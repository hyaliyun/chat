import{_ as c,o as s,c as n,a as t,m,t as d,C as h,M as g,U as b,f as l,F as x,p as y,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function R(i,e,u,_,r,a){return s(),n("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(d(u.poem.solution),1)])])])}const A=c(q,[["render",R],["__scopeId","data-v-2eaa2dbd"]]),S=JSON.parse(`[{"question":"def library_management(events): Determine the final status of each book in the library based on a series of check-in and check-out events. Args: events (List[str]): A list of strings representing the events in chronological order. Each event is either \\"CheckIn <book_id>\\" or \\"CheckOut <book_id>\\". Returns: List[Tuple[str, str]]: A list of tuples where each tuple contains a book ID and its final status, either \\"Available\\" or \\"Checked Out\\". The books should be sorted in lexicographical order by ID. >>> library_management([\\"CheckIn book1\\", \\"CheckOut book1\\", \\"CheckIn book2\\", \\"CheckOut book2\\", \\"CheckIn book3\\", \\"CheckOut book3\\"]) [('book1', 'Checked Out'), ('book2', 'Checked Out'), ('book3', 'Checked Out')] >>> library_management([\\"CheckIn bookA\\", \\"CheckOut bookA\\", \\"CheckIn bookB\\", \\"CheckIn bookC\\", \\"CheckOut bookB\\"]) [('bookA', 'Checked Out'), ('bookB', 'Checked Out'), ('bookC', 'Available')] >>> library_management([\\"CheckIn book1\\", \\"CheckIn book2\\", \\"CheckIn book1\\"]) [('book1', 'Available'), ('book2', 'Available')] >>> library_management([\\"CheckIn xyz\\", \\"CheckOut xyz\\", \\"CheckIn abc\\", \\"CheckOut abc\\", \\"CheckIn lmn\\"]) [('abc', 'Checked Out'), ('lmn', 'Available'), ('xyz', 'Checked Out')] >>> library_management([\\"CheckIn bookA\\", \\"CheckOut bookA\\", \\"CheckIn bookA\\"]) [('bookA', 'Available')]","solution":"def library_management(events): book_status = {} for event in events: action, book_id = event.split() if action == \\"CheckIn\\": book_status[book_id] = \\"Available\\" elif action == \\"CheckOut\\": book_status[book_id] = \\"Checked Out\\" sorted_books = sorted(book_status.items()) return sorted_books # Function to transform input and output def process_library_events(t, event_list): events = [input().strip() for _ in range(t)] final_status = library_management(events) for book_id, status in final_status: print(f\\"{book_id} {status}\\")"},{"question":"from typing import List, Dict def find_longest_activity(n: int, activity_log: List[str]) -> Dict[str, str]: Determines the most time-consuming activity for each day based on the input data. Parameters: n (int): The number of activities logged. activity_log (List[str]): List of strings representing activities along with corresponding time. Returns: Dict[str, str]: A dictionary where keys are the days and values are the most time-consuming activities. >>> find_longest_activity(5, [\\"2023-10-01 Reading - 02:30:00\\", \\"2023-10-01 Coding - 01:45:00\\", \\"2023-10-02 Meeting - 02:00:00\\", \\"2023-10-02 Emails - 01:15:00\\", \\"2023-10-01 Jogging - 00:45:00\\"]) {'2023-10-01': 'Reading', '2023-10-02': 'Meeting'} >>> find_longest_activity(3, [\\"2023-09-15 Exam - 03:00:00\\", \\"2023-09-15 Preparation - 03:00:00\\", \\"2023-09-16 Homework - 02:30:00\\"]) {'2023-09-15': 'Exam', '2023-09-16': 'Homework'}","solution":"from datetime import timedelta def find_longest_activity(n, activity_log): Determines the most time-consuming activity for each day based on the input data. Parameters: n (int): The number of activities logged. activity_log (List[str]): List of strings representing activities along with corresponding time. Returns: dict: A dictionary where keys are the days and values are the most time-consuming activities. activities = {} for entry in activity_log: day_activity, time = entry.rsplit(' - ', 1) day, activity = day_activity.split(' ', 1) hours, minutes, seconds = map(int, time.split(':')) duration = timedelta(hours=hours, minutes=minutes, seconds=seconds) if day not in activities or duration > activities[day][1]: activities[day] = (activity, duration) result = {day: activities[day][0] for day in sorted(activities)} return result"},{"question":"def rank_players(test_cases): Ranks the players based on their total scores in descending order. If two players have the same score, they are ranked alphabetically by their names. :param test_cases: List of test cases where each case is a list of tuples containing player's name and score. :return: List of lists where each list contains ranked player names for the corresponding test case. pass # Unit tests def test_rank_single_test_case(): test_cases = [ [(\\"Alice\\", 100), (\\"Bob\\", 200), (\\"Charlie\\", 150)] ] expected_output = [ [\\"Bob\\", \\"Charlie\\", \\"Alice\\"] ] assert rank_players(test_cases) == expected_output def test_rank_multiple_test_cases(): test_cases = [ [(\\"Alice\\", 100), (\\"Bob\\", 200), (\\"Charlie\\", 150)], [(\\"Dave\\", 300), (\\"Eve\\", 300), (\\"Frank\\", 100), (\\"Grace\\", 200)] ] expected_output = [ [\\"Bob\\", \\"Charlie\\", \\"Alice\\"], [\\"Dave\\", \\"Eve\\", \\"Grace\\", \\"Frank\\"] ] assert rank_players(test_cases) == expected_output def test_rank_same_score_alphabetical_order(): test_cases = [ [(\\"Alice\\", 100), (\\"Bob\\", 100), (\\"Charlie\\", 100)] ] expected_output = [ [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] ] assert rank_players(test_cases) == expected_output def test_rank_single_player(): test_cases = [ [(\\"Alice\\", 100)] ] expected_output = [ [\\"Alice\\"] ] assert rank_players(test_cases) == expected_output def test_rank_no_players(): test_cases = [ [] ] expected_output = [ [] ] assert rank_players(test_cases) == expected_output","solution":"def rank_players(test_cases): Ranks the players based on their total scores in descending order. If two players have the same score, they are ranked alphabetically by their names. :param test_cases: List of test cases where each case is a list of tuples containing player's name and score. :return: List of lists where each list contains ranked player names for the corresponding test case. result = [] for case in test_cases: players = [(name, score) for name, score in case] players.sort(key=lambda x: (-x[1], x[0])) # sort by score desc and name asc ranked_names = [name for name, score in players] result.append(ranked_names) return result"},{"question":"def max_money(coins: List[int]) -> int: Determine the maximum amount of money Alice can collect if both players play optimally. >>> max_money([1, 2, 9, 4]) 10 >>> max_money([4, 4, 4]) 8","solution":"def max_money(coins): n = len(coins) dp = [[0] * n for _ in range(n)] for length in range(1, n + 1): for i in range(n - length + 1): j = i + length - 1 if i == j: dp[i][j] = coins[i] else: pick_i = coins[i] + min(dp[i + 2][j] if i + 2 <= j else 0, dp[i + 1][j - 1] if i + 1 <= j - 1 else 0) pick_j = coins[j] + min(dp[i][j - 2] if i <= j - 2 else 0, dp[i + 1][j - 1] if i + 1 <= j - 1 else 0) dp[i][j] = max(pick_i, pick_j) return dp[0][n - 1] # Example usage: # coins = [1, 2, 9, 4] # print(max_money(coins)) # Output should be 10"},{"question":"def election_results(n, m, seat_weights, candidate_influences): Determines which candidates secure which seats based on their influences and seat weights. Parameters: n (int): Number of seats m (int): Number of candidates seat_weights (list of int): Weights of the seats candidate_influences (list of int): Influences of the candidates Returns: list: List of seat weights secured by each candidate in the order of their input influences, or \\"None\\" if they do not secure a seat. >>> election_results(3, 4, [30, 20, 10], [80, 50, 40, 10]) [30, 20, 10, 'None'] >>> election_results(4, 3, [30, 20, 10, 5], [80, 50, 40]) [30, 20, 10] >>> election_results(3, 3, [30, 20, 10], [80, 50, 40]) [30, 20, 10] >>> election_results(1, 1, [30], [80]) [30] >>> election_results(1, 3, [30], [80, 50, 40]) [30, 'None', 'None'] >>> election_results(3, 1, [30, 20, 10], [80]) [30] >>> election_results(0, 1, [], [80]) ['None']","solution":"def election_results(n, m, seat_weights, candidate_influences): Determines which candidates secure which seats based on their influences and seat weights. Parameters: n (int): Number of seats m (int): Number of candidates seat_weights (list of int): Weights of the seats candidate_influences (list of int): Influences of the candidates Returns: list: List of seat weights secured by each candidate in the order of their input influences, or \\"None\\" if they do not secure a seat. sorted_seats = sorted(seat_weights, reverse=True) sorted_candidates = sorted(candidate_influences, reverse=True) seat_mapping = {} for i, influence in enumerate(sorted_candidates): if i < len(sorted_seats): seat_mapping[influence] = sorted_seats[i] else: seat_mapping[influence] = \\"None\\" return [seat_mapping[influence] for influence in candidate_influences] # Example usage: # print(election_results(3, 4, [30, 20, 10], [80, 50, 40, 10]))"},{"question":"def is_balanced(s): Implement a function that takes a string consisting of open and closed brackets (i.e., '(', ')', '{', '}', '[' and ']') and returns true if the brackets are balanced and false otherwise. A string is considered balanced if all open brackets are closed in the correct order. >>> is_balanced(\\"()\\") True >>> is_balanced(\\"()[]{}\\") True >>> is_balanced(\\"{[()()]}\\") True >>> is_balanced(\\"(]\\") False >>> is_balanced(\\"([)]\\") False >>> is_balanced(\\"\\") True >>> is_balanced(\\"a(b)c[d]e{f}g\\") True >>> is_balanced(\\"a(b]c\\") False","solution":"def is_balanced(s): Returns True if the brackets in the string are balanced, False otherwise. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False else: continue return stack == []"},{"question":"def handle_queries(n, q, candies, queries): Handle multiple types of queries on candy distribution among students. Parameters: n (int): Number of students. q (int): Number of queries. candies (list of int): Initial number of candies each student has. queries (list of tuples): List of queries where each query can be of type 1, 2, or 3. - (1, i, j) -> student i gives one candy to student j. - (2, i) -> print the current number of candies that student i possesses. - (3, ) -> print the least number of candies and the most number of candies. Returns: list: The results of the queries of type 2 or 3. Example: >>> handle_queries(5, 7, [5, 3, 7, 8, 2], [(2, 1), (1, 3, 1), (2, 1), (3,), (1, 4, 2), (2, 4), (3,)]) [5, 6, (2, 8), 7, (2, 7)] >>> handle_queries(3, 5, [1, 3, 2], [(1, 2, 1), (3,), (1, 3, 1), (2, 1), (3,)]) [(2, 2), 2, (2, 2)]","solution":"def handle_queries(n, q, candies, queries): results = [] for query in queries: if query[0] == 1: i, j = query[1], query[2] if candies[i-1] > candies[j-1]: # Ensure i gives candy to j only if i has more candies candies[i-1] -= 1 candies[j-1] += 1 elif query[0] == 2: i = query[1] results.append(candies[i-1]) elif query[0] == 3: min_candies = min(candies) max_candies = max(candies) results.append((min_candies, max_candies)) return results"},{"question":"def count_substrings_with_k_distinct_chars(s: str, k: int) -> int: Returns the number of substrings containing at least k distinct characters. >>> count_substrings_with_k_distinct_chars(\\"abcabc\\", 3) -> 10 >>> count_substrings_with_k_distinct_chars(\\"zzzz\\", 2) -> 0","solution":"def count_substrings_with_k_distinct_chars(s, k): Returns the number of substrings containing at least k distinct characters. if k > len(s): return 0 count = 0 for i in range(len(s)): distinct_chars = set() for j in range(i, len(s)): distinct_chars.add(s[j]) if len(distinct_chars) >= k: count += (len(s) - j) break return count"},{"question":"def hasSubsetSum(arr, N, target): Determines if there exists a subset of arr with a sum equal to the target. Parameters: arr (list): List of integers. N (int): Size of the array. target (int): Target sum. Returns: str: \\"YES\\" if there is a subset with sum equal to target, otherwise \\"NO\\". >>> hasSubsetSum([1, 2, 3, 4, 5], 5, 9) \\"YES\\" >>> hasSubsetSum([1, 2, 5], 3, 4) \\"NO\\" >>> hasSubsetSum([1, 2, 3], 3, 6) \\"YES\\" >>> hasSubsetSum([3, 34, 4, 12, 5, 2], 6, 9) \\"YES\\" >>> hasSubsetSum([3, 34, 4, 12, 5, 2], 6, 30) \\"NO\\" >>> hasSubsetSum([1, 2, 5, 6], 4, 11) \\"YES\\" >>> hasSubsetSum([1, 1, 1, 1, 1], 5, 3) \\"YES\\" >>> hasSubsetSum([2], 1, 1) \\"NO\\" >>> hasSubsetSum([2], 1, 2) \\"YES\\" >>> hasSubsetSum([2, 4, 6, 8], 4, 10) \\"YES\\"","solution":"def hasSubsetSum(arr, N, target): Determines if there exists a subset of arr with a sum equal to the target. Parameters: arr (list): List of integers. N (int): Size of the array. target (int): Target sum. Returns: str: \\"YES\\" if there is a subset with sum equal to target, otherwise \\"NO\\". # Create a DP table to store the solution to subproblems dp = [False] * (target + 1) dp[0] = True # A sum of 0 can always be formed with an empty subset # Iterate over each element in the array for num in arr: # Update the DP table in reverse order to prevent using the same element multiple times for t in range(target, num - 1, -1): if dp[t - num]: dp[t] = True return \\"YES\\" if dp[target] else \\"NO\\""},{"question":"import bisect from typing import List class Bookshelf: def __init__(self): self.books = [] def add_book(self, identifier: int) -> None: Add a book with a given identifier to the shelf. pass def remove_book(self, identifier: int) -> None: Remove a book with a given identifier from the shelf. pass def find_kth_book(self, k: int) -> int: Find the identifier of the k-th smallest book on the shelf. pass def process_requests(requests: List[str]) -> List[int]: Process the list of requests and return the results of any \\"3 K\\" requests. Args: requests (List[str]): List of requests. Returns: List[int]: Results of any \\"3 K\\" requests. >>> process_requests([\\"1 5\\", \\"1 2\\", \\"1 9\\", \\"3 2\\"]) [5] >>> process_requests([\\"1 5\\", \\"1 2\\", \\"1 9\\", \\"3 2\\", \\"2 5\\", \\"3 2\\", \\"3 3\\"]) [5, 9, -1] pass","solution":"import bisect class Bookshelf: def __init__(self): self.books = [] def add_book(self, identifier): bisect.insort(self.books, identifier) def remove_book(self, identifier): index = bisect.bisect_left(self.books, identifier) if index < len(self.books) and self.books[index] == identifier: self.books.pop(index) def find_kth_book(self, k): if 0 < k <= len(self.books): return self.books[k - 1] return -1 def process_requests(requests): bookshelf = Bookshelf() results = [] for request in requests: parts = request.split() if parts[0] == '1': bookshelf.add_book(int(parts[1])) elif parts[0] == '2': bookshelf.remove_book(int(parts[1])) elif parts[0] == '3': results.append(bookshelf.find_kth_book(int(parts[1]))) return results"},{"question":"def count_even_sum_pairs(t: int, queries: List[Tuple[int, List[int]]]) -> List[int]: Count the number of distinct pairs (i, j) such that i < j and a_i + a_j is even. Args: t : int : number of queries queries : List[Tuple[int, List[int]]] : list of tuples, where each tuple contains an integer n (number of elements in the array) and a list of n integers a_1, a_2, ..., a_n (the elements of the array) Returns: List[int] : list of integers representing the number of valid pairs for each query >>> count_even_sum_pairs(2, [(4, [1, 2, 3, 4]), (6, [2, 4, 6, 8, 10, 12])]) [2, 15] >>> count_even_sum_pairs(1, [(5, [2, 4, 6, 8, 10])]) [10]","solution":"def count_even_sum_pairs(t, queries): results = [] for i in range(t): n, array = queries[i] count_even = 0 count_odd = 0 for number in array: if number % 2 == 0: count_even += 1 else: count_odd += 1 # The number of valid pairs that sum to even results.append((count_even * (count_even - 1) // 2) + (count_odd * (count_odd - 1) // 2)) return results"},{"question":"def xor_binary_strings(b1, b2): Returns the result of XOR operation between two binary strings of equal length. pass def determine_key(num_test_cases, test_cases): Determine the encryption key for given messages and ciphertexts if possible. :param num_test_cases: int :param test_cases: list of tuples, each containing (N, message, ciphertext) :return: list of results where each result is either the key or \\"Cannot be determined\\" pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 original_message = data[index] index += 1 ciphertext = data[index] index += 1 test_cases.append((N, original_message, ciphertext)) results = determine_key(T, test_cases) for result in results: print(result)","solution":"def xor_binary_strings(b1, b2): Returns the result of XOR operation between two binary strings of equal length. return ''.join('1' if bit1 != bit2 else '0' for bit1, bit2 in zip(b1, b2)) def determine_key(num_test_cases, test_cases): Determine the encryption key for given messages and ciphertexts if possible. :param num_test_cases: int :param test_cases: list of tuples, each containing (N, message, ciphertext) :return: list of results where each result is either the key or \\"Cannot be determined\\" results = [] for N, message, ciphertext in test_cases: key = xor_binary_strings(message, ciphertext) results.append(key) return results"},{"question":"def park_cars(n: int, m: int) -> List[int]: Function to distribute n cars across m columns such that the difference between the number of cars in any two columns is minimized. Parameters: n (int): Number of cars m (int): Number of columns Returns: List[int]: A list where the i-th element represents the number of cars parked in the i-th column. >>> park_cars(7, 3) [3, 2, 2] >>> park_cars(10, 4) [3, 3, 2, 2] >>> park_cars(1, 1) [1] >>> park_cars(2, 2) [1, 1] >>> park_cars(5, 2) [3, 2] >>> park_cars(100000, 1000) [100, 100, 100, ..., 100] # 1000 times >>> park_cars(4, 4) [1, 1, 1, 1] >>> park_cars(3, 5) [1, 1, 1, 0, 0]","solution":"def park_cars(n, m): Function to distribute n cars across m columns such that the difference between the number of cars in any two columns is minimized. Parameters: n (int): Number of cars m (int): Number of columns Returns: List[int]: A list where the i-th element represents the number of cars parked in the i-th column. # Base number of cars per column base = n // m # Number of columns that will get an extra car extra_cars = n % m result = [base] * m for i in range(extra_cars): result[i] += 1 return result"},{"question":"def count_ways(n: int, m: int, grid: List[List[str]]) -> int: Determine the number of possible ways the knight can safely travel from the top-left corner (1, 1) to the bottom-right corner (n, m) without stepping on a dangerous cell, modulo 998244353. >>> count_ways(3, 3, [['.', '.', '.'], ['.', '*', '.'], ['.', '.', '.']]) 2 >>> count_ways(4, 4, [['.', '.', '.', '.'], ['.', '*', '.', '.'], ['.', '.', '*', '.'], ['.', '.', '.', '.']]) 4 >>> count_ways(1, 1, [['.']]) 1 >>> count_ways(3, 3, [['*', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) 0 >>> count_ways(3, 3, [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '*']]) 0 >>> count_ways(4, 4, [['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.']]) 20 >>> count_ways(3, 3, [['.', '*', '.'], ['*', '*', '*'], ['.', '*', '.']]) 0","solution":"def count_ways(n, m, grid): MOD = 998244353 if grid[0][0] == '*' or grid[n-1][m-1] == '*': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '*': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[n-1][m-1]"},{"question":"def is_palindrome_number(number: int) -> str: Returns \\"YES\\" if the given number is a palindrome, otherwise \\"NO\\". >>> is_palindrome_number(121) \\"YES\\" >>> is_palindrome_number(-121) \\"NO\\" >>> is_palindrome_number(10) \\"NO\\" >>> is_palindrome_number(-101) \\"NO\\" >>> is_palindrome_number(0) \\"YES\\" def check_palindromes(T: int, numbers: List[int]) -> List[str]: Takes the number of test cases T and a list of numbers, and returns a list of \\"YES\\" or \\"NO\\" for each number indicating if it is a palindrome. >>> check_palindromes(4, [121, -121, 10, -101]) [\\"YES\\", \\"NO\\", \\"NO\\", \\"NO\\"] >>> check_palindromes(3, [0, 22, 1234321]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> check_palindromes(2, [-11, 123]) [\\"NO\\", \\"NO\\"] >>> check_palindromes(5, [111, 333, -202, 404, 999]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"]","solution":"def is_palindrome_number(number): Returns \\"YES\\" if the given number is a palindrome, otherwise \\"NO\\". str_num = str(number) if str_num == str_num[::-1]: return \\"YES\\" else: return \\"NO\\" def check_palindromes(T, numbers): Takes the number of test cases T and a list of numbers, and returns a list of \\"YES\\" or \\"NO\\" for each number indicating if it is a palindrome. results = [] for num in numbers: results.append(is_palindrome_number(num)) return results"},{"question":"def min_cost_path(grid): Aila is developing a pathfinding algorithm for a grid-based game. The grid is represented as a two-dimensional array where each cell contains an integer representing the cost of entering that cell. Aila's algorithm must find the minimum cost to navigate from the top-left corner of the grid (0, 0) to the bottom-right corner (N-1, M-1), only moving right or down one cell at a time. >>> min_cost_path([ >>> [1, 3, 5, 8], >>> [4, 2, 1, 7], >>> [4, 3, 2, 3] >>> ]) == 12 >>> min_cost_path([[5]]) == 5 >>> min_cost_path([[1, 2, 3, 4]]) == 10 >>> min_cost_path([[1], [2], [3], [4]]) == 10 >>> N, M = 500, 500 >>> grid = [[1 for _ in range(M)] for _ in range(N)] >>> min_cost_path(grid) == (N + M - 1) >>> min_cost_path([ >>> [1, 3, 1, 1], >>> [4, 1, 1, 1], >>> [1, 5, 1, 1] >>> ]) == 8","solution":"def min_cost_path(grid): N = len(grid) M = len(grid[0]) # Create a 2D DP array to store the minimum cost path sum dp = [[0] * M for _ in range(N)] # Initialize the DP array dp[0][0] = grid[0][0] # Fill the first row for j in range(1, M): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, N): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the DP array for i in range(1, N): for j in range(1, M): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The minimum cost to reach the bottom-right corner return dp[N - 1][M - 1]"},{"question":"def build_suffix_array(s: str) -> List[int]: Constructs the suffix array for the given string s. :param s: A string containing only lowercase English letters (1 ≤ len(s) ≤ 100,000) :returns: A list of integers representing the suffix array of the string >>> build_suffix_array(\\"banana\\") [5, 3, 1, 0, 4, 2] >>> build_suffix_array(\\"a\\") [0] >>> build_suffix_array(\\"abc\\") [0, 1, 2] >>> build_suffix_array(\\"aaaa\\") [3, 2, 1, 0] >>> build_suffix_array(\\"abracadabra\\") [10, 7, 0, 3, 5, 8, 1, 4, 6, 9, 2]","solution":"def build_suffix_array(s): Constructs the suffix array for the given string s. :param s: A string containing only lowercase English letters (1 ≤ len(s) ≤ 100,000) :returns: A list of integers representing the suffix array of the string # Naive approach using sorted with key set as suffix string suffixes = [(s[i:], i) for i in range(len(s))] suffixes.sort() suffix_array = [suffix[1] for suffix in suffixes] return suffix_array # Example usage: # print(build_suffix_array(\\"banana\\")) # Output: [5, 3, 1, 0, 4, 2]"},{"question":"def count_paths(n, m, grid): Determine the number of distinct paths from the top-left corner of the grid to the bottom-right corner of the grid. n: int - the number of rows in the grid m: int - the number of columns in the grid grid: List[List[str]] - the grid configuration Returns: int - the number of unique paths from the start to the destination >>> count_paths(3, 3, [ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.'] ... ]) 2 >>> count_paths(2, 2, [ ... ['.', '#'], ... ['.', '.'] ... ]) 1 >>> count_paths(2, 2, [ ... ['#', '.'], ... ['.', '.'] ... ]) 0","solution":"def count_paths(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] # Example usage; this function would typically be called with proper inputs: # n, m = 3, 3 # grid = [ # ['.', '.', '.'], # ['.', '#', '.'], # ['.', '.', '.'] # ] # print(count_paths(n, m, grid)) # Output: 2"},{"question":"def max_distinct_substrings(S: str, queries: List[int]) -> List[int]: Returns a list of maximum possible number of distinct substrings of length X present in the string S for each query. Args: S: str: the input string queries: List[int]: list of lengths for which to determine the number of distinct substrings Returns: List[int]: list of max distinct substrings for each query length >>> max_distinct_substrings('abacaba', [3, 2, 4]) [4, 4, 4] >>> max_distinct_substrings('abcde', [1, 3]) [5, 3] def process_test_cases(test_cases: List[Tuple[int, int, str, List[int]]]) -> List[List[int]]: Processes each test case and returns the maximum number of distinct substrings for each query length per test case. Args: test_cases: List[Tuple[int, int, str, List[int]]]: list of test cases where each test case is a tuple containing the length of the string N, the number of queries Q, the string S, and the list of query lengths Returns: List[List[int]]: list of results for each test case >>> process_test_cases([(7, 3, 'abacaba', [3, 2, 4]), (5, 2, 'abcde', [1, 3])]) [[4, 4, 4], [5, 3]]","solution":"def max_distinct_substrings(S, queries): Returns a list of maximum possible number of distinct substrings of length X present in the string S for each query. Args: S : str : the input string queries : list of int : list of lengths for which to determine the number of distinct substrings Returns: list of int : list of max distinct substrings for each query length results = [] for X in queries: if X > len(S): results.append(0) else: substrings = set() for i in range(len(S) - X + 1): substrings.add(S[i:i+X]) results.append(len(substrings)) return results def process_test_cases(test_cases): results = [] for N, Q, S, queries in test_cases: result = max_distinct_substrings(S, queries) results.append(result) return results"},{"question":"def count_valid_subarrays(N: int, M: int, X: int, A: List[int]) -> int: Returns the number of contiguous subarrays of length M such that the sum of the maximum and minimum elements of the subarray is greater than X. Examples: >>> count_valid_subarrays(5, 3, 10, [1, 3, 8, 6, 4]) 2 >>> count_valid_subarrays(4, 2, 7, [9, 7, 3, 8]) 3 pass def solve(T: int, test_cases: List[Tuple[int, int, int, List[int]]]) -> List[int]: Processes multiple test cases and returns a list of results for each test case. Examples: >>> solve(2, [(5, 3, 10, [1, 3, 8, 6, 4]), (4, 2, 7, [9, 7, 3, 8])]) [2, 3] pass","solution":"def count_valid_subarrays(N, M, X, A): Returns the number of contiguous subarrays of length M such that the sum of the maximum and minimum elements of the subarray is greater than X. count = 0 for i in range(N - M + 1): subarray = A[i:i + M] max_element = max(subarray) min_element = min(subarray) if max_element + min_element > X: count += 1 return count def solve(T, test_cases): results = [] for case in test_cases: N, M, X, A = case results.append(count_valid_subarrays(N, M, X, A)) return results"},{"question":"def count_workflows(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the number of distinct workflows that can be created where there are no obstacles between any two employees in the same workflow. Args: t (int): number of test cases test_cases (List[Tuple[Tuple[int, int], List[int]]]): list of test cases where each test case contains a tuple with number of employees and teams, and a list of team IDs for employees Returns: List[int]: number of distinct workflows for each test case >>> count_workflows(3, [((4, 3), [1, 1, 2, 2]), ((5, 2), [1, 1, 1, 1, 1]), ((6, 3), [1, 2, 2, 3, 3, 3])]) [2, 1, 3] >>> count_workflows(1, [((4, 4), [1, 2, 3, 4])]) [4] >>> count_workflows(1, [((5, 1), [1, 1, 1, 1, 1])]) [1] >>> count_workflows(2, [((5, 3), [2, 3, 2, 1, 3]), ((6, 4), [1, 2, 3, 4, 4, 1])]) [3, 4]","solution":"def count_workflows(t, test_cases): results = [] for case in test_cases: n, k = case[0] team_ids = case[1] # Use set to identify unique teams in the employees list unique_teams = set(team_ids) # The number of unique teams is the number of distinct workflows results.append(len(unique_teams)) return results"},{"question":"def generate_dominoes(n: int) -> List[List[int]]: Generates all unique domino arrangements where each half of the domino contains a number from 1 to n. The order of numbers on the domino does not matter. Args: n (int): The largest number that can appear on either half of a domino. Returns: List[List[int]]: A list of unique domino arrangements. Example: >>> generate_dominoes(3) [[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 3]]","solution":"def generate_dominoes(n): Returns a list of unique domino pairs for a given n. Each pair is represented as a list [a, b] where 1 ≤ a ≤ b ≤ n. dominoes = [] for i in range(1, n + 1): for j in range(i, n + 1): dominoes.append([i, j]) return dominoes"},{"question":"def count_unique_names(names: List[str]) -> Tuple[int, int]: Given a list of people's names, return the number of unique first names and the number of unique last names. Args: names (list of str): List of people's names. Returns: tuple: (number of unique first names, number of unique last names) >>> count_unique_names([\\"John Doe\\", \\"Jane Doe\\", \\"Emily Smith\\", \\"Jane Smith\\", \\"John Smith\\"]) (3, 2) >>> count_unique_names([\\"John Doe\\", \\"Jane Smith\\", \\"Emily Brown\\"]) (3, 3) >>> count_unique_names([\\"John Doe\\"]) (1, 1) >>> count_unique_names([]) (0, 0)","solution":"def count_unique_names(names): Given a list of people's names, return the number of unique first names and the number of unique last names. Args: names (list of str): List of people's names. Returns: tuple: (number of unique first names, number of unique last names) first_names = set() last_names = set() for name in names: first, last = name.split() first_names.add(first) last_names.add(last) return len(first_names), len(last_names)"},{"question":"def makeEqual(arr: List[int]) -> int: Returns the minimum number of operations required to make all elements in the list equal. >>> makeEqual([1, 2, 3]) 1 >>> makeEqual([4, 4, 4]) 0","solution":"def makeEqual(arr): Returns the minimum number of operations required to make all elements in 'arr' equal. # Find the maximum and minimum values in the array max_val = max(arr) min_val = min(arr) # The number of operations to make all elements equal will be the difference between max and min divided by 2 return (max_val - min_val) // 2"},{"question":"def find_two_sum(nums: List[int], target: int) -> str: Determines if there are two distinct elements in the list \`nums\` that add up to \`target\`. >>> find_two_sum([2, 7, 11, 15, -5], 10) \\"YES\\" >>> find_two_sum([1, 2, 3, 4], 8) \\"NO\\"","solution":"def find_two_sum(nums, target): Determines if there are two distinct elements in the list \`nums\` that add up to \`target\`. Returns \\"YES\\" if such elements exist, otherwise \\"NO\\". seen = set() for num in nums: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def has_pair_with_sum(arr, target): Determine whether there is a pair of elements in the array whose sum equals the target value. >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) == \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) == \\"NO\\"","solution":"def has_pair_with_sum(arr, target): Determine whether there is a pair of elements in the array whose sum equals the target value. seen = set() for num in arr: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def collatz_sequence(n): Generates the Collatz sequence starting from n and continuing until reaching 1. Parameters: n (int): The starting positive integer (1 ≤ n ≤ 1000). Returns: str: A string of the Collatz sequence numbers separated by commas. >>> collatz_sequence(6) '6,3,10,5,16,8,4,2,1' >>> collatz_sequence(11) '11,34,17,52,26,13,40,20,10,5,16,8,4,2,1'","solution":"def collatz_sequence(n): Generates the Collatz sequence starting from n and continuing until reaching 1. Parameters: n (int): The starting positive integer (1 ≤ n ≤ 1000). Returns: str: A string of the Collatz sequence numbers separated by commas. sequence = [] while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 sequence.append(1) # append the last number 1 return ','.join(map(str, sequence))"},{"question":"def is_prime(num): Helper function to check if a number is prime. pass def prime_factors(n): Returns a list of prime factors of n. pass def process_datasets(datasets): Processes multiple datasets to output prime factors. pass if __name__ == \\"__main__\\": Create a program that outputs all prime factors of a number n. The prime factor conditions are as follows. However, 2 ≤ n ≤ 100,000. If the number is prime, output \\"Prime\\". * A prime factor is a factor that is a prime number. * The factors should be printed in ascending order. Input Given multiple datasets. The format of each dataset is as follows: n Input ends when n is 0. The number of datasets does not exceed 100. Output Print the prime factors or \\"Prime\\" for each dataset. Insert one blank line between the datasets. datasets = [28, 17, 100, 0] results = process_datasets(datasets) for res in results: if isinstance(res, list): for factor in res: print(factor) else: print(res) print() # This prints the blank line between datasets","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def prime_factors(n): Returns a list of prime factors of n. factors = [] if is_prime(n): return \\"Prime\\" while n % 2 == 0: factors.append(2) n = n // 2 for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.append(i) n = n // i if n > 2: factors.append(n) return factors def process_datasets(datasets): Processes multiple datasets to output prime factors. results = [] for n in datasets: if n == 0: break result = prime_factors(n) results.append(result) return results if __name__ == \\"__main__\\": datasets = [28, 17, 100, 0] results = process_datasets(datasets) for res in results: if isinstance(res, list): for factor in res: print(factor) else: print(res) print() # This prints the blank line between datasets"},{"question":"def longest_repeating_subsequence(s: str) -> int: Returns the length of the longest repeating subsequence in the given string such that the two subsequences do not have any common characters at the same position in the original string. >>> longest_repeating_subsequence(\\"aab\\") 1 >>> longest_repeating_subsequence(\\"aabb\\") 2 >>> longest_repeating_subsequence(\\"aabebcdd\\") 3 >>> longest_repeating_subsequence(\\"axxxy\\") 2 pass","solution":"def longest_repeating_subsequence(s): Returns the length of the longest repeating subsequence in the string s. n = len(s) dp = [[0] * (n + 1) for _ in range(n + 1)] # Build the dp array for i in range(1, n + 1): for j in range(1, n + 1): if s[i - 1] == s[j - 1] and i != j: dp[i][j] = 1 + dp[i - 1][j - 1] else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][n]"},{"question":"import math def min_days_to_deliver(n: int) -> int: Returns the minimum number of days required to deliver all n letters in the worst-case scenario. >>> min_days_to_deliver(1) 1 >>> min_days_to_deliver(3) 6 >>> min_days_to_deliver(4) 24","solution":"import math def min_days_to_deliver(n): Returns the minimum number of days required to deliver all n letters in the worst-case scenario. return math.factorial(n)"},{"question":"def treeHeight(N: int) -> int: Returns the height of the tree after N years. >>> treeHeight(0) == 1 >>> treeHeight(1) == 2 >>> treeHeight(3) == 7 >>> treeHeight(5) == 32 >>> treeHeight(50) == 1 + sum(2**i for i in range(50))","solution":"def treeHeight(N): Returns the height of the tree after N years. height = 1 for year in range(1, N + 1): height += 2 ** (year - 1) return height"},{"question":"from typing import List, Tuple def longest_palindrome_length(s: str, queries: List[Tuple[int, int]]) -> List[int]: For each query, returns the length of the longest palindrome that can be formed from the substring s[L..R]. :param s: String S of length N :param queries: List of tuples, where each tuple contains two integers L and R :return: List of integers representing the length of the longest palindrome for each query Example: >>> longest_palindrome_length(\\"abacaba\\", [(0, 6), (1, 5), (2, 4)]) [7, 3, 3] >>> longest_palindrome_length(\\"a\\", [(0, 0)]) [1] >>> longest_palindrome_length(\\"abc\\", [(0, 2)]) [1] >>> longest_palindrome_length(\\"aaaaaa\\", [(0, 5), (0, 2)]) [6, 3] >>> longest_palindrome_length(\\"abcdcdcba\\", [(0, 8), (1, 7)]) [9, 7]","solution":"from collections import Counter def longest_palindrome_length(s, queries): For each query, returns the length of the longest palindrome that can be formed from the substring s[L..R]. :param s: String S of length N :param queries: List of tuples, where each tuple contains two integers L and R :return: List of integers representing the length of the longest palindrome for each query results = [] for L, R in queries: substring = s[L:R+1] count = Counter(substring) length = 0 odd_count_found = False for freq in count.values(): length += (freq // 2) * 2 if freq % 2 == 1: odd_count_found = True # If there's any character with odd frequency, # we can use one of them in the middle of the palindrome. if odd_count_found: length += 1 results.append(length) return results"},{"question":"from typing import List def merge_cat_ids(N: int, M: int, existing_ids: List[int], new_ids: List[int]) -> List[int]: Merges two sorted arrays of cat IDs into one sorted array. pass # Test cases def test_merge_normal_case(): assert merge_cat_ids(5, 3, [1, 3, 5, 7, 9], [2, 4, 6]) == [1, 2, 3, 4, 5, 6, 7, 9] def test_merge_overlap_case(): assert merge_cat_ids(4, 4, [1, 2, 5, 7], [3, 4, 8, 10]) == [1, 2, 3, 4, 5, 7, 8, 10] def test_merge_empty_existhing_array(): assert merge_cat_ids(0, 3, [], [2, 4, 6]) == [2, 4, 6] def test_merge_empty_new_array(): assert merge_cat_ids(3, 0, [2, 4, 6], []) == [2, 4, 6] def test_merge_all_identical_elements(): assert merge_cat_ids(3, 3, [1, 1, 1], [1, 1, 1]) == [1, 1, 1, 1, 1, 1] def test_merge_mixed_numbers(): assert merge_cat_ids(4, 4, [1, 3, 3, 4], [2, 3, 5, 6]) == [1, 2, 3, 3, 3, 4, 5, 6] def test_merge_large_numbers(): assert merge_cat_ids(4, 4, [1000, 2000, 3000, 4000], [1500, 2500, 3500, 4500]) == [1000, 1500, 2000, 2500, 3000, 3500, 4000, 4500]","solution":"from typing import List def merge_cat_ids(N: int, M: int, existing_ids: List[int], new_ids: List[int]) -> List[int]: Merges two sorted arrays of cat IDs into one sorted array. i, j = 0, 0 merged_ids = [] # Merge both arrays until one is exhausted while i < N and j < M: if existing_ids[i] <= new_ids[j]: merged_ids.append(existing_ids[i]) i += 1 else: merged_ids.append(new_ids[j]) j += 1 # Append rest of the elements of the non-exhausted array while i < N: merged_ids.append(existing_ids[i]) i += 1 while j < M: merged_ids.append(new_ids[j]) j += 1 return merged_ids"},{"question":"def generate_leaderboard(num_participants: int, participants_scores: List[Tuple[str, int]]) -> List[str]: Generates the leaderboard based on the given list of participants and their scores. Participants are sorted in descending order of their scores. If two participants have the same score, they are sorted alphabetically by their names. :param num_participants: Number of participants :param participants_scores: List of tuples containing participant names and their respective scores :return: List of participants' names sorted as per the rules >>> input_data = \\"5nAlice 300nBob 200nCharlie 300nDavid 150nEve 200\\" >>> print(main(input_data)) ['Alice', 'Charlie', 'Bob', 'Eve', 'David'] >>> input_data = \\"4nAlice 300nBob 300nCharlie 200nDavid 200\\" >>> print(main(input_data)) ['Alice', 'Bob', 'Charlie', 'David'] >>> input_data = \\"4nAlice 300nBob -200nCharlie 300nDavid -150\\" >>> print(main(input_data)) ['Alice', 'Charlie', 'David', 'Bob'] >>> input_data = \\"1nAlice 300\\" >>> print(main(input_data)) ['Alice'] >>> input_data = \\"4nAlice 100nBob 100nCharlie 100nDavid 100\\" >>> print(main(input_data)) ['Alice', 'Bob', 'Charlie', 'David'] def main(input_data: str) -> List[str]: Helper function to process input data and return the leaderboard. :param input_data: A string representing the input data :return: List of participants' names sorted as per the rules","solution":"def generate_leaderboard(num_participants, participants_scores): # Sorting the participants first by score descending then by name ascending participants_scores.sort(key=lambda x: (-x[1], x[0])) # Extracting the sorted names sorted_names = [name for name, score in participants_scores] return sorted_names def main(input_data): lines = input_data.split(\\"n\\") T = int(lines[0]) participants_scores = [] for i in range(1, T + 1): name, score = lines[i].split() participants_scores.append((name, int(score))) leaderboard = generate_leaderboard(T, participants_scores) return leaderboard"},{"question":"def min_operations_to_make_string_same(S): Returns the minimum number of operations required to make all characters in the string S the same. In one operation, you can choose any character and change it to the other character ('a' to 'b' or 'b' to 'a'). :param S: Input string consisting of characters 'a' and 'b' only :return: Minimum number of operations required >>> min_operations_to_make_string_same(\\"abb\\") 1 >>> min_operations_to_make_string_same(\\"aaaa\\") 0 >>> min_operations_to_make_string_same(\\"baaba\\") 2 pass def process_test_cases(T, test_cases): Processes multiple test cases to determine the minimum number of operations required for each string. :param T: Number of test cases :param test_cases: List of input strings :return: List of results for each test case >>> process_test_cases(3, [\\"abb\\", \\"aaaa\\", \\"baaba\\"]) [1, 0, 2] >>> process_test_cases(1, [\\"a\\" * 10**6]) [0] >>> process_test_cases(1, [\\"b\\" * 10**6]) [0] >>> process_test_cases(1, [\\"ab\\" * 5 * 10**5]) [500000] pass","solution":"def min_operations_to_make_string_same(S): Returns the minimum number of operations required to make all characters in the string S the same. In one operation, you can choose any character and change it to the other character ('a' to 'b' or 'b' to 'a'). :param S: Input string consisting of characters 'a' and 'b' only :return: Minimum number of operations required count_a = S.count('a') count_b = len(S) - count_a return min(count_a, count_b) def process_test_cases(T, test_cases): Processes multiple test cases to determine the minimum number of operations required for each string. :param T: Number of test cases :param test_cases: List of input strings :return: List of results for each test case results = [] for S in test_cases: results.append(min_operations_to_make_string_same(S)) return results"},{"question":"def remove_consecutive_duplicates(s: str) -> str: Removes consecutive duplicate characters from the input string. Args: s (str): The input string containing potential consecutive duplicates. Returns: str: The string after removing consecutive duplicate characters. >>> remove_consecutive_duplicates(\\"aabbcc\\") 'abc' >>> remove_consecutive_duplicates(\\"aaabbbcccaaa\\") 'abca' >>> remove_consecutive_duplicates(\\"thequickbrownfox\\") 'thequickbrownfox' >>> remove_consecutive_duplicates(\\"a\\") 'a' >>> remove_consecutive_duplicates(\\"abcdefg\\") 'abcdefg' >>> remove_consecutive_duplicates(\\"aaaa\\") 'a'","solution":"def remove_consecutive_duplicates(s): Removes consecutive duplicate characters from the input string. Args: s (str): The input string containing potential consecutive duplicates. Returns: str: The string after removing consecutive duplicate characters. if not s: return s output = [s[0]] for char in s[1:]: if char != output[-1]: output.append(char) return ''.join(output)"},{"question":"def sequence_length(N): Given a starting number N, generates the sequence based on the described rules, and returns the length of the sequence. >>> sequence_length(6) 9 >>> sequence_length(1) 1 >>> sequence_length(16) 5 pass def generate_sequences(T, test_cases): Processes multiple test cases and returns the lengths of the sequences for each test case. >>> generate_sequences(3, [6, 1, 16]) [9, 1, 5] >>> generate_sequences(2, [10, 12]) [7, 10] pass # Unit Tests def test_sequence_length(): assert sequence_length(6) == 9 assert sequence_length(1) == 1 assert sequence_length(16) == 5 assert sequence_length(19) == 21 assert sequence_length(27) == 112 def test_generate_sequences(): assert generate_sequences(3, [6, 1, 16]) == [9, 1, 5] assert generate_sequences(2, [10, 12]) == [7, 10] assert generate_sequences(1, [15]) == [18] assert generate_sequences(3, [4, 5, 2]) == [3, 6, 2]","solution":"def sequence_length(N): Given a starting number N, generates the sequence based on the described rules, and returns the length of the sequence. length = 1 while N != 1: if N % 2 == 0: N //= 2 else: N = 3 * N + 1 length += 1 return length def generate_sequences(T, test_cases): Processes multiple test cases and returns the lengths of the sequences for each test case. results = [] for N in test_cases: results.append(sequence_length(N)) return results"},{"question":"from typing import List def find_missing_number(n: int, arr: List[int]) -> int: You are given an array of integers representing the integers from 1 to n in an arbitrary order. However, one number is missing from the array. Write a program that efficiently finds and returns the missing number. Parameters: n (int): The total number of elements that should be in the array including the missing one. arr (List[int]): The list of integers with one missing number. Returns: int: The missing number. Examples: >>> find_missing_number(5, [2, 3, 1, 5]) 4 >>> find_missing_number(5, [2, 3, 1, 4]) 5 >>> find_missing_number(5, [2, 3, 5, 4]) 1 # Unit tests def test_missing_number_with_middle_value(): n = 5 arr = [2, 3, 1, 5] assert find_missing_number(n, arr) == 4 def test_missing_number_with_last_value(): n = 5 arr = [2, 3, 1, 4] assert find_missing_number(n, arr) == 5 def test_missing_number_with_first_value(): n = 5 arr = [2, 3, 5, 4] assert find_missing_number(n, arr) == 1 def test_missing_number_with_large_array(): n = 10000 arr = list(range(1, 10001)) arr.remove(1234) assert find_missing_number(n, arr) == 1234 def test_missing_number_smallest_case(): n = 1 arr = [] assert find_missing_number(n, arr) == 1","solution":"def find_missing_number(n, arr): Finds and returns the missing number in the array. total_sum = n * (n + 1) / 2 array_sum = sum(arr) return int(total_sum - array_sum)"},{"question":"def game_winner(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines the winner of the game for each test case provided. Each test case consists of an integer N (the size of the array) followed by an array of N integers. Bob starts the game, and the players take turns removing an element or increasing/decreasing any element by 1. The player who cannot make a move loses. Returns a list of strings, where each string is either \\"Alice\\" or \\"Bob\\", indicating the winner of each test case. Examples: >>> game_winner(3, [(5, [1, 2, 3, 4, 5]), (3, [2, 2, 2]), (4, [1, 1, 1, 1])]) [\\"Alice\\", \\"Alice\\", \\"Bob\\"] >>> game_winner(1, [(1, [1])]) [\\"Alice\\"] >>> game_winner(1, [(4, [1, 2, 3, 4])]) [\\"Bob\\"]","solution":"def game_winner(T, test_cases): Determines the game winner for each test case based on array manipulation rules. winners = [] for N, array in test_cases: if N % 2 == 1: # Odd number of elements in the array winners.append(\\"Alice\\") else: # Even number of elements in the array winners.append(\\"Bob\\") return winners"},{"question":"def most_frequent_char(s: str) -> str: Finds the most frequent character in the string. In case of a tie, returns the character that appears first in the string. If the string is empty, returns an empty string. >>> most_frequent_char(\\"abracadabra\\") \\"a\\" >>> most_frequent_char(\\"zzzzzz\\") \\"z\\" >>> most_frequent_char(\\"aabbcc\\") \\"a\\" >>> most_frequent_char(\\"\\") \\"\\" >>> most_frequent_char(\\"x\\") \\"x\\" >>> most_frequent_char(\\"abbcccddddeeeee\\") \\"e\\" >>> most_frequent_char(\\"abcbcdc\\") \\"c\\"","solution":"def most_frequent_char(s: str) -> str: Finds the most frequent character in the string. In case of a tie, returns the character that appears first in the string. If the string is empty, returns an empty string. if not s: return \\"\\" char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 most_frequent = max(char_count, key=lambda k: (char_count[k], -s.index(k))) return most_frequent"},{"question":"def check_password(password: str) -> str: Returns 'VALID' if the password is valid according to the following criteria: 1. It must contain at least one lowercase letter. 2. It must contain at least one uppercase letter. 3. It must contain at least one digit. 4. It must contain at least one special character from the set: !@#%^&*()-+ 5. It must be at least 8 characters long but no longer than 20 characters. Otherwise, returns 'INVALID'. >>> check_password(\\"Passw0rd!\\") \\"VALID\\" >>> check_password(\\"password\\") \\"INVALID\\"","solution":"def check_password(password): Returns 'VALID' if the password is valid according to the following criteria: 1. It must contain at least one lowercase letter. 2. It must contain at least one uppercase letter. 3. It must contain at least one digit. 4. It must contain at least one special character from the set: !@#%^&*()-+ 5. It must be at least 8 characters long but no longer than 20 characters. Otherwise, returns 'INVALID'. if not (8 <= len(password) <= 20): return \\"INVALID\\" has_lower = any(c.islower() for c in password) has_upper = any(c.isupper() for c in password) has_digit = any(c.isdigit() for c in password) has_special = any(c in \\"!@#%^&*()-+\\" for c in password) if has_lower and has_upper and has_digit and has_special: return \\"VALID\\" else: return \\"INVALID\\""},{"question":"def check_all_ones_submatrices(test_cases: List[Tuple[int, List[List[int]]]]) -> List[str]: Determine whether there is a submatrix that contains all ones. The submatrix must be entirely composed of 1s and can vary in size but must be at least 2x2. >>> check_all_ones_submatrices([(3, [[1, 0, 1], [0, 1, 0], [1, 1, 1]])]) == [\\"NO\\"] >>> check_all_ones_submatrices([(4, [[1, 1, 0, 0], [1, 1, 0, 1], [0, 0, 0, 1], [1, 1, 1, 1]])]) == [\\"YES\\"] >>> check_all_ones_submatrices([(1, [[1]])]) == [\\"NO\\"] >>> check_all_ones_submatrices([(3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]])]) == [\\"NO\\"] >>> check_all_ones_submatrices([(2, [[1, 1], [1, 1]]), (3, [[0, 1, 0], [1, 0, 1], [0, 1, 0]]), (4, [[1, 1, 0, 1], [1, 1, 0, 0], [0, 0, 0, 1], [1, 0, 1, 1]])]) == [\\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"def has_full_ones_submatrix(matrix, n): for i in range(n-1): for j in range(n-1): if matrix[i][j] == 1 and matrix[i+1][j] == 1 and matrix[i][j+1] == 1 and matrix[i+1][j+1] == 1: return True return False def check_all_ones_submatrices(test_cases): results = [] for n, matrix in test_cases: if has_full_ones_submatrix(matrix, n): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def generate_pascal_triangle_row(n: int) -> List[int]: Generate the n-th row of Pascal's Triangle. >>> generate_pascal_triangle_row(0) [1] >>> generate_pascal_triangle_row(1) [1, 1] >>> generate_pascal_triangle_row(2) [1, 2, 1] >>> generate_pascal_triangle_row(3) [1, 3, 3, 1] >>> generate_pascal_triangle_row(4) [1, 4, 6, 4, 1]","solution":"from typing import List def generate_pascal_triangle_row(n: int) -> List[int]: if n == 0: return [1] row = [1] for k in range(1, n + 1): next_value = row[-1] * (n - k + 1) // k row.append(next_value) return row"},{"question":"def min_knight_moves(n: int, start_row: int, start_col: int, target_row: int, target_col: int) -> int: Determine the minimum number of knight moves from the starting position to the target position. :param n: Size of the n x n chessboard. :param start_row: Starting row position of the knight. :param start_col: Starting column position of the knight. :param target_row: Target row position of the knight. :param target_col: Target column position of the knight. :return: Minimum number of moves required for the knight to move from the starting position to the target position. If it is impossible to reach the target cell, returns -1. ---Example--- >>> min_knight_moves(8, 0, 0, 7, 7) 6 >>> min_knight_moves(8, 0, 0, 0, 1) 3 >>> min_knight_moves(8, 0, 0, 3, 3) 2 >>> min_knight_moves(1, 0, 0, 0, 0) 0 >>> min_knight_moves(500, 250, 250, 250, 251) 3 >>> min_knight_moves(8, 7, 7, 0, 0) 6 >>> min_knight_moves(8, 0, 0, 5, 5) 4 def solve_knight_moves(test_cases: List[Tuple[int, Tuple[int, int], Tuple[int, int]]]) -> List[int]: Process multiple test cases and determine the minimum knight moves for each. :param test_cases: List of test cases where each test case is a tuple consisting of: - The size of the chessboard n - Starting position as a tuple (start_row, start_col) - Target position as a tuple (target_row, target_col) :return: List of minimum knight moves required for each test case. ---Example--- >>> solve_knight_moves([(8, (0, 0), (7, 7)), (8, (0, 0), (0, 1)), (8, (0, 0), (3, 3))]) [6, 3, 2] >>> solve_knight_moves([(1, (0, 0), (0, 0))]) [0] >>> solve_knight_moves([(500, (250, 250), (250, 251))]) [3] >>> solve_knight_moves([(8, (7, 7), (0, 0))]) [6] >>> solve_knight_moves([(8, (0, 0), (5, 5))]) [4]","solution":"from collections import deque def min_knight_moves(n, start_row, start_col, target_row, target_col): directions = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] if start_row == target_row and start_col == target_col: return 0 queue = deque([(start_row, start_col, 0)]) visited = set() visited.add((start_row, start_col)) while queue: row, col, steps = queue.popleft() for dr, dc in directions: new_row, new_col = row + dr, col + dc if (new_row, new_col) == (target_row, target_col): return steps + 1 if 0 <= new_row < n and 0 <= new_col < n and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, steps + 1)) return -1 def solve_knight_moves(test_cases): results = [] for n, start, target in test_cases: start_row, start_col = start target_row, target_col = target result = min_knight_moves(n, start_row, start_col, target_row, target_col) results.append(result) return results"},{"question":"from typing import List def min_steps_to_target(n: int, m: int, maze: List[str], x_start: int, y_start: int, x_target: int, y_target: int) -> int: Determine the minimum number of steps required for the explorers to move from the starting position to the target position in the maze. >>> min_steps_to_target(5, 5, [\\".....\\", \\".#.\\", \\".#.#.\\", \\".#...\\", \\".....\\"], 0, 0, 4, 4) 8 >>> min_steps_to_target(4, 4, [\\"#...\\", \\"#.\\", \\".#..\\", \\"...#\\"], 0, 0, 3, 3) -1 >>> min_steps_to_target(3, 3, [\\"...\\", \\"...\\", \\"...\\"], 1, 1, 1, 1) 0 >>> min_steps_to_target(3, 3, [\\".#.\\", \\"#\\", \\".#.\\"], 0, 0, 2, 2) -1 >>> min_steps_to_target(3, 3, [\\"...\\", \\"...\\", \\"...\\"], 0, 0, 2, 2) 4","solution":"from collections import deque def min_steps_to_target(n, m, maze, x_start, y_start, x_target, y_target): def is_valid(x, y): return 0 <= x < n and 0 <= y < m and maze[x][y] == '.' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(x_start, y_start, 0)]) # (x, y, steps) visited = set() visited.add((x_start, y_start)) while queue: x, y, steps = queue.popleft() if x == x_target and y == y_target: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1 # Target not reachable"},{"question":"def is_robot_back_to_origin(commands: str) -> str: Determine if the robot returns to the starting position after executing the commands. >>> is_robot_back_to_origin(\\"UDLR\\") 'Yes' >>> is_robot_back_to_origin(\\"UUDDLLRRR\\") 'No' >>> is_robot_back_to_origin(\\"UDUDUDUDUD\\") 'Yes' >>> is_robot_back_to_origin(\\"UUUUDDDD\\") 'Yes' >>> is_robot_back_to_origin(\\"UUDDR\\") 'No' >>> is_robot_back_to_origin(\\"UU\\") 'No' >>> is_robot_back_to_origin(\\"U\\" * 50000 + \\"D\\" * 50000 + \\"L\\" * 50000 + \\"R\\" * 50000) 'Yes'","solution":"def is_robot_back_to_origin(commands): Determine if the robot returns to the starting position after executing the commands. Args: commands (str): A string representing the sequence of commands. Returns: str: 'Yes' if the robot returns to the starting position, 'No' otherwise. x, y = 0, 0 # Starting position for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return \\"Yes\\" if x == 0 and y == 0 else \\"No\\""},{"question":"from datetime import datetime def validate_transaction(transaction): Validates a transaction based on the given rules. - The \`amount\` should be greater than 0. - The \`currency\` should be one of the accepted currencies: [\\"USD\\", \\"EUR\\", \\"GBP\\"]. - The \`card_number\` should be a string of exactly 16 digits. - The \`expiry_date\` should be a valid date in the future. - The \`cvv\` should be a string of exactly 3 digits. >>> transaction1 = { ... \\"amount\\": 100.0, ... \\"currency\\": \\"USD\\", ... \\"card_number\\": \\"1234567812345678\\", ... \\"expiry_date\\": \\"12/25\\", ... \\"cvv\\": \\"123\\" ... } >>> validate_transaction(transaction1) True >>> transaction2 = { ... \\"amount\\": -50.0, ... \\"currency\\": \\"USD\\", ... \\"card_number\\": \\"1234567812345678\\", ... \\"expiry_date\\": \\"10/20\\", ... \\"cvv\\": \\"123\\" ... } >>> validate_transaction(transaction2) False","solution":"from datetime import datetime def validate_transaction(transaction): Validates a transaction based on the given rules. # Check amount is greater than 0 if transaction['amount'] <= 0: return False # Check currency is in accepted list accepted_currencies = [\\"USD\\", \\"EUR\\", \\"GBP\\"] if transaction['currency'] not in accepted_currencies: return False # Check card_number is a string of exactly 16 digits if not (isinstance(transaction['card_number'], str) and len(transaction['card_number']) == 16 and transaction['card_number'].isdigit()): return False # Check expiry_date is a valid future date try: expiry = datetime.strptime(transaction['expiry_date'], \\"%m/%y\\") if expiry < datetime.now(): return False except ValueError: return False # Check cvv is a string of exactly 3 digits if not (isinstance(transaction['cvv'], str) and len(transaction['cvv']) == 3 and transaction['cvv'].isdigit()): return False return True"},{"question":"def max_gold(m, n, grid): Returns the maximum amount of gold that can be collected when the player reaches the bottom-right cell of the grid. Parameters: m (int): number of rows in the grid n (int): number of columns in the grid grid (List[List[int]]): the grid representing the dungeon with non-negative integers Returns: int: maximum amount of gold collected Examples: >>> max_gold(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_gold(2, 2, [[5, 3], [2, 4]]) 12","solution":"def max_gold(m, n, grid): Returns the maximum amount of gold that can be collected when the player reaches the bottom-right cell of the grid. dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"def min_operations_to_equal_elements(n, array): Returns the minimum number of operations required to make all elements in the array equal. Parameters: n (int): The number of elements in the array. array (list of int): The list of integers. Returns: int: The minimum number of operations. Example: >>> min_operations_to_equal_elements(5, [1, 2, 3, 4, 5]) 6 >>> min_operations_to_equal_elements(3, [10, 20, 30]) 20","solution":"def min_operations_to_equal_elements(n, array): Returns the minimum number of operations required to make all elements in the array equal. Parameters: n (int): The number of elements in the array. array (list of int): The list of integers. Returns: int: The minimum number of operations. array.sort() median = array[n // 2] # Select the median return sum(abs(x - median) for x in array)"},{"question":"def flatten_list(nested_list): Flattens a nested list of arbitrary depth and returns a one-dimensional list containing all the elements in the same order. Identifies and reports non-list elements found within the input list. pass def test_flatten_simple_nested_list(): assert flatten_list([1, [2, 3], [4, [5, 6]], 7]) == [1, 2, 3, 4, 5, 6, 7] def test_non_list_elements(): assert flatten_list([1, [2, 'a'], [4, [5, 6]], 7]) == \\"There is 1 non-list entry: ['a']\\" assert flatten_list([1, [2, 'a'], 'b', [4], [5, [6, 7]], 8]) == \\"There are 2 non-list entries: ['a', 'b']\\" def test_nested_string_lists(): assert flatten_list([1, [2, '[3, 4]'], [5, [6, 7]], 8]) == [1, 2, 3, 4, 5, 6, 7, 8] def test_list_with_none_elements(): assert flatten_list([1, [2, None], [4, [5, 6]], None, 7]) == [1, 2, 4, 5, 6, 7] def test_ignore_empty_lists(): assert flatten_list([1, [], [2, [[]]], [3, [], [4, 5]], 6]) == [1, 2, 3, 4, 5, 6] def test_negative_numbers_and_zero(): assert flatten_list([1, [2, [-3, 0]], [4, [-5, 6]], 7]) == [1, 2, -3, 0, 4, -5, 6, 7]","solution":"def flatten_list(nested_list): Flattens a nested list of arbitrary depth and returns a one-dimensional list containing all the elements in the same order. Identifies and reports non-list elements found within the input list. flat_list = [] non_list_elements = [] def _flatten(lst): for element in lst: if isinstance(element, list): _flatten(element) elif isinstance(element, str): try: evaluated_element = eval(element) if isinstance(evaluated_element, list): _flatten(evaluated_element) else: non_list_elements.append(element) except (SyntaxError, NameError): non_list_elements.append(element) elif element is None: continue else: flat_list.append(element) _flatten(nested_list) if non_list_elements: plurality = 'are' if len(non_list_elements) > 1 else 'is' element_plural = 'entries' if len(non_list_elements) > 1 else 'entry' return f\\"There {plurality} {len(non_list_elements)} non-list {element_plural}: {non_list_elements}\\" return flat_list"},{"question":"def minPalindromicCuts(s: str) -> int: Given a string s, split it into as few substrings as possible such that each substring is a palindrome. Return the minimum number of substrings required. >>> minPalindromicCuts(\\"aab\\") 1 >>> minPalindromicCuts(\\"abc\\") 2 def test_example_1(): assert minPalindromicCuts(\\"aab\\") == 1 def test_example_2(): assert minPalindromicCuts(\\"abc\\") == 2 def test_single_character(): assert minPalindromicCuts(\\"a\\") == 0 def test_all_same_characters(): assert minPalindromicCuts(\\"aaaa\\") == 0 def test_two_characters(): assert minPalindromicCuts(\\"ab\\") == 1 def test_long_palindrome(): assert minPalindromicCuts(\\"abba\\") == 0 def test_mixed_string(): assert minPalindromicCuts(\\"abacdc\\") == 1","solution":"def minPalindromicCuts(s): n = len(s) # Check if a substring is a palindrome def is_palindrome(s, start, end): while start < end: if s[start] != s[end]: return False start += 1 end -= 1 return True # DP table to store minimum cuts dp = [0] * n for i in range(n): if is_palindrome(s, 0, i): dp[i] = 0 else: min_cuts = float('inf') for j in range(i): if is_palindrome(s, j + 1, i): min_cuts = min(min_cuts, dp[j] + 1) dp[i] = min_cuts return dp[-1]"},{"question":"from typing import List, Tuple def process_logs(logs: List[str]) -> Tuple[List[str], str]: Process a list of log messages and return all messages with log level \\"ERROR\\" and the most common word among these messages. >>> process_logs([ \\"[2023-03-21 14:32:00] [INFO] User logged in\\", \\"[2023-03-21 14:33:00] [ERROR] File not found\\", \\"[2023-03-21 14:34:00] [DEBUG] Starting process\\", \\"[2023-03-21 14:35:00] [ERROR] Unable to open file\\" ]) ([\\"[2023-03-21 14:33:00] [ERROR] File not found\\", \\"[2023-03-21 14:35:00] [ERROR] Unable to open file\\"], \\"file\\") >>> process_logs([ \\"[2023-03-21 14:33:00] [INFO] All systems operational\\", \\"[2023-03-21 14:34:00] [DEBUG] Running diagnostics\\" ]) ([], \\"\\") >>> process_logs([\\"[2023-03-21 14:35:00] [ERROR] Critical failure in module A\\"]) ([\\"[2023-03-21 14:35:00] [ERROR] Critical failure in module A\\"], \\"critical\\") >>> process_logs([ \\"[2023-03-21 14:35:00] [ERROR] Disk space low\\", \\"[2023-03-21 14:36:00] [ERROR] Disk space low\\", \\"[2023-03-21 14:37:00] [ERROR] Disk space low\\" ]) ([ \\"[2023-03-21 14:35:00] [ERROR] Disk space low\\", \\"[2023-03-21 14:36:00] [ERROR] Disk space low\\", \\"[2023-03-21 14:37:00] [ERROR] Disk space low\\" ], \\"disk\\") >>> process_logs([ \\"[2023-03-21 14:33:00] [ERROR] Disk space low!\\", \\"[2023-03-21 14:34:00] [ERROR] Disk, space low\\" ]) ([ \\"[2023-03-21 14:33:00] [ERROR] Disk space low!\\", \\"[2023-03-21 14:34:00] [ERROR] Disk, space low\\" ], \\"disk\\") pass","solution":"from typing import List, Tuple import re from collections import Counter def process_logs(logs: List[str]) -> Tuple[List[str], str]: error_logs = [] word_counter = Counter() for log in logs: if \\"[ERROR]\\" in log: error_logs.append(log) # Extract the message part after the log level message = log.split('] [ERROR] ')[1] # Normalize to lower case and remove punctuation, then split into words words = re.findall(r'bw+b', message.lower()) word_counter.update(words) # Find the most common word if word_counter: most_common_word = word_counter.most_common(1)[0][0] else: most_common_word = \\"\\" return error_logs, most_common_word"},{"question":"def reverse_string(s: str) -> str: Takes a string as input and returns a new string that is the reverse of the input string. >>> reverse_string(\\"python\\") 'nohtyp' >>> reverse_string(\\"hello\\") 'olleh' from solution import reverse_string def test_reverse_string(): assert reverse_string(\\"python\\") == \\"nohtyp\\" assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"\\") == \\"\\" assert reverse_string(\\"A\\") == \\"A\\" assert reverse_string(\\"racecar\\") == \\"racecar\\" assert reverse_string(\\"123456789\\") == \\"987654321\\" assert reverse_string(\\"123 456\\") == \\"654 321\\" assert reverse_string(\\"!@# %^\\") == \\"^% #@!\\"","solution":"def reverse_string(s: str) -> str: Returns the reverse of the input string. :param s: The input string to be reversed. :return: A new string which is the reverse of the input string. return s[::-1]"},{"question":"from typing import Tuple def longest_non_repeating_substring(s: str) -> str: Returns the longest substring without repeating characters. If there are multiple substrings of the same length, the first one is returned. >>> longest_non_repeating_substring(\\"abcabcbb\\") == \\"abc\\" >>> longest_non_repeating_substring(\\"bbbbb\\") == \\"b\\" >>> longest_non_repeating_substring(\\"pwwkew\\") == \\"wke\\"","solution":"def longest_non_repeating_substring(s): Returns the longest substring without repeating characters. If there are multiple substrings of the same length, the first one is returned. char_index = {} longest_substr = \\"\\" start = 0 for end, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = end if end - start + 1 > len(longest_substr): longest_substr = s[start:end+1] return longest_substr"},{"question":"def max_orbs(m: int, n: int, E: int) -> int: Returns the maximum number of magical orbs that can be produced with given constraints. Args: m (int): magical energy required to cast the spell once. n (int): number of magical orbs generated per cast. E (int): total available units of magical energy. Returns: int: maximum number of magical orbs that can be produced. >>> max_orbs(5, 10, 45) 90 >>> max_orbs(7, 3, 70) 30 >>> max_orbs(4, 5, 0) 0 >>> max_orbs(0, 10, 50) 500 from solution import max_orbs def test_max_orbs_example_1(): assert max_orbs(5, 10, 45) == 90 def test_max_orbs_example_2(): assert max_orbs(7, 3, 70) == 30 def test_max_orbs_example_3(): assert max_orbs(4, 5, 0) == 0 def test_max_orbs_example_4(): assert max_orbs(0, 10, 50) == 500 def test_max_orbs_m_zero(): assert max_orbs(0, 15, 100) == 1500 def test_max_orbs_n_zero(): assert max_orbs(5, 0, 20) == 0 def test_max_orbs_no_energy(): assert max_orbs(5, 10, 0) == 0 def test_max_orbs_large_values(): assert max_orbs(3, 2, 1000) == 666 def test_max_orbs_large_values_edge_case(): assert max_orbs(1, 1, 1000) == 1000","solution":"def max_orbs(m, n, E): Returns the maximum number of magical orbs that can be produced with given constraints. Args: m (int): magical energy required to cast the spell once. n (int): number of magical orbs generated per cast. E (int): total available units of magical energy. Returns: int: maximum number of magical orbs that can be produced. if m == 0: return E * n max_casts = E // m return max_casts * n"},{"question":"from typing import List, Tuple def find_task_order(tasks: List[str], dependencies: List[Tuple[str, str]]) -> List[str]: Simulates the execution of tasks with dependencies represented as nodes in a Directed Acyclic Graph (DAG). Given the dependencies, this function returns a valid order to execute all tasks such that each task is performed only after all its dependencies have been completed. If no valid order exists (i.e., if a cycle is detected in the graph), an empty list is returned. >>> find_task_order([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], [(\\"a\\", \\"b\\"), (\\"a\\", \\"c\\"), (\\"b\\", \\"d\\"), (\\"c\\", \\"d\\")]) in [['a', 'b', 'c', 'd'], ['a', 'c', 'b', 'd']] True >>> find_task_order([\\"a\\", \\"b\\", \\"c\\"], [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"a\\")]) [] def test_find_task_order_basic(): tasks = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] dependencies = [(\\"a\\", \\"b\\"), (\\"a\\", \\"c\\"), (\\"b\\", \\"d\\"), (\\"c\\", \\"d\\")] order = find_task_order(tasks, dependencies) assert order in [[\\"a\\", \\"b\\", \\"c\\", \\"d\\"], [\\"a\\", \\"c\\", \\"b\\", \\"d\\"]] def test_find_task_order_with_no_dependencies(): tasks = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] dependencies = [] order = find_task_order(tasks, dependencies) assert set(order) == set(tasks) def test_find_task_order_with_cycle(): tasks = [\\"a\\", \\"b\\", \\"c\\"] dependencies = [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"a\\")] order = find_task_order(tasks, dependencies) assert order == [] def test_find_task_order_single_task(): tasks = [\\"a\\"] dependencies = [] order = find_task_order(tasks, dependencies) assert order == [\\"a\\"] def test_find_task_order_multiple_valid_orders(): tasks = [\\"a\\", \\"b\\", \\"c\\"] dependencies = [(\\"a\\", \\"b\\"), (\\"a\\", \\"c\\")] order = find_task_order(tasks, dependencies) assert order in [[\\"a\\", \\"b\\", \\"c\\"], [\\"a\\", \\"c\\", \\"b\\"]]","solution":"from typing import List, Tuple def find_task_order(tasks: List[str], dependencies: List[Tuple[str, str]]) -> List[str]: from collections import defaultdict, deque # Initialize graph and in-degree (number of incoming edges) of each node graph = defaultdict(list) in_degree = {task: 0 for task in tasks} # Build the graph and the in-degree for each task for prereq, task in dependencies: graph[prereq].append(task) in_degree[task] += 1 # Find all starting nodes with no incoming edges queue = deque([task for task in tasks if in_degree[task] == 0]) order = [] while queue: current = queue.popleft() order.append(current) # Decrease the in-degree of each neighboring node by 1 for neighbor in graph[current]: in_degree[neighbor] -= 1 # If in-degree becomes 0, add it to the queue if in_degree[neighbor] == 0: queue.append(neighbor) # If the order contains all the tasks, return the order if len(order) == len(tasks): return order else: # A cycle was detected return []"},{"question":"def is_valid_sudoku(grid): Write a function that checks if a given grid of characters represents a valid Sudoku solution. The Sudoku grid is 9x9 and can have values from '1' to '9' or be empty cells (represented by '.'). A valid Sudoku solution must satisfy the following constraints: - Each row must contain the digits '1' to '9' without repetition. - Each column must contain the digits '1' to '9' without repetition. - Each of the nine 3x3 sub-grids must contain the digits '1' to '9' without repetition. If the grid is a valid Sudoku solution, return \`true\`. Otherwise, return \`false\`. >>> grid = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] >>> is_valid_sudoku(grid) True >>> grid = [ [\\"8\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] >>> is_valid_sudoku(grid) False","solution":"def is_valid_sudoku(grid): def is_valid_unit(unit): elements = [num for num in unit if num != '.'] return len(elements) == len(set(elements)) def is_valid_row(grid): for row in grid: if not is_valid_unit(row): return False return True def is_valid_col(grid): for col in range(9): if not is_valid_unit([grid[row][col] for row in range(9)]): return False return True def is_valid_subgrid(grid): for i in range(0, 9, 3): for j in range(0, 9, 3): subgrid = [grid[x][y] for x in range(i, i+3) for y in range(j, j+3)] if not is_valid_unit(subgrid): return False return True return is_valid_row(grid) and is_valid_col(grid) and is_valid_subgrid(grid)"},{"question":"from typing import List def is_path_exists(n: int, m: int, grid: List[str]) -> str: Determines if there is a path from the top-left corner to the bottom-right corner with green traffic lights only. Args: n (int): Number of vertical roads. m (int): Number of horizontal roads. grid (List[str]): A list of strings representing the grid of traffic lights. Returns: str: \\"YES\\" if there exists a path from (1, 1) to (n, m) through green lights only, otherwise \\"NO\\". Examples: >>> is_path_exists(5, 5, [\\"GGGGG\\", \\"RGRGR\\", \\"GRRGG\\", \\"RGRGR\\", \\"GGGGG\\"]) \\"YES\\" >>> is_path_exists(3, 3, [\\"GRG\\", \\"RRR\\", \\"GRG\\"]) \\"NO\\" def test_example_1(): grid = [ \\"GGGGG\\", \\"RGRGR\\", \\"GRRGG\\", \\"RGRGR\\", \\"GGGGG\\" ] assert is_path_exists(5, 5, grid) == \\"YES\\" def test_example_2(): grid = [ \\"GRG\\", \\"RRR\\", \\"GRG\\" ] assert is_path_exists(3, 3, grid) == \\"NO\\" def test_example_3(): grid = [ \\"GGGG\\", \\"GRRG\\", \\"GRRG\\", \\"GRGG\\" ] assert is_path_exists(4, 4, grid) == \\"YES\\" def test_single_cell_green(): grid = [\\"G\\"] assert is_path_exists(1, 1, [\\"G\\"]) == \\"YES\\" def test_single_cell_red(): grid = [\\"R\\"] assert is_path_exists(1, 1, [\\"R\\"]) == \\"NO\\" def test_no_possible_path(): grid = [ \\"GGG\\", \\"RRR\\", \\"GGG\\" ] assert is_path_exists(3, 3, grid) == \\"NO\\" def test_all_red(): grid = [ \\"RRR\\", \\"RRR\\", \\"RRR\\" ] assert is_path_exists(3, 3, grid) == \\"NO\\"","solution":"def is_path_exists(n, m, grid): def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] != 'G' or visited[x][y]: return False if x == n-1 and y == m-1: return True visited[x][y] = True return dfs(x+1, y) or dfs(x, y+1) or dfs(x-1, y) or dfs(x, y-1) if grid[0][0] != 'G' or grid[n-1][m-1] != 'G': return \\"NO\\" visited = [[False for _ in range(m)] for _ in range(n)] return \\"YES\\" if dfs(0, 0) else \\"NO\\""},{"question":"def number_of_mixed_homogeneous_sequences(N: int, M: int) -> int: Determine the number of different Mixed Homogeneous Sequences modulo 10^9 + 7. >>> number_of_mixed_homogeneous_sequences(2, 3) == 9 >>> number_of_mixed_homogeneous_sequences(3, 2) == 4 >>> number_of_mixed_homogeneous_sequences(4, 1) == 1 >>> number_of_mixed_homogeneous_sequences(5, 3) == 9 >>> number_of_mixed_homogeneous_sequences(6, 1) == 1","solution":"def number_of_mixed_homogeneous_sequences(N, M): MOD = 10**9 + 7 if N % 2 == 0: # For even N, the number of possible sequences is M (odd positions) * M (even positions) = M^2 result = pow(M, 2, MOD) else: # For odd N, similarly, it's only M (odd positions) * M (even positions) = M^2 result = pow(M, 2, MOD) return result"},{"question":"import itertools def fibonacci_string_order_k(k: int) -> str: Generate the fibonacci string of order k. >>> fibonacci_string_order_k(1) 'a' >>> fibonacci_string_order_k(2) 'b' >>> fibonacci_string_order_k(3) 'ba' >>> fibonacci_string_order_k(4) 'bab' # Implement the function here def pth_permutation(k: int, p: int) -> str: Find the p-th permutation of the fibonacci string Fk in lexicographical order. >>> pth_permutation(3, 1) 'ab' >>> pth_permutation(3, 2) 'ba' >>> pth_permutation(4, 1) 'abb' >>> pth_permutation(4, 6) 'bba' # Implement the function here","solution":"import itertools def fibonacci_string_order_k(k): if k == 1: return \\"a\\" elif k == 2: return \\"b\\" else: Fi_minus_2 = \\"a\\" Fi_minus_1 = \\"b\\" Fi = \\"\\" for i in range(3, k + 1): Fi = Fi_minus_1 + Fi_minus_2 Fi_minus_2 = Fi_minus_1 Fi_minus_1 = Fi return Fi def pth_permutation(k, p): Fk = fibonacci_string_order_k(k) perms = sorted(itertools.permutations(Fk)) return ''.join(perms[p-1])"},{"question":"from typing import List def reorganize_string(s: str) -> str: Rearrange the letters of the string to form the lexicographically smallest string possible such that no two adjacent letters are the same. If it is not possible, return an empty string. >>> reorganize_string(\\"aabbc\\") in [\\"abcab\\", \\"ababc\\"] True >>> reorganize_string(\\"aaab\\") \\"\\"","solution":"from collections import Counter import heapq def reorganize_string(s: str) -> str: if not s: return \\"\\" # Get the frequency of each character counter = Counter(s) # Max heap for storing the characters by frequency max_heap = [(-freq, ch) for ch, freq in counter.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap or prev_freq < 0: if not max_heap: return \\"\\" freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char, prev_freq = char, freq + 1 return \\"\\".join(result)"},{"question":"def remove_duplicates(log): Removes duplicates from the session log while preserving the order of first occurrence. Args: log (list of int): The list of session IDs. Returns: list of int: The list of session IDs with duplicates removed. >>> remove_duplicates([1, 2, 3, 4, 2, 1, 5, 6, 7, 3]) [1, 2, 3, 4, 5, 6, 7] >>> remove_duplicates([1, 1, 1, 1, 1]) [1] >>> remove_duplicates([1, 2, 3, 4, 5, 6, 7, 8, 9]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> remove_duplicates([42]) [42] >>> remove_duplicates([]) []","solution":"def remove_duplicates(log): Removes duplicates from the session log while preserving the order of first occurrence. Args: log (list of int): The list of session IDs. Returns: list of int: The list of session IDs with duplicates removed. seen = set() result = [] for session_id in log: if session_id not in seen: seen.add(session_id) result.append(session_id) return result"},{"question":"import random def simulatePrices(startPriceConsoleA, startPriceConsoleB, numMonths): Simulates the prices of two gaming consoles over a given number of months and returns the month number at which the price difference between the two consoles is the smallest and the corresponding smallest price difference. Parameters: startPriceConsoleA (float): Initial price of Console A startPriceConsoleB (float): Initial price of Console B numMonths (int): Number of months to simulate Returns: (int, float): Month number with smallest price difference and the smallest price difference >>> simulatePrices(500, 700, 12) [MonthNumber, SmallestPriceDifference]","solution":"import random def simulatePrices(startPriceConsoleA, startPriceConsoleB, numMonths): min_difference = float('inf') min_diff_month = -1 consoleA = startPriceConsoleA consoleB = startPriceConsoleB for month in range(1, numMonths + 1): percentage_change = random.uniform(-0.05, 0.05) consoleA += consoleA * percentage_change consoleB += consoleB * percentage_change price_difference = abs(consoleA - consoleB) if price_difference < min_difference: min_difference = price_difference min_diff_month = month return (min_diff_month, round(min_difference, 2))"},{"question":"def count_fruits(N: int, fruits: str) -> tuple: Returns the count of apples and oranges in the basket. Parameters: N (int): The total number of fruits. fruits (str): A string of length N consisting of characters 'A' and 'O'. Returns: tuple: A tuple containing two integers: the number of apples and the number of oranges. >>> count_fruits(5, 'AAOOA') (3, 2) >>> count_fruits(4, 'OOOO') (0, 4)","solution":"def count_fruits(N, fruits): Returns the count of apples and oranges in the basket. Parameters: N (int): The total number of fruits. fruits (str): A string of length N consisting of characters 'A' and 'O'. Returns: tuple: A tuple containing two integers: the number of apples and the number of oranges. apples = fruits.count('A') oranges = fruits.count('O') return apples, oranges"},{"question":"def reorder_lexico(arr): Reorders the elements into the lexicographically smallest sequence possible by performing at most one swap between any two elements. pass # Test cases def test_no_swap_needed(): assert reorder_lexico([1, 2, 3]) == [1, 2, 3] def test_reverse_order(): assert reorder_lexico([3, 2, 1]) == [1, 2, 3] def test_single_swap(): assert reorder_lexico([2, 3, 1]) == [1, 3, 2] def test_duplicate_numbers(): assert reorder_lexico([2, 2, 1, 1]) == [1, 2, 2, 1] def test_large_numbers(): assert reorder_lexico([1000000000, 999999999, 1]) == [1, 999999999, 1000000000] def test_single_element(): assert reorder_lexico([1]) == [1] def test_lexico_order(): assert reorder_lexico([1, 20, 2]) == [1, 2, 20]","solution":"def reorder_lexico(arr): Reorders the elements into the lexicographically smallest sequence possible by performing at most one swap between any two elements. n = len(arr) if n <= 1: return arr # Create a list of tuples (value, index) indexed_arr = [(value, idx) for idx, value in enumerate(arr)] # Sort the list by value to get the target lexicographical order sorted_arr = sorted(indexed_arr) # Find the first position where the array and the sorted array differ for i in range(n): if arr[i] != sorted_arr[i][0]: swap_to_idx = sorted_arr[i][1] break else: # If there is no such position, the array is already lexicographically smallest return arr # Perform the swap arr[i], arr[swap_to_idx] = arr[swap_to_idx], arr[i] return arr"},{"question":"def assign_guards(n: int, m: int, roads: List[Tuple[int, int]]) -> List[int]: Determine the minimum number of guards required in each city. :param n: Integer - The number of cities. :param m: Integer - The number of roads. :param roads: List of tuples - Each tuple contains two integers representing the cities connected by a road. :return: List of integers where the i-th integer represents the number of guards required in city i. Examples: >>> assign_guards(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) [1, 2, 2, 2, 1] >>> assign_guards(3, 0, []) [0, 0, 0]","solution":"def assign_guards(n, m, roads): This function determines the minimum number of guards required in each city. :param n: Integer - The number of cities. :param m: Integer - The number of roads. :param roads: List of tuples - Each tuple contains two integers representing the cities connected by a road. :return: List of integers where the i-th integer represent the number of guards required in city i+1. # Initialize the list for number of guards required in each city guards = [0] * n # Dictionary to keep track of each city's connections city_connections = {i: 0 for i in range(1, n + 1)} # Count the number of connections for each city for u, v in roads: city_connections[u] += 1 city_connections[v] += 1 # Assign guards based on the number of connections for city in range(1, n + 1): if city_connections[city] > 0: guards[city - 1] = city_connections[city] return guards"},{"question":"def solve_sudoku(board): Solves the given Sudoku board in-place and returns True if a solution exists, else False. >>> board = [ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9] ... ] >>> solve_sudoku(board) True >>> print(board) [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ]","solution":"def solve_sudoku(board): Solves the given Sudoku board in-place and returns True if a solution exists, else False. def is_valid(board, row, col, num): # Check if num is not in the current row for x in range(9): if board[row][x] == num: return False # Check if num is not in the current column for x in range(9): if board[x][col] == num: return False # Check if num is not in the current 3x3 box start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if board[i + start_row][j + start_col] == num: return False return True def solve(board): for row in range(9): for col in range(9): if board[row][col] == 0: for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = 0 return False return True return solve(board)"},{"question":"from itertools import permutations from typing import List def generate_permutations(test_cases: List[str]) -> List[List[str]]: Generate all possible permutations of the string in lexicographical order. >>> generate_permutations([\\"abc\\"]) [[\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"]] >>> generate_permutations([\\"dog\\"]) [[\\"dgo\\", \\"dog\\", \\"gdo\\", \\"god\\", \\"odg\\", \\"ogd\\"]] >>> generate_permutations([\\"a\\"]) [[\\"a\\"]] >>> generate_permutations([\\"abc\\", \\"dog\\"]) [[\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"], [\\"dgo\\", \\"dog\\", \\"gdo\\", \\"god\\", \\"odg\\", \\"ogd\\"]] >>> generate_permutations([\\"xyz\\"]) [[\\"xyz\\", \\"xzy\\", \\"yxz\\", \\"yzx\\", \\"zxy\\", \\"zyx\\"]]","solution":"from itertools import permutations def generate_permutations(test_cases): results = [] for s in test_cases: perms = sorted(''.join(p) for p in permutations(s)) results.append(perms) return results"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determines if the two strings can be made to look the same by reordering their characters. Args: str1 (string): The first input string. str2 (string): The second input string. Returns: bool: True if the two strings can be made to look the same by reordering their characters, False otherwise. >>> are_anagrams(\\"god\\", \\"dog\\") True >>> are_anagrams(\\"Listen\\", \\"Silent\\") False >>> are_anagrams(\\"Hello, World!\\", \\"o!ldl rHoWe\\") False >>> are_anagrams(\\"The eyes\\", \\"They see!!\\") False >>> are_anagrams(\\"12345!@#\\", \\"54321#@!\\") True >>> are_anagrams(\\"123aBc!\\", \\"Bc1a32!\\") True","solution":"def are_anagrams(str1, str2): Determines if the two strings can be made to look the same by reordering their characters. Args: str1 (string): The first input string. str2 (string): The second input string. Returns: bool: True if the two strings can be made to look the same by reordering their characters, False otherwise. return sorted(str1) == sorted(str2)"},{"question":"def process_orders(orders: List[str]) -> Dict[str, int]: Processes customer purchase orders and generates a summary report based on the quantities of items ordered. Args: orders (list of str): A list of string orders, where each order is a comma-separated string of \\"item_name quantity\\". Returns: dict: A dictionary where keys are item names and values are total quantities across all orders, sorted alphabetically by item name. >>> process_orders([\\"apple 4,banana 2,apple 1\\"]) {'apple': 5, 'banana': 2} >>> process_orders([ \\"apple 4,banana 2,apple 1\\", \\"orange 3,apple 2,banana 2\\", \\"grape 5,orange 2\\" ]) {'apple': 7, 'banana': 4, 'grape': 5, 'orange': 5} >>> process_orders([ \\"apple 4,banana 2\\", \\"\\" ]) {'apple': 4, 'banana': 2} >>> process_orders([\\"\\"]) {} >>> process_orders([ \\" apple 4 , banana 2 , apple 1 \\", \\" orange 3 ,apple 2, banana 2 \\", \\" grape 5 , orange 2\\" ]) {'apple': 7, 'banana': 4, 'grape': 5, 'orange': 5}","solution":"def process_orders(orders): Processes customer purchase orders and generates a summary report based on the quantities of items ordered. Args: orders (list of str): A list of string orders, where each order is a comma-separated string of \\"item_name quantity\\". Returns: dict: A dictionary where keys are item names and values are total quantities across all orders, sorted alphabetically by item name. from collections import defaultdict item_totals = defaultdict(int) for order in orders: if not order.strip(): # Skip any blank lines continue items = order.split(',') for item in items: item_name, quantity = item.split() item_totals[item_name] += int(quantity) # Create a sorted dictionary by keys sorted_item_totals = dict(sorted(item_totals.items())) return sorted_item_totals"},{"question":"def removeDuplicates(s: str) -> str: Removes all adjacent duplicates from the string. Example 1: >>> removeDuplicates(\\"abbaca\\") \\"ca\\" Example 2: >>> removeDuplicates(\\"azxxzy\\") \\"ay\\"","solution":"def removeDuplicates(s): Removes all adjacent duplicates from the string. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"def compare_perimeters(T: int, test_cases: list[tuple[int, int, int]]) -> list[str]: Given T test cases, each containing the side length of a square and the length and width of a rectangle, determine which shape has a larger perimeter or if they are equal. Parameters: T (int): Number of test cases test_cases (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers S, L, W Returns: List[str]: A list of strings where each string is \\"SQUARE\\", \\"RECTANGLE\\", or \\"EQUAL\\" >>> compare_perimeters(3, [(4, 5, 3), (6, 4, 4), (7, 8, 7)]) [\\"EQUAL\\", \\"SQUARE\\", \\"RECTANGLE\\"] >>> compare_perimeters(2,[(2, 2, 2), (3, 3, 3)]) [\\"EQUAL\\", \\"EQUAL\\"] >>> compare_perimeters(1, [(4, 10, 2)]) [\\"RECTANGLE\\"] >>> compare_perimeters(2, [(30, 10, 5), (25, 10, 12)]) [\\"SQUARE\\", \\"SQUARE\\"] >>> compare_perimeters(3, [(3, 9, 1), (5, 7, 6), (10, 4, 20)]) [\\"RECTANGLE\\", \\"RECTANGLE\\", \\"RECTANGLE\\"]","solution":"def compare_perimeters(T, test_cases): Given T test cases, each containing the side length of a square and the length and width of a rectangle, determine which shape has a larger perimeter or if they are equal. Parameters: T (int): Number of test cases test_cases (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers S, L, W Returns: List[str]: A list of strings where each string is \\"SQUARE\\", \\"RECTANGLE\\", or \\"EQUAL\\" results = [] for S, L, W in test_cases: perimeter_square = 4 * S perimeter_rectangle = 2 * (L + W) if perimeter_square > perimeter_rectangle: results.append(\\"SQUARE\\") elif perimeter_square < perimeter_rectangle: results.append(\\"RECTANGLE\\") else: results.append(\\"EQUAL\\") return results"},{"question":"def max_food_per_request(n: int, m: int, A: List[int], requests: List[Tuple[int, int, int]]) -> List[int]: Determine the maximum number of food items that can be taken from the specified range. Args: n (int): The number of storage units. m (int): The number of food requests. A (List[int]): The array of food items in each storage unit. requests (List[Tuple[int, int, int]]): The list of requests where each request is a tuple (l, r, k). Returns: List[int]: The results for each request. >>> max_food_per_request(6, 3, [5, 20, 15, 10, 7, 25], [(1, 3, 40), (2, 5, 30), (1, 6, 50)]) [40, 30, 50] >>> max_food_per_request(1, 1, [100], [(1, 1, 50)]) [50] >>> max_food_per_request(5, 2, [10, 20, 30, 40, 50], [(1, 5, 200), (2, 4, 100)]) [150, 90] >>> max_food_per_request(4, 2, [8, 12, 15, 10], [(1, 4, 45), (2, 3, 27)]) [45, 27] >>> max_food_per_request(4, 2, [10, 20, 30, 40], [(1, 4, 50), (2, 3, 10)]) [50, 10]","solution":"def max_food_per_request(n, m, A, requests): results = [] for l, r, k in requests: total_food = sum(A[l-1:r]) results.append(min(total_food, k)) return results"},{"question":"def count_even_sum_pairs(cards): Returns the number of pairs (i, j) such that i < j and the sum of the values on the cards at positions i and j is even. Parameters: cards (list of int): List of integer card values. Returns: int: Number of pairs whose sums are even. Examples: >>> count_even_sum_pairs([3, 5, 8, 10]) 2 >>> count_even_sum_pairs([2, 4, 6, 8]) 6 >>> count_even_sum_pairs([1, 3, 5, 7]) 6 >>> count_even_sum_pairs([1, 2]) 0 >>> count_even_sum_pairs([1, 3]) 1 >>> count_even_sum_pairs([2, 4]) 1 >>> count_even_sum_pairs([1, 3, 2, 4, 6]) 4","solution":"def count_even_sum_pairs(cards): Returns the number of pairs (i, j) such that i < j and the sum of the values on the cards at positions i and j is even. Parameters: cards (list of int): List of integer card values. Returns: int: Number of pairs whose sums are even. even_count = 0 odd_count = 0 for card in cards: if card % 2 == 0: even_count += 1 else: odd_count += 1 # Pairs of evens and pairs of odds will result in even sums. even_pairs = even_count * (even_count - 1) // 2 odd_pairs = odd_count * (odd_count - 1) // 2 return even_pairs + odd_pairs"},{"question":"def calculate_lightness(rgb_values): Given a list of strings representing RGB values, calculate the lightness for each set. The input consists of multiple datasets. Each dataset is in one line, which consists of three integers r, g, and b separated by a space. For each line, 0 ≤ r, g, b ≤ 255 holds. The end of the input is specified by \\"end\\". For example: >>> calculate_lightness([\\"255 0 0\\", \\"0 255 0\\", \\"0 0 255\\", \\"220 220 220\\", \\"128 128 128\\", \\"0 0 0\\", \\"255 255 255\\", \\"end\\"]) [127, 127, 127, 220, 128, 0, 255] >>> calculate_lightness([\\"end\\"]) [] >>> calculate_lightness([\\"255 255 0\\", \\"end\\"]) [127] >>> calculate_lightness([\\"50 100 200\\", \\"10 20 30\\", \\"end\\"]) [125, 20] >>> calculate_lightness([\\"0 0 0\\", \\"255 255 255\\", \\"end\\"]) [0, 255]","solution":"def calculate_lightness(rgb_values): Given a list of strings representing RGB values, calculate the lightness for each set. lightness_values = [] for values in rgb_values: if values.strip().lower() == 'end': break r, g, b = map(int, values.split()) lightness = (max(r, g, b) + min(r, g, b)) // 2 lightness_values.append(lightness) return lightness_values"},{"question":"def compute_product(test_cases): Compute the product of all elements in the array for each test case. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples where the first element in each tuple is the number of integers and the second element is the list of integers. Returns: List[int]: A list containing the products for each test case. >>> compute_product([(3, [2, 3, 4])]) [24] >>> compute_product([(3, [2, 3, 4]), (4, [1, 5, 2, 2])]) [24, 20] def main(): T = int(input().strip()) test_cases = [] for _ in range(T): N = int(input().strip()) array = list(map(int, input().strip().split())) test_cases.append((N, array)) results = compute_product(test_cases) for result in results: print(result)","solution":"def compute_product(test_cases): results = [] for case in test_cases: N = case[0] array = case[1] product = 1 for number in array: product *= number results.append(product) return results def main(): T = int(input().strip()) test_cases = [] for _ in range(T): N = int(input().strip()) array = list(map(int, input().strip().split())) test_cases.append((N, array)) results = compute_product(test_cases) for result in results: print(result)"},{"question":"def max_difference_value(N, array): Find the maximum difference value among all subarrays of the given array. Parameters: N (int): The size of the array. array (List[int]): The list of integers. Returns: int: The maximum difference value among all subarrays. Examples: >>> max_difference_value(5, [1, 3, 2, 7, 9]) 8 >>> max_difference_value(6, [4, 4, 4, 4, 4, 4]) 0","solution":"def max_difference_value(N, array): Returns the maximum difference value among all subarrays of the given array. max_diff = 0 for i in range(N): for j in range(i, N): subarray = array[i:j+1] current_diff = max(subarray) - min(subarray) if current_diff > max_diff: max_diff = current_diff return max_diff"},{"question":"def max_items(prices: List[int], budget: int) -> int: Returns the maximum number of items that can be bought without exceeding the given budget. >>> max_items([1, 12, 5, 111, 200], 10) 2 >>> max_items([20, 30, 50], 35) 1 >>> max_items([2, 2, 2], 4) 2 >>> max_items([1, 1, 1, 1, 1], 3) 3 def solve(t: int, test_cases: List[Tuple[int, List[int], int]]) -> List[int]: Solves the problem for multiple test cases. >>> solve(2, [(5, [1, 12, 5, 111, 200], 10), (3, [20, 30, 50], 35)]) [2, 1] >>> solve(3, [(3, [2, 2, 2], 4), (5, [1, 1, 1, 1, 1], 3), (4, [1000, 2000, 3000, 4000], 10000)]) [2, 3, 4]","solution":"def max_items(prices, budget): Returns the maximum number of items that can be bought without exceeding the given budget. prices.sort() total_spent = 0 num_items = 0 for price in prices: if total_spent + price <= budget: total_spent += price num_items += 1 else: break return num_items def solve(t, test_cases): Solves the problem for multiple test cases. results = [] for i in range(t): n, prices, budget = test_cases[i] result = max_items(prices, budget) results.append(result) return results"},{"question":"from typing import List def next_permutation(nums: List[int]) -> None: Rearrange the given array of integers into their lexicographically next greater permutation. If such an arrangement is not possible, it must rearrange it to the lowest possible order (i.e., sorted in ascending order). The rearrangement must be done in-place and with constant extra memory. >>> nums = [1, 2, 3] >>> next_permutation(nums) >>> nums [1, 3, 2] >>> nums = [3, 2, 1] >>> next_permutation(nums) >>> nums [1, 2, 3] >>> nums = [1, 1, 5] >>> next_permutation(nums) >>> nums [1, 5, 1] >>> nums = [1, 5, 1] >>> next_permutation(nums) >>> nums [5, 1, 1] >>> nums = [2, 3, 1] >>> next_permutation(nums) >>> nums [3, 1, 2] >>> nums = [1] >>> next_permutation(nums) >>> nums [1] >>> nums = [1, 2, 3, 6, 5, 4] >>> next_permutation(nums) >>> nums [1, 2, 4, 3, 5, 6]","solution":"from typing import List def next_permutation(nums: List[int]) -> None: Rearranges the array into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it transforms it into the lowest possible order (i.e., sorted in ascending order). This must be done in-place. n = len(nums) if n <= 1: return # Step 1: Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, the permutation is the last permutation. k = n - 2 while k >= 0 and nums[k] >= nums[k + 1]: k -= 1 if k >= 0: # If such index exists # Step 2: Find the largest index l greater than k such that nums[k] < nums[l] l = n - 1 while nums[k] >= nums[l]: l -= 1 # Step 3: Swap the value of nums[k] with that of nums[l] nums[k], nums[l] = nums[l], nums[k] # Step 4: Reverse the sequence from nums[k + 1] to the end nums[k + 1:] = reversed(nums[k + 1:])"},{"question":"def find_shortest_word_length(s: str) -> int: Given a string of words separated by spaces, return the length of the shortest word. Parameters: s (str): A string of words separated by spaces. Returns: int: The length of the shortest word. Examples: >>> find_shortest_word_length(\\"The quick brown fox\\") 3 >>> find_shortest_word_length(\\"Jumped over the lazy dog\\") 3 >>> find_shortest_word_length(\\"I have a dream\\") 1 >>> find_shortest_word_length(\\"Something wonderful will happen\\") 4 >>> find_shortest_word_length(\\"Supercalifragilisticexpialidocious\\") 34","solution":"def find_shortest_word_length(s): Returns the length of the shortest word in the given string s. words = s.split() shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"def apply_operations(n: int, m: int, operations: List[Tuple[int, int, int, int, int]]) -> Tuple[int, int]: Compute the minimum and maximum values in an n x n grid after applying m operations. Each operation adds a value v to a subgrid defined by top-left (x1, y1) and bottom-right (x2, y2) corners. Args: n (int): Size of the grid (n x n). m (int): Number of operations. operations (List[Tuple[int, int, int, int, int]]): A list of operations, with each operation defined by 5 integers (x1, y1, x2, y2, v). Returns: Tuple[int, int]: A tuple containing the minimum and maximum values in the resulting grid. >>> apply_operations(3, 2, [(1, 1, 2, 2, 3), (2, 2, 3, 3, 5)]) (0, 8) >>> apply_operations(3, 1, [(1, 1, 3, 3, 5)]) (5, 5) >>> apply_operations(3, 1, [(1, 1, 2, 2, 4)]) (0, 4) >>> apply_operations(3, 2, [(1, 1, 1, 1, 3), (3, 3, 3, 3, 7)]) (0, 7) >>> apply_operations(1, 1, [(1, 1, 1, 1, 0)]) (0, 0) # Implement the function here","solution":"def apply_operations(n, m, operations): # Create a grid initialized with 0s grid = [[0] * n for _ in range(n)] # Apply each operation to the grid for op in operations: x1, y1, x2, y2, v = op for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): grid[i][j] += v # Find the minimum and maximum value in the grid min_value = float('inf') max_value = float('-inf') for row in grid: min_value = min(min_value, min(row)) max_value = max(max_value, max(row)) return min_value, max_value"},{"question":"def can_reach_destination(input_str: str) -> str: Determine if the spaceship can reach (x, y) from (0, 0) following the given rule. >>> can_reach_destination(\\"3 4\\") \\"NO\\" >>> can_reach_destination(\\"3 3\\") \\"YES\\" >>> can_reach_destination(\\"0 0\\") \\"YES\\" >>> can_reach_destination(\\"2 2\\") \\"YES\\" >>> can_reach_destination(\\"5 8\\") \\"NO\\"","solution":"def can_reach_destination(input_str): x, y = map(int, input_str.split()) # The sum of the coordinates must remain invariant. # Since we start at (0,0) where the sum is 0, # the sum of x and y should be zero based on movement rule. return \\"YES\\" if x == y else \\"NO\\""},{"question":"def largest_empty_rectangle(garden: List[str]) -> int: Determine the area of the largest rectangle that consists entirely of empty cells in a garden grid. Parameters: garden (List[str]): A 2D grid of characters where '.' denotes an empty cell and '*' denotes a cell with a flower. Returns: int: The area of the largest rectangular area consisting entirely of empty cells. Examples: >>> largest_empty_rectangle([\\"....\\"]) 4 >>> largest_empty_rectangle([\\".\\", \\".\\", \\".\\", \\".\\"]) 4 >>> largest_empty_rectangle([\\"****\\"]) 0 >>> largest_empty_rectangle([ ... \\".*..\\", ... \\"....\\", ... \\"****\\", ... \\".*..\\" ... ]) 4 >>> largest_empty_rectangle([ ... \\"....\\", ... \\"....\\", ... \\"....\\", ... \\"....\\" ... ]) 16 >>> largest_empty_rectangle([ ... \\".*.*\\", ... \\"*.**\\", ... \\"****\\", ... \\"*.*.\\" ... ]) 1 # Your implementation here","solution":"def maximalRectangle(matrix): if not matrix or not matrix[0]: return 0 max_area = 0 n = len(matrix) m = len(matrix[0]) heights = [0] * (m + 1) for row in matrix: for i in range(m): if row[i] == '.': heights[i] += 1 else: heights[i] = 0 stack = [-1] for j in range(m + 1): while heights[j] < heights[stack[-1]]: h = heights[stack.pop()] w = j - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(j) return max_area def largest_empty_rectangle(garden): return maximalRectangle(garden) # Example usage: n = 4 garden = [ \\".*..\\", \\"....\\", \\"****\\", \\".*..\\" ] print(largest_empty_rectangle(garden)) # Output: 4"},{"question":"def total_growth(P: int, plant_data: list) -> list: Calculate the total growth achieved for each plant based on initial height and daily growth records. Args: P (int): number of plants plant_data (list): list of tuples, each tuple containing: - D (int): number of daily growth records - Hi (int): initial height of the plant - growth_records (list): list of tuples with each tuple containing: - date (str): the date of the daily record - dh (int): change in height for that day Returns: list: total growth for each plant over the entire period of records def test_total_growth_case_1(): P = 2 plant_data = [ (3, 10, [(\\"2023-01-01\\", 5), (\\"2023-01-02\\", -3), (\\"2023-01-03\\", 7)]), (2, 20, [(\\"2023-01-01\\", 2), (\\"2023-01-02\\", -5)]) ] assert total_growth(P, plant_data) == [19, 17] def test_total_growth_no_daily_records(): P = 1 plant_data = [ (0, 15, []) ] assert total_growth(P, plant_data) == [15] def test_total_growth_negative_growth(): P = 1 plant_data = [ (4, 12, [(\\"2022-12-01\\", -1), (\\"2022-12-02\\", -2), (\\"2022-12-03\\", -3), (\\"2022-12-04\\", -4)]) ] assert total_growth(P, plant_data) == [2] def test_total_growth_mixed_growth(): P = 1 plant_data = [ (3, 10, [(\\"2023-01-01\\", 0), (\\"2023-01-02\\", -10), (\\"2023-01-03\\", 20)]) ] assert total_growth(P, plant_data) == [20] def test_total_growth_single_day_record(): P = 1 plant_data = [ (1, 5, [(\\"2023-01-01\\", 3)]) ] assert total_growth(P, plant_data) == [8]","solution":"def total_growth(P, plant_data): Calculate the total growth achieved for each plant based on initial height and daily growth records. Args: P: int - number of plants plant_data: list of tuples, each tuple containing: - D: int - number of daily growth records - Hi: int - initial height of the plant - growth_records: list of tuples with each tuple containing: - date: str - the date of the daily record - dh: int - change in height for that day Returns: list of int - total growth for each plant over the entire period of records results = [] for data in plant_data: D, Hi, growth_records = data total_growth = Hi for record in growth_records: date, dh = record total_growth += dh results.append(total_growth) return results # Example input: # P = 2 # plant_data = [ # (3, 10, [(\\"2023-01-01\\", 5), (\\"2023-01-02\\", -3), (\\"2023-01-03\\", 7)]), # (2, 20, [(\\"2023-01-01\\", 2), (\\"2023-01-02\\", -5)]) # ] # Output: [19, 17]"},{"question":"def canPartition(arr: List[int]) -> bool: Given a list of non-negative integers arr, partition the list into two non-empty sublists such that the sum of the elements in the first sublist is equal to the sum of the elements in the second sublist. If it is not possible to partition the list this way, return false. Otherwise, return true. >>> canPartition([1, 5, 11, 5]) True >>> canPartition([1, 2, 3, 5]) False >>> canPartition([2, 2, 3, 5]) False import pytest from solution import canPartition def test_can_partition_example1(): arr = [1, 5, 11, 5] assert canPartition(arr) == True def test_can_partition_example2(): arr = [1, 2, 3, 5] assert canPartition(arr) == False def test_can_partition_example3(): arr = [2, 2, 3, 5] assert canPartition(arr) == False def test_can_partition_single_element(): arr = [10] assert canPartition(arr) == False def test_can_partition_two_elements_equal(): arr = [10, 10] assert canPartition(arr) == True def test_can_partition_two_elements_not_equal(): arr = [10, 5] assert canPartition(arr) == False def test_can_partition_multiple_elements(): arr = [3, 1, 1, 2, 2, 1] assert canPartition(arr) == True def test_can_partition_large_example(): arr = [1] * 200 assert canPartition(arr) == True","solution":"def canPartition(arr): total_sum = sum(arr) # If total_sum is odd, it's not possible to partition it into two equal sum sublists if total_sum % 2 != 0: return False target = total_sum // 2 n = len(arr) # DP array to store whether a sum up to target can be achieved dp = [False] * (target + 1) dp[0] = True for num in arr: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"def group_consecutive(numbers: List[int]) -> List[List[int]]: Given a list of integers, groups them into sublists of consecutive numbers. >>> group_consecutive([1, 2, 3, 7, 8, 10, 11, 12, 14]) [[1, 2, 3], [7, 8], [10, 11, 12], [14]] >>> group_consecutive([4, 5, 1, 2, 3, 10]) [[4, 5], [1, 2, 3], [10]]","solution":"def group_consecutive(numbers): Groups a list of integers into sublists of consecutive numbers. Parameters: numbers (list): A list of integers. Returns: list: A list of sublists where each sublist contains consecutive numbers. if not numbers: return [] grouped = [] temp_group = [numbers[0]] for i in range(1, len(numbers)): if numbers[i] == numbers[i-1] + 1: temp_group.append(numbers[i]) else: grouped.append(temp_group) temp_group = [numbers[i]] grouped.append(temp_group) return grouped"},{"question":"def sum_of_adjacent_differences(arr: list) -> int: Returns the sum of absolute differences between each adjacent pair of elements in the list. If the list has fewer than 2 elements, returns 0. >>> sum_of_adjacent_differences([1, 3, 6, 2]) 9 >>> sum_of_adjacent_differences([7, 2, 5]) 8 >>> sum_of_adjacent_differences([10]) 0","solution":"def sum_of_adjacent_differences(arr: list) -> int: Returns the sum of absolute differences between each adjacent pair of elements in the list. If the list has fewer than 2 elements, returns 0. if len(arr) < 2: return 0 total_diff = 0 for i in range(len(arr) - 1): total_diff += abs(arr[i] - arr[i + 1]) return total_diff"},{"question":"def longest_negative_product_subsequence_length(t: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Given a number of test cases each containing a sequence of integers, find the length of the longest subsequence where adjacent pairs of numbers have a product that is negative. >>> longest_negative_product_subsequence_length(3, [(6, [1, -2, 3, -4, 5, -6]), (5, [-1, -2, -3, -4, -5]), (4, [1, 2, 3, 4])]) [6, 1, 1] >>> longest_negative_product_subsequence_length(1, [(2, [3, -2])]) [2] >>> longest_negative_product_subsequence_length(1, [(4, [2, 4, 6, 8])]) [1] >>> longest_negative_product_subsequence_length(1, [(5, [-1, -2, -3, -4, -5])]) [1]","solution":"def longest_negative_product_subsequence_length(t, cases): results = [] for case in cases: n, sequence = case if n == 0: results.append(0) continue max_len = 1 current_len = 1 for i in range(1, n): if sequence[i] * sequence[i-1] < 0: current_len += 1 else: current_len = 1 max_len = max(max_len, current_len) results.append(max_len) return results"},{"question":"def max_completed_tasks(n, tasks): Given an integer n and a list of tuples tasks where each tuple contains two integers: the time T[i] and deadline D[i] for each task, determine the maximum number of tasks that can be successfully completed. >>> max_completed_tasks(3, [(3, 5), (8, 12), (4, 9)]) 2 >>> max_completed_tasks(4, [(2, 8), (5, 6), (1, 5), (4, 10)]) 3 pass # Below are some test cases to validate your solution def test_example_1(): tasks = [(3, 5), (8, 12), (4, 9)] assert max_completed_tasks(3, tasks) == 2 def test_example_2(): tasks = [(2, 8), (5, 6), (1, 5), (4, 10)] assert max_completed_tasks(4, tasks) == 3 def test_edge_case_min_values(): tasks = [(1, 1)] assert max_completed_tasks(1, tasks) == 1 def test_edge_case_large_values(): tasks = [(10**9, 10**9)] assert max_completed_tasks(1, tasks) == 1 def test_multiple_tasks_with_same_deadline(): tasks = [(2, 5), (1, 5), (3, 5)] assert max_completed_tasks(3, tasks) == 2 def test_all_tasks_uncompleted(): tasks = [(5, 4), (6, 5), (7, 6)] assert max_completed_tasks(3, tasks) == 0 def test_some_tasks_completed(): tasks = [(3, 10), (2, 6), (1, 5), (5, 8)] assert max_completed_tasks(4, tasks) == 3","solution":"def max_completed_tasks(n, tasks): This function takes in an integer n and a list of tuples tasks where each tuple contains two integers: the time T[i] and deadline D[i] for each task. It returns the maximum number of tasks that can be successfully completed. # Sort the tasks based on deadlines first, and then by their times to handle tie cases tasks.sort(key=lambda x: (x[1], x[0])) current_time = 0 completed_tasks = 0 for t, d in tasks: if current_time + t <= d: # If the task can be completed within its deadline current_time += t completed_tasks += 1 return completed_tasks"},{"question":"def process_requests(input_lines: List[str]) -> List[str]: Processes inventory updates and purchase requests for a bookstore. Args: input_lines (list of str): Each line describes an inventory update or a purchase request. - Inventory update: 'U book_id quantity' - Purchase request: 'P book_id quantity' Returns: list of str: The outcomes of the purchase requests with each line being one of: 'book_id successful', 'book_id out of stock', and 'book_id insufficient stock'. >>> process_requests([\\"U 101 3\\", \\"U 202 5\\", \\"P 101 2\\", \\"P 202 6\\", \\"P 303 1\\", \\"P 202 3\\"]) ['101 successful', '202 insufficient stock', '303 out of stock', '202 successful'] >>> process_requests([\\"U 101 10\\", \\"P 101 5\\", \\"P 101 5\\"]) ['101 successful', '101 successful'] >>> process_requests([\\"U 101 5\\", \\"P 101 6\\"]) ['101 insufficient stock'] >>> process_requests([\\"P 101 1\\"]) ['101 out of stock'] >>> process_requests([\\"U 101 3\\", \\"U 101 2\\", \\"P 101 4\\", \\"P 101 1\\"]) ['101 successful', '101 successful'] >>> process_requests([\\"U 101 3\\", \\"U 202 2\\", \\"P 202 2\\", \\"P 101 1\\", \\"P 101 2\\", \\"P 102 1\\"]) ['202 successful', '101 successful', '101 successful', '102 out of stock'] pass","solution":"def process_requests(input_lines): Processes inventory updates and purchase requests for a bookstore. Args: input_lines (list of str): Each line describes an inventory update or a purchase request. - Inventory update: 'U book_id quantity' - Purchase request: 'P book_id quantity' Returns: list of str: The outcomes of the purchase requests with each line being one of: 'book_id successful', 'book_id out of stock', and 'book_id insufficient stock'. inventory = {} results = [] for line in input_lines: parts = line.split() command, book_id, quantity = parts[0], int(parts[1]), int(parts[2]) if command == 'U': # Inventory update if book_id in inventory: inventory[book_id] += quantity else: inventory[book_id] = quantity elif command == 'P': # Purchase request if book_id not in inventory: results.append(f'{book_id} out of stock') elif inventory[book_id] < quantity: results.append(f'{book_id} insufficient stock') else: inventory[book_id] -= quantity results.append(f'{book_id} successful') return results"},{"question":"import re def validate_group_code(codes): Validates a list of group codes to check if each one follows the format of three uppercase letters followed by four digits (e.g., \\"ABC1234\\"). Args: codes (list of str): The list of group codes to validate. Returns: list of bool: A list of booleans indicating whether each group code is valid. Examples: >>> validate_group_code([\\"ABC1234\\", \\"AB12345\\", \\"XYZ6789\\"]) [True, False, True] >>> validate_group_code([\\"AB12345\\", \\"abc1234\\", \\"1234ABC\\"]) [False, False, False]","solution":"import re def validate_group_code(codes): Validates a list of group codes to check if each one follows the format of three uppercase letters followed by four digits (e.g., \\"ABC1234\\"). Args: codes (list of str): The list of group codes to validate. Returns: list of bool: A list of booleans indicating whether each group code is valid. pattern = re.compile(r'^[A-Z]{3}d{4}') return [bool(pattern.match(code)) for code in codes]"},{"question":"def is_critical_connection(n: int, m: int, connections: List[Tuple[int, int]]) -> str: Determines if removing any single connection results in any pair of stations becoming disconnected. >>> is_critical_connection(5, 5, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5)]) \\"YES\\" >>> is_critical_connection(4, 5, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4)]) \\"NO\\"","solution":"def is_critical_connection(n, m, connections): from collections import defaultdict def dfs(node, parent=None): nonlocal time discovery[node] = low[node] = time time += 1 for neighbor in graph[node]: if discovery[neighbor] == -1: # If neighbor is not visited children[node].append(neighbor) if dfs(neighbor, node): return True low[node] = min(low[node], low[neighbor]) if low[neighbor] > discovery[node]: # Found a critical connection return True elif neighbor != parent: # If neighbor is visited and not the parent of node low[node] = min(low[node], discovery[neighbor]) return False graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) discovery = [-1] * (n + 1) low = [-1] * (n + 1) children = defaultdict(list) time = 0 for station in range(1, n + 1): if discovery[station] == -1: # If station is not visited if dfs(station): return \\"YES\\" return \\"NO\\""},{"question":"def count_inversions(arr): Count inversions in the given array. :param arr: List of integers :return: Integer count of inversions >>> count_inversions([2, 3, 8, 6, 1]) 5 >>> count_inversions([1, 2, 3, 4]) 0 >>> count_inversions([5, 4, 3, 2, 1, 0]) 15 >>> count_inversions([1]) 0 >>> count_inversions([1, 3, 2, 3, 1]) 4 >>> count_inversions([1000000000, 999999999, 999999998, 1]) 6 pass","solution":"def count_inversions(arr): Count inversions in the given array. :param arr: List of integers :return: Integer count of inversions def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for the left subarray j = mid + 1 # Starting index for the right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: # There are mid - i inversions, because all the remaining elements in the left subarray # (arr[i+1], arr[i+2], ..., arr[mid]) are greater than arr[j] temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count n = len(arr) temp_arr = [0]*n return merge_sort_and_count(arr, temp_arr, 0, n-1)"},{"question":"from typing import List def sum_main_diagonal(matrix: List[List[int]]) -> int: Returns the sum of the elements in the main diagonal of the given matrix. Examples: >>> sum_main_diagonal([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 15 >>> sum_main_diagonal([[10, 2, 3, 4], [5, 20, 7, 8], [9, 10, 30, 15], [4, 3, 2, 40]]) 100 >>> sum_main_diagonal([[5]]) 5 >>> sum_main_diagonal([[8, 3], [1, 6]]) 14 >>> sum_main_diagonal([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) -15 >>> sum_main_diagonal([[1, -2, 3], [-4, 5, -6], [7, -8, 9]]) 15","solution":"from typing import List def sum_main_diagonal(matrix: List[List[int]]) -> int: Returns the sum of the elements in the main diagonal of the given matrix. return sum(matrix[i][i] for i in range(len(matrix)))"},{"question":"def longest_subarray_with_k_distinct(nums, k): Given an array of integers, return the length of the longest contiguous subarray that contains at most \`k\` distinct integers. >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) 4 >>> longest_subarray_with_k_distinct([1, 2, 1, 3, 4], 3) 4 >>> longest_subarray_with_k_distinct([1], 1) 1 >>> longest_subarray_with_k_distinct([1, 1, 1, 1], 1) 4 >>> longest_subarray_with_k_distinct([1, 2, 3, 4], 5) 4 >>> longest_subarray_with_k_distinct([], 1) 0 >>> longest_subarray_with_k_distinct([1, 2, 3, 4], 0) 0 >>> longest_subarray_with_k_distinct([2,1,2,3,4], 3) 4 >>> longest_subarray_with_k_distinct([4, 1, 1, 1, 3, 3, 3, 2], 2) 6","solution":"def longest_subarray_with_k_distinct(nums, k): from collections import defaultdict if k == 0: return 0 left = 0 max_length = 0 char_count = defaultdict(int) for right in range(len(nums)): char_count[nums[right]] += 1 while len(char_count) > k: char_count[nums[left]] -= 1 if char_count[nums[left]] == 0: del char_count[nums[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def find_pair_with_sum(test_cases): Given an array of integers, determine if there exists a pair of elements in the array whose sum is equal to a given target value. The function should return a string indicating whether such a pair exists with \\"Pair found\\" or \\"No pair found\\". >>> find_pair_with_sum([{'m': 4, 't': 6, 'arr': [1, 2, 3, 4]}]) [\\"Pair found\\"] >>> find_pair_with_sum([{'m': 5, 't': 10, 'arr': [1, 2, 3, 8, 5]}]) [\\"Pair found\\"] >>> find_pair_with_sum([{'m': 4, 't': 10, 'arr': [1, 2, 3, 4]}]) [\\"No pair found\\"] >>> find_pair_with_sum([{'m': 6, 't': 7, 'arr': [1, 2, 3, 4, 2, 5]}]) [\\"Pair found\\"] >>> find_pair_with_sum([{'m': 4, 't': 6, 'arr': [1, 2, 3, 4]}, {'m': 5, 't': 10, 'arr': [1, 2, 3, 8, 5]}]) [\\"Pair found\\", \\"Pair found\\"] >>> find_pair_with_sum([{'m': 3, 't': 8, 'arr': [1, 2, 5]}, {'m': 4, 't': 9, 'arr': [1, 2, 3, 4]}]) [\\"No pair found\\", \\"No pair found\\"]","solution":"def find_pair_with_sum(test_cases): results = [] for case in test_cases: m, t, arr = case['m'], case['t'], case['arr'] found = False seen = set() for number in arr: if t - number in seen: results.append(\\"Pair found\\") found = True break seen.add(number) if not found: results.append(\\"No pair found\\") return results # Example usage: # test_cases = [{'m': 4, 't': 6, 'arr': [1, 2, 3, 4]}, {'m': 5, 't': 10, 'arr': [1, 2, 3, 8, 5]}] # print(find_pair_with_sum(test_cases)) # Output: [\\"Pair found\\", \\"Pair found\\"]"},{"question":"import math from functools import reduce from itertools import combinations from typing import List, Tuple def max_total_efficiency(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Assign workers optimally into groups to maximize the total efficiency. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where the first integer is the number of workers and the second list contains the efficiencies of the workers for each test case. Returns: List[int]: A list of integers where each integer is the maximum total efficiency for each test case. Examples: >>> max_total_efficiency(2, [(4, [12, 15, 18, 24]), (3, [3, 6, 9])]) [69, 18] >>> max_total_efficiency(1, [(1, [7])]) [7] >>> max_total_efficiency(1, [(3, [10, 10, 10])]) [30] >>> max_total_efficiency(1, [(3, [2, 3, 5])]) [10] >>> max_total_efficiency(1, [(3, [7, 9, 11])]) [27]","solution":"import math from functools import reduce from itertools import combinations def max_total_efficiency(T, test_cases): results = [] for case in test_cases: N, efficiencies = case max_efficiency = sum(efficiencies) # All unique non-empty subsets of efficiencies for i in range(1, N): for subset in combinations(efficiencies, i): gcd_value = reduce(math.gcd, subset) remaining = [x for x in efficiencies if x not in subset] remaining_sum = sum(remaining) total_efficiency = gcd_value + remaining_sum if total_efficiency > max_efficiency: max_efficiency = total_efficiency results.append(max_efficiency) return results"},{"question":"def trap_rainwater(heights): Calculate the total volume of water trapped between blocks after a rain. Parameters: heights (list of int): A list of non-negative integers representing the heights of blocks. Returns: int: Total volume of water trapped. >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rainwater([4, 2, 0, 3, 2, 5]) 9 >>> trap_rainwater([3, 3, 3, 3]) 0 >>> trap_rainwater([1, 2, 3, 4]) 0 >>> trap_rainwater([4, 3, 2, 1]) 0 >>> trap_rainwater([5]) 0 >>> trap_rainwater([4, 5]) 0 >>> trap_rainwater([5, 4]) 0 >>> trap_rainwater([3, 0, 0, 3]) 6 >>> trap_rainwater([]) 0","solution":"def trap_rainwater(heights): Calculate the total volume of water trapped between blocks after a rain. Parameters: heights (list of int): A list of non-negative integers representing the heights of blocks. Returns: int: Total volume of water trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate trapped water water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def max_min_stolen_fruits(n: int, k: int, fruit_values: List[int]) -> Tuple[int, int]: Returns the maximum and minimum possible sum of the values of the k stolen fruits. Args: n : int - Total number of fruits. k : int - Number of stolen fruits. fruit_values : List[int] - Values of the fruits. Returns: Tuple[int, int] : Minimum and maximum possible sum of the values of the k stolen fruits. >>> max_min_stolen_fruits(5, 2, [3, 7, 2, 5, 8]) (5, 15) >>> max_min_stolen_fruits(4, 3, [10, 1, 5, 2]) (8, 17) >>> max_min_stolen_fruits(6, 4, [6, 5, 9, 8, 1, 3]) (15, 28) >>> max_min_stolen_fruits(1, 1, [1]) (1, 1) >>> max_min_stolen_fruits(6, 3, [4, 4, 4, 4, 4, 4]) (12, 12) >>> max_min_stolen_fruits(5, 3, [10, 20, 30, 40, 50]) (60, 120) >>> max_min_stolen_fruits(4, 2, [10, 8, 6, 4]) (10, 18)","solution":"def max_min_stolen_fruits(n, k, fruit_values): Returns the maximum and minimum possible sum of the values of the k stolen fruits. Args: n : int - Total number of fruits. k : int - Number of stolen fruits. fruit_values : list of int - Values of the fruits. Returns: tuple of int : Minimum and maximum possible sum of the values of the k stolen fruits. # Sort the fruit values sorted_values = sorted(fruit_values) # Minimum sum of k stolen fruits min_sum = sum(sorted_values[:k]) # Maximum sum of k stolen fruits max_sum = sum(sorted_values[-k:]) return (min_sum, max_sum)"},{"question":"def can_transform(str1: str, str2: str, k: int) -> str: Determines if it is possible to transform str1 into str2 using exactly k operations. Each operation can be either deleting the last character of str1 or appending any character to the end of str1. >>> can_transform(\\"abc\\", \\"def\\", 6) \\"Yes\\" >>> can_transform(\\"abc\\", \\"def\\", 4) \\"No\\"","solution":"def can_transform(str1, str2, k): Determines if it is possible to transform str1 into str2 using exactly k operations. Each operation can be either deleting the last character of str1 or appending any character to the end of str1. # Calculate the common length of the prefix of both strings common_length = 0 for c1, c2 in zip(str1, str2): if c1 == c2: common_length += 1 else: break # Calculate the number of operations needed total_ops = (len(str1) - common_length) + (len(str2) - common_length) # Check if the operations needed are less than or equal to k and the difference # between k and required operations should be even to allow for 'noop' operations return \\"Yes\\" if total_ops <= k and (k - total_ops) % 2 == 0 else \\"No\\""},{"question":"def calculate_total_score(scores): Calculates the total score of the student in the contest. :param scores: List of strings where each string is formatted as \\"x:y\\" :return: Total score as a float >>> calculate_total_score([\\"5:1\\", \\"3:1\\", \\"4:1\\"]) == 3 >>> calculate_total_score([\\"2:0.5\\", \\"3:0.5\\", \\"1:0.5\\"]) == 0.75 >>> calculate_total_score([\\"5:1\\", \\"3:0.5\\", \\"4:1\\", \\"2:0.5\\"]) == 2.5 >>> calculate_total_score([]) == 0.0 >>> calculate_total_score([\\"7:1\\"]) == 1.0 >>> calculate_total_score([\\"7:0.5\\"]) == 0.25","solution":"def calculate_total_score(scores): Calculates the total score of the student in the contest. :param scores: List of strings where each string is formatted as \\"x:y\\" :return: Total score as a float total_score = 0.0 for score in scores: x, y = score.split(':') x = float(x) y = float(y) if y == 1: total_score += y elif y == 0.5: total_score += y / 2 return total_score"},{"question":"def shift_string(n: int, s: str) -> str: Shift each alphabetic character in the string forward by n positions in the alphabet. Wrap around if necessary. Non-alphabetic characters remain unchanged. >>> shift_string(3, 'abc') 'def' >>> shift_string(3, 'xyz') 'abc' >>> shift_string(3, 'XYZ') 'ABC' >>> shift_string(3, 'abcXYZ123') 'defABC123' >>> shift_string(-3, 'defABC123') 'abcXYZ123'","solution":"def shift_string(n, s): def shift_char(c, n): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + n) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + n) % 26 + ord('A')) else: return c return ''.join(shift_char(c, n) for c in s)"},{"question":"from typing import List def minDaysToClimb(N: int, H: int, P: List[int]) -> int: Determine the minimum number of days required for John to climb at least H meters. Args: N (int): Number of days available. H (int): Total height John needs to climb. P (List[int]): List of integers where P[i] is the maximum possible height John can climb on the i-th day. Returns: int: Minimum number of days required to climb at least H meters. Examples: >>> minDaysToClimb(5, 100, [10, 20, 50, 30, 70]) 2 >>> minDaysToClimb(4, 90, [20, 20, 20, 20]) 5 # Your implementation here","solution":"def minDaysToClimb(N, H, P): P.sort(reverse=True) total_height = 0 days = 0 for height in P: total_height += height days += 1 if total_height >= H: return days # If we exhausted all climbing days but still didn't meet the height if total_height >= H: return days else: # Calculate how many extra days needed if not enough remaining_height = H - total_height extra_days = (remaining_height + max(P) - 1) // max(P) return days + extra_days"},{"question":"def can_make_equal(arr): Returns 'YES' if all elements in the array can be made equal using the given operations, otherwise returns 'NO'. >>> can_make_equal([2, 8, 4, 6]) == 'YES' >>> can_make_equal([4, 5, 6]) == 'NO' >>> can_make_equal([7, 7]) == 'YES' pass def process_test_cases(T, test_cases): Processes multiple test cases and returns a list of results. >>> process_test_cases(3, [(4, [2, 8, 4, 6]), (3, [4, 5, 6]), (2, [7, 7])]) == ['YES', 'NO', 'YES'] >>> process_test_cases(2, [(3, [2, 4, 6]), (3, [1, 3, 5])]) == ['YES', 'YES'] >>> process_test_cases(1, [(2, [1, 2])]) == ['NO'] pass","solution":"def can_make_equal(arr): Returns 'YES' if all elements in the array can be made equal by using the given operations, otherwise returns 'NO'. # Checking if all numbers have the same parity first_parity = arr[0] % 2 for num in arr: if num % 2 != first_parity: return 'NO' return 'YES' def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] A = test_cases[i][1] result = can_make_equal(A) results.append(result) return results"},{"question":"def longest_subsequence_with_max_diff_one(arr): Returns the length of the longest subsequence with the difference between the maximum and minimum elements at most 1. >>> longest_subsequence_with_max_diff_one([1, 2, 2, 3, 1]) 4 >>> longest_subsequence_with_max_diff_one([4, 6, 5, 3, 3]) 3 >>> longest_subsequence_with_max_diff_one([4, 4, 4, 4]) 4 >>> longest_subsequence_with_max_diff_one([1, 1, 1, 1, 2, 2, 2]) 7 >>> longest_subsequence_with_max_diff_one([10, 11, 12, 13, 14, 15, 15]) 3 >>> longest_subsequence_with_max_diff_one([]) 0 >>> longest_subsequence_with_max_diff_one([0, 0, 0, 1, 1, 1, 2, 2, 2]) 6 # Write your solution here def solve(test_cases): Returns a list with the result of each test case. >>> solve([(5, [1, 2, 2, 3, 1]), (5, [4, 6, 5, 3, 3])]) [4, 3] >>> solve([(4, [4, 4, 4, 4]), (7, [1, 1, 1, 1, 2, 2, 2]), (7, [10, 11, 12, 13, 14, 15, 15])]) [4, 7, 3] # Write your solution here","solution":"def longest_subsequence_with_max_diff_one(arr): Returns the length of the longest subsequence with the difference between the maximum and minimum elements at most 1. from collections import Counter if not arr: return 0 counts = Counter(arr) max_length = 0 for num in counts: # Length of subsequence made of \`num\` and \`num + 1\` current_length = counts[num] + counts.get(num + 1, 0) max_length = max(max_length, current_length) return max_length def solve(test_cases): results = [] for n, a in test_cases: results.append(longest_subsequence_with_max_diff_one(a)) return results"},{"question":"def adjust_time_slots(n: int, slots: List[List[int]]) -> List[List[int]]: Ensure no two booked time slots overlap. If an overlapping time slot is found, adjust it to the nearest available time slot. Args: n (int): Number of booked time slots. slots (List[List[int]]): List of time slots, each defined by a start and end time in minutes. Returns: List[List[int]]: Adjusted time slots with no overlaps. Examples: >>> adjust_time_slots(3, [[10, 20], [15, 25], [30, 40]]) [[10, 20], [20, 25], [30, 40]] >>> adjust_time_slots(2, [[10, 20], [15, 25]]) [[10, 20], [20, 30]] import pytest def test_no_overlap(): slots = [[10, 20], [30, 40], [50, 60]] assert adjust_time_slots(3, slots) == [[10, 20], [30, 40], [50, 60]] def test_single_overlap(): slots = [[10, 20], [15, 25]] assert adjust_time_slots(2, slots) == [[10, 20], [20, 30]] def test_multiple_overlaps(): slots = [[10, 20], [15, 25], [20, 30]] assert adjust_time_slots(3, slots) == [[10, 20], [20, 30], [30, 40]] def test_complex_overlaps(): slots = [[10, 20], [15, 25], [20, 25], [30, 40]] assert adjust_time_slots(4, slots) == [[10, 20], [20, 30], [30, 35], [35, 45]] def test_large_numbers(): slots = [[0, 100000000], [50000000, 150000000]] assert adjust_time_slots(2, slots) == [[0, 100000000], [100000000, 200000000]] def test_all_same_slots(): slots = [[10, 20], [10, 20], [10, 20]] assert adjust_time_slots(3, slots) == [[10, 20], [20, 30], [30, 40]]","solution":"def adjust_time_slots(n, slots): # First, sort the slots based on the starting time slots.sort(key=lambda x: x[0]) # Initialize the result list with the first slot result = [slots[0]] # Iterate over the remaining slots to adjust them for i in range(1, n): prev_slot = result[-1] current_slot = slots[i] # If the current slot overlaps with the previous one if current_slot[0] < prev_slot[1]: # Adjust the start and end times of the current slot new_start = prev_slot[1] new_end = new_start + (current_slot[1] - current_slot[0]) result.append([new_start, new_end]) else: # No overlap, keep the current slot as is result.append(current_slot) return result"},{"question":"def removeDuplicatesAndSort(S: str) -> str: Removes all duplicate characters from the string S and returns the resulting string in sorted order. Expected Time Complexity: O(NLogN). Expected Auxiliary Space: O(N). Constraints: 1 ≤ |S| ≤ 10^5 S consists of lowercase English letters only. >>> removeDuplicatesAndSort(\\"banana\\") 'abn' >>> removeDuplicatesAndSort(\\"apple\\") 'aelp'","solution":"def removeDuplicatesAndSort(S): Removes all duplicate characters from the string S and returns the resulting string in sorted order. # Use a set to remove duplicates unique_chars = set(S) # Convert the set back to a list and sort it sorted_unique_chars = sorted(unique_chars) # Join the sorted characters to form the resulting string result = ''.join(sorted_unique_chars) return result"},{"question":"def flatten_json(json_obj: dict) -> dict: Takes a JSON-like dictionary object and returns a new dictionary with all nested structures flattened. The keys in the flattened dictionary represent the path taken through the nested structure using periods (.) as separators. >>> flatten_json({ ... \\"user\\": { ... \\"name\\": \\"Alex\\", ... \\"address\\": { ... \\"street\\": \\"123 Maple Street\\", ... \\"city\\": \\"Metropolis\\", ... \\"zip\\": \\"10001\\" ... } ... }, ... \\"items\\": [ ... {\\"item_id\\": 1, \\"description\\": \\"A book\\"}, ... {\\"item_id\\": 2, \\"description\\": \\"A pen\\"} ... ] ... }) { \\"user.name\\": \\"Alex\\", \\"user.address.street\\": \\"123 Maple Street\\", \\"user.address.city\\": \\"Metropolis\\", \\"user.address.zip\\": \\"10001\\", \\"items.0.item_id\\": 1, \\"items.0.description\\": \\"A book\\", \\"items.1.item_id\\": 2, \\"items.1.description\\": \\"A pen\\" } >>> flatten_json({}) {} >>> flatten_json({\\"key1\\": \\"value1\\", \\"key2\\": \\"value2\\"}) {\\"key1\\": \\"value1\\", \\"key2\\": \\"value2\\"}","solution":"def flatten_json(json_obj, parent_key='', sep='.'): items = [] for k, v in json_obj.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_json(v, new_key, sep=sep).items()) elif isinstance(v, list): for i, item in enumerate(v): items.extend(flatten_json({str(i): item}, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def custom_sequence(signature, function, iterations): This function generates a custom sequence by iteratively applying a given function. :param signature: List[int]: The initial sequence values. :param function: Function[int, int]: The function to apply iteratively to generate new values. :param iterations: int: The total number of iterations to perform. :return: int: The value of the sequence after the specified number of iterations. # Implementation goes here # Example usage: increment_by_one = lambda x: x + 1 multiply_by_two = lambda x: x * 2 print(custom_sequence([1], increment_by_one, 5)) # Output: 6 print(custom_sequence([2], multiply_by_two, 3)) # Output: 16 Unit Test: from solution import custom_sequence def increment_by_one(x): return x + 1 def multiply_by_two(x): return x * 2 def test_custom_sequence_increase_by_one(): assert custom_sequence([1], increment_by_one, 5) == 6 def test_custom_sequence_multiply_by_two(): assert custom_sequence([2], multiply_by_two, 3) == 16 def test_custom_sequence_iteration_zero(): assert custom_sequence([10], increment_by_one, 0) == 10 def test_custom_sequence_negative_iterations(): assert custom_sequence([3], increment_by_one, -2) == 3 def test_custom_sequence_varied_function(): def add_five(x): return x + 5 assert custom_sequence([0], add_five, 4) == 20 def test_custom_sequence_initial_empty_signature(): try: custom_sequence([], increment_by_one, 3) except IndexError: assert True else: assert False def test_custom_sequence_initial_with_multiple_elements_signature(): assert custom_sequence([1, 3, 5, 7], increment_by_one, 2) == 9","solution":"def custom_sequence(signature, function, iterations): This function generates a custom sequence by iteratively applying a given function. :param signature: List[int]: The initial sequence values. :param function: Function[int, int]: The function to apply iteratively to generate new values. :param iterations: int: The total number of iterations to perform. :return: int: The value of the sequence after the specified number of iterations. current_value = signature[-1] for _ in range(iterations): current_value = function(current_value) return current_value"},{"question":"def sum_of_odd_digits(n: int) -> int: Returns the sum of all odd digits present in the integer n. >>> sum_of_odd_digits(123456) 9 >>> sum_of_odd_digits(-789) 16 >>> sum_of_odd_digits(2468) 0 >>> sum_of_odd_digits(0) 0","solution":"def sum_of_odd_digits(n): Returns the sum of all odd digits present in the integer n. # Convert the integer to a string to iterate over each digit. n_str = str(abs(n)) odd_sum = 0 # Iterate through each character in the string representation of the number. for char in n_str: digit = int(char) if digit % 2 != 0: odd_sum += digit return odd_sum"},{"question":"def isKPalindromePossible(s: str, k: int) -> bool: Given a string s and an integer k, determine whether it is possible to rearrange the characters in s to form a palindrome string such that each palindrome string has exactly k distinct characters. >>> isKPalindromePossible(\\"aabbcc\\", 3) == True >>> isKPalindromePossible(\\"aabbccc\\", 2) == False >>> isKPalindromePossible(\\"aabb\\", 2) == True","solution":"def isKPalindromePossible(s, k): from collections import Counter # Count the frequency of each character freq = Counter(s) # Count characters with odd frequency odd_count = sum(1 for count in freq.values() if count % 2 == 1) # Check if we can form a palindrome if odd_count > 1: return False # Check if the number of distinct characters in string matches k distinct_chars = len(freq) return distinct_chars == k"},{"question":"def maximum_toll_booths(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Find the maximum number of toll booths that can be placed in the city without any two toll roads being directly connected. >>> maximum_toll_booths(4, 4, [(1, 2, 5), (2, 3, 10), (3, 4, 3), (4, 1, 2)]) 2 >>> maximum_toll_booths(5, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4)]) 2 >>> maximum_toll_booths(2, 1, [(1, 2, 1)]) 1 >>> maximum_toll_booths(1, 0, []) 0 >>> maximum_toll_booths(6, 3, [(1, 2, 2), (3, 4, 2), (5, 6, 2)]) 3","solution":"def maximum_toll_booths(n, m, roads): from collections import defaultdict def bpm(u, matchR, seen): for v in bipartite[u]: if not seen[v]: seen[v] = True if matchR[v] == -1 or bpm(matchR[v], matchR, seen): matchR[v] = u return True return False bipartite = defaultdict(list) intervals = [] for u, v, t in roads: intervals.append((u, v)) bipartite[u].append(v) bipartite[v].append(u) matchR = [-1] * (n + 1) result = 0 for i in range(1, n + 1): seen = [False] * (n + 1) if bpm(i, matchR, seen): result += 1 return result // 2"},{"question":"def sum_of_triples(nums): Returns the sum of all unique triplets in the list that sum up to zero. >>> sum_of_triples([1, -1, 2, -2, 0]) 0 >>> sum_of_triples([-1, 0, 1, 2, -1, -4]) 0 from solution import sum_of_triples def test_sum_of_triples_example1(): assert sum_of_triples([1, -1, 2, -2, 0]) == 0 def test_sum_of_triples_example2(): assert sum_of_triples([-1, 0, 1, 2, -1, -4]) == 0 def test_sum_of_triples_no_triplets(): assert sum_of_triples([1, 2, -2, -1]) == 0 def test_sum_of_triples_all_zeros(): assert sum_of_triples([0, 0, 0, 0]) == 0 def test_sum_of_triples_multiple_triplets(): assert sum_of_triples([-2, 0, 0, 2, -2, 2]) == 0 def test_sum_of_triples_duplicates_in_input(): assert sum_of_triples([-1, -1, 0, 1, 1]) == 0 def test_sum_of_triples_mixed_values(): assert sum_of_triples([-1, -2, 3, 2, 0, 1]) == 0","solution":"def sum_of_triples(nums): Returns the sum of all unique triplets in the list that sum up to zero. nums.sort() triplet_sums = set() for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left = i + 1 right = len(nums) - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: triplet_sums.add((nums[i], nums[left], nums[right])) # Move past duplicates while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 # Sum each triplet and return the total sum return sum(sum(triplet) for triplet in triplet_sums)"},{"question":"def library_fines(input_data: str) -> str: Determine if all books have been returned within their loan periods. If any book is returned late, return \\"FINE\\". Otherwise, return \\"ALL RETURNED\\". >>> library_fines(\\"2n201 20 15n202 10 10n\\") 'ALL RETURNED' >>> library_fines(\\"3n101 14 10n102 7 5n103 30 35n\\") 'FINE'","solution":"def check_book_loans(N, loans): for loan in loans: ID, D, R = loan if R > D: return \\"FINE\\" return \\"ALL RETURNED\\" def library_fines(input_data): lines = input_data.strip().split('n') N = int(lines[0]) loans = [tuple(map(int, line.split())) for line in lines[1:N+1]] return check_book_loans(N, loans)"},{"question":"def top_selling_products_by_category(products): Returns a dictionary with the top-selling product for each category from the input list of products. Parameters: products (list): A list of dictionaries, where each dictionary contains 'name', 'category', and 'sales' keys. Returns: dict: A dictionary where each key is a category name and the value is the name of the top-selling product in that category. Example: >>> top_selling_products_by_category([ ... {'name': 'Product A', 'category': 'Electronics', 'sales': 150}, ... {'name': 'Product B', 'category': 'Electronics', 'sales': 200}, ... {'name': 'Product C', 'category': 'Books', 'sales': 120}, ... {'name': 'Product D', 'category': 'Books', 'sales': 85}, ... {'name': 'Product E', 'category': 'Clothing', 'sales': 250}, ... {'name': 'Product F', 'category': 'Clothing', 'sales': 300} ... ]) == { ... 'Electronics': 'Product B', ... 'Books': 'Product C', ... 'Clothing': 'Product F' ... }","solution":"def top_selling_products_by_category(products): Returns a dictionary with the top-selling product for each category from the input list of products. Parameters: products (list): A list of dictionaries, where each dictionary contains 'name', 'category', and 'sales' keys. Returns: dict: A dictionary where each key is a category name and the value is the name of the top-selling product in that category. category_top_sellers = {} for product in products: category = product['category'] name = product['name'] sales = product['sales'] if category not in category_top_sellers or category_top_sellers[category]['sales'] < sales: category_top_sellers[category] = {'name': name, 'sales': sales} return {category: top['name'] for category, top in category_top_sellers.items()}"},{"question":"def calculate_discount(months: int, yearly_spent: float, fixed_discount: int, extra_discount: int) -> int: Calculate the total discount percentage based on loyalty and expenditure. :param months: int - Number of months the customer has been purchasing from the company :param yearly_spent: float - Total amount spent by the customer in the past year :param fixed_discount: int - Fixed percentage discount for loyal customers :param extra_discount: int - Additional percentage discount for high spending customers :return: int - Total discount percentage the customer will receive >>> calculate_discount(7, 1200.50, 20, 10) == 30 >>> calculate_discount(5, 900.75, 15, 5) == 0 >>> calculate_discount(8, 950.00, 15, 10) == 15 >>> calculate_discount(4, 1200.00, 20, 15) == 15 >>> calculate_discount(3, 500.00, 10, 5) == 0 >>> calculate_discount(1, 0.0, 0, 0) == 0 >>> calculate_discount(12, 10000.0, 100, 100) == 200","solution":"def calculate_discount(months: int, yearly_spent: float, fixed_discount: int, extra_discount: int) -> int: Calculate the total discount percentage based on loyalty and expenditure. :param months: int - Number of months the customer has been purchasing from the company :param yearly_spent: float - Total amount spent by the customer in the past year :param fixed_discount: int - Fixed percentage discount for loyal customers :param extra_discount: int - Additional percentage discount for high spending customers :return: int - Total discount percentage the customer will receive total_discount = 0 if months > 6: total_discount += fixed_discount if yearly_spent > 1000: total_discount += extra_discount return total_discount"},{"question":"def sort_primes_first(lst): Given an input list of integers, return the list sorted in ascending order but with all prime numbers at the beginning of the list, followed by non-prime numbers. Preserve the original relative order of all prime and non-prime numbers within their respective sections. >>> sort_primes_first([11, 4, 7, 10, 3, 8, 14]) [11, 7, 3, 4, 10, 8, 14] >>> sort_primes_first([5, 8, 7, 10, 2, 4, 1]) [5, 7, 2, 8, 10, 4, 1]","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def sort_primes_first(lst): Sort the list with prime numbers first while preserving the relative order of the primes and non-primes. primes = [x for x in lst if is_prime(x)] non_primes = [x for x in lst if not is_prime(x)] return primes + non_primes"},{"question":"from typing import List, Tuple def shortestAlternatingPaths(n: int, m: int, edges: List[Tuple[int, int, str]]) -> List[int]: Alice wants to find the shortest path from vertex 1 to every other vertex in the graph, following the alternating colors rule. >>> shortestAlternatingPaths(4, 5, [(1, 2, 'red'), (1, 3, 'blue'), (2, 3, 'red'), (2, 4, 'blue'), (3, 4, 'red')]) [0, 1, 1, 2] >>> shortestAlternatingPaths(5, 4, [(1, 2, 'red'), (2, 3, 'blue'), (3, 4, 'red'), (4, 5, 'blue')]) [0, 1, 2, 3, 4] >>> shortestAlternatingPaths(3, 0, []) [0, -1, -1] >>> shortestAlternatingPaths(4, 4, [(1, 2, 'red'), (1, 3, 'blue'), (2, 4, 'blue'), (3, 4, 'red')]) [0, 1, 1, 2] >>> shortestAlternatingPaths(6, 6, [(1, 2, 'red'), (2, 3, 'blue'), (4, 5, 'red'), (5, 6, 'blue')]) [0, 1, 2, -1, -1, -1]","solution":"from collections import deque def shortestAlternatingPaths(n, m, edges): # create the adjacency list for red and blue edges red_adjacency = [[] for _ in range(n + 1)] blue_adjacency = [[] for _ in range(n + 1)] for u, v, c in edges: if c == 'red': red_adjacency[u].append(v) else: blue_adjacency[u].append(v) # distances array, initialize with -1 distances = [-1] * (n + 1) distances[1] = 0 # queue for BFS, storing (node, step, color: 0 for red, 1 for blue) q = deque() q.append((1, 0, 0)) # start node with red color q.append((1, 0, 1)) # start node with blue color # visited set to avoid repeated state visited = set() visited.add((1, 0)) visited.add((1, 1)) while q: node, step, color = q.popleft() # next color to use next_color = 1 - color # determine the adjacent edges based on next color if next_color == 0: adj = red_adjacency else: adj = blue_adjacency for neighbor in adj[node]: if (neighbor, next_color) not in visited: visited.add((neighbor, next_color)) distances[neighbor] = step + 1 if distances[neighbor] == -1 else min(distances[neighbor], step + 1) q.append((neighbor, step + 1, next_color)) return distances[1:]"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths from the top-left to the bottom-right corner of a grid of size M x N. Args: m (int): number of rows n (int): number of columns Returns: int: total number of unique paths >>> unique_paths(3, 7) 28 >>> unique_paths(1, 1) 1 >>> unique_paths(2, 2) 2 >>> unique_paths(3, 3) 6 >>> unique_paths(4, 4) 20 >>> unique_paths(5, 5) 70 >>> unique_paths(10, 10) 48620","solution":"def unique_paths(m, n): Calculate the number of unique paths from the top-left to the bottom-right corner of a grid of size M x N. Args: m (int): number of rows n (int): number of columns Returns: int: total number of unique paths # Create a 2D array initialized to 1 for the base cases dp = [[1] * n for _ in range(m)] # Fill the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def longest_increasing_subsequence(heights: List[int]) -> int: Returns the length of the longest increasing subsequence. >>> longest_increasing_subsequence([5, 3, 4, 8, 6, 7]) 4 >>> longest_increasing_subsequence([4]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> longest_increasing_subsequence([10, 10, 10, 10]) 1 >>> longest_increasing_subsequence([1, 3, 2, 4, 3, 5, 4]) 4","solution":"def longest_increasing_subsequence(heights): Returns the length of the longest increasing subsequence. if not heights: return 0 n = len(heights) lis = [1] * n for i in range(1, n): for j in range(i): if heights[i] > heights[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis) # Example usage # n = 6 # heights = [5, 3, 4, 8, 6, 7] # print(longest_increasing_subsequence(heights)) # Output: 4"},{"question":"def rearrangeString(s: str) -> str: Determine if it is possible to rearrange the characters of string s such that no two consecutive characters are the same. Args: s (str): the input string Returns: str: the rearranged string or \\"Not Possible\\" >>> rearrangeString(\\"aabb\\") 'abab' >>> rearrangeString(\\"aaab\\") 'Not Possible'","solution":"from collections import Counter import heapq def rearrangeString(s): # Count frequencies of each character freq = Counter(s) max_heap = [] # Push all characters and their counts into a max_heap for char, count in freq.items(): heapq.heappush(max_heap, (-count, char)) prev_char, prev_count = '', 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char, prev_count = char, count + 1 result_str = ''.join(result) # Check if the rearranged string has the same length as input if len(result_str) == len(s): return result_str else: return \\"Not Possible\\""},{"question":"def nthFibonacci(N: int) -> int: Returns the Nth Fibonacci number. The function uses an efficient approach to handle larger values of N. >>> nthFibonacci(5) 5 >>> nthFibonacci(10) 55","solution":"def nthFibonacci(N): Returns the Nth Fibonacci number using an iterative approach which is efficient in terms of space and time. if N <= 0: return 0 elif N == 1: return 1 a, b = 0, 1 for _ in range(2, N + 1): a, b = b, a + b return b"},{"question":"def min_adjacent_swaps_to_sort(N: int, array: List[int]) -> int: Calculate the minimum number of adjacent swaps needed to sort the array. Parameters: N (int): The number of elements in the array. array (List[int]): The list of integers to be sorted. Returns: int: The minimum number of adjacent swaps required to sort the array. >>> min_adjacent_swaps_to_sort(4, [4, 3, 2, 1]) 6 >>> min_adjacent_swaps_to_sort(5, [1, 5, 4, 3, 2]) 6 >>> min_adjacent_swaps_to_sort(5, [5, 4, 3, 2, 1]) 10 >>> min_adjacent_swaps_to_sort(3, [3, 2, 1]) 3 >>> min_adjacent_swaps_to_sort(5, [1, 2, 3, 4, 5]) 0 >>> min_adjacent_swaps_to_sort(1, [1]) 0 >>> min_adjacent_swaps_to_sort(5, [2, 3, 4, 5, 1]) 4 >>> min_adjacent_swaps_to_sort(6, [6, 5, 4, 3, 2, 1]) 15","solution":"def min_adjacent_swaps_to_sort(N, array): Calculate the minimum number of adjacent swaps needed to sort the array. def merge_sort_with_count(arr): if len(arr) <= 1: return arr, 0 mid = len(arr) // 2 left, left_swaps = merge_sort_with_count(arr[:mid]) right, right_swaps = merge_sort_with_count(arr[mid:]) merged, merge_swaps = merge_and_count(left, right) return merged, left_swaps + right_swaps + merge_swaps def merge_and_count(left, right): merged = [] i = j = swaps = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 swaps += len(left) - i # Number of remaining elements in left merged.extend(left[i:]) merged.extend(right[j:]) return merged, swaps _, swap_count = merge_sort_with_count(array) return swap_count"},{"question":"def min_moves_to_palindrome(n, s): Determine the minimum number of moves required to make the binary string a palindrome. Args: n (int): Length of the string. s (str): Binary string of length n. Returns: int: The minimum number of moves. def solve(test_cases): Determine the minimum number of moves required to make each binary string in test cases a palindrome. Args: test_cases (List[Tuple[int, str]]): List of tuples each containing the length of binary string and the string itself. Returns: List[int]: List containing the minimum number of moves for each test case. # Example unit tests def test_min_moves_to_palindrome(): assert min_moves_to_palindrome(5, \\"11001\\") == 1 assert min_moves_to_palindrome(4, \\"1001\\") == 0 assert min_moves_to_palindrome(6, \\"101011\\") == 1 assert min_moves_to_palindrome(1, \\"0\\") == 0 assert min_moves_to_palindrome(2, \\"01\\") == 1 assert min_moves_to_palindrome(3, \\"010\\") == 0 assert min_moves_to_palindrome(4, \\"0000\\") == 0 def test_solve(): test_cases = [ (5, \\"11001\\"), (4, \\"1001\\"), (6, \\"101011\\") ] assert solve(test_cases) == [1, 0, 1] test_cases = [ (1, \\"0\\"), (2, \\"01\\"), (3, \\"010\\") ] assert solve(test_cases) == [0, 1, 0]","solution":"def min_moves_to_palindrome(n, s): Determine the minimum number of moves required to make the binary string a palindrome. Args: n (int): Length of the string. s (str): Binary string of length n. Returns: int: The minimum number of moves. count = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: count += 1 return (count + 1) // 2 def solve(test_cases): results = [] for n, s in test_cases: results.append(min_moves_to_palindrome(n, s)) return results"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Finds the shortest path in a 5x5 grid from the top-left corner to the bottom-right corner. Returns the length of the shortest path or -1 if no path exists. >>> shortest_path([ >>> [0, 0, 1, 0, 0], >>> [0, 1, 0, 1, 0], >>> [0, 0, 0, 0, 1], >>> [1, 0, 1, 0, 0], >>> [0, 0, 0, 1, 0] >>> ]) 8 >>> shortest_path([ >>> [0, 0, 1, 0, 0], >>> [1, 1, 1, 1, 1], >>> [0, 0, 0, 0, 1], >>> [1, 0, 1, 0, 1], >>> [0, 0, 0, 1, 0] >>> ]) -1","solution":"from collections import deque def shortest_path(grid): Finds the shortest path in a 5x5 grid from the top-left corner to the bottom-right corner. Returns the length of the shortest path or -1 if no path exists. rows, cols = 5, 5 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right # Check if the start or end positions are blocked if grid[0][0] == 1 or grid[4][4] == 1: return -1 # Queue for BFS queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() # Check if we've reached the end if (x, y) == (4, 4): return dist # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) # If we exit the loop without finding a path return -1 # Example usage grid = [ [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 1], [1, 0, 1, 0, 0], [0, 0, 0, 1, 0] ] print(shortest_path(grid)) # Output: 8"},{"question":"def most_influential_users(T, test_cases): Determine the most influential user(s) in a social media platform based on unique interactions received. If multiple users meet the criteria, return the user(s) with the lowest user ID. Args: T (int): The number of test cases. test_cases (list): A list of tuples, where each tuple contains: - An integer N: the number of users. - An integer M: the number of interactions. - A list of M tuples: each containing two integers u and v representing an interaction. Returns: list: A list of integers representing the user ID of the most influential user for each test case. Example: >>> test_cases = [ ... (5, 4, [(1, 3), (2, 3), (2, 4), (1, 5)]), ... (4, 4, [(1, 2), (1, 3), (2, 3), (3, 2)]) ... ] >>> most_influential_users(2, test_cases) [3, 2] # Your code here. def test_single_test_case(): T = 1 test_cases = [ (5, 4, [(1, 3), (2, 3), (2, 4), (1, 5)]) ] result = most_influential_users(T, test_cases) assert result == [3] def test_multiple_influential_users(): T = 1 test_cases = [ (4, 4, [(1, 2), (1, 3), (2, 3), (3, 2)]) ] result = most_influential_users(T, test_cases) assert result == [2] # Since both user 2 and 3 have 2 unique interactions, the lowest ID is returned def test_no_interactions(): T = 1 test_cases = [ (3, 0, []) ] result = most_influential_users(T, test_cases) assert result == [1] # No interactions, so the smallest user ID (1) is the most influential by default def test_multiple_cases(): T = 2 test_cases = [ (5, 4, [(1, 3), (2, 3), (2, 4), (1, 5)]), (4, 4, [(1, 2), (1, 3), (2, 3), (3, 2)]) ] result = most_influential_users(T, test_cases) assert result == [3, 2] def test_large_input(): T = 1 N = 100 M = 1000 interactions = [(i, i % 10 + 1) for i in range(1, 1001)] test_cases = [ (N, M, interactions) ] result = most_influential_users(T, test_cases) assert result == [1] # since there's a pattern and all receive interactions equally, first id should be returned","solution":"def most_influential_users(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] M = test_cases[i][1] interactions = test_cases[i][2] interaction_count = {user: set() for user in range(1, N + 1)} for u, v in interactions: interaction_count[v].add(u) max_influencer = None max_interactions = 0 for user, interactors in interaction_count.items(): if len(interactors) > max_interactions: max_influencer = user max_interactions = len(interactors) elif len(interactors) == max_interactions: if max_influencer is None or user < max_influencer: max_influencer = user results.append(max_influencer) return results # The function to handle the input and output processing def main(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 test_cases = [] for _ in range(T): N = int(data[idx]) idx += 1 M = int(data[idx]) idx += 1 interactions = [] for _ in range(M): u = int(data[idx]) v = int(data[idx + 1]) interactions.append((u, v)) idx += 2 test_cases.append((N, M, interactions)) results = most_influential_users(T, test_cases) for res in results: print(res)"},{"question":"from typing import List, Tuple def find_steps_to_balance_load(t: int, test_cases: List[Tuple[int, int, List[int], List[Tuple[int, int]]]]) -> List[int]: Find the total number of operations required so that all nodes have the same load in a graph. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[int], List[Tuple[int, int]]]]): A list of test cases, where each test case is represented as a tuple containing: - The number of vertices \`n\` - The number of edges \`m\` - A list of initial loads on the vertices \`a\` - A list of edges, where each edge is a tuple \`(u, v)\` representing an undirected edge between nodes \`u\` and \`v\` Returns: List[int]: A list of integers where each integer is the number of steps required for all nodes to have the same load, or -1 if it's not possible. Example: >>> t = 1 >>> test_cases = [ (3, 3, [3, 1, 2], [(1, 2), (2, 3), (3, 1)]) ] >>> find_steps_to_balance_load(t, test_cases) [2] import pytest def test_case1(): t = 1 test_cases = [ (3, 3, [3, 1, 2], [(1, 2), (2, 3), (3, 1)]) ] assert find_steps_to_balance_load(t, test_cases) == [2] def test_case2(): t = 1 test_cases = [ (4, 5, [3, 5, 4, 6], [(1, 2), (2, 3), (3, 4), (4, 1), (3, 5)]) ] assert find_steps_to_balance_load(t, test_cases) == [-1] def test_case3(): t = 1 test_cases = [ (2, 0, [2, 0], []) ] assert find_steps_to_balance_load(t, test_cases) == [-1] def test_case4(): t = 1 test_cases = [ (5, 5, [1, 1, 1, 1, 1], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) ] assert find_steps_to_balance_load(t, test_cases) == [0] def test_multiple_cases(): t = 4 test_cases = [ (3, 3, [3, 1, 2], [(1, 2), (2, 3), (3, 1)]), (4, 5, [3, 5, 4, 6], [(1, 2), (2, 3), (3, 4), (4, 1), (3, 5)]), (2, 0, [2, 0], []), (5, 5, [1, 1, 1, 1, 1], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) ] assert find_steps_to_balance_load(t, test_cases) == [2, -1, -1, 0] if __name__ == \\"__main__\\": pytest.main()","solution":"def find_steps_to_balance_load(t, test_cases): results = [] for case in test_cases: n, m, loads, edges = case total_load = sum(loads) # Check if balancing is possible if total_load % n != 0: results.append(-1) continue target_load = total_load // n steps = 0 can_balance = True for _ in range(n): new_loads = loads[:] load_changed = False for u, v in edges: if loads[u-1] != loads[v-1]: load_change = (loads[u-1] - loads[v-1]) // 2 new_loads[u-1] -= load_change new_loads[v-1] += load_change load_changed = True # If no loads changed, it means we are already balanced if not load_changed: break loads = new_loads steps += 1 if all(load == target_load for load in loads): break if all(load == target_load for load in loads): results.append(steps) else: results.append(-1) return results"},{"question":"class ToDoItem: def __init__(self, title, description, due_date=None): self.title = title self.description = description self.due_date = due_date self.completed = False class ToDoManager: Class to manage to-do items. Supports adding, completing, and listing items based on certain criteria. def __init__(self): self.items = {} def add(self, title: str, description: str, due_date: str = None): Adds a new to-do item. The due date is optional and follows the format \`YYYY-MM-DD\`. If due date is not specified, it should be recorded as \`None\`. >>> manager = ToDoManager() >>> manager.add(\\"Test title\\", \\"Test description\\") >>> manager.add(\\"Test title 2\\", \\"Test description 2\\", \\"2023-11-03\\") >>> len(manager.items) 2 pass def complete(self, title: str): Marks the to-do item with the given title as completed. >>> manager = ToDoManager() >>> manager.add(\\"Test title\\", \\"Test description\\") >>> manager.complete(\\"Test title\\") >>> manager.items[\\"Test title\\"].completed True pass def list_items(self, option: str = \\"all\\") -> list: Lists to-do items based on the given option. >>> manager = ToDoManager() >>> manager.add(\\"Test title\\", \\"Test description\\") >>> manager.add(\\"Test title 2\\", \\"Test description 2\\") >>> result = manager.list_items(\\"all\\") >>> len(result) 2 >>> result = manager.list_items(\\"completed\\") >>> len(result) 0 >>> manager.complete(\\"Test title\\") >>> result = manager.list_items(\\"uncompleted\\") >>> len(result) 1 pass def process_input(commands: list): Processes the input commands to manage the to-do list. >>> commands = [ 'ADD \\"Buy groceries\\" \\"Buy milk, eggs, and bread\\" 2023-11-03', 'ADD \\"Read book\\" \\"Finish reading the current novel\\"', 'ADD \\"Prepare presentation\\" \\"Slides for Monday's meeting\\"', 'COMPLETE \\"Read book\\"', 'LIST all', 'EXIT' ] >>> process_input(commands) Title: Buy groceries, Description: Buy milk, eggs, and bread, Due Date: 2023-11-03, Status: Uncompleted Title: Read book, Description: Finish reading the current novel, Due Date: No due date, Status: Completed Title: Prepare presentation, Description: Slides for Monday's meeting, Due Date: No due date, Status: Uncompleted pass","solution":"class ToDoItem: def __init__(self, title, description, due_date=None): self.title = title self.description = description self.due_date = due_date self.completed = False class ToDoManager: def __init__(self): self.items = {} def add(self, title, description, due_date=None): item = ToDoItem(title, description, due_date) self.items[title] = item def complete(self, title): if title in self.items: self.items[title].completed = True def list_items(self, option=\\"all\\"): filtered_items = self.items.values() if option == \\"completed\\": filtered_items = filter(lambda item: item.completed, self.items.values()) elif option == \\"uncompleted\\": filtered_items = filter(lambda item: not item.completed, self.items.values()) result = [] for item in filtered_items: due_date = item.due_date if item.due_date else \\"No due date\\" status = \\"Completed\\" if item.completed else \\"Uncompleted\\" result.append(f\\"Title: {item.title}, Description: {item.description}, Due Date: {due_date}, Status: {status}\\") return result def process_input(commands): manager = ToDoManager() result = [] for command in commands: parts = command.split(\\" \\", 1) cmd = parts[0] if cmd == \\"EXIT\\": break elif cmd == \\"ADD\\": parts = command.split('\\"') title = parts[1] description = parts[3] due_date = parts[4].strip() if len(parts) > 4 else None manager.add(title, description, due_date) elif cmd == \\"COMPLETE\\": title = command.split('\\"')[1] manager.complete(title) elif cmd == \\"LIST\\": option = command.split(\\" \\")[1] if len(command.split(\\" \\")) > 1 else \\"all\\" result.append(\\"n\\".join(manager.list_items(option))) if result: print(\\"n\\".join(result)) # Example Usage commands = [ 'ADD \\"Buy groceries\\" \\"Buy milk, eggs, and bread\\" 2023-11-03', 'ADD \\"Read book\\" \\"Finish reading the current novel\\"', 'ADD \\"Prepare presentation\\" \\"Slides for Monday's meeting\\"', 'COMPLETE \\"Read book\\"', 'LIST all', 'EXIT' ] process_input(commands)"},{"question":"def generate_spiral_grid(N: int) -> List[List[int]]: Generates an N x N grid filled with numbers from 1 to N^2 in a clockwise spiral pattern. >>> generate_spiral_grid(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_grid(2) [[1, 2], [4, 3]]","solution":"def generate_spiral_grid(N): Generates an N x N grid filled with numbers from 1 to N^2 in a clockwise spiral pattern. grid = [[0] * N for _ in range(N)] direction = [(0, 1), (1, 0), (0, -1), (-1, 0)] current_direction = 0 row, col = 0, 0 current_value = 1 for _ in range(N * N): grid[row][col] = current_value current_value += 1 next_row = row + direction[current_direction][0] next_col = col + direction[current_direction][1] if next_row >= 0 and next_row < N and next_col >= 0 and next_col < N and grid[next_row][next_col] == 0: row, col = next_row, next_col else: current_direction = (current_direction + 1) % 4 row += direction[current_direction][0] col += direction[current_direction][1] return grid"},{"question":"from typing import List def gcd_subarray(n: int, q: int, array: List[int], queries: List[List[int]]) -> List[int]: Compute the greatest common divisor (GCD) of all the integers in a specified subarray of the list. n : int : the number of elements in the list q : int : the number of queries array : List[int] : the list of n integers queries : List[List[int]] : each query contains two integers, l and r, representing the range of the subarray (1 ≤ l ≤ r ≤ n) return : List[int] : a list of GCDs for each query >>> gcd_subarray(6, 3, [12, 15, 18, 21, 24, 27], [[2, 4], [1, 6], [3, 5]]) [3, 3, 3] >>> gcd_subarray(5, 2, [8, 16, 32, 64, 128], [[1, 3], [2, 5]]) [8, 16]","solution":"import math from typing import List def gcd_subarray(n: int, q: int, array: List[int], queries: List[List[int]]) -> List[int]: result = [] for l, r in queries: subarray_gcd = array[l-1] for i in range(l, r): subarray_gcd = math.gcd(subarray_gcd, array[i]) result.append(subarray_gcd) return result"},{"question":"def minOperations(S: str) -> int: Returns the minimum number of operations required to make the string alternate. Args: S: str - The input string consisting of '0's and '1's. Returns: int - The minimum number of operations required. Examples: >>> minOperations(\\"010101\\") 0 >>> minOperations(\\"1001\\") 2 >>> minOperations(\\"1111\\") 2","solution":"def minOperations(S): Returns the minimum number of operations required to make the string alternate. n = len(S) count1 = 0 # Count of flips when starting with '0' count2 = 0 # Count of flips when starting with '1' for i in range(n): if i % 2 == 0: if S[i] != '0': count1 += 1 if S[i] != '1': count2 += 1 else: if S[i] != '1': count1 += 1 if S[i] != '0': count2 += 1 return min(count1, count2)"},{"question":"def mirror_number(n: int) -> int: Returns the mirror image of a non-negative integer. Args: n (int): The non-negative integer to mirror. Returns: int: The mirrored image of the input number. >>> mirror_number(12345) 54321 >>> mirror_number(987654321) 123456789 >>> mirror_number(9) 9 >>> mirror_number(0) 0 >>> mirror_number(100) 1 >>> mirror_number(1000) 1","solution":"def mirror_number(n): Returns the mirror image of a non-negative integer. Args: n (int): The non-negative integer to mirror. Returns: int: The mirrored image of the input number. # Convert the number to a string str_num = str(n) # Reverse the string reversed_str = str_num[::-1] # Convert back to an integer to remove any leading zeros mirrored_number = int(reversed_str) return mirrored_number"},{"question":"from typing import List, Tuple def find_bottleneck_times(N: int, M: int, edges: List[Tuple[int, int, int]], Q: int, queries: List[Tuple[int, int]]) -> List[int]: A large company has a central server that connects all the computers in their network. Each node represents a computer, and each edge represents a direct connection between two computers. Each connection has an associated time in milliseconds it takes to transfer data between the two computers. The function calculates the bottleneck time (longest transfer time) for paths between various pairs of computers. Parameters: N (int): Number of nodes/computers M (int): Number of edges/connections edges (List[Tuple[int, int, int]]): List of edges with their transfer times Q (int): Number of pairs of nodes to find bottleneck times queries (List[Tuple[int, int]]): List of node pairs for which to find bottleneck times Returns: List[int]: Bottleneck times for the given node pairs. If nodes are not connected, return -1. Examples: >>> find_bottleneck_times(5, 6, [(1, 2, 4), (2, 3, 2), (1, 3, 6), (3, 4, 3), (4, 5, 5), (2, 5, 7)], 3, [(1, 4), (2, 5), (3, 1)]) [6, 7, 6] >>> find_bottleneck_times(4, 2, [(1, 2, 10), (3, 4, 20)], 2, [(1, 3), (2, 4)]) [-1, -1] >>> find_bottleneck_times(2, 1, [(1, 2, 10)], 1, [(1, 2)]) [10]","solution":"def find_bottleneck_times(N, M, edges, Q, queries): from collections import defaultdict, deque def bfs_max_edge(src, dest): BFS to find the max edge weight in the path between src and dest queue = deque([(src, -1)]) # (current_node, max_edge_weight) visited = [False] * (N + 1) visited[src] = True while queue: node, max_weight = queue.popleft() if node == dest: return max_weight for neighbor, weight in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, max(weight, max_weight))) return -1 # Build the graph using adjacency list graph = defaultdict(list) for u, v, t in edges: graph[u].append((v, t)) graph[v].append((u, t)) results = [] for a, b in queries: results.append(bfs_max_edge(a, b)) return results def parse_input(input): lines = input.strip().split('n') N, M = map(int, lines[0].split()) edges = [tuple(map(int, lines[i+1].split())) for i in range(M)] Q = int(lines[M+1]) queries = [tuple(map(int, lines[M+2+i].split())) for i in range(Q)] return N, M, edges, Q, queries"},{"question":"def construct_grid(n: int) -> List[List[int]]: Construct an n x n grid where each cell contains a positive integer such that the grid contains each integer from 1 to n exactly once, and integer k appears exactly k times consecutively in any direction (horizontally or vertically). Args: n (int): The size of the grid. Returns: List[List[int]]: The constructed n x n grid. Examples: >>> construct_grid(3) [[1, 1, 2], [1, 2, 3], [2, 3, 3]] >>> construct_grid(4) [[1, 1, 2, 2], [1, 3, 3, 3], [2, 3, 4, 4], [2, 4, 4, 4]] # Unit Tests from solution import construct_grid def test_construct_grid(): def test_grid(n, expected): grid = construct_grid(n) counts = [0] * (n + 1) for row in grid: for val in row: counts[val] += 1 for k in range(1, n + 1): assert counts[k] == k test_grid(1, [[1]]) test_grid(2, [[1, 1], [1, 2]]) test_grid(3, [[1, 1, 2], [1, 2, 3], [2, 3, 3]]) test_grid(4, [[1, 1, 2, 2], [1, 3, 3, 3], [2, 3, 4, 4], [2, 4, 4, 4]]) test_grid(5, [[1, 1, 2, 2, 3], [1, 3, 3, 3, 3], [2, 4, 4, 4, 4], [2, 5, 5, 5, 5], [3, 4, 4, 5, 5]]) test_construct_grid()","solution":"def construct_grid(n): def is_valid(x, y, grid): return 0 <= x < n and 0 <= y < n and grid[x][y] == 0 grid = [[0]*n for _ in range(n)] for num in range(1, n+1): placed = False for i in range(n): if placed: break for j in range(n): if placed: break # Try Horizontal Placement if j + num <= n and all(grid[i][j+k] == 0 for k in range(num)): for k in range(num): grid[i][j+k] = num placed = True # Try Vertical Placement elif i + num <= n and all(grid[i+k][j] == 0 for k in range(num)): for k in range(num): grid[i+k][j] = num placed = True return grid # Example usage n = 3 result = construct_grid(n) for row in result: print(' '.join(map(str, row)))"},{"question":"def fibonacci_sequence(n: int) -> List[int]: Returns a list containing the first n terms of the Fibonacci sequence. The sequence starts with 0 and 1. Return an empty list if n <= 0. >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(7) [0, 1, 1, 2, 3, 5, 8] >>> fibonacci_sequence(0) [] >>> fibonacci_sequence(-3) [] >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci_sequence(n): Returns a list containing the first n terms of the Fibonacci sequence. The sequence starts with 0 and 1. Return an empty list if n <= 0. if n <= 0: return [] sequence = [0, 1] for i in range(2, n): next_term = sequence[-1] + sequence[-2] sequence.append(next_term) return sequence[:n]"},{"question":"def min_task_time_difference(n: int, tasks: List[int]) -> int: Returns the minimum possible difference in total times taken by each processor. Args: n (int): number of tasks tasks (List[int]): list of integers, each representing the duration of a task Returns: int: minimum difference in total time taken by each processor Examples: >>> min_task_time_difference(5, [2, 3, 7, 1, 4]) 1 >>> min_task_time_difference(1, [10]) 10 >>> min_task_time_difference(2, [8, 8]) 0 >>> min_task_time_difference(2, [5, 8]) 3 >>> min_task_time_difference(3, [1, 10, 16]) 5 >>> min_task_time_difference(6, [5, 2, 7, 3, 6, 1]) 0","solution":"def min_task_time_difference(n, tasks): Returns the minimum possible difference in total times taken by each processor. :param n: Integer, number of tasks :param tasks: List of integers, each representing the duration of a task :return: Integer, minimum difference in total time taken by each processor # Calculate the total sum of all tasks total_sum = sum(tasks) # Initialize a DP table dp = [False] * (total_sum + 1) dp[0] = True # Update the DP table for each task for task in tasks: for j in range(total_sum, task - 1, -1): if dp[j - task]: dp[j] = True # Find the closest sum to half of the total sum half_sum = total_sum // 2 for i in range(half_sum, -1, -1): if dp[i]: return total_sum - 2 * i"},{"question":"def min_subset_sum_difference(T: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Partition the given set into two subsets such that the absolute difference between their sums is as small as possible. >>> min_subset_sum_difference(2, [(4, [1, 6, 11, 5]), (3, [1, 2, 3])]) [1, 0] >>> min_subset_sum_difference(1, [(4, [1, 1, 1, 1])]) [0]","solution":"def min_subset_sum_difference(T, cases): def find_min_difference(arr, n): total_sum = sum(arr) dp = [[False for _ in range(total_sum // 2 + 1)] for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if arr[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] else: dp[i][j] = dp[i-1][j] min_diff = float('inf') for j in range(total_sum // 2, -1, -1): if dp[n][j] == True: min_diff = abs(total_sum - 2 * j) break return min_diff results = [] for N, A in cases: results.append(find_min_difference(A, N)) return results"},{"question":"def solveQueries(nums, queries): Returns the sum of subarrays specified by the given queries. Parameters: nums (list): List of integers queries (list of tuple): List of tuples where each tuple contains two indices (L, R) Returns: list: List containing the sum for each query pass from solution import solveQueries def test_solveQueries_single_query(): nums = [1, 2, 3, 4, 5] queries = [(1, 3)] assert solveQueries(nums, queries) == [6] def test_solveQueries_multiple_queries(): nums = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 4), (1, 5)] assert solveQueries(nums, queries) == [6, 9, 15] def test_solveQueries_with_plane_array(): nums = [1] queries = [(1, 1)] assert solveQueries(nums, queries) == [1] def test_solveQueries_large_values(): nums = [100000] * 100000 queries = [(1, 100000)] assert solveQueries(nums, queries) == [100000 * 100000] def test_solveQueries_non_overlapping_queries(): nums = [3, 6, 1, 9, 12] queries = [(1, 2), (3, 4), (4, 5)] assert solveQueries(nums, queries) == [9, 10, 21]","solution":"def solveQueries(nums, queries): Returns the sum of subarrays specified by the given queries. Parameters: nums (list): List of integers queries (list of tuple): List of tuples where each tuple contains two indices (L, R) Returns: list: List containing the sum for each query # Create a prefix sum array prefix_sum = [0] * (len(nums) + 1) for i in range(1, len(nums) + 1): prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1] # Create a list to store the results for each query result = [] for L, R in queries: # Adjusting indices since queries are 1-based and prefix_sum is 0-based sum_subarray = prefix_sum[R] - prefix_sum[L - 1] result.append(sum_subarray) return result"},{"question":"def max_socks_pairs(n, socks): Returns the maximum number of pairs that can be formed from the given socks. Parameters: n (int): The total number of socks. socks (list of int): A list where each element is the color of a sock. Returns: int: The maximum number of pairs of socks. >>> max_socks_pairs(9, [10, 20, 20, 10, 10, 30, 50, 10, 20]) 3 >>> max_socks_pairs(6, [1, 1, 1, 1, 1, 1]) 3","solution":"def max_socks_pairs(n, socks): Returns the maximum number of pairs that can be formed from the given socks. Parameters: n (int): The total number of socks. socks (list of int): A list where each element is the color of a sock. Returns: int: The maximum number of pairs of socks. from collections import Counter sock_counter = Counter(socks) pairs = 0 for count in sock_counter.values(): pairs += count // 2 return pairs # Example usage: # n = 9 # socks = [10, 20, 20, 10, 10, 30, 50, 10, 20] # print(max_socks_pairs(n, socks)) # Output: 3"},{"question":"def minimum_spanning_tree(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Calculate the total weight of the Minimum Spanning Tree (MST) formed by the given edges. >>> minimum_spanning_tree(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 7), (3, 4, 3)]) 6","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal_mst(n, edges): edges.sort(key=lambda edge: edge[2]) uf = UnionFind(n) mst_weight = 0 mst_edges = 0 for u, v, w in edges: u -= 1 # Adjusting 1-based index to 0-based index v -= 1 # Adjusting 1-based index to 0-based index if uf.find(u) != uf.find(v): uf.union(u, v) mst_weight += w mst_edges += 1 if mst_edges == n - 1: break return mst_weight def minimum_spanning_tree(n, m, edges): return kruskal_mst(n, edges)"},{"question":"def can_form_palindrome(char_freq): Determine if it's possible to form a palindromic string using the characters and their frequencies given. Arguments: char_freq (dict): A dictionary where keys are characters and values are their frequencies. Returns: bool: True if a palindromic string can be formed, otherwise False. >>> can_form_palindrome({'a': 3, 'b': 3}) True >>> can_form_palindrome({'a': 3, 'b': 2}) True >>> can_form_palindrome({'a': 2, 'b': 1, 'c': 2}) False >>> can_form_palindrome({'a': 1}) True from solution import can_form_palindrome def test_can_form_palindrome_even_freq(): char_freq = {'a': 2, 'b': 2, 'c': 2} assert can_form_palindrome(char_freq) == True def test_can_form_palindrome_single_odd_freq(): char_freq = {'a': 3, 'b': 2, 'c': 2} assert can_form_palindrome(char_freq) == True def test_can_form_palindrome_multiple_odd_freq(): char_freq = {'a': 3, 'b': 3, 'c': 2} assert can_form_palindrome(char_freq) == False def test_can_form_palindrome_single_character(): char_freq = {'a': 1} assert can_form_palindrome(char_freq) == True def test_can_form_palindrome_all_unique_characters(): char_freq = {'a': 1, 'b': 1, 'c': 1} assert can_form_palindrome(char_freq) == False def test_can_form_palindrome_repeated_characters(): char_freq = {'a': 4, 'b': 4, 'c': 4} assert can_form_palindrome(char_freq) == True def test_can_form_palindrome_large_frequencies(): char_freq = {'a': 10**6, 'b': 10**6, 'c': 10**6} assert can_form_palindrome(char_freq) == True def test_can_form_palindrome_large_frequencies_single_odd(): char_freq = {'a': 10**6, 'b': 10**6, 'c': (10**6) + 1} assert can_form_palindrome(char_freq) == True def test_can_form_palindrome_large_frequencies_multiple_odd(): char_freq = {'a': (10**6) + 1, 'b': (10**6) + 1, 'c': 10**6} assert can_form_palindrome(char_freq) == False","solution":"def can_form_palindrome(char_freq): Determines if it is possible to form a palindromic string using the characters and their frequencies given. Args: char_freq (dict): A dictionary where keys are characters and values are their frequencies. Returns: bool: True if a palindromic string can be formed, otherwise False. odd_count = 0 for freq in char_freq.values(): if freq % 2 != 0: odd_count += 1 # For a string to be palindromic, at most one character can have an odd frequency return odd_count <= 1"},{"question":"def length_of_last_word(s: str) -> int: Returns the length of the last word in the string s. If the last word does not exist, returns 0. >>> length_of_last_word(\\"Hello World\\") == 5 >>> length_of_last_word(\\" \\") == 0 >>> length_of_last_word(\\"Hello\\") == 5 >>> length_of_last_word(\\"Welcome to the jungle\\") == 6 >>> length_of_last_word(\\" a\\") == 1 >>> length_of_last_word(\\"day \\") == 3 >>> length_of_last_word(\\"This is a test\\") == 4","solution":"def length_of_last_word(s): Returns the length of the last word in the string s. If the last word does not exist, returns 0. words = s.strip().split(\\" \\") if len(words[-1]) == 0: return 0 else: return len(words[-1])"},{"question":"class BankSystem: def __init__(self): Initialize the banking system with an empty accounts dictionary and a limit of 10 accounts. pass def create_account(self, account_number: str) -> str: Create a new account with a unique 5-digit account number. pass def deposit(self, account_number: str, amount: int) -> str: Deposit a specified amount into a specified account. pass def withdraw(self, account_number: str, amount: int) -> str: Withdraw a specified amount from a specified account. pass def balance(self, account_number: str) -> str: Check the current balance of a specified account. pass def handle_command(self, command: str) -> str: Process a command and return the appropriate response. pass # Test cases def test_create_account(): bank = BankSystem() assert bank.handle_command(\\"CREATE 12345\\") == \\"Account 12345 created\\" assert bank.handle_command(\\"CREATE 12345\\") == \\"Account 12345 already exists\\" def test_deposit(): bank = BankSystem() bank.handle_command(\\"CREATE 12345\\") assert bank.handle_command(\\"DEPOSIT 12345 200\\") == \\"Deposited 200 to 12345\\" assert bank.handle_command(\\"DEPOSIT 54321 100\\") == \\"Invalid account\\" def test_withdraw(): bank = BankSystem() bank.handle_command(\\"CREATE 12345\\") assert bank.handle_command(\\"WITHDRAW 12345 50\\") == \\"Insufficient funds\\" bank.handle_command(\\"DEPOSIT 12345 200\\") assert bank.handle_command(\\"WITHDRAW 12345 50\\") == \\"Withdrew 50 from 12345\\" assert bank.handle_command(\\"WITHDRAW 54321 50\\") == \\"Invalid account\\" def test_balance(): bank = BankSystem() bank.handle_command(\\"CREATE 12345\\") assert bank.handle_command(\\"BALANCE 12345\\") == \\"Account 12345 balance 0\\" bank.handle_command(\\"DEPOSIT 12345 200\\") assert bank.handle_command(\\"BALANCE 12345\\") == \\"Account 12345 balance 200\\" assert bank.handle_command(\\"BALANCE 54321\\") == \\"Invalid account\\" def test_invalid_operations(): bank = BankSystem() assert bank.handle_command(\\"CREATE\\") == \\"Invalid Operation\\" assert bank.handle_command(\\"DEPOSIT 12345\\") == \\"Invalid Operation\\" assert bank.handle_command(\\"WITHDRAW 12345\\") == \\"Invalid Operation\\" assert bank.handle_command(\\"BALANCE\\") == \\"Invalid Operation\\" assert bank.handle_command(\\"INVALIDOP\\") == \\"Invalid Operation\\" def test_account_limit(): bank = BankSystem() for i in range(10): assert bank.handle_command(f\\"CREATE {10000 + i}\\") == f\\"Account {10000 + i} created\\" assert bank.handle_command(\\"CREATE 20000\\") == \\"Account limit reached\\"","solution":"class BankSystem: def __init__(self): self.accounts = {} self.account_limit = 10 def create_account(self, account_number): if len(self.accounts) >= self.account_limit: return \\"Account limit reached\\" if account_number in self.accounts: return f\\"Account {account_number} already exists\\" self.accounts[account_number] = 0 return f\\"Account {account_number} created\\" def deposit(self, account_number, amount): if account_number not in self.accounts: return \\"Invalid account\\" self.accounts[account_number] += amount return f\\"Deposited {amount} to {account_number}\\" def withdraw(self, account_number, amount): if account_number not in self.accounts: return \\"Invalid account\\" if self.accounts[account_number] < amount: return \\"Insufficient funds\\" self.accounts[account_number] -= amount return f\\"Withdrew {amount} from {account_number}\\" def balance(self, account_number): if account_number not in self.accounts: return \\"Invalid account\\" return f\\"Account {account_number} balance {self.accounts[account_number]}\\" def handle_command(self, command): parts = command.split() operation = parts[0] if operation == \\"CREATE\\": if len(parts) != 2: return \\"Invalid Operation\\" account_number = parts[1] return self.create_account(account_number) elif operation == \\"DEPOSIT\\": if len(parts) != 3: return \\"Invalid Operation\\" account_number, amount = parts[1], int(parts[2]) return self.deposit(account_number, amount) elif operation == \\"WITHDRAW\\": if len(parts) != 3: return \\"Invalid Operation\\" account_number, amount = parts[1], int(parts[2]) return self.withdraw(account_number, amount) elif operation == \\"BALANCE\\": if len(parts) != 2: return \\"Invalid Operation\\" account_number = parts[1] return self.balance(account_number) elif operation == \\"QUIT\\": return None else: return \\"Invalid Operation\\""},{"question":"from typing import List def convert_schedules(schedule: List[str]) -> List[str]: Converts a list of times from 24-hour format to 12-hour format with AM/PM. Parameters: schedule (List[str]): List of strings representing times in 24-hour format (HHMM). Returns: List[str]: List of strings representing times in 12-hour format with AM/PM suffix. Examples: >>> convert_schedules([\\"0930\\", \\"2315\\", \\"0000\\", \\"1200\\"]) [\\"09:30 AM\\", \\"11:15 PM\\", \\"12:00 AM\\", \\"12:00 PM\\"] >>> convert_schedules([\\"1245\\"]) [\\"12:45 PM\\"]","solution":"from typing import List def convert_schedules(schedule: List[str]) -> List[str]: Converts a list of times from 24-hour format to 12-hour format with AM/PM. Parameters: schedule (List[str]): List of strings representing times in 24-hour format (HHMM). Returns: List[str]: List of strings representing times in 12-hour format with AM/PM suffix. result = [] for time in schedule: hour = int(time[:2]) minute = time[2:] if hour == 0: converted_time = f\\"12:{minute} AM\\" elif hour < 12: converted_time = f\\"{hour:02}:{minute} AM\\" elif hour == 12: converted_time = f\\"12:{minute} PM\\" else: converted_time = f\\"{hour - 12:02}:{minute} PM\\" result.append(converted_time) return result"},{"question":"def maximum_robbed_amount(n: int, a: List[int]) -> int: Determine the maximum amount of money the thief can rob without robbing two consecutive houses. >>> maximum_robbed_amount(4, [1, 2, 3, 1]) 4 >>> maximum_robbed_amount(5, [2, 7, 9, 3, 1]) 12 pass # Example test cases def test_example_1(): assert maximum_robbed_amount(4, [1, 2, 3, 1]) == 4 def test_example_2(): assert maximum_robbed_amount(5, [2, 7, 9, 3, 1]) == 12 def test_single_house(): assert maximum_robbed_amount(1, [10]) == 10 def test_two_houses(): assert maximum_robbed_amount(2, [1, 2]) == 2 assert maximum_robbed_amount(2, [2, 2]) == 2 assert maximum_robbed_amount(2, [3, 2]) == 3 def test_all_zeros(): assert maximum_robbed_amount(4, [0, 0, 0, 0]) == 0 def test_alternating_amounts(): assert maximum_robbed_amount(6, [0, 1, 0, 1, 0, 1]) == 3 def test_large_input(): import random random.seed(0) n = 100000 a = [random.randint(0, 10000) for _ in range(n)] assert isinstance(maximum_robbed_amount(n, a), int)","solution":"from typing import List def maximum_robbed_amount(n: int, a: List[int]) -> int: if n == 0: return 0 elif n == 1: return a[0] elif n == 2: return max(a[0], a[1]) dp = [0] * n dp[0] = a[0] dp[1] = max(a[0], a[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + a[i]) return dp[-1]"},{"question":"def football_tournament(N: int, matches: List[Tuple[int, int]]) -> List[int]: Simulate the outcome of n matches and determine the team with the highest number of wins. :param N: Number of teams :param matches: List of tuples where each tuple contains two integers representing the winner and the loser of a match. :return: List of team(s) with the highest number of wins in numerical order. Example: >>> football_tournament(5, [(2, 1), (3, 2), (4, 5), (3, 4), (2, 3), (3, 1), (5, 4)]) [3] >>> football_tournament(3, [(1, 2), (2, 3), (3, 1), (1, 3)]) [1]","solution":"def football_tournament(N, matches): Determines the team(s) with the highest number of wins. Parameters: N (int): The number of teams. matches (List[Tuple[int, int]]): A list of match results where each tuple represents (winner, loser). Returns: List[int]: List of teams with the highest number of wins in numerical order. from collections import Counter wins = Counter() for winner, loser in matches: wins[winner] += 1 max_wins = max(wins.values(), default=0) top_teams = [team for team, win_count in wins.items() if win_count == max_wins] return sorted(top_teams)"},{"question":"def net_effects(M: int, interactions: List[Tuple[str, str, str]]) -> List[List[int]]: Determine the net effect of each species on every other species. The function takes an integer M, which represents the number of interactions, and a list of interactions, each represented by a tuple of two species names and the type of interaction (either 'help' or 'harm'). The function returns a matrix of net effects where the cell at row i and column j contains the net effect of species i on species j. >>> net_effects(6, [('Lion', 'Deer', 'help'), ('Deer', 'Grass', 'help'), ('Grass', 'Lion', 'harm'), ... ('Lion', 'Grass', 'help'), ('Deer', 'Lion', 'harm'), ('Grass', 'Deer', 'help')]) [[0, 1, 1], [-1, 0, 1], [-1, 1, 0]] >>> net_effects(1, [('A', 'B', 'help')]) [[0, 1], [0, 0]] >>> net_effects(1, [('A', 'B', 'harm')]) [[0, -1], [0, 0]] >>> net_effects(3, [('A', 'B', 'help'), ('A', 'B', 'harm'), ('A', 'B', 'help')]) [[0, 1], [0, 0]] >>> net_effects(0, []) []","solution":"def net_effects(M, interactions): species_index = {} index = 0 # Assigning an index to each species for inter in interactions: sp1, sp2, effect = inter if sp1 not in species_index: species_index[sp1] = index index += 1 if sp2 not in species_index: species_index[sp2] = index index += 1 n = len(species_index) net_matrix = [[0] * n for _ in range(n)] # Calculating net effects for inter in interactions: sp1, sp2, effect = inter if effect == \\"help\\": net_matrix[species_index[sp1]][species_index[sp2]] += 1 elif effect == \\"harm\\": net_matrix[species_index[sp1]][species_index[sp2]] -= 1 return net_matrix"},{"question":"def increase_by_ten(lst): This function takes a list of integers and returns a new list where each integer is increased by 10. If any element in the list is not an integer, the function returns \\"Invalid input\\". >>> increase_by_ten([1, 2, 3]) == [11, 12, 13] >>> increase_by_ten([-1, 0, 1]) == [9, 10, 11] >>> increase_by_ten([-10, -20, -30]) == [0, -10, -20] >>> increase_by_ten([]) == [] >>> increase_by_ten([1, 'two', 3]) == \\"Invalid input\\" >>> increase_by_ten([1, 2.5, 3]) == \\"Invalid input\\" >>> increase_by_ten([1, None, 3]) == \\"Invalid input\\" >>> increase_by_ten(['a', 'b', 'c']) == \\"Invalid input\\"","solution":"def increase_by_ten(lst): This function takes a list of integers and returns a new list where each integer is increased by 10. If any element in the list is not an integer, the function returns \\"Invalid input\\". if not all(isinstance(x, int) for x in lst): return \\"Invalid input\\" return [x + 10 for x in lst]"},{"question":"def sum_of_minimums(n: int) -> int: Computes the sum of the minimum values of all subarrays of the array [1, 2, 3, ..., n]. Args: n (int): A positive integer representing the size of the array. Returns: int: The sum of the minimum values of all subarrays. Examples: >>> sum_of_minimums(1) 1 >>> sum_of_minimums(2) 4 >>> sum_of_minimums(3) 10 pass","solution":"def sum_of_minimums(n): Returns the sum of the minimum values of all subarrays of the array [1, 2, 3, ..., n]. total_sum = 0 # Nested loop to consider all subarrays for i in range(1, n + 1): for j in range(i, n + 1): # For a subarray starting at \`i\` and ending at \`j\` the minimum value is just \`i\` total_sum += i return total_sum"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Determines if the digits in the string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"112233\\") \\"YES\\" >>> can_form_palindrome(\\"123\\") \\"NO\\" >>> can_form_palindrome(\\"445544\\") \\"YES\\" >>> can_form_palindrome(\\"1\\") \\"YES\\" >>> can_form_palindrome(\\"22\\") \\"YES\\" >>> can_form_palindrome(\\"12321\\") \\"YES\\" >>> can_form_palindrome(\\"12311\\") \\"NO\\" >>> can_form_palindrome(\\"111122233\\") \\"YES\\" >>> can_form_palindrome(\\"112234\\") \\"NO\\" >>> can_form_palindrome(\\"2345432\\") \\"YES\\" pass def solve(test_cases: List[str]) -> List[str]: Solve the problem for multiple test cases. >>> solve([\\"112233\\", \\"123\\", \\"445544\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> solve([\\"1\\", \\"22\\", \\"12321\\", \\"12311\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] >>> solve([\\"111122233\\", \\"112234\\", \\"2345432\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"from collections import Counter def can_form_palindrome(s): Determines if the digits in the string s can be rearranged to form a palindrome. digit_counts = Counter(s) # A string can form a palindrome if at most one character has an odd count odd_count = sum(1 for count in digit_counts.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\" def solve(test_cases): results = [] for s in test_cases: results.append(can_form_palindrome(s)) return results"},{"question":"def optimal_storage(input_str: str) -> str: Optimize storage for Acme Widget Company to maximize value without exceeding warehouse volume. >>> optimal_storage(\\"3 50ngadget 10 60ndoohickey 20 100nthingamajig 30 120\\") 'gadget 5' >>> optimal_storage(\\"2 5nwidget1 10 50nwidget2 20 100\\") 'IMPOSSIBLE' >>> optimal_storage(\\"1 100nwidget 25 30\\") 'widget 4' >>> optimal_storage(\\"2 40nwidget1 10 20nwidget2 20 40\\") 'widget1 4' >>> optimal_storage(\\"2 30nwidget1 15 50nwidget2 10 30\\") 'widget1 2'","solution":"def find_optimal_storage(n, V, widgets): dp = [0] * (V + 1) counts = [{} for _ in range(V + 1)] for widget_name, volume, value in widgets: for j in range(volume, V + 1): if dp[j - volume] + value > dp[j]: dp[j] = dp[j - volume] + value counts[j] = counts[j - volume].copy() if widget_name in counts[j]: counts[j][widget_name] += 1 else: counts[j][widget_name] = 1 if dp[V] == 0: return \\"IMPOSSIBLE\\" else: result = counts[V] return [(name, count) for name, count in result.items()] # Parsing input def parse_input(input_str): lines = input_str.strip().split('n') n, V = map(int, lines[0].split()) widgets = [] for i in range(1, len(lines)): parts = lines[i].split() name = parts[0] volume = int(parts[1]) value = int(parts[2]) widgets.append((name, volume, value)) return n, V, widgets # Wrapper function def optimal_storage(input_str): n, V, widgets = parse_input(input_str) result = find_optimal_storage(n, V, widgets) if result == \\"IMPOSSIBLE\\": return \\"IMPOSSIBLE\\" else: return \\"n\\".join(f\\"{name} {count}\\" for name, count in result)"},{"question":"def lowest_effective_monthly_cost(subscriptions): Determines the lowest effective monthly cost among all available subscription plans. Args: subscriptions (list of dict): Each dict represents a subscription plan with base cost and blocks. Returns: int: The lowest effective monthly cost among all plans rounded down to the nearest integer. pass def parse_input(input_str): Parses the input string into a more structured format for processing. Args: input_str (str): Raw input string containing the subscription plans data. Returns: list of dict: Structured list of subscription plans. pass def main(input_str): subscriptions = parse_input(input_str) return lowest_effective_monthly_cost(subscriptions) def test_case_1(): input_str = \\"2n100n2n6 5n12 10n200n1n3 20\\" assert main(input_str) == 90 def test_case_2(): input_str = \\"1n500n3n1 0n6 50n12 75\\" assert main(input_str) == 125 def test_case_3(): input_str = \\"1n300n1n24 10\\" assert main(input_str) == 270 def test_case_4(): input_str = \\"1n1000n2n12 10n18 15\\" assert main(input_str) == 850 def test_case_5(): input_str = \\"1n350n2n6 20n24 50\\" assert main(input_str) == 175","solution":"def lowest_effective_monthly_cost(subscriptions): Determines the lowest effective monthly cost among all available subscription plans. Args: subscriptions (list of dict): Each dict represents a subscription plan with base cost and blocks. Returns: int: The lowest effective monthly cost among all plans rounded down to the nearest integer. min_cost = float('inf') for plan in subscriptions: base_cost = plan['base_cost'] for block in plan['blocks']: months, discount = block effective_cost = base_cost * (1 - discount / 100) monthly_cost = (effective_cost * months) / months min_cost = min(min_cost, monthly_cost) return int(min_cost) def parse_input(input_str): Parses the input string into a more structured format for processing. Args: input_str (str): Raw input string containing the subscription plans data. Returns: list of dict: Structured list of subscription plans. lines = input_str.split('n') T = int(lines[0]) index = 1 subscriptions = [] for _ in range(T): base_cost = int(lines[index]) index += 1 B = int(lines[index]) index += 1 blocks = [] for _ in range(B): M, D = map(int, lines[index].split()) blocks.append((M, D)) index += 1 subscriptions.append({'base_cost': base_cost, 'blocks': blocks}) return subscriptions def main(input_str): subscriptions = parse_input(input_str) return lowest_effective_monthly_cost(subscriptions) # Example usage: # input_str = \\"2n100n2n6 5n12 10n200n1n3 20\\" # print(main(input_str)) # Output: 90"},{"question":"def max_consecutive_years(p: int, n: int) -> int: This function computes the maximum number of consecutive years Dr. Bacchus can drink a perfectly aged bottle of wine starting from the first year. Args: p (int): Shortest aging period (in years) of the wine bottles. n (int): Number of boxes in the cellar. Returns: int: Maximum number of consecutive years with perfectly aged wine. >>> max_consecutive_years(3, 1) 1 >>> max_consecutive_years(3, 4) 3 >>> max_consecutive_years(10, 20) 10 >>> max_consecutive_years(100, 50) 50 >>> max_consecutive_years(1, 10) 1 pass def process_input(input_data: str) -> list: This function processes the input data and returns the maximum number of consecutive years Dr. Bacchus can drink a perfectly aged bottle of wine for each dataset. Args: input_data (str): The input data as a string where each line contains two integers p and n. Returns: list: A list of integers representing the maximum number of consecutive years for each dataset. >>> input_data = \\"3 1n3 4n10 20n100 50n1 10n0 0\\" >>> process_input(input_data) [1, 3, 10, 50, 1] >>> input_data = \\"1 1n0 0\\" >>> process_input(input_data) [1] >>> input_data = \\"50 100n20 20n0 0\\" >>> process_input(input_data) [50, 20] >>> input_data = \\"0 0\\" >>> process_input(input_data) [] pass","solution":"def max_consecutive_years(p, n): This function computes the maximum number of consecutive years Dr. Bacchus can drink a perfectly aged bottle of wine starting from the first year. p is the shortest aging period and n is the number of boxes in the cellar. return min(p, n) def process_input(input_data): result = [] for line in input_data.split('n'): p, n = map(int, line.split()) if p == 0 and n == 0: break result.append(max_consecutive_years(p, n)) return result"},{"question":"from typing import List, Tuple def max_non_overlapping_trains(N: int, schedules: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping trains that can be scheduled on a single track. Parameters: N (int): The number of trains. schedules (list of tuples): Each tuple contains two integers representing the start time and end time of a train. Returns: int: The maximum number of non-overlapping trains. >>> max_non_overlapping_trains(3, [(1, 3), (2, 5), (4, 6)]) 2 >>> max_non_overlapping_trains(4, [(1, 2), (2, 3), (3, 4), (1, 3)]) 3","solution":"def max_non_overlapping_trains(N, schedules): Determines the maximum number of non-overlapping trains that can be scheduled on a single track. Parameters: N (int): The number of trains. schedules (list of tuples): Each tuple contains two integers representing the start time and end time of a train. Returns: int: The maximum number of non-overlapping trains. # Sort the schedules by end time schedules.sort(key=lambda x: x[1]) # Initialize counters max_trains = 0 last_end_time = -1 # Iterate through sorted schedules for start, end in schedules: if start >= last_end_time: max_trains += 1 last_end_time = end return max_trains # Example usage: # print(max_non_overlapping_trains(3, [(1, 3), (2, 5), (4, 6)])) # Output: 2 # print(max_non_overlapping_trains(4, [(1, 2), (2, 3), (3, 4), (1, 3)])) # Output: 3"},{"question":"def most_common_tree_species(R: int, C: int, grid: List[List[str]]) -> Tuple[str, int]: Returns the most common tree species from the grid and its frequency. Args: - R: int, number of rows in the grid. - C: int, number of columns in the grid. - grid: list of list of strings, representing the tree species in the grid. Returns: - tuple: (most_common_species, frequency) where most_common_species is the most frequently occurring species in the grid and frequency is its count. Example: >>> grid = [ ... [\\"oak\\", \\"pine\\", \\"birch\\"], ... [\\"oak\\", \\"birch\\", \\"pine\\"], ... [\\"pine\\", \\"oak\\", \\"oak\\"] ... ] >>> most_common_tree_species(3, 3, grid) ('oak', 4)","solution":"def most_common_tree_species(R, C, grid): Returns the most common tree species from the grid and its frequency. Args: - R: int, number of rows in the grid. - C: int, number of columns in the grid. - grid: list of list of strings, representing the tree species in the grid. Returns: - tuple: (most_common_species, frequency) where most_common_species is the most frequently occurring species in the grid and frequency is its count. from collections import Counter # Flatten the grid to a single list of species species_list = [tree for row in grid for tree in row] # Count the occurrences of each species species_count = Counter(species_list) # Find the species with the highest frequency, breaking ties by lexicographical order most_common_species = min(species_count.items(), key=lambda x: (-x[1], x[0])) return most_common_species[0], most_common_species[1] # Example usage: # grid = [ # [\\"oak\\", \\"pine\\", \\"birch\\"], # [\\"oak\\", \\"birch\\", \\"pine\\"], # [\\"pine\\", \\"oak\\", \\"oak\\"] # ] # R, C = 3, 3 # most_common_tree_species(R, C, grid) should return (\\"oak\\", 4)"},{"question":"def fibonacci_thickness(T1: int, T2: int, N: int) -> int: Calculates the thickness of the branch at the Nth position in the Fibonacci Tree sequence. Parameters: T1 (int): Thickness of the first branch. T2 (int): Thickness of the second branch. N (int): Position of the branch whose thickness is to be found. Returns: int: Thickness of the branch at the Nth position. >>> fibonacci_thickness(1, 1, 5) 5 >>> fibonacci_thickness(2, 3, 6) 21 >>> fibonacci_thickness(4, 5, 1) 4 >>> fibonacci_thickness(4, 5, 2) 5 >>> fibonacci_thickness(1, 2, 10) 89 >>> fibonacci_thickness(10**9, 10**9, 3) 2 * 10**9 >>> fibonacci_thickness(1, 1, 20) 6765","solution":"def fibonacci_thickness(T1, T2, N): Calculates the thickness of the branch at the Nth position in the Fibonacci Tree sequence. Parameters: T1 (int): Thickness of the first branch. T2 (int): Thickness of the second branch. N (int): Position of the branch whose thickness is to be found. Returns: int: Thickness of the branch at the Nth position. if N == 1: return T1 elif N == 2: return T2 a, b = T1, T2 for _ in range(N - 2): a, b = b, a + b return b"},{"question":"def minReduceToOne(N: int) -> int: Given a positive integer N, determine the minimum number of steps required to reduce it to 1. In each step, you may choose one of the following operations: 1. Subtract 1 from the number. 2. If the number is divisible by 2, divide the number by 2. 3. If the number is divisible by 3, divide the number by 3. >>> minReduceToOne(10) 3 >>> minReduceToOne(6) 2 >>> minReduceToOne(4) 2 Parameters: N (int): The positive integer to be reduced. Returns: int: The minimum number of steps to reduce the number to 1.","solution":"def minReduceToOne(N): if N == 1: return 0 dp = [float('inf')] * (N + 1) dp[1] = 0 for i in range(2, N + 1): dp[i] = dp[i - 1] + 1 if i % 2 == 0: dp[i] = min(dp[i], dp[i // 2] + 1) if i % 3 == 0: dp[i] = min(dp[i], dp[i // 3] + 1) return dp[N]"},{"question":"def nextGreaterElement(arr): Modify the array such that each element in the array is replaced with the next greater element present on its right side in the array. If there is no greater element, replace it with -1. Parameters: arr (List[int]): An array of integers Returns: List[int]: A new array with each element replaced by the next greater element Examples: >>> nextGreaterElement([4, 5, 2, 10, 8]) [5, 10, 10, -1, -1] >>> nextGreaterElement([3, 7, 1, 7, 8, 4, 5]) [7, 8, 7, 8, -1, 5, -1]","solution":"def nextGreaterElement(arr): This function takes an array of integers and returns a new array where each element is replaced with the next greater element to its right. If there is no greater element on the right, replace it with -1. n = len(arr) result = [-1] * n stack = [] for i in range(n): while stack and arr[stack[-1]] < arr[i]: result[stack.pop()] = arr[i] stack.append(i) return result"},{"question":"from typing import List def find_kth_largest(nums: List[int], k: int) -> int: Given an integer array nums and an integer k, return the k-th largest element in the array. Note that it is the k-th largest element in sorted order, not the k-th distinct element. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([1], 1) 1","solution":"def find_kth_largest(nums, k): Returns the k-th largest element in the given array. nums.sort(reverse=True) return nums[k-1]"},{"question":"def lastTwoDigits(N: int) -> int: Returns the last two digits of 2 raised to the power of N. Parameters: N (int): The exponent to raise 2 to. Returns: int: The last two digits of the result. >>> lastTwoDigits(15) 68 >>> lastTwoDigits(100) 76 >>> lastTwoDigits(1) 2 >>> lastTwoDigits(2) 4 >>> lastTwoDigits(1000000000000000000) 76 >>> lastTwoDigits(10**18) 76","solution":"def lastTwoDigits(N): Returns the last two digits of 2 raised to the power of N. Parameters: N (int): The exponent to raise 2 to. Returns: int: The last two digits of the result. if N == 0: return 1 # using modulo property to find last two digits return pow(2, N, 100)"},{"question":"def max_product_non_adjacent_subsequence(N: int, A: List[int]) -> int: Find the maximum product by selecting a non-empty subsequence of the array such that no two adjacent elements in the array are part of the subsequence. The result should be given modulo 1,000,000,007. >>> max_product_non_adjacent_subsequence(4, [1, 2, 3, 4]) 4 >>> max_product_non_adjacent_subsequence(1, [10]) 10 >>> max_product_non_adjacent_subsequence(5, [7, 7, 7, 7, 7]) 7 >>> max_product_non_adjacent_subsequence(3, [10**9, 10**9, 10**9]) 1000000007 >>> max_product_non_adjacent_subsequence(10**5, [2] * 10**5) 2","solution":"def max_product_non_adjacent_subsequence(N, A): MOD = 1000000007 # Considering that the maximum value is individual element (no adjacent consideration) max_product = 0 for num in A: # Each number in the array could become the potential product max_product = max(max_product, num) return max_product % MOD"},{"question":"def are_words_unique_in_range(n: int, words: List[str], q: int, queries: List[Tuple[int, int]]) -> List[str]: Determine if all the words within the range specified by the query are unique. >>> are_words_unique_in_range(5, ['apple', 'banana', 'cherry', 'date', 'elderberry'], 3, [(1, 3), (2, 5), (3, 4)]) ['YES', 'YES', 'YES'] >>> are_words_unique_in_range(4, ['pear', 'plum', 'peach', 'apple'], 2, [(1, 2), (3, 4)]) ['YES', 'YES']","solution":"def are_words_unique_in_range(n, words, q, queries): results = [] for l, r in queries: if l == r: results.append(\\"YES\\") else: word_set = set(words[l-1:r]) if len(word_set) == (r - l + 1): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def find_edges_to_remove(n: int, edges: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Mike Micromanager needs to identify all possible sets of directed edges that, if removed, would eliminate all cycles in the city's street network and leave the rest of the street system as connected as possible. :param n: Number of intersections (nodes) :param edges: List of tuples representing directed edges (u, v) :return: List of tuples representing the edges to be removed >>> find_edges_to_remove(6, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4), (1, 4), (2, 5), (3, 6)]) [(1, 2), (4, 5)] >>> find_edges_to_remove(1, []) [] >>> find_edges_to_remove(3, [(1, 2), (2, 3)]) [] >>> find_edges_to_remove(3, [(1, 2), (2, 3), (3, 1)]) [(1, 2)] >>> find_edges_to_remove(4, [(1, 2), (2, 1), (3, 4), (4, 3)]) [(1, 2), (3, 4)] pass","solution":"def find_edges_to_remove(n, edges): Find the minimum set of edges that, when removed, eliminate all cycles in the directed graph. :param n: Number of intersections (nodes) :param edges: List of tuples representing directed edges (u, v) :return: List of tuples representing the edges to be removed from collections import defaultdict import heapq def tarjan_scc(n, edges): index = 0 indices = [-1] * n lowlink = [-1] * n on_stack = [False] * n stack = [] sccs = [] def strongconnect(node): nonlocal index indices[node] = index lowlink[node] = index index += 1 stack.append(node) on_stack[node] = True for neighbor in adjacency_list[node]: if indices[neighbor] == -1: strongconnect(neighbor) lowlink[node] = min(lowlink[node], lowlink[neighbor]) elif on_stack[neighbor]: lowlink[node] = min(lowlink[node], indices[neighbor]) if lowlink[node] == indices[node]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == node: break sccs.append(scc) adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u-1].append(v-1) for i in range(n): if indices[i] == -1: strongconnect(i) return sccs def find_cycle_edges(scc): in_degree = defaultdict(int) for u in scc: for v in adjacency_list[u]: if v in scc: in_degree[v] += 1 removable_edges = [] for u in scc: for v in adjacency_list[u]: if v in scc and in_degree[v] > 0: removable_edges.append((u, v)) in_degree[v] -= 1 removable_edges.sort() return removable_edges[0] sccs = tarjan_scc(n, edges) adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u-1].append(v-1) remove_edges = [] for scc in sccs: if len(scc) > 1: edge = find_cycle_edges(scc) remove_edges.append((edge[0] + 1, edge[1] + 1)) return sorted(remove_edges)"},{"question":"def count_direct_pairs(n: int, edges: List[Tuple[int, int]]) -> int: Returns the number of unique direct communication pairs in the tree. :param n: Integer, number of nodes in the tree. :param edges: List of tuples, each containing two integers u and v that denote an edge between nodes u and v. :return: Integer, number of unique direct communication pairs. >>> count_direct_pairs(4, [(1, 2), (1, 3), (3, 4)]) 3 >>> count_direct_pairs(6, [(1, 4), (3, 4), (2, 3), (2, 5), (6, 5)]) 5","solution":"def count_direct_pairs(n, edges): Returns the number of unique direct communication pairs in the tree. :param n: Integer, number of nodes in the tree. :param edges: List of tuples, each containing two integers u and v that denote an edge between nodes u and v. :return: Integer, number of unique direct communication pairs. # The number of unique direct communication pairs is simply the number # of edges in the tree since each edge represents a direct connection. return len(edges) # This function can be tested with inputs and expected outputs. # Sample test cases provided in the problem: print(count_direct_pairs(4, [(1, 2), (1, 3), (3, 4)])) # Output should be 3 print(count_direct_pairs(6, [(1, 4), (3, 4), (2, 3), (2, 5), (6, 5)])) # Output should be 5"},{"question":"def rob(buildings): Calculate the maximum amount of money that can be robbed without alerting security. Parameters: buildings (List[int]): A list representing the amount of money in each building. Returns: int: The maximum amount of money that can be robbed. Examples: >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([10, 1, 10]) 20","solution":"def rob(buildings): Calculate the maximum amount of money that can be robbed without alerting security. Parameters: buildings (List[int]): A list representing the amount of money in each building. Returns: int: The maximum amount of money that can be robbed. # Edge case where there are no buildings if not buildings: return 0 # Edge case where there is only one building elif len(buildings) == 1: return buildings[0] # Dynamic programming approach # DP array to store the maximum money that can be robbed up to each building dp = [0] * len(buildings) dp[0] = buildings[0] dp[1] = max(buildings[0], buildings[1]) for i in range(2, len(buildings)): dp[i] = max(dp[i-1], dp[i-2] + buildings[i]) return dp[-1]"},{"question":"from typing import List def shortest_path_with_obstacles(grid: List[List[int]]) -> int: Given a grid with obstacles, finds the shortest path from the top-left corner to the bottom-right corner. Returns -1 if no such path exists. Args: grid : List[List[int]] : 2D grid of 0s and 1s where 0 represents an empty cell and 1 represents an obstacle Returns: int : the length of the shortest path or -1 if no path exists >>> shortest_path_with_obstacles([[0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0]]) 7 >>> shortest_path_with_obstacles([[0, 1, 0], [1, 1, 0], [0, 0, 0]]) -1 import pytest def test_simple_grid(): grid = [ [0, 0], [0, 0] ] assert shortest_path_with_obstacles(grid) == 3 def test_obstacle_grid(): grid = [ [0, 1], [0, 0] ] assert shortest_path_with_obstacles(grid) == 3 def test_no_path(): grid = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] assert shortest_path_with_obstacles(grid) == -1 def test_medium_grid(): grid = [ [0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0] ] assert shortest_path_with_obstacles(grid) == 7 def test_large_grid(): grid = [[0] * 1000 for _ in range(1000)] assert shortest_path_with_obstacles(grid) == 1999 def test_large_grid_with_obstacle(): grid = [[0] * 1000 for _ in range(1000)] grid[500][500] = 1 assert shortest_path_with_obstacles(grid) == 1999 def test_entrance_blocked(): grid = [ [1, 0], [0, 0] ] assert shortest_path_with_obstacles(grid) == -1 def test_exit_blocked(): grid = [ [0, 0], [0, 1] ] assert shortest_path_with_obstacles(grid) == -1","solution":"from collections import deque def shortest_path_with_obstacles(grid): Given a grid with obstacles, finds the shortest path from the top-left corner to the bottom-right corner. Returns -1 if no such path exists. N = len(grid) M = len(grid[0]) if grid[0][0] == 1 or grid[N-1][M-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == N-1 and c == M-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < M and grid[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"def subarray_sum_divisible(t, test_cases): Given an integer array, determine if there exists a subarray whose sum is divisible by a given integer k. >>> subarray_sum_divisible(2, [[(5, 6), [1, 3, 2, 5, 4]], [(4, 3), [1, 2, 3, 4]]]) [\\"YES\\", \\"YES\\"] >>> subarray_sum_divisible(1, [[(3, 7), [1, 1, 1]]]) [\\"NO\\"]","solution":"def subarray_sum_divisible(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] arr = test_cases[i][1] prefix_sum_mod_k = {} prefix_sum = 0 found = False for j in range(n): prefix_sum += arr[j] mod = prefix_sum % k if mod == 0: found = True break if mod in prefix_sum_mod_k: found = True break else: prefix_sum_mod_k[mod] = j if found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def weeks_to_reach_goal(T, cases): Determines the number of weeks it will take for John to achieve his goal distance. Parameters: T (int): Number of test cases cases (list of tuples): Each tuple consists of three integers D, G, Y Returns: list of int: A list containing the number of weeks for each test case >>> weeks_to_reach_goal(3, [(10, 30, 5), (40, 100, 10), (20, 50, 10)]) [4, 6, 3] >>> weeks_to_reach_goal(1, [(10, 11, 1)]) [1]","solution":"def weeks_to_reach_goal(T, cases): Determines the number of weeks it will take for John to achieve his goal distance. Parameters: T (int): Number of test cases cases (list of tuples): Each tuple consists of three integers D, G, Y Returns: list of int: A list containing the number of weeks for each test case results = [] for D, G, Y in cases: weeks_needed = (G - D) // Y results.append(weeks_needed) return results # Example usage T = 3 cases = [ (10, 30, 5), (40, 100, 10), (20, 50, 10) ] print(weeks_to_reach_goal(T, cases))"},{"question":"from typing import List, Tuple def find_shortest_paths(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Find the shortest path from the top-left corner to the bottom-right corner of the maze for multiple test cases. Each test case consists of a rectangular maze of size n x m where each cell is either an empty space (represented by '.') or a wall (represented by '#'). You can only move up, down, left, or right, and cannot pass through walls. Args: t (int): Number of test cases. test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each represented by a tuple containing: - n (int): Number of rows in the maze. - m (int): Number of columns in the maze. - maze (List[str]): List of strings representing the maze. Returns: List[int]: List of integers representing the length of the shortest path for each test case, or -1 if no such path exists. >>> t = 3 >>> test_cases = [ ... (3, 3, [\\"...\\", \\".#.\\", \\"...\\"]), ... (5, 5, [\\"..#\\", \\".#..#\\", \\"#.#\\", \\"#..\\", \\"...#.\\"]), ... (4, 4, [\\"....\\", \\".#.#\\", \\".#..\\", \\"....\\"]) ... ] >>> find_shortest_paths(t, test_cases) [4, -1, 6]","solution":"from collections import deque def shortest_path_length(n, m, maze): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() # If we reached the bottom-right corner if r == n-1 and c == m-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and maze[nr][nc] == '.' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1 def find_shortest_paths(t, test_cases): results = [] for i in range(t): n, m, maze = test_cases[i] results.append(shortest_path_length(n, m, maze)) return results"},{"question":"from typing import List def decode_message(T: int, test_cases: List[str]) -> List[str]: Jack's task is to decode a secret message by removing all the special characters and reversing the remaining alphabetical characters. Parameters: T (int): Number of test cases. test_cases (List[str]): List containing the test case strings. Returns: List[str]: List containing the decoded messages for each test case. >>> decode_message(2, [\\"h!e@l#lo\\", \\"c!od!ing\\"]) [\\"olleh\\", \\"gnidoc\\"] >>> decode_message(1, [\\"hello\\"]) [\\"olleh\\"] >>> decode_message(1, [\\"!@#%\\"]) [\\"\\"] >>> decode_message(2, [\\"abcd1234\\", \\"12!3abc@de\\"]) [\\"dcba\\", \\"edcba\\"] >>> decode_message(1, [\\"a\\" * 100000 + \\"!\\" * 100000]) [\\"a\\" * 100000]","solution":"def decode_message(T, test_cases): Takes the number of test cases and a list of test case strings, and returns the decoded messages for each test case. results = [] for S in test_cases: # Remove special characters and reverse the string decoded = ''.join([char for char in S if char.isalpha()])[::-1] results.append(decoded) return results"},{"question":"def reverse_words(s: str) -> str: Reverse the words in a given string. Args: s (str): The input string containing words separated by spaces. Returns: str: A new string with the words in reverse order. Examples: >>> reverse_words('Hello World') 'World Hello' >>> reverse_words('Python is fun') 'fun is Python'","solution":"def reverse_words(s): Reverse the words in a given string. Args: s (str): The input string containing words separated by spaces. Returns: str: A new string with the words in reverse order. return ' '.join(s.split()[::-1])"},{"question":"def min_shelves(W: int, widths: List[int]) -> int: Returns the minimum number of shelves needed to store all parcels without exceeding the maximum width W per shelf. Parameters: W (int): The maximum width of a shelf. widths (list of int): The widths of the parcels. Returns: int: The minimum number of shelves needed. Examples: >>> min_shelves(10, [2, 3, 5, 8, 2, 1]) 3 >>> min_shelves(15, [10, 5, 10, 5, 5, 5]) 3","solution":"def min_shelves(W, widths): Returns the minimum number of shelves needed to store all parcels without exceeding the maximum width W per shelf. Parameters: W (int): The maximum width of a shelf. widths (list of int): The widths of the parcels. Returns: int: The minimum number of shelves needed. current_width = 0 num_shelves = 1 # At least one shelf is needed initially for width in widths: if current_width + width <= W: current_width += width else: num_shelves += 1 current_width = width # Place this parcel on the new shelf return num_shelves"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestValues(root): Finds the largest value in each row of a binary tree. Args: root (TreeNode): The root of the binary tree. Returns: List[int]: List of largest values in each row of the binary tree. Example: >>> root = TreeNode(1, TreeNode(3, TreeNode(5), TreeNode(3)), TreeNode(2, None, TreeNode(9))) >>> largestValues(root) [1, 3, 9]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestValues(root): Finds the largest value in each row of a binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) max_value = float('-inf') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"def process_queries(T: int, test_cases: List[Tuple[int, int, List[int], List[Tuple[int, int, int]]]]) -> List[int]: Function to process the given test cases and their queries (update and prefix sum operations) and return the results. Args: T (int): the number of test cases. test_cases (List[Tuple[int, int, List[int], List[Tuple[int, int, int]]]]): a list of tuples where, - Each tuple contains: - an integer M, the size of the array. - an integer P, the number of queries. - a list of M integers (the initial state of the array). - a list of P operations (each operation is a tuple of 3 integers). Returns: List[int]: Results of all the prefix sum queries in the order they were found in the input. return [] def run_tests(input_text: str) -> List[int]: Function to parse the input text, call the process_queries function, and return the results. Args: input_text (str): Multi-line string containing all the test cases and queries. Returns: List[int]: Results of all the prefix sum queries in the order they were found in the input. return [] # Sample Test Cases def test_sample_input_1(): input_text = 1 5 5 1 2 3 4 5 2 1 3 1 3 10 2 2 4 1 5 15 2 1 5 expected_output = [6, 16, 32] assert run_tests(input_text) == expected_output def test_single_update_query(): input_text = 1 3 1 1 2 3 1 2 5 expected_output = [] assert run_tests(input_text) == expected_output def test_single_prefix_sum_query(): input_text = 1 4 1 1 2 3 4 2 1 4 expected_output = [10] assert run_tests(input_text) == expected_output def test_multiple_cases(): input_text = 2 3 2 1 2 3 2 1 2 1 3 4 5 3 5 10 15 20 25 2 2 5 1 1 30 2 1 1 expected_output = [3, 70, 30] assert run_tests(input_text) == expected_output def test_edge_cases(): input_text = 1 1 1 100000 2 1 1 expected_output = [100000] assert run_tests(input_text) == expected_output input_text = 1 1 1 0 2 1 1 expected_output = [0] assert run_tests(input_text) == expected_output","solution":"def process_queries(T, test_cases): results = [] for case in test_cases: M, P, B, operations = case for op in operations: if op[0] == 1: _, X, Y = op B[X-1] = Y elif op[0] == 2: _, L, R = op results.append(sum(B[L-1:R])) return results # Function to parse input and call main processing function def run_tests(input_text): input_lines = input_text.strip().split('n') T = int(input_lines[0].strip()) index = 1 test_cases = [] for _ in range(T): M, P = map(int, input_lines[index].strip().split()) index += 1 B = list(map(int, input_lines[index].strip().split())) index += 1 operations = [] for _ in range(P): operations.append(list(map(int, input_lines[index].strip().split()))) index += 1 test_cases.append((M, P, B, operations)) results = process_queries(T, test_cases) return results"},{"question":"from typing import List def max_savings(arr: List[int], N: int) -> int: Given an array arr[] of size N representing the prices of house rentals on different days, determines if there exists a way to choose two different days such that renting a house on those two days will maximize your total savings in rental. The second chosen day must be after the first chosen day in the array. Args: arr (List[int]): List of integers representing house rental prices on different days. N (int): Number of days. Returns: int: The maximum savings that can be achieved by choosing two different days. Examples: >>> max_savings([7, 1, 5, 3, 6, 4], 6) 5 >>> max_savings([7, 6, 4, 3, 1], 5) 0","solution":"def max_savings(arr, N): if N < 2: return 0 max_savings = 0 min_price = arr[0] for i in range(1, N): if arr[i] - min_price > max_savings: max_savings = arr[i] - min_price if arr[i] < min_price: min_price = arr[i] return max_savings"},{"question":"def maxReward(grid): Calculate the maximum reward Fox AI can collect by moving from the top-left to the bottom-right corner of the grid. >>> maxReward([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> maxReward([ ... [1, -3, 1], ... [2, 10, -1] ... ]) 12 >>> maxReward([[-1, 2, -3, 4, 5]]) 7","solution":"def maxReward(grid): m = len(grid) n = len(grid[0]) # Initialize a DP array to store max rewards to each cell dp = [[0] * n for _ in range(m)] # Start from the top-left corner dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the DP array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the max reward return dp[m-1][n-1]"},{"question":"def divide_range(n: int, k: int) -> List[int]: Divides the range [1, n] into k contiguous segments such that each segment contains at least one element, and the difference between the largest and smallest sum of these segments is minimized. >>> divide_range(10, 3) [4, 3, 3] >>> divide_range(1, 1) [1] >>> divide_range(9, 3) [3, 3, 3] >>> divide_range(1000000, 3) [333334, 333333, 333333]","solution":"def divide_range(n, k): Divides the range [1, n] into k contiguous segments such that each segment contains at least one element, and the difference between the largest and smallest sum of these segments is minimized. quotient = n // k remainder = n % k segments = [quotient] * k for i in range(remainder): segments[i] += 1 # Distribute the remainder return segments # Example usage: # n = 10, k = 3 # The result would be [4, 3, 3] or any permutation of this. # because when 10 // 3 = 3 and remainder is 1, so we add one to one of the segments. print(divide_range(10, 3))"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isCousins(root, x, y): Determine if two nodes are cousins in a binary tree, i.e., they are at the same level and have different parents. Args: root (TreeNode): The root of the binary tree. x (int): The value of the first node. y (int): The value of the second node. Returns: bool: True if the nodes are cousins, False otherwise. Example: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.right.right = TreeNode(5) >>> isCousins(root, 4, 5) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(6) >>> isCousins(root, 4, 6) False >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.right.right = TreeNode(5) >>> root.left.left.left = TreeNode(7) >>> isCousins(root, 4, 7) False >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> isCousins(root, 4, 10) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isCousins(root, x, y): def find_depth_and_parent(node, val, depth=0, parent=None): if not node: return None if node.val == val: return (depth, parent) left_result = find_depth_and_parent(node.left, val, depth + 1, node) if left_result: return left_result right_result = find_depth_and_parent(node.right, val, depth + 1, node) return right_result x_info = find_depth_and_parent(root, x) y_info = find_depth_and_parent(root, y) if not x_info or not y_info: return False x_depth, x_parent = x_info y_depth, y_parent = y_info return x_depth == y_depth and x_parent != y_parent"},{"question":"def second_smallest(numbers): Returns the second smallest integer in the list or -1 if there are fewer than 2 unique integers. >>> second_smallest([1, 3, 4, 2, 1, 2]) 2 >>> second_smallest([5, 5, 5, 5]) -1 >>> second_smallest([2, 1]) 2 >>> second_smallest([10]) -1 def process_test_cases(test_cases): Processes multiple test cases and returns list of results. >>> process_test_cases([\\"1 3 4 2 1 2\\", \\"5 5 5 5\\", \\"2 1\\", \\"10\\"]) [2, -1, 2, -1] def main(input_string): Main function to handle input and output. >>> main(\\"4n1 3 4 2 1 2n5 5 5 5n2 1n10n\\") 2 -1 2 -1","solution":"def second_smallest(numbers): Returns the second smallest integer in the list or -1 if there are fewer than 2 unique integers. unique_numbers = list(set(numbers)) if len(unique_numbers) < 2: return -1 unique_numbers.sort() return unique_numbers[1] def process_test_cases(test_cases): results = [] for case in test_cases: numbers = list(map(int, case.split())) results.append(second_smallest(numbers)) return results def main(input_string): lines = input_string.strip().split('n') T = int(lines[0]) test_cases = lines[1:T + 1] results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def min_delivery_time(matrix: List[List[int]]) -> int: Find the shortest delivery route from the top-left corner (0,0) to the bottom-right corner (N-1, M-1) only moving right or down. >>> min_delivery_time([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_delivery_time([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5 >>> min_delivery_time([[2, 1, 3, 2], [4, 3, 1, 1], [1, 2, 5, 1], [4, 1, 1, 1]]) 10 >>> min_delivery_time([[1, 2], [4, 3]]) 6 >>> min_delivery_time([[0]]) 0","solution":"def min_delivery_time(matrix): N = len(matrix) M = len(matrix[0]) # Initialize a 2D list to store the minimum delivery times dp = [[0]*M for _ in range(N)] # Set up the starting point dp[0][0] = matrix[0][0] # Fill the values for the first row for j in range(1, M): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the values for the first column for i in range(1, N): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the dp table for i in range(1, N): for j in range(1, M): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] # The minimum delivery time to reach the bottom-right corner return dp[N-1][M-1] # Utility function to read input and call the solution function def main(): import sys input = sys.stdin.read data = input().split() # Read N and M index = 0 N = int(data[index]) M = int(data[index + 1]) index += 2 # Read the matrix matrix = [] for i in range(N): row = list(map(int, data[index:index + M])) matrix.append(row) index += M # Compute and print the result print(min_delivery_time(matrix))"},{"question":"def max_scenic_trails(n: int, m: int, trails: List[Tuple[int, int]]) -> int: Determine the maximum number of scenic trails a traveler can include in their journey without visiting any location more than once. >>> max_scenic_trails(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 3), (3, 5)]) 5 >>> max_scenic_trails(2, 1, [(1, 2)]) 1 >>> max_scenic_trails(4, 2, [(1, 2), (3, 4)]) 1","solution":"def max_scenic_trails(n, m, trails): Find the maximum number of scenic trails that can be included in a journey without visiting the same location more than once. def explore(current, visited, count): nonlocal max_count max_count = max(max_count, count) for next_location in graph[current]: if next_location not in visited: visited.add(next_location) explore(next_location, visited, count + 1) visited.remove(next_location) # Build the graph graph = {i: [] for i in range(1, n + 1)} for u, v in trails: graph[u].append(v) graph[v].append(u) max_count = 0 # Try to start exploring from each location for start in range(1, n + 1): explore(start, {start}, 0) return max_count"},{"question":"def longestIncreasingSubarray(sales, n): Function to find the length of the longest subarray with strictly increasing sales. >>> longestIncreasingSubarray([1, 2, 3, 1, 2, 4, 6, 1, 2], 9) 4 >>> longestIncreasingSubarray([5, 4, 3, 2, 1], 5) 1 >>> longestIncreasingSubarray([1, 2, 3, 4, 5], 5) 5 >>> longestIncreasingSubarray([1, 3, 2, 4, 6, 8], 6) 4 >>> longestIncreasingSubarray([2, 2, 2, 2, 2], 5) 1 >>> longestIncreasingSubarray([], 0) 0 >>> longestIncreasingSubarray([1], 1) 1","solution":"def longestIncreasingSubarray(sales, n): Function to find the length of the longest subarray with strictly increasing sales. if n == 0: return 0 max_len = 1 curr_len = 1 for i in range(1, n): if sales[i] > sales[i-1]: curr_len += 1 max_len = max(max_len, curr_len) else: curr_len = 1 return max_len"},{"question":"from typing import List class BookClub: A class to manage a book club's collection of previously read books with functionalities to add new books and find books by a specific author. Methods ------- add_book(title: str, author: str) -> None Adds a book with the given title and author to the collection. find_books_by_author(author: str) -> List[str] Returns a list of book titles by the specified author, in the order they were added. Example usage: >>> bc = BookClub() >>> bc.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\") >>> bc.add_book(\\"1984\\", \\"George Orwell\\") >>> bc.add_book(\\"Animal Farm\\", \\"George Orwell\\") >>> bc.add_book(\\"Pride and Prejudice\\", \\"Jane Austen\\") >>> bc.find_books_by_author(\\"George Orwell\\") [\\"1984\\", \\"Animal Farm\\"] >>> bc.find_books_by_author(\\"Harper Lee\\") [\\"To Kill a Mockingbird\\"] >>> bc.find_books_by_author(\\"Jane Austen\\") [\\"Pride and Prejudice\\"] def add_book(self, title: str, author: str) -> None: Adds a book to the collection. pass def find_books_by_author(self, author: str) -> List[str]: Finds and returns a list of book titles by the specified author. pass","solution":"from typing import List, Tuple class BookClub: def __init__(self): self.books = [] def add_book(self, title: str, author: str) -> None: self.books.append((title, author)) def find_books_by_author(self, author: str) -> List[str]: return [title for title, book_author in self.books if book_author == author]"},{"question":"def allocate_resources(tasks: List[Dict], available_resources: Dict[str, int]) -> Tuple[List[Dict], int]: Allocate resources to tasks while minimizing the total cost. Args: tasks (list): A list of tasks, where each task is a dictionary with 'required_resources' and 'cost' keys. available_resources (dict): A dictionary of available resources with resource types as keys and quantities as values. Returns: tuple: A tuple containing a list of tasks that can be successfully allocated and the total cost. Example: >>> tasks = [ ... {\\"required_resources\\": {\\"cpu\\": 2, \\"memory\\": 4}, \\"cost\\": 100}, ... {\\"required_resources\\": {\\"cpu\\": 1, \\"memory\\": 2}, \\"cost\\": 50}, ... {\\"required_resources\\": {\\"cpu\\": 3, \\"memory\\": 6}, \\"cost\\": 200}, ... ] ... >>> available_resources = { ... \\"cpu\\": 4, ... \\"memory\\": 8, ... } ... >>> allocate_resources(tasks, available_resources) ([ {\\"required_resources\\": {\\"cpu\\": 2, \\"memory\\": 4}, \\"cost\\": 100}, {\\"required_resources\\": {\\"cpu\\": 1, \\"memory\\": 2}, \\"cost\\": 50}, ], 150)","solution":"def allocate_resources(tasks, available_resources): allocated_tasks = [] total_cost = 0 for task in tasks: can_allocate = True for resource, quantity in task['required_resources'].items(): if available_resources.get(resource, 0) < quantity: can_allocate = False break if can_allocate: allocated_tasks.append(task) total_cost += task['cost'] for resource, quantity in task['required_resources'].items(): available_resources[resource] -= quantity return allocated_tasks, total_cost"},{"question":"def isHarmoniousSequence(N: int, k: int, m: int) -> bool: Determines if the sequence generated by note formula is harmonious. Args: N: int - Length of the sequence. k: int - Multiplier constant. m: int - Modulus constant. Returns: bool - True if the sequence is harmonious, False otherwise. >>> isHarmoniousSequence(4, 3, 5) True >>> isHarmoniousSequence(5, 2, 4) False >>> isHarmoniousSequence(1, 1, 1) True >>> isHarmoniousSequence(10, 0, 1) False >>> isHarmoniousSequence(10, 7, 11) True >>> isHarmoniousSequence(5, 1, 5) True >>> isHarmoniousSequence(5, 2, 3) False >>> isHarmoniousSequence(1000000, 2, 4) False >>> isHarmoniousSequence(1000000, 123456, 1000003) True","solution":"def isHarmoniousSequence(N, k, m): Determines if the sequence generated by note formula is harmonious. Args: N: int - Length of the sequence. k: int - Multiplier constant. m: int - Modulus constant. Returns: bool - True if the sequence is harmonious, False otherwise. notes = set() for i in range(N): note = (i * k) % m if note in notes: return False notes.add(note) return True"},{"question":"from typing import List def is_palindrome_permutation(s: str) -> bool: Return True if the input string can be rearranged to form a palindrome, else False. Ignore spaces and consider characters case-insensitively. def check_palindrome_permutations(input_list: List[str]) -> List[bool]: Takes a list of strings and returns a list of booleans indicating if each string is a palindrome permutation. >>> check_palindrome_permutations([\\"Tact Coa\\", \\"Hello\\", \\"A man a plan a canal Panama\\", \\"No lemon no melon\\"]) [True, False, True, True] >>> check_palindrome_permutations([\\"abc cba\\", \\"ab cc ba\\", \\"ABCCBA\\"]) [True, True, True] >>> check_palindrome_permutations([\\"random\\", \\"not a palindrome\\"]) [False, False]","solution":"def is_palindrome_permutation(s): Return True if the input string can be rearranged to form a palindrome, else False. # Ignore spaces and consider characters case-insensitively s = s.replace(\\" \\", \\"\\").lower() # Create a frequency dictionary to count each character char_count = {} for char in s: char_count[char] = char_count.get(char, 0) + 1 # Check the frequency of characters odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # A string can be rearranged to form a palindrome if it has at most one character with an odd count return odd_count <= 1 def check_palindrome_permutations(input_list): Takes a list of strings and returns a list of booleans indicating if each string is a palindrome permutation. return [is_palindrome_permutation(s) for s in input_list]"},{"question":"def find_fibonacci_position(n: int) -> int: Returns the position in the Fibonacci sequence where the value is exactly n. If n is not a Fibonacci number, returns -1. >>> find_fibonacci_position(21) 8 >>> find_fibonacci_position(14) -1 >>> find_fibonacci_position(0) 0 >>> find_fibonacci_position(1) 1 >>> find_fibonacci_position(144) 12 >>> find_fibonacci_position(150) -1 pass def process_test_cases(test_cases: List[int]) -> List[int]: Processes a list of test cases and returns the smallest number of months required for a Fibonacci tree to have exactly the given number of leaves, or -1 if it is not possible. >>> process_test_cases([21, 14, 0]) [8, -1, 0] pass","solution":"def find_fibonacci_position(n): Returns the position in the Fibonacci sequence where the value is exactly n. If n is not a Fibonacci number, returns -1. if n == 0: return 0 a, b = 0, 1 position = 1 while b <= n: if b == n: return position a, b = b, a + b position += 1 return -1 def process_test_cases(test_cases): results = [] for n in test_cases: result = find_fibonacci_position(n) results.append(result) return results"},{"question":"from typing import List def longest_arithmetic_subsequence(arr: List[int]) -> int: Calculate the length of the Longest Arithmetic Subsequence (LAS) in a list of integers. Args: arr (List[int]): A list of integers. Returns: int: The length of the longest arithmetic subsequence. Examples: >>> longest_arithmetic_subsequence([3, 6, 9, 12]) 4 >>> longest_arithmetic_subsequence([9, 4, 7, 2, 10]) 3 >>> longest_arithmetic_subsequence([20, 1, 15, 3, 10, 5, 8]) 4 def test_longest_arithmetic_subsequence(): def test_case(arr, expected): assert longest_arithmetic_subsequence(arr) == expected test_case([3, 6, 9, 12], 4) test_case([9, 4, 7, 2, 10], 3) test_case([20, 1, 15, 3, 10, 5, 8], 4) test_case([1, 5, 9, 13, 17], 5) test_case([1], 1) test_case([1, 2, 3, 4, 5, 6, 7], 7) test_case([10, 20, 30, 40, 50], 5) test_case([2, 2, 2, 2], 4) test_case([1, 3, 5, 7, 9, 11], 6) test_case([], 0)","solution":"from typing import List def longest_arithmetic_subsequence(arr: List[int]) -> int: if not arr: return 0 n = len(arr) if n == 1: return 1 dp = [{} for _ in range(n)] max_length = 2 # Minimal length of arithmetic sequence is 2 for i in range(1, n): for j in range(i): diff = arr[i] - arr[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"def generate_registration_numbers(n: int, names: List[str]) -> List[str]: Generates registration numbers for participants based on their first and last names. Parameters: - n: integer, number of participants - names: list of strings, each string being a participant's name in the format \\"First Last\\" Returns: - list of strings, each string being a registration number in the format \\"FL#\\" >>> generate_registration_numbers(1, [\\"John Doe\\"]) [\\"JD001\\"] >>> generate_registration_numbers(3, [\\"Alice Johnson\\", \\"Bob Smith\\", \\"Charlie Brown\\"]) [\\"AJ001\\", \\"BS002\\", \\"CB003\\"] >>> generate_registration_numbers(2, [\\"John Doe\\", \\"Jane Smith\\"]) [\\"JD001\\", \\"JS002\\"] >>> generate_registration_numbers(4, [\\"Participant One\\", \\"Participant Two\\", \\"Participant Three\\", \\"Participant Four\\"]) [\\"PO001\\", \\"PT002\\", \\"PT003\\", \\"PF004\\"] >>> generate_registration_numbers(4, [\\"First Last\\", \\"Another Person\\", \\"One More\\", \\"Final Entry\\"]) [\\"FL001\\", \\"AP002\\", \\"OM003\\", \\"FE004\\"]","solution":"def generate_registration_numbers(n, names): Generates registration numbers for participants. Parameters: - n: integer, number of participants - names: list of strings, each string being a participant's name in the format \\"First Last\\" Returns: - list of strings, each string being a registration number in the format \\"FL#\\" registration_numbers = [] for i, full_name in enumerate(names, 1): first_name, last_name = full_name.split() reg_number = first_name[0].upper() + last_name[0].upper() + f\\"{i:03}\\" registration_numbers.append(reg_number) return registration_numbers"},{"question":"import random from typing import List def simulate_bandits(N: int, machine1: List[int], machine2: List[int]) -> int: Simulates N plays on two slot machines to maximize the total payout. Args: N (int): The number of plays. machine1 (list of int): Payouts for the first slot machine. machine2 (list of int): Payouts for the second slot machine. Returns: int: Maximum possible total payout after N plays. >>> simulate_bandits(5, [1, -1, 2], [2, 1, -2]) 10 >>> simulate_bandits(10, [0, 0, 0], [0, 0, 0]) 0","solution":"import random def simulate_bandits(N, machine1, machine2): Simulates N plays on two slot machines to maximize the total payout. Args: N (int): The number of plays. machine1 (list of int): Payouts for the first slot machine. machine2 (list of int): Payouts for the second slot machine. Returns: int: Maximum possible total payout after N plays. total_payout = 0 # Calculate and compare average payouts of the two machines avg_machine1 = sum(machine1) / len(machine1) avg_machine2 = sum(machine2) / len(machine2) # Choose the machine with the higher average payout for all plays chosen_machine = machine1 if avg_machine1 > avg_machine2 else machine2 for _ in range(N): payout = random.choice(chosen_machine) total_payout += payout return total_payout"},{"question":"def find_t(s: str, n: int, k: int) -> str: Determine if there exists a string \`t\` such that its Levenshtein distance from \`s\` is exactly \`k\`. Args: s (str): The original string of length \`n\`. n (int): The length of the string \`s\`. k (int): The desired Levenshtein distance. Returns: str: A string \`t\` of length \`m\` where the Levenshtein distance between \`s\` and \`t\` is \`k\` if such a \`t\` exists, otherwise \\"IMPOSSIBLE\\". >>> find_t(\\"abc\\", 3, 2) 'abcc' >>> find_t(\\"test\\", 4, 0) 'test' >>> find_t(\\"hello\\", 5, 6) 'IMPOSSIBLE'","solution":"def find_t(s, n, k): Determine if there exists a string t such that its Levenshtein distance from s is exactly k. if k > len(s): # If k is greater than the length of s, creating such a t is impossible return \\"IMPOSSIBLE\\" if k == 0: # If k is 0, the string t should be same as s return s # Base condition: if k <= n, we can simply try to extend the string with k modifications t = s # We can append characters to the string \`t\` to achieve the required Levenshtein distance t += 'a' * k return t"},{"question":"from typing import List, Tuple def is_prime(num: int) -> bool: Check if the given number is a prime number. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(11) True def min_milestones_for_prime_distance(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of milestones (including the first and last) the driver can travel through to ensure the total distance is a prime number. If it is impossible, return -1. >>> min_milestones_for_prime_distance([(5, [2, 3, 5, 7, 11]), (4, [10, 20, 30, 40])]) [2, -1] >>> min_milestones_for_prime_distance([(3, [17, 19, 23]), (3, [24, 36, 48])]) [2, -1] def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(5) == True assert is_prime(10) == False assert is_prime(11) == True def test_min_milestones_for_prime_distance(): test_cases = [(5, [2, 3, 5, 7, 11]), (4, [10, 20, 30, 40])] expected = [2, -1] assert min_milestones_for_prime_distance(test_cases) == expected test_cases = [(3, [17, 19, 23]), (3, [24, 36, 48])] expected = [2, -1] assert min_milestones_for_prime_distance(test_cases) == expected test_cases = [(6, [1, 3, 6, 10, 15, 21]), (5, [7, 11, 13, 17, 19])] expected = [2, 2] assert min_milestones_for_prime_distance(test_cases) == expected test_is_prime() test_min_milestones_for_prime_distance()","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if (num % i == 0) or (num % (i + 2) == 0): return False i += 6 return True def min_milestones_for_prime_distance(test_cases): results = [] for case in test_cases: N, milestones = case found = False min_milestones = float('inf') for i in range(N): for j in range(i+1, N): distance = milestones[j] - milestones[i] if is_prime(distance): num_milestones = j - i + 1 min_milestones = min(min_milestones, num_milestones) found = True if found: results.append(min_milestones) else: results.append(-1) return results # Example usage: if __name__ == \\"__main__\\": T = int(input()) test_cases = [] for _ in range(T): N = int(input()) milestones = list(map(int, input().split())) test_cases.append((N, milestones)) results = min_milestones_for_prime_distance(test_cases) for result in results: print(result)"},{"question":"def alternate_case(s: str) -> str: Returns a new string with the case of each alphabetic character switched. Non-alphabetic characters remain unchanged. Args: s (str): The input string. Returns: str: The string with cases of alphabetic characters switched. >>> alternate_case(\\"Hello, World!\\") 'hELLO, wORLD!' >>> alternate_case(\\"\\") '' >>> alternate_case(\\"hello\\") 'HELLO' >>> alternate_case(\\"123!@#\\") '123!@#' >>> alternate_case(\\"PyThOn!\\") 'pYtHoN!' pass def reverse_words(s: str) -> str: Returns a new string with the order of the words reversed. Characters in each word remain in their original order. Args: s (str): The input string. Returns: str: The string with the order of the words reversed. >>> reverse_words(\\"Hello, World!\\") 'World! Hello,' >>> reverse_words(\\"Hello\\") 'Hello' >>> reverse_words(\\"\\") '' >>> reverse_words(\\"Hello World !\\") '! World Hello' >>> reverse_words(\\"Hello, world\\") 'world Hello,' pass","solution":"def alternate_case(s): Returns a new string with the case of each alphabetic character switched. Non-alphabetic characters remain unchanged. return ''.join([char.lower() if char.isupper() else char.upper() for char in s]) def reverse_words(s): Returns a new string with the order of the words reversed. Characters in each word remain in their original order. words = s.split(' ') reversed_words = ' '.join(reversed(words)) return reversed_words"},{"question":"def validate_codes(codes: List[str]) -> List[str]: Determines if the codes are VALID or INVALID based on the given pattern: - Starts with a letter (uppercase or lowercase) - Contains at least one digit - Length of exactly 6 characters Args: codes: List of strings representing the codes. Returns: List of strings \\"VALID\\" or \\"INVALID\\" for each code in the input list. >>> validate_codes([\\"a1b2C3\\", \\"123456\\", \\"abcdef\\", \\"A12B34\\"]) [\\"VALID\\", \\"INVALID\\", \\"INVALID\\", \\"VALID\\"] >>> validate_codes([\\"1a1a1a\\", \\"abcdef\\"]) [\\"INVALID\\", \\"INVALID\\"]","solution":"def validate_codes(codes): Determines if the codes are VALID or INVALID based on the given pattern: - Starts with a letter (uppercase or lowercase) - Contains at least one digit - Length of exactly 6 characters Args: codes: List of strings representing the codes. Returns: List of strings \\"VALID\\" or \\"INVALID\\" for each code in the input list. results = [] for code in codes: if len(code) == 6 and code[0].isalpha() and any(char.isdigit() for char in code): results.append(\\"VALID\\") else: results.append(\\"INVALID\\") return results"},{"question":"from typing import List def min_changes_to_identical_subarray(n: int, k: int, m: int, arr: List[int]) -> int: Determine the smallest number of changes required to make all elements in at least one contiguous subarray of length at least m identical. >>> min_changes_to_identical_subarray(10, 3, 4, [1, 3, 2, 2, 2, 1, 1, 2, 3, 2]) 1 >>> min_changes_to_identical_subarray(5, 2, 3, [1, 1, 1, 1, 1]) 0 >>> min_changes_to_identical_subarray(6, 6, 2, [1, 2, 3, 4, 5, 6]) 1 >>> min_changes_to_identical_subarray(4, 2, 1, [1, 2, 1, 2]) 0 >>> min_changes_to_identical_subarray(5, 2, 5, [1, 2, 2, 1, 1]) 2 >>> min_changes_to_identical_subarray(7, 2, 3, [1, 2, 1, 2, 1, 1, 2]) 1 # Implement the function here","solution":"def min_changes_to_identical_subarray(n, k, m, arr): from collections import defaultdict min_changes = float('inf') # iterate over array for all possible starting points of subarray with length m for start in range(n - m + 1): frequency = defaultdict(int) # count the frequencies of elements in the subarray of length m for i in range(start, start + m): frequency[arr[i]] += 1 # find the maximum frequency in the subarray max_freq = max(frequency.values()) # calculate the number of changes needed for this subarray changes_needed = m - max_freq min_changes = min(min_changes, changes_needed) return min_changes"},{"question":"from typing import List def can_partition(nums: List[int]) -> bool: Determines if it is possible to partition the list into two parts such that the sum of the elements in both parts is equal. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False","solution":"from typing import List def can_partition(nums: List[int]) -> bool: total = sum(nums) # If the total sum is odd, it's impossible to partition it into two equal parts if total % 2 != 0: return False target = total // 2 dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"def marathon_ranking(n: int, m: int, pairs: List[Tuple[int, int]]) -> str: Determine the consistency of marathon participants' finishing times based on reported pairwise rankings. Args: n : int : number of participants m : int : number of reported comparisons pairs : List[Tuple[int, int]] : list of tuples where each tuple (A, B) means participant A finished before participant B Returns: str : \\"consistent\\" if the reported finishing times are consistent, \\"inconsistent\\" otherwise Examples: >>> marathon_ranking(4, 3, [(0, 1), (1, 2), (2, 3)]) 'consistent' >>> marathon_ranking(4, 3, [(0, 1), (2, 1), (1, 3)]) 'consistent' >>> marathon_ranking(4, 3, [(0, 1), (2, 1), (1, 2)]) 'inconsistent'","solution":"def check_consistency(n, m, comparisons): from collections import defaultdict, deque # Create a graph based on the pairwise comparisons graph = defaultdict(list) in_degree = [0] * n for a, b in comparisons: graph[a].append(b) in_degree[b] += 1 # Topological Sort (Kahn's Algorithm) queue = deque([node for node in range(n) if in_degree[node] == 0]) sorted_list = [] while queue: node = queue.popleft() sorted_list.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If we can sort all nodes, the sorting is consistent if len(sorted_list) == n: return 'consistent' else: return 'inconsistent' # Function to input the data and call the check_consistency function def marathon_ranking(n, m, pairs): return check_consistency(n, m, pairs)"},{"question":"def find_poorly_performing_servers(servers_data: List[str]) -> List[str]: Determine which servers are performing poorly based on their average latency exceeding a given threshold. >>> find_poorly_performing_servers([\\"server1 100.0 120.5 130.2 110.0\\", \\"server2 150.0 100.0 120.0 140.0\\", \\"server3 90.0 85.0 95.0 105.0\\"]) [\\"server1\\", \\"server3\\"] >>> find_poorly_performing_servers([\\"server1 150.0 120.5 130.2 110.0\\", \\"server2 200.0 100.0 120.0 140.0\\", \\"server3 180.0 85.0 95.0 105.0\\"]) [\\"All servers are healthy\\"]","solution":"def find_poorly_performing_servers(servers_data): poorly_performing_servers = [] for server_data in servers_data: parts = server_data.split() server_id = parts[0] threshold = float(parts[1]) latencies = list(map(float, parts[2:])) average_latency = sum(latencies) / len(latencies) if average_latency > threshold: poorly_performing_servers.append(server_id) if not poorly_performing_servers: return [\\"All servers are healthy\\"] else: return poorly_performing_servers"},{"question":"def earliest_trigger_time(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Find the earliest time at which Luigi needs to start triggering the traps to catch the ghost. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers S and P. Returns: List[int]: A list of integers where each integer represents the earliest time (in seconds) for the corresponding test case. >>> earliest_trigger_time(3, [(2, 4), (3, 9), (1, 10)]) [2, 3, 10] >>> earliest_trigger_time(2, [(5, 25), (10, 100)]) [5, 10] >>> earliest_trigger_time(3, [(1, 1), (2, 2), (3, 3)]) [1, 1, 1] >>> earliest_trigger_time(1, [(4, 16)]) [4] >>> earliest_trigger_time(4, [(7, 49), (8, 64), (6, 36), (9, 81)]) [7, 8, 6, 9] >>> earliest_trigger_time(2, [(1, 100), (100, 1)]) [100, 0]","solution":"def earliest_trigger_time(T, test_cases): results = [] for case in test_cases: S, P = case # Calculate the earliest time to start triggering the traps time = P // S results.append(time) return results"},{"question":"def rotateMatrix(mat): Rotates the given n x n 2D matrix by 90 degrees in clockwise direction in-place. Args: mat: List[List[int]] -- n x n 2D matrix Returns: List[List[int]] -- Rotated n x n 2D matrix Example: >>> rotateMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotateMatrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] # Test cases def test_rotateMatrix_3x3(): mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotateMatrix(mat) == rotated def test_rotateMatrix_2x2(): mat = [ [1, 2], [3, 4] ] rotated = [ [3, 1], [4, 2] ] assert rotateMatrix(mat) == rotated def test_rotateMatrix_1x1(): mat = [ [42] ] rotated = [ [42] ] assert rotateMatrix(mat) == rotated def test_rotateMatrix_4x4(): mat = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotated = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotateMatrix(mat) == rotated def test_rotateMatrix_5x5(): mat = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] rotated = [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ] assert rotateMatrix(mat) == rotated","solution":"def rotateMatrix(mat): Rotates the given n x n 2D matrix by 90 degrees in clockwise direction in-place. n = len(mat) # Transpose the matrix for i in range(n): for j in range(i + 1, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j] # Reverse each row for i in range(n): mat[i].reverse() return mat"},{"question":"def can_reach_endpoint(M, N, E, grid): Determines if the hiker can reach the endpoint from the start point with the given energy level. Parameters: M (int): number of rows in the grid. N (int): number of columns in the grid. E (int): initial energy level of the hiker. grid (list of str): the grid representing the trail. Returns: str: \\"YES\\" if the hiker can reach the endpoint, otherwise \\"NO\\". pass # Your implementation here def test_can_reach_endpoint(): assert can_reach_endpoint(5, 6, 10, [ \\"S.....\\", \\".#..\\", \\"..#...\\", \\"..\\", \\"...E..\\" ]) == \\"YES\\" assert can_reach_endpoint(5, 6, 5, [ \\"S.....\\", \\".#..\\", \\"..#...\\", \\"..\\", \\"...E..\\" ]) == \\"NO\\" def test_with_exact_energy(): assert can_reach_endpoint(3, 3, 4, [ \\"S.#\\", \\"..#\\", \\"#.E\\" ]) == \\"YES\\" def test_with_obstacles_unreachable(): assert can_reach_endpoint(3, 3, 5, [ \\"S\\", \\"#\\", \\"E\\" ]) == \\"NO\\" def test_minimal_case(): assert can_reach_endpoint(1, 1, 1, [\\"S\\"]) == \\"NO\\" assert can_reach_endpoint(2, 2, 1, [ \\"S.\\", \\".E\\" ]) == \\"NO\\" def test_reachable_with_extra_energy(): assert can_reach_endpoint(4, 4, 15, [ \\"S...\\", \\".#..\\", \\"..\\", \\"...E\\" ]) == \\"YES\\"","solution":"from collections import deque def can_reach_endpoint(M, N, E, grid): Determines if the hiker can reach the endpoint from the start point with the given energy level. Parameters: M (int): number of rows in the grid. N (int): number of columns in the grid. E (int): initial energy level of the hiker. grid (list of str): the grid representing the trail. Returns: str: \\"YES\\" if the hiker can reach the endpoint, otherwise \\"NO\\". directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] start = end = None # Locate start and end points for i in range(M): for j in range(N): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'E': end = (i, j) if not start or not end: return \\"NO\\" # BFS to find the shortest path queue = deque([(start[0], start[1], E)]) visited = set() visited.add((start[0], start[1])) while queue: x, y, energy = queue.popleft() if (x, y) == end: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and grid[nx][ny] != '#' and (nx, ny) not in visited: if energy - 1 >= 0: queue.append((nx, ny, energy - 1)) visited.add((nx, ny)) return \\"NO\\""},{"question":"import heapq from typing import List, Tuple def find_minimum_toll(n: int, m: int, edges: List[Tuple[int, int, int]], k: int, queries: List[Tuple[int, int, int]]) -> List[str]: Determines if it is possible for each person to travel between their specified cities within their budget, and if so, finds the minimum toll cost for each person to make the trip. >>> find_minimum_toll(4, 4, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 1, 10)], 3, [(1, 3, 25), (1, 4, 5), (2, 4, 20)]) [\\"YES 20\\", \\"NO\\", \\"YES 20\\"] >>> find_minimum_toll(3, 3, [(1, 2, 5), (2, 3, 5), (1, 3, 15)], 2, [(1, 3, 10), (2, 3, 10)]) [\\"YES 10\\", \\"YES 5\\"]","solution":"import heapq def find_minimum_toll(n, m, edges, k, queries): # Create adjacency list adj = [[] for _ in range(n + 1)] for u, v, c in edges: adj[u].append((v, c)) adj[v].append((u, c)) # Dijkstra to find minimum toll cost between all pairs of cities def dijkstra(source): dist = [float('inf')] * (n + 1) dist[source] = 0 pq = [(0, source)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in adj[u]: if dist[u] + weight < dist[v]: dist[v] = dist[u] + weight heapq.heappush(pq, (dist[v], v)) return dist results = [] for a, b, max_budget in queries: dist_from_a = dijkstra(a) if dist_from_a[b] <= max_budget: results.append(f\\"YES {dist_from_a[b]}\\") else: results.append(\\"NO\\") return results"},{"question":"def process_commands(commands: List[str]) -> List[int]: Process a list of commands to manage hierarchical file storage and retrieve folder sizes. >>> process_commands([ \\"8\\", \\"ADD_FOLDER root documents\\", \\"ADD_FILE documents file1 1000\\", \\"ADD_FOLDER documents projects\\", \\"ADD_FILE projects file2 3000\\", \\"ADD_FOLDER root music\\", \\"ADD_FILE music file3 2000\\", \\"QUERY root\\", \\"QUERY music\\" ]) [6000, 2000] >>> process_commands([ \\"6\\", \\"ADD_FOLDER root a\\", \\"ADD_FILE a file1 100\\", \\"ADD_FILE a file2 200\\", \\"ADD_FOLDER a b\\", \\"ADD_FILE b file3 300\\", \\"QUERY a\\" ]) [600] >>> process_commands([ \\"2\\", \\"ADD_FOLDER root empty\\", \\"QUERY empty\\" ]) [0] >>> process_commands([ \\"10\\", \\"ADD_FOLDER root f1\\", \\"ADD_FOLDER f1 f2\\", \\"ADD_FILE f2 file1 400\\", \\"ADD_FILE f1 file2 100\\", \\"ADD_FOLDER root f3\\", \\"ADD_FILE f3 file3 500\\", \\"QUERY f1\\", \\"QUERY f2\\", \\"QUERY f3\\", \\"QUERY root\\" ]) [500, 400, 500, 1000]","solution":"class Folder: def __init__(self): self.files = {} self.subfolders = {} self.total_size_cache = None class FileStorageSystem: def __init__(self): self.root = Folder() self.folders = {'root': self.root} def add_file(self, folder_id, file_id, size): if folder_id in self.folders: self.folders[folder_id].files[file_id] = size self.invalidate_cache(folder_id) def add_folder(self, parent_folder_id, folder_id): if parent_folder_id in self.folders: new_folder = Folder() self.folders[parent_folder_id].subfolders[folder_id] = new_folder self.folders[folder_id] = new_folder self.invalidate_cache(parent_folder_id) def invalidate_cache(self, folder_id): stack = [folder_id] while stack: current = stack.pop() if current in self.folders: self.folders[current].total_size_cache = None stack.extend(self.folders[current].subfolders.keys()) def compute_total_size(self, folder): if folder.total_size_cache is not None: return folder.total_size_cache total_size = sum(folder.files.values()) for subfolder in folder.subfolders.values(): total_size += self.compute_total_size(subfolder) folder.total_size_cache = total_size return total_size def query(self, folder_id): if folder_id in self.folders: return self.compute_total_size(self.folders[folder_id]) return 0 def process_commands(commands): fss = FileStorageSystem() results = [] for command in commands: parts = command.split() if parts[0] == 'ADD_FILE': fss.add_file(parts[1], parts[2], int(parts[3])) elif parts[0] == 'ADD_FOLDER': fss.add_folder(parts[1], parts[2]) elif parts[0] == 'QUERY': results.append(fss.query(parts[1])) return results"},{"question":"def knight_moves(position: str) -> int: Returns the number of valid moves the knight can make from the given starting position. Parameters: position (str): The current position of the knight on the chessboard (e.g., 'd4'). Returns: int: The number of valid moves the knight can make from the given position. Examples: >>> knight_moves(\\"d4\\") 8 >>> knight_moves(\\"a1\\") 2 >>> knight_moves(\\"g7\\") 4","solution":"def knight_moves(position): Returns the number of valid moves the knight can make from the given position. # Moves a knight can make on a chessboard moves = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] # Generate the initial position from the given input file, rank = position file = ord(file) - ord('a') + 1 rank = int(rank) valid_moves = 0 # Check all potential moves to see if they are within the board limits for move in moves: new_file = file + move[0] new_rank = rank + move[1] if 1 <= new_file <= 8 and 1 <= new_rank <= 8: valid_moves += 1 return valid_moves # Example usage: # print(knight_moves(\\"d4\\")) # Output: 8 # print(knight_moves(\\"a1\\")) # Output: 2 # print(knight_moves(\\"g7\\")) # Output: 4"},{"question":"def max_block_length(K, components, L): Calculate the maximum length of the block that can be created without exceeding L. >>> max_block_length(3, [(5, 3), (10, 2), (3, 8)], 25) 25 >>> max_block_length(2, [(1, 2), (2, 3)], 10) 8 >>> max_block_length(2, [(5, 1), (10, 2)], 20) 20 >>> max_block_length(3, [(5, 1), (10, 1), (2, 3)], 18) 17 >>> max_block_length(3, [(5, 3), (10, 2), (100, 2)], 25) 25","solution":"def max_block_length(K, components, L): dp = [0] * (L + 1) for size, count in components: for j in range(L, size - 1, -1): for k in range(1, count + 1): if j - k * size >= 0: dp[j] = max(dp[j], dp[j - k * size] + k * size) return dp[L] # Function to process input and call the main function def solve(): import sys input = sys.stdin.read data = input().split() K = int(data[0]) components = [] index = 1 for _ in range(K): size = int(data[index]) count = int(data[index + 1]) components.append((size, count)) index += 2 L = int(data[index]) print(max_block_length(K, components, L))"},{"question":"from typing import List, Tuple def subtree_sum(n: int, edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: Given the number of nodes, edges, and queries, this function returns the sum of the values in the subtree rooted at each query node. Parameters: n (int): The number of nodes in the tree. edges (List[Tuple[int, int]]): A list of tuples where each tuple (u, v) represents an edge between nodes u and v. queries (List[int]): A list of integers representing the query nodes. Returns: List[int]: A list of integers where each integer is the sum of the values in the subtree rooted at the corresponding query node. Example: >>> subtree_sum(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], [2, 3, 1]) [11, 16, 28] >>> subtree_sum(1, [], [1]) [1] >>> subtree_sum(2, [(1, 2)], [1, 2]) [3, 2]","solution":"from typing import List, Tuple from collections import defaultdict def subtree_sum(n: int, edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) def dfs(node, parent): total_sum = node for neighbor in tree[node]: if neighbor != parent: total_sum += dfs(neighbor, node) subtree_sums[node] = total_sum return total_sum subtree_sums = {} dfs(1, -1) return [subtree_sums[query] for query in queries]"},{"question":"def longest_palindrome(s: str) -> str: Finds the longest palindromic substring in the given string s. >>> longest_palindrome(\\"babad\\") \\"bab\\" >>> longest_palindrome(\\"cbbd\\") \\"bb\\"","solution":"def longest_palindrome(s): Finds the longest palindromic substring in the given string s. Args: s (str): The string to search within. Returns: str: The longest palindromic substring. def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if not s or len(s) == 1: return s longest = '' for i in range(len(s)): # Try to expand for odd length palindrome odd_pal = expand_around_center(i, i) if len(odd_pal) > len(longest): longest = odd_pal # Try to expand for even length palindrome even_pal = expand_around_center(i, i + 1) if len(even_pal) > len(longest): longest = even_pal return longest"},{"question":"from typing import List def process_queries(N: int, A: List[int], K: int, Q: int, queries: List[List[int]]) -> List[int]: Process the queries on the array to either update an element or check if it is well-ordered. Args: N (int): Size of the array. A (List[int]): Array of integers. K (int): Size of the subarray. Q (int): Number of queries. queries (List[List[int]]): List of queries to be processed. Returns: List[int]: Result of query type 2 (check if well-ordered). Example: >>> N = 5 >>> A = [3, 1, 4, 1, 5] >>> K = 3 >>> Q = 6 >>> queries = [ ... [1, 2, 6], ... [2], ... [1, 5, 9], ... [2], ... [1, 3, 2], ... [2] ... ] >>> process_queries(N, A, K, Q, queries) [0, 0, 0] >>> N = 3 >>> A = [1, 1, 1] >>> K = 3 >>> Q = 3 >>> queries = [ ... [2], ... [1, 1, 2], ... [2] ... ] >>> process_queries(N, A, K, Q, queries) [1, 1] >>> N = 1 >>> A = [1] >>> K = 1 >>> Q = 2 >>> queries = [ ... [2], ... [1, 1, 2] ... ] >>> process_queries(N, A, K, Q, queries) [1]","solution":"def process_queries(N, A, K, Q, queries): from itertools import islice result = [] def is_well_ordered(): if K > N: return 1 subarray_sum = sum(A[:K]) for i in range(1, N - K + 1): new_sum = subarray_sum - A[i - 1] + A[i + K - 1] if new_sum != subarray_sum: return 0 return 1 for query in queries: if query[0] == 2: result.append(is_well_ordered()) else: _, i, x = query A[i - 1] = x return result"},{"question":"def evaluate_expression(s: str) -> int: Evaluates a given valid arithmetic expression containing integers, the operators '+', '-', '*', '/', and parentheses '(', ')'. - The expression may contain spaces between characters which should be ignored. - Division should truncate towards zero for negative numbers. Args: s (str): The input arithmetic expression as a string. Returns: int: The resulting integer after evaluating the expression. Examples: >>> evaluate_expression(\\"3+2 * 2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" 2-1 + 2 \\") 3 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23 >>> evaluate_expression(\\"14/3 * 2\\") 8","solution":"def evaluate_expression(s: str) -> int: def apply_operator(operators, values): right = values.pop() left = values.pop() operator = operators.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(int(left / right)) # truncate division towards zero def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 operators = [] values = [] i = 0 n = len(s) while i < n: if s[i] == ' ': i += 1 continue elif s[i] == '(': operators.append(s[i]) elif s[i].isdigit(): val = 0 while i < n and s[i].isdigit(): val = val * 10 + int(s[i]) i += 1 values.append(val) i -= 1 elif s[i] == ')': while operators and operators[-1] != '(': apply_operator(operators, values) operators.pop() else: while (operators and precedence(operators[-1]) >= precedence(s[i])): apply_operator(operators, values) operators.append(s[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"def can_arrange_balls_without_adjacent(R, B): Determine if it's possible to arrange the balls such that no two adjacent balls are of the same color. :param R: Number of red balls :param B: Number of blue balls :return: \\"Possible\\" if it is feasible to arrange, otherwise \\"Not Possible\\" >>> can_arrange_balls_without_adjacent(3, 4) == \\"Possible\\" >>> can_arrange_balls_without_adjacent(5, 5) == \\"Possible\\" >>> can_arrange_balls_without_adjacent(2, 3) == \\"Possible\\" >>> can_arrange_balls_without_adjacent(1, 3) == \\"Not Possible\\" >>> can_arrange_balls_without_adjacent(8, 7) == \\"Possible\\" >>> can_arrange_balls_without_adjacent(10, 0) == \\"Not Possible\\" def process_test_cases(test_cases): Process multiple test cases for the ball arrangement problem. :param test_cases: List of tuples containing test cases (R, B) :return: List of results for each test case >>> process_test_cases([(3, 4), (5, 5), (2, 3)]) == [\\"Possible\\", \\"Possible\\", \\"Possible\\"] >>> process_test_cases([(1, 3), (7, 7), (9, 8)]) == [\\"Not Possible\\", \\"Possible\\", \\"Possible\\"] >>> process_test_cases([(100, 1), (50, 49), (0, 0)]) == [\\"Not Possible\\", \\"Possible\\", \\"Possible\\"]","solution":"def can_arrange_balls_without_adjacent(R, B): Determine if it's possible to arrange the balls such that no two adjacent balls are of the same color. :param R: Number of red balls :param B: Number of blue balls :return: \\"Possible\\" if it is feasible to arrange, otherwise \\"Not Possible\\" # Check if the difference between the counts of red and blue balls is greater than 1 if abs(R - B) > 1: return \\"Not Possible\\" else: return \\"Possible\\" def process_test_cases(test_cases): Process multiple test cases for the ball arrangement problem. :param test_cases: List of tuples containing test cases (R, B) :return: List of results for each test case results = [] for R, B in test_cases: result = can_arrange_balls_without_adjacent(R, B) results.append(result) return results"},{"question":"def amusement_park(N, M, Q, thrill_levels, tickets, queries): Simulate the amusement park operation with the given number of rides, tickets, and queries. :param N: The number of rides :param M: The number of tickets :param Q: The number of queries :param thrill_levels: List of thrill levels of the rides :param tickets: List of lists containing the rides accessible with each ticket :param queries: The queries to perform :return: List of maximum thrill levels for the relevant queries >>> amusement_park(5, 2, 3, [3, 5, 4, 2, 1], [[3, 1, 2, 3], [2, 3, 5]], [[2, 1, 2, 100], [1, 3, 10], [2, 1, 2, 100]]) [5, 10] >>> amusement_park(4, 3, 4, [7, 2, 9, 4], [[2, 1, 2], [2, 3, 4], [2, 1, 3]], [[2, 1, 3, 100], [1, 2, 8], [2, 1, 2, 100], [1, 3, 10]]) [9, 9]","solution":"def amusement_park(N, M, Q, thrill_levels, tickets, queries): ride_thrills = thrill_levels[:] # Copy of thrill levels to modify ticket_rides = [set(ticket[1:]) for ticket in tickets] # [ {rides}, ... ] def update_thrill_level(X, Y): ride_thrills[X - 1] = Y def find_max_thrill_level(L, R): accessible_rides = set() for ticket_index in range(L - 1, R): accessible_rides.update(ticket_rides[ticket_index]) return max(ride_thrills[ride - 1] for ride in accessible_rides) result = [] for query in queries: if query[0] == 1: _, X, Y = query update_thrill_level(X, Y) elif query[0] == 2: _, L, R, K = query result.append(find_max_thrill_level(L, R)) return result"},{"question":"def minimum_flowers(N): Determines the minimum number of towns that need to be planted with flowers such that every 3x3 subgrid within an N x N grid contains at least one town with flowers, given constraints on the boundary cells. >>> minimum_flowers(3) == 1 >>> minimum_flowers(5) == 1 >>> minimum_flowers(6) == 4","solution":"def minimum_flowers(N): Determines the minimum number of towns that need to be planted with flowers such that every 3x3 subgrid within an N x N grid contains at least one town with flowers, given constraints on the boundary cells. # If N is less than 5, the grid itself is small enough that only one flower is needed if N < 5: return 1 # Subtract the boundary rows and columns where flowers cannot be planted inner_side = N - 2 # Calculate the number of flowers required by considering non-overlapping 3x3 subgrids flowers_per_row = inner_side // 3 if inner_side % 3 != 0: flowers_per_row += 1 flowers_per_column = inner_side // 3 if inner_side % 3 != 0: flowers_per_column += 1 return flowers_per_row * flowers_per_column # Example usage: # N = int(input()) # print(minimum_flowers(N))"},{"question":"def max_height_difference(n: int, activities: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Returns the maximum height difference at each unique timestamp in ascending order. >>> max_height_difference(5, [(1, 3), (3, -1), (1, -2), (2, 4), (3, 5)]) [(1, 3), (2, 4), (3, 5)] >>> max_height_difference(4, [(2, 3), (2, -3), (1, 5), (1, -6)]) [(1, 5), (2, 3)]","solution":"def max_height_difference(n, activities): Returns the maximum height difference at each unique timestamp in ascending order. height_map = {} for t, d in activities: if t in height_map: height_map[t] = max(height_map[t], d) else: height_map[t] = d result = sorted(height_map.items()) return result"},{"question":"from typing import List def max_product_of_selected_elements(N: int, M: int, b: List[int]) -> int: Function to calculate the maximum product of M selected elements from sequence b while keeping their order. Args: N: int : Length of the sequence b M: int : Number of elements to select to form sequence c b: list : List of integers representing the sequence b Returns: int: Maximum possible product of the selected M elements >>> max_product_of_selected_elements(5, 3, [1, 2, 3, 4, 5]) 60 >>> max_product_of_selected_elements(2, 1, [999, 1000]) 1000 >>> max_product_of_selected_elements(3, 3, [1, 2, 3]) 6 >>> max_product_of_selected_elements(5, 2, [1, 10, 10, 1, 1]) 100 >>> max_product_of_selected_elements(5, 2, [2, 3, 5, 7, 11]) 77 >>> max_product_of_selected_elements(4, 2, [5, 5, 5, 5]) 25 >>> max_product_of_selected_elements(6, 3, [1, 100, 1, 100, 1, 100]) 1000000","solution":"from itertools import combinations def max_product_of_selected_elements(N, M, b): Function to calculate the maximum product of M selected elements from sequence b while keeping their order. Args: N: int : Length of the sequence b M: int : Number of elements to select to form sequence c b: list : List of integers representing the sequence b Returns: int: Maximum possible product of the selected M elements max_product = -1 # Generate all combinations of M elements from the list b for combo in combinations(b, M): # Calculate the product of current combination product = 1 for num in combo: product *= num # Update max_product if current combination's product is greater if product > max_product: max_product = product return max_product"},{"question":"from typing import List def count_increasing_subarrays(n: int, d: int, arr: List[int]) -> int: Returns the number of increasing subarrays of length d in arr. >>> count_increasing_subarrays(8, 3, [1, 3, 5, 4, 2, 7, 8, 9]) 3 >>> count_increasing_subarrays(5, 2, [2, 2, 2, 2, 2]) 0","solution":"def count_increasing_subarrays(n, d, arr): Returns the number of increasing subarrays of length d in arr. count = 0 for i in range(n - d + 1): is_increasing = True for j in range(i, i + d - 1): if arr[j] >= arr[j + 1]: is_increasing = False break if is_increasing: count += 1 return count"},{"question":"def minWindow(S: str, P: str) -> str: Find the minimum length substring of S that contains all characters of P (including duplicates). >>> minWindow(\\"this is a test string\\", \\"tist\\") 't stri' >>> minWindow(\\"geeksforgeeks\\", \\"ork\\") 'ksfor' >>> minWindow(\\"abcdef\\", \\"xyz\\") '' >>> minWindow(\\"a\\", \\"a\\") 'a' >>> minWindow(\\"adobecodebanc\\", \\"abc\\") 'banc' >>> minWindow(\\"aa\\", \\"aa\\") 'aa' >>> minWindow(\\"\\", \\"\\") '' >>> minWindow(\\"hello\\", \\"world\\") ''","solution":"def minWindow(S, P): from collections import Counter, defaultdict len_s = len(S) len_p = len(P) if len_s < len_p: return \\"\\" count_p = Counter(P) count_s = defaultdict(int) required = len(count_p) formed = 0 l, r = 0, 0 min_length = float(\\"inf\\") min_left = 0 while r < len_s: character = S[r] count_s[character] += 1 if character in count_p and count_s[character] == count_p[character]: formed += 1 while l <= r and formed == required: character = S[l] if r - l + 1 < min_length: min_length = r - l + 1 min_left = l count_s[character] -= 1 if character in count_p and count_s[character] < count_p[character]: formed -= 1 l += 1 r += 1 if min_length == float(\\"inf\\"): return \\"\\" else: return S[min_left:min_left+min_length]"},{"question":"def trap_rainwater(arr: List[int]) -> int: Calculate the maximum amount of rainwater that can be trapped. :param arr: List of non-negative integers representing heights of bars. :return: Maximum amount of trapped rainwater. >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rainwater([1, 2, 3, 4, 5, 6]) 0 >>> trap_rainwater([3, 0, 2]) 2 >>> trap_rainwater([5]) 0 >>> trap_rainwater([6, 5, 4, 3, 2, 1]) 0 >>> trap_rainwater([3, 0, 0, 2, 0, 4]) 10","solution":"def trap_rainwater(arr): Calculate the maximum amount of rainwater that can be trapped. :param arr: List of non-negative integers representing heights of bars. :return: Maximum amount of trapped rainwater. if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - arr[i] return water_trapped # Function to process the input format def process_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:])) return trap_rainwater(arr) if __name__ == \\"__main__\\": print(process_input())"},{"question":"def process_actions(n: int, actions: List[str]) -> List[int]: Process actions on a user's shopping cart and return the results of the QUERY actions. The input actions can be: - \\"ADD item_name price quantity\\" - \\"REMOVE item_name quantity\\" - \\"QUERY\\" The function should return the total cost of the items in the cart for each \\"QUERY\\" action. >>> process_actions(6, [\\"ADD apple 10 5\\", \\"ADD banana 20 3\\", \\"QUERY\\", \\"REMOVE apple 2\\", \\"QUERY\\", \\"ADD apple 10 2\\"]) [110, 90] >>> process_actions(5, [\\"ADD book 12 7\\", \\"ADD pen 3 10\\", \\"QUERY\\", \\"REMOVE pen 5\\", \\"QUERY\\"]) [114, 99] import pytest def test_case_1(): actions = [ \\"ADD apple 10 5\\", \\"ADD banana 20 3\\", \\"QUERY\\", \\"REMOVE apple 2\\", \\"QUERY\\", \\"ADD apple 10 2\\" ] assert process_actions(6, actions) == [110, 90] def test_case_2(): actions = [ \\"ADD book 12 7\\", \\"ADD pen 3 10\\", \\"QUERY\\", \\"REMOVE pen 5\\", \\"QUERY\\" ] assert process_actions(5, actions) == [114, 99] def test_add_and_remove(): actions = [ \\"ADD item 100 2\\", \\"ADD item 100 3\\", \\"REMOVE item 1\\", \\"QUERY\\" ] assert process_actions(4, actions) == [400] def test_remove_all(): actions = [ \\"ADD item 50 5\\", \\"REMOVE item 5\\", \\"QUERY\\" ] assert process_actions(3, actions) == [0] def test_empty_cart(): actions = [ \\"QUERY\\" ] assert process_actions(1, actions) == [0] def test_multiple_items(): actions = [ \\"ADD item1 50 1\\", \\"ADD item2 70 2\\", \\"QUERY\\", \\"REMOVE item1 1\\", \\"REMOVE item2 1\\", \\"QUERY\\" ] assert process_actions(6, actions) == [190, 70]","solution":"def process_actions(n, actions): cart = {} def add_item(item_name, price, quantity): if item_name in cart: cart[item_name]['quantity'] += quantity cart[item_name]['price'] = price else: cart[item_name] = {'price': price, 'quantity': quantity} def remove_item(item_name, quantity): if item_name in cart: cart[item_name]['quantity'] -= quantity if cart[item_name]['quantity'] <= 0: del cart[item_name] def query_total(): total_cost = sum(item['price'] * item['quantity'] for item in cart.values()) return total_cost results = [] for action in actions: parts = action.split() if parts[0] == \\"ADD\\": _, item_name, price, quantity = parts add_item(item_name, int(price), int(quantity)) elif parts[0] == \\"REMOVE\\": _, item_name, quantity = parts remove_item(item_name, int(quantity)) elif parts[0] == \\"QUERY\\": results.append(query_total()) return results"},{"question":"def min_operations_to_sort_books(T, test_cases): Determines the minimum number of operations needed to sort books on a shelf. Args: T : int : number of test cases test_cases : List[Tuple[int, List[int]]] : a list of tuples where the first item is the number of books followed by a list of integers representing the thickness of the books Returns: List[int] : a list of results where each result is the minimum number of operations for each test case >>> min_operations_to_sort_books(2, [(4, [4, 3, 2, 1]), (5, [2, 3, 4, 1, 5])]) [1, 2] >>> min_operations_to_sort_books(1, [(4, [1, 2, 3, 4])]) [0] >>> min_operations_to_sort_books(1, [(1, [1])]) [0] pass","solution":"def min_operations_to_sort_books(T, test_cases): results = [] for i in range(T): n, books = test_cases[i] sorted_books = sorted(books) if books == sorted_books: # If the books are already sorted, no operation is needed. results.append(0) else: start = 0 end = n - 1 # Find the first position from the left where the books are mismatched while start < n and books[start] == sorted_books[start]: start += 1 # Find the first position from the right where the books are mismatched while end >= 0 and books[end] == sorted_books[end]: end -= 1 if start >= end: # If no mismatch is found in the inner portion, only one reversal is needed results.append(1) else: # Check if reversing this segment makes the entire list sorted sublist_reversed = books[:start] + books[start:end + 1][::-1] + books[end + 1:] if sublist_reversed == sorted_books: results.append(1) else: results.append(2) return results"},{"question":"from collections import Counter def is_harmonious(s: str) -> bool: Returns true if the string s is harmonious, otherwise returns false. A string is harmonious if the frequency of each character in the string is the same. >>> is_harmonious(\\"aabb\\") True >>> is_harmonious(\\"aabbcc\\") True >>> is_harmonious(\\"aabc\\") False >>> is_harmonious(\\"abcd\\") True","solution":"from collections import Counter def is_harmonious(s): Returns true if the string s is harmonious, otherwise returns false. A string is harmonious if the frequency of each character in the string is the same. if not s: return True frequencies = Counter(s).values() return len(set(frequencies)) == 1"},{"question":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]: Perform a zigzag level order traversal of a binary tree. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> zigzagLevelOrder(root) [[3], [20, 9], [15, 7]] >>> zigzagLevelOrder(None) []","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): if not root: return [] result = [] node_queue = deque([root]) left_to_right = True while node_queue: level_size = len(node_queue) current_level = deque() for _ in range(level_size): node = node_queue.popleft() if left_to_right: current_level.append(node.val) else: current_level.appendleft(node.val) if node.left: node_queue.append(node.left) if node.right: node_queue.append(node.right) result.append(list(current_level)) left_to_right = not left_to_right return result"},{"question":"def max_stars(n: int, m: int, grid: List[List[int]]) -> int: Returns the maximum number of stars the robot can collect from top-left to bottom-right of a grid. >>> max_stars(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_stars(2, 2, [[1, 2], [3, 4]]) 8","solution":"def max_stars(n, m, grid): Returns the maximum number of stars the robot can collect from top-left to bottom-right of a grid. dp = [[0 for _ in range(m)] for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the grid for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"def minimum_harvest_steps(n: int) -> int: Given n trees in a circular arrangement, calculates the minimum number of steps required to harvest one fruit from each tree starting from tree 1. >>> minimum_harvest_steps(4) 3 >>> minimum_harvest_steps(5) 4 >>> minimum_harvest_steps(3) 2 >>> minimum_harvest_steps(10**6) 999999 >>> minimum_harvest_steps(10**6 + 1) 1000000","solution":"def minimum_harvest_steps(n): Given n trees in a circular arrangement, calculates the minimum steps required to harvest one fruit from each tree starting from tree 1. return n - 1"},{"question":"def sorted_squares(nums): Given an array of integers, returns a new array that contains the square of each element from the original array, but sorted in non-decreasing order. This function achieves it in O(n) time complexity. >>> sorted_squares([-4, -1, 0, 3, 10]) [0, 1, 9, 16, 100] >>> sorted_squares([-7, -3, 2, 3, 11]) [4, 9, 9, 49, 121]","solution":"def sorted_squares(nums): Given an array of integers, returns a new array that contains the square of each element from the original array, but sorted in non-decreasing order. This function achieves it in O(n) time complexity. n = len(nums) result = [0] * n left, right = 0, n - 1 position = n - 1 while left <= right: left_sq = nums[left] ** 2 right_sq = nums[right] ** 2 if left_sq > right_sq: result[position] = left_sq left += 1 else: result[position] = right_sq right -= 1 position -= 1 return result"},{"question":"def has_passed(scores): Determines if the average score is at least 50%. pass def check_result_for_cases(test_cases): For each test case, determine if Alice passed or failed. pass def main(T, test_cases): For each test case, input the number of scores and the scores themselves, then determine if Alice passed or failed. pass","solution":"def has_passed(scores): Determines if the average score is at least 50%. average_score = sum(scores) / len(scores) return average_score >= 50 def check_result_for_cases(test_cases): For each test case, determine if Alice passed or failed. results = [] for scores in test_cases: result = 'PASSED' if has_passed(scores) else 'FAILED' results.append(result) return results def main(T, test_cases): results = check_result_for_cases(test_cases) return results"},{"question":"from typing import List def isPathExists(matrix: List[List[str]]) -> bool: Determines if there is a path from the top-left to the bottom-right in the matrix, traversing only 'O' cells. >>> isPathExists([['O', 'X', 'O', 'O'], ['O', 'O', 'X', 'O'], ['X', 'O', 'X', 'O'], ['O', 'O', 'O', 'O']]) True >>> isPathExists([['O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O']]) False","solution":"from typing import List def isPathExists(matrix: List[List[str]]) -> bool: Determines if there is a path from the top-left to the bottom-right in the matrix, traversing only 'O' cells. rows = len(matrix) cols = len(matrix[0]) if matrix[0][0] == 'X' or matrix[rows - 1][cols - 1] == 'X': return False directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(row, col): if row == rows - 1 and col == cols - 1: return True visited[row][col] = True for dr, dc in directions: nr, nc = row + dr, col + dc if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and matrix[nr][nc] == 'O': if dfs(nr, nc): return True return False return dfs(0, 0)"},{"question":"def organize_books(n: int, books: List[str]) -> List[str]: Organize books by genre and then alphabetically by title. Args: n : int : number of books books : List[str] : list of strings with each string containing a genre and a title separated by a comma Returns: List[str] : a sorted list of genres with their corresponding sorted book titles Examples: >>> organize_books(5, [ ... \\"Fantasy,The Hobbit\\", ... \\"Science Fiction,Dune\\", ... \\"Fantasy,Harry Potter\\", ... \\"Science Fiction,Foundation\\", ... \\"Mystery,The Hound of the Baskervilles\\" ... ]) ['Fantasy', 'Harry Potter', 'The Hobbit', 'Mystery', 'The Hound of the Baskervilles', 'Science Fiction', 'Dune', 'Foundation'] pass","solution":"def organize_books(n, books): genre_dict = {} for book in books: genre, title = book.split(',', maxsplit=1) genre = genre.strip() title = title.strip() if genre not in genre_dict: genre_dict[genre] = [] genre_dict[genre].append(title) sorted_genres = sorted(genre_dict.keys()) result = [] for genre in sorted_genres: result.append(genre) sorted_titles = sorted(genre_dict[genre]) result.extend(sorted_titles) return result"},{"question":"import os def relative_path(src: str, target: str) -> str: Returns the relative path from the source file to the target file. >>> relative_path(\\"/foo/bar\\", \\"/foo/bar/baz\\") 'baz' >>> relative_path(\\"/home/user/docs\\", \\"/home/user/docs/report.txt\\") 'report.txt'","solution":"import os def relative_path(src, target): Returns the relative path to get from src to target. return os.path.relpath(target, start=src)"},{"question":"from typing import List, Tuple def process_queries(N: int, values: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]: Process queries on a tree with N nodes where each node has a unique value. Args: N (int): number of nodes in the tree. values (List[int]): initial values of each node. edges (List[Tuple[int, int]]): undirected edges defining the tree. queries (List[Tuple[int, int, int]]): list of queries to process. Returns: List[int]: results of query type 2. Example: >>> process_queries(5, [5, 3, 8, 6, 1], [(1, 2), (1, 3), (3, 4), (3, 5)], [(2, 3), (1, 3, 10), (2, 1), (1, 1, 2)]) [8, 10] >>> process_queries(1, [1], [], [(2, 1), (1, 1, 5), (2, 1)]) [1, 5] def test_process_queries(): N = 5 values = [5, 3, 8, 6, 1] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [(2, 3), (1, 3, 10), (2, 1), (1, 1, 2)] assert process_queries(N, values, edges, queries) == [8, 10] def test_process_queries_single_node(): N = 1 values = [1] edges = [] queries = [(2, 1), (1, 1, 5), (2, 1)] assert process_queries(N, values, edges, queries) == [1, 5] def test_process_queries_line_tree(): N = 4 values = [1, 2, 3, 4] edges = [(1, 2), (2, 3), (3, 4)] queries = [(2, 1), (1, 2, 10), (2, 2), (1, 4, 20), (2, 3)] assert process_queries(N, values, edges, queries) == [4, 10, 20] def test_process_queries_star_tree(): N = 5 values = [10, 20, 30, 40, 50] edges = [(1, 2), (1, 3), (1, 4), (1, 5)] queries = [(2, 1), (1, 1, 5), (2, 1), (1, 2, 25), (2, 1)] assert process_queries(N, values, edges, queries) == [50, 50, 50] def test_process_queries_complex_tree(): N = 6 values = [7, 1, 3, 9, 4, 5] edges = [(1, 2), (1, 3), (3, 4), (3, 5), (4, 6)] queries = [(2, 3), (1, 4, 20), (2, 3), (1, 1, 8), (2, 1)] assert process_queries(N, values, edges, queries) == [9, 20, 20]","solution":"from collections import defaultdict import sys sys.setrecursionlimit(200000) class Tree: def __init__(self, n, values): self.n = n self.values = values self.graph = defaultdict(list) self.subtree_values = [0] * (n + 1) self.max_subtree = [0] * (n + 1) def add_edge(self, u, v): self.graph[u].append(v) self.graph[v].append(u) def dfs(self, node, parent): self.subtree_values[node] = self.values[node-1] max_value = self.subtree_values[node] for neighbor in self.graph[node]: if neighbor == parent: continue self.dfs(neighbor, node) max_value = max(max_value, self.max_subtree[neighbor]) self.max_subtree[node] = max_value def update(self, x, k): self.values[x-1] = k self.dfs(1, -1) def query(self, x): return self.max_subtree[x] def process_queries(N, values, edges, queries): tree = Tree(N, values) for u, v in edges: tree.add_edge(u, v) tree.dfs(1, -1) result = [] for query in queries: if query[0] == 1: tree.update(query[1], query[2]) elif query[0] == 2: result.append(tree.query(query[1])) return result"},{"question":"def is_water_flow_possible(pipeline: str) -> bool: Determines if there is a continuous path of water flow from any 'A' to any 'T' in the pipeline. >>> is_water_flow_possible(\\"A.-|.-T\\") True >>> is_water_flow_possible(\\"A.-|.-B.T|A.---T\\") True >>> is_water_flow_possible(\\"A.|-.A.-|B-.T\\") False >>> is_water_flow_possible(\\"A.|-.-T|-B.T\\") True >>> is_water_flow_possible(\\"B..A..T\\") True >>> is_water_flow_possible(\\".|-.T.T|-T\\") False >>> is_water_flow_possible(\\"A.|-.-|-|A\\") False pass","solution":"def is_water_flow_possible(pipeline: str) -> bool: Determines if there is a continuous path of water flow from any 'A' to any 'T' in the pipeline. # Get the index of all 'A's and 'T's in the pipeline sources = {i for i, char in enumerate(pipeline) if char == 'A'} targets = {i for i, char in enumerate(pipeline) if char == 'T'} # Define the set of blockers blockers = {'B'} for source in sources: # We'll use a stack for DFS stack = [source] visited = set() while stack: current = stack.pop() if current in targets: return True if current in visited: continue visited.add(current) # Explore neighbors (left and right) if current + 1 < len(pipeline) and pipeline[current+1] not in blockers: stack.append(current + 1) if current - 1 >= 0 and pipeline[current-1] not in blockers: stack.append(current - 1) return False"},{"question":"def is_anagram_not_identical(s1: str, s2: str) -> str: Determines whether s2 is an anagram of s1 but not identical to s1. >>> is_anagram_not_identical(\\"listen\\", \\"silent\\") \\"YES\\" >>> is_anagram_not_identical(\\"triangle\\", \\"integral\\") \\"YES\\" >>> is_anagram_not_identical(\\"apple\\", \\"apple\\") \\"NO\\" >>> is_anagram_not_identical(\\"hello\\", \\"olelh\\") \\"YES\\" >>> is_anagram_not_identical(\\"abc\\", \\"def\\") \\"NO\\" >>> is_anagram_not_identical(\\"abcd\\", \\"abcde\\") \\"NO\\" def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[str]: Processes the given test cases and returns the results. >>> process_test_cases([(\\"listen\\", \\"silent\\"), (\\"triangle\\", \\"integral\\"), (\\"apple\\", \\"apple\\"), (\\"hello\\", \\"olelh\\"), (\\"abc\\", \\"def\\"), (\\"abcd\\", \\"abcde\\")]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def is_anagram_not_identical(s1, s2): Determines whether s2 is an anagram of s1 but not identical to s1. if s1 == s2: return \\"NO\\" return \\"YES\\" if sorted(s1) == sorted(s2) else \\"NO\\" def process_test_cases(test_cases): results = [] for s1, s2 in test_cases: results.append(is_anagram_not_identical(s1, s2)) return results"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring('abcabcbb') 3 >>> length_of_longest_substring('bbbbb') 1 >>> length_of_longest_substring('pwwkew') 3 >>> length_of_longest_substring('') 0 >>> length_of_longest_substring('a') 1 >>> length_of_longest_substring('abcdefg') 7 >>> length_of_longest_substring('a b a') 3 >>> length_of_longest_substring('abc123!@#abc') 9","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def sum_pairs(lst): Returns a list containing the sum of every adjacent pair of integers in the input list. Arguments: lst -- A list of integers containing at least two elements. Returns: A list of integers. def test_sum_pairs_with_positive_numbers(): assert sum_pairs([1, 2, 3, 4]) == [3, 5, 7] def test_sum_pairs_with_zero_and_positive_numbers(): assert sum_pairs([0, 10, -10, 5]) == [10, 0, -5] def test_sum_pairs_with_all_negative_numbers(): assert sum_pairs([-1, -2, -3, -4]) == [-3, -5, -7] def test_sum_pairs_with_mixed_sign_numbers(): assert sum_pairs([5, -3, 4, -2]) == [2, 1, 2] def test_sum_pairs_with_two_elements(): assert sum_pairs([100, 200]) == [300] def test_sum_pairs_with_large_numbers(): assert sum_pairs([10**6, -10**6, 10**6, -10**6]) == [0, 0, 0]","solution":"def sum_pairs(lst): Returns a list containing the sum of every adjacent pair of integers in the input list. Arguments: lst -- A list of integers containing at least two elements. Returns: A list of integers. return [lst[i] + lst[i + 1] for i in range(len(lst) - 1)]"},{"question":"def sum_of_frequencies(N: int, K: int, S: str) -> List[int]: For a given string S of length N and an integer K, find the sum of frequencies of characters for each substring of length K. >>> sum_of_frequencies(6, 3, \\"abcabc\\") [3, 3, 3, 3] >>> sum_of_frequencies(5, 1, \\"aaaaa\\") [1, 1, 1, 1, 1] >>> sum_of_frequencies(7, 3, \\"abababa\\") [3, 3, 3, 3, 3] >>> sum_of_frequencies(6, 2, \\"abcdef\\") [2, 2, 2, 2, 2]","solution":"def sum_of_frequencies(N, K, S): from collections import Counter # Create a list to store the result result = [] # Iterate through the substrings of length K for i in range(N - K + 1): substring = S[i:i+K] counter = Counter(substring) frequency_sum = sum(counter.values()) result.append(frequency_sum) return result"},{"question":"def calculate_final_position(instructions_list): Calculates the final coordinates of the robot after executing the given instructions. Parameters: instructions_list (list): A list of tuples where each tuple contains a direction string and a step integer. Returns: tuple: The final (x, y) coordinates of the robot. # Your implementation here def process_test_cases(T, test_cases): Processes multiple test cases to find the final coordinates of the robot for each test case. Parameters: T (int): Number of test cases. test_cases (list): A list of test cases, each containing a list of instructions. Returns: list: A list of tuples, where each tuple contains the final (x, y) coordinates for each test case. # Your implementation here # Unit Tests def test_case_1(): instructions_list = [('UP', 5), ('LEFT', 3), ('DOWN', 2)] assert calculate_final_position(instructions_list) == (-3, 3) def test_case_2(): instructions_list = [('RIGHT', 10), ('UP', 2), ('LEFT', 5), ('DOWN', 3)] assert calculate_final_position(instructions_list) == (5, -1) def test_large_movement(): instructions_list = [('UP', 1000000), ('DOWN', 1000000), ('LEFT', 500000), ('RIGHT', 500000)] assert calculate_final_position(instructions_list) == (0, 0) def test_multiple_movements(): instructions_list = [('UP', 5), ('UP', 10), ('DOWN', 15), ('LEFT', 20), ('RIGHT', 5), ('RIGHT', 15)] assert calculate_final_position(instructions_list) == (0, 0) def test_case_same_direction(): instructions_list = [('UP', 3), ('UP', 2), ('UP', 4)] assert calculate_final_position(instructions_list) == (0, 9) def test_process_test_cases(): test_cases = [ [('UP', 5), ('LEFT', 3), ('DOWN', 2)], [('RIGHT', 10), ('UP', 2), ('LEFT', 5), ('DOWN', 3)], [('UP', 1), ('UP', 1), ('DOWN', 1)] ] T = 3 result = process_test_cases(T, test_cases) assert result == [(-3, 3), (5, -1), (0, 1)]","solution":"def calculate_final_position(instructions_list): Calculates the final coordinates of the robot after executing the given instructions. Parameters: instructions_list (list): A list of tuples where each tuple contains a direction string and a step integer. Returns: tuple: The final (x, y) coordinates of the robot. x, y = 0, 0 for direction, steps in instructions_list: if direction == 'UP': y += steps elif direction == 'DOWN': y -= steps elif direction == 'LEFT': x -= steps elif direction == 'RIGHT': x += steps return x, y def process_test_cases(T, test_cases): Processes multiple test cases to find the final coordinates of the robot for each test case. Parameters: T (int): Number of test cases. test_cases (list): A list of test cases, each containing a list of instructions. Returns: list: A list of tuples, where each tuple contains the final (x, y) coordinates for each test case. results = [] for instructions in test_cases: results.append(calculate_final_position(instructions)) return results"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Returns the sum of the subarray with the maximum sum. >>> max_subarray_sum([2, 3, 1, 5]) == 11 >>> max_subarray_sum([0, 0, 0, 0]) == 0 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([5]) == 5 >>> max_subarray_sum([-2, -3, -1, -4]) == -1 >>> max_subarray_sum([1]*100000) == 100000 >>> max_subarray_sum([-1]*99999 + [10000]) == 10000","solution":"def max_subarray_sum(arr): Returns the sum of the subarray with the maximum sum using Kadane's Algorithm. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a given mathematical expression string with integers and the operators +, -, *, and /. >>> evaluate_expression(\\"2+3\\") == 5 >>> evaluate_expression(\\"5-2\\") == 3 >>> evaluate_expression(\\"3*4\\") == 12 >>> evaluate_expression(\\"6/2\\") == 3 >>> evaluate_expression(\\"3+5*2-9/3\\") == 10 >>> evaluate_expression(\\"(3+5)*2\\") == 16 >>> evaluate_expression(\\"3+4*2/2-1\\") == 6 >>> evaluate_expression(\\"7/2\\") == 3","solution":"def evaluate_expression(expression): Evaluates a given mathematical expression string with integers and the operators +, -, *, and /. return int(eval(expression))"},{"question":"def min_swaps_helper(N: int, initial: List[int], target: List[int]) -> int: Determines the minimum number of swaps needed to transform the initial sequence into the target sequence. If it's not possible to transform the initial sequence into the target sequence, returns -1. Args: N: the length of the sequences. initial: the initial sequence of integers. target: the target sequence of integers. Returns: An integer representing the minimum number of swaps, or -1 if transformation is not possible. Examples: >>> min_swaps_helper(5, [3, 1, 2, 4, 5], [1, 2, 3, 4, 5]) 2 >>> min_swaps_helper(5, [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) 0 >>> min_swaps_helper(5, [5, 4, 3, 2, 1], [1, 2, 3, 4, 5]) 2 >>> min_swaps_helper(5, [1, 2, 3, 4, 6], [1, 2, 3, 4, 5]) -1 >>> min_swaps_helper(7, [2, 3, 4, 5, 6, 7, 1], [1, 2, 3, 4, 5, 6, 7]) 6","solution":"def min_swaps_to_transform(initial, target): if sorted(initial) != sorted(target): return -1 index_dict = {v: i for i, v in enumerate(target)} for i in range(len(initial)): initial[i] = index_dict[initial[i]] visited = [False] * len(initial) swaps = 0 for i in range(len(initial)): if visited[i] or initial[i] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = initial[x] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps # Function to be called def min_swaps_helper(N, initial, target): return min_swaps_to_transform(initial, target)"},{"question":"def sort_mixed_numbers(arr): Returns a new list sorted in ascending order, where the strings are converted to their numerical forms for comparison. valid words: \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\", \\"ten\\" Examples: >>> sort_mixed_numbers([3, \\"one\\", 2, \\"five\\", 7, \\"three\\"]) [\\"one\\", 2, 3, \\"three\\", \\"five\\", 7] >>> sort_mixed_numbers([\\"two\\", \\"nine\\", \\"five\\"]) [\\"two\\", \\"five\\", \\"nine\\"] import pytest def test_all_numbers(): assert sort_mixed_numbers([5, 2, 9]) == [2, 5, 9] def test_all_words(): assert sort_mixed_numbers([\\"two\\", \\"nine\\", \\"five\\"]) == [\\"two\\", \\"five\\", \\"nine\\"] def test_mixed_types(): assert sort_mixed_numbers([3, \\"one\\", 2, \\"five\\", 7, \\"three\\"]) == [\\"one\\", 2, 3, \\"three\\", \\"five\\", 7] def test_with_all_elements(): assert sort_mixed_numbers([10, \\"one\\", 2, \\"five\\", \\"three\\", 6, \\"eight\\"]) == [\\"one\\", 2, \\"three\\", \\"five\\", 6, \\"eight\\", 10] def test_with_duplicates(): assert sort_mixed_numbers([10, \\"one\\", \\"one\\", 10]) == [\\"one\\", \\"one\\", 10, 10] def test_empty_list(): assert sort_mixed_numbers([]) == [] def test_single_element_number(): assert sort_mixed_numbers([4]) == [4] def test_single_element_word(): assert sort_mixed_numbers([\\"four\\"]) == [\\"four\\"] def test_mixed_with_unlisted_string(): with pytest.raises(KeyError): sort_mixed_numbers([3, \\"eleven\\", 2, \\"five\\", 7, \\"three\\"])","solution":"def sort_mixed_numbers(arr): Returns a new list sorted in ascending order, where the strings are converted to their numerical forms for comparison. word_to_num = { \\"one\\": 1, \\"two\\": 2, \\"three\\": 3, \\"four\\": 4, \\"five\\": 5, \\"six\\": 6, \\"seven\\": 7, \\"eight\\": 8, \\"nine\\": 9, \\"ten\\": 10 } # Convert all elements to numbers for sorting comparison converted = [(word_to_num[x] if isinstance(x, str) else x) for x in arr] # Create a paired list of (converted value, original value) for sorting paired = list(zip(converted, arr)) # Sort paired list by converted value paired_sorted = sorted(paired, key=lambda x: x[0]) # Extract the original values from the sorted paired list result = [x[1] for x in paired_sorted] return result"},{"question":"def remove_gray_pixels(image): Removes all gray pixels from the given 2D list representing an image. Gray pixels are defined as those where the red, green, and blue components are all equal. Args: image (list of list of tuples): The input image represented as a 2D list of RGB tuples. Returns: list of list of tuples: The modified image with gray pixels removed. >>> image = [ ... [(30, 30, 30), (0, 0, 255), (40, 40, 40)], ... [(255, 255, 255), (128, 128, 128), (255, 0, 0)], ... [(0, 0, 0), (10, 10, 10), (100, 200, 100)] ... ] >>> remove_gray_pixels(image) [[(0, 0, 255)], [(255, 0, 0)], [(100, 200, 100)]]","solution":"def remove_gray_pixels(image): Removes all gray pixels from the given 2D list representing an image. Gray pixels are defined as those where the red, green, and blue components are all equal. Args: image (list of list of tuples): The input image represented as a 2D list of RGB tuples. Returns: list of list of tuples: The modified image with gray pixels removed. return [[pixel for pixel in row if not (pixel[0] == pixel[1] == pixel[2])] for row in image] # Example usage image = [ [(30, 30, 30), (0, 0, 255), (40, 40, 40)], [(255, 255, 255), (128, 128, 128), (255, 0, 0)], [(0, 0, 0), (10, 10, 10), (100, 200, 100)] ] modified_image = remove_gray_pixels(image) print(modified_image)"},{"question":"def filter_greater_than_next(lst): Returns a list containing elements from the input list that are greater than their following element. The last element of the list is always included. Example: >>> filter_greater_than_next([5, 3, 8, 4, 2, 10]) [5, 8, 4, 10] >>> filter_greater_than_next([1, 2, 3, 4, 5]) [5] >>> filter_greater_than_next([5, 4, 3, 2, 1]) [5, 4, 3, 2, 1] >>> filter_greater_than_next([42]) [42] >>> filter_greater_than_next([2, 1]) [2, 1] >>> filter_greater_than_next([1, 2]) [2] >>> filter_greater_than_next([]) [] >>> filter_greater_than_next([2, 2, 2]) [2]","solution":"def filter_greater_than_next(lst): Returns a list containing elements from the input list that are greater than their following element. The last element of the list is always included. result = [] if not lst: # Check if the list is empty return result for i in range(len(lst) - 1): if lst[i] > lst[i + 1]: result.append(lst[i]) result.append(lst[-1]) # Include the last element return result"},{"question":"from typing import List def minimize_max_difference(M: int, K: int, heights: List[int]) -> int: Minimize the maximum difference in height (ΔH) between the highest and lowest cell within any section. Args: M (int): Number of cells in the conveyor belt. K (int): Number of contiguous sections to partition the conveyor belt into. heights (List[int]): List of heights of the cells in the conveyor belt. Returns: int: The minimum possible value of ΔH for the optimal partitioning. Examples: >>> minimize_max_difference(7, 3, [10, 5, 7, 9, 12, 6, 3]) 3 >>> minimize_max_difference(6, 2, [1, 2, 3, 4, 5, 6]) 2 pass def process_input_and_output(input_lines: List[str]) -> List[int]: Process input lines and produce output results for multiple test cases. Args: input_lines (List[str]): List of input lines where each test case consists of two lines. Returns: List[int]: The list of results for each test case. Examples: >>> input_lines = [ ... \\"7 3\\", ... \\"10 5 7 9 12 6 3\\", ... \\"6 2\\", ... \\"1 2 3 4 5 6\\", ... \\"0 0\\" ... ] >>> process_input_and_output(input_lines) [3, 2] pass def test_minimize_max_difference(): assert minimize_max_difference(7, 3, [10, 5, 7, 9, 12, 6, 3]) == 3 assert minimize_max_difference(6, 2, [1, 2, 3, 4, 5, 6]) == 2 assert minimize_max_difference(4, 2, [10, 20, 30, 40]) == 10 assert minimize_max_difference(3, 3, [1, 1, 1]) == 0 assert minimize_max_difference(3, 1, [1, 2, 3]) == 2 def test_process_input_and_output(): input_lines = [ \\"7 3\\", \\"10 5 7 9 12 6 3\\", \\"6 2\\", \\"1 2 3 4 5 6\\", \\"0 0\\" ] expected_output = [3, 2] assert process_input_and_output(input_lines) == expected_output def test_edge_cases(): assert minimize_max_difference(1, 1, [1]) == 0 assert minimize_max_difference(10, 1, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 9 assert minimize_max_difference(10, 10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 0","solution":"def minimize_max_difference(M, K, heights): def can_partition(max_diff): count, current_min, current_max = 1, heights[0], heights[0] for height in heights[1:]: current_min, current_max = min(current_min, height), max(current_max, height) if current_max - current_min > max_diff: count += 1 current_min, current_max = height, height if count > K: return False return True heights.sort() # Sorting for easier binary search range determination low, high = 0, max(heights) - min(heights) while low < high: mid = (low + high) // 2 if can_partition(mid): high = mid else: low = mid + 1 return low def process_input_and_output(input_lines): results = [] i = 0 while i < len(input_lines): M, K = map(int, input_lines[i].strip().split()) if M == 0 and K == 0: break heights = list(map(int, input_lines[i + 1].strip().split())) results.append(minimize_max_difference(M, K, heights)) i += 2 return results"},{"question":"def isPrimeFriendlyStreet(streetNumber: int) -> bool: Returns True if the street number is \\"prime-friendly\\", otherwise False. A street number is \\"prime-friendly\\" if the sum of its digits is a prime number. >>> isPrimeFriendlyStreet(23) True >>> isPrimeFriendlyStreet(40) False >>> isPrimeFriendlyStreet(100) False >>> isPrimeFriendlyStreet(2) True >>> isPrimeFriendlyStreet(10) False >>> isPrimeFriendlyStreet(29) True","solution":"def isPrimeFriendlyStreet(streetNumber): Returns True if the street number is \\"prime-friendly\\", otherwise False. A street number is \\"prime-friendly\\" if the sum of its digits is a prime number. def is_prime(n): if n <= 1: return False for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True # Sum of the digits of the street number digit_sum = sum(int(digit) for digit in str(streetNumber)) return is_prime(digit_sum)"},{"question":"def prime_factors_diff(n: int) -> int: Returns the difference between the largest and smallest prime factors of n. If n has fewer than two distinct prime factors, the function returns 0. >>> prime_factors_diff(60) # Prime factors are 2, 3, and 5. Difference is 5 - 2 = 3 3 >>> prime_factors_diff(49) # Only one prime factor is 7 0 >>> prime_factors_diff(30) # Prime factors are 2, 3, and 5. Difference is 5 - 2 = 3 3 >>> prime_factors_diff(2) # Only one prime factor is 2 0 >>> prime_factors_diff(1) # No prime factors 0","solution":"def prime_factors_diff(n): Returns the difference between the largest and smallest prime factors of n. If n has fewer than two distinct prime factors, the function returns 0. if n <= 1: return 0 def smallest_prime_factor(n): Returns the smallest prime factor of n greater than 1 if n % 2 == 0: return 2 i = 3 while i * i <= n: if n % i == 0: return i i += 2 return n prime_factors = set() while n > 1: spf = smallest_prime_factor(n) prime_factors.add(spf) while n % spf == 0: n //= spf if len(prime_factors) < 2: return 0 return max(prime_factors) - min(prime_factors)"},{"question":"def classify_triangle(a: int, b: int, c: int) -> str: Classifies a triangle based on its side lengths a, b, and c. Parameters: a (int): The length of the first side. b (int): The length of the second side. c (int): The length of the third side. Returns: str: The type of the triangle (\\"Invalid\\", \\"Equilateral\\", \\"Isosceles\\", or \\"Scalene\\"). >>> classify_triangle(3, 4, 5) 'Scalene' >>> classify_triangle(2, 2, 2) 'Equilateral' >>> classify_triangle(1, 10, 12) 'Invalid'","solution":"def classify_triangle(a, b, c): Classifies a triangle based on its side lengths a, b, and c. Parameters: a (int): The length of the first side. b (int): The length of the second side. c (int): The length of the third side. Returns: str: The type of the triangle (\\"Invalid\\", \\"Equilateral\\", \\"Isosceles\\", or \\"Scalene\\"). # Check if the triangle is valid based on the triangle inequality theorem if a + b > c and b + c > a and c + a > b: if a == b == c: return \\"Equilateral\\" elif a == b or b == c or c == a: return \\"Isosceles\\" else: return \\"Scalene\\" else: return \\"Invalid\\""},{"question":"def merge_and_sort_lists(list1, list2): Merges two lists of integers and returns a single list in non-decreasing order. Args: list1 (List[int]): The first list of integers. list2 (List[int]): The second list of integers. Returns: List[int]: A single list containing all elements from list1 and list2, sorted in non-decreasing order. Examples: >>> merge_and_sort_lists([1, 3, 5, 7], [2, 4, 6, 8, 9]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> merge_and_sort_lists([10, 20, 30], [5, 15, 25]) [5, 10, 15, 20, 25, 30] >>> merge_and_sort_lists([100000, 200000], [99999, 100001]) [99999, 100000, 100001, 200000]","solution":"def merge_and_sort_lists(list1, list2): Merges two lists of integers and returns a single list in non-decreasing order. return sorted(list1 + list2)"},{"question":"from typing import List, Tuple def find_longest_unique_substring_len(segment: str) -> int: Returns the length of the longest substring with all unique characters. >>> find_longest_unique_substring_len(\\"aabb\\") == 2 >>> find_longest_unique_substring_len(\\"abbcde\\") == 4 >>> find_longest_unique_substring_len(\\"aabbcdee\\") == 4 >>> find_longest_unique_substring_len(\\"abcdef\\") == 6 >>> find_longest_unique_substring_len(\\"aaaaa\\") == 1 def process_queries(S: str, queries: List[Tuple[int, int]]) -> List[int]: Processes the queries to find the length of the longest valid substring for each given segment. Args: S: The input string of lowercase English letters. queries: A list of tuples, each containing two integers L and R. Returns: A list of results, each representing the maximum length of valid substring for the given segment. >>> process_queries(\\"aabbcdee\\", [(1, 4), (2, 7), (1, 8)]) == [2, 4, 4] >>> process_queries(\\"abcdef\\", [(1, 3), (2, 5), (1, 6)]) == [3, 4, 6] >>> process_queries(\\"aaaaaaa\\", [(1, 7), (1, 3)]) == [1, 1]","solution":"def find_longest_unique_substring_len(segment): Returns the length of the longest substring with all unique characters. n = len(segment) char_set = set() left = 0 max_length = 0 for right in range(n): while segment[right] in char_set: char_set.remove(segment[left]) left += 1 char_set.add(segment[right]) max_length = max(max_length, right - left + 1) return max_length def process_queries(S, queries): Processes the queries to find the length of the longest valid substring for each given segment. Args: S: The input string of lowercase English letters. queries: A list of tuples, each containing two integers L and R. Returns: A list of results, each representing the maximum length of valid substring for the given segment. results = [] for L, R in queries: segment = S[L-1:R] max_length = find_longest_unique_substring_len(segment) results.append(max_length) return results"},{"question":"def max_bus_stops_per_round_trip(test_cases): Returns the max number of bus stops covered in a single round trip for each test case. def parse_input(input_string): Parses the input data into a format suitable for processing. def test_max_bus_stops_per_round_trip(): input_data = \\"4n1 2 3 4n3n5 9 2n5n1 1 1 1 1n0n\\" expected_output = [10, 16, 5] test_cases = parse_input(input_data) result = max_bus_stops_per_round_trip(test_cases) assert result == expected_output, f\\"Expected {expected_output}, but got {result}\\" def test_single_route(): input_data = \\"1n10n0n\\" expected_output = [10] test_cases = parse_input(input_data) result = max_bus_stops_per_round_trip(test_cases) assert result == expected_output, f\\"Expected {expected_output}, but got {result}\\" def test_all_routes_single_stop(): input_data = \\"3n1 1 1n0n\\" expected_output = [3] test_cases = parse_input(input_data) result = max_bus_stops_per_round_trip(test_cases) assert result == expected_output, f\\"Expected {expected_output}, but got {result}\\" def test_empty_data(): input_data = \\"0n\\" expected_output = [] test_cases = parse_input(input_data) result = max_bus_stops_per_round_trip(test_cases) assert result == expected_output, f\\"Expected {expected_output}, but got {result}\\" def test_varied_routes(): input_data = \\"3n2 3 4n2n6 7n0n\\" expected_output = [9, 13] test_cases = parse_input(input_data) result = max_bus_stops_per_round_trip(test_cases) assert result == expected_output, f\\"Expected {expected_output}, but got {result}\\"","solution":"def max_bus_stops_per_round_trip(test_cases): Returns the max number of bus stops covered in a single round trip for each test case. results = [] for routes in test_cases: if routes: results.append(sum(routes)) return results def parse_input(input_string): lines = input_string.strip().split('n') test_cases = [] i = 0 while i < len(lines): N = int(lines[i]) if N == 0: break routes = list(map(int, lines[i + 1].split())) test_cases.append(routes) i += 2 return test_cases"},{"question":"from typing import List def max_difference(arr: List[int]) -> int: Determines the maximum difference between any two elements in the list such that the larger element comes after the smaller one in the original list. >>> max_difference([2, 3, 10, 6, 4, 8, 1]) == 8 >>> max_difference([7, 9, 5, 6, 3, 2]) == 2 >>> max_difference([7, 6, 4, 3, 1]) == 0 >>> max_difference([1, 2, 3, 4, 5]) == 4 >>> max_difference([5]) == 0 pass def test_max_difference_case1(): assert max_difference([2, 3, 10, 6, 4, 8, 1]) == 8 def test_max_difference_case2(): assert max_difference([7, 9, 5, 6, 3, 2]) == 2 def test_max_difference_case3(): assert max_difference([7, 6, 4, 3, 1]) == 0 def test_max_difference_case4(): assert max_difference([1, 2, 3, 4, 5]) == 4 def test_max_difference_case5(): assert max_difference([5]) == 0 def test_max_difference_with_negative_numbers(): assert max_difference([2, -3, 10, -6, 4, -8, 1]) == 13 def test_max_difference_with_single_element(): assert max_difference([10]) == 0 def test_max_difference_with_duplicate_elements(): assert max_difference([5, 5, 5, 5, 5]) == 0 def test_max_difference_with_zero(): assert max_difference([0, 0, 0, 0]) == 0","solution":"def max_difference(arr): Determines the maximum difference between any two elements in the list such that the larger element comes after the smaller one in the original list. if not arr or len(arr) < 2: return 0 min_element = arr[0] max_diff = 0 for i in range(1, len(arr)): if arr[i] > min_element: max_diff = max(max_diff, arr[i] - min_element) min_element = min(min_element, arr[i]) return max_diff"},{"question":"def factorial_digit_sum(n: int) -> int: Returns the sum of the digits in the decimal representation of the factorial of n. Parameters: n (int): The non-negative integer Returns: int: The sum of the digits of n! Examples: >>> factorial_digit_sum(5) # 5! = 120 -> 1 + 2 + 0 = 3 >>> factorial_digit_sum(10) # 10! = 3628800 -> 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27 >>> factorial_digit_sum(0) # 0! = 1 -> 1 >>> factorial_digit_sum(1) # 1! = 1 -> 1 >>> factorial_digit_sum(4) # 4! = 24 -> 2 + 4 = 6 >>> factorial_digit_sum(100) # The sum of digits of 100! is 648","solution":"def factorial_digit_sum(n: int) -> int: Returns the sum of the digits in the decimal representation of the factorial of n. Parameters: n (int): The non-negative integer Returns: int: The sum of the digits of n! import math factorial_value = math.factorial(n) digit_sum = sum(int(digit) for digit in str(factorial_value)) return digit_sum"},{"question":"def max_non_adjacent_subsequence_sum(arr): Given a list of integers, returns the maximum sum of a non-empty subsequence such that no two elements in the subsequence are adjacent in the list. >>> max_non_adjacent_subsequence_sum([3, 2, 5, 10]) == 13 >>> max_non_adjacent_subsequence_sum([3, 2, 7, 10, 3]) == 13 >>> max_non_adjacent_subsequence_sum([-1, -2, -3]) == -1","solution":"def max_non_adjacent_subsequence_sum(arr): Given a list of integers, returns the maximum sum of a non-empty subsequence such that no two elements in the subsequence are adjacent in the list. if not arr: return 0 n = len(arr) if n == 1: return arr[0] # Initialize prev and current to track the maximum sum without adjacent elements prev = arr[0] curr = max(arr[0], arr[1]) for i in range(2, n): new_curr = max(curr, prev + arr[i]) prev = curr curr = new_curr return curr"},{"question":"def min_coins_to_make_s(S: int, a: int, b: int, c: int) -> int: Returns the minimum number of coins needed to make amount S using denominations a, b, and c. Returns -1 if it is impossible. >>> min_coins_to_make_s(11, 1, 5, 7) 3 >>> min_coins_to_make_s(9, 2, 3, 4) 3 >>> min_coins_to_make_s(10, 5, 3, 2) 2 >>> min_coins_to_make_s(7, 2, 5, 7) 1 >>> min_coins_to_make_s(8, 3, 6, 10) -1 >>> min_coins_to_make_s(1, 1, 1, 1) 1","solution":"def min_coins_to_make_s(S, a, b, c): Returns the minimum number of coins needed to make amount S using denominations a, b, and c. Returns -1 if it is impossible. # Initialize dp array where dp[i] will be storing the minimum number # of coins required for i value. We initialize dp[0] to 0 as no coins # are needed to make 0 amount and rest to infinity dp = [float('inf')] * (S + 1) dp[0] = 0 arr = [a, b, c] for i in range(1, S + 1): for coin in arr: if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[S] if dp[S] != float('inf') else -1"},{"question":"def calculate_roman_sum(s: str) -> int: Given a string of Roman numeral expressions separated by '+', returns their sum as an integer. >>> calculate_roman_sum(\\"X\\") == 10 >>> calculate_roman_sum(\\"X+V\\") == 15 >>> calculate_roman_sum(\\"X+V+XII\\") == 27 >>> calculate_roman_sum(\\"IX+VIII+III\\") == 20 >>> calculate_roman_sum(\\"C+L+X+X\\") == 170 >>> calculate_roman_sum(\\"IX+IV\\") == 13","solution":"def roman_to_int(roman): Converts a single Roman numeral string to an integer roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(roman): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total def calculate_roman_sum(s): Given a string of Roman numeral expressions separated by '+', returns their sum as an integer roman_numerals = s.split('+') total_sum = sum(roman_to_int(roman) for roman in roman_numerals) return total_sum"},{"question":"def longest_balanced_parentheses(s: str) -> int: Find the length of the longest balanced parentheses substring. >>> longest_balanced_parentheses(\\"(()))\\") 4 >>> longest_balanced_parentheses(\\")((())()\\") 6 >>> longest_balanced_parentheses(\\"()(())\\") 6 def process_test_cases(T: int, cases: List[str]) -> List[int]: Process multiple test cases to find the length of the longest balanced parentheses substrings. >>> process_test_cases(3, [\\"(()))\\", \\")((())()\\", \\"()(())\\"]) [4, 6, 6] >>> process_test_cases(2, [\\"\\", \\"((()\\"]) [0, 2]","solution":"def longest_balanced_parentheses(s): Find the length of the longest balanced parentheses substring. max_len = 0 stack = [-1] for i, char in enumerate(s): if char == '(': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_len = max(max_len, i - stack[-1]) return max_len def process_test_cases(T, cases): results = [] for i in range(T): results.append(longest_balanced_parentheses(cases[i])) return results"},{"question":"def max_subarray_sum_prefixes(arr): Given an array \`arr\`, this function returns a list where the ith element is the sum of the maximum subarray for the prefix of length i. >>> max_subarray_sum_prefixes([1, -2, 3, 4]) [1, 1, 3, 7] >>> max_subarray_sum_prefixes([1, 2, 3, 4]) [1, 3, 6, 10] >>> max_subarray_sum_prefixes([-1, -2, -3, -4]) [-1, -1, -1, -1] >>> max_subarray_sum_prefixes([-1, 2, 3, -2, 5, -3]) [-1, 2, 5, 5, 8, 8] >>> max_subarray_sum_prefixes([5]) [5] >>> max_subarray_sum_prefixes([10**9, -10**9, 10**9, -10**9, 10**9]) [10**9, 10**9, 10**9, 10**9, 10**9] >>> max_subarray_sum_prefixes([0, 0, 0, 0]) [0, 0, 0, 0]","solution":"def max_subarray_sum_prefixes(arr): Given an array \`arr\`, this function returns a list where the ith element is the sum of the maximum subarray for the prefix of length i. n = len(arr) result = [] current_prefix_sum = 0 # Keeps track of the sum of the current prefix subarray max_ending_here = float('-inf') # Keeps track of the max subarray ending at the current position max_so_far = float('-inf') # Keeps track of the max subarray for each prefix for i in range(n): # Consider the maximum subarray ending at the current element max_ending_here = max(arr[i], max_ending_here + arr[i]) # Update the max subarray sum seen so far for the current prefix max_so_far = max(max_so_far, max_ending_here) # Append the result for the current prefix length result.append(max_so_far) return result"},{"question":"def can_form_sequence(y: int, r: int, b: int) -> str: Determine if a sequence of length y with r red stones and b blue stones can be arranged such that no two red stones are adjacent. Return \\"YES\\" or \\"NO\\". >>> can_form_sequence(5, 2, 3) 'YES' >>> can_form_sequence(4, 3, 1) 'NO' >>> can_form_sequence(6, 2, 4) 'YES' def solve(t: int, test_cases: List[Tuple[int, int, int]]) -> List[str]: Solve the problem for multiple test cases. :param t: Number of test cases :param test_cases: List of tuples, each containing y, r, and b :return: List of results for each test case (\\"YES\\" or \\"NO\\") >>> solve(3, [(5, 2, 3), (4, 3, 1), (6, 2, 4)]) ['YES', 'NO', 'YES'] >>> solve(2, [(4, 2, 2), (5, 3, 1)]) ['YES', 'NO']","solution":"def can_form_sequence(y, r, b): Determine if a sequence of length y with r red stones and b blue stones can be arranged such that no two red stones are adjacent. if (r - 1) <= b and r + b == y: return \\"YES\\" else: return \\"NO\\" def solve(t, test_cases): results = [] for case in test_cases: y, r, b = case results.append(can_form_sequence(y, r, b)) return results"},{"question":"def process_book_management(commands_list): Process the commands for book borrowing system and produce the correct output. :param commands_list: List of lists, where each list contains commands for a dataset :returns: List of lists, where each list contains the results of the check commands in that dataset >>> process_book_management([[\\"B 1 100\\", \\"C 100\\", \\"R 1 100\\", \\"C 100\\"]]) [['1', 'available']] >>> process_book_management([[\\"B 1 100\\", \\"B 2 101\\", \\"C 100\\", \\"C 101\\"]]) [['1', '2']]","solution":"def process_book_management(commands_list): Process the commands for book borrowing system and produce the correct output. :param commands_list: List of lists, where each list contains commands for a dataset results = [] for commands in commands_list: book_status = {} # To track the status of each book output = [] for command in commands: parts = command.split() cmd_type = parts[0] if cmd_type == \\"B\\": user = parts[1] book = parts[2] book_status[book] = user elif cmd_type == \\"R\\": user = parts[1] book = parts[2] if book in book_status and book_status[book] == user: del book_status[book] elif cmd_type == \\"C\\": book = parts[1] if book in book_status: output.append(book_status[book]) else: output.append(\\"available\\") results.append(output) return results def handle_input_and_output(input_data): Handles the input and output processing for the book management system. :param input_data: Multiline string input representing commands lines = input_data.strip().split('n') idx = 0 commands_list = [] while idx < len(lines): n = int(lines[idx]) if n == 0: break commands = lines[idx + 1: idx + 1 + n] commands_list.append(commands) idx += n + 1 results = process_book_management(commands_list) for result in results: for res in result: print(res) print() # Example input example_input = 6 B 1 100 B 2 101 C 100 C 101 R 1 100 C 100 4 B 1 200 C 200 R 1 200 C 200 0 handle_input_and_output(example_input)"},{"question":"def is_subsequence(n: int, seq1: List[int], m: int, seq2: List[int]) -> str: Determines if seq1 is a subsequence of seq2. >>> is_subsequence(3, [1, 3, 5], 5, [1, 2, 3, 4, 5]) \\"YES\\" >>> is_subsequence(4, [1, 2, 3, 4], 3, [1, 4, 2]) \\"NO\\" >>> is_subsequence(4, [2, 3, 4, 5], 7, [5, 6, 7, 1, 2, 3, 4]) \\"NO\\"","solution":"def is_subsequence(n, seq1, m, seq2): Determines if seq1 is a subsequence of seq2. Args: n (int): Length of the first sequence. seq1 (list): The first sequence of positive integers. m (int): Length of the second sequence. seq2 (list): The second sequence of positive integers. Returns: str: \\"YES\\" if seq1 is a subsequence of seq2, otherwise \\"NO\\". i = 0 # Pointer for seq1 j = 0 # Pointer for seq2 while i < n and j < m: if seq1[i] == seq2[j]: i += 1 # Move pointer of seq1 j += 1 # Always move pointer of seq2 # If we have traversed all elements in seq1, it's a subsequence return \\"YES\\" if i == n else \\"NO\\""},{"question":"def minimum_teams(n: int) -> int: Given the number of teams n, finds and returns the minimum number of unique teams required to conduct the tournament such that the number of teams in each round is a power of 2. >>> minimum_teams(7) 8 >>> minimum_teams(16) 16 >>> minimum_teams(99999) 131072","solution":"def minimum_teams(n): Given the number of teams n, finds and returns the minimum number of unique teams required to conduct the tournament such that the number of teams in each round is a power of 2. # Calculate the nearest power of 2 greater than or equal to n power_of_two = 1 while power_of_two < n: power_of_two *= 2 return power_of_two"},{"question":"def count_distinct_substrings(s: str, n: int) -> int: Returns the number of distinct substrings of length n in string s. >>> count_distinct_substrings(\\"abcabc\\", 3) 3 >>> count_distinct_substrings(\\"aaaaa\\", 2) 1 >>> count_distinct_substrings(\\"abcdef\\", 4) 3","solution":"def count_distinct_substrings(s, n): Returns the number of distinct substrings of length n in string s. if n > len(s): return 0 substrings = set() for i in range(len(s) - n + 1): substrings.add(s[i:i+n]) return len(substrings)"},{"question":"from typing import List, Tuple def shortest_path_from_one(N: int, M: int, edge_list: List[Tuple[int, int, int]]) -> List[int]: Compute the length of the shortest path from vertex 1 to all other vertices. :param N: The number of vertices :param M: The number of edges :param edge_list: List of tuples (u, v, w) denoting a directed edge from vertex u to vertex v with weight w :return: A list of shortest distance from vertex 1 to each vertex from 2 through N, or -1 if the vertex is unreachable >>> shortest_path_from_one(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (3, 4, 1), (2, 4, 7), (5, 3, 5)]) [2, 3, 4, -1] >>> shortest_path_from_one(4, 1, [(1, 2, 3)]) [3, -1, -1] # Implementation here","solution":"import heapq def dijkstra(N, edges): Compute the shortest path from vertex 1 to all other vertices. :param N: Total number of vertices. :param edges: List of tuples representing directed edges (u, v, w) with weight w. :return: List of shortest distances from vertex 1 to vertex i (2 <= i <= N), or -1 if unreachable. graph = [[] for _ in range(N + 1)] for u, v, w in edges: graph[u].append((v, w)) distances = [float('inf')] * (N + 1) distances[1] = 0 priority_queue = [(0, 1)] # (distance, vertex) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) result = [] for i in range(2, N + 1): if distances[i] == float('inf'): result.append(-1) else: result.append(distances[i]) return result # Function to interface with user input def shortest_path_from_one(N, M, edge_list): return dijkstra(N, edge_list)"},{"question":"def paint_canvas(n: int, m: int, k: int, p: int, q: int, r: int) -> Tuple[str, List[List[int]]]: Determine if there exists a way to paint the entire canvas following the given rules. >>> paint_canvas(3, 3, 3, 2, 2, 1) (\\"YES\\", [[1, 2, 3], [2, 3, 1], [3, 1, 2]]) >>> paint_canvas(3, 3, 2, 2, 2, 2) (\\"NO\\", [])","solution":"def can_color(canvas, i, j, n, m, k, p, q, r): used_colors = set() # Check colors directly above within p range for x in range(1, p+1): if i-x >= 0: used_colors.add(canvas[i-x][j]) # Check colors directly to the left within q range for y in range(1, q+1): if j-y >= 0: used_colors.add(canvas[i][j-y]) # Check colors diagonally top-left within r range for d in range(1, r+1): if i-d >= 0 and j-d >= 0: used_colors.add(canvas[i-d][j-d]) # Return available colors not in used_colors return set(range(1, k+1)) - used_colors def paint_canvas(n, m, k, p, q, r): canvas = [[0] * m for _ in range(n)] def backtrack(i, j): if i == n: return True next_i, next_j = (i, j+1) if j+1 < m else (i+1, 0) possible_colors = can_color(canvas, i, j, n, m, k, p, q, r) for color in possible_colors: canvas[i][j] = color if backtrack(next_i, next_j): return True canvas[i][j] = 0 return False if backtrack(0, 0): return \\"YES\\", canvas else: return \\"NO\\", [] def format_canvas(canvas): return \\"n\\".join(\\" \\".join(map(str, row)) for row in canvas) def main(n, m, k, p, q, r): status, canvas = paint_canvas(n, m, k, p, q, r) if status == \\"YES\\": print(\\"YES\\") print(format_canvas(canvas)) else: print(\\"NO\\")"},{"question":"def count_friendly_pairs(test_cases): Given multiple test cases of employees and direct messages, return the count of friendly pairs for each test case. Args: test_cases (List[Tuples[int, int, List[Tuples[int, int]]]]): List of test cases where each test case is formatted as: (number of employees, number of messages, list of messages) Returns: List[int]: List of integers representing the number of unique friendly pairs for each test case. >>> count_friendly_pairs([(3, 3, [(1, 2), (2, 3), (2, 1)]), (4, 4, [(1, 2), (2, 1), (3, 4), (4, 3)])]) [1, 2] >>> count_friendly_pairs([(2, 1, [(1, 2)]), (3, 1, [(2, 3)])]) [0, 0] >>> count_friendly_pairs([(5, 6, [(1, 2), (2, 1), (3, 4), (4, 3), (1, 3), (3, 1)]), (3, 5, [(1, 2), (2, 1), (1, 3), (3, 1), (2, 3)])]) [3, 2] from solution import count_friendly_pairs def test_example_cases(): test_cases = [ (3, 3, [(1, 2), (2, 3), (2, 1)]), (4, 4, [(1, 2), (2, 1), (3, 4), (4, 3)]) ] assert count_friendly_pairs(test_cases) == [1, 2] def test_single_message(): test_cases = [ (2, 1, [(1, 2)]), (3, 1, [(2, 3)]) ] assert count_friendly_pairs(test_cases) == [0, 0] def test_multiple_pairs(): test_cases = [ (5, 6, [(1, 2), (2, 1), (3, 4), (4, 3), (1, 3), (3, 1)]), (3, 5, [(1, 2), (2, 1), (1, 3), (3, 1), (2, 3)]) ] assert count_friendly_pairs(test_cases) == [3, 2] def test_no_pairs(): test_cases = [ (4, 4, [(1, 2), (3, 4), (2, 3), (4, 1)]) ] assert count_friendly_pairs(test_cases) == [0] def test_symmetric_pairs(): test_cases = [ (6, 4, [(1, 2), (2, 1), (3, 4), (4, 5)]), (5, 4, [(1, 2), (2, 3), (1, 3), (1, 2)]) ] assert count_friendly_pairs(test_cases) == [1, 0] def test_mixed_cases(): test_cases = [ (7, 8, [(1, 2), (2, 1), (3, 4), (4, 3), (5, 6), (6, 5), (1, 7), (7, 1)]), (8, 10, [(1, 2), (2, 1), (3, 4), (4, 3), (5, 6), (6, 5), (6, 7), (7, 6), (8, 5), (5, 8)]) ] assert count_friendly_pairs(test_cases) == [4, 5]","solution":"def count_friendly_pairs(test_cases): Given multiple test cases of employees and direct messages, return the count of friendly pairs for each test case. results = [] for case in test_cases: n, m, messages = case msg_set = set() friendly_pairs = set() for u, v in messages: if (v, u) in msg_set: friendly_pairs.add(tuple(sorted((u, v)))) msg_set.add((u, v)) results.append(len(friendly_pairs)) return results # Example usage # test_cases = [ # (3, 3, [(1, 2), (2, 3), (2, 1)]), # (4, 4, [(1, 2), (2, 1), (3, 4), (4, 3)]) #] # print(count_friendly_pairs(test_cases)) # Output: [1, 2]"},{"question":"def get_resource_score(resources): Returns the sum of the resource units mod 10^9 + 7. MOD = 10**9 + 7 return sum(resources) % MOD def update_resource(resources, index, new_value): Updates the resource at the given index with the new value and returns the updated sum. resources[index] = new_value return get_resource_score(resources) def resource_management(n, resources, updates): Returns the initial resource score and the scores after each update. >>> resource_management(3, [1, 2, 3], [(2, 5), (1, 6)]) [6, 9, 14] >>> resource_management(3, [10**9, 10**9, 10**9], [(1, 1), (2, 2)]) [2999999997 % (10**9 + 7), 2000000001 % (10**9 + 7), 1000000003 % (10**9 + 7)] >>> resource_management(2, [10**9, 10**9], [(1, 1)]) [2000000000 % (10**9 + 7), 1000000001 % (10**9 + 7)]","solution":"def get_resource_score(resources): Returns the sum of the resource units mod 10^9 + 7. MOD = 10**9 + 7 return sum(resources) % MOD def update_resource(resources, index, new_value): Updates the resource at the given index with the new value and returns the updated sum. resources[index] = new_value return get_resource_score(resources) def resource_management(n, resources, updates): Returns the initial resource score and the scores after each update. scores = [] current_score = get_resource_score(resources) scores.append(current_score) for update in updates: index, new_value = update current_score = update_resource(resources, index - 1, new_value) scores.append(current_score) return scores"},{"question":"def canConvertToPalindrome(S: str) -> str: Determine if it is possible to convert the string into a palindrome by removing exactly one character. >>> canConvertToPalindrome(\\"abca\\") \\"Yes\\" >>> canConvertToPalindrome(\\"abcd\\") \\"No\\" # Your implementation goes here def test_can_convert_to_palindrome(): assert canConvertToPalindrome(\\"abca\\") == \\"Yes\\" assert canConvertToPalindrome(\\"abcd\\") == \\"No\\" assert canConvertToPalindrome(\\"a\\") == \\"Yes\\" assert canConvertToPalindrome(\\"aa\\") == \\"Yes\\" assert canConvertToPalindrome(\\"ab\\") == \\"Yes\\" assert canConvertToPalindrome(\\"racecar\\") == \\"Yes\\" assert canConvertToPalindrome(\\"radar\\") == \\"Yes\\" assert canConvertToPalindrome(\\"raddar\\") == \\"Yes\\" assert canConvertToPalindrome(\\"abcde\\") == \\"No\\" assert canConvertToPalindrome(\\"abccbaa\\") == \\"Yes\\" assert canConvertToPalindrome(\\"aabccdbaa\\") == \\"Yes\\" assert canConvertToPalindrome(\\"acba\\") == \\"Yes\\" assert canConvertToPalindrome(\\"aaccaa\\") == \\"Yes\\" assert canConvertToPalindrome(\\"aabbca\\") == \\"No\\" assert canConvertToPalindrome(\\"abacadaba\\") == \\"No\\" if __name__ == \\"__main__\\": test_can_convert_to_palindrome() print(\\"All tests passed.\\")","solution":"def canConvertToPalindrome(S): def is_palindrome_range(s, left, right): Helper function to check if the substring s[left:right+1] is a palindrome. while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True left, right = 0, len(S) - 1 while left < right: if S[left] != S[right]: # Try removing one character and check if it becomes a palindrome return \\"Yes\\" if is_palindrome_range(S, left+1, right) or is_palindrome_range(S, left, right-1) else \\"No\\" left += 1 right -= 1 return \\"Yes\\""},{"question":"def rotate(nums, k): Rotates the array nums to the right by k steps. >>> nums = [1,2,3,4,5,6,7] >>> rotate(nums, 3) >>> nums [5,6,7,1,2,3,4] >>> nums = [-1,-100,3,99] >>> rotate(nums, 2) >>> nums [3,99,-1,-100] >>> nums = [1,2,3,4,5,6,7] >>> rotate(nums, 0) >>> nums [1,2,3,4,5,6,7] >>> nums = [1,2,3,4,5,6,7] >>> rotate(nums, 7) >>> nums [1,2,3,4,5,6,7] >>> nums = [1,2,3,4,5,6,7] >>> rotate(nums, 10) >>> nums [5,6,7,1,2,3,4] >>> nums = [1] >>> rotate(nums, 5) >>> nums [1]","solution":"def rotate(nums, k): Rotates the array nums to the right by k steps. # Ensure k is within the bounds of the length of nums k = k % len(nums) nums[:] = nums[-k:] + nums[:-k]"},{"question":"def find_pair_with_sum(arr: List[int], target: int) -> List[int]: Determines whether there exists a pair of integers in the list that add up to the target. If such a pair exists, returns the indices of the two numbers. If no such pair exists, returns an empty list. Examples: >>> find_pair_with_sum([2, 7, 11, 15, 4], 9) [0, 1] >>> find_pair_with_sum([3, 2, 4], 6) [1, 2] >>> find_pair_with_sum([1, 2, 3, 4], 8) []","solution":"def find_pair_with_sum(arr, target): Determines whether there exists a pair of integers in the list that add up to the target. If such a pair exists, returns the indices of the two numbers. If no such pair exists, returns an empty list. indices_map = {} for index, number in enumerate(arr): complement = target - number if complement in indices_map: return [indices_map[complement], index] indices_map[number] = index return []"},{"question":"def reverse_words(s: str) -> str: Reverses the order of words in a given string while ensuring that the internal characters of each word remain in place. :param s: Input string :return: String with words in reversed order >>> reverse_words(\\"hello world\\") 'world hello' >>> reverse_words(\\"The quick brown fox jumps over the lazy dog\\") 'dog lazy the over jumps fox brown quick The'","solution":"def reverse_words(s: str) -> str: Reverses the order of words in a given string while ensuring that the internal characters of each word remain in place. :param s: Input string :return: String with words in reversed order # Split the string by spaces words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list back into a string with spaces return ' '.join(reversed_words)"},{"question":"def can_reorder_to_equal_sum(n: int, A: List[int], B: List[int]) -> str: Determines if it is possible to reorder array B such that the sum of corresponding elements in A and B is the same for all indices. :param n: int - the number of elements in each array :param A: list of int - the elements of array A :param B: list of int - the elements of array B :return: str - \\"YES\\" if possible, otherwise \\"NO\\" >>> can_reorder_to_equal_sum(4, [1, 2, 3, 4], [5, 6, 7, 8]) \\"YES\\" >>> can_reorder_to_equal_sum(3, [1, 2, 3], [1, 1, 1]) \\"NO\\"","solution":"def can_reorder_to_equal_sum(n, A, B): Determines if it is possible to reorder array B such that the sum of corresponding elements in A and B is the same for all indices. :param n: int - the number of elements in each array :param A: list of int - the elements of array A :param B: list of int - the elements of array B :return: str - \\"YES\\" if possible, otherwise \\"NO\\" # Sort both arrays sorted_A = sorted(A) sorted_B = sorted(B) # Calculate the expected sum using the first element of the sorted arrays expected_sum = sorted_A[0] + sorted_B[-1] # Check if all elements in the arrays can produce the expected sum for i in range(n): if sorted_A[i] + sorted_B[-1 - i] != expected_sum: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def rearrange_string(S: str) -> str: Rearranges the input string S such that no two adjacent characters are the same. If it is not possible, returns an empty string. >>> rearrange_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] True >>> rearrange_string(\\"aaabc\\") in [\\"abaca\\", \\"acaba\\"] True >>> rearrange_string(\\"aaab\\") ''","solution":"import heapq from collections import Counter def rearrange_string(S): Rearranges the input string S such that no two adjacent characters are the same. If it is not possible, returns an empty string. count = Counter(S) max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_char and prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 # Decrease the frequency since we used one instance of char rearranged_string = ''.join(result) if len(rearranged_string) == len(S): return rearranged_string else: return ''"},{"question":"def minDifficultyRange(k, problems): Returns the minimum difference between the hardest and easiest problem in any set of k consecutive problems. >>> minDifficultyRange(3, [3, 1, 9, 7, 5, 11]) 4 >>> minDifficultyRange(4, [8, 2, 10, 6, 1, 12, 3, 7]) 4","solution":"def minDifficultyRange(k, problems): Returns the minimum difference between the hardest and easiest problem in any set of k consecutive problems. problems.sort() min_diff = float('inf') for i in range(len(problems) - k + 1): current_diff = problems[i + k - 1] - problems[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"def longest_increasing_path(n: int, hardnesses: List[int]) -> int: Return the length of the longest path a car can drive sequentially through the stages without violating the difficulty rule. >>> longest_increasing_path(1, [5]) == 1 >>> longest_increasing_path(5, [3, 3, 3, 3, 3]) == 1 >>> longest_increasing_path(5, [1, 2, 3, 4, 5]) == 5 >>> longest_increasing_path(5, [1, 2, 3, 2, 4]) == 3 >>> longest_increasing_path(6, [1, 5, 2, 3, 7, 4]) == 3 >>> longest_increasing_path(5, [5, 4, 3, 2, 1]) == 1 >>> longest_increasing_path(10, [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) == 2","solution":"def longest_increasing_path(n, hardnesses): Return the length of the longest path a car can drive sequentially through the stages without violating the difficulty rule. if n == 0: return 0 max_length = 1 # At least one stage can always be driven current_length = 1 for i in range(1, n): if hardnesses[i] > hardnesses[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def is_prime(n): Determines if the input \`n\` is a prime number. Return None for non-integer inputs. Return False for numbers less than 2. Return True if the number is prime. Examples: >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(\\"abc\\") None","solution":"def is_prime(n): Determines if the input \`n\` is a prime number. Return None for non-integer inputs. Return False for numbers less than 2. Return True if the number is prime. if not isinstance(n, int): return None if n < 2: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True"},{"question":"from typing import List def can_form_arithmetic_progression(arr: List[int]) -> bool: Determine if the given array can be rearranged to form an arithmetic progression. >>> can_form_arithmetic_progression([3, 5, 1]) True >>> can_form_arithmetic_progression([1, 2, 4]) False","solution":"from typing import List def can_form_arithmetic_progression(arr: List[int]) -> bool: Determine if the given array can be rearranged to form an arithmetic progression. Args: arr (List[int]): A list of integers. Returns: bool: True if the array can be rearranged to form an arithmetic progression, False otherwise. if len(arr) < 2: return False arr.sort() diff = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i - 1] != diff: return False return True"},{"question":"import math from typing import List def calculate_total_with_tip(t: int, bills: List[int]) -> List[int]: Given a list of bill amounts, calculate the total amount (bill + tip) rounded down to the nearest whole number. >>> calculate_total_with_tip(1, [30]) [36] >>> calculate_total_with_tip(1, [75]) [86] >>> calculate_total_with_tip(1, [250]) [275] >>> calculate_total_with_tip(1, [100]) [115] >>> calculate_total_with_tip(4, [30, 75, 250, 100]) [36, 86, 275, 115] >>> calculate_total_with_tip(1, [50]) [57] >>> calculate_total_with_tip(1, [200]) [230] >>> calculate_total_with_tip(1, [49]) [58] >>> calculate_total_with_tip(1, [201]) [221]","solution":"import math def calculate_total_with_tip(t, bills): Given a list of bill amounts, calculate the total amount (bill + tip) rounded down to the nearest whole number. results = [] for bill in bills: if bill < 50: tip = 0.2 * bill elif bill <= 200: tip = 0.15 * bill else: tip = 0.1 * bill total = bill + tip results.append(math.floor(total)) return results"},{"question":"def decrypt_message(encrypted_message: str, shift: int) -> str: Decrypts an encrypted message by shifting each letter back by the given number of positions. :param encrypted_message: The encrypted message as a string. (1 ≤ length ≤ 100) :param shift: The number of positions each letter was shifted during encryption. (1 ≤ s ≤ 25) :return: The decrypted message as a string. >>> decrypt_message('khoor', 3) 'hello' >>> decrypt_message('zruog', 3) 'world'","solution":"def decrypt_message(encrypted_message, shift): Decrypts an encrypted message by shifting each letter back by the given number of positions. :param encrypted_message: The encrypted message as a string. :param shift: The number of positions each letter was shifted during encryption. :return: The decrypted message as a string. decrypted_message = [] for char in encrypted_message: if 'a' <= char <= 'z': new_char = chr((ord(char) - ord('a') - shift) % 26 + ord('a')) decrypted_message.append(new_char) return ''.join(decrypted_message)"},{"question":"def number_of_routes(n, grid): Returns the number of distinct routes from the top-left to the bottom-right corner of the grid without passing through impassable cells. Parameters: n (int): The size of the grid (number of rows and columns). grid (List[List[int]]): The n x n grid where 0 means passable and 1 means impassable. Returns: int: The number of distinct routes from (0, 0) to (n-1, n-1). >>> number_of_routes(3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 >>> number_of_routes(3, [[0, 0, 0], [0, 1, 1], [0, 0, 0]]) == 1 >>> number_of_routes(2, [[0, 1], [1, 0]]) == 0 >>> number_of_routes(2, [[1, 0], [0, 0]]) == 0 >>> number_of_routes(5, [ [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0] ]) == 2 >>> number_of_routes(1, [[0]]) == 1 >>> number_of_routes(2, [[0, 0], [0, 0]]) == 2 pass","solution":"def number_of_routes(n, grid): Returns the number of distinct routes from the top-left to the bottom-right corner of the grid without passing through impassable cells. if grid[0][0] == 1 or grid[n-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 # no path through an impassable cell else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def is_perfect_square(n: int) -> str: Determines if an integer n is a perfect square. Returns \\"Yes\\" if it is a perfect square, otherwise returns \\"No\\". >>> is_perfect_square(16) \\"Yes\\" >>> is_perfect_square(17) \\"No\\"","solution":"def is_perfect_square(n): Determines if n is a perfect square. Returns \\"Yes\\" if it is a perfect square, otherwise returns \\"No\\". root = int(n**0.5) if root * root == n: return \\"Yes\\" else: return \\"No\\""},{"question":"def minimal_distance(n: int, gem_coordinates: List[int]) -> int: Returns the minimal distance Martha must travel to collect all gems and return to the starting point. >>> minimal_distance(4, [1, 3, 6, 2]) 12 >>> minimal_distance(2, [5, 9]) 18 >>> minimal_distance(5, [1, 3, 5, 7, 9]) 18 >>> minimal_distance(4, [8, 3, 5, 2]) 16 >>> minimal_distance(2, [1, 1000]) 2000 >>> minimal_distance(3, [1, 2, 3]) 6","solution":"def minimal_distance(n, gem_coordinates): Returns the minimal distance Martha must travel to collect all gems and return to the starting point. # Sort the gem coordinates gem_coordinates.sort() # Initialize total distance total_distance = 0 # Traverse from 0 to the smallest gem, between gems, and then return to 0 total_distance += abs(gem_coordinates[0] - 0) # from starting point to the first gem for i in range(1, n): total_distance += abs(gem_coordinates[i] - gem_coordinates[i-1]) # between consecutive gems total_distance += abs(gem_coordinates[-1] - 0) # return from the last gem to the starting point return total_distance"},{"question":"def distribute_medals(times): Distribute medals based on participants' completion times. :param times: List of strings representing times in \\"HH:MM:SS\\" format. :return: List of strings representing medals (\\"Gold\\", \\"Silver\\", \\"Bronze\\"). >>> distribute_medals([\\"00:45:30\\", \\"00:30:20\\", \\"00:50:00\\", \\"00:45:30\\"]) [\\"Silver\\", \\"Gold\\", \\"Bronze\\", \\"Silver\\"] >>> distribute_medals([\\"00:30:20\\", \\"00:30:20\\", \\"00:30:20\\"]) [\\"Gold\\", \\"Gold\\", \\"Gold\\"] >>> distribute_medals([\\"00:45:30\\", \\"00:30:20\\"]) [\\"Silver\\", \\"Gold\\"] >>> distribute_medals([\\"00:10:00\\", \\"00:20:00\\", \\"00:30:00\\"]) [\\"Gold\\", \\"Silver\\", \\"Bronze\\"] >>> distribute_medals([\\"00:30:00\\", \\"00:20:00\\", \\"00:10:00\\"]) [\\"Bronze\\", \\"Silver\\", \\"Gold\\"] >>> distribute_medals([\\"01:00:00\\", \\"00:30:00\\", \\"00:45:00\\", \\"00:45:00\\"]) [\\"Bronze\\", \\"Gold\\", \\"Silver\\", \\"Silver\\"]","solution":"def distribute_medals(times): Distribute medals based on participants' completion times. :param times: List of strings representing times in \\"HH:MM:SS\\" format. :return: List of strings representing medals (\\"Gold\\", \\"Silver\\", \\"Bronze\\"). # List of medals in the order of their importance medals = [\\"Gold\\", \\"Silver\\", \\"Bronze\\"] # Parse the times and store them along with their original indices parsed_times = [(i, list(map(int, time.split(':')))) for i, time in enumerate(times)] # Sort the times in ascending order based on hours, then minutes, then seconds parsed_times.sort(key=lambda x: x[1]) # Initialize results with empty strings result = [\\"\\"] * len(times) # Initialize current rank and current medal index current_rank = 0 # Start with rank 0 current_medal_index = 0 for i in range(len(parsed_times)): index, time = parsed_times[i] if i == 0: # First participant gets the highest available medal result[index] = medals[current_medal_index] else: # Compare current time with the previous one prev_index, prev_time = parsed_times[i - 1] if time == prev_time: # Same time gets the same medal result[index] = result[prev_index] else: # Different time, increment the rank current_rank += 1 if current_rank < len(medals): current_medal_index = current_rank if current_rank >= len(medals): # There are more participants than medals, so everyone else gets the last available medal result[index] = medals[-1] else: result[index] = medals[current_medal_index] return result"},{"question":"def dice_game_results(test_cases): Given the results of the dice throws for Sophie and Max, determine the number of rounds won by Sophie, the number of rounds won by Max, and the number of rounds resulting in a draw for each test case. Parameters: test_cases (list of list of int): A list containing the dice results of Sophie and Max for each test case. Each element in the list is a sublist with exactly 6 integers representing the dice results. Returns: list of tuples: A list of tuples where each tuple contains three integers representing the number of rounds won by Sophie, the number of rounds won by Max, and the number of rounds resulting in a draw, respectively.","solution":"def dice_game_results(test_cases): Given the results of the dice throws for Sophie and Max, determine the number of rounds won by Sophie, the number of rounds won by Max, and the number of rounds resulting in a draw for each test case. Parameters: test_cases (list of list of int): A list containing the dice results of Sophie and Max for each test case. Each element in the list is a sublist with exactly 6 integers representing the dice results. Returns: list of tuples: A list of tuples where each tuple contains three integers representing the number of rounds won by Sophie, the number of rounds won by Max, and the number of rounds resulting in a draw, respectively. results = [] for case in test_cases: # Extracting individual dice throws a1, a2, a3, b1, b2, b3 = case # Calculate the total for Sophie and Max sophie_total = a1 + a2 + a3 max_total = b1 + b2 + b3 if sophie_total > max_total: results.append((1, 0, 0)) elif max_total > sophie_total: results.append((0, 1, 0)) else: results.append((0, 0, 1)) return results"},{"question":"def find_unauthorized_access(swipes): Analyze a list of swipes and identify any individuals who had unauthorized access. Unauthorized access is defined as entering the facility at least three times in a given hour. >>> find_unauthorized_access([ ... \\"08:00 Alice\\", \\"08:10 Bob\\", \\"08:20 Alice\\", \\"09:00 Alice\\", ... \\"08:30 Alice\\", \\"08:50 Bob\\", \\"09:05 Alice\\", \\"08:55 Alice\\", ... \\"09:10 Bob\\", \\"08:40 Bob\\" ... ]) Alice Bob >>> find_unauthorized_access([ ... \\"12:00 Charlie\\", \\"12:15 Charlie\\", \\"12:30 Charlie\\", ... \\"13:00 David\\", \\"13:20 David\\" ... ]) Charlie >>> find_unauthorized_access([ ... \\"14:00 Eve\\", \\"14:10 Frank\\", \\"14:20 Gary\\" ... ]) No unauthorized access import pytest def convert_stdout_to_list(capfd): out, _ = capfd.readouterr() return out.strip().split(\\"n\\") def test_example_1(capfd): swipes = [ \\"08:00 Alice\\", \\"08:10 Bob\\", \\"08:20 Alice\\", \\"09:00 Alice\\", \\"08:30 Alice\\", \\"08:50 Bob\\", \\"09:05 Alice\\", \\"08:55 Alice\\", \\"09:10 Bob\\", \\"08:40 Bob\\" ] find_unauthorized_access(swipes) captured_output = convert_stdout_to_list(capfd) assert captured_output == [\\"Alice\\", \\"Bob\\"] def test_example_2(capfd): swipes = [ \\"12:00 Charlie\\", \\"12:15 Charlie\\", \\"12:30 Charlie\\", \\"13:00 David\\", \\"13:20 David\\" ] find_unauthorized_access(swipes) captured_output = convert_stdout_to_list(capfd) assert captured_output == [\\"Charlie\\"] def test_example_3(capfd): swipes = [ \\"14:00 Eve\\", \\"14:10 Frank\\", \\"14:20 Gary\\" ] find_unauthorized_access(swipes) captured_output = convert_stdout_to_list(capfd) assert captured_output == [\\"No unauthorized access\\"] def test_no_unauthorized_access(capfd): swipes = [ \\"08:00 Alice\\", \\"09:04 Bob\\", \\"10:01 Charlie\\" ] find_unauthorized_access(swipes) captured_output = convert_stdout_to_list(capfd) assert captured_output == [\\"No unauthorized access\\"] def test_edge_case_maximum_swipes(capfd): swipes = [\\"08:00 David\\"] * 10000 # David swipes 10000 times at the same time find_unauthorized_access(swipes) captured_output = convert_stdout_to_list(capfd) assert captured_output == [\\"David\\"]","solution":"def find_unauthorized_access(swipes): from collections import defaultdict import heapq swipe_data = defaultdict(list) for swipe in swipes: time, name = swipe.split() hh, mm = map(int, time.split(\\":\\")) swipe_time = hh * 60 + mm swipe_data[name].append(swipe_time) unauthorized_users = set() for name, times in swipe_data.items(): times.sort() for i in range(len(times) - 2): if times[i + 2] < times[i] + 60: unauthorized_users.add(name) break if unauthorized_users: for name in sorted(unauthorized_users): print(name) else: print(\\"No unauthorized access\\") # Example usage: # m = 10 # swipes = [ # \\"08:00 Alice\\", \\"08:10 Bob\\", \\"08:20 Alice\\", \\"09:00 Alice\\", # \\"08:30 Alice\\", \\"08:50 Bob\\", \\"09:05 Alice\\", \\"08:55 Alice\\", # \\"09:10 Bob\\", \\"08:40 Bob\\" # ] # find_unauthorized_access(swipes)"},{"question":"def decode_string(s: str) -> str: Write a function \`decode_string\` that takes an encoded string as input and returns its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. The function should handle nested encoded strings. Args: s (str): The encoded string. Returns: str: The decoded string. Examples: >>> decode_string(\\"3[a]2[bc]\\") \\"aaabcbc\\" >>> decode_string(\\"3[a2[c]]\\") \\"accaccacc\\" >>> decode_string(\\"2[abc]3[cd]ef\\") \\"abcabccdcdcdef\\" >>> decode_string(\\"10[a]\\") \\"aaaaaaaaaa\\"","solution":"def decode_string(s: str) -> str: def decode(index): result = \\"\\" k = 0 while index < len(s): if s[index].isdigit(): k = k * 10 + int(s[index]) elif s[index] == '[': decoded_string, end_index = decode(index + 1) result += k * decoded_string k = 0 index = end_index elif s[index] == ']': return result, index else: result += s[index] index += 1 return result, index decoded_string, _ = decode(0) return decoded_string"},{"question":"def min_time_required(taskTimes): Given an array of task times, returns the minimum total time to complete all tasks, where at most two tasks can be executed simultaneously. >>> min_time_required([4, 3, 2, 3, 1]) == 4 >>> min_time_required([5, 1, 2, 6, 2]) == 6 >>> min_time_required([7]) == 7 >>> min_time_required([4, 5]) == 5 >>> min_time_required([2, 2, 2, 2, 2]) == 2 >>> min_time_required([10, 3, 5, 7, 2, 1]) == 10 >>> min_time_required([1000] * 1000) == 1000","solution":"def min_time_required(taskTimes): Given an array of task times, returns the minimum total time to complete all tasks, where at most two tasks can be executed simultaneously. taskTimes.sort(reverse=True) max_time = 0 i = 0 while i < len(taskTimes): if i == len(taskTimes) - 1: max_time = max(max_time, taskTimes[i]) break else: max_time = max(max_time, taskTimes[i]) i += 1 i += 1 return max_time"},{"question":"def largestSquareSubMatrix(T: int, test_cases: List[Tuple[Tuple[int, int], List[List[int]]]]) -> List[int]: Given a matrix of size M x N, find the size of the largest square sub-matrix which is composed entirely of 1s. Args: T: int : number of test cases test_cases: List : each test case contains a tuple with dimensions (M, N) and the matrix itself. Returns: List: size of the largest square sub-matrix which is composed entirely of 1s for each test case Examples: >>> largestSquareSubMatrix(2, [((5, 5), [[1, 1, 1, 1, 0], [1, 1, 1, 1, 0], [1, 1, 1, 1, 1], [0, 0, 1, 1, 1], [0, 0, 1, 1, 1]]), ((3, 3), [[1, 0, 1], [1, 1, 1], [1, 1, 1]])]) [3, 2] >>> largestSquareSubMatrix(1, [((1, 1), [[1]])]) [1] >>> largestSquareSubMatrix(1, [((1, 1), [[0]])]) [0]","solution":"def largestSquareSubMatrix(T, test_cases): results = [] def findMaxSquare(matrix, M, N): max_size = 0 dp = [[0] * (N + 1) for _ in range(M + 1)] for i in range(1, M + 1): for j in range(1, N + 1): if matrix[i-1][j-1] == 1: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_size = max(max_size, dp[i][j]) return max_size for case in test_cases: M, N = case[0] matrix = case[1] results.append(findMaxSquare(matrix, M, N)) return results"},{"question":"def count_attendees(M, A): Returns the number of unique employees that will attend the event. :param M: int, The number of invitations sent. :param A: list of int, The list of employee IDs who received the invitations. :return: int, The number of unique employees that will attend the event. >>> count_attendees(5, [1, 2, 2, 3, 4]) == 4 >>> count_attendees(7, [1, 1, 1, 2, 2, 3, 4]) == 4","solution":"def count_attendees(M, A): Returns the number of unique employees that will attend the event. :param M: int, The number of invitations sent. :param A: list of int, The list of employee IDs who received the invitations. :return: int, The number of unique employees that will attend the event. return len(set(A))"},{"question":"def min_operations_to_beautiful_string(N: int, s: str) -> int: Returns the minimum number of operations required to make the string beautiful. A beautiful string has no two consecutive characters the same. Args: N (int): Length of the string. s (str): The initial string of length N. Returns: int: Minimum number of operations required. Examples: >>> min_operations_to_beautiful_string(4, 'aabb') 2 >>> min_operations_to_beautiful_string(6, 'abcdef') 0 # Your code goes here # Unit Test def test_sample_input(): assert min_operations_to_beautiful_string(4, 'aabb') == 2 def test_all_different_characters(): assert min_operations_to_beautiful_string(6, 'abcdef') == 0 def test_all_same_characters(): assert min_operations_to_beautiful_string(5, 'aaaaa') == 2 def test_alternating_characters(): assert min_operations_to_beautiful_string(7, 'abababa') == 0 def test_single_character(): assert min_operations_to_beautiful_string(1, 'a') == 0 def test_long_repeated_sequence(): assert min_operations_to_beautiful_string(10, 'aaabbaaaab') == 4 def test_edge_case_smallest(): assert min_operations_to_beautiful_string(2, 'aa') == 1 def test_edge_case_largest(): input_str = 'a' * 100000 assert min_operations_to_beautiful_string(100000, input_str) == 50000","solution":"def min_operations_to_beautiful_string(N, s): Returns the minimum number of operations required to make the string beautiful. Beautiful string means no two consecutive characters are the same. operations = 0 # Iterate over the string and check consecutive characters for i in range(1, N): if s[i] == s[i-1]: operations += 1 # Count the operations needed # Change current character to any different character # New character should be different from the next character as well if it exists if i + 1 < N and s[i] == s[i+1]: s = s[:i] + ('a' if s[i] != 'a' else 'b') + s[i+1:] else: s = s[:i] + ('a' if s[i] != 'a' else 'b') + s[i+1:] return operations # Read input data def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) s = data[1] print(min_operations_to_beautiful_string(N, s)) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List def solve(test_cases: List[str]) -> List[int]: Given a list of strings, return the length of the longest substring of each string such that the length of the substring is a prime number and the substring is also a palindrome. If no such substring exists, return -1. >>> solve([\\"abacabad\\", \\"abcde\\"]) == [7, -1] >>> solve([\\"a\\"]) == [-1] >>> solve([\\"abcdefghijklmnopqrstuvwxyz\\"]) == [-1] >>> solve([\\"aaaaaaa\\"]) == [7] >>> solve([\\"aabcbadad\\"]) == [5] >>> solve([\\"a\\" * 1000]) == [997] >>> solve([\\"abacaba\\", \\"abcbabcbabcba\\"]) == [7, 13]","solution":"def is_palindrome(s): return s == s[::-1] def generate_primes(n): primes = [] sieve = [True] * (n + 1) for p in range(2, n + 1): if sieve[p]: primes.append(p) for i in range(p * p, n + 1, p): sieve[i] = False return primes def longest_prime_length_palindrome(S): max_length = len(S) primes = generate_primes(max_length) longest_length = -1 for length in primes: for start in range(max_length - length + 1): substring = S[start:start + length] if is_palindrome(substring): longest_length = max(longest_length, length) return longest_length def solve(test_cases): results = [] for S in test_cases: result = longest_prime_length_palindrome(S) results.append(result) return results"},{"question":"def determine_sequence(arr): Determines if the array of positive integers is strictly increasing, strictly decreasing, or neither. Parameters: arr (list of int): A list of positive integers. Returns: str: \\"Increasing\\", \\"Decreasing\\", or \\"Neither\\". Examples: >>> determine_sequence([1, 2, 3, 4, 5]) 'Increasing' >>> determine_sequence([10, 8, 6, 4]) 'Decreasing' >>> determine_sequence([1, 3, 2, 4, 5, 7]) 'Neither'","solution":"def determine_sequence(arr): Determines if the array of positive integers is strictly increasing, strictly decreasing, or neither. Parameters: arr (list of int): A list of positive integers. Returns: str: \\"Increasing\\", \\"Decreasing\\", or \\"Neither\\". if all(arr[i] < arr[i + 1] for i in range(len(arr) - 1)): return \\"Increasing\\" elif all(arr[i] > arr[i + 1] for i in range(len(arr) - 1)): return \\"Decreasing\\" else: return \\"Neither\\""},{"question":"from typing import List def find_pair_with_sum(lst: List[int], target: int) -> List[int]: Returns a pair of numbers from the list that add up to the target value, or an empty list if no such pair exists. Args: lst: List of integers. target: Target sum value. Returns: A list containing the pair of numbers that add up to the target value, or an empty list if no such pair exists. Examples: >>> find_pair_with_sum([2, 7, 11, 15], 9) [2, 7] >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) []","solution":"def find_pair_with_sum(lst, target): Returns a pair of numbers from the list that add up to the target value, or an empty list if no such pair exists. Args: lst: List of integers. target: Target sum value. Returns: A list containing the pair of numbers that add up to the target value, or an empty list if no such pair exists. seen = {} for number in lst: complement = target - number if complement in seen: return [complement, number] seen[number] = True return [] # Example usage: # lst = [2, 7, 11, 15] # target = 9 # result = find_pair_with_sum(lst, target) # print(result) # Output: [2, 7]"},{"question":"def calculate_pastries(n, m): Calculate the number of pastries per box and the number of leftover pastries. Args: n (int): The number of pastries. m (int): The number of boxes. Returns: (int, int): A tuple containing the number of pastries per box and the number of leftover pastries. Examples: >>> calculate_pastries(10, 3) (3, 1) >>> calculate_pastries(25, 7) (3, 4) >>> calculate_pastries(999, 100) (9, 99)","solution":"def calculate_pastries(n, m): Calculate the number of pastries per box and the number of leftover pastries. Args: n (int): The number of pastries. m (int): The number of boxes. Returns: (int, int): A tuple containing the number of pastries per box and the number of leftover pastries. pastries_per_box = n // m leftover_pastries = n % m return pastries_per_box, leftover_pastries"},{"question":"def findSubarraySum(nums: List[int], target: int) -> int: Returns the total number of continuous subarrays whose sum equals to target. >>> findSubarraySum([1, 1, 1], 2) 2 >>> findSubarraySum([1, 2, 3], 3) 2 >>> findSubarraySum([3], 3) 1 >>> findSubarraySum([1, 2, 3], 7) 0 >>> findSubarraySum([1, 2, 1, 2, 1], 3) 4 >>> findSubarraySum([0, 0, 0, 0], 0) 10 >>> findSubarraySum([-1, -1, 1], 0) 1","solution":"def findSubarraySum(nums, target): from collections import defaultdict sum_count = defaultdict(int) current_sum = 0 count = 0 sum_count[0] = 1 # There's one way to have a cumulative sum of 0. for num in nums: current_sum += num if (current_sum - target) in sum_count: count += sum_count[current_sum - target] sum_count[current_sum] += 1 return count"},{"question":"from typing import List def num_islands(grid: List[List[str]]) -> int: Given a 2D grid of size m x n representing a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You can assume all four edges of the grid are all surrounded by water. Example: >>> num_islands([[\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"0\\"],[\\"1\\",\\"1\\",\\"0\\",\\"1\\",\\"0\\"],[\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"],[\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"]]) 1 >>> num_islands([[\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"],[\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"],[\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"],[\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"]]) 3 pass def test_num_islands_case_1(): grid = [ [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"1\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ] assert num_islands(grid) == 1 def test_num_islands_case_2(): grid = [ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ] assert num_islands(grid) == 3 def test_num_islands_empty_grid(): grid = [] assert num_islands(grid) == 0 def test_num_islands_single_element(): grid = [[\\"0\\"]] assert num_islands(grid) == 0 grid = [[\\"1\\"]] assert num_islands(grid) == 1 def test_num_islands_all_land(): grid = [ [\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\"] ] assert num_islands(grid) == 1 def test_num_islands_all_water(): grid = [ [\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\"] ] assert num_islands(grid) == 0 def test_num_islands_diagonal_islands(): grid = [ [\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"1\\",\\"0\\"], [\\"0\\",\\"0\\",\\"1\\"] ] assert num_islands(grid) == 3","solution":"def num_islands(grid): Returns the number of islands in the given grid. if not grid: return 0 m, n = len(grid), len(grid[0]) num_islands = 0 def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == '0': return grid[i][j] = '0' # Mark as visited dfs(i+1, j) # Explore down dfs(i-1, j) # Explore up dfs(i, j+1) # Explore right dfs(i, j-1) # Explore left for i in range(m): for j in range(n): if grid[i][j] == '1': dfs(i, j) num_islands += 1 return num_islands"},{"question":"def decode_messages(t: int, messages: list) -> list: Determine the number of ways each encoded message can be decoded into a meaningful message. >>> decode_messages(2, [\\"12\\", \\"226\\"]) == [2, 3] >>> decode_messages(1, [\\"06\\"]) == [0] # Your code here","solution":"def num_decodings(s: str) -> int: Calculate the number of ways to decode the given encoded message. if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != '0': dp[i] += dp[i - 1] if i > 1 and '10' <= s[i - 2:i] <= '26': dp[i] += dp[i - 2] return dp[n] def decode_messages(t: int, messages: list) -> list: results = [] for message in messages: results.append(num_decodings(message)) return results"},{"question":"def min_operations_to_non_decreasing(N: int, heights: List[int]) -> int: Determine the minimum number of operations required to ensure that the height of the pillars forms a non-decreasing sequence. Args: N : int : the number of pillars heights : List[int] : the heights of the pillars Returns: int : the minimum number of operations required Examples: >>> min_operations_to_non_decreasing(5, [3, 1, 4, 2, 5]) 4 >>> min_operations_to_non_decreasing(4, [1, 2, 3, 4]) 0 >>> min_operations_to_non_decreasing(6, [5, 3, 4, 2, 1, 6]) 10","solution":"def min_operations_to_non_decreasing(N, heights): Returns the minimum number of operations needed to make the pillar heights non-decreasing. ops = 0 for i in range(1, N): if heights[i] < heights[i-1]: ops += heights[i-1] - heights[i] heights[i] = heights[i-1] return ops"},{"question":"def can_schedule_all_appointments(I: int, A: int, interviewers: List[Tuple[int, int]], applicants: List[Tuple[int, int]]) -> str: Determine if it is possible to schedule all requested appointments. Args: I (int): Number of interviewers A (int): Number of applicants interviewers (List[Tuple[int, int]]): A list of (start, end) times of availability for each interviewer applicants (List[Tuple[int, int]]): A list of (start time, duration) for each applicant's request Returns: str: \\"YES\\" if it is possible to schedule all applicants, otherwise \\"NO\\" >>> can_schedule_all_appointments(3, 2, [(60, 120), (180, 240), (300, 360)], [(90, 30), (200, 20)]) \\"YES\\" >>> can_schedule_all_appointments(3, 2, [(60, 120), (180, 240), (300, 360)], [(170, 30), (200, 20)]) \\"NO\\"","solution":"def can_schedule_all_appointments(I, A, interviewers, applicants): # Convert interviewer availability into intervals available_intervals = [] for i in range(I): start, end = interviewers[i] available_intervals.append((start, end)) # Sort available intervals by start time available_intervals.sort() for start_time, duration in applicants: needed_end_time = start_time + duration can_schedule = False for index, (int_start, int_end) in enumerate(available_intervals): if int_start <= start_time < int_end and needed_end_time <= int_end: # Remove this interval to ensure it is not used again available_intervals.pop(index) can_schedule = True break if not can_schedule: return \\"NO\\" return \\"YES\\""},{"question":"def max_non_overlapping_events(events): Determines the maximum number of non-overlapping events. :param events: List of tuples, each tuple contains start and end time of an event. :return: Maximum number of non-overlapping events. pass from max_non_overlapping_events import max_non_overlapping_events def test_single_event(): assert max_non_overlapping_events([(1, 2)]) == 1 def test_no_overlapping_events(): assert max_non_overlapping_events([(1, 2), (3, 4), (5, 6)]) == 3 def test_overlapping_events(): assert max_non_overlapping_events([(1, 5), (1, 4), (2, 6)]) == 1 def test_mixed_events(): assert max_non_overlapping_events([(1, 3), (2, 4), (3, 5), (6, 8)]) == 2 def test_events_with_same_end_time(): assert max_non_overlapping_events([(1, 3), (2, 3), (3, 3)]) == 1 def test_events_with_gap(): assert max_non_overlapping_events([(1, 2), (4, 5), (6, 7), (8, 9)]) == 4 def test_all_events_end_same_time(): assert max_non_overlapping_events([(1, 5), (2, 5), (3, 5)]) == 1","solution":"def max_non_overlapping_events(events): Determines the maximum number of non-overlapping events. :param events: List of tuples, each tuple contains start and end time of an event. :return: Maximum number of non-overlapping events. # Sort events by their end times events.sort(key=lambda x: x[1]) max_events = 0 last_end_time = -1 for event in events: if event[0] > last_end_time: max_events += 1 last_end_time = event[1] return max_events"},{"question":"def max_team_strength(n: int, skill_levels: List[int]) -> int: Determine the maximum combined strength of any team of three students. Args: n (int): The number of students. skill_levels (List[int]): The skill levels of the students. Returns: int: The maximum combined strength of any team of three students. >>> max_team_strength(5, [10, 20, 30, 40, 50]) 120 >>> max_team_strength(3, [10, 20, 30]) 60 >>> max_team_strength(6, [1, 2, 3, 4, 5, 6]) 15 >>> max_team_strength(4, [10, 10, 10, 10]) 30 >>> max_team_strength(3, [1, 1, 1]) 3","solution":"def max_team_strength(n, skill_levels): Returns the maximum combined strength of any team of three students. Args: n: int, the number of students skill_levels: list of int, the skill levels of the students Returns: int, the maximum combined strength of any team of three students # Sort the skill levels in descending order skill_levels.sort(reverse=True) # The three highest skill levels will give the maximum possible team strength return skill_levels[0] + skill_levels[1] + skill_levels[2]"},{"question":"MOD = 1000000007 def count_paths(R: int, C: int, grid: List[str]) -> int: Compute the number of distinct paths Koma can take to reach the goal without traveling through any blocked cells, modulo 1000000007. >>> count_paths(3, 3, [\\"..#\\", \\"#..\\", \\"...\\"]) 2 >>> count_paths(3, 3, [\\"#..\\", \\"...\\", \\"...\\"]) 0 >>> count_paths(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 6 >>> count_paths(4, 4, [ \\"....\\", \\"....\\", \\"....\\", \\"....\\"]) 20 >>> count_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 pass # Replace with implementation","solution":"MOD = 1000000007 def count_paths(R, C, grid): dp = [[0] * C for _ in range(R)] dp[0][0] = 1 for i in range(R): for j in range(C): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[R-1][C-1] def main(): import sys input = sys.stdin.read data = input().split() R = int(data[0]) C = int(data[1]) grid = data[2:] result = count_paths(R, C, grid) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def evaluate_expression(expression: str) -> float: Given an input string representing a mathematical expression, evaluates the expression and returns the result. The expression can include addition, subtraction, multiplication, division, and parentheses. >>> evaluate_expression(\\"3+2*2\\") 7.0 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23.0 >>> evaluate_expression(\\"2*(5+5*2)/3+(6/2+8)\\") 21.0","solution":"def evaluate_expression(expression): Evaluates a mathematical expression and returns the result as a float. Supported operations: +, -, *, /, (, ) def evaluate(tokens): def operate(operators, values): right = values.pop() left = values.pop() operator = operators.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(left / right) operators = [] values = [] i = 0 while i < len(tokens): if tokens[i].isdigit(): value = 0 while i < len(tokens) and tokens[i].isdigit(): value = value * 10 + int(tokens[i]) i += 1 values.append(value) i -= 1 elif tokens[i] == '(': operators.append(tokens[i]) elif tokens[i] == ')': while operators and operators[-1] != '(': operate(operators, values) operators.pop() else: while (operators and operators[-1] in \\"+-*/\\" and precedence(operators[-1]) >= precedence(tokens[i])): operate(operators, values) operators.append(tokens[i]) i += 1 while operators: operate(operators, values) return values[0] def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 return float(evaluate(list(expression)))"},{"question":"def is_balanced(expression: str) -> bool: Checks if the given expression has balanced brackets. Args: expression (str): The string containing the expression with brackets. Returns: bool: True if the brackets are balanced, False otherwise. Examples: >>> is_balanced(\\"([]){}\\") True >>> is_balanced(\\"[{()}]\\") True >>> is_balanced(\\"[(])\\") False >>> is_balanced(\\"[(()]\\") False","solution":"def is_balanced(expression): Checks if the given expression has balanced brackets. Args: expression (str): The string containing the expression with brackets. Returns: bool: True if the brackets are balanced, False otherwise. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in expression: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False return stack == []"},{"question":"def count_unique_substrings(S: str) -> int: Given a string S, split it into the smallest possible number of non-overlapping substrings such that each substring contains unique characters, and return the number of such substrings. >>> count_unique_substrings(\\"abac\\") 2 >>> count_unique_substrings(\\"aaaa\\") 4 >>> count_unique_substrings(\\"abcdef\\") 1","solution":"def count_unique_substrings(S): Given a string S, split it into the smallest possible number of non-overlapping substrings such that each substring contains unique characters, and return the number of such substrings. substring_count = 0 seen_chars = set() for char in S: if char in seen_chars: substring_count += 1 seen_chars.clear() seen_chars.add(char) # Adding one for the last substring if seen_chars: substring_count += 1 return substring_count"},{"question":"from typing import List def longest_snake(n: int, m: int, grid: List[str]) -> int: Simulate the Snake game and find the maximum length of the snake that can be achieved by consuming the available food without revisiting any cell. Args: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (List[str]): The grid containing '.' for empty cells, 'S' for the starting position of the snake, and 'F' for cells containing food. Returns: int: The maximum length of the snake. Examples: >>> longest_snake(3, 3, [\\"..F\\", \\"S..\\", \\"...\\"]) 2 >>> longest_snake(4, 4, [\\"S.F.\\", \\"....\\", \\".F..\\", \\"....\\"]) 3 pass def test_case_1(): n, m = 3, 3 grid = [ \\"..F\\", \\"S..\\", \\"...\\" ] assert longest_snake(n, m, grid) == 2 def test_case_2(): n, m = 4, 4 grid = [ \\"S.F.\\", \\"....\\", \\".F..\\", \\"....\\" ] assert longest_snake(n, m, grid) == 3 def test_case_3(): n, m = 2, 2 grid = [ \\"S.\\", \\".F\\" ] assert longest_snake(n, m, grid) == 2 def test_case_4(): n, m = 3, 3 grid = [ \\"S..\\", \\"...\\", \\"..F\\" ] assert longest_snake(n, m, grid) == 2 def test_case_5(): n, m = 5, 5 grid = [ \\"S....\\", \\".....\\", \\".....\\", \\".....\\", \\"....F\\" ] assert longest_snake(n, m, grid) == 2","solution":"def longest_snake(n, m, grid): def dfs(x, y, length, visited): max_length = length for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited: if grid[nx][ny] == 'F': visited.add((nx, ny)) max_length = max(max_length, dfs(nx, ny, length + 1, visited)) visited.remove((nx, ny)) elif grid[nx][ny] == '.': visited.add((nx, ny)) max_length = max(max_length, dfs(nx, ny, length, visited)) visited.remove((nx, ny)) return max_length start_pos = None for i in range(n): for j in range(m): if grid[i][j] == 'S': start_pos = (i, j) break if start_pos: break if not start_pos: return 1 return dfs(start_pos[0], start_pos[1], 1, {start_pos}) # Examples to test our solution n1, m1 = 3, 3 grid1 = [ \\"..F\\", \\"S..\\", \\"...\\" ] print(longest_snake(n1, m1, grid1)) # Output: 2 n2, m2 = 4, 4 grid2 = [ \\"S.F.\\", \\"....\\", \\".F..\\", \\"....\\" ] print(longest_snake(n2, m2, grid2)) # Output: 3"},{"question":"def max_subarray_sum(arr): Return the maximum sum of a contiguous subarray using Kadane's Algorithm. >>> max_subarray_sum([1, 2, 3, -2, 5]) == 9 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 pass def process_test_cases(T, test_cases): Process multiple test cases and return the results of the maximum subarray sum. >>> T = 2 >>> test_cases = [(5, [1, 2, 3, -2, 5]), (4, [-1, -2, -3, -4])] >>> process_test_cases(T, test_cases) == [9, -1] pass","solution":"def max_subarray_sum(arr): Return the maximum sum of a contiguous subarray using Kadane's Algorithm. max_so_far = float('-inf') max_ending_here = 0 for number in arr: max_ending_here = max_ending_here + number if max_so_far < max_ending_here: max_so_far = max_ending_here if max_ending_here < 0: max_ending_here = 0 return max_so_far def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] arr = test_cases[i][1] results.append(max_subarray_sum(arr)) return results"},{"question":"class ListNode: def __init__(self, data=0, next=None): self.data = data self.next = next def getIntersectionNode(head1, head2): Returns the intersection node data of two linked lists, or -1 if there is no intersection. >>> nodes1 = [ListNode(3), ListNode(6), ListNode(15), ListNode(30)] >>> for i in range(len(nodes1) - 1): nodes1[i].next = nodes1[i + 1] >>> head1 = nodes1[0] >>> nodes2 = [ListNode(10), nodes1[2]] >>> for i in range(len(nodes2) - 1): nodes2[i].next = nodes2[i + 1] >>> head2 = nodes2[0] >>> getIntersectionNode(head1, head2) 15 >>> head1 = ListNode(9, ListNode(8, ListNode(7))) >>> head2 = ListNode(6, ListNode(5, ListNode(4))) >>> getIntersectionNode(head1, head2) -1 >>> head1 = ListNode(1, ListNode(2, ListNode(3))) >>> head2 = None >>> getIntersectionNode(head1, head2) -1 >>> getIntersectionNode(None, None) -1","solution":"class ListNode: def __init__(self, data=0, next=None): self.data = data self.next = next def getIntersectionNode(head1, head2): Returns the intersection node data of two linked lists, or -1 if there is no intersection. def get_length(head): length = 0 current = head while current: length += 1 current = current.next return length # Get lengths of both linked lists length1 = get_length(head1) length2 = get_length(head2) # Align both pointers for the longer to start with the same relative position current1 = head1 current2 = head2 if length1 > length2: for _ in range(length1 - length2): current1 = current1.next else: for _ in range(length2 - length1): current2 = current2.next # Move both pointers until they meet or reach the end while current1 and current2: if current1 == current2: return current1.data current1 = current1.next current2 = current2.next return -1"},{"question":"def find_max_uniform_toll(toll_rates): Find the maximum value X such that each vehicle pays at least X and no higher than the original rate at each booth. Parameters: toll_rates (list): List of integers representing the toll rates at each booth. Returns: int: The maximum value of X or -1 if it's not possible. >>> find_max_uniform_toll([7, 5, 3, 9]) == 3 >>> find_max_uniform_toll([2, 2, 1]) == 1 >>> find_max_uniform_toll([10, 20, 15]) == 10 >>> find_max_uniform_toll([]) == -1 >>> find_max_uniform_toll([100]) == 100 >>> find_max_uniform_toll([5, 5, 5, 5]) == 5 >>> find_max_uniform_toll([4, 2, 8, 1]) == 1","solution":"def find_max_uniform_toll(toll_rates): Finds the maximum value X such that each vehicle pays at least X and no higher than the original rate at each booth. Parameters: toll_rates (list): List of integers representing the toll rates at each booth. Returns: int: The maximum value of X or -1 if it's not possible. return min(toll_rates) if toll_rates else -1"},{"question":"def analyze_rectangles(data): Create a program to analyze the relationship between two rectangles on a plane. The rectangles are axis-aligned, meaning their sides are parallel to the x and y axes. Each rectangle is defined by the coordinates of its top-left and bottom-right corners. >>> analyze_rectangles([[1, 4, 5, 1, 2, 3, 6, 2], [5, 5, 8, 8, 6, 6, 7, 7], [3, 3, 6, 6, 1, 4, 5, 1], [0, 0, 0, 0]]) ['o', 'r2_ins_r1', 'n']","solution":"def analyze_rectangles(data): results = [] def rect_type(r1, r2): x1, y1, x2, y2 = r1 x3, y3, x4, y4 = r2 if x1 == x3 and y1 == y3 and x2 == x4 and y2 == y4: return 'i' if x1 >= x3 and y1 <= y3 and x2 <= x4 and y2 >= y4: return 'r1_ins_r2' if x3 >= x1 and y3 <= y1 and x4 <= x2 and y4 >= y2: return 'r2_ins_r1' if x1 > x4 or x3 > x2 or y1 < y4 or y3 < y2: return 'n' return 'o' for dataset in data: if not any(dataset): break r1 = dataset[:4] r2 = dataset[4:] results.append(rect_type(r1, r2)) return results"},{"question":"def are_anagrams(s1: str, s2: str) -> str: Returns 'YES' if the two strings s1 and s2 are anagrams, otherwise 'NO'. >>> are_anagrams(\\"listen\\", \\"silent\\") == \\"YES\\" >>> are_anagrams(\\"triangle\\", \\"integral\\") == \\"YES\\" >>> are_anagrams(\\"apple\\", \\"papel\\") == \\"NO\\" def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[str]: Processes a list of test cases and returns a list of results for each pair of strings. >>> process_test_cases([(\\"listen\\", \\"silent\\"), (\\"triangle\\", \\"integral\\"), (\\"apple\\", \\"papel\\")]) == [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def are_anagrams(s1, s2): Returns 'YES' if the two strings s1 and s2 are anagrams, otherwise 'NO'. if sorted(s1) == sorted(s2): return \\"YES\\" return \\"NO\\" def process_test_cases(test_cases): results = [] for s1, s2 in test_cases: results.append(are_anagrams(s1, s2)) return results"},{"question":"def count_occurrences_in_subarray(a: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: For each query, calculate the number of occurrences of x in the subarray a[l..r]. :param a: List of integers representing the array. :param queries: List of tuples where each tuple contains three integers (l, r, x). :return: List of integers, each representing the result of the corresponding query. >>> count_occurrences_in_subarray([1, 2, 1, 2, 3], [(1, 3, 1), (2, 4, 2), (1, 5, 3)]) [2, 2, 1] >>> count_occurrences_in_subarray([1], [(1, 1, 1), (1, 1, 2)]) [1, 0]","solution":"def count_occurrences_in_subarray(a, queries): For each query, calculate the number of occurrences of x in the subarray a[l..r]. :param a: List of integers representing the array. :param queries: List of tuples where each tuple contains three integers (l, r, x). :return: List of integers, each representing the result of the corresponding query. results = [] for l, r, x in queries: # Subarray is a[l-1:r], since l and r are 1-indexed. subarray = a[l-1:r] results.append(subarray.count(x)) return results"},{"question":"from typing import List def largest_number(nums: List[int]) -> str: Returns the concatenation of the numbers in nums in a way that forms the largest possible number. >>> largest_number([3, 30, 34, 5, 9]) '9534330' >>> largest_number([10, 2]) '210' >>> largest_number([0, 0, 0, 0]) '0' >>> largest_number([42]) '42'","solution":"from functools import cmp_to_key def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 def largest_number(nums): Returns the concatenation of the numbers in nums in a way that forms the largest possible number. # Convert all numbers to strings str_nums = list(map(str, nums)) # Sort the numbers based on their order in the largest combined form str_nums.sort(key=cmp_to_key(compare)) # Join the sorted numbers result = ''.join(str_nums) # Handle the case where the result has leading zeros (for example, if all numbers are zeros) if result[0] == '0': return '0' return result"},{"question":"def is_subsequence(s: str, p: str) -> str: Determines if p is a subsequence of s. Args: s (str): The main string. p (str): The pattern string. Returns: str: \\"Yes\\" if p is a subsequence of s, \\"No\\" otherwise. Examples: >>> is_subsequence(\\"abcde\\", \\"ace\\") \\"Yes\\" >>> is_subsequence(\\"abcde\\", \\"aec\\") \\"No\\"","solution":"def is_subsequence(s, p): Determines if p is a subsequence of s. Args: s (str): The main string. p (str): The pattern string. Returns: str: \\"Yes\\" if p is a subsequence of s, \\"No\\" otherwise. # Two pointers to navigate through s and p i, j = 0, 0 # Traverse through the main string while i < len(s) and j < len(p): if s[i] == p[j]: j += 1 i += 1 # If we have traversed all characters of p return \\"Yes\\" if j == len(p) else \\"No\\""},{"question":"def can_display_paintings(t: int, test_cases: List[Tuple[Tuple[int, int], List[int], List[int]]]) -> List[str]: Determine if it is possible to display all the paintings on the gallery wall. Parameters: t (int): the number of test cases test_cases (List[Tuple[Tuple[int, int], List[int], List[int]]]): a list of test cases where each test case contains: - a tuple with the total width available on the gallery wall and the number of paintings - a list of integers representing the widths of the paintings - a list of integers representing the gaps between each pair of consecutive paintings Returns: List[str]: a list of results for each test case, where \\"YES\\" indicates it is possible to hang all the paintings, otherwise \\"NO\\" >>> can_display_paintings(2, [((100, 3), [30, 30, 30], [5, 5]), ((50, 2), [20, 30], [10])]) [\\"YES\\", \\"NO\\"] >>> can_display_paintings(1, [((10, 2), [5, 5], [0])]) [\\"YES\\"]","solution":"def can_display_paintings(t, test_cases): results = [] for i in range(t): w, n = test_cases[i][0] painting_widths = test_cases[i][1] gaps = test_cases[i][2] total_paintings_width = sum(painting_widths) total_gaps_width = sum(gaps) total_needed_width = total_paintings_width + total_gaps_width if total_needed_width <= w: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def process_customer_requests(B, branch_cars, C, customer_requests): This function processes customer requests and determines how many customers are served successfully. Parameters: B (int): Number of branches branch_cars (List[int]): List of the number of cars available at each branch C (int): Number of customers customer_requests (List[Tuple[int, int, int]]): List of customer requests containing branch number, cars requested, and duration Returns: int: Number of customers successfully served >>> process_customer_requests( ... 5, [10, 5, 8, 2, 1], ... 4, [(1, 3, 2), (2, 6, 1), (3, 2, 3), (5, 1, 1)] ... ) 3 >>> process_customer_requests( ... 3, [1, 2, 3], ... 3, [(1, 1, 1), (2, 1, 1), (3, 4, 1)] ... ) 2 >>> process_customer_requests( ... 4, [5, 5, 5, 5], ... 4, [(1, 1, 1), (2, 3, 1), (3, 2, 1), (4, 5, 1)] ... ) 4 >>> process_customer_requests( ... 4, [5, 3, 2, 0], ... 3, [(1, 6, 1), (2, 3, 1), (3, 3, 1)] ... ) 1","solution":"def process_customer_requests(B, branch_cars, C, customer_requests): This function processes customer requests and determines how many customers are served successfully. Parameters: B (int): Number of branches branch_cars (List[int]): List of the number of cars available at each branch C (int): Number of customers customer_requests (List[Tuple[int, int, int]]): List of customer requests containing branch number, cars requested, and duration Returns: int: Number of customers successfully served successfully_served_count = 0 for request in customer_requests: branch, cars_requested, duration = request if branch_cars[branch - 1] >= cars_requested: branch_cars[branch - 1] -= cars_requested successfully_served_count += 1 return successfully_served_count # Sample Input B = 5 branch_cars = [10, 5, 8, 2, 1] C = 4 customer_requests = [ (1, 3, 2), (2, 6, 1), (3, 2, 3), (5, 1, 1) ] # Example Output result = process_customer_requests(B, branch_cars, C, customer_requests) print(result) # Output: 3"},{"question":"def min_energy_path(N, M, x1, y1, x2, y2, grid): Compute the minimum energy required for the rover to travel from the starting point to the destination in the given terrain grid. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. x1 (int): Starting x-coordinate (1-based index). y1 (int): Starting y-coordinate (1-based index). x2 (int): Ending x-coordinate (1-based index). y2 (int): Ending y-coordinate (1-based index). grid (List[str]): The terrain grid. Returns: int: Minimum energy required to travel from (x1, y1) to (x2, y2), or -1 if the destination is not reachable. pass def process_input(input_data: str) -> List[int]: Process the input data and compute the minimum energy required for each dataset. Parameters: input_data (str): Raw input data as a single string. Returns: List[int]: List of minimum energy consumption for each dataset. pass def main(): import sys input_data = sys.stdin.read() results = process_input(input_data) for res in results: print(res)","solution":"import heapq def min_energy_path(N, M, x1, y1, x2, y2, grid): def neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] != '#': yield nx, ny def cost(from_cell, to_cell): if grid[to_cell[0]][to_cell[1]] == '~': return 3 return 1 start = (x1 - 1, y1 - 1) end = (x2 - 1, y2 - 1) pq = [(0, start)] visited = set() while pq: current_cost, current = heapq.heappop(pq) if current in visited: continue visited.add(current) if current == end: return current_cost for neighbor in neighbors(*current): if neighbor not in visited: heapq.heappush(pq, (current_cost + cost(current, neighbor), neighbor)) return -1 def process_input(input_data): input_lines = input_data.strip().split('n') result = [] i = 0 while i < len(input_lines): dims = input_lines[i].strip().split() if len(dims) == 1 and dims[0] == '0': break N, M = int(dims[0]), int(dims[1]) coords = list(map(int, input_lines[i+1].strip().split())) grid = [input_lines[i+2+j].strip() for j in range(N)] result.append(min_energy_path(N, M, *coords, grid)) i += N + 2 return result def main(): import sys input_data = sys.stdin.read() results = process_input(input_data) for res in results: print(res)"},{"question":"def unique_paths_in_grid(grid_str: str) -> int: Determine the number of unique valid paths in a grid. This function takes a string representation of a grid and returns the number of unique valid paths from the top-left corner to the bottom-right corner. The first line of the input string contains two integers, R and C, separated by a single space. Each of the following R lines contains a string of length C consisting of '0's and '1's representing the grid. >>> unique_paths_in_grid(\\"3 3n000n010n000\\") 2 >>> unique_paths_in_grid(\\"2 2n00n11\\") 0 >>> unique_paths_in_grid(\\"4 4n0000n0110n0000n0010\\") 2","solution":"def count_unique_paths(grid): R = len(grid) C = len(grid[0]) if grid[0][0] == '1' or grid[R-1][C-1] == '1': return 0 dp = [[0] * C for _ in range(R)] dp[0][0] = 1 for i in range(R): for j in range(C): if grid[i][j] == '1': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[R-1][C-1] def unique_paths_in_grid(grid_str): input_lines = grid_str.strip().split('n') R, C = map(int, input_lines[0].split()) grid = [list(input_lines[i+1]) for i in range(R)] return count_unique_paths(grid)"},{"question":"def block_order(word: str) -> List[int]: Returns the indexes of the blocks in the order they should be placed to form the given word. Indexes start from 1. >>> block_order(\\"hello\\") [1, 2, 3, 4, 5] >>> block_order(\\"coding\\") [1, 2, 3, 4, 5, 6]","solution":"def block_order(word): Returns the indexes of the blocks in the order they should be placed to form the given word. Indexes start from 1. return list(range(1, len(word) + 1))"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_second_smallest(root: TreeNode) -> int: Given a binary search tree (BST), find the second smallest element in the BST. >>> root = TreeNode(4) >>> root.left = TreeNode(2, TreeNode(1), TreeNode(3)) >>> root.right = TreeNode(6) >>> find_second_smallest(root) 2 >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.left.left = TreeNode(2) >>> root.left.left.left = TreeNode(1) >>> root.left.right = TreeNode(4) >>> root.right = TreeNode(8) >>> find_second_smallest(root) 2","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_second_smallest(root): def inorder_traversal(node): Helper function to perform inorder traversal of the tree if node is None: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) inorder_elements = inorder_traversal(root) if len(inorder_elements) < 2: return None else: return inorder_elements[1]"},{"question":"def max_coins(n: int, coins: List[int]) -> int: Determine the maximum number of coins that can be collected from the tower levels. >>> max_coins(5, [3, 2, 5, 10, 7]) == 15 >>> max_coins(4, [2, 9, 7, 5]) == 14","solution":"def max_coins(n, coins): if n == 0: return 0 if n == 1: return coins[0] # Create an array to store the maximum coins that can be collected up to each level dp = [0] * n dp[0] = coins[0] if n > 1: dp[1] = max(coins[0], coins[1]) for i in range(2, n): dp[i] = max(dp[i - 1], coins[i] + dp[i - 2]) return dp[-1]"},{"question":"def shortest_route(n: int, cities: List[str], distances: List[List[int]]) -> List[str]: Finds the shortest route that visits each city exactly once and returns to the starting city. Parameters: n (int): Number of cities. cities (list of str): List of city names. distances (list of list of int): n x n matrix of distances between cities. Returns: list of str: The order of city names representing the shortest route. Example Usage: >>> n = 4 >>> cities = [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] >>> distances = [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ] >>> shortest_route(n, cities, distances) in [[\\"A\\", \\"B\\", \\"D\\", \\"C\\", \\"A\\"], [\\"A\\", \\"C\\", \\"D\\", \\"B\\", \\"A\\"]] True","solution":"from itertools import permutations def shortest_route(n, cities, distances): Finds the shortest route that visits each city exactly once and returns to the starting city. Parameters: n (int): Number of cities. cities (list of str): List of city names. distances (list of list of int): n x n matrix of distances between cities. Returns: list of str: The order of city names representing the shortest route. min_distance = float('inf') shortest_path = [] for perm in permutations(range(1, n)): current_distance = 0 current_path = [0] + list(perm) + [0] for i in range(n): current_distance += distances[current_path[i]][current_path[i+1]] if current_distance < min_distance: min_distance = current_distance shortest_path = current_path return [cities[i] for i in shortest_path] # Example usage n = 4 cities = [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] distances = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] print(shortest_route(n, cities, distances))"},{"question":"def max_payment(T: int, test_cases: List[Tuple[int, List[Tuple[int, int, int]]]]) -> List[int]: Determine the maximum payment Emily can collect by working on the optimal set of non-overlapping contracts. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int, int]]]]): List containing tuples for each test case. Each tuple contains an integer N (number of contracts) and a list of N tuples (start_time, end_time, payment). Returns: List[int]: List containing the maximum payment for each test case. Example: >>> max_payment(2, [(3, [(1, 3, 50), (2, 5, 20), (4, 6, 10)]), (2, [(1, 2, 10), (2, 3, 20)])]) [60, 20] results = [] for case in test_cases: N, contracts = case results.append(find_max_payment(contracts)) return results","solution":"def max_payment(T, test_cases): def find_max_payment(contracts): # Sort contracts by end time contracts.sort(key=lambda x: x[1]) # Dynamic programming array to store max payments dp = [0] * len(contracts) dp[0] = contracts[0][2] # First contract payment for i in range(1, len(contracts)): # Payment if taking the current contract payment_include = contracts[i][2] # Find the latest non-overlapping contract with binary search lo, hi = 0, i - 1 while lo <= hi: mid = (lo + hi) // 2 if contracts[mid][1] < contracts[i][0]: if contracts[mid + 1][1] < contracts[i][0]: lo = mid + 1 else: payment_include += dp[mid] break else: hi = mid - 1 # Max payment using the dp array dp[i] = max(dp[i-1], payment_include) return dp[-1] results = [] for case in test_cases: N, contracts = case results.append(find_max_payment(contracts)) return results # Example usage t = 2 cases = [ (3, [(1, 3, 50), (2, 5, 20), (4, 6, 10)]), (2, [(1, 2, 10), (2, 3, 20)]) ] print(max_payment(t, cases)) # Output: [60, 20]"},{"question":"def sort_heights(heights): Sort the array of heights such that the tallest student is at the first position and the shortest at the last. Maintain the relative order of students with the same height. >>> sort_heights([160, 180, 165, 170, 165, 160]) [180, 170, 165, 165, 160, 160] >>> sort_heights([150, 150, 150]) [150, 150, 150] >>> sort_heights([180]) [180] >>> sort_heights([200, 190, 180]) [200, 190, 180] >>> sort_heights([150, 160, 170, 180, 190]) [190, 180, 170, 160, 150]","solution":"def sort_heights(heights): Sort the array of heights such that the tallest student is at the first position and the shortest at the last. Maintain the relative order of students with the same height. return sorted(heights, reverse=True, key=lambda x: x)"},{"question":"def top_k_frequent_elements(nums: List[int], k: int) -> List[int]: Accepts a list of integers and an integer \`k\`, and returns a list of integers representing the \`k\` values that occur most frequently in the input list. If multiple values have the same frequency, prioritize the smaller number first. >>> top_k_frequent_elements([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> top_k_frequent_elements([1, 1, 1, 2, 2, 3, 3, 4], 3) [1, 2, 3] >>> top_k_frequent_elements([4, 4, 1, 3, 3, 3, 2, 2, 1, 1], 2) [1, 3] # Your implementation here pass","solution":"from collections import Counter def top_k_frequent_elements(nums, k): Returns the k most frequent elements in the given list of integers. If multiple elements have the same frequency, the smaller number is prioritized. # Count the frequency of each element frequency = Counter(nums) # Sort the items by frequency in descending order, and by number in ascending order if frequencies are the same sorted_items = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) # Get the first k elements return [item[0] for item in sorted_items[:k]]"},{"question":"def average_positive_numbers(numbers: List[int]) -> float: Returns the average of positive numbers in the list. If there are no positive numbers, returns 0. Args: numbers (List[int]): List of integers. Returns: float: Average of positive numbers or 0 if no positive numbers are present. >>> average_positive_numbers([1, -2, 3, 4]) 2.6666666666666665 >>> average_positive_numbers([-1, -2, -3, -4]) 0 >>> average_positive_numbers([]) 0 >>> average_positive_numbers([0, -5, 2, 5]) 3.5 >>> average_positive_numbers([1, 3, 5, 7, 9]) 5.0 >>> average_positive_numbers([10]) 10 >>> average_positive_numbers([-10]) 0 >>> average_positive_numbers([0]) 0","solution":"def average_positive_numbers(numbers): Returns the average of positive numbers in the list. If there are no positive numbers, returns 0. positive_numbers = [num for num in numbers if num > 0] if not positive_numbers: return 0 return sum(positive_numbers) / len(positive_numbers)"},{"question":"def categorize_numbers(nums: List[int]) -> str: Categorizes a list of numbers into 'Even' or 'Odd' and formats them in a specific way. >>> categorize_numbers([1, 2, 3, 4, 5]) \\"1 (Odd), 2 (Even), 3 (Odd), 4 (Even), 5 (Odd)\\" >>> categorize_numbers([10, 15, 24]) \\"10 (Even), 15 (Odd), 24 (Even)\\" >>> categorize_numbers([]) \\"\\" >>> categorize_numbers([0]) \\"0 (Even)\\" >>> categorize_numbers([7]) \\"7 (Odd)\\" >>> categorize_numbers([2, 4, 6, 8, 10]) \\"2 (Even), 4 (Even), 6 (Even), 8 (Even), 10 (Even)\\" >>> categorize_numbers([-1, -2, -3]) \\"-1 (Odd), -2 (Even), -3 (Odd)\\" >>> categorize_numbers([13, 22, 31, 42, 51, 64]) \\"13 (Odd), 22 (Even), 31 (Odd), 42 (Even), 51 (Odd), 64 (Even)\\"","solution":"def categorize_numbers(nums): Categorizes a list of numbers into \\"Even\\" or \\"Odd\\" and formats them in a specific way. Args: nums (list): A list of integers. Returns: str: A string with each number followed by its label (\\"Even\\" or \\"Odd\\"), separated by a comma and a space. result = [] for num in nums: if num % 2 == 0: result.append(f\\"{num} (Even)\\") else: result.append(f\\"{num} (Odd)\\") return ', '.join(result)"},{"question":"def maxRectangleArea(heights): Given a list of positive integers, each integer represents the height of a building in a skyline. The buildings are all contiguous. Calculate the maximum rectangular area possible in a histogram-like skyline made of the buildings' heights. >>> maxRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> maxRectangleArea([2, 4]) 4 >>> maxRectangleArea([1]) 1 >>> maxRectangleArea([1000]) 1000 >>> maxRectangleArea([2, 2, 2, 2]) 8 >>> maxRectangleArea([1, 2, 3, 4, 5]) 9 >>> maxRectangleArea([5, 4, 3, 2, 1]) 9 >>> maxRectangleArea([6, 2, 5, 4, 5, 1, 6]) 12","solution":"def maxRectangleArea(heights): Function to calculate the maximum rectangular area in a histogram-like skyline. stack = [] # Stack to store the indices of the histogram's bars max_area = 0 # Initialize max area index = 0 # Current index while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def mergeSortedArrays(arr1, arr2): Merges two sorted lists into a single sorted list. >>> mergeSortedArrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> mergeSortedArrays([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> mergeSortedArrays([1, 5, 9], [2, 6]) [1, 2, 5, 6, 9] >>> mergeSortedArrays([], []) [] >>> mergeSortedArrays([], [1, 2, 3]) [1, 2, 3] >>> mergeSortedArrays([1, 2, 3], []) [1, 2, 3] >>> mergeSortedArrays([1, 2], [3, 4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> mergeSortedArrays([1, 3, 5, 7], [2, 4, 6, 8, 10, 12]) [1, 2, 3, 4, 5, 6, 7, 8, 10, 12]","solution":"def mergeSortedArrays(arr1, arr2): Merges two sorted lists into a single sorted list. i, j = 0, 0 merged_array = [] while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Append remaining elements of arr1, if any while i < len(arr1): merged_array.append(arr1[i]) i += 1 # Append remaining elements of arr2, if any while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def sum_of_absolute_differences(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a sequence of N integers, compute the sum of the absolute differences between all pairs of integers in the sequence. Args: T : int : number of test cases test_cases : List[Tuple[int, List[int]]] : list of test cases, where each test case is a tuple containing an integer N and a list of N integers Returns: List[int] : list containing the result for each test case >>> sum_of_absolute_differences(2, [(3, [1, 2, 3]), (4, [-1, -2, -3, -4])]) [4, 10] >>> sum_of_absolute_differences(1, [(5, [1, 3, 5, 7, 9])]) [40] >>> sum_of_absolute_differences(1, [(4, [-1, -2, -3, -4])]) [10] >>> sum_of_absolute_differences(1, [(3, [-5, 0, 5])]) [20] >>> sum_of_absolute_differences(1, [(3, [100000, -100000, 0])]) [400000]","solution":"def sum_of_absolute_differences(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] sequence = test_cases[i][1] sum_abs_diff = 0 for j in range(N): for k in range(j + 1, N): sum_abs_diff += abs(sequence[j] - sequence[k]) results.append(sum_abs_diff) return results"},{"question":"def find_subarray_count_with_sum_k(n, k, array): Returns the number of contiguous subarrays whose sum is exactly k. Parameters: n (int): The length of the array k (int): The sum to find in the subarrays array (list of int): The input array of integers Returns: int: The count of contiguous subarrays with sum equal to k from solution import find_subarray_count_with_sum_k def test_example_1(): assert find_subarray_count_with_sum_k(5, 7, [3, 4, 7, 2, -3]) == 2 def test_example_2(): assert find_subarray_count_with_sum_k(4, 0, [1, -1, 1, -1]) == 4 def test_single_element_equals_k(): assert find_subarray_count_with_sum_k(1, 1, [1]) == 1 def test_single_element_not_equal_k(): assert find_subarray_count_with_sum_k(1, 2, [1]) == 0 def test_all_elements_zero_k_zero(): assert find_subarray_count_with_sum_k(3, 0, [0, 0, 0]) == 6 def test_large_negative_and_positive_elements(): assert find_subarray_count_with_sum_k(5, 3, [-1, -2, 5, -1, 2]) == 2","solution":"def find_subarray_count_with_sum_k(n, k, array): Returns the number of contiguous subarrays whose sum is exactly k. Parameters: n (int): The length of the array k (int): The sum to find in the subarrays array (list of int): The input array of integers Returns: int: The count of contiguous subarrays with sum equal to k sum_count = {0: 1} current_sum = 0 count = 0 for num in array: current_sum += num if (current_sum - k) in sum_count: count += sum_count[current_sum - k] if current_sum in sum_count: sum_count[current_sum] += 1 else: sum_count[current_sum] = 1 return count"},{"question":"def total_trip_distance(cities: List[str], distances: List[int]) -> int: Calculate the total trip distance given a list of cities and distances between consecutive cities. :param cities: List of city names. :param distances: List of distances between consecutive cities. :return: The total distance of the trip. >>> total_trip_distance([\\"New York\\", \\"Boston\\", \\"Chicago\\", \\"Dallas\\"], [215, 996, 925]) 2136 >>> total_trip_distance([\\"San Francisco\\", \\"Los Angeles\\", \\"Las Vegas\\"], [381, 270]) 651 >>> total_trip_distance([\\"Seattle\\", \\"Vancouver\\"], [141]) 141 >>> total_trip_distance([\\"CityA\\", \\"CityB\\", \\"CityC\\", \\"CityD\\"], [100, 200, 50, 150]) 500 >>> total_trip_distance([\\"CityA\\", \\"CityB\\", \\"CityC\\"], [0, 0]) 0","solution":"def total_trip_distance(cities, distances): Calculate the total trip distance given a list of cities and distances between consecutive cities. :param cities: List of city names. :param distances: List of distances between consecutive cities. :return: The total distance of the trip. return sum(distances)"},{"question":"def primaryDiagonalSum(N, Mat): Returns the sum of the primary diagonal elements of a square matrix. Parameters: N (int): The dimension of the matrix. Mat (list of list of int): The NxN matrix. Returns: int: The sum of primary diagonal elements. Example: >>> primaryDiagonalSum(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 15 >>> primaryDiagonalSum(2, [[10, 3], [7, 6]]) 16","solution":"def primaryDiagonalSum(N, Mat): Returns the sum of the primary diagonal elements of a square matrix. Parameters: N (int): The dimension of the matrix. Mat (list of list of int): The NxN matrix. Returns: int: The sum of primary diagonal elements. sum_diagonal = 0 for i in range(N): sum_diagonal += Mat[i][i] return sum_diagonal"},{"question":"def rectangle_perimeter(w: int, h: int) -> int: Given the width and height of a rectangle, return its perimeter. >>> rectangle_perimeter(2, 3) 10 >>> rectangle_perimeter(1, 1) 4 >>> rectangle_perimeter(100, 100) 400 >>> rectangle_perimeter(5, 10) 30 >>> rectangle_perimeter(50, 60) 220 >>> rectangle_perimeter(7, 8) 30 >>> rectangle_perimeter(99, 1) 200","solution":"def rectangle_perimeter(w, h): Returns the perimeter of a rectangle given its width (w) and height (h). return 2 * (w + h)"},{"question":"def find_subarray_with_sum(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: This function determines the starting and ending indices (1-based) of a contiguous subarray that sums to a given target sum for multiple test cases. If no such subarray exists, it returns -1. Parameters: T (int): number of test cases test_cases (List[Tuple[Tuple[int, int], List[int]]]): a list containing tuples. Each tuple contains: - (n, S): where n is the size of the sequence and S is the target sum - list of n integers representing the sequence Returns: List[str]: a list of strings with either the starting and ending indices or -1 for each test case Examples: >>> find_subarray_with_sum(2, [((5, 12), [1, 2, 3, 7, 5]), ((10, 15), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])]) [\\"2 4\\", \\"1 5\\"] >>> find_subarray_with_sum(1, [((5, 100), [1, 2, 3, 4, 5])]) [\\"-1\\"] >>> find_subarray_with_sum(1, [((5, -5), [-10, 5, -2, 3, -1])]) [\\"1 2\\"] >>> find_subarray_with_sum(1, [((1, 3), [3])]) [\\"1 1\\"]","solution":"def find_subarray_with_sum(T, test_cases): results = [] for i in range(T): n, S = test_cases[i][0] arr = test_cases[i][1] current_sum = 0 start_index = 0 found = False for end_index in range(n): current_sum += arr[end_index] while current_sum > S and start_index <= end_index: current_sum -= arr[start_index] start_index += 1 if current_sum == S: results.append(f\\"{start_index + 1} {end_index + 1}\\") found = True break if not found: results.append(\\"-1\\") return results"},{"question":"def min_crystals_needed(h: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the minimum number of crystals required to reach at least a target energy value T. Parameters: h (int): Number of test cases. test_cases (List[Tuple[int, int, List[int]]]): List of tuples, where each tuple contains: - N (int): Number of available crystals. - T (int): Target energy value. - E (List[int]): List of energy values of the crystals. Returns: List[int]: List of integers where each integer is the minimum number of crystals needed for each test case, or -1 if it is not possible to reach the target energy value. Example: >>> min_crystals_needed(2, [(4, 15, [2, 3, 5, 7]), (5, 8, [1, 2, 3, 4, 5])]) [3, 2] >>> min_crystals_needed(1, [(3, 30, [5, 3, 2])]) [-1]","solution":"def min_crystals_needed(h, test_cases): results = [] for i in range(h): N, T, E = test_cases[i] E.sort(reverse=True) # Sort crystals in descending order by energy value total_energy = 0 crystal_count = 0 for energy in E: total_energy += energy crystal_count += 1 if total_energy >= T: results.append(crystal_count) break else: results.append(-1) return results # Example usage: # test_cases = [ # (4, 15, [2, 3, 5, 7]), # (5, 8, [1, 2, 3, 4, 5]) # ] # print(min_crystals_needed(2, test_cases))"},{"question":"def maximalRectangle(grid): Find the area of the largest rectangular patch of grassy land in the given n x n binary matrix where 0 represents grassy cell and 1 represents waterlogged cell. Args: grid (List[List[int]]): A n x n binary matrix representing the garden layout. Returns: int: The area of the largest rectangle that can be formed with grassy cells. >>> maximalRectangle([ ... [0, 1, 1, 0, 1], ... [1, 0, 1, 1, 0], ... [0, 0, 1, 0, 0], ... [1, 1, 0, 0, 0], ... [1, 0, 0, 1, 0] ... ]) 4 >>> maximalRectangle([ ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ]) 25 >>> maximalRectangle([ ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1] ... ]) 0 >>> maximalRectangle([ ... [0, 0, 1, 0, 0], ... [0, 1, 1, 1, 0], ... [1, 1, 0, 1, 1], ... [0, 0, 1, 0, 0], ... [0, 0, 1, 0, 0] ... ]) 4 >>> maximalRectangle([ ... [0] ... ]) 1 >>> maximalRectangle([ ... [1] ... ]) 0","solution":"def maximalRectangle(grid): if not grid: return 0 n = len(grid) heights = [0] * n max_area = 0 for i in range(n): for j in range(n): heights[j] = heights[j] + 1 if grid[i][j] == 0 else 0 max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): stack = [] max_area = 0 heights.append(0) # Append a zero to handle remaining bars in stack. for i in range(len(heights)): while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() # Remove the appended zero. return max_area"},{"question":"def symmetry_index(s: str) -> int: Returns the length of the longest palindromic substring in the given string. >>> symmetry_index(\\"babad\\") 3 >>> symmetry_index(\\"cbbd\\") 2 >>> symmetry_index(\\"a\\") 1 >>> symmetry_index(\\"\\") 0 >>> symmetry_index(\\"aaaa\\") 4 >>> symmetry_index(\\"bbbbb\\") 5 >>> symmetry_index(\\"abcde\\") 1 >>> symmetry_index(\\"racecar\\") 7 >>> symmetry_index(\\"banana\\") 5","solution":"def symmetry_index(s): Returns the length of the longest palindromic substring in the given string. n = len(s) if n == 0: return 0 # Table to store results of subproblems dp = [[False]*n for _ in range(n)] max_length = 1 # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True # Check for sub-strings of length 2 start = 0 for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True start = i max_length = 2 # Check for lengths greater than 2. k is length of substring for k in range(3, n+1): for i in range(n - k + 1): j = i + k - 1 if dp[i+1][j-1] and s[i] == s[j]: dp[i][j] = True if k > max_length: start = i max_length = k return max_length"},{"question":"from typing import List def calculate_median(N: int, scores: List[int]) -> float: Returns the median score from a list of scores. >>> calculate_median(5, [1, 3, 4, 2, 5]) 3.0 >>> calculate_median(4, [1, 2, 3, 4]) 2.5","solution":"def calculate_median(N, scores): Returns the median score from a list of scores. :param N: int - the number of scores :param scores: list of int - the list of scores :return: float - the median score scores.sort() if N % 2 == 1: return float(scores[N // 2]) else: return (scores[N // 2 - 1] + scores[N // 2]) / 2"},{"question":"def min_balls_to_win(n: int, balls: List[int]) -> Union[int, str]: Determine the minimum number of balls that need to be drawn to win the game. If at any point, the sequence of ball numbers can be rearranged to form a sequence of consecutive integers, the function returns the minimum number of balls to draw. If it's impossible, it returns \\"impossible\\". >>> min_balls_to_win(5, [2, 4, 3, 6, 1, 5]) == 5 >>> min_balls_to_win(5, [1, 2, 8, 4, 5]) == \\"impossible\\"","solution":"def min_balls_to_win(n, balls): balls = sorted(balls) for i in range(n): if balls[i] - balls[0] == i: if i + 1 == n: return n else: break return \\"impossible\\""},{"question":"def applyBonuses(salaries: List[float]) -> List[float]: Adjust the salaries of employees based on their respective bonuses. Params: - salaries (list of float): A list of employee salaries before bonuses. Returns: - list of float: The updated list of employee salaries after applying the bonuses. Examples: >>> applyBonuses([4000, 6000, 25000, 7000, 15000]) [4400.0, 6300.0, 25000.0, 7350.0, 15750.0] >>> applyBonuses([0, 0, 0, 0, 0]) [0, 0, 0, 0, 0]","solution":"def applyBonuses(salaries): Adjust the salaries of employees based on their respective bonuses. Params: - salaries (list of float): A list of employee salaries before bonuses. Returns: - list of float: The updated list of employee salaries after applying the bonuses. updated_salaries = [] for salary in salaries: if salary < 5000: bonus = salary * 0.10 elif 5000 <= salary <= 20000: bonus = salary * 0.05 else: bonus = 0 updated_salaries.append(salary + bonus) return updated_salaries"},{"question":"from typing import List, Union, Tuple def findPair(nums: List[int], target: int) -> Union[Tuple[int, int], int]: Returns a tuple (a, b) where a and b are two distinct numbers from nums that add up to target, or -1 if no such pair exists. >>> findPair([2, 7, 11, 15], 9) (2, 7) >>> findPair([1, 2, 3, 4], 8) -1 >>> findPair([-3, 4, 1, 90], -2) (-3, 1) >>> findPair([10, 5, -2, 7, 8], 8) (10, -2) >>> findPair([1, 5, 9, 14], 25) -1","solution":"def findPair(nums, target): Returns a tuple (a, b) where a and b are two distinct numbers from nums that add up to target, or -1 if no such pair exists. num_set = set() for num in nums: if target - num in num_set: return (target - num, num) num_set.add(num) return -1"},{"question":"def find_treasure_min_steps(n: int, m: int, grid: List[str]) -> int: Find the minimum number of steps to reach the treasure in the bottom-right corner from the top-left corner. If it's impossible to reach, return -1. Example: >>> find_treasure_min_steps(4, 4, [\\"OOOO\\", \\"ORRO\\", \\"OOOO\\", \\"RROO\\"]) 6 >>> find_treasure_min_steps(3, 3, [\\"ROR\\", \\"ORR\\", \\"ROR\\"]) -1","solution":"from collections import deque def find_treasure_min_steps(n, m, grid): Find the minimum number of steps to reach the treasure in bottom-right from top-left. If it's impossible to reach, return -1. if grid[0][0] == 'R' or grid[n-1][m-1] == 'R': return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0)]) steps = [[float('inf')] * m for _ in range(n)] steps[0][0] = 0 while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return steps[x][y] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 'O' and steps[nx][ny] > steps[x][y] + 1: steps[nx][ny] = steps[x][y] + 1 queue.append((nx, ny)) return -1 if steps[n-1][m-1] == float('inf') else steps[n-1][m-1]"},{"question":"def number_of_diagonals(n: int) -> int: Returns the number of distinct diagonals in a regular polygon with n vertices. >>> number_of_diagonals(3) 0 >>> number_of_diagonals(4) 2 >>> number_of_diagonals(5) 5","solution":"def number_of_diagonals(n): Returns the number of distinct diagonals in a regular polygon with n vertices. # Using the formula for the number of diagonals in a polygon: n * (n - 3) / 2 return n * (n - 3) // 2"},{"question":"class SegmentTree: def __init__(self, array): self.n = len(array) self.tree = [0] * (2 * self.n) self.build(array) def build(self, array): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = array[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, idx, value): idx += self.n self.tree[idx] = value while idx > 1: idx //= 2 self.tree[idx] = min(self.tree[2 * idx], self.tree[2 * idx + 1]) def query(self, l, r): l += self.n r += self.n + 1 res = float('inf') while l < r: if l % 2: res = min(res, self.tree[l]) l += 1 if r % 2: r -= 1 res = min(res, self.tree[r]) l //= 2 r //= 2 return res def solve(n, q, array, queries): Given an array of n integers and q queries, each of the following format: 1. \\"1 l r\\" - Find the minimum value in the array between indices l and r (inclusive) 2. \\"2 i x\\" - Update the value at index i to x Args: n: int - the length of the array q: int - the number of queries array: List[int] - the array of integers queries: List[Tuple[int, int, int]] - list of queries where each query is a tuple Returns: List[int] - the list of results for all range query operations Example: >>> solve(5, 3, [5, 3, 8, 6, 2], [(1, 2, 4), (2, 3, 1), (1, 1, 5)]) [3, 1] >>> solve(4, 2, [7, 2, 5, 8], [(1, 1, 3), (2, 2, 6)]) [2]","solution":"class SegmentTree: def __init__(self, array): self.n = len(array) self.tree = [0] * (2 * self.n) self.build(array) def build(self, array): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = array[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, idx, value): idx += self.n self.tree[idx] = value while idx > 1: idx //= 2 self.tree[idx] = min(self.tree[2 * idx], self.tree[2 * idx + 1]) def query(self, l, r): l += self.n r += self.n + 1 res = float('inf') while l < r: if l % 2: res = min(res, self.tree[l]) l += 1 if r % 2: r -= 1 res = min(res, self.tree[r]) l //= 2 r //= 2 return res def solve(n, q, array, queries): segment_tree = SegmentTree(array) results = [] for query in queries: if query[0] == 1: l, r = query[1] - 1, query[2] - 1 results.append(segment_tree.query(l, r)) elif query[0] == 2: i, x = query[1] - 1, query[2] segment_tree.update(i, x) return results"},{"question":"from math import comb def count_valid_configurations(n: int, m: int, k: int) -> int: Returns the number of valid configurations of an n by m grid with exactly k 'A' molecules such that no two 'A' molecules are in the same row or column. >>> count_valid_configurations(2, 2, 2) == 2 >>> count_valid_configurations(3, 3, 1) == 9 >>> count_valid_configurations(2, 2, 3) == 0 >>> count_valid_configurations(2, 2, 0) == 1 pass # implementation here def factorial(x: int) -> int: Returns the factorial of x. pass # implementation here","solution":"from math import comb def count_valid_configurations(n, m, k): Returns the number of valid configurations of an n by m grid with exactly k 'A' molecules such that no two 'A' molecules are in the same row or column. if k > min(n, m): return 0 return comb(n, k) * comb(m, k) * factorial(k) def factorial(x): Returns the factorial of x. if x == 0: return 1 res = 1 for i in range(1, x + 1): res *= i return res"},{"question":"def get_sorted_identifiers(data: str) -> List[int]: Given a list of blocks with their identifiers, sizes, and densities, sort them according to the rules: 1. Blocks with higher density should be placed first. 2. If two blocks have the same density, the larger block should come before the smaller one. 3. If two blocks have both the same density and size, they can be in any order relative to each other. Args: data - a string containing blocks information: example: \\"4n1 10 5 Enginen2 8 6 Coachn3 15 4 Freightn4 15 7 Tender\\" Returns: list of identifiers sorted based on the rules >>> get_sorted_identifiers(\\"4n1 10 5 Enginen2 8 6 Coachn3 15 4 Freightn4 15 7 Tender\\") [4, 3, 1, 2] >>> get_sorted_identifiers(\\"3n1 10 5 Enginen2 10 6 Coachn3 10 4 Freight\\") [2, 1, 3]","solution":"def sort_blocks(blocks): Sorts blocks based on given rules: 1. Blocks with higher density should be placed first. 2. If two blocks have the same density, the larger block should come before the smaller one. 3. If two blocks have both the same density and size, they can be in any order relative to each other. Args: blocks - a list of tuples, each containing (identifier, density, size, type) example: [(1, 10, 5, 'Engine'), (2, 8, 6, 'Coach')] Returns: list of identifiers sorted based on the rules # Sort blocks by density (descending) and then by size (descending) sorted_blocks = sorted(blocks, key=lambda x: (-x[1], -x[2])) # Extract the identifiers from sorted blocks return [block[0] for block in sorted_blocks] def process_input(data): lines = data.strip().split(\\"n\\") n = int(lines[0].strip()) blocks = [] for i in range(1, n + 1): identifier, density, size, block_type = lines[i].strip().split() blocks.append((int(identifier), int(density), int(size), block_type)) return blocks def get_sorted_identifiers(data): blocks = process_input(data) sorted_identifiers = sort_blocks(blocks) return sorted_identifiers"},{"question":"def find_peaks(arr): Returns the list of indices which are peaks in the given array. A peak is an element that is greater than its neighbors. For edge elements, only one neighbor is compared. pass def process_test_cases(t, test_cases): Process multiple test cases to find peaks in each array. pass # Unit tests def test_find_peaks_case_1(): assert find_peaks([1, 3, 2, 4, 1]) == [1, 3] def test_find_peaks_case_2(): assert find_peaks([2, 2, 2, 2, 2, 2]) == [] def test_find_peaks_single_element(): assert find_peaks([5]) == [0] def test_find_peaks_two_elements(): assert find_peaks([5, 3]) == [0] assert find_peaks([3, 5]) == [1] def test_find_peaks_all_descending(): assert find_peaks([5, 4, 3, 2, 1]) == [0] def test_find_peaks_all_ascending(): assert find_peaks([1, 2, 3, 4, 5]) == [4] def test_process_test_cases(): t = 3 test_cases = [ (5, [1, 3, 2, 4, 1]), (6, [2, 2, 2, 2, 2, 2]), (4, [1, 2, 1, 2]) ] expected_results = [ [1, 3], [], [1, 3] ] assert process_test_cases(t, test_cases) == expected_results","solution":"def find_peaks(arr): Returns the list of indices which are peaks in the given array. A peak is an element that is greater than its neighbors. For edge elements, only one neighbor is compared. n = len(arr) peaks = [] if n == 0: return peaks if n == 1: peaks.append(0) return peaks # Check the first element if arr[0] > arr[1]: peaks.append(0) # Check the middle elements for i in range(1, n-1): if arr[i] > arr[i-1] and arr[i] > arr[i+1]: peaks.append(i) # Check the last element if arr[n-1] > arr[n-2]: peaks.append(n-1) return peaks def process_test_cases(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] peaks = find_peaks(arr) results.append(peaks) return results"},{"question":"def merge(nums1, m, nums2, n): Merges two sorted integer arrays nums1 and nums2 into a single sorted array in nums1. Note: You should not return a new array. Modify nums1 in-place. Args: nums1 (List[int]): The first sorted array with enough space at the end to hold elements from nums2. m (int): The number of elements in nums1. nums2 (List[int]): The second sorted array. n (int): The number of elements in nums2. Examples: >>> nums1 = [1,2,3,0,0,0] >>> merge(nums1, 3, [2,5,6], 3) >>> assert nums1 == [1,2,2,3,5,6] >>> nums1 = [1] >>> merge(nums1, 1, [], 0) >>> assert nums1 == [1] >>> nums1 = [0] >>> merge(nums1, 0, [1], 1) >>> assert nums1 == [1]","solution":"def merge(nums1, m, nums2, n): Merges two sorted integer arrays nums1 and nums2 into a single sorted array in nums1. # Set pointers for nums1 and nums2 p1 = m - 1 p2 = n - 1 # Set pointer for nums1's end p = m + n - 1 # While there are still elements to compare while p1 >= 0 and p2 >= 0: if nums1[p1] > nums2[p2]: nums1[p] = nums1[p1] p1 -= 1 else: nums1[p] = nums2[p2] p2 -= 1 p -= 1 # If there are still elements to add from nums2 while p2 >= 0: nums1[p] = nums2[p2] p2 -= 1 p -= 1"},{"question":"def robot_movements(commands_list): Simulates the movements of a robot on a 2D grid and returns the final coordinates after executing all commands. Args: commands_list (List[str]): A list of strings where each string represents a dataset. Each dataset provides initial coordinates and movement commands. Returns: List[str]: A list of strings with the final coordinates of the robot for each dataset. Example: >>> robot_movements([ ... \\"3 4n5nUnRnDnLnUn\\", ... \\"1 1n4nRnRnUnLn\\", ... \\"0 0\\" ... ]) [\\"3 5\\", \\"2 2\\"] >>> robot_movements([ ... \\"0 0n2nUnLn\\", ... \\"2 3n3nDnRnUn\\", ... \\"0 0\\" ... ]) [\\"-1 1\\", \\"3 3\\"] >>> robot_movements([ ... \\"0 0n1nLn\\", ... \\"0 0\\" ... ]) [\\"-1 0\\"] >>> robot_movements([ ... \\"1 1n4nUnDnLnRn\\", ... \\"0 0\\" ... ]) [\\"1 1\\"] >>> robot_movements([ ... \\"0 0n1nUn\\", ... \\"0 0\\" ... ]) [\\"0 1\\"]","solution":"def robot_movements(commands_list): results = [] for dataset in commands_list: if dataset == \\"0 0\\": break lines = dataset.strip().split('n') x, y = map(int, lines[0].split()) n = int(lines[1]) for command in lines[2:n+2]: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 results.append(f\\"{x} {y}\\") return results"},{"question":"def unique_sums(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given a list of positive integer weights representing different coins. Your task is to determine all the possible unique sums that can be made using any subset of the given coins. Note that a subset can be empty as well. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where the first element of each tuple is the number of coins and the second element is a list of integers representing the weights of the coins. Returns: List[int]: A list of integers indicating the number of unique possible sums obtainable from the given set of coins for each test case. Examples: >>> unique_sums(3, [(3, [1, 2, 3]), (2, [1, 5]), (4, [3, 3, 3, 3])]) [7, 4, 5] >>> unique_sums(1, [(5, [1, 1, 1, 1, 1])]) [6]","solution":"def unique_sums(t, test_cases): results = [] for test_case in test_cases: n, coins = test_case possible_sums = {0} for coin in coins: current_sums = list(possible_sums) for s in current_sums: possible_sums.add(s + coin) results.append(len(possible_sums)) return results # Example usage: # t = 3 # test_cases = [(3, [1, 2, 3]), (2, [1, 5]), (4, [3, 3, 3, 3])] # print(unique_sums(t, test_cases)) # Output: [7, 4, 5]"},{"question":"def get_product_prices(N: int, products: List[Tuple[str, int]], Q: int, queries: List[str]) -> List[str]: Returns the price of products based on provided queries. Args: - N (int): The number of products. - products (List[Tuple[str, int]]): List of tuples where each tuple contains a product ID and its price. - Q (int): The number of queries. - queries (List[str]): List of product IDs to query for their prices. Returns: - List[str]: List of results for each query; either the price of the product or \\"Product not found\\". Example Usage: >>> get_product_prices(3, [(\\"prod1\\", 100), (\\"prod2\\", 200), (\\"prod3\\", 300)], 3, [\\"prod1\\", \\"prod4\\", \\"prod3\\"]) [\\"100\\", \\"Product not found\\", \\"300\\"] >>> get_product_prices(2, [(\\"item1\\", 150), (\\"item2\\", 250)], 2, [\\"item1\\", \\"item2\\"]) [\\"150\\", \\"250\\"]","solution":"def get_product_prices(N, products, Q, queries): Returns the price of products based on provided queries. Args: - N (int): The number of products. - products (List[Tuple[str, int]]): List of tuples where each tuple contains a product ID and its price. - Q (int): The number of queries. - queries (List[str]): List of product IDs to query for their prices. Returns: - List[str]: List of results for each query; either the price of the product or \\"Product not found\\". product_dict = {product_id: price for product_id, price in products} result = [] for query in queries: if query in product_dict: result.append(str(product_dict[query])) else: result.append(\\"Product not found\\") return result"},{"question":"def checkEqualElements(arr, N): Check whether it is possible to make all elements of the array equal by modifying at most one element. >>> checkEqualElements([1, 1, 1, 2, 1], 5) \\"YES\\" >>> checkEqualElements([2, 1, 1, 1], 4) \\"YES\\" >>> checkEqualElements([3, 3, 3], 3) \\"YES\\" >>> checkEqualElements([1, 2, 3, 4], 4) \\"NO\\" >>> checkEqualElements([7, 7, 7, 7, 7], 5) \\"YES\\" >>> checkEqualElements([1], 1) \\"YES\\" >>> checkEqualElements([1, 2, 2, 3, 3], 5) \\"NO\\" >>> checkEqualElements([10, 20], 2) \\"YES\\" >>> checkEqualElements([5] * 99999 + [10], 100000) \\"YES\\"","solution":"def checkEqualElements(arr, N): Check if it is possible to make all elements in the array equal by modifying at most one element. if N <= 1: return \\"YES\\" frequency = {} for num in arr: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 max_count = max(frequency.values()) # If all elements are already the same if max_count == N: return \\"YES\\" # If we can change exactly one element to make all elements equal if max_count == N - 1: return \\"YES\\" # Otherwise, it is not possible return \\"NO\\""},{"question":"def max_strictly_increasing_subarray_length(n: int, sweetness_values: List[int]) -> int: Determine the maximum length of a subarray that is strictly in increasing order with unique sweetness values. >>> max_strictly_increasing_subarray_length(5, [1, 2, 2, 3, 4]) 3 >>> max_strictly_increasing_subarray_length(6, [9, 8, 1, 2, 3, 5]) 4","solution":"def max_strictly_increasing_subarray_length(n, sweetness_values): if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if sweetness_values[i] > sweetness_values[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List def minimum_sensors(n: int, importance_levels: List[int]) -> int: Returns the minimum number of sensors required to cover all artifacts. Args: n (int): Number of artifacts. importance_levels (list of int): Importance levels of the artifacts. Returns: int: Minimum number of sensors required. Examples: >>> minimum_sensors(6, [10, 20, 30, 40, 50, 60]) 2 >>> minimum_sensors(7, [5, 15, 25, 35, 45, 55, 65]) 3 >>> minimum_sensors(3, [1, 2, 3]) 1 >>> minimum_sensors(4, [1, 2, 3, 4]) 2 def test_minimum_sensors(): assert minimum_sensors(6, [10, 20, 30, 40, 50, 60]) == 2 assert minimum_sensors(7, [5, 15, 25, 35, 45, 55, 65]) == 3 assert minimum_sensors(3, [1, 2, 3]) == 1 assert minimum_sensors(4, [1, 2, 3, 4]) == 2 assert minimum_sensors(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 4 assert minimum_sensors(100, list(range(1, 101))) == 34","solution":"def minimum_sensors(n, importance_levels): Returns the minimum number of sensors required to cover all artifacts. Args: n (int): Number of artifacts. importance_levels (list of int): Importance levels of the artifacts. Returns: int: Minimum number of sensors required. return (n + 2) // 3"},{"question":"def min_strokes_to_paint_rectangle(n: int, m: int, x1: int, y1: int, x2: int, y2: int) -> int: Calculate the minimum number of continuous strokes needed to paint the rectangular region defined by the upper-left corner (x1, y1) and the lower-right corner (x2, y2). >>> min_strokes_to_paint_rectangle(5, 5, 2, 2, 4, 4) 3 >>> min_strokes_to_paint_rectangle(10, 7, 3, 3, 6, 5) 3 >>> min_strokes_to_paint_rectangle(10, 10, 5, 2, 5, 8) 1 >>> min_strokes_to_paint_rectangle(10, 10, 2, 3, 8, 3) 1 >>> min_strokes_to_paint_rectangle(5, 5, 1, 1, 5, 5) 5 >>> min_strokes_to_paint_rectangle(5, 5, 3, 3, 3, 3) 1","solution":"def min_strokes_to_paint_rectangle(n, m, x1, y1, x2, y2): Calculate the minimum number of continuous strokes needed to paint the rectangular region defined by the upper-left corner (x1, y1) and the lower-right corner (x2, y2). # Calculate the width and height of the rectangle width = y2 - y1 + 1 height = x2 - x1 + 1 # The minimum strokes needed is the smaller of the width and height return min(width, height)"},{"question":"def min_removals(A: List[int]) -> int: Returns the minimum number of elements to remove to make the array non-decreasing. >>> min_removals([3, 1, 2, 4, 3]) 2 >>> min_removals([1, 2, 3, 4, 5]) 0 >>> min_removals([42]) 0 >>> min_removals([7, 7, 7, 7, 7]) 0 >>> min_removals([10, 5, 3, 7, 4, 8, 9]) 3","solution":"def min_removals(A): Returns the minimum number of elements to remove to make the array non-decreasing. from bisect import bisect_right def longest_increasing_subsequence_length(A): Returns the length of the longest increasing subsequence in the array A. dp = [] # This will store the smallest ending element for each length of increasing subsequence found so far. for num in A: idx = bisect_right(dp, num) if idx >= len(dp): dp.append(num) else: dp[idx] = num return len(dp) n = len(A) lis_length = longest_increasing_subsequence_length(A) return n - lis_length"},{"question":"def three_sum_closest(nums: List[int], target: int) -> int: Finds the sum of three integers in nums such that the sum is closest to the target. >>> three_sum_closest([-1, 2, 1, -4], 1) 2 >>> three_sum_closest([1, 1, 1, 0, 5], 4) 3 Returns the sum of the three integers.","solution":"def three_sum_closest(nums, target): Finds the sum of three integers in nums such that the sum is closest to the target. nums.sort() closest_sum = float('inf') for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return current_sum return closest_sum"},{"question":"from typing import List def list_primes(n: int) -> List[int]: Returns a list of all prime numbers less than or equal to n. >>> list_primes(5) [2, 3, 5] >>> list_primes(10) [2, 3, 5, 7]","solution":"from typing import List def list_primes(n: int) -> List[int]: Returns a list of all prime numbers less than or equal to n. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False primes = [num for num in range(2, n + 1) if sieve[num]] return primes"},{"question":"class FileSystem: A class to simulate a simple text-based file system. This file system supports operations for creating directories, creating files, and listing the contents of a directory. >>> fs = FileSystem() >>> fs.mkdir(\\"/a/b/c\\") >>> fs.create(\\"/a/b/c/d\\", \\"hello\\") >>> fs.ls(\\"/\\") [\\"a\\"] >>> fs.ls(\\"/a/b/c\\") [\\"d\\"] >>> fs.ls(\\"/a/b/c/d\\") [\\"d\\"] >>> fs.create(\\"/a/b/e\\", \\"world\\") >>> fs.ls(\\"/a/b\\") [\\"c\\", \\"e\\"] def __init__(self): pass def mkdir(self, path: str): pass def create(self, path: str, content: str): pass def ls(self, path: str): pass","solution":"class FileSystem: def __init__(self): self.fs = {'/': {}} def _traverse(self, path): parts = path.strip('/').split('/') current = self.fs['/'] for part in parts: if part: if part not in current: current[part] = {} current = current[part] return current, parts[-1] def mkdir(self, path): self._traverse(path) def create(self, path, content): dir_path, file_name = path.rsplit('/', 1) parent_dir, _ = self._traverse(dir_path) if file_name not in parent_dir: parent_dir[file_name] = \\"\\" parent_dir[file_name] = content def ls(self, path): if path == '/': return sorted(self.fs['/'].keys()) current, name = self._traverse(path) if isinstance(current, dict): return sorted(current.keys()) else: return [name]"},{"question":"from typing import List def containsNearbyDuplicate(arr: List[int], k: int) -> bool: Determines if there are two distinct indices i and j in the array such that arr[i] == arr[j] and the absolute difference between i and j is at most k. >>> containsNearbyDuplicate([1,2,3,1,2,3], 2) False >>> containsNearbyDuplicate([1,0,1,1], 1) True pass","solution":"def containsNearbyDuplicate(arr, k): Determines if there are two distinct indices i and j in the array such that arr[i] == arr[j] and the absolute difference between i and j is at most k. :param arr: List[int] - The array of integers. :param k: int - The maximum index difference. :return: bool - True if such elements exist, otherwise False. value_to_index = {} for i, num in enumerate(arr): if num in value_to_index and i - value_to_index[num] <= k: return True value_to_index[num] = i return False"},{"question":"def capitalize_words(s: str) -> str: Capitalizes the first letter of each word in the given string. >>> capitalize_words(\\"hello world\\") 'Hello World' >>> capitalize_words(\\"coding is fun\\") 'Coding Is Fun' >>> capitalize_words(\\"python\\") 'Python' >>> capitalize_words(\\" hello world \\") 'Hello World' >>> capitalize_words(\\"hello world\\") 'Hello World' >>> capitalize_words(\\"\\") '' >>> capitalize_words(\\"a b c\\") 'A B C' >>> capitalize_words(\\"hello World\\") 'Hello World'","solution":"def capitalize_words(s): Capitalizes the first letter of each word in the given string. :param s: The input string containing words separated by spaces. :return: A string with the first letter of each word capitalized. return ' '.join(word.capitalize() for word in s.split())"},{"question":"def calculate_productive_time(events): Compute the total productive time worked by the employee, excluding breaks. Args: events (List[str]): A list of strings representing the events in chronological order. Returns: int: Total productive time worked by the employee in minutes. Examples: >>> calculate_productive_time([\\"start 0\\", \\"break 30\\", \\"return 45\\", \\"stop 90\\"]) 75 >>> calculate_productive_time([\\"start 0\\", \\"stop 100\\"]) 100 >>> calculate_productive_time([\\"start 0\\", \\"break 30\\", \\"return 45\\", \\"break 60\\", \\"return 75\\", \\"stop 90\\"]) 60 >>> calculate_productive_time([\\"start 0\\", \\"stop 0\\"]) 0 >>> calculate_productive_time([\\"start 0\\", \\"break 5\\", \\"return 100\\", \\"stop 150\\"]) 55","solution":"def calculate_productive_time(events): productive_time = 0 work_start_time = 0 break_start_time = 0 on_break = False for event in events: action, t = event.split() t = int(t) if action == \\"start\\": work_start_time = t elif action == \\"stop\\": if not on_break: productive_time += t - work_start_time elif action == \\"break\\": if not on_break: productive_time += t - work_start_time on_break = True break_start_time = t elif action == \\"return\\": if on_break: work_start_time = t on_break = False return productive_time"},{"question":"def encode_title(title: str) -> str: Encodes a title based on consecutive runs of the same character. >>> encode_title(\\"book\\") \\"b1o2k1\\" >>> encode_title(\\"keeper\\") \\"k1e2p1e1r1\\" >>> encode_title(\\"a\\") \\"a1\\" def encode_titles(titles: [str]) -> [str]: Encodes a list of titles. >>> encode_titles([\\"book\\", \\"keeper\\", \\"a\\"]) [\\"b1o2k1\\", \\"k1e2p1e1r1\\", \\"a1\\"] def test_encode_title_single_char(): assert encode_title(\\"a\\") == \\"a1\\" def test_encode_title_multiple_chars_with_repeats(): assert encode_title(\\"book\\") == \\"b1o2k1\\" assert encode_title(\\"keeper\\") == \\"k1e2p1e1r1\\" def test_encode_title_all_unique_chars(): assert encode_title(\\"abcd\\") == \\"a1b1c1d1\\" def test_encode_title_all_same_chars(): assert encode_title(\\"aaaa\\") == \\"a4\\" def test_encode_multiple_titles(): titles = [\\"book\\", \\"keeper\\", \\"a\\"] result = encode_titles(titles) expected = [\\"b1o2k1\\", \\"k1e2p1e1r1\\", \\"a1\\"] assert result == expected def test_encode_empty_title(): assert encode_title(\\"\\") == \\"\\" python","solution":"def encode_title(title): Encodes a title based on consecutive runs of the same character. if not title: return \\"\\" encoded = [] current_char = title[0] count = 1 for char in title[1:]: if char == current_char: count += 1 else: encoded.append(f\\"{current_char}{count}\\") current_char = char count = 1 encoded.append(f\\"{current_char}{count}\\") return ''.join(encoded) def encode_titles(titles): Encodes a list of titles. return [encode_title(title) for title in titles]"},{"question":"def longest_subarray_with_abs_diff_one(arr): Returns the length of the longest subarray where every two consecutive elements have an absolute difference of 1. >>> longest_subarray_with_abs_diff_one([1, 2, 2, 3, 4, 4]) 3 >>> longest_subarray_with_abs_diff_one([1, 3, 5, 7, 9, 11, 13, 15]) 1 >>> longest_subarray_with_abs_diff_one([5, 5, 5, 5, 5]) 1 >>> longest_subarray_with_abs_diff_one([1000]) 1 >>> longest_subarray_with_abs_diff_one([-1, -2, -1, 0, 1, 2, 3]) 7 >>> longest_subarray_with_abs_diff_one([1, 2, 3, 2, 1, 0, -1, -2, -1, 0, 1, 2, 3]) 13 >>> longest_subarray_with_abs_diff_one([1, 2, 1, 2, 1, 2, 1, 2]) 8 >>> longest_subarray_with_abs_diff_one([10, 5, 15, 20, 25]) 1","solution":"def longest_subarray_with_abs_diff_one(arr): Returns the length of the longest subarray where every two consecutive elements have an absolute difference of 1. if not arr: return 0 longest = 1 current_length = 1 for i in range(1, len(arr)): if abs(arr[i] - arr[i-1]) == 1: current_length += 1 longest = max(longest, current_length) else: current_length = 1 return longest"},{"question":"def findMedianSortedArrays(arr1: List[int], arr2: List[int]) -> float: Returns the median of the two sorted arrays. >>> findMedianSortedArrays([1, 2, 3], [4, 5, 6, 7]) 4.0 >>> findMedianSortedArrays([1, 3, 8], [7, 11]) 7.0 >>> findMedianSortedArrays([], []) 0.0","solution":"def findMedianSortedArrays(arr1, arr2): Returns the median of the two sorted arrays. if not arr1 and not arr2: return 0.0 # Ensuring arr1 is the smaller array. if len(arr1) > len(arr2): arr1, arr2 = arr2, arr1 m, n = len(arr1), len(arr2) imin, imax, half_len = 0, m, (m + n + 1) // 2 while imin <= imax: i = (imin + imax) // 2 j = half_len - i if i < m and arr2[j-1] > arr1[i]: imin = i + 1 elif i > 0 and arr1[i-1] > arr2[j]: imax = i - 1 else: if i == 0: max_of_left = arr2[j-1] elif j == 0: max_of_left = arr1[i-1] else: max_of_left = max(arr1[i-1], arr2[j-1]) if (m + n) % 2 == 1: return float(max_of_left) if i == m: min_of_right = arr2[j] elif j == n: min_of_right = arr1[i] else: min_of_right = min(arr1[i], arr2[j]) return (max_of_left + min_of_right) / 2.0"},{"question":"def sum_modulo(arr: List[int]) -> int: Returns the sum of integers in the list modulo 1000000007 if the sum is even. If the sum is odd, returns -1. >>> sum_modulo([1, 2, 3]) 6 >>> sum_modulo([1, 2, 4]) -1","solution":"def sum_modulo(arr): Returns the sum of integers in list modulo 1000000007 if the sum is even. If the sum is odd, returns -1. total = sum(arr) if total % 2 == 0: return total % 1000000007 else: return -1"},{"question":"def can_make_even_occurrences(Q: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Determine if it is possible to make all integers in the array appear an even number of times using at most P operations. Args: Q: The number of test cases. test_cases: A list of test cases, each containing a tuple of (M, P) and a list of M integers. Returns: A list of strings, \\"YES\\" if it is possible for each test case, and \\"NO\\" otherwise. >>> can_make_even_occurrences(2, [((5, 3), [1, 2, 2, 3, 3]), ((4, 1), [1, 1, 2, 3])]) [\\"YES\\", \\"NO\\"] >>> can_make_even_occurrences(1, [((4, 0), [2, 2, 4, 4])]) [\\"YES\\"]","solution":"def can_make_even_occurrences(Q, test_cases): results = [] for test in test_cases: M, P = test[0] B = test[1] frequency_map = {} for num in B: if num in frequency_map: frequency_map[num] += 1 else: frequency_map[num] = 1 odd_count = sum(1 for count in frequency_map.values() if count % 2 != 0) if odd_count <= P: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage def process_input_output(): import sys input = sys.stdin.read data = input().split() index = 0 Q = int(data[index]) index += 1 test_cases = [] for _ in range(Q): M, P = int(data[index]), int(data[index+1]) index += 2 B = list(map(int, data[index:index+M])) index += M test_cases.append([(M, P), B]) results = can_make_even_occurrences(Q, test_cases) for result in results: print(result)"},{"question":"def min_window(s: str, t: str) -> str: Given two strings s and t, return the minimum window in s which will contain all the characters in t. If there is no such window in s that covers all characters in t, return the empty string ''. >>> min_window(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> min_window(\\"a\\", \\"a\\") \\"a\\" >>> min_window(\\"a\\", \\"b\\") \\"\\" >>> min_window(\\"\\", \\"a\\") \\"\\" >>> min_window(\\"a\\", \\"\\") \\"\\" >>> min_window(\\"ADOBECODEBANCB\\", \\"ABC\\") \\"BANC\\"","solution":"def min_window(s, t): from collections import Counter if not t or not s: return \\"\\" dict_t = Counter(t) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = {} ans = float(\\"inf\\"), None, None while r < len(s): character = s[r] window_counts[character] = window_counts.get(character, 0) + 1 if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]: ans[2] + 1]"},{"question":"def generate_pascals_triangle(numRows: int) -> List[List[int]]: Generate the first numRows of Pascal's triangle. Example 1: >>> generate_pascals_triangle(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] Example 2: >>> generate_pascals_triangle(1) [[1]]","solution":"def generate_pascals_triangle(numRows): Generates the first numRows of Pascal's triangle. Args: numRows (int): The number of rows of Pascal's triangle to generate. Returns: List[List[int]]: A list of lists where each inner list represents a row of Pascal's triangle. if numRows <= 0: return [] triangle = [[1]] for i in range(1, numRows): row = [1] for j in range(1, i): row.append(triangle[i - 1][j - 1] + triangle[i - 1][j]) row.append(1) triangle.append(row) return triangle"},{"question":"from typing import List, Tuple def find_three_sum(target: int, numbers: List[int]) -> List[int]: Find three distinct integers in the list that add up to a given target sum. Return an empty list if no such triplet exists. >>> find_three_sum(10, [1, 2, 3, 4, 5, 6, 7, 8, 9]) [1, 2, 7] >>> find_three_sum(15, [2, 2, 2, 2, 2]) [] def solve(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Solve the problem for T test cases. Each test case consists of a target sum and a list of integers. >>> solve(2, [(10, [1, 2, 3, 4, 5, 6, 7, 8, 9]), (15, [2, 2, 2, 2, 2])]) [[1, 2, 7], []] >>> solve(1, [(8, [1, 2, 3, 4, 5])]) [[1, 2, 5]] from solution import solve def test_case_1(): T = 2 test_cases = [ (10, [1, 2, 3, 4, 5, 6, 7, 8, 9]), (15, [2, 2, 2, 2, 2]) ] expected = [ [1, 2, 7], [] ] assert solve(T, test_cases) == expected def test_case_2(): T = 1 test_cases = [ (8, [1, 2, 3, 4, 5]) ] expected = [ [1, 2, 5] ] assert solve(T, test_cases) == expected def test_case_3(): T = 1 test_cases = [ (10, [-1, 2, 9, 7, 3]) ] expected = [ [-1, 2, 9] ] assert solve(T, test_cases) == expected def test_case_4(): T = 1 test_cases = [ (0, [-1, 1, -2, 2, -3, 3]) ] expected = [ [-3, 1, 2] ] assert solve(T, test_cases) == expected def test_case_5(): T = 1 test_cases = [ (20, [5, 10, 15, 20, 25]) ] expected = [ [] ] assert solve(T, test_cases) == expected","solution":"from typing import List, Tuple def find_three_sum(target: int, numbers: List[int]) -> List[int]: numbers.sort() # Sorting the list to ease the process of finding the lexicographically smallest triplet n = len(numbers) for i in range(n - 2): if i > 0 and numbers[i] == numbers[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = numbers[i] + numbers[left] + numbers[right] if current_sum == target: return [numbers[i], numbers[left], numbers[right]] elif current_sum < target: left += 1 else: right -= 1 return [] def solve(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: results = [] for target, numbers in test_cases: result = find_three_sum(target, numbers) results.append(result) return results"},{"question":"def can_form_right_angled_triangle(points): Determine if a set of magical points can form a right-angled triangle with the right angle at the origin (0, 0). Args: points (List[Tuple[int, int]]): List of tuples containing coordinates (xi, yi). Returns: str: \\"YES\\" if the points can form a right-angled triangle with the right angle at the origin, \\"NO\\" otherwise. >>> can_form_right_angled_triangle([(0, 0), (1, 2), (3, 0)]) == \\"YES\\" >>> can_form_right_angled_triangle([(0, 0), (6, 8), (3, 0)]) == \\"YES\\" >>> can_form_right_angled_triangle([(0, 0), (1, 1), (2, 2)]) == \\"NO\\" def check_cities(cities): Checks multiple cities’ points to see if each set can form a right-angled triangle with the right angle at the origin. Args: cities (List[List[Tuple[int, int]]]): List of cities, each city is a list of (x, y) tuples. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each city. >>> check_cities([[(0, 0), (1, 2), (3, 0)], [(0, 0), (6, 8), (3, 0)], [(0, 0), (1, 1), (2, 2)]]) == [\\"YES\\", \\"YES\\", \\"NO\\"] >>> check_cities([[(0, 0), (0, 1), (1, 0), (2, 2)], [(0, 0), (1, 2), (4, 0)], [(0, 0), (2, 3), (5, 0), (0, 4)]]) == [\\"YES\\", \\"YES\\", \\"YES\\"] >>> check_cities([[(1, 1), (2, 2), (3, 3)], [(1, 2), (2, 4), (3, 6)], [(5, 5), (10, 0), (0, 10)]]) == [\\"NO\\", \\"NO\\", \\"YES\\"]","solution":"def can_form_right_angled_triangle(points): Determine if a set of magical points can form a right-angled triangle with the right angle at the origin (0, 0). Args: points (List[Tuple[int, int]]): List of tuples containing coordinates (xi, yi). Returns: str: \\"YES\\" if the points can form a right-angled triangle with the right angle at the origin, \\"NO\\" otherwise. for i in range(len(points)): for j in range(i + 1, len(points)): if (points[i][0] == 0 and points[j][1] == 0) or (points[i][1] == 0 and points[j][0] == 0): return \\"YES\\" return \\"NO\\" def check_cities(cities): Checks multiple cities’ points to see if each set can form a right-angled triangle with the right angle at the origin. Args: cities (List[List[Tuple[int, int]]]): List of cities, each city is a list of (x, y) tuples. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each city. return [can_form_right_angled_triangle(city) for city in cities]"},{"question":"from typing import List, Tuple def canAttendMeetings(times: List[Tuple[int, int]]) -> bool: Returns True if a person can attend all meetings without overlap, else returns False. :param times: List of tuples where each tuple is a (start, end) time of the meeting. >>> canAttendMeetings([(0, 30), (5, 10), (15, 20)]) False >>> canAttendMeetings([(7, 10), (2, 4)]) True","solution":"from typing import List, Tuple def canAttendMeetings(times: List[Tuple[int, int]]) -> bool: Returns True if a person can attend all meetings without overlap, else returns False. :param times: List of tuples where each tuple is a (start, end) time of the meeting. if not times: return True # Sort the meetings by their start time times.sort(key=lambda x: x[0]) # Iterate through the sorted list and check for any overlap for i in range(1, len(times)): if times[i][0] < times[i-1][1]: return False return True"},{"question":"def is_perfect_square(n: int) -> bool: Checks if a given integer is a perfect square. >>> is_perfect_square(16) # True, because 4*4 = 16 >>> is_perfect_square(15) # False, because sqrt(15) = 3.872..., which is not an integer >>> is_perfect_square(0) # True, because 0*0 = 0 >>> is_perfect_square(1) # True, because 1*1 = 1","solution":"def is_perfect_square(n: int) -> bool: Checks if a given integer is a perfect square. Args: n (int): The integer to check. Returns: bool: True if n is a perfect square, False otherwise. if n < 0: return False if n == 0 or n == 1: return True left, right = 1, n while left <= right: mid = (left + right) // 2 squared = mid * mid if squared == n: return True elif squared < n: left = mid + 1 else: right = mid - 1 return False"},{"question":"def min_toggles_to_uniform(T: int, test_cases: List[Tuple[int, str]]) -> List[int]: Determine the minimum number of toggles to make all bulbs in a string either fully on or fully off. Args: T (int): Number of test cases. test_cases (List[Tuple[int, str]]): Each test case is a tuple containing an integer N (number of bulbs) and a string S (state of each bulb). Returns: List[int]: A list of integers where each integer denotes the minimum number of toggles for each test case. >>> min_toggles_to_uniform(3, [(6, \\"001100\\"), (4, \\"1010\\"), (5, \\"11111\\")]) [1, 2, 0] >>> min_toggles_to_uniform(2, [(1, \\"0\\"), (1, \\"1\\")]) [0, 0] >>> min_toggles_to_uniform(3, [(3, \\"000\\"), (4, \\"1111\\"), (5, \\"00000\\")]) [0, 0, 0] >>> min_toggles_to_uniform(3, [(4, \\"0101\\"), (6, \\"010101\\"), (8, \\"10101010\\")]) [2, 3, 4]","solution":"def min_toggles_to_uniform(T, test_cases): results = [] for case in test_cases: N, S = case # Count the number of transitions from '0' to '1' or '1' to '0' transitions = sum(1 for i in range(1, N) if S[i] != S[i - 1]) # Divide the transitions by 2 and round up to get the number of groups min_toggles = (transitions + 1) // 2 results.append(min_toggles) return results"},{"question":"def generate_spiral_matrix(N): Generates an NxN matrix filled with integers from 1 to N^2 in a spiral order starting from the top-left corner and moving right. :param N: Size of the matrix (1 ≤ N ≤ 100) :return: NxN 2D list representing the spiral matrix. >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral_matrix(1) [[1]]","solution":"def generate_spiral_matrix(N): Generates an NxN matrix filled with integers from 1 to N^2 in a spiral order. :param N: Size of the matrix (1 ≤ N ≤ 100) :return: NxN 2D list representing the spiral matrix. if N <= 0: return [] # Initialize an N x N matrix filled with 0s matrix = [[0 for _ in range(N)] for _ in range(N)] direction = 'right' top, bottom, left, right = 0, N-1, 0, N-1 current_number = 1 while top <= bottom and left <= right: if direction == 'right': for col in range(left, right + 1): matrix[top][col] = current_number current_number += 1 top += 1 direction = 'down' elif direction == 'down': for row in range(top, bottom + 1): matrix[row][right] = current_number current_number += 1 right -= 1 direction = 'left' elif direction == 'left': for col in range(right, left - 1, -1): matrix[bottom][col] = current_number current_number += 1 bottom -= 1 direction = 'up' elif direction == 'up': for row in range(bottom, top - 1, -1): matrix[row][left] = current_number current_number += 1 left += 1 direction = 'right' return matrix"},{"question":"def has_subsequence_with_sum(S, X): Determines if there exists a continuous subsequence within a list of positive integers S whose sum is exactly X. Parameters: S (list): A list of positive integers. X (int): The target sum. Returns: str: \\"Yes\\" if such a subsequence exists, otherwise \\"No\\". >>> has_subsequence_with_sum([1, 2, 3, 4, 5], 9) \\"Yes\\" >>> has_subsequence_with_sum([2, 4, 6], 5) \\"No\\" >>> has_subsequence_with_sum([5], 5) \\"Yes\\" >>> has_subsequence_with_sum([5], 10) \\"No\\" >>> has_subsequence_with_sum([1, 2, 3], 6) \\"Yes\\" >>> has_subsequence_with_sum([5, 1, 2, 3], 5) \\"Yes\\" >>> has_subsequence_with_sum([1, 2, 3, 4, 5], 12) \\"Yes\\" >>> has_subsequence_with_sum([1, 3, 2, 1, 4, 6, 5], 10) \\"Yes\\"","solution":"def has_subsequence_with_sum(S, X): Determines if there exists a continuous subsequence whose sum is exactly X. Parameters: S (list): A list of positive integers. X (int): The target sum. Returns: str: \\"Yes\\" if such a subsequence exists, otherwise \\"No\\". current_sum = 0 left = 0 for right in range(len(S)): current_sum += S[right] while current_sum > X and left <= right: current_sum -= S[left] left += 1 if current_sum == X: return \\"Yes\\" return \\"No\\""},{"question":"from typing import List, Tuple def track_solved_problems(Q: int, M: int, submissions: List[Tuple[int, int]]) -> List[int]: Tracks the number of problems solved after each submission. Parameters: Q (int): The number of problems in the contest. M (int): The number of submissions made by the contestants. submissions (List[Tuple[int, int]]): List of tuples representing submissions. Returns: List[int]: Number of problems solved after each submission. pass def test_all_correct_submissions(): Q = 4 M = 4 submissions = [(1, 1), (2, 1), (3, 1), (4, 1)] assert track_solved_problems(Q, M, submissions) == [1, 2, 3, 4] def test_all_incorrect_submissions(): Q = 4 M = 4 submissions = [(1, 0), (2, 0), (3, 0), (4, 0)] assert track_solved_problems(Q, M, submissions) == [0, 0, 0, 0] def test_mixed_submissions(): Q = 3 M = 5 submissions = [(1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] assert track_solved_problems(Q, M, submissions) == [1, 1, 2, 2, 3] def test_repeated_correct_submissions(): Q = 2 M = 4 submissions = [(1, 1), (1, 1), (2, 1), (2, 1)] assert track_solved_problems(Q, M, submissions) == [1, 1, 2, 2] def test_redundant_incorrect_submissions(): Q = 2 M = 4 submissions = [(1, 0), (1, 1), (2, 0), (2, 1)] assert track_solved_problems(Q, M, submissions) == [0, 1, 1, 2]","solution":"def track_solved_problems(Q, M, submissions): Tracks the number of problems solved after each submission. Parameters: Q (int): The number of problems in the contest. M (int): The number of submissions made by the contestants. submissions (List[Tuple[int, int]]): List of tuples representing submissions. Returns: List[int]: Number of problems solved after each submission. problems_solved = set() solved_counts = [] for p, status in submissions: if status == 1: problems_solved.add(p) solved_counts.append(len(problems_solved)) return solved_counts # Example function call Q = 4 M = 6 submissions = [(1, 1), (2, 0), (2, 1), (3, 1), (4, 1), (4, 0)] print(track_solved_problems(Q, M, submissions)) # Output: [1, 1, 2, 3, 4, 4]"},{"question":"def process_queries(n: int, edges: List[Tuple[int, int]], queries: List[str]) -> List[int]: Handle cut and find queries on a tree with n nodes and n-1 edges. >>> process_queries(5, [(1, 2), (1, 3), (3, 4), (3, 5)], [\\"cut 3 4\\", \\"find 4\\", \\"find 3\\"]) [4, 1] >>> process_queries(4, [(1, 2), (2, 3), (3, 4)], [\\"cut 2 3\\", \\"find 1\\", \\"find 4\\"]) [1, 3]","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size self.smallest = list(range(size)) # keeps the smallest element in the component def find(self, p): if self.parent[p] != p: root = self.find(self.parent[p]) self.parent[p] = root self.smallest[p] = self.smallest[root] return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP self.smallest[rootP] = min(self.smallest[rootP], self.smallest[rootQ]) elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ self.smallest[rootQ] = min(self.smallest[rootP], self.smallest[rootQ]) else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.smallest[rootP] = min(self.smallest[rootP], self.smallest[rootQ]) def get_smallest(self, p): return self.smallest[self.find(p)] def process_queries(n, edges, queries): uf = UnionFind(n + 1) remaining_edges = {frozenset(edge) for edge in edges} # Perform initial unions for edge in edges: uf.union(edge[0], edge[1]) results = [] for query in queries: parts = query.split() if parts[0] == \\"cut\\": x, y = int(parts[1]), int(parts[2]) remaining_edges.remove(frozenset([x, y])) uf = UnionFind(n + 1) for edge in remaining_edges: uf.union(list(edge)[0], list(edge)[1]) elif parts[0] == \\"find\\": x = int(parts[1]) results.append(uf.get_smallest(x)) return results"},{"question":"def min_operations(s1: str, s2: str) -> int: Calculate the minimum number of operations required to transform string s1 into string s2. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"abc\\", \\"\\") 3 >>> min_operations(\\"\\", \\"\\") 0 >>> min_operations(\\"abc\\", \\"abc\\") 0 >>> min_operations(\\"a\\", \\"ab\\") 1 >>> min_operations(\\"ab\\", \\"a\\") 1 >>> min_operations(\\"a\\", \\"b\\") 1","solution":"def min_operations(s1, s2): Calculate the minimum number of operations required to transform string s1 into string s2. :param s1: str, initial string :param s2: str, target string :return: int, minimum number of operations m, n = len(s1), len(s2) # Initialize a dp array where dp[i][j] represents the minimum number of operations # required to convert s1[0..i-1] to s2[0..j-1] dp = [[0] * (n + 1) for _ in range(m + 1)] # If the first string is empty, the only option is to insert all characters of the second string for j in range(1, n + 1): dp[0][j] = j # If the second string is empty, the only option is to remove all characters of the first string for i in range(1, m + 1): dp[i][0] = i # Fill dp array for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: # If the characters are the same, no new operation is needed dp[i][j] = dp[i - 1][j - 1] else: # If the characters are different, consider all three operations dp[i][j] = min(dp[i - 1][j] + 1, # Remove dp[i][j - 1] + 1, # Add dp[i - 1][j - 1] + 1 # Replace ) # The bottom-right corner will contain the answer return dp[m][n]"},{"question":"def max_profit(prices): Returns the maximum profit that can be made by buying and then selling one item across the given days. Parameters: prices (List[int]): A list of integers where each integer represents the price of the item on that day. Returns: int: The maximum profit achievable. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Returns the maximum profit that can be made by buying and then selling one item across given days. if len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit"},{"question":"def count_max_subset(N: int, collection: List[int]) -> int: Given a collection of N objects, return the number of distinct subsequences that maximize the sum of the objects. >>> count_max_subset(3, [5, 1, 5]) 3 >>> count_max_subset(4, [3, 3, 2, 1]) 3 pass def number_of_max_subsequences(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Given T test cases, each consisting of a tuple with: - (N, K) : the size of the collection and the maximum possible value of an object respectively - A list of integers representing the objects in the collection Return a list of results, each representing the number of distinct subsequences that maximize the sum of the objects for each corresponding test case. >>> number_of_max_subsequences(2, [((3, 5), [5, 1, 5]), ((4, 3), [3, 3, 2, 1])]) [3, 3] pass","solution":"def count_max_subset(N, collection): Given a collection of N objects, return the number of distinct subsequences that maximize the sum of the objects. max_element = max(collection) max_count = collection.count(max_element) # Calculate number of non-empty subsequences with the maximum element return (2 ** max_count) - 1 def number_of_max_subsequences(T, test_cases): results = [] for case in test_cases: N, K = case[0] collection = case[1] results.append(count_max_subset(N, collection)) return results"},{"question":"from typing import List def max_subarray_sum(n: int, sequence: List[int]) -> int: Finds the maximum sum of any contiguous subarray within the sequence. Parameters: n (int): The number of elements in the sequence. sequence (List[int]): The sequence of integers. Returns: int: The maximum sum of any contiguous subarray. Examples: >>> max_subarray_sum(8, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum(1, [-1]) -1","solution":"def max_subarray_sum(n, sequence): Finds the maximum sum of any contiguous subarray within the sequence using Kadane's Algorithm. if n == 0: return 0 # Initialize current max and global max with the first element current_max = global_max = sequence[0] # Traverse through the sequence starting from the second element for i in range(1, n): current_max = max(sequence[i], current_max + sequence[i]) if current_max > global_max: global_max = current_max return global_max"},{"question":"def minimum_bonus_amount(test_cases): Calculate the minimum bonus amount per unit of rating. Args: test_cases (List[Tuple[int, List[int]]]): List of test cases where each test case is a tuple containing number of employees and their ratings. Returns: List[int]: List of minimum bonus amounts for each test case. >>> minimum_bonus_amount([(3, [1, 2, 3]), (4, [2, 3, 5, 7]), (5, [4, 4, 4, 4, 4])]) [1, 1, 1] results = [] for case in test_cases: N, ratings = case # Placeholder for actual implementation return results def parse_input_output(input_string): Parse input string and format output string according to the expected input/output format. Args: input_string (str): Input string in specified format Returns: str: Output string in specified format >>> parse_input_output(\\"3n3n1 2 3n4n2 3 5 7n5n4 4 4 4 4\\") '1n1n1' input_lines = input_string.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) ratings = list(map(int, input_lines[index+1].strip().split())) test_cases.append((N, ratings)) index += 2 results = minimum_bonus_amount(test_cases) output_string = \\"n\\".join(map(str, results)) return output_string def test_parse_input_output(): input_data = 3 3 1 2 3 4 2 3 5 7 5 4 4 4 4 4 expected_output = 1 1 1 assert parse_input_output(input_data) == expected_output input_data = 1 2 5 10 expected_output = 1 assert parse_input_output(input_data) == expected_output input_data = 2 1 1000 3 10 10 10 expected_output = 1 1 assert parse_input_output(input_data) == expected_output","solution":"def minimum_bonus_amount(test_cases): results = [] for case in test_cases: N, ratings = case # Since we need the minimum payout per rating unit, we can always assume it to be 1 results.append(1) return results # Parsing input and formatting output according to the expected input/output format def parse_input_output(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) ratings = list(map(int, input_lines[index+1].strip().split())) test_cases.append((N, ratings)) index += 2 results = minimum_bonus_amount(test_cases) output_string = \\"n\\".join(map(str, results)) return output_string"},{"question":"def largest_number_with_max_ones(N: int) -> int: Returns the largest number less than or equal to N that has the maximum number of 1s in its binary representation. >>> largest_number_with_max_ones(5) 3 >>> largest_number_with_max_ones(10) 7 pass # Unit Tests from solution import largest_number_with_max_ones def test_example_case(): assert largest_number_with_max_ones(5) == 3 def test_small_numbers(): assert largest_number_with_max_ones(1) == 1 assert largest_number_with_max_ones(2) == 1 assert largest_number_with_max_ones(3) == 3 assert largest_number_with_max_ones(4) == 3 def test_larger_numbers(): assert largest_number_with_max_ones(10) == 7 # Binary of 7 is 111 assert largest_number_with_max_ones(15) == 15 # Binary of 15 is 1111 assert largest_number_with_max_ones(25) == 15 # Binary of 15 is 1111 def test_edge_cases(): assert largest_number_with_max_ones(10000) == 8191 # Binary of 8191 is 1111111111111 assert largest_number_with_max_ones(1023) == 1023 # Binary of 1023 is 1111111111 assert largest_number_with_max_ones(512) == 511 # Binary of 511 is 111111111","solution":"def largest_number_with_max_ones(N): Returns the largest number less than or equal to N that has the maximum number of 1s in its binary representation. def count_ones(x): # Helper function to count the number of 1s in the binary representation of x return bin(x).count('1') max_ones = 0 result = 0 for i in range(N + 1): current_ones = count_ones(i) if current_ones > max_ones: max_ones = current_ones result = i return result"},{"question":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index, value): pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def query(self, l, r): result = 0 l += self.n r += self.n while l <= r: if l % 2 == 1: result += self.tree[l] l += 1 if r % 2 == 0: result += self.tree[r] r -= 1 l //= 2 r //= 2 return result def process_commands(n, array, q, commands): Process a sequence of commands and return the results of the query commands. Parameters: n (int): Number of elements in the array. array (List[int]): The initial array of integers. q (int): Number of commands. commands (List[str]): List of commands to process. Returns: List[int]: Results of the query commands. >>> process_commands(5, [1, 2, 3, 4, 5], 3, [\\"Q 1 3\\", \\"U 2 10\\", \\"Q 1 3\\"]) [6, 14] >>> process_commands(3, [7, 8, 9], 1, [\\"Q 2 3\\"]) [17]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Initialize the tree with base values for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index, value): pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def query(self, l, r): result = 0 l += self.n r += self.n while l <= r: if l % 2 == 1: result += self.tree[l] l += 1 if r % 2 == 0: result += self.tree[r] r -= 1 l //= 2 r //= 2 return result def process_commands(n, array, q, commands): # Create Segment Tree from data array segment_tree = SegmentTree(array) results = [] for command in commands: parts = command.split() if parts[0] == 'Q': l = int(parts[1]) - 1 r = int(parts[2]) - 1 results.append(segment_tree.query(l, r)) elif parts[0] == 'U': i = int(parts[1]) - 1 x = int(parts[2]) segment_tree.update(i, x) return results"},{"question":"def calculate_engagement_rate(n, posts): Calculate the engagement rate for each post. :param n: Number of posts :param posts: List of tuples, each containing three integers (likes, comments, shares) :return: List of engagement rates for each post with two decimal precision >>> calculate_engagement_rate(3, [(10, 5, 0), (0, 0, 0), (1, 2, 1)]) ['1.00', '0.00', '1.00'] >>> calculate_engagement_rate(2, [(0, 0, 0), (0, 0, 0)]) ['0.00', '0.00'] >>> calculate_engagement_rate(1, [(5, 3, 2)]) ['1.00'] pass","solution":"def calculate_engagement_rate(n, posts): Calculate the engagement rate for each post. :param n: Number of posts :param posts: List of tuples, each containing three integers (likes, comments, shares) :return: List of engagement rates for each post with two decimal precision engagement_rates = [] for post in posts: li, ci, si = post total_interactions = li + ci + si if total_interactions == 0: engagement_rate = 0.00 else: engagement_rate = total_interactions / total_interactions engagement_rates.append(f\\"{engagement_rate:.2f}\\") return engagement_rates # Example usage: # n = 3 # posts = [(10, 5, 0), (0, 0, 0), (1, 2, 1)] # print(calculate_engagement_rate(n, posts)) => ['1.00', '0.00', '1.00']"},{"question":"def min_subset_sum_difference(n: int, arr: List[int]) -> int: Given an integer array \`arr\` of size \`n\`, partition the array into two subsets such that the sum of elements in both subsets is nearly equal. The absolute difference between the sums of subsets should be minimized. Return the minimum possible difference. >>> min_subset_sum_difference(4, [1, 6, 11, 5]) 1 >>> min_subset_sum_difference(3, [2, 3, 5]) 0","solution":"def min_subset_sum_difference(n, arr): total_sum = sum(arr) dp = [[False] * (total_sum + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True # Sum 0 can be achieved with any number of elements by taking no element for i in range(1, n + 1): for j in range(1, total_sum + 1): if arr[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] else: dp[i][j] = dp[i-1][j] min_diff = total_sum for s1 in range(total_sum // 2 + 1): if dp[n][s1]: s2 = total_sum - s1 min_diff = min(min_diff, abs(s2 - s1)) return min_diff # Helper function to read input and call the solution def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) arr = list(map(int, data[1:])) result = min_subset_sum_difference(n, arr) print(result)"},{"question":"def smallest_cyclic_shift(binary_string: str) -> str: Returns the smallest binary string that can be obtained from any cyclic shift of the input binary string. >>> smallest_cyclic_shift(\\"11001\\") \\"00111\\" >>> smallest_cyclic_shift(\\"101010\\") \\"010101\\" # Unit tests def test_cyclic_shift_example1(): assert smallest_cyclic_shift(\\"11001\\") == \\"00111\\" def test_cyclic_shift_example2(): assert smallest_cyclic_shift(\\"101010\\") == \\"010101\\" def test_single_char(): assert smallest_cyclic_shift(\\"0\\") == \\"0\\" assert smallest_cyclic_shift(\\"1\\") == \\"1\\" def test_alternating_characters(): assert smallest_cyclic_shift(\\"0101\\") == \\"0101\\" assert smallest_cyclic_shift(\\"1010\\") == \\"0101\\" def test_same_characters(): assert smallest_cyclic_shift(\\"111\\") == \\"111\\" assert smallest_cyclic_shift(\\"0000\\") == \\"0000\\" def test_rotation(): assert smallest_cyclic_shift(\\"1001\\") == \\"0011\\" assert smallest_cyclic_shift(\\"0110\\") == \\"0011\\"","solution":"def smallest_cyclic_shift(binary_string): Returns the smallest binary string that can be obtained from any cyclic shift of the input binary string. n = len(binary_string) extended_string = binary_string + binary_string smallest_shift = binary_string for i in range(1, n): current_shift = extended_string[i:i+n] if current_shift < smallest_shift: smallest_shift = current_shift return smallest_shift"},{"question":"def process_commands(commands): Process a sequence of library commands and return the results. Parameters: commands (List[str]): A list of commands as strings. Each command has the format: 'ADD <book_title> <count>', 'BORROW <book_title>', or 'RETURN <book_title>'. Returns: List[str]: A list of results for 'BORROW' and 'RETURN' commands. Possible results are: 'Borrow successful', 'Return successful', 'Book not available', and 'All copies are already in the library'. >>> process_commands([\\"ADD HarryPotter 5\\", \\"BORROW HarryPotter\\", \\"BORROW HarryPotter\\"]) ['Borrow successful', 'Borrow successful'] >>> process_commands([\\"ADD HarryPotter 3\\", \\"BORROW HarryPotter\\", \\"RETURN HarryPotter\\", \\"RETURN HarryPotter\\"]) ['Borrow successful', 'Return successful', 'All copies are already in the library'] >>> process_commands([\\"ADD HarryPotter 1\\", \\"BORROW HarryPotter\\", \\"BORROW HarryPotter\\"]) ['Borrow successful', 'Book not available'] >>> process_commands([\\"BORROW HarryPotter\\"]) ['Book not available'] >>> process_commands([\\"ADD HarryPotter 2\\", \\"RETURN HarryPotter\\", \\"BORROW HarryPotter\\", \\"RETURN HarryPotter\\", \\"RETURN HarryPotter\\"]) ['All copies are already in the library', 'Borrow successful', 'Return successful', 'All copies are already in the library']","solution":"class Library: def __init__(self): self.inventory = {} self.borrowed = {} def add_book(self, book_title, count): if book_title in self.inventory: self.inventory[book_title] += count else: self.inventory[book_title] = count if book_title not in self.borrowed: self.borrowed[book_title] = 0 def borrow_book(self, book_title): if book_title in self.inventory and self.inventory[book_title] > self.borrowed[book_title]: self.borrowed[book_title] += 1 return \\"Borrow successful\\" else: return \\"Book not available\\" def return_book(self, book_title): if book_title in self.borrowed and self.borrowed[book_title] > 0: self.borrowed[book_title] -= 1 return \\"Return successful\\" else: return \\"All copies are already in the library\\" def process_commands(commands): library = Library() results = [] for command in commands: parts = command.split() action = parts[0] book_title = parts[1] if action == \\"ADD\\": count = int(parts[2]) library.add_book(book_title, count) elif action == \\"BORROW\\": result = library.borrow_book(book_title) results.append(result) elif action == \\"RETURN\\": result = library.return_book(book_title) results.append(result) return results"},{"question":"def most_active_user(activities: List[Tuple[str, int]]) -> str: Given a list of activities represented by tuples of (userID, timestamp), this function returns the userID of the most active user. If multiple users have the same number of activities, it returns the one with the smallest lexicographical userID. >>> most_active_user([(\\"alice\\", 1609459200)]) 'alice' >>> most_active_user([(\\"alice\\", 1609459200), (\\"alice\\", 1609459250), (\\"alice\\", 1609459300)]) 'alice' >>> most_active_user([(\\"alice\\", 1609459200), (\\"bob\\", 1609459250), (\\"charlie\\", 1609459300)]) 'alice' >>> most_active_user([(\\"alice\\", 1609459200), (\\"bob\\", 1609459250), (\\"alice\\", 1609459300), (\\"charlie\\", 1609459350), (\\"bob\\", 1609459400), (\\"alice\\", 1609459450)]) 'alice' >>> most_active_user([(\\"alice\\", 1609459200), (\\"bob\\", 1609459250), (\\"alice\\", 1609459300), (\\"bob\\", 1609459350)]) 'alice' >>> most_active_user([]) None >>> most_active_user([(\\"bob\\", 1609459200), (\\"alice\\", 1609459250), (\\"bob\\", 1609459300), (\\"alice\\", 1609459350)]) 'alice'","solution":"from typing import List, Tuple def most_active_user(activities: List[Tuple[str, int]]) -> str: Given a list of activities represented by tuples of (userID, timestamp), this function returns the userID of the most active user. If multiple users have the same number of activities, it returns the one with the smallest lexicographical userID. from collections import defaultdict # Dictionary to count activities per user user_activity_count = defaultdict(int) # Count activities for each user for user_id, _ in activities: user_activity_count[user_id] += 1 # Find the user with maximum activities or smallest lexicographical order if tied most_active = None max_activities = 0 for user_id, count in user_activity_count.items(): if count > max_activities or (count == max_activities and user_id < most_active): most_active = user_id max_activities = count return most_active"},{"question":"def can_john_guarantee_win(n: int, array: List[int]) -> str: Determine if John can guarantee a win in the Balanced Array game. Parameters: n (int): Size of the array. array (list of int): Array of integers. Returns: str: \\"YES\\" if John can guarantee a win, \\"NO\\" otherwise. >>> can_john_guarantee_win(3, [1, 3, 5]) \\"NO\\" >>> can_john_guarantee_win(4, [2, 2, 2, 2]) \\"YES\\" pass # Test cases from solution import can_john_guarantee_win def test_can_john_guarantee_win_odd_count(): assert can_john_guarantee_win(3, [1, 3, 5]) == \\"NO\\" assert can_john_guarantee_win(4, [1, 2, 2, 4]) == \\"NO\\" def test_can_john_guarantee_win_even_count(): assert can_john_guarantee_win(4, [2, 2, 2, 2]) == \\"YES\\" assert can_john_guarantee_win(4, [2, 2, 4, 4]) == \\"YES\\" def test_can_john_guarantee_win_single_element(): assert can_john_guarantee_win(1, [1]) == \\"NO\\" assert can_john_guarantee_win(1, [2]) == \\"YES\\" def test_can_john_guarantee_win_varied_elements(): assert can_john_guarantee_win(5, [1, 2, 3, 4, 5]) == \\"NO\\" assert can_john_guarantee_win(6, [2, 3, 5, 7, 11, 13]) == \\"NO\\" assert can_john_guarantee_win(6, [1, 2, 2, 3, 4, 5]) == \\"NO\\"","solution":"def can_john_guarantee_win(n, array): Determine if John can guarantee a win in the Balanced Array game. Parameters: n (int): Size of the array. array (list of int): Array of integers. Returns: str: \\"YES\\" if John can guarantee a win, \\"NO\\" otherwise. # Count the number of odd integers in the array odd_count = sum(1 for x in array if x % 2 != 0) # John can guarantee a win if there are an even number of odd integers return \\"YES\\" if odd_count % 2 == 0 else \\"NO\\""},{"question":"def count_isolated_groups(n: int, friendships: List[Tuple[int, int]]) -> int: Count the number of isolated groups (connected components) in the company. >>> count_isolated_groups(5, [(1, 2), (2, 3), (4, 5)]) 2 >>> count_isolated_groups(6, [(1, 2), (3, 4), (5, 6)]) 3 from solution import count_isolated_groups def test_count_isolated_groups(): assert count_isolated_groups(5, [(1, 2), (2, 3), (4, 5)]) == 2 assert count_isolated_groups(6, [(1, 2), (3, 4), (5, 6)]) == 3 assert count_isolated_groups(4, [(1, 2), (2, 3), (3, 4)]) == 1 assert count_isolated_groups(4, [(1, 2), (3, 4)]) == 2 assert count_isolated_groups(4, []) == 4 assert count_isolated_groups(1, []) == 1 assert count_isolated_groups(2, [(1, 2)]) == 1 assert count_isolated_groups(2, []) == 2 assert count_isolated_groups(3, [(1, 2)]) == 2 assert count_isolated_groups(3, [(1, 2), (2, 3)]) == 1 assert count_isolated_groups(5, [(1, 2), (3, 4), (4, 5)]) == 2","solution":"def count_isolated_groups(n, friendships): from collections import defaultdict, deque def bfs(node): queue = deque([node]) visited.add(node) while queue: u = queue.popleft() for v in graph[u]: if v not in visited: visited.add(v) queue.append(v) graph = defaultdict(list) for u, v in friendships: graph[u].append(v) graph[v].append(u) visited = set() isolated_count = 0 for i in range(1, n + 1): if i not in visited: bfs(i) isolated_count += 1 return isolated_count if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) friendships = [] for i in range(M): u = int(data[2 + 2*i]) v = int(data[3 + 2*i]) friendships.append((u, v)) print(count_isolated_groups(N, friendships))"},{"question":"def max_fulfilled_orders(M, Q, item_categories, R, orders): Calculate the maximum number of order requests that can be fully or partially fulfilled. Parameters: M (int): The number of items in the inventory. Q (int): The number of different product categories. item_categories (List[int]): List of integers where each integer represents the product category of an item. R (int): The number of order requests. orders (List[Tuple[int, int]]): List of tuples where each tuple contains a product category and the quantity demanded for that order request. Returns: int: Maximum number of order requests that can be fully or partially fulfilled. Example: >>> max_fulfilled_orders(10, 3, [1, 2, 1, 3, 2, 1, 3, 2, 1, 1], 4, [(1, 3), (2, 2), (3, 1), (1, 5)]) 4 >>> max_fulfilled_orders(10, 3, [1, 2, 1, 3, 2, 1, 2, 3, 1, 1], 3, [(1, 6), (2, 4), (3, 1)]) 3","solution":"def max_fulfilled_orders(M, Q, item_categories, R, orders): from collections import Counter # Count the inventory per category inventory = Counter(item_categories) fulfilled_orders = 0 for category, quantity in orders: available = inventory[category] if available > 0: fulfilled_orders += 1 if available >= quantity: inventory[category] -= quantity else: inventory[category] = 0 return fulfilled_orders"},{"question":"def calculate_prices(N, Q, prices, events, queries): Calculate and print the price of specific product after each event. >>> calculate_prices(5, 3, [100, 200, 300, 400, 500], [(1, 3, 50), (2, 5, -100), (3, 3, 75)], [1, 4]) [150, 300] >>> calculate_prices(4, 2, [150, 250, 350, 450], [(1, 2, 100), (3, 4, -50)], [2, 4]) [350, 400] >>> calculate_prices(3, 1, [500, 750, 1000], [(1, 3, 100)], [1, 2, 3]) [600, 850, 1100] >>> calculate_prices(6, 2, [10, 20, 30, 40, 50, 60], [(2, 4, 10), (3, 5, -5)], [1, 5, 6]) [10, 45, 60] >>> calculate_prices(2, 1, [1000, 2000], [(1, 2, -500)], [1, 2]) [500, 1500]","solution":"def calculate_prices(N, Q, prices, events, queries): # Apply all events once delta = [0] * (N + 1) for L, R, X in events: delta[L - 1] += X if R < N: delta[R] -= X # Calculate the final prices for i in range(1, N): delta[i] += delta[i - 1] final_prices = [prices[i] + delta[i] for i in range(N)] # Return the prices for the queried products return [final_prices[K - 1] for K in queries]"},{"question":"def max_items(prices, amount): Returns the maximum number of items that can be purchased without exceeding the specified amount. :param prices: list of integers representing item prices. :param amount: integer representing the total amount of money available. :return: integer, maximum number of items that can be bought. >>> max_items([1, 12, 5, 111, 200, 1000, 10], 50) 4 >>> max_items([20, 10, 5, 30, 70], 35) 3 >>> max_items([1, 2, 3, 4], 100) 4 def process_test_cases(test_cases): Processes multiple test cases and returns results for each. :param test_cases: list of tuples, each containing (n, k, prices) for a test case. :return: list of integers, each representing the maximum number of items for a test case. >>> process_test_cases([(7, 50, [1, 12, 5, 111, 200, 1000, 10]), ... (5, 35, [20, 10, 5, 30, 70]), ... (4, 100, [1, 2, 3, 4])]) [4, 3, 4]","solution":"def max_items(prices, amount): Returns the maximum number of items that can be purchased without exceeding the specified amount. :param prices: list of integers representing item prices. :param amount: integer representing the total amount of money available. :return: integer, maximum number of items that can be bought. # Sort the prices in ascending order prices.sort() count = 0 total_spent = 0 for price in prices: if total_spent + price <= amount: total_spent += price count += 1 else: break return count def process_test_cases(test_cases): Processes multiple test cases and returns results for each. :param test_cases: list of tuples, each containing (n, k, prices) for a test case. :return: list of integers, each representing the maximum number of items for a test case. results = [] for n, k, prices in test_cases: results.append(max_items(prices, k)) return results"},{"question":"def process_queries(n: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Processes the queries to find the sum of subarrays defined by the given queries. >>> process_queries(5, [1, 2, 3, 4, 5], [(1, 3), (2, 5), (1, 5)]) [6, 14, 15] >>> process_queries(1, [10], [(1, 1)]) [10] >>> process_queries(5, [5, 5, 5, 5, 5], [(1, 5), (2, 4), (3, 3)]) [25, 15, 5] >>> process_queries(10, list(range(1, 11)), [(1, 10), (1, 5), (6, 10)]) [55, 15, 40] >>> process_queries(5, [1000, 1000, 1000, 1000, 1000], [(1, 2), (3, 5), (1, 5)]) [2000, 3000, 5000]","solution":"def compute_prefix_sums(arr): Computes the prefix sums of the given array. n = len(arr) prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + arr[i - 1] return prefix_sums def range_sum(prefix_sums, l, r): Computes the sum of the subarray from index l to r using the prefix sums array. return prefix_sums[r] - prefix_sums[l - 1] def process_queries(n, arr, queries): Processes the queries to find the sum of subarrays defined by the given queries. prefix_sums = compute_prefix_sums(arr) results = [] for l, r in queries: results.append(range_sum(prefix_sums, l, r)) return results"},{"question":"def sum_of_elements_greater_than_k(n: int, k: int, arr: List[int]) -> int: Returns the sum of all elements in the array that are greater than k. >>> sum_of_elements_greater_than_k(6, 3, [1, 4, 2, 7, 5, 3]) == 16 >>> sum_of_elements_greater_than_k(4, -1, [-2, -1, 0, 1]) == 1 >>> sum_of_elements_greater_than_k(5, 0, [0, 0, 0, 0, 0]) == 0 >>> sum_of_elements_greater_than_k(3, 10, [20, 30, 40]) == 90 >>> sum_of_elements_greater_than_k(5, 5, [5, 4, 6, 7, 5]) == 13 >>> sum_of_elements_greater_than_k(3, -10**9, [-10**9, 10**9, 0]) == 10**9","solution":"def sum_of_elements_greater_than_k(n, k, arr): Returns the sum of all elements in the array that are greater than k. return sum(x for x in arr if x > k)"},{"question":"def flatten_dict(d, parent_key='', sep='_'): Flattens a nested dictionary into a single depth dictionary. Args: d (dict): The dictionary to flatten parent_key (str): The base key string (for recursion) sep (str): The separator between parent and child keys Returns: dict: The flattened dictionary Example: >>> flatten_dict({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3, \\"f\\": 4}}}) {'a': 1, 'b_c': 2, 'b_d_e': 3, 'b_d_f': 4} >>> flatten_dict({}) {}","solution":"def flatten_dict(d, parent_key='', sep='_'): Flattens a nested dictionary into a single depth dictionary. Args: d (dict): The dictionary to flatten parent_key (str): The base key string (for recursion) sep (str): The separator between parent and child keys Returns: dict: The flattened dictionary items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def longest_green_segment(n, lights): Returns the length of the longest segment of consecutive green lights. :param n: Integer, the number of traffic lights. :param lights: List of integers (0 or 1), representing the state of each traffic light. :return: Integer, length of the longest segment of consecutive green lights. >>> longest_green_segment(10, [1, 1, 0, 1, 1, 1, 0, 0, 1, 1]) 3 >>> longest_green_segment(5, [0, 0, 0, 0, 0]) 0","solution":"def longest_green_segment(n, lights): Returns the length of the longest segment of consecutive green lights. :param n: Integer, the number of traffic lights. :param lights: List of integers (0 or 1), representing the state of each traffic light. :return: Integer, length of the longest segment of consecutive green lights. max_length = 0 current_length = 0 for light in lights: if light == 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"from typing import List def calculate_anagram_pairs(n: int, passwords: List[str]) -> int: Returns the number of pairs of passwords that are case-insensitive anagrams of each other. >>> calculate_anagram_pairs(4, [\\"abc\\", \\"Bac\\", \\"adb\\", \\"BAD\\"]) 2 >>> calculate_anagram_pairs(3, [\\"a\\", \\"A\\", \\"a\\"]) 3 >>> calculate_anagram_pairs(3, [\\"abc\\", \\"def\\", \\"ghi\\"]) 0 >>> calculate_anagram_pairs(5, [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"]) 0 >>> calculate_anagram_pairs(6, [\\"abc\\", \\"Bac\\", \\"cab\\", \\"CBA\\", \\"ACB\\", \\"bac\\"]) 15","solution":"from collections import defaultdict def count_anagram_pairs(passwords): Returns the number of pairs of passwords that are case-insensitive anagrams of each other. counter = defaultdict(int) for password in passwords: sorted_password = ''.join(sorted(password.lower())) counter[sorted_password] += 1 pair_count = 0 for count in counter.values(): pair_count += count * (count - 1) // 2 return pair_count def calculate_anagram_pairs(n, passwords): return count_anagram_pairs(passwords)"},{"question":"from typing import List, Tuple def floyd_warshall(n: int, distances: List[Tuple[int, int, int]]) -> List[List[int]]: Perform the Floyd-Warshall algorithm to find shortest paths between all pairs of nodes. pass def min_travel_time(n: int, m: int, edges: List[Tuple[int, int, int]], q: int, queries: List[Tuple[int, int]]) -> List[int]: Determine the minimum travel time between pairs of stations in a subway system. Args: n (int): The number of stations. m (int): The number of subway lines. edges (List[Tuple[int, int, int]]): The list of subway lines defined by tuples of (u, v, w) where u and v are the stations and w is the travel time. q (int): The number of queries. queries (List[Tuple[int, int]]): The list of queries defined by tuples of (a, b) where a and b are the stations between which the travel time is to be calculated. Returns: List[int]: The list of minimum travel times for each query. If a path is not possible, return -1. pass def test_min_travel_time(): n, m = 4, 3 edges = [ (1, 2, 4), (2, 3, 1), (3, 4, 2) ] q = 3 queries = [ (1, 4), (1, 3), (2, 1) ] expected = [7, 5, 4] assert min_travel_time(n, m, edges, q, queries) == expected def test_min_travel_time_disconnected(): n, m = 4, 1 edges = [ (1, 2, 4) ] q = 2 queries = [ (1, 3), (3, 4) ] expected = [-1, -1] assert min_travel_time(n, m, edges, q, queries) == expected def test_min_travel_time_single_edge(): n, m = 2, 1 edges = [ (1, 2, 5) ] q = 1 queries = [ (1, 2) ] expected = [5] assert min_travel_time(n, m, edges, q, queries) == expected def test_min_travel_time_self_path(): n, m = 3, 3 edges = [ (1, 2, 3), (2, 3, 4), (3, 1, 5) ] q = 1 queries = [ (1, 1) ] expected = [0] assert min_travel_time(n, m, edges, q, queries) == expected def test_min_travel_time_large_case(): n, m = 5, 5 edges = [ (1, 2, 10), (2, 3, 20), (3, 4, 30), (4, 5, 40), (1, 5, 100) ] q = 3 queries = [ (1, 5), (2, 4), (5, 3) ] expected = [100, 50, 70] assert min_travel_time(n, m, edges, q, queries) == expected","solution":"def floyd_warshall(n, distances): # Initialize the distance matrix with infinity inf = float('inf') dist = [[inf] * (n + 1) for _ in range(n + 1)] # Distance from a node to itself is 0 for i in range(1, n + 1): dist[i][i] = 0 # Fill initial distances based on input for u, v, w in distances: dist[u][v] = w dist[v][u] = w # Floyd-Warshall algorithm for k in range(1, n + 1): for i in range(1, n + 1): for j in range(1, n + 1): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist def min_travel_time(n, m, edges, q, queries): # Compute all pairs shortest path dist = floyd_warshall(n, edges) results = [] for a, b in queries: if dist[a][b] == float('inf'): results.append(-1) else: results.append(dist[a][b]) return results"},{"question":"[Completion Task in Python] from typing import List def max_path_sum(grid: List[List[int]]) -> int: Write a function that takes a 2D list of integers representing a grid and returns the maximum sum of values from the grid following these rules: - You start at any cell in the first row. - You can move to the cell directly below or to the cell diagonally below left or right. - Your goal is to reach any cell in the last row following these movement rules and maximize the sum of the values along your path. >>> max_path_sum([ ... [5, 3, 2, 4], ... [4, 7, 1, 2], ... [2, 3, 8, 1], ... [6, 1, 1, 5] ... ]) 25 >>> max_path_sum([[5, 3, 4]]) 5 >>> max_path_sum([[5], [9], [2], [7]]) 23 >>> max_path_sum([ ... [2, 1, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 18 >>> max_path_sum([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 3 >>> max_path_sum([ ... [1000, 1000, 1000], ... [1000, 1000, 1000] ... ]) 2000 >>> max_path_sum([[1 for _ in range(50)] for _ in range(50)]) 50","solution":"from typing import List def max_path_sum(grid: List[List[int]]) -> int: Returns the maximum sum of values following the path rules if not grid or not grid[0]: return 0 # Dimensions of the grid m, n = len(grid), len(grid[0]) # Create a DP table to store the maximum path sum up to each cell dp = [[0] * n for _ in range(m)] # Initialize the first row of DP table for j in range(n): dp[0][j] = grid[0][j] # Fill the DP table for i in range(1, m): for j in range(n): # Maximum of moving from directly above, diagonally left above, or diagonally right above max_from_above = dp[i-1][j] if j > 0: max_from_above = max(max_from_above, dp[i-1][j-1]) if j < n-1: max_from_above = max(max_from_above, dp[i-1][j+1]) dp[i][j] = grid[i][j] + max_from_above # The maximum sum will be the maximum value in the last row of the DP table return max(dp[m-1])"},{"question":"def find_shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Find the smallest weight of a path from node \`1\` to node \`n\` in an undirected graph. Args: n (int): Number of nodes in the graph. m (int): Number of edges in the graph. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented as a tuple (u, v, w). Returns: int: The smallest weight of a path from node \`1\` to node \`n\`. If no such path exists, return \`-1\`. >>> find_shortest_path(4, 4, [(1, 2, 5), (2, 3, 10), (1, 3, 20), (3, 4, 1)]) 16 >>> find_shortest_path(3, 3, [(1, 2, 1), (2, 3, 2), (3, 1, 4)]) 3 >>> find_shortest_path(4, 2, [(1, 2, 5), (3, 4, 1)]) -1 >>> find_shortest_path(1, 0, []) 0 >>> find_shortest_path(1000, 999, [(i, i+1, 1) for i in range(1, 1000)]) 999","solution":"import heapq def dijkstra(n, edges): def build_graph(n, edges): graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) return graph graph = build_graph(n, edges) pq = [(0, 1)] # (distance, node) dist = {i: float('inf') for i in range(1, n+1)} dist[1] = 0 visited = set() while pq: current_dist, node = heapq.heappop(pq) if node in visited: continue visited.add(node) for neighbor, weight in graph[node]: if neighbor not in visited: new_dist = current_dist + weight if new_dist < dist[neighbor]: dist[neighbor] = new_dist heapq.heappush(pq, (new_dist, neighbor)) return dist[n] if dist[n] != float('inf') else -1 def find_shortest_path(n, m, edges): return dijkstra(n, edges)"},{"question":"def product_of_integers_except_smallest_largest(s: str) -> int: Returns the product of all integers in the comma-separated string s except the smallest and largest ones. If the input string is empty, or the removal of the smallest and largest integers would cause the string to be empty, return None. >>> product_of_integers_except_smallest_largest(\\"1,2,3,4,5\\") 24 >>> product_of_integers_except_smallest_largest(\\"-3,-2,-1,0,1,2,3\\") 0 >>> product_of_integers_except_smallest_largest(\\"0,1,2,3,4\\") 6 >>> product_of_integers_except_smallest_largest(\\"\\") None >>> product_of_integers_except_smallest_largest(\\"5\\") None >>> product_of_integers_except_smallest_largest(\\"1,2\\") None >>> product_of_integers_except_smallest_largest(\\"5,5,5,5,5\\") 125","solution":"def product_of_integers_except_smallest_largest(s): Returns the product of all integers in the comma-separated string s except the smallest and largest ones. If the input string is empty, or the removal of smallest and largest integers would cause the string to be empty, return None. if not s: return None nums = list(map(int, s.split(','))) if len(nums) <= 2: return None nums.sort() nums = nums[1:-1] product = 1 for num in nums: product *= num return product"},{"question":"def highest_product_of_three(numbers): Returns the highest product of any three numbers from the list. If the list has fewer than three integers, returns None. >>> highest_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> highest_product_of_three([1, 2]) None >>> highest_product_of_three([-10, -10, 1, 3, 2]) 300 >>> highest_product_of_three([-1, -2, -3, -4, -5]) -6 >>> highest_product_of_three([0, -1, -2, -3, 2, 3]) 18 >>> highest_product_of_three([0, 0, 0, 0, 0]) 0","solution":"def highest_product_of_three(numbers): Returns the highest product of any three numbers from the list. If the list has fewer than three integers, returns None. if len(numbers) < 3: return None numbers.sort() max1, max2, max3 = numbers[-1], numbers[-2], numbers[-3] min1, min2 = numbers[0], numbers[1] return max(max1 * max2 * max3, max1 * min1 * min2)"},{"question":"def is_palindrome(s: str) -> bool: Returns True if the given string s is a palindrome, ignoring spaces, punctuation, and capitalization. Returns False otherwise. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") == True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") == True >>> is_palindrome(\\"No lemon, no melon\\") == True >>> is_palindrome(\\"Hello world\\") == False def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring within the given string s. If there are multiple palindromic substrings of the same maximum length, returns the first one from the left. >>> longest_palindromic_substring(\\"babad\\") in (\\"bab\\", \\"aba\\") >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindromic_substring(\\"a\\") == \\"a\\" >>> longest_palindromic_substring(\\"ac\\") in (\\"a\\", \\"c\\") import pytest def test_is_palindrome(): assert is_palindrome(\\"A man, a plan, a canal, Panama!\\") == True assert is_palindrome(\\"Was it a car or a cat I saw?\\") == True assert is_palindrome(\\"No lemon, no melon\\") == True assert is_palindrome(\\"Hello world\\") == False assert is_palindrome(\\"A\\") == True assert is_palindrome(\\" \\") == True assert is_palindrome(\\"12321\\") == True assert is_palindrome(\\"12345\\") == False def test_longest_palindromic_substring(): assert longest_palindromic_substring(\\"babad\\") in (\\"bab\\", \\"aba\\") assert longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" assert longest_palindromic_substring(\\"a\\") == \\"a\\" assert longest_palindromic_substring(\\"ac\\") in (\\"a\\", \\"c\\") assert longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" assert longest_palindromic_substring(\\"abcdefgh\\") in (\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\", \\"h\\") if __name__ == \\"__main__\\": pytest.main()","solution":"import re def is_palindrome(s): Returns True if the given string s is a palindrome, ignoring spaces, punctuation, and capitalization. Returns False otherwise. cleaned_string = re.sub(r'[^A-Za-z0-9]', '', s).lower() return cleaned_string == cleaned_string[::-1] def longest_palindromic_substring(s): Returns the longest palindromic substring within the given string s. If there are multiple palindromic substrings of the same maximum length, returns the first one from the left. def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left+1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindromes (single character center) temp = expand_around_center(i, i) if len(temp) > len(longest): longest = temp # Even length palindromes (two character center) temp = expand_around_center(i, i+1) if len(temp) > len(longest): longest = temp return longest"},{"question":"def find_duplicates(library: dict) -> list: Identify duplicate photo filenames in a nested dictionary structure representing a photo library. The function takes a dictionary where keys are years and values are dictionaries of months, with lists of photo filenames. It returns a list of filenames that are duplicates across the entire library, sorted alphabetically. >>> library = { ... '2020': { ... '01': ['img1.jpg', 'img2.jpg', 'img3.jpg'], ... '02': ['img2.jpg', 'img4.jpg'], ... '03': ['img3.jpg', 'img5.jpg'] ... }, ... '2021': { ... '01': ['img6.jpg', 'img2.jpg'], ... '04': ['img1.jpg', 'img7.jpg'] ... } ... } >>> find_duplicates(library) ['img1.jpg', 'img2.jpg', 'img3.jpg'] pass from solution import find_duplicates def test_find_duplicates_no_duplicates(): library = { '2020': { '01': ['img1.jpg', 'img2.jpg'], '02': ['img3.jpg', 'img4.jpg'], '03': ['img5.jpg', 'img6.jpg'] }, '2021': { '01': ['img7.jpg', 'img8.jpg'], '04': ['img9.jpg', 'img10.jpg'] } } assert find_duplicates(library) == [] def test_find_duplicates_some_duplicates(): library = { '2020': { '01': ['img1.jpg', 'img2.jpg', 'img3.jpg'], '02': ['img2.jpg', 'img4.jpg'], '03': ['img3.jpg', 'img5.jpg'] }, '2021': { '01': ['img6.jpg', 'img2.jpg'], '04': ['img1.jpg', 'img7.jpg'] } } assert find_duplicates(library) == ['img1.jpg', 'img2.jpg', 'img3.jpg'] def test_find_duplicates_all_duplicates(): library = { '2020': { '01': ['img1.jpg', 'img2.jpg', 'img3.jpg'], '02': ['img1.jpg', 'img2.jpg', 'img3.jpg'], '03': ['img1.jpg', 'img2.jpg', 'img3.jpg'] }, '2021': { '01': ['img1.jpg', 'img2.jpg', 'img3.jpg'], '04': ['img1.jpg', 'img2.jpg', 'img3.jpg'] } } assert find_duplicates(library) == ['img1.jpg', 'img2.jpg', 'img3.jpg'] def test_find_duplicates_different_photos(): library = { '2020': { '01': ['img1.jpg'], '02': ['img2.jpg'] }, '2021': { '03': ['img3.jpg'], '04': ['img4.jpg'] } } assert find_duplicates(library) == [] def test_find_duplicates_edge_case_empty_library(): library = {} assert find_duplicates(library) == [] def test_find_duplicates_edge_case_single_photo(): library = { '2020': { '01': ['img1.jpg'] } } assert find_duplicates(library) == []","solution":"def find_duplicates(library: dict) -> list: from collections import defaultdict # Dictionary to count occurrences of photo filenames photo_count = defaultdict(int) # Traverse the library and count occurrences of each photo for year in library.values(): for month_photos in year.values(): # Using a set to avoid considering the same photo multiple times in a single month unique_photos_in_month = set(month_photos) for photo in unique_photos_in_month: photo_count[photo] += 1 # Collect filenames that appear more than once duplicates = [photo for photo, count in photo_count.items() if count > 1] # Return duplicates sorted alphabetically return sorted(duplicates)"},{"question":"from collections import Counter def can_hike_without_repeating(n: int, peaks: List[int]) -> str: Determines if it is possible to rearrange the sequence of mountain peaks such that no peak is repeated on consecutive days. Args: n (int): Number of mountain peaks. peaks (list of int): List of identifiers for the mountain peaks. Returns: str: \\"POSSIBLE\\" if a valid rearrangement is possible, \\"NO\\" otherwise. >>> can_hike_without_repeating(5, [1, 2, 3, 4, 5]) \\"POSSIBLE\\" >>> can_hike_without_repeating(4, [1, 2, 2, 3]) \\"POSSIBLE\\" >>> can_hike_without_repeating(3, [1, 1, 1]) \\"NO\\" def test_hiking_possible_no_repeats(): assert can_hike_without_repeating(5, [1, 2, 3, 4, 5]) == \\"POSSIBLE\\" def test_hiking_possible_with_repeats(): assert can_hike_without_repeating(4, [1, 2, 2, 3]) == \\"POSSIBLE\\" def test_hiking_not_possible_all_same(): assert can_hike_without_repeating(3, [1, 1, 1]) == \\"NO\\" def test_hiking_possible_with_repeated_pairs(): assert can_hike_without_repeating(6, [1, 2, 2, 3, 3, 4]) == \\"POSSIBLE\\" def test_hiking_not_possible_one_off(): assert can_hike_without_repeating(5, [1, 1, 1, 1, 2]) == \\"NO\\" def test_hiking_edge_case_min(): assert can_hike_without_repeating(2, [1, 2]) == \\"POSSIBLE\\" def test_hiking_edge_case_two_same(): assert can_hike_without_repeating(2, [1, 1]) == \\"NO\\" def test_hiking_possible_large_n(): assert can_hike_without_repeating(100, [1]*50 + [2]*30 + [3]*20) == \\"POSSIBLE\\" def test_hiking_not_possible_large_n(): assert can_hike_without_repeating(100, [1]*51 + [2]*25 + [3]*24) == \\"NO\\"","solution":"from collections import Counter def can_hike_without_repeating(n, peaks): Determines if it is possible to rearrange the sequence of mountain peaks such that no peak is repeated on consecutive days. Args: n (int): Number of mountain peaks. peaks (list of int): List of identifiers for the mountain peaks. Returns: str: \\"POSSIBLE\\" if a valid rearrangement is possible, \\"NO\\" otherwise. count = Counter(peaks) max_frequency = max(count.values()) if max_frequency <= (n + 1) // 2: return \\"POSSIBLE\\" else: return \\"NO\\""},{"question":"from typing import List def min_transformations(n: int, dictionary: List[str], start: str, end: str) -> int: Determine the minimum number of transformations needed to transform the start word into the end word using a dictionary of words. Parameters: - n (int): The number of words in the dictionary. - dictionary (List[str]): The list of words in the dictionary. - start (str): The starting word. - end (str): The target word. Returns: - int: The minimum number of transformations needed to transform the start word into the end word. If it is not possible, return -1. Examples: >>> min_transformations(6, [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"], \\"hit\\", \\"cog\\") 4 >>> min_transformations(4, [\\"abba\\", \\"acca\\", \\"effe\\", \\"fffe\\"], \\"abcd\\", \\"effe\\") -1 pass","solution":"from collections import deque def min_transformations(n, dictionary, start, end): if start == end: return 0 word_set = set(dictionary) if end not in word_set: return -1 def can_transform(word1, word2): Check if word1 can be transformed to word2 by changing exactly one letter. differences = sum(1 for a, b in zip(word1, word2) if a != b) return differences == 1 queue = deque([(start, 0)]) visited = set([start]) while queue: current_word, steps = queue.popleft() for word in list(word_set): # List to avoid runtime changes during iteration if can_transform(current_word, word): if word == end: return steps + 1 if word not in visited: visited.add(word) queue.append((word, steps + 1)) word_set.remove(word) return -1"},{"question":"def generate_grid(n): Generates an nxn grid following the specified rules. Args: n (int): the size of the grid Returns: List[List[int]]: nxn grid filled according to the rules >>> generate_grid(1) [[1]] >>> generate_grid(2) [[1, 2], [4, 3]] >>> generate_grid(3) [[1, 2, 3], [6, 5, 4], [7, 8, 9]] >>> generate_grid(4) [[1, 2, 3, 4], [8, 7, 6, 5], [9, 10, 11, 12], [16, 15, 14, 13]]","solution":"def generate_grid(n): Generates an nxn grid following the specified rules. Args: n (int): the size of the grid Returns: List[List[int]]: nxn grid filled according to the rules grid = [] number = 1 for i in range(n): row = [] for j in range(n): row.append(number) number += 1 if i % 2 == 1: row.reverse() grid.append(row) return grid"},{"question":"def maxSumSubrectangle(grid): Returns the maximum sum of any non-empty subrectangle in the grid. Args: grid (List[List[int]]): 2D integer array representing the grid Returns: int: Maximum sum of any non-empty subrectangle pass def test_maxSumSubrectangle(): grid1 = [[1, 2, -1, 4], [-5, -2, 3, 6], [2, 2, -5, 1]] assert maxSumSubrectangle(grid1) == 12 grid2 = [[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]] assert maxSumSubrectangle(grid2) == -1 grid3 = [[-1]] assert maxSumSubrectangle(grid3) == -1 grid4 = [[1, -2, -1], [2, 2, -2], [-1, 1, 3]] assert maxSumSubrectangle(grid4) == 5 grid5 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] assert maxSumSubrectangle(grid5) == 45","solution":"def maxSumSubrectangle(grid): Returns the maximum sum of any non-empty subrectangle in the grid. Args: grid (List[List[int]]): 2D integer array representing the grid Returns: int: Maximum sum of any non-empty subrectangle m = len(grid) n = len(grid[0]) def maxSumSubarray(arr): Helper function to calculate maximum sum of subarray in 1D array using Kadane's algorithm max_sum = float('-inf') current_sum = 0 for num in arr: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum max_sum = float('-inf') for left in range(n): row_sum = [0] * m for right in range(left, n): for i in range(m): row_sum[i] += grid[i][right] max_sum = max(max_sum, maxSumSubarray(row_sum)) return max_sum"},{"question":"def can_transform_to_target_matrix(mat, target): Determines if the target matrix can be obtained from the given matrix using transpose and reverse operations. Args: mat (List[List[int]]): The starting N x N matrix. target (List[List[int]]): The target N x N matrix. Returns: bool: True if the target matrix can be obtained, otherwise False. >>> can_transform_to_target_matrix([[1, 2], [3, 4]], [[3, 1], [4, 2]]) True >>> can_transform_to_target_matrix([[1, 2], [3, 4]], [[4, 3], [2, 1]]) False pass def can_transform_multiple(test_cases): Determines if the target matrices can be obtained from the given matrices for multiple test cases. Args: test_cases (List[Tuple[int, List[List[int]], List[List[int]]]]): A list of test cases where each test case contains: - an integer N, the size of the NxN matrix. - a list of lists of integers, representing the starting matrix. - a list of lists of integers, representing the target matrix. Returns: List[str]: A list of strings \\"YES\\" or \\"NO\\" for each test case indicating if the target matrix can be obtained. >>> test_cases = [(2, [[1, 2], [3, 4]], [[3, 1], [4, 2]]), (3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[3, 6, 9], [2, 5, 8], [1, 4, 7]])] >>> can_transform_multiple(test_cases) [\\"YES\\", \\"YES\\"] pass","solution":"def can_transform_to_target_matrix(mat, target): Determines if the target matrix can be obtained from the given matrix using transpose and reverse operations. if mat == target: return True n = len(mat) # Transpose the matrix transposed = [[mat[j][i] for j in range(n)] for i in range(n)] # Check against the target if transposed == target: return True # Reverse the original matrix rows reversed_rows = [row[::-1] for row in mat] # Check against the target if reversed_rows == target: return True # Reverse and then transpose the matrix reversed_transposed = [[reversed_rows[j][i] for j in range(n)] for i in range(n)] if reversed_transposed == target: return True # Transpose and then reverse the rows of the transposed matrix transposed_reversed_rows = [row[::-1] for row in transposed] if transposed_reversed_rows == target: return True return False def can_transform_multiple(test_cases): results = [] for case in test_cases: N, starting_matrix, target_matrix = case if can_transform_to_target_matrix(starting_matrix, target_matrix): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def update_performance(n: int, q: int, events: List[List[int]]) -> List[int]: Process a series of performance updates and score adjustments and report the final performance score of each employee. Parameters: n (int): The number of employees. q (int): The number of events. events (List[List[int]]): A list of events where each event is either of the form: [1, id, x] or [2, x] Returns: List[int]: A list of performance scores of all employees after processing all events. >>> update_performance(5, 4, [[1, 3, 20], [1, 2, 5], [2, 10], [1, 4, 7]]) [0, 5, 10, 7, 0] >>> update_performance(3, 3, [[1, 1, 15], [1, 3, 25], [2, 20]]) [15, 0, 20]","solution":"def update_performance(n, q, events): scores = [0] * n for event in events: if event[0] == 1: # Increase the score of employee id by x id, x = event[1] - 1, event[2] scores[id] += x elif event[0] == 2: # Set performance scores above x to be exactly x x = event[1] scores = [min(score, x) for score in scores] return scores"},{"question":"def find_anagrams(text: str, pattern: str) -> List[int]: Find all starting indices of the pattern's anagrams in the text. >>> find_anagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> find_anagrams(\\"abcdefg\\", \\"hij\\") [] >>> find_anagrams(\\"bacdef\\", \\"bac\\") [0] >>> find_anagrams(\\"abab\\", \\"ab\\") [0, 1, 2] >>> find_anagrams(\\"aabbcc\\", \\"abc\\") [] >>> find_anagrams(\\"a\\", \\"abc\\") [] >>> find_anagrams(\\"aaaaa\\", \\"a\\") [0, 1, 2, 3, 4] >>> find_anagrams(\\"acdbacdacb\\", \\"abc\\") [3, 7]","solution":"def find_anagrams(text, pattern): from collections import Counter p_len = len(pattern) t_len = len(text) if p_len > t_len: return [] pattern_count = Counter(pattern) window_count = Counter(text[:p_len]) result = [] for i in range(t_len - p_len + 1): if i > 0: window_count[text[i - 1]] -= 1 if window_count[text[i - 1]] == 0: del window_count[text[i - 1]] window_count[text[i + p_len - 1]] += 1 if window_count == pattern_count: result.append(i) return result"},{"question":"def process_input_and_calculate_total_points(input_data): Process input data to extract team scores and calculate total points for each team. >>> process_input_and_calculate_total_points(\\"2n3n100n200n300n2n50n75\\") [600, 125] >>> process_input_and_calculate_total_points(\\"1n1n500\\") [500] >>> process_input_and_calculate_total_points(\\"1n3n10n20n30\\") [60] >>> process_input_and_calculate_total_points(\\"3n2n1n2n3n10n20n30n1n100\\") [3, 60, 100] >>> process_input_and_calculate_total_points(\\"2n0n0\\") [0, 0] >>> process_input_and_calculate_total_points(\\"1n100n\\" + \\"n\\".join([\\"1000\\"]*100)) [100000]","solution":"def calculate_total_points(n, teams_scores): Calculate the total points earned by each team. :param n: Number of teams :param teams_scores: List of lists where each sublist contains points for the tasks completed by a team. :return: List containing total points for each team total_points = [] for scores in teams_scores: total_points.append(sum(scores)) return total_points def process_input_and_calculate_total_points(input_data): Process input data to extract team scores and calculate total points for each team. :param input_data: String containing the input data :return: List containing total points for each team lines = input_data.strip().split('n') n = int(lines[0]) index = 1 teams_scores = [] for _ in range(n): t = int(lines[index]) index += 1 scores = [int(lines[index + i]) for i in range(t)] teams_scores.append(scores) index += t return calculate_total_points(n, teams_scores)"},{"question":"def arrange_books(n: int, shelves: List[int], m: int, books: List[int]) -> List[int]: Places books on shelves according to their height constraints. >>> arrange_books(4, [5, 10, 15, 20], 5, [4, 9, 21, 2, 11]) [1, 2, -1, 1, 3] >>> arrange_books(0, [], 3, [1, 2, 3]) [-1, -1, -1] >>> arrange_books(3, [5, 10, 15], 0, []) [] >>> arrange_books(3, [10, 20, 30], 3, [5, 7, 9]) [1, 1, 1] >>> arrange_books(3, [5, 10, 15], 4, [4, 8, 12, 20]) [1, 2, 3, -1] >>> arrange_books(3, [5, 10, 15], 3, [16, 17, 18]) [-1, -1, -1]","solution":"def arrange_books(n, shelves, m, books): Places books on shelves according to their height constraints. Parameters: n (int): number of shelves. shelves (list of int): heights of shelves. m (int): number of books. books (list of int): heights of books. Returns: list of int: 1-based index of the shelf where the book is placed or -1 if it can't be placed. result = [] for book in books: placed = False for index in range(n): if book <= shelves[index]: result.append(index + 1) placed = True break if not placed: result.append(-1) return result"},{"question":"def maxWaterTrapped(n: int, heights: List[int]) -> int: Returns the maximum amount of water that can be trapped between two buildings. >>> maxWaterTrapped(9, [1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> maxWaterTrapped(9, [1, 1, 1, 1, 1, 1, 1, 1, 1]) 8 from solution import maxWaterTrapped def test_maxWaterTrapped_example1(): assert maxWaterTrapped(9, [1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 def test_maxWaterTrapped_example2(): assert maxWaterTrapped(9, [1, 1, 1, 1, 1, 1, 1, 1, 1]) == 8 def test_maxWaterTrapped_single_highest_peak(): assert maxWaterTrapped(5, [1, 2, 3, 4, 5]) == 6 # Between heights 1 and 5 (indices 0 and 4) def test_maxWaterTrapped_uniform_heights(): assert maxWaterTrapped(5, [5, 5, 5, 5, 5]) == 20 # All the same height, max(width * height) = 4 * 5 def test_maxWaterTrapped_decreasing_heights(): assert maxWaterTrapped(5, [5, 4, 3, 2, 1]) == 6 # Between heights 5 and 1 (indices 0 and 4) def test_maxWaterTrapped_minimum_edge_case(): assert maxWaterTrapped(2, [1, 2]) == 1 # Only two buildings, minimum required","solution":"def maxWaterTrapped(n, heights): Returns the maximum amount of water that can be trapped between two buildings. left = 0 right = n - 1 max_trapped = 0 while left < right: height = min(heights[left], heights[right]) width = right - left max_trapped = max(max_trapped, height * width) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_trapped"},{"question":"def longest_combo_length(test_cases): Determines the length of the longest combo in a sequence of button presses for each test case. Args: test_cases (List[Tuple[int, List[int]]]): List of test cases, where each test case is a tuple containing an integer n (length of the sequence) and a list of integers b (sequence of button presses). Returns: List[int]: List of integers representing the length of the longest combo for each test case. Example: >>> longest_combo_length([(8, [1, 2, 2, 3, 1, 2, 3, 4]), (5, [3, 3, 3, 3, 3]), (6, [1, 2, 1, 2, 1, 2])]) [4, 5, 2] pass # Helper function to parse input and execute the main function def execute_longest_combo_length(input_data): Parses the input data and executes the longest_combo_length function. Args: input_data (str): Input data as a string. Returns: List[int]: The output from longest_combo_length function for the given input. lines = input_data.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) b = list(map(int, lines[index + 1].split())) test_cases.append((n, b)) index += 2 return longest_combo_length(test_cases)","solution":"def longest_combo_length(test_cases): results = [] for case in test_cases: n, b = case max_length = 1 current_length = 1 for i in range(1, n): if b[i] >= b[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) results.append(max_length) return results # Helper function to parse input and execute the main function def execute_longest_combo_length(input_data): lines = input_data.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) b = list(map(int, lines[index + 1].split())) test_cases.append((n, b)) index += 2 return longest_combo_length(test_cases)"},{"question":"def max_sum_non_decreasing_subsequence(n: int, A: List[int], k: int) -> List[int]: Find the non-decreasing subsequence of length k with the maximum sum. Parameters: n (int): Size of the array A. A (list of int): The elements of the array. k (int): The desired length of the subsequences. Returns: list of int: The elements of the subsequence in non-decreasing order. >>> max_sum_non_decreasing_subsequence(5, [4, 2, 3, 1, 5], 3) == [3, 4, 5] >>> max_sum_non_decreasing_subsequence(6, [1, 3, 2, 4, 2, 5], 2) == [4, 5]","solution":"def max_sum_non_decreasing_subsequence(n, A, k): Find the non-decreasing subsequence of length k with the maximum sum. Parameters: n (int): Size of the array A. A (list of int): The elements of the array. k (int): The desired length of the subsequences. Returns: list of int: The elements of the subsequence in non-decreasing order. if k == 1: return [max(A)] A.sort() return A[-k:]"},{"question":"def calculate_min_time(N: int, times: List[int]) -> List[float]: This function calculates the minimum time to paint the wall for each test case considering both options: painting individually or with an assistant. Parameters: N (int): Number of test cases. times (list of int): List containing T, the time taken to paint the wall individually. Returns: list of float: List containing the minimum time to paint the wall for each test case. >>> calculate_min_time(3, [300, 1500, 45]) [210, 1050, 31.5] >>> calculate_min_time(1, [5000]) [3500.0] from typing import List def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) times = [int(data[i]) for i in range(1, N + 1)] result = calculate_min_time(N, times) for time in result: print(time) if __name__ == \\"__main__\\": main()","solution":"def calculate_min_time(N, times): This function calculates the minimum time to paint the wall for each test case considering both options: painting individually or with an assistant. Parameters: N (int): Number of test cases. times (list of int): List containing T, the time taken to paint the wall individually. Returns: list of float: List containing the minimum time to paint the wall for each test case. result = [] for T in times: with_assistant_time = T - (0.3 * T) min_time = min(T, with_assistant_time) result.append(min_time) return result"},{"question":"from itertools import combinations from typing import List def count_product_pairs(transactions: List[str]) -> int: pair_count = set() for transaction in transactions: products = transaction.split() for combo in combinations(products, 2): pair_count.add(tuple(sorted(combo))) return len(pair_count) def process_input(data: List[str]) -> List[int]: Determine the number of pairs of products that were bought together at least once. Args: data: A list of strings representing input data where the first element is the number of test cases, and the subsequent elements describe each test case. Returns: A list of integers, where each integer represents the number of unique product pairs bought together in each test case. >>> process_input([\\"2\\", \\"3\\", \\"apple banana\\", \\"banana orange\\", \\"apple orange\\", \\"2\\", \\"book pen\\", \\"pen pencil pen\\"]) [3, 3] >>> process_input([\\"1\\", \\"1\\", \\"apple banana orange\\"]) [3] >>> process_input([\\"1\\", \\"1\\", \\"apple\\"]) [0] >>> process_input([\\"1\\", \\"4\\", \\"apple banana\\", \\"apple orange\\", \\"banana orange\\", \\"banana apple\\"]) [3] >>> process_input([\\"1\\", \\"2\\", \\"pen book notebook\\", \\"notebook book pen\\"]) [3]","solution":"from itertools import combinations def count_product_pairs(transactions): pair_count = set() for transaction in transactions: products = transaction.split() for combo in combinations(products, 2): pair_count.add(tuple(sorted(combo))) return len(pair_count) def process_input(data): result = [] i = 0 T = int(data[i]) i += 1 for _ in range(T): N = int(data[i]) i += 1 transactions = [] for _ in range(N): transactions.append(data[i]) i += 1 result.append(count_product_pairs(transactions)) return result"},{"question":"import math from itertools import combinations from typing import List, Tuple def distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: Calculate the Euclidean distance between two points p1 and p2. >>> distance((0, 0), (3, 4)) 5.0 >>> distance((1, 1), (1, 1)) 0.0 pass def get_circle_center_and_radius(p1: Tuple[int, int], p2: Tuple[int, int], p3: Tuple[int, int]) -> Tuple[Tuple[float, float], float]: Find the circumcenter and radius of the circle passing through points p1, p2, and p3. >>> get_circle_center_and_radius((0, 0), (1, 0), (0, 1)) ((0.5, 0.5), 0.7071067811865476) pass def smallest_enclosing_circle(points: List[Tuple[int, int]]) -> Tuple[float, float, float]: Determine the smallest circle that can enclose all the given points. >>> smallest_enclosing_circle([(1, 1), (2, 2), (3, 3)]) (2.0, 2.0, 1.41) >>> smallest_enclosing_circle([(1, 0), (0, 1), (-1, 0), (0, -1)]) (0.0, 0.0, 1.0) >>> smallest_enclosing_circle([(0, 0)]) (0.0, 0.0, 0.0) pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) points = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n)] center_x, center_y, radius = smallest_enclosing_circle(points) print(f\\"{center_x:.2f} {center_y:.2f} {radius:.2f}\\")","solution":"import math from itertools import combinations def distance(p1, p2): Calculate the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def get_circle_center_and_radius(p1, p2, p3): Find the circumcenter and radius of the circle passing through points p1, p2, and p3. A = p2[0] - p1[0] B = p2[1] - p1[1] C = p3[0] - p1[0] D = p3[1] - p1[1] E = A * (p1[0] + p2[0]) + B * (p1[1] + p2[1]) F = C * (p1[0] + p3[0]) + D * (p1[1] + p3[1]) G = 2 * (A * (p3[1] - p2[1]) - B * (p3[0] - p2[0])) if G == 0: # Collinear points return None, float('inf') Cx = (D * E - B * F) / G Cy = (A * F - C * E) / G radius = distance(p1, (Cx, Cy)) return (Cx, Cy), radius def smallest_enclosing_circle(points): Determine the smallest circle that can enclose all the given points. n = len(points) if n == 1: return (points[0][0], points[0][1], 0.0) # Initialize the smallest circle with infinity radius. smallest_circle = (0, 0, float('inf')) for i in range(n): for j in range(i+1, n): center = ((points[i][0] + points[j][0]) / 2, (points[i][1] + points[j][1]) / 2) radius = distance(points[i], center) if all(distance(p, center) <= radius for p in points): if radius < smallest_circle[2] or (radius == smallest_circle[2] and (center[0] < smallest_circle[0] or (center[0] == smallest_circle[0] and center[1] < smallest_circle[1]))): smallest_circle = (round(center[0], 2), round(center[1], 2), round(radius, 2)) for comb in combinations(points, 3): center, radius = get_circle_center_and_radius(*comb) if radius == float('inf'): continue if all(distance(p, center) <= radius for p in points): if radius < smallest_circle[2] or (radius == smallest_circle[2] and (center[0] < smallest_circle[0] or (center[0] == smallest_circle[0] and center[1] < smallest_circle[1]))): smallest_circle = (round(center[0], 2), round(center[1], 2), round(radius, 2)) return smallest_circle def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) points = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n)] center_x, center_y, radius = smallest_enclosing_circle(points) print(f\\"{center_x:.2f} {center_y:.2f} {radius:.2f}\\")"},{"question":"def find_minimized_max_edge(n: int, coordinates: List[Tuple[int, int]]) -> int: Given the number of tree houses and their coordinates, find the minimum spanning tree (MST) that minimizes the maximum weight of the edges. Args: n : int : Number of tree houses coordinates : List[Tuple[int, int]] : A list of tuples containing the coordinates of each tree house Returns: int : The minimized maximum weight of the edges in the MST >>> find_minimized_max_edge(4, [(0, 0), (2, 2), (2, 0), (0, 2)]) == 2 >>> find_minimized_max_edge(3, [(1, 1), (2, 2), (3, 3)]) == 2 from typing import List, Tuple def test_case_1(): assert find_minimized_max_edge(4, [(0, 0), (2, 2), (2, 0), (0, 2)]) == 2 def test_case_2(): assert find_minimized_max_edge(3, [(1, 1), (2, 2), (3, 3)]) == 2 def test_case_3(): assert find_minimized_max_edge(5, [(0, 0), (2, 2), (2, 0), (0, 2), (1, 1)]) == 2 def test_case_4(): assert find_minimized_max_edge(2, [(0, 0), (10000, 10000)]) == 20000 def test_case_5(): assert find_minimized_max_edge(3, [(0, 0), (0, 10000), (10000, 0)]) == 10000","solution":"def find_minimized_max_edge(n, coordinates): import heapq # Helper function to calculate Manhattan distance def manhattan_dist(p1, p2): return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) # Create all edges with their Manhattan distances edges = [] for i in range(n): for j in range(i + 1, n): distance = manhattan_dist(coordinates[i], coordinates[j]) edges.append((distance, i, j)) # Kruskal's algorithm to find MST edges.sort() parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX mst_max_edge = 0 for distance, u, v in edges: if find(u) != find(v): union(u, v) mst_max_edge = distance # If MST is connected with all n nodes if len(set(find(x) for x in range(n))) == 1: break return mst_max_edge"},{"question":"def pet_distribution(t, populations): Returns the possible distributions of people owning cats and dogs. Args: t: int, number of test cases. populations: list of int, populations for each test case. Returns: list of list of tuples: each list of tuples corresponds to one test case and contains (x, y) pairs. >>> pet_distribution(1, [2]) [[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (2, 0)]] >>> pet_distribution(1, [3]) [[(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (3, 0)]] >>> pet_distribution(2, [2, 3]) [ [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (2, 0)], [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (3, 0)] ] # Implement the distribution logic here. def format_pet_distribution(t, populations): Formats the pet distribution output as a string. Args: t: int, number of test cases. populations: list of int, populations for each test case. Returns: str: formatted string of pet distributions. >>> format_pet_distribution(1, [2]) '0 0n0 1n0 2n1 0n1 1n2 0' >>> format_pet_distribution(2, [2, 3]) '0 0n0 1n0 2n1 0n1 1n2 0nn0 0n0 1n0 2n0 3n1 0n1 1n1 2n2 0n2 1n3 0' # Implement the formatting logic here. def main(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) populations = [int(data[i]) for i in range(1, t + 1)] print(format_pet_distribution(t, populations))","solution":"def pet_distribution(t, populations): Returns the possible distributions of people owning cats and dogs. Args: t: int, number of test cases. populations: list of int, populations for each test case. Returns: list of list of tuples: each list of tuples corresponds to one test case and contains (x, y) pairs. results = [] for n in populations: pairs = [] for x in range(n + 1): for y in range(n + 1 - x): pairs.append((x, y)) results.append(pairs) return results def format_pet_distribution(t, populations): distribution = pet_distribution(t, populations) formatted_output = [] for test_case in distribution: formatted_output.append(\\"n\\".join(f\\"{x} {y}\\" for x, y in test_case)) return \\"nn\\".join(formatted_output) def main(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) populations = [int(data[i]) for i in range(1, t + 1)] print(format_pet_distribution(t, populations))"},{"question":"def max_non_overlapping_tasks(tasks): Determine the maximum number of non-overlapping tasks that can be assigned to a single server. >>> max_non_overlapping_tasks([(1, 3), (2, 5), (4, 6), (6, 7)]) 3 >>> max_non_overlapping_tasks([(4, 5), (2, 3), (3, 7)]) 2 >>> max_non_overlapping_tasks([(1, 5), (2, 6), (4, 9), (2, 9), (7, 8)]) 2 def process_input(input_data): Process multiple datasets and determine the maximum number of non-overlapping tasks for each dataset. >>> process_input([ \\"4\\", \\"1 3\\", \\"2 5\\", \\"4 6\\", \\"6 7\\", \\"3\\", \\"4 5\\", \\"2 3\\", \\"3 7\\", \\"5\\", \\"1 5\\", \\"2 6\\", \\"4 9\\", \\"2 9\\", \\"7 8\\", \\"0\\" ]) [3, 2, 2] def test_max_non_overlapping_tasks(): assert max_non_overlapping_tasks([(1, 3), (2, 5), (4, 6), (6, 7)]) == 3 assert max_non_overlapping_tasks([(4, 5), (2, 3), (3, 7)]) == 2 assert max_non_overlapping_tasks([(1, 5), (2, 6), (4, 9), (2, 9), (7, 8)]) == 2 def test_process_input(): input_data = [ \\"4\\", \\"1 3\\", \\"2 5\\", \\"4 6\\", \\"6 7\\", \\"3\\", \\"4 5\\", \\"2 3\\", \\"3 7\\", \\"5\\", \\"1 5\\", \\"2 6\\", \\"4 9\\", \\"2 9\\", \\"7 8\\", \\"0\\" ] expected_output = [3, 2, 2] assert process_input(input_data) == expected_output","solution":"def max_non_overlapping_tasks(tasks): # Sort tasks by their end times tasks.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in tasks: if start >= last_end_time: count += 1 last_end_time = end return count def process_input(input_data): result = [] index = 0 while index < len(input_data): n = int(input_data[index]) if n == 0: break tasks = [] for i in range(1, n + 1): start, end = map(int, input_data[index + i].split()) tasks.append((start, end)) result.append(max_non_overlapping_tasks(tasks)) index += n + 1 return result"},{"question":"def min_completion_time_difference(tasks: List[int]) -> int: Determines the minimum difference in completion times between the fastest and slowest worker. Args: tasks (List[int]): A list of integers where each integer represents the tasks a worker needs to complete. Returns: int: The minimum difference in completion times between the fastest and slowest worker. >>> min_completion_time_difference([]) == 0 >>> min_completion_time_difference([3]) == 0 >>> min_completion_time_difference([4, 4]) == 0 >>> min_completion_time_difference([4, 1]) == 3 >>> min_completion_time_difference([3, 1, 4, 2, 2]) == 0 >>> min_completion_time_difference([5, 2, 1, 8, 7, 3]) == 1 >>> min_completion_time_difference([10, 20, 30, 40]) == 10 >>> min_completion_time_difference([4, 5, 6, 7, 8, 9, 10]) == 1 >>> min_completion_time_difference([100, 200, 300, 400, 500, 600, 700]) == 100","solution":"def min_completion_time_difference(tasks): Determines the minimum difference in completion times between the fastest and slowest worker. tasks.sort() min_diff = float('inf') for i in range(len(tasks) - 1): min_diff = min(min_diff, tasks[i + 1] - tasks[i]) return 0 if min_diff == float('inf') else min_diff"},{"question":"from typing import List, Tuple def max_projects(n: int, projects: List[Tuple[int, int]]) -> int: Determine the maximum number of projects that can be completed without missing any deadlines. >>> max_projects(4, [(10, 5), (8, 3), (15, 7), (7, 2)]) == 3 >>> max_projects(1, [(5, 5)]) == 1 >>> max_projects(2, [(5, 6), (3, 4)]) == 0 >>> max_projects(3, [(10, 2), (8, 2), (6, 2)]) == 3 >>> max_projects(3, [(1, 1), (2, 2), (3, 3)]) == 1 >>> max_projects(5, [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]) == 5 >>> max_projects(4, [(8, 3), (7, 2), (15, 7), (10, 5)]) == 3","solution":"def max_projects(n, projects): # Sort projects by their deadlines projects.sort(key=lambda x: x[0]) current_day = 0 count = 0 for deadline, duration in projects: if current_day + duration <= deadline: current_day += duration count += 1 return count"},{"question":"def can_be_made_strictly_increasing(a): Returns True if the array can be made strictly increasing by changing at most one element. # Implementation here pass def solve(t, test_cases): Given an integer t representing the number of test cases and a list of test cases, determine if each array can be made strictly increasing by changing at most one element. Args: t : int : number of test cases test_cases : list of (int, list of int) : list containing each test case Returns: list : list of strings \\"YES\\" or \\"NO\\" for each test case >>> solve(5, [ ... (3, [1, 2, 3]), ... (3, [3, 2, 1]), ... (5, [1, 3, 5, 6, 4]), ... (4, [5, 10, 20, 8]), ... (3, [2, 2, 3]) ... ]) ['YES', 'NO', 'YES', 'YES', 'YES'] # Implementation here pass","solution":"def can_be_made_strictly_increasing(a): Returns True if the array can be made strictly increasing by changing at most one element. n = len(a) count = 0 pos = -1 for i in range(1, n): if a[i] <= a[i - 1]: count += 1 pos = i if count == 0: return True if count > 1: return False if pos == 1 or pos == n - 1: return True if a[pos - 1] < a[pos + 1] or a[pos - 2] < a[pos]: return True return False def solve(t, test_cases): results = [] for n, a in test_cases: if can_be_made_strictly_increasing(a): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def calculate_net_height_change(n: int, m: int, q: int, observations: List[Tuple[int, int, int]]) -> List[int]: Calculate the net height change for each section based on the given observations. :param n: Number of plants (not used in this solution) :param m: Number of sections :param q: Number of days/observations :param observations: List of tuples containing (si, ei, pi) :return: List of net height changes for each section from 1 to m >>> calculate_net_height_change(3, 5, 3, [(1, 2, 3), (2, 4, -2), (3, 5, 1)]) [3, 1, -1, -1, 1] >>> calculate_net_height_change(3, 5, 1, [(1, 2, 3)]) [3, 3, 0, 0, 0] >>> calculate_net_height_change(3, 5, 2, [(1, 2, 0), (3, 5, 0)]) [0, 0, 0, 0, 0]","solution":"def calculate_net_height_change(n, m, q, observations): Calculate the net height change for each section based on the given observations. :param n: Number of plants (not used in this solution) :param m: Number of sections :param q: Number of days/observations :param observations: List of tuples containing (si, ei, pi) :return: List of net height changes for each section from 1 to m # Initialize an array to store the difference of heights height_changes = [0] * (m + 1) # Apply the observations using a difference array approach for si, ei, pi in observations: height_changes[si - 1] += pi if ei < m: height_changes[ei] -= pi # Convert the difference array to the actual height changes net_height_changes = [0] * m current_change = 0 for i in range(m): current_change += height_changes[i] net_height_changes[i] = current_change return net_height_changes"},{"question":"def count_subarrays_with_sum(arr: List[int], target: int) -> int: Given an array of integers, return the number of subarrays whose sum is equal to a given value. Parameters: arr (List[int]): The list of integers. target (int): The target sum for the subarrays. Returns: int: The number of subarrays with sum equal to the target. Examples: >>> count_subarrays_with_sum([1, 1, 1], 2) 2 >>> count_subarrays_with_sum([1, 2, 3], 3) 2 >>> count_subarrays_with_sum([1, -1, 0], 0) 3 ... from solution import count_subarrays_with_sum def test_example_1(): assert count_subarrays_with_sum([1, 1, 1], 2) == 2 def test_example_2(): assert count_subarrays_with_sum([1, 2, 3], 3) == 2 def test_example_3(): assert count_subarrays_with_sum([1, -1, 0], 0) == 3 def test_single_element_matches_target(): assert count_subarrays_with_sum([5], 5) == 1 def test_single_element_does_not_match_target(): assert count_subarrays_with_sum([5], 10) == 0 def test_no_subarrays_match(): assert count_subarrays_with_sum([1, 2, 1, 2, 1], 10) == 0 def test_large_array(): large_arr = [1] * 10000 assert count_subarrays_with_sum(large_arr, 5000) == 5001","solution":"def count_subarrays_with_sum(arr, target): Returns the number of subarrays whose sum is equal to the given target. count = 0 cumulative_sum = 0 sum_dict = {0: 1} # Dictionary to store the cumulative sum frequencies for num in arr: cumulative_sum += num if (cumulative_sum - target) in sum_dict: count += sum_dict[cumulative_sum - target] sum_dict[cumulative_sum] = sum_dict.get(cumulative_sum, 0) + 1 return count"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring of the given string s. If there are multiple substrings of the same maximum length, it returns the first one that appears in the string. >>> longest_palindromic_substring(\\"babad\\") \\"bab\\" or \\"aba\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\"","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring of the given string s. If there are multiple substrings of the same maximum length, it returns the first one that appears in the string. Parameters: s (str): The input string consisting of lowercase and uppercase English letters. Returns: str: The longest palindromic substring. n = len(s) if n == 0: return \\"\\" # Initialize DP table dp = [[False] * n for _ in range(n)] start = 0 max_length = 1 # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True # Check for substring of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True start = i max_length = length return s[start:start + max_length]"},{"question":"from typing import List, Tuple def top_k_ip_pairs(logs: List[Tuple[str, str, str]], K: int) -> List[str]: Identify the top K most frequent IP pairs from the given log data. Args: logs: List of tuples, where each tuple contains (source IP, destination IP, timestamp). K : int, the number of top IP pairs to identify. Returns: List of strings where each string is in the format \\"source IP -> destination IP\\". >>> logs = [ >>> (\\"192.168.1.1\\", \\"192.168.1.2\\", \\"2023-01-01 12:00:00\\"), >>> (\\"192.168.1.1\\", \\"192.168.1.2\\", \\"2023-01-01 12:05:00\\"), >>> (\\"192.168.1.2\\", \\"192.168.1.3\\", \\"2023-01-01 12:10:00\\"), >>> (\\"192.168.1.1\\", \\"192.168.1.2\\", \\"2023-01-01 12:15:00\\"), >>> (\\"192.168.1.2\\", \\"192.168.1.3\\", \\"2023-01-01 12:20:00\\") >>> ] >>> K = 2 >>> top_k_ip_pairs(logs, K) ['192.168.1.1 -> 192.168.1.2', '192.168.1.2 -> 192.168.1.3']","solution":"from collections import Counter def top_k_ip_pairs(logs, K): Identify the top K most frequent IP pairs from the given log data. Args: logs: List of tuples, where each tuple contains (source IP, destination IP, timestamp). K : int, the number of top IP pairs to identify. Returns: List of strings where each string is in the format \\"source IP -> destination IP\\". # Counter to store the frequency of each IP pair ip_pairs_counter = Counter() # Iterate through each log entry to count the frequency of each IP pair for log in logs: source_ip, destination_ip, timestamp = log ip_pairs_counter[(source_ip, destination_ip)] += 1 # Find the top K most frequent IP pairs most_common_pairs = ip_pairs_counter.most_common() # Sort the pairs primarily by frequency (descending), then by IP addresses (lexicographically) most_common_pairs.sort(key=lambda x: (-x[1], x[0][0], x[0][1])) # Extract the top K results and format them as \\"source IP -> destination IP\\" result = [] for pair, _ in most_common_pairs[:K]: result.append(f\\"{pair[0]} -> {pair[1]}\\") return result"},{"question":"def reorganize_string(s: str) -> str: Reorder the characters of the string in such a way that no two adjacent characters are the same. Return the reordered string or an empty string if it is not possible to reorder as required. Examples: >>> reorganize_string('aab') 'aba' >>> reorganize_string('aaab') ''","solution":"import heapq from collections import Counter def reorganize_string(s): counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char result = ''.join(result) if len(result) != len(s): return \\"\\" return result"},{"question":"def check_element_pairs(t, test_cases): Determine whether every element appears exactly twice in each test case. Args: t : int : Number of test cases test_cases : list : List of tuples, where each tuple contains an integer N and a list of N integers Returns: list : List of strings, \\"YES\\" or \\"NO\\" for each test case >>> check_element_pairs(1, [(4, [1, 2, 2, 1])]) [\\"YES\\"] >>> check_element_pairs(1, [(5, [1, 2, 2, 1, 3])]) [\\"NO\\"] >>> check_element_pairs(2, [(4, [1, 2, 2, 1]), (5, [1, 2, 2, 1, 3])]) [\\"YES\\", \\"NO\\"] >>> check_element_pairs(1, [(10**5, [i for i in range(1, 50001)]*2)]) [\\"YES\\"] >>> check_element_pairs(1, [(3, [1, 2, 2])]) [\\"NO\\"] >>> check_element_pairs(1, [(2, [1, 1])]) [\\"YES\\"] >>> check_element_pairs(1, [(4, [-1, -2, -2, -1])]) [\\"YES\\"] >>> check_element_pairs(1, [(2, [1, 2])]) [\\"NO\\"]","solution":"def check_element_pairs(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] element_count = {} for num in arr: if num in element_count: element_count[num] += 1 else: element_count[num] = 1 if all(count == 2 for count in element_count.values()): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_processing_time(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the minimum possible time required to process all player requests given the constraints. >>> min_processing_time(2, [((6, 3), [8, 4, 3, 5, 7, 2]), ((5, 2), [10, 10, 10, 10, 10])]) == [10, 30] >>> min_processing_time(1, [((3, 1), [1, 2, 3])]) == [6] >>> min_processing_time(1, [((3, 3), [4, 2, 7])]) == [7] >>> min_processing_time(1, [((4, 2), [10, 10, 10, 10])]) == [20] >>> min_processing_time(1, [((5, 4), [2, 5, 6, 8, 3])]) == [8] >>> min_processing_time(1, [((10, 5), [1, 1, 1, 1, 1, 1, 1, 1, 1, 1])]) == [2] >>> min_processing_time(1, [((1, 1), [100])]) == [100]","solution":"def min_processing_time(T, test_cases): from heapq import heappop, heappush results = [] for i in range(T): N, M = test_cases[i][0] processing_times = test_cases[i][1] # If the number of worker nodes is greater than or equal to the number of requests # The minimum time required is the maximum individual processing time if M >= N: results.append(max(processing_times)) continue # Use a min-heap to simulate assigning tasks to worker nodes and track node load heap = [0] * M for time in sorted(processing_times, reverse=True): least_loaded_node = heappop(heap) heappush(heap, least_loaded_node + time) # The total time to process all requests would be the load of the most loaded node results.append(max(heap)) return results"},{"question":"class ArrayOperations: def __init__(self, arr): Initialize the array operations object with the given array. >>> array_ops = ArrayOperations([1, 2, 3, 4, 5]) self.arr = arr def update(self, i, x): Update the element at index i to x. >>> array_ops.update(2, 10) def subarray_sum(self, l, r): Compute the sum of the elements between indices l and r (inclusive). >>> array_ops.subarray_sum(0, 2) 6 def subarray_min(self, l, r): Find the minimum element between indices l and r (inclusive). >>> array_ops.subarray_min(1, 3) 2 def process_operations(n, q, arr, operations): Process the given operations on the array and return the results of sum and min queries. >>> n, q = 5, 6 >>> arr = [1, 2, 3, 4, 5] >>> operations = [\\"sum 0 2\\", \\"min 1 3\\", \\"update 2 10\\", \\"sum 2 4\\", \\"min 0 4\\", \\"sum 0 4\\"] >>> process_operations(n, q, arr, operations) [6, 2, 19, 1, 22] array_ops = ArrayOperations(arr) results = [] for operation in operations: op = operation.split() if op[0] == \\"update\\": _, i, x = op array_ops.update(int(i), int(x)) elif op[0] == \\"sum\\": _, l, r = op results.append(array_ops.subarray_sum(int(l), int(r))) elif op[0] == \\"min\\": _, l, r = op results.append(array_ops.subarray_min(int(l), int(r))) return results","solution":"class ArrayOperations: def __init__(self, arr): self.arr = arr def update(self, i, x): Update the element at index i to x. self.arr[i] = x def subarray_sum(self, l, r): Compute the sum of the elements between indices l and r (inclusive). return sum(self.arr[l:r+1]) def subarray_min(self, l, r): Find the minimum element between indices l and r (inclusive). return min(self.arr[l:r+1]) def process_operations(n, q, arr, operations): array_ops = ArrayOperations(arr) results = [] for operation in operations: op = operation.split() if op[0] == \\"update\\": _, i, x = op array_ops.update(int(i), int(x)) elif op[0] == \\"sum\\": _, l, r = op result = array_ops.subarray_sum(int(l), int(r)) results.append(result) elif op[0] == \\"min\\": _, l, r = op result = array_ops.subarray_min(int(l), int(r)) results.append(result) return results"},{"question":"def kth_smallest_in_union(nums: List[int], k: int) -> int: Finds the kth smallest element in the union of the array and its reversal. Args: nums (List[int]): A list of unique integers. k (int): The 1-based index of the element to be found. Returns: int: The kth smallest element in the union of nums and its reversal. >>> kth_smallest_in_union([2, 4, 1], 5) 4 >>> kth_smallest_in_union([4, 3, 7, 6], 3) 4 >>> kth_smallest_in_union([5], 1) 5 >>> kth_smallest_in_union([1, 2, 3], 6) 3 >>> kth_smallest_in_union([3, 2, 1], 4) 2 >>> kth_smallest_in_union([1, 5, 2, 8], 7) 8 >>> kth_smallest_in_union([4, 2, 3], 1) 2 >>> kth_smallest_in_union([1000000000, 999999999], 2) 999999999","solution":"def kth_smallest_in_union(nums, k): Finds the kth smallest element in the union of the array and its reversal. Args: nums (list): A list of unique integers. k (int): The 1-based index of the element to be found. Returns: int: The kth smallest element in the union of nums and its reversal. combined = nums + nums[::-1] combined.sort() return combined[k-1]"},{"question":"def max_product_of_three(nums: List[int]) -> int: Returns the maximum product of any three distinct numbers from the list nums. >>> max_product_of_three([10, 3, 5, 6, 20]) 1200 >>> max_product_of_three([1, 2, 3, 4]) 24","solution":"def max_product_of_three(nums): Returns the maximum product of any three distinct numbers from the list nums. nums.sort() # The top 3 maximum numbers max1 = nums[-1] max2 = nums[-2] max3 = nums[-3] # The two minimum numbers (could be large negative values) min1 = nums[0] min2 = nums[1] # Either the product of the three largest numbers or the product of the two smallest and the largest number return max(max1 * max2 * max3, min1 * min2 * max1)"},{"question":"def can_withstand_asteroids(t: int, test_cases: List[Dict[str, Any]]) -> List[str]: Determine whether the space station can withstand the impact of all incoming asteroids. >>> can_withstand_asteroids(2, [ {\\"max_force\\": 5000, \\"asteroids\\": [(10, 20), (5, 25), (15, 5)]}, {\\"max_force\\": 10000, \\"asteroids\\": [(20, 2), (30, 10)]} ]) [\\"SAFE\\", \\"SAFE\\"] >>> can_withstand_asteroids(1, [{\\"max_force\\": 100, \\"asteroids\\": [(10, 20), (5, 25), (15, 5)]}]) [\\"DANGER\\"] >>> can_withstand_asteroids(1, [{\\"max_force\\": 2500, \\"asteroids\\": [(5, 10), (10, 15)]}]) [\\"SAFE\\"] >>> can_withstand_asteroids(1, [{\\"max_force\\": 500, \\"asteroids\\": [(5, 5)]}]) [\\"SAFE\\"] >>> can_withstand_asteroids(1, [{\\"max_force\\": 100, \\"asteroids\\": [(10, 20)]}]) [\\"DANGER\\"]","solution":"def can_withstand_asteroids(t, test_cases): results = [] for case in test_cases: k, asteroids = case['max_force'], case['asteroids'] total_force = sum(d * d * m for d, m in asteroids) if total_force <= k: results.append(\\"SAFE\\") else: results.append(\\"DANGER\\") return results"},{"question":"def identify_bird_species(n: int, sightings: List[int]) -> Tuple[int, List[Tuple[int, int]]]: Identifies the unique bird species and the first day each was spotted. Args: n (int): the number of days for which sightings are recorded. sightings (list of int): the list of bird species spotted each day. Returns: tuple: a tuple containing the number of distinct species and a list of tuples with species and first sighting day. Examples: >>> identify_bird_species(7, [4, 5, 4, 2, 5, 2, 4]) (3, [(4, 1), (5, 2), (2, 4)]) >>> identify_bird_species(5, [10, 12, 10, 12, 10]) (2, [(10, 1), (12, 2)]) pass # Unit tests def test_identify_bird_species_example1(): n = 7 sightings = [4, 5, 4, 2, 5, 2, 4] expected_output = (3, [(4, 1), (5, 2), (2, 4)]) assert identify_bird_species(n, sightings) == expected_output def test_identify_bird_species_example2(): n = 5 sightings = [10, 12, 10, 12, 10] expected_output = (2, [(10, 1), (12, 2)]) assert identify_bird_species(n, sightings) == expected_output def test_identify_bird_species_all_unique(): n = 4 sightings = [1, 2, 3, 4] expected_output = (4, [(1, 1), (2, 2), (3, 3), (4, 4)]) assert identify_bird_species(n, sightings) == expected_output def test_identify_bird_species_all_same(): n = 4 sightings = [1, 1, 1, 1] expected_output = (1, [(1, 1)]) assert identify_bird_species(n, sightings) == expected_output def test_identify_bird_species_mixed(): n = 6 sightings = [5, 4, 5, 4, 5, 6] expected_output = (3, [(5, 1), (4, 2), (6, 6)]) assert identify_bird_species(n, sightings) == expected_output","solution":"def identify_bird_species(n, sightings): Identifies the unique bird species and the first day each was spotted. Args: n (int): the number of days for which sightings are recorded. sightings (list of int): the list of bird species spotted each day. Returns: tuple: a tuple containing the number of distinct species and a list of tuples with species and first sighting day. bird_dict = {} for day, species in enumerate(sightings, start=1): if species not in bird_dict: bird_dict[species] = day distinct_species = len(bird_dict) result = list(bird_dict.items()) return distinct_species, result"},{"question":"def count_ways_to_form_groups(T, test_cases): Determines the number of ways to divide cows into groups with consecutive IDs. Parameters: T (int): Number of test cases test_cases (list of tuples): List where each tuple contains (N, M) Returns: list: Number of ways to divide the cows into M groups for each test case >>> count_ways_to_form_groups(2, [(6, 3), (9, 2)]) [1, 0] >>> count_ways_to_form_groups(4, [(6, 3), (9, 2), (10, 5), (7, 1)]) [1, 0, 1, 1] >>> count_ways_to_form_groups(3, [(10, 1), (15, 1), (5, 1)]) [1, 1, 1] >>> count_ways_to_form_groups(3, [(11, 3), (14, 4), (17, 5)]) [0, 0, 0] >>> count_ways_to_form_groups(3, [(12, 3), (20, 4), (30, 5)]) [1, 1, 1]","solution":"def count_ways_to_form_groups(T, test_cases): Determines the number of ways to divide cows into groups with consecutive IDs. Parameters: T (int): Number of test cases test_cases (list of tuples): List where each tuple contains (N, M) Returns: list: Number of ways to divide the cows into M groups for each test case results = [] for N, M in test_cases: if N % M == 0: results.append(1) else: results.append(0) return results"},{"question":"def has_friend_never_receiving(n: int, friends: List[int]) -> str: Determine if there exists at least one friend who will never receive the token. >>> has_friend_never_receiving(5, [2, 3, 4, 5, 1]) 'NO' >>> has_friend_never_receiving(4, [2, 2, 3, 4]) 'YES'","solution":"def has_friend_never_receiving(n, friends): receives_token = [0] * n for friend in friends: receives_token[friend - 1] += 1 for token_count in receives_token: if token_count == 0: return \\"YES\\" return \\"NO\\""},{"question":"def longest_subarray_with_two_distinct(nums: List[int]) -> int: Given an array of integers, find the length of the longest subarray that contains at most two distinct integers. >>> longest_subarray_with_two_distinct([4, 3, 5, 5, 6, 2, 2]) 3 >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3, 3, 2, 2, 2, 1]) 6 >>> longest_subarray_with_two_distinct([1, 1, 1, 1, 1]) 5 >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 1, 2]) 6 >>> longest_subarray_with_two_distinct([]) 0 >>> longest_subarray_with_two_distinct([1]) 1 >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3, 4]) 4 >>> n = 10**5 >>> large_array = [1, 2] * (n // 2) >>> longest_subarray_with_two_distinct(large_array) 100000 >>> longest_subarray_with_two_distinct([-1, -1, -1, -2, -2, -1, -2, -2, -1]) 9","solution":"def longest_subarray_with_two_distinct(nums): from collections import defaultdict if len(nums) == 0: return 0 last_occurrence = defaultdict(int) max_length = start = 0 for end in range(len(nums)): last_occurrence[nums[end]] = end if len(last_occurrence) > 2: min_last_occurrence = min(last_occurrence.values()) del last_occurrence[nums[min_last_occurrence]] start = min_last_occurrence + 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def is_alien_sorted(words, order): Determines if the given list of words is sorted according to the new alien language order. :param words: List of words in the alien language :param order: The order of the alien alphabet :return: Boolean value indicating whether the words are sorted according to the new order >>> is_alien_sorted([\\"hello\\", \\"leetcode\\"], \\"hlabcdefgijkmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"word\\", \\"world\\", \\"row\\"], \\"worldabcefghijkmnpqstuvxyz\\") False >>> is_alien_sorted([\\"apple\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"aaa\\", \\"aaa\\", \\"aaa\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"xyz\\", \\"x\\", \\"wxyz\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") False >>> is_alien_sorted([\\"app\\", \\"apple\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"app\\", \\"apple\\", \\"ap\\"], \\"abcdefghijklmnopqrstuvwxyz\\") False >>> is_alien_sorted([\\"apple\\", \\"app\\", \\"ap\\"], \\"zxywvutsrqponmlkjihgfedcba\\") False","solution":"def is_alien_sorted(words, order): Determines if the given list of words is sorted according to the new alien language order. :param words: List of words in the alien language :param order: The order of the alien alphabet :return: Boolean value indicating whether the words are sorted according to the new order # Create a dictionary to map each character to its rank in the new order order_index = {c: i for i, c in enumerate(order)} def compare(word1, word2): Compare two words according to the new alien alphabet order. :param word1: First word to compare :param word2: Second word to compare :return: -1 if word1 < word2, 0 if word1 == word2, 1 if word1 > word2 for c1, c2 in zip(word1, word2): if order_index[c1] < order_index[c2]: return -1 elif order_index[c1] > order_index[c2]: return 1 if len(word1) < len(word2): return -1 elif len(word1) > len(word2): return 1 return 0 # Compare each word with the next word in the list for i in range(len(words) - 1): if compare(words[i], words[i + 1]) > 0: return False return True"},{"question":"def retrieve_nested_value(data: dict, key: str) -> str: Recursively traverses the dictionary to find the value associated with the specified key. If the key is not found, returns 'Key not found'. Parameters: data (dict): The dictionary to search. key (str): The key to look for. Returns: str: The value associated with the key or 'Key not found'. pass # Example usage: # data = { # \\"name\\": \\"Alice\\", # \\"details\\": { # \\"age\\": 30, # \\"location\\": { # \\"city\\": \\"Wonderland\\", # \\"zipcode\\": \\"12345\\" # } # } # } # print(retrieve_nested_value(data, \\"zipcode\\")) # Output: '12345' # data = { # \\"name\\": \\"Alice\\", # \\"details\\": { # \\"age\\": 30, # \\"location\\": { # \\"city\\": \\"Wonderland\\" # } # } # } # print(retrieve_nested_value(data, \\"zipcode\\")) # Output: 'Key not found' # Test cases def test_key_found_at_first_level(): data = { \\"name\\": \\"Alice\\", \\"details\\": { \\"age\\": 30, \\"location\\": { \\"city\\": \\"Wonderland\\", \\"zipcode\\": \\"12345\\" } } } assert retrieve_nested_value(data, \\"name\\") == \\"Alice\\" def test_key_found_at_nested_level(): data = { \\"name\\": \\"Alice\\", \\"details\\": { \\"age\\": 30, \\"location\\": { \\"city\\": \\"Wonderland\\", \\"zipcode\\": \\"12345\\" } } } assert retrieve_nested_value(data, \\"zipcode\\") == \\"12345\\" def test_key_not_found(): data = { \\"name\\": \\"Alice\\", \\"details\\": { \\"age\\": 30, \\"location\\": { \\"city\\": \\"Wonderland\\" } } } assert retrieve_nested_value(data, \\"zipcode\\") == \\"Key not found\\" def test_empty_dictionary(): data = {} assert retrieve_nested_value(data, \\"anykey\\") == \\"Key not found\\" def test_multiple_levels_of_nesting(): data = { \\"level1\\": { \\"level2\\": { \\"level3\\": { \\"key\\": \\"value\\" } } } } assert retrieve_nested_value(data, \\"key\\") == \\"value\\" def test_key_in_multiple_levels(): data = { \\"key\\": \\"top-level\\", \\"level1\\": { \\"key\\": \\"nested-level\\", \\"level2\\": { \\"key\\": \\"most-nested-level\\" } } } assert retrieve_nested_value(data, \\"key\\") == \\"top-level\\" def test_non_dict_values(): data = { \\"level1\\": { \\"level2\\": [ {\\"key\\": \\"value1\\"}, {\\"key\\": \\"value2\\"} ], \\"another_key\\": {\\"key\\": \\"value3\\"} } } assert retrieve_nested_value(data, \\"key\\") == \\"value3\\"","solution":"def retrieve_nested_value(data: dict, key: str) -> str: Recursively traverses the dictionary to find the value associated with the specified key. If the key is not found, returns 'Key not found'. Parameters: data (dict): The dictionary to search. key (str): The key to look for. Returns: str: The value associated with the key or 'Key not found'. # Traversing the dictionary using BFS queue = [data] while queue: current_data = queue.pop(0) for k, v in current_data.items(): if k == key: return v if isinstance(v, dict): queue.append(v) return \\"Key not found\\""},{"question":"def maximum_rings_collected(n, rings): Function to determine the maximum number of rings Sonic can collect. :param n: Number of segments :param rings: A list containing the number of rings in each segment :return: The maximum number of rings that can be collected in a contiguous segment # Implementation here # Unit tests def test_maximum_rings_collected_single_segment(): assert maximum_rings_collected(1, [5]) == 5 def test_maximum_rings_collected_all_positive(): assert maximum_rings_collected(5, [2, 1, 5, 1, 3]) == 12 def test_maximum_rings_collected_multiple_segments(): assert maximum_rings_collected(6, [4, 2, 6, 1, 3, 2]) == 18 def test_maximum_rings_collected_all_large_segments(): assert maximum_rings_collected(3, [9, 7, 10]) == 26 def test_maximum_rings_collected_edge_case_minimum_n(): assert maximum_rings_collected(1, [1]) == 1","solution":"def maximum_rings_collected(n, rings): Function to determine the maximum number of rings Sonic can collect. :param n: Number of segments :param rings: A list containing the number of rings in each segment :return: The maximum number of rings that can be collected in a contiguous segment max_rings = 0 current_rings = 0 for ring in rings: current_rings += ring if current_rings > max_rings: max_rings = current_rings return max_rings"},{"question":"from typing import List def max_height_difference(grid: List[List[int]], K: int) -> int: Find the maximum height difference you can achieve following exactly K moves starting from any cell in the grid. >>> grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> max_height_difference(grid, 3) 8 >>> max_height_difference(grid, 4) 8","solution":"from collections import deque def max_height_difference(grid, K): N = len(grid) M = len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_diff = 0 def bfs(start_x, start_y): queue = deque([(start_x, start_y, 0)]) min_height = grid[start_x][start_y] max_height = grid[start_x][start_y] visited = set() visited.add((start_x, start_y)) while queue: x, y, moves = queue.popleft() if moves < K: for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) min_height = min(min_height, grid[nx][ny]) max_height = max(max_height, grid[nx][ny]) return max_height - min_height for i in range(N): for j in range(M): max_diff = max(max_diff, bfs(i, j)) return max_diff"},{"question":"def can_reduce_to_zero(test_cases): Determine if it is possible to reduce each list to a single integer 0. >>> can_reduce_to_zero([(2, [4, 4]), (3, [2, 4, 6]), (4, [1, 5, 7, 9])]) ['YES', 'YES', 'NO'] # Implement your code here def process_input(input_data): Process the input data into a more manageable format. >>> process_input(3 ... 2 ... 4 4 ... 3 ... 2 4 6 ... 4 ... 1 5 7 9) [(2, [4, 4]), (3, [2, 4, 6]), (4, [1, 5, 7, 9])] # Implement your code here def main(input_data): test_cases = process_input(input_data) results = can_reduce_to_zero(test_cases) for result in results: print(result) # Test cases def test_can_reduce_to_zero(): input_data = 3 2 4 4 3 2 4 6 4 1 5 7 9 expected_output = [\\"YES\\", \\"YES\\", \\"NO\\"] assert can_reduce_to_zero(process_input(input_data)) == expected_output input_data = 2 3 0 0 0 4 10 20 30 40 expected_output = [\\"YES\\", \\"YES\\"] assert can_reduce_to_zero(process_input(input_data)) == expected_output input_data = 1 4 1 2 3 4 expected_output = [\\"NO\\"] assert can_reduce_to_zero(process_input(input_data)) == expected_output def test_process_input(): input_data = 2 2 4 4 3 2 4 6 expected_output = [(2, [4, 4]), (3, [2, 4, 6])] assert process_input(input_data) == expected_output input_data = 1 4 0 0 0 0 expected_output = [(4, [0, 0, 0, 0])] assert process_input(input_data) == expected_output","solution":"def can_reduce_to_zero(test_cases): results = [] for case in test_cases: n, arr = case if all(num % 2 == 0 for num in arr): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def process_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): n = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append((n, arr)) index += 2 return test_cases def main(input_data): test_cases = process_input(input_data) results = can_reduce_to_zero(test_cases) for result in results: print(result)"},{"question":"def find_max_hourglass_sum(matrix): Given an NxN matrix, find the maximum hourglass sum. An hourglass is defined as: a b c d e f g >>> find_max_hourglass_sum([ ... [1, 2, 3, 0, 0], ... [0, 5, 0, 0, 0], ... [9, 8, 7, 0, 0], ... [0, 0, 0, 0, 0] ... ]) == 35 >>> find_max_hourglass_sum([ ... [-1, -1, -1, -2, -2], ... [-1, -1, -1, -2, -2], ... [-1, -1, -1, -2, -2], ... [-2, -2, -2, -2, -2], ... [-2, -2, -2, -2, -2] ... ]) == -7 >>> find_max_hourglass_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 35 >>> find_max_hourglass_sum([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) == 0 >>> find_max_hourglass_sum([ ... [1, 1, 1, 0, 0, 0], ... [0, 1, 0, 0, 0, 0], ... [1, 1, 1, 0, 0, 0], ... [0, 0, 2, 4, 4, 0], ... [0, 0, 0, 2, 0, 0], ... [0, 0, 1, 2, 4, 0] ... ]) == 19","solution":"def find_max_hourglass_sum(matrix): Given an NxN matrix, find the maximum hourglass sum. An hourglass is defined as: a b c d e f g N = len(matrix) max_sum = float('-inf') for i in range(N - 2): for j in range(N - 2): current_sum = (matrix[i][j] + matrix[i][j+1] + matrix[i][j+2] + matrix[i+1][j+1] + matrix[i+2][j] + matrix[i+2][j+1] + matrix[i+2][j+2]) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def remove_duplicates(product_ids: List[str]) -> List[str]: Removes duplicate product IDs from the list while maintaining the order of their first appearance. >>> remove_duplicates([\\"A123\\", \\"B456\\", \\"A123\\", \\"C789\\", \\"B456\\"]) [\\"A123\\", \\"B456\\", \\"C789\\"] >>> remove_duplicates([\\"P100\\", \\"P101\\", \\"P102\\", \\"P100\\", \\"P103\\", \\"P101\\"]) [\\"P100\\", \\"P101\\", \\"P102\\", \\"P103\\"] >>> remove_duplicates([\\"X001\\", \\"Y002\\", \\"Z003\\", \\"X001\\", \\"Y002\\", \\"Y002\\", \\"X001\\"]) [\\"X001\\", \\"Y002\\", \\"Z003\\"]","solution":"from typing import List def remove_duplicates(product_ids: List[str]) -> List[str]: Removes duplicate product IDs from the list while maintaining the order of their first appearance. seen = set() unique_product_ids = [] for product_id in product_ids: if product_id not in seen: unique_product_ids.append(product_id) seen.add(product_id) return unique_product_ids"},{"question":"def treasure_hunt(N: int, M: int, forest: List[str], sx: int, sy: int, ex: int, ey: int) -> Union[int, str]: Returns the minimum number of steps required to reach the end point from the start point in the forest grid. If no such path exists, returns \\"Trapped!\\". Args: N: int - the number of rows in the grid M: int - the number of columns in the grid forest: List[str] - the grid representing the forest where each cell is either '.' or '#' sx: int - row coordinate of the start point sy: int - column coordinate of the start point ex: int - row coordinate of the end point ey: int - column coordinate of the end point Returns: int - the minimum number of steps required to reach the end point str - \\"Trapped!\\" if no path exists to reach the end point Example: >>> N, M = 5, 5 >>> forest = [ ... \\".....\\", ... \\".#.\\", ... \\".....\\", ... \\".#.\\", ... \\".....\\" ... ] >>> sx, sy, ex, ey = 0, 0, 4, 4 >>> treasure_hunt(N, M, forest, sx, sy, ex, ey) 8 >>> N = 5 >>> M = 5 >>> forest = [ ... \\".....\\", ... \\".#.\\", ... \\".....\\", ... \\".#.\\", ... \\"....#\\" ... ] >>> sx, sy, ex, ey = 0, 0, 4, 4 >>> treasure_hunt(N, M, forest, sx, sy, ex, ey) \\"Trapped!\\"","solution":"from collections import deque def treasure_hunt(N, M, forest, sx, sy, ex, ey): Returns the minimum number of steps required to reach the end point from the start point. If no such path exists, returns \\"Trapped!\\". # Directions for movement in the grid (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize the queue for BFS and visited set queue = deque([(sx, sy, 0)]) # (current x, current y, steps taken) visited = set() visited.add((sx, sy)) while queue: x, y, steps = queue.popleft() # If reached the end point if (x, y) == (ex, ey): return steps # Explore the neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and forest[nx][ny] == '.': queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) # If no path is found return \\"Trapped!\\""},{"question":"def max_contiguous_subset_score(n: int, cards: List[int]) -> int: Returns the maximum possible score of any contiguous subset of the cards. Uses Kadane's Algorithm to find the maximum sum of a contiguous subarray. :param n: Integer, number of cards in the deck :param cards: List of integers, numbers on the cards :return: Integer, the maximum score of any contiguous subset of the cards >>> max_contiguous_subset_score(5, [-2, 1, -3, 4, -1]) == 4 >>> max_contiguous_subset_score(8, [-2, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_contiguous_subset_score(1, [5]) == 5 >>> max_contiguous_subset_score(1, [-5]) == -5 >>> max_contiguous_subset_score(5, [-1, -2, -3, -4, -5]) == -1 >>> max_contiguous_subset_score(4, [1, 2, 3, 4]) == 10 >>> max_contiguous_subset_score(7, [2, -3, 5, 1, -1, 2, -3]) == 7 >>> cards = [i for i in range(1, 1001)] >>> max_contiguous_subset_score(1000, cards) == sum(range(1, 1001))","solution":"def max_contiguous_subset_score(n, cards): Returns the maximum possible score of any contiguous subset of the cards. Uses Kadane's Algorithm to find the maximum sum of a contiguous subarray. :param n: Integer, number of cards in the deck :param cards: List of integers, numbers on the cards :return: Integer, the maximum score of any contiguous subset of the cards max_ending_here = max_so_far = cards[0] for i in range(1, n): max_ending_here = max(cards[i], max_ending_here + cards[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def flatten_dict(d, delimiter=\\".\\", parent_key=\\"\\"): Flattens a nested dictionary by concatenating keys with a given delimiter. Parameters: d (dict): The nested dictionary to flatten delimiter (str): The delimiter to use between keys parent_key (str): The concatenated key for recursive calls (used internally) Returns: dict: A new dictionary with flattened keys pass def test_flatten_dict_single_level(): data = {\\"a\\": 1, \\"b\\": 2} expected = {\\"a\\": 1, \\"b\\": 2} assert flatten_dict(data) == expected def test_flatten_dict_two_levels(): data = {\\"a\\": 1, \\"b\\": {\\"c\\": 2}} expected = {\\"a\\": 1, \\"b.c\\": 2} assert flatten_dict(data) == expected def test_flatten_dict_multiple_levels(): data = { \\"a\\": 1, \\"b\\": { \\"c\\": 2, \\"d\\": { \\"e\\": 3, \\"f\\": 4 } } } expected = { \\"a\\": 1, \\"b.c\\": 2, \\"b.d.e\\": 3, \\"b.d.f\\": 4 } assert flatten_dict(data) == expected def test_flatten_dict_with_different_delimiter(): data = { \\"a\\": 1, \\"b\\": { \\"c\\": 2, \\"d\\": { \\"e\\": 3, \\"f\\": 4 } } } expected = { \\"a\\": 1, \\"b-c\\": 2, \\"b-d-e\\": 3, \\"b-d-f\\": 4 } assert flatten_dict(data, delimiter=\\"-\\") == expected def test_flatten_dict_empty(): data = {} expected = {} assert flatten_dict(data) == expected","solution":"def flatten_dict(d, delimiter=\\".\\", parent_key=\\"\\"): Flattens a nested dictionary by concatenating keys with a given delimiter. Parameters: d (dict): The nested dictionary to flatten delimiter (str): The delimiter to use between keys parent_key (str): The concatenated key for recursive calls (used internally) Returns: dict: A new dictionary with flattened keys items = [] for k, v in d.items(): new_key = f\\"{parent_key}{delimiter}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, delimiter, new_key).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def min_moves_to_remove_palindromes(T: int, strings: List[str]) -> List[int]: Given a list of strings, find the minimal number of moves required to remove all the characters from each string using the operation of removing non-empty palindromic subsequences. >>> min_moves_to_remove_palindromes(3, [\\"ababa\\", \\"abcd\\", \\"aabb\\"]) [1, 2, 2] >>> min_moves_to_remove_palindromes(2, [\\"mom\\", \\"apple\\"]) [1, 2] >>> min_moves_to_remove_palindromes(1, [\\"a\\"]) [1] def test_all_palindromic(): assert min_moves_to_remove_palindromes(1, [\\"level\\"]) == [1] assert min_moves_to_remove_palindromes(1, [\\"madam\\"]) == [1] assert min_moves_to_remove_palindromes(1, [\\"racecar\\"]) == [1] def test_not_palindromic(): assert min_moves_to_remove_palindromes(1, [\\"abcd\\"]) == [2] assert min_moves_to_remove_palindromes(1, [\\"pqrs\\"]) == [2] def test_mixed_cases(): assert min_moves_to_remove_palindromes(3, [\\"ababa\\", \\"abcd\\", \\"aabb\\"]) == [1, 2, 2] assert min_moves_to_remove_palindromes(2, [\\"mom\\", \\"apple\\"]) == [1, 2] def test_single_char(): assert min_moves_to_remove_palindromes(1, [\\"a\\"]) == [1] assert min_moves_to_remove_palindromes(1, [\\"z\\"]) == [1]","solution":"def min_moves_to_remove_palindromes(T, strings): def is_palindrome(s): return s == s[::-1] result = [] for s in strings: if is_palindrome(s): result.append(1) else: result.append(2 if not is_palindrome(s[::-1]) else 1) return result"},{"question":"MOD = 1000000007 def preprocess_prefix_sums(arr): Preprocess the array to compute prefix sums. n = len(arr) prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = (prefix_sums[i - 1] + arr[i - 1]) % MOD return prefix_sums def query_sum(prefix_sums, l, r): Return the sum of subarray from index l to r (1-based index), modulo 1000000007. return (prefix_sums[r] - prefix_sums[l - 1] + MOD) % MOD def process_queries(n, q, arr, queries): Process the input array and queries, and return result for each query. prefix_sums = preprocess_prefix_sums(arr) results = [] for l, r in queries: results.append(query_sum(prefix_sums, l, r)) return results import pytest def test_preprocess_prefix_sums(): arr = [1, 2, 3, 4, 5] expected_prefix_sums = [0, 1, 3, 6, 10, 15] assert preprocess_prefix_sums(arr) == expected_prefix_sums def test_query_sum(): prefix_sums = [0, 1, 3, 6, 10, 15] assert query_sum(prefix_sums, 1, 3) == 6 assert query_sum(prefix_sums, 2, 4) == 9 assert query_sum(prefix_sums, 1, 5) == 15 def test_process_queries(): arr = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 4), (1, 5)] expected = [6, 9, 15] assert process_queries(5, 3, arr, queries) == expected def test_process_queries_large_input(): arr = [1000000000] * 100000 queries = [(1, 100000), (1, 1), (1, 2)] expected = [(1000000000 * 100000) % MOD, 1000000000 % MOD, (1000000000 * 2) % MOD] assert process_queries(100000, 3, arr, queries) == expected","solution":"MOD = 1000000007 def preprocess_prefix_sums(arr): Preprocess the array to compute prefix sums. n = len(arr) prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = (prefix_sums[i - 1] + arr[i - 1]) % MOD return prefix_sums def query_sum(prefix_sums, l, r): Return the sum of subarray from index l to r (1-based index), modulo 1000000007. return (prefix_sums[r] - prefix_sums[l - 1] + MOD) % MOD def process_queries(n, q, arr, queries): Process the input array and queries, and return result for each query. prefix_sums = preprocess_prefix_sums(arr) results = [] for l, r in queries: results.append(query_sum(prefix_sums, l, r)) return results"},{"question":"def check_subarray_sum(nums, k): Checks if there is a continuous subarray of size at least 2 that sums up to a multiple of \`k\`. Returns True if such a subarray exists, otherwise False. >>> check_subarray_sum([23, 2, 4, 6, 7], 6) True >>> check_subarray_sum([23, 2, 6, 4, 7], 6) True >>> check_subarray_sum([23, 2, 6, 4, 7], 13) False","solution":"def check_subarray_sum(nums, k): Checks if there's a continuous subarray of size at least 2 that sums up to a multiple of k. if not nums or len(nums) < 2: return False # Dictionary to store the remainder when sum up to current index is divided by k remainders = {0: -1} total_sum = 0 for i, num in enumerate(nums): total_sum += num if k != 0: remainder = total_sum % k else: remainder = total_sum if remainder in remainders: if i - remainders[remainder] > 1: return True else: remainders[remainder] = i return False"},{"question":"def check_all_vowels(s: str) -> bool: Determine if the given string contains all the vowels (a, e, i, o, u) at least once. >>> check_all_vowels(\\"education\\") True >>> check_all_vowels(\\"aeiou\\") True >>> check_all_vowels(\\"quick\\") False","solution":"def check_all_vowels(s): Returns whether the input string contains all the vowels (a, e, i, o, u) at least once. vowels = set('aeiou') return vowels.issubset(set(s))"},{"question":"def maxHourglassSum(matrix, M, N): Given a matrix of size MxN, find the maximum sum of any hourglass shape in the matrix. An hourglass shape is defined as: a b c d e f g Args: matrix (List[List[int]]): 2D array of integers representing the matrix M (int): number of rows in the matrix N (int): number of columns in the matrix Returns: int: Maximum sum of any hourglass shape in the matrix >>> matrix = [ ... [1, 1, 1], ... [0, 1, 0], ... [1, 1, 1] ... ] >>> maxHourglassSum(matrix, 3, 3) 7 >>> matrix = [ ... [1, 2, 3, 0], ... [0, 1, 0, 0], ... [1, 1, 1, 0], ... [0, 0, 2, 4] ... ] >>> maxHourglassSum(matrix, 4, 4) 10 pass def test_maxHourglassSum_single_hourglass_matrix(): matrix = [ [1, 1, 1], [0, 1, 0], [1, 1, 1] ] M, N = 3, 3 assert maxHourglassSum(matrix, M, N) == 7 def test_maxHourglassSum_multiple_hourglasses(): matrix = [ [1, 2, 3, 0], [0, 1, 0, 0], [1, 1, 1, 0], [0, 0, 2, 4] ] M, N = 4, 4 assert maxHourglassSum(matrix, M, N) == 10 def test_maxHourglassSum_negative_values(): matrix = [ [-1, -1, 0, -9, -2, -2], [-2, -1, -6, -8, -2, -5], [-1, -1, -1, -2, -3, -4], [-1, -9, -2, -4, -4, -5], [-7, -3, -3, -2, -9, -9], [-1, -3, -1, -2, -4, -5] ] M, N = 6, 6 assert maxHourglassSum(matrix, M, N) == -6 def test_maxHourglassSum_mixed_values(): matrix = [ [1, -1, 1, -1, 1], [-1, 1, -1, 1, -1], [1, -1, 1, -1, 1], [-1, 1, -1, 1, -1], [1, -1, 1, -1, 1] ] M, N = 5, 5 assert maxHourglassSum(matrix, M, N) == 3 def test_maxHourglassSum_large_values(): matrix = [ [10**6, 10**6, 10**6, 0], [0, 10**6, 0, 0], [10**6, 10**6, 10**6, 0], [0, 0, 0, 0] ] M, N = 4, 4 assert maxHourglassSum(matrix, M, N) == 7 * 10**6 # To execute the tests use \`pytest\` module # Install pytest using \`pip install pytest\`","solution":"def maxHourglassSum(matrix, M, N): max_sum = float('-inf') for i in range(M - 2): for j in range(N - 2): top = matrix[i][j] + matrix[i][j + 1] + matrix[i][j + 2] middle = matrix[i + 1][j + 1] bottom = matrix[i + 2][j] + matrix[i + 2][j + 1] + matrix[i + 2][j + 2] hourglass_sum = top + middle + bottom max_sum = max(max_sum, hourglass_sum) return max_sum"},{"question":"def determine_list_trend(lst): Determine whether the list is strictly increasing, strictly decreasing, or neither. >>> determine_list_trend([1, 2, 3, 4, 5]) \\"increasing\\" >>> determine_list_trend([5, 4, 3, 2, 1]) \\"decreasing\\" >>> determine_list_trend([1, 2, 2, 3]) \\"neither\\"","solution":"def determine_list_trend(lst): Determine whether the list is strictly increasing, strictly decreasing, or neither. Parameters: lst (list): List of integers. Returns: str: \\"increasing\\" if the list is strictly increasing, \\"decreasing\\" if it is strictly decreasing, \\"neither\\" otherwise. if len(lst) < 2: return \\"neither\\" is_increasing = all(lst[i] < lst[i + 1] for i in range(len(lst) - 1)) is_decreasing = all(lst[i] > lst[i + 1] for i in range(len(lst) - 1)) if is_increasing: return \\"increasing\\" elif is_decreasing: return \\"decreasing\\" else: return \\"neither\\""},{"question":"from typing import List def canTravelToEnd(buildings: List[int], jumpHeight: int) -> bool: Determines if it's possible to travel from the first building to the last building using the given jump height. Parameters: buildings (List[int]): List of integers representing the height of each building. jumpHeight (int): Maximum height difference you can jump. Returns: bool: True if it's possible to travel from the first building to the last one, else False. Example: >>> canTravelToEnd([4, 2, 7, 6, 9], 3) True >>> canTravelToEnd([3, 6, 8, 5, 2], 2) False >>> canTravelToEnd([1, 2, 3, 4, 5], 1) True","solution":"from typing import List def canTravelToEnd(buildings: List[int], jumpHeight: int) -> bool: Determines if it's possible to travel from the first building to the last building using the given jump height. Parameters: buildings (List[int]): List of integers representing the height of buildings. jumpHeight (int): Maximum height difference you can jump. Returns: bool: True if it's possible to travel from the first building to the last one, else False. n = len(buildings) # BFS approach for exploring possible jumps to_visit = [0] visited = set() while to_visit: current = to_visit.pop(0) if current == n - 1: return True # Skipping already visited buildings if current in visited: continue # Mark the current building as visited visited.add(current) # Check all possible jumps to the next buildings for next_building in range(current + 1, min(n, current + jumpHeight + 1)): if abs(buildings[next_building] - buildings[current]) <= jumpHeight: to_visit.append(next_building) # Check all possible jumps to the previous buildings for prev_building in range(max(0, current - jumpHeight), current): if abs(buildings[prev_building] - buildings[current]) <= jumpHeight: to_visit.append(prev_building) return False"},{"question":"def valid_trail_checker(T: int, test_cases: List[Tuple[Tuple[int, int], List[Tuple[int, int]]]]) -> List[str]: Determine if each set of given points and bidirectional paths forms a valid trail. Args: T: The number of test cases. test_cases: A list where each element is a tuple containing two parts: (1) A tuple of two integers (N, M), the number of points and the number of bidirectional paths. (2) A list of M tuples, each containing two integers u and v describing a bidirectional path between points u and v. Returns: A list of strings, where each string is \\"YES\\" if the set of points and paths forms a valid trail, otherwise \\"NO\\". >>> valid_trail_checker(2, [((4, 3), [(1, 2), (2, 3), (3, 4)]), ((4, 3), [(1, 2), (2, 3), (1, 3)])]) ['YES', 'NO'] >>> valid_trail_checker(1, [((5, 4), [(1, 2), (2, 3), (3, 4), (4, 5)])]) ['YES']","solution":"def is_valid_trail(N, M, paths): from collections import defaultdict # Helper function to perform DFS def dfs(node, parent): visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: if not dfs(neighbor, node): return False elif neighbor != parent: return False return True if N == 0: return True graph = defaultdict(list) for u, v in paths: graph[u].append(v) graph[v].append(u) visited = [False] * (N + 1) # Check if the graph is connected and acyclic using DFS or BFS if not dfs(1, -1): return False # Ensure all nodes are visited (connected graph) if not all(visited[1:N+1]): return False return True def valid_trail_checker(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][0] paths = test_cases[i][1] if is_valid_trail(N, M, paths): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_credits(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the maximum amount of space credits left after performing all trades, considering the trades sequence in both original and reversed order. >>> max_credits(2, [(4, [5, -3, 12, -7]), (3, [1, 2, 3])]) [7, 6] >>> max_credits(1, [(5, [-1000, 500, 500, 1000, -1000])]) [0] # Your code here","solution":"def max_credits(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] trades = test_cases[i][1] total_original = sum(trades) total_reversed = sum(trades[::-1]) results.append(max(total_original, total_reversed)) return results"},{"question":"def maxProfit(prices): This function takes in an array of prices and returns the maximum profit possible by buying on one day and selling on a later day. Parameters: prices (List[int]): List of daily stock prices. Returns: int: Maximum profit possible from one transaction. Example: >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0","solution":"def maxProfit(prices): This function takes in an array of prices and returns the maximum profit possible by buying on one day and selling on a later day. # Initialize variables to keep track of the minimum price and the maximum profit min_price = float('inf') max_profit = 0 # Iterate through the list of prices for price in prices: # Update the minimum price encountered so far if price < min_price: min_price = price # Calculate the potential profit from selling at the current price profit = price - min_price # Update the maximum profit if the current profit is greater if profit > max_profit: max_profit = profit return max_profit"},{"question":"def countUniqueStrings(K: int) -> int: Determine the number of unique K-length strings that can be created from the set of characters {'a', 'b', 'c', 'd'} such that no two adjacent characters are the same. Parameters: K (int): The length of the strings. Returns: int: The number of unique K-length strings. >>> countUniqueStrings(1) 4 >>> countUniqueStrings(2) 12 >>> countUniqueStrings(3) 36 >>> countUniqueStrings(4) 108","solution":"def countUniqueStrings(K): Returns the number of unique K-length strings with no two adjacent characters being the same. if K == 1: return 4 total_ways = 4 * (3 ** (K - 1)) return total_ways"},{"question":"from typing import List def symmetric_sum(N: int, levels: List[int]) -> List[int]: Calculate the symmetric sum for each level of the binary tree. Args: N (int): Number of nodes in the tree. levels (List[int]): List of integers representing the level-order traversal of the tree. Returns: List[int]: List where each element indicates the symmetric sum at each level. Examples: >>> symmetric_sum(7, [1, 2, 3, -1, -1, 4, 5]) [1, 5, 9] >>> symmetric_sum(9, [10, 20, 20, 10, -1, -1, 10, -1, -1, -1, -1]) [10, 40, 20] >>> symmetric_sum(1, [1]) [1] from solution import symmetric_sum def test_symmetric_sum_case_1(): assert symmetric_sum(7, [1, 2, 3, -1, -1, 4, 5]) == [1, 5, 9] def test_symmetric_sum_case_2(): assert symmetric_sum(9, [10, 20, 20, 10, -1, -1, 10, -1, -1, -1, -1]) == [10, 40, 20] def test_symmetric_sum_single_node(): assert symmetric_sum(1, [1]) == [1] def test_symmetric_sum_complete_tree(): assert symmetric_sum(7, [7, 4, 3, 9, 2, 5, 2]) == [7, 7, 18] def test_symmetric_sum_empty_tree(): assert symmetric_sum(0, []) == []","solution":"def symmetric_sum(N, levels): if N == 0: return [] from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(values): if not values: return None root = TreeNode(values[0]) queue = deque([root]) i = 1 while i < len(values): current = queue.popleft() if values[i] != -1: current.left = TreeNode(values[i]) queue.append(current.left) i += 1 if i < len(values) and values[i] != -1: current.right = TreeNode(values[i]) queue.append(current.right) i += 1 return root def symmetric_level_sum(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_vals = [] for _ in range(level_size): node = queue.popleft() level_vals.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) n = len(level_vals) level_sum = 0 for i in range(n // 2): level_sum += level_vals[i] + level_vals[n - 1 - i] if n % 2 == 1: level_sum += level_vals[n // 2] result.append(level_sum) return result tree_root = build_tree(levels) return symmetric_level_sum(tree_root)"},{"question":"def two_sum_indices(arr, target): Find two indices in the array arr that sum up to target. Parameters: arr (list of int): Input array of integers. target (int): The target sum. Returns: tuple of int: A tuple of two integers representing the indices (1-based) of the elements that sum to the target. Indices are returned in ascending order. If no such pair is found, return \\"No valid pair\\". Examples: >>> two_sum_indices([2, 7, 11, 15, 1], 9) (1, 2) >>> two_sum_indices([1, 2, 3, 4], 8) \\"No valid pair\\"","solution":"def two_sum_indices(arr, target): Find two indices in the array arr that sum up to target. Parameters: arr (list of int): Input array of integers. target (int): The target sum. Returns: tuple of int: A tuple of two integers representing the indices (1-based) of the elements that sum to the target. Indices are returned in ascending order. If no such pair is found, return \\"No valid pair\\". index_map = {} for i, num in enumerate(arr): complement = target - num if complement in index_map: return (index_map[complement] + 1, i + 1) index_map[num] = i return \\"No valid pair\\""},{"question":"def double_char(s: str) -> str: Given a string, return a new string where each character in the original string is duplicated such that each appears twice in a row. >>> double_char(\\"abcd\\") \\"aabbccdd\\" >>> double_char(\\"hello\\") \\"hheelllloo\\" >>> double_char(\\"xyz\\") \\"xxyyzz\\"","solution":"def double_char(s): Returns a new string where each character in the original string is duplicated. return \\"\\".join([char * 2 for char in s])"},{"question":"from typing import List, Tuple def min_moves_for_each_case(test_cases: List[Tuple[int, int, int, int, int, List[Tuple[int, int]]]]) -> List[int]: Determine the minimum number of moves the robot needs to collect the item for each test case. Each test case consists of: - m: dimension of the grid (m x m) - sx, sy: starting position of the robot - ix, iy: position of the item - k: number of traps - traps: a list of trap coordinates Returns a list with the result for each input test case. Example: >>> min_moves_for_each_case([(3, 1, 1, 3, 3, [(2, 2)])]) [4] >>> min_moves_for_each_case([(4, 1, 1, 4, 4, [(2, 2), (3, 3), (4, 2)])]) [6] pass # Unit tests def test_case_1(): test_cases = [ (3, 1, 1, 3, 3, [(2, 2)]) ] assert min_moves_for_each_case(test_cases) == [4] def test_case_2(): test_cases = [ (4, 1, 1, 4, 4, [(2, 2), (3, 3), (4, 2)]) ] assert min_moves_for_each_case(test_cases) == [6] def test_case_3(): test_cases = [ (5, 1, 1, 5, 5, []) ] assert min_moves_for_each_case(test_cases) == [8] def test_case_4(): test_cases = [ (5, 1, 1, 5, 5, [(2, 2), (3, 3), (4, 4)]) ] assert min_moves_for_each_case(test_cases) == [8] def test_case_5(): test_cases = [ (6, 2, 3, 5, 6, [(2, 2), (3, 4)]) ] assert min_moves_for_each_case(test_cases) == [6]","solution":"from collections import deque def bfs_min_moves(m, sx, sy, ix, iy, traps): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) trap_set = set(traps) while queue: x, y, moves = queue.popleft() if (x, y) == (ix, iy): return moves for dx, dy in directions: nx, ny = x + dx, y + dy if 1 <= nx <= m and 1 <= ny <= m and (nx, ny) not in visited and (nx, ny) not in trap_set: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) def min_moves_for_each_case(test_cases): results = [] for case in test_cases: m, sx, sy, ix, iy, traps = case moves = bfs_min_moves(m, sx, sy, ix, iy, traps) results.append(moves) return results # Example usage for testing: test_cases = [ (3, 1, 1, 3, 3, [(2, 2)]), (4, 1, 1, 4, 4, [(2, 2), (3, 3), (4, 2)]) ] print(min_moves_for_each_case(test_cases)) # Output: [4, 6]"},{"question":"def transform_strings(k: int, test_cases: List[Tuple[int, str, str]]) -> List[Tuple[int, List[str]]]: Transform the initial string \`s\` into the desired string \`t\` using a series of operations. The number of operations must not exceed 20000. >>> transform_strings(2, [(5, \\"abcde\\", \\"badce\\"), (4, \\"alex\\", \\"bale\\")]) [(4, [\\"1 1\\", \\"1 2\\", \\"2 1 b\\", \\"1 4\\"]), (3, [\\"2 1 b\\", \\"2 2 a\\", \\"2 3 l\\"])] >>> transform_strings(1, [(6, \\"abcdef\\", \\"fedcba\\")]) [(15, [\\"1 1\\", \\"1 2\\", \\"1 3\\", \\"1 4\\", \\"1 5\\", \\"2 1 f\\", \\"2 2 e\\", \\"2 3 d\\", \\"2 4 c\\", \\"2 5 b\\", \\"2 6 a\\", \\"1 1\\", \\"1 2\\", \\"1 3\\", \\"1 4\\"])] >>> transform_strings(1, [(1000, \\"a\\" * 1000, \\"b\\" * 1000)]) [(1000, [\\"2 1 b\\", \\"2 2 b\\", \\"2 3 b\\", \\"2 4 b\\", [...] \\"2 998 b\\", \\"2 999 b\\", \\"2 1000 b\\"])] >>> transform_strings(1, [(3, \\"abc\\", \\"def\\")]) [(3, [\\"2 1 d\\", \\"2 2 e\\", \\"2 3 f\\"])] >>> transform_strings(1, [(3, \\"abc\\", \\"abc\\")]) [(0, [])]","solution":"def transform_strings(k, test_cases): def get_operations(n, s, t): operations = [] # Step 1: Align characters by swap if needed s = list(s) for i in range(n): if s[i] != t[i]: for j in range(i+1, n): if s[j] == t[i]: # Swap s[i] and s[j] s[i], s[j] = s[j], s[i] operations.append(f\\"1 {i+1}\\") break # Step 2: Replace characters to match target s = list(s) for i in range(n): if s[i] != t[i]: operations.append(f\\"2 {i+1} {t[i]}\\") return operations results = [] for i in range(k): n = test_cases[i][0] s = test_cases[i][1] t = test_cases[i][2] operations = get_operations(n, s, t) results.append((len(operations), operations)) return results"},{"question":"def diving_rating(T: int, A: int) -> str: Determines the rating for Charles's dive based on his technical (T) and artistic (A) scores. Arguments: T -- technical score (0 <= T <= 100) A -- artistic score (0 <= A <= 100) Returns: A string representing the rating (\\"Excellent\\", \\"Good\\", or \\"Needs Improvement\\"). >>> diving_rating(90, 80) 'Excellent' >>> diving_rating(50, 100) 'Good' >>> diving_rating(30, 60) 'Needs Improvement'","solution":"def diving_rating(T, A): Determines the rating for Charles's dive based on his technical (T) and artistic (A) scores. Arguments: T -- technical score (0 <= T <= 100) A -- artistic score (0 <= A <= 100) Returns: A string representing the rating (\\"Excellent\\", \\"Good\\", or \\"Needs Improvement\\"). total_score = T + A if total_score > 160: return \\"Excellent\\" elif 120 <= total_score <= 160: return \\"Good\\" else: return \\"Needs Improvement\\""},{"question":"from typing import List def optimal_firefighter_position(m: int, n: int, grid: List[List[int]]) -> int: Find the optimal starting position for a firefighter to minimize the maximum distance to any building. >>> optimal_firefighter_position(3, 3, [[1, 0, 1], [0, 0, 0], [1, 0, 1]]) 2 >>> optimal_firefighter_position(4, 4, [[0, 1, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]]) 2","solution":"from collections import deque def optimal_firefighter_position(m, n, grid): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque() distance = [[-1] * n for _ in range(m)] # Enqueue all buildings into the queue and set their distance to 0 for i in range(m): for j in range(n): if grid[i][j] == 1: queue.append((i, j)) distance[i][j] = 0 # BFS from all buildings while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and distance[nx][ny] == -1: distance[nx][ny] = distance[x][y] + 1 queue.append((nx, ny)) max_distance = 0 for i in range(m): for j in range(n): if grid[i][j] == 0: max_distance = max(max_distance, distance[i][j]) return max_distance"},{"question":"def hasEulerianCircuit(N: int, M: int, Edges: List[List[int]]) -> bool: Determine if a given undirected graph contains an Eulerian circuit. An Eulerian circuit exists if and only if every vertex has an even degree, and all vertices with non-zero degree lie in a single connected component. Parameters: N (int): The number of vertices in the graph. M (int): The number of edges in the graph. Edges (List[List[int]]): The list of edges, where each edge is represented as a list of two integers [u, v]. Returns: bool: True if the graph contains an Eulerian circuit, otherwise False. Examples: >>> hasEulerianCircuit(3, 3, [[1, 2], [2, 3], [3, 1]]) True >>> hasEulerianCircuit(4, 3, [[1, 2], [2, 3], [2, 4]]) False from typing import List def test_eulerian_circuit(): assert hasEulerianCircuit(3, 3, [[1, 2], [2, 3], [3, 1]]) == True def test_no_eulerian_circuit_due_to_odd_degree(): assert hasEulerianCircuit(4, 3, [[1, 2], [2, 3], [2, 4]]) == False def test_no_edges(): assert hasEulerianCircuit(5, 0, []) == True def test_disconnected_graph_with_even_degrees(): assert hasEulerianCircuit(4, 2, [[1, 2], [3, 4]]) == False def test_single_cycle(): assert hasEulerianCircuit(5, 5, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 1]]) == True def test_simple_two_vertex_cycle(): assert hasEulerianCircuit(2, 2, [[1, 2], [2, 1]]) == True","solution":"def hasEulerianCircuit(N, M, Edges): def isConnectedAndNonZeroDegree(): visited = [False] * (N + 1) # Find a vertex with non-zero degree start = -1 for i in range(1, N + 1): if degree[i] > 0: start = i break if start == -1: # No edges in the graph return True # Use DFS to traverse the graph def dfs(v): stack = [v] while stack: node = stack.pop() if not visited[node]: visited[node] = True for neighbor in adj[node]: if not visited[neighbor]: stack.append(neighbor) dfs(start) # Check if all vertices with non-zero degree are visited for i in range(1, N + 1): if degree[i] > 0 and not visited[i]: return False return True degree = [0] * (N + 1) adj = [[] for _ in range(N + 1)] # Construct the graph for u, v in Edges: degree[u] += 1 degree[v] += 1 adj[u].append(v) adj[v].append(u) # Check if all vertices have even degree for i in range(1, N + 1): if degree[i] % 2 != 0: return False # Check if all vertices with non-zero degree are connected if not isConnectedAndNonZeroDegree(): return False return True"},{"question":"def highest_unique_words_paragraph(paragraphs: List[str]) -> int: You are given a large text document containing multiple paragraphs. Your task is to find the paragraph which contains the highest number of unique words. A word is defined as a contiguous sequence of non-space characters and is case-insensitive (i.e., \\"Word\\" and \\"word\\" should be considered the same). Words are separated by spaces, punctuation marks, or line breaks. Write a program that takes the text document as input and outputs the paragraph number (1-based) with the highest number of unique words. If there are multiple paragraphs with the highest number of unique words, output the paragraph that appears first. Args: paragraphs (List[str]): A list of paragraphs as strings. Returns: int: The 1-based index of the paragraph with the highest number of unique words. >>> paragraphs1 = [ ... \\"This is the first paragraph.\\", ... \\"Here is the second paragraph, which is slightly longer than the first.\\", ... \\"The third paragraph is here.\\" ... ] >>> highest_unique_words_paragraph(paragraphs1) 2 >>> paragraphs2 = [ ... \\"Hello, world! This is a test.\\", ... \\"Another test, with more words and even more unique ones.\\" ... ] >>> highest_unique_words_paragraph(paragraphs2) 2","solution":"def highest_unique_words_paragraph(paragraphs): def unique_word_count(paragraph): words = set(word.lower() for word in re.findall(r'bw+b', paragraph)) return len(words) max_unique_words = 0 paragraph_index = 0 for i, paragraph in enumerate(paragraphs): count = unique_word_count(paragraph) if count > max_unique_words: max_unique_words = count paragraph_index = i return paragraph_index + 1 import re def find_paragraph_with_highest_unique_words(): T = int(input().strip()) paragraphs = [input().strip() for _ in range(T)] return highest_unique_words_paragraph(paragraphs)"},{"question":"def max_difference(n: int) -> int: Returns the maximum possible absolute difference between the number of coins Ben and Chris receive when Alex distributes 'n' coins according to the rules. Parameters: n (int): The number of coins Alex has (2 ≤ n ≤ 10^9). Returns: int: The maximum possible absolute difference. >>> max_difference(5) 3 >>> max_difference(2) 0","solution":"def max_difference(n): Returns the maximum possible absolute difference between the number of coins Ben and Chris receive when Alex distributes 'n' coins according to the rules. Parameters: n (int): The number of coins Alex has (2 ≤ n ≤ 10^9). Returns: int: The maximum possible absolute difference. # If Alex has n coins, the most skewed distribution to maximize the difference: # Give one player 1 coin, and the other player (n-1) coins. # The difference would be |1 - (n - 1)| = |1 - n + 1| = |n - 2| max_diff = n - 2 return max_diff"},{"question":"def maximum_minimum_distance(n, guests): Determines the maximum minimum distance between any two guests when seated in a straight line. :param n: Integer, number of seats :param guests: List of strings, guest names :return: Integer, maximum possible minimum distance between any two guests >>> maximum_minimum_distance(5, [\\"Alice\\", \\"Bob\\", \\"Charlie\\"]) 2 >>> maximum_minimum_distance(8, [\\"David\\", \\"Eva\\", \\"Frank\\", \\"Grace\\"]) 2 >>> maximum_minimum_distance(3, [\\"Alice\\", \\"Bob\\"]) 2 >>> maximum_minimum_distance(10, [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eva\\"]) 2 >>> maximum_minimum_distance(9, [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"]) 2 >>> maximum_minimum_distance(6, [\\"Alice\\"]) 5","solution":"def maximum_minimum_distance(n, guests): Determines the maximum minimum distance between any two guests when seated in a straight line. :param n: Integer, number of seats :param guests: List of strings, guest names :return: Integer, maximum possible minimum distance between any two guests def can_seat_with_distance(distance): Helper function to check if guests can be seated with at least 'distance' spaces apart. last_position = -distance count = 0 for i in range(n): if i - last_position >= distance: count += 1 last_position = i if count == len(guests): return True return False # Binary search for the maximum minimum distance. left, right = 1, n - 1 max_distance = 0 while left <= right: mid = (left + right) // 2 if can_seat_with_distance(mid): max_distance = mid left = mid + 1 else: right = mid - 1 return max_distance"},{"question":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Determine the number of unique paths the robot can take to reach the bottom right corner of the grid without colliding with any obstacles. Args: - grid (List[List[int]]): The grid representing the field with obstacles (1s) and free spaces (0s) Returns: - int: The number of unique paths, or 0 if no valid path exists. Example: >>> unique_paths_with_obstacles([ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) 2 >>> unique_paths_with_obstacles([ [0, 1, 0], [0, 1, 0], [0, 0, 0] ]) 1 def find_unique_paths(test_cases: List[List[List[int]]]) -> List[int]: Process multiple test cases and determine the number of unique paths for each grid configuration. Args: - test_cases (List[List[List[int]]]): A list of grid test cases, each represented as a list of lists of integers. Returns: - List[int]: A list of integers representing the number of unique paths for each grid. Example: >>> find_unique_paths([ [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ], [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ] ]) [2, 1] def parse_input(input_str: str) -> List[List[List[int]]]: Parse the input string and generate the list of test case grids. Args: - input_str (str): The input string representing multiple test cases Returns: - List[List[List[int]]]: A list of grid configurations extracted from the input string. Example: >>> parse_input(\\"3 3n0 0 0n0 1 0n0 0 0n3 3n0 1 0n0 1 0n0 0 0n0\\") [ [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ], [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ] ] def main(input_str: str): Main function to process the input and output the results for each test case. Args: - input_str (str): The input string representing multiple test cases","solution":"def unique_paths_with_obstacles(grid): n = len(grid) m = len(grid[0]) if n > 0 else 0 if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 dp = [[0]*m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1] def find_unique_paths(test_cases): results = [] for grid in test_cases: results.append(unique_paths_with_obstacles(grid)) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") i = 0 test_cases = [] while i < len(lines): if lines[i] == '0': break n, m = map(int, lines[i].split()) grid = [list(map(int, lines[i+j+1].split())) for j in range(n)] test_cases.append(grid) i += n + 1 return test_cases def main(input_str): test_cases = parse_input(input_str) results = find_unique_paths(test_cases) for result in results: print(result)"},{"question":"def max_tasks(tasks, T1, T2): Determines the maximum number of non-overlapping tasks that can be completed within the given time window. Args: tasks (List[Tuple[int, int]]): List of tasks with their start and end times. T1 (int): Start of the time window. T2 (int): End of the time window. Returns: int: Maximum number of tasks that can be completed. >>> max_tasks([(1, 3), (2, 5), (6, 9)], 1, 10) 2 >>> max_tasks([(1, 4), (3, 5), (5, 7), (6, 10)], 2, 8) 2 >>> max_tasks([(0, 6), (5, 8), (7, 10), (9, 11), (12, 14)], 0, 15) 3 from solution import max_tasks def test_example1(): tasks = [(1, 3), (2, 5), (6, 9)] assert max_tasks(tasks, 1, 10) == 2 def test_example2(): tasks = [(1, 4), (3, 5), (5, 7), (6, 10)] assert max_tasks(tasks, 2, 8) == 2 def test_example3(): tasks = [(0, 6), (5, 8), (7, 10), (9, 11), (12, 14)] assert max_tasks(tasks, 0, 15) == 3 def test_no_tasks_within_window(): tasks = [(1, 3), (4, 6), (7, 9)] assert max_tasks(tasks, 10, 20) == 0 def test_all_tasks_non_overlapping(): tasks = [(1, 2), (3, 4), (5, 6)] assert max_tasks(tasks, 0, 7) == 3 def test_some_tasks_overlap(): tasks = [(0, 2), (1, 3), (2, 4), (3, 5)] assert max_tasks(tasks, 0, 5) == 2 def test_edge_case_single_task(): tasks = [(0, 3)] assert max_tasks(tasks, 0, 3) == 1 assert max_tasks(tasks, 3, 5) == 0 def test_large_time_window(): tasks = [(i, i+1) for i in range(0, 100000, 2)] assert max_tasks(tasks, 0, 200000) == 50000","solution":"def max_tasks(tasks, T1, T2): Returns the maximum number of non-overlapping tasks that can be completed within the time window [T1, T2]. # Filter tasks to those within the time window filtered_tasks = [task for task in tasks if task[0] >= T1 and task[1] <= T2] # Sort tasks by end time filtered_tasks.sort(key=lambda x: x[1]) count = 0 last_end_time = T1 for start, end in filtered_tasks: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"from typing import List def minimum_steps_to_target(n: int, m: int, sr: int, sc: int, tr: int, tc: int, grid: List[List[int]]) -> int: Determine the shortest path a robot should take to reach a specified target within the warehouse grid. n: int - number of rows in the grid m: int - number of columns in the grid sr: int - starting row position of the robot sc: int - starting column position of the robot tr: int - target row position tc: int - target column position grid: List[List[int]] - 2D list representing the warehouse grid where 0 is a free cell and 1 is an obstacle Return the minimum number of steps the robot should take to reach the target position, or -1 if unreachable. >>> minimum_steps_to_target(5, 5, 0, 0, 4, 4, ... [[0, 0, 0, 0, 0], ... [0, 1, 1, 1, 0], ... [0, 1, 0, 0, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 0, 0]]) 8 >>> minimum_steps_to_target(3, 3, 0, 0, 2, 2, ... [[0, 1, 0], ... [0, 1, 0], ... [0, 1, 0]]) -1 >>> minimum_steps_to_target(3, 3, 1, 1, 1, 1, ... [[0, 0, 0], ... [0, 0, 0], ... [0, 0, 0]]) 0 >>> minimum_steps_to_target(2, 2, 0, 0, 0, 1, ... [[0, 0], ... [0, 1]]) 1","solution":"from collections import deque from typing import List def minimum_steps_to_target(n: int, m: int, sr: int, sc: int, tr: int, tc: int, grid: List[List[int]]) -> int: if sr == tr and sc == tc: return 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(sr, sc, 0)]) # (row, col, steps) visited = set([(sr, sc)]) while queue: r, c, steps = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] == 0: if nr == tr and nc == tc: return steps + 1 queue.append((nr, nc, steps + 1)) visited.add((nr, nc)) return -1"},{"question":"from typing import List def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"abcde\\") 5 >>> length_of_longest_substring(\\"aab\\") 2","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) char_index_map = {} longest = 0 start = 0 for end in range(n): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end longest = max(longest, end - start + 1) return longest"},{"question":"def is_possible_to_traverse(matrix, N, M, S): Determine whether it's possible to traverse the matrix from the top-left corner to the bottom-right corner within the given sum constraint S. Only right and downward movements are allowed. def test_sample_input_1(): matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] N, M, S = 3, 3, 15 assert is_possible_to_traverse(matrix, N, M, S) == \\"YES\\" def test_sample_input_2(): matrix = [ [1, 2], [4, 3] ] N, M, S = 2, 2, 3 assert is_possible_to_traverse(matrix, N, M, S) == \\"NO\\" def test_single_cell_within_constraint(): matrix = [ [5] ] N, M, S = 1, 1, 5 assert is_possible_to_traverse(matrix, N, M, S) == \\"YES\\" def test_single_cell_exceeds_constraint(): matrix = [ [7] ] N, M, S = 1, 1, 5 assert is_possible_to_traverse(matrix, N, M, S) == \\"NO\\" def test_large_matrix_with_possible_path(): matrix = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] N, M, S = 4, 4, 10 assert is_possible_to_traverse(matrix, N, M, S) == \\"YES\\" def test_large_matrix_without_possible_path(): matrix = [ [100, 100, 100], [100, 100, 100], [100, 100, 100] ] N, M, S = 3, 3, 200 assert is_possible_to_traverse(matrix, N, M, S) == \\"NO\\"","solution":"def is_possible_to_traverse(matrix, N, M, S): Determine whether it's possible to traverse the matrix from the top-left corner to the bottom-right corner within the given sum constraint S. Only right and downward movements are allowed. if N == 0 or M == 0: return \\"NO\\" # No path if matrix size is zero. # Initialize a DP table to store the minimum path sum to reach each cell. dp = [[float('inf')] * M for _ in range(N)] dp[0][0] = matrix[0][0] # Starting point. # Fill the DP table for r in range(N): for c in range(M): if r > 0: dp[r][c] = min(dp[r][c], dp[r-1][c] + matrix[r][c]) # Coming from top. if c > 0: dp[r][c] = min(dp[r][c], dp[r][c-1] + matrix[r][c]) # Coming from left. # Check if bottom-right corner is within the sum constraint if dp[N-1][M-1] <= S: return \\"YES\\" else: return \\"NO\\" # Read the input def main(): import sys input = sys.stdin.read data = input().strip().split() N, M, S = int(data[0]), int(data[1]), int(data[2]) matrix = [] pos = 3 for i in range(N): row = list(map(int, data[pos:pos+M])) matrix.append(row) pos += M result = is_possible_to_traverse(matrix, N, M, S) print(result)"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, return a new list such that each element at index \`i\` of the new list is the product of all the numbers in the original list except the one at \`i\`. This function achieves the solution in linear time without using division. >>> product_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_except_self([3, 2, 1]) [2, 3, 6] pass # Test cases to validate the solution def test_product_except_self(): assert product_except_self([1, 2, 3, 4, 5]) == [120, 60, 40, 30, 24] assert product_except_self([3, 2, 1]) == [2, 3, 6] assert product_except_self([2, 3, 4, 5]) == [60, 40, 30, 24] assert product_except_self([1, 2, 0, 4, 5]) == [0, 0, 40, 0, 0] assert product_except_self([0, 0]) == [0, 0] assert product_except_self([42]) == [1] assert product_except_self([-1, -2, -3, -4]) == [-24, -12, -8, -6] def test_large_input(): input_data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] expected_output = [3628800, 1814400, 1209600, 907200, 725760, 604800, 518400, 453600, 403200, 362880] assert product_except_self(input_data) == expected_output def test_all_ones(): input_data = [1, 1, 1, 1, 1] expected_output = [1, 1, 1, 1, 1] assert product_except_self(input_data) == expected_output","solution":"def product_except_self(nums): Given a list of integers, return a new list such that each element at index \`i\` of the new list is the product of all the numbers in the original list except the one at \`i\`. This function achieves the solution in linear time without using division. length = len(nums) # Initialize the answer array to store the result answer = [1] * length # Calculate the product of all the elements to the left of each index left_product = 1 for i in range(length): answer[i] = left_product left_product *= nums[i] # Calculate the product of all the elements to the right of each index right_product = 1 for i in range(length - 1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"def merge_tasks(tasks: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merge overlapping or touching tasks and return the resulting list of tasks. >>> merge_tasks([(1, 3), (2, 4), (5, 7), (6, 8)]) [(1, 4), (5, 8)] >>> merge_tasks([(1, 2), (2, 3), (4, 5)]) [(1, 3), (4, 5)]","solution":"def merge_tasks(tasks): if not tasks: return [] # Sort the tasks by their start times tasks.sort(key=lambda x: x[0]) merged_tasks = [] current_start, current_end = tasks[0] for i in range(1, len(tasks)): start, end = tasks[i] # If the current task overlaps with the previous one, merge them if start <= current_end: current_end = max(current_end, end) else: merged_tasks.append((current_start, current_end)) current_start, current_end = start, end # Don't forget to add the last merged task merged_tasks.append((current_start, current_end)) return merged_tasks"},{"question":"def trap(height): Calculate the total amount of water that can be trapped after it rains. The height parameter is a list of integers representing the amount of water stored in units at different heights. The function returns an integer representing the maximum amount of water that can be trapped within these heights after it rains. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([3, 3, 3, 3, 3]) 0 >>> trap([4]) 0 >>> trap([]) 0","solution":"def trap(height): Calculate the total amount of water that can be trapped after it rains. :param height: List[int] - List of integer heights of each unit :return: int - Total amount of trapped water if not height or len(height) < 3: return 0 n = len(height) left, right = 0, n - 1 left_max, right_max = height[left], height[right] trapped_water = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) trapped_water += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) trapped_water += right_max - height[right] return trapped_water"},{"question":"def can_distribute_even_candies(C: int, G: int) -> str: Determines if C candies can be distributed evenly among G guests such that each guest gets an even number of candies. Args: C (int): Total number of candies. G (int): Total number of guests. Returns: str: \\"YES\\" if candies can be distributed evenly with even number for each guest, otherwise \\"NO\\". >>> can_distribute_even_candies(8, 4) \\"YES\\" >>> can_distribute_even_candies(10, 4) \\"NO\\" from solution import can_distribute_even_candies def test_even_distribution_possible(): assert can_distribute_even_candies(8, 4) == \\"YES\\" assert can_distribute_even_candies(12, 6) == \\"YES\\" def test_even_distribution_not_possible(): assert can_distribute_even_candies(10, 4) == \\"NO\\" assert can_distribute_even_candies(9, 3) == \\"NO\\" def test_edge_cases(): assert can_distribute_even_candies(1000, 100) == \\"YES\\" assert can_distribute_even_candies(999, 100) == \\"NO\\" assert can_distribute_even_candies(1000, 1) == \\"YES\\" assert can_distribute_even_candies(1, 1) == \\"NO\\"","solution":"def can_distribute_even_candies(C, G): Determines if C candies can be distributed evenly among G guests such that each guest gets an even number of candies. Args: C (int): Total number of candies. G (int): Total number of guests. Returns: str: \\"YES\\" if candies can be distributed evenly with even number for each guest, otherwise \\"NO\\". return \\"YES\\" if (C % G == 0) and ((C // G) % 2 == 0) else \\"NO\\""},{"question":"def longest_equal_substring_length(s: str) -> int: Computes the length of the longest substring where the number of 'a's and 'b's are equal. >>> longest_equal_substring_length(\\"abba\\") 4 >>> longest_equal_substring_length(\\"aaaa\\") 0 >>> longest_equal_substring_length(\\"aababab\\") 6 def process_test_cases(test_cases: List[str]) -> List[int]: Processes each test case and returns the results. >>> process_test_cases([\\"abba\\", \\"aaaa\\", \\"aababab\\"]) [4, 0, 6] >>> process_test_cases([\\"aabbab\\", \\"ababab\\", \\"aaabbbab\\"]) [6, 6, 8]","solution":"def longest_equal_substring_length(s): Computes the length of the longest substring where the number of 'a's and 'b's are equal. max_len = 0 n = len(s) balance = {0: -1} # Balance map to store first occurrence of each balance integer count = 0 for i in range(n): if s[i] == 'a': count += 1 else: count -= 1 if count in balance: max_len = max(max_len, i - balance[count]) else: balance[count] = i return max_len def process_test_cases(test_cases): Processes each test case and returns the results. results = [] for s in test_cases: results.append(longest_equal_substring_length(s)) return results"},{"question":"def longest_path(n: int, m: int, grid: List[str]) -> int: Determine the length of the longest path from the top-left corner to the bottom-right corner in a grid while only moving rightwards or downwards, avoiding obstacles. Return -1 if the path is impossible. >>> longest_path(3, 4, [\\"..#.\\", \\"..\\", \\"...#\\"]) == -1 >>> longest_path(4, 4, [\\"..#.\\", \\".#..\\", \\"...#\\", \\"....\\"]) == 6 from typing import List def test_example_1(): n = 3 m = 4 grid = [ \\"..#.\\", \\"..\\", \\"...#\\" ] assert longest_path(n, m, grid) == -1 def test_example_2(): n = 4 m = 4 grid = [ \\"..#.\\", \\".#..\\", \\"...#\\", \\"....\\" ] assert longest_path(n, m, grid) == 6 def test_single_cell_with_no_obstacle(): n = 1 m = 1 grid = [ \\".\\" ] assert longest_path(n, m, grid) == 0 def test_single_cell_with_obstacle(): n = 1 m = 1 grid = [ \\"#\\" ] assert longest_path(n, m, grid) == -1 def test_no_obstacle(): n = 2 m = 2 grid = [ \\"..\\", \\"..\\" ] assert longest_path(n, m, grid) == 2 def test_obstacle_in_path(): n = 2 m = 2 grid = [ \\"..\\", \\".#\\" ] assert longest_path(n, m, grid) == -1 def test_path_around_obstacle(): n = 3 m = 3 grid = [ \\"...\\", \\".#.\\", \\"...\\" ] assert longest_path(n, m, grid) == 4","solution":"def longest_path(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 dp = [[-1] * m for _ in range(n)] dp[0][0] = 0 for i in range(n): for j in range(m): if i == 0 and j == 0: continue if grid[i][j] == '#': dp[i][j] = -1 else: if i > 0 and dp[i-1][j] != -1: dp[i][j] = max(dp[i][j], dp[i-1][j] + 1) if j > 0 and dp[i][j-1] != -1: dp[i][j] = max(dp[i][j], dp[i][j-1] + 1) return dp[n-1][m-1] if dp[n-1][m-1] != -1 else -1"},{"question":"def count_paths(n, m, blocked_cells): Count the number of distinct paths that can be taken to move from the top left to the bottom right corner of the grid. Args: n (int): The number of rows in the grid. m (int): The number of columns in the grid. blocked_cells (List[Tuple[int, int]]): A list of tuples representing the positions of the blocked cells in the grid. Returns: int: The number of distinct paths from the top left to the bottom right corner of the grid, or 0 if no such path exists. Examples: >>> count_paths(3, 3, []) 6 >>> count_paths(2, 2, []) 2 >>> count_paths(3, 3, [(2, 2)]) 2 >>> count_paths(3, 3, [(1, 1)]) 0 >>> count_paths(3, 3, [(3, 3)]) 0","solution":"def count_paths(n, m, blocked_cells): if (n, m) == (1, 1): return 0 if (1, 1) in blocked_cells else 1 blocked_set = set(blocked_cells) if (1, 1) in blocked_set or (n, m) in blocked_set: return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 # Fill the dp array for i in range(n): for j in range(m): if (i + 1, j + 1) in blocked_set: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[n - 1][m - 1]"},{"question":"def canBePalindrome(s: str) -> bool: Given a string consisting of only lowercase letters, determine whether it is a palindrome. A string is considered a palindrome if it reads the same forwards and backwards. However, you can change exactly one character in the string to make it a palindrome. The function returns True if it is possible to modify at most one character to make the string a palindrome. Otherwise, returns False. >>> canBePalindrome(\\"abca\\") True >>> canBePalindrome(\\"abcdef\\") False >>> canBePalindrome(\\"a\\") True >>> canBePalindrome(\\"racecar\\") True >>> canBePalindrome(\\"abccba\\") True","solution":"def canBePalindrome(s: str) -> bool: Returns True if it is possible to modify at most one character to make the string a palindrome. Otherwise, returns False. left, right = 0, len(s) - 1 mismatch_count = 0 while left < right: if s[left] != s[right]: mismatch_count += 1 if mismatch_count > 1: return False left += 1 right -= 1 return True"},{"question":"def min_trucks_required(T: int, P: int, weights: List[int]) -> int: Determine the minimum number of trucks required to transport all packages. Parameters: T: The maximum weight capacity of any truck. P: The number of packages. weights: A list of integers representing the weights of the packages. Returns: int: The minimum number of trucks required to transport all packages. Examples: >>> min_trucks_required(50, 5, [10, 30, 20, 40, 10]) 3 >>> min_trucks_required(10, 4, [5, 5, 5, 5]) 2","solution":"def min_trucks_required(T, P, weights): Returns the minimum number of trucks required to transport all packages. Parameters: T (int): Maximum weight capacity of any truck. P (int): Number of packages. weights (list of int): Weights of the packages. Returns: int: Minimum number of trucks required. weights.sort(reverse=True) trucks = [] for weight in weights: placed = False for i in range(len(trucks)): if trucks[i] + weight <= T: trucks[i] += weight placed = True break if not placed: trucks.append(weight) return len(trucks)"},{"question":"def find_incorrect_substitution(T: int, test_cases: List[Dict[str, Any]]) -> List[str]: Given T test cases with encrypted messages and partial decryption keys, identify the letter with the incorrect substitution. Args: T : int : number of test cases test_cases : list : list of dictionaries containing 'message', 'k', and 'mappings' Returns: list : a list containing the incorrectly substituted letter for each test case pass def process_input_and_find_incorrect_substitution(input_str: str) -> List[str]: Process the input string to parse the test cases and identify the incorrectly substituted letters. Args: input_str : str : multiline string containing the input Returns: list : a list containing the incorrectly substituted letter for each test case pass import pytest def test_simple_case(): input_str = \\"1nifmmpn4nf onm nnm lnp q\\" expected_output = ['i'] assert process_input_and_find_incorrect_substitution(input_str) == expected_output def test_multiple_cases(): input_str = \\"2nifmmpn4nf onm nnm lnp qnhbvwln3nh dnv lnb e\\" expected_output = ['i', 'w'] assert process_input_and_find_incorrect_substitution(input_str) == expected_output def test_single_letter_message(): input_str = \\"1nan0\\" expected_output = ['a'] assert process_input_and_find_incorrect_substitution(input_str) == expected_output def test_no_incorrect_substitution(): input_str = \\"1nabcn3na xnb ync z\\" expected_output = [] assert process_input_and_find_incorrect_substitution(input_str) == expected_output def test_one_correct_substitution(): input_str = \\"1nhellon1nh x\\" expected_output = ['e'] assert process_input_and_find_incorrect_substitution(input_str) == expected_output def test_with_repeated_characters(): input_str = \\"1nhelloln3nh xne ynl z\\" expected_output = ['o'] assert process_input_and_find_incorrect_substitution(input_str) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"def find_incorrect_substitution(T, test_cases): Given T test cases with encrypted messages and partial decryption keys, identify the letter with the incorrect substitution. Args: T : int : number of test cases test_cases : list : list of dictionaries containing 'message', 'k', and 'mappings' Returns: list : a list containing the incorrectly substituted letter for each test case results = [] for case in test_cases: message = case['message'] k = case['k'] mappings = case['mappings'] correct_decryption = {} for enc_letter, dec_letter in mappings: correct_decryption[enc_letter] = dec_letter for char in message: if char not in correct_decryption: results.append(char) break else: decrypted_char = correct_decryption[char] if message.count(char) != len([c for c in message if correct_decryption.get(c) == decrypted_char]): results.append(char) break return results # Function to process input and output def process_input_and_find_incorrect_substitution(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): message = lines[index] k = int(lines[index + 1]) mappings = [] for i in range(k): mappings.append(tuple(lines[index + 2 + i].split())) test_cases.append({'message': message, 'k': k, 'mappings': mappings}) index += 2 + k result = find_incorrect_substitution(T, test_cases) return result"},{"question":"def tsp_dp(cost_matrix): Finds the minimum cost Hamiltonian Cycle (TSP) using dynamic programming with bitmasking. :param cost_matrix: A 2D list representing the cost between each pair of cities. :return: Minimum cost of the Hamiltonian Cycle or -1 if no cycle exists. >>> tsp_dp([ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ]) == 80 >>> tsp_dp([ [0, 20, 30], [20, 0, 10], [30, 10, 0] ]) == 60 >>> tsp_dp([ [0, 2], [2, 0] ]) == 4 def solve_traveling_salesman_problem(T, test_cases): Solves the Traveling Salesman Problem for multiple test cases. :param T: The number of test cases :param test_cases: A list of matrices representing each test case :return: A list of results for each test case >>> solve_traveling_salesman_problem(2, [ [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ], [ [0, 20, 30], [20, 0, 10], [30, 10, 0] ] ]) == [80, 60]","solution":"def tsp_dp(cost_matrix): Finds the minimum cost Hamiltonian Cycle (TSP) using dynamic programming with bitmasking. :param cost_matrix: A 2D list representing the cost between each pair of cities. :return: Minimum cost of the Hamiltonian Cycle or -1 if no cycle exists. N = len(cost_matrix) dp = [[float('inf')] * N for _ in range(1 << N)] # dp[mask][i] will store the minimum cost to reach i with bitmask mask dp[1][0] = 0 # Start journey from city 0 for mask in range(1 << N): for i in range(N): if mask & (1 << i): # If i is in the set represented by mask for j in range(N): if mask & (1 << j) == 0: # If j is not in the set represented by mask new_mask = mask | (1 << j) dp[new_mask][j] = min(dp[new_mask][j], dp[mask][i] + cost_matrix[i][j]) # The minimum cost cycle that returns to the starting city answer = float('inf') for i in range(1, N): answer = min(answer, dp[(1 << N) - 1][i] + cost_matrix[i][0]) return answer if answer != float('inf') else -1 def solve_traveling_salesman_problem(T, test_cases): Solves the Traveling Salesman Problem for multiple test cases. :param T: The number of test cases :param test_cases: A list of matrices representing each test case :return: A list of results for each test case results = [] for case in test_cases: result = tsp_dp(case) results.append(result) return results"},{"question":"class TownManagementSystem: A system to manage houses and roads in a small town, handling various queries efficiently. >>> tm_system = TownManagementSystem(5, 4, [12, 23, 34, 45, 56], [(1, 2), (2, 3), (4, 5), (1, 4)]) >>> tm_system.update_address(3, 29) >>> tm_system.addresses [12, 23, 29, 45, 56] >>> tm_system.check_road(2, 3) YES >>> tm_system.count_houses_in_range(10, 40) 3 def __init__(self, n, m, addresses, roads): self.n = n self.addresses = addresses self.adj_list = {i: [] for i in range(1, n+1)} for u, v in roads: self.adj_list[u].append(v) self.adj_list[v].append(u) def update_address(self, k, x): Update the address of the k-th house to a new address x. pass def check_road(self, y, z): Check if there is a direct road between house y and house z. pass def count_houses_in_range(self, li, ri): Find the number of houses within a given address range [li, ri]. pass # Example usage def main(): n, m = 5, 4 addresses = [12, 23, 34, 45, 56] roads = [(1, 2), (2, 3), (4, 5), (1, 4)] q = 5 queries = [ (1, 3, 29), (2, 2, 3), (3, 10, 40), (3, 35, 50), (2, 1, 4) ] tm_system = TownManagementSystem(n, m, addresses, roads) outputs = [] for query in queries: if query[0] == 1: tm_system.update_address(query[1], query[2]) elif query[0] == 2: if tm_system.check_road(query[1], query[2]): outputs.append(\\"YES\\") else: outputs.append(\\"NO\\") elif query[0] == 3: outputs.append(tm_system.count_houses_in_range(query[1], query[2])) print(outputs) # ['YES', 2, 1, 'NO']","solution":"class TownManagementSystem: def __init__(self, n, m, addresses, roads): self.n = n self.addresses = addresses self.adj_list = {i: [] for i in range(1, n+1)} for u, v in roads: self.adj_list[u].append(v) self.adj_list[v].append(u) def update_address(self, k, x): self.addresses[k-1] = x def check_road(self, y, z): return z in self.adj_list[y] def count_houses_in_range(self, li, ri): return sum(1 for address in self.addresses if li <= address <= ri) # Example usage n, m = 5, 4 addresses = [12, 23, 34, 45, 56] roads = [(1, 2), (2, 3), (4, 5), (1, 4)] q = 5 queries = [ (1, 3, 29), (2, 2, 3), (3, 10, 40), (3, 35, 50), (2, 1, 4) ] tm_system = TownManagementSystem(n, m, addresses, roads) outputs = [] for query in queries: if query[0] == 1: tm_system.update_address(query[1], query[2]) elif query[0] == 2: if tm_system.check_road(query[1], query[2]): outputs.append(\\"YES\\") else: outputs.append(\\"NO\\") elif query[0] == 3: outputs.append(tm_system.count_houses_in_range(query[1], query[2])) print(outputs) # ['YES', 2, 1, 'NO']"},{"question":"def smallest_window_length(s: str) -> int: Find the smallest window length that contains all the distinct characters of the given string at least once. >>> smallest_window_length(\\"aabcbcdbca\\") 4 >>> smallest_window_length(\\"aaab\\") 2 def process_test_cases(t: int, strings: list) -> list: Process multiple test cases and return a list containing the smallest window lengths for each string. >>> process_test_cases(2, [\\"aabcbcdbca\\", \\"aaab\\"]) [4, 2] >>> process_test_cases(1, [\\"a\\"]) [1]","solution":"def smallest_window_length(s: str) -> int: from collections import defaultdict n = len(s) if n == 0: return 0 unique_chars = set(s) num_chars = len(unique_chars) min_length = float('inf') left = 0 char_count = defaultdict(int) distinct_count = 0 for right in range(n): char_count[s[right]] += 1 if char_count[s[right]] == 1: distinct_count += 1 while left <= right and distinct_count == num_chars: current_window_length = right - left + 1 if current_window_length < min_length: min_length = current_window_length char_count[s[left]] -= 1 if char_count[s[left]] == 0: distinct_count -= 1 left += 1 return min_length def process_test_cases(t: int, strings: list) -> list: results = [] for s in strings: results.append(smallest_window_length(s)) return results"},{"question":"def longest_consecutive_char_sequence(n: int, s: str) -> int: Determine the maximum length of a sequence of consecutive identical characters in the string. :param n: The length of the string s. :param s: A string consisting of lowercase English letters. :return: The maximum length of a sequence of consecutive identical characters in the string. Example ------- >>> longest_consecutive_char_sequence(6, \\"aaabbc\\") 3 >>> longest_consecutive_char_sequence(10, \\"bbbccccddd\\") 4 >>> longest_consecutive_char_sequence(5, \\"abcde\\") 1","solution":"def longest_consecutive_char_sequence(n, s): Returns the length of the longest sequence of consecutive identical characters in the given string. :param n: Length of the string s. :param s: Input string consisting of lowercase English letters. :return: Length of the longest sequence of consecutive identical characters. if n == 0: return 0 max_len = 1 current_len = 1 for i in range(1, n): if s[i] == s[i-1]: current_len += 1 if current_len > max_len: max_len = current_len else: current_len = 1 return max_len"},{"question":"from typing import List, Tuple def can_arrange_books(n: int, books: List[Tuple[int, str]]) -> str: Determine if it is possible to arrange books such that no two adjacent books have the same color. >>> can_arrange_books(4, [(1, 'red'), (2, 'blue'), (3, 'red'), (4, 'green')]) 'YES' >>> can_arrange_books(3, [(1, 'red'), (2, 'red'), (3, 'red')]) 'NO'","solution":"from collections import Counter def can_arrange_books(n, books): Determine if it is possible to arrange books such that no two adjacent books have the same color. Parameters: n (int): Number of books. books (List[Tuple[int, str]]): List of books where each book is represented by its height and color. Returns: str: \\"YES\\" if arrangement is possible, \\"NO\\" otherwise. color_count = Counter(color for _, color in books) # Find the most frequent color count max_color_count = max(color_count.values()) # If the most frequent color count is more than half of the books rounded up, # it is impossible to arrange them without having two adjacent books of the same color. if max_color_count > (n + 1) // 2: return \\"NO\\" return \\"YES\\""},{"question":"def usable_laptops(available_laptops, broken_laptops) -> int: Returns the count of usable laptops. A usable laptop is in the list of available laptops and not in the list of broken laptops. >>> usable_laptops([\\"L123\\", \\"L456\\", \\"L789\\"], [\\"L456\\"]) 2 >>> usable_laptops([\\"L1\\", \\"L2\\", \\"L3\\"], [\\"L4\\", \\"L5\\"]) 3 >>> usable_laptops([\\"L101\\", \\"L102\\"], [\\"L101\\", \\"L102\\", \\"L103\\"]) 0 usable = set(available_laptops) - set(broken_laptops) return len(usable)","solution":"def usable_laptops(available_laptops, broken_laptops): Returns the count of usable laptops. A usable laptop is in the list of available laptops and not in the list of broken laptops. usable = set(available_laptops) - set(broken_laptops) return len(usable)"},{"question":"def convert_time(time_str: str) -> str: Converts a time string in the format \\"HH:MM AM/PM\\" to 24-hour format \\"HH:MM\\". >>> convert_time('02:30 PM') '14:30' >>> convert_time('12:45 AM') '00:45'","solution":"def convert_time(time_str): Converts a time string in the format \\"HH:MM AM/PM\\" to 24-hour format \\"HH:MM\\". # Extract the components of the time string time, period = time_str[:-3], time_str[-2:] hours, minutes = map(int, time.split(':')) # Convert hours based on the period if period == 'PM' and hours != 12: hours += 12 elif period == 'AM' and hours == 12: hours = 0 # Format the time in 24-hour format return f\\"{hours:02}:{minutes:02}\\""},{"question":"MOD = 10**9 + 7 def count_valid_arrangements(N): Calculate the number of valid flower arrangements for N flowers. # Implementation to be completed. def flower_arrangements(T, cases): Determine the number of valid arrangements for each test case. Args: T (int): the number of test cases. cases (List[int]): a list containing the number of flowers to be planted for each test case. Returns: List[int]: a list containing the number of valid arrangements for each test case, modulo 10^9 + 7. >>> flower_arrangements(1, [1]) [3] >>> flower_arrangements(1, [2]) [6] >>> flower_arrangements(1, [3]) [12] >>> flower_arrangements(3, [1, 2, 3]) [3, 6, 12] results = [] for N in cases: results.append(count_valid_arrangements(N)) return results","solution":"MOD = 10**9 + 7 def count_valid_arrangements(N): if N == 1: return 3 elif N == 2: return 6 prev_prev = 3 prev = 6 for _ in range(3, N + 1): current = (prev_prev * 2 + prev) % MOD prev_prev, prev = prev, current return prev def flower_arrangements(T, cases): results = [] for N in cases: results.append(count_valid_arrangements(N)) return results"},{"question":"def min_commands_to_remove(n: int, commands: str) -> int: Determine the minimum number of commands to be removed so that the robot returns to the origin (0, 0). Args: n (int): The number of commands. commands (str): A string of commands consisting of 'U', 'D', 'L', 'R' characters. Returns: int: The minimum number of commands to be removed, or -1 if it is impossible. Examples: >>> min_commands_to_remove(6, \\"UUDLRL\\") 2 >>> min_commands_to_remove(4, \\"UDUD\\") 0 >>> min_commands_to_remove(7, \\"UUDDLRL\\") -1","solution":"def min_commands_to_remove(n, commands): x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 if (x + y) % 2 != 0: return -1 return abs(x) + abs(y)"},{"question":"from typing import List, Tuple def find_max_rating_users(M: int, messages: List[Tuple[int, int, int]]) -> List[int]: Given number of message exchanges and each message details (User ID, Message ID, Rating value), find the user ID who rated the maximum number of messages for each of the rating values from 1 to 5. If there is a tie, output the smallest User ID. Args: M : int : number of message exchanges messages : List[Tuple[int, int, int]] : list containing the details of the message exchanges (User ID, Message ID, Rating value) Returns: List[int] : list containing the user IDs who rated the maximum number of messages for each rating value from 1 to 5 >>> find_max_rating_users(8, [(1, 101, 5), (2, 102, 4), (1, 103, 5), (3, 104, 2), (2, 105, 4), (1, 106, 3), (4, 107, 2), (2, 108, 1)]) [2, 3, 1, 2, 1] >>> find_max_rating_users(5, [(1, 101, 1), (1, 102, 2), (1, 103, 3), (1, 104, 4), (1, 105, 5)]) [1, 1, 1, 1, 1] >>> find_max_rating_users(0, []) [\\"No ratings\\", \\"No ratings\\", \\"No ratings\\", \\"No ratings\\", \\"No ratings\\"] >>> find_max_rating_users(6, [(1, 101, 1), (2, 102, 1), (1, 103, 2), (2, 104, 2), (3, 105, 3), (4, 106, 3)]) [1, 1, 3, \\"No ratings\\", \\"No ratings\\"]","solution":"from collections import defaultdict def find_max_rating_users(M, messages): rating_counts = defaultdict(lambda: defaultdict(int)) for user_id, message_id, rating_value in messages: rating_counts[rating_value][user_id] += 1 result = [] for rating_value in range(1, 6): users = rating_counts[rating_value] if users: max_ratings = max(users.values()) max_users = [user for user, count in users.items() if count == max_ratings] result.append(min(max_users)) else: result.append(\\"No ratings\\") return result"},{"question":"def minimum_temperature_adjustments(n: int, temperatures: List[int]) -> int: Returns the minimum number of times Tina needs to adjust the oven's temperature to bake all layers in their given order. :param n: Number of layers (integer) :param temperatures: List of desired baking temperatures for each layer (list of integers) :return: Minimum number of adjustments (integer) >>> minimum_temperature_adjustments(6, [350, 350, 450, 450, 375, 350]) 3 >>> minimum_temperature_adjustments(1, [350]) 0 >>> minimum_temperature_adjustments(3, [300, 300, 300]) 0 >>> minimum_temperature_adjustments(4, [400, 350, 400, 450]) 3 >>> minimum_temperature_adjustments(5, [100, 200, 300, 200, 100]) 4","solution":"def minimum_temperature_adjustments(n, temperatures): Returns the minimum number of times Tina needs to adjust the oven's temperature to bake all layers in their given order. :param n: Number of layers (integer) :param temperatures: List of desired baking temperatures for each layer (list of integers) :return: Minimum number of adjustments (integer) if n <= 1: return 0 adjustments = 0 current_temp = temperatures[0] for temp in temperatures[1:]: if temp != current_temp: adjustments += 1 current_temp = temp return adjustments"},{"question":"def average_temperature(temperatures): Calculates the average temperature from the list of temperatures, rounded to 2 decimal places. Parameters: temperatures (list): A list of temperature readings (real numbers). Returns: float: The average temperature rounded to 2 decimal places. >>> average_temperature([23.5, 18.7, 26.8, 22.1, 19.0]) 22.02 >>> average_temperature([20.0, 20.0, 20.0, 20.0, 20.0]) 20.00 >>> average_temperature([-10.0, 20.0, 30.0, -20.0, 0.0]) 4.00 >>> average_temperature([0.0, 10.0, -10.0, 5.0, -5.0]) 0.00 >>> average_temperature([25.0]) 25.00 >>> average_temperature([]) 0.0","solution":"def average_temperature(temperatures): Calculates the average temperature from the list of temperatures, rounded to 2 decimal places. Parameters: temperatures (list): A list of temperature readings (real numbers). Returns: float: The average temperature rounded to 2 decimal places. if not temperatures: return 0.0 avg_temp = sum(temperatures) / len(temperatures) return round(avg_temp, 2)"},{"question":"def pairs_with_sum_k(A: List[int], K: int) -> List[List[int]]: Returns all pairs of elements in the array A that sum up to the target value K. Each pair is displayed in ascending order, making sure that the same pair is not counted more than once. :param A: List of integers :param K: Target sum value :return: List of pairs [x, y] where x + y = K >>> pairs_with_sum_k([1, 5, 7, -1, 5], 6) [[-1, 7], [1, 5]] >>> pairs_with_sum_k([2, 2, 4, 4], 6) [[2, 4]] >>> pairs_with_sum_k([1, 2, 3, 4, 5], 10) [] >>> pairs_with_sum_k([3, 3, 3, 3], 6) [[3, 3]]","solution":"def pairs_with_sum_k(A, K): Returns all pairs of elements in the array A that sum up to the target value K. Each pair is displayed in ascending order, making sure that the same pair is not counted more than once. :param A: List of integers :param K: Target sum value :return: List of pairs [x, y] where x + y = K A.sort() front, back = 0, len(A) - 1 result = [] while front < back: current_sum = A[front] + A[back] if current_sum == K: result.append([A[front], A[back]]) # Move front up to the next different element while front < back and A[front] == result[-1][0]: front += 1 # Move back down to the next different element while front < back and A[back] == result[-1][1]: back -= 1 elif current_sum < K: front += 1 else: back -= 1 return result"},{"question":"def is_wave_pattern(sequence: List[int]) -> bool: Determine if the given sequence of integers forms a wave pattern. A wave pattern is defined as a sequence that first strictly increases until it reaches a peak, and then strictly decreases. Args: sequence (List[int]): The sequence of integers to check. Returns: bool: True if the sequence forms a wave pattern, False otherwise. Examples: >>> is_wave_pattern([1, 3, 5, 4, 2]) True >>> is_wave_pattern([3, 2, 1]) False >>> is_wave_pattern([1, 2, 3, 4, 5, 4, 3, 2, 1]) True >>> is_wave_pattern([1, 1, 2, 3, 2, 1, 1]) False","solution":"def is_wave_pattern(sequence): if len(sequence) < 2: return False increasing = True peaked = False for i in range(1, len(sequence)): if increasing: if sequence[i] > sequence[i-1]: continue elif sequence[i] == sequence[i-1]: return False else: if i == 1: return False increasing = False peaked = True if not increasing: if sequence[i] < sequence[i-1]: continue else: return False return peaked"},{"question":"def split_cost(n: int, c: int) -> (int, int): Splits the cost of the trip equally among friends and calculates the remainder. Args: n (int): Number of friends. c (int): Total cost of the trip in dollars. Returns: (int, int): Amount each friend needs to pay and the remaining amount. # Example usage: # >>> split_cost(4, 100) # (25, 0) # >>> split_cost(3, 100) # (33, 1) # >>> split_cost(5, 17) # (3, 2) # Your logic to calculate the division and remainder goes here","solution":"def split_cost(n, c): Splits the cost of the trip equally among friends and calculates the remainder. Args: n (int): Number of friends. c (int): Total cost of the trip in dollars. Returns: (int, int): Amount each friend needs to pay and the remaining amount. amount_per_friend = c // n remainder = c % n return amount_per_friend, remainder"},{"question":"def find_palindrome(n): Transform the number by reversing its digits and adding the reversed number to the original, repeating until a palindrome is obtained or return (-1, -1) if not found within 1000 iterations. :param n: Non-negative integer :return: Tuple of (palindrome found, number of steps taken) or (-1, -1) if not found within 1000 iterations >>> find_palindrome(87) (4884, 4) >>> find_palindrome(0) (0, 0) >>> find_palindrome(196) (-1, -1)","solution":"def find_palindrome(n): Transform the number by reversing its digits and adding the reversed number to the original, repeating until a palindrome is obtained or return (-1, -1) if not found within 1000 iterations. :param n: Non-negative integer :return: Tuple of (palindrome found, number of steps taken) or (-1, -1) if not found within 1000 iterations def is_palindrome(num): return str(num) == str(num)[::-1] steps = 0 while steps < 1000: if is_palindrome(n): return (n, steps) reversed_n = int(str(n)[::-1]) n = n + reversed_n steps += 1 return (-1, -1)"},{"question":"from typing import List, Tuple def letter_frequency(s: str) -> List[Tuple[str, int]]: Given a string s, return a list of tuples each containing a letter from the string and its respective frequency in decreasing order of frequency. Ignore non-alphabetic characters and treat uppercase and lowercase letters as the same. >>> letter_frequency(\\"Hello, World!\\") [('l', 3), ('o', 2), ('h', 1), ('e', 1), ('w', 1), ('r', 1), ('d', 1)] >>> letter_frequency(\\"1234!@#%^_^\\") [] >>> letter_frequency(\\"\\") [] >>> letter_frequency(\\"a\\") [('a', 1)] >>> letter_frequency(\\"AaBbCc\\") [('a', 2), ('b', 2), ('c', 2)] >>> letter_frequency(\\"abbccc\\") [('c', 3), ('b', 2), ('a', 1)]","solution":"from collections import Counter def letter_frequency(s): Given a string s, return a list of tuples each containing a letter from the string and its respective frequency in decreasing order of frequency. Ignore non-alphabetic characters and treat uppercase and lowercase letters as the same. # Convert the string to lowercase and filter out non-alphabetic characters filtered_s = ''.join(filter(str.isalpha, s.lower())) # Count frequency of each letter frequency = Counter(filtered_s) # Sort the letters first by frequency (in decreasing order) and then by their order in the string sorted_frequency = sorted(frequency.items(), key=lambda pair: (-pair[1], filtered_s.find(pair[0]))) return sorted_frequency"},{"question":"def power_of_two(n: int) -> int: Returns the nth power of 2 without using the power operator or function. Parameters: n (int): Non-negative integer representing the power to which 2 is to be raised. Returns: int: 2 raised to the power of n. Examples: >>> power_of_two(0) 1 >>> power_of_two(1) 2 >>> power_of_two(3) 8 >>> power_of_two(30) 1073741824 if n < 0: raise ValueError(\\"Input should be a non-negative integer\\")","solution":"def power_of_two(n): Returns the nth power of 2 without using the power operator or function. Parameters: n (int): Non-negative integer representing the power to which 2 is to be raised. Returns: int: 2 raised to the power of n. if n < 0: raise ValueError(\\"Input should be a non-negative integer\\") result = 1 for _ in range(n): result *= 2 return result"},{"question":"def count_prefix_suffix_substrings(S: str) -> int: Given a string S, return the number of distinct non-empty substrings of S that are both a prefix and a suffix. Parameters: S (str): The input string. Returns: int: The count of distinct non-empty substrings that are both prefix and suffix. Examples: >>> count_prefix_suffix_substrings(\\"ababa\\") 3 >>> count_prefix_suffix_substrings(\\"aaaaa\\") 5 >>> count_prefix_suffix_substrings(\\"abcd\\") 1 >>> count_prefix_suffix_substrings(\\"a\\") 1 >>> count_prefix_suffix_substrings(\\"abcdef\\") 1 >>> count_prefix_suffix_substrings(\\"abcabc\\") 2 >>> count_prefix_suffix_substrings(\\"abababab\\") 4 >>> count_prefix_suffix_substrings(\\"abcdefghijklmnopqrstuvwxyz\\") 1","solution":"def count_prefix_suffix_substrings(S): Given a string S, return the number of distinct non-empty substrings of S that are both a prefix and a suffix. Parameters: S (str): The input string. Returns: int: The count of distinct non-empty substrings that are both prefix and suffix. L = len(S) count = 0 for i in range(1, L+1): # Check if the prefix of length i is the same as the suffix of length i if S[:i] == S[-i:]: count += 1 return count"},{"question":"from typing import List, Tuple def longest_contiguous_subarray(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the length of the longest contiguous subarray where all the elements have the same value. Args: test_cases: A list of tuples where each tuple contains: - an integer n representing the length of the array - a list of n integers representing the elements of the array Returns: A list of integers representing the length of the longest contiguous subarray of identical values for each test case. Examples: >>> longest_contiguous_subarray([(5, [1, 2, 2, 3, 3]), (6, [4, 4, 4, 4, 4, 4]), (10, [1, 1, 2, 2, 2, 3, 3, 3, 3, 4])]) [2, 6, 4] >>> longest_contiguous_subarray([(7, [5, 5, 5, 3, 3, 3, 3])]) [4]","solution":"def longest_contiguous_subarray(test_cases): results = [] for case in test_cases: n, array = case max_len = 1 current_len = 1 for i in range(1, n): if array[i] == array[i-1]: current_len += 1 if current_len > max_len: max_len = current_len else: current_len = 1 results.append(max_len) return results"},{"question":"def findKthLargest(nums: List[int], k: int) -> int: Returns the k-th largest unique score in the list 'nums'. If there are fewer than k unique scores, return -1. >>> findKthLargest([4, 5, 1, 4, 3, 2, 5, 2], 3) 3 >>> findKthLargest([7, 7, 7], 2) -1 >>> findKthLargest([4, 2, 2], 3) -1 >>> findKthLargest([10, 9, 8, 10, 7, 8], 1) 10 >>> findKthLargest([-1, 2, 3, 4, -3, -2, 1], 5) -1 >>> findKthLargest([1, 2, 3, 4, 5, 6, 7], 4) 4","solution":"def findKthLargest(nums, k): Returns the k-th largest unique score in the list 'nums'. If there are fewer than k unique scores, return -1. # Generate a set of unique numbers unique_scores = set(nums) # Sort the unique scores in descending order sorted_unique_scores = sorted(unique_scores, reverse=True) # Check if there are fewer than k unique scores if len(sorted_unique_scores) < k: return -1 # Return the k-th largest unique score return sorted_unique_scores[k - 1]"},{"question":"def organize_books_on_shelf(test_cases): Determines if it is possible to sort books in non-decreasing order using at most k swaps for each test case. Args: test_cases (List[Tuple[int, int, List[int]]]): A list of test cases, where each tuple contains: - n (int): Number of books - k (int): Maximum number of swaps allowed - books (List[int]): Identifiers of the books Returns: List[str]: A list of results for each test case - \\"YES\\" or \\"NO\\" Examples: >>> organize_books_on_shelf([(5, 10, [4, 3, 2, 1, 5])]) ['YES'] >>> organize_books_on_shelf([(4, 1, [2, 1, 4, 3])]) ['NO'] >>> organize_books_on_shelf([(4, 5, [4, 3, 2, 1])]) ['YES']","solution":"def is_sortable_in_k_swaps(n, k, books): Determines if the array books can be sorted in non-decreasing order with at most k adjacent swaps. Parameters: - n: int, the number of books. - k: int, the maximum number of swaps allowed. - books: list of int, the identifiers of the books. Returns: - str: \\"YES\\" if it's possible to sort books with at most k swaps, otherwise \\"NO\\". total_swaps = 0 sorted_books = sorted(books) for i in range(n): if books[i] != sorted_books[i]: swap_index = books.index(sorted_books[i]) total_swaps += abs(swap_index - i) if total_swaps > k: return \\"NO\\" books[swap_index], books[i] = books[i], books[swap_index] return \\"YES\\" def organize_books_on_shelf(test_cases): results = [] for case in test_cases: n, k, books = case results.append(is_sortable_in_k_swaps(n, k, books)) return results"},{"question":"def validateUsername(username: str) -> bool: Validates the given username based on the following rules: 1. The username must be between 5 and 20 characters, inclusive. 2. The username can contain only lowercase letters (a-z), digits (0-9), and underscores (_). 3. The username must start with a lowercase letter. >>> validateUsername(\\"cool_user_123\\") True >>> validateUsername(\\"UserCool_123\\") False >>> validateUsername(\\"_underscore\\") False >>> validateUsername(\\"short\\") True","solution":"def validateUsername(username: str) -> bool: Validates the username based on the given rules: 1. The username must be between 5 and 20 characters, inclusive. 2. The username can contain only lowercase letters (a-z), digits (0-9), and underscores (_). 3. The username must start with a lowercase letter. if not (5 <= len(username) <= 20): return False if not username[0].islower(): return False for char in username: if not (char.islower() or char.isdigit() or char == '_'): return False return True"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(list1, list2): Merge the two sorted linked lists into one sorted linked list. Args: list1 (ListNode): Head of the first sorted linked list. list2 (ListNode): Head of the second sorted linked list. Returns: ListNode: Head of the merged sorted linked list. def list_to_linkedlist(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linkedlist_to_list(node): result = [] current = node while current: result.append(current.val) current = current.next return result from solution import ListNode, merge_two_sorted_lists, list_to_linkedlist, linkedlist_to_list def test_example1(): list1 = list_to_linkedlist([1, 2, 4]) list2 = list_to_linkedlist([1, 3, 4]) merged_head = merge_two_sorted_lists(list1, list2) assert linkedlist_to_list(merged_head) == [1, 1, 2, 3, 4, 4] def test_example2(): list1 = list_to_linkedlist([]) list2 = list_to_linkedlist([]) merged_head = merge_two_sorted_lists(list1, list2) assert linkedlist_to_list(merged_head) == [] def test_example3(): list1 = list_to_linkedlist([]) list2 = list_to_linkedlist([0]) merged_head = merge_two_sorted_lists(list1, list2) assert linkedlist_to_list(merged_head) == [0] def test_mixed_values(): list1 = list_to_linkedlist([-3, 0, 2, 7]) list2 = list_to_linkedlist([-5, -3, 1]) merged_head = merge_two_sorted_lists(list1, list2) assert linkedlist_to_list(merged_head) == [-5, -3, -3, 0, 1, 2, 7] def test_one_empty(): list1 = list_to_linkedlist([1, 3, 5]) list2 = list_to_linkedlist([]) merged_head = merge_two_sorted_lists(list1, list2) assert linkedlist_to_list(merged_head) == [1, 3, 5]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(list1, list2): dummy = ListNode() current = dummy while list1 and list2: if list1.val <= list2.val: current.next = list1 list1 = list1.next else: current.next = list2 list2 = list2.next current = current.next if list1: current.next = list1 if list2: current.next = list2 return dummy.next def list_to_linkedlist(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linkedlist_to_list(node): result = [] current = node while current: result.append(current.val) current = current.next return result"},{"question":"def count_beautiful_subsegments(a): Returns the count of beautiful subsegments in the sequence. >>> count_beautiful_subsegments([1, 2, 3]) 6 >>> count_beautiful_subsegments([4, 5, 6]) 6 >>> count_beautiful_subsegments([1, 0, 3]) 5 >>> count_beautiful_subsegments([0, 0, 3]) 3 def count_beautiful_subsegments_multiple_cases(test_cases): Handles multiple test cases and returns the results. >>> count_beautiful_subsegments_multiple_cases([(3, [1, 2, 3]), (3, [4, 5, 6])]) [6, 6] >>> count_beautiful_subsegments_multiple_cases([(3, [1, 0, 3]), (3, [0, 0, 3])]) [5, 3]","solution":"def count_beautiful_subsegments(a): Returns the count of beautiful subsegments in the sequence. n = len(a) total_subsegments = n * (n + 1) // 2 # Total number of subsegments in the array zero_streak = 0 count_non_beautiful = 0 for num in a: if num == 0: zero_streak += 1 else: if zero_streak > 0: count_non_beautiful += zero_streak * (zero_streak + 1) // 2 zero_streak = 0 if zero_streak > 0: count_non_beautiful += zero_streak * (zero_streak + 1) // 2 beautiful_subsegments = total_subsegments - count_non_beautiful return beautiful_subsegments def count_beautiful_subsegments_multiple_cases(test_cases): results = [] for n, a in test_cases: results.append(count_beautiful_subsegments(a)) return results # Main function to read input and process the data def main(): import sys input = sys.stdin.read data = input().split() idx = 0 t = int(data[idx]) idx += 1 test_cases = [] for _ in range(t): n = int(data[idx]) idx += 1 a = list(map(int, data[idx:idx + n])) idx += n test_cases.append((n, a)) results = count_beautiful_subsegments_multiple_cases(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def find_longest_sequences(test_cases): Find the longest sequence of trails with strictly increasing difficulty levels for multiple test cases. Args: test_cases: List of tuples, where each tuple contains: - An integer N: the number of trails - A list of N integers representing the difficulty levels of the trails Returns: A list of integers where each integer represents the length of the longest strictly increasing sequence of trails for each test case. Example: >>> find_longest_sequences([(6, [1, 3, 2, 5, 4, 7]), (5, [5, 3, 4, 8, 6])]) [4, 3] >>> find_longest_sequences([(4, [1, 2, 3, 4])]) [4] >>> find_longest_sequences([(5, [2, 2, 2, 2, 2])]) [1] from bisect import bisect_left def longest_increasing_subsequence(nums): Returns the length of the longest increasing subsequence. if not nums: return 0 lis = [] for num in nums: pos = bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis) from solution import find_longest_sequences def test_find_longest_sequences_basic_cases(): assert find_longest_sequences([(6, [1, 3, 2, 5, 4, 7]), (5, [5, 3, 4, 8, 6])]) == [4, 3] def test_find_longest_sequences_single_trail(): assert find_longest_sequences([(1, [1])]) == [1] def test_find_longest_sequences_increasing_order(): assert find_longest_sequences([(4, [1, 2, 3, 4])]) == [4] def test_find_longest_sequences_decreasing_order(): assert find_longest_sequences([(4, [4, 3, 2, 1])]) == [1] def test_find_longest_sequences_mixed_order(): assert find_longest_sequences([(7, [10, 20, 10, 30, 20, 50, 60])]) == [5] def test_find_longest_sequences_repeated_elements(): assert find_longest_sequences([(5, [2, 2, 2, 2, 2])]) == [1] def test_find_longest_sequences_large_input(): assert find_longest_sequences([(5, [1000000, 999999, 999998, 999997, 999996])]) == [1] assert find_longest_sequences([(5, [1, 2, 3, 4, 5])]) == [5]","solution":"def longest_increasing_subsequence(nums): Returns the length of the longest increasing subsequence. from bisect import bisect_left if not nums: return 0 lis = [] for num in nums: pos = bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis) def find_longest_sequences(test_cases): results = [] for n, difficulties in test_cases: result = longest_increasing_subsequence(difficulties) results.append(result) return results"},{"question":"def are_isomorphic(str1: str, str2: str) -> bool: Determine if two strings are isomorphic. Two strings are isomorphic if the characters in the first string can be replaced to get the second string, while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. Args: str1 (str): First string str2 (str): Second string Returns: bool: True if the strings are isomorphic, False otherwise Examples: >>> are_isomorphic(\\"egg\\", \\"add\\") True >>> are_isomorphic(\\"foo\\", \\"bar\\") False >>> are_isomorphic(\\"paper\\", \\"title\\") True >>> are_isomorphic(\\"aab\\", \\"xyz\\") False","solution":"def are_isomorphic(str1: str, str2: str) -> bool: if len(str1) != len(str2): return False mapping_str1_to_str2 = {} mapping_str2_to_str1 = {} for c1, c2 in zip(str1, str2): if c1 in mapping_str1_to_str2: if mapping_str1_to_str2[c1] != c2: return False else: mapping_str1_to_str2[c1] = c2 if c2 in mapping_str2_to_str1: if mapping_str2_to_str1[c2] != c1: return False else: mapping_str2_to_str1[c2] = c1 return True"},{"question":"from typing import List def maxScoreDifference(nums: List[int]) -> int: Determine the maximum score difference between any two players, where the lower score player must have had a higher rank (appeared earlier in the list). >>> maxScoreDifference([6, 1, 9, 5, 7]) 8 >>> maxScoreDifference([4, 3, 2, 1]) -1 >>> maxScoreDifference([1, 2, 6, 4, 8]) 7 def test_example_1(): nums = [6, 1, 9, 5, 7] assert maxScoreDifference(nums) == 8 def test_example_2(): nums = [4, 3, 2, 1] assert maxScoreDifference(nums) == -1 def test_example_3(): nums = [1, 2, 6, 4, 8] assert maxScoreDifference(nums) == 7 def test_single_pair(): nums = [1, 10] assert maxScoreDifference(nums) == 9 def test_multiple_pairs(): nums = [2, 3, 10, 6, 4, 8, 1] assert maxScoreDifference(nums) == 8 def test_all_equal(): nums = [5, 5, 5, 5] assert maxScoreDifference(nums) == -1 def test_minimum_input_length(): nums = [3, 1] assert maxScoreDifference(nums) == -1 def test_increasing_sequence(): nums = [1, 2, 3, 4, 5, 6] assert maxScoreDifference(nums) == 5 def test_decreasing_sequence(): nums = [6, 5, 4, 3, 2, 1] assert maxScoreDifference(nums) == -1 def test_alternating_sequence(): nums = [1, 3, 2, 5, 4] assert maxScoreDifference(nums) == 4","solution":"from typing import List def maxScoreDifference(nums: List[int]) -> int: if len(nums) < 2: return -1 # if there are fewer than 2 elements, no pair is possible min_score = nums[0] max_diff = -1 for i in range(1, len(nums)): if nums[i] > min_score: max_diff = max(max_diff, nums[i] - min_score) min_score = min(min_score, nums[i]) return max_diff"},{"question":"def minimal_known_planets(n: int, k: int, known_planets: List[Tuple[int, str]]) -> int: Determine the minimal number of planets' characteristics needed initially to predict all planet's characteristics in the array. Args: n (int): The number of planets. k (int): The number of initially known planets' characteristics. known_planets (List[Tuple[int, str]]): A list of tuples where each tuple contains the position of a planet and its characteristic string. Returns: int: The minimal number of planets' characteristics needed initially. >>> minimal_known_planets(4, 1, [(2, \\"ATG\\")]) 1 >>> minimal_known_planets(6, 2, [(1, \\"TTA\\"), (4, \\"AGC\\")]) 2 >>> minimal_known_planets(5, 0, []) 5","solution":"def minimal_known_planets(n, k, known_planets): if k == 0: return n return k # Example usage: # n, k = 4, 1 # known_planets = [(2, \\"ATG\\")] # print(minimal_known_planets(n, k, known_planets)) # Output should be 1"},{"question":"def most_frequent_substring(k: int, S: str) -> str: Determine the most frequent substring of length k in a given string. If there are multiple substrings with the same maximum frequency, return the lexicographically smallest one. >>> most_frequent_substring(3, 'abcabcabc') 'abc' >>> most_frequent_substring(2, 'ababab') 'ab' >>> most_frequent_substring(1, 'aaaaa') 'a' >>> most_frequent_substring(2, 'abcdabc') 'ab' >>> most_frequent_substring(7, 'abcdefg') 'abcdefg' >>> most_frequent_substring(3, 'aaaabbbbcccc') 'aaa'","solution":"from collections import defaultdict def most_frequent_substring(k, S): Returns the most frequent substring of length k in the given string S. If there are multiple substrings with the same maximum frequency, returns the lexicographically smallest one. substring_count = defaultdict(int) # Iterate over the string to count occurrences of each substring of length k for i in range(len(S) - k + 1): substring = S[i:i+k] substring_count[substring] += 1 # Find the most frequent substring max_frequency = 0 most_frequent_substr = \\"\\" for substr, count in substring_count.items(): if count > max_frequency or (count == max_frequency and substr < most_frequent_substr): max_frequency = count most_frequent_substr = substr return most_frequent_substr"},{"question":"def calculate_payroll(wage, hours, threshold, extra_bonus): Calculates the total weekly earnings for an employee based on wage, hours worked, threshold hours for a bonus, and additional per-hour bonus for hours worked beyond the threshold. Parameters: wage (int): The hourly wage of the employee. hours (int): The number of hours the employee worked in the week. threshold (int): The number of hours that must be exceeded to gain the extra bonus. extra_bonus (int): The additional bonus received per hour beyond the threshold. Returns: int: The total weekly earnings for that employee. Examples: >>> calculate_payroll(20, 38, 35, 5) 775 >>> calculate_payroll(15, 40, 40, 10) 600 >>> calculate_payroll(30, 50, 45, 20) 1600","solution":"def calculate_payroll(wage, hours, threshold, extra_bonus): Calculates the total weekly earnings for an employee based on wage, hours worked, threshold hours for a bonus, and additional per-hour bonus for hours worked beyond the threshold. Parameters: wage (int): The hourly wage of the employee. hours (int): The number of hours the employee worked in the week. threshold (int): The number of hours that must be exceeded to gain the extra bonus. extra_bonus (int): The additional bonus received per hour beyond the threshold. Returns: int: The total weekly earnings for that employee. base_pay = wage * hours if hours > threshold: bonus_hours = hours - threshold bonus_pay = bonus_hours * extra_bonus else: bonus_pay = 0 total_pay = base_pay + bonus_pay return total_pay"},{"question":"def min_vendors_to_collect_items(n: int, k: int, vendors: List[List[int]]) -> int: Determine the minimum number of vendors to visit to collect all k items, and minimize the total travel distance if there are multiple solutions. Args: n (int): Number of vendors. k (int): Number of item types. vendors (List[List[int]]): List of vendors with their positions and items sold. Returns: int: Minimum number of vendors to visit. Examples: >>> min_vendors_to_collect_items(5, 3, [ ... [2, 2, 1, 2], ... [6, 1, 1], ... [10, 1, 3], ... [14, 1, 2], ... [18, 2, 2, 3] ... ]) 2 >>> min_vendors_to_collect_items(3, 2, [ ... [0, 1, 1], ... [10, 1, 2], ... [5, 2, 1, 2] ... ]) 1","solution":"def min_vendors_to_collect_items(n, k, vendors): from itertools import combinations # Create a list of vendor data where each element is (position, set of items) vendor_data = [(v[0], set(v[2:])) for v in vendors] def covered_items(vendors_subset): Helper function to get a set of all unique items from the vendors subset. items = set() for vendor in vendors_subset: items.update(vendor[1]) return items # Check all combinations of vendors for num_vendors in range(1, n + 1): # start from 1 vendor to n vendors for subset in combinations(vendor_data, num_vendors): if len(covered_items(subset)) == k: # This subset covers all items. Calculate the travel distance. positions = sorted(v[0] for v in subset) travel_distance = (positions[-1] - positions[0]) return num_vendors return n # If no combination works (though the problem ensures the solution always exists) # This function can now be tested with appropriate test cases."},{"question":"def max_subarray_sum_with_length(array, max_length): Given an array and a maximum length, find the maximum sum of any subarray of at most that length. def process_queries(array, queries): Process a list of queries to find the maximum sum of any subarray of at most a given length. >>> process_queries([1, -2, 3, 4, -5], [1, 2, 5]) == [4, 7, 7] >>> process_queries([-1, -2, -3, -4], [1, 2]) == [-1, -1]","solution":"def max_subarray_sum_with_length(array, max_length): Given an array and a maximum length, find the maximum sum of any subarray of at most that length. n = len(array) dp = [float('-inf')] * (n + 1) result = float('-inf') for i in range(n): current_sum = 0 for j in range(max_length): if i + j >= n: break current_sum += array[i + j] if current_sum > dp[i + j + 1]: dp[i + j + 1] = current_sum for x in dp: if x > result: result = x return result def process_queries(array, queries): results = [] for k in queries: results.append(max_subarray_sum_with_length(array, k)) return results"},{"question":"def sortBookIDs(ids): Sorts the list of book IDs such that even IDs come before odd IDs and relative order of even and odd IDs is maintained. Args: ids (list): The list of book IDs. Returns: list: The sorted list of book IDs. >>> sortBookIDs([3, 8, 5, 6, 12, 7]) [8, 6, 12, 3, 5, 7] >>> sortBookIDs([11, 2, 7, 4, 25]) [2, 4, 11, 7, 25]","solution":"def sortBookIDs(ids): Sorts the list of book IDs such that even IDs come before odd IDs and relative order of even and odd IDs is maintained. Args: ids (list): The list of book IDs. Returns: list: The sorted list of book IDs. evens = [id for id in ids if id % 2 == 0] odds = [id for id in ids if id % 2 != 0] return evens + odds"},{"question":"import heapq from typing import List, Tuple def shortest_delay(N: int, M: int, S: int, T: int, K: int, links: List[Tuple[int, int, int]]) -> int: Calculate the shortest possible delay to send data from a given server S to another server T, without using any link delay that exceeds the threshold K. Args: N (int): Number of servers. M (int): Number of communication links. S (int): Source server. T (int): Target server. K (int): Threshold for link delays. links (List[Tuple[int, int, int]]): List of tuples representing the links with delays (A_i, B_i, D_i). Returns: int: The shortest delay from S to T considering the threshold, or -1 if it's not possible. Example: >>> shortest_delay(4, 5, 1, 4, 3, [(1, 2, 2), (2, 3, 1), (3, 4, 2), (1, 3, 5), (2, 4, 4)]) 5 >>> shortest_delay(4, 5, 1, 4, 2, [(1, 2, 3), (2, 3, 3), (3, 4, 3), (1, 3, 5), (2, 4, 4)]) -1 pass from solution import shortest_delay def test_shortest_delay_example(): N, M, S, T, K = 4, 5, 1, 4, 3 links = [ (1, 2, 2), (2, 3, 1), (3, 4, 2), (1, 3, 5), (2, 4, 4) ] assert shortest_delay(N, M, S, T, K, links) == 5 def test_shortest_delay_no_path(): N, M, S, T, K = 4, 5, 1, 4, 2 links = [ (1, 2, 3), (2, 3, 3), (3, 4, 3), (1, 3, 5), (2, 4, 4) ] assert shortest_delay(N, M, S, T, K, links) == -1 def test_shortest_delay_direct_path(): N, M, S, T, K = 5, 6, 1, 5, 10 links = [ (1, 2, 1), (2, 3, 1), (3, 5, 5), (1, 4, 2), (4, 5, 1), (2, 5, 10) ] assert shortest_delay(N, M, S, T, K, links) == 3 def test_shortest_delay_threshold_at_limit(): N, M, S, T, K = 3, 3, 1, 3, 5 links = [ (1, 2, 5), (2, 3, 1), (1, 3, 10) ] assert shortest_delay(N, M, S, T, K, links) == 6 def test_shortest_delay_multiple_paths(): N, M, S, T, K = 5, 7, 1, 5, 7 links = [ (1, 2, 5), (2, 3, 2), (3, 5, 1), (1, 3, 15), (1, 4, 2), (4, 3, 3), (4, 5, 4) ] assert shortest_delay(N, M, S, T, K, links) == 6","solution":"import heapq def shortest_delay(N, M, S, T, K, links): graph = {i: [] for i in range(1, N + 1)} for A, B, D in links: if D <= K: graph[A].append((D, B)) # Dijkstra's algorithm to find the shortest path from S to T pq = [(0, S)] dist = {i: float('inf') for i in range(1, N + 1)} dist[S] = 0 while pq: current_delay, node = heapq.heappop(pq) if node == T: return current_delay for delay, neighbor in graph[node]: new_delay = current_delay + delay if new_delay < dist[neighbor]: dist[neighbor] = new_delay heapq.heappush(pq, (new_delay, neighbor)) return -1 def parse_input(): import sys input = sys.stdin.read data = input().splitlines() N, M, S, T, K = map(int, data[0].split()) links = [tuple(map(int, line.split())) for line in data[1:]] return N, M, S, T, K, links if __name__ == \\"__main__\\": N, M, S, T, K, links = parse_input() result = shortest_delay(N, M, S, T, K, links) print(result)"},{"question":"class PerfectNumber: @staticmethod def is_perfect(n: int) -> bool: Check if n is a perfect number. >>> PerfectNumber.is_perfect(6) True >>> PerfectNumber.is_perfect(28) True >>> PerfectNumber.is_perfect(10) False @staticmethod def get_next_perfect(n: int) -> int: Return the next perfect number greater than n. >>> PerfectNumber.get_next_perfect(6) 28 >>> PerfectNumber.get_next_perfect(28) 496 @staticmethod def get_perfect_series(count: int, start: int = 1) -> list: Return a list of \`count\` perfect numbers, starting from the next perfect number greater than or equal to \`start\`. >>> PerfectNumber.get_perfect_series(3) [6, 28, 496] >>> PerfectNumber.get_perfect_series(2, 28) [28, 496] # Unit Tests def test_is_perfect_true(): assert PerfectNumber.is_perfect(6) == True assert PerfectNumber.is_perfect(28) == True def test_is_perfect_false(): assert PerfectNumber.is_perfect(10) == False assert PerfectNumber.is_perfect(1) == False def test_get_next_perfect(): assert PerfectNumber.get_next_perfect(6) == 28 assert PerfectNumber.get_next_perfect(28) == 496 assert PerfectNumber.get_next_perfect(496) == 8128 def test_get_perfect_series(): assert PerfectNumber.get_perfect_series(3) == [6, 28, 496] assert PerfectNumber.get_perfect_series(2, 28) == [28, 496] assert PerfectNumber.get_perfect_series(1, 496) == [496] def test_get_perfect_series_with_exactly_perfect_start(): assert PerfectNumber.get_perfect_series(1, 6) == [6] assert PerfectNumber.get_perfect_series(2, 6) == [6, 28]","solution":"class PerfectNumber: @staticmethod def is_perfect(n: int) -> bool: if n <= 1: return False divisors_sum = sum(i for i in range(1, n) if n % i == 0) return divisors_sum == n @staticmethod def get_next_perfect(n: int) -> int: num = n + 1 while True: if PerfectNumber.is_perfect(num): return num num += 1 @staticmethod def get_perfect_series(count: int, start: int = 1) -> list: perfect_numbers = [] if PerfectNumber.is_perfect(start): perfect_numbers.append(start) start = start + 1 while len(perfect_numbers) < count: next_perfect = PerfectNumber.get_next_perfect(start - 1) perfect_numbers.append(next_perfect) start = next_perfect + 1 return perfect_numbers"},{"question":"def clean_message(message: str) -> str: Remove redundant commas from a message. >>> clean_message(\\",hello,world,,\\") == \\"hello,world\\" >>> clean_message(\\"welcome,to,,code,,challenge\\") == \\"welcome,to,code,challenge\\" >>> clean_message(\\",,,codewars,,\\") == \\"codewars\\" >>> clean_message(\\"hello\\") == \\"hello\\" >>> clean_message(\\",,,\\") == \\"\\" >>> clean_message(\\"a,b,c\\") == \\"a,b,c\\" >>> clean_message(\\"a,,b\\") == \\"a,b\\" >>> clean_message(\\",,hello,,world,,\\") == \\"hello,world\\" >>> clean_message(\\",a,b,c,\\") == \\"a,b,c\\" >>> clean_message(\\",,,a,,b,,,\\") == \\"a,b\\"","solution":"def clean_message(message): Function to remove redundant commas from the input message. # Remove commas from the start and end of the string message = message.strip(',') # Replace multiple consecutive commas with a single comma while ',,' in message: message = message.replace(',,', ',') return message"},{"question":"def thue_morse_nth_term(n: int) -> int: Returns the nth term of the Thue-Morse sequence. The Thue-Morse sequence is a binary sequence with the following properties: 1. Start with a single \`0\`. 2. In each subsequent step, append the binary complement of the entire sequence obtained so far. Given an integer \`n\`, return the \`n\`th term (0-based indexing) of the Thue-Morse sequence. >>> thue_morse_nth_term(0) -> 0 >>> thue_morse_nth_term(1) -> 1 >>> thue_morse_nth_term(2) -> 1 >>> thue_morse_nth_term(3) -> 0 >>> thue_morse_nth_term(4) -> 1 >>> thue_morse_nth_term(5) -> 0 >>> thue_morse_nth_term(6) -> 0 >>> thue_morse_nth_term(7) -> 1","solution":"def thue_morse_nth_term(n: int) -> int: Returns the nth term of the Thue-Morse sequence. The nth term is determined by the number of 1s in the binary representation of n. If the number of 1s is even, the nth term is 0, otherwise it is 1. # Count the number of 1s in the binary representation of n count_of_1s = bin(n).count('1') # Return 0 if the count is even, otherwise return 1 return 0 if count_of_1s % 2 == 0 else 1"},{"question":"def findClosestSmaller(arr: List[int], N: int) -> List[int]: Given an array of N integers, you need to find the closest smaller or equal element for each element of the array. Specifically, for each element in the array, you must find the closest element to its left which is smaller than or equal to it. If no such element exists for a position, fill with -1. >>> findClosestSmaller([1, 3, 0, 2, 5], 5) [-1, 1, -1, 0, 2] >>> findClosestSmaller([2, 4, 3, 5], 4) [-1, 2, 2, 3] >>> findClosestSmaller([1, 1, 1, 1], 4) [-1, 1, 1, 1] >>> findClosestSmaller([4, 3, 2, 1], 4) [-1, -1, -1, -1] >>> findClosestSmaller([1, 2, 3, 4], 4) [-1, 1, 2, 3] >>> findClosestSmaller([10], 1) [-1]","solution":"def findClosestSmaller(arr, N): Given an array, returns an array of the closest smaller or equal elements to the left of each element. result = [-1] * N stack = [] for i in range(N): while stack and stack[-1] > arr[i]: stack.pop() if stack: result[i] = stack[-1] stack.append(arr[i]) return result"},{"question":"def find_min_energy_frequencies(M: int, N: int, energy_frequencies: list[int]) -> int: Finds the minimum number of energy frequencies required to travel from planet 1 to planet M. Parameters: M (int): The number of planets. N (int): The number of unique energy frequencies. energy_frequencies (list of int): The list of energy frequencies. Returns: int: Minimum number of energy frequencies required. >>> find_min_energy_frequencies(4, 3, [1, 2, 3]) 2 >>> find_min_energy_frequencies(9, 4, [1, 2, 3, 4]) 4 >>> find_min_energy_frequencies(1, 1, [1]) 0 >>> find_min_energy_frequencies(16, 5, [1, 2, 3, 4, 5]) 6","solution":"def find_min_energy_frequencies(M, N, energy_frequencies): Finds the minimum number of energy frequencies required to travel from planet 1 to planet M. Parameters: M (int): The number of planets. N (int): The number of unique energy frequencies. energy_frequencies (list of int): The list of energy frequencies. Returns: int: Minimum number of energy frequencies required. # Since planets are indexed from 1 to M, the grid is sqrt(M) x sqrt(M) import math grid_size = int(math.sqrt(M)) if grid_size * grid_size != M: raise ValueError(\\"Invalid grid configuration for given M\\") # Minimum energy frequencies needed to travel from 1 to M is the number # of moves required in that grid from top-left to bottom-right return (grid_size - 1) * 2 # Example usage: M = 4 N = 3 energy_frequencies = [1, 2, 3] print(find_min_energy_frequencies(M, N, energy_frequencies)) # Output should be 2"},{"question":"from typing import List, Tuple def areIsomorphic(N: int, M: int, G1_edges: List[Tuple[int, int, int]], G2_edges: List[Tuple[int, int, int]]) -> bool: Determines whether two directed graphs G1 and G2 are isomorphic. >>> areIsomorphic(4, 5, [(0, 1, 10), (1, 2, 20), (2, 3, 30), (3, 0, 40), (0, 2, 50)], [(3, 2, 30), (2, 1, 20), (1, 0, 10), (0, 3, 40), (0, 2, 50)]) == True >>> areIsomorphic(3, 3, [(0, 1, 5), (1, 2, 10), (2, 0, 15)], [(0, 1, 5), (1, 2, 10), (2, 0, 20)]) == False >>> areIsomorphic(1, 0, [], []) == True >>> areIsomorphic(2, 1, [(0, 1, 10)], [(1, 0, 10)]) == True","solution":"from collections import defaultdict def areIsomorphic(N, M, G1_edges, G2_edges): def build_adj_list(N, edges): adjacency = defaultdict(list) for u, v, w in edges: adjacency[u].append((v, w)) adjacency[v].append((u, w)) return {node: sorted(neighbors) for node, neighbors in adjacency.items()} G1_adj = build_adj_list(N, G1_edges) G2_adj = build_adj_list(N, G2_edges) G1_sorted = sorted(G1_adj.items()) G2_sorted = sorted(G2_adj.items()) return G1_sorted == G2_sorted"},{"question":"def reorder_tasks(n: int, priorities: List[int]) -> List[int]: Returns the reordered list of task priorities Jackson will follow for the day, sorted in descending order of their priority values. Args: n: int - the number of tasks priorities: list of int - the priorities of tasks Returns: list of int - reordered list of task priorities Examples: >>> reorder_tasks(5, [1, 3, 5, 2, 4]) [5, 4, 3, 2, 1] >>> reorder_tasks(4, [10, 20, 30, 25]) [30, 25, 20, 10]","solution":"def reorder_tasks(n, priorities): Returns the reordered list of task priorities Jackson will follow for the day, sorted in descending order of their priority values. Args: n: int - the number of tasks priorities: list of int - the priorities of tasks Returns: list of int - reordered list of task priorities return sorted(priorities, reverse=True) # Example usage: # print(reorder_tasks(5, [1, 3, 5, 2, 4])) # Output: [5, 4, 3, 2, 1] # print(reorder_tasks(4, [10, 20, 30, 25])) # Output: [30, 25, 20, 10]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root): Returns the maximum path sum of a binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> maxPathSum(root) 6 >>> root = TreeNode(-10) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> maxPathSum(root) 42 # Your code here","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root): Returns the maximum path sum of a binary tree. max_sum = float('-inf') def helper(node): nonlocal max_sum if not node: return 0 # Recur for left and right subtree left = max(helper(node.left), 0) # We only add positive contributions right = max(helper(node.right), 0) # We only add positive contributions # Compute the path value that passes through the node current_sum = node.val + left + right # Update global max_sum if current_sum is greater max_sum = max(max_sum, current_sum) # Return the value for parent function call return node.val + max(left, right) helper(root) return max_sum"},{"question":"def manage_marathon(participants_info: List[str], operations: List[str]) -> List[List[Tuple[str, float]]]: Manage the marathon participants and their race times. Arguments: participants_info -- a list of strings, each containing a participant identifier and initial time operations -- a list of strings representing the operations to be performed on the participants Returns: A list of lists containing participants' identifiers and their best times, sorted by times (and lexicographically by identifiers if times are equal). >>> manage_marathon([\\"alice 360.5\\", \\"bob 359.3\\", \\"charlie 360.5\\"], [\\"RANKING\\"]) [[('bob', 359.3), ('alice', 360.5), ('charlie', 360.5)]] >>> manage_marathon([\\"alice 360.5\\", \\"bob 359.3\\", \\"charlie 360.5\\"], [\\"UPDATE bob 358.2\\", \\"UPDATE alice 358.2\\", \\"RANKING\\", \\"UPDATE charlie 357.9\\", \\"RANKING\\"]) [[('alice', 358.2), ('bob', 358.2), ('charlie', 360.5)], [('charlie', 357.9), ('alice', 358.2), ('bob', 358.2)]] >>> manage_marathon([\\"alice 360.5\\", \\"bob 359.3\\", \\"charlie 360.5\\"], [\\"UPDATE alice 361.0\\", \\"RANKING\\"]) [[('bob', 359.3), ('alice', 360.5), ('charlie', 360.5)]] >>> manage_marathon([\\"alice 360.5\\", \\"bob 360.5\\", \\"charlie 360.5\\"], [\\"RANKING\\"]) [[('alice', 360.5), ('bob', 360.5), ('charlie', 360.5)]]","solution":"def manage_marathon(participants_info, operations): participants = {} # Record initial data for info in participants_info: identifier, time = info.split() participants[identifier] = float(time) results = [] # Process operations for operation in operations: if operation.startswith(\\"UPDATE\\"): _, identifier, new_time = operation.split() participants[identifier] = min(participants[identifier], float(new_time)) elif operation == \\"RANKING\\": ranking = sorted(participants.items(), key=lambda x: (x[1], x[0])) results.append([(ident, time) for ident, time in ranking]) return results"},{"question":"def has_revisited_position(positions): Returns True if any position is revisited in the given list of positions. :param positions: List of tuples, where each tuple contains two floats (latitude, longitude). :return: Boolean, True if a position is revisited, False otherwise. Examples: >>> has_revisited_position([(40.712776, -74.005974), (34.052235, -118.243683), (40.712776, -74.005974), (51.507351, -0.127758)]) True >>> has_revisited_position([(37.774929, -122.419416), (34.052235, -118.243683), (51.507351, -0.127758), (48.856614, 2.352222)]) False","solution":"def has_revisited_position(positions): Returns True if any position is revisited in the given list of positions. :param positions: List of tuples, where each tuple contains two floats (latitude, longitude). :return: Boolean, True if a position is revisited, False otherwise. visited_positions = set() for position in positions: if position in visited_positions: return True visited_positions.add(position) return False # Example usage: # print(has_revisited_position([(40.712776, -74.005974), (34.052235, -118.243683), (40.712776, -74.005974), (51.507351, -0.127758)])) # True # print(has_revisited_position([(37.774929, -122.419416), (34.052235, -118.243683), (51.507351, -0.127758), (48.856614, 2.352222)])) # False"},{"question":"def count_ways_to_remove(N, X, Y): Returns the number of ways Alice and Bob can remove the elements such that they form the sequence [X, Y] in the order of their removal. >>> count_ways_to_remove(5, 3, 4) 1 >>> count_ways_to_remove(5, 3, 3) 0 >>> count_ways_to_remove(5, 6, 3) 0 >>> count_ways_to_remove(5, 3, 6) 0 >>> count_ways_to_remove(2000, 1, 2000) 1 >>> count_ways_to_remove(2, 1, 2) 1 >>> count_ways_to_remove(2, 2, 1) 1 >>> count_ways_to_remove(5, 6, 6) 0 >>> count_ways_to_remove(5, -1, 3) 0","solution":"def count_ways_to_remove(N, X, Y): Returns the number of ways Alice and Bob can remove the elements such that they form the sequence [X, Y] in the order of their removal. # Alice removes X and Bob removes Y: # There is only one way to do this if N is valid since the numbers have to be distinct and follow [X, Y]. return 1 if X != Y and 1 <= X <= N and 1 <= Y <= N else 0"},{"question":"def categorize_strings(T: int, strings: List[str]) -> List[str]: Categorize each complaint or feedback string as polite or rude. A polite string is one in which no word appears more than once. A rude string is one which contains at least one repeated word. Args: T (int): The number of test cases. strings (List[str]): A list of strings, each containing a complaint or feedback. Returns: List[str]: A list of results where \\"POLITE\\" indicates a polite string and \\"RUDE\\" indicates a rude string. >>> categorize_strings(4, [\\"this is a good day\\", \\"be kind to others\\", \\"this is is rude\\", \\"politeness is important in service\\"]) [\\"POLITE\\", \\"POLITE\\", \\"RUDE\\", \\"POLITE\\"] >>> categorize_strings(3, [\\"hello world\\", \\"unique words here\\", \\"every word is different\\"]) [\\"POLITE\\", \\"POLITE\\", \\"POLITE\\"]","solution":"def categorize_strings(T, strings): results = [] for S in strings: words = S.split() if len(words) == len(set(words)): results.append(\\"POLITE\\") else: results.append(\\"RUDE\\") return results"},{"question":"class MultiSet: def __init__(self): Initializes an empty multiset. self.data = [] def insert(self, x): Insert element x into the multiset. Args: x (int): The element to insert. def remove(self, x): Remove one occurrence of element x from the multiset if it exists. Args: x (int): The element to remove. def get_median(self): Return the median of the multiset. Returns: int: The median of the multiset. Raises: ValueError: If the multiset is empty. def process_operations(operations): Processes a list of operations on the multiset. Args: operations (List[str]): A list of strings specifying the operations. Returns: List[int]: The result of each get_median operation. ms = MultiSet() result = [] for operation in operations: parts = operation.split() cmd = parts[0] if cmd == 'insert': ms.insert(int(parts[1])) elif cmd == 'remove': ms.remove(int(parts[1])) elif cmd == 'get_median': result.append(ms.get_median()) return result","solution":"import bisect class MultiSet: def __init__(self): self.data = [] def insert(self, x): bisect.insort(self.data, x) def remove(self, x): idx = bisect.bisect_left(self.data, x) if idx < len(self.data) and self.data[idx] == x: self.data.pop(idx) def get_median(self): n = len(self.data) if n == 0: raise ValueError(\\"The multiset is empty\\") if n % 2 == 1: return self.data[n // 2] else: return self.data[n // 2 - 1] def process_operations(operations): ms = MultiSet() result = [] for operation in operations: parts = operation.split() cmd = parts[0] if cmd == 'insert': ms.insert(int(parts[1])) elif cmd == 'remove': ms.remove(int(parts[1])) elif cmd == 'get_median': result.append(ms.get_median()) return result"},{"question":"def is_palindrome(s): This function checks if the provided string s is a palindrome, ignoring spaces and case differences. >>> is_palindrome(\\"A man a plan a canal Panama\\") True >>> is_palindrome(\\"No lemon no melon\\") True >>> is_palindrome(\\"Hello World\\") False >>> is_palindrome(\\"RaceCar\\") True >>> is_palindrome(\\"Was it a car or a cat I saw\\") True def palindrome_game(T, cases): This function processes multiple test cases to check if each is a palindrome. >>> palindrome_game(3, [\\"A man a plan a canal Panama\\", \\"No lemon no melon\\", \\"Step on no pets\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> palindrome_game(2, [\\"Hello World\\", \\"RaceCar\\"]) [\\"NO\\", \\"YES\\"] >>> palindrome_game(4, [\\"Was it a car or a cat I saw\\", \\"step on no pets\\", \\"no lemon no melon\\", \\"not a palindrome\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def is_palindrome(s): This function checks if the provided string s is a palindrome, ignoring spaces and case differences. cleaned_s = ''.join(e.lower() for e in s if e.isalnum()) return cleaned_s == cleaned_s[::-1] def palindrome_game(T, cases): This function processes multiple test cases to check if each is a palindrome. results = [] for s in cases: if is_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def word_lengths(text: str) -> dict: Given a string, returns a dictionary with each word as the key and its length as the value, excluding punctuation. Ignore case while processing the words and maintain the original case in the output dictionary. >>> word_lengths(\\"Hello world!\\") == {\\"Hello\\": 5, \\"world\\": 5} >>> word_lengths(\\"Coding is fun, isn't it?\\") == {\\"Coding\\": 6, \\"is\\": 2, \\"fun\\": 3, \\"isn't\\": 5, \\"it\\": 2}","solution":"import string def word_lengths(text): Returns a dictionary with each word as the key and its length as the value, excluding punctuation. Ignore case while processing the words and maintain the original case in the output dictionary. translator = str.maketrans('', '', string.punctuation) words = text.translate(translator).split() result = {word: len(word) for word in words} return result"},{"question":"def has_equal_sum_subsequence(n: int, arr1: List[int], arr2: List[int]) -> str: Determine if there exists a subsequence from both arrays such that the sum of the subsequence from arr1 is equal to the sum of the subsequence from arr2. Parameters: n (int): The length of the arrays. arr1 (list of int): The first array. arr2 (list of int): The second array. Returns: str: \\"YES\\" if such subsequence exists, otherwise \\"NO\\". >>> has_equal_sum_subsequence(4, [1, 2, 3, 4], [5, 6, 7, 8]) \\"NO\\" >>> has_equal_sum_subsequence(3, [1, 2, 3], [3, 2, 1]) \\"YES\\" >>> has_equal_sum_subsequence(5, [1, 2, 2, 1, 1], [2, 1, 1, 2, 1]) \\"YES\\"","solution":"def has_equal_sum_subsequence(n, arr1, arr2): Determine if there exists a subsequence from both arrays such that the sum of the subsequence from arr1 is equal to the sum of the subsequence from arr2. Parameters: n (int): The length of the arrays. arr1 (list of int): The first array. arr2 (list of int): The second array. Returns: str: \\"YES\\" if such subsequence exists, otherwise \\"NO\\". sum_arr1 = sum(arr1) sum_arr2 = sum(arr2) if sum_arr1 == sum_arr2: return \\"YES\\" else: return \\"NO\\""},{"question":"def word_break(s: str, dictionary: List[str]) -> str: Returns \\"YES\\" if the string can be broken down into a sequence of space-separated words from the dictionary, otherwise returns \\"NO\\". >>> word_break(\\"leetcodeable\\", [\\"leet\\", \\"code\\"]) \\"NO\\" >>> word_break(\\"leetcodecode\\", [\\"leet\\", \\"code\\"]) \\"YES\\" >>> word_break(\\"applepie\\", [\\"apple\\", \\"pie\\", \\"pear\\"]) \\"YES\\" pass from solution import word_break def test_case_1(): assert word_break(\\"leetcodeable\\", [\\"leet\\", \\"code\\"]) == \\"NO\\" def test_case_2(): assert word_break(\\"leetcodecode\\", [\\"leet\\", \\"code\\"]) == \\"YES\\" def test_case_3(): assert word_break(\\"applepie\\", [\\"apple\\", \\"pie\\", \\"pear\\"]) == \\"YES\\" def test_case_4(): assert word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == \\"NO\\" def test_case_5(): assert word_break(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) == \\"YES\\" def test_case_empty_string(): assert word_break(\\"\\", [\\"leet\\", \\"code\\"]) == \\"YES\\" def test_case_no_match(): assert word_break(\\"hello\\", [\\"planet\\", \\"earth\\"]) == \\"NO\\" def test_case_full_string_match(): assert word_break(\\"hello\\", [\\"hello\\"]) == \\"YES\\" def test_case_multiple_matches(): assert word_break(\\"helloworld\\", [\\"hello\\", \\"world\\"]) == \\"YES\\"","solution":"def word_break(s, dictionary): Returns \\"YES\\" if the string can be broken down into a sequence of space-separated words from the dictionary, otherwise returns \\"NO\\". dict_set = set(dictionary) n = len(s) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): for j in range(i): if dp[j] and s[j:i] in dict_set: dp[i] = True break return \\"YES\\" if dp[n] else \\"NO\\""},{"question":"def encode(message: str, shift: int) -> str: Encodes the message by reversing the string and shifting each character in the ASCII table by shift positions. pass def decode(encoded_message: str, shift: int) -> str: Decodes the message by reversing the shifting each character in the ASCII table by shift positions and then reversing the string. pass def process_message(n: int, s: str) -> str: Encodes and then decodes the message to verify the original string is correctly restored. pass def test_simple_message(): assert process_message(3, \\"hello\\") == \\"hello\\" def test_negative_shift(): assert process_message(-3, \\"world\\") == \\"world\\" def test_empty_string(): assert process_message(5, \\"\\") == \\"\\" def test_single_character(): assert process_message(1, \\"a\\") == \\"a\\" def test_large_shift(): assert process_message(100, \\"teststring\\") == \\"teststring\\" def test_special_characters(): assert process_message(2, \\"~!@#\\") == \\"~!@#\\" def test_long_string(): long_string = \\"a\\" * 10000 assert process_message(1, long_string) == long_string","solution":"def encode(message, shift): Encodes the message by reversing the string and shifting each character in the ASCII table by shift positions. Parameters: message (str): The original message to encode. shift (int): The number of positions to shift each character in the ASCII table. Returns: str: The encoded message. reversed_message = message[::-1] encoded_chars = [chr(ord(char) + shift) for char in reversed_message] return ''.join(encoded_chars) def decode(encoded_message, shift): Decodes the message by reversing the shifting each character in the ASCII table by shift positions and then reversing the string. Parameters: encoded_message (str): The encoded message to decode. shift (int): The number of positions each character was originally shifted in the ASCII table. Returns: str: The decoded original message. shifted_back_chars = [chr(ord(char) - shift) for char in encoded_message] decoded_message = ''.join(shifted_back_chars) return decoded_message[::-1] def process_message(n, s): Encodes and then decodes the message to verify the original string is correctly restored. Parameters: n (int): The number of positions each character is shifted in the ASCII table during encoding. s (str): The original string to encode and decode. Returns: str: The original string after encoding and then decoding to verify the process. encoded = encode(s, n) decoded = decode(encoded, n) return decoded"},{"question":"def canFormArithmeticProgression(nums: List[int]) -> bool: Determines if it is possible to form an arithmetic progression with at least 3 elements by removing some (or none) of the elements from the array. :param nums: List[int], the list of integers. :return: bool, True if an arithmetic progression can be formed, False otherwise. pass from solution import canFormArithmeticProgression def test_example_1(): nums = [3, 5, 1, 7, 9] assert canFormArithmeticProgression(nums) == True def test_example_2(): nums = [1, 2, 4, 6] assert canFormArithmeticProgression(nums) == True def test_example_3(): nums = [1, 3, 7, 9] assert canFormArithmeticProgression(nums) == False def test_example_4(): nums = [1, 3] assert canFormArithmeticProgression(nums) == False def test_small_array(): nums = [1, 2, 3] assert canFormArithmeticProgression(nums) == True def test_large_array(): nums = [1, 100, 10000, 1000, 1001] assert canFormArithmeticProgression(nums) == False","solution":"def canFormArithmeticProgression(nums): Determines if it is possible to form an arithmetic progression with at least 3 elements by removing some (or none) of the elements from the array. :param nums: List[int], the list of integers. :return: bool, True if an arithmetic progression can be formed, False otherwise. if len(nums) < 3: return False n = len(nums) nums.sort() for i in range(n): for j in range(i+1, n): d = nums[j] - nums[i] count = 2 last = nums[j] for k in range(j+1, n): if nums[k] - last == d: last = nums[k] count += 1 if count >= 3: return True return False"},{"question":"def min_potions_to_defeat_dragon(H: int, X: int) -> int: Calculate the minimum number of potions required to defeat the dragon. >>> min_potions_to_defeat_dragon(10, 3) 3 >>> min_potions_to_defeat_dragon(1, 1) 1 >>> min_potions_to_defeat_dragon(1, 10) 1 >>> min_potions_to_defeat_dragon(8, 3) 3 >>> min_potions_to_defeat_dragon(10**9, 10**9) 1 # Implement the function to return the minimum number of potions needed","solution":"def min_potions_to_defeat_dragon(H, X): Calculates the minimum number of potions required to defeat the dragon. Parameters: H (int): Initial health of the dragon. X (int): Potency of Potion A. Returns: int: Minimum number of potions required. count = 0 while H > 0: if H // 2 < H - X: # if halving is more effective than subtracting H //= 2 else: H -= X count += 1 return count"},{"question":"def min_operations_to_make_elements_equal(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an array of integers, determine the minimum number of operations required to make all elements in the array identical. In one operation, you can pick any two distinct elements in the array and replace one of them with the value of the other. >>> min_operations_to_make_elements_equal([(4, [1, 2, 3, 4])]) [3] >>> min_operations_to_make_elements_equal([(5, [1, 1, 3, 3, 3])]) [2] >>> min_operations_to_make_elements_equal([(6, [4, 5, 6, 7, 7, 7])]) [3]","solution":"def min_operations_to_make_elements_equal(test_cases): results = [] for case in test_cases: n = case[0] array = case[1] frequency = {} for num in array: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 max_freq = max(frequency.values()) min_operations = n - max_freq results.append(min_operations) return results"},{"question":"def length_of_LIS(clues: List[int]) -> int: Returns the length of the longest increasing subsequence of clue numbers. >>> length_of_LIS([1, 2, 1, 2, 3]) 3 >>> length_of_LIS([5, 1, 2, 6, 3, 4]) 4 >>> length_of_LIS([7, 3, 5, 3]) 2 >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_LIS([]) 0 >>> length_of_LIS([1]) 1 >>> length_of_LIS([5, 7, 4, 8, 1, 6]) 3 pass def process_test_cases(test_cases: List[List[int]]) -> List[int]: Process multiple test cases to find the length of the longest increasing subsequence in each. >>> test_cases = [ ... [1, 2, 1, 2, 3], ... [5, 1, 2, 6, 3, 4], ... [7, 3, 5, 3] ... ] >>> process_test_cases(test_cases) [3, 4, 2] pass","solution":"def length_of_LIS(clues): if not clues: return 0 n = len(clues) dp = [1] * n # dp[i] will be the length of LIS ending at index i for i in range(1, n): for j in range(i): if clues[i] > clues[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def process_test_cases(test_cases): results = [] for clues in test_cases: results.append(length_of_LIS(clues)) return results"},{"question":"def can_form_pyramid(N: int) -> str: Determine if we can form a pyramid with exactly N blocks. :param N: The number of building blocks. :return: \\"YES\\" if we can form a pyramid with exactly N blocks, otherwise \\"NO\\". >>> can_form_pyramid(6) \\"YES\\" >>> can_form_pyramid(7) \\"NO\\" >>> can_form_pyramid(10) \\"YES\\" >>> can_form_pyramid(1) \\"YES\\" >>> can_form_pyramid(2) \\"NO\\" >>> can_form_pyramid(15) \\"YES\\" >>> can_form_pyramid(8) \\"NO\\"","solution":"def can_form_pyramid(N): Determine if we can form a pyramid with exactly N blocks. level = 0 total_blocks = 0 while total_blocks < N: level += 1 total_blocks += level if total_blocks == N: return \\"YES\\" return \\"NO\\""},{"question":"def longest_consecutive_subsequence_length(s: str) -> int: Returns the length of the longest consecutive subsequence of the same character in the string s. >>> longest_consecutive_subsequence_length(\\"aaabbbaaacccdde\\") 3 >>> longest_consecutive_subsequence_length(\\"abcdeeee\\") 4 >>> longest_consecutive_subsequence_length(\\"abbccdddeeeeeeeee\\") 9 pass def process_test_cases(T: int, strings: List[str]) -> List[int]: Processes T test cases and returns a list of results for each string. >>> process_test_cases(3, [\\"aaabbbaaacccdde\\", \\"abcdeeee\\", \\"abbccdddeeeeeeeee\\"]) [3, 4, 9] >>> process_test_cases(2, [\\"a\\", \\"abcd\\"]) [1, 1] >>> process_test_cases(1, [\\"\\"]) [0] >>> process_test_cases(2, [\\"aaa\\", \\"zzzzz\\"]) [3, 5] pass","solution":"def longest_consecutive_subsequence_length(s): Returns the length of the longest consecutive subsequence of the same character in the string s. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length def process_test_cases(T, strings): Processes T test cases and returns a list of results for each string. results = [] for s in strings: results.append(longest_consecutive_subsequence_length(s)) return results"},{"question":"def longest_substring_two_distinct(s: str) -> str: Returns the longest substring that contains at most two distinct characters. >>> longest_substring_two_distinct(\\"eceba\\") \\"ece\\" >>> longest_substring_two_distinct(\\"ccaabbb\\") \\"aabbb\\"","solution":"def longest_substring_two_distinct(s): Returns the longest substring that contains at most two distinct characters. if len(s) == 0: return \\"\\" start, max_len, max_substring = 0, 0, \\"\\" char_map = {} for end, char in enumerate(s): char_map[char] = char_map.get(char, 0) + 1 while len(char_map) > 2: start_char = s[start] char_map[start_char] -= 1 if char_map[start_char] == 0: del char_map[start_char] start += 1 if end - start + 1 > max_len: max_len = end - start + 1 max_substring = s[start:end+1] return max_substring"},{"question":"def calculate_B(A: List[int]) -> List[int]: Given an array A of N integers, create another array B such that B[i] is the sum of all elements in A except A[i], without using the division operation. >>> calculate_B([1, 2, 3, 4, 5]) [14, 13, 12, 11, 10] >>> calculate_B([10]) [0] >>> calculate_B([0, 0, 0, 0]) [0, 0, 0, 0] >>> calculate_B([1, -1, 3, -2]) [0, 2, -2, 3] >>> calculate_B([-1, -2, -3, -4]) [-9, -8, -7, -6] >>> calculate_B([10] * 100000) [999990] * 100000","solution":"def calculate_B(A): Given an array A, this function returns another array B such that B[i] is the sum of all elements in A except A[i]. N = len(A) total_sum = sum(A) B = [total_sum - A[i] for i in range(N)] return B"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def max_sum_path(N: int, Q: int, values: List[int], queries: List[Tuple[int, int]], edges: List[Tuple[int, int]]) -> List[int]: Calculate the maximum sum of values along the simple path from node u to node v. Parameters: N: int : Number of nodes Q: int : Number of queries values: List[int] : Values of the nodes queries: List[Tuple[int, int]] : List of queries edges: List[Tuple[int, int]] : List of edges Returns: List[int] : Result of each query >>> max_sum_path(5, 3, [5, 3, 6, 1, 9], [(1, 3), (4, 2), (1, 5)], [(1, 2), (2, 4), (2, 3), (2, 5)]) == [14, 4, 17] >>> max_sum_path(3, 2, [1, 2, 3], [(1, 3), (2, 3)], [(1, 2), (2, 3)]) == [6, 5] >>> max_sum_path(1, 1, [5], [(1, 1)], []) == [5]","solution":"import sys from collections import defaultdict, deque def max_sum_path(N, Q, values, queries, edges): graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # BFS to find depths and parents depth = [-1] * (N + 1) parent = [-1] * (N + 1) depth[1] = 0 parent[1] = 0 queue = deque([1]) while queue: node = queue.popleft() for neighbor in graph[node]: if depth[neighbor] == -1: # Unvisited depth[neighbor] = depth[node] + 1 parent[neighbor] = node queue.append(neighbor) # Prepare for LCA with binary lifting LOG = max(1, (N).bit_length()) up = [[-1] * (LOG + 1) for _ in range(N + 1)] for i in range(1, N + 1): up[i][0] = parent[i] for j in range(1, LOG + 1): for i in range(1, N + 1): if up[i][j - 1] != -1: up[i][j] = up[up[i][j - 1]][j - 1] def lca(u, v): if depth[u] < depth[v]: u, v = v, u diff = depth[u] - depth[v] for i in range(LOG, -1, -1): if (diff >> i) & 1: u = up[u][i] if u == v: return u for i in range(LOG, -1, -1): if up[u][i] != up[v][i]: u = up[u][i] v = up[v][i] return up[u][0] results = [] for u, v in queries: lca_uv = lca(u, v) path_sum = value_u_v_sum(u, v, lca_uv, values, parent) results.append(path_sum) return results def value_u_v_sum(u, v, lca_uv, values, parent): sum_u = 0 while u != lca_uv: sum_u += values[u-1] u = parent[u] sum_v = 0 while v != lca_uv: sum_v += values[v-1] v = parent[v] sum_lca = values[lca_uv-1] return sum_u + sum_v + sum_lca"},{"question":"def max_potion_duration(potion_data): Determines the maximum total duration of potion effects that can be purchased within the given budget. Parameters: - potion_data: List of tuples where each tuple contains (number of potions, budget, list of potions). Each potion is represented as a tuple (cost, duration). Returns: - List of integers representing the maximum total duration for each dataset.","solution":"def max_potion_duration(potion_data): Determines the maximum total duration of potion effects that can be purchased within the given budget. Parameters: - potion_data: List of tuples where each tuple contains (number of potions, budget, list of potions). Each potion is represented as a tuple (cost, duration). Returns: - List of integers representing the maximum total duration for each dataset. results = [] for data in potion_data: N, B, potions = data if N == 0 and B == 0: break # Sort potions based on cost per duration in ascending order potions.sort(key=lambda x: x[0] / x[1]) total_duration = 0 for cost, duration in potions: if B >= cost: max_potions = B // cost total_duration += max_potions * duration B %= cost # Remaining budget after buying the maximum potions of current type if B <= 0: break results.append(total_duration) return results"},{"question":"def max_sum_subarray_of_size_k(n: int, k: int, arr: List[int]) -> List[int]: Returns the subarray of size k with the maximum sum. In case of ties, returns the first one. >>> max_sum_subarray_of_size_k(8, 3, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) [4, -1, 2] >>> max_sum_subarray_of_size_k(5, 2, [3, 3, -1, 2, 2]) [3, 3] from typing import List def test_case_1(): assert max_sum_subarray_of_size_k(8, 3, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) == [4, -1, 2] def test_case_2(): assert max_sum_subarray_of_size_k(5, 2, [3, 3, -1, 2, 2]) == [3, 3] def test_case_all_positive(): assert max_sum_subarray_of_size_k(6, 3, [1, 2, 3, 4, 5, 6]) == [4, 5, 6] def test_case_all_negative(): assert max_sum_subarray_of_size_k(6, 3, [-6, -5, -4, -3, -2, -1]) == [-3, -2, -1] def test_case_mix(): assert max_sum_subarray_of_size_k(6, 2, [1, -2, 3, 4, -2, 2]) == [3, 4] def test_case_tie(): assert max_sum_subarray_of_size_k(5, 2, [1, 2, 1, 2, 1]) == [1, 2]","solution":"def max_sum_subarray_of_size_k(n, k, arr): Returns the subarray of size k with the maximum sum. In case of ties, returns the first one. max_sum = float('-inf') current_sum = 0 start_index = 0 for i in range(k): current_sum += arr[i] max_sum = current_sum max_start_index = 0 for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum max_start_index = i - k + 1 return arr[max_start_index:max_start_index + k]"},{"question":"def min_moves_to_reach(X: int, Y: int, K: int, blocks: list) -> int: Finds the minimum number of moves required to reach the end point (X, Y) from the starting point (0, 0) on a 2D grid, avoiding K block positions. If it is not possible, returns -1. Args: X (int): X-coordinate of the endpoint. Y (int): Y-coordinate of the endpoint. K (int): Number of blocked positions. blocks (list of tuples): List of blocked positions as (B_x, B_y). Returns: int: Minimum number of moves to reach (X, Y) or -1 if not possible. >>> min_moves_to_reach(2, 3, 0, []) 5 >>> min_moves_to_reach(2, 3, 1, [(1, 2)]) 5 >>> min_moves_to_reach(0, 0, 0, []) 0 >>> min_moves_to_reach(10, 10, 4, [(1, 0), (0, 1), (1, 1), (2, 2)]) -1 >>> min_moves_to_reach(1000, 1000, 0, []) 2000","solution":"from collections import deque def min_moves_to_reach(X, Y, K, blocks): Finds the minimum number of moves required to reach (X, Y) from (0, 0) on a 2D grid, avoiding K block positions. If it is not possible, returns -1. Args: X (int): X-coordinate of the endpoint. Y (int): Y-coordinate of the endpoint. K (int): Number of blocked positions. blocks (list of tuples): List of blocked positions as (B_x, B_y). Returns: int: Minimum number of moves to reach (X, Y) or -1 if not possible. # Directions: right, down, left, up directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # Convert list of blocks into a set for fast lookup block_set = set(blocks) # Queue for BFS: stores (current_x, current_y, distance_from_start) queue = deque([(0, 0, 0)]) # Set to keep track of visited nodes visited = set() visited.add((0, 0)) while queue: current_x, current_y, distance = queue.popleft() # If we have reached the destination, return the distance if current_x == X and current_y == Y: return distance # Explore neighbors for dx, dy in directions: new_x, new_y = current_x + dx, current_y + dy # Check bounds and if the new position is not a block and not visited if 0 <= new_x <= 1000 and 0 <= new_y <= 1000 and (new_x, new_y) not in block_set and (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append((new_x, new_y, distance + 1)) # If the queue is empty and we haven't reached the destination, return -1 return -1"},{"question":"def subarray_with_given_sum(a: List[int], S: int) -> str: Returns 'YES' if there exists a subarray whose sum is exactly S, otherwise returns 'NO'. Args: a (List[int]): The list of integers. S (int): The target sum. Returns: str: 'YES' or 'NO'. Examples: >>> subarray_with_given_sum([1, 2, 3, 7, 5], 12) 'YES' >>> subarray_with_given_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) 'YES' >>> subarray_with_given_sum([1, 2, 3], 7) 'NO' def process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Processes multiple test cases to determine if each contains a subarray with a specified sum. Args: test_cases (List[Tuple[int, int, List[int]]]): A list of test case tuples, each containing: - N (int): The number of integers in the array. - S (int): The target sum. - a (List[int]): The list of integers. Returns: List[str]: A list containing 'YES' or 'NO' for each test case. Example: >>> process_test_cases([(5, 12, [1, 2, 3, 7, 5]), (10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])]) ['YES', 'YES']","solution":"def subarray_with_given_sum(a, S): Returns 'YES' if there exists a subarray whose sum is exactly S, otherwise returns 'NO'. N = len(a) current_sum = 0 sum_dict = {} for i in range(N): current_sum += a[i] if current_sum == S: return \\"YES\\" if (current_sum - S) in sum_dict: return \\"YES\\" sum_dict[current_sum] = i return \\"NO\\" def process_test_cases(test_cases): results = [] for N, S, a in test_cases: results.append(subarray_with_given_sum(a, S)) return results"},{"question":"def find_smallest_subarray_to_remove(n: int, a: List[int]) -> Tuple[int, int]: Determines the smallest continuous subarray that can be removed so that the remaining array is sorted in non-decreasing order. Parameters: n (int): the number of elements in the array a (List[int]): the given array of integers Returns: Tuple[int, int]: 1-based indices of the subarray to be removed pass # Test cases from solution import find_smallest_subarray_to_remove def test_already_sorted(): assert find_smallest_subarray_to_remove(5, [1, 3, 5, 7, 9]) == (1, 1) def test_single_element(): assert find_smallest_subarray_to_remove(1, [5]) == (1, 1) def test_case_1(): assert find_smallest_subarray_to_remove(6, [1, 2, 5, 3, 4, 6]) == (3, 4) def test_case_2(): assert find_smallest_subarray_to_remove(5, [4, 5, 3, 7, 8]) == (2, 3) def test_case_3(): assert find_smallest_subarray_to_remove(6, [1, 2, 3, 6, 5, 4]) == (4, 6) def test_case_4(): assert find_smallest_subarray_to_remove(6, [5, 4, 3, 2, 1, 6]) == (1, 5) def test_case_5(): assert find_smallest_subarray_to_remove(0, []) == (1, 1)","solution":"def find_smallest_subarray_to_remove(n, a): Determines the smallest continuous subarray that can be removed so that the remaining array is sorted in non-decreasing order. Parameters: n (int) - the number of elements in the array a (list of int) - the given array of integers Returns: tuple of (int, int) - 1-based indices of the subarray to be removed l, r = 0, 0 # Check if already sorted if sorted(a) == a: return 1, 1 # Find the first segment that's out of order from the left for i in range(1, n): if a[i] < a[i - 1]: l = i - 1 break # Find the first segment that's out of order from the right for i in range(n - 1, 0, -1): if a[i] < a[i - 1]: r = i break # Check ranges from the two segments while l > 0 and a[l - 1] == a[l]: l -= 1 while r < n - 1 and a[r + 1] == a[r]: r += 1 # Check if removing this segment makes the array sorted if sorted(a[:l] + a[r+1:]) == a[:l] + a[r+1:]: return l + 1, r + 1 return 1, 1"},{"question":"def canPartition(lst: List[int]) -> str: Given a list of n integers, determine whether a list can be split into two sublists with equal sums. The two sublists must solely contain elements from the original list, and every element must be included in exactly one of the two sublists. Return YES if such a split is possible, otherwise return NO. >>> canPartition([1, 5, 11, 5]) 'YES' >>> canPartition([1, 2, 3, 8]) 'NO' from solution import canPartition def test_canPartition_example1(): assert canPartition([1, 5, 11, 5]) == \\"YES\\" def test_canPartition_example2(): assert canPartition([1, 2, 3, 8]) == \\"NO\\" def test_canPartition_single_element(): assert canPartition([1]) == \\"NO\\" def test_canPartition_two_elements_equal(): assert canPartition([2, 2]) == \\"YES\\" def test_canPartition_two_elements_not_equal(): assert canPartition([1, 2]) == \\"NO\\" def test_canPartition_multiple_elements_yes(): assert canPartition([1, 2, 4, 5, 6]) == \\"YES\\" def test_canPartition_multiple_elements_no(): assert canPartition([1, 2, 3, 9]) == \\"NO\\" def test_canPartition_large_equal_elements(): assert canPartition([100, 100, 100, 100]) == \\"YES\\" def test_canPartition_large_odd_sum(): assert canPartition([1, 2, 3, 5, 7, 9]) == \\"NO\\"","solution":"def canPartition(lst): total_sum = sum(lst) # If total sum is odd, it's not possible to split into two equal sums if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 n = len(lst) # Create a DP table where dp[i] will be True if there is a subset of lst[0..i-1] with sum equal to i dp = [False] * (target + 1) dp[0] = True for num in lst: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return \\"YES\\" if dp[target] else \\"NO\\""},{"question":"def count_subnetworks(N: int, M: int, connections: List[Tuple[int, int]]) -> int: Determine the number of sub-networks (connected components) in a network. Args: N: An integer representing the number of devices. M: An integer representing the number of direct connections. connections: A list of tuples representing the direct connections between devices. Returns: An integer representing the number of sub-networks. >>> count_subnetworks(5, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> count_subnetworks(4, 0, []) 4","solution":"def count_subnetworks(N, M, connections): from collections import defaultdict, deque def bfs(node, visited, graph): queue = deque([node]) while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) visited = set() sub_networks = 0 for device in range(1, N + 1): if device not in visited: sub_networks += 1 visited.add(device) bfs(device, visited, graph) return sub_networks"},{"question":"def count_greater_or_equal_numbers(t, test_cases): Returns the count of numbers greater than or equal to X in the sequence for each test case. Parameters: t (int): Number of test cases test_cases (list of tuples): Each tuple contains: - n (int): Length of the sequence - x (int): Alice's chosen integer - sequence (list of int): The sequence of numbers Returns: list of int: Counts of numbers greater than or equal to X for each test case","solution":"def count_greater_or_equal_numbers(t, test_cases): Returns the count of numbers greater than or equal to X in the sequence for each test case. Parameters: t (int): Number of test cases test_cases (list of tuples): Each tuple contains: - n (int): Length of the sequence - x (int): Alice's chosen integer - sequence (list of int): The sequence of numbers Returns: list of int: Counts of numbers greater than or equal to X for each test case res = [] for n, x, sequence in test_cases: count = sum(1 for num in sequence if num >= x) res.append(count) return res"},{"question":"from typing import List def product_of_all_except_self(nums: List[int]) -> List[int]: Returns a new list where each element is replaced by the product of all other elements in the original list except the element at that position. >>> product_of_all_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_of_all_except_self([2, 5, 6]) [30, 12, 10] >>> product_of_all_except_self([10]) [1] >>> product_of_all_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_of_all_except_self([0, 0, 0]) [0, 0, 0] >>> product_of_all_except_self([]) []","solution":"def product_of_all_except_self(nums): Returns a new list where each element is replaced by the product of all other elements in the original list except the element at that position. n = len(nums) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [1] * n left_accumulator = 1 for i in range(n): left_products[i] = left_accumulator left_accumulator *= nums[i] right_accumulator = 1 for i in range(n - 1, -1, -1): right_products[i] = right_accumulator right_accumulator *= nums[i] for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"class TreeNode: def __init__(self): self.children = {} self.parent = None def longest_path_between_leaves(n, edges): Returns the length of the longest path between any two leaves in the tree. >>> longest_path_between_leaves(5, [(1, 2, 3), (1, 3, 4), (3, 4, 2), (2, 5, 6)]) 15 >>> longest_path_between_leaves(1, []) 0 >>> longest_path_between_leaves(2, [(1, 2, 1)]) 1 >>> longest_path_between_leaves(3, [(1, 2, 2), (1, 3, 3)]) 5 >>> longest_path_between_leaves(4, [(1, 2, 3), (2, 3, 4), (3, 4, 5)]) 12 pass def read_input(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) edges = [] for i in range(1, len(data), 3): u = int(data[i]) v = int(data[i + 1]) w = int(data[i + 2]) edges.append((u, v, w)) return n, edges if __name__ == \\"__main__\\": n, edges = read_input() print(longest_path_between_leaves(n, edges))","solution":"class TreeNode: def __init__(self): self.children = {} self.parent = None def longest_path_between_leaves(n, edges): Returns the length of the longest path between any two leaves in the tree. from collections import defaultdict, deque if n == 1: return 0 # Construct the tree tree = defaultdict(TreeNode) for u, v, w in edges: tree[u].children[v] = w tree[v].parent = u tree[v].children[u] = w tree[u].parent = v # Function for DFS to find the longest path def dfs(node, parent): max1, max2 = 0, 0 for child, weight in tree[node].children.items(): if child != parent: child_length = weight + dfs(child, node) if child_length > max1: max1, max2 = child_length, max1 elif child_length > max2: max2 = child_length global_max[0] = max(global_max[0], max1 + max2) return max1 root = next(iter(tree)) global_max = [0] dfs(root, None) return global_max[0] # Function to read input based on the given format def read_input(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) edges = [] for i in range(1, len(data), 3): u = int(data[i]) v = int(data[i + 1]) w = int(data[i + 2]) edges.append((u, v, w)) return n, edges if __name__ == \\"__main__\\": n, edges = read_input() print(longest_path_between_leaves(n, edges))"},{"question":"def total_moves(n, y): Determines the total number of moves in the game between Mia and Noah. :param n: The total number of nodes in the linked list. :param y: The starting node of Noah (1 < y ≤ n). :return: The total number of moves that will be made. pass # Example usage: # >>> total_moves(6, 4) # 8 # >>> total_moves(4, 2) # 2","solution":"def total_moves(n, y): Determines the total number of moves in the game between Mia and Noah. :param n: The total number of nodes in the linked list. :param y: The starting node of Noah (1 < y ≤ n). :return: The total number of moves that will be made. # Mia starts at node 1 # Noah starts at node y # Mia has to make moves to reach Noah starting from node 1 # Noah tries to maintain the maximum distance within the available moves. # The total moves needed is y + (y-1) - 1 total_moves = 2 * (y - 1) return total_moves"},{"question":"def max_sum_path(grid): Calculate the maximum sum of integers collected following the rules: 1. You start at the top-left cell (1, 1). 2. You can move right, down, or diagonally right-down to the next cell. 3. The sum of integers you can collect is the sum of the integers in all the cells you visit from the starting cell to the target cell. Parameters: grid (list of list of int): The input grid Returns: int: The maximum sum of integers collected Example: >>> max_sum_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_sum_path([[1]]) 1 def main(): import sys input = sys.stdin.read data = input().strip().split() R = int(data[0]) C = int(data[1]) grid = [] index = 2 for i in range(R): row = list(map(int, data[index:index + C])) grid.append(row) index += C print(max_sum_path(grid)) if __name__ == \\"__main__\\": main()","solution":"def max_sum_path(grid): R = len(grid) C = len(grid[0]) # Initialize dp array with the same dimensions as the grid dp = [[0] * C for _ in range(R)] # Start from the top-left cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, C): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, R): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, R): for j in range(1, C): dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j] # The answer is in the bottom-right cell return dp[R-1][C-1] def main(): import sys input = sys.stdin.read data = input().strip().split() R = int(data[0]) C = int(data[1]) grid = [] index = 2 for i in range(R): row = list(map(int, data[index:index + C])) grid.append(row) index += C print(max_sum_path(grid)) if __name__ == \\"__main__\\": main()"},{"question":"class DNASequence: def __init__(self, sequence): self.sequence = sequence def is_valid(self): Checks if the DNA sequence is valid (contains only A, C, G, T). pass def reverse_complement(self): Returns the reverse complement of the DNA sequence. pass def nucleotide_count(self): Returns a dictionary with the count of each nucleotide in the sequence. pass","solution":"class DNASequence: def __init__(self, sequence): self.sequence = sequence def is_valid(self): Checks if the DNA sequence is valid (contains only A, C, G, T). return all(nucleotide in 'ACGT' for nucleotide in self.sequence) def reverse_complement(self): Returns the reverse complement of the DNA sequence. complement = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A'} return ''.join(complement[nucleotide] for nucleotide in reversed(self.sequence)) def nucleotide_count(self): Returns a dictionary with the count of each nucleotide in the sequence. return {nucleotide: self.sequence.count(nucleotide) for nucleotide in 'ACGT'}"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number is prime. :param n: Integer to check for primality. :return: True if n is a prime number, False otherwise. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(19) True >>> is_prime(20) False # Your implementation here pass def filter_primes(numbers: List[int]) -> List[int]: Given a list of integers, return a new list containing only the prime numbers. :param numbers: List of integers to filter. :return: List of prime numbers. >>> filter_primes([3, 4, 7, 6, 11, 13, 17, 18, 19]) [3, 7, 11, 13, 17, 19] >>> filter_primes([1, 2, 3, 5, 6, 8]) [2, 3, 5] >>> filter_primes([4, 6, 8, 9, 10]) [] >>> filter_primes([23, 29, 31]) [23, 29, 31] >>> filter_primes([]) [] # Your implementation here pass","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Given a list of integers, return a new list containing only the prime numbers. return [num for num in numbers if is_prime(num)]"},{"question":"class TextEditor: def __init__(self): Initializes the text editor with an empty string. pass def move_left(self): Moves the cursor one character to the left. pass def move_right(self): Moves the cursor one character to the right. pass def insert(self, char): Inserts the given character at the current cursor position. pass def get_text(self): Returns the text in the editor as a string. return \\"\\" # Example Usage: editor = TextEditor() editor.insert('a') editor.insert('b') editor.insert('c') editor.move_left() editor.insert('d') print(editor.get_text()) # Output should be \\"abdc\\"","solution":"class TextEditor: def __init__(self): Initializes the text editor with an empty string. self.left_stack = [] self.right_stack = [] def move_left(self): Moves the cursor one character to the left. if self.left_stack: self.right_stack.append(self.left_stack.pop()) def move_right(self): Moves the cursor one character to the right. if self.right_stack: self.left_stack.append(self.right_stack.pop()) def insert(self, char): Inserts the given character at the current cursor position. self.left_stack.append(char) def get_text(self): Returns the text in the editor as a string. return ''.join(self.left_stack) + ''.join(reversed(self.right_stack))"},{"question":"def has_zero_sum_subarray(n, sequence): Checks whether there exists at least one sub-array with a sum of zero in a given sequence. Args: n (int): The number of elements in the sequence. sequence (List[int]): The sequence of integers. Returns: str: \\"YES\\" if there exists at least one sub-array with a sum of zero, otherwise \\"NO\\". >>> has_zero_sum_subarray(5, [4, 2, -3, 1, 6]) \\"YES\\" >>> has_zero_sum_subarray(4, [1, 2, 3, 4]) \\"NO\\" >>> has_zero_sum_subarray(6, [1, 4, -2, -2, 5, 1]) \\"YES\\" >>> has_zero_sum_subarray(1, [0]) \\"YES\\" >>> has_zero_sum_subarray(1, [5]) \\"NO\\" >>> has_zero_sum_subarray(3, [0, 0, 0]) \\"YES\\" >>> has_zero_sum_subarray(5, [-3, 1, 2, 3, 4]) \\"YES\\" >>> has_zero_sum_subarray(4, [10000, -10000, 5, -5]) \\"YES\\" >>> has_zero_sum_subarray(6, [1, 2, 3, 4, 5, 6]) \\"NO\\"","solution":"def has_zero_sum_subarray(n, sequence): Checks whether there exists at least one sub-array with a sum of zero in a given sequence. Args: n (int): The number of elements in the sequence. sequence (List[int]): The sequence of integers. Returns: str: \\"YES\\" if there exists at least one sub-array with a sum of zero, otherwise \\"NO\\". prefix_sums = set() current_sum = 0 for num in sequence: current_sum += num if current_sum == 0 or current_sum in prefix_sums: return \\"YES\\" prefix_sums.add(current_sum) return \\"NO\\""},{"question":"def maxSubstring(s: str) -> str: Find the lexicographically largest substring of a given string s. Args: s: A string consisting of only lowercase alphabets. Returns: The lexicographically largest substring of the string s. Examples: >>> maxSubstring(\\"ababaa\\") \\"babaa\\" >>> maxSubstring(\\"abc\\") \\"c\\" >>> maxSubstring(\\"a\\") \\"a\\" >>> maxSubstring(\\"zxy\\") \\"zxy\\" >>> maxSubstring(\\"aaaaa\\") \\"aaaaa\\" >>> maxSubstring(\\"aaaaab\\") \\"b\\" >>> maxSubstring(\\"abcdefaaabcd\\") \\"faaabcd\\"","solution":"def maxSubstring(s: str) -> str: Find the lexicographically largest substring of the given string s. max_substr = \\"\\" for i in range(len(s)): if s[i:] > max_substr: max_substr = s[i:] return max_substr"},{"question":"def maxMeetings(N: int, arr: List[List[int]]) -> int: Returns the maximum number of non-overlapping meetings that can be scheduled. >>> maxMeetings(3, [[1, 4], [2, 5], [3, 6]]) 1 >>> maxMeetings(4, [[1, 3], [2, 4], [3, 5], [7, 8]]) 2 from typing import List # Unit Tests def test_example_cases(): assert maxMeetings(3, [[1, 4], [2, 5], [3, 6]]) == 1 assert maxMeetings(4, [[1, 3], [2, 4], [3, 5], [7, 8]]) == 2 def test_single_meeting_case(): assert maxMeetings(1, [[1, 2]]) == 1 def test_no_meeting_overlap(): assert maxMeetings(5, [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]) == 5 def test_all_meetings_overlap(): assert maxMeetings(3, [[1, 10], [2, 9], [3, 8]]) == 1 def test_varied_intervals(): assert maxMeetings(6, [[1, 3], [5, 7], [2, 6], [8, 10], [5, 9], [1, 4]]) == 3","solution":"def maxMeetings(N, arr): Returns the maximum number of non-overlapping meetings that can be scheduled. # Sort intervals based on end time arr.sort(key=lambda x: x[1]) # Initialize the end time of the last chosen meeting last_end_time = float('-inf') count = 0 for start, end in arr: if start > last_end_time: # If the current meeting starts after the last chosen one ends, count it count += 1 last_end_time = end return count"},{"question":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstToDoublyList(root): Function to convert a BST to a sorted doubly linked list in place. >>> create_tree = lambda vals: lambda i=0: Node(vals[i], create_tree(vals[:i]), create_tree(vals[i+1:])) if vals else None >>> linked_list_to_list = lambda head: (ls := [], (lambda cur: (ls.append(cur.val), head:=cur.right)[1] or cur.right and cur.right(cur)) and ls)(head) >>> test_tree1 = create_tree([4, 6, 8, 10, 12, 14, 16]) >>> linked_list_to_list(bstToDoublyList(test_tree1)) [4, 6, 8, 10, 12, 14, 16] >>> test_tree2 = create_tree([1, 2, 3]) >>> linked_list_to_list(bstToDoublyList(test_tree2)) [1, 2, 3]","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstToDoublyList(root): Function to convert a BST to a sorted doubly linked list in place. if not root: return None # Helper function to handle the conversion def convert(node): nonlocal head, prev if not node: return # Recur on the left subtree convert(node.left) # Now handle the current node if prev: prev.right = node node.left = prev else: head = node prev = node # Recur on the right subtree convert(node.right) head, prev = None, None convert(root) return head"},{"question":"def check_spices(available_spices, required_spices): This function checks if all required spices are available. Parameters: available_spices (list of str): List of available spices required_spices (list of str): List of required spices for the dishes Returns: str: Message about the availability of spices >>> check_spices([\\"cumin\\", \\"turmeric\\", \\"coriander\\"], [\\"cumin\\", \\"coriander\\"]) \\"All required spices are available.\\" >>> check_spices([\\"cumin\\", \\"turmeric\\", \\"coriander\\"], [\\"cumin\\", \\"paprika\\", \\"coriander\\"]) \\"Missing spices: paprika\\" >>> check_spices([\\"cumin\\", \\"turmeric\\"], [\\"cayenne\\", \\"cumin\\", \\"turmeric\\", \\"cloves\\"]) \\"Missing spices: cayenne, cloves\\" >>> check_spices([], [\\"chili\\", \\"oregano\\"]) \\"Missing spices: chili, oregano\\"","solution":"def check_spices(available_spices, required_spices): This function checks if all required spices are available. Parameters: available_spices (list of str): List of available spices required_spices (list of str): List of required spices for the dishes Returns: str: Message about the availability of spices missing_spices = [spice for spice in required_spices if spice not in available_spices] if not missing_spices: return \\"All required spices are available.\\" else: return f\\"Missing spices: {', '.join(missing_spices)}\\""},{"question":"def balance_arrays(arr1, arr2): Write a function balance_arrays(arr1, arr2) that takes two lists of integers arr1 and arr2. Determine if you can make arr1 and arr2 identical by swapping at most one integer from arr1 with one integer from arr2. If it's possible, return True; otherwise, return False. If either list is empty, return False. >>> balance_arrays([1, 2, 3], [1, 2, 3]) == True >>> balance_arrays([1, 2, 3], [1, 3, 4]) == True >>> balance_arrays([1, 2, 3], [4, 5, 6]) == False >>> balance_arrays([], [1, 2, 3]) == False >>> balance_arrays([1, 2, 3], [1, 2]) == False >>> balance_arrays([1, 1, 1], [1, 1, 1]) == True >>> balance_arrays([1, 2, 3], [3, 2, 1]) == True >>> balance_arrays([2, 4, 6], [2, 4, 6]) == True","solution":"def balance_arrays(arr1, arr2): Determines if you can make arr1 and arr2 identical by swapping at most one integer from arr1 with one integer from arr2. If it's possible, returns True; otherwise, returns False. If either list is empty, returns False. if not arr1 or not arr2: return False if sorted(arr1) == sorted(arr2): return True sum_arr1 = sum(arr1) sum_arr2 = sum(arr2) target_diff = sum_arr1 - sum_arr2 possible_swaps = set(arr1) for num in arr2: required_num = num + target_diff // 2 if (target_diff % 2 == 0) and (required_num in possible_swaps): return True return False"},{"question":"def sorted_squares(nums): Given a sorted array of integers, returns a sorted array of the squares of each number. >>> sorted_squares([-4, -1, 0, 3, 10]) [0, 1, 9, 16, 100] >>> sorted_squares([-7, -3, 2, 3, 11]) [4, 9, 9, 49, 121]","solution":"def sorted_squares(nums): Given a sorted array of integers, returns a sorted array of the squares of each number. return sorted(x*x for x in nums)"},{"question":"def min_max_height_difference(N, M, matrix): Finds a path from the top-left corner (0, 0) to the bottom-right corner (N-1, M-1) in an N x M matrix such that the maximum height difference between any two adjacent cells in this path is minimized. Args: N : int : number of rows in the matrix M : int : number of columns in the matrix matrix : List[List[int]] : the N x M matrix of heights Returns: int : minimum possible value of the maximum height difference between any two adjacent cells in the optimal path >>> min_max_height_difference(3, 3, [[1, 3, 5], [2, 8, 3], [4, 7, 6]]) 3 >>> min_max_height_difference(1, 1, [[0]]) 0 >>> min_max_height_difference(2, 2, [[1, 1000000], [1000000, 1]]) 999999 >>> min_max_height_difference(3, 3, [[1, 2, 2], [3, 8, 2], [5, 3, 5]]) 2 >>> min_max_height_difference(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> min_max_height_difference(2, 2, [[10, 10], [10, 10]]) 0","solution":"from heapq import heappop, heappush def min_max_height_difference(N, M, matrix): def is_valid(x, y): return 0 <= x < N and 0 <= y < M directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] heap = [(0, 0, 0)] # (diff, x, y) max_diff = [[float('inf')] * M for _ in range(N)] max_diff[0][0] = 0 while heap: diff, x, y = heappop(heap) if (x, y) == (N-1, M-1): return diff for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): new_diff = max(diff, abs(matrix[x][y] - matrix[nx][ny])) if new_diff < max_diff[nx][ny]: max_diff[nx][ny] = new_diff heappush(heap, (new_diff, nx, ny)) return max_diff[N-1][M-1]"},{"question":"from typing import List from functools import reduce def gcd(a: int, b: int) -> int: Returns the greatest common divisor of a and b using Euclid's algorithm. >>> gcd(54, 24) 6 >>> gcd(48, 18) 6 >>> gcd(101, 103) 1 >>> gcd(56, 98) 14 >>> gcd(27, 0) 27 # Implementation here def find_gcd_of_list(numbers: List[int]) -> int: Returns the greatest common divisor of all the integers in the list. >>> find_gcd_of_list([6, 9, 15]) 3 >>> find_gcd_of_list([100, 75, 25, 50]) 25 >>> find_gcd_of_list([12, 15, 21]) 3 >>> find_gcd_of_list([17, 19, 23, 29]) 1 >>> find_gcd_of_list([2, 3, 5, 7, 11, 13]) 1 >>> find_gcd_of_list([10000, 5000, 1000, 2000]) 1000 # Implementation here","solution":"def gcd(a, b): Returns the greatest common divisor of a and b using Euclid's algorithm. while b: a, b = b, a % b return a def find_gcd_of_list(numbers): Returns the greatest common divisor of all the integers in the list. from functools import reduce return reduce(gcd, numbers)"},{"question":"def merge_lists(lists, operations): Function to merge multiple lists based on the given merge operations. Parameters: lists (List[List[int]]): A list of lists containing integers. operations (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing indices of lists to merge. Returns: List[int]: The final merged list after all operations are completed. def process_input_and_merge(data): Reads input from a string, processes it, and returns the merged list result. Parameters: data (str): Multi-line string containing the input data with list of integers and merge operations. Returns: List[int]: The final merged list after all merge operations. lines = data.strip().split('n') m = int(lines[0].strip()) lists = [] for i in range(1, m + 1): lists.append(list(map(int, lines[i].strip().split()))) n = int(lines[m + 1].strip()) operations = [] for i in range(m + 2, m + 2 + n): x, y = map(int, lines[i].strip().split()) operations.append((x, y)) result = merge_lists(lists, operations) return result import pytest def test_merge_simple_case(): data = \\"3n1 2 3 4n5 6 7n8 9n2n1 2n1 3\\" assert process_input_and_merge(data) == [1, 2, 3, 4, 5, 6, 7, 8, 9] def test_merge_no_operations(): data = \\"2n1 2n3 4n0\\" assert process_input_and_merge(data) == [1, 2, 3, 4] def test_merge_all_into_one(): data = \\"3n1n2n3n2n1 2n1 3\\" assert process_input_and_merge(data) == [1, 2, 3] def test_merge_large_numbers(): data = \\"2n1000000 -1000000n999999 -999999n1n1 2\\" assert process_input_and_merge(data) == [1000000, -1000000, 999999, -999999] def test_merge_interleaved_lists(): data = \\"3n1 3 5n2 4 6n7 8n2n1 2n2 3\\" assert process_input_and_merge(data) == [1, 3, 5, 2, 4, 6, 7, 8] def test_merge_single_element_lists(): data = \\"4n1n2n3n4n3n1 2n2 3n3 4\\" assert process_input_and_merge(data) == [1, 2, 3, 4] if __name__ == '__main__': pytest.main()","solution":"def merge_lists(lists, operations): Function to merge multiple lists based on the given merge operations. Parameters: lists (List[List[int]]): A list of lists containing integers. operations (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing indices of lists to merge. Returns: List[int]: The final merged list after all operations are completed. for x, y in operations: lists[x - 1].extend(lists[y - 1]) lists[y - 1] = [] # Collecting all non-empty lists merged_list = [] for lst in lists: if lst: merged_list.extend(lst) return merged_list # This function reads input, processes it, and returns the result for testing def process_input_and_merge(data): lines = data.strip().split('n') m = int(lines[0].strip()) lists = [] for i in range(1, m + 1): lists.append(list(map(int, lines[i].strip().split()))) n = int(lines[m + 1].strip()) operations = [] for i in range(m + 2, m + 2 + n): x, y = map(int, lines[i].strip().split()) operations.append((x, y)) result = merge_lists(lists, operations) return result"},{"question":"def unique_positions(N: int) -> int: Determine the number of unique positions the robot can be at after making exactly N moves. >>> unique_positions(1) 4 >>> unique_positions(2) 9 >>> unique_positions(3) 16","solution":"def unique_positions(N): Returns the number of unique positions the robot can be at after making exactly N moves. return (N + 1) ** 2"},{"question":"from typing import List def landing_priorities(flights: List[List[int]]) -> List[int]: Determines the landing priorities for the given list of flights based on their fuel level and flight duration. Parameters: flights (List[List[int]]): An array where each subarray contains two integers, fuel level and flight duration. Returns: List[int]: A list of indices representing the order in which the flights should land, with the highest priority flight first. Example: >>> landing_priorities([[5, 120], [4, 100], [3, 180], [5, 130], [2, 90]]) [4, 2, 1, 3, 0] >>> landing_priorities([[3, 50], [1, 100], [2, 90]]) [1, 2, 0] # Your code here # Unit Tests def test_landing_priorities_example(): flights = [[5, 120], [4, 100], [3, 180], [5, 130], [2, 90]] assert landing_priorities(flights) == [4, 2, 1, 3, 0] def test_landing_priorities_same_fuel_levels(): flights = [[5, 110], [5, 120], [5, 100]] assert landing_priorities(flights) == [1, 0, 2] def test_landing_priorities_single_flight(): flights = [[5, 120]] assert landing_priorities(flights) == [0] def test_landing_priorities_same_fuel_durations(): flights = [[5, 120], [5, 120], [5, 120]] assert landing_priorities(flights) == [0, 1, 2] def test_landing_priorities_different_fuel_levels(): flights = [[3, 50], [1, 100], [2, 90]] assert landing_priorities(flights) == [1, 2, 0] def test_landing_priorities_same_durations(): flights = [[5, 120], [4, 120], [3, 120], [2, 120]] assert landing_priorities(flights) == [3, 2, 1, 0]","solution":"def landing_priorities(flights): Returns the ordered list of landing priorities based on fuel level and flight duration. If the fuel levels are equal, the flight with the longer duration has higher priority. # Sort by fuel level (ascending) then by flight duration (descending) and then by original index sorted_flights = sorted(enumerate(flights), key=lambda x: (x[1][0], -x[1][1], x[0])) # Extract the original indices in the sorted order priorities = [index for index, flight in sorted_flights] return priorities # Example Test flights = [[5, 120], [4, 100], [3, 180], [5, 130], [2, 90]] print(landing_priorities(flights)) # Output: [4, 2, 1, 3, 0]"},{"question":"def longest_bitonic_subsequence(n: int, arr: List[int]) -> int: Returns the length of the longest bitonic subsequence. A subsequence of array A is called bitonic if it is first strictly increasing and then strictly decreasing. Args: n: An integer representing the size of the array A. arr: A list of n positive integers representing the elements of the array A. Returns: An integer representing the length of the longest bitonic subsequence. >>> longest_bitonic_subsequence(8, [1, 11, 2, 10, 4, 5, 2, 1]) == 6 >>> longest_bitonic_subsequence(6, [12, 11, 40, 5, 3, 1]) == 5 >>> longest_bitonic_subsequence(6, [80, 60, 30, 40, 20, 10]) == 5 >>> longest_bitonic_subsequence(1, [1]) == 1 >>> longest_bitonic_subsequence(5, [1, 2, 3, 4, 5]) == 5 >>> longest_bitonic_subsequence(5, [5, 4, 3, 2, 1]) == 5 >>> longest_bitonic_subsequence(0, []) == 0 >>> longest_bitonic_subsequence(9, [3, 5, 8, 12, 13, 6, 2, 1, 0]) == 9","solution":"def longest_bitonic_subsequence(n, arr): Returns the length of the longest bitonic subsequence. if n == 0: return 0 # Initialize the increasing and decreasing sequences inc = [1] * n # Length of increasing subsequence ending at each element dec = [1] * n # Length of decreasing subsequence starting at each element # Compute lengths of increasing subsequences for each element for i in range(1, n): for j in range(i): if arr[i] > arr[j]: inc[i] = max(inc[i], inc[j] + 1) # Compute lengths of decreasing subsequences for each element for i in range(n - 2, -1, -1): for j in range(n - 1, i, -1): if arr[i] > arr[j]: dec[i] = max(dec[i], dec[j] + 1) # Calculate the maximum value of (inc[i] + dec[i] - 1) max_len = 1 for i in range(n): max_len = max(max_len, inc[i] + dec[i] - 1) return max_len"},{"question":"def max_subarray_sum(n: int, distances: List[int]) -> int: Given an array of distances Alice ran over some days, find the maximum sum of any contiguous subarray. Parameters: n (int): Number of days recorded. distances (list of int): List of distances run on each day. Returns: int: The maximum sum of any contiguous subarray. >>> max_subarray_sum(5, [1, -2, 3, 4, -1]) 7 >>> max_subarray_sum(6, [-1, 2, 3, -4, 5, -3]) 6 >>> max_subarray_sum(3, [-1, -2, -3]) -1 >>> max_subarray_sum(8, [1, -3, 2, 1, -1, 2, -5, 4]) 4 >>> max_subarray_sum(1, [4]) 4 >>> max_subarray_sum(1, [-4]) -4 >>> max_subarray_sum(0, []) 0","solution":"def max_subarray_sum(n, distances): Given an array of distances Alice ran over some days, find the maximum sum of any contiguous subarray. Parameters: n (int): Number of days recorded. distances (list of int): List of distances run on each day. Returns: int: The maximum sum of any contiguous subarray. if n == 0: return 0 max_sum = current_sum = distances[0] for i in range(1, n): current_sum = max(distances[i], current_sum + distances[i]) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"class Elevator: def __init__(self, floors): Initialize the Elevator with given floors. Args: - floors (int): Total number of floors in the building. self.current_floor = 0 # Elevator starts at ground floor self.requests = [] # List of tuples (request type, floor number) self.floors = floors # Total number of floors in the building def call_elevator(self, request_floor): Add request to pick up passengers from \`request_floor\`. Args: - request_floor (int): The floor to which the elevator is requested. self.requests.append(('call', request_floor)) def select_floor(self, destination_floor): Add request to take elevator to \`destination_floor\`. Args: - destination_floor (int): The floor requested by a passenger inside the elevator. self.requests.append(('select', destination_floor)) def step(self): Simulate a single step of the elevator's movement. if not self.requests: return self.current_floor # Elevator remains where it is if no requests request_type, floor = self.requests.pop(0) if request_type == 'call': self._move_to_floor(floor) elif request_type == 'select': self._move_to_floor(floor) def _move_to_floor(self, floor): Move the elevator to the target floor. Args: - floor (int): The floor number to move the elevator to. if floor >= 0 and floor < self.floors: self.current_floor = floor def simulate_elevator(): elevator = Elevator(floors=10) # Example request queue: elevator.call_elevator(2) # Passenger at floor 2 elevator.select_floor(5) # Wants to go to floor 5 elevator.call_elevator(7) # New request at floor 7 elevator.select_floor(3) # Wants to go to floor 3 # Simulate the elevator's steps for _ in range(4): print(\\"Elevator current floor:\\", elevator.step()) simulate_elevator() Unit Test: from solution import Elevator def test_elevator_initial_state(): elevator = Elevator(floors=5) assert elevator.current_floor == 0 assert elevator.requests == [] def test_elevator_simple_call(): elevator = Elevator(floors=5) elevator.call_elevator(3) assert elevator.step() == 3 assert elevator.step() == 3 # remains at the last handled position def test_elevator_multiple_calls(): elevator = Elevator(floors=5) elevator.call_elevator(3) elevator.call_elevator(4) assert elevator.step() == 3 assert elevator.step() == 4 assert elevator.step() == 4 # remains at the last handled position def test_elevator_select_floor(): elevator = Elevator(floors=5) elevator.call_elevator(2) assert elevator.step() == 2 elevator.select_floor(4) assert elevator.step() == 4 assert elevator.step() == 4 # remains at the last handled position def test_elevator_mixed_requests(): elevator = Elevator(floors=5) elevator.call_elevator(1) elevator.select_floor(3) elevator.call_elevator(0) assert elevator.step() == 1 assert elevator.step() == 3 assert elevator.step() == 0 assert elevator.step() == 0 # remains at the last handled position def test_elevator_out_of_range(): elevator = Elevator(floors=5) elevator.call_elevator(6) # Invalid request elevator.select_floor(-1) # Invalid request assert elevator.step() == 0 # remain in initial floor assert elevator.step() == 0 def test_elevator_no_requests(): elevator = Elevator(floors=5) assert elevator.step() == 0","solution":"class Elevator: def __init__(self, floors): self.current_floor = 0 # Elevator starts at ground floor self.requests = [] # List of tuples (request type, floor number) self.floors = floors # Total number of floors in the building def call_elevator(self, request_floor): Add request to pick up passengers from \`request_floor\`. self.requests.append(('call', request_floor)) def select_floor(self, destination_floor): Add request to take elevator to \`destination_floor\`. self.requests.append(('select', destination_floor)) def step(self): Simulate a single step of the elevator's movement. if not self.requests: return self.current_floor # Elevator remains where it is if no requests request_type, floor = self.requests.pop(0) if request_type == 'call': self._move_to_floor(floor) elif request_type == 'select': self._move_to_floor(floor) return self.current_floor def _move_to_floor(self, floor): Move the elevator to the target floor. if floor >= 0 and floor < self.floors: self.current_floor = floor def simulate_elevator(): elevator = Elevator(floors=10) # Example request queue: elevator.call_elevator(2) # Passenger at floor 2 elevator.select_floor(5) # Wants to go to floor 5 elevator.call_elevator(7) # New request at floor 7 elevator.select_floor(3) # Wants to go to floor 3 # Simulate the elevator's steps for _ in range(4): print(\\"Elevator current floor:\\", elevator.step()) simulate_elevator()"},{"question":"def max_absolute_value_in_subarrays(arr, queries): Returns a list of the maximum absolute values from given subarrays. Parameters: arr (list of int): The input array of integers. queries (list of tuple): A list of tuples where each tuple contains two integers representing the range [l_j, r_j]. Returns: list of int: The maximum absolute value from each subarray. >>> max_absolute_value_in_subarrays([-3, 7, -2, 10, -5, 7, 3, -4], [(1, 4), (2, 6), (3, 8)]) [10, 10, 10] >>> max_absolute_value_in_subarrays([1, -2, 3], [(1, 1), (2, 2), (3, 3)]) [1, 2, 3] >>> max_absolute_value_in_subarrays([1, 2, -3, 4, -5], [(1, 5)]) [5] >>> max_absolute_value_in_subarrays([-100, 0, 50, -10, 5], [(1, 3), (2, 5)]) [100, 50] >>> max_absolute_value_in_subarrays([5, 5, 5, 5, 5], [(1, 5)]) [5]","solution":"def max_absolute_value_in_subarrays(arr, queries): Returns a list of the maximum absolute values from given subarrays. Parameters: arr (list of int): The input array of integers. queries (list of tuple): A list of tuples where each tuple contains two integers representing the range [l_j, r_j]. Returns: list of int: The maximum absolute value from each subarray. results = [] for l, r in queries: # Extract the subarray subarray = arr[l-1:r] # Find the maximum absolute value in the subarray max_abs_val = max(abs(num) for num in subarray) results.append(max_abs_val) return results"},{"question":"def find_permutation(P: List[int]) -> List[int]: Luka is playing with permutations. A permutation of length \`n\` is an array containing each number from \`1\` to \`n\` exactly once. Luka has an array \`P\` that is a permutation of length \`n\`. He wants to create a new array \`Q\` which is defined as follows: For each \`1 <= i <= n\`, \`Q[i] = P[P[i]]\` Help Luka to find the resulting array \`Q\` for the given permutation \`P\`. >>> find_permutation([2, 3, 1, 5, 4]) [3, 1, 2, 4, 5] >>> find_permutation([2, 1, 3]) [1, 2, 3] >>> find_permutation([1]) [1]","solution":"def find_permutation(P): n = len(P) Q = [0] * n for i in range(n): Q[i] = P[P[i] - 1] return Q"},{"question":"def validate_transactions(transactions): Validates the transactions based on the balance requirements. Parameters: transactions (list of tuples): A list where each tuple contains three integers (B, A, C). Returns: list of str: A list of results corresponding to each transaction validation.","solution":"def validate_transactions(transactions): Validates the transactions based on the balance requirements. Parameters: transactions (list of tuples): A list where each tuple contains three integers (B, A, C). Returns: list of str: A list of results corresponding to each transaction validation. results = [] for B, A, C in transactions: if B - A >= C: results.append(\\"successful transaction\\") else: results.append(\\"insufficient funds\\") return results"},{"question":"def min_coins(n, coin_values, m): Function to calculate the minimum number of coins required to make a given amount of money. >>> min_coins(3, [1, 3, 4], 6) 2 >>> min_coins(2, [2, 5], 3) -1 >>> min_coins(4, [1, 2, 5, 10], 27) 4 # Unit tests def test_min_coins_example1(): assert min_coins(3, [1, 3, 4], 6) == 2 def test_min_coins_example2(): assert min_coins(2, [2, 5], 3) == -1 def test_min_coins_example3(): assert min_coins(4, [1, 2, 5, 10], 27) == 4 def test_min_coins_small_amount(): assert min_coins(3, [1, 2, 5], 1) == 1 def test_min_coins_large_coin_value(): assert min_coins(2, [2, 5], 7) == 2 def test_min_coins_no_solution(): assert min_coins(3, [2, 4, 6], 7) == -1 def test_min_coins_same_value(): assert min_coins(1, [1], 10) == 10 def test_min_coins_exact_match(): assert min_coins(3, [2, 3, 7], 7) == 1 def test_min_coins_large_m(): assert min_coins(4, [1, 2, 5, 10], 1000) == 100 def test_min_coins_min_coin_larger_than_m(): assert min_coins(1, [5], 3) == -1","solution":"def min_coins(n, coin_values, m): Function to calculate the minimum number of coins required to make a given amount of money. # Initialize the table with large numbers, bigger than the possible number of coins dp = [float('inf')] * (m + 1) # Base case: 0 coins needed to make 0 amount dp[0] = 0 # Fill the dp table with minimum coins required for each amount up to m for coin in coin_values: for i in range(coin, m + 1): dp[i] = min(dp[i], dp[i - coin] + 1) # If dp[m] is still infinity, it means it's not possible to make amount m return dp[m] if dp[m] != float('inf') else -1"},{"question":"from itertools import product from typing import List def generate_permutations(n: int, m: int) -> List[str]: Returns a list of all possible permutations of length m using the integers from 1 to n in lexicographically sorted order. >>> generate_permutations(3, 2) ['1 1', '1 2', '1 3', '2 1', '2 2', '2 3', '3 1', '3 2', '3 3'] >>> generate_permutations(2, 2) ['1 1', '1 2', '2 1', '2 2'] permutations = product(range(1, n + 1), repeat=m) return [\\" \\".join(map(str, p)) for p in permutations]","solution":"from itertools import product def generate_permutations(n, m): Returns a list of all possible permutations of length m using the integers from 1 to n in lexicographically sorted order. permutations = product(range(1, n + 1), repeat=m) return [\\" \\".join(map(str, p)) for p in permutations]"},{"question":"def ancient_sorting_books(input_text: str) -> str: An old and mystical library has a chief librarian who is known for his skill in an ancient way of sorting books. These books have information written on each page about knowledge long forgotten. The chief librarian wants to sort these books based on the total information they contain. The total information in a book is the sum of information on each of its pages. Now, you being an understudy of the chief librarian, are tasked to help with this sorting process. Given the number of pages in each book and the information on each page, find out the order of books from the one with the least total information to the one with the most. For each test case, output a single line containing the indices of the books sorted by increasing order of total information. If two books have the same total information, maintain their original order. Input: - The first line contains an integer T, the number of test cases. - Each test case starts with an integer n, the number of books. - The next line contains n integers, where the i-th integer indicates the number of pages in the i-th book. - The following lines contain the information for each book's pages. For each book, there will be a line of integers with the amount of information on each page. Output: - For each test case, output a single line containing the indices of the books sorted by increasing order of total information. If two books have the same total information, maintain their original order. Constraints: 1. 1 ≤ T ≤ 10 2. 1 ≤ n ≤ 100 3. 1 ≤ pages_i ≤ 100 4. 1 ≤ information on each page ≤ 1000 SAMPLE INPUT: 2 3 3 2 4 1 2 3 4 5 3 3 3 3 2 5 2 6 6 6 6 6 1 1 SAMPLE OUTPUT: 0 1 2 1 0 >>> ancient_sorting_books(\\"2n3n3 2 4n1 2 3n4 5n3 3 3 3n2n5 2n6 6 6 6 6n1 1\\") \\"0 1 2n1 0\\" >>> ancient_sorting_books(\\"1n2n2 3n2 3n1 1 5\\") \\"0 1\\"","solution":"def sort_books(test_cases): results = [] for n, pages, information in test_cases: total_info = [] for i in range(n): total_info.append((i, sum(information[i]))) sorted_info = sorted(total_info, key=lambda x: x[1]) results.append([idx for idx, _ in sorted_info]) return results # Reading input and formatting it accordingly def parse_input(input_text): input_lines = input_text.split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): n = int(input_lines[index]) pages = list(map(int, input_lines[index+1].split())) information = [] for i in range(n): info = list(map(int, input_lines[index+2+i].split())) information.append(info) test_cases.append((n, pages, information)) index += 2 + n return test_cases def format_output(results): return 'n'.join([' '.join(map(str, result)) for result in results]) # Main function to handle the complete sorting process def ancient_sorting_books(input_text): test_cases = parse_input(input_text) results = sort_books(test_cases) return format_output(results)"},{"question":"def standardize_identifiers(n: int, characteristics: List[str]) -> List[str]: Returns the standardized identifiers by sorting characters in each characteristic string. Parameters: n : int The number of organisms. characteristics : list of str The list of characteristics of each organism. Returns: list of str The list of standardized identifiers. >>> standardize_identifiers(3, [\\"bac\\", \\"abc\\", \\"cba\\"]) [\\"abc\\", \\"abc\\", \\"abc\\"] >>> standardize_identifiers(2, [\\"zxy\\", \\"yxz\\"]) [\\"xyz\\", \\"xyz\\"]","solution":"def standardize_identifiers(n, characteristics): Returns the standardized identifiers by sorting characters in each characteristic string. Parameters: n : int The number of organisms. characteristics : list of str The list of characteristics of each organism. Returns: list of str The list of standardized identifiers. return [''.join(sorted(char)) for char in characteristics] # Example usage: # n = 3 # characteristics = [\\"bac\\", \\"abc\\", \\"cba\\"] # print(standardize_identifiers(n, characteristics)) # Output should be [\\"abc\\", \\"abc\\", \\"abc\\"]"},{"question":"def count_visited_points(n, moves, m, points): Computes the number of distinct points visited by the robot. Parameters: n (int): Length of the move sequence. moves (str): Sequence of moves ('U', 'D', 'L', 'R'). m (int): Number of points on the grid. points (list): List of tuples representing the points (x, y). Returns: int: Number of points visited by the robot at least once. >>> count_visited_points(6, \\"URRDUL\\", 5, [(0, 0), (1, 1), (1, 0), (0, 1), (-1, 0)]) 3 >>> count_visited_points(4, \\"DDRR\\", 3, [(2, 0), (1, -2), (2, -2)]) 2 >>> count_visited_points(3, \\"UDU\\", 2, [(0, 0), (0, 1)]) 2 >>> count_visited_points(5, \\"LRLRL\\", 1, [(0, 0)]) 1 >>> count_visited_points(5, \\"RRRRR\\", 2, [(0, 0), (5, 0)]) 2","solution":"def count_visited_points(n, moves, m, points): Computes the number of distinct points visited by the robot. Parameters: n (int): Length of the move sequence. moves (str): Sequence of moves ('U', 'D', 'L', 'R'). m (int): Number of points on the grid. points (list): List of tuples representing the points (x, y). Returns: int: Number of points visited by the robot at least once. visited_positions = set() x, y = 0, 0 visited_positions.add((x, y)) for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 visited_positions.add((x, y)) visited_count = sum((x, y) in visited_positions for x, y in points) return visited_count"},{"question":"def duplicate_characters(input_string: str) -> str: Returns a new string with each character in the input string duplicated. >>> duplicate_characters(\\"hello\\") 'hheelllloo' >>> duplicate_characters(\\" \\") ' ' >>> duplicate_characters(\\"A\\") 'AA' >>> duplicate_characters(\\"aAaA\\") 'aaAAaaAA' >>> duplicate_characters(\\"!@#\\") '!!@@' >>> duplicate_characters(\\"Hello, world!\\") 'HHeelllloo,, wwoorrlldd!!' >>> duplicate_characters(\\"123\\") '112233'","solution":"def duplicate_characters(input_string): Returns a new string with each character in the input string duplicated. :param input_string: A string containing alphabetic characters, spaces, and punctuation marks. :return: A new string with each character duplicated. return ''.join([char * 2 for char in input_string])"},{"question":"def max_subarray_sum(points: List[int]) -> int: Determine the maximum sum of points obtained from any contiguous subarray. :param points: List[int] - List of points earned in each challenge. :return: int - Maximum sum of a contiguous subarray. >>> max_subarray_sum([1, -2, 3, 4, -1]) 7 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([5, -3, 5, -2, 6, -1]) 11 >>> max_subarray_sum([2, 3, -1]) 5","solution":"def max_subarray_sum(points): Returns the maximum sum of points obtained from any contiguous subarray. :param points: List[int] - List of points earned in each challenge. :return: int - Maximum sum of a contiguous subarray. max_current = max_global = points[0] for point in points[1:]: max_current = max(point, max_current + point) if max_current > max_global: max_global = max_current return max_global"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the string s can be rearranged into a palindrome. Args: s (str): The input string consisting of only lowercase English letters. Returns: bool: True if the string can be rearranged into a palindrome, False otherwise. Examples: >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aab\\") True","solution":"def can_form_palindrome(s: str) -> bool: Determines if the string s can be rearranged into a palindrome. from collections import Counter # Count the occurrences of each character char_counts = Counter(s) # Count how many characters have an odd number of occurrences odd_count = sum(1 for count in char_counts.values() if count % 2 == 1) # A string can be rearranged into a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"class ParkingLot: Design a parking lot. You are given a parking lot with multiple levels. Each level has a certain number of rows, and each row has a certain number of spots (parking spaces). Cars can be parked in any available spot, but trucks require an entire row to themselves and buses need an entire level. Implement the following functions to manage the parking lot: 1. \`addCar(level, row, spot)\`: Park a car in the specific spot on the given level and row. 2. \`addTruck(level, row)\`: Park a truck in the specified row on the given level if the whole row is free. 3. \`addBus(level)\`: Park a bus on the specified level if the whole level is free. 4. \`freeSpot(level, row, spot)\`: Free the specific spot on the given level and row. 5. \`freeRow(level, row)\`: Free all spots on the specified row. 6. \`freeLevel(level)\`: Free all spots on the given level. Each of these operations should return a boolean indicating if the operation was successful or not. def __init__(self, L, R, S): pass def addCar(self, level, row, spot): pass def addTruck(self, level, row): pass def addBus(self, level): pass def freeSpot(self, level, row, spot): pass def freeRow(self, level, row): pass def freeLevel(self, level): pass def test_parking_lot(): parking_lot = ParkingLot(3, 2, 3) # Test adding a car assert parking_lot.addCar(0, 1, 2) == True assert parking_lot.addCar(0, 1, 2) == False # Spot already taken # Test adding a truck assert parking_lot.addTruck(1, 1) == True assert parking_lot.addTruck(1, 1) == False # Row already taken # Test adding a bus assert parking_lot.addBus(2) == True assert parking_lot.addBus(2) == False # Level already taken # Test freeing a spot assert parking_lot.freeSpot(0, 1, 2) == True assert parking_lot.addCar(0, 1, 2) == True # Spot should be free now # Test freeing a row assert parking_lot.freeRow(1, 1) == True assert parking_lot.addTruck(1, 1) == True # Row should be free now # Test freeing a level assert parking_lot.freeLevel(2) == True assert parking_lot.addBus(2) == True # Level should be free now","solution":"class ParkingLot: def __init__(self, L, R, S): self.levels = [[[False for _ in range(S)] for _ in range(R)] for _ in range(L)] def addCar(self, level, row, spot): if not self.levels[level][row][spot]: self.levels[level][row][spot] = True return True return False def addTruck(self, level, row): if all(not spot for spot in self.levels[level][row]): self.levels[level][row] = [True] * len(self.levels[level][row]) return True return False def addBus(self, level): if all(all(not spot for spot in row) for row in self.levels[level]): self.levels[level] = [[True] * len(row) for row in self.levels[level]] return True return False def freeSpot(self, level, row, spot): self.levels[level][row][spot] = False return True def freeRow(self, level, row): self.levels[level][row] = [False] * len(self.levels[level][row]) return True def freeLevel(self, level): self.levels[level] = [[False] * len(row) for row in self.levels[level]] return True"},{"question":"from typing import List, Tuple def max_path_sum(n: int, m: int, grid: List[List[int]]) -> int: Computes the maximum sum of integers you can collect starting from the top-left cell and moving to the bottom-right cell, given that you can only move either right or down at any step. Args: n (int): number of rows in the grid m (int): number of columns in the grid grid (List[List[int]]): 2D grid of integers Returns: int: maximum sum of integers collected >>> max_path_sum(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_path_sum(2, 2, [[-1, -2], [-3, 4]]) 1 pass def solve(test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Solves multiple test cases of the maximum path sum problem. Args: test_cases (List[Tuple[int, int, List[List[int]]]]): list of test cases, each a tuple containing: - n (number of rows) - m (number of columns) - grid (2D grid of integers) Returns: List[int]: list of results for each test case >>> solve([(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]), (2, 2, [[-1, -2], [-3, 4]])]) [29, 1] pass def parse_input(input_str: str) -> List[Tuple[int, int, List[List[int]]]]: Parses the input string into the appropriate format for the problem. Args: input_str (str): input string Returns: List[Tuple[int, int, List[List[int]]]]: parsed test cases >>> parse_input(\\"2n3 3n1 2 3n4 5 6n7 8 9n2 2n-1 -2n-3 4\\") [(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]), (2, 2, [[-1, -2], [-3, 4]])] pass def format_output(results: List[int]) -> str: Formats the output results into a string. Args: results (List[int]): list of results Returns: str: formatted output string >>> format_output([29, 1]) \\"29n1\\" pass","solution":"def max_path_sum(n, m, grid): # Initialize a dp array dp = [[0] * m for _ in range(n)] # Fill the dp array dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1] def solve(test_cases): results = [] for n, m, grid in test_cases: results.append(max_path_sum(n, m, grid)) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) idx = 1 test_cases = [] for _ in range(T): n, m = map(int, lines[idx].split()) grid = [] for i in range(n): grid.append(list(map(int, lines[idx + 1 + i].split()))) test_cases.append((n, m, grid)) idx += n + 1 return test_cases def format_output(results): return 'n'.join(map(str, results)) # To use these functions input_str = 2 3 3 1 2 3 4 5 6 7 8 9 2 2 -1 -2 -3 4 test_cases = parse_input(input_str) results = solve(test_cases) output_str = format_output(results) print(output_str) # This should print: # 29 # 1"},{"question":"def rob_houses(houses: list) -> int: Determines the maximum amount of money the robber can steal without alerting the police. :param houses: A list of integers where each integer represents the amount of money in each house. :return: The maximum amount of money that can be stolen without robbing two adjacent houses. >>> rob_houses([2, 7, 9, 3, 1]) 12 >>> rob_houses([2, 1, 1, 2]) 4 >>> rob_houses([5]) 5 >>> rob_houses([3, 10]) 10 >>> rob_houses([]) 0","solution":"def rob_houses(houses): Determines the maximum amount of money the robber can steal without alerting the police. :param houses: A list of integers where each integer represents the amount of money in each house. :return: The maximum amount of money that can be stolen without robbing two adjacent houses. if not houses: return 0 if len(houses) == 1: return houses[0] if len(houses) == 2: return max(houses[0], houses[1]) dp = [0] * len(houses) dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, len(houses)): dp[i] = max(houses[i] + dp[i-2], dp[i-1]) return dp[-1] # Test examples houses = [2, 7, 9, 3, 1] print(rob_houses(houses)) # should return 12"},{"question":"from typing import List def largestNumber(nums: List[int]) -> str: Given a list of integers, return the largest number formed by combining them into a single number. Examples: >>> largestNumber([10, 2]) '210' >>> largestNumber([3, 30, 34, 5, 9]) '9534330' >>> largestNumber([1]) '1' >>> largestNumber([10]) '10' >>> largestNumber([0, 0]) '0' pass","solution":"from functools import cmp_to_key def largestNumber(nums): Given a list of integers, return the largest number formed by combining them into a single number. # Custom comparator def compare(x, y): if x + y > y + x: return -1 # x should come before y elif x + y < y + x: return 1 # y should come before x else: return 0 # they are equal in terms of concatenation # Convert integers to strings to prepare for comparison str_nums = list(map(str, nums)) # Sort using the custom comparator sorted_nums = sorted(str_nums, key=cmp_to_key(compare)) # Edge case: Check if the largest number is 0 (to handle [0, 0]) if sorted_nums[0] == '0': return '0' # Join the sorted list into a single string return ''.join(sorted_nums)"},{"question":"def generate_daily_sales_report(transaction_records: List[Dict[str, Union[str, float]]]) -> List[Dict[str, Union[str, float, int]]]: Generate daily sales reports from a list of transaction records. Each daily sales report should include: - date: The date of the report. - total_sales: The total sales amount for that date. - unique_customers: The number of unique customers who made transactions on that date. - transactions: The total number of transactions on that date. >>> transaction_records = [ ... {\\"transaction_id\\": \\"1\\", \\"date\\": \\"2023-10-01\\", \\"customer_id\\": \\"C1\\", \\"amount\\": 100.0}, ... {\\"transaction_id\\": \\"2\\", \\"date\\": \\"2023-10-01\\", \\"customer_id\\": \\"C2\\", \\"amount\\": 150.0}, ... {\\"transaction_id\\": \\"3\\", \\"date\\": \\"2023-10-02\\", \\"customer_id\\": \\"C1\\", \\"amount\\": 200.0}, ... {\\"transaction_id\\": \\"4\\", \\"date\\": \\"2023-10-02\\", \\"customer_id\\": \\"C3\\", \\"amount\\": 50.0}, ... {\\"transaction_id\\": \\"5\\", \\"date\\": \\"2023-10-02\\", \\"customer_id\\": \\"C1\\", \\"amount\\": 75.0} ... ] >>> expected_output = [ ... {\\"date\\": \\"2023-10-01\\", \\"total_sales\\": 250.0, \\"unique_customers\\": 2, \\"transactions\\": 2}, ... {\\"date\\": \\"2023-10-02\\", \\"total_sales\\": 325.0, \\"unique_customers\\": 2, \\"transactions\\": 3} ... ] >>> generate_daily_sales_report(transaction_records) == expected_output True","solution":"def generate_daily_sales_report(transaction_records): from collections import defaultdict report = defaultdict(lambda: {\\"total_sales\\": 0, \\"unique_customers\\": set(), \\"transactions\\": 0}) for record in transaction_records: date = record[\\"date\\"] report[date][\\"total_sales\\"] += record[\\"amount\\"] report[date][\\"unique_customers\\"].add(record[\\"customer_id\\"]) report[date][\\"transactions\\"] += 1 result = [] for date, data in sorted(report.items()): result.append({ \\"date\\": date, \\"total_sales\\": data[\\"total_sales\\"], \\"unique_customers\\": len(data[\\"unique_customers\\"]), \\"transactions\\": data[\\"transactions\\"] }) return result"},{"question":"def count_multiples(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Returns the number of unique scores that are multiples of M for each test case. Parameters: T (int): number of test cases test_cases (list of tuples): each tuple contains two integers P and M Returns: list of int: count of multiples for each test case >>> count_multiples(3, [(10, 3), (15, 5), (20, 7)]) == [3, 3, 2]","solution":"def count_multiples(T, test_cases): Returns the number of unique scores that are multiples of M for each test case. Parameters: T (int): number of test cases test_cases (list of tuples): each tuple contains two integers P and M Returns: list of int: count of multiples for each test case results = [] for P, M in test_cases: results.append(P // M) return results"},{"question":"def count_unique_dishes(N: int) -> int: Calculate the number of unique dishes that can be created from N ingredients. Parameters: N (int): The number of ingredients available. Returns: int: The total number of unique dishes. Examples: >>> count_unique_dishes(1) 1 >>> count_unique_dishes(3) 7 >>> count_unique_dishes(5) 31 >>> count_unique_dishes(10) 1023 >>> count_unique_dishes(100) 1267650600228229401496703205375","solution":"def count_unique_dishes(N): Calculate the number of unique dishes that can be created from N ingredients. Parameters: N (int): The number of ingredients available. Returns: int: The total number of unique dishes. # The total number of ways to choose from N ingredients (including the empty set) # is 2^N, and removing the empty set gives us 2^N - 1. return (2 ** N) - 1"},{"question":"MOD = 1000000007 def distribute_toys(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Given the number of toy types and containers, calculate the number of ways to distribute the toys as per the given rules. Args: T: int : Number of test cases test_cases: List[Tuple[int, int]] : List of tuples where each contains two integers M and N respectively representing the number of toy types and the number of containers Returns: List[int] : List of integers representing the number of ways to distribute the toys into containers for each test case modulo 1000000007. >>> distribute_toys(3, [(2, 3), (3, 3), (4, 5)]) [2, 6, 24] >>> distribute_toys(1, [(1000, 1000)]) [641419708] >>> distribute_toys(2, [(5, 3), (10, 8)]) [0, 0] >>> distribute_toys(1, [(3, 3)]) [6] >>> distribute_toys(2, [(0, 0), (1, 0)]) [1, 0] pass def parse_input(input_string: str) -> Tuple[int, List[Tuple[int, int]]]: Parse the input string to extract the number of test cases and the list of M and N pairs. Args: input_string: str : The input string containing the number of test cases followed by lines of M and N values. Returns: Tuple[int, List[Tuple[int, int]]] : A tuple where the first element is the number of test cases and the second element is a list of tuples containing the M and N values for each test case. >>> parse_input('3n2 3n3 3n4 5n') (3, [(2, 3), (3, 3), (4, 5)]) >>> parse_input('1n1000 1000n') (1, [(1000, 1000)]) pass","solution":"MOD = 1000000007 def distribute_toys(T, test_cases): results = [] for M, N in test_cases: if M > N: results.append(0) else: # Calculating M! % MOD factorial = 1 for i in range(1, M + 1): factorial = (factorial * i) % MOD results.append(factorial) return results def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) test_cases = [tuple(map(int, line.split())) for line in lines[1:T + 1]] return T, test_cases"},{"question":"def findFirstOccurrence(arr, n, x): Finds the first occurrence of number x in a sorted array arr of size n. Parameters: arr (List[int]): A sorted list of integers. n (int): The size of the sorted list. x (int): The target integer to find in the list. Returns: int: The index of the first occurrence of x in arr, or -1 if x is not present. ... def test_findFirstOccurrence_present(): assert findFirstOccurrence([2, 4, 4, 4, 7, 9, 10, 14, 16, 18], 10, 4) == 1 def test_findFirstOccurrence_missing(): assert findFirstOccurrence([1, 3, 5, 7, 9, 11, 13], 7, 8) == -1 def test_findFirstOccurrence_first_element(): assert findFirstOccurrence([2, 4, 6, 8, 10], 5, 2) == 0 def test_findFirstOccurrence_last_element(): assert findFirstOccurrence([1, 2, 3, 4, 5], 5, 5) == 4 def test_findFirstOccurrence_single_element_present(): assert findFirstOccurrence([10], 1, 10) == 0 def test_findFirstOccurrence_single_element_missing(): assert findFirstOccurrence([10], 1, 5) == -1 def test_findFirstOccurrence_multiple_occurrences(): assert findFirstOccurrence([1, 1, 1, 1, 1], 5, 1) == 0 def test_findFirstOccurrence_edge_case(): assert findFirstOccurrence([1]*100000, 100000, 1) == 0 assert findFirstOccurrence([i for i in range(1, 100001)], 100000, 99999) == 99998","solution":"def findFirstOccurrence(arr, n, x): Finds the first occurrence of number x in a sorted array arr of size n. Parameters: arr (List[int]): A sorted list of integers. n (int): The size of the sorted list. x (int): The target integer to find in the list. Returns: int: The index of the first occurrence of x in arr, or -1 if x is not present. low, high = 0, n - 1 while low <= high: mid = (low + high) // 2 if arr[mid] == x: # Check if it's the first occurrence if mid == 0 or arr[mid - 1] != x: return mid high = mid - 1 elif arr[mid] > x: high = mid - 1 else: low = mid + 1 return -1"},{"question":"def max_non_overlapping_challenges(n: int, challenges: List[Tuple[int, int]]) -> int: Find the maximum number of non-overlapping challenges. Parameters: n (int): number of challenges challenges (list of tuples): a list where each tuple represents (start time, end time) of a challenge Returns: int: maximum number of non-overlapping challenges >>> max_non_overlapping_challenges(4, [(1, 3), (2, 5), (4, 6), (5, 7)]) 2 >>> max_non_overlapping_challenges(3, [(1, 4), (2, 5), (3, 6)]) 1 >>> max_non_overlapping_challenges(3, [(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_challenges(6, [(1, 5), (2, 3), (4, 7), (6, 8), (9, 10), (11, 12)]) 4 >>> max_non_overlapping_challenges(1, [(1, 2)]) 1","solution":"def max_non_overlapping_challenges(n, challenges): Find the maximum number of non-overlapping challenges. Parameters: n (int): number of challenges challenges (list of tuples): a list where each tuple represents (start time, end time) of a challenge Returns: int: maximum number of non-overlapping challenges # Sort challenges by their end times challenges.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in challenges: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"from collections import deque from typing import List def minimum_steps_to_exit(n: int, m: int, grid: List[List[int]]) -> int: Determine the minimum number of steps required to reach the exit cell starting from the entrance cell. If it is not possible, return -1. :param n: Number of rows in the grid. :param m: Number of columns in the grid. :param grid: List of lists representing the grid. :return: Minimum number of steps to reach the exit, or -1 if not possible. >>> minimum_steps_to_exit(3, 3, [[1, 0, 0], [1, 1, 0], [0, 1, 1]]) 5 >>> minimum_steps_to_exit(2, 2, [[1, 0], [1, 1]]) 3 >>> minimum_steps_to_exit(3, 3, [[1, 0, 1], [0, 0, 1], [1, 1, 1]]) -1 >>> minimum_steps_to_exit(4, 4, [[1, 1, 1, 0], [0, 1, 0, 1], [1, 1, 0, 0], [1, 1, 1, 1]]) 7 >>> minimum_steps_to_exit(1, 2, [[1, 1]]) 2","solution":"from collections import deque def minimum_steps_to_exit(n, m, grid): Determine the minimum number of steps required to reach the exit cell starting from the entrance cell. If it is not possible, return -1. :param n: Number of rows in the grid. :param m: Number of columns in the grid. :param grid: List of lists representing the grid. :return: Minimum number of steps to reach the exit, or -1 if not possible. if grid[0][0] == 0 or grid[n-1][m-1] == 0: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right queue = deque([(0, 0, 1)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if r == n - 1 and c == m - 1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] == 1 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1"},{"question":"def max_profit(prices: List[int]) -> int: Determine the maximum profit from buying and selling one stock. If the list is empty or contains only one element, return -1. >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([3, 3, 5, 0, 0, 3, 1, 4]) 4 >>> max_profit([]) -1 >>> max_profit([5]) -1","solution":"def max_profit(prices): Returns the maximum profit from buying and selling one stock. If the list is empty or contains only one element, returns -1. if not prices or len(prices) < 2: return -1 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"def find_longest_unique_range(n, arr): This function returns the 1-based starting and ending indices of the longest range with unique elements in the given array. :param n: int, the length of the array :param arr: list of int, the array of integers :return: tuple of two ints, the starting and ending indices (1-based) >>> find_longest_unique_range(5, [1, 2, 3, 2, 1]) (1, 3) >>> find_longest_unique_range(6, [1, 2, 1, 3, 4, 3]) (2, 5) >>> find_longest_unique_range(4, [1, 1, 1, 1]) (1, 1) def solve(test_cases): This function processes multiple test cases and returns the results for each test case. :param test_cases: list of tuples, where each tuple contains an integer and a list of integers :return: list of strings, each string represents the 1-based starting and ending indices of the longest range with unique elements in the array >>> solve([(5, [1, 2, 3, 2, 1]), (6, [1, 2, 1, 3, 4, 3]), (4, [1, 1, 1, 1])]) ['1 3', '2 5', '1 1']","solution":"def find_longest_unique_range(n, arr): This function returns the 1-based starting and ending indices of the longest range with unique elements in the given array. :param n: int, the length of the array :param arr: list of int, the array of integers :return: tuple of two ints, the starting and ending indices (1-based) last_seen = {} max_len = 0 start = 0 left = 0 for right in range(n): if arr[right] in last_seen and last_seen[arr[right]] >= left: left = last_seen[arr[right]] + 1 last_seen[arr[right]] = right if right - left + 1 > max_len: max_len = right - left + 1 start = left return (start + 1, start + max_len) def solve(test_cases): results = [] for n, arr in test_cases: start_index, end_index = find_longest_unique_range(n, arr) results.append(f\\"{start_index} {end_index}\\") return results"},{"question":"from typing import List def prime_factors(n: int) -> set: Compute the prime factors of a number. Args: n (int): The number to factorize. Returns: set: A set of prime factors of the number. # Implementation here def max_k_th_prime_factor_count(n: int, k: int, arr: List[int]) -> int: Determine the maximum \\"k-th distinct prime factor count\\" for any valid subarray of length \`k\`. Args: n (int): The size of the array. k (int): The length of the subarray. arr (List[int]): The array of integers. Returns: int: The maximum \\"k-th distinct prime factor count\\". >>> max_k_th_prime_factor_count(5, 3, [10, 15, 21, 24, 30]) 3 >>> max_k_th_prime_factor_count(8, 4, [7, 11, 13, 2, 3, 5, 14, 20]) 2 # Test cases to validate the solution def test_case_0(): assert max_k_th_prime_factor_count(5, 3, [10, 15, 21, 24, 30]) == 3 def test_case_1(): assert max_k_th_prime_factor_count(8, 4, [7, 11, 13, 2, 3, 5, 14, 20]) == 2 def test_single_element_subarray(): assert max_k_th_prime_factor_count(1, 1, [7]) == 1 def test_no_prime_factors(): assert max_k_th_prime_factor_count(3, 2, [1, 1, 1]) == 0 def test_larger_prime_factors(): assert max_k_th_prime_factor_count(5, 2, [17, 51, 102, 85, 355]) == 3 def test_repeating_numbers(): assert max_k_th_prime_factor_count(4, 2, [5, 10, 5, 10]) == 2","solution":"from collections import defaultdict import math # Function to compute prime factors of a number def prime_factors(n): factors = set() while n % 2 == 0: factors.add(2) n = n // 2 for i in range(3, int(math.sqrt(n)) + 1, 2): while n % i == 0: factors.add(i) n = n // i if n > 2: factors.add(n) return factors def max_k_th_prime_factor_count(n, k, arr): max_prime_factors_count = 0 for i in range(n - k + 1): subarray = sorted(arr[i:i + k]) kth_largest = subarray[k - 1] prime_factors_count = len(prime_factors(kth_largest)) max_prime_factors_count = max(max_prime_factors_count, prime_factors_count) return max_prime_factors_count"},{"question":"def preprocess_matrix(matrix): Preprocess the matrix to create a prefix sum matrix. def submatrix_sum(prefix_sum, r1, c1, r2, c2): Use the prefix sum matrix to calculate the sum of the submatrix. def process_queries(matrix, queries): Process all queries and return the results. results = [] def test_preprocess_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected_prefix_sum = [ [0, 0, 0, 0], [0, 1, 3, 6], [0, 5, 12, 21], [0, 12, 27, 45] ] assert preprocess_matrix(matrix) == expected_prefix_sum def test_submatrix_sum(): prefix_sum = [ [0, 0, 0, 0], [0, 1, 3, 6], [0, 5, 12, 21], [0, 12, 27, 45] ] assert submatrix_sum(prefix_sum, 1, 1, 2, 2) == 12 assert submatrix_sum(prefix_sum, 2, 2, 3, 3) == 28 assert submatrix_sum(prefix_sum(prefix_sum, 1, 1, 3, 3) == 45 assert submatrix_sum(prefix_sum, 1, 2, 2, 3) == 16 def test_process_queries(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(1, 1, 2, 2), (2, 2, 3, 3), (1, 1, 3, 3), (1, 2, 2, 3)] expected_results = [12, 28, 45, 16] assert process_queries(matrix, queries) == expected_results","solution":"def preprocess_matrix(matrix): Preprocess the matrix to create a prefix sum matrix. n = len(matrix) m = len(matrix[0]) prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = matrix[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] return prefix_sum def submatrix_sum(prefix_sum, r1, c1, r2, c2): Use the prefix sum matrix to calculate the sum of the submatrix. return prefix_sum[r2][c2] - prefix_sum[r1 - 1][c2] - prefix_sum[r2][c1 - 1] + prefix_sum[r1 - 1][c1 - 1] def process_queries(matrix, queries): Process all queries and return the results. prefix_sum = preprocess_matrix(matrix) results = [] for r1, c1, r2, c2 in queries: results.append(submatrix_sum(prefix_sum, r1, c1, r2, c2)) return results"},{"question":"def lowest_unique_integer(numbers): Returns the lowest unique integer in the list of numbers. If there is no unique integer, returns -1. >>> lowest_unique_integer([1, 2, 2, 3, 4, 4, 5]) == 1 >>> lowest_unique_integer([3, 3, 2, 2, 1, 5, 5]) == 1 >>> lowest_unique_integer([2, 3, 4, 3, 2, 4]) == -1 >>> lowest_unique_integer([]) == -1 >>> lowest_unique_integer([6]) == 6 >>> lowest_unique_integer([6, 7, 8, 8, 9, 9, 7]) == 6","solution":"def lowest_unique_integer(numbers): Returns the lowest unique integer in the list of numbers. If there is no unique integer, returns -1. if not numbers: return -1 from collections import Counter counts = Counter(numbers) unique_numbers = [num for num, count in counts.items() if count == 1] if not unique_numbers: return -1 return min(unique_numbers)"},{"question":"def is_well_formed(s: str) -> bool: Checks if the given string of parentheses is well-formed. A string is well-formed if every opening parenthesis '(' has a matching closing parenthesis ')' and the pairs are properly nested. Args: s (str): The input string containing only '(' and ')'. Returns: bool: True if the string is well-formed, False otherwise. Examples: >>> is_well_formed(\\"()\\") True >>> is_well_formed(\\"(())\\") True >>> is_well_formed(\\"(()\\") False >>> is_well_formed(\\")(\\") False def test_is_well_formed(): # Test well-formed strings assert is_well_formed(\\"()\\") == True assert is_well_formed(\\"(())\\") == True assert is_well_formed(\\"()()\\") == True assert is_well_formed(\\"((()))\\") == True # Test not well-formed strings assert is_well_formed(\\"(()\\") == False assert is_well_formed(\\")(\\") == False assert is_well_formed(\\"((())\\") == False assert is_well_formed(\\"())(\\") == False # Test empty string assert is_well_formed(\\"\\") == True # Test single parentheses assert is_well_formed(\\"(\\") == False assert is_well_formed(\\")\\") == False","solution":"def is_well_formed(s): Checks if the given string of parentheses is well-formed. A string is well-formed if every opening parenthesis '(' has a matching closing parenthesis ')' and the pairs are properly nested. Args: s (str): The input string containing only '(' and ')'. Returns: bool: True if the string is well-formed, False otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"from typing import Optional, List # Precompute primes up to 10^6 def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all primes less than or equal to n. primes = [] is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for p in range(2, n + 1): if is_prime[p]: primes.append(p) for multiple in range(p * p, n + 1, p): is_prime[multiple] = False return primes prime_limit = 1000000 primes = sieve_of_eratosthenes(prime_limit) def getKthPrime(k: int) -> Optional[int]: Returns the k-th smallest prime number. >>> getKthPrime(1) 2 >>> getKthPrime(3) 5 >>> getKthPrime(10) 29 >>> getKthPrime(0) None >>> getKthPrime(-5) None >>> getKthPrime(100) 541 >>> getKthPrime(1000) 7919 >>> getKthPrime(10000) 104729","solution":"def sieve_of_eratosthenes(n): Returns a list of all primes less than or equal to n. primes = [] is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for p in range(2, n + 1): if is_prime[p]: primes.append(p) for multiple in range(p * p, n + 1, p): is_prime[multiple] = False return primes # Precompute primes up to 10^6 prime_limit = 1000000 primes = sieve_of_eratosthenes(prime_limit) def getKthPrime(k): Returns the k-th smallest prime number. if k < 1 or k > len(primes): return None # Invalid input return primes[k - 1]"},{"question":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None def insert_bst(root, key): Inserts a key into the BST and returns the root of the tree. if root is None: return TreeNode(key) else: if key < root.key: root.left = insert_bst(root.left, key) else: root.right = insert_bst(root.right, key) return root def range_sum_bst(root, L, R): Calculates the sum of all nodes with values between L and R (inclusive). Parameters: root (TreeNode): The root of the binary search tree. L (int): The lower bound of the range. R (int): The upper bound of the range. Returns: int: The sum of all nodes with values between L and R. >>> root = None >>> keys = [10, 5, 15, 3, 7, 18, 2] >>> for key in keys: >>> root = insert_bst(root, key) >>> range_sum_bst(root, 7, 15) 32 >>> range_sum_bst(root, 5, 10) 22 >>> range_sum_bst(root, 1, 4) 5 >>> range_sum_bst(root, 2, 18) 60 >>> range_sum_bst(TreeNode(5), 5, 5) 5 >>> range_sum_bst(None, 1, 10) 0","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None def insert_bst(root, key): Inserts a key into the BST and returns the root of the tree. if root is None: return TreeNode(key) else: if key < root.key: root.left = insert_bst(root.left, key) else: root.right = insert_bst(root.right, key) return root def range_sum_bst(root, L, R): Calculates the sum of all nodes with values between L and R (inclusive). if root is None: return 0 if root.key < L: return range_sum_bst(root.right, L, R) elif root.key > R: return range_sum_bst(root.left, L, R) else: return root.key + range_sum_bst(root.left, L, R) + range_sum_bst(root.right, L, R)"},{"question":"def is_palindrome(s: str) -> bool: Returns True if the input string is a palindrome, ignoring case and non-alphanumeric characters. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"RaceCar\\") == True >>> is_palindrome(\\"No lemon, no melon\\") == True >>> is_palindrome(\\"Able was I, ere I saw Elba!\\") == True >>> is_palindrome(\\"This is not a palindrome\\") == False","solution":"def is_palindrome(s): Returns True if the input string is a palindrome, ignoring case and non-alphanumeric characters. # Filter out non-alphanumeric characters and convert to lowercase filtered_s = ''.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is equal to its reverse return filtered_s == filtered_s[::-1]"},{"question":"def find_pairs(nums: list, n: int): Returns a list of unique pairs of integers from the input list that sum up to n. If no such pairs exist, return an empty list. If the input is not a list of integers or n is not an integer, return \\"Please enter a valid list of integers and a valid integer.\\" Parameters: nums (list): A list of integers. n (int): An integer to which the pairs should sum up. Returns: list: A list of tuples where each tuple contains a pair of integers that sum up to n. pass def test_find_pairs_valid_input(): assert find_pairs([2, 4, 3, 5, 7, 8, 9, 1], 10) == [(1, 9), (2, 8), (3, 7)] def test_find_pairs_empty_list(): assert find_pairs([], 10) == [] def test_find_pairs_no_pairs(): assert find_pairs([1, 2, 3], 10) == [] def test_find_pairs_negative_numbers(): assert find_pairs([-1, -2, -3, -4, 1, 2, 3], -1) == [(-4, 3), (-3, 2), (-2, 1)] def test_find_pairs_mixed_sign_numbers(): assert find_pairs([4, -1, 2, 9, 1, 3, -2, 6], 5) == [(-1, 6), (1, 4), (2, 3)] def test_find_pairs_duplicate_numbers(): assert find_pairs([1, 1, 2, 2, 3, 3, 4, 4], 5) == [(1, 4), (2, 3)] def test_find_pairs_non_integer_input(): assert find_pairs([1, 2, 3, \\"4\\"], 7) == \\"Please enter a valid list of integers and a valid integer.\\" assert find_pairs(\\"1234\\", 7) == \\"Please enter a valid list of integers and a valid integer.\\" assert find_pairs([1, 2, 3], \\"7\\") == \\"Please enter a valid list of integers and a valid integer.\\" def test_find_pairs_single_element_list(): assert find_pairs([5], 10) == []","solution":"def find_pairs(nums, n): Returns a list of unique pairs of integers from the input list that sum up to n. Parameters: nums (list): A list of integers. n (int): An integer to which the pairs should sum up. Returns: list: A list of tuples where each tuple contains a pair of integers that sum up to n. If no such pairs exist, returns an empty list. If input is not valid, returns a string with an error message. if not isinstance(nums, list) or not isinstance(n, int): return \\"Please enter a valid list of integers and a valid integer.\\" if any(not isinstance(x, int) for x in nums): return \\"Please enter a valid list of integers and a valid integer.\\" nums_set = set(nums) pairs = set() for num in nums: if (n - num) in nums_set: pair = tuple(sorted((num, n - num))) if pair[0] != pair[1]: # To prevent using the same element twice pairs.add(pair) return sorted(pairs)"},{"question":"def arrange_items_in_box(r: int, c: int, weights: List[int]) -> List[List[int]]: Arranges items in a rectangular box such that the difference between the maximum weight and the minimum weight in any row and any column is minimized. Args: r (int): Number of rows in the box. c (int): Number of columns in the box. weights (list of int): Weights of the items. Returns: list of list of int: Arranged weights in the box. >>> arrange_items_in_box(2, 3, [1, 6, 4, 2, 5, 3]) [[1, 2, 3], [4, 5, 6]] >>> arrange_items_in_box(3, 3, [5, 1, 3, 6, 2, 8, 7, 4, 9]) [[1, 2, 3], [4, 5, 6], [7, 8, 9]]","solution":"def arrange_items_in_box(r, c, weights): Arranges items in a rectangular box such that the difference between the maximum weight and the minimum weight in any row and any column is minimized. Args: r (int): Number of rows in the box. c (int): Number of columns in the box. weights (list of int): Weights of the items. Returns: list of list of int: Arranged weights in the box. # Sort the weights to distribute the weights evenly in the box sorted_weights = sorted(weights) # Create the box with r rows and c columns box = [[0] * c for _ in range(r)] # Fill the box in a row-major order index = 0 for i in range(r): for j in range(c): box[i][j] = sorted_weights[index] index += 1 return box # Example usage: # r, c = 2, 3 # weights = [1, 6, 4, 2, 5, 3] # print(arrange_items_in_box(r, c, weights))"},{"question":"def largest_uniform_rectangle(n: int, m: int, grid: List[List[int]]) -> int: Identify the size of the largest rectangle within the grid where all the numbers are the same. >>> largest_uniform_rectangle(2, 3, [[1, 1, 1], [1, 1, 1]]) == 6 >>> largest_uniform_rectangle(4, 4, [[1, 2, 3, 4], [5, 1, 1, 1], [1, 1, 1, 1], [1, 1, 2, 2]]) == 6 >>> largest_uniform_rectangle(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 1 >>> largest_uniform_rectangle(4, 4, [[1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 2, 2], [2, 2, 2, 2]]) == 6 >>> largest_uniform_rectangle(1, 1, [[5]]) == 1 >>> largest_uniform_rectangle(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 9 >>> largest_uniform_rectangle(2, 2, [[1, 2], [2, 2]]) == 2","solution":"def largest_uniform_rectangle(n, m, grid): def largest_histogram_area(histogram): stack = [] max_area = 0 index = 0 while index < len(histogram): if not stack or histogram[index] >= histogram[stack[-1]]: stack.append(index) index += 1 else: top = stack.pop() area = histogram[top] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) while stack: top = stack.pop() area = histogram[top] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area max_rectangle = 0 for num in range(10): histograms = [[1 if cell == num else 0 for cell in row] for row in grid] for i in range(1, n): for j in range(m): if histograms[i][j]: histograms[i][j] += histograms[i - 1][j] for row in histograms: max_rectangle = max(max_rectangle, largest_histogram_area(row)) return max_rectangle"},{"question":"def smallest_even_occurrence(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of integers, find the smallest integer that appears an even number of times for each test case. >>> smallest_even_occurrence(2, [(5, [4, 3, 2, 2, 3]), (4, [1, 2, 3, 4])]) [2, -1] >>> smallest_even_occurrence(1, [(5, [1, 1, 1, 3, 3, 3])]) [-1]","solution":"def smallest_even_occurrence(T, test_cases): results = [] for i in range(T): n, arr = test_cases[i] count = {} for num in arr: if num in count: count[num] += 1 else: count[num] = 1 smallest_even = float('inf') for num, c in count.items(): if c % 2 == 0: if num < smallest_even: smallest_even = num if smallest_even == float('inf'): results.append(-1) else: results.append(smallest_even) return results"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(preorder, inorder): Build the binary tree from preorder and inorder traversals. pass def postorder_traversal(root): Perform a postorder traversal of the binary tree. pass def tree_postorder(preorder, inorder): Reconstruct the binary tree from preorder and inorder traversals and return the postorder traversal of the tree. >>> tree_postorder([1, 2, 4, 5, 3, 6], [4, 2, 5, 1, 6, 3]) [4, 5, 2, 6, 3, 1] >>> tree_postorder([10, 5, 1, 7, 40, 50], [1, 5, 7, 10, 40, 50]) [1, 7, 5, 50, 40, 10] pass import pytest def test_example_1(): preorder = [1, 2, 4, 5, 3, 6] inorder = [4, 2, 5, 1, 6, 3] expected_postorder = [4, 5, 2, 6, 3, 1] assert tree_postorder(preorder, inorder) == expected_postorder def test_example_2(): preorder = [10, 5, 1, 7, 40, 50] inorder = [1, 5, 7, 10, 40, 50] expected_postorder = [1, 7, 5, 50, 40, 10] assert tree_postorder(preorder, inorder) == expected_postorder def test_single_node(): preorder = [1] inorder = [1] expected_postorder = [1] assert tree_postorder(preorder, inorder) == expected_postorder def test_two_nodes(): preorder = [1, 2] inorder = [2, 1] expected_postorder = [2, 1] assert tree_postorder(preorder, inorder) == expected_postorder def test_three_nodes(): preorder = [1, 2, 3] inorder = [2, 1, 3] expected_postorder = [2, 3, 1] assert tree_postorder(preorder, inorder) == expected_postorder def test_balanced_tree(): preorder = [3, 1, 2, 5, 4, 6] inorder = [1, 2, 3, 4, 5, 6] expected_postorder = [2, 1, 4, 6, 5, 3] assert tree_postorder(preorder, inorder) == expected_postorder if __name__ == \\"__main__\\": pytest.main()","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(preorder, inorder): if not preorder or not inorder: return None root_value = preorder[0] root = TreeNode(root_value) mid = inorder.index(root_value) root.left = build_tree(preorder[1:mid+1], inorder[:mid]) root.right = build_tree(preorder[mid+1:], inorder[mid+1:]) return root def postorder_traversal(root): result = [] if root: result += postorder_traversal(root.left) result += postorder_traversal(root.right) result.append(root.value) return result def tree_postorder(preorder, inorder): root = build_tree(preorder, inorder) return postorder_traversal(root) # Example usage: # n = 6 # preorder = [1, 2, 4, 5, 3, 6] # inorder = [4, 2, 5, 1, 6, 3] # print(tree_postorder(preorder, inorder)) # Output: [4, 5, 2, 6, 3, 1]"},{"question":"def solve(n: int, m: int, edge_list: List[str]) -> str: Determine if a given graph is bipartite and find the two disjoint sets of vertices if it is. Parameters: n (int): The number of vertices in the graph. m (int): The number of edges in the graph. edge_list (List[str]): A list of edges in the graph, where each edge is represented as a string of two space-separated integers \\"u v\\". Returns: str: If the graph isn't bipartite, return the string \\"-1\\". Otherwise, return the count and list of vertices in each of the two sets. Examples: >>> solve(4, 4, [\\"1 2\\", \\"1 3\\", \\"2 4\\", \\"3 4\\"]) '2n1 4n2n2 3' >>> solve(3, 3, [\\"1 2\\", \\"1 3\\", \\"2 3\\"]) '-1'","solution":"from collections import deque, defaultdict def is_bipartite(n, edges): graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) color = {} def bfs(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in color: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True for node in range(1, n + 1): if node not in color: if not bfs(node): return \\"-1\\" set1 = [node for node in color if color[node] == 0] set2 = [node for node in color if color[node] == 1] return f\\"{len(set1)}n{' '.join(map(str, sorted(set1)))}n{len(set2)}n{' '.join(map(str, sorted(set2)))}\\" # Function to process input and call the solution function def solve(n, m, edge_list): edges = [tuple(map(int, edge.split())) for edge in edge_list] return is_bipartite(n, edges)"},{"question":"def digital_root(n: int) -> int: Returns the digital root of a number n. >>> digital_root(5) 5 >>> digital_root(38) 2 >>> digital_root(12345) 6 >>> digital_root(987654321) 9 >>> digital_root(0) 0 pass def digital_roots(numbers: List[str]) -> List[int]: Given a list of numbers, returns the digital root for each number. >>> digital_roots(['1729', '12345', '987654321', '10', '5', '1001']) [1, 6, 9, 1, 5, 2] pass","solution":"def digital_root(n): Returns the digital root of a number n. while n >= 10: n = sum(int(digit) for digit in str(n)) return n def digital_roots(numbers): Given a list of numbers, returns the digital root for each number. results = [] for number in numbers: results.append(digital_root(int(number))) return results"},{"question":"def find_top_students(t: int, test_cases: List[Tuple[Tuple[int, int], List[Tuple[str, int, int, int]]]]) -> List[List[str]]: Janet has a list of names of her students along with their marks in Mathematics, Science, and English. She wants to find the top K students based on their average marks across the three subjects. If multiple students have the same average marks, they should be ordered alphabetically by their names. Help Janet by writing a program that does this task. Input: The first line contains an integer t (1 ≤ t ≤ 50) — the number of test cases. The first line of each test case contains two integers n (1 ≤ n ≤ 1000) — the number of students, and K (1 ≤ K ≤ n) — the number of top students to find. The next n lines contain a student's name (a string of length 1 to 100) followed by three integers m1, m2, m3 (0 ≤ m1, m2, m3 ≤ 100) — the marks of the student in Mathematics, Science, and English, respectively. Output: For each test case, output K lines, each containing the names of the top K students sorted by their average marks and then alphabetically if needed. >>> t = 2 >>> test_cases = [ ... ((4, 2), [ ... (\\"Alice\\", 78, 82, 91), ... (\\"Bob\\", 88, 90, 85), ... (\\"Charlie\\", 85, 83, 87), ... (\\"David\\", 90, 91, 89) ... ]), ... ((5, 3), [ ... (\\"Eve\\", 70, 75, 80), ... (\\"Frank\\", 90, 92, 94), ... (\\"Grace\\", 85, 80, 89), ... (\\"Heidi\\", 95, 96, 90), ... (\\"Ivy\\", 100, 99, 100) ... ]) ... ] >>> find_top_students(t, test_cases) [['David', 'Bob'], ['Ivy', 'Heidi', 'Frank']] from solution import find_top_students def test_find_top_students(): t = 2 test_cases = [ ((4, 2), [ (\\"Alice\\", 78, 82, 91), (\\"Bob\\", 88, 90, 85), (\\"Charlie\\", 85, 83, 87), (\\"David\\", 90, 91, 89) ]), ((5, 3), [ (\\"Eve\\", 70, 75, 80), (\\"Frank\\", 90, 92, 94), (\\"Grace\\", 85, 80, 89), (\\"Heidi\\", 95, 96, 90), (\\"Ivy\\", 100, 99, 100) ]) ] result = find_top_students(t, test_cases) assert result == [ [\\"David\\", \\"Bob\\"], [\\"Ivy\\", \\"Heidi\\", \\"Frank\\"] ] def test_same_average_different_names(): t = 1 test_cases = [ ((4, 3), [ (\\"Alice\\", 90, 90, 90), (\\"Bob\\", 90, 90, 90), (\\"Charlie\\", 80, 80, 80), (\\"David\\", 70, 70, 70) ]) ] result = find_top_students(t, test_cases) assert result == [ [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] ]","solution":"def find_top_students(t, test_cases): results = [] for idx in range(t): n, K = test_cases[idx][0] students = test_cases[idx][1] students_sorted = sorted(students, key=lambda x: (-((x[1] + x[2] + x[3]) / 3), x[0])) results.append([student[0] for student in students_sorted[:K]]) return results"},{"question":"def find_connected_components(n: int, connections: List[Tuple[int, int]]) -> int: Determine the number of isolated groups of trees in the forest. Parameters: n (int): Number of trees (nodes) connections (List[Tuple[int, int]]): List of root connections (edges) where each connection is a tuple (u, v) Returns: int: The number of isolated groups of trees Examples: >>> find_connected_components(5, [(1, 2), (2, 3), (4, 5)]) 2 >>> find_connected_components(4, [(1, 2), (3, 4)]) 2 >>> find_connected_components(6, []) 6 >>> find_connected_components(1, []) 1 >>> find_connected_components(4, []) 4 >>> find_connected_components(4, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) 1 >>> find_connected_components(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 1 >>> find_connected_components(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) 1","solution":"def find_connected_components(n, connections): from collections import defaultdict, deque def bfs(start, visited, adj_list): queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in adj_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) adj_list = defaultdict(list) for u, v in connections: adj_list[u].append(v) adj_list[v].append(u) visited = set() components = 0 for node in range(1, n + 1): if node not in visited: bfs(node, visited, adj_list) components += 1 return components"},{"question":"def completed_percentage(tasks: list) -> int: A company is creating a task management application and needs to implement a feature to calculate the percentage of completed tasks. The application keeps track of the tasks in a list, where each task is represented by a dictionary with the following structure: { \\"title\\": \\"Task Name\\", \\"completed\\": True or False } The company needs a function that takes a list of tasks and returns the percentage of tasks that are completed. The function should round the result to the nearest whole number. Args: tasks (list): A list of task dictionaries. Returns: int: The percentage of completed tasks rounded to the nearest whole number. Example: >>> tasks = [{\\"title\\": \\"Write documentation\\", \\"completed\\": True}, ... {\\"title\\": \\"Fix bugs\\", \\"completed\\": False}, ... {\\"title\\": \\"Develop new features\\", \\"completed\\": True}, ... {\\"title\\": \\"Review code\\", \\"completed\\": False}] >>> completed_percentage(tasks) 50 pass","solution":"def completed_percentage(tasks: list) -> int: Returns the percentage of tasks that are completed rounded to the nearest whole number. if not tasks: return 0 total_tasks = len(tasks) completed_tasks = sum(task[\\"completed\\"] for task in tasks) percentage = (completed_tasks / total_tasks) * 100 return round(percentage)"},{"question":"def to_upper_diagonal(): Transforms a given square matrix into its upper diagonal form. Read the matrix dimensions and values from the input, transform the matrix, and print the transformed matrix. Example: Input: 3 1 2 3 4 5 6 7 8 9 Output: 1 2 3 0 5 6 0 0 9 import subprocess def test_to_upper_diagonal(): input_data = \\"3n1 2 3n4 5 6n7 8 9n\\" expected_output = \\"1 2 3n0 5 6n0 0 9n\\" process = subprocess.Popen(['python', '-c', 'import solution; solution.to_upper_diagonal()'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) stdout, stderr = process.communicate(input=input_data.encode()) assert stdout.decode() == expected_output, f\\"Expected output:n{expected_output}nBut got:n{stdout.decode()}\\" def test_to_upper_diagonal_min_size(): input_data = \\"1n100n\\" expected_output = \\"100n\\" process = subprocess.Popen(['python', '-c', 'import solution; solution.to_upper_diagonal()'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) stdout, stderr = process.communicate(input=input_data.encode()) assert stdout.decode() == expected_output, f\\"Expected output:n{expected_output}nBut got:n{stdout.decode()}\\" def test_to_upper_diagonal_all_negative_elements(): input_data = \\"2n-1 -2n-3 -4n\\"; expected_output = \\"-1 -2n0 -4n\\" process = subprocess.Popen(['python', '-c', 'import solution; solution.to_upper_diagonal()'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) stdout, stderr = process.communicate(input=input_data.encode()) assert stdout.decode() == expected_output, f\\"Expected output:n{expected_output}nBut got:n{stdout.decode()}\\" def test_to_upper_diagonal_size_three_with_mixed_elements(): input_data = \\"3n-1 2 3n4 -5 6n7 8 -9n\\"; expected_output = \\"-1 2 3n0 -5 6n0 0 -9n\\" process = subprocess.Popen(['python', '-c', 'import solution; solution.to_upper_diagonal()'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) stdout, stderr = process.communicate(input=input_data.encode()) assert stdout.decode() == expected_output, f\\"Expected output:n{expected_output}nBut got:n{stdout.decode()}\\"","solution":"def to_upper_diagonal(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) matrix = [] idx = 1 for i in range(N): row = [] for j in range(N): row.append(int(data[idx])) idx += 1 matrix.append(row) # Transforming to upper diagonal matrix for i in range(N): for j in range(i): matrix[i][j] = 0 for row in matrix: print(' '.join(map(str, row)))"},{"question":"def is_valid_expression(expression: str) -> str: Determines if the given string is a valid mathematical expression based on defined rules: - A number can be a positive integer or a decimal (e.g., 1.0, 0.5, 123.456). - Valid operators are +, -, *, /. - Operators must be surrounded by valid numbers. - Parentheses must be properly balanced. - Spaces should be ignored during validation. Parameters: expression (str): String input representing the mathematical expression. Returns: str: \\"Valid expression\\" or \\"Invalid expression\\" >>> is_valid_expression(\\"3 + 5\\") == \\"Valid expression\\" >>> is_valid_expression(\\"10.2 * (2 + 3)\\") == \\"Valid expression\\" >>> is_valid_expression(\\"(4 + 5) * 3.1\\") == \\"Valid expression\\" >>> is_valid_expression(\\"123..45\\") == \\"Invalid expression\\" >>> is_valid_expression(\\"2 + - 3\\") == \\"Invalid expression\\" >>> is_valid_expression(\\"3 + (2 * (5 / 2\\") == \\"Invalid expression\\" >>> is_valid_expression(\\"(1 + (2 * (3 + 4)))\\") == \\"Valid expression\\" >>> is_valid_expression(\\"+3 + 5\\") == \\"Invalid expression\\" >>> is_valid_expression(\\"3 + 5 /\\") == \\"Invalid expression\\" >>> is_valid_expression(\\"3 + ()\\") == \\"Invalid expression\\" >>> is_valid_expression(\\" 3 + 5 \\") == \\"Valid expression\\" # Implementation here","solution":"import re def is_valid_expression(expression): Determines if the given string is a valid mathematical expression based on defined rules. Rules: - A number can be a positive integer or a decimal. - Valid operators are +, -, *, /. - Operators must be surrounded by valid numbers. - Parentheses must be properly balanced. - Spaces should be ignored. Parameters: expression (str): String input representing the mathematical expression. Returns: str: \\"Valid expression\\" or \\"Invalid expression\\" # Remove all spaces expression = expression.replace(' ', '') # Check for invalid characters if not re.match(r'^[d.+-*/()]*', expression): return \\"Invalid expression\\" # Regular expression patterns to match valid numbers and operators valid_number = r'(d+(.d+)?|.d+)' valid_operator = r'[+-*/]' token_pattern = re.compile(rf'({valid_number}|{valid_operator}|(|))') # Tokenize the expression tokens = token_pattern.findall(expression) tokens = [token[0] for token in tokens] # Check if the tokens sequence is valid if not tokens: return \\"Invalid expression\\" # Validate balanced parentheses def balanced_parentheses(tokens): balance = 0 for token in tokens: if token == '(': balance += 1 elif token == ')': balance -= 1 if balance < 0: return False return balance == 0 if not balanced_parentheses(tokens): return \\"Invalid expression\\" # Validate the sequence of tokens def valid_sequence(tokens): prev_token = '' for i, token in enumerate(tokens): if re.match(valid_number, token): if prev_token and re.match(valid_number, prev_token): return False elif re.match(valid_operator, token): if i == 0 or i == len(tokens) - 1: return False if re.match(valid_operator, prev_token) or prev_token == '(': return False elif token == '(': if prev_token and re.match(valid_number, prev_token): return False elif token == ')': if prev_token == '(' or re.match(valid_operator, prev_token): return False prev_token = token return True if not valid_sequence(tokens): return \\"Invalid expression\\" return \\"Valid expression\\""},{"question":"def findTriplets(arr, target): Determines if there exist three elements in the array whose sum is equal to a given target value. Parameters: arr (list): List of integers. target (int): Target sum value. Returns: bool: True if such a triplet exists, otherwise False. >>> findTriplets([1, 4, 45, 6, 10, 8], 22) True >>> findTriplets([1, 2, 4, 3, 6], 10) True >>> findTriplets([1, 2, 3, 4, 5], 50) False >>> findTriplets([-1, 0, 1, 2, -1, -4], 0) True # (-1, 1, 0) or (-1, -1, 2) >>> findTriplets([100000, -100000, 0, 50000, -50000, 30000], 0) True # (100000, -100000, 0) >>> findTriplets([1], 3) False >>> findTriplets([1, 2], 3) False >>> findTriplets([1, -1, 2, -2, 0], 0) True # (-1, 1, 0) or (2, -2, 0)","solution":"def findTriplets(arr, target): Determines if there exist three elements in the array whose sum is equal to a given target value. Parameters: arr (list): List of integers. target (int): Target sum value. Returns: bool: True if such a triplet exists, otherwise False. n = len(arr) arr.sort() for i in range(n-2): left = i + 1 right = n - 1 while (left < right): current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"from typing import List def min_moves(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of moves Lena needs to reach the goal in a grid game, or if it's possible. >>> min_moves(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 4 >>> min_moves(5, 5, [\\".....\\", \\".#...\\", \\".....\\", \\"...#.\\", \\".....\\"]) 8 >>> min_moves(3, 3, [\\"#\\", \\"#\\", \\"#\\"]) -1 >>> min_moves(1, 1, [\\".\\"]) 0 >>> min_moves(3, 3, [\\".\\", \\"#.#\\", \\".\\"]) -1","solution":"from collections import deque def min_moves(n, m, grid): # Valid moves: right, left, up, down moves = [(0, 1), (0, -1), (1, 0), (-1, 0)] # BFS initialization queue = deque([(0, 0, 0)]) # (row, col, distance) visited = [[False] * m for _ in range(n)] visited[0][0] = True while queue: x, y, dist = queue.popleft() # If we reached the bottom-right corner if x == n - 1 and y == m - 1: return dist # Explore neighbors for dx, dy in moves: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1"},{"question":"def cumulativeSkill(initialSkill: int, dailyIncreasePercentage: int, days: int) -> int: Calculate the cumulative skill level after a given number of days. :param initialSkill: int, initial skill level of the trainee :param dailyIncreasePercentage: int, percentage increase in skill level per day :param days: int, number of training days :return: int, total cumulative skill level at the end of the given number of days >>> cumulativeSkill(10, 20, 3) 36 >>> cumulativeSkill(5, 10, 0) 0 >>> cumulativeSkill(10, 20, 1) 10 >>> cumulativeSkill(99, 1, 3) 297 >>> cumulativeSkill(1000, 50, 2) 2500 >>> cumulativeSkill(10, 100, 2) 30 # Your code here","solution":"def cumulativeSkill(initialSkill, dailyIncreasePercentage, days): Calculate the cumulative skill level after a given number of days. :param initialSkill: int, initial skill level of the trainee :param dailyIncreasePercentage: int, percentage increase in skill level per day :param days: int, number of training days :return: int, total cumulative skill level at the end of the given number of days cumulative_skill = 0 current_skill = initialSkill for day in range(days): cumulative_skill += current_skill current_skill = int(current_skill * (1 + dailyIncreasePercentage / 100)) return cumulative_skill"},{"question":"from collections import Counter def are_kits_consistent(kits): Check if all supply kits are consistent in terms of items and counts. Args: kits (list of str): List of strings representing the supply kits. Returns: bool: True if all kits are consistent, False otherwise. Examples: >>> are_kits_consistent([\\"WWFFMM\\", \\"MMFFWW\\", \\"WWMMFF\\"]) True >>> are_kits_consistent([\\"WWFFMM\\", \\"MMFFWW\\", \\"WWMF\\"]) False >>> are_kits_consistent([]) True >>> are_kits_consistent([\\"WWFFMM\\"]) True >>> are_kits_consistent([\\"ABCD\\", \\"DCBA\\", \\"BADC\\", \\"BCAD\\"]) True >>> are_kits_consistent([\\"AACCDD\\", \\"CCBDDA\\", \\"AACCDD\\", \\"AABBDD\\"]) False >>> are_kits_consistent([\\"AAB\\", \\"ABB\\", \\"BAA\\", \\"AA\\"]) False","solution":"from collections import Counter def are_kits_consistent(kits): Check if all supply kits are consistent in terms of items and counts. Args: kits (list of str): List of strings representing the supply kits. Returns: bool: True if all kits are consistent, False otherwise. if not kits: return True first_kit_counter = Counter(kits[0]) for kit in kits[1:]: if Counter(kit) != first_kit_counter: return False return True"},{"question":"def max_data_samples(n, k_1, k_2, s): Find the maximum total number of data samples that can be collected during the project period. n: int - The number of days. k_1: int - The maximum number of samples collected on any single day. k_2: int - The maximum number of samples collected over any two consecutive days. s: str - A string where '0' represents a maintenance day and '1' represents a non-maintenance day. Returns: int - The maximum number of data samples that can be collected. >>> max_data_samples(4, 5, 7, \\"1011\\") 12 >>> max_data_samples(4, 4, 10, \\"0101\\") 8 >>> max_data_samples(5, 3, 4, \\"11011\\") 8 >>> max_data_samples(6, 4, 6, \\"011101\\") 14 def max_samples_for_all_cases(t, cases): Find the maximum total number of data samples that can be collected for multiple test cases. t: int - The number of test cases. cases: List[Tuple[int, int, int, str]] - A list of tuples, each containing (n, k_1, k_2, s). Returns: List[int] - A list of the maximum number of data samples for each test case. >>> t = 4 >>> cases = [ ... (4, 5, 7, \\"1011\\"), ... (4, 4, 10, \\"0101\\"), ... (5, 3, 4, \\"11011\\"), ... (6, 4, 6, \\"011101\\") ... ] >>> max_samples_for_all_cases(t, cases) [12, 8, 8, 14] # Unit Tests def test_case_1(): n, k_1, k_2 = 4, 5, 7 s = \\"1011\\" assert max_data_samples(n, k_1, k_2, s) == 12 def test_case_2(): n, k_1, k_2 = 4, 4, 10 s = \\"0101\\" assert max_data_samples(n, k_1, k_2, s) == 8 def test_case_3(): n, k_1, k_2 = 5, 3, 4 s = \\"11011\\" assert max_data_samples(n, k_1, k_2, s) == 8 def test_case_4(): n, k_1, k_2 = 6, 4, 6 s = \\"011101\\" assert max_data_samples(n, k_1, k_2, s) == 14 def test_multiple_cases(): t = 4 cases = [ (4, 5, 7, \\"1011\\"), (4, 4, 10, \\"0101\\"), (5, 3, 4, \\"11011\\"), (6, 4, 6, \\"011101\\") ] assert max_samples_for_all_cases(t, cases) == [12, 8, 8, 14] def test_edge_case_minimal(): n, k_1, k_2 = 1, 1, 1 s = \\"0\\" assert max_data_samples(n, k_1, k_2, s) == 0 def test_edge_case_maximal(): n, k_1, k_2 = 5000, 200000, 200000 s = \\"1\\" * 5000 expected = 200000 * 2500 assert max_data_samples(n, k_1, k_2, s) == expected","solution":"def max_data_samples(n, k_1, k_2, s): # Initialize total samples collected total_samples = 0 # Previous day's collected samples prev_samples = 0 for i in range(n): if s[i] == '1': # Calculate max samples we can collect today curr_samples = min(k_1, k_2 - prev_samples) total_samples += curr_samples prev_samples = curr_samples else: # Reset previous samples count when maintenance day comes prev_samples = 0 return total_samples def max_samples_for_all_cases(t, cases): results = [] for case in cases: n, k_1, k_2, s = case results.append(max_data_samples(n, k_1, k_2, s)) return results"},{"question":"def min_length_after_deletions(test_cases: List[str]) -> List[int]: Returns the minimum possible length of the string after performing any number of \\"ab\\" deletions. :param test_cases: List of input strings :return: List of minimum possible lengths for each input string >>> min_length_after_deletions(['abba', 'ababab', 'aaaa']) [0, 0, 4] >>> min_length_after_deletions(['aabb', 'bbaa']) [0, 0] >>> min_length_after_deletions(['a', 'b', 'ab']) [1, 1, 0] def process_input(t: int, cases: List[str]) -> List[int]: Process the input and return the minimum possible lengths for each test case. >>> process_input(3, ['abba', 'ababab', 'aaaa']) [0, 0, 4] >>> process_input(2, ['aabb', 'bbaa']) [0, 0]","solution":"def min_length_after_deletions(test_cases): Returns the minimum possible length of the string after performing any number of \\"ab\\" deletions. :param test_cases: List of input strings :return: List of minimum possible lengths for each input string results = [] for s in test_cases: count_a = s.count('a') count_b = s.count('b') min_length = abs(count_a - count_b) results.append(min_length) return results def process_input(t, cases): return min_length_after_deletions(cases)"},{"question":"def extract_house_number(label: str) -> int: Extracts the house number from the package label which is guaranteed to have digits only at the end. >>> extract_house_number(\\"MapleStreet456\\") == 456 >>> extract_house_number(\\"OakAve7890\\") == 7890 >>> extract_house_number(\\"ElmStreet123\\") == 123 >>> extract_house_number(\\"BirchBlvd999\\") == 999 >>> extract_house_number(\\"PineRoad101\\") == 101 >>> extract_house_number(\\"CherryLn42\\") == 42 >>> extract_house_number(\\"CedarDrive7\\") == 7","solution":"def extract_house_number(label): Extracts the house number from the package label which is guaranteed to have digits only at the end. house_number = '' # Traverse the string in the reverse order to find the digits at the end for char in reversed(label): if char.isdigit(): house_number = char + house_number else: break return int(house_number)"},{"question":"def is_palindromic_subsequence(s: str, k: int) -> bool: Determine if there exists a palindromic subsequence of length k in the string s. Examples: >>> is_palindromic_subsequence(\\"abcbab\\", 3) True >>> is_palindromic_subsequence(\\"abcdef\\", 2) False >>> is_palindromic_subsequence(\\"racecar\\", 7) True >>> is_palindromic_subsequence(\\"aabb\\", 1) True","solution":"def is_palindromic_subsequence(s: str, k: int) -> bool: Determine if there exists a palindromic subsequence of length k in string s. def is_palindrome(subs): return subs == subs[::-1] n = len(s) # Use dynamic programming to find the maximum length of a palindromic subsequence dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return any(dp[i][j] == k for i in range(n) for j in range(i, n))"},{"question":"def is_powerful_number(n: int) -> str: Determines if the number is a powerful number (can be represented as a sum of two or more consecutive positive integers). Parameters: n (int): The number to check. Returns: str: \\"Yes\\" if the number is powerful, \\"No\\" otherwise. >>> is_powerful_number(15) 'Yes' >>> is_powerful_number(7) 'No' >>> is_powerful_number(9) 'Yes' >>> is_powerful_number(1) 'No' >>> is_powerful_number(99999) 'Yes'","solution":"def is_powerful_number(n): Determines if the number is a powerful number (can be represented as a sum of two or more consecutive positive integers). Parameters: n (int): The number to check. Returns: str: \\"Yes\\" if the number is powerful, \\"No\\" otherwise. # A number is non-powerful if it is a power of 2; hence, n & (n - 1) == 0 if n & (n - 1) == 0: return \\"No\\" return \\"Yes\\""},{"question":"from typing import List def has_pair_with_difference(arr: List[int], target: int) -> bool: Determines if there are two distinct indices i and j in the array such that the difference between the values at these indices equals the target. Args: arr: List of integers. target: The target difference. Returns: Boolean indicating whether such a pair exists. Examples: >>> has_pair_with_difference([5, 20, 3, 2, 50, 80], 78) True >>> has_pair_with_difference([90, 70, 20, 80, 50], 45) False >>> has_pair_with_difference([1, 2, 3, 4, 5], 0) False >>> has_pair_with_difference([1, 5, 9, 13, 17], 4) True >>> has_pair_with_difference([1, 3, 5, 7, 9], -2) True >>> has_pair_with_difference(list(range(1, 100001)), 99999) True >>> has_pair_with_difference([10, 20, 30, 40, 50], 100) False","solution":"from typing import List def has_pair_with_difference(arr: List[int], target: int) -> bool: Determines if there are two distinct indices i and j in the array such that the difference between the values at these indices equals the target. Args: arr: List of integers. target: The target difference. Returns: Boolean indicating whether such a pair exists. seen = set() for value in arr: if value + target in seen or value - target in seen: return True seen.add(value) return False"},{"question":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the array. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([0, 1, 0, 3, 2, 3]) 4 >>> length_of_lis([7]) 1 pass","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the array. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def find_bridges(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determines if the graph contains any bridges. Args: n : int : Number of vertices in the graph. m : int : Number of edges in the graph. edges : List[Tuple[int, int]] : List of edges in the graph. Returns: str : \\"YES\\" if there is at least one bridge, otherwise \\"NO\\". Examples: >>> find_bridges(4, 4, [(1, 2), (1, 3), (2, 3), (3, 4)]) \\"YES\\" >>> find_bridges(4, 3, [(1, 2), (1, 3), (2, 3)]) \\"NO\\" pass # Example Unit Tests if __name__ == \\"__main__\\": assert find_bridges(4, 4, [(1, 2), (1, 3), (2, 3), (3, 4)]) == \\"YES\\" assert find_bridges(4, 3, [(1, 2), (1, 3), (2, 3)]) == \\"NO\\" assert find_bridges(3, 0, []) == \\"NO\\" assert find_bridges(2, 1, [(1, 2)]) == \\"YES\\" assert find_bridges(6, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (3, 6)]) == \\"YES\\" assert find_bridges(6, 8, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 5), (4, 6), (5, 6), (4, 5)]) == \\"NO\\"","solution":"def find_bridges(n, m, edges): from collections import defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) time = 0 visited = [False] * (n + 1) disc = [float(\\"Inf\\")] * (n + 1) low = [float(\\"Inf\\")] * (n + 1) parent = [-1] * (n + 1) bridges = [] def bridge_util(u): nonlocal time visited[u] = True disc[u] = low[u] = time time += 1 for v in graph[u]: if not visited[v]: parent[v] = u bridge_util(v) low[u] = min(low[u], low[v]) if low[v] > disc[u]: bridges.append((u, v)) elif v != parent[u]: low[u] = min(low[u], disc[v]) for i in range(1, n+1): if not visited[i]: bridge_util(i) return \\"YES\\" if bridges else \\"NO\\" # Example execution # find_bridges(4, 4, [(1, 2), (1, 3), (2, 3), (3, 4)]) should return 'YES' # find_bridges(4, 3, [(1, 2), (1, 3), (2, 3)]) should return 'NO'"},{"question":"def can_visit_all_cities(n: int, m: int, roads: List[Tuple[int, int]], s: int) -> str: Determines if it's possible to visit all cities starting from city s without revisiting any city. Args: n (int): The number of cities. m (int): The number of roads. roads (List[Tuple[int, int]]): A list of tuples representing directed roads from city u to city v. s (int): The starting city. Returns: str: \\"YES\\" if all cities can be visited starting from city s without revisiting, \\"NO\\" otherwise. Examples: >>> can_visit_all_cities(5, 5, [(1, 2), (2, 3), (1, 3), (3, 4), (4, 5)], 1) 'YES' >>> can_visit_all_cities(4, 3, [(1, 2), (3, 4), (4, 2)], 1) 'NO' pass # Unit Tests from solution import can_visit_all_cities def test_city_reachable_positive(): n = 5 m = 5 roads = [(1, 2), (2, 3), (1, 3), (3, 4), (4, 5)] s = 1 assert can_visit_all_cities(n, m, roads, s) == \\"YES\\" def test_city_not_reachable(): n = 4 m = 3 roads = [(1, 2), (3, 4), (4, 2)] s = 1 assert can_visit_all_cities(n, m, roads, s) == \\"NO\\" def test_disconnected_graph(): n = 6 m = 6 roads = [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4)] s = 4 assert can_visit_all_cities(n, m, roads, s) == \\"NO\\" def test_complex_graph(): n = 7 m = 8 roads = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 3), (1, 6)] s = 1 assert can_visit_all_cities(n, m, roads, s) == \\"YES\\"","solution":"def can_visit_all_cities(n, m, roads, s): Determines if it's possible to visit all cities starting from city s without revisiting any city. from collections import defaultdict, deque graph = defaultdict(list) for u, v in roads: graph[u].append(v) visited = set() queue = deque([s]) while queue: city = queue.popleft() if city in visited: continue visited.add(city) for neighbor in graph[city]: if neighbor not in visited: queue.append(neighbor) return \\"YES\\" if len(visited) == n else \\"NO\\" # Example usage: n = 5 m = 5 roads = [(1, 2), (2, 3), (1, 3), (3, 4), (4, 5)] s = 1 print(can_visit_all_cities(n, m, roads, s)) # Output: YES"},{"question":"def k_spaced_words(input_string: str) -> str: Transform each word by spacing its characters k-1 spaces apart, where k is the position of the word. Constraints: k is within the length of the word. Args: input_string: str - A string of words separated by spaces Returns: str - A transformed string where each word's characters are k-spaced apart >>> k_spaced_words(\\"hello world\\") 'hello w o r l d' >>> k_spaced_words(\\"hello world code assessment\\") 'hello w o r l d c o d e a s s e s s m e n t' >>> k_spaced_words(\\"hi bye\\") 'hi b y e' >>> k_spaced_words(\\"\\") '' >>> k_spaced_words(\\"a b c d\\") 'a b c d'","solution":"def k_spaced_words(input_string): Transform each word by spacing its characters k-1 spaces apart, where k is the position of the word. Constraints: k is within the length of the word. Args: input_string: str - A string of words separated by spaces Returns: str - A transformed string where each word's characters are k-spaced apart words = input_string.split() spaced_words = [] for i, word in enumerate(words): k = i + 1 spaces_between = min(k - 1, len(word) - 1) spaced_word = ' ' * spaces_between spaced_word = spaced_word.join(word) spaced_words.append(spaced_word) return ' '.join(spaced_words)"},{"question":"def find_subject_with_max_enrollment(n: int, enrollments: List[Tuple[str, int]]) -> str: Returns the name of the subject with the maximum enrollment. >>> find_subject_with_max_enrollment(4, [(\\"Mathematics\\", 50), (\\"Physics\\", 75), (\\"Chemistry\\", 75), (\\"Biology\\", 60)]) == \\"Physics\\" >>> find_subject_with_max_enrollment(2, [(\\"\\", 70), (\\"Physics\\", 65)]) == \\"\\" from typing import List, Tuple","solution":"def find_subject_with_max_enrollment(n, enrollments): Returns the name of the subject with the maximum enrollment. max_enrollment = -1 subject_with_max_enrollment = \\"\\" for subject, enrollment in enrollments: if enrollment > max_enrollment: max_enrollment = enrollment subject_with_max_enrollment = subject return subject_with_max_enrollment"},{"question":"def maxInSubarrays(nums: List[int], k: int) -> List[int]: Returns the maximum element in every k-sized subarray of the array nums. If the length of the array is less than k, the function returns an empty list. >>> maxInSubarrays([1, 3, -1, -3, 5, 3, 6, 7], 3) [3, 3, 5, 5, 6, 7] >>> maxInSubarrays([1], 1) [1]","solution":"from collections import deque def maxInSubarrays(nums, k): Returns the maximum element in every k-sized subarray of the array nums. If the length of the array is less than k, the function returns an empty list. if k > len(nums): return [] deq = deque() result = [] for i in range(len(nums)): # Remove elements not within the sliding window if deq and deq[0] == i - k: deq.popleft() # Remove all elements smaller than the current element from the deque while deq and nums[deq[-1]] <= nums[i]: deq.pop() deq.append(i) # Start adding maximum to result list after the first k elements if i >= k - 1: result.append(nums[deq[0]]) return result"},{"question":"def is_subsequence(s: str, word: str) -> bool: Check if word can be formed by deleting some characters from s. it = iter(s) return all(char in it for char in word) def longest_word_in_list(s: str, word_list: List[str]) -> str: Returns the longest word that can be formed by deleting some characters of the string s and without reordering the remaining characters. If there are multiple possible results, return the longest word. If there are still multiple results, return the one which appears first in the list. >>> longest_word_in_list(\\"abpcplea\\", [\\"apple\\", \\"monkey\\", \\"plea\\"]) 'apple' >>> longest_word_in_list(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) 'a'","solution":"def is_subsequence(s, word): Helper function to check if word can be formed by deleting some characters from s. it = iter(s) return all(char in it for char in word) def longest_word_in_list(s, word_list): Returns the longest word that can be formed by deleting some characters of the string s and without reordering the remaining characters. If there are multiple possible results, return the longest word. If there are still multiple results, return the one which appears first in the list. longest_word = \\"\\" for word in word_list: if is_subsequence(s, word): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word_list.index(word) < word_list.index(longest_word)): longest_word = word return longest_word"},{"question":"class Inventory: def __init__(self): Initializes an empty inventory def add_product(self, ID, name, quantity): Adds a new product with the given ID, name, and quantity to the inventory. If a product with the same ID already exists, updates its name and quantity to the new values. def update_quantity(self, ID, quantity): Updates the quantity of the product with the given ID by adding the specified quantity to its current quantity. def query_quantity(self, ID): Queries the inventory for the current quantity of the product with the given ID. Returns: int: The current quantity of the product with the given ID. If the product does not exist, return 0. def highest_quantity(self): Finds the product with the highest quantity in the inventory. Returns: tuple: The ID and quantity of the product with the highest quantity. If there are multiple products with the same highest quantity, returns the one with the smallest ID. def process_operations(operations): Processes a list of operations and returns the results of queries and highest quantity operations. Args: operations (list): List of operations to be performed on the inventory where each operation is in a specified format. Returns: list: List of results for 'query' and 'highest quantity' operations. # Sample input operations = [ \\"1 101 Apple 50\\", \\"1 102 Banana 30\\", \\"1 103 Orange 40\\", \\"2 102 20\\", \\"3 102\\", \\"4\\", \\"2 101 10\\" ] # Sample expected output # [50, (101, 50)] from solution import Inventory, process_operations def test_add_product(): inv = Inventory() inv.add_product(101, \\"Apple\\", 50) assert inv.products[101] == {'name': 'Apple', 'quantity': 50} def test_update_quantity(): inv = Inventory() inv.add_product(101, \\"Apple\\", 50) inv.update_quantity(101, 10) assert inv.products[101]['quantity'] == 60 def test_query_quantity(): inv = Inventory() inv.add_product(101, \\"Apple\\", 50) assert inv.query_quantity(101) == 50 def test_highest_quantity(): inv = Inventory() inv.add_product(101, \\"Apple\\", 50) inv.add_product(102, \\"Banana\\", 60) assert inv.highest_quantity() == (102, 60) inv.add_product(103, \\"Orange\\", 60) assert inv.highest_quantity() == (102, 60) def test_process_operations(): operations = [ \\"1 101 Apple 50\\", \\"1 102 Banana 30\\", \\"1 103 Orange 40\\", \\"2 102 20\\", \\"3 102\\", \\"4\\", \\"2 101 10\\" ] expected_output = [ 50, # result of \\"3 102\\" (101, 50) # result of \\"4\\" ] assert process_operations(operations) == expected_output","solution":"class Inventory: def __init__(self): self.products = {} def add_product(self, ID, name, quantity): self.products[ID] = {'name': name, 'quantity': quantity} def update_quantity(self, ID, quantity): if ID in self.products: self.products[ID]['quantity'] += quantity def query_quantity(self, ID): if ID in self.products: return self.products[ID]['quantity'] return 0 def highest_quantity(self): max_quantity = -1 max_id = None for ID, details in self.products.items(): if details['quantity'] > max_quantity or (details['quantity'] == max_quantity and ID < max_id): max_quantity = details['quantity'] max_id = ID return (max_id, max_quantity) def process_operations(operations): inventory = Inventory() results = [] for operation in operations: op = operation.split() if op[0] == '1': ID = int(op[1]) name = op[2] quantity = int(op[3]) inventory.add_product(ID, name, quantity) elif op[0] == '2': ID = int(op[1]) quantity = int(op[2]) inventory.update_quantity(ID, quantity) elif op[0] == '3': ID = int(op[1]) results.append(inventory.query_quantity(ID)) elif op[0] == '4': results.append(inventory.highest_quantity()) return results"},{"question":"def total_blooming_flowers(n: int, flowers: List[int], s: int) -> int: Calculate the total number of blooming flowers in circular garden starting from section s. Parameters: n (int): Number of sections flowers (list of int): Number of flowers in each section s (int): Starting section index (1-based) Returns: int: Total number of blooming flowers >>> total_blooming_flowers(5, [3, 0, 4, 2, 5], 3) 14 >>> total_blooming_flowers(4, [5, 1, 3, 6], 2) 15 >>> total_blooming_flowers(6, [7, 3, 0, 2, 1, 4], 6) 17 >>> total_blooming_flowers(3, [8, 8, 8], 1) 24 >>> total_blooming_flowers(1, [5], 1) 5 >>> total_blooming_flowers(4, [0, 0, 0, 0], 2) 0","solution":"def total_blooming_flowers(n, flowers, s): Calculate the total number of blooming flowers in circular garden starting from section s. Parameters: n (int): Number of sections flowers (list of int): Number of flowers in each section s (int): Starting section index (1-based) Returns: int: Total number of blooming flowers # Convert starting index to 0-based start_index = s - 1 total_flowers = 0 # Iterate through the sections in circular manner for i in range(n): total_flowers += flowers[(start_index + i) % n] return total_flowers"},{"question":"def maximum_sum_of_beads(N: int, weights: List[int]) -> int: Calculates the maximum sum of weights of beads collected starting from some position to the end. :param N: An integer representing the number of beads. :param weights: A list of integers representing the weights of the beads in sequential order. :return: An integer representing the maximum sum of weights. >>> maximum_sum_of_beads(6, [-1, 2, 3, -5, 4, 6]) 10 >>> maximum_sum_of_beads(1, [5]) 5 >>> maximum_sum_of_beads(3, [-3, -2, -1]) -1 >>> maximum_sum_of_beads(5, [1, -2, 3, 5, -1]) 8 >>> maximum_sum_of_beads(5, [0, 0, 0, 0, 0]) 0","solution":"def maximum_sum_of_beads(N, weights): Calculates the maximum sum of weights of beads collected starting from some position to the end. :param N: An integer representing the number of beads. :param weights: A list of integers representing the weights of the beads in sequential order. :return: An integer representing the maximum sum of weights. max_sum_ending_here = [0] * N max_sum_ending_here[-1] = weights[-1] for i in range(N-2, -1, -1): max_sum_ending_here[i] = max(weights[i], weights[i] + max_sum_ending_here[i + 1]) return max(max_sum_ending_here) # Example Usage # N = 6 # weights = [-1, 2, 3, -5, 4, 6] # print(maximum_sum_of_beads(N, weights)) # Output: 10"},{"question":"from datetime import datetime, timedelta from typing import List, Tuple def count_valid_extensions(borrowing_records: List[Tuple[str, str, str, str]]) -> int: Counts the number of valid extension requests based on the library's policy. :param borrowing_records: List of tuples containing (User-name, Book-name, Borrow-date, Extension-request-date) :return: Integer count of valid extension requests pass def test_single_valid_extension(): records = [(\\"Alice\\", \\"Pride and Prejudice\\", \\"2023-01-01\\", \\"2023-01-10\\")] assert count_valid_extensions(records) == 1 def test_single_invalid_extension_before_halfway(): records = [(\\"Bob\\", \\"1984\\", \\"2023-02-15\\", \\"2023-02-21\\")] assert count_valid_extensions(records) == 0 def test_single_invalid_extension_after_due_date(): records = [(\\"Eve\\", \\"To Kill a Mockingbird\\", \\"2023-03-01\\", \\"2023-03-16\\")] assert count_valid_extensions(records) == 0 def test_mixed_valid_and_invalid_extensions(): records = [ (\\"Alice\\", \\"Pride and Prejudice\\", \\"2023-01-01\\", \\"2023-01-10\\"), (\\"Bob\\", \\"1984\\", \\"2023-02-15\\", \\"2023-02-21\\"), (\\"Eve\\", \\"To Kill a Mockingbird\\", \\"2023-03-01\\", \\"2023-03-16\\"), ] assert count_valid_extensions(records) == 1 def test_multiple_valid_extensions(): records = [ (\\"Alice\\", \\"Pride and Prejudice\\", \\"2023-01-01\\", \\"2023-01-10\\"), (\\"Charlie\\", \\"Moby Dick\\", \\"2023-01-01\\", \\"2023-01-12\\"), ] assert count_valid_extensions(records) == 2 def test_no_records(): records = [] assert count_valid_extensions(records) == 0","solution":"from datetime import datetime, timedelta def count_valid_extensions(borrowing_records): Counts the number of valid extension requests based on the library's policy. :param borrowing_records: List of tuples containing (User-name, Book-name, Borrow-date, Extension-request-date) :return: Integer count of valid extension requests valid_extensions = 0 borrowing_period = 14 # Fixed borrowing period in days halfway_period = 7 # Halfway point in days for record in borrowing_records: user_name, book_name, borrow_date_str, extension_request_date_str = record borrow_date = datetime.strptime(borrow_date_str, '%Y-%m-%d') extension_request_date = datetime.strptime(extension_request_date_str, '%Y-%m-%d') halfway_date = borrow_date + timedelta(days=halfway_period) due_date = borrow_date + timedelta(days=borrowing_period) if halfway_date < extension_request_date < due_date: valid_extensions += 1 return valid_extensions"},{"question":"def smallest_rotation(s: str) -> str: Returns the lexicographically smallest rotated version of the string s. >>> smallest_rotation(\\"bca\\") 'abc' >>> smallest_rotation(\\"ccc\\") 'ccc' >>> smallest_rotation(\\"rzfakz\\") 'akzrzf' >>> smallest_rotation(\\"a\\") 'a' >>> smallest_rotation(\\"aaaaa\\") 'aaaaa' >>> smallest_rotation(\\"abba\\") 'aabb' >>> smallest_rotation(\\"zdacb\\") 'acbzd' >>> smallest_rotation(\\"abcdefghij\\") 'abcdefghij'","solution":"def smallest_rotation(s): Returns the lexicographically smallest rotated version of the string s. n = len(s) candidates = [s[i:] + s[:i] for i in range(n)] return min(candidates)"},{"question":"def find_pair_with_target_sum(t, test_cases): Determine if there exists a pair of distinct elements in the array whose sum equals the target value. Args: t (int): Number of test cases. test_cases (list): List of tuples, each containing: - n (int): Number of elements in the array. - k (int): The target value. - array (list of int): The elements of the array. Returns: list: List of strings, \\"YES\\" if there exists a pair of distinct elements whose sum equals the target value, \\"NO\\" otherwise. >>> find_pair_with_target_sum(3, [(5, 9, [1, 2, 3, 4, 5]), (4, 8, [2, 2, 2, 2]), (6, 0, [-3, 1, 4, 3, -2, -1])]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def find_pair_with_target_sum(t, test_cases): results = [] for test in test_cases: n, k, array = test seen = set() found = False for num in array: if k - num in seen: results.append(\\"YES\\") found = True break seen.add(num) if not found: results.append(\\"NO\\") return results"},{"question":"import math from typing import List def block_sum_grid(n: int, m: int, k: int, grid: List[List[int]]) -> List[List[int]]: Transform the grid into a grid of block sums where each block is k × k in size. Each block sum should be the sum of all elements within that block. Args: n (int): number of rows in the grid m (int): number of columns in the grid k (int): size of each block grid (List[List[int]]): 2D list representing the grid Returns: List[List[int]]: transformed grid with block sums Examples: >>> block_sum_grid(4, 4, 2, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) [[14, 22], [46, 54]] >>> block_sum_grid(3, 3, 2, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[12, 9], [15, 9]]","solution":"import math def block_sum_grid(n, m, k, grid): new_rows = math.ceil(n / k) new_cols = math.ceil(m / k) result = [] for i in range(new_rows): row = [] for j in range(new_cols): sum_value = 0 for x in range(i*k, min((i+1)*k, n)): for y in range(j*k, min((j+1)*k, m)): sum_value += grid[x][y] row.append(sum_value) result.append(row) return result"},{"question":"def format_number_with_commas(num: str) -> str: Takes in a string representing a large number and formats it with commas as thousands separators. The input string will contain only digits and may have leading zeros. The function should return the formatted string without any leading zeros unless the input string represents the number zero. Examples: >>> format_number_with_commas(\\"1234567\\") \\"1,234,567\\" >>> format_number_with_commas(\\"001234567\\") \\"1,234,567\\" >>> format_number_with_commas(\\"1000\\") \\"1,000\\" >>> format_number_with_commas(\\"0001000\\") \\"1,000\\" >>> format_number_with_commas(\\"0\\") \\"0\\"","solution":"def format_number_with_commas(num): Takes in a string representing a large number and formats it with commas as thousands separators. Removes leading zeros unless the number is zero. # Remove leading zeros num = num.lstrip('0') # If the stripped num is empty, it means the original number was effectively '0' if num == '': return '0' # Format the number with commas result = '' length = len(num) count = 0 for i in range(length - 1, -1, -1): result = num[i] + result count += 1 if count == 3 and i != 0: result = ',' + result count = 0 return result"},{"question":"def findMaxLength(nums: List[int]) -> int: Returns the length of the longest contiguous subarray with an equal number of 0s and 1s. >>> findMaxLength([0, 1, 0, 1, 0, 1]) == 6 >>> findMaxLength([0, 0, 1, 0, 1]) == 4 >>> findMaxLength([0, 0, 1, 1]) == 4 >>> findMaxLength([0, 1, 1, 0, 1, 1, 0, 0]) == 8 >>> findMaxLength([0, 1, 1, 0, 1, 0, 0, 1]) == 8 >>> findMaxLength([1, 1, 1, 1]) == 0 >>> findMaxLength([0]) == 0 >>> findMaxLength([0, 1]) == 2 pass","solution":"def findMaxLength(nums): Returns the length of the longest contiguous subarray with an equal number of 0s and 1s. # Change all 0s to -1s nums = [-1 if num == 0 else 1 for num in nums] # Initialize the dictionary and variables prefix_sum_map = {0: -1} max_length = 0 curr_sum = 0 for i, num in enumerate(nums): curr_sum += num if curr_sum in prefix_sum_map: max_length = max(max_length, i - prefix_sum_map[curr_sum]) else: prefix_sum_map[curr_sum] = i return max_length"},{"question":"from typing import List def min_operations_to_unique_chars(s: str) -> int: Calculates the minimum number of adjacent removals needed to make all characters in the string unique. >>> min_operations_to_unique_chars(\\"aabbcc\\") 3 >>> min_operations_to_unique_chars(\\"abcabc\\") 3 >>> min_operations_to_unique_chars(\\"aabb\\") 2 >>> min_operations_to_unique_chars(\\"abc\\") 0 >>> min_operations_to_unique_chars(\\"a\\") 0 def process_test_cases(test_cases: List[str]) -> List[int]: Process multiple test cases and returns their results as a list of integers. >>> process_test_cases([\\"aabbcc\\", \\"abcabc\\", \\"aabb\\", \\"abc\\", \\"a\\"]) [3, 3, 2, 0, 0] >>> process_test_cases([\\"\\", \\"aaaa\\", \\"abac\\"]) [0, 3, 1]","solution":"def min_operations_to_unique_chars(s): Calculates the minimum number of adjacent removals needed to make all characters in the string unique. if not s: return 0 char_count = dict() for char in s: if char not in char_count: char_count[char] = 0 char_count[char] += 1 total_removals = 0 for count in char_count.values(): if count > 1: total_removals += (count - 1) return total_removals def process_test_cases(test_cases): Process multiple test cases and returns their results as a list of integers. results = [] for s in test_cases: results.append(min_operations_to_unique_chars(s)) return results"},{"question":"class DynamicArray: Design a data structure that supports the following operations efficiently on a dynamic array of integers. - Initialization: create an empty array. - Append: add an integer to the end of the array. - Remove: remove the integer at a specified index. - Get: return the integer at a specified index. - Sum: return the sum of all integers in the array. Example: >>> da = DynamicArray() >>> da.append(1) >>> da.append(2) >>> da.append(3) >>> da.get(1) 2 >>> da.remove(1) >>> da.get(1) 3 >>> da.sum() 4 >>> da.append(4) >>> da.sum() 8 def __init__(self): pass def append(self, x): pass def remove(self, i): pass def get(self, i): pass def sum(self): pass import pytest def test_append(): da = DynamicArray() da.append(1) da.append(2) da.append(3) assert da.array == [1, 2, 3] def test_remove(): da = DynamicArray() da.append(1) da.append(2) da.append(3) da.remove(1) assert da.array == [1, 3] def test_get(): da = DynamicArray() da.append(1) da.append(2) da.append(3) assert da.get(1) == 2 assert da.get(0) == 1 assert da.get(2) == 3 def test_sum(): da = DynamicArray() da.append(1) da.append(2) da.append(3) assert da.sum() == 6 da.append(4) assert da.sum() == 10","solution":"class DynamicArray: def __init__(self): self.array = [] def append(self, x): self.array.append(x) def remove(self, i): self.array.pop(i) def get(self, i): return self.array[i] def sum(self): return sum(self.array)"},{"question":"import heapq from typing import List def minimum_difficulty(R: int, C: int, grid: List[List[int]]) -> int: Find the minimum possible difficulty of a path from the top-left cell to the bottom-right cell in a grid. >>> minimum_difficulty(3, 3, [ ... [8, 4, 7], ... [6, 1, 3], ... [2, 9, 5]]) 4 >>> minimum_difficulty(1, 4, [ ... [1, 2, 3, 4]]) 1 >>> minimum_difficulty(4, 1, [ ... [1], ... [2], ... [3], ... [4]]) 1 >>> minimum_difficulty(2, 2, [ ... [5, 5], ... [5, 5]]) 0 >>> minimum_difficulty(2, 2, [ ... [1, 1000], ... [1000, 1]]) 999 # Unit Tests def test_minimum_difficulty(): assert minimum_difficulty(3, 3, [[8, 4, 7], [6, 1, 3], [2, 9, 5]]) == 4 assert minimum_difficulty(1, 4, [[1, 2, 3, 4]]) == 1 assert minimum_difficulty(4, 1, [[1], [2], [3], [4]]) == 1 assert minimum_difficulty(2, 2, [[5, 5], [5, 5]]) == 0 assert minimum_difficulty(2, 2, [[1, 1000], [1000, 1]]) == 999","solution":"import heapq def minimum_difficulty(R, C, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def in_bounds(x, y): return 0 <= x < R and 0 <= y < C min_heap = [(0, 0, 0)] max_difficulty = [[float('inf')] * C for _ in range(R)] max_difficulty[0][0] = 0 while min_heap: diff, x, y = heapq.heappop(min_heap) if x == R-1 and y == C-1: return diff for dx, dy in directions: nx, ny = x + dx, y + dy if in_bounds(nx, ny): current_diff = max(diff, abs(grid[x][y] - grid[nx][ny])) if current_diff < max_difficulty[nx][ny]: max_difficulty[nx][ny] = current_diff heapq.heappush(min_heap, (current_diff, nx, ny)) return -1 def read_input(): R, C = map(int, input().split()) grid = [] for _ in range(R): grid.append(list(map(int, input().split()))) return R, C, grid # If you want to test the function interactively, uncomment the following lines: # R, C, grid = read_input() # print(minimum_difficulty(R, C, grid))"},{"question":"def product_elements(lst: List[int]) -> int: Takes a list of integers as input and returns the product of all the non-zero integers. If the list contains only zeroes, return 0. The input list will always contain at least one integer. >>> product_elements([1, 2, 3, 4]) 24 >>> product_elements([0, 0, 0]) 0 >>> product_elements([-1, 4, 0]) -4 >>> product_elements([7, 3, 0, 2, -1]) -42 >>> product_elements([5]) 5 >>> product_elements([0]) 0 >>> product_elements([0, 0, 5, 0]) 5 >>> product_elements([-3, 0, 0, 0]) -3","solution":"def product_elements(lst): Returns the product of all the non-zero integers in the list. If the list contains only zeroes, returns 0. product = 1 non_zero_found = False for num in lst: if num != 0: product *= num non_zero_found = True return product if non_zero_found else 0"},{"question":"def clean_text(text: str) -> str: Cleans the given text by removing leading special characters from each word. Non-alphabetical words are removed entirely. Args: text (str): Input string containing words separated by spaces. Returns: str: Cleaned version of the input string. >>> clean_text(\\"hello ***world !good @morning\\") # Output: \\"hello world good morning\\" >>> clean_text(\\"123start 456end\\") # Output: \\"start end\\" >>> clean_text(\\"**@ coding !!!is @@fun\\") # Output: \\"coding is fun\\" >>> clean_text(\\"@@@@****\\") # Output: \\"\\"","solution":"import re def clean_text(text: str) -> str: Cleans the given text by removing leading special characters from each word. Non-alphabetical words are removed entirely. Args: text (str): Input string containing words separated by spaces. Returns: str: Cleaned version of the input string. # Split the text into words words = text.split() # Remove leading special characters and filter non-alphabetical words cleaned_words = [re.sub(r'^[^a-zA-Z]+', '', word) for word in words] filtered_words = [word for word in cleaned_words if re.search(r'[a-zA-Z]', word)] # Join the filtered words with a single space return ' '.join(filtered_words)"},{"question":"def roman_to_int(s: str) -> int: Convert a valid Roman numeral to its integer equivalent. :param s: Roman numeral as a string :return: Integer equivalent of the Roman numeral >>> roman_to_int('III') 3 >>> roman_to_int('IV') 4 >>> roman_to_int('IX') 9 >>> roman_to_int('LVIII') 58 >>> roman_to_int('XC') 90 >>> roman_to_int('C') 100 >>> roman_to_int('MCMXCIV') 1994 >>> roman_to_int('MMXXIII') 2023 >>> roman_to_int('CDXLIV') 444 >>> roman_to_int('I') 1 >>> roman_to_int('MMMCMXCIX') 3999","solution":"def roman_to_int(s): Convert a valid Roman numeral to its integer equivalent. :param s: Roman numeral as a string :return: Integer equivalent of the Roman numeral roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"def can_transform(a: str, b: str) -> str: Check if it is possible to transform word \`a\` into word \`b\` by removing characters and rearranging. >>> can_transform(\\"programming\\", \\"gamming\\") 'YES' >>> can_transform(\\"test\\", \\"best\\") 'NO'","solution":"def can_transform(a, b): Check if it is possible to transform word \`a\` into word \`b\` by removing characters and rearranging. from collections import Counter # Count character frequencies for both words count_a = Counter(a) count_b = Counter(b) # Check if \`count_b\` can be formed from \`count_a\` for char in count_b: if count_b[char] > count_a.get(char, 0): return \\"NO\\" return \\"YES\\""},{"question":"def shortest_path_length(graph, start, end): Write a function named \`shortest_path_length\` that takes two parameters: the dictionary \`graph\` and two integers \`start\` and \`end\`. The function should return the length of the shortest path between \`start\` and \`end\` in the given undirected graph. If there is no path between \`start\` and \`end\`, return -1. Example: >>> shortest_path_length({1: [2, 3], 2: [1, 4], 3: [1], 4: [2]}, 1, 4) 2 >>> shortest_path_length({1: [2], 2: [1], 3: [4], 4: [3]}, 1, 3) -1 Constraints: 1 <= len(graph) <= 10^4 1 <= sum(len(v) for v in graph.values()) <= 2 * 10^4 1 <= start, end <= max(graph.keys()) pass def test_example_1(): graph = {1: [2, 3], 2: [1, 4], 3: [1], 4: [2]} assert shortest_path_length(graph, 1, 4) == 2 def test_example_2(): graph = {1: [2], 2: [1], 3: [4], 4: [3]} assert shortest_path_length(graph, 1, 3) == -1 def test_start_equals_end(): graph = {1: [2], 2: [1, 3], 3: [2]} assert shortest_path_length(graph, 1, 1) == 0 def test_no_connection(): graph = {1: [2], 2: [1], 3: [], 4: []} assert shortest_path_length(graph, 1, 3) == -1 def test_single_node(): graph = {1: []} assert shortest_path_length(graph, 1, 1) == 0 def test_larger_graph(): graph = { 1: [2, 3, 4], 2: [1, 5, 6], 3: [1], 4: [1], 5: [2], 6: [2, 7, 8], 7: [6], 8: [6] } assert shortest_path_length(graph, 1, 8) == 3","solution":"from collections import deque def shortest_path_length(graph, start, end): Returns the length of the shortest path between start and end in the given undirected graph. If there is no path, return -1. if start == end: return 0 # Initialize a queue for BFS queue = deque([(start, 0)]) # (current_node, current_distance) visited = set([start]) while queue: current_node, current_distance = queue.popleft() for neighbor in graph.get(current_node, []): if neighbor == end: return current_distance + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_distance + 1)) # If we exhaust the queue without finding the end return -1"},{"question":"def max_path_sum(n: int, grid: List[List[int]]) -> int: Returns the maximum sum of numbers along a path from the top-left corner to the bottom-right corner where you can only move either right or down. :param n: the size of the grid :param grid: the grid itself as a list of lists :return: the maximum sum >>> max_path_sum(3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 12 >>> max_path_sum(2, [ ... [1, 2], ... [1, 1] ... ]) == 4","solution":"def max_path_sum(n, grid): Returns the maximum sum of numbers along a path from the top-left corner to the bottom-right corner where you can only move either right or down. :param n: the size of the grid :param grid: the grid itself as a list of lists :return: the maximum sum dp = [[0]*n for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[0][i] = dp[0][i-1] + grid[0][i] dp[i][0] = dp[i-1][0] + grid[i][0] for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"def compute_skyline(buildings: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: Compute the skyline formed by overlapping and adjacent buildings. Each building is represented by a tuple of three integers (start, end, height). The skyline should be a list of key points (start position, height) that describes the outline. Args: buildings: List of tuples, where each tuple contains three integers (start, end, height). Returns: List of tuples representing the key points of the skyline. >>> compute_skyline([(2, 9, 10), (3, 7, 15), (5, 12, 12)]) [(2, 10), (3, 15), (7, 12), (12, 0)] >>> compute_skyline([(1, 3, 3), (2, 4, 4), (5, 6, 1), (4, 5, 2)]) [(1, 3), (2, 4), (4, 2), (5, 1), (6, 0)]","solution":"def compute_skyline(buildings): This function takes a list of buildings represented by tuples (start, end, height) and returns the skyline formed by these buildings as a list of key points (x, height). events = [] for (start, end, height) in buildings: events.append((start, -height)) events.append((end, height)) # Sort events, prioritizing by x position, and then by height: events.sort(key=lambda x: (x[0], x[1])) result = [] heights = {0} prev_max_height = 0 for x, h in events: if h < 0: # Building start point heights.add(-h) else: # Building end point heights.remove(h) current_max_height = max(heights) if current_max_height != prev_max_height: result.append((x, current_max_height)) prev_max_height = current_max_height return result"},{"question":"def plant_flowers(n: int, d: int) -> str: Determine if it's possible to plant flowers around trees satisfying the city's rule. Each type of flower is represented by an integer, and there are no restrictions on the number of times a type of flower can be used, except that there must be at least d different types between any two neighboring trees. Parameters: n (int): Number of trees. d (int): Minimum number of different types of flowers between two neighboring trees. Returns: str: \\"YES\\" followed by the flower arrangement if possible, otherwise \\"NO\\". Examples: >>> plant_flowers(5, 2) 'YESn1 2 1 2' >>> plant_flowers(3, 3) 'NO'","solution":"def plant_flowers(n, d): if d > n - 1: return \\"NO\\" # If it's possible to plant the flowers flower_types = list(range(1, d + 1)) # Create a list of d different flowers result = [] for i in range(n - 1): result.append(flower_types[i % d]) return f\\"YESn{' '.join(map(str, result))}\\""},{"question":"def reverse_words(s: str) -> str: Returns a new string with each word reversed, but with the original word order retained. >>> reverse_words(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words(\\"This is a test.\\") \\"sihT si a .tset\\" >>> reverse_words(\\"Coding assessments are fun!\\") \\"gnidoC stnemssessa era !nuf\\"","solution":"def reverse_words(s): Returns a new string with each word reversed, but with the original word order retained. # Split the string into words words = s.split() # Reverse each word reversed_words = [word[::-1] for word in words] # Join the reversed words back into a single string return ' '.join(reversed_words)"},{"question":"def process_queries(N: int, Q: int, array: List[int], queries: List[List[int]]) -> List[int]: Processes a sequence of sum and update queries on an array. Args: N : int : Number of elements in the array. Q : int : Number of queries. array : List[int] : Initial array of integers. queries : List[List[int]] : List of queries where each query is either of the form [1, L, R] or [2, L, V]. Query Types: [1, L, R] : Find the sum of elements from index L to R (1-based index). [2, L, V] : Update the value of the array at index L to V (1-based index). Returns: List[int] : List of results for sum queries. Examples: >>> process_queries(5, 4, [1, 2, 3, 4, 5], [[1, 1, 3], [2, 2, 10], [1, 1, 3], [1, 2, 5]]) [6, 14, 22] >>> process_queries(3, 3, [1, -1, 1], [[1, 1, 3], [2, 3, 5], [1, 1, 3]]) [1, 5] >>> process_queries(6, 2, [1, 2, 3, 4, 5, 6], [[1, 2, 5], [1, 1, 6]]) [14, 21] >>> process_queries(4, 2, [10, 20, 30, 40], [[2, 4, 100], [1, 1, 4]]) [160] >>> process_queries(1, 2, [5], [[1, 1, 1], [2, 1, 10], [1, 1, 1]]) [5, 10]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Build the tree self.build(data) def build(self, data): # Initialize the segment tree array for i in range(self.n): self.tree[i + self.n] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, index, value): # Update value at position index pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def query(self, left, right): # Query the sum in the range left += self.n right += self.n + 1 # make the range inclusive of right sum_ = 0 while left < right: if left % 2 == 1: sum_ += self.tree[left] left += 1 if right % 2 == 1: right -= 1 sum_ += self.tree[right] left //= 2 right //= 2 return sum_ def process_queries(N, Q, array, queries): seg_tree = SegmentTree(array) results = [] for query in queries: if query[0] == 1: _, L, R = query results.append(seg_tree.query(L - 1, R - 1)) elif query[0] == 2: _, L, V = query seg_tree.update(L - 1, V) return results"},{"question":"def min_promo_codes_needed(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Calculate the minimum number of promotional codes required for the customer to reach or exceed a target number of points. >>> min_promo_codes_needed(3, [(5, 10), (10, 40), (4, 100)]) == [1, 2, 3] >>> min_promo_codes_needed(2, [(10, 5), (100, 100)]) == [0, 0] >>> min_promo_codes_needed(1, [(1, 1000000)]) == [13] >>> min_promo_codes_needed(2, [(2, 9), (3, 27)]) == [2, 2] >>> min_promo_codes_needed(2, [(1, 1), (999999, 1000000)]) == [0, 1]","solution":"def min_promo_codes_needed(T, test_cases): results = [] for i in range(T): P, N = test_cases[i] if P >= N: results.append(0) else: promo_codes = 0 while P < N: P *= 3 promo_codes += 1 results.append(promo_codes) return results # Sample Input T = 3 test_cases = [(5, 10), (10, 40), (4, 100)] print(min_promo_codes_needed(T, test_cases))"},{"question":"def minimize_sum_adjacent_differences(sequence: List[int]) -> int: Given a sequence of integers, calculate the minimum cost required to modify the sequence to minimize the sum of adjacent differences. sequence : List[int] - A list of integers representing the sequence. Returns : int - The minimum cost to achieve the goal. >>> minimize_sum_adjacent_differences([3, 1, 4, 1, 5]) 4 >>> minimize_sum_adjacent_differences([1, 2, 3, 4, 5]) 4 pass # Implement the function here","solution":"def minimize_sum_adjacent_differences(sequence): Given a sequence of integers, this function calculates the minimum cost required to modify the sequence to minimize the sum of adjacent differences. sequence: List[int] - A list of integers representing the sequence. Returns: int - The minimum cost to achieve the goal. sequence.sort() total_cost = 0 for i in range(1, len(sequence)): total_cost += abs(sequence[i] - sequence[i - 1]) return total_cost"},{"question":"def can_complete_tasks(intervals): Determines if it is possible to complete all tasks without any overlaps. Args: intervals: List of tuples, where each tuple contains two integers (s, e) representing the start and end times of a task. Returns: \\"YES\\" if it is possible to complete all tasks without any overlaps, otherwise \\"NO\\". >>> can_complete_tasks([(1, 3), (2, 4), (3, 5)]) \\"NO\\" >>> can_complete_tasks([(5, 10), (0, 5)]) \\"YES\\" >>> can_complete_tasks([(0, 1)]) \\"YES\\" >>> can_complete_tasks([(1, 3), (3, 5), (5, 7)]) \\"YES\\" >>> can_complete_tasks([(1, 2), (3, 4), (5, 6)]) \\"YES\\" >>> can_complete_tasks([(1, 4), (2, 5), (6, 8)]) \\"NO\\" >>> can_complete_tasks([(0, 1000000), (1000000, 2000000)]) \\"YES\\" >>> can_complete_tasks([(1, 3), (4, 6), (2, 5)]) \\"NO\\"","solution":"def can_complete_tasks(intervals): Determines if it is possible to complete all tasks without any overlaps. Args: intervals: List of tuples, where each tuple contains two integers (s, e) representing the start and end times of a task. Returns: \\"YES\\" if it is possible to complete all tasks without any overlaps, otherwise \\"NO\\". # Sort intervals based on the end time intervals.sort(key=lambda x: x[1]) # Initialize the end time of the last completed task to the earliest possible time last_end_time = 0 # Iterate over the intervals to check for overlaps for start, end in intervals: if start < last_end_time: return \\"NO\\" last_end_time = end return \\"YES\\""},{"question":"def compress_string(s: str) -> str: Compresses a given string by summarizing repeated characters. >>> compress_string(\\"aabcccccaaa\\") \\"a2bc5a3\\" >>> compress_string(\\"abcd\\") \\"abcd\\" >>> compress_string(\\"aaabbbccc\\") \\"a3b3c3\\" from solution import compress_string def test_compress_string_basic(): assert compress_string(\\"aabcccccaaa\\") == \\"a2bc5a3\\" def test_compress_string_with_no_repeats(): assert compress_string(\\"abcd\\") == \\"abcd\\" def test_compress_string_all_same_char(): assert compress_string(\\"aaa\\") == \\"a3\\" def test_compress_string_mixed_repeats(): assert compress_string(\\"aaabbbccc\\") == \\"a3b3c3\\" def test_compress_string_one_char(): assert compress_string(\\"a\\") == \\"a\\" def test_compress_string_empty_string(): assert compress_string(\\"\\") == \\"\\" def test_compress_string_with_different_patterns(): assert compress_string(\\"aabbcc\\") == \\"a2b2c2\\" assert compress_string(\\"abbbbbbc\\") == \\"ab6c\\" assert compress_string(\\"aaaaaabbbbccccccccc\\") == \\"a6b4c9\\"","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: if count > 1: compressed.append(f\\"{prev_char}{count}\\") else: compressed.append(prev_char) prev_char = char count = 1 if count > 1: compressed.append(f\\"{prev_char}{count}\\") else: compressed.append(prev_char) return ''.join(compressed)"},{"question":"class TemperatureMonitor: def __init__(self): self.readings = [] def addReading(self, t, v): Add a temperature reading with timestamp t and value v. Args: t (int): The timestamp of the reading. v (int): The temperature value of the reading. pass def average(self, t1, t2): Calculate the average temperature of all readings recorded in the time interval [t1, t2]. Args: t1 (int): The start timestamp of the interval. t2 (int): The end timestamp of the interval. Returns: float: The average temperature in the interval [t1, t2], rounded to 2 decimal places. Example: >>> tm = TemperatureMonitor() >>> tm.addReading(1, 30) >>> tm.addReading(2, 25) >>> tm.addReading(3, 28) >>> tm.average(1, 2) 27.50 pass def process_input(input_lines): Process multiple operations for the TemperatureMonitor system. Args: input_lines (list): List of strings where each string is a command. Returns: list: List of results for each 'average' command in the input, rounded to 2 decimal places. Example: >>> input_lines = [ ... \\"addReading 1 30\\", ... \\"addReading 2 25\\", ... \\"addReading 3 28\\", ... \\"average 1 2\\", ... \\"addReading 4 32\\", ... \\"average 1 4\\", ... \\"average 3 4\\", ... \\"end\\" ... ] >>> process_input(input_lines) ['27.50', '28.75', '30.00'] pass","solution":"class TemperatureMonitor: def __init__(self): self.readings = [] def addReading(self, t, v): self.readings.append((t, v)) def average(self, t1, t2): total_temp = 0 count = 0 for t, v in self.readings: if t1 <= t <= t2: total_temp += v count += 1 return round(total_temp / count, 2) if count > 0 else 0.00 def process_input(input_lines): tm = TemperatureMonitor() outputs = [] for line in input_lines: if line.startswith(\\"addReading\\"): _, t, v = line.split() tm.addReading(int(t), int(v)) elif line.startswith(\\"average\\"): _, t1, t2 = line.split() avg_temp = tm.average(int(t1), int(t2)) outputs.append(f\\"{avg_temp:.2f}\\") elif line.strip() == \\"end\\": break return outputs"},{"question":"def first_book_out_of_stock(n: int, sales: List[int]) -> int: Returns the identifier of the first book that becomes out of stock based on sales transactions. Parameters: n (int): number of sales. sales (List[int]): list of book identifiers representing each sale. >>> first_book_out_of_stock(5, [1, 2, 1, 3, 2]) 1 >>> first_book_out_of_stock(4, [5, 6, 5, 6]) 5 >>> first_book_out_of_stock(3, [4, 4, 2]) 4 from typing import List def test_first_book_out_of_stock(): assert first_book_out_of_stock(5, [1, 2, 1, 3, 2]) == 1 assert first_book_out_of_stock(4, [5, 6, 5, 6]) == 5 assert first_book_out_of_stock(3, [4, 4, 2]) == 4 def test_single_sale(): assert first_book_out_of_stock(1, [1]) == None # Only one sale, no book out of stock in this case def test_no_repeat_sales(): assert first_book_out_of_stock(3, [1, 2, 3]) == None # No book is out of stock, expected output is None def test_multiple_sales_before_out_of_stock(): assert first_book_out_of_stock(6, [1, 2, 3, 1, 2, 3]) == 1 # Since the input will trigger the stockout of book 1 first def test_late_out_of_stock(): assert first_book_out_of_stock(6, [3, 1, 2, 3, 1, 2]) == 3 # The last book 3 will be the first one to stockout","solution":"def first_book_out_of_stock(n, sales): Returns the identifier of the first book that becomes out of stock. Parameters: n (int): number of sales. sales (list of int): list of book identifiers representing each sale. Returns: int: The identifier of the first book that becomes out of stock. stock = {} for book_id in sales: if book_id in stock: return book_id stock[book_id] = 1 return None # This should not happen with the given problem constraints"},{"question":"def unique_subsets(nums): Returns all possible unique subsets of the list of integers. Args: nums (list): A list of integers. Returns: list: A list of lists containing unique subsets. Examples: >>> unique_subsets([1, 2, 2]) [[], [1], [2], [1, 2], [2, 2], [1, 2, 2]] >>> unique_subsets([]) [[]] >>> unique_subsets([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> unique_subsets([1, 1, 1]) [[], [1], [1, 1], [1, 1, 1]] >>> unique_subsets([1, 2, 2, 3]) [[], [1], [2], [1, 2], [2, 2], [1, 2, 2], [3], [1, 3], [2, 3], [1, 2, 3], [2, 2, 3], [1, 2, 2, 3]]","solution":"def unique_subsets(nums): Returns all possible unique subsets of the list of integers. Args: nums (list): A list of integers. Returns: list: A list of lists containing unique subsets. nums.sort() result = [] subset = [] def dfs(index): result.append(subset[:]) for i in range(index, len(nums)): if i > index and nums[i] == nums[i - 1]: continue subset.append(nums[i]) dfs(i + 1) subset.pop() dfs(0) return result"},{"question":"def can_reach_target(n: int, m: int, t: int, sx: int, sy: int, tx: int, ty: int, grid: List[str]) -> str: Determine whether the robot can reach the target position within the given turn limit. n, m: dimensions of the grid t: maximum number of turns sx, sy: starting position of the robot tx, ty: target position grid: list of strings representing the grid >>> can_reach_target(5, 5, 3, 0, 0, 4, 4, [\\".....\\", \\".....\\", \\"..X..\\", \\".....\\", \\".....\\"]) \\"YES\\" >>> can_reach_target(5, 5, 1, 0, 0, 4, 4, [\\".....\\", \\".....\\", \\"..X..\\", \\".....\\", \\".....\\"]) \\"NO\\"","solution":"from collections import deque def can_reach_target(n, m, t, sx, sy, tx, ty, grid): # Directions: Right, Down, Left, Up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS Setup queue = deque([(sx, sy, -1, 0)]) # (x, y, last_dir, turns) visited = set([(sx, sy, -1)]) while queue: x, y, last_dir, turns = queue.popleft() # If target is reached within allowed turns if (x, y) == (tx, ty): return \\"YES\\" for idx, (dx, dy) in enumerate(directions): nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.': new_turns = turns if idx == last_dir else turns + 1 if new_turns <= t and (nx, ny, idx) not in visited: visited.add((nx, ny, idx)) queue.append((nx, ny, idx, new_turns)) return \\"NO\\""},{"question":"def count_beautiful_substrings(s: str) -> int: Calculate the number of beautiful substrings (substrings that are palindromes) in the given string of digits. :param s: A string of digits :return: The number of beautiful substrings Examples: >>> count_beautiful_substrings(\\"121\\") 4 >>> count_beautiful_substrings(\\"1\\") 1","solution":"def count_beautiful_substrings(s): This function counts the number of palindromic (beautiful) substrings in the given string of digits s. def is_palindrome(sub): return sub == sub[::-1] count = 0 n = len(s) for i in range(n): for j in range(i, n): if is_palindrome(s[i:j+1]): count += 1 return count"},{"question":"def analyze_running_performance(n, distances, threshold): Analyze running performance. Parameters: n (int): Number of days distances recorded. distances (list of float): List of distances run on each day. threshold (float): Distance threshold. Returns: tuple: maximum distance, total distance above threshold, number of days not run >>> analyze_running_performance(7, [5.0, 10.5, 0.0, 3.2, 6.3, 8.1, 0.0], 5.0) (10.5, 24.9, 2) >>> analyze_running_performance(0, [], 5.0) (0.0, 0.0, 0) >>> analyze_running_performance(5, [0.0, 0.0, 0.0, 0.0, 0.0], 1.0) (0.0, 0.0, 5) >>> analyze_running_performance(4, [1.0, 2.0, 3.0, 4.0], 5.0) (4.0, 0.0, 0) >>> analyze_running_performance(3, [6.0, 7.0, 8.0], 5.0) (8.0, 21.0, 0)","solution":"def analyze_running_performance(n, distances, threshold): Analyze running performance. Parameters: n (int): Number of days distances recorded. distances (list of float): List of distances run on each day. threshold (float): Distance threshold. Returns: tuple: maximum distance, total distance above threshold, number of days not run if n == 0: return (0.0, 0.0, 0) max_distance = max(distances) total_distance_above_threshold = sum(d for d in distances if d > threshold) non_running_days = distances.count(0) return (max_distance, total_distance_above_threshold, non_running_days)"},{"question":"def min_operations_to_sort_books(N: int, books: List[int]) -> int: Returns the minimum number of prefix reverse operations required to sort the books in increasing order. >>> min_operations_to_sort_books(5, [4, 3, 2, 1, 5]) 3 >>> min_operations_to_sort_books(3, [1, 3, 2]) 1","solution":"def min_operations_to_sort_books(N, books): Returns the minimum number of prefix reverse operations required to sort the books in increasing order. longest_prefix = 1 count = 1 for i in range(1, N): if books[i] > books[i-1]: count += 1 else: count = 1 longest_prefix = max(longest_prefix, count) return N - longest_prefix"},{"question":"def min_delivery_time(N, P1, P2): Calculate the minimum time for two delivery drones to meet in zones. Parameters: N (int): The number of zones arranged in a circle. P1 (int): The starting zone of the first drone. P2 (int): The starting zone of the second drone. Returns: int: The minimum time required for the drones to meet. from solution import min_delivery_time def test_drones_same_position(): assert min_delivery_time(5, 1, 1) == 0 assert min_delivery_time(10, 5, 5) == 0 def test_drones_adjacent(): assert min_delivery_time(5, 1, 2) == 1 assert min_delivery_time(5, 2, 1) == 1 def test_wrap_around(): assert min_delivery_time(5, 1, 5) == 1 assert min_delivery_time(5, 5, 1) == 1 def test_general_case(): assert min_delivery_time(5, 1, 3) == 2 assert min_delivery_time(4, 2, 4) == 2 assert min_delivery_time(6, 6, 5) == 1 def test_large_case(): assert min_delivery_time(1000000000, 123456789, 987654321) == min((987654321 - 123456789) % 1000000000, (123456789 - 987654321) % 1000000000)","solution":"def min_delivery_time(N, P1, P2): Calculate the minimum time for two delivery drones to meet in zones. Parameters: N (int): The number of zones arranged in a circle. P1 (int): The starting zone of the first drone. P2 (int): The starting zone of the second drone. Returns: int: The minimum time required for the drones to meet. if P1 == P2: return 0 clockwise_distance = (P2 - P1) % N counter_clockwise_distance = (P1 - P2) % N return min(clockwise_distance, counter_clockwise_distance)"},{"question":"from typing import List def longest_consecutive_sequence(nums: List[int]) -> int: Write a function \`longest_consecutive_sequence(nums: List[int]) -> int\` that takes a list of unsorted integers and returns the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([1, 2, 0, 1]) 3 >>> longest_consecutive_sequence([1, 3, 5, 2, 4]) 5 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([10]) 1 >>> longest_consecutive_sequence([-1, 1, 0]) 3 >>> longest_consecutive_sequence([1, 2, 2, 3]) 3 def test_longest_consecutive_sequence(): assert longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4 assert longest_consecutive_sequence([1, 2, 0, 1]) == 3 assert longest_consecutive_sequence([1, 3, 5, 2, 4]) == 5 assert longest_consecutive_sequence([]) == 0 assert longest_consecutive_sequence([10]) == 1 assert longest_consecutive_sequence([-1, 1, 0]) == 3 assert longest_consecutive_sequence([1, 2, 2, 3]) == 3 def test_longest_consecutive_sequence_with_duplicates(): assert longest_consecutive_sequence([1, 2, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10]) == 10 def test_longest_consecutive_sequence_with_negative_numbers(): assert longest_consecutive_sequence([-2, -3, -1, 2, 0, 1]) == 6","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # only start counting at the beginning of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"import itertools from typing import List def shortest_hike_path(n: int, distances: List[List[int]]) -> int: Return the total distance of the shortest path that visits each point exactly once and returns to the starting point. :param n: Number of points of interest :param distances: A list of lists where distances[i][j] is the distance from point i to point j :return: Total distance of the shortest path >>> shortest_hike_path(3, [[0, 29, 20], [29, 0, 15], [20, 15, 0]]) 64 >>> shortest_hike_path(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) 80 >>> shortest_hike_path(4, [[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]]) 4 >>> shortest_hike_path(4, [[0, 2, 9, 10], [1, 0, 6, 4], [15, 7, 0, 8], [6, 3, 12, 0]]) 21","solution":"import itertools def shortest_hike_path(n, distances): Return the total distance of the shortest path that visits each point exactly once and returns to the starting point. :param n: Number of points of interest :param distances: A list of lists where distances[i][j] is the distance from point i to point j :return: Total distance of the shortest path points = range(n) min_path_cost = float('inf') for perm in itertools.permutations(points): current_cost = 0 for i in range(n): current_cost += distances[perm[i]][perm[(i + 1) % n]] min_path_cost = min(min_path_cost, current_cost) return min_path_cost"},{"question":"def can_split_balls(n: int, W: int, weights: List[int]) -> Tuple[str, Optional[List[int]], Optional[List[int]]]: Determine if it is possible to split balls into two groups such that the total weight of each group is less than or equal to the weight limit W. If possible, return \\"YES\\" followed by two lists of indices representing the two groups. If not, return \\"NO\\". :param n: int - Number of balls :param W: int - Weight limit for each group :param weights: List[int] - List of weights of the balls :return: Tuple containing: - \\"YES\\" or \\"NO\\" - If \\"YES\\", two lists of indices representing the two groups. If \\"NO\\", None and None. pass from typing import List, Tuple, Optional # Example usage: # >>> can_split_balls(5, 10, [1, 2, 3, 4, 5]) # (\\"YES\\", [1, 2, 3], [4, 5]) # >>> can_split_balls(4, 7, [3, 3, 3, 3]) # (\\"YES\\", [1, 2], [3, 4]) # >>> can_split_balls(3, 4, [5, 6, 7]) # (\\"NO\\", None, None)","solution":"def can_split_balls(n, W, weights): Determine if it is possible to split balls into two groups such that the weight of each group is <= W. If possible, return \\"YES\\" followed by two lines of indices. If not, return \\"NO\\". from itertools import combinations # Generate all possible combinations for half the balls or more for k in range(1, n): for combo in combinations(range(n), k): group1_weight = sum(weights[i] for i in combo) group2_weight = sum(weights[i] for i in range(n) if i not in combo) if group1_weight <= W and group2_weight <= W: group1 = [i + 1 for i in combo] group2 = [i + 1 for i in range(n) if i not in combo] return \\"YES\\", group1, group2 return \\"NO\\", None, None"},{"question":"def min_integer_with_digit_sum(n): Returns the minimum integer m such that the sum of the digits of m is equal to n. >>> min_integer_with_digit_sum(1) 1 >>> min_integer_with_digit_sum(9) 9 >>> min_integer_with_digit_sum(10) 19 >>> min_integer_with_digit_sum(11) 29 >>> min_integer_with_digit_sum(18) 99 >>> min_integer_with_digit_sum(20) 299 >>> min_integer_with_digit_sum(5) 5 >>> min_integer_with_digit_sum(27) 999 pass def process_tests(test_cases): Processes a list of test cases and returns a list of results for each test case. >>> process_tests([1, 9, 10]) [1, 9, 19] >>> process_tests([11, 18, 20]) [29, 99, 299] >>> process_tests([5, 27]) [5, 999] pass","solution":"def min_integer_with_digit_sum(n): Returns the minimum integer m such that the sum of the digits of m is equal to n. if n <= 9: return n digits = [] while n > 0: if n >= 9: digits.append(9) n -= 9 else: digits.append(n) n = 0 digits.reverse() return int(\\"\\".join(map(str, digits))) def process_tests(test_cases): Processes a list of test cases and returns a list of results for each test case. results = [] for n in test_cases: results.append(min_integer_with_digit_sum(n)) return results"},{"question":"def find_min_sum_indices(arr): Find the pair of indices (i, j) such that every integer in the array is divisible by the GCD of the integers at the provided indices. Among all such pairs, find the pair with the minimum sum of the indices. If there are multiple such pairs, return the one with the smaller first index. >>> find_min_sum_indices([10, 15, 100, 90]) (1, 2) >>> find_min_sum_indices([8, 4, 16]) (1, 2) def process_test_cases(test_cases): Processes multiple test cases and returns the results. >>> test_cases = [(4, [10, 15, 100, 90]), (3, [8, 4, 16])] >>> process_test_cases(test_cases) [(1, 2), (1, 2)]","solution":"from math import gcd from itertools import combinations def find_min_sum_indices(arr): n = len(arr) min_sum = float('inf') best_pair = (-1, -1) for i, j in combinations(range(n), 2): g = gcd(arr[i], arr[j]) if all(a % g == 0 for a in arr): if i + j < min_sum or (i + j == min_sum and i < best_pair[0]): min_sum = i + j best_pair = (i, j) # Convert 0-based indices to 1-based as required in the problem statement return best_pair[0] + 1, best_pair[1] + 1 def process_test_cases(test_cases): results = [] for (n, arr) in test_cases: results.append(find_min_sum_indices(arr)) return results"},{"question":"def process_queries(array, queries): Alice receives an array of integers and a series of query ranges. For each query range, she wants to determine the sum of all elements in the array within that range and find the maximum frequency of any element within this subarray. Args: array (List[int]): List of integers queries (List[Tuple[int, int]]): List of queries where each query is a tuple (l, r) representing the range Returns: List[Tuple[int, int]]: List of results where each result is a tuple containing the sum of the subarray and the maximum frequency of any element in the subarray Examples: >>> process_queries([1, 2, 2, 3, 1], [(1,3), (2,5), (1,5)]) [(5,2), (8,2), (9,2)] >>> process_queries([1, 2, 3, 4, 5], [(1,5)]) [(15,1)] >>> process_queries([42], [(1,1)]) [(42,1)] results = [] prefix_sum = [0] * (len(array) + 1) # Compute prefix sums for efficient range sum queries for i in range(1, len(array) + 1): prefix_sum[i] = prefix_sum[i - 1] + array[i - 1] for l, r in queries: # Calculate the sum for range [l-1, r-1] total_sum = prefix_sum[r] - prefix_sum[l - 1] # Determine the maximum frequency in the range freq_map = defaultdict(int) max_freq = 0 for i in range(l - 1, r): freq_map[array[i]] += 1 if freq_map[array[i]] > max_freq: max_freq = freq_map[array[i]] results.append((total_sum, max_freq)) return results","solution":"from collections import defaultdict def process_queries(array, queries): results = [] prefix_sum = [0] * (len(array) + 1) # Compute prefix sums for efficient range sum queries for i in range(1, len(array) + 1): prefix_sum[i] = prefix_sum[i - 1] + array[i - 1] for l, r in queries: # Calculate the sum for range [l-1, r-1] total_sum = prefix_sum[r] - prefix_sum[l - 1] # Determine the maximum frequency in the range freq_map = defaultdict(int) max_freq = 0 for i in range(l - 1, r): freq_map[array[i]] += 1 if freq_map[array[i]] > max_freq: max_freq = freq_map[array[i]] results.append((total_sum, max_freq)) return results"},{"question":"def calculate_slope(x1, y1, x2, y2): Returns the slope of the line passing through the points (x1, y1) and (x2, y2). If the slope is undefined (i.e., the line is vertical), the function returns \\"undefined\\". >>> calculate_slope(1, 2, 3, 4) 1.0 >>> calculate_slope(2, 5, 2, 8) \\"undefined\\" >>> calculate_slope(0, 0, 1, 2) 2.0 >>> calculate_slope(1, 1, 2, 4) 3.0","solution":"def calculate_slope(x1, y1, x2, y2): Returns the slope of the line passing through the points (x1, y1) and (x2, y2). If the slope is undefined (i.e., the line is vertical), the function returns \\"undefined\\". if x1 == x2: # vertical line return \\"undefined\\" return (y2 - y1) / (x2 - x1)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Return the lowest common ancestor (LCA) of two nodes in the binary tree. pass import pytest @pytest.fixture def tree(): # create the binary tree from example: # 3 # / # 5 1 # / / # 6 2 0 8 # / # 7 4 root = TreeNode(3) root.left = TreeNode(5) root.right = TreeNode(1) root.left.left = TreeNode(6) root.left.right = TreeNode(2) root.left.right.left = TreeNode(7) root.left.right.right = TreeNode(4) root.right.left = TreeNode(0) root.right.right = TreeNode(8) return root def test_lca_root(tree): p = tree.left # Node 5 q = tree.right # Node 1 lca = lowest_common_ancestor(tree, p, q) assert lca == tree # Node 3 def test_lca_left_subtree(tree): p = tree.left # Node 5 q = tree.left.right.right # Node 4 lca = lowest_common_ancestor(tree, p, q) assert lca == tree.left # Node 5 def test_lca_different_subtrees(tree): p = tree.left.left # Node 6 q = tree.right.right # Node 8 lca = lowest_common_ancestor(tree, p, q) assert lca == tree # Node 3 def test_lca_same_parent(tree): p = tree.left.right.left # Node 7 q = tree.left.right.right # Node 4 lca = lowest_common_ancestor(tree, p, q) assert lca == tree.left.right # Node 2 def test_lca_node_is_lca(tree): p = tree.left # Node 5 q = tree.left.left # Node 6 lca = lowest_common_ancestor(tree, p, q) assert lca == tree.left # Node 5","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Returns the lowest common ancestor (LCA) of two nodes in the binary tree. if not root or root == p or root == q: return root left = lowest_common_ancestor(root.left, p, q) right = lowest_common_ancestor(root.right, p, q) if left and right: return root return left if left else right"},{"question":"def sort_vowels_and_consonants(s: str) -> str: Returns a string where all vowels come before consonants while preserving their relative order. >>> sort_vowels_and_consonants(\\"example\\") 'eae xmpl' >>> sort_vowels_and_consonants(\\"computer\\") 'oue cmptr' >>> sort_vowels_and_consonants(\\"hello\\") 'eo hll' >>> sort_vowels_and_consonants(\\"a\\") 'a ' >>> sort_vowels_and_consonants(\\"b\\") ' b' >>> sort_vowels_and_consonants(\\"aeiou\\") 'aeiou ' >>> sort_vowels_and_consonants(\\"bcdfg\\") ' bcdfg' >>> sort_vowels_and_consonants(\\"programming\\") 'oai prgrmmng'","solution":"def sort_vowels_and_consonants(s): Returns a string where all vowels come before consonants while preserving their relative order. vowels = 'aeiou' vowel_part = \\"\\".join([char for char in s if char in vowels]) consonant_part = \\"\\".join([char for char in s if char not in vowels]) return vowel_part + \\" \\" + consonant_part"},{"question":"from typing import List, Tuple def min_distance(points: List[Tuple[int, int]]) -> int: Calculate the minimum distance to visit all the points in a sequence. >>> min_distance([(1, 1), (3, 3), (5, 5)]) 4 >>> min_distance([(10, 10), (20, 20)]) 10 >>> min_distance([(1, 1), (1, 1)]) 0 >>> min_distance([(0, 0), (-3, -3)]) 3 >>> min_distance([(0, 0), (3, -3)]) 3 pass def solve(t: int, test_cases: List[List[Tuple[int, int]]]) -> List[int]: Solve the problem for a number of test cases. >>> solve(2, [[(1, 1), (3, 3), (5, 5)], [(10, 10), (20, 20)]]) [4, 10] pass","solution":"def min_distance(points): Calculate the minimum distance to visit all the points in a sequence. def distance(p1, p2): Calculate the step distance between two points considering movements in 8 possible directions (horizontal, vertical, diagonal). return max(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) total_distance = 0 for i in range(len(points) - 1): total_distance += distance(points[i], points[i+1]) return total_distance def solve(t, test_cases): results = [] for i in range(t): points = test_cases[i] min_dist = min_distance(points) results.append(min_dist) return results"},{"question":"def max_customers_seated(n: int, customer_data: List[Tuple[int, int]]) -> int: Determine the maximum number of customers that can be seated such that the overall stress is minimized. Parameters: n (int): The number of customers. customer_data (List[Tuple[int, int]]): A list of tuples where each tuple contains the satisfaction level and stress level of a customer. Returns: int: The maximum number of customers that can be seated with minimized stress. Examples: >>> max_customers_seated(5, [(5, 4), (3, 6), (8, 9), (2, 10), (6, 3)]) 3 >>> max_customers_seated(4, [(7, 6), (5, 8), (3, 10), (6, 4)]) 2 >>> max_customers_seated(6, [(8, 7), (2, 3), (4, 9), (1, 10), (7, 4), (5, 5)]) 4 pass # Implement the function here import pytest from solution import max_customers_seated def test_example1(): assert max_customers_seated(5, [(5, 4), (3, 6), (8, 9), (2, 10), (6, 3)]) == 3 def test_example2(): assert max_customers_seated(4, [(7, 6), (5, 8), (3, 10), (6, 4)]) == 2 def test_example3(): assert max_customers_seated(6, [(8, 7), (2, 3), (4, 9), (1, 10), (7, 4), (5, 5)]) == 4 def test_all_stress_high(): assert max_customers_seated(4, [(1, 8), (2, 9), (3, 10), (4, 8)]) == 0 def test_all_stress_low(): assert max_customers_seated(4, [(5, 3), (6, 2), (7, 1), (8, 4)]) == 4 def test_mixed_stress(): assert max_customers_seated(5, [(2, 10), (6, 2), (7, 4), (5, 10), (8, 5)]) == 3","solution":"def max_customers_seated(n, customer_data): # Filter out the customers with stress level higher than 7 filtered_customers = [i for i in range(n) if customer_data[i][1] < 8] # Calculate the maximum number of customers that can be seated max_customers = 0 for i in range(len(filtered_customers)): count = 0 for j in range(i, len(filtered_customers)): count += 1 if count > max_customers: max_customers = count return max_customers def main(): import sys input = sys.stdin.read data = input().splitlines() n = int(data[0]) customer_data = [] for i in range(1, n + 1): satisfaction, stress = map(int, data[i].split()) customer_data.append((satisfaction, stress)) result = max_customers_seated(n, customer_data) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def final_population(initial_population: int, changes: List[int]) -> int: Calculate the final population after applying daily changes. >>> final_population(1000, [10, -5, 3, -2]) 1006 >>> final_population(1500, [20, -10, 5]) 1515","solution":"def final_population(initial_population, changes): Calculate the final population after applying daily changes. :param initial_population: The initial population of the town :param changes: A list of daily population changes :return: The final population after all changes for change in changes: initial_population += change return initial_population"},{"question":"def maxSubArraySum(nums): Returns the maximum possible sum of elements of any subarray. >>> maxSubArraySum([-2,1,-3,4,-1,2,1,-5,4]]) == 6 >>> maxSubArraySum([1]) == 1 >>> maxSubArraySum([5,4,-1,7,8]) == 23 >>> maxSubArraySum([-1, -2, -3, -4]) == -1 >>> maxSubArraySum([0, -2, 3, 5, -1, 2, -4]) == 9 >>> maxSubArraySum([8, -19, 5, -4, 20]) == 21 >>> maxSubArraySum([-5]) == -5 >>> maxSubArraySum([-2, 1]) == 1 >>> maxSubArraySum([-2, -3, 4]) == 4","solution":"def maxSubArraySum(nums): Returns the maximum possible sum of elements of any subarray. max_so_far = nums[0] max_ending_here = nums[0] for i in range(1, len(nums)): max_ending_here = max(nums[i], max_ending_here + nums[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def count_partitions(n: int) -> int: Returns the number of ways to express n as a sum of positive integers, where the order of summands does not matter. >>> count_partitions(4) 5 >>> count_partitions(6) 11","solution":"def count_partitions(n): Returns the number of ways to express n as a sum of positive integers, where the order of summands does not matter. # Initialize a list to store the number of partitions for each value up to n partitions = [0] * (n + 1) partitions[0] = 1 # There's one way to partition 0 (using no parts) # Iterate through each number from 1 to n and update the partitions list for i in range(1, n + 1): for j in range(i, n + 1): partitions[j] += partitions[j - i] return partitions[n]"},{"question":"def trap(height: List[int]) -> int: Given a list of non-negative integers representing the amount of rainwater trapped at each bar of a histogram where the width of each bar is 1, return the total amount of rainwater trapped. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9","solution":"def trap(height): Returns the total amount of rainwater trapped. :param height: List[int], a list of non-negative integers representing the histogram bars. :return: int, the total amount of rainwater trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def mergeSortArrays(A, B): Merges two lists A and B into a single sorted list in non-decreasing order. :param A: List of integers. :param B: List of integers. :return: A single merged and sorted list. >>> mergeSortArrays([5, 1, 3], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> mergeSortArrays([10, 5], [7, 3, 1]) [1, 3, 5, 7, 10] pass import pytest from solution import mergeSortArrays def test_example_1(): assert mergeSortArrays([5, 1, 3], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] def test_example_2(): assert mergeSortArrays([10, 5], [7, 3, 1]) == [1, 3, 5, 7, 10] def test_empty_A(): assert mergeSortArrays([], [1, 2, 3]) == [1, 2, 3] def test_empty_B(): assert mergeSortArrays([4, 5, 6], []) == [4, 5, 6] def test_both_empty(): assert mergeSortArrays([], []) == [] def test_identical_arrays(): assert mergeSortArrays([1, 2, 3], [1, 2, 3]) == [1, 1, 2, 2, 3, 3] def test_different_sizes(): assert mergeSortArrays([9, 8, 7, 6], [5]) == [5, 6, 7, 8, 9] def test_reverse_ordered_inputs(): assert mergeSortArrays([10, 9, 8], [7, 6, 5]) == [5, 6, 7, 8, 9, 10] def test_large_numbers(): assert mergeSortArrays([10000], [9999]) == [9999, 10000] def test_single_element(): assert mergeSortArrays([3], [1, 2]) == [1, 2, 3]","solution":"def mergeSortArrays(A, B): Merges two lists A and B into a single sorted list in non-decreasing order. :param A: List of integers. :param B: List of integers. :return: A single merged and sorted list. # Combine both lists combined = A + B # Sort the combined list combined.sort() return combined"},{"question":"def is_subsequence(s1: str, s2: str) -> bool: Determines if s1 is a subsequence of s2. >>> is_subsequence('abc', 'ahbgdc') True >>> is_subsequence('axc', 'ahbgdc') False >>> is_subsequence('ace', 'abcde') True >>> is_subsequence('', 'anything') True >>> is_subsequence('anything', '') False >>> is_subsequence('', '') True >>> is_subsequence('subsequence', 'subsequence') True >>> is_subsequence('abc', 'cab') False","solution":"def is_subsequence(s1: str, s2: str) -> bool: Determines if s1 is a subsequence of s2. if not s1: return True if not s2: return False iter_s2 = iter(s2) return all(char in iter_s2 for char in s1)"},{"question":"def length_of_lis(nums: List[int]) -> int: Returns the length of the longest increasing subsequence in the list nums. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([0, 1, 0, 3, 2, 3]) 4 >>> length_of_lis([7, 7, 7, 7, 7, 7, 7]) 1","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the list nums. if not nums: return 0 # dp array to store the length of the longest increasing subsequence dp = [1] * len(nums) # Loop through the list to fill the dp array for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence will be the maximum value in dp array return max(dp)"},{"question":"def multiplyStrings(str1: str, str2: str) -> str: Multiplies two large numbers represented as strings and returns the product as a string. >>> multiplyStrings(\\"123\\", \\"456\\") \\"56088\\" >>> multiplyStrings(\\"0\\", \\"98765\\") \\"0\\" >>> multiplyStrings(\\"9\\", \\"8\\") \\"72\\" >>> multiplyStrings(\\"123456789\\", \\"987654321\\") \\"121932631112635269\\" >>> multiplyStrings(\\"1000\\", \\"0\\") \\"0\\" >>> multiplyStrings(\\"1\\", \\"123456\\") \\"123456\\" >>> multiplyStrings(\\"123\\", \\"456789\\") \\"56185047\\"","solution":"def multiplyStrings(str1, str2): Multiplies two large numbers represented as strings and returns the product as a string. if str1 == \\"0\\" or str2 == \\"0\\": return \\"0\\" len1 = len(str1) len2 = len(str2) result = [0] * (len1 + len2) for i in range(len1 - 1, -1, -1): for j in range(len2 - 1, -1, -1): mul = int(str1[i]) * int(str2[j]) sum = mul + result[i + j + 1] result[i + j + 1] = sum % 10 result[i + j] += sum // 10 result = ''.join(map(str, result)) return result.lstrip('0')"},{"question":"def longestSubstringWithTwoDistinctChars(s: str) -> int: Returns the length of the longest substring that contains at most 2 distinct characters. >>> longestSubstringWithTwoDistinctChars(\\"eceba\\") 3 >>> longestSubstringWithTwoDistinctChars(\\"ccaabbb\\") 5 >>> longestSubstringWithTwoDistinctChars(\\"abcabcabc\\") 2","solution":"def longestSubstringWithTwoDistinctChars(s: str) -> int: Returns the length of the longest substring that contains at most 2 distinct characters. n = len(s) if n < 3: return n # Sliding window left and right pointers left = 0 right = 0 # HashMap that holds the character count in the current window hashmap = {} max_len = 2 while right < n: if len(hashmap) < 3: hashmap[s[right]] = right right += 1 if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"def longest_unique_genres_subarray(N: int, M: int, genres: List[int]) -> int: Determine the length of the longest subarray with all unique genres. :param N: The number of books on the shelf. :param M: The number of different genres. :param genres: A list of integers representing the genres of the books. :return: The length of the longest subarray with all unique genres. >>> longest_unique_genres_subarray(7, 5, [1, 2, 1, 3, 4, 2, 5]) 5 >>> longest_unique_genres_subarray(5, 3, [1, 2, 3, 1, 2]) 3 >>> longest_unique_genres_subarray(8, 4, [4, 3, 2, 1, 4, 3, 2, 1]) 4 >>> longest_unique_genres_subarray(10, 6, [1, 2, 3, 4, 5, 6, 3, 4, 5, 6]) 6 >>> longest_unique_genres_subarray(6, 6, [1, 2, 3, 4, 5, 6]) 6 >>> longest_unique_genres_subarray(8, 4, [1, 2, 1, 2, 1, 2, 1, 2]) 2 >>> longest_unique_genres_subarray(5, 1, [1, 1, 1, 1, 1]) 1","solution":"def longest_unique_genres_subarray(N, M, genres): genre_index_map = {} start = 0 max_length = 0 for end in range(N): if genres[end] in genre_index_map: start = max(start, genre_index_map[genres[end]] + 1) genre_index_map[genres[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def move_zeroes(nums): Moves all zeros in the integer array to the end while maintaining the relative order of non-zero elements. >>> move_zeroes([0, 1, 0, 3, 12]) [1, 3, 12, 0, 0] >>> move_zeroes([0, 0, 1]) [1, 0, 0] >>> move_zeroes([0, 0, 0, 0, 0]) [0, 0, 0, 0, 0] >>> move_zeroes([1, 2, 3, 4]) [1, 2, 3, 4] >>> move_zeroes([2, 0, 1, 0, 3, 0, 4]) [2, 1, 3, 4, 0, 0, 0] # Implementation here","solution":"def move_zeroes(nums): Moves all zeros in the integer array to the end while maintaining the relative order of non-zero elements. last_non_zero_found_at = 0 # If the current element is not 0, then we need to append it to the end of the last non-zero found position. for i in range(len(nums)): if nums[i] != 0: nums[last_non_zero_found_at] = nums[i] last_non_zero_found_at += 1 # After we have finished processing new elements, all the remaining elements should be 0 for i in range(last_non_zero_found_at, len(nums)): nums[i] = 0 return nums"},{"question":"def first_non_repeating_character_index(T: int, strings: List[str]) -> List[int]: Given a list of strings, this function returns a list with the index of the first non-repeating character for each string. If all characters are repeating, returns -1 for that string. Parameters: T (int): Number of test cases strings (List[str]): List of test case strings Returns: List[int]: List of indices of the first non-repeating character for each test case string. Examples: >>> first_non_repeating_character_index(1, [\\"leetcode\\"]) [0] >>> first_non_repeating_character_index(1, [\\"loveleetcode\\"]) [2] >>> first_non_repeating_character_index(1, [\\"aabbccddeeff\\"]) [-1]","solution":"def first_non_repeating_character_index(T, strings): Given a list of strings, this function returns a list with the index of the first non-repeating character for each string. If all characters are repeating, returns -1 for that string. results = [] for S in strings: # Dictionary to store the frequency of characters char_count = {} # Count occurrences of each character in the string for char in S: char_count[char] = char_count.get(char, 0) + 1 # Find the first character that appears only once found = False for index, char in enumerate(S): if char_count[char] == 1: results.append(index) found = True break # If there are no non-repeating characters if not found: results.append(-1) return results"},{"question":"def rearrange_string(s: str) -> str: Takes a string containing a mix of letters and digits, and returns a new string where all the digits are moved to the front, preserving the order of characters and digits seen in the input. >>> rearrange_string(\\"a1b2c3\\") '123abc' >>> rearrange_string(\\"abcdef\\") 'abcdef' >>> rearrange_string(\\"123456\\") '123456' >>> rearrange_string(\\"\\") '' >>> rearrange_string(\\"1a2b3\\") '123ab' >>> rearrange_string(\\"abc\\") 'abc'","solution":"def rearrange_string(s): Takes a string containing a mix of letters and digits, and returns a new string where all the digits are moved to the front, preserving the order of characters and digits seen in the input. digits = ''.join([char for char in s if char.isdigit()]) letters = ''.join([char for char in s if char.isalpha()]) return digits + letters"},{"question":"from typing import List, Tuple def total_distance(points: List[Tuple[int, int]]) -> float: Calculates the total Euclidean distance traveled given a list of coordinates. Args: points (list of tuples): List of (x, y) coordinates. Returns: float: Total distance traveled rounded to two decimal places. pass def forestia_biodiversity_tracking(test_cases: List[List[Tuple[int, int]]]) -> List[Tuple[int, float]]: Processes multiple test cases to compute the total distance traveled for each set of coordinates. Args: test_cases (list of lists): List containing test cases where each test case is a list of (x, y) coordinates. Returns: list of tuples: Each tuple contains the test case number and the computed total distance. pass # Unit Test def test_total_distance(): assert total_distance([(0, 0), (3, 4), (0, 8)]) == 10.00 assert total_distance([(1, 1), (2, 2), (3, 3), (4, 4)]) == 4.24 assert total_distance([(0, 0), (0, 0)]) == 0.00 assert total_distance([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)]) == 4.00 def test_forestia_biodiversity_tracking(): test_cases = [ [(0, 0), (3, 4), (0, 8)], [(1, 1), (2, 2), (3, 3), (4, 4)] ] results = forestia_biodiversity_tracking(test_cases) assert results == [(1, 10.00), (2, 4.24)] test_cases = [ [(0, 0), (0, 0)], [(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)] ] results = forestia_biodiversity_tracking(test_cases) assert results == [(1, 0.00), (2, 4.00)] test_cases = [ [(1000, 1000), (-1000, -1000)], [(0, 0), (1, 1)] ] results = forestia_biodiversity_tracking(test_cases) assert results == [(1, 2828.43), (2, 1.41)]","solution":"from math import sqrt def total_distance(points): Calculates the total Euclidean distance traveled given a list of coordinates. Args: points (list of tuples): List of (x, y) coordinates. Returns: float: Total distance traveled rounded to two decimal places. total_dist = 0.0 for i in range(1, len(points)): x1, y1 = points[i-1] x2, y2 = points[i] dist = sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) total_dist += dist return round(total_dist, 2) def forestia_biodiversity_tracking(test_cases): Processes multiple test cases to compute the total distance traveled for each set of coordinates. Args: test_cases (list of lists): List containing test cases where each test case is a list of (x, y) coordinates. Returns: list of tuples: Each tuple contains the test case number and the computed total distance. results = [] for i, points in enumerate(test_cases): dist = total_distance(points) results.append((i + 1, dist)) return results"},{"question":"def unique_paths(m: int, n: int, grid: List[List[str]]) -> int: Determine the number of unique paths in an M x N grid. The grid is represented by a list of lists of characters, where '.' indicates an empty cell and '#' indicates an obstacle. The hunter can move either right or down at each step. >>> unique_paths(3, 3, [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) 6 >>> unique_paths(3, 3, [['.', '#', '.'], ['.', '.', '.'], ['#', '.', '.']]) 2 >>> unique_paths(3, 3, [['.', '#', '.'], ['#', '#', '.'], ['.', '.', '.']]) 0 >>> unique_paths(1, 1, [['.']]) 1 >>> unique_paths(3, 3, [['#', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) 0 >>> unique_paths(3, 3, [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '#']]) 0","solution":"def unique_paths(m, n, grid): if grid[0][0] == '#' or grid[m-1][n-1] == '#': return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1] def main(): import sys input = sys.stdin.read data = input().splitlines() m, n = map(int, data[0].split()) grid = [list(line) for line in data[1:m+1]] print(unique_paths(m, n, grid)) if __name__ == \\"__main__\\": main()"},{"question":"def sum_of_squares(numbers: List[int]) -> int: Returns the sum of the squares of each element in the list. If the list is empty, return 0. Args: numbers (List[int]): A list of integers. Returns: int: Sum of the squares of each element. Examples: >>> sum_of_squares([1, 2, 3]) 14 >>> sum_of_squares([0, -4, 5]) 41 >>> sum_of_squares([]) 0 >>> sum_of_squares([10, -2]) 104","solution":"def sum_of_squares(numbers): Returns the sum of the squares of each element in the list. If the list is empty, return 0. return sum(x ** 2 for x in numbers)"},{"question":"def redact_configurations(k: int, redact_keys: List[str], n: int, config_lines: List[str]) -> List[str]: Redacts specific keys in the configuration file. Args: k (int): The number of keys to redact. redact_keys (list of str): The list of keys that need to be redacted. n (int): The number of lines in the configuration file. config_lines (list of str): The list of configuration lines in the form KEY=VALUE. Returns: list of str: The updated configuration lines after redaction. >>> redact_configurations(2, ['PASSWORD', 'API_KEY'], 5, ['USERNAME=admin', 'PASSWORD=secret123', 'HOST=localhost', 'API_KEY=abcd1234', 'PORT=8080']) ['USERNAME=admin', 'PASSWORD=REDACTED', 'HOST=localhost', 'API_KEY=REDACTED', 'PORT=8080'] >>> redact_configurations(1, ['TOKEN'], 3, ['USER_ID=42', 'TOKEN=db790f', 'MODE=production']) ['USER_ID=42', 'TOKEN=REDACTED', 'MODE=production'] >>> redact_configurations(0, [], 3, ['USER_ID=42', 'TOKEN=db790f', 'MODE=production']) ['USER_ID=42', 'TOKEN=db790f', 'MODE=production'] >>> redact_configurations(3, ['USER_ID', 'TOKEN', 'MODE'], 3, ['USER_ID=42', 'TOKEN=db790f', 'MODE=production']) ['USER_ID=REDACTED', 'TOKEN=REDACTED', 'MODE=REDACTED'] >>> redact_configurations(2, ['DB_PASSWORD', 'API_KEY'], 4, ['DB_USER=root', 'DB_PASSWORD=qwerty', 'API_KEY=abcd1234', 'PORT=8080']) ['DB_USER=root', 'DB_PASSWORD=REDACTED', 'API_KEY=REDACTED', 'PORT=8080']","solution":"def redact_configurations(k, redact_keys, n, config_lines): Redacts specific keys in the configuration file. Args: k (int): The number of keys to redact. redact_keys (list of str): The list of keys that need to be redacted. n (int): The number of lines in the configuration file. config_lines (list of str): The list of configuration lines in the form KEY=VALUE. Returns: list of str: The updated configuration lines after redaction. redacted_configs = [] redact_set = set(redact_keys) for line in config_lines: key, value = line.split('=', 1) if key in redact_set: redacted_configs.append(f\\"{key}=REDACTED\\") else: redacted_configs.append(line) return redacted_configs"},{"question":"def unmet_water_requirement(n: int, d: int, water_requirements: List[int]) -> int: Calculate the total amount of unmet water requirement for all plants. >>> unmet_water_requirement(3, 4, [3, 6, 2]) 2 >>> unmet_water_requirement(5, 10, [12, 5, 8, 15, 9]) 7","solution":"def unmet_water_requirement(n, d, water_requirements): Calculate the total amount of unmet water requirement for all plants. :param n: Number of plants :param d: Maximum amount of water that can be provided to each plant daily :param water_requirements: List of water requirements for each plant :return: Total unmet water requirement total_unmet = 0 for requirement in water_requirements: if requirement > d: total_unmet += (requirement - d) return total_unmet # Example usage (for debugging): # n = 3 # d = 4 # water_requirements = [3, 6, 2] # print(unmet_water_requirement(n, d, water_requirements)) # Output: 2"},{"question":"def max_perimeter(sticks: List[int]) -> int: Return the maximum perimeter of a triangle that can be formed with any three sticks. If no valid triangle can be formed, return 0. >>> max_perimeter([2, 1, 2]) == 5 >>> max_perimeter([1, 2, 1]) == 0 >>> max_perimeter([3, 2, 3, 4]) == 10 >>> max_perimeter([3, 6, 2, 3]) == 8","solution":"def max_perimeter(sticks): Return the maximum perimeter of a triangle that can be formed with any three sticks. If no valid triangle can be formed, return 0. # Sort sticks in descending order sticks.sort(reverse=True) # Iterate through sorted sticks and check for valid triangles for i in range(len(sticks) - 2): if sticks[i] < sticks[i + 1] + sticks[i + 2]: # Found a valid triangle return sticks[i] + sticks[i + 1] + sticks[i + 2] # No valid triangle found return 0"},{"question":"def find_pairs(arr: List[int], target: int) -> List[List[int]]: Write a function that takes an array of integers and a target integer. The function should return all unique pairs of integers from the array that add up to the target integer. Each pair should be returned as an array with two elements, and the pairs themselves should be returned in an array. If no such pairs exist, return an empty array. The returned pairs should be in ascending order based on the first element of each pair, and within each pair, the smaller element should come first. >>> find_pairs([1, 2, 3, 4, 3, 2], 5) [[1, 4], [2, 3]] >>> find_pairs([1, 2, 2, 3, 3, 4], 6) [[2, 4], [3, 3]] >>> find_pairs([1, 1, 1, 1], 2) [[1, 1]] >>> find_pairs([5, 5, 5], 10) [[5, 5]] >>> find_pairs([1, 2, 3, 4], 8) [] from solution import find_pairs def test_find_pairs_example1(): assert find_pairs([1, 2, 3, 4, 3, 2], 5) == [[1, 4], [2, 3]] def test_find_pairs_example2(): assert find_pairs([1, 2, 2, 3, 3, 4], 6) == [[2, 4], [3, 3]] def test_find_pairs_example3(): assert find_pairs([1, 1, 1, 1], 2) == [[1, 1]] def test_find_pairs_example4(): assert find_pairs([5, 5, 5], 10) == [[5, 5]] def test_find_pairs_example5(): assert find_pairs([1, 2, 3, 4], 8) == [] def test_find_pairs_no_removal_of_duplicates(): assert find_pairs([1, 2, 3, 4, 3], 5) == [[1, 4], [2, 3]] def test_find_pairs_large_input(): assert find_pairs([10, 1, 9, 3, 7, 5], 12) == [[3, 9], [5, 7]]","solution":"def find_pairs(arr, target): Returns a list of unique pairs from the array that add up to the target. Each pair is in ascending order and the list of pairs is sorted based on the first element. pairs = set() arr.sort() seen = {} for num in arr: complement = target - num if complement in seen and seen[complement] > 0: pairs.add((min(num, complement), max(num, complement))) seen[complement] -= 1 else: if num in seen: seen[num] += 1 else: seen[num] = 1 result = [list(pair) for pair in pairs] result.sort() return result"},{"question":"def find_median(arr: List[int]) -> int: Find and return the median of the array without using any in-built sort functions. >>> find_median([3, 1, 4, 1, 5]) 3 >>> find_median([13, 7, 9, 1, 8, 5, 10]) 8 >>> find_median([10]) 10 >>> find_median([1, 2, 3, 4, 5]) 3 >>> find_median([5, 4, 3, 2, 1]) 3 >>> find_median([11, 3, 7, 1, 5, 9, 13]) 7 pass","solution":"def find_median(arr): Find the median of an array without using any in-built sort functions. def quicksort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right) sorted_arr = quicksort(arr) median_idx = len(sorted_arr) // 2 return sorted_arr[median_idx] # Example usage: # arr = [3, 1, 4, 1, 5] # print(find_median(arr)) # Output: 3"},{"question":"def calculate_gcd(input_pairs: List[Tuple[int, int]]) -> List[int]: Calculate the GCD of each pair of integers. Args: input_pairs (list of tuples): List of tuples where each tuple contains two integers (a, b) Returns: list: List of GCDs for each pair of integers. Examples: >>> calculate_gcd([(15, 25), (25, 30), (17, 19)]) [5, 5, 1] >>> calculate_gcd([(1, 1), (1, 1)]) [1, 1] >>> calculate_gcd([(13, 17), (19, 23), (29, 31)]) [1, 1, 1]","solution":"import math def calculate_gcd(input_pairs): Calculate the GCD of each pair of integers. Args: input_pairs (list of tuples): List of tuples where each tuple contains two integers (a, b) Returns: list: List of GCDs for each pair of integers. gcd_list = [] for a, b in input_pairs: gcd_list.append(math.gcd(a, b)) return gcd_list"},{"question":"from typing import List def countDistinct(arr: List[int], k: int) -> List[int]: Given an integer array \`arr\` of size \`n\` and an integer \`k\`, find the count of unique elements in every subarray of size \`k\`. The function should return a list of integers where each integer represents the count of unique elements in the corresponding subarray of \`k\` elements beginning with the first element of \`arr\` and sliding one element to the right each time. >>> countDistinct([4, 1, 1, 2, 3, 4, 5], 3) [2, 2, 3, 3, 3] >>> countDistinct([1, 2, 3, 4, 5], 2) [2, 2, 2, 2] >>> countDistinct([2, 2, 2, 2, 2], 3) [1, 1, 1] >>> countDistinct([1, 2, 2, 3, 4, 4, 5], 4) [3, 3, 3, 3] >>> countDistinct([1, 2, 2, 3, 4], 5) [4] >>> countDistinct([1, 2, 3], 4) []","solution":"def countDistinct(arr, k): This function takes an integer array arr of size n and an integer k, and returns a list of integers representing the count of unique elements in every subarray of size k. n = len(arr) if k > n: return [] # Dictionary to store the frequency of elements freq_map = {} unique_counts = [] # Initialize the frequency map for the first window for i in range(k): if arr[i] in freq_map: freq_map[arr[i]] += 1 else: freq_map[arr[i]] = 1 # Add the count of the first window unique_counts.append(len(freq_map)) # Slide the window over the rest of the array for i in range(1, n - k + 1): # Remove the frequency of the outgoing element if freq_map[arr[i - 1]] == 1: del freq_map[arr[i - 1]] else: freq_map[arr[i - 1]] -= 1 # Add the frequency of the new element if arr[i + k - 1] in freq_map: freq_map[arr[i + k - 1]] += 1 else: freq_map[arr[i + k - 1]] = 1 # Add the count of the current window unique_counts.append(len(freq_map)) return unique_counts"},{"question":"from typing import List, Dict def pixel_frequency(image: List[List[int]]) -> Dict[int, int]: Given a 2D list representing a grayscale image, returns a dictionary where the keys are pixel values and the values are the frequency of each pixel. >>> pixel_frequency([[0, 255, 60], [130, 45, 60], [255, 0, 45]]) {0: 2, 45: 2, 60: 2, 130: 1, 255: 2}","solution":"from typing import List, Dict from collections import defaultdict def pixel_frequency(image: List[List[int]]) -> Dict[int, int]: Given a 2D list representing a grayscale image, returns a dictionary where the keys are pixel values and the values are the frequency of each pixel. frequency = defaultdict(int) for row in image: for value in row: frequency[value] += 1 return dict(frequency)"},{"question":"def is_palindrome(n: int) -> bool: Check if the number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(1331) True >>> is_palindrome(10) False def next_palindrome(x: int) -> int: Find the smallest palindromic number greater than x. >>> next_palindrome(123) 131 >>> next_palindrome(999) 1001 >>> next_palindrome(12321) 12421 >>> next_palindrome(1) 2 >>> next_palindrome(88) 99 >>> next_palindrome(10) 11","solution":"def is_palindrome(n): Check if the number is a palindrome. return str(n) == str(n)[::-1] def next_palindrome(x): Find the smallest palindromic number greater than x. num = x + 1 while not is_palindrome(num): num += 1 return num"},{"question":"def longest_even_char_substring(s: str) -> int: Calculate the length of the longest substring where every character's frequency is even. >>> longest_even_char_substring(\\"abccba\\") 6 >>> longest_even_char_substring(\\"abcd\\") 0 >>> longest_even_char_substring(\\"aabbcc\\") 6","solution":"def longest_even_char_substring(s): def is_even_freq(sub): # Helper function to check if all characters in the substring appear even times from collections import Counter count = Counter(sub) return all(freq % 2 == 0 for freq in count.values()) max_len = 0 n = len(s) # Iterate over all possible substrings and check if they satisfy the condition for i in range(n): for j in range(i+1, n+1): if is_even_freq(s[i:j]): max_len = max(max_len, j-i) return max_len"},{"question":"def calculate_mean(N, numbers): Calculates the mean of a list of numbers and returns it rounded to 4 decimal places. Parameters: N (int): The number of elements in the list. numbers (list): The list of integers. Returns: float: The mean of the numbers, rounded to 4 decimal places. Example usage: >>> calculate_mean(5, [1, 2, 3, 4, 5]) 3.0000 >>> calculate_mean(1, [10]) 10.0000 >>> calculate_mean(3, [-1, -2, -3]) -2.0000 >>> calculate_mean(4, [-1, 2, -3, 4]) 0.5000 >>> calculate_mean(2, [1000000, 2000000]) 1500000.0000 >>> calculate_mean(0, []) 0.0000 >>> calculate_mean(3, [2, 2, 2]) 2.0000","solution":"def calculate_mean(N, numbers): Calculates the mean of a list of numbers and returns it rounded to 4 decimal places. Parameters: N (int): The number of elements in the list. numbers (list): The list of integers. Returns: float: The mean of the numbers, rounded to 4 decimal places. if N == 0: return 0.0000 mean_value = sum(numbers) / N return round(mean_value, 4)"},{"question":"def determine_winner(s: str) -> str: Determines the winner of the game given the initial string s. Parameters: s (str): input string consisting of lowercase English letters Returns: str: \\"Alice\\" if Alice has a winning strategy, otherwise \\"Bob\\" >>> determine_winner(\\"abc\\") \\"Alice\\" >>> determine_winner(\\"aaaaa\\") \\"Bob\\"","solution":"def determine_winner(s): Determines the winner of the game given the initial string s. Parameters: s (str): input string consisting of lowercase English letters Returns: str: \\"Alice\\" if Alice has a winning strategy, otherwise \\"Bob\\" unique_characters = set(s) # Alice wins if there is more than one unique character. # Bob wins if there is only one unique character because Alice can't make a unique move to prevent Bob from winning. if len(unique_characters) > 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def max_subarray_length(n: int, s: int, arr: List[int]) -> int: Finds the maximum number of elements in a subarray such that the sum of its elements is at most s. Parameters: n (int): Number of elements in the array s (int): Maximum allowed sum of the subarray arr (list of int): List of integers representing the array Returns: int: Maximum number of elements in the subarray with sum <= s >>> max_subarray_length(5, 6, [1, 2, 3, 2, 1]) 3 >>> max_subarray_length(6, 10, [4, 2, 2, 1, 5, 1]) 4 pass","solution":"def max_subarray_length(n, s, arr): Finds the maximum number of elements in a subarray such that the sum of its elements is at most s. Parameters: n (int): Number of elements in the array s (int): Maximum allowed sum of the subarray arr (list): List of integers representing the array Returns: int: Maximum number of elements in the subarray with sum <= s max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] # While current_sum exceeds s, move the start pointer to right while current_sum > s: current_sum -= arr[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def nth_fibonacci_modulo(n: int) -> int: Write a function that takes an integer N and returns the N-th Fibonacci number modulo 10^9+7. The Fibonacci sequence is defined as: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 >>> nth_fibonacci_modulo(0) == 0 >>> nth_fibonacci_modulo(1) == 1 >>> nth_fibonacci_modulo(5) == 5 >>> nth_fibonacci_modulo(10) == 55","solution":"def nth_fibonacci_modulo(n: int) -> int: MOD = 10**9 + 7 def matrix_mult(A, B): return [ [(A[0][0] * B[0][0] + A[0][1] * B[1][0]) % MOD, (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % MOD], [(A[1][0] * B[0][0] + A[1][1] * B[1][0]) % MOD, (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % MOD] ] def matrix_pow(mat, exp): res = [[1, 0], [0, 1]] base = mat while exp > 0: if exp % 2 == 1: res = matrix_mult(res, base) base = matrix_mult(base, base) exp //= 2 return res if n == 0: return 0 if n == 1: return 1 F = [[1, 1], [1, 0]] result_matrix = matrix_pow(F, n-1) return result_matrix[0][0]"},{"question":"def is_sum_divisible_by_k(arr, k): Checks if there are any three distinct elements in the array whose sum is divisible by k. >>> is_sum_divisible_by_k([1, 2, 3, 4, 5], 3) \\"YES\\" >>> is_sum_divisible_by_k([10, 15, 7, 8], 7) \\"NO\\" >>> is_sum_divisible_by_k([3, 6, 9, 12, 15, 18], 11) \\"YES\\" def process_multiple_test_cases(test_cases): Handles multiple test cases for the problem. def transform_input(input_data): Transforms the raw input into a list format suitable for processing. def main(input_data): Main function to execute the code with provided input data. def test_is_sum_divisible_by_k_yes(): assert is_sum_divisible_by_k([1, 2, 3, 4, 5], 3) == \\"YES\\" def test_is_sum_divisible_by_k_no(): assert is_sum_divisible_by_k([10, 15, 7, 8], 7) == \\"NO\\" def test_is_sum_divisible_by_k_borderline(): assert is_sum_divisible_by_k([3, 6, 9, 12, 15, 18], 11) == \\"YES\\" def test_transform_input(): input_data = \\"3n5 3n1 2 3 4 5n4 7n10 15 7 8n6 11n3 6 9 12 15 18\\" expected_result = [ (5, 3, [1, 2, 3, 4, 5]), (4, 7, [10, 15, 7, 8]), (6, 11, [3, 6, 9, 12, 15, 18]) ] assert transform_input(input_data) == expected_result def test_process_multiple_test_cases(): test_cases = [ (5, 3, [1, 2, 3, 4, 5]), (4, 7, [10, 15, 7, 8]), (6, 11, [3, 6, 9, 12, 15, 18]) ] expected_results = [\\"YES\\", \\"NO\\", \\"YES\\"] assert process_multiple_test_cases(test_cases) == expected_results def test_main(): input_data = \\"3n5 3n1 2 3 4 5n4 7n10 15 7 8n6 11n3 6 9 12 15 18\\" expected_output = \\"YESnNOnYES\\" assert main(input_data) == expected_output","solution":"def is_sum_divisible_by_k(arr, k): Checks if there are any three distinct elements in the array whose sum is divisible by k. n = len(arr) for i in range(n - 2): for j in range(i + 1, n - 1): for l in range(j + 1, n): if (arr[i] + arr[j] + arr[l]) % k == 0: return \\"YES\\" return \\"NO\\" def process_multiple_test_cases(test_cases): Handles multiple test cases for the problem. results = [] for N, K, arr in test_cases: results.append(is_sum_divisible_by_k(arr, K)) return results def transform_input(input_data): Transforms the raw input into a list format suitable for processing. lines = input_data.split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N, K = map(int, lines[index].split()) index += 1 arr = list(map(int, lines[index].split())) index += 1 test_cases.append((N, K, arr)) return test_cases def main(input_data): test_cases = transform_input(input_data) results = process_multiple_test_cases(test_cases) return \\"n\\".join(results)"},{"question":"def max_satisfaction_score(n: int, puzzles: List[int]) -> int: This function takes in an integer n and a list of integers puzzles, and returns the maximum possible satisfaction score, which is the number of times a participant receives a puzzle whose variant number is strictly greater than the variant number received by the participant immediately before them. Args: n (int): The number of different types of puzzles. puzzles (List[int]): A list of integers representing the variants of the puzzles. Returns: int: The maximum possible satisfaction score. Example: >>> max_satisfaction_score(5, [1, 2, 3, 4, 5]) 4","solution":"def max_satisfaction_score(n, puzzles): This function takes in an integer n and a list of integers puzzles, and returns the maximum possible satisfaction score, which is the number of times a participant receives a puzzle whose variant number is strictly greater than the variant number received by the participant immediately before them. # Sort the puzzles to maximize the satisfaction score. puzzles = sorted(puzzles) # Satisfaction score is the count of pairs where the latter element is greater # than the former element, which after sorting is simply n - 1. satisfaction_score = n - 1 return satisfaction_score"},{"question":"def addFactors(n: int) -> int: Returns the sum of all the factors of n, including 1 and n itself. >>> addFactors(6) # 1 + 2 + 3 + 6 = 12 12 >>> addFactors(28) # 1 + 2 + 4 + 7 + 14 + 28 = 56 56 >>> addFactors(1) # 1 1 >>> addFactors(13) # 1 + 13 = 14 14 >>> addFactors(36) # 1 + 2 + 3 + 4 + 6 + 9 + 12 + 18 + 36 = 91 91 >>> addFactors(7919) # 1 + 7919 = 7920 7920 >>> addFactors(100) # 1 + 2 + 4 + 5 + 10 + 20 + 25 + 50 + 100 = 217 217","solution":"def addFactors(n): Returns the sum of all the factors of n, including 1 and n itself. Parameters: n (int): The integer to find the sum of factors for. Returns: int: Sum of all factors of n. if n == 1: return 1 sum_factors = 0 sqrt_n = int(n**0.5) for i in range(1, sqrt_n + 1): if n % i == 0: sum_factors += i if i != n // i: sum_factors += n // i return sum_factors"},{"question":"def is_valid_palindrome(s: str) -> str: Given a string s, determine if it is a valid palindrome ignoring non-alphanumeric characters and case. A palindrome is a string that reads the same forward and backward after removing non-alphanumeric characters and converting all letters to a single case. Args: s (str): The input string Returns: str: \\"YES\\" if the string is a valid palindrome, \\"NO\\" otherwise Examples: >>> is_valid_palindrome(\\"A man, a plan, a canal: Panama\\") \\"YES\\" >>> is_valid_palindrome(\\"race a car\\") \\"NO\\"","solution":"def is_valid_palindrome(s): Returns \\"YES\\" if the string s is a valid palindrome ignoring non-alphanumeric characters and case, \\"NO\\" otherwise. # Filter out non-alphanumeric characters and convert to lower case filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered list of characters is a palindrome return \\"YES\\" if filtered_chars == filtered_chars[::-1] else \\"NO\\""},{"question":"def calculate(expression: str) -> int: Given a string that represents an arithmetic expression containing non-negative integers, +, -, *, and / operators, evaluate the expression and return its value. The expression is always valid, so no need to handle invalid input. The operators + and - have the same precedence, which is lower than * and /. The * and / operators also have the same precedence, which is higher than + and -. All operations are left-associative, meaning they are evaluated from left to right. Example: >>> calculate(\\"3+5*2\\") 13 >>> calculate(\\"10+2*6\\") 22 >>> calculate(\\"100*2/1\\") 200 from solution import calculate def test_expression_simple_addition(): assert calculate(\\"1+1\\") == 2 def test_expression_addition_and_multiplication(): assert calculate(\\"3+5*2\\") == 13 def test_expression_addition_and_multiplication_with_spaces(): assert calculate(\\"3 + 5 * 2\\") == 13 def test_expression_addition_and_multiplication_with_division(): assert calculate(\\"10+2*6\\") == 22 def test_expression_addition_subtraction_multiplication_division(): assert calculate(\\"100*2/1\\") == 200 def test_expression_with_multiple_operators(): assert calculate(\\"10 + 3 * 5 / 2\\") == 17 def test_expression_long_expression(): assert calculate(\\"3+5*2-4/2+10\\") == 21","solution":"def calculate(expression): def apply_operator(operators, values): right = values.pop() left = values.pop() op = operators.pop() if op == '+': values.append(left + right) elif op == '-': values.append(left - right) elif op == '*': values.append(left * right) elif op == '/': values.append(int(left / right)) # Use int() for floor division like in Python 2 def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 operators, values = [], [] i = 0 while i < len(expression): if expression[i].isdigit(): val = 0 while (i < len(expression) and expression[i].isdigit()): val = val * 10 + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] in '+-*/': while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"def total_travel_cost(n, travels): Calculate the total cost for traveling in different directions given the costs per kilometer. Cost per kilometer: North (N) - 1 per kilometer South (S) - 2 per kilometer East (E) - 3 per kilometer West (W) - 4 per kilometer The first argument is the number of directions traveled, and the second argument is a list of tuples representing the directions and the kilometers traveled. >>> total_travel_cost(4, [('N', 10), ('S', 5), ('E', 3), ('W', 2)]) 37 >>> total_travel_cost(4, [('N', 1), ('S', 1), ('E', 1), ('W', 1)]) 10 >>> total_travel_cost(3, [('N', 5), ('N', 5), ('E', 2)]) 16 >>> total_travel_cost(1, [('W', 7)]) 28 >>> total_travel_cost(4, [('S', 3), ('E', 4), ('W', 1), ('N', 7)]) 29","solution":"def total_travel_cost(n, travels): Given the number of travel segments and a list of tuples containing the direction and kilometers, calculate the total cost of the trip. Args: n (int): Number of directions traveled travels (list of tuples): Each tuple contains a direction (str) and kilometers (int) Returns: int: Total cost of the trip cost_per_km = { 'N': 1, 'S': 2, 'E': 3, 'W': 4 } total_cost = 0 for direction, km in travels: total_cost += cost_per_km[direction] * km return total_cost"},{"question":"def most_common_phrase(test_cases: List[Tuple[int, int, List[str]]]) -> List[str]: Identify the most common phrase of a specified length across multiple feedback statements. >>> most_common_phrase([(3, 2, [\\"this is a test statement\\", \\"test this is a sample\\", \\"statement this is not\\"]), (2, 3, [\\"we love coding\\", \\"coding we love\\"])]) [\\"this is 3\\", \\"coding we love 1\\"] >>> most_common_phrase([(1, 1, [\\"hello world\\"])]) [\\"hello 1\\", \\"world 1\\"]","solution":"from collections import defaultdict def most_common_phrase(test_cases): results = [] for n, l, statements in test_cases: phrase_count = defaultdict(int) for statement in statements: words = statement.split() for i in range(len(words) - l + 1): phrase = ' '.join(words[i:i+l]) phrase_count[phrase] += 1 most_frequent_phrase = min(phrase_count, key=lambda phrase: (-phrase_count[phrase], phrase)) results.append(f\\"{most_frequent_phrase} {phrase_count[most_frequent_phrase]}\\") return results def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N, L = map(int, lines[index].split()) statements = lines[index + 1:index + 1 + N] test_cases.append((N, L, statements)) index += N + 1 return test_cases def main(input_string): test_cases = parse_input(input_string) return most_common_phrase(test_cases)"},{"question":"def shift_string(s: str) -> str: Returns a new string where each character in the original string is replaced by the next character in the alphabet. 'z' is wrapped around to 'a'. >>> shift_string(\\"abc\\") \\"bcd\\" >>> shift_string(\\"xyz\\") \\"yza\\" >>> shift_string(\\"hello\\") \\"ifmmp\\"","solution":"def shift_string(s): Returns a new string where each character in the original string is replaced by the next character in the alphabet. 'z' is wrapped around to 'a'. return ''.join(chr((ord(char) - ord('a') + 1) % 26 + ord('a')) for char in s)"},{"question":"def can_partition(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if you can partition the array into exactly two non-empty segments such that the sum of the elements in both segments is equal. Returns \\"YES\\" if such a partition exists, otherwise \\"NO\\". >>> can_partition(3, [(4, [1, 2, 3, 4]), (5, [1, 1, 1, 1, 2]), (3, [3, 3, 3])]) [\\"NO\\", \\"YES\\", \\"NO\\"] >>> can_partition(2, [(2, [0, 0]), (3, [1, 2, 5])]) [\\"YES\\", \\"NO\\"]","solution":"def can_partition(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] a = test_cases[i][1] total_sum = sum(a) if total_sum % 2 != 0: results.append(\\"NO\\") continue target_sum = total_sum // 2 current_sum = 0 for num in a: current_sum += num if current_sum == target_sum: results.append(\\"YES\\") break else: results.append(\\"NO\\") return results"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def longestDistinctPath(root: TreeNode) -> int: Takes the root of the binary tree as input and returns the length of the longest path where all the nodes on the path have distinct values. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(2) >>> longestDistinctPath(root) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(1) >>> longestDistinctPath(root) 2","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def longestDistinctPath(root): if not root: return 0 def dfs(node, seen): if not node: return len(seen) if node.val in seen: return len(seen) seen.add(node.val) left_len = dfs(node.left, seen.copy()) right_len = dfs(node.right, seen.copy()) seen.remove(node.val) return max(left_len, right_len) return dfs(root, set())"},{"question":"def min_rooms_needed(meetings): Function to determine the minimum number of conference rooms needed to accommodate all meetings without any overlap. Parameters: meetings (list of tuples): Each tuple contains the start time and end time of a meeting. Returns: int: Minimum number of conference rooms required. Examples: >>> min_rooms_needed([(1, 4), (2, 3), (3, 5), (7, 10), (8, 9)]) 2 >>> min_rooms_needed([(0, 30), (5, 10), (15, 20)]) 2 >>> min_rooms_needed([(1, 2), (2, 3), (3, 4), (4, 5)]) 1","solution":"def min_rooms_needed(meetings): Function to determine the minimum number of conference rooms needed to accommodate all meetings without any overlap. Parameters: meetings (list of tuples): Each tuple contains the start time and end time of a meeting. Returns: int: Minimum number of conference rooms required. if not meetings: return 0 start_times = sorted([meeting[0] for meeting in meetings]) end_times = sorted([meeting[1] for meeting in meetings]) num_rooms = 0 end_index = 0 for start in start_times: if start < end_times[end_index]: num_rooms += 1 else: end_index += 1 return num_rooms"},{"question":"def is_correctly_capitalized(S: str) -> bool: Determine whether the capitalization of each word in the string S follows the rules defined by the Royal Typographic Society. >>> is_correctly_capitalized(\\"Hello World\\") True >>> is_correctly_capitalized(\\"HELLO WORLD\\") True >>> is_correctly_capitalized(\\"Hello world\\") False >>> is_correctly_capitalized(\\"Good Morning\\") True","solution":"def is_correctly_capitalized(S): Returns True if the capitalization in the string S follows the Royal Typographic Society's rules. words = S.split() for word in words: # Check if the word is correctly capitalized if not (word.isupper() or (word[0].isupper() and word[1:].islower())): return False return True"},{"question":"def max_clean_cells(x: int, y: int, b: int) -> int: Determine the maximum number of unique cells the robot vacuum cleaner can clean. The robot starts at given position (x, y) on the grid and has a battery life of b. Args: x (int): The starting x-coordinate of the vacuum cleaner. y (int): The starting y-coordinate of the vacuum cleaner. b (int): The initial battery life (number of moves). Returns: int: The maximum number of unique cells the vacuum cleaner can clean. >>> max_clean_cells(0, 0, 5) 36 >>> max_clean_cells(10, 10, 3) 16 >>> max_clean_cells(-3, -3, 2) 9 >>> max_clean_cells(1000000000, 1000000000, 0) 1 >>> max_clean_cells(-1000000000, -1000000000, 100000) 10000200001","solution":"def max_clean_cells(x: int, y: int, b: int) -> int: This function returns the maximum number of unique cells the robot vacuum cleaner can clean given the starting position (x, y) and the initial battery life b. return (b + 1) * (b + 1)"},{"question":"def generate_security_code(full_name: str) -> str: Generates the security code for a staff member based on their full name. Args: full_name (str): The full name of the staff member. It consists of exactly two words separated by a space. Returns: str: The generated security code. Examples: >>> generate_security_code(\\"John Doe\\") '4*74*111*104*110*2' >>> generate_security_code(\\"Alice Wonderland\\") '5*65*108*105*99*101*3'","solution":"def generate_security_code(full_name): Generates the security code for a staff member based on their full name. Args: full_name (str): The full name of the staff member. It consists of exactly two words separated by a space. Returns: str: The generated security code. first_name, last_name = full_name.split() # First character of the code is the length of the first name security_code = str(len(first_name)) # Append the ASCII value of each character in the first name for char in first_name: security_code += '*' + str(ord(char)) # Append the number of vowels in the last name vowels = set('aeiouAEIOU') vowel_count = sum(1 for char in last_name if char in vowels) security_code += '*' + str(vowel_count) return security_code"},{"question":"def check_work_hours(T: int, test_cases: list) -> list: Determine if employees met the required working hours each week. Args: T (int): Number of test cases. test_cases (list): List containing test cases, where each test case includes: - (D, H): Tuple of integers representing the number of days and the minimum required hours. - List of integers representing the hours worked each day. Returns: list: List of strings where each entry is \\"YES\\" if the employee met or exceeded the required hours, otherwise \\"NO x\\" where x is the number of additional hours needed. Examples: >>> check_work_hours(2, [(5, 40), [8, 8, 8, 8, 8], (7, 50), [6, 7, 8, 9, 10, 5, 4]]) ['YES', 'NO 1'] >>> check_work_hours(1, [(3, 25), [10, 10, 10]]) ['YES']","solution":"def check_work_hours(T, test_cases): results = [] for i in range(T): D, H = test_cases[i * 2] hours_worked = test_cases[i * 2 + 1] total_hours = sum(hours_worked) if total_hours >= H: results.append(\\"YES\\") else: results.append(f\\"NO {H - total_hours}\\") return results # Example of function usage: # T = 2 # test_cases = [ # (5, 40), # [8, 8, 8, 8, 8], # (7, 50), # [6, 7, 8, 9, 10, 5, 4] # ] # print(check_work_hours(T, test_cases))"},{"question":"def word_break(s: str, wordDict: List[str]) -> bool: Determine if the string s can be segmented into a space-separated sequence of one or more dictionary words from wordDict. :param s: str :param wordDict: List[str] :return: bool >>> word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False","solution":"def word_break(s, wordDict): Determine if the string s can be segmented into a space-separated sequence of one or more dictionary words from wordDict. :param s: str :param wordDict: List[str] :return: bool word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"def does_return_to_origin(movements: str) -> str: Given a string containing only the characters 'L', 'R', 'U', and 'D', determine if the sequence of movements described by the string will return the robot to its original position. >>> does_return_to_origin('LRUD') 'YES' >>> does_return_to_origin('LRRU') 'NO' >>> does_return_to_origin('') 'YES' >>> does_return_to_origin('LRLR') 'YES' >>> does_return_to_origin('LRL') 'NO' >>> does_return_to_origin('UDUD') 'YES' >>> does_return_to_origin('UUD') 'NO' >>> does_return_to_origin('LDRRUULD') 'YES' >>> does_return_to_origin('LDRRUUL') 'NO'","solution":"def does_return_to_origin(movements): Determines if the sequence of movements described will return the robot to its original position. horizontal = 0 vertical = 0 for move in movements: if move == 'L': horizontal -= 1 elif move == 'R': horizontal += 1 elif move == 'U': vertical += 1 elif move == 'D': vertical -= 1 return \\"YES\\" if horizontal == 0 and vertical == 0 else \\"NO\\""},{"question":"def parse_time_string(time_str): Parse the time string into hours and minutes >>> parse_time_string(\\"08:00\\") (8, 0) >>> parse_time_string(\\"23:59\\") (23, 59) >>> parse_time_string(\\"00:00\\") (0, 0) # Define function body here def time_in_minutes(hours, minutes): Convert time into total minutes >>> time_in_minutes(8, 0) 480 >>> time_in_minutes(23, 59) 1439 >>> time_in_minutes(0, 0) 0 # Define function body here def to_time_string(minutes): Convert minutes since the start of the day into a time string >>> to_time_string(480) \\"08:00\\" >>> to_time_string(1439) \\"23:59\\" >>> to_time_string(0) \\"00:00\\" # Define function body here def find_peak_least_periods(dataset): Determine the peak hour period and least busy hour period from the dataset. >>> dataset = [(\\"08:00\\", 50), (\\"09:30\\", 30), (\\"10:45\\", 60), (\\"11:15\\", 80), (\\"12:30\\", 50), (\\"13:00\\", 90)] >>> find_peak_least_periods(dataset) (\\"13:00-13:59\\", \\"09:00-09:59\\") >>> dataset = [(\\"00:00\\", 10), (\\"01:15\\", 5), (\\"03:30\\", 20), (\\"04:45\\", 15), (\\"06:00\\", 8)] >>> find_peak_least_periods(dataset) (\\"03:00-03:59\\", \\"01:00-01:59\\") # Define function body here def process_inputs(input_data): Process input data and return peak and least busy hour periods for each dataset. >>> input_data = (\\"6n08:00 50n09:30 30n10:45 60n11:15 80n12:30 50n13:00 90n\\" + ... \\"5n00:00 10n01:15 5n03:30 20n04:45 15n06:00 8n0n\\") >>> expected_output = [ ... (\\"13:00-13:59\\", \\"09:00-09:59\\"), ... (\\"03:00-03:59\\", \\"01:00-01:59\\") ... ] >>> process_inputs(input_data) expected_output # Define function body here","solution":"def parse_time_string(time_str): hours, minutes = map(int, time_str.split(':')) return hours, minutes def time_in_minutes(hours, minutes): return hours * 60 + minutes def to_time_string(minutes): hours = minutes // 60 minutes = minutes % 60 return f\\"{hours:02}:{minutes:02}\\" def find_peak_least_periods(dataset): from collections import defaultdict count_by_hour = defaultdict(int) # Dictionary to keep sum of vehicle counts by hour for time_str, count in dataset: hours, minutes = parse_time_string(time_str) count_by_hour[hours] += count peak_hour_start = min(count_by_hour.keys(), key=lambda h: (-count_by_hour[h], h)) least_busy_hour_start = min(count_by_hour.keys(), key=lambda h: (count_by_hour[h], h)) peak_hour_period = f\\"{to_time_string(peak_hour_start*60)}-{to_time_string(peak_hour_start*60+59)}\\" least_busy_hour_period = f\\"{to_time_string(least_busy_hour_start*60)}-{to_time_string(least_busy_hour_start*60+59)}\\" return peak_hour_period, least_busy_hour_period def process_inputs(input_data): input_lines = input_data.strip().split(\\"n\\") idx = 0 results = [] while idx < len(input_lines): m = int(input_lines[idx]) if m == 0: break idx += 1 dataset = [] for _ in range(m): time, count = input_lines[idx].split() count = int(count) dataset.append((time, count)) idx += 1 peak_hour_period, least_busy_hour_period = find_peak_least_periods(dataset) results.append((peak_hour_period, least_busy_hour_period)) return results"},{"question":"def column_sums(matrix): Returns a list containing the sum of the elements for each column in the input matrix. >>> column_sums([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [12, 15, 18] >>> column_sums([[1, 2], [3, 4], [5, 6]]) == [9, 12] >>> column_sums([[1], [2], [3], [4]]) == [10] >>> column_sums([[1, 2, 3, 4]]) == [1, 2, 3, 4] >>> column_sums([]) == [] >>> column_sums([[]]) == [] >>> column_sums([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == [0, 0, 0]","solution":"def column_sums(matrix): Returns a list containing the sum of the elements for each column in the input matrix. if not matrix or not matrix[0]: return [] num_rows = len(matrix) num_cols = len(matrix[0]) column_sum_list = [0] * num_cols for j in range(num_cols): for i in range(num_rows): column_sum_list[j] += matrix[i][j] return column_sum_list"},{"question":"def spiral_matrix(n): Generates an n x n matrix filled with elements from 1 to n^2 in a spiral order. >>> matrix_to_string(spiral_matrix(1)) == \\"1\\" >>> matrix_to_string(spiral_matrix(2)) == \\"1 2n4 3\\" >>> matrix_to_string(spiral_matrix(3)) == \\"1 2 3n8 9 4n7 6 5\\" >>> matrix_to_string(spiral_matrix(4)) == \\"1 2 3 4n12 13 14 5n11 16 15 6n10 9 8 7\\" >>> matrix_to_string(spiral_matrix(5)) == (\\"1 2 3 4 5n\\" \\"16 17 18 19 6n\\" \\"15 24 25 20 7n\\" \\"14 23 22 21 8n\\" \\"13 12 11 10 9\\")","solution":"def spiral_matrix(n): Generates an n x n matrix filled with elements from 1 to n^2 in a spiral order. matrix = [[0]*n for _ in range(n)] num = 1 left, right = 0, n-1 top, bottom = 0, n-1 while left <= right and top <= bottom: for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 if top <= bottom: for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"from typing import List def accounts_merge(accounts: List[List[str]]) -> List[List[str]]: Merge accounts based on email addresses. Each account contains a list of emails and is identified by the first email in the list. The result should include merged accounts with unique emails sorted in lexicographical order. :param accounts: List of accounts where the first element is the account name and the rest are emails. :return: Merged accounts with unique emails sorted. >>> accounts_merge([ [\\"John\\", \\"johnsmith@mail.com\\", \\"john00@mail.com\\"], [\\"John\\", \\"johnnybravo@mail.com\\"], [\\"John\\", \\"johnsmith@mail.com\\", \\"john_newyork@mail.com\\"], [\\"Mary\\", \\"mary@mail.com\\"] ]) [ [\\"John\\", \\"john00@mail.com\\", \\"john_newyork@mail.com\\", \\"johnsmith@mail.com\\"], [\\"John\\", \\"johnnybravo@mail.com\\"], [\\"Mary\\", \\"mary@mail.com\\"] ]","solution":"from collections import defaultdict def accounts_merge(accounts): Merge accounts based on email addresses. :param accounts: List of accounts where first element is account name and rest are emails. :return: Merged accounts with unique emails sorted. email_to_name = {} graph = defaultdict(set) # Build the graph for account in accounts: name = account[0] emails = account[1:] for email in emails: graph[emails[0]].add(email) graph[email].add(emails[0]) email_to_name[email] = name seen = set() merged_accounts = [] # Perform DFS to find connected components (all emails of one account) def dfs(email): stack = [email] result = [] while stack: node = stack.pop() if node not in seen: seen.add(node) result.append(node) stack.extend(graph[node]) return result for email in graph: if email not in seen: emails = sorted(dfs(email)) merged_accounts.append([email_to_name[email]] + emails) return merged_accounts"},{"question":"def smallest_subarray_with_sum(arr, x): Returns the length of the smallest subarray with sum greater than or equal to x. If no such subarray exists, return -1. >>> smallest_subarray_with_sum([1, 2, 3, 4, 5], 11) 3 >>> smallest_subarray_with_sum([2, 1, 5, 2, 8, 1], 7) 1 >>> smallest_subarray_with_sum([1, 1, 1, 1], 10) -1","solution":"def smallest_subarray_with_sum(arr, x): Returns the length of the smallest subarray with sum greater than or equal to x. If no such subarray exists, return -1. n = len(arr) if n == 0: return -1 min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= x: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def find_minimum_cost(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Given N cities and M direct roads with weights, compute the minimum cost required to ensure there is a unique path for every pair of cities. :param N: Number of cities :param M: Number of roads :param roads: List of tuples representing the roads (u, v, w) :return: Minimum cost or -1 if impossible >>> find_minimum_cost(4, 4, [(1, 2, 3), (2, 3, 2), (3, 4, 4), (1, 4, 1)]) 6 >>> find_minimum_cost(6, 2, [(1, 2, 5), (4, 5, 6)]) -1 >>> find_minimum_cost(3, 0, []) -1 >>> find_minimum_cost(2, 1, [(1, 2, 1)]) 1 >>> find_minimum_cost(1, 0, []) 0 >>> find_minimum_cost(5, 6, [(1, 2, 1), (1, 3, 1), (2, 4, 1), (3, 4, 4), (4, 5, 1), (5, 1, 3)]) 4","solution":"def find_minimum_cost(N, M, roads): Given N cities and M direct roads with weights, compute the minimum cost required to ensure there is a unique path for every pair of cities. :param N: Number of cities :param M: Number of roads :param roads: List of tuples representing the roads (u, v, w) :return: Minimum cost or -1 if impossible if M == 0: return -1 if N > 1 else 0 # Union-Find implementation to detect cycles parent = list(range(N + 1)) rank = [0] * (N + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 return True return False # Kruskal's algorithm to find the Minimum Spanning Tree (MST) roads.sort(key=lambda x: x[2]) mst_cost = 0 edges_used = 0 for u, v, w in roads: if union(u, v): mst_cost += w edges_used += 1 if edges_used == N - 1: return mst_cost # If we didn't use exactly N-1 edges, it means we couldn't connect all cities return -1 def parse_input(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) roads = [] index = 2 for _ in range(M): u = int(data[index]) v = int(data[index+1]) w = int(data[index+2]) roads.append((u, v, w)) index += 3 return N, M, roads if __name__ == \\"__main__\\": N, M, roads = parse_input() result = find_minimum_cost(N, M, roads) print(result)"},{"question":"def calculate_decorated_length(N: int, M: int, coordinates: List[int], decoration_plans: List[Tuple[int, int]]) -> int: Calculates the total length of the subway line decorated based on given decoration plans. Parameters: N (int): Number of stations. M (int): Number of decoration plans. coordinates (list of int): Coordinates of the stations. decoration_plans (list of tuples): Each tuple contains two integers (si, ei) representing the decoration plan. Returns: int: Total length of the decorated subway line. pass # Example test cases def test_calculate_decorated_length_case_1(): N = 5 M = 3 coordinates = [1, 3, 6, 10, 15] decoration_plans = [(1, 3), (2, 4), (3, 5)] assert calculate_decorated_length(N, M, coordinates, decoration_plans) == 14 def test_calculate_decorated_length_no_overlap(): N = 4 M = 2 coordinates = [1, 5, 10, 15] decoration_plans = [(1, 2), (3, 4)] assert calculate_decorated_length(N, M, coordinates, decoration_plans) == 9 def test_calculate_decorated_length_complete_overlap(): N = 3 M = 2 coordinates = [1, 3, 5] decoration_plans = [(1, 3), (1, 3)] assert calculate_decorated_length(N, M, coordinates, decoration_plans) == 4 def test_calculate_decorated_length_partial_overlap(): N = 4 M = 2 coordinates = [1, 4, 8, 12] decoration_plans = [(1, 3), (2, 4)] assert calculate_decorated_length(N, M, coordinates, decoration_plans) == 11 def test_calculate_decorated_length_single_station(): N = 1 M = 1 coordinates = [1] decoration_plans = [(1, 1)] assert calculate_decorated_length(N, M, coordinates, decoration_plans) == 0","solution":"def calculate_decorated_length(N, M, coordinates, decoration_plans): Calculates the total length of the subway line decorated based on given decoration plans. Parameters: N (int): Number of stations. M (int): Number of decoration plans. coordinates (list of int): Coordinates of the stations. decoration_plans (list of tuples): Each tuple contains two integers (si, ei) representing the decoration plan. Returns: int: Total length of the decorated subway line. decorated_segments = [] # Convert decoration plans to segments in terms of coordinates for si, ei in decoration_plans: # si and ei are 1-based indices decorated_segments.append((coordinates[si-1], coordinates[ei-1])) # Merge overlapping intervals decorated_segments.sort() merged_segments = [] for segment in decorated_segments: if not merged_segments or merged_segments[-1][1] < segment[0]: merged_segments.append(segment) else: merged_segments[-1] = (merged_segments[-1][0], max(merged_segments[-1][1], segment[1])) # Calculate total length of merged segments total_length = 0 for start, end in merged_segments: total_length += end - start return total_length"},{"question":"def calculate_score(commands: str) -> int: Calculates the total score based on a sequence of character commands. The player moves on a 2D grid starting at position (0,0). The score increases by the Manhattan distance moved from the previous position. Commands: - 'U' for moving up - 'D' for moving down - 'L' for moving left - 'R' for moving right Parameters: commands (str): A string of commands to move the player. Returns: int: The total score based on the movements. >>> calculate_score(\\"URDL\\") 4 >>> calculate_score(\\"UUUU\\") 4 >>> calculate_score(\\"UDUD\\") 4 >>> calculate_score(\\"\\") 0 >>> calculate_score(\\"LLRRUUDD\\") 8","solution":"def calculate_score(commands): Calculates total score based on a sequence of commands. Parameters: commands (str): A string of commands ('U', 'D', 'L', 'R') to move the player. Returns: int: The total score based on the movement. x, y = 0, 0 score = 0 for command in commands: if command == 'U': new_x, new_y = x, y + 1 elif command == 'D': new_x, new_y = x, y - 1 elif command == 'L': new_x, new_y = x - 1, y elif command == 'R': new_x, new_y = x + 1, y distance = abs(new_x - x) + abs(new_y - y) score += distance x, y = new_x, new_y return score"},{"question":"from typing import List def shortestPathInMaze(maze: List[List[int]]) -> int: Find the shortest path in a maze from the top-left corner to the bottom-right corner. The maze is represented as a 2D list where 0 represents an empty space and 1 represents a wall. You can move only up, down, left, or right. If there is no path, return -1. >>> maze1 = [ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [0, 1, 0, 0, 0], ... [1, 0, 0, 1, 0] ... ] >>> shortestPathInMaze(maze1) 9 >>> maze2 = [ ... [0, 1, 1], ... [1, 0, 1], ... [1, 1, 0] ... ] >>> shortestPathInMaze(maze2) -1 pass","solution":"from collections import deque from typing import List def shortestPathInMaze(maze: List[List[int]]) -> int: if not maze or not maze[0]: return -1 rows, cols = len(maze), len(maze[0]) if maze[0][0] == 1 or maze[rows - 1][cols - 1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) visited = set() visited.add((0, 0)) while queue: x, y, dist = queue.popleft() if x == rows - 1 and y == cols - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"from typing import List def max_in_subarrays(arr: List[int], k: int) -> List[int]: Given an array of integers, find the maximum for each and every contiguous subarray of size k. Example 1: >>> max_in_subarrays([1, 3, -1, -3, 5, 3, 6, 7], 3) [3, 3, 5, 5, 6, 7] Example 2: >>> max_in_subarrays([4, 2, 12, 11, -5], 2) [4, 12, 12, 11] Parameters: arr (list of int): The input array. k (int): The size of each subarray. Returns: list of int: A list of integers denoting the maximum for each subarray of size k.","solution":"from collections import deque def max_in_subarrays(arr, k): Given an array of integers, find the maximum for each and every contiguous subarray of size k. Parameters: arr (list of int): The input array. k (int): The size of each subarray. Returns: list of int: A list of integers denoting the maximum for each subarray of size k. n = len(arr) if n * k == 0: return [] if k == 1: return arr deq = deque() result = [] # Process first k elements for i in range(k): while deq and arr[i] >= arr[deq[-1]]: deq.pop() deq.append(i) # Process the rest of the elements for i in range(k, n): result.append(arr[deq[0]]) # Remove elements not within the sliding window while deq and deq[0] <= i - k: deq.popleft() # Remove elements smaller than the current element from the deque while deq and arr[i] >= arr[deq[-1]]: deq.pop() deq.append(i) # Add the maximum for the last window result.append(arr[deq[0]]) return result"},{"question":"from typing import List def days_until_more_rainfall(n: int, rainfall: List[int]) -> List[int]: Determine, for each day, the number of days until the next day with strictly more rainfall. >>> days_until_more_rainfall(6, [2, 1, 1, 5, 3, 6]) [3, 2, 1, 2, 1, 0] >>> days_until_more_rainfall(4, [3, 2, 1, 4]) [3, 2, 1, 0] pass def test_example_1(): assert days_until_more_rainfall(6, [2, 1, 1, 5, 3, 6]) == [3, 2, 1, 2, 1, 0] def test_example_2(): assert days_until_more_rainfall(4, [3, 2, 1, 4]) == [3, 2, 1, 0] def test_single_day(): assert days_until_more_rainfall(1, [5]) == [0] def test_all_equal(): assert days_until_more_rainfall(5, [3, 3, 3, 3, 3]) == [0, 0, 0, 0, 0] def test_increasing(): assert days_until_more_rainfall(4, [1, 2, 3, 4]) == [1, 1, 1, 0] def test_decreasing(): assert days_until_more_rainfall(4, [4, 3, 2, 1]) == [0, 0, 0, 0] def test_large_input(): n = 10**5 rainfall = list(range(10**5)) assert days_until_more_rainfall(n, rainfall) == [1] * (n - 1) + [0]","solution":"def days_until_more_rainfall(n, rainfall): result = [0] * n stack = [] for i in range(n): while stack and rainfall[i] > rainfall[stack[-1]]: prev_index = stack.pop() result[prev_index] = i - prev_index stack.append(i) return result"},{"question":"def is_valid_time(time_str: str) -> bool: Determines if a given string is a valid time in 24-hour format (HH:MM). Parameters: time_str (str): The time string to check. Returns: bool: True if time_str is a valid time, False otherwise. >>> is_valid_time(\\"13:45\\") True >>> is_valid_time(\\"00:00\\") True >>> is_valid_time(\\"23:59\\") True >>> is_valid_time(\\"09:30\\") True >>> is_valid_time(\\"24:00\\") False >>> is_valid_time(\\"12:60\\") False >>> is_valid_time(\\"9:30\\") False >>> is_valid_time(\\"23:5\\") False >>> is_valid_time(\\":::\\") False >>> is_valid_time(\\"2400\\") False >>> is_valid_time(\\"12:345\\") False >>> is_valid_time(\\"aa:bb\\") False >>> is_valid_time(\\"12:ab\\") False >>> is_valid_time(\\"ab:34\\") False","solution":"def is_valid_time(time_str): Determines if a given string is a valid time in 24-hour format (HH:MM). Parameters: time_str (str): The time string to check. Returns: bool: True if time_str is a valid time, False otherwise. if len(time_str) != 5 or time_str[2] != ':': return False try: hours = int(time_str[:2]) minutes = int(time_str[3:]) except ValueError: return False if 0 <= hours <= 23 and 0 <= minutes <= 59: return True return False"},{"question":"def is_sequence_possible(M, patterns, sequence): Checks if a sequence can be completely formed using the given patterns. :param M: Number of predefined patterns :param patterns: List of patterns (each pattern is a list of integers) :param sequence: List of integers representing the sequence to verify :return: 'Possible' or 'Impossible' >>> is_sequence_possible(3, [[1, 2, 3], [4, 5, 6], [7, 8]], [1, 2, 3, 4, 5, 6, 7, 8]) 'Possible' >>> is_sequence_possible(3, [[1, 2, 3], [4, 5, 6], [7, 8]], [1, 2, 3, 4, 5, 6, 7, 8, 9]) 'Impossible' >>> is_sequence_possible(3, [[1, 2, 3], [4, 5, 6], [7, 8]], [1, 2, 3, 5, 6, 7, 8]) 'Impossible' >>> is_sequence_possible(3, [[1, 3], [4, 5, 6], [7, 8]], [1, 3, 4, 5, 6, 7, 8]) 'Possible' >>> is_sequence_possible(1, [[1, 2, 3]], [1, 2, 3]) 'Possible' >>> is_sequence_possible(1, [[1, 2, 3]], [1, 2, 4]) 'Impossible'","solution":"def is_sequence_possible(M, patterns, sequence): Checks if a sequence can be completely formed using the given patterns. :param M: Number of predefined patterns :param patterns: List of patterns (each pattern is a list of integers) :param sequence: List of integers representing the sequence to verify :return: 'Possible' or 'Impossible' index = 0 while index < len(sequence): matched = False for pattern in patterns: if sequence[index:index + len(pattern)] == pattern: index += len(pattern) matched = True break if not matched: return 'Impossible' return 'Possible' # Sample Input: # 3 # 1 2 3 # 4 5 6 # 7 8 # 1 2 3 4 5 6 7 8"},{"question":"from typing import List def minimal_removal_to_palindrome(t: int, cases: List[str]) -> List[str]: Form a palindromic string by removing the minimum number of characters. Args: t (int): number of test cases. cases (List[str]): list of strings for each test case. Returns: List[str]: list of palindromic strings with minimum removals. Examples: >>> minimal_removal_to_palindrome(3, [\\"abc\\", \\"abac\\", \\"a\\"]) ['a', 'aba', 'a'] >>> minimal_removal_to_palindrome(1, [\\"abacde\\"]) ['aba'] >>> minimal_removal_to_palindrome(2, [\\"racecar\\", \\"level\\"]) ['racecar', 'level']","solution":"def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp def form_palindromic_string(s, dp): n = len(s) seq = [''] * dp[0][n - 1] i, j = 0, n - 1 left, right = 0, dp[0][n - 1] - 1 while i <= j: if s[i] == s[j]: seq[left] = s[i] seq[right] = s[j] left += 1 right -= 1 i += 1 j -= 1 elif dp[i + 1][j] > dp[i][j - 1]: i += 1 else: j -= 1 return ''.join(seq) def minimal_removal_to_palindrome(t, cases): results = [] for s in cases: dp = longest_palindromic_subsequence(s) palindrome = form_palindromic_string(s, dp) results.append(palindrome) return results"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Determine the length of the longest substring that can be rearranged to form a palindrome. >>> longest_palindromic_substring_length(\\"abccb\\") 5 >>> longest_palindromic_substring_length(\\"aabbcc\\") 6 >>> longest_palindromic_substring_length(\\"abc\\") 1","solution":"from collections import Counter def longest_palindromic_substring_length(s): Returns the length of the longest substring that can be rearranged to form a palindrome. # Count the occurrences of each character in the string char_count = Counter(s) # Initialize length of the longest palindromic substring length = 0 odd_count_found = False # Check the counts of each character for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_count_found = True # If we have any characters with an odd count, we can use one of them in the middle of the palindrome if odd_count_found: length += 1 return length"},{"question":"def score_string_similarity(str1: str, str2: str) -> int: Calculate the similarity score between two strings based on matching character positions. >>> score_string_similarity(\\"abc\\", \\"abd\\") 2 >>> score_string_similarity(\\"hello\\", \\"hxllo\\") 4 >>> score_string_similarity(\\"abcdef\\", \\"abc\\") 3 >>> score_string_similarity(\\"abcdef\\", \\"ghijkl\\") 0 >>> score_string_similarity(\\"short\\", \\"longerstr\\") 2","solution":"def score_string_similarity(str1, str2): Calculate the similarity score between two strings based on matching character positions. score = 0 min_length = min(len(str1), len(str2)) for i in range(min_length): if str1[i] == str2[i]: score += 1 return score"},{"question":"def min_shipments(n: int, W: int, weights: List[int]) -> int: Determines the minimum number of shipments needed to send all packages. Args: n (int): The number of packages. W (int): The maximum weight per shipment. weights (list): A list of integers representing the weight of each package. Returns: int: The minimum number of shipments required. Example: >>> min_shipments(5, 10, [2, 2, 2, 2, 10]) 2 >>> min_shipments(1, 10, [10]) 1 >>> min_shipments(5, 10, [2, 2, 2, 2, 2]) 1 >>> min_shipments(5, 10, [5, 5, 5, 5, 5]) 3 pass from solution import min_shipments def test_example_case(): assert min_shipments(5, 10, [2, 2, 2, 2, 10]) == 2 def test_single_package(): assert min_shipments(1, 10, [10]) == 1 def test_all_packages_same_weight(): assert min_shipments(5, 10, [2, 2, 2, 2, 2]) == 1 assert min_shipments(5, 10, [5, 5, 5, 5, 5]) == 3 def test_large_weight_per_shipment(): assert min_shipments(3, 100, [30, 40, 50]) == 2 def test_multiple_shipments(): assert min_shipments(5, 5, [1, 2, 3, 4, 5]) == 3 def test_edge_case_minimum_weights(): assert min_shipments(5, 1, [1, 1, 1, 1, 1]) == 5 def test_edge_case_maximum_weights(): assert min_shipments(3, 1000, [500, 400, 300]) == 2 def test_mixed_weights(): assert min_shipments(6, 8, [3, 3, 3, 3, 5, 5]) == 3","solution":"def min_shipments(n, W, weights): Determines the minimum number of shipments needed to send all packages. Args: n (int): The number of packages. W (int): The maximum weight per shipment. weights (list): A list of integers representing the weight of each package. Returns: int: The minimum number of shipments required. weights.sort(reverse=True) shipments = 0 while weights: current_load = 0 to_be_removed = [] for i, weight in enumerate(weights): if current_load + weight <= W: current_load += weight to_be_removed.append(i) for i in reversed(to_be_removed): weights.pop(i) shipments += 1 return shipments"},{"question":"def is_leap_year(year: int) -> str: Determine whether a given year is a leap year. Parameters: year (int): The year to check (1 ≤ year ≤ 10000) Returns: str: \\"Leap Year\\" if the year is a leap year, \\"Not a Leap Year\\" otherwise. Examples: >>> is_leap_year(2020) \\"Leap Year\\" >>> is_leap_year(1900) \\"Not a Leap Year\\"","solution":"def is_leap_year(year): Determine whether a given year is a leap year. Parameters: year (int): The year to check (1 ≤ year ≤ 10000) Returns: str: \\"Leap Year\\" if the year is a leap year, \\"Not a Leap Year\\" otherwise. if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return \\"Leap Year\\" else: return \\"Not a Leap Year\\""},{"question":"from typing import List, Tuple def determine_winner(T: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[str]: Determine the winner in the resource gathering battle between Alpha and Omega. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[List[int]]]]): A list of tuples where each tuple contains an integer \`n\` representing the size of the grid and a list of lists representing the grid \`G\`. Returns: List[str]: A list of results where each result is \\"Alpha\\", \\"Omega\\", or \\"Tie\\" depending on which faction collects the most resources. results = [] for case in test_cases: n, grid = case resources = [cell for row in grid for cell in row] sorted_resources = sorted(resources, reverse=True) alpha_resources = sum(sorted_resources[i] for i in range(0, len(sorted_resources), 2)) omega_resources = sum(sorted_resources[i] for i in range(1, len(sorted_resources), 2)) if alpha_resources > omega_resources: results.append(\\"Alpha\\") elif alpha_resources < omega_resources: results.append(\\"Omega\\") else: results.append(\\"Tie\\") return results # Example usage T = 3 # Number of test cases test_cases = [ (3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]), (2, [ [5, 5], [5, 5] ]), (2, [ [8, 7], [7, 8] ]) ] # Expected outputs: [\\"Alpha\\", \\"Tie\\", \\"Tie\\"] print(determine_winner(T, test_cases))","solution":"def determine_winner(T, test_cases): results = [] for case in test_cases: n, grid = case resources = [cell for row in grid for cell in row] sorted_resources = sorted(resources, reverse=True) alpha_resources = sum(sorted_resources[i] for i in range(0, len(sorted_resources), 2)) omega_resources = sum(sorted_resources[i] for i in range(1, len(sorted_resources), 2)) if alpha_resources > omega_resources: results.append(\\"Alpha\\") elif alpha_resources < omega_resources: results.append(\\"Omega\\") else: results.append(\\"Tie\\") return results # Convert the input text to the function format. def parse_input(input_text): lines = input_text.strip().split('n') index = 0 T = int(lines[index]) index += 1 test_cases = [] for _ in range(T): n = int(lines[index]) index += 1 grid = [] for _ in range(n): row = list(map(int, lines[index].split())) grid.append(row) index += 1 test_cases.append((n, grid)) return T, test_cases # Convert the function output to the output text format. def format_output(results): return \\"n\\".join(results) # Full solution integrating parsing and formatting. def main(input_text): T, test_cases = parse_input(input_text) results = determine_winner(T, test_cases) return format_output(results)"},{"question":"from typing import List, Tuple def find_order(n: int, m: int, dependencies: List[Tuple[int, int]]) -> List[int]: Determine a valid order in which to complete all the tasks from the given list of dependencies. Return an empty list if no valid order exists. >>> find_order(4, 3, [(1, 0), (2, 1), (3, 2)]) [3, 2, 1, 0] >>> find_order(3, 3, [(0, 1), (1, 2), (2, 0)]) [] >>> find_order(3, 0, []) [0, 1, 2]","solution":"from collections import deque, defaultdict def find_order(n, m, dependencies): # Step 1: Create the adjacency list and the in-degree array. adj_list = defaultdict(list) in_degree = [0] * n # Step 2: Fill the adjacency list and in-degree array based on the dependencies. for a, b in dependencies: adj_list[a].append(b) in_degree[b] += 1 # Step 3: Initialize a queue with tasks that have no dependencies (in-degree 0). queue = deque([i for i in range(n) if in_degree[i] == 0]) # Step 4: Initialize the result list. result = [] # Step 5: Process the queue. while queue: task = queue.popleft() result.append(task) # For each dependent task, reduce its in-degree by 1. for dependent in adj_list[task]: in_degree[dependent] -= 1 # If in-degree becomes 0, add it to the queue. if in_degree[dependent] == 0: queue.append(dependent) # Step 6: If the result list contains all the tasks, return it. Otherwise, return an empty list. if len(result) == n: return result else: return []"},{"question":"def find_arrangement(n: int, m: int, pairs: List[Tuple[int, int]]) -> Union[str, List[int]]: Find an arrangement of guests such that every guest is seated next to someone they know and it forms a valid circle. Args: n (int): Number of guests. m (int): Number of pairs of guests who know each other. pairs (List[Tuple[int, int]]): List of pairs of guests who know each other. Returns: Union[str, List[int]]: A list representing the seating arrangement of the guests, or \\"No arrangement possible\\" if no valid arrangement exists. Examples: >>> find_arrangement(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (1, 4)]) [1, 2, 3, 4, 5, 6] >>> find_arrangement(4, 2, [(1, 2), (3, 4)]) 'No arrangement possible' Test case 1: input_data = \\"6n7n1 2n2 3n3 4n4 5n5 6n6 1n1 4\\" process_input(input_data) in [\\"1 2 3 4 5 6\\", \\"6 5 4 3 2 1\\"] Test case 2: input_data = \\"4n2n1 2n3 4\\" process_input(input_data) == \\"No arrangement possible\\" pass # Function to read input data and call the find_arrangement function def process_input(input_data: str) -> str: lines = input_data.strip().split(\\"n\\") n = int(lines[0]) m = int(lines[1]) pairs = [tuple(map(int, line.split())) for line in lines[2:2 + m]] # Call the arrangement function arrangement = find_arrangement(n, m, pairs) # Format the output if isinstance(arrangement, list): return \\" \\".join(map(str, arrangement)) else: return arrangement","solution":"def find_arrangement(n, m, pairs): if n == 1: return [1] from collections import defaultdict, deque # Build the adjacency list for the graph adj = defaultdict(set) for a, b in pairs: adj[a].add(b) adj[b].add(a) # Function to test if the current path forms a valid circle def valid_circle(path, n): for i in range(n): if path[i] not in adj[path[i - 1]]: return False return True # A basic DFS to find any path that forms a cycle of length n def dfs(node, path, visited): if len(path) == n: if valid_circle(path, n): return path else: return None for neighbor in adj[node]: if neighbor not in visited: visited.add(neighbor) path.append(neighbor) res = dfs(neighbor, path, visited) if res: return res path.pop() visited.remove(neighbor) return None # Try to start DFS from each node to find a valid circle for start in range(1, n + 1): path = [start] visited = {start} res = dfs(start, path, visited) if res: return res # If no valid circle is found return \\"No arrangement possible\\" # Function to read input data and call the find_arrangement function def process_input(input_data): lines = input_data.strip().split(\\"n\\") n = int(lines[0]) m = int(lines[1]) pairs = [tuple(map(int, line.split())) for line in lines[2:2 + m]] # Call the arrangement function arrangement = find_arrangement(n, m, pairs) # Format the output if isinstance(arrangement, list): return \\" \\".join(map(str, arrangement)) else: return arrangement"},{"question":"def single_digit_sum(N: str) -> int: Given a large integer N as a string, compute the sum of its digits. If the sum is greater than 9, compute the sum of the resulting digits. Repeat this process until a single digit is obtained. >>> single_digit_sum(\\"9876543210\\") 9 >>> single_digit_sum(\\"5\\") 5 >>> single_digit_sum(\\"0000\\") 0 >>> single_digit_sum(\\"1000000\\") 1 >>> single_digit_sum(\\"99999999999999999999999999999999999999999999999999\\") 9","solution":"def single_digit_sum(N): Returns the single digit sum of the digits of a large integer N. while len(N) > 1: N = str(sum(int(digit) for digit in N)) return int(N)"},{"question":"def decompress_sequence(S: str) -> str: Decompresses a compressed sequence. Args: S (str): A string representing the compressed sequence. Returns: str: The decompressed sequence. >>> decompress_sequence(\\"3a 2b 4c\\") 'aaabbcccc' >>> decompress_sequence(\\"5x 1y 2z\\") 'xxxxxyzz'","solution":"def decompress_sequence(S): Decompresses a compressed sequence. Args: S (str): A string representing the compressed sequence. Returns: str: The decompressed sequence. decompressed = [] parts = S.split() for part in parts: num = \\"\\" char = \\"\\" for ch in part: if ch.isdigit(): num += ch else: char = ch break decompressed.append(char * int(num)) return ''.join(decompressed)"},{"question":"def min_hours_to_reach_threshold(n, k, T, initial_counts): Calculate the minimum number of hours required for the total bacteria count to reach or exceed the threshold. Args: n (int): Number of petri dishes. k (int): Growth factor of bacteria every hour. T (int): Threshold that needs to be reached. initial_counts (List[int]): Initial counts of bacteria in each petri dish. Returns: int: Minimum number of hours required to reach or exceed the threshold. >>> min_hours_to_reach_threshold(3, 2, 100, [5, 7, 9]) 3 >>> min_hours_to_reach_threshold(2, 3, 200, [20, 30]) 2 >>> min_hours_to_reach_threshold(4, 5, 1000, [100, 100, 100, 100]) 1 def process_test_cases(test_cases): Process multiple test cases to find the minimum number of hours required for each. Args: test_cases (List[Tuple[int, int, int, List[int]]]): List of test cases where each test case is a tuple (n, k, T, initial_counts). Returns: List[int]: List of results where each element represents the minimum number of hours for the corresponding test case. >>> process_test_cases([(3, 2, 100, [5, 7, 9]), (2, 3, 200, [20, 30]), (4, 5, 1000, [100, 100, 100, 100])]) [3, 2, 1] def parse_input(input_string): Parse the input string to extract test cases. Args: input_string (str): Input string containing the number of test cases and their details. Returns: List[Tuple[int, int, int, List[int]]]: List of parsed test cases. >>> input_string = \\"3n3 2 100n5 7 9n2 3 200n20 30n4 5 1000n100 100 100 100\\" >>> parse_input(input_string) [(3, 2, 100, [5, 7, 9]), (2, 3, 200, [20, 30]), (4, 5, 1000, [100, 100, 100, 100])]","solution":"def min_hours_to_reach_threshold(n, k, T, initial_counts): current_sum = sum(initial_counts) hours = 0 while current_sum < T: current_sum *= k hours += 1 return hours def process_test_cases(test_cases): results = [] for test_case in test_cases: n, k, T, initial_counts = test_case hours = min_hours_to_reach_threshold(n, k, T, initial_counts) results.append(hours) return results def parse_input(input_string): lines = input_string.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n, k, T = map(int, lines[index].split()) initial_counts = list(map(int, lines[index + 1].split())) test_cases.append((n, k, T, initial_counts)) index += 2 return test_cases"},{"question":"def length_of_longest_increasing_subarray(arr): Returns the length of the longest contiguous increasing subarray. >>> length_of_longest_increasing_subarray([1, 3, 2, 3, 4, 5]) == 4 >>> length_of_longest_increasing_subarray([15, 12, 20, 22]) == 3 >>> length_of_longest_increasing_subarray([1, 2, 3, 4, 5]) == 5 >>> length_of_longest_increasing_subarray([5, 4, 3, 2, 1]) == 1 >>> length_of_longest_increasing_subarray([]) == 0 >>> length_of_longest_increasing_subarray([3]) == 1 pass def solve(test_cases): Given a list of test cases, returns the length of the longest increasing contiguous subarray for each test case. def parse_input(input_string): Parses the input string and returns a list of test cases. >>> parse_input(\\"2n6n1 3 2 3 4 5n4n15 12 20 22\\") == [(6, [1, 3, 2, 3, 4, 5]), (4, [15, 12, 20, 22])] pass","solution":"def length_of_longest_increasing_subarray(arr): Returns the length of the longest contiguous increasing subarray. n = len(arr) if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if arr[i] > arr[i-1]: current_length += 1 else: current_length = 1 max_length = max(max_length, current_length) return max_length def solve(test_cases): results = [] for case in test_cases: N, arr = case results.append(length_of_longest_increasing_subarray(arr)) return results # Example input handling parsing def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append((N, arr)) index += 2 return test_cases"},{"question":"def largest_scc(test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Find the size of the largest strongly connected component for each test case. :param test_cases: List of tuples where each tuple contains an integer n (number of towns) and a list of pairs (a, b) indicating roads from town a to town b. :return: List of integers representing the size of the largest SCC for each test case. >>> largest_scc([(5, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 4)])]) [3] >>> largest_scc([(4, [(1, 2), (2, 3), (3, 4), (4, 1)])]) [4] >>> largest_scc([(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)])]) [6] >>> largest_scc([(7, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4), (7, 7)])]) [3] >>> largest_scc([ ... (4, [(1, 2), (2, 1), (3, 4), (4, 3)]), ... (6, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4)]), ... ]) [2, 3]","solution":"from collections import defaultdict, deque def largest_scc_size(n, roads): def kosaraju_scc(n, graph): visit_stack = [] visited = set() def dfs1(v): visited.add(v) for neighbor in graph[v]: if neighbor not in visited: dfs1(neighbor) visit_stack.append(v) def dfs2(v, scc_set): scc_set.add(v) for neighbor in reversed_graph[v]: if neighbor not in visited_scc: visited_scc.add(neighbor) dfs2(neighbor, scc_set) graph = defaultdict(list) reversed_graph = defaultdict(list) for u, v in roads: graph[u].append(v) reversed_graph[v].append(u) for i in range(1, n + 1): if i not in visited: dfs1(i) visited_scc = set() largest_scc = 0 while visit_stack: node = visit_stack.pop() if node not in visited_scc: visited_scc.add(node) scc_set = set() dfs2(node, scc_set) largest_scc = max(largest_scc, len(scc_set)) return largest_scc graph = [(a, b) for a, b in roads] return kosaraju_scc(n, graph) def largest_scc(test_cases): results = [] for (n, roads) in test_cases: results.append(largest_scc_size(n, roads)) return results"},{"question":"def rotateList(arr: List[int], k: int) -> List[int]: Rotates the list arr k times to the right. >>> rotateList([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotateList([100, 120, 130, 140], 3) [120, 130, 140, 100] >>> rotateList([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotateList([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotateList([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotateList([1, 2, 3], 1) [3, 1, 2] >>> rotateList([1], 10) [1]","solution":"def rotateList(arr, k): Rotates the list arr k times to the right. n = len(arr) k = k % n # Ensure k is within the bounds of the list length return arr[-k:] + arr[:-k]"},{"question":"def game_winner(N: int) -> str: Determines whether Alice or Bob has a winning strategy given N stones. Parameters: N (int): The number of stones in the pile. Returns: str: \\"Alice\\" if Alice has a winning strategy, otherwise \\"Bob\\". >>> game_winner(4) \\"Bob\\" >>> game_winner(7) \\"Alice\\" >>> game_winner(10) \\"Alice\\" >>> game_winner(1) \\"Alice\\" >>> game_winner(2) \\"Alice\\" >>> game_winner(8) \\"Bob\\" # Logic to determine the game winner","solution":"def game_winner(N): Determines whether Alice or Bob has a winning strategy given N stones. Parameters: N (int): The number of stones in the pile. Returns: str: \\"Alice\\" if Alice has a winning strategy, otherwise \\"Bob\\". if N % 4 == 0: return \\"Bob\\" else: return \\"Alice\\""},{"question":"from collections import OrderedDict class RecentlyUsedList: A class that simulates a list of recently used items. Methods: - __init__(): Constructor to initialize an empty list. - add(item): Adds a new item to the list. If the item already exists in the list, it should be moved to the front (indicating it was recently used). The list does not contain duplicate entries. - get(): Returns the list of items with the most recently added or accessed item at the front and the oldest at the back. >>> recentlyUsedList = RecentlyUsedList() >>> recentlyUsedList.add(\\"item1\\") >>> recentlyUsedList.add(\\"item2\\") >>> recentlyUsedList.add(\\"item3\\") >>> recentlyUsedList.add(\\"item2\\") >>> recentlyUsedList.add(\\"item4\\") >>> recentlyUsedList.get() [\\"item4\\", \\"item2\\", \\"item3\\", \\"item1\\"] def __init__(self): pass def add(self, item): pass def get(self): pass","solution":"from collections import OrderedDict class RecentlyUsedList: def __init__(self): self.items = OrderedDict() def add(self, item): if item in self.items: self.items.move_to_end(item) self.items[item] = None self.items.move_to_end(item, last=False) def get(self): return list(self.items.keys())"},{"question":"def find_pair_with_sum(arr: List[int], target_sum: int) -> bool: Determine if there are two numbers in the array that add up to the target sum. >>> find_pair_with_sum([2, 7, 11, 15], 9) True >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) False","solution":"def find_pair_with_sum(arr, target_sum): Returns True if there are two numbers in the array that add up to the target_sum, else False. seen = set() for num in arr: if target_sum - num in seen: return True seen.add(num) return False"},{"question":"def sequence_sort_check(n: int, seq: List[int]) -> Union[List[int], int]: Determine if the sequence can be sorted in non-decreasing order by changing at most one integer in the sequence. Return the list of integers after the change, or -1 if it is not possible. >>> sequence_sort_check(5, [1, 2, 10, 5, 6]) [1, 2, 5, 5, 6] >>> sequence_sort_check(3, [4, 1, 3]) [1, 1, 3] >>> sequence_sort_check(4, [5, 4, 3, 2]) -1","solution":"def can_be_sorted_by_one_change(sequence): n = len(sequence) # Helper function to check if a sequence is sorted in non-decreasing order def is_sorted(seq): return all(seq[i] <= seq[i + 1] for i in range(len(seq) - 1)) if is_sorted(sequence): return sequence # Already sorted # Find the first position where the sequence is not sorted for i in range(n - 1): if sequence[i] > sequence[i + 1]: break else: # If no break statement encountered, the sequence is sorted return sequence # Try changing sequence[i] original_value = sequence[i] sequence[i] = sequence[i + 1] if is_sorted(sequence): return sequence # Restore the original value and try changing sequence[i + 1] sequence[i] = original_value sequence[i + 1] = sequence[i] if is_sorted(sequence): return sequence # If neither modification works, return -1 return -1 # Wrapper function to fit the required input-output format def sequence_sort_check(n, seq): result = can_be_sorted_by_one_change(seq) if result == -1: return -1 else: return result"},{"question":"def sort_rocks(rock_samples: str) -> str: Return the sequence of rock samples sorted according to Tom's special rule (reverse alphabetical order). Parameters: rock_samples (str): A string of uppercase letters representing unique rock samples. Returns: str: The sorted sequence in reverse alphabetical order. >>> sort_rocks(\\"CBDAFE\\") 'FEDCBA' >>> sort_rocks(\\"ZYXW\\") 'ZYXW' >>> sort_rocks(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") 'ZYXWVUTSRQPONMLKJIHGFEDCBA'","solution":"def sort_rocks(rock_samples): Return the sequence of rock samples sorted according to Tom's special rule (reverse alphabetical order). Parameters: rock_samples (str): A string of uppercase letters representing unique rock samples. Returns: str: The sorted sequence in reverse alphabetical order. return ''.join(sorted(rock_samples, reverse=True))"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def searchLinkedList(head, target): Returns the position (1-based index) of the target value in the linked list. If the target does not exist, return -1. >>> node5 = ListNode(9) >>> node4 = ListNode(7, node5) >>> node3 = ListNode(5, node4) >>> node2 = ListNode(3, node3) >>> head = ListNode(1, node2) >>> searchLinkedList(head, 5) 3 >>> node4 = ListNode(40) >>> node3 = ListNode(30, node4) >>> node2 = ListNode(20, node3) >>> head = ListNode(10, node2) >>> searchLinkedList(head, 25) -1","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def searchLinkedList(head, target): Returns the position (1-based index) of the target value in the linked list. If the target does not exist, return -1. current = head position = 1 while current: if current.val == target: return position current = current.next position += 1 return -1"},{"question":"def unique_paths(grid: List[List[int]]) -> int: Determine the number of unique paths from the top-left corner to the bottom-right corner of the grid. A value of 0 in the grid indicates a passable cell and a value of 1 indicates a blocked cell. >>> unique_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 6 >>> unique_paths([[0, 1], [1, 0]]) 0 >>> unique_paths([[1, 0], [0, 0]]) 0 >>> unique_paths([[0, 0], [0, 1]]) 0 >>> unique_paths([[0]]) 1 pass","solution":"def unique_paths(grid): if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 n, m = len(grid), len(grid[0]) dp = [[0]*m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 0: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def find_longest_concatenated_word(words: List[str]) -> str: Find the longest word in the list that can be constructed by concatenating copies of shorter words also in the list. Args: words (List[str]): List of words. Returns: str: The longest concatenated word. Examples: >>> find_longest_concatenated_word([\\"cat\\", \\"dog\\", \\"catdog\\", \\"cats\\", \\"dogcatsdog\\"]) \\"dogcatsdog\\" >>> find_longest_concatenated_word([\\"abcd\\", \\"abc\\", \\"def\\", \\"abcddef\\"]) \\"abcddef\\" >>> find_longest_concatenated_word([\\"apple\\", \\"pie\\", \\"applepie\\"]) \\"applepie\\" >>> find_longest_concatenated_word([\\"rat\\", \\"bat\\", \\"ratbatbat\\"]) \\"ratbatbat\\"","solution":"def find_longest_concatenated_word(words): Find the longest word in the list that can be constructed by concatenating copies of shorter words also in the list. words_set = set(words) memo = {} def is_concatenated(word): if word in memo: return memo[word] for i in range(1, len(word)): prefix = word[:i] suffix = word[i:] if prefix in words_set: if suffix in words_set or is_concatenated(suffix): memo[word] = True return True memo[word] = False return False longest_word = \\"\\" for word in words: if is_concatenated(word): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"def max_activities(activities): Get the maximum number of activities that can be selected without overlap. Parameters: activities (List[Tuple[int, int]]): List of tuples representing start and end times of activities. Returns: int: Maximum number of non-overlapping activities. pass # Unit Tests import pytest def test_max_activities_case1(): activities = [(1, 2), (3, 4), (0, 6), (5, 7), (8, 9)] assert max_activities(activities) == 4 def test_max_activities_case2(): activities = [(1, 4), (2, 3), (3, 5), (6, 8)] assert max_activities(activities) == 3 def test_max_activities_case3(): activities = [(1, 1000000000)] assert max_activities(activities) == 1 def test_max_activities_case4(): activities = [] assert max_activities(activities) == 0 def test_max_activities_case5(): activities = [(1, 10), (2, 3), (4, 5), (6, 7), (8, 9)] assert max_activities(activities) == 4 def test_max_activities_case6(): activities = [(0, 1), (1, 2), (1, 3), (2, 3)] assert max_activities(activities) == 3","solution":"def max_activities(activities): Get the maximum number of activities that can be selected without overlap. Parameters: activities (List[Tuple[int, int]]): List of tuples representing start and end times of activities. Returns: int: Maximum number of non-overlapping activities. if not activities: return 0 # Sort activities based on their end times. activities.sort(key=lambda x: x[1]) count = 1 # We can always select the first activity end_time = activities[0][1] for i in range(1, len(activities)): if activities[i][0] >= end_time: count += 1 end_time = activities[i][1] return count"},{"question":"def fibonacci_numbers_up_to(n): Generate a list of Fibonacci numbers up to n in the Fibonacci System (starting with 1, 2, ...). >>> fibonacci_numbers_up_to(10) [1, 2, 3, 5, 8, 13] >>> fibonacci_numbers_up_to(21) [1, 2, 3, 5, 8, 13, 21] def min_fib_numbers_sum(x): Find the minimum number of Fibonacci numbers needed to sum up to x in the Fibonacci System. >>> min_fib_numbers_sum(4) 2 >>> min_fib_numbers_sum(10) 2 >>> min_fib_numbers_sum(7) 2 >>> min_fib_numbers_sum(2) 1 def solve_min_fib_numbers_sum(T, test_cases): Solve for each test case the minimum number of Fibonacci numbers needed to sum up to each x. >>> solve_min_fib_numbers_sum(2, [4, 10]) [2, 2] >>> solve_min_fib_numbers_sum(3, [1, 5, 21]) [1, 1, 1]","solution":"def fibonacci_numbers_up_to(n): fibs = [1, 2] while fibs[-1] < n: fibs.append(fibs[-1] + fibs[-2]) return fibs def min_fib_numbers_sum(x): fibs = fibonacci_numbers_up_to(x) count = 0 i = len(fibs) - 1 while x > 0: if fibs[i] <= x: x -= fibs[i] count += 1 i -= 1 return count def solve_min_fib_numbers_sum(T, test_cases): results = [] for x in test_cases: results.append(min_fib_numbers_sum(x)) return results"},{"question":"def generate_matrix(n): Generate an n x n matrix where: - If n is even, the matrix contains equal numbers of -1 and 1. - If n is odd, the matrix contains (n^2 - 1) / 2 elements as -1 and (n^2 + 1) / 2 elements as 1. - The sum of the elements in any row must be 1. - The sum of the elements in any column must be 1. Example: >>> generate_matrix(2) [[1, -1], [-1, 1]] >>> generate_matrix(3) [[1, -1, -1], [-1, 1, -1], [-1, -1, 1]] >>> generate_matrix(4) [[1, -1, -1, -1], [-1, 1, -1, -1], [-1, -1, 1, -1], [-1, -1, -1, 1]] def solve(input_data): Solve the problem of generating multiple matrices based on input data. Example: >>> solve(\\"3n2n3n4n\\") '1 -1n-1 1nn1 -1 -1n-1 1 -1n-1 -1 1nn1 -1 -1 -1n-1 1 -1 -1n-1 -1 1 -1n-1 -1 -1 1'","solution":"def generate_matrix(n): Generate an n x n matrix where: - If n is even, the matrix contains equal numbers of -1 and 1. - If n is odd, the matrix contains (n^2 - 1) / 2 elements as -1 and (n^2 + 1) / 2 elements as 1. - The sum of the elements in any row must be 1. - The sum of the elements in any column must be 1. matrix = [[-1] * n for _ in range(n)] if n == 1: return [[1]] # Fill diagonals with 1 to make sure the sum of each row and column becomes 1 for i in range(n): matrix[i][i] = 1 return matrix def solve(input_data): result = [] t, *cases = map(int, input_data.split()) for n in cases: matrix = generate_matrix(n) result.append(\\"n\\".join(\\" \\".join(map(str, row)) for row in matrix)) return \\"nn\\".join(result)"},{"question":"def count_vowels(s: str) -> int: Returns the number of vowels in the given string s. >>> count_vowels(\\"bcdfg\\") == 0 >>> count_vowels(\\"aeiou\\") == 5 >>> count_vowels(\\"hello\\") == 2 >>> count_vowels(\\"programming\\") == 3 >>> count_vowels(\\"\\") == 0 >>> count_vowels(\\"aaaa\\") == 4 >>> count_vowels(\\"eeeee\\") == 5 >>> count_vowels(\\"Hello\\") == 2 >>> count_vowels(\\"AEIOU\\") == 0 >>> count_vowels(\\"a\\") == 1 >>> count_vowels(\\"b\\") == 0","solution":"def count_vowels(s): Returns the number of vowels in the given string s. vowels = 'aeiou' count = sum(1 for char in s if char in vowels) return count"},{"question":"from typing import List def max_product_subarray(nums: List[int]) -> int: Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product. Examples: >>> max_product_subarray([2, 3, -2, 4]) 6 >>> max_product_subarray([-2, 0, -1]) 0","solution":"def max_product_subarray(nums): Returns the maximum product of a contiguous subarray within the array nums. if not nums: return 0 max_prod = min_prod = result = nums[0] for num in nums[1:]: if num < 0: max_prod, min_prod = min_prod, max_prod max_prod = max(num, max_prod * num) min_prod = min(num, min_prod * num) result = max(result, max_prod) return result"},{"question":"def min_machines_required(tasks: List[Tuple[int, int]]) -> int: Determine the minimum number of machines required to handle all tasks without overlap. >>> min_machines_required([(1, 4), (2, 5), (3, 6)]) 3 >>> min_machines_required([(1, 3), (2, 4), (3, 5), (4, 6)]) 2","solution":"def min_machines_required(tasks): events = [] for task in tasks: s, e = task events.append((s, 'start')) events.append((e, 'end')) events.sort() max_machines = 0 current_machines = 0 for event in events: if event[1] == 'start': current_machines += 1 max_machines = max(max_machines, current_machines) else: current_machines -= 1 return max_machines # Example usage: # tasks = [(1, 4), (2, 5), (3, 6)] # print(min_machines_required(tasks)) # Output: 3"},{"question":"def is_happy_number(n: int) -> str: Determine if a number n is a Happy Number. A number is called a Happy Number if it reaches 1 after a sequence of steps where each step number is replaced by the sum of squares of its digits repeatedly. A number is considered Not Happy if it fails to reach 1 within 100 steps. >>> is_happy_number(19) \\"Happy\\" >>> is_happy_number(4) \\"Not Happy\\" >>> is_happy_number(23) \\"Happy\\" >>> is_happy_number(2) \\"Not Happy\\" >>> is_happy_number(1) \\"Happy\\"","solution":"def is_happy_number(n): Determine if a number n is a happy number. def get_next(number): return sum(int(digit) ** 2 for digit in str(number)) seen = set() steps = 0 while n != 1 and steps < 100: if n in seen: return \\"Not Happy\\" seen.add(n) n = get_next(n) steps += 1 return \\"Happy\\" if n == 1 else \\"Not Happy\\""},{"question":"class Organization: A class to model a simple hierarchical structure of employees and teams in an organization. Methods: - add_employee(name): Adds a new employee to the organization. Each employee must have a unique name. - assign_manager(employee_name, manager_name): Assigns the given manager_name as the manager of the employee_name. Returns False if there is any conflict such as cyclic reporting or if either name does not exist in the organization. Returns True otherwise. - get_manager(employee_name): Returns the name of the manager of the given employee, or None if the employee has no manager or does not exist. - get_team(manager_name): Returns the names of employees who directly report to the given manager in alphabetical order. Returns an empty list if the manager has no direct reports or does not exist. def __init__(self): pass def add_employee(self, name): Add a new employee to the organization. :param name: str, name of the employee :return: None pass def assign_manager(self, employee_name, manager_name): Assigns the given manager_name as the manager of the employee_name. :param employee_name: str, name of the employee :param manager_name: str, name of the manager :return: bool, True if the assignment is successful, False otherwise pass def get_manager(self, employee_name): Returns the name of the manager of the given employee :param employee_name: str, name of the employee :return: str or None, name of the manager or None if the employee has no manager or does not exist pass def get_team(self, manager_name): Returns the names of employees who directly report to the given manager in alphabetical order. :param manager_name: str, name of the manager :return: list of str, names of direct reports or empty list if the manager has no direct reports or does not exist pass def test_add_employee(): org = Organization() org.add_employee(\\"Alice\\") assert \\"Alice\\" in org.employees def test_assign_manager(): org = Organization() org.add_employee(\\"Alice\\") org.add_employee(\\"Bob\\") assert org.assign_manager(\\"Bob\\", \\"Alice\\") == True assert org.employees[\\"Bob\\"] == \\"Alice\\" assert \\"Bob\\" in org.managers[\\"Alice\\"] def test_assign_manager_invalid(): org = Organization() org.add_employee(\\"Alice\\") assert not org.assign_manager(\\"Bob\\", \\"Alice\\") assert not org.assign_manager(\\"Alice\\", \\"Bob\\") def test_assign_manager_cycle(): org = Organization() org.add_employee(\\"Alice\\") org.add_employee(\\"Bob\\") org.add_employee(\\"Charlie\\") assert org.assign_manager(\\"Bob\\", \\"Alice\\") == True assert org.assign_manager(\\"Charlie\\", \\"Bob\\") == True assert org.assign_manager(\\"Alice\\", \\"Charlie\\") == False def test_get_manager(): org = Organization() org.add_employee(\\"Alice\\") org.add_employee(\\"Bob\\") org.assign_manager(\\"Bob\\", \\"Alice\\") assert org.get_manager(\\"Bob\\") == \\"Alice\\" assert org.get_manager(\\"Alice\\") == None def test_get_team(): org = Organization() org.add_employee(\\"Alice\\") org.add_employee(\\"Bob\\") org.add_employee(\\"Charlie\\") org.assign_manager(\\"Bob\\", \\"Alice\\") org.assign_manager(\\"Charlie\\", \\"Bob\\") assert org.get_team(\\"Alice\\") == [\\"Bob\\"] assert org.get_team(\\"Bob\\") == [\\"Charlie\\"] assert org.get_team(\\"Charlie\\") == [] def test_get_team_empty(): org = Organization() org.add_employee(\\"Alice\\") assert org.get_team(\\"Alice\\") == [] assert org.get_team(\\"Bob\\") == []","solution":"class Organization: def __init__(self): self.employees = {} self.managers = {} def add_employee(self, name): if name not in self.employees: self.employees[name] = None def assign_manager(self, employee_name, manager_name): if employee_name not in self.employees or manager_name not in self.employees: return False if self._creates_cycle(employee_name, manager_name): return False self.employees[employee_name] = manager_name if manager_name not in self.managers: self.managers[manager_name] = [] self.managers[manager_name].append(employee_name) return True def get_manager(self, employee_name): return self.employees.get(employee_name, None) def get_team(self, manager_name): if manager_name not in self.managers: return [] return sorted(self.managers[manager_name]) def _creates_cycle(self, employee, manager): # Check if assigning this manager creates a cycle current = manager while current is not None: if current == employee: return True current = self.employees.get(current, None) return False"},{"question":"def paths_exist(T: int, test_cases: List[Tuple[int, int, Tuple[int, int], Tuple[int, int], int, List[Tuple[int, int]]]]) -> List[str]: Determine if there is a path for the player to move from the starting position to the final position without hitting any obstacles for each test case. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, int, Tuple[int, int], Tuple[int, int], int, List[Tuple[int, int]]]]): A list of test cases, where each test case is represented by: - N (int): number of rows in the grid - M (int): number of columns in the grid - start (Tuple[int, int]): starting position (startX, startY) - end (Tuple[int, int]): final position (endX, endY) - K (int): number of obstacles - obstacles (List[Tuple[int, int]]): list of obstacle coordinates Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case indicating if a path exists or not. >>> paths_exist(2, [(5, 5, (0, 0), (4, 4), 3, [(0, 1), (1, 0), (1, 2)]), (5, 5, (0, 0), (4, 4), 0, [])]) ['NO', 'YES'] >>> paths_exist(1, [(3, 3, (0, 0), (2, 2), 0, [])]) ['YES']","solution":"def bfs(grid, startX, startY, endX, endY, N, M): from collections import deque # Define possible movements : up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize the queue for BFS queue = deque([(startX, startY)]) grid[startX][startY] = True # Mark initial position as visited while queue: x, y = queue.popleft() # If we reach the end position, return True if x == endX and y == endY: return True # Explore the neighbors for dx, dy in directions: nx, ny = x + dx, y + dy # Check if the new position is within bounds and not visited/obstacle if 0 <= nx < N and 0 <= ny < M and not grid[nx][ny]: grid[nx][ny] = True queue.append((nx, ny)) # Return False if there's no path return False def is_path_possible(N, M, startX, startY, endX, endY, obstacles): # Create a grid of NxM with False denoting unvisited cells grid = [[False] * M for _ in range(N)] # Mark obstacles as True (visited) for ox, oy in obstacles: grid[ox][oy] = True return bfs(grid, startX, startY, endX, endY, N, M) def paths_exist(T, test_cases): results = [] for (N, M, start, end, K, obstacles) in test_cases: result = is_path_possible(N, M, start[0], start[1], end[0], end[1], obstacles) results.append(\\"YES\\" if result else \\"NO\\") return results # Sample usage # Input T = 2 test_cases = [ (5, 5, (0, 0), (4, 4), 3, [(0, 1), (1, 0), (1, 2)]), (5, 5, (0, 0), (4, 4), 0, []) ] print(paths_exist(T, test_cases)) # Output: ['NO', 'YES']"},{"question":"def smallest_missing_positive(arr): Returns the smallest positive integer that is not present in the array. >>> smallest_missing_positive([1, 2, 0]) 3 >>> smallest_missing_positive([3, 4, -1, 1, 2]) 5 >>> smallest_missing_positive([-1, -2, -3]) 1 >>> smallest_missing_positive([0, 0, 0]) 1 >>> smallest_missing_positive([1, 2, 3, 4, 5]) 6 >>> smallest_missing_positive([10, 11, 14, 20]) 1 >>> smallest_missing_positive([100, 1, 2, 200, 3]) 4 >>> smallest_missing_positive(list(range(-1000000, 0)) + list(range(1, 1000000))) 1000000","solution":"def smallest_missing_positive(arr): Returns the smallest positive integer that is not present in the array. arr = [num for num in arr if num > 0] arr = list(set(arr)) # Remove duplicates arr.sort() smallest_missing = 1 for num in arr: if num == smallest_missing: smallest_missing += 1 elif num > smallest_missing: break return smallest_missing"},{"question":"def remove_duplicates(input_list): Removes duplicates from the input list while maintaining the original order. Args: input_list (list): List of integers from which to remove duplicates. Returns: list: List with duplicates removed and original order maintained. >>> remove_duplicates([4, 5, 6, 4, 5, 6, 7]) [4, 5, 6, 7] >>> remove_duplicates([1, 2, 3, 2, 4, 3, 5, 6]) [1, 2, 3, 4, 5, 6] >>> remove_duplicates([0, 1, 0, 2, 0, 3]) [0, 1, 2, 3] >>> remove_duplicates([1, 1, 1, 1, 1]) [1] >>> remove_duplicates([]) [] >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([42]) [42]","solution":"def remove_duplicates(input_list): Removes duplicates from the input list while maintaining the original order. Args: input_list (list): List of integers from which to remove duplicates. Returns: list: List with duplicates removed and original order maintained. seen = set() output_list = [] for item in input_list: if item not in seen: seen.add(item) output_list.append(item) return output_list"},{"question":"class Task: def __init__(self, task_id, description): Initialize the task with the provided ID and description. >>> task = Task(1, \\"Test Task\\") >>> task.task_id 1 >>> task.description \\"Test Task\\" >>> task.completed False # Implement the initialization method def mark_complete(self): Mark the task as complete. >>> task = Task(1, \\"Test Task\\") >>> task.mark_complete() >>> task.completed True # Implement the method to mark task as complete class ToDoList: def __init__(self, list_name): Initialize the to-do list with the provided name. >>> todo_list = ToDoList(\\"Work\\") >>> todo_list.list_name \\"Work\\" >>> todo_list.tasks {} >>> todo_list.next_task_id 1 # Implement the initialization method def add_task(self, task_description): Add a task with the given description to the to-do list. >>> todo_list = ToDoList(\\"Work\\") >>> todo_list.add_task(\\"Task 1\\") >>> len(todo_list.tasks) 1 # Implement the method to add a task def remove_task(self, task_id): Remove the task with the given ID from the to-do list. >>> todo_list = ToDoList(\\"Work\\") >>> todo_list.add_task(\\"Task 1\\") >>> task_id = next(iter(todo_list.tasks)) # Assume it returns the task_id >>> todo_list.remove_task(task_id) >>> len(todo_list.tasks) 0 # Implement the method to remove a task def mark_task_complete(self, task_id): Mark the task with the given ID as complete in the to-do list. >>> todo_list = ToDoList(\\"Work\\") >>> todo_list.add_task(\\"Task 1\\") >>> task_id = next(iter(todo_list.tasks)) # Assume it returns the task_id >>> todo_list.mark_task_complete(task_id) >>> todo_list.tasks[task_id].completed True # Implement the method to mark a task as complete class User: def __init__(self, user_id, username): Initialize the user with the provided user_id and username. >>> user = User(1, \\"testuser\\") >>> user.user_id 1 >>> user.username \\"testuser\\" >>> user.lists {} # Implement the initialization method def create_list(self, list_name): Create a new ToDoList with the given name for the user. >>> user = User(1, \\"testuser\\") >>> user.create_list(\\"Work\\") >>> \\"Work\\" in user.lists True # Implement the method to create a list def delete_list(self, list_name): Delete the ToDoList with the given name from the user. >>> user = User(1, \\"testuser\\") >>> user.create_list(\\"Work\\") >>> user.delete_list(\\"Work\\") >>> \\"Work\\" not in user.lists True # Implement the method to delete a list def add_task_to_list(self, list_name, task_description): Add a new task with the given description to the specified list. >>> user = User(1, \\"testuser\\") >>> user.create_list(\\"Work\\") >>> user.add_task_to_list(\\"Work\\", \\"Task 1\\") >>> len(user.lists[\\"Work\\"].tasks) 1 # Implement the method to add a task to a list def remove_task_from_list(self, list_name, task_id): Remove the task with the given ID from the specified list. >>> user = User(1, \\"testuser\\") >>> user.create_list(\\"Work\\") >>> user.add_task_to_list(\\"Work\\", \\"Task 1\\") >>> task_id = next(iter(user.lists[\\"Work\\"].tasks)) # Assume it returns the task_id >>> user.remove_task_from_list(\\"Work\\", task_id) >>> len(user.lists[\\"Work\\"].tasks) 0 # Implement the method to remove a task from a list def mark_task_complete(self, list_name, task_id): Mark the task with the given ID as complete in the specified list. >>> user = User(1, \\"testuser\\") >>> user.create_list(\\"Work\\") >>> user.add_task_to_list(\\"Work\\", \\"Task 1\\") >>> task_id = next(iter(user.lists[\\"Work\\"].tasks)) # Assume it returns the task_id >>> user.mark_task_complete(\\"Work\\", task_id) >>> user.lists[\\"Work\\"].tasks[task_id].completed True # Implement the method to mark a task as complete","solution":"class Task: def __init__(self, task_id, description): self.task_id = task_id self.description = description self.completed = False def mark_complete(self): self.completed = True class ToDoList: def __init__(self, list_name): self.list_name = list_name self.tasks = {} self.next_task_id = 1 def add_task(self, task_description): task = Task(self.next_task_id, task_description) self.tasks[self.next_task_id] = task self.next_task_id += 1 def remove_task(self, task_id): if task_id in self.tasks: del self.tasks[task_id] def mark_task_complete(self, task_id): if task_id in self.tasks: self.tasks[task_id].mark_complete() class User: def __init__(self, user_id, username): self.user_id = user_id self.username = username self.lists = {} def create_list(self, list_name): if list_name not in self.lists: self.lists[list_name] = ToDoList(list_name) def delete_list(self, list_name): if list_name in self.lists: del self.lists[list_name] def add_task_to_list(self, list_name, task_description): if list_name in self.lists: self.lists[list_name].add_task(task_description) def remove_task_from_list(self, list_name, task_id): if list_name in self.lists: self.lists[list_name].remove_task(task_id) def mark_task_complete(self, list_name, task_id): if list_name in self.lists: self.lists[list_name].mark_task_complete(task_id)"},{"question":"from typing import List, Dict def reorder_logs(logs: List[str], word_frequencies: Dict[str, int]) -> List[str]: Reorder the logs using the provided words' frequency, preserving the original log order when ties occur. >>> reorder_logs([\\"error at line 3\\", \\"server warning\\", \\"connection timeout\\"], {\\"error\\": 5, \\"at\\": 1, \\"line\\": 2, \\"3\\": 1, \\"server\\": 4, \\"warning\\": 3, \\"connection\\": 2, \\"timeout\\": 1}) [\\"error at line 3\\", \\"server warning\\", \\"connection timeout\\"] >>> reorder_logs([\\"user login\\", \\"admin access granted\\", \\"user logout\\"], {\\"user\\": 4, \\"login\\": 2, \\"admin\\": 5, \\"access\\": 3, \\"granted\\": 1, \\"logout\\": 2}) [\\"admin access granted\\", \\"user login\\", \\"user logout\\"]","solution":"from typing import List, Dict def reorder_logs(logs: List[str], word_frequencies: Dict[str, int]) -> List[str]: def log_frequency(log): return sum(word_frequencies.get(word, 0) for word in log.split()) # Sort logs by the calculated frequency in descending order sorted_logs = sorted(logs, key=log_frequency, reverse=True) return sorted_logs"},{"question":"def prime_numbers(n: int) -> List[int]: Returns a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. >>> prime_numbers(10) [2, 3, 5, 7] >>> prime_numbers(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> prime_numbers(1) [] >>> prime_numbers(2) [2] >>> prime_numbers(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]","solution":"def prime_numbers(n): Returns a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. if n < 2: return [] is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(n**0.5) + 1): if is_prime[i]: for j in range(i * i, n + 1, i): is_prime[j] = False return [i for i, prime in enumerate(is_prime) if prime]"},{"question":"def manage_names(commands: List[str]) -> List[str]: Manage a list of names by adding or removing them based on the given commands. Args: commands (list): List of commands to be executed on the names list Returns: list: Sorted list of names after executing all commands >>> manage_names([\\"add alice\\", \\"add bob\\", \\"add charlie\\", \\"remove bob\\", \\"add dave\\", \\"remove bob\\"]) [\\"alice\\", \\"charlie\\", \\"dave\\"] >>> manage_names([\\"add zebra\\", \\"remove zebra\\", \\"add yak\\", \\"add xenon\\", \\"add apple\\"]) [\\"apple\\", \\"xenon\\", \\"yak\\"]","solution":"def manage_names(commands): Manage a list of names by adding or removing them based on the given commands. Args: commands (list): List of commands to be executed on the names list Returns: list: Sorted list of names after executing all commands names = set() for command in commands: action, name = command.split() if action == 'add': names.add(name) elif action == 'remove' and name in names: names.remove(name) return sorted(names)"},{"question":"def find_unique_element(n: int, arr: List[int]) -> int: Find the single element that appears only once in the array. Args: n: An integer represents the number of elements in the array. arr: A list of integers where each element appears twice except for one unique element. Returns: The unique element that appears only once. >>> find_unique_element(7, [1, 2, 3, 2, 1, 4, 3]) 4 >>> find_unique_element(5, [4, 3, 3, 4, 5]) 5 from solution import find_unique_element def test_single_element(): assert find_unique_element(1, [1]) == 1 def test_all_pairs_except_one(): assert find_unique_element(7, [1, 2, 3, 2, 1, 4, 3]) == 4 assert find_unique_element(5, [4, 3, 3, 4, 5]) == 5 def test_large_numbers(): assert find_unique_element(5, [1000000000, 999999999, 999999999, 1000000000, 123456789]) == 123456789 def test_all_elements_same(): assert find_unique_element(3, [999999999, 999999999, 1000000000]) == 1000000000 def test_mixed_order(): assert find_unique_element(9, [11, 12, 11, 22, 12, 33, 22, 44, 33]) == 44 def test_with_duplicates(): assert find_unique_element(9, [4, 1, 2, 1, 2, 4, 3, 3, 8]) == 8","solution":"def find_unique_element(n, arr): Returns the unique element in the array. unique_element = 0 for num in arr: unique_element ^= num return unique_element # Example usage: # n = 7 # arr = [1, 2, 3, 2, 1, 4, 3] # print(find_unique_element(n, arr)) # Output: 4"},{"question":"def calculate_weight(string, weights): Calculate and return the total weight of the string based on the given weights. # Your code here def sort_strings_by_weight(weights, strings): Sort the given list of strings based on their calculated weights. Maintain the original order in case of ties. # Your code here def main(weights, n, strings): Sort the strings by their weighted sum and then by their original order in case of tie. Weights is a list of 26 integers, each representing the weight of the corresponding letter. N is the number of strings. Strings is the list of strings to be sorted. Example: >>> weights = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26] >>> n = 5 >>> strings = [\\"abb\\", \\"abc\\", \\"abcd\\", \\"aaa\\", \\"bcc\\"] >>> main(weights, n, strings) ['aaa', 'abb', 'abc', 'bcc', 'abcd'] Tests: >>> weights = list(range(1, 27)) >>> strings = [\\"abb\\", \\"abc\\", \\"abcd\\", \\"aaa\\", \\"bcc\\"] >>> sort_strings_by_weight(weights, strings) ['aaa', 'abb', 'abc', 'bcc', 'abcd'] >>> weights = list(range(1, 27)) >>> calculate_weight(\\"abc\\", weights) 6 # Your code here","solution":"def calculate_weight(string, weights): Calculate and return the total weight of the string based on the given weights. return sum(weights[ord(char) - ord('a')] for char in string) def sort_strings_by_weight(weights, strings): Sort the given list of strings based on their calculated weights. Maintain the original order in case of ties. weighted_strings = [(string, calculate_weight(string, weights)) for string in strings] weighted_strings.sort(key=lambda x: x[1]) return [string for string, weight in weighted_strings] def main(weights, n, strings): sorted_strings = sort_strings_by_weight(weights, strings) return sorted_strings"},{"question":"def navigate_robot(target_x: int, target_y: int, commands: List[str]) -> bool: Function to navigate the robot from (0, 0) to (target_x, target_y) using a list of commands. :param target_x: int - x-coordinate of the target position :param target_y: int - y-coordinate of the target position :param commands: list - list of commands (\\"U\\", \\"D\\", \\"L\\", \\"R\\") :return: bool - True if the sequence of commands correctly moves the robot to the target position, False otherwise. >>> navigate_robot(2, 2, [\\"R\\", \\"R\\", \\"D\\", \\"D\\"]) True >>> navigate_robot(3, 3, [\\"R\\", \\"R\\", \\"R\\", \\"D\\", \\"D\\", \\"D\\"]) True >>> navigate_robot(3, 3, [\\"R\\", \\"U\\", \\"D\\", \\"R\\", \\"D\\", \\"D\\", \\"R\\"]) False >>> navigate_robot(5, 5, [\\"R\\", \\"R\\", \\"R\\", \\"R\\", \\"D\\", \\"D\\", \\"D\\", \\"D\\", \\"L\\", \\"L\\"]) False","solution":"def navigate_robot(target_x, target_y, commands): Function to navigate the robot from (0, 0) to (target_x, target_y) using a list of commands. :param target_x: int - x-coordinate of the target position :param target_y: int - y-coordinate of the target position :param commands: list - list of commands (\\"U\\", \\"D\\", \\"L\\", \\"R\\") :return: bool - True if the sequence of commands correctly moves the robot to the target position, False otherwise. x, y = 0, 0 # initial position # move the robot based on the commands for command in commands: if command == \\"U\\": y -= 1 elif command == \\"D\\": y += 1 elif command == \\"L\\": x -= 1 elif command == \\"R\\": x += 1 # check if the robot is within grid boundaries if not (0 <= x <= 9 and 0 <= y <= 9): return False # check if the robot is at the target position return x == target_x and y == target_y"},{"question":"from typing import List, Tuple def number_of_branches(initial_branches: int, year: int) -> int: Given the initial number of branches and a specific year, returns the number of branches in that year. >>> number_of_branches(5, 3) 20 >>> number_of_branches(5, 5) 80 pass def total_branches_between_years(initial_branches: int, start_year: int, end_year: int) -> int: Given the initial number of branches and a range of years, returns the total number of branches that existed between the start_year and end_year, inclusive. >>> total_branches_between_years(5, 1, 3) 35 >>> total_branches_between_years(5, 2, 4) 70 pass def process_queries(initial_branches: int, queries: List[Tuple[int, ...]]) -> List[int]: Processes a series of queries and returns a list of results for each query. >>> process_queries(5, [(1, 3), (2, 1, 3), (1, 5), (2, 2, 4), (1, 7)]) [20, 35, 80, 70, 320] >>> process_queries(1, [(1, 1), (2, 1, 2), (1, 3)]) [1, 3, 4] pass","solution":"def number_of_branches(initial_branches, year): Given the initial number of branches and a specific year, returns the number of branches in that year. return initial_branches * (2 ** (year - 1)) def total_branches_between_years(initial_branches, start_year, end_year): Given the initial number of branches and a range of years, returns the total number of branches that existed between the start_year and end_year, inclusive. total_branches = 0 for year in range(start_year, end_year + 1): total_branches += number_of_branches(initial_branches, year) return total_branches def process_queries(initial_branches, queries): results = [] for query in queries: if query[0] == 1: # Query type [1 Y] year = query[1] results.append(number_of_branches(initial_branches, year)) elif query[0] == 2: # Query type [2 L R] start_year = query[1] end_year = query[2] results.append(total_branches_between_years(initial_branches, start_year, end_year)) return results"},{"question":"from typing import List, Tuple class NumArray: def __init__(self, nums: List[int]): self.n = len(nums) self.nums = nums[:] self.tree = [0] * (self.n + 1) for i in range(self.n): self._update_tree(i + 1, nums[i]) def _update_tree(self, i: int, val: int): while i <= self.n: self.tree[i] += val i += i & -i def update(self, index: int, val: int): delta = val - self.nums[index] self.nums[index] = val self._update_tree(index + 1, delta) def sum_range(self, left: int, right: int) -> int: return self._prefix_sum(right + 1) - self._prefix_sum(left) def _prefix_sum(self, i: int) -> int: total = 0 while i > 0: total += self.tree[i] i -= i & -i return total def handle_queries(n: int, q: int, nums: List[int], queries: List[str]) -> List[int]: Process a list of queries to update and sum elements in the list. >>> n = 5 >>> q = 3 >>> nums = [1, 2, 3, 4, 5] >>> queries = [\\"sum 1 3\\", \\"update 2 10\\", \\"sum 1 3\\"] >>> handle_queries(n, q, nums, queries) [9, 16] >>> n = 3 >>> q = 3 >>> nums = [1, 2, 3] >>> queries = [\\"update 0 5\\", \\"update 1 6\\", \\"update 2 7\\"] >>> handle_queries(n, q, nums, queries) [] >>> n = 4 >>> q = 2 >>> nums = [10, 20, 30, 40] >>> queries = [\\"sum 0 3\\", \\"sum 1 2\\"] >>> handle_queries(n, q, nums, queries) [100, 50] >>> n = 5 >>> q = 5 >>> nums = [7, 8, 9, 10, 11] >>> queries = [\\"sum 0 2\\", \\"update 3 5\\", \\"sum 2 4\\", \\"update 0 1\\", \\"sum 0 4\\"] >>> handle_queries(n, q, nums, queries) [24, 25, 34]","solution":"class NumArray: def __init__(self, nums): self.n = len(nums) self.nums = nums[:] self.tree = [0] * (self.n + 1) for i in range(self.n): self._update_tree(i + 1, nums[i]) def _update_tree(self, i, val): while i <= self.n: self.tree[i] += val i += i & -i def update(self, index, val): delta = val - self.nums[index] self.nums[index] = val self._update_tree(index + 1, delta) def sum_range(self, left, right): return self._prefix_sum(right + 1) - self._prefix_sum(left) def _prefix_sum(self, i): total = 0 while i > 0: total += self.tree[i] i -= i & -i return total def handle_queries(n, q, nums, queries): num_array = NumArray(nums) results = [] for query in queries: parts = query.split() if parts[0] == \\"update\\": index = int(parts[1]) value = int(parts[2]) num_array.update(index, value) elif parts[0] == \\"sum\\": left = int(parts[1]) right = int(parts[2]) results.append(num_array.sum_range(left, right)) return results"},{"question":"def max_subarray_sum(arr): Returns the maximum possible sum of a contiguous subarray within the given array. >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([5, 3, 2, 6, 7]) 23 >>> max_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) 9 pass def process_test_cases(test_cases): Processes multiple test cases to find the maximum sum of contiguous subarrays for each. >>> process_test_cases([[1, 2, 3, 4], [5, 3, 2, 6, 7]]) [10, 23] pass","solution":"def max_subarray_sum(arr): Returns the maximum possible sum of a contiguous subarray within the given array. max_current = max_global = arr[0] for i in range(1, len(arr)): max_current = max(arr[i], max_current + arr[i]) if max_current > max_global: max_global = max_current return max_global def process_test_cases(test_cases): results = [] for arr in test_cases: results.append(max_subarray_sum(arr)) return results"},{"question":"def update_inventory(inventory, n, transactions, m): Update the inventory list based on the transactions. Parameters: inventory (list): Initial quantities of items. n (int): Number of items in the inventory. transactions (list): List of transaction tuples (item index, transaction amount). m (int): Number of transactions. Returns: list: Updated inventory list. Example: >>> update_inventory([10, 5, 8, 3], 4, [(0, -3), (1, 7), (2, -10), (3, -1), (0, 1)], 5) [8, 12, 8, 2] >>> update_inventory([4, 2], 2, [(0, -5), (1, 3), (0, 2)], 3) [6, 5]","solution":"def update_inventory(inventory, n, transactions, m): Update the inventory list based on the transactions. Parameters: inventory (list): Initial quantities of items. n (int): Number of items in the inventory. transactions (list): List of transaction tuples (item index, transaction amount). m (int): Number of transactions. Returns: list: Updated inventory list. for (index, amount) in transactions: if 0 <= index < n: if inventory[index] + amount >= 0: inventory[index] += amount return inventory"},{"question":"from typing import List def is_overloaded(request_times: List[int], k: int) -> bool: Determines if the servers are overloaded given a list of request times and a threshold \`k\`. Parameters: - request_times (list): List of integers representing request times in milliseconds. - k (int): Maximum number of requests that can be handled in a 1 second (1000 milliseconds) interval. Returns: - bool: True if any one-second window is overloaded, otherwise False. Examples: >>> is_overloaded([100, 200, 300, 1500, 1600, 1700, 1800, 1900], 3) False >>> is_overloaded([100, 200, 300, 400, 500, 600, 700, 800], 3) True","solution":"def is_overloaded(request_times, k): Determines if the servers are overloaded given a list of request times and a threshold \`k\`. Parameters: - request_times (list): List of integers representing request times in milliseconds. - k (int): Maximum number of requests that can be handled in a 1 second (1000 milliseconds) interval. Returns: - bool: True if any one-second window is overloaded, otherwise False. # Edge case where there are no request times if not request_times: return False # Sort the request times to facilitate sliding window check request_times.sort() n = len(request_times) for i in range(n): # Find the end of the current 1-second window j = i while j < n and request_times[j] < request_times[i] + 1000: j += 1 # If the number of requests in this window exceeds the threshold if j - i > k: return True return False"},{"question":"def maximize_score(n: int, sequence: List[int]) -> int: Alice is playing a game with a sequence of integers. In this game, she can perform the following operations: 1. Choose any subsequence of the sequence, remove it, and append the sum of the removed elements to the end of the sequence. 2. Stop the game at any point, and calculate the score of the sequence as the sum of all remaining elements. Alice wants to maximize her score. You need to help Alice determine the maximum score she can achieve by performing a series of operations as described above. Returns the maximum score Alice can achieve by performing the operations. Parameters: n (int): Length of the sequence. sequence (List[int]): The initial sequence of integers. >>> maximize_score(5, [1, 2, 3, 4, 5]) 15 >>> maximize_score(3, [10, 20, 30]) 60 >>> maximize_score(4, [1, 1, 1, 1]) 4 >>> maximize_score(1, [1000000]) 1000000 >>> maximize_score(6, [10, 20, 30, 40, 50, 60]) 210","solution":"def maximize_score(n, sequence): Returns the maximum score Alice can achieve by performing the operations. # The maximum score Alice can achieve is simply the sum of all the elements in the sequence return sum(sequence)"},{"question":"def can_partition_graph(N: int, M: int, edges: List[Tuple[int, int]]) -> str: Determine if it is possible to partition an undirected connected graph into exactly two connected components by removing a single edge. Arguments: N -- number of nodes M -- number of edges edges -- list of edges represented as tuples of two integers (u, v) >>> can_partition_graph(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (2, 4)]) 'YES' >>> can_partition_graph(3, 3, [(1, 2), (2, 3), (1, 3)]) 'NO' >>> can_partition_graph(4, 3, [(1, 2), (2, 3), (3, 4)]) 'YES' >>> can_partition_graph(2, 1, [(1, 2)]) 'YES' >>> can_partition_graph(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 'YES' >>> can_partition_graph(5, 3, [(1, 2), (3, 4), (4, 5)]) 'NO'","solution":"def can_partition_graph(N, M, edges): from collections import defaultdict import sys sys.setrecursionlimit(200000) def dfs(node, visited, graph): visited[node] = True component_size = 1 for neighbor in graph[node]: if not visited[neighbor]: component_size += dfs(neighbor, visited, graph) return component_size if N == 2: return \\"YES\\" if M == 1 else \\"NO\\" graph = defaultdict(list) edge_count = defaultdict(int) for u, v in edges: graph[u].append(v) graph[v].append(u) edge_count[u] += 1 edge_count[v] += 1 for u, v in edges: graph[u].remove(v) graph[v].remove(u) visited = [False] * (N + 1) components = 0 valid = True sizes = [] for i in range(1, N + 1): if not visited[i]: sizes.append(dfs(i, visited, graph)) if len(sizes) > 2: valid = False break components += 1 graph[u].append(v) graph[v].append(u) if components == 2 and valid: return \\"YES\\" return \\"NO\\""},{"question":"def minCompletionTime(workers, tasks): Determine the minimum amount of time required to complete all tasks with the given number of workers. Parameters: workers (int): the number of workers available. tasks (list): a list of integers where each integer represents the time duration of a task. Returns: int: the minimum units of time required to complete all tasks. >>> minCompletionTime(3, [2, 2, 3, 5, 9, 3]) 9 >>> minCompletionTime(1, [1, 2, 3, 4, 5]) 15 >>> minCompletionTime(10, [4, 2, 7]) 7 >>> minCompletionTime(5, [1, 2, 3, 4, 5]) 5 >>> minCompletionTime(10, [17, 11, 8, 47, 30, 5, 22]) 47","solution":"def minCompletionTime(workers, tasks): Determine the minimum amount of time required to complete all tasks with the given number of workers. Parameters: workers (int): the number of workers available. tasks (list): a list of integers where each integer represents the time duration of a task. Returns: int: the minimum units of time required to complete all tasks. from heapq import heappop, heappush # If the number of workers is greater than or equal to the number of tasks, # then the time required is just the longest task if workers >= len(tasks): return max(tasks) # Sort tasks in descending order to assign the longest tasks first tasks.sort(reverse=True) # Initialize a min-heap with zeros, one for each worker min_heap = [0] * workers # Assign each task to the worker with the current least load for task in tasks: least_loaded_worker = heappop(min_heap) heappush(min_heap, least_loaded_worker + task) # The time required is the maximum load of any worker after all assignments return max(min_heap)"},{"question":"def fillZigzag(n: int) -> List[List[int]]: Given a positive integer n representing the number of rows, returns a list of lists representing a matrix of size n x 10 filled in a zigzag pattern. >>> fillZigzag(3) [[1, 6, 7, 12, 13, 18, 19, 24, 25, 30], [2, 5, 8, 11, 14, 17, 20, 23, 26, 29], [3, 4, 9, 10, 15, 16, 21, 22, 27, 28]] >>> fillZigzag(1) [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]] >>> fillZigzag(5) [[1, 10, 11, 20, 21, 30, 31, 40, 41, 50], [2, 9, 12, 19, 22, 29, 32, 39, 42, 49], [3, 8, 13, 18, 23, 28, 33, 38, 43, 48], [4, 7, 14, 17, 24, 27, 34, 37, 44, 47], [5, 6, 15, 16, 25, 26, 35, 36, 45, 46]]","solution":"def fillZigzag(n): Returns a list of lists representing a matrix of size n x 10 filled in a zigzag pattern. matrix = [[0] * 10 for _ in range(n)] num = 1 for col in range(10): if col % 2 == 0: # fill top to bottom for row in range(n): matrix[row][col] = num num += 1 else: # fill bottom to top for row in range(n - 1, -1, -1): matrix[row][col] = num num += 1 return matrix"},{"question":"def longest_good_clues_segment(n: int, clues: List[int]) -> int: Returns the length of the longest consecutive segment of good clues. Parameters: n (int): The number of clues. clues (list of int): A list of integers where each integer is either 1 (good) or 0 (bad). Returns: int: The length of the longest segment of consecutive good clues. >>> longest_good_clues_segment(10, [1, 0, 1, 1, 0, 1, 1, 1, 0, 1]) 3 >>> longest_good_clues_segment(6, [0, 0, 0, 0, 0, 0]) 0","solution":"def longest_good_clues_segment(n, clues): Returns the length of the longest consecutive segment of good clues. Parameters: n (int): The number of clues. clues (list of int): A list of integers where each integer is either 1 (good) or 0 (bad). Returns: int: The length of the longest segment of consecutive good clues. max_length = 0 current_length = 0 for clue in clues: if clue == 1: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"def main(z: int, r: int, road_list: List[Tuple[int, int, int]]) -> List[List[int]]: Write a function to find the Minimum Spanning Tree (MST) for a given graph of zones and roads. The function should return the roads included in the MST that will connect all the zones with the minimum total length. :param z: an integer representing the number of zones. :param r: an integer representing the number of roads. :param road_list: a list of tuples where each tuple contains three integers (u, v, w). u and v are the endpoints of a road, and w is the length of the road. :return: a list of lists where each inner list represents a road in the MST with [u, v, w]. Example: >>> main(4, 5, [(0, 1, 1), (0, 2, 2), (0, 3, 1), (1, 3, 3), (2, 3, 4)]) [[0, 1, 1], [0, 3, 1], [0, 2, 2]] >>> main(2, 1, [(0, 1, 5)]) [[0, 1, 5]] >>> main(1, 0, []) []","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(z, r, roads): result = [] i = 0 e = 0 roads = sorted(roads, key=lambda item: item[2]) parent = [] rank = [] for node in range(z): parent.append(node) rank.append(0) while e < z - 1: u, v, w = roads[i] i = i + 1 x = find(parent, u) y = find(parent, v) if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) return result # Main function to process input and output def main(z, r, road_list): roads = [tuple(road) for road in road_list] mst = kruskal_mst(z, r, roads) return mst"},{"question":"def find_influencer(n: int, m: int, connections: List[Tuple[int, int]]) -> int: Determines the user ID of the influencer based on the follow connections. :param n: Number of users in the network. :param m: Number of follow connections. :param connections: List of tuples representing the follow connections. :return: User ID of the influencer. >>> find_influencer(5, 4, [(1, 3), (2, 3), (4, 3), (5, 2)]) 3 >>> find_influencer(4, 6, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (4, 1)]) 3","solution":"def find_influencer(n, m, connections): Determines the user ID of the influencer based on the follow connections. :param n: Number of users in the network. :param m: Number of follow connections. :param connections: List of tuples representing the follow connections. :return: User ID of the influencer. from collections import defaultdict followers_count = defaultdict(int) for a, b in connections: followers_count[b] += 1 max_followers = -1 influencer_id = float('inf') for user_id, count in followers_count.items(): if count > max_followers or (count == max_followers and user_id < influencer_id): max_followers = count influencer_id = user_id return influencer_id"},{"question":"def decode_string(N: int, E: str) -> str: Decodes the string 'E' by rotating each character backward by 'N' steps in the alphabet. Args: N: Integer representing the number of steps to rotate each letter backward. E: Encoded string consisting of uppercase and lowercase English letters. Returns: Decoded string where each letter is rotated backward by 'N' steps. Examples: >>> decode_string(3, 'KhoorZruog') 'HelloWorld' >>> decode_string(1, 'UifsfJtBOpY') 'ThereIsANoX' pass # Unit tests def test_decode_string_case1(): assert decode_string(3, 'KhoorZruog') == 'HelloWorld' def test_decode_string_case2(): assert decode_string(1, 'UifsfJtBOpY') == 'ThereIsANoX' def test_decode_string_single_char(): assert decode_string(5, 'f') == 'a' assert decode_string(1, 'B') == 'A' def test_decode_string_multiple_chars(): assert decode_string(2, 'cde') == 'abc' assert decode_string(2, 'CDE') == 'ABC' def test_decode_string_edge_cases(): assert decode_string(26, 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' assert decode_string(0, 'KhoorZruog') == 'KhoorZruog'","solution":"def decode_string(N, E): Decodes the string 'E' by rotating each character backward by 'N' steps. Args: N: Number of steps each letter was initially rotated forward. E: The encoded string. Returns: Decoded string. decoded_chars = [] for char in E: if 'A' <= char <= 'Z': decoded_char = chr(((ord(char) - ord('A') - N) % 26) + ord('A')) elif 'a' <= char <= 'z': decoded_char = chr(((ord(char) - ord('a') - N) % 26) + ord('a')) decoded_chars.append(decoded_char) return ''.join(decoded_chars)"},{"question":"from typing import List, Tuple def find_min_additional_corridors(N: int, M: int, corridors: List[Tuple[int, int]]) -> int: Compute the minimal number of additional corridors required to ensure that all rooms are interconnected. Args: N (int): Number of rooms. M (int): Number of existing corridors. corridors (List[Tuple[int, int]]): List of tuples representing existing corridors between rooms. Returns: int: Minimum number of additional corridors needed. >>> find_min_additional_corridors(4, 2, [(0, 1), (2, 3)]) 1 >>> find_min_additional_corridors(5, 3, [(0, 2), (0, 3), (1, 4)]) 1 >>> find_min_additional_corridors(3, 0, []) 2 from solution import find_min_additional_corridors def test_example_1(): assert find_min_additional_corridors(4, 2, [(0, 1), (2, 3)]) == 1 def test_example_2(): assert find_min_additional_corridors(5, 3, [(0, 2), (0, 3), (1, 4)]) == 1 def test_example_3(): assert find_min_additional_corridors(3, 0, []) == 2 def test_single_room(): assert find_min_additional_corridors(2, 0, []) == 1 def test_complete_graph(): assert find_min_additional_corridors(4, 6, [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]) == 0 def test_no_existing_corridors(): assert find_min_additional_corridors(5, 0, []) == 4 def test_already_connected(): assert find_min_additional_corridors(3, 2, [(0, 1), (1, 2)]) == 0","solution":"def find_min_additional_corridors(N, M, corridors): from collections import defaultdict def dfs(node, visited, graph): stack = [node] while stack: curr = stack.pop() if not visited[curr]: visited[curr] = True for neighbor in graph[curr]: if not visited[neighbor]: stack.append(neighbor) graph = defaultdict(list) for u, v in corridors: graph[u].append(v) graph[v].append(u) visited = [False] * N connected_components = 0 for i in range(N): if not visited[i]: dfs(i, visited, graph) connected_components += 1 return connected_components - 1"},{"question":"def maxSubtractions(N: int, M: int) -> int: Returns the maximum number of times M can be subtracted from N before N becomes less than or equal to zero. >>> maxSubtractions(10, 3) 3 >>> maxSubtractions(15, 5) 3 >>> maxSubtractions(1000000000, 1) 1000000000","solution":"def maxSubtractions(N, M): Returns the maximum number of times M can be subtracted from N before N becomes less than or equal to zero. return N // M"},{"question":"from typing import List, Tuple def max_sum_of_A(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Partition the array into two subsets such that the sum of elements in subset A is maximized, and the number of elements in subset A is greater than or equal to the number of elements in subset B. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer n (the number of elements in the array) and a list of integers representing the array. Returns: List[int]: A list of integers where each integer is the sum of elements in subset A for each test case. Example: >>> max_sum_of_A(3, [(4, [1, 2, 3, 4]), (5, [1, 1, 1, 1, 1]), (6, [3, 3, 3, 3, 3, 3])]) [7, 3, 9]","solution":"def max_sum_of_A(t, test_cases): def partition_array(numbers): numbers.sort(reverse=True) length = len(numbers) half_length = (length + 1) // 2 sum_A = sum(numbers[:half_length]) return sum_A results = [] for i in range(t): n = test_cases[i][0] array = test_cases[i][1] results.append(partition_array(array)) return results"},{"question":"def max_subsequence_xor(arr): Returns the maximum XOR value of any non-empty subsequence of the given array. Examples: >>> max_subsequence_xor([3, 10, 5]) 15 >>> max_subsequence_xor([1, 2, 3, 4]) 7 >>> max_subsequence_xor([8, 7]) 15 >>> max_subsequence_xor([9]) 9 >>> max_subsequence_xor([1, 1, 1, 1]) 1 >>> max_subsequence_xor([2, 3, 4, 5, 6, 7, 8, 9, 10]) 15","solution":"def max_subsequence_xor(arr): Returns the maximum XOR value of any non-empty subsequence of the given array. # Initialize result max_xor = 0 # Traverse through all elements of the array for num in arr: # Update max_xor if needed max_xor |= num return max_xor if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) A = list(map(int, data[1:])) print(max_subsequence_xor(A))"},{"question":"from typing import List, Tuple, Union def sequence_operations(N: int, X: str, Y: str, operations: List[Union[Tuple[str, int, int], Tuple[str, int, int, str]]]) -> List[int]: Perform Swap and Query operations on two sequences of letters to maintain balance in the economy. Args: N : int : Length of sequences X and Y X : str : Sequence of letters consisting of 'A', 'B', 'C', 'D' Y : str : Sequence of letters consisting of 'A', 'B', 'C', 'D' operations : List[Union[Tuple[str, int, int], Tuple[str, int, int, str]]] : List of operations (Swap i j) and queries (Query n m k) to be performed Returns: List[int] : List of results for each Query operation Examples: >>> sequence_operations(5, \\"AACBD\\", \\"BDCAB\\", [(\\"Query\\", 3, 3, \\"A\\"), (\\"Swap\\", 1, 5), (\\"Query\\", 5, 5, \\"D\\"), (\\"Swap\\", 2, 4)]) [2, 8] >>> sequence_operations(4, \\"ABCD\\", \\"DCBA\\", [(\\"Query\\", 4, 4, \\"A\\"), (\\"Swap\\", 1, 2), (\\"Query\\", 4, 4, \\"B\\")]) [1, 1]","solution":"def sequence_operations(n, x, y, operations): # Helper function to get value based on character def get_value(character): values = {'A': 1, 'B': 2, 'C': 3, 'D': 4} return values[character] # Convert strings to lists for mutability x = list(x) y = list(y) results = [] for op in operations: if op[0] == 'Swap': _, i, j = op i -= 1 # Convert to 0-based index j -= 1 # Convert to 0-based index x[i], x[j] = x[j], x[i] y[i], y[j] = y[j], y[i] elif op[0] == 'Query': _, n, m, k = op value = get_value(k) count_in_x = sum(1 for char in x[:n] if char == k) count_in_y = sum(1 for char in y[:m] if char == k) total_value = (count_in_x + count_in_y) * value results.append(total_value) return results"},{"question":"def max_height_from_each_test_case(T, test_cases): Calculate the maximum height the bird can reach starting from a specific tree. Inputs: - T: Number of test cases. - test_cases: A list of tuples. Each tuple consists of: - N: The number of trees. - A list of N tuples (Xi, Yi, Hi) representing the coordinates and height of each tree. - S: The starting tree index. Output: - A list of integers representing the maximum height the bird can reach for each test case. >>> max_height_from_each_test_case(2, [ ... (4, [(0, 0, 10), (0, 1, 20), (1, 0, 15), (1, 1, 25)], 1), ... (3, [(3, 3, 5), (4, 3, 6), (5, 3, 2)], 2) ... ]) [25, 6] >>> max_height_from_each_test_case(1, [ ... (5, [(0, 0, 10), (0, 1, 20), (1, 0, 15), (1, 1, 25), (2, 1, 30)], 4) ... ]) [30]","solution":"def get_maximum_height(trees, start_index): from collections import deque def is_adjacent(tree1, tree2): x1, y1, _ = tree1 x2, y2, _ = tree2 return (x1 == x2 and abs(y1 - y2) == 1) or (y1 == y2 and abs(x1 - x2) == 1) n = len(trees) start_tree = trees[start_index - 1] max_height = start_tree[2] visited = [False] * n queue = deque([start_index - 1]) while queue: current = queue.popleft() if visited[current]: continue visited[current] = True current_tree = trees[current] for i in range(n): if not visited[i] and is_adjacent(current_tree, trees[i]) and trees[i][2] >= current_tree[2]: queue.append(i) max_height = max(max_height, trees[i][2]) return max_height def max_height_from_each_test_case(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] trees = test_cases[i][1] S = test_cases[i][2] results.append(get_maximum_height(trees, S)) return results"},{"question":"def minimize_max_sum(nums: List[int], K: int) -> int: Minimizes the maximum sum of K sub-arrays. >>> minimize_max_sum([1, 2, 3, 4, 5], 2) 9 >>> minimize_max_sum([5, 5, 5, 5, 5], 5) 5 >>> minimize_max_sum([5, 10, 5, 1], 3) 10 >>> minimize_max_sum([1000000000, 1, 1, 1, 1000000000], 2) 1000000002 >>> minimize_max_sum([1, 1, 1, 1, 1], 1) 5","solution":"def minimize_max_sum(nums, K): Minimizes the maximum sum of K sub-arrays. :param nums: List of integers representing the difficulty levels. :param K: Integer representing the number of sub-arrays. :return: Integer representing the minimal value of the maximum sum of the K sub-arrays. def can_split(max_sum): current_sum = 0 sub_array_count = 1 for num in nums: if current_sum + num > max_sum: sub_array_count += 1 current_sum = num if sub_array_count > K: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"def num_ways_to_reach_end(N: int, M: int, K: int, enemies: List[Tuple[int, int]]) -> int: Find the number of ways to move from the top-left corner to the bottom-right corner of an N x M grid without passing through enemy-occupied cells. You can only move right or down at each step. Return the result modulo 10**9 + 7. >>> num_ways_to_reach_end(3, 3, 0, []) 6 >>> num_ways_to_reach_end(3, 3, 1, [(2, 2)]) 2 >>> num_ways_to_reach_end(3, 3, 1, [(1, 1)]) 0 >>> num_ways_to_reach_end(1, 1, 0, []) 1 >>> num_ways_to_reach_end(4, 4, 2, [(2, 2), (3, 3)]) 4 >>> num_ways_to_reach_end(4, 4, 3, [(1, 2), (2, 1), (2, 2)]) 0","solution":"def num_ways_to_reach_end(N, M, K, enemies): MOD = 10**9 + 7 # Create a grid initialized to 0 grid = [[0] * M for _ in range(N)] # Mark the enemy cells as -1 for r, c in enemies: grid[r-1][c-1] = -1 # Initialize the starting cell if it's not an enemy cell grid[0][0] = 1 if grid[0][0] != -1 else 0 # Fill the grid with number of ways for i in range(N): for j in range(M): # If current cell is an enemy cell, skip it if grid[i][j] == -1: grid[i][j] = 0 continue # Add ways from top cell if it's within bounds and not an enemy if i > 0 and grid[i-1][j] != -1: grid[i][j] = (grid[i][j] + grid[i-1][j]) % MOD # Add ways from left cell if it's within bounds and not an enemy if j > 0 and grid[i][j-1] != -1: grid[i][j] = (grid[i][j] + grid[i][j-1]) % MOD # The result is the number of ways to reach the bottom-right corner return grid[N-1][M-1]"},{"question":"from typing import List, Tuple def minimum_spanning_tree_cost(n: int, m: int, edge_list: List[Tuple[int, int, int]]) -> int: Compute the minimum total cost to connect all nodes in the graph using the existing roads. Args: n (int): The number of nodes in the graph. m (int): The number of edges in the graph. edge_list (List[Tuple[int, int, int]]): A list of tuples where each tuple represents an edge with two nodes and a weight. Returns: int: The total cost of the Minimum Spanning Tree (MST). Example: >>> minimum_spanning_tree_cost(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 6), (3, 4, 3)]) 6 pass def test_example_case(): n = 4 m = 5 edges = [ (1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 6), (3, 4, 3) ] result = minimum_spanning_tree_cost(n, m, edges) assert result == 6 def test_disconnected_graph(): n = 3 m = 3 edges = [ (1, 2, 1), (2, 3, 2), (1, 3, 2) ] result = minimum_spanning_tree_cost(n, m, edges) assert result == 3 def test_larger_case(): n = 6 m = 8 edges = [ (1, 2, 3), (1, 3, 1), (1, 4, 6), (2, 3, 5), (2, 5, 2), (3, 4, 5), (3, 6, 4), (5, 6, 6) ] result = minimum_spanning_tree_cost(n, m, edges) assert result == 15 def test_single_edge(): n = 2 m = 1 edges = [ (1, 2, 1) ] result = minimum_spanning_tree_cost(n, m, edges) assert result == 1 def test_every_edge_has_same_weight(): n = 4 m = 5 edges = [ (1, 2, 4), (1, 3, 4), (2, 3, 4), (2, 4, 4), (3, 4, 4) ] result = minimum_spanning_tree_cost(n, m, edges) assert result == 12","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal_mst(n, edges): result = [] # This will store the resultant MST i, e = 0, 0 # Initialize count of edges in MST and index variable edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1: u, v, w = edges[i] i = i + 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) minimum_cost = sum([w for u, v, w in result]) return minimum_cost def minimum_spanning_tree_cost(n, m, edge_list): return kruskal_mst(n, edge_list)"},{"question":"from typing import List def findElementsWithSmallerAndLarger(arr: List[int]) -> int: Given an array of integers, find the number of elements that have at least one smaller element and at least one larger element. >>> findElementsWithSmallerAndLarger([5, 1, 9, 2, 5, 7]) 4 >>> findElementsWithSmallerAndLarger([1, 2, 3, 4, 5]) 3","solution":"from typing import List def findElementsWithSmallerAndLarger(arr: List[int]) -> int: if len(arr) < 2: return 0 min_element = min(arr) max_element = max(arr) count = 0 for element in arr: if element > min_element and element < max_element: count += 1 return count"},{"question":"def count_palindromic_paths(m: int, n: int) -> int: Calculate the number of unique palindromic paths from (1,1) to (m,n). >>> count_palindromic_paths(2, 2) 2 >>> count_palindromic_paths(3, 3) 6 >>> count_palindromic_paths(1, 1) 1 >>> count_palindromic_paths(2, 3) 0 >>> count_palindromic_paths(4, 4) 20 >>> count_palindromic_paths(5, 5) 70 >>> count_palindromic_paths(2, 5) 0 >>> count_palindromic_paths(4, 5) 0","solution":"def count_palindromic_paths(m, n): # Total steps we need to take to reach from (1,1) to (m,n) steps = m + n - 2 # If the step count is odd, there can't be any palindromic paths if steps % 2 != 0: return 0 # Initialize a 3D dp array dp = [[[0 for _ in range(m)] for _ in range(n)] for _ in range(steps // 2 + 1)] # Base case: for paths of length 0, only the starting point is valid for i in range(m): for j in range(n): dp[0][i][j] = (i == 0 and j == 0) # Fill the dp table by counting the valid moves for each half-length for l in range(1, steps // 2 + 1): for i in range(m): for j in range(n): if i > 0: dp[l][i][j] += dp[l - 1][i - 1][j] if j > 0: dp[l][i][j] += dp[l - 1][i][j - 1] # Count palindromic paths count = 0 half_steps = steps // 2 for i in range(m): for j in range(n): if i + j == half_steps: count += dp[half_steps][i][j] * dp[half_steps][m - 1 - i][n - 1 - j] return count"},{"question":"def is_prime(n: int) -> bool: Determines if a given number n is prime. :param n: The integer to check for primality. :return: True if n is a prime number, else False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(10) False >>> is_prime(17) True def check_primes(test_cases: List[int]) -> List[str]: Determines prime status for a list of test cases. :param test_cases: List of integers to check for primality. :return: List of strings \\"Yes\\" or \\"No\\" for each test case. >>> check_primes([2, 4, 5, 10]) [\\"Yes\\", \\"No\\", \\"Yes\\", \\"No\\"] >>> check_primes([1, 3, 9, 13]) [\\"No\\", \\"Yes\\", \\"No\\", \\"Yes\\"]","solution":"def is_prime(n): Determines if a given number n is prime. :param n: The integer to check for primality. :return: True if n is a prime number, else False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def check_primes(test_cases): Determines prime status for a list of test cases. :param test_cases: List of integers to check for primality. :return: List of strings \\"Yes\\" or \\"No\\" for each test case. return [\\"Yes\\" if is_prime(n) else \\"No\\" for n in test_cases]"},{"question":"def max_food(grid: List[List[int]]) -> int: Calculate the max food that can be consumed following the described rules. >>> max_food([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> max_food([ ... [1, 2], ... [3, 4] ... ]) 8 >>> max_food([[5]]) 5 >>> max_food([ ... [1, 2, 3, 4] ... ]) 10 >>> max_food([ ... [1], ... [2], ... [3], ... [4] ... ]) 10 >>> max_food([[1] * 1000 for _ in range(1000)]) 1999","solution":"def max_food(grid): Calculate the max food that can be consumed following the described rules. :param grid: List[List[int]], a 2D list representing the grid. :return: int, the maximum total food that can be consumed. if not grid or not grid[0]: return 0 N = len(grid) M = len(grid[0]) # Create a dp array to store the maximum food collected up to each cell dp = [[0] * M for _ in range(N)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, M): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, N): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, N): for j in range(1, M): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right corner contains the answer return dp[N - 1][M - 1]"},{"question":"def is_zigzag_sequence(nums): Determines if the given list of numbers is a Zigzag Sequence. A sequence of numbers is considered a Zigzag Sequence if each element is either strictly greater than or strictly less than its neighbors. Args: nums (list): List of numbers. Returns: bool: True if the list is a Zigzag Sequence, otherwise False.","solution":"def is_zigzag_sequence(nums): Determines if the given list of numbers is a Zigzag Sequence. A sequence of numbers is considered a Zigzag Sequence if each element is either strictly greater than or strictly less than its neighbors. Args: nums (list): List of numbers. Returns: bool: True if the list is a Zigzag Sequence, otherwise False. if len(nums) < 2: return False if len(nums) == 2: return nums[0] != nums[1] for i in range(1, len(nums) - 1): if not ((nums[i - 1] < nums[i] > nums[i + 1]) or (nums[i - 1] > nums[i] < nums[i + 1])): return False return True"},{"question":"import heapq from typing import List, Tuple def shortest_distance(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: You are given a road network represented by a graph with \`n\` nodes and \`m\` edges. Each node corresponds to a city, and each edge represents a bidirectional road connecting two cities with an integer length associated with it. Two cities can be connected directly by more than one road with different lengths. Your task is to find the shortest distance from the first city (city 1) to the last city (city \`n\`). If the city \`n\` cannot be reached from city 1, return -1. - Parameters: - n: an integer, number of cities/nodes - m: an integer, number of roads/edges - roads: a list of tuples, where each tuple contains three integers \`u\`, \`v\`, \`w\` representing a road connecting cities \`u\` and \`v\` with length \`w\`. - Returns: A single integer, the shortest distance from the first city (city 1) to the last city (city \`n\`). If there is no path from the first city to the last city, return -1. >>> shortest_distance(5, 6, [(1, 2, 2), (2, 3, 4), (3, 5, 1), (1, 4, 1), (4, 5, 3), (2, 5, 6)]) 4 >>> shortest_distance(3, 1, [(1, 2, 3)]) -1 pass","solution":"import heapq def shortest_distance(n, m, roads): Returns the shortest distance from city 1 to city n. If city n cannot be reached from city 1, return -1. graph = [[] for _ in range(n+1)] for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) INF = float('inf') dist = [INF] * (n + 1) dist[1] = 0 priority_queue = [(0, 1)] while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) return dist[n] if dist[n] != INF else -1"},{"question":"def count_genre_mismatches(n: int, inventory_check: List[Tuple[str, str]], correct_genre: List[Tuple[str, str]]) -> Tuple[int, int]: Count the number of books correctly and incorrectly labeled. Parameters: n (int): The number of books in the library. inventory_check (list of tuples): Each tuple consists of (Bi, Gi) where Bi is the book ID and Gi is the genre label as per the inventory check. correct_genre (list of tuples): Each tuple consists of (Bi, Gi) where Bi is the book ID and Gi is the correct genre. Returns: (int, int): A tuple where the first element is the number of correctly labeled books and the second element is the number of mislabeled books. >>> n = 4 >>> inventory_check = [(\\"bk1\\", \\"Fiction\\"), (\\"bk2\\", \\"Science\\"), (\\"bk3\\", \\"Romance\\"), (\\"bk4\\", \\"Fiction\\")] >>> correct_genre = [(\\"bk1\\", \\"Literature\\"), (\\"bk2\\", \\"Science\\"), (\\"bk3\\", \\"Thriller\\"), (\\"bk4\\", \\"Fiction\\")] >>> count_genre_mismatches(n, inventory_check, correct_genre) (2, 2) >>> n = 3 >>> inventory_check = [(\\"bk1\\", \\"Fantasy\\"), (\\"bk2\\", \\"Mystery\\"), (\\"bk3\\", \\"Science\\")] >>> correct_genre = [(\\"bk1\\", \\"Fantasy\\"), (\\"bk2\\", \\"Mystery\\"), (\\"bk3\\", \\"Romance\\")] >>> count_genre_mismatches(n, inventory_check, correct_genre) (2, 1) from typing import List, Tuple def test_count_genre_mismatches_example1(): n = 4 inventory_check = [(\\"bk1\\", \\"Fiction\\"), (\\"bk2\\", \\"Science\\"), (\\"bk3\\", \\"Romance\\"), (\\"bk4\\", \\"Fiction\\")] correct_genre = [(\\"bk1\\", \\"Literature\\"), (\\"bk2\\", \\"Science\\"), (\\"bk3\\", \\"Thriller\\"), (\\"bk4\\", \\"Fiction\\")] assert count_genre_mismatches(n, inventory_check, correct_genre) == (2, 2) def test_count_genre_mismatches_example2(): n = 3 inventory_check = [(\\"bk1\\", \\"Fantasy\\"), (\\"bk2\\", \\"Mystery\\"), (\\"bk3\\", \\"Science\\")] correct_genre = [(\\"bk1\\", \\"Fantasy\\"), (\\"bk2\\", \\"Mystery\\"), (\\"bk3\\", \\"Romance\\")] assert count_genre_mismatches(n, inventory_check, correct_genre) == (2, 1) def test_count_genre_mismatches_all_correct(): n = 3 inventory_check = [(\\"bk1\\", \\"Fantasy\\"), (\\"bk2\\", \\"Mystery\\"), (\\"bk3\\", \\"Science\\")] correct_genre = [(\\"bk1\\", \\"Fantasy\\"), (\\"bk2\\", \\"Mystery\\"), (\\"bk3\\", \\"Science\\")] assert count_genre_mismatches(n, inventory_check, correct_genre) == (3, 0) def test_count_genre_mismatches_all_mismatched(): n = 2 inventory_check = [(\\"bk1\\", \\"Fantasy\\"), (\\"bk2\\", \\"Science\\")] correct_genre = [(\\"bk1\\", \\"Mystery\\"), (\\"bk2\\", \\"Romance\\")] assert count_genre_mismatches(n, inventory_check, correct_genre) == (0, 2) def test_count_genre_mismatches_empty_list(): n = 0 inventory_check = [] correct_genre = [] assert count_genre_mismatches(n, inventory_check, correct_genre) == (0, 0)","solution":"def count_genre_mismatches(n, inventory_check, correct_genre): This function returns the count of correctly labeled books and mislabeled books. Parameters: n (int): The number of books in the library. inventory_check (list of tuples): Each tuple consists of (Bi, Gi) where Bi is the book ID and Gi is the genre label as per the inventory check. correct_genre (list of tuples): Each tuple consists of (Bi, Gi) where Bi is the book ID and Gi is the correct genre. Returns: (int, int): A tuple where the first element is the number of correctly labeled books and the second element is the number of mislabeled books. # Create a dictionary to hold the correct genre for each book ID correct_dict = {bi: gi for bi, gi in correct_genre} correctly_labeled = 0 mislabeled = 0 # Iterate over the inventory_check list and compare with correct_dict for bi, gi in inventory_check: if gi == correct_dict[bi]: correctly_labeled += 1 else: mislabeled += 1 return correctly_labeled, mislabeled"},{"question":"def can_partition(nums: List[int]) -> bool: Determine if there is a way to split the list into two non-empty subsets such that the sum of the elements in each subset is equal. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([1]) False >>> can_partition([2, 2]) True","solution":"def can_partition(nums): Returns True if the list can be partitioned into two subsets with equal sum. total_sum = sum(nums) # If the total sum is odd, it's not possible to partition it into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Create a dp array to store results of subproblems dp = [False] * (target + 1) dp[0] = True # Iterate through the numbers in the array for num in nums: # Iterate through the dp array backwards to update the values for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"def contains_repeated_characters(S: str) -> str: Determines if the input string S contains any repeated characters. :param S: A string consisting of lowercase English letters :return: 'YES' if any character in S is repeated, otherwise 'NO' >>> contains_repeated_characters(\\"hello\\") 'YES' >>> contains_repeated_characters(\\"world\\") 'NO' >>> contains_repeated_characters(\\"unique\\") 'YES' >>> contains_repeated_characters(\\"abcde\\") 'NO'","solution":"def contains_repeated_characters(S): Determines if the input string S contains any repeated characters. :param S: A string consisting of lowercase English letters :return: 'YES' if any character in S is repeated, otherwise 'NO' return 'YES' if len(set(S)) != len(S) else 'NO'"},{"question":"from typing import List def rotate_matrix_90_degrees(matrix: List[List[int]]) -> List[List[int]]: Rotates the input n x n matrix 90 degrees clockwise. Args: matrix (List[List[int]]): The input 2D matrix with n x n dimensions. Returns: List[List[int]]: The rotated matrix. Example: >>> rotate_matrix_90_degrees([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_degrees([[5]]) [[5]] # Pass to complete this method pass def test_rotate_matrix_3x3(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix_90_degrees(matrix) == expected def test_rotate_matrix_2x2(): matrix = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] assert rotate_matrix_90_degrees(matrix) == expected def test_rotate_matrix_1x1(): matrix = [ [5] ] expected = [ [5] ] assert rotate_matrix_90_degrees(matrix) == expected def test_rotate_matrix_4x4(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix_90_degrees(matrix) == expected def test_rotate_matrix_5x5(): matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] expected = [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ] assert rotate_matrix_90_degrees(matrix) == expected","solution":"from typing import List def rotate_matrix_90_degrees(matrix: List[List[int]]) -> List[List[int]]: Rotates the input n x n matrix 90 degrees clockwise. n = len(matrix) # Create a new matrix to store the result rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix # Example test input_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_matrix_90_degrees(input_matrix)) # Should output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ]"},{"question":"def lengthOfLongestSubstring(s: str) -> int: Returns the length of the longest substring without repeating characters. Example: >>> lengthOfLongestSubstring(\\"abcabcbb\\") 3 >>> lengthOfLongestSubstring(\\"bbbbb\\") 1","solution":"def lengthOfLongestSubstring(s): Returns the length of the longest substring without repeating characters. :param s: a string :return: an integer, the length of the longest substring without repeating characters char_index = {} longest = 0 start = 0 for end in range(len(s)): if s[end] in char_index and char_index[s[end]] >= start: start = char_index[s[end]] + 1 char_index[s[end]] = end longest = max(longest, end - start + 1) return longest"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers and the operators \`+\`, \`-\`, \`*\`, and \`/\` while maintaining the order of operations (BIDMAS/BODMAS rules). :param expression: A string representing the mathematical expression :return: An integer which is the result of evaluating the expression >>> evaluate_expression(\\"3+5*2\\") == 13 >>> evaluate_expression(\\"10+2*6/3\\") == 14 >>> evaluate_expression(\\"7-3\\") == 4 >>> evaluate_expression(\\"8/4\\") == 2 >>> evaluate_expression(\\"12*3/6\\") == 6 >>> evaluate_expression(\\"50/5*2\\") == 20 >>> evaluate_expression(\\"9*3/3\\") == 9 >>> evaluate_expression(\\"20+30-10\\") == 40 >>> evaluate_expression(\\"100-50+25\\") == 75 >>> evaluate_expression(\\"5+8*3-4/2\\") == 27 >>> evaluate_expression(\\"10+2*6-8/4\\") == 20 >>> evaluate_expression(\\"42\\") == 42 >>> evaluate_expression(\\"0\\") == 0","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers and the operators \`+\`, \`-\`, \`*\`, and \`/\` while maintaining the order of operations (BIDMAS/BODMAS rules). :param expression: A string representing the mathematical expression :return: An integer which is the result of evaluating the expression def operate(op, second, first): if op == '+': return first + second elif op == '-': return first - second elif op == '*': return first * second elif op == '/': return first // second num_stack = [] op_stack = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 num_stack.append(num) i -= 1 elif expression[i] in '+-*/': while (op_stack and op_stack[-1] in '*/' and expression[i] in '*/' or op_stack and op_stack[-1] in '*/' and expression[i] in '+-' or op_stack and op_stack[-1] in '+-' and expression[i] in '+-'): num_stack.append(operate(op_stack.pop(), num_stack.pop(), num_stack.pop())) op_stack.append(expression[i]) i += 1 while op_stack: num_stack.append(operate(op_stack.pop(), num_stack.pop(), num_stack.pop())) return num_stack[0]"},{"question":"import heapq from typing import List def merge_k_sorted_arrays(test_cases: int) -> List[str]: Merge K sorted arrays into a single sorted list for multiple test cases. Args: test_cases: An integer representing the number of test cases. Returns: A list of strings, where each string contains the elements of the merged sorted list for each test case. Example: >>> merge_k_sorted_arrays(2) [\\"1 1 2 2 3 4 4 5 7 8 10 15\\", \\"-10 0 1 5 20\\"] results = [] for _ in range(test_cases): k = int(input().strip()) arrays = [] for _ in range(k): array = list(map(int, input().strip().split()))[1:] arrays.append(array) merged_list = [] min_heap = [] for idx, array in enumerate(arrays): if array: heapq.heappush(min_heap, (array[0], idx, 0)) while min_heap: value, array_idx, element_idx = heapq.heappop(min_heap) merged_list.append(value) if element_idx + 1 < len(arrays[array_idx]): next_value = arrays[array_idx][element_idx + 1] heapq.heappush(min_heap, (next_value, array_idx, element_idx + 1)) results.append(\\" \\".join(map(str, merged_list))) return results # Example unit test def test_merge_k_sorted_arrays(): # Redirect input and output for testing from io import StringIO import sys input_data = 2 3 3 1 4 5 5 2 2 7 10 15 4 1 3 4 8 2 2 0 1 3 -10 5 20 expected_output = [\\"1 1 2 2 3 4 4 5 7 8 10 15\\", \\"-10 0 1 5 20\\"] sys.stdin = StringIO(input_data) results = merge_k_sorted_arrays(int(input().strip())) for result, expected in zip(results, expected_output): assert result == expected # Reset stdin sys.stdin = sys.__stdin__ test_merge_k_sorted_arrays()","solution":"import heapq def merge_k_sorted_arrays(test_cases): results = [] for _ in range(test_cases): k = int(input().strip()) arrays = [] for _ in range(k): array = list(map(int, input().strip().split()))[1:] arrays.append(array) merged_list = [] min_heap = [] for idx, array in enumerate(arrays): if array: heapq.heappush(min_heap, (array[0], idx, 0)) while min_heap: value, array_idx, element_idx = heapq.heappop(min_heap) merged_list.append(value) if element_idx + 1 < len(arrays[array_idx]): next_value = arrays[array_idx][element_idx + 1] heapq.heappush(min_heap, (next_value, array_idx, element_idx + 1)) results.append(\\" \\".join(map(str, merged_list))) return results"},{"question":"def transform_dictionary(input_dict): Transforms the input dictionary into a new dictionary where each key is the string from the original dictionary reversed, and the value is the product of all the integers in the original dictionary except for the integer corresponding to that key. >>> transform_dictionary({'apple': 2, 'banana': 3, 'cherry': 4}) {'elppa': 12, 'ananab': 8, 'yrrehc': 6} >>> transform_dictionary({'single': 5}) {'elgnis': 1} >>> transform_dictionary({}) {} >>> transform_dictionary({'one': 7, 'two': 5}) {'eno': 5, 'owt': 7} >>> transform_dictionary({'first': 2, 'second': 3, 'third': 5, 'fourth': 7}) {'tsrif': 105, 'dnoces': 70, 'driht': 42, 'htruof': 30}","solution":"def transform_dictionary(input_dict): Transforms the input dictionary into a new dictionary where each key is the string from the original dictionary reversed, and the value is the product of all the integers in the original dictionary except for the integer corresponding to that key. if not input_dict: return {} # Calculate the product of all values in the dictionary total_product = 1 for value in input_dict.values(): total_product *= value # Generate the new dictionary new_dict = {} for key, value in input_dict.items(): new_key = key[::-1] if len(input_dict) > 1: new_value = total_product // value else: new_value = 1 new_dict[new_key] = new_value return new_dict"},{"question":"def most_frequent_character(n: int, s: str) -> str: Returns the most frequently occurring character in a given string. If there is a tie, returns the lexicographically smallest character. >>> most_frequent_character(6, \\"bbaacc\\") 'a' >>> most_frequent_character(12, \\"aabbbccccddd\\") 'c' >>> most_frequent_character(5, \\"eeeee\\") 'e'","solution":"def most_frequent_character(n, s): Returns the most frequently occurring character in a given string. If there is a tie, returns the lexicographically smallest character. from collections import Counter frequency = Counter(s) most_common_char = min(frequency.keys(), key=lambda char: (-frequency[char], char)) return most_common_char"},{"question":"def largestPerimeter(nums): Returns the largest perimeter of a triangle with non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0. pass from typing import List def test_example_1(): assert largestPerimeter([2, 1, 2]) == 5 def test_example_2(): assert largestPerimeter([1, 2, 1]) == 0 def test_example_3(): assert largestPerimeter([3, 6, 2, 3]) == 8 def test_large_numbers(): assert largestPerimeter([10, 15, 20, 5, 25]) == 60 def test_no_valid_triangle(): assert largestPerimeter([1, 1, 1, 1, 1]) == 3 def test_multiple_triangles(): assert largestPerimeter([2, 3, 4, 5, 10]) == 12 def test_only_zero_area(): assert largestPerimeter([10, 50, 5]) == 0 def test_large_array(): large_array = [i for i in range(1, 10001)] assert largestPerimeter(large_array) == 29997 def test_min_max_values(): assert largestPerimeter([1, 1, 1, 1, 1000000, 1000000, 1000000]) == 3000000","solution":"def largestPerimeter(nums): Returns the largest perimeter of a triangle with non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0. nums.sort(reverse=True) for i in range(len(nums) - 2): if nums[i] < nums[i + 1] + nums[i + 2]: return nums[i] + nums[i + 1] + nums[i + 2] return 0"},{"question":"def distribute_funds(t: int, n: int) -> Tuple[int, int]: Calculate how much money each community center receives and how much money is left with Anna. Parameters: t (int): Total donation funds (100 ≤ t ≤ 1000000). n (int): Number of community centers (1 ≤ n ≤ 1000). Returns: tuple: Amount each community center receives, Leftover amount with Anna. >>> distribute_funds(2500, 7) (357, 1) >>> distribute_funds(10000, 15) (666, 10) >>> distribute_funds(5000, 3) (1666, 2)","solution":"def distribute_funds(t, n): Calculate how much money each community center receives and leftover amount. Parameters: t (int): Total donation funds (100 ≤ t ≤ 1000000). n (int): Number of community centers (1 ≤ n ≤ 1000). Returns: tuple: Amount each community center receives, Leftover amount with Anna. per_center = t // n leftover = t % n return per_center, leftover"},{"question":"def are_anagrams(str_list: List[str]) -> str: Determines if all strings in the list are anagrams of each other. Args: str_list (list): List of strings to check Returns: str: \\"Yes\\" if all strings are anagrams, otherwise \\"No\\" pass def test_all_anagrams(): assert are_anagrams(['listen', 'silent', 'enlist']) == \\"Yes\\" assert are_anagrams(['abc', 'cab', 'bca']) == \\"Yes\\" def test_not_all_anagrams(): assert are_anagrams(['listen', 'silent', 'hello']) == \\"No\\" assert are_anagrams(['abcd', 'abdc', 'abcf']) == \\"No\\" def test_same_strings(): assert are_anagrams(['aaa', 'aaa', 'aaa']) == \\"Yes\\" def test_single_character_strings(): assert are_anagrams(['a', 'a', 'a']) == \\"Yes\\" assert are_anagrams(['a', 'b', 'a']) == \\"No\\" def test_two_strings(): assert are_anagrams(['abc', 'bca']) == \\"Yes\\" assert are_anagrams(['abc', 'def']) == \\"No\\" # Edge cases def test_empty_list(): assert are_anagrams([]) == \\"No\\"","solution":"def are_anagrams(str_list): Determines if all strings in the list are anagrams of each other. Args: str_list (list): List of strings to check Returns: str: \\"Yes\\" if all strings are anagrams, otherwise \\"No\\" if not str_list: return \\"No\\" # Sort the first string to get a base anagram comparison base_sorted = sorted(str_list[0]) for s in str_list[1:]: if sorted(s) != base_sorted: return \\"No\\" return \\"Yes\\""},{"question":"def countSubstrs(s: str) -> int: Count the number of contiguous substrings that start and end with the same character. :param s: input string :type s: str :return: number of substrings :rtype: int Examples: >>> countSubstrs(\\"abcab\\") 7 >>> countSubstrs(\\"aaaa\\") 10","solution":"def countSubstrs(s): Count contiguous substrings that start and end with the same character. :param s: input string :type s: str :return: number of substrings :rtype: int n = len(s) count = 0 for i in range(n): j = i while j < n: if s[i] == s[j]: count += 1 j += 1 return count"},{"question":"def is_path_exists(grid): Determine if there's a path from the starting point 'S' to the endpoint 'E' in the given grid. >>> is_path_exists([ ... \\"S..B\\", ... \\"..B.\\", ... \\"B...\\", ... \\"...E\\" ... ]) \\"Yes\\" >>> is_path_exists([ ... \\"S.B\\", ... \\".B.\\", ... \\".BE\\" ... ]) \\"No\\"","solution":"def is_path_exists(grid): from collections import deque n = len(grid) m = len(grid[0]) # Find the starting point 'S' start = None for i in range(n): for j in range(m): if grid[i][j] == 'S': start = (i, j) break if start: break # Direction vectors for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Use a queue to perform BFS queue = deque([start]) visited = set() visited.add(start) while queue: x, y = queue.popleft() if grid[x][y] == 'E': return \\"Yes\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] != 'B': queue.append((nx, ny)) visited.add((nx, ny)) return \\"No\\""},{"question":"from typing import List def length_of_longest_substring(s: str) -> int: Given a string, find the length of the longest substring without repeating characters. Args: s: A string consisting of lower-case alphabets. Returns: Integer: Length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"au\\") 2 def process_test_cases(test_cases: List[str]) -> List[int]: Takes a list of test cases and returns a list of results for each test case. Args: test_cases: A list of strings where each string is a test case. Returns: List of integers where each integer is the length of the longest substring without repeating characters for a test case. >>> process_test_cases([\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 3] >>> process_test_cases([\\"\\", \\"a\\", \\"au\\"]) [0, 1, 2]","solution":"def length_of_longest_substring(s: str) -> int: Given a string, find the length of the longest substring without repeating characters. n = len(s) char_index_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index_map: start = max(char_index_map[s[end]] + 1, start) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length def process_test_cases(test_cases: list) -> list: Takes a list of test cases and returns a list of results for each test case. result = [] for s in test_cases: result.append(length_of_longest_substring(s)) return result"},{"question":"def can_transform(source: str, target: str) -> str: Determines if the source string can be transformed into the target string by repeatedly moving any character to the front of the string. >>> can_transform(\\"abc\\", \\"cab\\") 'YES' >>> can_transform(\\"abc\\", \\"xyz\\") 'NO' >>> can_transform(\\"aaabb\\", \\"bbaaa\\") 'YES' >>> can_transform(\\"abcde\\", \\"edcba\\") 'YES'","solution":"def can_transform(source, target): Determines if the source string can be transformed into the target string by repeatedly moving any character to the front of the string. if sorted(source) == sorted(target): return \\"YES\\" else: return \\"NO\\""},{"question":"class IntegerSet: Implement a data structure that supports the following operations on a set of integers: - insert(x): Add integer \`x\` to the set. - remove(x): Remove integer \`x\` from the set if it is present. - find(x): Determines if integer \`x\` is present in the set. - get_min(): Return the smallest integer in the set. If the set is empty, return \`None\`. - get_max(): Return the largest integer in the set. If the set is empty, return \`None\`. def __init__(self): pass def insert(self, x): pass def remove(self, x): pass def find(self, x): pass def get_min(self): pass def get_max(self): pass # Unit Tests def test_operations(): integer_set = IntegerSet() # Test insert and find integer_set.insert(5) integer_set.insert(3) integer_set.insert(7) assert integer_set.find(5) == \\"YES\\" assert integer_set.find(3) == \\"YES\\" assert integer_set.find(7) == \\"YES\\" assert integer_set.find(10) == \\"NO\\" # Test get_min and get_max assert integer_set.get_min() == 3 assert integer_set.get_max() == 7 # Test remove and find integer_set.remove(5) assert integer_set.find(5) == \\"NO\\" # Test get_min and get_max after removal assert integer_set.get_min() == 3 assert integer_set.get_max() == 7 # Test boundary condition with removal of all elements integer_set.remove(3) integer_set.remove(7) assert integer_set.get_min() == None assert integer_set.get_max() == None def test_mixed_operations(): integer_set = IntegerSet() # Initial inserts and checks integer_set.insert(10) assert integer_set.get_min() == 10 assert integer_set.get_max() == 10 # Remove and check empty state integer_set.remove(10) assert integer_set.get_min() == None assert integer_set.get_max() == None # Insert again and check integer_set.insert(2) integer_set.insert(8) assert integer_set.get_min() == 2 assert integer_set.get_max() == 8 integer_set.remove(2) assert integer_set.get_min() == 8 assert integer_set.get_max() == 8","solution":"class IntegerSet: def __init__(self): self.set = set() def insert(self, x): self.set.add(x) def remove(self, x): self.set.discard(x) # discard does not raise an error if x is not present def find(self, x): return \\"YES\\" if x in self.set else \\"NO\\" def get_min(self): if not self.set: return None return min(self.set) def get_max(self): if not self.set: return None return max(self.set)"},{"question":"def calculate_ticket_cost(group_size: int) -> int: Calculates the total cost of tickets based on the group size. Args: group_size (int): The number of people in the group Returns: int: The total cost of tickets for the group # Your code goes here def process_test_cases(test_cases: List[int]) -> List[int]: Calculates the total cost of tickets for various test cases. Args: test_cases (List[int]): List of group sizes for each test case Returns: List[int]: List of total costs for each test case # Your code goes here","solution":"def calculate_ticket_cost(group_size): Calculates the total cost of tickets based on the group size. Args: group_size (int): The number of people in the group Returns: int: The total cost of tickets for the group ticket_price = 20 total_cost = group_size * ticket_price if group_size >= 5: total_cost *= 0.8 return int(total_cost) def process_test_cases(test_cases): results = [] for group_size in test_cases: results.append(calculate_ticket_cost(group_size)) return results"},{"question":"def sort_pokemon(t, test_cases): Sorts Pokémon species by their region number and then alphabetically within each region. >>> sort_pokemon(2, [(5, [(\\"Pikachu\\", 1), (\\"Bulbasaur\\", 2), (\\"Charmander\\", 1), (\\"Squirtle\\", 2), (\\"Eevee\\", 1)]), (3, [(\\"Oddish\\", 3), (\\"Bellsprout\\", 3), (\\"Pidgey\\", 2)])]) [[('Charmander', 1), ('Eevee', 1), ('Pikachu', 1), ('Bulbasaur', 2), ('Squirtle', 2)], [('Pidgey', 2), ('Bellsprout', 3), ('Oddish', 3)]] pass def format_output(sorted_pokemons): Formats the sorted Pokémon species list into a string with each line containing the Pokémon's name followed by its region. >>> format_output([[('Charmander', 1), ('Eevee', 1), ('Pikachu', 1), ('Bulbasaur', 2), ('Squirtle', 2)], [('Pidgey', 2), ('Bellsprout', 3), ('Oddish', 3)]]) 'Charmander 1nEevee 1nPikachu 1nBulbasaur 2nSquirtle 2nnPidgey 2nBellsprout 3nOddish 3' pass def main(): Main function to read input, process Pokémon records, and output the sorted list. pass if __name__ == \\"__main__\\": main()","solution":"def sort_pokemon(t, test_cases): result = [] for test_case in test_cases: n, pokemons = test_case pokemons.sort(key=lambda x: (x[1], x[0])) # Sorting by region and then alphabetically result.append(pokemons) return result def format_output(sorted_pokemons): output = [] for i, pokemons in enumerate(sorted_pokemons): for pokemon in pokemons: output.append(f\\"{pokemon[0]} {pokemon[1]}\\") if i < len(sorted_pokemons) - 1: output.append(\\"\\") # Blank line between test cases return \\"n\\".join(output) def main(): import sys input = sys.stdin.read data = input().split(\\"n\\") t = int(data[0]) index = 1 test_cases = [] for _ in range(t): n = int(data[index]) pokemons = [] for j in range(index + 1, index + 1 + n): p, r = data[j].rsplit(\\" \\", 1) pokemons.append((p, int(r))) test_cases.append((n, pokemons)) index += n + 1 sorted_pokemons = sort_pokemon(t, test_cases) output = format_output(sorted_pokemons) print(output) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List, Tuple def find_minimum_toll_cost(N: int, M: int, Q: int, roads: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determine the lowest possible toll cost to travel from intersection S to intersection T for Q different queries. Args: - N (int): The number of intersections. - M (int): The number of roads. - Q (int): The number of queries. - roads (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, w indicating a road between intersections u and v with a toll cost of w. - queries (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers S and T representing a query to find the minimum toll cost from intersection S to intersection T. Returns: - List[int]: A list of integers where each integer is the minimum toll cost corresponding to each query. If it is not possible to travel from S to T, returns -1 for that query. Example: >>> N = 5 >>> M = 6 >>> Q = 3 >>> roads = [(1, 2, 4), (1, 3, 2), (2, 3, 1), (2, 4, 7), (3, 4, 3), (4, 5, 1)] >>> queries = [(1, 4), (3, 5), (1, 5)] >>> find_minimum_toll_cost(N, M, Q, roads, queries) [5, 4, 6] >>> N = 5 >>> M = 3 >>> Q = 2 >>> roads = [(1, 2, 4), (1, 3, 2), (4, 5, 1)] >>> queries = [(1, 4), (4, 5)] >>> find_minimum_toll_cost(N, M, Q, roads, queries) [-1, 1] >>> N = 4 >>> M = 4 >>> Q = 1 >>> roads = [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 3)] >>> queries = [(1, 3)] >>> find_minimum_toll_cost(N, M, Q, roads, queries) [2] >>> N = 3 >>> M = 3 >>> Q = 1 >>> roads = [(1, 2, 1000), (2, 3, 1000), (1, 3, 2000)] >>> queries = [(1, 3)] >>> find_minimum_toll_cost(N, M, Q, roads, queries) [2000]","solution":"import heapq def find_minimum_toll_cost(N, M, Q, roads, queries): # Create the graph graph = [[] for _ in range(N+1)] for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) def dijkstra(start): min_toll = [float('inf')] * (N + 1) min_toll[start] = 0 pq = [(0, start)] # (toll, node) while pq: current_toll, current_node = heapq.heappop(pq) if current_toll > min_toll[current_node]: continue for neighbor, toll_cost in graph[current_node]: new_toll = current_toll + toll_cost if new_toll < min_toll[neighbor]: min_toll[neighbor] = new_toll heapq.heappush(pq, (new_toll, neighbor)) return min_toll result = [] for S, T in queries: min_toll_from_S = dijkstra(S) result.append(min_toll_from_S[T] if min_toll_from_S[T] != float('inf') else -1) return result"},{"question":"def is_monotonic(arr: List[int]) -> bool: Determines whether the array is monotonic or not. A monotonic array is entirely non-increasing or entirely non-decreasing. >>> is_monotonic([1, 2, 2, 3, 4]) True >>> is_monotonic([5, 4, 3, 2, 1]) True >>> is_monotonic([1, 3, 2, 4, 5]) False >>> is_monotonic([4, 4, 4, 4, 4]) True >>> is_monotonic([-1, -2, -3, -4, -5]) True >>> is_monotonic([-5, -4, -3, -2, -1]) True >>> is_monotonic([-1, -2, -1, -3, -4]) False","solution":"def is_monotonic(arr): Determines whether the array is monotonic or not. A monotonic array is entirely non-increasing or entirely non-decreasing. increasing = decreasing = True for i in range(1, len(arr)): if arr[i] < arr[i-1]: increasing = False if arr[i] > arr[i-1]: decreasing = False return increasing or decreasing # Read input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:n+1])) print(\\"YES\\" if is_monotonic(arr) else \\"NO\\")"},{"question":"def generate_flower_bed(n: int) -> List[List[int]]: Generate a flower bed with pyramid-shaped layers composed of numbers. Args: n (int): The number of layers in the flower bed Returns: List[List[int]]: The flower bed represented as a list of layers Examples: >>> generate_flower_bed(1) [[1]] >>> generate_flower_bed(2) [[1], [1, 2, 1]] >>> generate_flower_bed(3) [[1], [1, 2, 1], [1, 2, 3, 2, 1]] # Your code here def print_flower_bed(n: int) -> None: Print the flower bed for a given number of layers with proper formatting. Args: n (int): The number of layers in the flower bed Examples: >>> print_flower_bed(2) 1 1 2 1 >>> print_flower_bed(3) 1 1 2 1 1 2 3 2 1 # Your code here","solution":"def generate_flower_bed(n): flower_bed = [] for i in range(1, n + 1): layer = [] for j in range(1, i + 1): layer.append(j) for j in range(i - 1, 0, -1): layer.append(j) flower_bed.append(layer) return flower_bed def print_flower_bed(n): flower_bed = generate_flower_bed(n) max_layer_width = 2 * n - 1 for i in range(n): layer_str = ' '.join(map(str, flower_bed[i])) padding_length = (max_layer_width - len(flower_bed[i])) // 2 print(' ' * (2 * padding_length) + layer_str)"},{"question":"from typing import List, Tuple def process_queries(n: int, q: int, A: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Processes the given queries on array A. Args: n : int - the length of array A q : int - the number of queries A : list of int - the initial elements of the array queries : list of tuples - the queries (each tuple starts with either 1 or 2) Returns: List of int - the results of the sum queries pass # Unit tests def test_case_1(): n = 5 q = 4 A = [1, 2, 3, 4, 5] queries = [ (2, 1, 3), (1, 3, 10), (2, 2, 5), (2, 1, 5) ] assert process_queries(n, q, A, queries) == [6, 21, 22] def test_case_2(): n = 6 q = 5 A = [10, 20, 30, 40, 50, 60] queries = [ (2, 1, 6), (1, 2, 15), (2, 1, 2), (2, 2, 6), (1, 6, 100) ] assert process_queries(n, q, A, queries) == [210, 25, 195] def test_case_3(): n = 3 q = 2 A = [5, 5, 5] queries = [ (2, 1, 3), (1, 2, 1) ] assert process_queries(n, q, A, queries) == [15] def test_case_4(): n = 4 q = 3 A = [1, 1, 1, 1] queries = [ (1, 2, 2), (2, 1, 4), (1, 1, 3) ] assert process_queries(n, q, A, queries) == [5]","solution":"def process_queries(n, q, A, queries): Processes the given queries on array A. Args: n : int - the length of array A q : int - the number of queries A : list of int - the initial elements of the array queries : list of tuples - the queries (each tuple starts with either 1 or 2) Returns: List of int - the results of the sum queries result = [] for query in queries: if query[0] == 1: i, x = query[1] - 1, query[2] # Convert to 0-based index A[i] = x elif query[0] == 2: l, r = query[1] - 1, query[2] - 1 # Convert to 0-based index result.append(sum(A[l:r+1])) return result"},{"question":"from typing import List, Tuple def subtree_sums(N: int, node_values: List[int], edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: For a given tree with N nodes rooted at 1, and node values, computes the sum of values of all nodes in the subtree of a given node u for each query. Args: - N: int - the number of nodes in the tree. - node_values: List[int] - the values assigned to the nodes of the tree. - edges: List[Tuple[int, int]] - the edges of the tree represented by pairs of nodes. - queries: List[int] - the list of queries representing the node whose subtree sum is to be computed. Returns: - List[int] - a list containing the sum of values of the nodes in the subtree for each query. Example: >>> subtree_sums(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)], [1, 2, 3]) [15, 11, 3] >>> subtree_sums(1, [42], [], [1]) [42]","solution":"from collections import defaultdict def subtree_sums(N, node_values, edges, queries): def dfs(node): subtree_sum[node] = node_values[node - 1] for neighbor in tree[node]: if neighbor != parent[node]: parent[neighbor] = node dfs(neighbor) subtree_sum[node] += subtree_sum[neighbor] tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) parent = {1: None} subtree_sum = {} dfs(1) result = [] for query in queries: result.append(subtree_sum[query]) return result # Input reading example def read_input(): import sys input = sys.stdin.read data = input().split() index = 0 N = int(data[index]) index += 1 node_values = list(map(int, data[index:index+N])) index += N edges = [] for _ in range(N - 1): u = int(data[index]) v = int(data[index + 1]) edges.append((u, v)) index += 2 Q = int(data[index]) index += 1 queries = [] for _ in range(Q): queries.append(int(data[index])) index += 1 return N, node_values, edges, queries # Example usage if __name__ == \\"__main__\\": N, node_values, edges, queries = read_input() results = subtree_sums(N, node_values, edges, queries) for res in results: print(res)"},{"question":"def sieve_of_eratosthenes(n): Uses the Sieve of Eratosthenes to find all prime numbers up to a given number n. Returns a list indicating prime status for each number from 0 to n. pass def count_primes_up_to_n(n): Given a number n, returns the count of prime numbers up to and including n. pass def prime_count_per_test_case(test_cases): Given a list of test cases, returns a list with the count of prime numbers up to and including the given number for each test case. pass def test_sieve_of_eratosthenes(): result = sieve_of_eratosthenes(10) expected = [False, False, True, True, False, True, False, True, False, False, False] assert result == expected def test_count_primes_up_to_n(): assert count_primes_up_to_n(10) == 4 assert count_primes_up_to_n(20) == 8 assert count_primes_up_to_n(30) == 10 def test_prime_count_per_test_case(): assert prime_count_per_test_case([10, 20, 30]) == [4, 8, 10] assert prime_count_per_test_case([5, 15, 25]) == [3, 6, 9] assert prime_count_per_test_case([2, 3, 5]) == [1, 2, 3] def test_edge_cases(): assert prime_count_per_test_case([1, 2, 3]) == [0, 1, 2] assert prime_count_per_test_case([0, 1]) == [0, 0]","solution":"def sieve_of_eratosthenes(n): Uses the Sieve of Eratosthenes to find all prime numbers up to a given number n. Returns a list indicating prime status for each number from 0 to n. is_prime = [True] * (n + 1) is_prime[0], is_prime[1] = False, False p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return is_prime def count_primes_up_to_n(n): Given a number n, returns the count of prime numbers up to and including n. is_prime = sieve_of_eratosthenes(n) return sum(is_prime) def prime_count_per_test_case(test_cases): Given a list of test cases, returns a list with the count of prime numbers up to and including the given number for each test case. max_n = max(test_cases) is_prime = sieve_of_eratosthenes(max_n) prefix_sums = [0] * (max_n + 1) for i in range(1, max_n + 1): prefix_sums[i] = prefix_sums[i - 1] + (1 if is_prime[i] else 0) return [prefix_sums[n] for n in test_cases] # Sample execution T = 3 test_cases = [10, 20, 30] print(prime_count_per_test_case(test_cases))"},{"question":"def has_pair_with_sum(arr, n, k): Determines if there exists a pair of elements in the array whose sum is equal to the given target sum k. Args: arr: List of integers n: Integer, number of elements in the array k: Integer, target sum Returns: \\"YES\\" if a pair exists, otherwise \\"NO\\" >>> has_pair_with_sum([1, 4, 45, 6, 10], 5, 16) \\"YES\\" >>> has_pair_with_sum([1, 2, 4, 3], 4, 8) \\"NO\\" >>> has_pair_with_sum([1], 1, 2) \\"NO\\" >>> has_pair_with_sum([5, -2, -1, 10], 4, 20) \\"NO\\" >>> has_pair_with_sum([-1, 3, 4, 6], 4, 5) \\"YES\\" >>> has_pair_with_sum([1000000000, 999999999, -1000000000, 2], 4, 1000000001) \\"YES\\"","solution":"def has_pair_with_sum(arr, n, k): Determines if there exists a pair of elements in the array whose sum is equal to the given target sum k. Args: arr: List of integers n: Integer, number of elements in the array k: Integer, target sum Returns: \\"YES\\" if a pair exists, otherwise \\"NO\\" seen = set() for num in arr: if k - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def clean_message(message: str) -> str: Cleans up the message by removing any leading or trailing whitespace and reducing any sequence of multiple spaces within the message to a single space. >>> clean_message(\\" Hello, this is a sample message! \\") == \\"Hello, this is a sample message!\\" >>> clean_message(\\"No excessive spaces here\\") == \\"No excessive spaces here\\" >>> clean_message(\\" Leading and trailing spaces \\") == \\"Leading and trailing spaces\\" >>> clean_message(\\" Multiple spaces between words \\") == \\"Multiple spaces between words\\" >>> clean_message(\\"\\") == \\"\\" >>> clean_message(\\" singleWord \\") == \\"singleWord\\" >>> clean_message(\\" This is a test message. \\") == \\"This is a test message.\\"","solution":"def clean_message(message): Cleans up the message by removing any leading or trailing whitespace and reducing any sequence of multiple spaces within the message to a single space. return ' '.join(message.split())"},{"question":"def count_palindromes(strings): Counts the number of palindromic strings in the given list of strings. >>> count_palindromes([\\"madam\\", \\"level\\", \\"deified\\"]) == 3 >>> count_palindromes([\\"hello\\", \\"world\\", \\"python\\"]) == 0 >>> count_palindromes([\\"Racecar\\", \\"Programming\\", \\"Madam\\"]) == 2 >>> count_palindromes([\\"\\"]) == 1 >>> count_palindromes([\\"a\\", \\"B\\", \\"c\\"]) == 3 >>> count_palindromes([\\"Level\\", \\"deed\\", \\"hello\\", \\"noon\\", \\"World\\"]) == 3 >>> count_palindromes([\\"Racecar\\", \\"Programming\\", \\"Madam\\"]) == 2","solution":"def count_palindromes(strings): Counts the number of palindromic strings in the given list of strings. def is_palindrome(s): return s.lower() == s.lower()[::-1] count = 0 for s in strings: if is_palindrome(s): count += 1 return count"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> str: Finds the longest common subsequence (LCS) between two strings. >>> longest_common_subsequence(\\"ABCBDAB\\", \\"BDCAB\\") \\"BCAB\\" >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") \\"GTAB\\" pass","solution":"def longest_common_subsequence(str1: str, str2: str) -> str: Finds the longest common subsequence (LCS) between two strings. m, n = len(str1), len(str2) # Creating the DP table with (m+1) x (n+1) dimensions dp = [[0] * (n + 1) for _ in range(m + 1)] # Populating the DP table for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Backtracking to find the LCS i, j = m, n lcs = [] while i > 0 and j > 0: if str1[i - 1] == str2[j - 1]: lcs.append(str1[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] >= dp[i][j - 1]: i -= 1 else: j -= 1 # The lcs list is built backwards, so reverse it lcs.reverse() return ''.join(lcs)"},{"question":"def count_teams(n: int, k: int) -> int: Calculate the number of unique teams that can be formed from n employees with a team size of k. The result should be returned modulo 10^9+7. Arguments: n: Total number of employees. k: Required team size. Returns: The number of unique teams modulo 10^9+7. >>> count_teams(5, 3) 10 >>> count_teams(6, 2) 15 >>> count_teams(10, 4) 210 >>> count_teams(1, 1) 1 >>> count_teams(1000, 500) 159835829","solution":"def count_teams(n, k): MOD = 10**9 + 7 # Function to compute factorial % MOD def factorial(x): result = 1 for i in range(2, x + 1): result = (result * i) % MOD return result # Function to compute modular multiplicative inverse % MOD def mod_inverse(x): return pow(x, MOD - 2, MOD) # Compute nCk % MOD def binomial_coefficient(n, k): if k > n: return 0 return (factorial(n) * mod_inverse(factorial(k)) % MOD * mod_inverse(factorial(n - k))) % MOD return binomial_coefficient(n, k) def process_input(num_cases, cases): results = [] for n, k in cases: results.append(count_teams(n, k)) return results"},{"question":"def pack_boxes_into_crates(M: int, N: int, boxes: List[Tuple[int, int]], crates: List[Tuple[int, int]]) -> int: Determines how many boxes can be packed into crates. Parameters: - M: int, number of boxes - N: int, number of crates - boxes: list of tuples (width, height), dimensions of the boxes - crates: list of tuples (width, height), dimensions of the crates Return: - int, number of boxes that can be packed into crates >>> pack_boxes_into_crates(4, 3, [(4, 5), (6, 8), (7, 3), (5, 5)], [(8, 6), (5, 6), (4, 4)]) 2 >>> pack_boxes_into_crates(5, 5, [(3, 3), (6, 4), (5, 2), (3, 7), (8, 1)], [(5, 5), (3, 3), (6, 5), (4, 2), (7, 2)]) 3 >>> pack_boxes_into_crates(3, 3, [(5, 4), (6, 5), (7, 8)], [(3, 3), (4, 4), (3, 3)]) 0 >>> pack_boxes_into_crates(3, 3, [(4, 4), (5, 5), (6, 6)], [(6, 6), (6, 6), (6, 6)]) 3 >>> pack_boxes_into_crates(4, 5, [(1, 1), (2, 2), (3, 3), (4, 4)], [(1, 1), (2, 2), (3, 3), (1, 1), (2, 2)]) 3 >>> pack_boxes_into_crates(10, 10, [(i, i + 1) for i in range(10)], [(i + 1, i + 2) for i in range(10)]) 10 >>> pack_boxes_into_crates(6, 6, [(2, 2) for _ in range(6)], [(2, 2) for _ in range(6)]) 6","solution":"def pack_boxes_into_crates(M, N, boxes, crates): Determines how many boxes can be packed into crates. Parameters: - M: int, number of boxes - N: int, number of crates - boxes: list of tuples (width, height), dimensions of the boxes - crates: list of tuples (width, height), dimensions of the crates Return: - int, number of boxes that can be packed into crates packed_count = 0 for box in boxes: for crate in crates: if box[0] <= crate[0] and box[1] <= crate[1]: packed_count += 1 crates.remove(crate) # this crate is now used break return packed_count"},{"question":"def number_of_islands(n: int, m: int, matrix: List[List[int]]) -> int: Determine the number of distinct islands in the matrix. An island is defined as a group of 1s connected horizontally or vertically. Boundary cells are considered part of the edge of the matrix. Args: n (int): Number of rows in the matrix. m (int): Number of columns in the matrix. matrix (List[List[int]]): The matrix of integers (0s and 1s). Returns: int: The number of distinct islands in the matrix. Examples: >>> number_of_islands(4, 5, [ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 1, 0], ... [0, 0, 0, 1, 1], ... [0, 1, 0, 0, 0] ... ]) 3 >>> number_of_islands(3, 4, [ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) 0 >>> number_of_islands(3, 3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 1 Test cases: >>> matrix = [ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 1, 0], ... [0, 0, 0, 1, 1], ... [0, 1, 0, 0, 0] ... ] >>> number_of_islands(4, 5, matrix) 3 >>> matrix = [ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ] >>> number_of_islands(3, 4, matrix) 0 >>> matrix = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> number_of_islands(3, 3, matrix) 1 >>> matrix = [ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ] >>> number_of_islands(3, 3, matrix) 5 >>> matrix = [ ... [1, 0, 1, 0, 1], ... [1, 0, 1, 1, 0] ... ] >>> number_of_islands(2, 5, matrix) 3 >>> matrix = [[1]] >>> number_of_islands(1, 1, matrix) 1 >>> matrix = [[0]] >>> number_of_islands(1, 1, matrix) 0","solution":"def number_of_islands(n, m, matrix): def dfs(row, col): if row < 0 or row >= n or col < 0 or col >= m or matrix[row][col] != 1: return matrix[row][col] = -1 # Mark cell as visited # Explore all 4 possible directions (up, down, left, right) dfs(row - 1, col) dfs(row + 1, col) dfs(row, col - 1) dfs(row, col + 1) count_islands = 0 for i in range(n): for j in range(m): if matrix[i][j] == 1: count_islands += 1 dfs(i, j) return count_islands"},{"question":"def min_cost_path(cost): Returns the minimum cost required to travel from the top-left to the bottom-right of the matrix. Parameters: cost (List[List[int]]) : 2D list where each element represents the cost to step on that cell Returns: int: minimum cost to reach bottom-right cell from top-left cell >>> min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path([[1, 2], [1, 1]]) 3 >>> min_cost_path([[5]]) 5 >>> min_cost_path([[1, 3, 5, 2]]) 11 >>> min_cost_path([[1], [3], [5], [2]]) 11 >>> min_cost_path([[1] * 1000 for _ in range(1000)]) 1999","solution":"def min_cost_path(cost): Returns the minimum cost required to travel from the top-left to the bottom-right of the matrix. n = len(cost) m = len(cost[0]) for i in range(1, m): cost[0][i] += cost[0][i-1] for i in range(1, n): cost[i][0] += cost[i-1][0] for i in range(1, n): for j in range(1, m): cost[i][j] += min(cost[i-1][j], cost[i][j-1]) return cost[n-1][m-1]"},{"question":"def generate_flower_grid(n: int, m: int, k: int, t: int) -> List[List[int]]: Generates an n by m grid filled with flower types such that no two consecutive cells contain the same type of flower. Args: n : int : number of rows m : int : number of columns k : int : number of flower types t : int : rotation period Returns: List[List[int]] : The initial n by m grid >>> generate_flower_grid(4, 3, 3, 1) [[1, 2, 3], [2, 3, 1], [3, 1, 2], [1, 2, 3]] >>> generate_flower_grid(3, 3, 4, 2) [[1, 2, 3], [2, 3, 4], [3, 4, 1]] >>> generate_flower_grid(1, 1, 2, 1) [[1]] >>> generate_flower_grid(2, 2, 2, 1) [[1, 2], [2, 1]] >>> generate_flower_grid(5, 2, 3, 1) [[1, 2], [2, 3], [3, 1], [1, 2], [2, 3]] # Add your implementation here","solution":"def generate_flower_grid(n, m, k, t): Generates an n by m grid filled with flower types such that no two consecutive cells contain the same type of flower. Args: n : int : number of rows m : int : number of columns k : int : number of flower types t : int : rotation period Returns: List[List[int]] : The initial n by m grid grid = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): # Calculate the flower type such that no adjacent flowers are the same grid[i][j] = ((i + j) % k) + 1 return grid"},{"question":"def count_crops_clusters(m: int, n: int, grid: List[str]) -> int: Returns the number of isolated crop clusters in the m x n grid. >>> count_crops_clusters(4, 5, [\\"CCBCC\\", \\"BCCCC\\", \\"CBBCC\\", \\"CCBCC\\"]) 2 >>> count_crops_clusters(3, 3, [\\"CCC\\", \\"CCC\\", \\"CCC\\"]) 1 >>> count_crops_clusters(3, 3, [\\"BCB\\", \\"CCC\\", \\"BCB\\"]) 1","solution":"def count_crops_clusters(m, n, grid): Returns the number of isolated crop clusters in the m x n grid. def dfs(x, y): # Stack approach for DFS to avoid recursion depth issues in large grids stack = [(x, y)] visited.add((x, y)) while stack: i, j = stack.pop() for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 'C' and (ni, nj) not in visited: visited.add((ni, nj)) stack.append((ni, nj)) visited = set() clusters_count = 0 for i in range(m): for j in range(n): if grid[i][j] == 'C' and (i, j) not in visited: dfs(i, j) clusters_count += 1 return clusters_count"},{"question":"from typing import List, Tuple def check_anagrams(test_cases: List[Tuple[int, List[str]]]) -> List[str]: Determine if any two distinct words from the list are anagrams of each other. Args: test_cases (List[Tuple[int, List[str]]]): The list of test cases. Returns: List[str]: List containing \\"YES\\" or \\"NO\\" for each test case. pass def parse_input(input_str: str) -> List[Tuple[int, List[str]]]: Parse the input string to extract the number of test cases and the list of words. Args: input_str (str): The input string. Returns: List[Tuple[int, List[str]]]: Parsed test cases. pass # Unit Test def test_check_anagrams(): input_str = \\"2n4nlistennsilentnenlistngooglen3ncatndogntacn\\" test_cases = parse_input(input_str) results = check_anagrams(test_cases) assert results == [\\"YES\\", \\"YES\\"] def test_single_word(): input_str = \\"1n1nabcn\\" test_cases = parse_input(input_str) results = check_anagrams(test_cases) assert results == [\\"NO\\"] def test_no_anagrams(): input_str = \\"1n3nabcndefnghin\\" test_cases = parse_input(input_str) results = check_anagrams(test_cases) assert results == [\\"NO\\"] def test_all_anagrams(): input_str = \\"1n3nabcnbcancabn\\" test_cases = parse_input(input_str) results = check_anagrams(test_cases) assert results == [\\"YES\\"] def test_mixed_case(): input_str = \\"1n3nabcnbcanxyzn\\" test_cases = parse_input(input_str) results = check_anagrams(test_cases) assert results == [\\"YES\\"]","solution":"def check_anagrams(test_cases): results = [] for test_case in test_cases: N, words = test_case sorted_words = [''.join(sorted(word)) for word in words] if len(sorted_words) != len(set(sorted_words)): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def parse_input(input_str): lines = input_str.split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) words = lines[index + 1:index + N + 1] test_cases.append((N, words)) index += N + 1 return test_cases"},{"question":"def find_winner(participants): Determines the winner of the marathon based on the completion times. Args: participants (list of tuples): A list where each tuple contains a participant number and their completion time. Returns: tuple: The participant number and their completion time of the winner. pass from solution import find_winner def test_single_participant(): assert find_winner([(1, 100)]) == (1, 100) def test_two_participants_different_times(): assert find_winner([(1, 100), (2, 90)]) == (2, 90) def test_two_participants_same_time(): assert find_winner([(1, 100), (2, 100)]) == (1, 100) def test_multiple_participants_different_times(): participants = [(3, 142), (1, 145), (4, 142), (2, 150), (5, 147)] assert find_winner(participants) == (3, 142) def test_multiple_participants_with_same_time(): participants = [(2, 120), (1, 110), (4, 130), (5, 110), (3, 120)] assert find_winner(participants) == (1, 110) def test_all_same_times(): participants = [(1, 150), (2, 150), (3, 150)] assert find_winner(participants) == (1, 150)","solution":"def find_winner(participants): Determines the winner of the marathon based on the completion times. Args: participants (list of tuples): A list where each tuple contains a participant number and their completion time. Returns: tuple: The participant number and their completion time of the winner. # Sort participants based on time, then by participant number in case of tie sorted_participants = sorted(participants, key=lambda x: (x[1], x[0])) # The first element in the sorted list is the winner winner = sorted_participants[0] return winner"},{"question":"def find_pair_with_sum(arr, target): Determine if there are two distinct integers in the array whose sum equals the target value. If such a pair exists, return the result as a string \\"YES\\" followed by the pair. If no such pair exists, return the result as \\"NO\\". >>> find_pair_with_sum([2, 7, 11, 15, 1], 9) == \\"YES 2 7\\" >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) == \\"NO\\" >>> find_pair_with_sum([1, 2, 3, 4, 5], 8) == \\"YES 3 5\\" >>> find_pair_with_sum([-1, -2, -3, -4, -5], -8) == \\"YES -3 -5\\" >>> find_pair_with_sum([1, 1, 1, 1, 1], 2) == \\"YES 1 1\\" >>> find_pair_with_sum([0, 0, 0, 0, 0], 0) == \\"YES 0 0\\" >>> find_pair_with_sum([10**9, -(10**9)], 0) == \\"YES 1000000000 -1000000000\\" >>> find_pair_with_sum([1, 4, 5, 3, 6], 7) == \\"YES 4 3\\"","solution":"def find_pair_with_sum(arr, target): Determine if there are two distinct integers in the array whose sum equals the target value. If such a pair exists, return the result as a string \\"YES\\" followed by the pair. If no such pair exists, return the result as \\"NO\\". seen = {} for number in arr: complement = target - number if complement in seen: return f\\"YES {complement} {number}\\" seen[number] = True return \\"NO\\""},{"question":"def construct_array(N: int) -> List[int]: Construct an array A of length N such that: 1. For all i (1 ≤ i ≤ N), A[i] = 1 or A[i] = -1. 2. The sum of the prefix sums of A is as small as possible. >>> construct_array(3) [1, -1, 1] >>> construct_array(4) [1, -1, 1, -1] A = [] for i in range(N): if i % 2 == 0: A.append(1) else: A.append(-1) return A","solution":"def construct_array(N): Construct an array A of length N such that: 1. For all i (1 ≤ i ≤ N), A[i] = 1 or A[i] = -1. 2. The sum of the prefix sums of A is as small as possible. A = [] for i in range(N): if i % 2 == 0: A.append(1) else: A.append(-1) return A"},{"question":"def find_positions(arr, start, end): Finds the position of the leftmost minimum element and the position of the rightmost maximum element in the given range. :param arr: List of integers. :param start: Start index of the range. :param end: End index of the range. :return: Tuple containing the positions of the leftmost minimum element and the rightmost maximum element. >>> find_positions([2, 3, 1, 4, 1, 5], 1, 4) (2, 3) >>> find_positions([9, 6, 4, 2, 0, 1, 2, 3], 0, 4) (4, 0) >>> find_positions([5], 0, 0) (0, 0) >>> find_positions([7, 7, 7, 7, 7], 1, 4) (1, 4) >>> find_positions([10, 20, 30, 40, 50], 1, 3) (1, 3)","solution":"def find_positions(arr, start, end): Finds the position of the leftmost minimum element and the position of the rightmost maximum element in the given range. :param arr: List of integers. :param start: Start index of the range. :param end: End index of the range. :return: Tuple containing the positions of the leftmost minimum element and the rightmost maximum element. leftmost_min_pos = start rightmost_max_pos = start min_val = arr[start] max_val = arr[start] for i in range(start, end + 1): if arr[i] < min_val: min_val = arr[i] leftmost_min_pos = i if arr[i] >= max_val: max_val = arr[i] rightmost_max_pos = i return (leftmost_min_pos, rightmost_max_pos)"},{"question":"def find_smallest_range(A: List[int], queries: List[int]) -> List[Union[int, Tuple[int, int]]]: Given an array A of size n, answer q queries. Each query consists of an integer x. Return the smallest range [l, r] where sum of elements is exactly x. If no such range exists, return -1. >>> find_smallest_range([1, -1, 2, 3, -1], [5, 4, 1]) [(1, 4), (2, 5), (2, 2)] >>> find_smallest_range([3, 2], [2]) [(2, 2)] >>> find_smallest_range([1, 2, 3], [7]) [-1] >>> find_smallest_range([1, 2, 3, 4, 5], [6]) [(1, 3)] >>> find_smallest_range([-1, -2, -3, -4, -5], [-10]) [(1, 4)]","solution":"def find_smallest_range(A, queries): results = [] for x in queries: found = False for l in range(len(A)): for r in range(l, len(A)): if sum(A[l:r+1]) == x: results.append((l + 1, r + 1)) found = True break if found: break if not found: results.append(-1) return results"},{"question":"def find_sudoku_solution(grid_lines: List[str]) -> str: Solve a given Sudoku puzzle and return the completed grid in the same format. The input consists of 9 lines, each containing 9 characters which represent the Sudoku grid. Empty cells are denoted by '.', and filled cells contain digits from '1' to '9'. The provided grid will have a unique solution. :param grid_lines: List of strings representing the Sudoku grid :return: Completed Sudoku grid as a string >>> input_grid = [ ... \\"5 3 . . 7 . . . .\\", ... \\"6 . . 1 9 5 . . .\\", ... \\". 9 8 . . . . 6 .\\", ... \\"8 . . . 6 . . . 3\\", ... \\"4 . . 8 . 3 . . 1\\", ... \\"7 . . . 2 . . . 6\\", ... \\". 6 . . . . 2 8 .\\", ... \\". . . 4 1 9 . . 5\\", ... \\". . . . 8 . . 7 9\\", ... ] >>> expected_output = ( ... \\"5 3 4 6 7 8 9 1 2n\\" ... \\"6 7 2 1 9 5 3 4 8n\\" ... \\"1 9 8 3 4 2 5 6 7n\\" ... \\"8 5 9 7 6 1 4 2 3n\\" ... \\"4 2 6 8 5 3 7 9 1n\\" ... \\"7 1 3 9 2 4 8 5 6n\\" ... \\"9 6 1 5 3 7 2 8 4n\\" ... \\"2 8 7 4 1 9 6 3 5n\\" ... \\"3 4 5 2 8 6 1 7 9\\" ... ) >>> assert find_sudoku_solution(input_grid) == expected_output","solution":"def solve_sudoku(board): Solves the given Sudoku board in place. :param board: list of list of str :return: None def is_valid(board, r, c, num): # Check the row for i in range(9): if board[r][i] == num: return False # Check the column for i in range(9): if board[i][c] == num: return False # Check the 3x3 box box_row_start = (r // 3) * 3 box_col_start = (c // 3) * 3 for i in range(3): for j in range(3): if board[box_row_start + i][box_col_start + j] == num: return False return True def solve(board): for r in range(9): for c in range(9): if board[r][c] == '.': for num in map(str, range(1, 10)): if is_valid(board, r, c, num): board[r][c] = num if solve(board): return True board[r][c] = '.' return False return True solve(board) return board def parse_input(grid_lines): return [line.split() for line in grid_lines] def format_output(board): return \\"n\\".join(\\" \\".join(row) for row in board) def find_sudoku_solution(grid_lines): board = parse_input(grid_lines) solve_sudoku(board) return format_output(board)"},{"question":"def max_profit(prices): Function to determine the maximum profit by buying and selling a stock on specific days. :param prices: List[int] - A list of stock prices :return: int - The maximum profit possible >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2]) 1 >>> max_profit([2, 1]) 0","solution":"def max_profit(prices): Function to determine the maximum profit by buying and selling a stock on specific days. :param prices: List[int] - A list of stock prices :return: int - The maximum profit possible if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def validate_trades(T: int, test_cases: List[Dict[str, Union[int, List[int], List[Tuple[int, int, int, int]]]]]) -> List[str]: Determine if a series of trades in a trading card game is valid. Args: T : int : Number of test cases test_cases : List : A list of dictionaries, each containing: 'n' : int : Number of different card types 'm' : int : Number of trades 'initial_cards' : List[int] : Initial count of cards of each type 'trades' : List[Tuple[int, int, int, int]] : List of trades represented as tuples Returns: List[str] : \\"Valid\\" if the trades in a test case are valid, otherwise \\"Invalid\\" Example: >>> T = 2 >>> test_cases = [ ... { ... 'n': 3, ... 'm': 3, ... 'initial_cards': [5, 10, 5], ... 'trades': [ ... (1, 2, 4, 3), ... (3, 1, 2, 2), ... (2, 3, 1, 1) ... ] ... }, ... { ... 'n': 2, ... 'm': 2, ... 'initial_cards': [3, 5], ... 'trades': [ ... (1, 2, 4, 6), ... (2, 1, 3, 5) ... ] ... } ... ] >>> validate_trades(T, test_cases) [\\"Valid\\", \\"Invalid\\"] results = [] # Implement the logic to check the validity of trades return results","solution":"def validate_trades(T, test_cases): results = [] for case in test_cases: n = case['n'] m = case['m'] initial_cards = case['initial_cards'] trades = case['trades'] # Create a copy of the initial_cards to track changes cards = initial_cards[:] valid = True for trade in trades: a, b, c, d = trade # Perform the trade: give c cards of type a, receive d cards of type b if cards[a - 1] < c: valid = False break cards[a - 1] -= c cards[b - 1] += d results.append(\\"Valid\\" if valid else \\"Invalid\\") return results # Example usage: # T = 2 # test_cases = [ # { # 'n': 3, # 'm': 3, # 'initial_cards': [5, 10, 5], # 'trades': [ # (1, 2, 4, 3), # (3, 1, 2, 2), # (2, 3, 1, 1) # ] # }, # { # 'n': 2, # 'm': 2, # 'initial_cards': [3, 5], # 'trades': [ # (1, 2, 4, 6), # (2, 1, 3, 5) # ] # } # ] # print(validate_trades(T, test_cases))"},{"question":"def min_operations_to_equal_elements(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of operations required to make all elements of \`a\` equal. >>> min_operations_to_equal_elements(3, [(3, [1, 2, 3]), (4, [4, 4, 4, 4]), (2, [1, 1])]) [2, 0, 0] >>> min_operations_to_equal_elements(1, [(3, [5, 5, 5])]) [0] >>> min_operations_to_equal_elements(2, [(3, [1, 1, 2]), (2, [10, 20])]) [1, 1]","solution":"def min_operations_to_equal_elements(t, test_cases): results = [] for n, a in test_cases: unique_elements = set(a) results.append(len(unique_elements) - 1) return results # Example usage: # t = 3 # test_cases = [ # (3, [1, 2, 3]), # (4, [4, 4, 4, 4]), # (2, [1, 1]) # ] # print(min_operations_to_equal_elements(t, test_cases))"},{"question":"def non_overlapping_flower_beds(n, beds): Determines the maximum number of non-overlapping flower beds that can be placed in the garden. Args: n (int): Number of flower beds. beds (list of tuples): Each tuple contains four integers representing the coordinates of the bottom-left and top-right corners of a flower bed. Returns: int: The maximum number of non-overlapping flower beds. Examples: >>> non_overlapping_flower_beds(3, [(1, 1, 3, 3), (2, 2, 4, 4), (5, 5, 6, 6)]) 2 >>> non_overlapping_flower_beds(4, [(0, 0, 2, 2), (1, 1, 3, 3), (3, 3, 5, 5), (2, 2, 4, 4)]) 2 from solution import non_overlapping_flower_beds def test_example_1(): n = 3 beds = [ (1, 1, 3, 3), (2, 2, 4, 4), (5, 5, 6, 6) ] assert non_overlapping_flower_beds(n, beds) == 2 def test_example_2(): n = 4 beds = [ (0, 0, 2, 2), (1, 1, 3, 3), (3, 3, 5, 5), (2, 2, 4, 4) ] assert non_overlapping_flower_beds(n, beds) == 2 def test_example_3(): n = 1 beds = [ (0, 0, 1, 1) ] assert non_overlapping_flower_beds(n, beds) == 1 def test_large_intervals(): n = 2 beds = [ (0, 0, 10**9 - 1, 10**9), (10**9 - 5, 0, 10**9, 10**9) ] assert non_overlapping_flower_beds(n, beds) == 1 def test_all_overlapping(): n = 3 beds = [ (1, 1, 4, 4), (2, 2, 5, 5), (3, 3, 6, 6) ] assert non_overlapping_flower_beds(n, beds) == 1 def test_no_overlapping(): n = 5 beds = [ (1, 1, 2, 2), (3, 3, 4, 4), (5, 5, 6, 6), (7, 7, 8, 8), (9, 9, 10, 10) ] assert non_overlapping_flower_beds(n, beds) == 5","solution":"def non_overlapping_flower_beds(n, beds): # Sort beds by their right side (x2) beds.sort(key=lambda x: x[2]) # Initialize variables count = 0 last_end = -1 # Iterate over the sorted beds for bed in beds: x1, y1, x2, y2 = bed if x1 >= last_end: # If the current bed does not overlap with the last selected bed count += 1 last_end = x2 return count"},{"question":"def is_valid_paragraph(paragraph: str) -> bool: Determines if the given string is a valid paragraph. A valid paragraph satisfies the following: 1. It starts with a capital letter. 2. It ends with a proper punctuation mark (either a period, a question mark, or an exclamation point). 3. It has at least one other sentence. Each sentence within the paragraph (excluding the first) must: - Start with a capital letter. - End with a proper punctuation mark. Args: paragraph (str): The paragraph string to be validated. Returns: bool: True if the paragraph is valid, False otherwise. def test_valid_single_sentence(): assert is_valid_paragraph(\\"Hello.\\") == False def test_valid_multiple_sentences(): assert is_valid_paragraph(\\"Hello. This is a test.\\") == True assert is_valid_paragraph(\\"Is this valid? Yes, it is!\\") == True assert is_valid_paragraph(\\"Testing. Another sentence! And one more?\\") == True def test_invalid_without_end_punctuation(): assert is_valid_paragraph(\\"This is invalid\\") == False assert is_valid_paragraph(\\"An incomplete sentence\\") == False def test_invalid_first_not_capitalized(): assert is_valid_paragraph(\\"hello. This is not valid.\\") == False def test_invalid_subsequent_not_capitalized(): assert is_valid_paragraph(\\"Hello. this is not valid.\\") == False def test_invalid_last_has_no_punctuation(): assert is_valid_paragraph(\\"Hello. This is valid until this\\") == False def test_invalid_no_spacing_between_sentences(): assert is_valid_paragraph(\\"Hello.This is not valid.\\") == False","solution":"import re def is_valid_paragraph(paragraph): Determines if the given string is a valid paragraph. A valid paragraph satisfies the following: 1. It starts with a capital letter. 2. It ends with a proper punctuation mark (either a period, a question mark, or an exclamation point). 3. It has at least one other sentence. Each sentence within the paragraph (excluding the first) must: - Start with a capital letter. - End with a proper punctuation mark. Args: paragraph (str): The paragraph string to be validated. Returns: bool: True if the paragraph is valid, False otherwise. sentences = re.split(r'(?<=[.!?])s+', paragraph) if len(sentences) < 2: return False for i, sentence in enumerate(sentences): if not sentence: return False if i == 0: # First sentence if not sentence[0].isupper() or not sentence.endswith(('.', '?', '!')): return False else: if not sentence[0].isupper() or not sentence.endswith(('.', '?', '!')): return False return True"},{"question":"def longest_subsequence(n: int, k: int, arr: List[int]) -> int: Returns the length of the longest subsequence where the difference between consecutive elements is exactly k. Parameters: n (int): Length of the list. k (int): Fixed integer difference. arr (list): List of integers. Returns: int: Length of the longest subsequence. Examples: >>> longest_subsequence(6, 2, [1, 3, 5, 7, 9, 11]) 6 >>> longest_subsequence(5, 2, [1, 6, 11, 16, 21]) 1 >>> longest_subsequence(7, 3, [10, 7, 4, 1, 13, 16, 19]) 4 >>> longest_subsequence(10, 1, [1, 2, 2, 3, 3, 4, 1, 2, 3, 4]) 4 >>> longest_subsequence(1, 2, [10]) 1 >>> longest_subsequence(0, 5, []) 0","solution":"def longest_subsequence(n, k, arr): Returns the length of the longest subsequence where the difference between consecutive elements is exactly k. Parameters: n (int): Length of the list. k (int): Fixed integer difference. arr (list): List of integers. Returns: int: Length of the longest subsequence. if n == 0: return 0 dp = {} max_length = 1 for num in arr: previous_num = num - k if previous_num in dp: dp[num] = dp[previous_num] + 1 else: dp[num] = 1 if dp[num] > max_length: max_length = dp[num] return max_length # Example usage # n = 6 # k = 2 # arr = [1, 3, 5, 7, 9, 11] # print(longest_subsequence(n, k, arr)) # Output should be 6"},{"question":"class DisjointSetUnion: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n self.count = n # Initially, each location is in its own component def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def disconnect(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX == rootY: self.count += 1 self.parent[y] = y self.rank[rootY] -= 1 def process_events(n, events): Process a series of transportation events and return the number of disconnected groups after each event. >>> n = 5 >>> events = [\\"+ 1 2\\", \\"+ 2 3\\", \\"+ 4 5\\", \\"- 1 2\\", \\"+ 3 4\\", \\"- 2 3\\"] >>> process_events(n, events) [4, 3, 2, 3, 2, 2] import pytest def test_example_case(): n = 5 events = [ \\"+ 1 2\\", \\"+ 2 3\\", \\"+ 4 5\\", \\"- 1 2\\", \\"+ 3 4\\", \\"- 2 3\\" ] expected_output = [4, 3, 2, 3, 2, 2] assert process_events(n, events) == expected_output def test_all_single_components(): n = 3 events = [\\"+ 1 2\\", \\"+ 2 3\\"] expected_output = [2, 1] assert process_events(n, events) == expected_output def test_no_change(): n = 3 events = [\\"+ 1 2\\", \\"- 1 2\\"] expected_output = [2, 3] assert process_events(n, events) == expected_output def test_reverse_operations(): n = 3 events = [\\"+ 1 2\\", \\"- 1 2\\", \\"+ 1 3\\", \\"- 1 3\\"] expected_output = [2, 3, 2, 3] assert process_events(n, events) == expected_output def test_complex_connectivity(): n = 4 events = [\\"+ 1 2\\", \\"+ 1 3\\", \\"+ 1 4\\", \\"- 1 3\\", \\"+ 2 3\\", \\"- 1 2\\"] expected_output = [3, 2, 1, 2, 1, 2] assert process_events(n, events) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"class DisjointSetUnion: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n self.count = n # Initially, each location is in its own component def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def disconnect(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX == rootY: self.count += 1 self.parent[y] = y self.rank[rootY] -= 1 def process_events(n, events): dsu = DisjointSetUnion(n) results = [] added = {} for event in events: parts = event.split() if parts[0] == '+': u, v = int(parts[1]) - 1, int(parts[2]) - 1 # Adjusting index for 0-based if (u, v) not in added: dsu.union(u, v) added[(u, v)] = True added[(v, u)] = True elif parts[0] == '-': u, v = int(parts[1]) - 1, int(parts[2]) - 1 if (u, v) in added: dsu.disconnect(u, v) del added[(u, v)] del added[(v, u)] results.append(dsu.count) return results"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def subarray_with_prime_sum(arr: List[int]) -> str: Check if there exists a subarray with a sum that is a prime number. >>> subarray_with_prime_sum([1, 2, 3, 4, 5]) \\"YES\\" >>> subarray_with_prime_sum([4, 6, 8, 10]) \\"NO\\" >>> subarray_with_prime_sum([7, 1, 12]) \\"YES\\"","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def subarray_with_prime_sum(arr): n = len(arr) for i in range(n): current_sum = 0 for j in range(i, n): current_sum += arr[j] if is_prime(current_sum): return \\"YES\\" return \\"NO\\" # Example usage: # array_b = [1, 2, 3, 4, 5] # result = subarray_with_prime_sum(array_b) # Outputs \\"YES\\""},{"question":"def caesar_cipher(T, test_cases): Encodes each message using the provided shift value in the Caesar Cipher technique. :param T: Integer, number of test cases :param test_cases: List of tuples containing shift value and message :return: List of encoded messages >>> caesar_cipher(3, [(3, \\"hello\\"), (-2, \\"world\\"), (1, \\"zebra\\")]) ['khoor', 'umpjb', 'afcsb'] >>> caesar_cipher(2, [(0, \\"abc\\"), (0, \\"xyz\\")]) ['abc', 'xyz'] >>> caesar_cipher(2, [(-1, \\"abc\\"), (-3, \\"def\\")]) ['zab', 'abc'] >>> caesar_cipher(2, [(1, \\"xyz\\"), (3, \\"uvw\\")]) ['yza', 'xyz'] >>> caesar_cipher(2, [(1, \\"hello\\"), (-1, \\"world\\")]) ['ifmmp', 'vnqkc']","solution":"def caesar_cipher(T, test_cases): Encodes each message using the provided shift value in the Caesar Cipher technique. :param T: Integer, number of test cases :param test_cases: List of tuples containing shift value and message :return: List of encoded messages encoded_messages = [] for S, M in test_cases: encoded_message = \\"\\" for char in M: new_char = chr((ord(char) - ord('a') + S) % 26 + ord('a')) encoded_message += new_char encoded_messages.append(encoded_message) return encoded_messages"},{"question":"def remove_duplicates(lst): Removes duplicates from the list while preserving the order of their first appearance. >>> remove_duplicates([4, 5, 6, 5, 4, 7, 8, 8, 4, 5, 9]) == [4, 5, 6, 7, 8, 9] >>> remove_duplicates([1, 2, 2, 3, 4, 4, 4, 5]) == [1, 2, 3, 4, 5] >>> remove_duplicates([-1, -2, -3, -3, -2, -1]) == [-1, -2, -3] >>> remove_duplicates([5, 5, 5, 5, 5, 5]) == [5] >>> remove_duplicates([]) == [] def process_input(input_string): Converts input string to list of integers, processes it to remove duplicates, and returns the result as a space-separated string of integers. >>> process_input('4 5 6 5 4 7 8 8 4 5 9') == '4 5 6 7 8 9' >>> process_input('1 2 2 3 4 4 4 5') == '1 2 3 4 5' >>> process_input('-1 -2 -3 -3 -2 -1') == '-1 -2 -3' >>> process_input('5 5 5 5 5 5') == '5' >>> process_input('') == ''","solution":"def remove_duplicates(lst): Removes duplicates from the list while preserving the order of their first appearance. seen = set() result = [] for number in lst: if number not in seen: seen.add(number) result.append(number) return result def process_input(input_string): Converts input string to list of integers, processes it to remove duplicates, and returns the result as a space-separated string of integers. lst = list(map(int, input_string.split())) unique_lst = remove_duplicates(lst) return ' '.join(map(str, unique_lst))"},{"question":"def longest_consecutive_sequence(nums): Returns the length of the longest sequence of consecutive integers and the sequence itself. Args: nums (list of int): The input list of integers. Returns: tuple: A tuple containing the length of the longest sequence and the sequence itself. >>> longest_consecutive_sequence([4, 2, 1, 6, 5]) (3, [4, 5, 6]) >>> longest_consecutive_sequence([1, 9, 3, 10, 4, 20, 2]) (4, [1, 2, 3, 4]) >>> longest_consecutive_sequence([]) (0, []) >>> longest_consecutive_sequence([1]) (1, [1]) >>> longest_consecutive_sequence([1, 3, 5, 7]) (1, [1]) >>> longest_consecutive_sequence([1, 2, 3, 10, 20]) (3, [1, 2, 3]) >>> longest_consecutive_sequence([10, 11, 12, 1, 2, 3]) (3, [1, 2, 3]) >>> longest_consecutive_sequence([1, 2, 3, 4, 5]) (5, [1, 2, 3, 4, 5])","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest sequence of consecutive integers and the sequence itself. Args: nums (list of int): The input list of integers. Returns: tuple: A tuple containing the length of the longest sequence and the sequence itself. if not nums: return (0, []) num_set = set(nums) longest_streak = 0 best_start = None for num in nums: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 if current_streak > longest_streak or (current_streak == longest_streak and (best_start is None or num < best_start)): longest_streak = current_streak best_start = num best_sequence = list(range(best_start, best_start + longest_streak)) return (longest_streak, best_sequence)"},{"question":"def is_path_exists(grid: List[str]) -> str: Determine if there is a path from the start cell 'S' to the goal cell 'G' in a maze represented by a 2D grid. >>> is_path_exists([ ... \\"S...\\", ... \\".#..\\", ... \\"..G.\\" ... ]) 'Path Exists' >>> is_path_exists([ ... \\"S....\\", ... \\".\\", ... \\"....#\\", ... \\".\\", ... \\"....G\\" ... ]) 'No Path' >>> is_path_exists([ ... \\"S...G\\" ... ]) 'Path Exists' >>> is_path_exists([ ... \\"S\\", ... \\".\\", ... \\".\\", ... \\"G\\" ... ]) 'Path Exists' >>> is_path_exists([ ... \\"...\\", ... \\"...\\", ... \\"..G\\" ... ]) 'No Path' >>> is_path_exists([ ... \\"S..\\", ... \\"...\\", ... \\"...\\" ... ]) 'No Path' pass def solve(mazes: List[List[str]]) -> List[str]: Determine if there is a path from 'S' to 'G' for multiple mazes. Args: mazes: List of mazes, each represented as a list of strings. Returns: List of results where each result is either \\"Path Exists\\" or \\"No Path\\". >>> solve([ ... [\\"S...\\", \\".#..\\", \\"..G.\\"], ... [\\"S....\\", \\".\\", \\"....#\\", \\".\\", \\"....G\\"] ... ]) ['Path Exists', 'No Path'] pass import pytest def test_is_path_exists_case1(): grid = [ \\"S...\\", \\".#..\\", \\"..G.\\" ] assert is_path_exists(grid) == \\"Path Exists\\" def test_is_path_exists_case2(): grid = [ \\"S....\\", \\".\\", \\"....#\\", \\".\\", \\"....G\\" ] assert is_path_exists(grid) == \\"No Path\\" def test_is_path_exists_case3_single_row(): grid = [ \\"S...G\\" ] assert is_path_exists(grid) == \\"Path Exists\\" def test_is_path_exists_case4_single_column(): grid = [ \\"S\\", \\".\\", \\".\\", \\"G\\" ] assert is_path_exists(grid) == \\"Path Exists\\" def test_is_path_exists_case5_no_start(): grid = [ \\"...\\", \\"...\\", \\"..G\\" ] assert is_path_exists(grid) == \\"No Path\\" def test_is_path_exists_case6_no_goal(): grid = [ \\"S..\\", \\"...\\", \\"...\\" ] assert is_path_exists(grid) == \\"No Path\\" def test_solve(): mazes = [ [\\"S...\\", \\".#..\\", \\"..G.\\"], [\\"S....\\", \\".\\", \\"....#\\", \\".\\", \\"....G\\"] ] assert solve(mazes) == [\\"Path Exists\\", \\"No Path\\"] if __name__ == \\"__main__\\": pytest.main()","solution":"def is_path_exists(grid): rows = len(grid) cols = len(grid[0]) # Helper function for BFS from collections import deque def bfs(start_r, start_c): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start_r, start_c)]) visited = set((start_r, start_c)) while queue: r, c = queue.popleft() if grid[r][c] == 'G': return True for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited: if grid[nr][nc] != '#': queue.append((nr, nc)) visited.add((nr, nc)) return False start_r, start_c = None, None for r in range(rows): for c in range(cols): if grid[r][c] == 'S': start_r, start_c = r, c break if start_r is not None: break if start_r is None: return \\"No Path\\" return \\"Path Exists\\" if bfs(start_r, start_c) else \\"No Path\\" def solve(mazes): results = [] for maze in mazes: results.append(is_path_exists(maze)) return results"},{"question":"from typing import List, Tuple, Union def auto_complete(log: List[Tuple[str, int]], prefix: str) -> Union[str, List]: Suggest the most frequently used words or phrases that start with the given prefix. >>> log = [(\\"hello\\", 10), (\\"hi\\", 5), (\\"how are you\\", 3), (\\"howdy\\", 7), (\\"house\\", 8)] >>> auto_complete(log, \\"ho\\") [(\\"house\\", 8), (\\"howdy\\", 7), (\\"how are you\\", 3)] >>> log = [(\\"apple\\", 15), (\\"application\\", 10), (\\"apply\\", 5), (\\"banana\\", 12)] >>> auto_complete(log, \\"app\\") [(\\"apple\\", 15), (\\"application\\", 10), (\\"apply\\", 5)] >>> log = [(\\"world\\", 4), (\\"word\\", 5), (\\"ward\\", 2)] >>> auto_complete(log, \\"wo\\") [(\\"word\\", 5), (\\"world\\", 4)] >>> log = [(\\"machine learning\\", 20), (\\"deep learning\\", 25)] >>> auto_complete(log, \\"ai\\") \\"No suggestions\\" def prepare_log(lines: List[str]) -> List[Tuple[str, int]]: Prepare the log from input lines. >>> lines = [\\"apple 15\\", \\"application 10\\", \\"apply 5\\", \\"banana 12\\"] >>> prepare_log(lines) [(\\"apple\\", 15), (\\"application\\", 10), (\\"apply\\", 5), (\\"banana\\", 12)]","solution":"def auto_complete(log, prefix): suggestions = [entry for entry in log if entry[0].startswith(prefix)] # Sort by frequency (descending), using lexicographical order for ties suggestions.sort(key=lambda x: (-x[1], x[0])) if not suggestions: return [\\"No suggestions\\"] return suggestions[:3] def prepare_log(lines): log = [] for line in lines: s, f = line.rsplit(' ', 1) log.append((s, int(f))) return log"},{"question":"def filter_and_multiply_even_numbers(lst): Takes a list of integers as input and returns a new list with only the even numbers, each multiplied by 3. :param lst: List of integers :return: New list with even numbers multiplied by 3 >>> filter_and_multiply_even_numbers([2, 4, 6]) [6, 12, 18] >>> filter_and_multiply_even_numbers([1, 3, 5]) [] >>> filter_and_multiply_even_numbers([1, 2, 3, 4]) [6, 12] >>> filter_and_multiply_even_numbers([0, 1, 2]) [0, 6] >>> filter_and_multiply_even_numbers([]) [] >>> filter_and_multiply_even_numbers([-2, -3, -4]) [-6, -12]","solution":"def filter_and_multiply_even_numbers(lst): Takes a list of integers as input and returns a new list with only the even numbers, each multiplied by 3. :param lst: List of integers :return: New list with even numbers multiplied by 3 return [x * 3 for x in lst if x % 2 == 0]"},{"question":"def generate_balanced_sequence(N: int, M: int): Generate a balanced sequence of length N with elements between 1 and M such that the sum of every two adjacent elements in the sequence is divisible by 3. If no such sequence exists, return \\"NO SEQUENCE\\". >>> generate_balanced_sequence(3, 10) [1, 2, 1] >>> generate_balanced_sequence(4, 2) NO SEQUENCE pass def balanced_sequences(T: int, cases: List[Tuple[int, int]]): For a given number of test cases, generate balanced sequences or indicate if no such sequences exist. >>> balanced_sequences(2, [(3, 10), (4, 2)]) ['1 2 1', 'NO SEQUENCE'] >>> balanced_sequences(1, [(6, 10)]) ['1 2 1 2 1 2'] pass","solution":"def generate_balanced_sequence(N, M): if M < 3: if N == 1: return [1] return \\"NO SEQUENCE\\" sequence = [] for i in range(N): if i % 2 == 0: sequence.append(1) else: sequence.append(2) return sequence def balanced_sequences(T, cases): result = [] for N, M in cases: sequence = generate_balanced_sequence(N, M) if sequence == \\"NO SEQUENCE\\": result.append(sequence) else: result.append(\\" \\".join(map(str, sequence))) return result"},{"question":"def total_views(heights): This function returns the total number of views for all people in the line, where each person can see another person to their left if the height of the second person is greater than or equal to their own height. :param heights: List of integers representing the heights of the people. :return: Total number of views. >>> total_views([4, 3, 5, 1, 2]) == 4 >>> total_views([2, 2, 2, 2]) == 6 >>> total_views([1]) == 0 >>> total_views([1, 2, 3, 4, 5]) == 0 >>> total_views([5, 4, 3, 2, 1]) == 10 >>> total_views([3, 1, 4, 2]) == 2 >>> total_views([3, 3, 3, 3]) == 6","solution":"def total_views(heights): This function returns the total number of views for all people in the line, where each person can see another person to their left if the height of the second person is greater than or equal to their own height. :param heights: List of integers representing the heights of the people. :return: Total number of views. n = len(heights) total_views = 0 for i in range(1, n): count = 0 for j in range(i-1, -1, -1): if heights[j] >= heights[i]: count += 1 else: break total_views += count return total_views"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to make a string a palindrome. >>> min_operations_to_palindrome(\\"abcd\\") == 2 >>> min_operations_to_palindrome(\\"racecar\\") == 0 >>> min_operations_to_palindrome(\\"abccbx\\") == 1 def min_operations_for_queries(q: int, queries: List[str]) -> List[int]: For each query string s, returns the minimum number of operations needed to make it a palindrome. >>> min_operations_for_queries(3, [\\"abcd\\", \\"racecar\\", \\"abccbx\\"]) == [2, 0, 1] >>> min_operations_for_queries(2, [\\"abcba\\", \\"abccba\\"]) == [0, 0]","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to make a string a palindrome. left, right = 0, len(s) - 1 operations = 0 while left < right: if s[left] != s[right]: operations += 1 left += 1 right -= 1 return operations def min_operations_for_queries(q, queries): For each query string s, returns the minimum number of operations needed to make it a palindrome. results = [] for s in queries: results.append(min_operations_to_palindrome(s)) return results"},{"question":"from typing import List class EventManager: def __init__(self): self.event_dates = set() def add_event_date(self, event_date): Insert the event date into the set of event dates. pass def query_unique_dates(self, start_date, end_date): Return the count of unique event dates within the inclusive range [start_date, end_date]. pass def process_operations(operations: List[List[str]]) -> List[int]: Process the list of operations and return the results of the Query operations. Args: operations: A list of operations where each operation is a list of strings. The first element of the list is the type of operation (\\"Add\\" or \\"Query\\"), followed by the relevant date or dates. Returns: A list of integers representing the results of the Query operations. Example: >>> operations = [ ... [\\"Add\\", \\"20230101\\"], ... [\\"Add\\", \\"20230102\\"], ... [\\"Query\\", \\"20230101\\", \\"20230103\\"], ... [\\"Add\\", \\"20230101\\"], ... [\\"Query\\", \\"20230101\\", \\"20230101\\"], ... [\\"Add\\", \\"20230301\\"], ... [\\"Query\\", \\"20230101\\", \\"20231231\\"], ... ] >>> process_operations(operations) [2, 1, 3] pass # Unit tests import pytest def test_basic_operations(): operations = [ [\\"Add\\", \\"20230101\\"], [\\"Add\\", \\"20230102\\"], [\\"Query\\", \\"20230101\\", \\"20230103\\"], [\\"Add\\", \\"20230101\\"], [\\"Query\\", \\"20230101\\", \\"20230101\\"], [\\"Add\\", \\"20230301\\"], [\\"Query\\", \\"20230101\\", \\"20231231\\"], ] expected = [2, 1, 3] assert process_operations(operations) == expected def test_add_duplicates(): operations = [ [\\"Add\\", \\"20230101\\"], [\\"Add\\", \\"20230101\\"], [\\"Query\\", \\"20230101\\", \\"20230101\\"], ] expected = [1] assert process_operations(operations) == expected def test_query_with_no_dates(): operations = [ [\\"Query\\", \\"20230101\\", \\"20230101\\"], [\\"Add\\", \\"20230102\\"], [\\"Query\\", \\"20230101\\", \\"20230101\\"], ] expected = [0, 0] assert process_operations(operations) == expected def test_query_multiple_ranges(): operations = [ [\\"Add\\", \\"20230101\\"], [\\"Add\\", \\"20230115\\"], [\\"Add\\", \\"20230201\\"], [\\"Query\\", \\"20230101\\", \\"20230131\\"], [\\"Query\\", \\"20230115\\", \\"20230201\\"], ] expected = [2, 2] assert process_operations(operations) == expected def test_large_range(): operations = [ [\\"Add\\", \\"20220101\\"], [\\"Add\\", \\"20230101\\"], [\\"Add\\", \\"20240101\\"], [\\"Query\\", \\"20220101\\", \\"20250101\\"], ] expected = [3] assert process_operations(operations) == expected if __name__ == \\"__main__\\": pytest.main()","solution":"from bisect import bisect_left, bisect_right class EventManager: def __init__(self): self.event_dates = set() def add_event_date(self, event_date): self.event_dates.add(event_date) def query_unique_dates(self, start_date, end_date): sorted_dates = sorted(self.event_dates) start_index = bisect_left(sorted_dates, start_date) end_index = bisect_right(sorted_dates, end_date) return len(sorted_dates[start_index:end_index]) def process_operations(operations): event_manager = EventManager() result = [] for operation in operations: if operation[0] == \\"Add\\": event_manager.add_event_date(int(operation[1])) elif operation[0] == \\"Query\\": result.append(event_manager.query_unique_dates(int(operation[1]), int(operation[2]))) return result"},{"question":"from typing import List, Tuple def calculate_median_resolution_times(tickets: List[Tuple[str, int]]) -> List[Tuple[str, float]]: Returns the median resolution time for each ticket type in lexicographic order. Args: tickets (List[Tuple[str, int]]): A list of tuples where each tuple contains a string representing the ticket type and an integer representing the time taken to resolve the ticket. Returns: List[Tuple[str, float]]: A list of tuples where each tuple contains a string representing the ticket type and a float representing the median resolution time for that type. Example: >>> tickets = [('billing', 30), ('technical', 40), ('billing', 20), ('technical', 60), ('general', 50)] >>> calculate_median_resolution_times(tickets) [('billing', 25.0), ('general', 50.0), ('technical', 50.0)] >>> tickets = [('refund', 20), ('refund', 50), ('refund', 10), ('inquiry', 15), ('inquiry', 35), ('technical', 40)] >>> calculate_median_resolution_times(tickets) [('inquiry', 25.0), ('refund', 20.0), ('technical', 40.0)]","solution":"import statistics def calculate_median_resolution_times(tickets): Returns the median resolution time for each ticket type. The types are listed in lexicographic order. from collections import defaultdict # Create a dictionary to store resolution times for each ticket type ticket_dict = defaultdict(list) # Process each ticket in the input for ticket in tickets: ticket_type, time = ticket ticket_dict[ticket_type].append(time) # Calculate medians and store results in a list of tuples median_times = [] for ticket_type in sorted(ticket_dict.keys()): times = ticket_dict[ticket_type] median_time = statistics.median(times) # Calculate the median median_times.append((ticket_type, median_time)) return median_times # Example usage tickets = [ ('billing', 30), ('technical', 40), ('billing', 20), ('technical', 60), ('general', 50) ] print(calculate_median_resolution_times(tickets))"},{"question":"def min_max_storage_utilization(n, storage_capacities): Determines the minimal maximum storage utilization across all non-empty subsets of warehouses. Parameters: n (int): Number of warehouses storage_capacities (list of int): Storage capacities of each warehouse Returns: int: The minimal possible value of maximum storage utilization >>> min_max_storage_utilization(3, [10, 20, 30]) 10 >>> min_max_storage_utilization(4, [5, 8, 6, 12]) 5 from solution import min_max_storage_utilization def test_single_warehouse(): assert min_max_storage_utilization(1, [7]) == 7 def test_multiple_warehouses(): assert min_max_storage_utilization(3, [10, 20, 30]) == 10 assert min_max_storage_utilization(4, [5, 8, 6, 12]) == 5 assert min_max_storage_utilization(5, [15, 10, 35, 25, 5]) == 5 def test_large_numbers(): assert min_max_storage_utilization(3, [1000000000, 999999999, 999999998]) == 999999998 assert min_max_storage_utilization(3, [10**9, 10**9 + 1, 10**9 + 2]) == 10**9 assert min_max_storage_utilization(2, [10**5, 10**6]) == 10**5 def test_descending_order(): assert min_max_storage_utilization(5, [50, 40, 30, 20, 10]) == 10","solution":"def min_max_storage_utilization(n, storage_capacities): Determines the minimal maximum storage utilization across all non-empty subsets of warehouses. Parameters: n (int): Number of warehouses storage_capacities (list of int): Storage capacities of each warehouse Returns: int: The minimal possible value of maximum storage utilization # The minimal possible value of maximum storage utilization across all subsets return min(storage_capacities)"},{"question":"def can_be_single_character_string(S: str) -> str: Determine if it is possible to transform string S into a single-character string based on the given operations. >>> can_be_single_character_string(\\"aaab\\") \\"IMPOSSIBLE\\" >>> can_be_single_character_string(\\"a\\") \\"a\\" pass def process_test_cases(Q: int, cases: List[str]) -> List[str]: Process multiple test cases to determine the result of transforming each string S into a single-character string. >>> process_test_cases(3, [\\"aaab\\", \\"abc\\", \\"a\\"]) [\\"IMPOSSIBLE\\", \\"IMPOSSIBLE\\", \\"a\\"] >>> process_test_cases(2, [\\"bbbb\\", \\"bbbaaa\\"]) [\\"b\\", \\"IMPOSSIBLE\\"] pass","solution":"def can_be_single_character_string(S): Function to determine if it is possible to transform the string S into a single-character string. for i in range(1, len(S)): # Check if there is any adjacent pair of different characters if S[i] != S[i-1]: return \\"IMPOSSIBLE\\" return S[0] # All characters are the same def process_test_cases(Q, cases): Function to process multiple test cases and return the results. results = [] for S in cases: result = can_be_single_character_string(S) results.append(result) return results # Example Input/Output function for demonstration purposes def solution(Q, cases): return process_test_cases(Q, cases)"},{"question":"def find_largest(a: int, b: int, c: int) -> int: Takes three integers as input and determines the largest among them. >>> find_largest(23, 89, 67) 89 >>> find_largest(-1, 0, 1) 1 >>> find_largest(0, 0, 0) 0","solution":"def find_largest(a, b, c): Returns the largest amongst a, b, and c. return max(a, b, c)"},{"question":"def is_robot_return_to_origin(commands: str) -> bool: Determine if the robot returns to the origin after completing the sequence of commands. :param commands: str - A string consisting of 'U', 'D', 'L', and 'R' :return: bool - True if the robot returns to the origin, otherwise False >>> is_robot_return_to_origin(\\"UD\\") == True >>> is_robot_return_to_origin(\\"LL\\") == False >>> is_robot_return_to_origin(\\"RRDD\\") == False >>> is_robot_return_to_origin(\\"LDRRLRUULR\\") == False >>> is_robot_return_to_origin(\\"UDLR\\") == True >>> is_robot_return_to_origin(\\"UUDDLRLR\\") == True >>> is_robot_return_to_origin(\\"\\") == True >>> is_robot_return_to_origin(\\"RRUUDDLL\\") == True >>> is_robot_return_to_origin(\\"UUUDDDRRR\\") == False","solution":"def is_robot_return_to_origin(commands: str) -> bool: Determine if the robot returns to the origin after completing the sequence of commands. :param commands: str - A string consisting of 'U', 'D', 'L', and 'R' :return: bool - True if the robot returns to the origin, otherwise False x, y = 0, 0 # start at the origin (0, 0) for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return x == 0 and y == 0"},{"question":"def canBeSorted(nums, k): Determines if the array can be sorted by reversing subarrays of size k. >>> canBeSorted([3, 1, 2, 4], 2) == True >>> canBeSorted([3, 1, 2, 4], 3) == False >>> canBeSorted([1], 1) == True >>> canBeSorted([1, 2, 3, 4], 2) == True >>> canBeSorted([4, 3, 2, 1], 4) == True >>> canBeSorted([1, 3, 2, 4, 5, 7, 6], 3) == False >>> canBeSorted([7, 9, 2, 4, 1, 3, 5, 6], 2) == True >>> canBeSorted([3, 1, 4, 2, 6, 5], 3) == False","solution":"def canBeSorted(nums, k): Determines if the array can be sorted by reversing subarrays of size k. if k == 1: # If k is 1, can't reverse anything, just need to check if already sorted return nums == sorted(nums) if k % 2 == 0: # If k is even, we can always sort the array by reversing adjacent pairs. return True # If k is odd, we need to check if the array is already sorted in segments of length k. for i in range(0, len(nums) - k + 1, k): segment = nums[i:i + k] if sorted(segment) != segment: return False return True"},{"question":"def findMajorityElement(nums): Returns the majority element which appears more than half the times in the list. If no such element exists, returns None. >>> findMajorityElement([3, 3, 4, 2, 4, 4, 2, 4, 4]) == 4 >>> findMajorityElement([1, 2, 3, 4, 5]) == None >>> findMajorityElement([1]) == 1 >>> findMajorityElement([7, 7, 7, 7, 7]) == 7 >>> findMajorityElement([1, 2, 2, 1]) == None","solution":"def findMajorityElement(nums): Returns the majority element which appears more than half the times in the list. If no such element exists, returns None. count = {} length = len(nums) for num in nums: if num in count: count[num] += 1 else: count[num] = 1 if count[num] > length // 2: return num return None"},{"question":"import re from collections import defaultdict def count_words(sentence: str) -> dict: Write a function named \`count_words\` that takes a string, \`sentence\`, as its argument and returns a dictionary with the counts of each word in the sentence. Words should be considered case-insensitively, and punctuation marks should be ignored. :param sentence: str, input sentence to count words from :return: dict, dictionary with word counts >>> count_words(\\"Hello, world! hello.\\") == {\\"hello\\": 2, \\"world\\": 1} >>> count_words(\\"Python is great. Python, PYTHON!\\") == {\\"python\\": 3, \\"is\\": 1, \\"great\\": 1}","solution":"import re from collections import defaultdict def count_words(sentence): Returns a dictionary with counts of each word in the given sentence. Words are considered case-insensitively and punctuation marks are ignored. :param sentence: str, input sentence to count words from :return: dict, dictionary with word counts # Convert to lowercase sentence = sentence.lower() # Remove punctuation and split into words words = re.findall(r'bw+b', sentence) # Create default dictionary to count words word_counts = defaultdict(int) for word in words: word_counts[word] += 1 return dict(word_counts)"},{"question":"def check_missile_hit(N: int, M: int, ships: List[Tuple[int, int]], missile: Tuple[int, int]) -> str: Determines if Player A's missile hits any of Player B's ships. Parameters: - N: Size of the grid (NxN). - M: Number of Player B's ships. - ships: A list of tuples representing the coordinates of Player B's ships. - missile: A tuple representing the coordinates where Player A fires the missile. Returns: - \\"HIT\\" if the missile hits any of Player B's ships, otherwise \\"MISS\\". >>> check_missile_hit(5, 3, [(0, 0), (1, 2), (3, 4)], (1, 2)) 'HIT' >>> check_missile_hit(5, 3, [(0, 0), (1, 2), (3, 4)], (2, 2)) 'MISS' >>> check_missile_hit(5, 1, [(4, 4)], (4, 4)) 'HIT' >>> check_missile_hit(5, 1, [(0, 0)], (4, 4)) 'MISS' >>> check_missile_hit(5, 0, [], (2, 2)) 'MISS'","solution":"def check_missile_hit(N, M, ships, missile): Determines if Player A's missile hits any of Player B's ships. Parameters: - N: Size of the grid (NxN). - M: Number of Player B's ships. - ships: A list of tuples representing the coordinates of Player B's ships. - missile: A tuple representing the coordinates where Player A fires the missile. Returns: - \\"HIT\\" if the missile hits any of Player B's ships, otherwise \\"MISS\\". ship_set = set(ships) if missile in ship_set: return \\"HIT\\" else: return \\"MISS\\""},{"question":"def filter_frauds(orders: List[Dict[str, Union[int, float]]]) -> List[Dict[str, Union[int, float]]]: Filters out fraudulent orders where the amount spent is identical to any of the previous five orders. >>> orders = [ ... {\\"order_id\\": 1, \\"amount\\": 100.0}, ... {\\"order_id\\": 2, \\"amount\\": 80.0}, ... {\\"order_id\\": 3, \\"amount\\": 100.0}, ... {\\"order_id\\": 4, \\"amount\\": 150.0}, ... {\\"order_id\\": 5, \\"amount\\": 80.0}, ... {\\"order_id\\": 6, \\"amount\\": 200.0}, ... {\\"order_id\\": 7, \\"amount\\": 150.0}, ... {\\"order_id\\": 8, \\"amount\\": 250.0}, ... ] >>> filter_frauds(orders) [ {\\"order_id\\": 1, \\"amount\\": 100.0}, {\\"order_id\\": 2, \\"amount\\": 80.0}, {\\"order_id\\": 4, \\"amount\\": 150.0}, {\\"order_id\\": 6, \\"amount\\": 200.0}, {\\"order_id\\": 8, \\"amount\\": 250.0}, ]","solution":"def filter_frauds(orders): Filters out fraudulent orders where the amount spent is identical to any of the previous five orders. valid_orders = [] last_five_amounts = [] for order in orders: if order['amount'] in last_five_amounts: continue valid_orders.append(order) last_five_amounts.append(order['amount']) if len(last_five_amounts) > 5: last_five_amounts.pop(0) return valid_orders"},{"question":"import re def isPalindrome(s: str) -> bool: Determine if a given string is a palindrome, ignoring punctuation, case, and spacing. >>> isPalindrome(\\"A man, a plan, a canal, Panama!\\") True >>> isPalindrome(\\"race a car\\") False >>> isPalindrome(\\"No 'x' in Nixon\\") True >>> isPalindrome(\\"madam\\") True >>> isPalindrome(\\"\\") True >>> isPalindrome(\\"!!!\\") True >>> isPalindrome(\\"abc\\") False","solution":"import re def isPalindrome(s): Returns True if the given string s is a palindrome, ignoring punctuation, case, and spacing. # Remove non-alphanumeric characters and convert to lowercase cleaned_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"def distribute_chocolates(T: int, cases: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Distributes chocolates among students and returns the results as a list of tuples. Parameters: T (int): number of test cases cases (list of tuples): Each tuple contains two integers N (number of students) and M (number of chocolates) Returns: list of tuples: Each tuple contains two integers: the maximum number of chocolates each student will get and the number of chocolates the school will collect Examples: >>> distribute_chocolates(3, [(5, 13), (10, 99), (4, 8)]) [(2, 3), (9, 9), (2, 0)] >>> distribute_chocolates(1, [(5, 0)]) [(0, 0)] >>> distribute_chocolates(1, [(1, 100)]) [(100, 0)]","solution":"def distribute_chocolates(T, cases): Distributes chocolates among students and returns the results as a list of tuples. Parameters: T (int): number of test cases cases (list of tuples): Each tuple contains two integers N (number of students) and M (number of chocolates) Returns: list of tuples: Each tuple contains two integers: the maximum number of chocolates each student will get and the number of chocolates the school will collect results = [] for case in cases: N, M = case chocolates_per_student = M // N leftovers = M % N results.append((chocolates_per_student, leftovers)) return results"},{"question":"def find_four_integers(t: int, values: List[int]) -> List[str]: Given a non-negative integer x, find four integers a, b, c, and d such that 0 <= a, b, c, d <= x and a+b = c+d. If no such integers exist, output -1. >>> find_four_integers(5, [0, 4, 10, 3, 100]) [\\"0 0 0 0\\", \\"1 3 2 2\\", \\"1 9 2 8\\", \\"-1\\", \\"1 99 2 98\\"] >>> find_four_integers(1, [0]) [\\"0 0 0 0\\"] >>> find_four_integers(1, [4]) [\\"1 3 2 2\\"]","solution":"def find_four_integers(t, values): results = [] for x in values: if x == 0: results.append(\\"0 0 0 0\\") elif x >= 4: a, b, c, d = 1, x - 1, 2, x - 2 results.append(f\\"{a} {b} {c} {d}\\") else: results.append(\\"-1\\") return results"},{"question":"from typing import List def lcm(a, b): Returns the least common multiple of a and b. pass def smallest_multiple(N): Returns the smallest positive integer that is evenly divisible by all the numbers from 1 to N. pass def solve(inputs): Handles multiple test cases for finding smallest multiple. pass # Unit tests def test_smallest_multiple(): assert smallest_multiple(1) == 1 assert smallest_multiple(5) == 60 assert smallest_multiple(10) == 2520 assert smallest_multiple(4) == 12 assert smallest_multiple(6) == 60 def test_solve(): inputs = [\\"3\\", \\"1\\", \\"5\\", \\"10\\"] assert solve(inputs) == [1, 60, 2520] inputs = [\\"2\\", \\"7\\", \\"3\\"] assert solve(inputs) == [420, 6] inputs = [\\"1\\", \\"20\\"] assert solve(inputs) == [232792560]","solution":"from math import gcd def lcm(a, b): Returns the least common multiple of a and b. return a * b // gcd(a, b) def smallest_multiple(N): Returns the smallest positive integer that is evenly divisible by all the numbers from 1 to N. smallest_mul = 1 for i in range(1, N + 1): smallest_mul = lcm(smallest_mul, i) return smallest_mul def solve(inputs): Handles multiple test cases for finding smallest multiple. T = int(inputs[0]) results = [] for i in range(1, T + 1): N = int(inputs[i]) results.append(smallest_multiple(N)) return results"},{"question":"def repeatString(s: str, n: int) -> str: Returns a string which is a concatenation of n copies of s. >>> repeatString(\\"abc\\", 3) \\"abcabcabc\\" >>> repeatString(\\"xyz\\", 5) \\"xyzxyzxyzxyzxyz\\" pass def test_repeatString_basic(): assert repeatString(\\"abc\\", 3) == \\"abcabcabc\\" assert repeatString(\\"xyz\\", 5) == \\"xyzxyzxyzxyzxyz\\" def test_repeatString_with_single_copy(): assert repeatString(\\"hello\\", 1) == \\"hello\\" def test_repeatString_with_empty_string(): assert repeatString(\\"\\", 3) == \\"\\" def test_repeatString_with_long_string(): long_string = \\"a\\" * 100 # 100 characters long assert repeatString(long_string, 2) == long_string * 2 def test_repeatString_with_max_n(): assert repeatString(\\"repeat\\", 100) == \\"repeat\\" * 100 def test_repeatString_with_special_characters(): assert repeatString(\\"!@#\\", 4) == \\"!@#!@#!@#!@#\\" def test_repeatString_single_char(): assert repeatString(\\"x\\", 10) == \\"x\\" * 10","solution":"def repeatString(s, n): Returns a string which is a concatenation of n copies of s. return s * n"},{"question":"def nth_prime(n: int) -> int: Calculate the nth prime number. Args: n (int): The position of the prime number to be found (1 ≤ n ≤ 10000). Returns: int: The nth prime number. Raises: ValueError: If n is less than 1. Examples: >>> nth_prime(1) 2 >>> nth_prime(6) 13 from nth_prime import nth_prime def test_nth_prime(): assert nth_prime(1) == 2 assert nth_prime(2) == 3 assert nth_prime(3) == 5 assert nth_prime(4) == 7 assert nth_prime(5) == 11 assert nth_prime(6) == 13 def test_nth_prime_large(): assert nth_prime(100) == 541 assert nth_prime(1000) == 7919 def test_invalid_n(): import pytest with pytest.raises(ValueError): nth_prime(0) with pytest.raises(ValueError): nth_prime(-1)","solution":"def nth_prime(n): Returns the nth prime number. if n < 1: raise ValueError(\\"n must be a positive integer greater than or equal to 1.\\") primes = [] num = 2 while len(primes) < n: for p in primes: if num % p == 0: break else: primes.append(num) num += 1 return primes[-1]"},{"question":"def minimized_maximum_distance(N: int, D: int) -> int: Given the total distance to be hiked and the number of days the hike will take place, determine the minimized maximum distance for any single day of the hike. :param N: Total distance to be hiked. :param D: Number of days the hike will occur. :return: Minimized maximum distance for any single day. >>> minimized_maximum_distance(100, 5) 20 >>> minimized_maximum_distance(123, 5) 25 >>> minimized_maximum_distance(10, 3) 4 >>> minimized_maximum_distance(1, 1) 1 >>> minimized_maximum_distance(10**6, 10**5) 10 >>> minimized_maximum_distance(999, 1000) 1 >>> minimized_maximum_distance(1000, 1) 1000 >>> minimized_maximum_distance(9, 3) 3","solution":"def minimized_maximum_distance(N, D): Returns the minimized maximum distance for any single day of the hike. :param N: Total distance to be hiked. :param D: Number of days the hike will occur. :return: Minimized maximum distance for any single day. return (N + D - 1) // D"},{"question":"def check_quasi_symmetric(string_input: str) -> str: Determine if a given n x n matrix is quasi-symmetric. For every pair of indices (i, j), the sum of matrix elements satisfies the following condition: A[i][j] + A[j][i] = A[n-1-i][n-1-j] + A[n-1-j][n-1-i] Input The first line contains the integer n. Each of the next n lines contains n integers, representing the matrix elements. Output Print \\"YES\\" if the matrix is quasi-symmetric, otherwise print \\"NO\\". Example >>> check_quasi_symmetric(\\"3n1 2 3n4 5 6n7 8 9\\") \\"NO\\" >>> check_quasi_symmetric(\\"2n1 2n2 1\\") \\"YES\\" # Implementation here","solution":"def is_quasi_symmetric(matrix): n = len(matrix) for i in range(n): for j in range(n): if matrix[i][j] + matrix[j][i] != matrix[n-1-i][n-1-j] + matrix[n-1-j][n-1-i]: return False return True def check_quasi_symmetric(string_input): lines = string_input.strip().split('n') n = int(lines[0]) matrix = [list(map(int, line.split())) for line in lines[1:n+1]] return \\"YES\\" if is_quasi_symmetric(matrix) else \\"NO\\""},{"question":"from typing import List def max_possible_weight(n: int, m: int, grid: List[List[int]], W: int) -> int: Returns the maximum possible total weight of products that can be moved without exceeding the target weight W. >>> max_possible_weight(2, 3, [[1, 2, 3], [4, 5, 6]], 10) 10 >>> max_possible_weight(3, 3, [[10, 20, 30], [40, 50, 60], [70, 80, 90]], 100) 100 >>> max_possible_weight(2, 2, [[5, 5], [5, 5]], 15) 15 >>> max_possible_weight(1, 1, [[1]], 1) 1 >>> max_possible_weight(1, 1, [[10000]], 10000) 10000 >>> max_possible_weight(2, 2, [[10, 20], [30, 40]], 15) 10","solution":"def max_possible_weight(n, m, grid, W): Returns the maximum possible total weight of products that can be moved without exceeding the target weight W. from itertools import combinations # Flatten the grid to treat it as a list of item weights weights = [grid[i][j] for i in range(n) for j in range(m)] max_weight = 0 # Generate all possible subsets of weights for r in range(1, len(weights) + 1): for subset in combinations(weights, r): subset_weight = sum(subset) if subset_weight <= W and subset_weight > max_weight: max_weight = subset_weight return max_weight"},{"question":"def earliest_time_to_reach_bottom_right(n: int, m: int, grid: List[List[Tuple[int, int]]]) -> int: Determine the earliest time a car can travel from the top-left intersection to the bottom-right intersection given the traffic light configurations. Args: n (int): number of rows m (int): number of columns grid (List[List[Tuple[int, int]]]): traffic light configurations for each intersection Returns: int: the earliest time to reach the bottom-right intersection >>> n = 3 >>> m = 3 >>> grid = [ ... [(0, 1), (1, 1), (0, 1)], ... [(1, 1), (0, 1), (1, 1)], ... [(0, 1), (1, 1), (0, 1)] ... ] >>> earliest_time_to_reach_bottom_right(n, m, grid) 4 >>> n = 4 >>> m = 4 >>> grid = [ ... [(0, 1), (1, 1), (0, 1), (1, 1)], ... [(1, 1), (0, 1), (1, 1), (0, 1)], ... [(0, 1), (1, 1), (0, 1), (1, 1)], ... [(1, 1), (0, 1), (1, 1), (0, 1)] ... ] >>> earliest_time_to_reach_bottom_right(n, m, grid) 6","solution":"from collections import deque def earliest_time_to_reach_bottom_right(n, m, grid): def is_green(light_state, duration, t): phase = t % duration return (phase < duration // 2) if light_state == 0 else (phase >= duration // 2) directions = [(0, 1), (1, 0)] # move right or down queue = deque([(0, 0, 0)]) # (row, column, time) visited = set((0, 0)) while queue: r, c, t = queue.popleft() if r == n - 1 and c == m - 1: return t for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m: if (nr, nc) in visited: continue h_i, v_i = grid[nr][nc] if dr == 0 and is_green(h_i, 2, t + 1): # moving right: check horizontal light visited.add((nr, nc)) queue.append((nr, nc, t + 1)) elif dr == 1 and is_green(v_i, 2, t + 1): # moving down: check vertical light visited.add((nr, nc)) queue.append((nr, nc, t + 1)) return -1 # should not reach here # Example usage n = 3 m = 3 grid = [ [(0, 1), (1, 1), (0, 1)], [(1, 1), (0, 1), (1, 1)], [(0, 1), (1, 1), (0, 1)] ] print(earliest_time_to_reach_bottom_right(n, m, grid)) # Output: 4"},{"question":"def sieve_of_eratosthenes(limit): Sieve of Eratosthenes algorithm to find all prime numbers up to a specified integer limit. Parameters: limit (int): The upper limit up to which to look for prime numbers. Returns: List[bool]: A boolean array where a value at index i is True if i is a prime number, otherwise False. pass def count_ones_in_range(L, R, prime): Count the number of '1's in the binary string segment from day L to day R. Parameters: L (int): The starting day of the range. R (int): The ending day of the range. prime (List[bool]): A boolean array where a value at index i is True if i is a prime number. Returns: int: The count of '1's in the specified range. pass def process_queries(T, queries): Process multiple queries to find the number of '1's in the binary string segment for each query. Parameters: T (int): The number of queries. queries (List[Tuple[int, int]]): A list of tuples where each tuple consists of two integers representing the range of days. Returns: List[int]: A list of results for each query. pass # Example unit tests def test_sieve_of_eratosthenes(): prime = sieve_of_eratosthenes(10) assert prime == [False, False, True, True, False, True, False, True, False, False, False] def test_count_ones_in_range(): prime = sieve_of_eratosthenes(20) assert count_ones_in_range(1, 10, prime) == 4 assert count_ones_in_range(11, 20, prime) == 4 assert count_ones_in_range(1, 20, prime) == 8 def test_process_queries(): queries = [(1, 10), (11, 20), (1, 20)] results = process_queries(3, queries) assert results == [4, 4, 8]","solution":"def sieve_of_eratosthenes(limit): prime = [True] * (limit + 1) p = 2 while (p * p <= limit): if (prime[p] == True): for i in range(p * p, limit + 1, p): prime[i] = False p += 1 prime[0], prime[1] = False, False return prime def count_ones_in_range(L, R, prime): return sum(prime[L:R+1]) def process_queries(T, queries): max_R = max(r for _, r in queries) prime = sieve_of_eratosthenes(max_R) results = [] for L, R in queries: results.append(count_ones_in_range(L, R, prime)) return results"},{"question":"def max_profit(transaction_count: int, transactions: List[int]) -> int: Returns the maximum possible profit for the day based on the given transactions. >>> max_profit(5, [-3, 5, -2, 4, -1]) == 7 >>> max_profit(4, [-1, -2, -3, -4]) == 0 >>> max_profit(3, [6, -1, 5]) == 10 pass # Test cases def test_example_1(): assert max_profit(5, [-3, 5, -2, 4, -1]) == 7 def test_example_2(): assert max_profit(4, [-1, -2, -3, -4]) == 0 def test_example_3(): assert max_profit(3, [6, -1, 5]) == 10 def test_all_positive_transactions(): assert max_profit(3, [1, 2, 3]) == 6 assert max_profit(5, [2, 4, 6, 8, 10]) == 30 def test_all_negative_transactions(): assert max_profit(3, [-1, -2, -3]) == 0 assert max_profit(4, [-4, -3, -2, -1]) == 0 def test_mixed_transactions(): assert max_profit(6, [1, 2, -1, 3, -2, 4]) == 7 assert max_profit(7, [5, -1, -1, 4, -2, 2, 1]) == 8 def test_single_transaction(): assert max_profit(1, [5]) == 5 assert max_profit(1, [-5]) == 0","solution":"def max_profit(transaction_count, transactions): Returns the maximum possible profit for the day based on the given transactions. :param transaction_count: int, number of transactions in a day :param transactions: list of int, the transaction amounts :return: int, the maximum possible profit max_profit = 0 current_profit = 0 for transaction in transactions: current_profit += transaction if current_profit < 0: current_profit = 0 if current_profit > max_profit: max_profit = current_profit return max_profit"},{"question":"def find_subarray_sum(n, q, sequence, queries): Given a sequence of integers and a number of queries, finds the sum of a sub-array for each query efficiently. Parameters: n (int): The length of the sequence q (int): The number of queries sequence (list of int): The sequence of integers queries (list of tuples): Each tuple contains two integers representing the start and end of the sub-array (inclusive) Returns: list of int: The sum of the sub-array for each query Examples: >>> find_subarray_sum(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> find_subarray_sum(6, 2, [3, 8, 7, 6, 1, 2], [(1, 6), (3, 5)]) [27, 14] >>> find_subarray_sum(4, 1, [5, 6, 7, 8], [(2, 4)]) [21]","solution":"def find_subarray_sum(n, q, sequence, queries): Given a sequence of integers and a number of queries, finds the sum of a sub-array for each query efficiently. Parameters: n (int): The length of the sequence q (int): The number of queries sequence (list of int): The sequence of integers queries (list of tuples): Each tuple contains two integers representing the start and end of the sub-array (inclusive) Returns: list of int: The sum of the sub-array for each query # Create a prefix sum array prefix_sum = [0] * (n + 1) for i in range(1, n + 1): prefix_sum[i] = prefix_sum[i - 1] + sequence[i - 1] result = [] for query in queries: l, r = query # sum from l to r is prefix_sum[r] - prefix_sum[l-1] result.append(prefix_sum[r] - prefix_sum[l - 1]) return result"},{"question":"def sports_event_winner(input_data: str) -> str: Determine the winner of a sports event based on participants' scores in multiple events. Parameters: input_data (str): A string representing the number of participants and events, followed by each participant's scores for each event. Returns: str: A string representing the winner's participant number and their total score. >>> sports_event_winner(\\"4 3n1 30 40 20n2 25 50 30n3 20 60 25n4 25 50 35\\") \\"2 105\\" >>> sports_event_winner(\\"1 3n1 10 20 30\\") \\"1 60\\" >>> sports_event_winner(\\"2 3n1 30 40 30n2 60 20 20\\") \\"1 100\\" >>> sports_event_winner(\\"4 3n1 25 25 50n2 30 30 40n3 20 35 45n4 50 25 25\\") \\"1 100\\" >>> sports_event_winner(\\"3 3n1 100 100 100n2 0 0 0n3 50 50 50\\") \\"1 300\\"","solution":"def find_winner(participants_scores): Finds the winner based on the highest total score. In case of a tie, the participant with the lower number wins. :param participants_scores: List of tuples where each tuple contains participant number and their scores in all events. :return: Tuple containing the winner's participant number and their total score. max_score = -1 winner_info = (None, -1) for participant_info in participants_scores: participant_number = participant_info[0] scores = participant_info[1:] total_score = sum(scores) if total_score > max_score or (total_score == max_score and participant_number < winner_info[0]): max_score = total_score winner_info = (participant_number, total_score) return winner_info def sports_event_winner(input_data): lines = input_data.strip().split('n') n, m = map(int, lines[0].split()) participants_scores = [] for line in lines[1:]: data = list(map(int, line.split())) participants_scores.append(tuple(data)) winner_info = find_winner(participants_scores) return f\\"{winner_info[0]} {winner_info[1]}\\""},{"question":"from typing import List, Union def arrange_books(number_of_books: int, book_series: List[str]) -> Union[str, int]: Determines if it is possible to arrange books such that no two books from the same series are adjacent. If possible, returns one possible valid arrangement, otherwise returns -1. >>> arrange_books(3, [\\"HarryPotter\\", \\"HarryPotter\\", \\"HarryPotter\\"]) -1 >>> arrange_books(1, [\\"HarryPotter\\"]) 'HarryPotter' >>> arrange_books(5, [\\"HarryPotter\\", \\"LOTR\\", \\"HarryPotter\\", \\"LOTR\\", \\"Hobbit\\"]) in [ 'HarryPotter LOTR HarryPotter Hobbit LOTR', 'HarryPotter LOTR Hobbit HarryPotter LOTR', 'HarryPotter Hobbit LOTR HarryPotter LOTR' ] True >>> arrange_books(4, [\\"A\\", \\"A\\", \\"B\\", \\"B\\"]) in [ 'A B A B', 'B A B A' ] True","solution":"from collections import Counter import heapq def arrange_books(number_of_books, book_series): Determines if it is possible to arrange books such that no two books from the same series are adjacent. If possible, returns one possible valid arrangement, otherwise returns -1. if number_of_books == 1: return \\" \\".join(book_series) series_count = Counter(book_series) max_heap = [(-count, series) for series, count in series_count.items()] heapq.heapify(max_heap) prev_count, prev_series = 0, \\"\\" result = [] while max_heap: count, series = heapq.heappop(max_heap) result.append(series) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_series)) count += 1 prev_count, prev_series = count, series if len(result) != number_of_books: return -1 return \\" \\".join(result)"},{"question":"def min_moves_to_equalize_water(water): Returns the minimum number of moves to equalize water in all sections or -1 if not possible. Examples: >>> min_moves_to_equalize_water([1, 0, 5]) 3 >>> min_moves_to_equalize_water([2, 2, 2, 4]) -1 >>> min_moves_to_equalize_water([4, 1, 1, 2]) 2 >>> min_moves_to_equalize_water([10]) 0 >>> min_moves_to_equalize_water([3, 3, 3]) 0 >>> min_moves_to_equalize_water([10000, 0, 0, 0]) 7500 >>> min_moves_to_equalize_water([3, 3, 3, 1]) -1","solution":"def min_moves_to_equalize_water(water): Returns the minimum number of moves to equalize water in all sections or -1 if not possible. n = len(water) total_water = sum(water) if total_water % n != 0: return -1 target = total_water // n # Calculate the deficit/surplus at each index moves = 0 deficit_sum = 0 for w in water: deficit_sum += w - target moves = max(moves, abs(deficit_sum)) return moves"},{"question":"def game_winner(n, array): Determines the winner of the game given the number of elements and the array. :param n: int - the number of elements in the array :param array: list of int - the elements of the array :return: str - \\"JACK\\" if Jack wins, \\"JILL\\" if Jill wins >>> game_winner(5, [1, 2, 3, 4, 5]) \\"JILL\\" >>> game_winner(4, [1, 3, 7, 9]) \\"JACK\\" >>> game_winner(1, [10]) \\"JILL\\" >>> game_winner(6, [2, 4, 5, 6, 8, 10]) \\"JACK\\" >>> game_winner(7, [1, 2, 3, 4, 5, 6, 7]) \\"JILL\\" >>> game_winner(100000, list(range(1, 100001))) \\"JACK\\" >>> game_winner(99999, list(range(1, 100000))) \\"JILL\\"","solution":"def game_winner(n, array): Determines the winner of the game given the number of elements and the array. :param n: int - the number of elements in the array :param array: list of int - the elements of the array :return: str - \\"JACK\\" if Jack wins, \\"JILL\\" if Jill wins return \\"JILL\\" if n % 2 == 1 else \\"JACK\\""},{"question":"def preprocess_array(arr): Preprocess the given array to get only distinct elements and then sort them. return sorted(set(arr)) def count_distinct_leq(preprocessed_arr, x): Count the number of distinct elements in the preprocessed array that are less than or equal to x. pass def distinct_elements_count(n: int, q: int, arr: List[int], queries: List[int]) -> List[int]: For each query, find the number of distinct integers in the array that are less than or equal to the query value. Args: n (int): The size of the array. q (int): The number of queries. arr (List[int]): The array elements. queries (List[int]): The list of query values. Returns: List[int]: A list of results for each query. Examples: >>> distinct_elements_count(6, 3, [1, 5, 2, 2, 3, 5], [2, 4, 5]) [2, 3, 4] >>> distinct_elements_count(5, 2, [8, 8, 8, 8, 8], [7, 9]) [0, 1] preprocessed_arr = preprocess_array(arr) results = [] for query in queries: pass return results","solution":"def preprocess_array(arr): Preprocess the given array to get only distinct elements and then sort them. This will be used to quickly answer the queries. return sorted(set(arr)) def count_distinct_leq(preprocessed_arr, x): Count the number of distinct elements in the preprocessed array that are less than or equal to x. count = 0 for num in preprocessed_arr: if num <= x: count += 1 else: break return count def distinct_elements_count(n, q, arr, queries): Main function to handle multiple queries. Returns the result for each query. preprocessed_arr = preprocess_array(arr) results = [] for query in queries: results.append(count_distinct_leq(preprocessed_arr, query)) return results"},{"question":"def analyze_dna_sequence(sequence): Count the occurrences of 'A', 'C', 'G', and 'T' in the given DNA sequence and find the most frequent character. Parameters: sequence (str): The DNA sequence consisting of characters 'A', 'C', 'G', and 'T'. Returns: tuple: A tuple containing counts of 'A', 'C', 'G', and 'T' in that order, and the most frequent character. >>> analyze_dna_sequence(\\"ACGTACGTAC\\") (3, 3, 2, 2, 'A') >>> analyze_dna_sequence(\\"TGGGGCCT\\") (0, 2, 4, 2, 'G') >>> analyze_dna_sequence(\\"CGATCGAT\\") (2, 2, 2, 2, 'A')","solution":"def analyze_dna_sequence(sequence): Count the occurrences of 'A', 'C', 'G', and 'T' in the given DNA sequence and find the most frequent character. Parameters: sequence (str): The DNA sequence consisting of characters 'A', 'C', 'G', and 'T'. Returns: tuple: A tuple containing counts of 'A', 'C', 'G', and 'T' in that order, and the most frequent character. counts = {'A': 0, 'C': 0, 'G': 0, 'T': 0} for char in sequence: if char in counts: counts[char] += 1 most_frequent_char = max(counts, key=lambda x: (counts[x], -ord(x))) return counts['A'], counts['C'], counts['G'], counts['T'], most_frequent_char"},{"question":"from typing import List, Tuple def shortest_distance_occurrences(T: int, test_cases: List[Tuple[str, int, List[str]]]) -> List[List[int]]: For each string and queries given, find the shortest distance from the character to its nearest occurrence in the string. Parameters: T (int): Number of test cases test_cases (List[Tuple[str, int, List[str]]]): Test cases where each test case is a tuple containing: - A string S - An integer Q representing the number of queries - A list of Q characters representing the queries Returns: List[List[int]]: A list of lists where each list contains the shortest distance for each query or -1 if the character does not exist in the string. Example: >>> shortest_distance_occurrences(2, [(\\"abcde\\", 3, ['a', 'b', 'z']), (\\"aabbcc\\", 4, ['a', 'd', 'b', 'c'])]) [[0, 1, -1], [0, -1, 2, 4]]","solution":"def shortest_distance_occurrences(T, test_cases): results = [] for i in range(T): string = test_cases[i][0] queries = test_cases[i][2] char_indices = {} for idx, char in enumerate(string): if char in char_indices: char_indices[char].append(idx) else: char_indices[char] = [idx] distances = [] for query in queries: if query in char_indices: query_indices = char_indices[query] min_distance = min([abs(idx - i) for i, idx in enumerate(query_indices)]) # Simplified to check minimum distance distances.append(min(query_indices)) # The nearest occurrence distance else: distances.append(-1) results.append(distances) return results"},{"question":"def minimum_assembly_time(n: int, m: int, edges: List[Tuple[int, int, int]]) -> Union[int, str]: Calculate the minimum time required to assemble a toy car from part 1 to part n in a directed acyclic graph. Args: n: Number of parts. m: Number of directed edges. edges: A list of tuples where each tuple contains three integers u, v, w representing a directed edge from part u to part v that requires w time units to assemble. Returns: int: Minimum time required to assemble the toy car or \\"impossible\\" if the assembly cannot be completed. >>> minimum_assembly_time(2, 1, [(1, 2, 3)]) 3 >>> minimum_assembly_time(3, 2, [(1, 2, 2), (2, 3, 1)]) 3 >>> minimum_assembly_time(4, 3, [(1, 2, 2), (2, 3, 3), (3, 4, 1)]) 6 def assemble_toy_cars(test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[Union[int, str]]: Process multiple test cases to find the minimum assembly time for each. Args: test_cases: A list of test cases, each containing the number of parts, number of edges, and a list of edges. Returns: List of results containing either the minimum assembly time or \\"impossible\\" for each test case. >>> test_cases = [(2, 1, [(1, 2, 3)]), (3, 2, [(1, 2, 2), (2, 3, 1)]), (4, 3, [(1, 2, 2), (2, 3, 3), (3, 4, 1)])] >>> assemble_toy_cars(test_cases) [3, 3, 6] results = [] for n, m, edges in test_cases: result = minimum_assembly_time(n, m, edges) results.append(result) return results","solution":"from collections import deque, defaultdict import sys def minimum_assembly_time(n, m, edges): # Create an adjacency list and calculate in-degrees graph = defaultdict(list) in_degree = {i: 0 for i in range(1, n+1)} time = {i: float('inf') for i in range(1, n+1)} time[1] = 0 for u, v, w in edges: graph[u].append((v, w)) in_degree[v] += 1 # Topological sort using Kahn's algorithm queue = deque([node for node in range(1, n+1) if in_degree[node] == 0]) while queue: u = queue.popleft() for v, w in graph[u]: if time[u] + w < time[v]: time[v] = time[u] + w in_degree[v] -= 1 if in_degree[v] == 0: queue.append(v) return time[n] if time[n] != float('inf') else \\"impossible\\" def assemble_toy_cars(test_cases): results = [] for n, m, edges in test_cases: result = minimum_assembly_time(n, m, edges) results.append(result) return results"},{"question":"def longest_unique_subarray_length(test_cases): Given multiple test cases, each containing an array of integers, this function returns the length of the longest contiguous subarray that contains only unique elements for each test case. pass def parse_input(input_string): Parse the input string and convert it into test cases, where each test case is an array of integers. pass def test_case_1(): input_string = \\"2n5n1 2 3 4 5n7n1 2 1 3 4 2 3\\" test_cases = parse_input(input_string) result = longest_unique_subarray_length(test_cases) assert result == [5, 4] def test_case_all_unique(): input_string = \\"1n10n1 2 3 4 5 6 7 8 9 10\\" test_cases = parse_input(input_string) result = longest_unique_subarray_length(test_cases) assert result == [10] def test_case_all_same(): input_string = \\"1n5n1 1 1 1 1\\" test_cases = parse_input(input_string) result = longest_unique_subarray_length(test_cases) assert result == [1] def test_case_mixed(): input_string = \\"1n6n1 2 3 2 1 4\\" test_cases = parse_input(input_string) result = longest_unique_subarray_length(test_cases) assert result == [4] def test_multiple_cases(): input_string = \\"3n3n1 1 1n4n1 2 3 4n5n5 5 5 5 5\\" test_cases = parse_input(input_string) result = longest_unique_subarray_length(test_cases) assert result == [1, 4, 1]","solution":"def longest_unique_subarray_length(test_cases): Given multiple test cases, each containing an array of integers, this function returns the length of the longest contiguous subarray that contains only unique elements for each test case. results = [] for arr in test_cases: n = len(arr) max_len = 0 start = 0 seen = {} for end in range(n): if arr[end] in seen: start = max(start, seen[arr[end]] + 1) seen[arr[end]] = end max_len = max(max_len, end - start + 1) results.append(max_len) return results def parse_input(input_string): lines = input_string.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append(arr) index += 2 return test_cases"},{"question":"class Sequence: def __init__(self): self.values = {} def set(self, x, y): Sets the value of the x-th integer in the sequence to y. def sum(self, l, r): Returns the sum of integers in the sequence from position l to position r (inclusive). # Unit tests def test_operations(): seq = Sequence() seq.set(1, 5) seq.set(2, 3) assert seq.sum(1, 2) == 8 seq.set(3, 2) assert seq.sum(1, 3) == 10 assert seq.sum(2, 3) == 5 seq.set(2, 0) assert seq.sum(1, 2) == 5 assert seq.sum(1, 3) == 7 seq.set(1, 7) assert seq.values[1] == 7 def test_single_set(): seq = Sequence() seq.set(5, 10) assert seq.values[5] == 10 def test_non_existing_sum(): seq = Sequence() assert seq.sum(1, 5) == 0 def test_partial_range(): seq = Sequence() seq.set(2, 5) seq.set(4, 10) assert seq.sum(1, 3) == 5 assert seq.sum(1, 4) == 15","solution":"class Sequence: def __init__(self): self.values = {} def set(self, x, y): Sets the value of the x-th integer in the sequence to y. self.values[x] = y def sum(self, l, r): Returns the sum of integers in the sequence from position l to position r (inclusive). summation = 0 for i in range(l, r + 1): if i in self.values: summation += self.values[i] return summation"},{"question":"def execute_queries(N, items, Q, queries): Execute a series of queries on an array of purchased items. Args: N (int): Number of items in the array. items (List[int]): List of integers representing the items bought. Q (int): Number of queries to be processed. queries (List[List[int]]): List of queries to be executed. Returns: List[int]: Result of the Type 3 queries. The queries are of three types: 1. [1, u, t]: replace the u-th purchase in the array with item t 2. [2, u, k]: add k to the current item, making it the \\"k-th\\" purchase 3. [3, l, r]: count the number of unique items in the array between l to r, both inclusive >>> execute_queries(5, [1, 2, 2, 1, 3], 4, [[3, 1, 5], [1, 2, 4], [3, 1, 5], [2, 3, 10]]) [3, 3] from solution import execute_queries def test_type_3_query_entire_range(): N = 5 items = [1, 2, 2, 1, 3] Q = 3 queries = [ [3, 1, 5], # Count unique items from index 1 to 5 inclusive, expected result: 3 ] assert execute_queries(N, items, Q, queries) == [3] def test_type_1_query_replacement(): N = 5 items = [1, 2, 2, 1, 3] Q = 2 queries = [ [1, 2, 4], # Replace the 2nd item with 4, resulting array: [1, 4, 2, 1, 3] [3, 1, 5] # Count unique items from index 1 to 5 inclusive, expected result: 4 ] assert execute_queries(N, items, Q, queries) == [4] def test_type_2_query_addition(): N = 5 items = [1, 2, 2, 1, 3] Q = 2 queries = [ [2, 3, 10], # Add 10 to the 3rd item, resulting array: [1, 2, 12, 1, 3] [3, 1, 5] # Count unique items from index 1 to 5 inclusive, expected result: 4 ] assert execute_queries(N, items, Q, queries) == [4] def test_mixed_queries(): N = 5 items = [1, 2, 2, 1, 3] Q = 4 queries = [ [3, 1, 5], # Initial unique count, expected result: 3 [1, 2, 4], # Replace the 2nd item with 4, resulting array: [1, 4, 2, 1, 3] [3, 1, 5], # Current unique count, expected result: 4 [2, 3, 10] # Add 10 to the 3rd item, resulting array: [1, 4, 12, 1, 3] ] assert execute_queries(N, items, Q, queries) == [3, 4]","solution":"def execute_queries(N, items, Q, queries): results = [] for query in queries: if query[0] == 1: # Type 1: Replace the u-th purchase in the array with item t u, t = query[1], query[2] items[u - 1] = t elif query[0] == 2: # Type 2: Add k to the current item, making it the \\"k-th\\" purchase u, k = query[1], query[2] items[u - 1] += k elif query[0] == 3: # Type 3: Count the number of unique items between l to r, inclusive l, r = query[1], query[2] results.append(len(set(items[l - 1:r]))) return results"},{"question":"def max_teams(f: int, m: int, d: int, g: int) -> int: Returns the maximum number of valid teams that can be formed. A valid team must have: - At least 1 Forward - At least 1 Midfielder - At least 1 Defender - Exactly 1 Goalkeeper The sum of all players should not exceed 11 per team. :param f: Number of Forwards :param m: Number of Midfielders :param d: Number of Defenders :param g: Number of Goalkeepers :return: The maximum number of valid teams that can be formed def calculate_max_teams(datasets: List[Tuple[int, int, int, int]]) -> List[int]: Calculates the maximum number of valid teams for each dataset. :param datasets: List of datasets where each dataset is a tuple of (fi, mi, di, gi) :return: List of maximum number of teams for each dataset # Test cases def test_max_teams(): assert max_teams(7, 5, 4, 2) == 2 assert max_teams(10, 7, 6, 3) == 3 assert max_teams(2, 2, 2, 1) == 1 assert max_teams(50, 40, 30, 5) == 5 assert max_teams(100, 100, 100, 50) == 50 assert max_teams(0, 10, 10, 10) == 0 assert max_teams(10, 0, 10, 10) == 0 assert max_teams(10, 10, 10, 0) == 0 assert max_teams(0, 0, 0, 0) == 0 def test_calculate_max_teams(): assert calculate_max_teams([(7, 5, 4, 2), (10, 7, 6, 3), (2, 2, 2, 1)]) == [2, 3, 1] assert calculate_max_teams([(0, 0, 0, 0), (1, 1, 1, 1), (5, 7, 8, 10)]) == [0, 1, 5] assert calculate_max_teams([(12, 34, 56, 78)]) == [12] assert calculate_max_teams([(0, 0, 0, 0), (1000, 1000, 0, 500)]) == [0, 0]","solution":"def max_teams(f, m, d, g): Returns the maximum number of valid teams that can be formed. A valid team has: - At least 1 Forward - At least 1 Midfielder - At least 1 Defender - Exactly 1 Goalkeeper The sum of all players should not exceed 11 per team. # Calculate the maximum team by limiting with the minimum role count and the 11 players limit max_possible_teams = min(f, m, d, g) return max_possible_teams def calculate_max_teams(datasets): calculates the maximum number of valid teams for each dataset. :param datasets: List of datasets where each dataset is a tuple of (fi, mi, di, gi) :return: List of maximum number of teams for each dataset max_teams_count = [] for dataset in datasets: f, m, d, g = dataset max_teams_for_current_dataset = max_teams(f, m, d, g) max_teams_count.append(max_teams_for_current_dataset) return max_teams_count"},{"question":"from typing import List, Tuple def best_days_to_trade(prices: List[int]) -> Tuple[int, int]: Returns the best day to buy and sell to maximize profit. If no profit can be made, returns (-1, -1). :param prices: List of stock prices :return: Tuple of integers (buy_day, sell_day) >>> best_days_to_trade([7, 1, 5, 3, 6, 4]) (1, 4) >>> best_days_to_trade([7, 6, 4, 3, 1]) (-1, -1) pass def test_empty_list(): assert best_days_to_trade([]) == (-1, -1) def test_single_element_list(): assert best_days_to_trade([5]) == (-1, -1) def test_no_profit(): assert best_days_to_trade([7, 6, 4, 3, 1]) == (-1, -1) def test_single_transaction(): assert best_days_to_trade([7, 1, 5, 3, 6, 4]) == (1, 4) def test_multiple_same_max_profit(): assert best_days_to_trade([3, 3, 5, 1, 5, 5]) == (3, 4) def test_increasing_prices(): assert best_days_to_trade([1, 2, 3, 4, 5]) == (0, 4) def test_decreasing_then_increasing_prices(): assert best_days_to_trade([10, 1, 2, 3, 4]) == (1, 4) def test_alternating_prices(): assert best_days_to_trade([2, 4, 1, 3, 5]) == (2, 4)","solution":"def best_days_to_trade(prices): Returns the best day to buy and sell to maximize profit. If no profit can be made, returns (-1, -1). :param prices: List of stock prices :return: Tuple of integers (buy_day, sell_day) if not prices or len(prices) < 2: return (-1, -1) min_price = prices[0] min_day = 0 max_profit = 0 best_buy_day = 0 best_sell_day = 0 for current_day in range(1, len(prices)): current_price = prices[current_day] if current_price - min_price > max_profit: max_profit = current_price - min_price best_buy_day = min_day best_sell_day = current_day if current_price < min_price: min_price = current_price min_day = current_day if max_profit > 0: return (best_buy_day, best_sell_day) else: return (-1, -1)"},{"question":"def nextPermutation(nums: List[int]) -> None: Rearrange the array of integers into the lexicographically next greater permutation of numbers. If such an arrangement is not possible, rearrange it as the lowest possible order (i.e., sorted in ascending order). The function modifies the array in-place and uses only constant extra memory. Args: nums (List[int]): List of integers to rearrange. Example: >>> nums = [1, 2, 3] >>> nextPermutation(nums) >>> nums [1, 3, 2] >>> nums = [3, 2, 1] >>> nextPermutation(nums) >>> nums [1, 2, 3] >>> nums = [1, 1, 5] >>> nextPermutation(nums) >>> nums [1, 5, 1] >>> nums = [1] >>> nextPermutation(nums) >>> nums [1] # Add the function logic here to complete the task.","solution":"def nextPermutation(nums): Rearrange numbers into the lexicographically next greater permutation of numbers. If such an arrangement is not possible, rearrange it as the lowest possible order. n = len(nums) if n <= 1: return # Step 1: Find the largest k such that nums[k] < nums[k + 1]. k = -1 for i in range(n - 1): if nums[i] < nums[i + 1]: k = i if k == -1: # The array is in descending order, reverse it. nums.reverse() return # Step 2: Find the largest l greater than k such that nums[k] < nums[l]. for l in range(n - 1, k, -1): if nums[k] < nums[l]: break # Step 3: Swap nums[k] and nums[l]. nums[k], nums[l] = nums[l], nums[k] # Step 4: Reverse the sequence from nums[k + 1] to the end. nums[k + 1:] = reversed(nums[k + 1:])"},{"question":"from typing import List, Tuple class NumArray: def __init__(self, nums: List[int]): Initializes the data structure with the given list of integers. self.nums = nums self.n = len(nums) self.bit = [0] * (self.n + 1) for i, num in enumerate(nums): self.add(i + 1, num) def update(self, index: int, val: int) -> None: Updates the value of an element at a specific index. diff = val - self.nums[index] self.nums[index] = val self.add(index + 1, diff) def add(self, index: int, val: int) -> None: Helper function to add value using Binary Indexed Tree (Fenwick Tree). while index <= self.n: self.bit[index] += val index += index & -index def sum_range(self, l: int, r: int) -> int: Computes the sum of elements in the specified range. return self.sum(r + 1) - self.sum(l) def sum(self, index: int) -> int: Helper function to get prefix sum using Binary Indexed Tree (Fenwick Tree). total = 0 while index > 0: total += self.bit[index] index -= index & -index return total def process_operations(n: int, nums: List[int], operations: List[Tuple[str, int, int]]) -> List[int]: Handles a list of update and sum operations on the list of integers. Args: - n: Length of the list of integers. - nums: List of integers. - operations: A list of operations in the format [('u', x, y), ('s', l, r)]. Returns: - A list with the results of the sum operations. Example: >>> process_operations(5, [1, 2, 3, 4, 5], [('s', 1, 3), ('u', 2, 10), ('s', 1, 3), ('u', 0, 6), ('s', 0, 4)]) [9, 16, 27] num_array = NumArray(nums) results = [] for op in operations: if op[0] == 'u': idx, val = int(op[1]), int(op[2]) num_array.update(idx, val) elif op[0] == 's': l, r = int(op[1]), int(op[2]) results.append(num_array.sum_range(l, r)) return results","solution":"class NumArray: def __init__(self, nums): self.nums = nums self.n = len(nums) self.bit = [0] * (self.n + 1) for i, num in enumerate(nums): self.add(i + 1, num) def update(self, index, val): diff = val - self.nums[index] self.nums[index] = val self.add(index + 1, diff) def add(self, index, val): while index <= self.n: self.bit[index] += val index += index & -index def sum_range(self, l, r): return self.sum(r + 1) - self.sum(l) def sum(self, index): total = 0 while index > 0: total += self.bit[index] index -= index & -index return total # Function to handle the input operations def process_operations(n, nums, operations): num_array = NumArray(nums) results = [] for op in operations: if op[0] == 'u': idx, val = int(op[1]), int(op[2]) num_array.update(idx, val) elif op[0] == 's': l, r = int(op[1]), int(op[2]) results.append(num_array.sum_range(l, r)) return results"},{"question":"def chess_tournament(n: int, results: List[List[int]]) -> Tuple[int, int, int, int]: In a round-robin chess tournament, find the total number of games played and evaluate the performance of Alice (the first participant). >>> chess_tournament(3, [[0, 1, -1], [-1, 0, 1], [1, -1, 0]]) (3, 1, 1, 0) >>> chess_tournament(4, [[0, 1, 0, -1], [-1, 0, 1, 0], [0, -1, 0, 1], [1, 0, -1, 0]]) (6, 1, 1, 1) pass from typing import List, Tuple def test_chess_tournament_example1(): n = 3 results = [ [0, 1, -1], [-1, 0, 1], [1, -1, 0] ] assert chess_tournament(n, results) == (3, 1, 1, 0) def test_chess_tournament_example2(): n = 4 results = [ [0, 1, 0, -1], [-1, 0, 1, 0], [0, -1, 0, 1], [1, 0, -1, 0] ] assert chess_tournament(n, results) == (6, 1, 1, 1) def test_chess_tournament_all_draws(): n = 3 results = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert chess_tournament(n, results) == (3, 0, 0, 2) def test_chess_tournament_all_wins(): n = 3 results = [ [0, 1, 1], [-1, 0, -1], [-1, 1, 0] ] assert chess_tournament(n, results) == (3, 2, 0, 0) def test_chess_tournament_all_losses(): n = 3 results = [ [0, -1, -1], [1, 0, 1], [1, -1, 0] ] assert chess_tournament(n, results) == (3, 0, 2, 0)","solution":"def chess_tournament(n, results): total_games = n * (n - 1) // 2 alice_wins = 0 alice_losses = 0 alice_draws = 0 for j in range(n): if results[0][j] == 1: alice_wins += 1 elif results[0][j] == -1: alice_losses += 1 elif results[0][j] == 0 and j != 0: alice_draws += 1 return total_games, alice_wins, alice_losses, alice_draws"},{"question":"from typing import List, Tuple def min_rounds_for_discussion(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the minimum number of distinct rounds required for a round-robin discussion in a hierarchical company. Args: T : int : Number of test cases. test_cases : List[Tuple[int, List[Tuple[int, int]]]] : List of test cases. Each test case consists of a number of employees (N) and a list of pairs representing direct report relationships. Returns: List[int] : List of minimum number of rounds required for each test case. Example: >>> min_rounds_for_discussion(2, [(3, [(1, 2), (1, 3)]), (5, [(1, 2), (1, 3), (3, 4), (3, 5)])]) [2, 3] pass # Unit tests def test_case_1(): T = 2 test_cases = [ (3, [(1, 2), (1, 3)]), (5, [(1, 2), (1, 3), (3, 4), (3, 5)]) ] assert min_rounds_for_discussion(T, test_cases) == [2, 3] def test_case_2(): T = 1 test_cases = [ (1, []) ] assert min_rounds_for_discussion(T, test_cases) == [1] def test_case_3(): T = 1 test_cases = [ (4, [(1, 2), (1, 3), (2, 4)]) ] assert min_rounds_for_discussion(T, test_cases) == [3] def test_case_4(): T = 1 test_cases = [ (6, [(1, 2), (1, 3), (2, 4), (3, 5), (3, 6)]) ] assert min_rounds_for_discussion(T, test_cases) == [3]","solution":"from collections import deque, defaultdict def min_rounds_for_discussion(T, test_cases): results = [] for case in test_cases: N, edges = case if N == 1: results.append(1) continue tree = defaultdict(list) indegree = [0] * (N + 1) for u, v in edges: tree[u].append(v) indegree[v] += 1 queue = deque() rounds = 0 for i in range(1, N + 1): if indegree[i] == 0: queue.append(i) while queue: rounds += 1 level_size = len(queue) for _ in range(level_size): node = queue.popleft() for child in tree[node]: indegree[child] -= 1 if indegree[child] == 0: queue.append(child) results.append(rounds) return results # Example usage: # T = 2 # test_cases = [ # (3, [(1, 2), (1, 3)]), # (5, [(1, 2), (1, 3), (3, 4), (3, 5)]) #] # print(min_rounds_for_discussion(T, test_cases)) # Output: [2, 3]"},{"question":"from typing import List class TreeNode: def __init__(self, id): self.id = id self.value = 0 self.children = [] def update_value(node: TreeNode, x: int): Update the value of a specific node. pass def find_max_in_subtree(node: TreeNode) -> int: Query the maximum value in the subtree rooted at a specific node. pass def process_operations(n: int, edges: List[int], operations: List[str]) -> List[int]: Perform update and query operations on the tree. Args: n: Number of nodes in the tree edges: List representing the edges of the tree operations: List of operations to be performed Returns: List of results for each query operation >>> process_operations(5, [1, 1, 2, 2], [\\"1 1 5\\", \\"1 3 3\\", \\"1 4 7\\", \\"2 1\\", \\"2 2\\", \\"2 5\\"]) [7, 7, 0] >>> process_operations(1, [], [\\"1 1 10\\", \\"2 1\\"]) [10] pass def test_tree_operations(): n = 5 q = 6 edges = [1, 1, 2, 2] operations = [\\"1 1 5\\", \\"1 3 3\\", \\"1 4 7\\", \\"2 1\\", \\"2 2\\", \\"2 5\\"] expected_outputs = [7, 7, 0] assert process_operations(n, edges, operations) == expected_outputs def test_single_node_tree(): n = 1 q = 2 edges = [] operations = [\\"1 1 10\\", \\"2 1\\"] expected_outputs = [10] assert process_operations(n, edges, operations) == expected_outputs def test_no_updates(): n = 3 q = 2 edges = [1, 1] operations = [\\"2 1\\", \\"2 2\\"] expected_outputs = [0, 0] assert process_operations(n, edges, operations) == expected_outputs def test_updates_and_max_queries(): n = 4 q = 5 edges = [1, 2, 2] operations = [\\"1 2 15\\", \\"1 4 5\\", \\"2 1\\", \\"2 2\\", \\"2 3\\"] expected_outputs = [15, 15, 0] assert process_operations(n, edges, operations) == expected_outputs","solution":"class TreeNode: def __init__(self, id): self.id = id self.value = 0 self.children = [] def update_value(node, x): node.value = x def find_max_in_subtree(node): max_value = node.value for child in node.children: max_value = max(max_value, find_max_in_subtree(child)) return max_value def process_operations(n, edges, operations): nodes = [TreeNode(i) for i in range(n + 1)] root = nodes[1] for i, parent in enumerate(edges, start=2): nodes[parent].children.append(nodes[i]) results = [] for op in operations: parts = op.split() if parts[0] == \\"1\\": vi, x = int(parts[1]), int(parts[2]) update_value(nodes[vi], x) elif parts[0] == \\"2\\": vi = int(parts[1]) results.append(find_max_in_subtree(nodes[vi])) return results"},{"question":"from typing import List def minCut(s: str) -> int: Given a string s, partition it such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. >>> minCut(\\"abcbm\\") 2 >>> minCut(\\"aabb\\") 1 >>> minCut(\\"abc\\") 2 >>> minCut(\\"ababbbabbababa\\") 3 pass def process_input(input_text: str) -> List[int]: For the given input_text, process the input and return a list of results representing the minimum number of cuts needed for each test case for palindrome partitioning. >>> process_input(\\"abcbmnaabbnabcnababbbabbababanENDn\\") [2, 1, 2, 3] pass def test_minCut_single_char(): assert minCut(\\"a\\") == 0 def test_minCut_simple_palindrome(): assert minCut(\\"aa\\") == 0 assert minCut(\\"aba\\") == 0 def test_minCut_complex_palindrome(): assert minCut(\\"abcbm\\") == 2 assert minCut(\\"aabb\\") == 1 assert minCut(\\"abc\\") == 2 assert minCut(\\"ababbbabbababa\\") == 3 def test_minCut_no_palindrome(): assert minCut(\\"abcdefg\\") == 6 def test_process_input(): input_text = \\"abcbmnaabbnabcnababbbabbababanENDn\\" expected_output = [2, 1, 2, 3] assert process_input(input_text) == expected_output","solution":"def minCut(s): n = len(s) dp = [[False] * n for _ in range(n)] cut = [0] * n for end in range(n): minCuts = end for start in range(end + 1): if s[start] == s[end] and (end - start <= 1 or dp[start + 1][end - 1]): dp[start][end] = True minCuts = 0 if start == 0 else min(minCuts, cut[start - 1] + 1) cut[end] = minCuts return cut[-1] def process_input(input_text): lines = input_text.strip().split() results = [] for line in lines: if line == \\"END\\": break results.append(minCut(line)) return results"},{"question":"from typing import List def is_arithmetic_sequence(arr: List[int]) -> str: Determines if there exists a combination of elements in the list that forms an arithmetic sequence. >>> is_arithmetic_sequence([3, 1, 4, 5]) 'Yes' >>> is_arithmetic_sequence([1, 2, 4]) 'No' >>> is_arithmetic_sequence([1, 2, 3, 5]) 'Yes' >>> is_arithmetic_sequence([1, 3, 5, 7]) 'Yes' >>> is_arithmetic_sequence([1, 3, 7, 10]) 'No' >>> is_arithmetic_sequence([1, 4, 7, 10]) 'Yes' >>> is_arithmetic_sequence([1, 1, 1, 1]) 'Yes' >>> is_arithmetic_sequence([100, 95, 90, 85]) 'Yes'","solution":"from itertools import combinations def is_arithmetic_sequence(arr): Determines if there exists a combination of elements in the list that forms an arithmetic sequence. def is_arith_seq(seq): n = len(seq) if n < 2: return True diff = seq[1] - seq[0] for i in range(2, n): if seq[i] - seq[i-1] != diff: return False return True n = len(arr) for r in range(3, n+1): for comb in combinations(arr, r): comb = sorted(comb) if is_arith_seq(comb): return \\"Yes\\" return \\"No\\" def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) arr = list(map(int, data[1:])) print(is_arithmetic_sequence(arr))"},{"question":"def max_area(heights): Returns the maximum amount of water that can be held between two lines. Args: heights (List[int]): An array of integers representing the heights of vertical lines. Returns: int: The maximum amount of water the container can hold. Examples: >>> max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_area([1, 1]) 1","solution":"def max_area(heights): Returns the maximum amount of water that can be held between two lines. left = 0 right = len(heights) - 1 max_water = 0 while left < right: width = right - left current_height = min(heights[left], heights[right]) current_area = width * current_height max_water = max(max_water, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"}]`),E={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},D={class:"search-container"},j={class:"card-container"},P={key:0,class:"empty-state"},C=["disabled"],I={key:0},F={key:1};function M(i,e,u,_,r,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",D,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",j,[(s(!0),n(x,null,y(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",P,' No results found for "'+d(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",F,"Loading...")):(s(),n("span",I,"See more"))],8,C)):l("",!0)])}const z=c(E,[["render",M],["__scopeId","data-v-8336fd8f"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/35.md","filePath":"library/35.md"}'),O={name:"library/35.md"},G=Object.assign(O,{setup(i){return(e,u)=>(s(),n("div",null,[w(z)]))}});export{B as __pageData,G as default};
