import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as y,U as _,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},E={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",E,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const N=c(k,[["render",A],["__scopeId","data-v-d772fe52"]]),S=JSON.parse('[{"question":"# Advanced Sorting Problem: Optimized Bucket Sort Given an array of `n` integers, write an optimized implementation of Bucket Sort that minimizes the worst-case time complexity and space usage. Instead of using a fixed bucket count, adaptively determine the number of buckets and ensure efficient sorting within each bucket. Use a more efficient sorting mechanism, such as Timsort, for sorting the contents of the buckets. Function Signature ```python def optimized_bucket_sort(arr: List[int]) -> List[int]: pass ``` Input - An array of integers, `arr`, with `1 ≤ len(arr) ≤ 10^6`. - Values in `arr` could range from `-10^9` to `10^9`. Output - A sorted array in ascending order. Constraints - Minimize the worst-case time complexity of your implementation. - Ensure that your solution works within a reasonable space complexity. Example ```python assert optimized_bucket_sort([4, 1, 3, 9, 7]) == [1, 3, 4, 7, 9] assert optimized_bucket_sort([10, -1, 2, 5, 0, 6]) == [-1, 0, 2, 5, 6, 10] assert optimized_bucket_sort([4, 4, 4, 4, 4]) == [4, 4, 4, 4, 4] ``` Ensure that your code handles large input sizes efficiently and consider performance optimizations and edge cases discussed in the algorithm analysis.","solution":"from typing import List def optimized_bucket_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr num_buckets = len(arr) min_val, max_val = min(arr), max(arr) if min_val == max_val: return arr bucket_range = (max_val - min_val) / num_buckets # Create buckets buckets = [[] for _ in range(num_buckets)] # Distribute input array values into buckets for num in arr: idx = int((num - min_val) / bucket_range) if idx == num_buckets: idx -= 1 # Handle the boundary case where num == max_val buckets[idx].append(num) # Sort each bucket and gather results sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"# Maximum Subarray Sum Scenario: You are working on a financial analysis program and need to find the period with the highest profit in a given year. The data for each month\'s profit/loss is given as a list of integers. You need to write a function that will determine the maximum profit that could be obtained by considering any contiguous subarray within this list. Function Signature: ```python def max_subarray(array: List[int]) -> int: ``` Input: - `array` (List[int]): A list of integers representing the profit or loss for each month. `1 <= len(array) <= 10^5`, `-10^6 <= array[i] <= 10^6`. Output: - `int`: The maximum sum of any contiguous subarray within the provided list. Example: ```python # Example 1: array = [1, 2, -3, 4, 5, -7, 23] print(max_subarray(array)) # Output: 25 (subarray: [4, 5, -7, 23]) # Example 2: array = [-1, -2, -3, -4] print(max_subarray(array)) # Output: -1 (single element subarray: [-1]) ``` Constraints: - The array must contain at least one element. - The array can contain both positive and negative integers. - The function should have a time complexity of O(n) and a space complexity of O(1). Explanation: Implement the \\"Kadane\'s Algorithm\\" to solve this problem efficiently. Iterate through the array while maintaining the `max_now` and `max_so_far` values as described in the analysis. Consider any potential edge cases like arrays with all negative numbers and make sure to handle them correctly.","solution":"def max_subarray(array): Returns the maximum sum of any contiguous subarray. max_now = max_so_far = array[0] for num in array[1:]: max_now = max(num, max_now + num) max_so_far = max(max_so_far, max_now) return max_so_far"},{"question":"You are tasked with implementing a more optimized version of a prime checking function. This function should be able to handle very large numbers efficiently by incorporating one or more optimization techniques or probabilistic approaches for determining primality, such as the Miller-Rabin primality test. # Function Signature ```python def is_prime_optimized(n: int) -> bool: Determine whether a given number `n` is prime. Parameters: n (int): An integer to be checked for primality. Returns: bool: True if `n` is a prime number, False otherwise. ``` # Inputs and Outputs - **Input**: - `n` is an integer where `0 <= n <= 10^18`. - **Output**: - Return `True` if `n` is a prime number, otherwise `False`. # Constraints - The function should work efficiently for the given range of `n`. # Performance Requirements - Time complexity should aim to be better than O(√n) for large numbers, leveraging probabilistic methods if necessary. - Space complexity should remain O(1) or only slightly more if storage of intermediate computational states is necessary. # Example ```python assert is_prime_optimized(1) == False assert is_prime_optimized(2) == True assert is_prime_optimized(3) == True assert is_prime_optimized(4) == False assert is_prime_optimized(29) == True assert is_prime_optimized(1_000_000_007) == True # Example of a large prime number ``` Your task is to implement the `is_prime_optimized` function, ensuring it meets the performance and accuracy requirements stated above.","solution":"def is_prime_optimized(n: int) -> bool: Determine whether a given number `n` is prime using the Miller-Rabin primality test. Parameters: n (int): An integer to be checked for primality. Returns: bool: True if `n` is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False # Miller-Rabin test with a predetermined set of bases def miller_rabin_test(d, n): import random a = random.randint(2, n - 2) x = pow(a, d, n) if x == 1 or x == n - 1: return True while d != n - 1: x = (x * x) % n d *= 2 if x == 1: return False if x == n - 1: return True return False # Find d such that n-1 = d * 2^r d = n - 1 while d % 2 == 0: d //= 2 # Perform the Miller-Rabin test multiple times k = 5 # Number of iterations for _ in range(k): if not miller_rabin_test(d, n): return False return True"},{"question":"# Question: You are required to implement an enhanced version of the `OrderedStack` class that maintains a stack where elements are always sorted in ascending order from bottom to top. This stack should have the following functionalities: 1. **Push**: Insert an element into the stack while maintaining the order. 2. **Pop**: Remove and return the top element from the stack. 3. **Peek**: Return the top element without removing it from the stack. 4. **Is_empty**: Check whether the stack is empty or not. 5. **Size**: Return the number of elements in the stack. Implement the class `OrderedStack` with the following method signatures: ```python class OrderedStack: def __init__(self): # Initialize an empty list to store stack elements pass def is_empty(self) -> bool: # Return True if the stack is empty, False otherwise pass def push(self, item: int) -> None: # Insert \'item\' into the stack, maintaining sorted order pass def pop(self) -> int: # Remove and return the top element of the stack pass def peek(self) -> int: # Return the top element without removing it from the stack pass def size(self) -> int: # Return the number of elements in the stack pass ``` # Input and Output: * The `push` method takes an integer as input and returns nothing. * The `pop` method returns the top element of the stack. * The `peek` method returns the top element of the stack without removing it. * The `is_empty` method returns a boolean indicating whether the stack is empty. * The `size` method returns an integer indicating the number of elements in the stack. # Constraints: * Elements in the stack are integers. * Assume all input operations are valid (i.e., no `pop` or `peek` will be called on an empty stack). # Example: ```python stack = OrderedStack() stack.push(5) stack.push(2) stack.push(8) stack.push(1) print(stack.peek()) # Output: 8 print(stack.pop()) # Output: 8 print(stack.size()) # Output: 3 print(stack.peek()) # Output: 5 print(stack.is_empty()) # Output: False ``` Ensure that your implementation efficiently manages the ordering of stack elements during the push operation.","solution":"class OrderedStack: def __init__(self): # Initialize an empty list to store stack elements self.stack = [] def is_empty(self) -> bool: # Return True if the stack is empty, False otherwise return len(self.stack) == 0 def push(self, item: int) -> None: # Insert \'item\' into the stack, maintaining sorted order if self.is_empty(): self.stack.append(item) else: insert_pos = len(self.stack) for i in range(len(self.stack)): if item <= self.stack[i]: insert_pos = i break self.stack.insert(insert_pos, item) def pop(self) -> int: # Remove and return the top element of the stack if not self.is_empty(): return self.stack.pop() else: raise IndexError(\\"pop from empty stack\\") def peek(self) -> int: # Return the top element without removing it from the stack if not self.is_empty(): return self.stack[-1] else: raise IndexError(\\"peek from empty stack\\") def size(self) -> int: # Return the number of elements in the stack return len(self.stack)"},{"question":"You are given a nested array (or list of lists) that may contain nested arrays to an arbitrary depth. Your task is to write a function that \\"flattens\\" this nested array, producing a one-dimensional array containing all the elements from the input array. # Requirements 1. **Function Signature**: ```python def flatten_array(nested_array: list) -> list: ``` - The function takes a single input, `nested_array`, which is a list that may contain nested lists. 2. **Expected Output**: - The function should return a single list containing all the elements from the input nested list, preserving their order. 3. **Constraints**: - You must handle arbitrarily deep nesting. - Nested lists can contain other types of iterable elements (e.g., tuples, sets). - Must not flatten strings. # Test Cases Consider the following test cases to validate your implementation: ```python # Test Case 1 nested_array = [1, [2, 3], [4, [5, 6]], 7, [[8], 9]] expected_output = [1, 2, 3, 4, 5, 6, 7, 8, 9] assert flatten_array(nested_array) == expected_output, f\\"Test case 1 failed\\" # Test Case 2 nested_array = [[], [[], [[], []]], [[[]]], 1] expected_output = [1] assert flatten_array(nested_array) == expected_output, f\\"Test case 2 failed\\" # Test Case 3 nested_array = [\\"a\\", [\\"b\\", [\\"c\\", [\\"d\\"]]], \\"e\\"] expected_output = [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"] assert flatten_array(nested_array) == expected_output, f\\"Test case 3 failed\\" # Test Case 4 nested_array = [1, [2, [3, [4, [5, [6]]]]]] expected_output = [1, 2, 3, 4, 5, 6] assert flatten_array(nested_array) == expected_output, f\\"Test case 4 failed\\" # Test Case 5 nested_array = [] expected_output = [] assert flatten_array(nested_array) == expected_output, f\\"Test case 5 failed\\" ``` # Hints 1. Recursion is a natural fit for this problem, but be cautious of recursive depth limits. 2. You may also consider iterative solutions using a stack to avoid deep recursion issues. 3. Don\'t forget to handle non-iterable elements and keep their order in the final list.","solution":"def flatten_array(nested_array): Flattens a nested list to a one-dimensional list. Parameters: nested_array (list): A list which can contain other nested lists. Returns: list: A flattened list containing all the elements from the input nested list. flat_list = [] def _flatten(arr): for item in arr: if isinstance(item, (list, tuple, set)): _flatten(item) else: flat_list.append(item) _flatten(nested_array) return flat_list"},{"question":"Enhanced Jump Search You are the lead software engineer at a data processing company, and your task is to optimize search operations in large sorted datasets. To achieve this, you need to implement an enhanced version of the Jump Search algorithm. This algorithm efficiently locates a target value within a sorted array, offering a blend of jump and binary search techniques for optimal search performance. Function Signature ```python def enhanced_jump_search(arr: List[int], target: int) -> int: pass ``` Input - `arr`: A list of integers sorted in ascending order. - `target`: An integer representing the value to be searched in the list. Output - Returns the index of the target value if found; otherwise, returns -1. # Constraints - All array elements are uniquely sorted in non-decreasing order. - The array has at most 10^6 elements. # Performance Requirements - Optimally handle searches with a time complexity better than O(n) but adjusted for large datasets to avoid inefficient linear scanning when the jump fails. # Example ```python arr = [3, 5, 6, 9, 12, 15, 19, 21, 25, 30] target = 19 assert enhanced_jump_search(arr, target) == 6 # Because arr[6] = 19 arr = [1, 3, 4, 6, 7, 9, 11] target = 10 assert enhanced_jump_search(arr, target) == -1 # Because 10 is not in the array ``` # Test Cases 1. **Basic Case**: ```python arr = [1, 2, 3, 4, 5] target = 3 assert enhanced_jump_search(arr, target) == 2 ``` 2. **Target Not Present**: ```python arr = [10, 20, 30, 40, 50] target = 35 assert enhanced_jump_search(arr, target) == -1 ``` 3. **Edge Case with Large Data**: ```python arr = list(range(1, 1000000)) target = 999999 assert enhanced_jump_search(arr, target) == 999998 ``` Your task is to implement `enhanced_jump_search`, taking advantage of both Jump Search and Binary Search within blocks for utmost efficiency. The solution should be robust, handling edge cases effectively and ensuring it operates within the specified constraints.","solution":"from math import sqrt from typing import List def enhanced_jump_search(arr: List[int], target: int) -> int: Enhanced Jump Search combining Jump Search and Binary Search techniques. n = len(arr) if n == 0: return -1 # Optimal jump size step = int(sqrt(n)) prev = 0 # Jumping through blocks while prev < n and arr[min(step, n)-1] < target: prev = step step += int(sqrt(n)) if prev >= n: return -1 # Linear search within the block for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"Question # Scenario You are analyzing a sequence of binary digits (0s and 1s) from a data stream. You need a function to count how many contiguous substrings have an equal number of 0s and 1s, and each group of 0s and 1s in these substrings have to be consecutive. # Task Write a function `count_binary_substring(s)` that takes a single string input `s` consisting of binary digits (\'0\' and \'1\') and returns an integer representing the number of non-empty contiguous substrings that have the same number of 0s and 1s grouped consecutively. # Requirements - **Input**: A single string `s` which consists only of \'0\'s and \'1\'s (1 ≤ |s| ≤ 10^5). - **Output**: An integer representing the count of valid substrings. # Constraints 1. All characters in the input string `s` are either \'0\' or \'1\'. 2. Overlapping substrings are counted separately if they form distinct valid substrings. # Performance Your function should run in O(n) time complexity and use O(1) extra space. # Example Example 1: ```plaintext Input: \\"00110011\\" Output: 6 Explanation: The possible valid substrings are \\"0011\\", \\"01\\", \\"1100\\", \\"10\\", \\"0011\\", and \\"01\\". ``` Example 2: ```plaintext Input: \\"10101\\" Output: 4 Explanation: The possible valid substrings are \\"10\\", \\"01\\", \\"10\\", \\"01\\". ``` # Note Substrings that occur multiple times are counted the number of times they occur. # Implementation Please implement the function signature as: ```python def count_binary_substring(s: str) -> int: # Your implementation here ```","solution":"def count_binary_substring(s: str) -> int: Returns the count of contiguous substrings having the same number of 0s and 1s and all the 0s and 1s in those substrings are grouped consecutively. prev_len = 0 cur_len = 1 count = 0 # Iterate through the string to find groups of consecutive 0\'s or 1\'s. for i in range(1, len(s)): if s[i] == s[i - 1]: cur_len += 1 else: count += min(prev_len, cur_len) prev_len = cur_len cur_len = 1 # Add the last group comparison count += min(prev_len, cur_len) return count"},{"question":"# Challenge You are given an array of complex numbers representing signal measurements in the time domain, and you need to convert this signal into its frequency domain representation using the Fast Fourier Transform (FFT). The task is to implement your own version of the Cooley-Tukey FFT algorithm based on the provided specifications and handle any edge scenarios that may arise. # Function Signature ```python def custom_fft(signal: List[complex]) -> List[complex]: pass ``` # Input * `signal` (List[complex]): A list of complex numbers with size (N), where (N) is an integer power of 2 (e.g., 2, 4, 8, 16, etc.). # Output * A list of complex numbers of size (N), representing the discrete Fourier transform of the input. # Constraints * The size of the input list (N) ranges from 1 to (2^{14}) (i.e., 16384). * You should handle edge cases where the input list contains only one element. # Performance Requirements * Your implementation must run with a time complexity of (O(N log N)) and a space complexity of (O(N)). # Example ```python example_signal = [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] print(custom_fft(example_signal)) # Expected output: [(8+8j), 2j, (2-2j), (-2+0j)] ``` # Additional Context FFT is widely used in applications involving signal processing or solving differential equations. Handling complex-valued inputs and ensuring efficiency are critical to achieving accurate results. Your implementation should replicate the recursive nature of FFT, handle base cases correctly, and accurately compute the discrete Fourier transform for a power-of-2 length input.","solution":"import cmath from typing import List def custom_fft(signal: List[complex]) -> List[complex]: N = len(signal) # Base case if N == 1: return signal # Ensure the length is a power of 2 assert N & (N-1) == 0, \\"The length of the input signal must be a power of 2.\\" # Split the input into even and odd indexed elements even = custom_fft(signal[0::2]) odd = custom_fft(signal[1::2]) combined = [0] * N for k in range(N // 2): t = cmath.exp(-2j * cmath.pi * k / N) * odd[k] combined[k] = even[k] + t combined[k + N // 2] = even[k] - t return combined"},{"question":"# Scenario You are tasked with designing a utility for a low-level system that manages feature flags using bitwise operations. Each feature flag is represented by a bit in a 32-bit integer. You need to evaluate which flags are set, enable new features, disable features, and update feature statuses. # Problem Statement Implement a function `feature_flag_manager` that accepts a list of operations and a 32-bit integer representing the feature flags. The operations will be formatted as tuples, where the first element is an operation type (`\\"get\\"`, `\\"set\\"`, `\\"clear\\"`, `\\"update\\"`), the second element is the index of the bit (0-31), and the third is the value (0 or 1) for `\\"update\\"` operations (ignored for other types). The function should return a list of results for `\\"get\\"` operations and the final state of the integer after all operations have been applied. Function Signature: ```python def feature_flag_manager(flags: int, operations: List[Tuple[str, int, Optional[int]]]) -> Tuple[List[bool], int]: ``` Input: - `flags`: int: A 32-bit integer representing the initial state of the feature flags. - `operations`: List of tuples, where each tuple is: - `\\"get\\"`: Check if the bit at the given index is set. - `\\"set\\"`: Set the bit at the given index. - `\\"clear\\"`: Clear the bit at the given index. - `\\"update\\"`: Update the bit at the given index with the provided value (second element in tuple). Output: - A tuple where the first element is a list of results for `\\"get\\"` operations (in the order they appeared), and the second element is the final integer after all operations have been applied. Constraints: 1. Flags will always be a non-negative integer. 2. Operations list will have at most 1000 operations. 3. Each bit index will be in the range 0-31. Example: ```python # Given the initial flags set to 0: # Apply: set bit 1, get bit 1, clear bit 1, get bit 1, update bit 2 to 1 flags = 0 operations = [ (\\"set\\", 1, None), (\\"get\\", 1, None), (\\"clear\\", 1, None), (\\"get\\", 1, None), (\\"update\\", 2, 1) ] # Expected Output ([True, False], 4) # Explanation: # After setting bit 1: flags = 2 # Check bit 1: returns True # Clear bit 1: flags = 0 # Check bit 1: returns False # Update bit 2 to 1: flags = 4 ``` # Implementation Tips: 1. Utilize the provided bit manipulation functions: `get_bit`, `set_bit`, `clear_bit`, and `update_bit`. 2. Remember to handle cases where a bit index is out of bounds gracefully (for this problem, assume indices are always valid).","solution":"from typing import List, Tuple, Optional def feature_flag_manager(flags: int, operations: List[Tuple[str, int, Optional[int]]]) -> Tuple[List[bool], int]: results = [] def get_bit(value, bit_index): return (value >> bit_index) & 1 def set_bit(value, bit_index): return value | (1 << bit_index) def clear_bit(value, bit_index): return value & ~(1 << bit_index) def update_bit(value, bit_index, bit_value): return (value & ~(1 << bit_index)) | (bit_value << bit_index) for operation in operations: op_type = operation[0] bit_index = operation[1] if op_type == \\"get\\": results.append(bool(get_bit(flags, bit_index))) elif op_type == \\"set\\": flags = set_bit(flags, bit_index) elif op_type == \\"clear\\": flags = clear_bit(flags, bit_index) elif op_type == \\"update\\": bit_value = operation[2] flags = update_bit(flags, bit_index, bit_value) return (results, flags)"},{"question":"# Problem: Implementing Heap Sort You are required to implement the Heap Sort algorithm. You must provide two implementations: one using a Max Heap and another using a Min Heap. Both implementations should sort an array of integers in ascending order. Your task is to define two functions - `heap_sort_max` and `heap_sort_min` - that follow these specifications. Function 1: `heap_sort_max` * **Input**: List of integers, `arr`. * **Output**: The list sorted in ascending order using Max Heap. Function 2: `heap_sort_min` * **Input**: List of integers, `arr`. * **Output**: The list sorted in ascending order using Min Heap. # Constraints * The input array length `n` will be (1 le n le 10^5). * The integer values in the array will be within the range of (-10^6) to (10^6). # Example 1. **Example 1**: * **Input**: `[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]` * **Output for heap_sort_max**: `[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]` * **Output for heap_sort_min**: `[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]` 2. **Example 2**: * **Input**: `[9, 8, 7, 6, 5, 4, 3, 2, 1]` * **Output for heap_sort_max**: `[1, 2, 3, 4, 5, 6, 7, 8, 9]` * **Output for heap_sort_min**: `[1, 2, 3, 4, 5, 6, 7, 8, 9]` # Additional Information If duplicate elements are present, they should appear in the same relative order.","solution":"def heapify_max(arr, n, i): Creates a max heap from a given subtree. largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify_max(arr, n, largest) def heap_sort_max(arr): Sorts an array in ascending order using max heap. n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify_max(arr, n, i) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify_max(arr, i, 0) return arr def heapify_min(arr, n, i): Creates a min heap from a given subtree. smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] < arr[smallest]: smallest = left if right < n and arr[right] < arr[smallest]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] heapify_min(arr, n, smallest) def heap_sort_min(arr): Sorts an array in ascending order using min heap. n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify_min(arr, n, i) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify_min(arr, i, 0) arr.reverse() return arr"},{"question":"# Cycle Sort Implementation and Analysis You are given the Cycle Sort algorithm described in the analysis. Your task is to implement the function and ensure it handles various edge cases correctly. The function should take an array of integers, `arr`, and return a sorted array using the cycle sort technique. Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: ``` Input * `arr` - A list of integers of length N where 1 <= N <= 10^4. Output * The sorted list of integers. Example ```python assert cycle_sort([3, 5, 2, 1, 4]) == [1, 2, 3, 4, 5] assert cycle_sort([1, 1, 1, 1, 1]) == [1, 1, 1, 1, 1] assert cycle_sort([9, 1, 8, 7, 2]) == [1, 2, 7, 8, 9] ``` Constraints & Requirements * The function should handle duplicate values gracefully. * Ensure the solution has O(1) additional space complexity. * Aim for minimal write operations reflecting Cycle Sort\'s properties. Performance Requirements * The solution should be efficient within a time complexity of O(N^2). * Handle input sizes up to 10,000 elements within the acceptable execution time. # Task Implement the `cycle_sort` function and test it with different cases, ensuring correct handling of possible edge cases and verifying that the result is sorted correctly.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: Cycle sort implementation to sort an array of integers. n = len(arr) for cycle_start in range(0, n - 1): item = arr[cycle_start] pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 if pos == cycle_start: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Question: Path Existence in a Directed Graph You are provided with a directed graph of `V` vertices. Your task is to write a function that determines whether there exists a path between two given nodes in this graph. Function Signature: ```python def is_path_exists(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: ``` Input: * `vertex_count` (int): The number of vertices in the graph (0-indexed, from `0` to `vertex_count - 1`). * `edges` (List[Tuple[int, int]]): A list of directed edges in the graph where each edge is represented as a tuple `(u, v)` indicating an edge from vertex `u` to vertex `v`. * `source` (int): The starting vertex. * `target` (int): The target vertex. Output: * `bool`: Return `True` if there exists a path from `source` to `target`, otherwise return `False`. Constraints: * `0 <= vertex_count <= 10⁴` * `0 <= number of edges <= 5 * 10⁴` * `0 <= u, v, source, target < vertex_count` Example: ```python assert is_path_exists(4, [(0, 1), (1, 2), (2, 3)], 0, 3) == True assert is_path_exists(4, [(0, 1), (1, 2), (3, 2)], 0, 3) == False ``` Note: You can use an iterative or recursive approach to implement the DFS algorithm for this problem. Ensure to handle common edge cases such as cycles in the graph or the graph being disconnected.","solution":"from typing import List, Tuple def is_path_exists(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: from collections import defaultdict, deque # Create graph as adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Perform BFS to find path from source to target visited = [False] * vertex_count queue = deque([source]) visited[source] = True while queue: current = queue.popleft() if current == target: return True for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return False"},{"question":"# Question: Implement a Custom Gap Sequence Shell Sort Shell Sort is an efficient sorting algorithm that generalizes insertion sort to allow the exchange of far apart elements. The algorithm uses a sequence of increments to segment the data, known as the gap sequence. The provided Shell Sort implementation uses a basic gap sequence where the gap is initially half of the array length and is reduced by half each iteration until it reaches 1. Your task is to implement an advanced version of Shell Sort using the following gap sequence proposed by Sedgewick: `1, 5, 19, 41, 109, ...` Specifically, the gap sequence is defined by the formula: if `k % 2 == 0`, gap = `9 * 2^k - 9 * 2^(k/2) + 1` if `k % 2 != 0`, gap = `8 * 2^k - 6 * 2^((k+1)/2) + 1` # Function Signature ```python def advanced_shell_sort(arr): pass ``` # Input * `arr`: a list of integers (0 <= len(arr) <= 10^5) to be sorted. # Output * A sorted list of integers. # Example ```python advanced_shell_sort([23, 42, 4, 16, 8, 15]) # Output: [4, 8, 15, 16, 23, 42] ``` # Constraints 1. The input list may contain duplicate elements. 2. The algorithm should maintain an average time complexity close to O(n log² n). # Performance Requirements * The implementation should handle arrays up to length 100,000 efficiently. * Minimize extra memory usage and ensure the algorithm works in-place. # Edge Cases * Test with an empty array. * Test with arrays containing only one or two elements. * Test with arrays where all elements are the same. Implement the `advanced_shell_sort` function to meet the above requirements.","solution":"def advanced_shell_sort(arr): Perform Shell Sort using the Sedgewick gap sequence. # Generate gap sequence according to Sedgewick\'s formula def generate_gaps(n): gaps = [] k = 0 while True: if k % 2 == 0: gap = 9 * (2 ** k) - 9 * (2 ** (k // 2)) + 1 else: gap = 8 * (2 ** k) - 6 * (2 ** ((k + 1) // 2)) + 1 if gap > n: break gaps.append(gap) k += 1 return gaps[::-1] # reverse the gaps to start from the largest gap n = len(arr) if n <= 1: return arr gaps = generate_gaps(n) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Context You are tasked with improving the RSA encryption key generation process to address two primary issues: performance and security. # Problem Statement Enhance the `generate_key` function to make the RSA key generation process more efficient and secure. Specifically, you need to implement the following improvements: 1. **Prime Number Generation**: Replace the current `is_prime` function with a more efficient primality testing method. 2. **Modular Inverse Calculation**: Implement the Extended Euclidean Algorithm for a faster computation of the modular inverse. # Function Signature Modify the following two functions in the given code: ```python def generate_key(k, seed=None): Enhanced RSA key generating algorithm. k : int : the number of bits in n. seed : int, optional : Seed for reproducibility. Returns tuple(n, e, d) def modinv(a, m): Extended Euclidean Algorithm for modular inverse. a : int : number to find the inverse of. m : int : modulus. Returns int : modular inverse of a mod m. ``` # Expected Input and Output `generate_key(k, seed=None)` - **Input**: - `k`: Integer specifying the bit size for `n`. - `seed`: Optional integer for reproducibility. - **Output**: - Returns a tuple `(n, e, d)`, where: - `n` is the modulus. - `e` is the public exponent. - `d` is the private exponent. `modinv(a, m)` - **Input**: - `a`: Integer whose modular inverse is to be calculated. - `m`: Modulus. - **Output**: - Returns the modular inverse of `a` mod `m`. # Constraints - `k` is typically large (e.g., 128 bits or more for secure encryption). - Prime numbers used should be securely generated. - Efficiency and security improvements should not compromise the correctness. Example Usage ```python # Example usage of enhanced generate_key n, e, d = generate_key(16) data = 20 encrypted = pow(data, e, n) decrypted = pow(encrypted, d, n) assert decrypted == data # Example usage of modinv a, m = 17, 3120 assert modinv(a, m) * a % m == 1 ```","solution":"import random from sympy import isprime def generate_key(k, seed=None): Enhanced RSA key generating algorithm. k : int : the number of bits in n. seed : int, optional : Seed for reproducibility. Returns tuple(n, e, d) if seed is not None: random.seed(seed) def generate_large_prime(bits): while True: p = random.getrandbits(bits) if isprime(p): return p p = generate_large_prime(k // 2) q = generate_large_prime(k // 2) n = p * q phi_n = (p - 1) * (q - 1) e = 65537 # Commonly used prime exponent d = modinv(e, phi_n) return n, e, d def modinv(a, m): Extended Euclidean Algorithm for modular inverse. a : int : number to find the inverse of. m : int : modulus. Returns int : modular inverse of a mod m. g, x, _ = extended_gcd(a, m) if g != 1: raise ValueError(\\"Modular inverse does not exist\\") else: return x % m def extended_gcd(a, b): Extended Euclidean Algorithm to compute the gcd of a and b, as well as the coefficients for the linear combination. if a == 0: return b, 0, 1 else: g, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return g, x, y"},{"question":"# Question: Implement Optimized Dijkstra\'s Algorithm You are given a programming task to implement an optimized version of Dijkstra\'s algorithm. This variant uses a priority queue to improve efficiency. Objective Given a directed graph represented as an adjacency list, you need to calculate the shortest paths from a specified starting node to all other nodes using Dijkstra\'s algorithm. Function Signature `def optimized_dijkstra(graph: List[List[Tuple[int, int]]], start: int) -> List[int]:` Input * `graph`: A list of lists where `graph[i]` contains tuples (j, w) representing an edge from node `i` to node `j` with weight `w`. * `start`: An integer representing the starting node. Output * Returns a list `dist` where `dist[i]` is the shortest distance from the start node to node `i`. If a node is unreachable, the distance should be represented as infinity (`float(\'inf\')`). Constraints * Assume the graph has `n` nodes labeled from `0` to `n-1`. * The edges have non-negative weights. * The graph can be sparse with some nodes not directly connected to others. Example ```python graph = [ [(1, 4), (2, 1)], # Node 0 connected to Node 1 with weight 4 and to Node 2 with weight 1 [(3, 1)], # Node 1 connected to Node 3 with weight 1 [(1, 2), (3, 5)], # Node 2 connected to Node 1 with weight 2 and to Node 3 with weight 5 [] # Node 3 has no outgoing edges ] start = 0 print(optimized_dijkstra(graph, start)) # Output: [0, 3, 1, 4] ``` Notes 1. Make sure your implementation efficiently handles the priority queue to achieve better performance compared to the naive O(V^2) complexity. 2. Consider using a heap data structure available in Python (`heapq`). # Requirement * Implement and test the provided function using various edge cases and scenarios to ensure its correctness and efficiency.","solution":"import heapq from typing import List, Tuple def optimized_dijkstra(graph: List[List[Tuple[int, int]]], start: int) -> List[int]: Implements an optimized Dijkstra\'s algorithm using a priority queue. Returns the shortest distances from the start node to all other nodes in the graph. n = len(graph) dist = [float(\'inf\')] * n dist[start] = 0 priority_queue = [(0, start)] # (distance, node) while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) return dist"},{"question":"**Context**: You are helping to develop a software system that needs to efficiently retrieve user information based on user IDs. User IDs are sorted in ascending order. To optimize the retrieval process, you decide to use the Ternary Search algorithm due to its theoretical efficiency in reducing search spaces. **Problem Statement**: Write a function `find_user_by_id(left: int, right: int, user_id: int, user_list: List[int]) -> int` that searches for a given `user_id` in `user_list` using ternary search. The function should return the index of the `user_id` if found, and `-1` otherwise. # Function Signature ```python def find_user_by_id(left: int, right: int, user_id: int, user_list: list) -> int: ``` **Input**: - `left`: An integer, indicating the starting index of the search range (inclusive). - `right`: An integer, indicating the ending index of the search range (inclusive). - `user_id`: An integer, the ID of the user to be found. - `user_list`: A list of integers sorted in ascending order, representing user IDs. **Output**: - Returns an integer, the index of `user_id` in `user_list` if found, otherwise `-1`. **Constraints**: - `0 <= left <= right < len(user_list)` - `len(user_list) <= 10^6` - `user_id` and all elements in `user_list` are non-negative integers. **Performance Requirements**: - The solution should have a time complexity of O(log3(N)) and space complexity of O(1). # Example Usage ```python # Assuming user_list = [1, 3, 6, 9, 11, 15, 20] print(find_user_by_id(0, 6, 11, [1, 3, 6, 9, 11, 15, 20])) # Should return 4 print(find_user_by_id(0, 6, 2, [1, 3, 6, 9, 11, 15, 20])) # Should return -1 ``` # Additional Notes - Think about how to handle edge cases such as: - An empty user_list. - The `user_id` being at the borders or not present in the list. - Ensure that your code runs efficiently within the provided constraints.","solution":"def find_user_by_id(left, right, user_id, user_list): Uses ternary search to find the index of user_id in user_list. Parameters: left (int): Starting index of the search range (inclusive). right (int): Ending index of the search range (inclusive). user_id (int): The ID of the user to be found. user_list (list of int): List of user IDs sorted in ascending order. Returns: int: The index of user_id in user_list if found, otherwise -1. while left <= right: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if user_list[mid1] == user_id: return mid1 if user_list[mid2] == user_id: return mid2 if user_id < user_list[mid1]: right = mid1 - 1 elif user_id > user_list[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"You need to write a function `partition_linked_list(head: Node, x: int) -> Node` that partitions a singly linked list around a value `x`. All nodes less than `x` should come before nodes greater than or equal to `x`. The relative order of nodes in each partition needs to be preserved. Function Signature: ```python def partition_linked_list(head: Node, x: int) -> Node: ``` # Input: - `head` (Node): The head of a singly linked list. - `x` (int): The partition value. # Output: - Node: The head of the modified linked list after partitioning. # Constraints: - The values of all linked list nodes are integers. - The partition value `x` is also an integer. - The linked list can contain any number of nodes, including zero. # Example: ```python # Nodes definition class Node: def __init__(self, val=None): self.val = int(val) self.next = None # Linked list creation a = Node(3) b = Node(5) c = Node(8) d = Node(5) e = Node(10) f = Node(2) g = Node(1) a.next = b b.next = c c.next = d d.next = e e.next = f f.next = g # Function call partitioned_head = partition_linked_list(a, 5) # Output should rearrange the list into: # 3 -> 2 -> 1 -> 5 -> 8 -> 5 -> 10 (or any valid partition with node values < 5 before >= 5) ``` # Notes: - You may use the provided `Node` class for defining the linked list nodes. - Ensure the function correctly handles edge cases including empty lists and lists where all nodes are either less than or greater than the partition value. - Performance constraints: Your solution should have a time complexity of O(n) and space complexity of O(1).","solution":"class Node: def __init__(self, val=None): self.val = int(val) self.next = None def partition_linked_list(head: Node, x: int) -> Node: if not head: return None # Dummy heads for less and more/equal partitions less_head = Node(0) more_head = Node(0) # Pointers to build the new lists less = less_head more = more_head current = head while current: if current.val < x: less.next = current less = less.next else: more.next = current more = more.next current = current.next # Link the two partitions together less.next = more_head.next # Last node of the more list should point to None more.next = None return less_head.next"},{"question":"# Question You are tasked with developing a function to find the longest substring without repeating characters in a given string. Your implementation should be efficient, using a sliding window approach with hash table optimization to maintain the longest substring dynamically. Requirements: 1. **Function Name**: `find_longest_substring` 2. **Input**: A single string `s` with a maximum length of 10^4 characters. 3. **Output**: A tuple containing an integer representing the length of the longest substring without repeating characters, and the substring itself. # Constraints: - The input string can contain any ASCII characters. - The function must handle edge cases gracefully. - Aim for O(n) time complexity. # Performance Requirements: - The function should operate within linear time constraints relative to the length of the input string. # Examples: 1. **Input**: `\\"abcabcbb\\"` **Output**: `(3, \'abc\')` 2. **Input**: `\\"bbbbb\\"` **Output**: `(1, \'b\')` 3. **Input**: `\\"pwwkew\\"` **Output**: `(3, \'wke\')` # Additional Constraints: - Avoid using any external libraries. - Ensure your solution handles large input sizes efficiently.","solution":"def find_longest_substring(s): Finds the length of the longest substring without repeating characters and the substring itself. Parameters: s (str): Input string Returns: tuple: (length of the longest substring, the longest substring) n = len(s) char_index = {} max_length = 0 start = 0 longest_sub_start = 0 for end in range(n): if s[end] in char_index and char_index[s[end]] >= start: start = char_index[s[end]] + 1 char_index[s[end]] = end current_length = end - start + 1 if current_length > max_length: max_length = current_length longest_sub_start = start longest_substring = s[longest_sub_start:longest_sub_start + max_length] return max_length, longest_substring"},{"question":"In this coding assessment, your task is to implement a function that removes duplicate values from an unsorted singly linked list. You have to solve this problem in two ways: 1. By using an additional data structure (like a set) to store seen values. 2. By modifying the list in place without using any additional data structures. # Function Signature You need to implement the following functions: ```python def remove_dups(head: Node) -> None: Removes duplicates from the linked list using a hash set. Parameters: head (Node): The head node of the linked list. pass def remove_dups_without_set(head: Node) -> None: Removes duplicates from the linked list without using any additional data structures. Parameters: head (Node): The head node of the linked list. pass ``` # Input Format - The input is a singly linked list represented by its head node. - The `Node` class definition is provided. Each node contains an integer value and a reference to the next node. # Output Format - Both functions should modify the linked list in place. They do not return any value. - After calling `remove_dups` or `remove_dups_without_set`, the list should contain only unique values in their original order. # Constraints - The number of nodes in the linked list is in the range `[0, 10^4]`. - Each node\'s value will be a non-negative integer in the range `[0, 10^6]`. # Example 1. **Example with duplicates:** ```python # Input: 1 -> 2 -> 2 -> 3 -> 4 -> 4 -> 5 # After remove_dups or remove_dups_without_set: 1 -> 2 -> 3 -> 4 -> 5 ``` 2. **Example without duplicates:** ```python # Input: 1 -> 2 -> 3 -> 4 -> 5 # After remove_dups or remove_dups_without_set: 1 -> 2 -> 3 -> 4 -> 5 (unchanged) ``` 3. **Empty list:** ```python # Input: None # After remove_dups or remove_dups_without_set: None (unchanged) ``` Implement `remove_dups` and `remove_dups_without_set` functions that meet the above specifications.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_dups(head: Node) -> None: Removes duplicates from the linked list using a hash set. Parameters: head (Node): The head node of the linked list. if not head: return current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: Removes duplicates from the linked list without using any additional data structures. Parameters: head (Node): The head node of the linked list. if not head: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"Scenario You are developing a pathfinding feature for a grid-based puzzle game where a player can only move right or down. The game requires a feature that counts how many unique paths are possible from the top-left corner of the grid to the bottom-right corner. Objective Write a function `count_unique_paths(m, n)` that takes two integers, `m` and `n`, representing the number of rows and columns of the grid. The function should return the number of unique paths from the top-left corner to the bottom-right corner, where only movements allowed are right or down. Input & Output * **Input**: Two positive integers `m` and `n` (`1 <= m, n <= 1000`). * **Output**: An integer representing the number of unique paths. Constraints * Return `0` if either `m` or `n` is less than 1. * Expected time complexity is O(m * n). * Optimize space complexity to O(n) if possible. Example ```python print(count_unique_paths(3, 3)) # Output: 6 print(count_unique_paths(3, 2)) # Output: 3 print(count_unique_paths(1, 1)) # Output: 1 print(count_unique_paths(0, 2)) # Output: 0 ``` Specifications * Handle edge cases like grids with only one row or one column. * Consider ways to optimize memory usage without compromising the algorithm\'s efficiency. * Avoid using overly complex recursive solutions due to potential stack overflow issues. Implement the function `count_unique_paths(m, n)` in Python.","solution":"def count_unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid where movements are restricted to right or down. if m < 1 or n < 1: return 0 # optimizing space complexity to O(n) dp = [1] * n for i in range(1, m): for j in range(1, n): dp[j] += dp[j - 1] return dp[-1]"},{"question":"# Ternary Search Implementation Background Ternary search is a divide and conquer algorithm similar to binary search. It divides an array into three parts using two middle points and recursively or iteratively searches the relevant segment for the target element. This algorithm is particularly useful for sorted arrays and can achieve a better reduction in search space compared to binary search. Problem Statement Given the following implementation of ternary search in Python: ```python def ternary_search(left, right, key, arr): while right >= left: mid1 = left + (right-left) // 3 mid2 = right - (right-left) // 3 if key == arr[mid1]: return mid1 if key == arr[mid2]: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1 ``` Task Enhance the above implementation of ternary search by: 1. Validating the input parameters (e.g., ensuring the array is sorted, `left` and `right` indices are within bounds). 2. Handling edge cases effectively such as: - An empty array. - `left` and `right` values outside the array bounds. - Key not present in the array. Function Specification **Function Name**: `ternary_search` **Input**: - `arr` (list of int): Sorted array of integers. - `left` (int): Starting index of the segment to search within. - `right` (int): Ending index of the segment to search within. - `key` (int): Target element to search for. **Output**: - Returns the index (int) of the key if found, otherwise returns -1. Constraints - The array should be sorted in non-decreasing order. - Values for `left` and `right` should be non-negative and within the array length. - `key` is an integer. Example ```python # Example usage arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 5 print(ternary_search(0, len(arr) - 1, key, arr)) # Output: 4 arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 11 print(ternary_search(0, len(arr) - 1, key, arr)) # Output: -1 ``` Implement the `ternary_search` function ensuring it adheres to the constraints and handles all edge cases appropriately.","solution":"def ternary_search(left, right, key, arr): if not arr: return -1 if left < 0 or right >= len(arr) or left > right: return -1 while right >= left: mid1 = left + (right-left) // 3 mid2 = right - (right-left) // 3 if key == arr[mid1]: return mid1 if key == arr[mid2]: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"You are provided with a list of words and a list of symbol strings. Your task is to process the words such that any occurrence of a symbol within a word is surrounded by square brackets. When matching multiple symbols, prioritize replacing the longest symbol found in the word. # Input: - `words` - List of strings, where each string represents a word. - `symbols` - List of strings, where each string represents a symbol to be found in the words. # Output: - List of strings where each word has the longest matched symbol surrounded by square brackets. # Constraints: - Symbols are case-sensitive. - In case no symbol from the list matches, the word should remain unchanged. - Handle up to 10^5 words and 10^5 symbols efficiently. # Example: Input: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] ``` Output: ```python [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Function Signature: ```python def match_and_bracket_words(words: List[str], symbols: List[str]) -> List[str]: pass ``` # Implementation Requirements: - Function should return a list of processed words with symbols appropriately bracketed. - Consider optimizing search using advanced data structures.","solution":"from typing import List def match_and_bracket_words(words: List[str], symbols: List[str]) -> List[str]: # Sort symbols by length in descending order so we replace with the longest first symbols = sorted(symbols, key=len, reverse=True) symbol_set = set(symbols) # Convert list to set for O(1) lookups def bracket_word(word: str) -> str: for symbol in symbols: if symbol in word: return word.replace(symbol, f\\"[{symbol}]\\") return word return [bracket_word(word) for word in words]"},{"question":"# Bipartite Graph Detection Context: A bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets such that every edge connects a vertex in the first set to a vertex in the second set. Your task is to determine whether a given graph is bipartite, using an adjacency matrix representation of the graph. Task: Implement a function `is_bipartite_graph(adj_matrix)` that takes an adjacency matrix of a graph and returns `True` if the graph is bipartite and `False` otherwise. Input: * `adj_matrix` (List[List[int]]): A square binary matrix representing the graph: * `adj_matrix[i][j] = 1` indicates an edge between vertex `i` and vertex `j`. * `adj_matrix[i][j] = 0` indicates no edge between vertex `i` and vertex `j`. Output: * Returns `True` if the graph is bipartite, `False` otherwise. Constraints: * The maximum number of vertices (n) is 100, where 1 <= n <= 100. Example: ``` adj_matrix = [ [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0] ] is_bipartite_graph(adj_matrix) # Should return: True adj_matrix = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ] is_bipartite_graph(adj_matrix) # Should return: False ``` Tips: * Consider all connected components, as graphs can be disconnected. * Efficiently utilize BFS for color assignment and verification.","solution":"from collections import deque def is_bipartite_graph(adj_matrix): Determines if the given graph represented by an adjacency matrix is bipartite. :param adj_matrix: List[List[int]], where adj_matrix[i][j] = 1 or 0, representing the adjacency matrix of the graph. :return: bool, True if the graph is bipartite, False otherwise. n = len(adj_matrix) colors = [-1] * n # -1 means not colored yet def bfs(start): queue = deque([start]) colors[start] = 0 # Start coloring with 0 while queue: node = queue.popleft() for neighbor in range(n): if adj_matrix[node][neighbor] == 1: if colors[neighbor] == -1: # Not colored colors[neighbor] = 1 - colors[node] # Assign opposite color queue.append(neighbor) elif colors[neighbor] == colors[node]: # Same color as current node return False return True for i in range(n): if colors[i] == -1: # Not colored yet, means a new component if not bfs(i): return False return True"},{"question":"# Question: Optimized Bubble Sort Implementation # Bubble Sort is a fundamental sorting algorithm. Your task is to implement an optimized version of the original bubble sort algorithm. In this suited-up version, modifications should include stopping the algorithm if the array becomes sorted before all passes are full. This will enhance its performance on nearly sorted datasets. You will design a function `optimized_bubble_sort` that sorts an array of integers and meets the following requirements: * Function Signature: `def optimized_bubble_sort(arr: List[int]) -> List[int]:` * Input: A list of integers `arr` where ( 1 leq len(arr) leq 10^3 ) and ( -10^3 leq arr[i] leq 10^3 ) * Output: The sorted list of integers in non-decreasing order. * Constraints: Implement the sorting algorithm with optimizations that would enhance its performance. Example: ```python assert optimized_bubble_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert optimized_bubble_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] ``` **Notes**: - Your implementation should include the early termination optimization. - Consider edge cases such as already sorted arrays, reversed arrays, and arrays with all identical elements.","solution":"from typing import List def optimized_bubble_sort(arr: List[int]) -> List[int]: Perform an optimized bubble sort on the list of integers. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr"},{"question":"Context: You have been hired by a company to design a playlist management system. This system will allow users to manage a list of their favorite songs efficiently. You decide to use a Doubly Linked List for its flexibility in traversal and efficient operations at both ends. Each song has an associated unique ID and title. Task: Implement a Doubly Linked List class and a function to sort the songs by their titles alphabetically. Given the constraints of the playlist management system, your solution should balance the efficiency of insertion, deletion, and sorting. Requirements: 1. **Node Class**: Create a `DoublyLinkedListNode` class with attributes for: * `value`: A dictionary with song ID and title. * `next`: Reference to the next node. * `prev`: Reference to the previous node. 2. **Doubly Linked List Class**: Implement a `DoublyLinkedList` class with methods for: * Adding a song at the end. * Deleting a song by its ID. * Sorting the list of songs by their titles alphabetically. 3. **Sort Function**: Implement a function in the `DoublyLinkedList` class to sort the songs by their titles using a merge sort algorithm (to achieve O(n log n) time complexity). Input Format: * The `add_song` method takes a dictionary with two keys: \'id\' (integer) and \'title\' (string). * The `delete_song` method takes an integer ID of the song to be deleted. Constraints: * Title strings will not be empty. * Song IDs will be unique and positive integers. * The list contains at least one song. Expected Output: * `sort_songs` should update the linked list so that songs are sorted alphabetically by title. Class and Function Signatures: ```python class DoublyLinkedListNode: def __init__(self, value: dict): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None def add_song(self, song: dict) -> None: # Implementation here def delete_song(self, song_id: int) -> None: # Implementation here def sort_songs(self) -> None: # Implementation here ```","solution":"class DoublyLinkedListNode: def __init__(self, value: dict): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None def add_song(self, song: dict) -> None: new_node = DoublyLinkedListNode(song) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node new_node.prev = current def delete_song(self, song_id: int) -> None: current = self.head while current: if current.value[\'id\'] == song_id: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: # If head needs to be removed self.head = current.next break current = current.next def sort_songs(self) -> None: if self.head is None or self.head.next is None: return self.head = self._merge_sort(self.head) def _split(self, head): fast = slow = head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next second_half = slow.next slow.next = None if second_half: second_half.prev = None return head, second_half def _merge(self, left, right): if not left: return right if not right: return left if left.value[\'title\'] <= right.value[\'title\']: result = left result.next = self._merge(left.next, right) if result.next: result.next.prev = result else: result = right result.next = self._merge(left, right.next) if result.next: result.next.prev = result return result def _merge_sort(self, head): if not head or not head.next: return head left, right = self._split(head) left = self._merge_sort(left) right = self._merge_sort(right) return self._merge(left, right)"},{"question":"# Stacks: Checking Order Validity You are tasked with writing a function that verifies whether the elements in a stack are in ascending order from bottom to top. This is a critical check in systems that require order constraints preserved in a LIFO data structure. The stack is implemented using Python lists, where the last element in the list (index -1) is considered the top of the stack. Your function must return a boolean indicating whether the stack elements are in ascending order without permanently altering the stack. # Input and Output * **Input**: A single list `stack` where elements are pushed and popped from the end of the list. * **Output**: A boolean value `True` if the stack is sorted in ascending order from bottom to top, otherwise `False`. ```python def is_sorted(stack): # Your code here ``` # Constraints and Requirements * You must not alter the contents or order of the original stack permanently. * Aim for an O(n) time complexity solution. * Minimize additional space usage beyond necessary temporary variables. * Handle edge cases as described. # Example ```python # Example 1: stack = [1, 2, 3, 4, 5] print(is_sorted(stack)) # Output: True # Example 2: stack = [5, 3, 4, 1, 2] print(is_sorted(stack)) # Output: False # Example 3: stack = [] print(is_sorted(stack)) # Output: True # Example 4: stack = [10] print(is_sorted(stack)) # Output: True ``` Focus on writing a solution that adheres to the provided constraints and efficiently determines the order of the stack elements.","solution":"def is_sorted(stack): Verifies if the elements in the stack are in ascending order from bottom to top. Parameters: stack (list): The stack represented as a list. Returns: bool: True if the stack is sorted in ascending order, otherwise False. # Edge case for an empty stack or a stack with one item if len(stack) <= 1: return True # Check ascending order from bottom to top of stack for i in range(len(stack) - 1): if stack[i] > stack[i + 1]: return False return True"},{"question":"Implement an efficient version of the Bucket Sort algorithm that can handle extremely large input arrays and optimize for varying distributions. Your task is to complete the function `optimized_bucket_sort` which takes an array of integers within a specified range and sorts it using the bucket sort technique. For the sorting within each bucket, you can use a sorting algorithm of your choice. **Function Signature:** ```python def optimized_bucket_sort(arr: List[int], num_buckets: int) -> List[int]: ``` **Input:** * `arr`: A list of integers; the range of integers is between 0 to max(arr). * `num_buckets`: An integer denoting the number of buckets to use for sorting. **Output:** * Returns a sorted list of integers. **Constraints:** * 1 <= len(arr) <= 10^6 * 0 <= arr[i] <= 10^6 * 1 <= num_buckets <= min(len(arr), 1000) **Performance Requirement:** * Your implementation should handle the worst-case scenarios efficiently and should complete within a reasonable time for large inputs. **Example:** ```python input_array = [78, 52, 88, 34, 99, 12, 76, 45] num_buckets = 5 optimized_bucket_sort(input_array, num_buckets) # Output: [12, 34, 45, 52, 76, 78, 88, 99] ``` **Additional Notes:** * Consider the distribution of input elements while deciding the number of buckets. * Make sure to handle edge cases and test your function for various input scenarios to ensure its accuracy.","solution":"from typing import List def optimized_bucket_sort(arr: List[int], num_buckets: int) -> List[int]: Sorts the input array using the bucket sort algorithm with the specified number of buckets. :param arr: List of integers to be sorted :param num_buckets: Number of buckets to use for sorting :return: A sorted list of integers if not arr or num_buckets <= 0: return arr # Find the range of the array max_val = max(arr) # Create the buckets bucket_size = (max_val + 1) // num_buckets buckets = [[] for _ in range(num_buckets)] # Distribute the elements into buckets for num in arr: index = min(num // bucket_size, num_buckets - 1) # Ensure the index is within range buckets[index].append(num) # Sort each bucket and collect the results sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"# Matrix Chain Multiplication - Minimal Operations Given a sequence of matrices, the goal is to find the most efficient way to multiply these matrices together with the minimal number of scalar multiplications. Matrix multiplication is associative, meaning you can multiply matrices in any order, but the number of operations required can vary drastically. Problem Description Write a function `optimal_matrix_chain_order(dimensions)` that determines the optimal order of matrix multiplication. Given an array `dimensions` where the `i-th` matrix has dimensions `dimensions[i-1] x dimensions[i]`, the function should return the minimum number of multiplications needed to multiply the chain and a list representing the optimal order of multiplication. # Input * `dimensions`: A list of integers `[p0, p1, p2, ..., pn]` representing dimensions of matrices `A1, A2, ..., An`, where matrix `Ai` has dimensions `pi-1 x pi`. # Output * An integer representing the minimum number of multiplications needed. * A string representation of the optimal parenthesization order. # Constraints 1. `2 <= len(dimensions) <= 100` - The length of the dimension list. 2. `1 <= dimensions[i] <= 100` - The value of each dimension. # Example ```python def optimal_matrix_chain_order(dimensions): # Define your function implementation here # Example Test Cases dimensions = [30, 35, 15, 5, 10, 20, 25] min_operations, order = optimal_matrix_chain_order(dimensions) print(min_operations) # Output: 15125 print(order) # Output: (((A1(A2A3))((A4A5)A6))) ``` # Requirements 1. Your function should use dynamic programming to tackle this problem. 2. Ensure that you handle edge cases such as a single matrix or very large matrices effectively. 3. The output parenthesization should match the exact operations order to achieve minimal multiplications. # Hint - Construct a solution similar to the given code snippet\'s `matrix_chain_order` for finding the minimal multiplications. - Utilize auxiliary space to store the indices of optimal breaks. - Implement a helper function to format the optimal solution in a readable string form.","solution":"def optimal_matrix_chain_order(dimensions): n = len(dimensions) - 1 # m[i][j] represents the minimum number of multiplications needed to compute the product of matrices Ai through Aj m = [[0 for _ in range(n+1)] for _ in range(n+1)] # s[i][j] represents the index of the matrix after which the product is split in an optimal parenthesization s = [[0 for _ in range(n+1)] for _ in range(n+1)] for length in range(2, n+1): # length is the current length of the chain for i in range(1, n-length+2): # i is the starting index j = i + length - 1 # j is the ending index m[i][j] = float(\'inf\') for k in range(i, j): # k is the index at which we split the product q = m[i][k] + m[k+1][j] + dimensions[i-1]*dimensions[k]*dimensions[j] if q < m[i][j]: m[i][j] = q s[i][j] = k def get_optimal_order(s, i, j): if i == j: return f\\"A{i}\\" else: k = s[i][j] left = get_optimal_order(s, i, k) right = get_optimal_order(s, k+1, j) return f\\"({left}{right})\\" min_operations = m[1][n] optimal_order = get_optimal_order(s, 1, n) return min_operations, optimal_order"},{"question":"# Palindrome Checker with Additional Constraints Background A palindrome is a string that reads the same forward and backward, ignoring non-alphanumeric characters and case differences. Palindromes can be used in various text-processing applications, data validation, and more. Task Given a string, write a function `is_custom_palindrome(s)` that determines whether it is a palindrome, considering only alphanumeric characters and ignoring cases. Additionally, this function should handle very large strings efficiently, optimizing both time and space complexity. # Input * `s`: A string which can contain alphabetic characters, digits, punctuation marks, and spaces. * Constraints: * The string length can be up to `10^5`. # Output * `True` if `s` is a palindrome, `False` otherwise. # Examples ```python # Example 1 input_string = \\"A man, a plan, a canal: Panama\\" print(is_custom_palindrome(input_string)) # Output: True # Example 2 input_string = \\"race a car\\" print(is_custom_palindrome(input_string)) # Output: False # Example 3 input_string = \\"\\" # an empty string print(is_custom_palindrome(input_string)) # Output: True ``` # Requirements 1. **Efficiency**: Aim for an algorithm with `O(n)` time complexity and minimal additional space usage. 2. **Edge handling**: Ensure the function correctly handles edge cases like empty strings and those with only non-alphanumeric characters.","solution":"def is_custom_palindrome(s): Determines if a given string is a palindrome, considering only alphanumeric characters and ignoring case. Parameters: s (str): The input string. Returns: bool: True if the string is a palindrome, False otherwise. left, right = 0, len(s) - 1 while left < right: while left < right and not s[left].isalnum(): left += 1 while left < right and not s[right].isalnum(): right -= 1 if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"**Problem Statement: Jump Search Implementation** You are given a sorted array `arr` and an integer `target`. Your task is to implement the `jump_search` function to find the index of the `target` in the `arr`. If the `target` is not present in the array, return `-1`. The `jump_search` function should follow these steps: 1. Determine the block size based on the length of the array. 2. Traverse the array in blocks to locate the block that may contain the `target`. 3. Perform a linear search within the identified block to find the precise index of the `target`. # Input Format: - `arr`: A list of integers, representing a sorted array. - `target`: An integer, representing the value to search for in the array. # Output Format: - An integer representing the index of the `target` in the array. If the `target` is not found, return `-1`. # Constraints: - The length of `arr` will be between `1` and `10^5`. - Each element in `arr` will be between `-10^9` and `10^9`. - The `target` will also be an integer between `-10^9` and `10^9`. # Example: ```python # Example 1 arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21] target = 15 # Output: 7 # Example 2 arr = [2, 4, 6, 8, 10] target = 1 # Output: -1 ``` # Implementation Guidelines: 1. Import the `math` module to calculate the block size. 2. Check if the `target` is larger than the last element in `arr`. 3. Traverse the array in blocks of size √n. 4. Perform linear search within the largest located block to find the index of the `target`. # Pseudocode: 1. Calculate `block_size` as `floor(sqrt(length of arr))`. 2. Initialize `block_prev` to `0` and `block` to `block_size`. 3. Iterate through the array in steps of `block_size` to find the block that might contain the `target`. 4. Use a linear search within the identified block. 5. Return the index of the `target` if found, otherwise return `-1`. Implement and test your function using the template below. ```python def jump_search(arr, target): import math length = len(arr) block_size = int(math.sqrt(length)) block_prev = 0 block = block_size if arr[length - 1] < target: return -1 while block <= length and arr[block - 1] < target: block_prev = block block += block_size while block_prev < min(block, length) and arr[block_prev] < target: block_prev += 1 if block_prev == min(block, length): return -1 if arr[block_prev] == target: return block_prev return -1 ```","solution":"def jump_search(arr, target): import math length = len(arr) if length == 0: return -1 block_size = int(math.sqrt(length)) block_prev = 0 block = block_size while block < length and arr[min(block, length) - 1] < target: block_prev = block block += block_size for i in range(block_prev, min(block, length)): if arr[i] == target: return i return -1"},{"question":"You are required to implement a class `WordDictionary` that supports adding new words and searching for a word, where the search can be for a literal word or a pattern. A pattern can include the wildcard character `.` which matches any single character. Class Definition ```python class WordDictionary: def __init__(self): pass def add_word(self, word: str) -> None: pass def search(self, word: str) -> bool: pass ``` Method Descriptions 1. **add_word(word: str) -> None**: - Adds the word to the data structure. 2. **search(word: str) -> bool**: - Returns `True` if the word is in the data structure, otherwise returns `False`. A word may contain the wildcard character `.` which can be matched with any letter. Constraints * All words will consist only of lowercase letters. * The length of each word will be between `1` and `500`. * Number of add_word and search operations will not exceed `3 * 10^4`. # Example ```python wordDictionary = WordDictionary() wordDictionary.add_word(\\"bad\\") wordDictionary.add_word(\\"dad\\") wordDictionary.add_word(\\"mad\\") print(wordDictionary.search(\\"pad\\")) # Output: False print(wordDictionary.search(\\"bad\\")) # Output: True print(wordDictionary.search(\\".ad\\")) # Output: True print(wordDictionary.search(\\"b..\\")) # Output: True ``` **Note**: * The search word `\\"pad\\"` does not match any word in the dictionary, so it returns `False`. * The search word `\\"bad\\"` is exactly in the dictionary, so it returns `True`. * The search word `\\".ad\\"` matches `bad`, `dad`, and `mad` in the dictionary, so it returns `True`. * The search word `\\"b..\\"` matches `bad` in the dictionary, so it returns `True`. The data structure should be implemented efficiently to handle a large number of add and search operations.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_in_node(word, self.root) def _search_in_node(self, word: str, node: TrieNode) -> bool: for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if self._search_in_node(word[i+1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word"},{"question":"You are tasked with implementing a function that finds the most frequent element(s) in an array, known as the mode(s). In case of a tie between elements, your function should return all of them. Function Signature ```python def find_modes(arr: List[int]) -> List[int]: pass ``` Input - `arr` (List[int]): A list of integers. Output - Returns a list of integers, containing the mode(s) of the input array. Constraints - The input list `arr` will have a length of at most 10^5. - The elements in `arr` will be integers between -10^6 and 10^6. Example - `find_modes([1, 1, 2, 2, 3, 4])` should return `[1, 2]` - `find_modes([4, 4, 1, 2, 2, 3, 1])` should return `[1, 2, 4]` - `find_modes([])` should return `[]` (an empty list for an empty input) Note Your implementation should be efficient with a time complexity of O(n) and a space complexity of O(n). Requirements 1. Use a frequency dictionary to count the occurrences of each element. 2. Identify the maximum count from the frequency dictionary. 3. Compile and return a list of elements that have the maximum count.","solution":"from typing import List from collections import Counter def find_modes(arr: List[int]) -> List[int]: if not arr: return [] frequency = Counter(arr) max_count = max(frequency.values()) modes = [key for key, count in frequency.items() if count == max_count] return modes"},{"question":"# Scenario You work at a tech company that specializes in data communication. Your team is developing a new protocol to detect and correct errors in transmitted binary data. A key part of your task involves determining the minimal number of bit flips needed to transform one binary message into another, which is crucial for determining the error-distance between two binary sequences. # Coding Task Write a function that determines the minimal number of bits you would need to flip to convert integer `A` to integer `B`. Function Signature ```python def count_flips_to_convert(a: int, b: int) -> int: ``` Input - `a`: An integer A (0 <= a <= 2^31 - 1). - `b`: An integer B (0 <= b <= 2^31 - 1). Both inputs will be non-negative integers within the range of a 32-bit unsigned integer. Output - Returns the minimal number of bit flips required to convert `a` to `b`. Examples ```python assert count_flips_to_convert(29, 15) == 2 assert count_flips_to_convert(10, 20) == 4 assert count_flips_to_convert(7, 0) == 3 assert count_flips_to_convert(0, 31) == 5 assert count_flips_to_convert(1000000, 1000000) == 0 ``` # Constraints 1. The solution must operate within O(k) time complexity where k is the number of bits in the integers. 2. The function should use constant space, i.e., O(1) auxiliary space. # Notes 1. Use of built-in functions to assist with bit manipulation is permitted. 2. Consider edge cases like when both integers are the same or when one of the integers is 0.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the minimal number of bit flips required to convert integer a to integer b. # XOR a and b, the result will have bits set where a and b differ xor = a ^ b # Count the number of set bits (which represents the differing bits) count = 0 while xor: count += xor & 1 xor >>= 1 return count"},{"question":"Context: Given a binary tree, you need to determine its maximum depth. The maximum depth is defined as the number of nodes along the longest path from the root node down to the farthest leaf node. Requirements: Implement a function `max_height` that calculates the maximum depth of a binary tree. Specifications: * **Input**: - `root`: A `TreeNode` object representing the root of the binary tree. * **Output**: - An integer representing the maximum depth of the tree. * **Function Signature**: - `def max_height(root: TreeNode) -> int:` Constraints: 1. The number of nodes in the tree is in the range [0, 10^4]. 2. Each node has a unique integer value. Example: Consider the following binary tree: ``` 10 / 12 15 / / 25 30 36 100 ``` Calling `max_height` on this tree should return `4`, as the longest path is from the root (10) to the leaf (100) via nodes 12 and 25. Edge Cases to Consider: 1. The tree is empty (root is `None`). 2. The tree contains only one node (only root without any children). Additional Information: - Ensure that your implementation efficiently handles large and wide trees. - Optimize space and time complexity where possible. Implementation Details: - You may use a level-order traversal (breadth-first search) to determine the maximum depth of the tree. - Consider using `collections.deque` for your queue to optimize append and pop operations.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_height(root: TreeNode) -> int: if not root: return 0 from collections import deque queue = deque([(root, 1)]) max_depth = 0 while queue: node, depth = queue.popleft() if node: max_depth = max(max_depth, depth) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return max_depth"},{"question":"**Euler\'s Totient Function Calculation** Your task is to implement the function `euler_totient(n)` that computes Euler\'s totient function for a given integer `n`, using the algorithm structure detailed above. The totient function, denoted ϕ(n), counts the integers from 1 to n that are coprime with `n`. # Input - A single integer `n` (1 ≤ n ≤ 10^6) # Output - Return the value of ϕ(n). # Example ```python assert euler_totient(1) == 1 assert euler_totient(5) == 4 assert euler_totient(10) == 4 assert euler_totient(12) == 4 assert euler_totient(100) == 40 ``` # Constraints - The solution should be optimized to run within the time limit for large values of `n` up to `1,000,000`. - Consider edge cases, such as small values of `n` and prime numbers. # Performance Requirements - The implementation should have a maximum time complexity of O(sqrt(n)).","solution":"def euler_totient(n): Computes Euler\'s Totient function for a given integer n. if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result"},{"question":"# Bogo Sort Timing Challenge Given the inefficiency and randomness of the Bogo Sort algorithm, it is critical to handle edge cases and understand its limitations. Your task is to implement an improved version of Bogo Sort that can identify certain optimizations and handle typical scenarios more effectively. The exercise also includes timing the Bogo Sort process to ensure it is not running indefinitely. Function Signature ```python def bogo_sort_timed(arr: List[int], timeout: int = 10) -> List[int]: Sorts the array using Bogo Sort algorithm with added timeout functionality. If the array cannot be sorted within the timeout limit, the function returns the array in its current state. Args: arr : List[int] - The list of integers to be sorted. timeout : int - The timeout limit in seconds. Returns: List[int] - Sorted list or partially sorted list after timeout. ``` Input * `arr`: A list of integers. * `timeout`: The maximum number of seconds the function should continue attempting to sort before stopping. Output * A sorted list if sorted within the timeout limit, or the partially sorted list if the timeout is reached. Constraints * The list can have up to 10 elements (n <= 10). * Each element in the list will be an integer within the range [-10^6, 10^6]. Example ```python # Example input with timeout of 5 seconds bogo_sort_timed([3, 2, 1, 4], 5) ``` Requirements 1. Implement necessary import statements and use them efficiently to measure time. 2. Handle the timeout properly, ensuring no infinite loops run. 3. Respect the input and output formats strictly. 4. Ensure no additional sorting mechanisms (like quicksort) are used to artificially manipulate the sorting results.","solution":"import random import time from typing import List def is_sorted(arr: List[int]) -> bool: Check if the array is sorted in ascending order. return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def bogo_sort_timed(arr: List[int], timeout: int = 10) -> List[int]: Sorts the array using Bogo Sort algorithm with added timeout functionality. If the array cannot be sorted within the timeout limit, the function returns the array in its current state. Args: arr : List[int] - The list of integers to be sorted. timeout : int - The timeout limit in seconds. Returns: List[int] - Sorted list or partially sorted list after timeout. start_time = time.time() while not is_sorted(arr): if time.time() - start_time > timeout: break random.shuffle(arr) return arr"},{"question":"# Question You are given an undirected graph represented as an adjacency list, a start node, and an end node. Implement a function that determines the number of unique paths from the start node to the end node in the graph. Your function should effectively utilize recursion and backtracking to explore all paths. Function Specification ```python def count_paths(graph: Dict[int, List[int]], start: int, end: int) -> int: Returns the number of unique paths from \'start\' to \'end\' in the given graph. Args: graph: Dictionary where key is node, and value is list of adjacent nodes. start: Integer representing the starting node. end: Integer representing the end node. Returns: Integer representing the number of unique paths from start to end. ``` Input and Output Formats - **Input**: - `graph`: Dictionary with integer keys and list of integer values representing the adjacency list. - `start`: Integer depicting the start node. - `end`: Integer depicting the end node. - **Output**: - Return an integer representing the count of unique paths from `start` to `end`. Example: ```python graph = { 0: [1, 2], 1: [2, 3], 2: [3], 3: [4], 4: [2] } count_paths(graph, 0, 3) => 3 ``` **Explanation**: There are three unique paths from node 0 to node 3: - 0 -> 1 -> 2 -> 3 - 0 -> 1 -> 3 - 0 -> 2 -> 3 Constraints: - All graph nodes and edges will have integers as values. - There can be cycles in the graph. - Assume all inputs provided are valid and the graph is connected. Performance Requirements: - Time complexity approximation: O(V!), where V is the number of nodes. - Space complexity should be optimal with careful handling of recursion stack.","solution":"def count_paths(graph, start, end): def dfs(current, end, visited): if current == end: return 1 visited.add(current) path_count = 0 for neighbor in graph.get(current, []): if neighbor not in visited: path_count += dfs(neighbor, end, visited) visited.remove(current) return path_count return dfs(start, end, set())"},{"question":"**Objective**: Write a Python function to count the number of digits in a given list of integers. **Task**: Implement a function `count_digits_in_list(numbers)` that takes a list of integers and returns a list of integers representing the count of digits for each number in the input list. **Input and Output Format**: - **Input**: A list of integers, `numbers`. - Example: `[155, -567, 0, 87]` - **Output**: A list of integers where each element is the number of digits in the corresponding integer from `numbers`. - Example: Input `[155, -567, 0, 87]` should produce the output `[3, 3, 1, 2]`. **Constraints**: - The input list can have up to 10,000 integers. - Each integer will be between -1,000,000,000 and 1,000,000,000 (inclusive). - The result should be computed efficiently. # Example ```python def count_digits_in_list(numbers): # Your code here # Example usage numbers = [155, -567, 0, 87] print(count_digits_in_list(numbers)) # Output: [3, 3, 1, 2] ``` # Additional Information - Ensure your solution considers the edge cases mentioned. - The function should operate in O(1) time per number for counting digits.","solution":"def count_digits_in_list(numbers): Returns a list with the count of digits for each integer in the input list. digit_counts = [] for number in numbers: # Convert the number to its absolute value and convert to string to count digits digit_counts.append(len(str(abs(number)))) return digit_counts"},{"question":"# Question: Anagram Checker with Enhanced Capabilities Given two strings, determine if they are anagrams, considering case insensitivity and ignoring non-alphabetic characters. Input * Two strings `s1` and `s2`, which can contain any printable ASCII characters. Output * A boolean value `True` if `s1` and `s2` are anagrams, and `False` otherwise. Constraints 1. The length of both strings `s1` and `s2` is at most (10^5). Requirements * The solution should be efficient, preferably with a linear runtime complexity and using constant extra space. * Ignore non-alphabetic characters and consider letters case insensitively. Example ```python assert enhanced_anagram(\\"apple!!\\", \\"!pleAp\\") == True assert enhanced_anagram(\\"apple123\\", \\"cherry!\\") == False ``` Notes Use any programming language you are comfortable with, but ensure your solution optimizes for both time and space. Implement the function `enhanced_anagram(s1: str, s2: str) -> bool` that meets the above requirements.","solution":"def enhanced_anagram(s1, s2): Determine if two strings are anagrams, considering case insensitivity and ignoring non-alphabetic characters. from collections import Counter def preprocess_string(s): return \'\'.join([char.lower() for char in s if char.isalpha()]) pre_s1 = preprocess_string(s1) pre_s2 = preprocess_string(s2) return Counter(pre_s1) == Counter(pre_s2)"},{"question":"# Separate Chaining Hash Table Implementation **Objective**: You are required to extend the functionality of a separate chaining hash table by adding a method to list all keys stored in the hash table. Your method should return a list of all keys currently stored in the hash table. **Function Signature**: ```python def keys(self) -> list: Returns a list of all keys stored in the hash table. pass ``` **Requirements**: 1. Implement the `keys` method inside the `SeparateChainingHashTable` class, which will iterate through all the buckets and collect keys from the linked lists. 2. Ensure that the function is efficient and handles empty buckets gracefully. 3. Handle the edge cases where the hash table is empty or contains duplicate keys (your method should still function correctly as duplicates are inherently handled by the put method). **Input and Output**: * The method does not take any input parameters. * The output is a list of keys currently stored in the hash table. **Constraints**: * The hash table can store any hashable type as keys. * The number of elements in the hash table can be very large, so efficiency is crucial. * The list of keys can be returned in any order. **Performance**: * Aim for an O(n) time complexity for the `keys` method, where n is the number of key-value pairs in the hash table. **Scenario**: Suppose you are building a caching layer for a web application, and you need to enumerate all the keys in the cache to perform a periodic cleanup or status report. Implementing this feature effectively and efficiently will help you manage the cache appropriately. ```python # Class definition provided above # Implement your keys method within the SeparateChainingHashTable class ```","solution":"class SeparateChainingHashTable: def __init__(self, size=10): self.size = size self.table = [[] for _ in range(size)] def hash_function(self, key): Compute the hash value for a given key. return hash(key) % self.size def put(self, key, value): Add a key-value pair to the hash table. hash_key = self.hash_function(key) key_exists = False for i, kv in enumerate(self.table[hash_key]): k, v = kv if key == k: key_exists = True self.table[hash_key][i] = (key, value) break if not key_exists: self.table[hash_key].append((key, value)) def get(self, key): Retrieve a value by key from the hash table. hash_key = self.hash_function(key) for k, v in self.table[hash_key]: if key == k: return v return None def remove(self, key): Remove a key-value pair from the hash table. hash_key = self.hash_function(key) for i, kv in enumerate(self.table[hash_key]): k, v = kv if key == k: del self.table[hash_key][i] break def keys(self) -> list: Returns a list of all keys stored in the hash table. keys_list = [] for bucket in self.table: for k, v in bucket: keys_list.append(k) return keys_list"},{"question":"# RSA Key Pair Validation Problem Statement You are given an implementation of the RSA encryption algorithm\'s key generation. The task requires you to implement a validation function that will verify if a given RSA key pair is valid and consistent with the encryption and decryption processes. Your function will be tested with random inputs, and your objective is to ensure the integrity of the RSA key pair. Your task is to complete the function `validate_key_pair(n, e, d, test_data)` which should return `True` if `(n, e, d)` constitutes a valid and working RSA key pair for the given `test_data`. Otherwise, return `False`. Input - Four integers: - `n`: The modulus in the RSA key pair. - `e`: The encryption exponent. - `d`: The decryption exponent. - `test_data`: A piece of example data that needs to be tested with the keys to ensure correctness. Output - A boolean indicating whether the key pair is valid. Constraints - Assume `k` (bit-size for `n`) is at least 8 bits and at most 2048 bits. - `test_data` should be an integer in the range `[0, n-1]`. Example ```python n, e, d = generate_key(16) test_data = 20 # Example data assert validate_key_pair(n, e, d, test_data) is True ``` # Function Signature ```python def validate_key_pair(n: int, e: int, d: int, test_data: int) -> bool: # your code here ``` # Steps and Considerations 1. Encrypt `test_data` using the public key `(n, e)`. 2. Decrypt the encrypted data using the private key `(d, n)`. 3. Check if the decrypted data matches the original `test_data`. 4. Ensure all computations handle large integers efficiently. 5. Test edge cases, e.g., very small and very large values of `n`, `e`, `d`, and `test_data`.","solution":"def validate_key_pair(n: int, e: int, d: int, test_data: int) -> bool: Validate if the provided (n, e, d) constitutes a valid RSA key pair for given test_data. if not (0 <= test_data < n): return False # Encrypt the test data encrypted_data = pow(test_data, e, n) # Decrypt the encrypted data decrypted_data = pow(encrypted_data, d, n) # Verify if the decrypted data matches the original test data return decrypted_data == test_data"},{"question":"# Anagram Detection with Extended Character Support **Context**: In many applications, checking anagrams is a fundamental task, such as in cryptography, text processing, or simply understanding textual data. This problem tests your ability to extend basic algorithms to handle more general cases, such as considering capital letters and special characters. # Problem Statement Write a function `extended_anagram(s1: str, s2: str) -> bool` that determines if two input strings `s1` and `s2` are anagrams, allowing for an extended set of characters beyond simple lowercase alphabets. Requirements: 1. The function should be case insensitive (e.g., \'A\' and \'a\' should be considered the same). 2. It should ignore spaces and punctuation marks. 3. It should handle a broad set of characters, including digits and special characters. # Inputs and Outputs: * **Input**: Two strings `s1` and `s2`. * **Output**: Boolean value `True` if the strings are anagrams, `False` otherwise. # Constraints: * String lengths are between 0 and 10000 characters. * Only ASCII characters will be present in the strings. # Example: ```python print(extended_anagram(\\"Apple!\\", \\"P eal p\\")) # Output: True print(extended_anagram(\\"Listen\\", \\"Silent!!\\")) # Output: True print(extended_anagram(\\"Hello\\", \\"Oleh\\")) # Output: True print(extended_anagram(\\"Hello\\", \\"World\\")) # Output: False ``` # Notes: - Be mindful of performance and optimize for time complexity. - Make sure to preprocess the strings by removing spaces and punctuation, and normalizing the case. **Function Signature:** ```python def extended_anagram(s1: str, s2: str) -> bool: pass ```","solution":"import re from collections import Counter def extended_anagram(s1: str, s2: str) -> bool: Determines if two input strings s1 and s2 are anagrams considering case insensitivity, ignoring spaces and punctuation marks. # Helper function to preprocess strings def preprocess(s): # Remove non-alphanumeric characters and convert to lower case return re.sub(r\'[^a-zA-Z0-9]\', \'\', s).lower() # Preprocess both strings s1_processed = preprocess(s1) s2_processed = preprocess(s2) # Use Counter to count character frequencies in both strings return Counter(s1_processed) == Counter(s2_processed)"},{"question":"**Context**: You are working within a system that processes sensor data, and this data is pushed into a stack for temporary storage. However, before processing, you need to verify that the data in the stack is sorted in ascending order. You are tasked with implementing a function that checks if the stack\'s elements are sorted as required. # Task Implement a function `is_sorted(stack)` that determines if the given stack is sorted in ascending order from the bottom to the top. The function should not alter the original stack\'s order. The stack contains only integer elements. Function Signature ```python def is_sorted(stack: list) -> bool: pass ``` # Input * A stack represented as a list of integers, where `stack[-1]` is the top of the stack. # Output * The function should return a boolean value `True` if the stack elements are in ascending order from bottom to top, `False` otherwise. # Constraints * The elements in the stack will be integers. * You should not utilize additional data structures beyond primitive types (e.g., single temporary variables) to optimize space complexity. # Performance Requirements * Time Complexity: O(n) * Space Complexity: O(1), or constant additional space beyond the input stack itself. Example ```python stack = [1, 2, 3, 4, 5, 6] print(is_sorted(stack)) # Output: True stack = [6, 5, 4, 3, 2, 1] print(is_sorted(stack)) # Output: False stack = [] print(is_sorted(stack)) # Output: True stack = [1] print(is_sorted(stack)) # Output: True ``` **Note**: Implement the function without altering the original order of the stack.","solution":"def is_sorted(stack: list) -> bool: Determines if the given stack is sorted in ascending order from the bottom to the top. :param stack: A list representing the stack :return: True if the stack is sorted in ascending order, False otherwise # Iterate through the stack from the bottom to the second to last element for i in range(len(stack) - 1): # Compare each element with the next if stack[i] > stack[i + 1]: return False return True"},{"question":"Context: You are working on a project where you need to dynamically construct file paths and URLs based on user inputs and configurations. It\'s crucial that these paths be constructed correctly to ensure your application functions as expected without resulting in malformed paths or missing resources. Task: Write a function `join_paths(base, suffix)` that joins a base path/URL and a suffix path/URL. The result should always ensure that there is exactly one slash between each part of the path, and no trailing or leading slashes exist on the output. # Function Signature: ```python def join_paths(base: str, suffix: str) -> str: pass ``` # Expected Input and Output Formats * **Input**: Two strings `base` and `suffix` representing the base path/URL and the suffix path/URL, respectively. * `base` could be a file system directory, or a URL ending in slash or non-slash. * `suffix` could be a file, resource, or endpoint. * **Output**: A single string that represents the correctly joined path or URL. # Constraints: * The input strings `base` and `suffix` will consist of only printable ASCII characters. * The inputs may include multiple consecutive slashes. * The inputs may include leading and trailing spaces which should be trimmed. # Examples: ```python # Example 1 print(join_paths(\\"http://domain.com\\", \\"resource\\")) # Expected: \\"http://domain.com/resource\\" # Example 2 print(join_paths(\\"http://domain.com/\\", \\"resource\\")) # Expected: \\"http://domain.com/resource\\" # Example 3 print(join_paths(\\"/path/to/dir\\", \\"file\\")) # Expected: \\"/path/to/dir/file\\" # Example 4 print(join_paths(\\"path/to/dir/\\", \\"/file\\")) # Expected: \\"path/to/dir/file\\" # Example 5 print(join_paths(\\"path/to/dir///\\", \\"////file\\")) # Expected: \\"path/to/dir/file\\" # Example 6 print(join_paths(\\" path/to/dir \\", \\" file \\")) # Expected: \\"path/to/dir/file\\" ``` Objectives: * Ensure the function handles leading and trailing spaces and slashes properly. * Ensure there is exactly one slash between the joined paths. * Consider edge cases such as empty strings and multiple consecutive slashes. Performance Requirements The function should efficiently handle strings up to length 1000 characters.","solution":"def join_paths(base: str, suffix: str) -> str: Joins a base path/URL and a suffix path/URL ensuring there is exactly one slash between each part of the path, and no trailing or leading slashes exist on the output. # Strip leading and trailing spaces base = base.strip() suffix = suffix.strip() # Remove trailing slashes from the base and leading slashes from the suffix base = base.rstrip(\'/\') suffix = suffix.lstrip(\'/\') # Join the base and suffix with exactly one slash return f\\"{base}/{suffix}\\""},{"question":"# Scenario You are working on a text editor that provides a \\"search and highlight\\" feature. The feature needs to find the first occurrence of a given keyword within the text and return the starting index of the keyword. You decide to use the Rabin-Karp algorithm for this task due to its efficient rolling hash mechanism. # Task Implement the Rabin-Karp algorithm to search for the first occurrence of the `pattern` in a given `text`. Return the starting index of the keyword in the text. If the pattern does not exist in the text, return `-1`. # Function Signature ```python def rabin_karp(pattern: str, text: str) -> int: # your code here ``` # Input * `pattern`: A non-empty string containing the pattern to search for. (1 ≤ len(pattern) ≤ 10^4) * `text`: A potentially empty string where the search is performed. (0 ≤ len(text) ≤ 10^6) # Output * An integer representing the starting index of the first occurrence of `pattern` in `text` or `-1` if `pattern` is not found. # Example ```python # Test Case 1 pattern = \\"abc\\" text = \\"abxabcabcaby\\" output = rabin_karp(pattern, text) print(output) # should print 3 # Test Case 2 pattern = \\"xyz\\" text = \\"abxabcabcaby\\" output = rabin_karp(pattern, text) print(output) # should print -1 ``` # Constraints * Your implementation must be efficient to handle the upper limits of the input sizes. * Ensure the hash function minimizes collisions to avoid unnecessary comparisons.","solution":"def rabin_karp(pattern: str, text: str) -> int: def create_hash(s, end, prime, base): hash_val = 0 for i in range(end): hash_val = (hash_val * base + ord(s[i])) % prime return hash_val def roll_hash(old_hash, old_char, new_char, base_pow, prime, base): new_hash = old_hash - ord(old_char) * base_pow new_hash = (new_hash * base + ord(new_char)) % prime return new_hash prime = 2**31 - 1 # A large prime number base = 256 # Number of characters in the input alphabet len_pattern = len(pattern) len_text = len(text) if len_pattern > len_text: return -1 pattern_hash = create_hash(pattern, len_pattern, prime, base) text_hash = create_hash(text, len_pattern, prime, base) base_pow = pow(base, len_pattern - 1, prime) for i in range(len_text - len_pattern + 1): if pattern_hash == text_hash: if text[i:i + len_pattern] == pattern: # Verifying hash match return i if i < len_text - len_pattern: text_hash = roll_hash(text_hash, text[i], text[i + len_pattern], base_pow, prime, base) return -1"},{"question":"# Question: Implement an Enhanced Interpolation Search You are given a sorted array of integers and a target search key. Implement a function `enhanced_interpolation_search` that searches for the target key in the array. The search should be efficient and robust, even for arrays that are not uniformly distributed. To achieve this: * The function should first attempt to use interpolation search to locate the search key. * If the interpolation fails to find the key within a reasonable number of guesses (define \\"reasonable\\" using a threshold, e.g., log2(n)), fallback to binary search for the remaining range. * The return should be the index of the search key in the array if found, otherwise, return -1. * Ensure to handle edge cases such as empty arrays, arrays with identical elements, etc. Input: * An integer array `arr` which is sorted. * An integer `key` representing the search key. Output: * Return the index of the `key` in the array if found. * Return -1 if the `key` is not present in the array. Constraints: * The array may contain negative integers. * The length of the array can vary from 0 to 10^6. * All elements in the array and the search key will be in the range of -10^6 to 10^6. Example: ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> int: # Implement your solution here. pass # Examples print(enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 14)) # Output: 3 print(enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55)) # Output: -1 print(enhanced_interpolation_search([], 5)) # Output: -1 print(enhanced_interpolation_search([-25, -12, -1, 0, 10, 20, 33], 10)) # Output: 4 ```","solution":"import math from typing import List def enhanced_interpolation_search(arr: List[int], key: int) -> int: if len(arr) == 0: return -1 low = 0 high = len(arr) - 1 threshold = int(math.log2(len(arr))) guesses = 0 while low <= high and key >= arr[low] and key <= arr[high]: if low == high: if arr[low] == key: return low else: return -1 pos = low + ((high - low) // (arr[high] - arr[low]) * (key - arr[low])) if pos < low or pos > high: break if arr[pos] == key: return pos if arr[pos] < key: low = pos + 1 else: high = pos - 1 guesses += 1 if guesses > threshold: break # Fallback to binary search return binary_search(arr, low, high, key) def binary_search(arr: List[int], low: int, high: int, key: int) -> int: while low <= high: mid = (low + high) // 2 if arr[mid] == key: return mid elif arr[mid] < key: low = mid + 1 else: high = mid - 1 return -1"},{"question":"# Scenario You have been hired by a financial technology company that deals with transactions involving very large sums of money. To ensure precision and avoid overflow issues with built-in data types, you need to implement multiplication of large numbers represented as strings. # Task Write a function `multiply_strings(num1: str, num2: str) -> str` that multiplies two non-negative integers represented as strings and returns the product as a string. The inputs will satisfy the following constraints: * The length of both num1 and num2 is less than 110. * Both num1 and num2 contain only digits 0-9. * Both num1 and num2 do not contain any leading zero (except when the number itself is \\"0\\"). You must not use any built-in BigInteger libraries or convert the inputs directly to integers. # Function Signature ```python def multiply_strings(num1: str, num2: str) -> str: pass ``` # Input * A string `num1` representing the first non-negative integer (1 <= len(num1) < 110). * A string `num2` representing the second non-negative integer (1 <= len(num2) < 110). # Output * A string representing the product of `num1` and `num2`. # Constraints * The length of both `num1` and `num2` is less than 110. * The product of `num1` and `num2` fits within the bounds of a string of length less than 220 (since the result of multiplying two n-digit numbers can be at most a 2n-digit number). # Example ```python assert multiply_strings(\\"123\\", \\"456\\") == \\"56088\\" assert multiply_strings(\\"2\\", \\"3\\") == \\"6\\" assert multiply_strings(\\"0\\", \\"10000\\") == \\"0\\" assert multiply_strings(\\"999\\", \\"999\\") == \\"998001\\" ``` # Notes - Consider intermediate storing of partial results and ensure to manage positional place values appropriately. - Optimize the algorithm where possible to handle the worst-case scenario within the given constraints.","solution":"def multiply_strings(num1: str, num2: str) -> str: Multiplies two non-negative integers represented as strings and returns the product as a string. if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" # Initialize a list to store the intermediate result result = [0] * (len(num1) + len(num2)) # Reverse both strings to simplify multiplication and addition num1 = num1[::-1] num2 = num2[::-1] # Multiply each digit of the two numbers for i in range(len(num1)): for j in range(len(num2)): multiply = int(num1[i]) * int(num2[j]) result[i + j] += multiply result[i + j + 1] += result[i + j] // 10 # Carry forward result[i + j] = result[i + j] % 10 # Remainder stays # Convert the result list back to a string while len(result) > 1 and result[-1] == 0: result.pop() result = result[::-1] return \'\'.join(map(str, result))"},{"question":"Given the following tasks, implement a function to perform postorder traversal on a binary tree. You can choose to implement an iterative or recursive approach. # Task 1. Write a function that takes the root of a binary tree as input and returns a list containing the postorder traversal of the tree\'s nodes. # Specifications - **Function Name**: `postorderTraversal` - **Input**: A single argument `root`, which represents the root of a binary tree. - **Output**: A list of integers representing the values of nodes visited in postorder. # Constraints 1. The number of nodes in the tree can be up to 10,000. 2. The node values will be integers. # Example Given the binary tree root: ``` 1 / 2 3 / 4 5 ``` The function should return `[4, 5, 2, 3, 1]`. # Notes - If the tree is empty (i.e., the root is `None`), return an empty list `[]`.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def postorderTraversal(root): Perform postorder traversal of a binary tree and return the list of node values. if root is None: return [] result = [] stack = [] current = root last_node_visited = None while stack or current: if current: stack.append(current) current = current.left else: peek_node = stack[-1] if peek_node.right and last_node_visited != peek_node.right: current = peek_node.right else: result.append(peek_node.value) last_node_visited = stack.pop() return result"},{"question":"# Question You are given the responsibility to extend an existing library of bit manipulation functions. The aim is to implement additional functionality that can be used in low-level systems and embedded programming. You need to implement the following functions: 1. **clear_rightmost_set_bit**(num): Clears the rightmost set bit (1) of the given integer \'num\'. - **Input**: An integer `num`. - **Output**: An integer with the rightmost set bit cleared. - **Example**: ```python clear_rightmost_set_bit(10) # returns 8 ``` 2. **isolate_rightmost_set_bit**(num): Isolates the rightmost set bit of the given integer \'num\'. All other bits should be set to 0. - **Input**: An integer `num`. - **Output**: An integer with only the rightmost set bit of `num` retained. - **Example**: ```python isolate_rightmost_set_bit(10) # returns 2 ``` 3. **bit_count**(num): Counts the number of bits set to 1 in the given integer \'num\' (also known as the Hamming weight or population count). - **Input**: An integer `num`. - **Output**: An integer representing the number of 1-bits in `num`. - **Example**: ```python bit_count(10) # returns 2 ``` # Implementation Requirements - You need to use bitwise operations to implement each function. - Consider edge cases such as `num` being zero, negative, or extremely large. - You are not allowed to use any library functions other than basic bitwise operators and control structures. # Performance Requirements - All operations must execute in constant or linear time relative to the number of bits in the integer.","solution":"def clear_rightmost_set_bit(num): Clears the rightmost set bit (1) of the given integer \'num\'. Example: clear_rightmost_set_bit(10) # returns 8 return num & (num - 1) def isolate_rightmost_set_bit(num): Isolates the rightmost set bit of the given integer \'num\'. Example: isolate_rightmost_set_bit(10) # returns 2 return num & -num def bit_count(num): Counts the number of bits set to 1 in the given integer \'num\'. Example: bit_count(10) # returns 2 count = 0 while num: count += num & 1 num >>= 1 return count"},{"question":"You have been tasked with implementing an optimized version of the Pigeonhole Sort algorithm. The classic pigeonhole sort algorithm you analyzed is excellent for sorting lists where the number of elements is close to the range of the values. However, we need a more space-efficient version that can handle larger ranges more gracefully. # Task Write a function `optimized_pigeonhole_sort` that sorts an array of integers using an enhanced approach to pigeonhole sort. Your function should minimize space usage while retaining the linear time efficiency for suitable input ranges. # Constraints 1. **Input Format**: * A list of integers `arr` of length `n` (0 ≤ `n` ≤ 10^5). * The integers in the list range from `Min` to `Max` where 0 ≤ `Min` ≤ `Max` and `Max` - `Min` ≤ 10^6. 2. **Output Format**: * Return a sorted list of integers. # Example ```python # Example I/O pattern # Input arr = [8, 3, 2, 7, 4] # Output [2, 3, 4, 7, 8] ``` # Requirements - Ensure your function is space efficient. - Handle edge cases such as empty lists or lists with the same elements. - Ensure your function is optimized for both time and space. # Additional Notes Your `optimized_pigeonhole_sort` function should follow the line of thinking of pigeonhole sorting but reduce unnecessary space usage by applying appropriate logic. # Code Template ```python def optimized_pigeonhole_sort(arr): # Your implementation here return arr ```","solution":"def optimized_pigeonhole_sort(arr): if not arr: return [] # Find the minimum and maximum values Min = min(arr) Max = max(arr) # Create holes size = Max - Min + 1 holes = [0] * size # Populate the holes with the number of times each element appears for num in arr: holes[num - Min] += 1 # Reconstruct the sorted array sorted_arr = [] for index in range(size): while holes[index] > 0: sorted_arr.append(index + Min) holes[index] -= 1 return sorted_arr"},{"question":"Scenario You\'re tasked with verifying data consistency by comparing the structure and values of large family tree datasets. Write a function to determine if two given binary trees are structurally identical and have identical node values. Function Signature: ```python def is_same_tree(tree_p: Optional[TreeNode], tree_q: Optional[TreeNode]): -> bool: ``` Input: * `tree_p`: Root node of the first binary tree (could be `None`). * `tree_q`: Root node of the second binary tree (could be `None`). Output: * Return `True` if both trees are the same, else return `False`. Constraints: * Both trees can have zero or more nodes. * Node values are integer and can be negative. Performance Requirements: * Aim for linear time complexity relative to the total number of nodes in the smaller tree. * Ensure the space complexity respects the recursion stack size limitation. Example: ```python # Consider the TreeNode class is already defined as: class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Test Case 1: # Tree 1: 1 Tree 2: 1 # / / # 2 3 2 3 tree_p = TreeNode(1, TreeNode(2), TreeNode(3)) tree_q = TreeNode(1, TreeNode(2), TreeNode(3)) print(is_same_tree(tree_p, tree_q)) # Output: True # Test Case 2: # Tree 1: 1 Tree 2: 1 # / / # 2 3 tree_p = TreeNode(1, TreeNode(2)) tree_q = TreeNode(1, TreeNode(3)) print(is_same_tree(tree_p, tree_q)) # Output: False ``` Prompt: 1. Implement the `is_same_tree` function as defined above. 2. Thoroughly test your function with various test cases to ensure correctness.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(tree_p: Optional[TreeNode], tree_q: Optional[TreeNode]) -> bool: if not tree_p and not tree_q: return True if not tree_p or not tree_q: return False if tree_p.val != tree_q.val: return False return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)"},{"question":"# Question: Implement an Optimized Bubble Sort You are required to implement an enhanced version of the Bubble Sort algorithm. This version will include additional optimizations and safety features, ensuring it performs better in various scenarios. Function Signature ```python def optimized_bubble_sort(arr: List[int]) -> List[int]: ``` Input: - `arr`: A list of integers (List[int]) which needs to be sorted. Output: - A sorted list of integers in ascending order. Constraints: - The length of `arr` will not exceed 1000. Requirements: 1. Implement the Bubble Sort algorithm with optimizations: - Early termination if the list is already sorted. - Handle edge cases such as empty arrays or arrays with all duplicate elements. 2. Do not use any built-in sorting functions. 3. Ensure the implementation remains stable. 4. Include inline comments explaining crucial steps and decisions in your code. Example: ```python assert optimized_bubble_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64] assert optimized_bubble_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert optimized_bubble_sort([]) == [] assert optimized_bubble_sort([5, 5, 5, 5]) == [5, 5, 5, 5] assert optimized_bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] ``` Edge Cases to Consider: - An empty array should return an empty array. - An array with all elements being the same should remain unchanged. - An already sorted array should not undergo unnecessary operations. Good luck!","solution":"from typing import List def optimized_bubble_sort(arr: List[int]) -> List[int]: Perform an optimized Bubble Sort to sort a list of integers in ascending order. n = len(arr) # Early return for an empty array or a single element if n < 2: return arr for i in range(n): swapped = False # Track if any swap has occurred in this pass for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True # If no elements were swapped, the array is already sorted if not swapped: break return arr"},{"question":"Prime Path Finder Given an undirected graph where each node corresponds to an integer, design a function to find the shortest path between two nodes where all the nodes in the path are prime numbers. Task Write a function `prime_shortest_path(graph, start, end)` that: 1. Takes an adjacency list `graph`, where `graph[node]` is a list of nodes adjacent to `node`. 2. The `start` and `end` nodes are integers representing the starting and target nodes, respectively. 3. Returns the length of the shortest path where all the intermediate nodes, including the start and end node, are prime numbers. If no such path exists, return `-1`. Example ```python def prime_check(n): # Prime check implementation as provided in the code snippet pass def prime_shortest_path(graph, start, end): # Your implementation comes here pass # Example usage: graph = { 2: [3, 5], 3: [2, 5, 11], 5: [2, 3, 7, 11], 7: [5, 11], 11: [3, 5, 7], 4: [6], 6: [4] } print(prime_shortest_path(graph, 2, 11)) #=> Expected output: Length of the shortest prime path from 2 to 11 ``` Additional Information * Ensure to use the `prime_check(n)` method to validate if a number `n` is prime. * Nodes with non-prime integers should not be part of the path considered. * Nodes including the starting and ending nodes should be prime. * The graph can contain nodes that are not prime numbers but they should not be included in the prime path consideration. Constraints * The graph nodes and edges form a valid undirected graph. * Node values can be any integer, positive or negative. * Typical graph size will be such that a BFS approach will work within acceptable time limits.","solution":"from collections import deque def prime_check(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_shortest_path(graph, start, end): if not prime_check(start) or not prime_check(end): return -1 # Perform BFS queue = deque([(start, 0)]) visited = set() while queue: current_node, current_distance = queue.popleft() if current_node == end: return current_distance if current_node in visited: continue visited.add(current_node) for neighbor in graph.get(current_node, []): if prime_check(neighbor) and neighbor not in visited: queue.append((neighbor, current_distance + 1)) return -1"},{"question":"Objective Given a rotated sorted array where elements are in ascending order before rotation, write a function to find the minimum element in the array. The solution should achieve O(log N) time complexity. Function Signature ```python def find_min_in_rotated_sorted_array(arr: List[int]) -> int: pass ``` Input * `arr`: A list of integers sorted in ascending order but rotated at some pivot. * Constraints: * 1 <= len(arr) <= 10^4 * -10^4 <= arr[i] <= 10^4 * No duplicates exist in the array. Output * Returns the minimum element in the rotated sorted array. Example ```python assert find_min_in_rotated_sorted_array([4, 5, 6, 7, 0, 1, 2]) == 0 assert find_min_in_rotated_sorted_array([3, 4, 5, 1, 2]) == 1 assert find_min_in_rotated_sorted_array([11, 13, 15, 17]) == 11 assert find_min_in_rotated_sorted_array([7]) == 7 ``` Description The key idea is to use a modified binary search to efficiently find the inflection point of the rotation which will be the smallest element in the array. Implement the `find_min_in_rotated_sorted_array` function to solve the task according to the given constraints ensuring optimal performance.","solution":"from typing import List def find_min_in_rotated_sorted_array(arr: List[int]) -> int: left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] > arr[right]: left = mid + 1 else: right = mid return arr[left]"},{"question":"# Sorting Evaluation with Improved Comb Sort You are part of a team responsible for optimizing the computation efficiency of a large data processing system. Your task is to implement a modified version of the Comb Sort algorithm to perform more efficiently than the current version. **Task**: Write a Python function `modified_comb_sort(arr: List[int]) -> List[int]` that sorts a list of integers using the Comb Sort algorithm with the following modifications: 1. Use a different shrink factor that might provide better performance. 2. Implement an additional check to identify if a part of the array is nearly sorted, minimizing redundant passes. **Input**: * A list of integers, `arr`, where `1 <= len(arr) <= 10^4`. **Output**: * A sorted list of integers. **Constraints**: * Your solution should optimize the gap reduction and handle nearly sorted data efficiently. * Aim to improve average performance closer to O(n log n). **Example**: ```python print(modified_comb_sort([34, 2, 10, -9])) # Output: [-9, 2, 10, 34] ``` # Notes: 1. The function should be self-contained and not depend on any external libraries. 2. Consider different strategies for the shrink factor and nearly sorted checks, and justify your approach in comments. Show how your improved comb sort can handle edge cases and large inputs effectively.","solution":"from typing import List def modified_comb_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Comb Sort algorithm with modifications. Uses a shrink factor of 1.3 and identifies nearly sorted parts to minimize redundant passes. def next_gap(gap): # Shrink gap by shrink factor 1.3, ensuring we always move at least by 1. new_gap = int(gap // 1.3) return max(new_gap, 1) n = len(arr) gap = n swapped = True while gap > 1 or swapped: gap = next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: # Swap the elements arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"Scenario: You are implementing a spell checker for a text processing application. To check the integrity of certain sequences in the document, you need to verify if these sequences are palindromes. Given a linked list structure representing sequences of characters, write an efficient solution to determine if the sequence is a palindrome. Objective: Implement a function `is_palindrome(head: ListNode) -> bool` that determines whether the linked list sequence is a palindrome. Input: - `head: ListNode` - The head of the singly linked list where each node contains a single character. Output: - `bool` - `True` if the linked list is a palindrome, otherwise `False`. Constraints: 1. The number of nodes in the linked list is in the range [0, 10^5]. 2. Each node contains a single lowercase English letter. 3. Aim for O(n) time complexity and O(1) space complexity where possible. Examples: 1. `Input: head = [\'a\',\'b\',\'c\',\'b\',\'a\']` `Output: True` 2. `Input: head = [\'a\',\'b\',\'c\',\'d\',\'e\']` `Output: False` Note: You must handle cases with odd or even lengths uniformly without duplicating logic. Function Signature: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head: ListNode) -> bool: # Your implementation here ``` **Your implementation should adhere to the given constraints and should efficiently check if the linked list is a palindrome.**","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head: ListNode) -> bool: if not head or not head.next: return True slow = head fast = head # Find the middle of the linked list while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the linked list prev = None while slow: next_node = slow.next slow.next = prev prev = slow slow = next_node # Compare the first half with the reversed second half left, right = head, prev while right: # Only need to check the second half if left.val != right.val: return False left = left.next right = right.next return True"},{"question":"# Unique Number Identification with Custom Frequency **Objective:** Write a function to identify a unique element in a list where every other element appears exactly three times. The function should achieve linear runtime and constant space complexity. # Problem Statement: You are given a list of integers where every integer appears exactly three times except for one integer which appears exactly once. Your task is to write a function to find that single integer. # Function Signature: ```python def find_single_number(nums: List[int]) -> int: ``` # Input: - A list `nums` of integers where 1 ≤ len(nums) ≤ 10^6. # Output: - A single integer which is unique in the list. # Constraints: - The function must run in O(n) time complexity. - The function should use O(1) extra space. # Example: ```python assert find_single_number([2, 2, 3, 2]) == 3 assert find_single_number([0, 1, 0, 1, 0, 1, 99]) == 99 ``` # Notes: - You should avoid using extra memory like hash maps or lists. - Use bitwise operations to achieve constant space complexity. # Hints: - Consider counting the number of occurrences of each bit position. - Use bit manipulation to track the occurrence counts modulo 3. - Variables `ones` and `twos` can be used to keep track of bits seen once and twice. # Solution Template: ```python from typing import List def find_single_number(nums: List[int]) -> int: ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones # Example usage nums = [2, 2, 3, 2] print(find_single_number(nums)) # Output should be 3 ``` Ensure your code considers edge cases, such as an array of size one. Test your solution to verify its correctness and performance against large inputs.","solution":"from typing import List def find_single_number(nums: List[int]) -> int: ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"Given a sorted list of integers in increasing order, your task is to implement a function that returns the index of the first occurrence of a specified number, if present. If the number is not present in the list, return `-1`. Function Signature: ```python def first_occurrence(array: List[int], query: int) -> int: ``` Input: - `array`: a list of integers, sorted in increasing order. (1 ≤ len(array) ≤ 10000, -10^9 ≤ array[i] ≤ 10^9) - `query`: an integer that needs to be searched in the array. Output: - Return the index of the first occurrence of the query element in the array if it exists. If the element is not present, return `-1`. Constraints: - **Time Complexity**: The function should have a time complexity of O(log n). - Adhere to memory-efficient practices, ideally aiming for O(1) additional space complexity. Examples: ```python # Example 1 array = [1, 2, 2, 2, 3, 4, 5] query = 2 # Expected Output: 1 # Example 2 array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] query = 7 # Expected Output: 7 # Example 3 array = [1, 2, 3, 4, 5, 6] query = 10 # Expected Output: -1 # Example 4 array = [1, 2, 3, 5, 5, 5, 5, 5, 5, 6, 7, 8] query = 5 # Expected Output: 3 ``` Write your implementation considering edge cases and performance constraints. Your solution should be efficient and readable.","solution":"def first_occurrence(array, query): Returns the index of the first occurrence of the query in the sorted array. If the query is not found, returns -1. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == query: if mid == 0 or array[mid - 1] != query: return mid high = mid - 1 elif array[mid] > query: high = mid - 1 else: low = mid + 1 return -1"},{"question":"# String Reverse Challenge **Context**: You are tasked with implementing a function to reverse a given string using Python. Given the varied methods for reversing strings, the aim is to explore understanding and efficiency. **Task**: Implement a function `reverse_string(s)` to reverse the input string `s`. Ensure your implementation is efficient and handles edge cases effectively. **Function Signature**: ```python def reverse_string(s: str) -> str: ``` **Input**: - `s`: A string `s` (0 <= len(s) <= 10^6), containing ASCII characters. **Output**: - Returns the reversed string. **Constraints**: - Your solution should handle large input sizes efficiently. - Avoid using excessive memory. **Performance Requirements**: - Aim for O(n) time complexity and O(1) additional space complexity beyond the input string. **Example**: ```python assert reverse_string(\\"abcdef\\") == \\"fedcba\\" assert reverse_string(\\"12345\\") == \\"54321\\" assert reverse_string(\\"\\") == \\"\\" assert reverse_string(\\"a\\") == \\"a\\" assert reverse_string(\\"racecar\\") == \\"racecar\\" ```","solution":"def reverse_string(s: str) -> str: Reverses the input string s. Parameters: s (str): The string to be reversed. Returns: str: The reversed string. return s[::-1]"},{"question":"# Doubly Linked List Operations Implement a **Doubly Linked List** class with the following functionality to handle a series of operations in an efficient manner. # Function Requirements - **Add Node**: Add a node to the beginning of the list. - **Delete Node**: Delete a node from the end of the list. - **Find Node**: Find the node by its value. - **Print List Forward**: Print the list from head to tail. - **Print List Backward**: Print the list from tail to head. Input Format You do not need to handle input/output. Implement the following methods: 1. `add_node(value: int) -> None`: Adds a node with the given value to the beginning of the DLL. 2. `delete_node() -> None`: Deletes the node from the end of the DLL. 3. `find_node(value: int) -> bool`: Returns True if a node with the given value exists, else False. 4. `print_list_forward() -> List[int]`: Returns a list of elements starting from the head. 5. `print_list_backward() -> List[int]`: Returns a list of elements starting from the tail. Constraints - The values are guaranteed to be unique for this exercise. - Lists may contain any non-negative integer value. ```python class DoublyLinkedList: class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None def __init__(self): self.head = None self.tail = None def add_node(self, value: int) -> None: # Implement this method to add node at the beginning pass def delete_node(self) -> None: # Implement this method to delete node from the end pass def find_node(self, value: int) -> bool: # Implement this method to find node by its value pass def print_list_forward(self) -> List[int]: # Implement this method to print list from head to tail pass def print_list_backward(self) -> List[int]: # Implement this method to print list from tail to head pass ``` Example Usage ```python dll = DoublyLinkedList() dll.add_node(10) dll.add_node(20) dll.add_node(30) dll.print_list_forward() # Should output: [30, 20, 10] dll.find_node(20) # Should return: True dll.delete_node() dll.print_list_backward() # Should output: [20, 30] ```","solution":"class DoublyLinkedList: class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None def __init__(self): self.head = None self.tail = None def add_node(self, value: int) -> None: new_node = self.DoublyLinkedListNode(value) if self.head is None: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def delete_node(self) -> None: if self.tail is None: return # List is empty, nothing to delete if self.head == self.tail: self.head = self.tail = None # Only one element else: self.tail = self.tail.prev self.tail.next = None def find_node(self, value: int) -> bool: current = self.head while current is not None: if current.value == value: return True current = current.next return False def print_list_forward(self) -> list: elements = [] current = self.head while current is not None: elements.append(current.value) current = current.next return elements def print_list_backward(self) -> list: elements = [] current = self.tail while current is not None: elements.append(current.value) current = current.prev return elements"},{"question":"Minimum Edit Distance Calculation Write a function `min_edit_distance(str1, str2)` to compute the minimum edit distance between two given strings `str1` and `str2`. Function Signature ```python def min_edit_distance(str1: str, str2: str) -> int: ``` Input * `str1` (string): The first string (0 <= len(str1) <= 1000) * `str2` (string): The second string (0 <= len(str2) <= 1000) Output * An integer representing the minimum number of operations required to transform `str1` into `str2`. Constraints * You should use dynamic programming to solve this problem efficiently. * Consider all operations (insertions, deletions, and substitutions) with equal cost. * The maximum length of both strings combined will not exceed 2000. Example ```python # Example 1 assert min_edit_distance(\\"FOOD\\", \\"MONEY\\") == 4 # Example 2 assert min_edit_distance(\\"\\", \\"abc\\") == 3 # Example 3 assert min_edit_distance(\\"intention\\", \\"execution\\") == 5 ``` Additional Requirements * Efficiently handle and correctly process edge cases such as empty strings, identical strings, etc. * Ensure the solution is optimal in terms of time and space complexity; aim for O(length_a * length_b) time and O(length_a * length_b) space complexity. * You are not allowed to use any inbuilt functions that directly solve the problem.","solution":"def min_edit_distance(str1: str, str2: str) -> int: Compute the minimum edit distance between two given strings str1 and str2 m, n = len(str1), len(str2) # Create a DP table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If first string is empty, insert all characters of second string elif j == 0: dp[i][j] = i # If second string is empty, remove all characters of first string elif str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] # Characters match, no operation needed else: dp[i][j] = 1 + min(dp[i-1][j], # Remove dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"Imagine you are working as a software engineer at a company that deals with a large dataset containing product prices. An operation critical to your data pipeline involves ensuring any subset of this data is correctly sorted without using excessive memory. Although Cycle Sort is not the most efficient in time complexity, its minimal memory write characteristic is ideal for your scenario due to hardware limitations. **Task**: Implement a function using the Cycle Sort algorithm that sorts an array of integers efficiently by minimizing the number of write operations. Your solution should handle edge cases effectively. **Function Signature**: ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` **Input**: * `arr`: A list of integers, not necessarily unique (1 ≤ len(arr) ≤ 10^5). **Output**: * A sorted list of integers in ascending order. **Constraints**: * Do not use any built-in sorting functions (e.g., `sorted()`, `.sort()`). * Aim to minimize the number of write operations. **Examples**: ```python # Example 1: input = [3, 1, 3, 2, 1] output = [1, 1, 2, 3, 3] # Example 2: input = [7, 5, 3, 1] output = [1, 3, 5, 7] ``` **Notes**: 1. Be mindful of the potential for cycles with duplicate values; ensure your algorithm can handle such cases without unnecessary operations or infinite loops. 2. Testing will include arrays of various sizes and values to ensure robustness and efficiency.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: n = len(arr) # Iterate through the array to place each element in its correct position for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find the position where we put the element pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Otherwise, put the item to the correct position while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Question: Implement an Enhanced Rabin-Karp Substring Search Function Scenario You are working on a text editor feature that searches for a specific word within a large document. To improve search efficiency, implement an enhanced version of the Rabin-Karp algorithm for substring search. Consider edge cases and optimize the hashing to handle collisions effectively. Task Write a function `enhanced_rabin_karp(word, text)` that searches for the first occurrence of the `word` within the `text` string. Your implementation should handle hash collisions effectively and provide a more robust solution compared to the standard Rabin-Karp algorithm. Input * `word` (str): The substring you are searching for. Constraints: 1 <= len(word) <= 10^4. * `text` (str): The main string in which you search for the word. Constraints: 1 <= len(text) <= 10^6. Output * (int): The starting index of the first occurrence of the word in the text, or -1 if the word is not found. Constraints and Performance Requirements * Your function must run in O(N+M) average-case time complexity. * You must handle large inputs efficiently. Consider optimizing the hash function to minimize collisions. Example ```python assert enhanced_rabin_karp(\\"pattern\\", \\"find the pattern in this text\\") == 9 assert enhanced_rabin_karp(\\"test\\", \\"this is a simple text\\") == 10 assert enhanced_rabin_karp(\\"notfound\\", \\"this is a test string\\") == -1 ``` Additional Notes * Ensure that you handle edge cases such as empty strings and cases where the word is longer than the text. * Optimize your hash function to minimize chances of collision.","solution":"def enhanced_rabin_karp(word, text): Searches for the first occurrence of `word` in `text` using an enhanced Rabin-Karp algorithm. Parameters: word (str): The substring to search for. text (str): The string in which to search the word. Returns: int: The starting index of the first occurrence of the word in the text, or -1 if not found. if not word or not text or len(word) > len(text): return -1 base = 256 prime = 101 word_length = len(word) text_length = len(text) word_hash = 0 current_hash = 0 high_order_base = 1 for i in range(word_length - 1): high_order_base = (high_order_base * base) % prime for i in range(word_length): word_hash = (base * word_hash + ord(word[i])) % prime current_hash = (base * current_hash + ord(text[i])) % prime for i in range(text_length - word_length + 1): if word_hash == current_hash: if text[i:i+word_length] == word: return i if i < text_length - word_length: current_hash = (base * (current_hash - ord(text[i]) * high_order_base) + ord(text[i + word_length])) % prime if current_hash < 0: current_hash += prime return -1"},{"question":"# Question: You are given a maze represented by a 2D binary grid, where `1` represents open paths and `0` represents blocked paths. An explorer needs to find the shortest path from the top-left cell (0,0) to the bottom-right cell (n-1, m-1) while only stepping on cells with value `1`. Return the length of the shortest path (excluding the top-left cell) or `-1` if no such path exists. **Input**: A list of lists `maze` representing the grid, where: - `maze` is an `n x m` grid. - Each cell contains a `0` or `1`. - `maze[0][0]` and `maze[n-1][m-1]` are always `1`. **Output**: An integer, representing the length of the shortest path from top-left to bottom-right, excluding the starting cell. Return `-1` if no path exists. **Constraints**: - 1 <= n, m <= 100 **Example 1**: ```python maze = [ [1,0,1,1,1,1], [1,0,1,0,1,0], [1,0,1,0,1,1], [1,1,1,0,1,1] ] Output: 14 ``` **Example 2**: ```python maze = [ [1,0,0], [0,1,1], [0,1,1], ] Output: -1 ``` Implement the function: ```python def find_shortest_path(maze): # your code here ```","solution":"from collections import deque def find_shortest_path(maze): Finds the shortest path from (0,0) to (n-1,m-1) in a binary maze. Returns the length of the path excluding the starting cell. Returns -1 if no such path exists. n, m = len(maze), len(maze[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] if maze[0][0] == 0 or maze[n-1][m-1] == 0: return -1 queue = deque([(0, 0, 0)]) # (x, y, distance) maze[0][0] = 0 # Mark the starting cell as visited while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and maze[nx][ny] == 1: queue.append((nx, ny, dist + 1)) maze[nx][ny] = 0 # Mark this cell as visited return -1"},{"question":"Problem Statement You are given a string `s` and you need to determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). Implement a function `is_palindrome(s)` that returns `True` if the string `s` is a palindrome, and `False` otherwise. # Constraints * The input string `s` can include any printable ASCII characters. * You may assume the string has a maximum length of 10,000 characters. * An empty string is considered a valid palindrome. # Input Format ``` s: a string containing printable ASCII characters ``` # Output Format Return a boolean indicating whether the string is a palindrome or not. # Example Example 1 ``` Input: s = \\"A man, a plan, a canal: Panama\\" Output: True ``` Example 2 ``` Input: s = \\"race a car\\" Output: False ``` # Implementation Requirements Your implementation should be efficient with respect to both time and space. Aim for a solution with O(n) time complexity and preferably O(1) space complexity. You are free to use any of the four variations provided (or indeed a different approach) but ensure it adheres to the constraints and cases described.","solution":"def is_palindrome(s): Determines if the given string is a palindrome, considering only alphanumeric characters and ignoring cases. Args: s (str): The input string. Returns: bool: True if the string is a palindrome, False otherwise. # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Compare the filtered list with its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"Objective: Implement an optimized version of Gnome Sort that can sort a given array of integers in non-decreasing order. # Explanation: Gnome Sort is a sorting algorithm similar to insertion sort in that it works by comparing each element with its predecessor and swaps them if they are in the wrong order. Your task is to implement this algorithm and test it against various inputs. # Function Signature: ```python def optimized_gnome_sort(arr: List[int]) -> List[int]: ``` # Input: * `arr` (List[int]): A list of integers to be sorted. # Output: * Return the sorted list in non-decreasing order. # Constraints: * The array can have up to `10^4` elements. * The elements of the array can be negative or positive integers. * The algorithm should run efficiently for smaller arrays. # Performance Requirements: * Ensure the algorithm runs within time limits for small arrays and is able to handle edge cases effectively. # Example: ```python assert optimized_gnome_sort([34, 2, 23, -1, 0, 12]) == [-1, 0, 2, 12, 23, 34] assert optimized_gnome_sort([5, 3, 3, 3, 2, 1]) == [1, 2, 3, 3, 3, 5] assert optimized_gnome_sort([]) == [] ``` # Constraints: * Aim to maintain the low space usage and simplicity of the original Gnome Sort. * Handle edge cases like empty arrays or arrays with all identical elements. Instructions: 1. Implement the `optimized_gnome_sort` function using the principles of Gnome Sort. 2. Test your implementation with diverse test cases. 3. Ensure your implementation handles edge cases effectively.","solution":"def optimized_gnome_sort(arr): n = len(arr) if n <= 1: return arr index = 0 while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Question: Cycle Detection in a Directed Graph You have learned about directed graphs from the provided classes. One common problem in directed graphs is detecting cycles. Your task is to implement a method that detects if there is a cycle in the graph. Function Signature ```python def detect_cycle(graph: DirectedGraph) -> bool: Detects if there\'s a cycle in a directed graph. :param graph: DirectedGraph object :return: Boolean value - True if there\'s a cycle, False otherwise ``` # Input - The function will receive a single parameter: - `graph`: An instance of the `DirectedGraph` class. # Output - Return `True` if the graph contains at least one cycle. - Return `False` if the graph contains no cycles. # Constraints - Maximum number of nodes in the graph: (10^3) - Maximum number of edges in the graph: (10^4) # Example ```python # Create an example graph graph_data = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"] } graph = DirectedGraph(graph_data) print(detect_cycle(graph)) # Output: True (There is a cycle: A -> B -> C -> A) graph_data = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [] } graph = DirectedGraph(graph_data) print(detect_cycle(graph)) # Output: False (There are no cycles) ``` # Requirements 1. Implement the function `detect_cycle(graph: DirectedGraph) -> bool` to detect cycles in the directed graph. 2. Ensure the solution adheres to the constraints and runs efficiently. 3. Test edge cases, such as empty graphs and graphs with no edges. # Notes - Consider different graph traversal techniques like DFS (Depth-First Search) to solve this problem. - Use appropriate data structures to keep track of visited nodes and recursion stack for cycle detection.","solution":"def detect_cycle(graph): Detects if there\'s a cycle in a directed graph. :param graph: DirectedGraph object :return: Boolean value - True if there\'s a cycle, False otherwise def dfs(node, visited, rec_stack): if not visited[node]: visited[node] = True rec_stack[node] = True for neighbor in graph.adjacency_list[node]: if not visited[neighbor] and dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[node] = False return False visited = {node: False for node in graph.adjacency_list} rec_stack = {node: False for node in graph.adjacency_list} for node in graph.adjacency_list: if not visited[node]: if dfs(node, visited, rec_stack): return True return False class DirectedGraph: def __init__(self, adjacency_list): self.adjacency_list = adjacency_list"},{"question":"You are tasked to verify whether a given graph is bipartite. A bipartite graph is one whose vertex set can be split into two distinct sets such that no two graph vertices within the same set are adjacent. Implement the function `is_bipartite(graph: List[List[int]]) -> bool` where `graph` is represented in an adjacency list format. Your function should efficiently determine if the graph can be colored using two colors ensuring no two adjacent nodes have the same color. # Input: * `graph`: List of List of integers `graph[i]` denotes the list of vertices connected to the `i`-th vertex. * `1 <= len(graph) <= 1000` (number of vertices) * `0 <= len(graph[i]) <= len(graph) - 1` (each vertex can connect to 0 to len(graph) - 1 other vertices) # Output: * `is_bipartite`: Return true if the graph is bipartite, otherwise return false. # Constraints: * No multiple edges between any pair of vertices. * The graph can be disconnected. # Example: ```python # Example 1: # Input: # graph = [ # [1, 3], # [0, 2], # [1, 3], # [0, 2] # ] # Output: # True # Explanation: # The graph can be colored using two colors as follows: # - Vertex 0: Color 0 # - Vertex 1: Color 1 # - Vertex 2: Color 0 # - Vertex 3: Color 1 # Example 2: # Input: # graph = [ # [1, 2, 3], # [0, 2], # [0, 1, 3], # [0, 2] # ] # Output: # False # Explanation: # The graph cannot be colored using two colors so that no two adjacent nodes have the same color. def is_bipartite(graph: List[List[int]]) -> bool: vertices = len(graph) set_type = [-1] * vertices for start in range(vertices): if set_type[start] == -1: queue = [start] set_type[start] = 0 while queue: current = queue.pop(0) for adjacent in graph[current]: if set_type[adjacent] == -1: set_type[adjacent] = 1 - set_type[current] queue.append(adjacent) elif set_type[adjacent] == set_type[current]: return False return True ``` # Scenario: A software development team is designing a task scheduling system that optimizes the assignment of tasks to avoid conflicts. They need to ensure that no mutually dependent tasks are assigned to the same worker. Your task is to create an algorithm that verifies whether such an assignment is possible by confirming that the task dependency graph is bipartite.","solution":"from typing import List def is_bipartite(graph: List[List[int]]) -> bool: Check if the given graph is bipartite using BFS. n = len(graph) color = [-1] * n # -1 means uncolored, 0 and 1 will represent the two colors for start in range(n): if color[start] == -1: # If the node is not yet colored queue = [start] color[start] = 0 # Start coloring it with color 0 while queue: node = queue.pop(0) for neighbor in graph[node]: if color[neighbor] == -1: # If the neighbor is not colored color[neighbor] = 1 - color[node] # Color it with opposite color queue.append(neighbor) elif color[neighbor] == color[node]: # If the neighbor has the same color return False # Not bipartite return True"},{"question":"# RSA Key Generation & Message Encryption/Decryption You are tasked with implementing a simplified RSA encryption system based on the provided principles and analysis. Complete the following functions to generate RSA key pairs, encrypt messages, and decrypt them using those keys. Functions to Implement ```python def generate_key(k, seed=None): Generate RSA key pairs. Parameters: k (int): Number of bits for n. seed (int): A seed value for randomness (optional). Returns: tuple: (n, e, d) where n is the modulus, e is the encryption exponent, and d is the decryption exponent. pass def encrypt(data, e, n): Encrypt data using RSA algorithm. Parameters: data (int): The message to encrypt. e (int): The encryption exponent. n (int): The modulus. Returns: int: The encrypted message. pass def decrypt(data, d, n): Decrypt data using RSA algorithm. Parameters: data (int): The encrypted message. d (int): The decryption exponent. n (int): The modulus. Returns: int: The decrypted original message. pass ``` # Constraints - `k` is a positive integer representing bits (we\'ll assume sensible values like 16, 32, 64 for testing). - The encryption exponent `e` will be chosen as a random prime. - `data` will be a positive integer less than `n`. # Performance Requirements - Generate RSA keys efficiently considering the provided constraints. - Ensure that encryption and decryption processes work correctly and securely. # Scenario Consider an online secure communication system that needs to generate RSA keys for users to ensure their messages are securely transmitted. Implement the required functions so the system can handle key generation and message encryption/decryption correctly. # Example ```python n, e, d = generate_key(16) data = 42 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data, \\"Decryption failed\\" ``` Implement the functions to ensure the assertion passes, and secure communication can be achieved as described.","solution":"import random from sympy import isprime, mod_inverse def generate_key(k, seed=None): if seed is not None: random.seed(seed) # Step 1: Choose two distinct prime numbers p and q while True: p = random.getrandbits(k // 2) if isprime(p): break while True: q = random.getrandbits(k // 2) if isprime(q) and q != p: break # Step 2: Compute n = pq n = p * q # Step 3: Compute φ(n) = (p-1)(q-1) phi_n = (p - 1) * (q - 1) # Step 4: Choose an integer e such that 1 < e < φ(n) and gcd(e, φ(n)) = 1; typically e is a small prime like 65537 while True: e = random.randint(3, phi_n - 1) if isprime(e) and phi_n % e != 0: break # Step 5: Determine d as d ≡ e^(-1) (mod φ(n)) d = mod_inverse(e, phi_n) return (n, e, d) def encrypt(data, e, n): Encrypt data using RSA algorithm. Parameters: data (int): The message to encrypt. e (int): The encryption exponent. n (int): The modulus. Returns: int: The encrypted message. return pow(data, e, n) def decrypt(data, d, n): Decrypt data using RSA algorithm. Parameters: data (int): The encrypted message. d (int): The decryption exponent. n (int): The modulus. Returns: int: The decrypted original message. return pow(data, d, n)"},{"question":"You are given an array of integers `arr` of length `n`, where `n` is up to `10^5`. You need to support the following operations: 1. **Update(i, x)**: Update the value of the element at index `i` to `x`. 2. **Query(i)**: Return the sum of the elements from the start of the array to the ith index (prefix sum). Implement a class `FenwickTree` that supports these operations efficiently using the Fenwick Tree (Binary Indexed Tree) data structure. The class should include the following methods: - `__init__(self, arr: List[int])`: Constructor to initialize the Fenwick Tree with the given array. - `update(self, i: int, x: int) -> None`: Update the value at index `i` to `x`. - `query(self, i: int) -> int`: Return the prefix sum up to the ith index. **Input Format**: - You will receive operations as a list of tuples. Each tuple represents an operation. - The first element is a string indicating the operation type (\\"Update\\" or \\"Query\\"). - For \\"Update\\", the tuple will be (\\"Update\\", i, x) where `i` is the index and `x` is the new value. - For \\"Query\\", the tuple will be (\\"Query\\", i) where `i` is the index. **Output Format**: - For each \\"Query\\" operation, return the result as part of a list. **Constraints**: - `0 <= i < n` - The array will contain integers within the range `[-10^9, 10^9]`. # Example: ```python # Example input arr = [1, 7, 3, 0, 7, 8, 3, 2, 6, 2] operations = [(\\"Update\\", 2, 5), (\\"Query\\", 5), (\\"Update\\", 5, 1), (\\"Query\\", 5)] # Expected Output # Initial array: [1, 7, 3, 0, 7, 8, 3, 2, 6, 2] # After (\\"Update\\", 2, 5): [1, 7, 5, 0, 7, 8, 3, 2, 6, 2] # Prefix sum up to index 5: 1 + 7 + 5 + 0 + 7 + 8 = 28 # After (\\"Update\\", 5, 1): [1, 7, 5, 0, 7, 1, 3, 2, 6, 2] # Prefix sum up to index 5: 1 + 7 + 5 + 0 + 7 + 1 = 21 fenwick_tree = FenwickTree(arr) results = [] for op in operations: if op[0] == \\"Update\\": fenwick_tree.update(op[1], op[2]) elif op[0] == \\"Query\\": results.append(fenwick_tree.query(op[1])) print(results) # Output: [28, 21] ``` Please implement the `FenwickTree` class as described.","solution":"from typing import List class FenwickTree: def __init__(self, arr: List[int]): self.n = len(arr) self.tree = [0] * (self.n + 1) self.arr = [0] * self.n for i, val in enumerate(arr): self.update(i, val) def update(self, i: int, x: int) -> None: delta = x - self.arr[i] self.arr[i] = x i += 1 # Fenwick Tree indices start from 1 while i <= self.n: self.tree[i] += delta i += i & -i def query(self, i: int) -> int: i += 1 # Fenwick Tree indices start from 1 result = 0 while i > 0: result += self.tree[i] i -= i & -i return result"},{"question":"You are given two functions, `encode_rle` and `decode_rle`, that perform Run-Length Encoding (RLE) and decoding, respectively. RLE is a simple compression algorithm that encodes consecutive character sequences by storing the character and its count. Your task is to modify and optimize these functions to handle all possible edge cases efficiently, enhance their performance, and ensure correctness under varied input conditions. # Objective * Implement a `optimized_encode_rle` function that: - Compresses a given string using RLE. - Improves upon the provided `encode_rle` in terms of performance and robustness. * Implement a `optimized_decode_rle` function that: - Expands a given RLE encoded string back to its original. - Handles edge cases and optimizes the decoding process for large counts and long sequences. # Requirements Encode Function * **Input**: A string `input`. * **Output**: A string representing the RLE-encoded data. * **Constraints**: - All characters in the input are valid ASCII characters. - The input string can be empty. Decode Function * **Input**: A string `input`. * **Output**: A string representing the original uncompressed data. * **Constraints**: - The input string is a valid RLE-encoded string. # Performance Constraints * Your solution should be optimized for large inputs (millions of characters). # Function Signatures ```python def optimized_encode_rle(input: str) -> str: pass def optimized_decode_rle(input: str) -> str: pass ``` # Example Encoding ```python optimized_encode_rle(\\"aaabbc\\") # Output: \\"3a2b1c\\" optimized_encode_rle(\\"abcd\\") # Output: \\"1a1b1c1d\\" optimized_encode_rle(\\"\\") # Output: \\"\\" ``` Decoding ```python optimized_decode_rle(\\"3a2b1c\\") # Output: \\"aaabbc\\" optimized_decode_rle(\\"1a1b1c1d\\") # Output: \\"abcd\\" optimized_decode_rle(\\"\\") # Output: \\"\\" ``` # Additional Notes - Ensure proper handling of edge cases, such as empty strings and strings with no repeated characters. - Consider performance optimizations, like avoiding string concatenations in loops.","solution":"def optimized_encode_rle(input: str) -> str: Compresses the input string using Run-Length Encoding (RLE). if not input: return \\"\\" encoded_str = [] count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded_str.append(f\\"{count}{input[i - 1]}\\") count = 1 encoded_str.append(f\\"{count}{input[-1]}\\") # Handle the last character and its count return \'\'.join(encoded_str) def optimized_decode_rle(input: str) -> str: Expands the RLE-encoded string back to its original form. if not input: return \\"\\" decoded_str = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) # Handle multi-digit counts else: decoded_str.append(char * count) count = 0 # Reset count return \'\'.join(decoded_str)"},{"question":"# Longest Common Subsequence Finder Scenario Given two strings, `s1` and `s2`, where `s2` contains all distinct characters, you are tasked with finding the length of the longest common subsequence shared by both strings. This is an important task in text processing and can help in various applications, from DNA sequencing to plagiarism detection. Function Signature ```python def max_common_substring_length(s1: str, s2: str) -> int: pass ``` Input - `s1`: A string containing any characters. (1 ≤ |s1| ≤ 10^5) - `s2`: A string containing distinct characters. (1 ≤ |s2| ≤ 10^5) Output - An integer representing the length of the longest common subsequence between `s1` and `s2`. Constraints - The algorithm should have a time complexity of O(n log n). Examples ```python # Example 1: s1 = \\"abcde\\" s2 = \\"ace\\" assert max_common_substring_length(s1, s2) == 1 # Example 2: s1 = \\"axabcxb\\" s2 = \\"abc\\" assert max_common_substring_length(s1, s2) == 2 # Example 3: s1 = \\"xyz\\" s2 = \\"abc\\" assert max_common_substring_length(s1, s2) == 0 ``` Notes - The output should be the length of the longest substring that can be found in both strings.","solution":"def max_common_substring_length(s1: str, s2: str) -> int: Returns the length of the longest common subsequence of distinct characters appearing in both s1 and s2. s2_chars = set(s2) common_chars_s1 = [char for char in s1 if char in s2_chars] # If common_chars_s1 is empty or has no repeating characters if not common_chars_s1: return 0 # Finding longest common substring using two pointers technique longest = 0 current_length = 0 current_char = \\"\\" for char in common_chars_s1: if char != current_char: longest = max(longest, current_length) current_length = 1 current_char = char else: current_length += 1 return max(longest, current_length)"},{"question":"# Scenario You are tasked with designing a low-level network component that requires manipulation of packet headers at the binary level. One of your tasks is to reverse the bits of a packet identifier in order to prepare it for certain cryptographic transformations. # Objective Write a function `reverse_bits` that takes an unsigned 32-bit integer and returns the integer resulting from reversing its bits. # Function Signature ```python def reverse_bits(n: int) -> int: ``` # Parameters - `n`: A 32-bit unsigned integer (0 <= n <= 2^32 - 1). # Output - Returns an integer that is the bit-reversed value of the input. # Example ```python # Example 1 input_num = 43261596 # binary: 00000010100101000001111010011100 # reversed: 00111001011110000010100101000000 # expected output: 964176192 print(reverse_bits(input_num)) # 964176192 # Example 2 input_num = 4294967293 # binary: 11111111111111111111111111111101 # reversed: 10111111111111111111111111111111 # expected output: 3221225471 print(reverse_bits(input_num)) # 3221225471 ``` # Constraints - The function must operate within O(1) time complexity. - You must use bitwise operations to achieve the result. - Do not use any in-built functions for bit reversal or conversion between binary and decimal forms. # Performance Requirements - Ensure the function executes in constant time and uses minimal extra space. # Additional Notes - Handle edge cases such as when all bits in the input integer are `0` or `1`.","solution":"def reverse_bits(n: int) -> int: reversed_num = 0 for i in range(32): bit = (n >> i) & 1 reversed_num |= (bit << (31 - i)) return reversed_num"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: Ford-Fulkerson method using Depth-First Search (DFS) for finding the maximum flow in a flow network. * **Complexity**: * **Time Complexity**: O(E * f), where E is the number of edges and f is the maximum flow. This complexity arises because in each iteration, we are traversing through the edges using DFS and updating the flow. * **Space Complexity**: O(V^2), due to the storage of the adjacency matrix, where V is the number of vertices. * **Principles**: * **Initial Setup**: Create a copy of the adjacency matrix to keep track of residual capacities. * **Path Finding**: Use DFS to find augmenting paths from the source to the sink. * **Augmenting Flow**: Calculate the minimum capacity of the found path, augment flow along the path, and update residual capacities. * **Termination**: Repeat the process until no augmenting path can be found. Characteristics & Applications * **Properties**: * Uses DFS for path-finding, making it path-based. * Updates residual capacities along the found paths. * Terminates when no further augmenting paths are available. * **Common Use Cases**: * Network routing optimization. * Bipartite matching. * Circulation with demands in networks. * **Strengths/Limitations**: * **Strengths**: Simple to implement with clear logical steps, reasonably efficient for moderate-sized networks. * **Limitations**: Can be inefficient for large networks due to non-deterministic path selection using DFS, which might take longer compared to strategies like BFS (Breadth-First Search) as used in the Edmonds-Karp algorithm. Implementation Challenges * **Edge Cases**: * No available path from source to sink right at the start. * Multiple edges with the same maximum capacity. * Networks with cycles. * **Performance Bottlenecks**: * Inefficiency in finding augmenting paths could lead to long runtime for networks with high maximum flow due to reliance on DFS. * **Error Scenarios**: * Incorrect handling of residual capacities can lead to incorrect flow calculations. * Potential infinite loops if paths are not updated correctly. * **Optimization Points**: * Use BFS instead of DFS (as in Edmonds-Karp) to improve path-finding efficiency. * Implement capacity scaling to deal with large capacity edges more effectively. <|Analysis End|> <|Question Begin|> # Maximum Network Flow Using DFS Problem Statement You are given a directed flow network represented as an n x n adjacency matrix. Each entry `graph[i][j]` represents the capacity of the edge from node i to node j. Your task is to implement a function that calculates the maximum flow from the source (node 0) to the sink (node n-1) using the Ford-Fulkerson method with Depth-First Search (DFS). Function Signature ```python def maximum_flow_dfs(adjacency_matrix: List[List[int]]) -> int: # Your implementation here ``` Input - `adjacency_matrix`: A 2D list of integers where `adjacency_matrix[i][j]` represents the capacity of the edge from node i to node j. It is guaranteed to have non-negative integer values, with no self-loops. Output - An integer that represents the maximum possible flow from the source to the sink. Constraints - `1 <= n <= 1000` (n is the number of nodes) - `0 <= adjacency_matrix[i][j] <= 10^6` (capacity of each edge) Example ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] print(maximum_flow_dfs(graph)) # Expected output: 23 ``` Additional Notes - Carefully handle updating the residual capacities after each augmentation. - Consider edge cases like no paths from source to sink. - Ensure to handle directed edges appropriately.","solution":"from typing import List def maximum_flow_dfs(adjacency_matrix: List[List[int]]) -> int: n = len(adjacency_matrix) residual_graph = [row[:] for row in adjacency_matrix] source, sink = 0, n - 1 parent = [-1] * n max_flow = 0 def dfs(u, min_capacity): if u == sink: return min_capacity visited[u] = True for v in range(n): if not visited[v] and residual_graph[u][v] > 0: min_cap = min(min_capacity, residual_graph[u][v]) result = dfs(v, min_cap) if result > 0: residual_graph[u][v] -= result residual_graph[v][u] += result return result return 0 while True: visited = [False] * n path_flow = dfs(source, float(\'Inf\')) if path_flow == 0: break max_flow += path_flow return max_flow"},{"question":"# Linked List Palindrome Checker Objective Given a singly linked list, you need to determine if the list is a palindrome. A list is considered a palindrome if it reads the same forwards and backwards. Function Specifications Implement the function `def check_palindrome(head: ListNode) -> bool:` where: - `head` is a `ListNode` object representing the head of a singly linked list. Your task is to: 1. Identify the midpoint of the list. 2. Reverse the second half of the list. 3. Compare the two halves to determine if the list is a palindrome. 4. Restore the list to its original order before returning the result. Constraints - The function must handle lists with up to 10^5 nodes efficiently. - You may assume that the input list nodes contain integer values. Example Consider the following linked list: ``` Input: 1 -> 2 -> 2 -> 1 Output: True ``` Explanation: The list reads the same forwards and backwards. Consider this example: ``` Input: 1 -> 2 -> 3 -> 2 -> 1 Output: True ``` Explanation: The list reads the same forwards and backwards. Edge Cases - Empty list or single node list should return True. - Lists with odd and even number of nodes should be correctly handled. Implement the function to meet the above requirements and constraints.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def check_palindrome(head: ListNode) -> bool: if not head or not head.next: return True slow = head fast = head # Step 1: Find the middle of the linked list while fast and fast.next: slow = slow.next fast = fast.next.next # Step 2: Reverse the second half of the linked list second_half_start = reverse_list(slow) # Step 3: Compare the first half and the reversed second half first_half_start = head second_half_copy = second_half_start while second_half_start: if first_half_start.val != second_half_start.val: return False first_half_start = first_half_start.next second_half_start = second_half_start.next # Step 4: Restore the list (optional) reverse_list(second_half_copy) return True"},{"question":"# Question: Implement a Separate Chaining Hash Table with Auto-Resizing A hash table is a data structure that maps keys to values, allowing for efficient data retrieval. One common method to handle collisions (when multiple keys hash to the same index) is the separate chaining technique, where each bucket in the table is a linked list of entries that have hashed to that bucket. Using the provided code as a foundation, extend the `SeparateChainingHashTable` class to include the following functionalities: 1. **Auto-Resizing**: - Implement auto-resizing for the hash table. When the number of key-value pairs exceeds 70% of the bucket size, double the table size and rehash all existing keys. 2. **Handling Updates**: - Ensure that inserting a duplicate key updates the existing value rather than adding a new entry. 3. **Iterative Methods**: - Implement methods to iterate over keys and values in the hash table. # Function Signature: ```python class SeparateChainingHashTableWithResizing(SeparateChainingHashTable): def __init__(self, size=11): Initializes a new hash table with the given initial size. super().__init__(size) def put(self, key, value): Add a key-value pair to the hash table. If the key already exists, update the value. If the number of items exceeds 70% of the bucket size, resize the table. # Implementation here def keys(self): Returns an iterator over the keys in the hash table. # Implementation here def values(self): Returns an iterator over the values in the hash table. # Implementation here def resize(self, new_size): Resizes the hash table to the new size and rehashes all existing keys. # Implementation here ``` # Constraints and Performance Requirements - The initial size of the hash table should be a prime number and should be doubled during resizing. - Ensure O(1) average time complexity for put, get, and del operations, and O(n) for the resizing operation. - Edge cases include attempting to retrieve or delete non-existent keys, resizing the table, and properly updating existing keys. Write a test suite to demonstrate the correctness and efficiency of your implementation.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None class SeparateChainingHashTableWithResizing: def __init__(self, size=11): self.size = size self.count = 0 self.buckets = [None] * size def _hash(self, key): return hash(key) % self.size def _load_factor(self): return self.count / self.size def put(self, key, value): index = self._hash(key) new_node = Node(key, value) node = self.buckets[index] if node is None: self.buckets[index] = new_node self.count += 1 else: while node.next is not None and node.key != key: node = node.next if node.key == key: node.value = value else: node.next = new_node self.count += 1 if self._load_factor() > 0.7: self._resize() def get(self, key): index = self._hash(key) node = self.buckets[index] while node is not None: if node.key == key: return node.value node = node.next raise KeyError(\\"Key not found\\") def delete(self, key): index = self._hash(key) node = self.buckets[index] prev_node = None while node is not None: if node.key == key: if prev_node is None: self.buckets[index] = node.next else: prev_node.next = node.next self.count -= 1 return prev_node = node node = node.next raise KeyError(\\"Key not found\\") def keys(self): for bucket in self.buckets: node = bucket while node is not None: yield node.key node = node.next def values(self): for bucket in self.buckets: node = bucket while node is not None: yield node.value node = node.next def _resize(self): old_buckets = self.buckets new_size = self._next_prime(2 * self.size) self.buckets = [None] * new_size self.size = new_size self.count = 0 for bucket in old_buckets: node = bucket while node is not None: self.put(node.key, node.value) node = node.next def _next_prime(self, n): def is_prime(k): if k <= 1: return False for i in range(2, int(k**0.5) + 1): if k % i == 0: return False return True while not is_prime(n): n += 1 return n"},{"question":"Problem Statement: You are given a directed graph with V vertices and E edges. You need to determine if the graph is strongly connected. A graph is strongly connected if there is a path between any pair of vertices u and v. Task: Complete the implementation of the `is_strongly_connected` function using Kosaraju\'s Algorithm. - The function signature is as follows: ```python def is_strongly_connected(self) -> bool: ``` - You are provided with the `Graph` class having the following methods: - `__init__(self, vertex_count)`: Initializes a graph with a specified number of vertices. - `add_edge(self, source, target)`: Adds an edge from `source` to `target`. - `dfs(self)`: Determines if all nodes are reachable from node 0. - `dfs_util(self, source, visited)`: Helper method to perform DFS traversal. - `reverse_graph(self)`: Reverses all edges in the graph. Input Format: - An integer `V` representing the number of vertices. - An integer `E` representing the number of edges. - E pairs of integers representing the directed edges between two vertices. Output Format: - A boolean value `True` if the graph is strongly connected, `False` otherwise. Constraints: 1. 1 ≤ V ≤ 5000 2. 0 ≤ E ≤ 10000 3. 0 ≤ source, target < V Example: ```python # Graph with 3 vertices (numbered 0, 1, and 2) # Edge list: [(0, 1), (1, 2), (2, 0)] g = Graph(3) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 0) print(g.is_strongly_connected()) # Output: True # Graph with 3 vertices (numbered 0, 1, and 2) # Edge list: [(0, 1), (1, 2)] g = Graph(3) g.add_edge(0, 1) g.add_edge(1, 2) print(g.is_strongly_connected()) # Output: False ```","solution":"class Graph: def __init__(self, vertex_count): self.V = vertex_count self.adj = [[] for _ in range(vertex_count)] self.rev_adj = [[] for _ in range(vertex_count)] def add_edge(self, source, target): self.adj[source].append(target) self.rev_adj[target].append(source) def dfs_util(self, vertex, visited, graph): visited[vertex] = True for neighbor in graph[vertex]: if not visited[neighbor]: self.dfs_util(neighbor, visited, graph) def dfs(self, start_vertex, graph): visited = [False] * self.V self.dfs_util(start_vertex, visited, graph) return visited def is_strongly_connected(self): # Step 1: Perform DFS on original graph starting from vertex 0 visited = self.dfs(0, self.adj) if not all(visited): return False # Step 2: Perform DFS on transposed graph starting from vertex 0 rev_visited = self.dfs(0, self.rev_adj) if not all(rev_visited): return False return True"},{"question":"You are required to implement the Bucket Sort algorithm with the following specifications and constraints. # Input: * An array `arr` of `n` non-negative integers where (1 leq n leq 10^5). * The integers in `arr` range from `0` to `10000`. # Output: * A sorted array containing the same elements as `arr`. # Constraints: * You are free to choose the number of buckets, but make sure that all elements are sorted correctly. * You must handle edge cases such as the input array being empty. * You should ensure that your solution handles the maximum constraints efficiently. # Example: ```python Input: [64, 25, 12, 22, 11] Output: [11, 12, 22, 25, 64] ``` # Notes: - You must use a sorting algorithm of your choice to sort individual buckets. - Ensure that the bucket distribution and sorting steps maintain the stability of the sorted result. # Implementation Details: 1. Implement a function `bucket_sort(arr)` that takes a list of integers and returns a sorted list of integers. 2. Implement an internal sorting function (`next_sort`) that can be used to sort individual buckets. # Your Code Goes Here: ```python def bucket_sort(arr): \'\'\' Bucket Sort \'\'\' if not arr: return arr max_value = max(arr) size = max_value // len(arr) # Create buckets buckets = [[] for _ in range(len(arr))] # Assign elements to the bucket for v in arr: index = v // size if index != len(arr): buckets[index].append(v) else: buckets[len(arr) - 1].append(v) # Sort each bucket and concatenate sorted_array = [] for bucket in buckets: sorted_array.extend(next_sort(bucket)) return sorted_array def next_sort(arr): \'\'\' Insertion Sort \'\'\' for i in range(1, len(arr)): j = i - 1 key = arr[i] while arr[j] > key and j >= 0: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr ```","solution":"def bucket_sort(arr): \'\'\' Bucket Sort \'\'\' if not arr: return arr max_value = max(arr) bucket_count = len(arr) size = (max_value / bucket_count) + 1 # Create buckets buckets = [[] for _ in range(bucket_count)] # Assign elements to the bucket for v in arr: index = int(v / size) buckets[index].append(v) # Sort each bucket and concatenate sorted_array = [] for bucket in buckets: sorted_array.extend(next_sort(bucket)) return sorted_array def next_sort(arr): \'\'\' Insertion Sort \'\'\' for i in range(1, len(arr)): j = i - 1 key = arr[i] while arr[j] > key and j >= 0: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"You are given two strings `haystack` and `needle`. Your task is to implement the function `contain_string(haystack, needle)` which returns the index of the first occurrence of `needle` in `haystack`. If `needle` is not part of `haystack`, return -1. # Input * `haystack`: A non-empty string consisting of lowercase English letters. * `needle`: A string that can be empty and consists of lowercase English letters. # Output * An integer representing the index of the first occurrence of `needle` in `haystack` or -1 if `needle` is not part of `haystack`. # Constraints 1. The input strings can be up to 10^5 characters in length. 2. The search should be case-sensitive. # Examples 1. **Input**: haystack = \\"hello\\", needle = \\"ll\\" **Output**: 2 2. **Input**: haystack = \\"aaaaa\\", needle = \\"bba\\" **Output**: -1 3. **Input**: haystack = \\"mississippi\\", needle = \\"issip\\" **Output**: 4 4. **Input**: haystack = \\"hello\\", needle = \\"\\" **Output**: 0 # Performance Requirements * Aim to achieve a solution that works within reasonable time limits for large inputs. * Consider edge cases and optimize for them within your implementation. # Notes * You are required to handle edge cases where `needle` is empty or larger than `haystack`. * Use efficient string comparison practices to manage time complexity.","solution":"def contain_string(haystack, needle): Returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Using Python\'s built-in find method is efficient and straightforward. return haystack.find(needle)"},{"question":"Context You are developing a software that requires high-efficiency processing of binary data. A crucial part of your task is to ensure correct and efficient summation of large binary numbers without directly converting them to integers due to potential overflow issues. Task Write a Python function `add_binary` that takes two binary strings as input and returns their sum as a binary string. Function Signature ```python def add_binary(a: str, b: str) -> str: pass ``` Input * `a: str` - a binary string consisting of \'0\' or \'1\'. * `b: str` - another binary string consisting of \'0\' or \'1\'. Output * A binary string representing the sum of the two input binary strings. Constraints * Both `a` and `b` will have lengths between 1 and 105. * Each character in the binary strings `a` and `b` is either \'0\' or \'1\'. Examples ```python add_binary(\\"11\\", \\"1\\") -> \\"100\\" add_binary(\\"1010\\", \\"1011\\") -> \\"10101\\" add_binary(\\"1101\\", \\"101\\") -> \\"10010\\" ``` Requirements * Your implementation should handle different lengths of input strings efficiently. * The function should not use any external libraries for converting binary to decimal or vice versa. * Ensure to handle carry and edge cases properly. Evaluation Criteria * Correct implementation of the binary addition. * Efficiency in terms of time and space complexity.","solution":"def add_binary(a: str, b: str) -> str: Adds two binary strings and returns their sum as a binary string. # Initialize result result = [] # Initialize carry to 0 carry = 0 # Initialize pointers for both strings i, j = len(a) - 1, len(b) - 1 # Traverse both strings from end to start while i >= 0 or j >= 0 or carry: # Compute the sum of current digits and carry digit_a = int(a[i]) if i >= 0 else 0 digit_b = int(b[j]) if j >= 0 else 0 total = digit_a + digit_b + carry # Compute digit to add to result (0 or 1) result.append(str(total % 2)) # Compute new carry (0 or 1) carry = total // 2 # Move pointers left i -= 1 j -= 1 # The result is in reverse order, so reverse it before returning return \'\'.join(result[::-1])"},{"question":"# Coding Challenge: Two Sum with Validation Objective Implement a function to find two indices in an array such that the elements at those indices sum up to a specific target value. Problem Statement Given an array of integers, return indices of the two numbers such that they add up to a specific target. Ensure your solution handles various edge cases and validates input constraints effectively. Constraints - Each input will have exactly one solution. - You may not use the same element twice. - The input array will have at least two elements. - Array elements and the target can be both positive and negative integers. Function Signature ```python def two_sum(array: List[int], target: int) -> Tuple[int, int]: pass ``` Input and Output - **Input**: - `array` (List[int]): A list of integers. - `target` (int): The target sum value. - **Output**: - Returns a tuple (int, int) containing the indices of the two elements that sum up to the target. Example ```python # Example 1 input_array = [2, 7, 11, 15] target_value = 9 # Expected Output: (0, 1) print(two_sum(input_array, target_value)) # Example 2 input_array = [3, 2, 4] target_value = 6 # Expected Output: (1, 2) print(two_sum(input_array, target_value)) # Example 3 input_array = [-1, -2, -3, -4, -5] target_value = -8 # Expected Output: (2, 4) print(two_sum(input_array, target_value)) ``` Notes - Ensure your implementation is efficient and handles edge cases like negative numbers and zero properly. - Assume the input list will always have at least one valid pair.","solution":"from typing import List, Tuple def two_sum(array: List[int], target: int) -> Tuple[int, int]: Finds two indices in the array such that the elements at those indices sum up to the target value. Parameters: - array: List[int]: A list of integers. - target: int: The target sum value. Returns: - A tuple (int, int) containing the indices of the two elements that sum up to the target. # Dictionary to store the index of the number we have seen seen = {} for index, number in enumerate(array): # Calculate the complement number that we need to find complement = target - number # Check if the complement is already in the dictionary if complement in seen: return (seen[complement], index) # If not, add the number with its index to the dictionary seen[number] = index"},{"question":"**Scenario**: You are developing a text editor feature that assists programmers by highlighting matching parentheses. A core part of this feature is to validate whether the parentheses, brackets, and braces in a given string are balanced and correctly nested. **Task**: Write a function `is_valid_expression(expression: str) -> bool` that determines if the input string `expression` containing just the characters `\'(\', \')\', \'{\', \'}\', \'[\' and \']\'` is valid. # Function Specifications: - **Input**: A string `expression` containing characters `\'(\', \')\', \'{\', \'}\', \'[\' and \']\'` only. - **Output**: Return a boolean value `True` if the input string is valid, `False` otherwise. A string is considered valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. # Examples: Example 1 Input: `expression = \\"()\\"` Output: `True` Example 2 Input: `expression = \\"()[]{}\\"` Output: `True` Example 3 Input: `expression = \\"(]\\"` Output: `False` Example 4 Input: `expression = \\"([)]\\"` Output: `False` Example 5 Input: `expression = \\"{[]}\\"` Output: `True` # Constraints: - The input string length is at least `0` and can be up to `10^4`. - The input only contains the characters `\'(\', \')\', \'{\', \'}\', \'[\' and \']\'`.","solution":"def is_valid_expression(expression: str) -> bool: Determines if the input string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' is valid. A string is considered valid if: 1. Open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. :param expression: String containing the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' :return: Boolean indicating if the input string is valid stack = [] matching_parentheses = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in expression: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses: if not stack or stack.pop() != matching_parentheses[char]: return False return not stack"},{"question":"Implement a `ResizableHashTable` class that extends a basic `HashTable` provided with dynamic resizing. Ensure that: 1. The `put` method resizes the hash table when the number of elements exceeds two-thirds of its capacity. 2. The new size of the hash table after resizing should be double the current capacity. 3. Handle edge cases such as inserting into a full hash table and removing elements properly. **Function Signature**: ```python class ResizableHashTable(HashTable): def __init__(self): super().__init__() def put(self, key, value): # Your implementation here def __resize(self): # Your implementation here ``` **Example**: ```python table = ResizableHashTable() table.put(1, \'one\') table.put(2, \'two\') table.put(3, \'three\') print(table.get(1)) # Output: one print(table.get(2)) # Output: two print(table.get(3)) # Output: three table.del_(2) print(table.get(2)) # Output: None ``` **Constraints**: * The hash function used should be simple and deterministic. * Use linear probing for collision resolution. * The initial capacity of the hash table should be 8. * Handle value replacements properly if the key already exists. **Notes**: * Focus on efficiency and correctness. * Ensure the hash table resizes dynamically and handles collisions appropriately using linear probing.","solution":"class HashTable: def __init__(self, capacity=8): self.capacity = capacity self.size = 0 self.table = [None] * self.capacity def hash_function(self, key): return hash(key) % self.capacity def put(self, key, value): index = self.hash_function(key) while self.table[index] is not None: if self.table[index][0] == key: break index = (index + 1) % self.capacity if self.table[index] is None: self.size += 1 self.table[index] = (key, value) def get(self, key): index = self.hash_function(key) while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.capacity return None def del_(self, key): index = self.hash_function(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.size -= 1 return index = (index + 1) % self.capacity class ResizableHashTable(HashTable): def __init__(self, capacity=8): super().__init__(capacity) def put(self, key, value): if self.size >= 2 * self.capacity // 3: self.__resize() super().put(key, value) def __resize(self): old_capacity = self.capacity old_table = self.table new_capacity = old_capacity * 2 self.table = [None] * new_capacity self.capacity = new_capacity self.size = 0 for item in old_table: if item is not None: super().put(item[0], item[1])"},{"question":"You are required to implement a function to perform `ternary search` on a sorted array of integers. The function should return the index of the specified key if it is present in the array, else return -1. Ensure your implementation is robust against various edge cases and performs efficiently for large datasets. # Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: ``` # Input * `left` (int): The starting index of the segment of the array to search. * `right` (int): The ending index of the segment of the array to search. * `key` (int): The value to search for in the array. * `arr` (List[int]): The sorted list of integers to search within. # Output * An integer, the index of the key in the array if found, otherwise -1. # Constraints * `0 <= left <= right < len(arr)` for valid input ranges. * The array `arr` is non-empty and sorted in ascending order. * The length of `arr` can be up to (10^6). # Example ```python # Example 1: assert ternary_search(0, 5, 3, [1, 2, 3, 4, 5, 6]) == 2 # Example 2: assert ternary_search(0, 4, 10, [1, 5, 8, 12, 15]) == -1 # Example 3: assert ternary_search(1, 3, 5, [1, 3, 5, 7, 9]) == 2 ``` # Detailed Description The function should perform the ternary search according to the following steps: 1. Calculate two midpoints, mid1 and mid2. 2. Compare the key with the values at the midpoints. 3. Depending on the comparison, narrow down the search to one of the three parts of the list. 4. Recursively or iteratively repeat the process on the narrowed segment until either the key is found or the segment is empty. 5. Return the index of the key if found, otherwise return -1. Ensure efficiency and correctness by handling all edge cases such as an empty array or key not found scenarios.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: while left <= right: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"**Question: Implement and Optimize Bucket Sort** # Scenario You are working to improve a data analysis pipeline where large datasets of floating-point numbers need to be sorted efficiently. The data tends to be uniformly distributed across a range, but you also want the solution to gracefully handle the cases where the data distribution is skewed. # Task 1. Implement the bucket sort algorithm detailed above. 2. Optimize the `next_sort` method to improve performance, considering an alternative sorting algorithm for larger subarrays. 3. Ensure that your solution handles edge cases like empty input arrays, arrays with single elements, and non-uniform distributions effectively. # Requirements 1. **Function Signature**: - Input: `List[float]` (an array of floating-point numbers) - Output: `List[float]` (sorted array) 2. **Constraints**: - Do not use Python\'s built-in sort functions for the main sorting mechanism. - Optimize for efficiency and stability. - Ensure that sorting within buckets is as efficient as possible. 3. **Performance**: - Your implementation should aim for average case O(n + k) efficiency where `n` is the number of elements and `k` is the number of buckets. - Handle input sizes up to 10,000 elements efficiently. # Example ```python def bucket_sort(arr: List[float]) -> List[float]: # Your optimized implementation here # Example usage data = [0.42, 0.32, 0.23, 0.52, 0.25, 0.47, 0.51] sorted_data = bucket_sort(data) print(sorted_data) # Expected output: [0.23, 0.25, 0.32, 0.42, 0.47, 0.51, 0.52] ``` # Notes 1. Explain the choice of the internal sorting algorithm and justify why it\'s appropriate. 2. Highlight any additional optimizations or checks incorporated to handle edge cases or improve performance.","solution":"from typing import List def insertion_sort(arr: List[float]) -> List[float]: A simple implementation of insertion sort that will sort the elements in a list. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def bucket_sort(arr: List[float]) -> List[float]: Sorts a list of floating-point numbers using the bucket sort algorithm. if len(arr) == 0: return [] # Initializing buckets num_buckets = len(arr) buckets = [[] for _ in range(num_buckets)] # Insert elements into buckets for num in arr: # Use the range of the elements to decide the appropriate bucket index = int(num_buckets * num) if index != num_buckets: buckets[index].append(num) else: buckets[num_buckets - 1].append(num) # Sort individual buckets for i in range(num_buckets): buckets[i] = insertion_sort(buckets[i]) # Concatenate the result to form the sorted array sorted_array = [] for bucket in buckets: sorted_array.extend(bucket) return sorted_array"},{"question":"# Coding Challenge Context You are designing a network protocol where you need to send and receive a list of strings efficiently. You have to implement two functions that encode a list of strings into a single string for transmission and decode it back to the original list of strings upon receipt. Task Write two functions `encode` and `decode`: 1. **encode(strs: List[str]) -> str** - Encodes a list of strings to a single string. - **Input**: - `strs`: List of strings (0 <= len(strs) <= 10^4, 0 <= len(str) <= 10^5) - **Output**: - A single encoded string. 2. **decode(s: str) -> List[str]** - Decodes a single string to a list of strings. - **Input**: - `s`: Encoded string. - **Output**: - List of original strings. Constraints - You may assume that the decoded list of strings will not contain strings with the \':\' character or that the \':\' character is not used as a delimiter by mistake. - The encoding format should be consistent across encoding and decoding to ensure accuracy. - Performance and memory efficiency should be considered due to the potential size of the strings. Example ```python # Examples for encode and decode input_strs = [\\"hello\\", \\"world\\", \\"apple\\"] encoded_str = encode(input_strs) print(encoded_str) # \\"5:hello5:world5:apple\\" decoded_strs = decode(encoded_str) print(decoded_strs) # [\\"hello\\", \\"world\\", \\"apple\\"] input_strs_empty = [] encoded_str_empty = encode(input_strs_empty) print(encoded_str_empty) # \\"\\" decoded_strs_empty = decode(encoded_str_empty) print(decoded_strs_empty) # [] ``` Implement the `encode` and `decode` functions to pass all test cases including edge cases. The functions should handle large lists and strings efficiently.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. encoded_str = \'\' for s in strs: encoded_str += f\'{len(s)}:{s}\' return encoded_str def decode(s: str) -> List[str]: Decodes a single string to a list of strings. decoded_list = [] i = 0 # Position in the encoded string while i < len(s): j = s.find(\':\', i) # Find the next \':\' delimiter length = int(s[i:j]) # Extract the length of the next string decoded_list.append(s[j+1:j+1+length]) # Extract the string of the given length i = j + 1 + length # Move to the next position return decoded_list"},{"question":"**Context**: You are given two strings, `s` and `t`, consisting only of lowercase letters. String `t` is generated by randomly shuffling string `s` and then adding one additional letter at a random position. **Objective**: Write a function that identifies and returns the additional letter in string `t`. **Function Signature**: ```python def find_difference(s: str, t: str) -> str: ``` **Parameters**: * `s` - A string consisting of only lowercase letters with length `n`. * `t` - A string consisting of only lowercase letters with length `n + 1`. **Returns**: * A single character, which is the additional character in string `t`. **Constraints**: * Both strings `s` and `t` will only contain lowercase letters (\'a\' - \'z\'). * Length of `t` will always be one greater than the length of `s`. **Examples**: ```python assert find_difference(\\"abcd\\", \\"abecd\\") == \'e\' assert find_difference(\\"aeiou\\", \\"ueoiax\\") == \'x\' assert find_difference(\\"\\", \\"y\\") == \'y\' ``` **Explanation**: 1. In the first example, \'e\' is the additional character in the string `t`. 2. In the second example, \'x\' is the added character among the vowels. 3. In the third example, the empty string gains \'y\' as the first and only character. **Edge Cases**: * Consider cases where all characters in `s` are the same and `t` just adds one more of a different character. * Base case where `s` is an empty string. Create an efficient solution and ensure it adheres to the performance constraints.","solution":"def find_difference(s: str, t: str) -> str: Identifies and returns the additional letter in string `t`. from collections import Counter s_counter = Counter(s) t_counter = Counter(t) for char in t_counter: if t_counter[char] != s_counter[char]: return char"},{"question":"Remove Duplicates from a Linked List You are provided with the definition of a singly linked list data structure and two implementations of duplicate removal from a linked list. Your task is to implement a new function `efficient_remove_dups` which combines the space efficiency of `remove_dups_without_set` and reduces its computational complexity, aiming at performance improvement. Function Definition ```python def efficient_remove_dups(head: Node) -> None: pass ``` Input - `head`: A Node object, which is the head of a singly linked list where each node contains a string value (1 ≤ |value| ≤ 100). Output - This method should remove duplicates from the linked list in place without returning any value. The linked list should remain connected without duplicate nodes. Constraints 1. You must not use additional data structures to store the values. 2. Your final solution should optimize time complexity compared to O(N²). Example Given the linked list: ``` A -> A -> B -> C -> D -> C -> F -> G ``` The output of `efficient_remove_dups` should modify the list to: ``` A -> B -> C -> D -> F -> G ``` Additional Notes - Consider edge cases such as empty linked lists and single-node linked lists. - Ensure your implementation efficiently traverses nodes and relative positions within the list to avoid unnecessary performance slowdowns. Good luck! Your implementation will be evaluated based on its correctness, performance, and adherence to constraints.","solution":"class Node: def __init__(self, value=None): self.value = value self.next = None def efficient_remove_dups(head: Node) -> None: Removes duplicates from the linked list. :param head: Node - head of the linked list. current = head while current is not None: runner = current while runner.next is not None: if runner.next.value == current.value: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Task: Encode and Decode String Lists Problem Statement You are tasked with implementing two functions, `encode` and `decode`, to encode and decode a list of strings into a single string. 1. **encode(List[str]) -> str**: - Encodes a list of strings to a single string. 2. **decode(str) -> List[str]**: - Decodes a single string back to the list of strings. Function Details - **encode(strs: List[str]) -> str** - Input: - `strs`: A list of strings. Each string in the list can be of arbitrary length and contain any characters. - Output: - Returns a single string containing the encoded form of the input list. - **decode(s: str) -> List[str]** - Input: - `s`: An encoded string, created by the `encode` function. - Output: - Decodes the input string back to a list of strings. Performance Requirements - Ensure both functions run in linear time relative to the total length of the strings. Example ```python # Example 1 strs = [\\"Hello\\", \\"World\\"] encoded_str = encode(strs) # Encoded string could be \\"5:Hello5:World\\" decoded_list = decode(encoded_str) # Decoded list should be [\\"Hello\\", \\"World\\"] assert strs == decoded_list # The original list and decoded list should be the same. # Example 2 strs = [\\"\\",\\"123\\",\\"abc:123\\"] encoded_str = encode(strs) # Encoded string could be \\"0:03:1237:abc:123\\" decoded_list = decode(encoded_str) # Decoded list should be [\\"\\",\\"123\\",\\"abc:123\\"] assert strs == decoded_list ``` Constraints * List lengths and individual string lengths can be zero. * Every string can contain any printable character including whitespaces and colons.","solution":"def encode(strs): Encodes a list of strings to a single string. encoded_str = \'\' for s in strs: encoded_str += str(len(s)) + \':\' + s return encoded_str def decode(s): Decodes a single string back to a list of strings. strs = [] i = 0 while i < len(s): # Find the delimiter j = i while s[j] != \':\': j += 1 len_str = int(s[i:j]) strs.append(s[j+1:j+1+len_str]) i = j+1+len_str return strs"},{"question":"Problem Statement: You are given an array of words where each word is made up of lowercase English letters. Each letter can be translated to Morse code using the following hash map: ```python morse_code = { \'a\':\\".-\\", \'b\':\\"-...\\", \'c\':\\"-.-.\\", \'d\': \\"-..\\", \'e\':\\".\\", \'f\':\\"..-.\\", \'g\':\\"--.\\", \'h\':\\"....\\", \'i\':\\"..\\", \'j\':\\".---\\", \'k\':\\"-.-\\", \'l\':\\".-..\\", \'m\':\\"--\\", \'n\':\\"-.\\", \'o\':\\"---\\", \'p\':\\".--.\\", \'q\':\\"--.-\\", \'r\':\\".-.\\", \'s\':\\"...\\", \'t\':\\"-\\", \'u\':\\"..-\\", \'v\':\\"...-\\", \'w\':\\".--\\", \'x\':\\"-..-\\", \'y\':\\"-.--\\", \'z\':\\"--..\\" } ``` Each word can be transformed into a string of Morse code by concatenating the Morse code of each letter. Your task is to write a function that returns the number of different Morse code transformations among all words. Function Signature: ```python def num_unique_morse_representations(words: List[str]) -> int: pass ``` Input: * `words`: A list of strings where each string is a word consisting of lowercase letters. (1 <= len(words) <= 100 and 1 <= len(words[i]) <= 12) Output: * An integer representing the number of unique Morse code transformations. Example: ```python assert num_unique_morse_representations([\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"]) == 2 ``` Constraints: * Each word in the input list will consist only of lowercase English letters. * The length of each word will be between 1 and 12. * The total number of words will not exceed 100. Implementation Notes: * Consider using a set to track unique Morse code transformations to enhance performance. * Ensure case insensitivity by converting all characters to lowercase before processing.","solution":"from typing import List def num_unique_morse_representations(words: List[str]) -> int: morse_code = { \'a\': \\".-\\", \'b\': \\"-...\\", \'c\': \\"-.-.\\", \'d\': \\"-..\\", \'e\': \\".\\", \'f\': \\"..-.\\", \'g\': \\"--.\\", \'h\': \\"....\\", \'i\': \\"..\\", \'j\': \\".---\\", \'k\': \\"-.-\\", \'l\': \\".-..\\", \'m\': \\"--\\", \'n\': \\"-.\\", \'o\': \\"---\\", \'p\': \\".--.\\", \'q\': \\"--.-\\", \'r\': \\".-.\\", \'s\': \\"...\\", \'t\': \\"-\\", \'u\': \\"..-\\", \'v\': \\"...-\\", \'w\': \\".--\\", \'x\': \\"-..-\\", \'y\': \\"-.--\\", \'z\': \\"--..\\" } transformations = set() for word in words: morse_transformation = \'\'.join(morse_code[letter] for letter in word) transformations.add(morse_transformation) return len(transformations)"},{"question":"**Subtree Check in Binary Trees** You are given the roots of two binary trees, `s` and `t`, and you need to check if `t` is a subtree of `s`. A subtree of a tree `s` is a tree `t` consisting of a node in `s` and all of this node\'s descendants in `s`. # Function Signature ```python def is_subtree(s: TreeNode, t: TreeNode) -> bool: ``` # Input - `s` (TreeNode): root of the binary tree `s`. - `t` (TreeNode): root of the binary tree `t`. # Output - Returns `True` if `t` is a subtree of `s`, otherwise returns `False`. # Constraints 1. The number of nodes in each tree will be at most 10^4. 2. Both `s` and `t` can be empty. # Example ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example 1: # s: # 3 # / # 4 5 # / # 1 2 # t: # 4 # / # 1 2 # Output: True # Example 2: # s: # 3 # / # 4 5 # / # 1 2 # / # 0 # t: # 4 # / # 1 2 # Output: False ``` # Scenario Imagine you are developing a feature to verify if a given hierarchical structure exists within another. This method is fundamental in areas like file systems, hierarchical record verification, and more. Your task is to efficiently determine if one binary structure is fully encapsulated within another. # Notes - Consider edge cases like completely empty trees or trees with only one node. - Ensure optimal performance for large inputs as the number of nodes can be up to 10^4.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_subtree(s: TreeNode, t: TreeNode) -> bool: if not t: return True if not s: return False def is_same_tree(a: TreeNode, b: TreeNode) -> bool: if not a and not b: return True if not a or not b: return False if a.val != b.val: return False return is_same_tree(a.left, b.left) and is_same_tree(a.right, b.right) if is_same_tree(s, t): return True return is_subtree(s.left, t) or is_subtree(s.right, t)"},{"question":"Optimized Power-of-Two Calculator Context Develop an efficient function to determine if a given non-negative integer is a power of two. This understanding is crucial in fields like computer graphics, memory management, and digital signal processing. Powers of two often represent sizes of data blocks, buffer sizes, or computational tasks split into equally sized jobs. Task Write a function `is_power_of_two(num)` using bit manipulation techniques to determine if a given non-negative integer `num` is a power of two. Recall that numbers that are powers of two have exactly one bit set in their binary representation. Implementation Requirements * **Input**: A single non-negative integer `num` * **Output**: A boolean value `True` if `num` is a power of two, otherwise `False` * **Constraints**: - `num` will be a non-negative integer within the range of 0 to 2^31-1 inclusive. Performance Requirements - The function should run in constant time, O(1), and use constant space, O(1). - Avoid using loops or recursion. Example ```python def is_power_of_two(num): pass # Expected behavior: print(is_power_of_two(8)) # True print(is_power_of_two(16)) # True print(is_power_of_two(18)) # False print(is_power_of_two(0)) # False print(is_power_of_two(1)) # True ``` Explanation: - `8` is `1000` in binary, which is a power of two. - `16` is `10000` in binary, which is a power of two. - `18` is `10010` in binary, which is not a power of two. - `0` is not a power of two by definition. - `1` is `1` in binary, which is a power of two. Provide a solution that follows these guidelines and passes the given examples.","solution":"def is_power_of_two(num): Determines if a given non-negative integer is a power of two. Args: num (int): A non-negative integer Returns: bool: True if num is a power of two, otherwise False if num <= 0: return False return (num & (num - 1)) == 0"},{"question":"# Context: You are developing a software that requires frequent checks for prime numbers. To enhance the efficiency, you have decided to implement an optimized Sieve of Eratosthenes that can handle large datasets efficiently. # Problem: Write a function `optimized_sieve(n)` that returns a list of all prime numbers less than a given positive integer `n` using an optimized version of the Sieve of Eratosthenes. The optimization should exclude even numbers from the sieve to minimize the memory usage and increase the speed of the computation. # Expected Function Signature: ```python def optimized_sieve(n: int) -> list: pass ``` # Input: - `n`: An integer greater than 0. (1 <= n <= 10^6) # Output: - Returns a list of integers representing all prime numbers less than `n`. # Constraints: 1. Handle large inputs efficiently (both time and space complexity). 2. Ensure edge cases like n = 1 or n = 2 are handled appropriately. # Example: ```python assert optimized_sieve(10) == [2, 3, 5, 7] assert optimized_sieve(15) == [2, 3, 5, 7, 11, 13] ```","solution":"def optimized_sieve(n: int) -> list: Returns a list of all prime numbers less than a given number n using an optimized version of the Sieve of Eratosthenes. if n <= 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers # Only consider odd numbers starting from 3 for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start * start, n, start): sieve[multiple] = False # Collect prime numbers, including 2 separately from the loop primes = [2] + [number for number in range(3, n, 2) if sieve[number]] return primes"},{"question":"# K-th Smallest Element in a Binary Search Tree **Context:** Suppose you are given a Binary Search Tree (BST) with N nodes, where each node contains a unique value. BSTs have the characteristic that for any given node, all values in its left subtree are smaller, and all values in its right subtree are larger. You need to implement a function to find the k-th smallest element in the BST. Remember that in a sorted order of all elements in the BST, the k-th smallest element is indexed k-1 in zero-based indexing. **Function Signature:** ```python def find_kth_smallest_element(root: Node, k: int) -> int: ``` # Input - `root`: a reference to the root node of the Binary Search Tree. - `k`: an integer representing which smallest element to find (1-based indexing). # Output - Returns an integer, the k-th smallest element of the BST. # Constraints - The number of nodes in the BST will be in the range `[1, 10^4]`. - `1 ≤ k ≤ N` where N is the number of nodes in the tree. - Each node\'s value will be unique and within the range of int in Python. # Performance Requirements - The solution should aim for O(h + k) time complexity if possible, where h is the height of the tree. - Try to keep the space complexity to O(h). # Sample Input & Output Example 1: ```python root = Node(3, Node(1, right=Node(2)), Node(4)) k = 2 print(find_kth_smallest_element(root, k)) # Output: 2 ``` Example 2: ```python root = Node(5, Node(3, Node(2, Node(1)), Node(4)), Node(6)) k = 3 print(find_kth_smallest_element(root, k)) # Output: 3 ``` **Note:** Please ensure your solution handles edge cases such as small trees with a single node and large trees with over thousands of nodes efficiently. # Additional Challenge Try to implement both iterative and recursive solutions for the problem, and compare their performance on large-sized BSTs. What trade-offs do you observe in practice?","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_kth_smallest_element(root: Node, k: int) -> int: Finds the k-th smallest element in a BST. Args: root (Node): The root of the BST. k (int): The k-th position to find (1-based index). Returns: int: The k-th smallest element\'s value. def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.value] + inorder_traversal(node.right) inorder_list = inorder_traversal(root) return inorder_list[k-1]"},{"question":"# Euler\'s Totient Function Implementation Background Euler\'s Totient function, ϕ(n), gives the number of integers from 1 to n which are coprime to n. Two numbers are defined as coprime if their greatest common divisor (GCD) is 1. Problem Statement Write a function `euler_totient(n)` that computes the value of Euler\'s Totient Function for a given integer `n`. Function Signature ```python def euler_totient(n: int) -> int: ``` Input * An integer `n` (1 ≤ n ≤ 10^6). Output * Returns an integer which is the result of the Euler\'s Totient function ϕ(n). Constraints * You should handle edge cases such as: - `n = 1` should return 1. - Prime numbers should properly handle the large `n > 1` check. * Ensure that your implementation is efficient and completes in O(sqrt(n)) time. Examples 1. `euler_totient(1)` should return `1`. 2. `euler_totient(2)` should return `1`. 3. `euler_totient(9)` should return `6`. 4. `euler_totient(10)` should return `4`. Testing & Validation Ensure to validate the function with a range of test cases including edge cases such as very low numbers and prime numbers.","solution":"def euler_totient(n: int) -> int: Computes the value of Euler\'s Totient Function for a given integer n. if n == 1: return 1 result = n p = 2 while p * p <= n: # Check if p is a divisor of n if n % p == 0: # If yes, then it means p is a prime factor of n while n % p == 0: n = n // p result -= result // p p += 1 # If n has a prime factor greater than sqrt(n) if n > 1: result -= result // n return result"},{"question":"A company\'s internal tool requires processing of singly linked lists in reverse order. As an intern software developer, you are tasked to implement this functionality efficiently. # Task Implement two functions to reverse a singly linked list: 1. An **iterative** function named `reverse_list`. 2. A **recursive** function named `reverse_list_recursive`. # Input - A singly linked list represented by its head node. Each node contains an integer value and a `next` pointer to the next node in the list. # Output - Return the head node of the reversed list. # Constraints - The length of the list will not exceed 10^5. - Node values are integers and can be positive, negative, or zero. # Performance Requirements - Both functions should run in O(n) time complexity. - Iterative function should have O(1) space complexity. - Recursive function can have up to O(n) space complexity due to the call stack. # Example ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Example list: 1 -> 2 -> 3 -> 4 -> None head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) # Iterative reversal reversed_head = reverse_list(head) # Output reversed list: 4 -> 3 -> 2 -> 1 -> None # Recursive reversal (set head to original list again) head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) reversed_head_recursive = reverse_list_recursive(head) # Output reversed list: 4 -> 3 -> 2 -> 1 -> None ``` # Function Signatures ```python def reverse_list(head: ListNode) -> ListNode: pass def reverse_list_recursive(head: ListNode) -> ListNode: pass ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: prev_node = None current_node = head while current_node: next_node = current_node.next # store next node current_node.next = prev_node # reverse the link prev_node = current_node # move prev_node to current node current_node = next_node # move current_node to next node return prev_node def reverse_list_recursive(head: ListNode) -> ListNode: if head is None or head.next is None: return head reversed_list_head = reverse_list_recursive(head.next) head.next.next = head head.next = None return reversed_list_head"},{"question":"# Question: Enhanced Selection Sort with Additional Features You are given an array of integers, and you need to sort this array using an enhanced version of the Selection Sort algorithm. The enhancement includes the following features: 1. **Early Termination**: The algorithm should detect if the array is already sorted at any point in the iteration and terminate early to save unnecessary operations. 2. **Sort Order**: The algorithm should sort the array in ascending order by default, but it should be capable of sorting in descending order if specified. 3. **Verbose Mode**: The algorithm should have a verbose mode that prints the state of the array after each outer loop iteration for debugging purposes. Implement the function `enhanced_selection_sort` with the following signature: ```python def enhanced_selection_sort(arr, reverse=False, verbose=False): # your code here ``` **Input:** - `arr`: A list of integers to be sorted. - `reverse`: A boolean value where `False` implies sorting in ascending order and `True` implies sorting in descending order. - `verbose`: A boolean value where `True` enables verbose mode. **Output:** - The sorted list of integers. **Constraints:** - The list can contain 0 to 1000 integers. - The integers can range from -1000 to 1000. **Example:** ```python # Example 1: input_array = [64, 25, 12, 22, 11] result = enhanced_selection_sort(input_array) print(result) # Output: [11, 12, 22, 25, 64] # Example 2: input_array = [64, 25, 12, 22, 11] result = enhanced_selection_sort(input_array, reverse=True) print(result) # Output: [64, 25, 22, 12, 11] # Example 3: input_array = [64, 25, 12, 22, 11] result = enhanced_selection_sort(input_array, verbose=True) # Output should show the array state after each outer loop iteration ``` **Note:** Ensure to handle edge cases such as empty lists and single-element lists. Also, make sure the function performs efficiently for the constraints provided.","solution":"def enhanced_selection_sort(arr, reverse=False, verbose=False): n = len(arr) for i in range(n): # Let initial minimum/maximum index be the first element of unsorted segment ext_index = i for j in range(i+1, n): if reverse: if arr[j] > arr[ext_index]: ext_index = j else: if arr[j] < arr[ext_index]: ext_index = j # Swap the found minimum/maximum element with the first element of the unsorted segment if ext_index != i: arr[i], arr[ext_index] = arr[ext_index], arr[i] # If verbose mode is on, print the current state of the array if verbose: print(f\\"Array after iteration {i+1}: {arr}\\") # Early termination check: if no swaps happened, the array is already sorted if i > 0 and arr == sorted(arr, reverse=reverse): break return arr"},{"question":"# Question: Implement a function `is_graph_strongly_connected` that determines if a given directed graph is strongly connected. The graph will be provided as an adjacency list. Function Signature ```python def is_graph_strongly_connected(adj_list: dict) -> bool: pass ``` Input - `adj_list`: A dictionary representing the adjacency list of a directed graph. The keys are node identifiers, and the values are lists of nodes to which there exist directed edges. Output - Returns `True` if the graph is strongly connected, otherwise `False`. Constraints - Nodes are represented by integers (0 to V-1, where V is the number of vertices). - Each key in the adjacency list is a valid node identifier, and its value is a list of valid node identifiers. - The graph does not contain duplicate edges or self-loops. Example ```python # Example graph: 0 -> 1, 1 -> 2, 2 -> 0 is strongly connected. adj_list = { 0: [1], 1: [2], 2: [0] } print(is_graph_strongly_connected(adj_list)) # Output: True # Example graph: 0 -> 1, 1 -> 2 is not strongly connected. adj_list = { 0: [1], 1: [2], 2: [] } print(is_graph_strongly_connected(adj_list)) # Output: False ``` # Requirements - Must implement the algorithm using the approach described in the analysis. - Must handle all edge cases correctly. - Ensure efficient input handling and processing to meet the time complexity constraints.","solution":"def is_graph_strongly_connected(adj_list: dict) -> bool: def dfs(graph, start): visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend(graph[node]) return visited # Get all nodes in the graph all_nodes = set(adj_list.keys()) for start_node in all_nodes: if len(dfs(adj_list, start_node)) != len(all_nodes): return False transposed_graph = {node: [] for node in all_nodes} for node in adj_list: for neighbor in adj_list[node]: transposed_graph[neighbor].append(node) if len(dfs(transposed_graph, start_node)) != len(all_nodes): return False return True"},{"question":"# Hash Table Mini Project Objective Implement a more advanced `HashTable` that includes both quadratic probing and dynamic resizing to enhance the performance. This project requires integrating understanding of hashing, quadratic probing for collision resolution, and dynamic array resizing. Problem Statement Given an existing `HashTable` class that uses linear probing for collision resolution, extend this implementation to: 1. Replace linear probing with quadratic probing. 2. Implement dynamic resizing of the hash table to maintain efficient operations. Function Signatures 1. `put(key, value)` 2. `get(key)` 3. `del_(key)` Quadratic Probing * The new hash function for collision resolution should be: `(hash_ + i^2) % size`, where i is the number of attempted probes. Resizing * Double the size of the hash table when it reaches a load factor of 0.7. Requirements * The hash table should support basic operations - insertion (put), retrieval (get), deletion (del_) with above characteristics. * It should handle dynamic resizing while maintaining quadratic probing. * Be mindful of performance, edge cases, and memory utilization. Inputs and Outputs * The hash table should handle integer keys and integer values. * The methods should raise relevant exceptions or handle error scenarios gracefully. # Function Implementation Details `put(key, value)` * Insert the key-value pair into the hash table. * If the key already exists, update its value. * Utilize quadratic probing for collision resolution. `get(key)` * Retrieve the value associated with the key. * Return `None` if the key does not exist. `del_(key)` * Remove the key-value pair from the hash table. * Utilize quadratic probing to locate the key. # Example ```python >>> ht = AdvancedHashTable() >>> ht.put(10, 20) >>> ht.put(21, 42) >>> ht.get(10) 20 >>> ht.get(21) 42 >>> ht.del_(10) >>> ht.get(10) None ``` Ensure that your solution passes the above example and handles edge cases like multiple collisions, dynamic resizing, and removals effectively.","solution":"class AdvancedHashTable: def __init__(self, initial_capacity=8): self.size = 0 self.capacity = initial_capacity self.table = [None] * self.capacity def _hash(self, key): return key % self.capacity def _resize(self): old_table = self.table self.capacity *= 2 self.table = [None] * self.capacity self.size = 0 for item in old_table: if item is not None and item != \'deleted\': self.put(item[0], item[1]) def _probe(self, key, i): return (self._hash(key) + i ** 2) % self.capacity def put(self, key, value): if self.size / self.capacity >= 0.7: self._resize() i = 0 while True: idx = self._probe(key, i) if self.table[idx] is None or self.table[idx] == \'deleted\': self.table[idx] = (key, value) self.size += 1 return elif self.table[idx][0] == key: self.table[idx] = (key, value) return i += 1 def get(self, key): i = 0 while True: idx = self._probe(key, i) if self.table[idx] is None: return None elif self.table[idx] != \'deleted\' and self.table[idx][0] == key: return self.table[idx][1] i += 1 def del_(self, key): i = 0 while True: idx = self._probe(key, i) if self.table[idx] is None: return elif self.table[idx] != \'deleted\' and self.table[idx][0] == key: self.table[idx] = \'deleted\' self.size -= 1 return i += 1"},{"question":"String Encoder-Decoder You are tasked with creating an encoder and a decoder for a list of strings. The system will encode the list into a single encoded string that can be transmitted over a network or stored and later decoded back into the original list of strings. Your Tasks Implement two functions: 1. `encode(strs: List[str]) -> str`: Encodes a list of strings to a single string. 2. `decode(encoded: str) -> List[str]`: Decodes a single string to a list of strings. Rules and Constraints 1. The `encode` function should combine the list of strings into one string such that when passed to the `decode` function, it returns the original list in the same order. 2. Use the format: length of the string followed by a colon `:` and then the string itself. 3. Ensure the `decode` function accurately reconstructs the list even if the strings contain colons `:`. Example Input: ```python strs = [\\"hello\\", \\"world\\"] encoded_str = encode(strs) # encoded_str should be \\"5:hello5:world\\" decoded_list = decode(encoded_str) # decoded_list should be [\\"hello\\", \\"world\\"] ``` Edge Cases: - An empty list: `[]` - A list with an empty string: `[\\"\\"]` Expected Functions ```python def encode(strs: List[str]) -> str: # Implementation here def decode(encoded: str) -> List[str]: # Implementation here ``` Your implementation should ensure correctness, handle edge cases, and maintain the constraints specified. Performance Requirements - The encoder and decoder must operate with a linear time complexity relative to the size of the input data.","solution":"from typing import List def encode(strs: List[str]) -> str: encoded_str = \'\' for s in strs: encoded_str += f\'{len(s)}:{s}\' return encoded_str def decode(encoded: str) -> List[str]: decoded_list = [] i = 0 while i < len(encoded): colon_pos = encoded.find(\':\', i) length = int(encoded[i:colon_pos]) i = colon_pos + 1 decoded_list.append(encoded[i:i+length]) i += length return decoded_list"},{"question":"# Topological Sorting with Dependency Patterns # Context You are supervising a project management system where tasks need to be executed in a specific order based on dependencies. Each task is represented as a node, and a directed edge from node (A) to node (B) means that task (A) must be completed before task (B). # Problem Given a Directed Acyclic Graph (DAG) represented as an adjacency list, write a function to perform topological sorting on the tasks. You need to ensure that all dependencies are met before a task is executed. If a cycle is detected in the graph, your function should raise an error. # Input - A dictionary `graph` where: * Keys are task identifiers (integers or strings). * Values are lists of identifiers representing tasks dependent on the key task. # Output - A list of task identifiers in a valid topological order. # Constraints - The graph is guaranteed to be a DAG (no cycles). - Tasks are represented as nodes with unique identifiers (strings or integers). - The number of tasks (V) (nodes) is at most (10^5). - The total number of dependencies (E) (edges) is at most (10^6). # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'D\'], \'D\': [] } # Expected Output: [\'A\', \'B\', \'C\', \'D\'] or [\'A\', \'C\', \'B\', \'D\'] ``` # Implementation ```python def perform_topological_sort(graph): GRAY, BLACK = 0, 1 order, enter, state = [], set(graph), {} def dfs(node): state[node] = GRAY for k in graph.get(node, ()): sk = state.get(k, None) if sk == GRAY: raise ValueError(\\"cycle\\") if sk == BLACK: continue enter.discard(k) dfs(k) order.append(node) state[node] = BLACK while enter: dfs(enter.pop()) return order ``` # Instructions 1. Implement the function `perform_topological_sort(graph)` as described. 2. Ensure your function handles edge cases such as nodes with no dependencies and isolated nodes correctly. 3. Test your implementation with the provided example and additional test cases to validate your solution.","solution":"def perform_topological_sort(graph): Perform topological sorting on the given directed acyclic graph (DAG). Args: graph (dict): A dictionary representing the adjacency list of the graph. Each key is a task identifier and the value is a list of identifiers representing tasks that depend on the key task. Returns: list: A list of task identifiers in a valid topological order. Raises: ValueError: If a cycle is detected in the graph. from collections import deque, defaultdict # Initialize indegree of all nodes indegree = defaultdict(int) for key in graph: if key not in indegree: indegree[key] = 0 for dependent in graph[key]: indegree[dependent] += 1 # Queue for nodes with no incoming edges (indegree 0) zero_indegree_queue = deque([node for node in indegree if indegree[node] == 0]) topological_order = [] while zero_indegree_queue: node = zero_indegree_queue.popleft() topological_order.append(node) # Reduce the indegree of each neighbor by 1 for neighbor in graph.get(node, []): indegree[neighbor] -= 1 # If indegree becomes zero, add it to the queue if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) if len(topological_order) == len(indegree): return topological_order else: raise ValueError(\\"A cycle was detected in the graph, which is invalid in a DAG.\\")"},{"question":"# Coding Problem - Advanced Segment Tree Application You are given an array and need to support two types of operations efficiently: 1. **Range Query**: Compute the sum of elements in a given range [L, R]. 2. **Update Operation**: Increment a value at a specified index by a given value. Implement a class `AdvancedSegmentTree` to efficiently handle these operations with the least possible time complexity. Expected Input and Output Formats: **Input**: * The first line contains an integer N denoting the number of elements in the array. * The second line contains N space-separated integers denoting the elements of the array. * The third line contains an integer Q denoting the number of queries. * Each of the next Q lines contains a query in one of the following formats: - `\\"sum L R\\"`: Query to calculate the sum of elements from index L to R (inclusive). - `\\"add I V\\"`: Query to add value V to element at index I. **Output**: * For each \\"sum\\" query, output the result in a new line. Constraints: * 1 <= N, Q <= 10^5 * -10^9 <= Array elements, V <= 10^9 * 0 <= L, R < N * 0 <= I < N Example: **Input**: ``` 5 1 2 3 4 5 5 sum 0 4 sum 1 3 add 2 10 sum 1 3 sum 0 4 ``` **Output**: ``` 15 9 19 25 ``` Implementation: Complete the following class definition: ```python class AdvancedSegmentTree: def __init__(self, arr): self.tree = [0] * len(arr) + arr self.size = len(arr) self.build_tree() def build_tree(self): for i in range(self.size - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, p, v): p += self.size self.tree[p] += v while p > 1: p //= 2 self.tree[p] = self.tree[p * 2] + self.tree[p * 2 + 1] def query(self, l, r): l, r = l + self.size, r + self.size res = 0 while l <= r: if l % 2 == 1: res += self.tree[l] l += 1 if r % 2 == 0: res += self.tree[r] r -= 1 l //= 2 r //= 2 return res def process_queries(self, queries): results = [] for query in queries: parts = query.split() if parts[0] == \\"sum\\": l, r = int(parts[1]), int(parts[2]) results.append(self.query(l, r)) elif parts[0] == \\"add\\": i, v = int(parts[1]), int(parts[2]) self.update(i, v) return results # Example usage: # array = [1, 2, 3, 4, 5] # queries = [\\"sum 0 4\\", \\"sum 1 3\\", \\"add 2 10\\", \\"sum 1 3\\", \\"sum 0 4\\"] # seg_tree = AdvancedSegmentTree(array) # print(seg_tree.process_queries(queries)) ```","solution":"class AdvancedSegmentTree: def __init__(self, arr): self.tree = [0] * (2 * len(arr)) self.size = len(arr) self.build_tree(arr) def build_tree(self, arr): # Build the segment tree for i in range(self.size): self.tree[self.size + i] = arr[i] for i in range(self.size - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, p, v): # Update a specific position value p += self.size self.tree[p] += v while p > 1: p //= 2 self.tree[p] = self.tree[2 * p] + self.tree[2 * p + 1] def query(self, l, r): # Range sum query l += self.size r += self.size res = 0 while l <= r: if l % 2 == 1: res += self.tree[l] l += 1 if r % 2 == 0: res += self.tree[r] r -= 1 l //= 2 r //= 2 return res def process_queries(self, queries): results = [] for query in queries: parts = query.split() if parts[0] == \\"sum\\": l, r = int(parts[1]), int(parts[2]) results.append(self.query(l, r)) elif parts[0] == \\"add\\": i, v = int(parts[1]), int(parts[2]) self.update(i, v) return results # Example usage: # array = [1, 2, 3, 4, 5] # queries = [\\"sum 0 4\\", \\"sum 1 3\\", \\"add 2 10\\", \\"sum 1 3\\", \\"sum 0 4\\"] # seg_tree = AdvancedSegmentTree(array) # print(seg_tree.process_queries(queries))"},{"question":"# Coding Challenge: Implement an Improved Priority Queue using a Binary Heap Context: You are tasked with improving the Priority Queue implementation to handle larger datasets efficiently. Your goal is to implement a Priority Queue using a Binary Heap, which will allow for both insertion and extraction operations to be performed in O(log n) time. Task: Implement a `BinaryHeapPriorityQueue` class that supports the following operations: 1. `__init__(self, items=None, priorities=None)`: Initialize the priority queue. If `items` and `priorities` are provided, they should be used to populate the heap. 2. `size(self)`: Return the number of elements in the priority queue. 3. `push(self, item, priority)`: Insert a new item into the priority queue. 4. `pop(self)`: Remove and return the item with the highest priority. Input/Output Specifications: * `__init__`: * Input: `items` (list of items for initial population), `priorities` (list of corresponding priorities). * Output: None * `size`: * Input: None * Output: Integer representing the number of elements in the priority queue. * `push`: * Input: `item` (the data to be inserted), `priority` (the priority of the item). * Output: None * `pop`: * Input: None * Output: The data of the item with the highest priority. Constraints: 1. The `items` and `priorities` lists will have the same length if provided. 2. All priorities are integers (negative and positive values allowed). 3. The `pop` method should handle cases where the queue is empty by raising an `IndexError`. Provide the implementation for the `BinaryHeapPriorityQueue` class.","solution":"import heapq class BinaryHeapPriorityQueue: def __init__(self, items=None, priorities=None): Initialize the priority queue. If items and priorities are provided, they are used to populate the heap. self.heap = [] if items and priorities: self.heap = [(priority, item) for item, priority in zip(items, priorities)] heapq.heapify(self.heap) def size(self): Return the number of elements in the priority queue. return len(self.heap) def push(self, item, priority): Insert a new item with the given priority into the priority queue. heapq.heappush(self.heap, (priority, item)) def pop(self): Remove and return the item with the highest priority. Raises IndexError if the queue is empty. if not self.heap: raise IndexError(\'pop from an empty priority queue\') priority, item = heapq.heappop(self.heap) return item"},{"question":"You are provided with a list of words. Each word can be written as a concatenation of the Morse code for each letter. We\'ll call such a concatenation the transformation of a word. Your task is to determine the number of unique transformations for a list of words. Morse Code Mapping: ```plaintext \'a\' : \\".-\\", \'b\' : \\"-...\\", \'c\' : \\"-.-.\\", \'d\' : \\"-..\\", \'e\' : \\".\\", \'f\' : \\"..-.\\", \'g\' : \\"--.\\", \'h\' : \\"....\\", \'i\' : \\"..\\", \'j\' : \\".---\\", \'k\' : \\"-.-\\", \'l\' : \\".-..\\", \'m\' : \\"--\\", \'n\' : \\"-.\\", \'o\' : \\"---\\", \'p\' : \\".--.\\", \'q\' : \\"--.-\\", \'r\' : \\".-.\\", \'s\' : \\"...\\", \'t\' : \\"-\\", \'u\' : \\"..-\\", \'v\' : \\"...-\\", \'w\' : \\".--\\", \'x\' : \\"-..-\\", \'y\' : \\"-.--\\", \'z\' : \\"--..\\" ``` Input: - A list of words where each word consists of lowercase English letters. Output: - An integer representing the number of unique Morse code transformations. Constraints: - 1 <= len(words) <= 100 - Each word will have at least 1 and at most 12 lowercase English letters. Performance Requirements: - The solution should efficiently handle the upper limits of the constraints. Example: Input: ```plaintext words = [\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"] ``` Output: ```plaintext 2 ``` Explanation: The transformation of each word is: - \\"gin\\" -> \\"--...-.\\" - \\"zen\\" -> \\"--...-.\\" - \\"gig\\" -> \\"--...--.\\" - \\"msg\\" -> \\"--...--.\\" There are 2 different transformations: \\"--...-.\\" and \\"--...--.\\". Task: Implement the following function: ```python def unique_morse(words): # Implement your solution here ```","solution":"def unique_morse(words): Returns the number of unique transformations for a list of words using Morse code mappings. morse_code = { \'a\': \\".-\\", \'b\': \\"-...\\", \'c\': \\"-.-.\\", \'d\': \\"-..\\", \'e\': \\".\\", \'f\': \\"..-.\\", \'g\': \\"--.\\", \'h\': \\"....\\", \'i\': \\"..\\", \'j\': \\".---\\", \'k\': \\"-.-\\", \'l\': \\".-..\\", \'m\': \\"--\\", \'n\': \\"-.\\", \'o\': \\"---\\", \'p\': \\".--.\\", \'q\': \\"--.-\\", \'r\': \\".-.\\", \'s\': \\"...\\", \'t\': \\"-\\", \'u\': \\"..-\\", \'v\': \\"...-\\", \'w\': \\".--\\", \'x\': \\"-..-\\", \'y\': \\"-.--\\", \'z\': \\"--..\\" } transformations = set() for word in words: transformation = \\"\\".join(morse_code[char] for char in word) transformations.add(transformation) return len(transformations)"},{"question":"# Pancake Sort Implementation and Analysis **Background**: Pancake sorting is an analogy-driven sorting algorithm that simulates reversing sections of an array, much like flipping pancakes. Despite its straightforward conceptual approach and in-place sorting characteristic, it has a quadratic time complexity. Your task involves implementing this algorithm and enhancing it for practical usage under the given constraints. **Task**: 1. Write a function `pancake_sort(arr)` that sorts an array using the Pancake Sort algorithm. 2. Modify the implementation to handle large datasets more efficiently by integrating an early termination condition. **Function Signature**: ```python def pancake_sort(arr: List[int]) -> List[int]: pass ``` **Input and Output**: * **Input**: An unsorted list of integers `arr`. * **Output**: The sorted list in ascending order. **Constraints**: * Array length (N): 0 ≤ N ≤ 10^5 * Array elements: -10^6 ≤ arr[i] ≤ 10^6 **Performance Requirements**: * Aim for your solution to handle the upper constraint efficiently. * Avoid unnecessary computations and optimize wherever possible. **Example**: ```python Input: [3, 6, 2, 8, 7] Output: [2, 3, 6, 7, 8] Input: [] Output: [] Input: [1] Output: [1] ``` **Additional Notes**: * **Edge Cases**: Ensure your function handles edge cases such as empty arrays and arrays with a single element correctly. * **Performance**: Test your implementation on both small and large datasets to ensure it runs efficiently. * **Optimization**: Implement any reasonable optimization to improve average and worst-case performance. This could include an early exit if the array is already sorted during intermediate steps.","solution":"from typing import List def pancake_sort(arr: List[int]) -> List[int]: def flip(arr: List[int], k: int) -> None: Helper function to reverse the first k elements of arr. arr[:k] = arr[:k][::-1] def find_max_index(arr: List[int], n: int) -> int: Helper function to find the index of the maximum element in arr[:n]. max_idx = 0 for i in range(1, n): if arr[i] > arr[max_idx]: max_idx = i return max_idx n = len(arr) for size in range(n, 1, -1): # Find the index of the maximum element in arr[:size] max_index = find_max_index(arr, size) # If the maximum element is not already at its final position if max_index != size - 1: # Flip the maximum element to the beginning if max_index > 0: flip(arr, max_index + 1) # Flip the maximum element to its final position flip(arr, size) return arr"},{"question":"**Problem Statement:** You are a member of a cryptography team working on implementing a secure communication system. One of the tasks is to compute modular inverses to encode and decode messages securely. Your job is to implement two crucial functions: `extended_gcd` and `modular_inverse`. 1. **Function `extended_gcd(a: int, b: int) -> [int, int, int]`**: - **Description**: Returns integers `s`, `t`, and `g`, where `a * s + b * t = GCD(a, b)`. - **Input**: Two integers, `a` and `b`. - **Output**: A tuple of three integers `(s, t, g)`. 2. **Function `modular_inverse(a: int, m: int) -> int`**: - **Description**: Returns the modular inverse `x` such that `a * x ≡ 1 (mod m)`. Throws an exception if `a` and `m` are not coprime. - **Input**: Two integers, `a` and `m`. - **Output**: An integer representing the modular inverse of `a` under `m`. **Constraints**: - `1 <= a, m <= 10^9` - The inputs to `modular_inverse` are guaranteed to be coprime. **Function Signature**: ```python def extended_gcd(a: int, b: int) -> [int, int, int]: pass def modular_inverse(a: int, m: int) -> int: pass ``` **Example 1**: ```python # Example Input a, b = 30, 20 s, t, g = extended_gcd(a, b) print(s, t, g) # Example Output: Should print integers that satisfy 30s + 20t = gcd(30, 20) # Example Input a, m = 3, 11 x = modular_inverse(a, m) print(x) # Example Output: Should print the modular inverse of 3 under 11, which is 4 ``` **Task**: 1. Implement the `extended_gcd` function using the Extended Euclidean Algorithm. 2. Implement the `modular_inverse` function that utilizes `extended_gcd` to find the modular inverse as specified in the description.","solution":"def extended_gcd(a: int, b: int): Given two integers a and b, return a tuple (s, t, g) such that a*s + b*t = g, where g is the GCD of a and b. if b == 0: return (1, 0, a) else: s, t, g = extended_gcd(b, a % b) return (t, s - (a // b) * t, g) def modular_inverse(a: int, m: int) -> int: Given two integers a and m, return the modular inverse x such that (a * x) % m == 1. Raise an exception if a and m are not coprime. s, t, g = extended_gcd(a, m) if g != 1: raise ValueError(f\\"No modular inverse exists for a = {a} and m = {m}\\") return s % m"},{"question":"Given a singly linked list, implement a function to find the k-th node from the end of the list. Your function should be efficient in terms of both time and space complexity. # Function Signature ```python class Node(): def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head: Node, k: int) -> Node: pass ``` # Parameters - `head` (Node): The head of the singly linked list. - `k` (int): The position from the end to retrieve (0-based). # Returns - `Node`: The k-th node from the end of the list. # Constraints 1. The list length is in the range of [0, 10^5]. 2. 0 <= k < length of the list. # Example With a list of values A -> B -> C -> D -> E: * For `k = 2`, the output should be the node with value \'C\'. * For `k = 4`, the output should be the node with value \'A\'. # Implementation Implement the function using a two-pointer technique for optimal performance with O(n) time complexity and O(1) space complexity. # Edge Cases 1. Ensure to handle the case if k is greater than or equal to the length of the list gracefully. ```python def kth_to_last(head: Node, k: int) -> Node: Retrieve the k-th to last node of a singly linked list. if not head or k < 0: raise ValueError(\\"Invalid input\\") p1 = head p2 = head # Move p1 k steps ahead for i in range(k): if p1 is None: raise IndexError(\\"k is greater than or equal to the length of the list\\") p1 = p1.next # Move p1 and p2 together until p1 reaches the end while p1.next: p1 = p1.next p2 = p2.next return p2 ``` # Test Add test cases to validate the implementation: ```python def test(): # Create linked list: A -> B -> C -> D -> E a = Node(\\"A\\") b = Node(\\"B\\") c = Node(\\"C\\") d = Node(\\"D\\") e = Node(\\"E\\") a.next = b b.next = c c.next = d d.next = e # Test cases assert kth_to_last(a, 2).val == \\"C\\" assert kth_to_last(a, 0).val == \\"E\\" assert kth_to_last(a, 4).val == \\"A\\" print(\\"All test cases passed.\\") if __name__ == \'__main__\': test() ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head: Node, k: int) -> Node: Retrieve the k-th to last node of a singly linked list using two-pointer technique. if not head or k < 0: raise ValueError(\\"Invalid input\\") p1 = head p2 = head # Move p1 k steps ahead for _ in range(k): if p1 is None: raise IndexError(\\"k is greater than or equal to the length of the list\\") p1 = p1.next if not p1: # This check is for the case when p1 could be None after moving k steps in a list that\'s exactly k+1 nodes long. raise IndexError(\\"k is greater than or equal to the length of the list\\") # Move p1 and p2 together until p1 reaches the end while p1.next: p1 = p1.next p2 = p2.next return p2"},{"question":"# Merge Sort Implementation Challenge Merge Sort is a classic divide-and-conquer algorithm that sorts an array by recursively breaking it down into halves and merging the sorted halves back together. Your task is to implement the Merge Sort algorithm without using built-in sort functions. Task Write a Python function `merge_sort(arr)` which sorts the list `arr` using the Merge Sort algorithm. Input * A list `arr` of integers, where `1 <= len(arr) <= 10^5`. Output * The function should return a sorted list in ascending order. # Constraints * The function should maintain a time complexity of O(n log n) and space complexity of O(n). * Handle edge cases like an array with a single element, an empty array, and arrays with duplicate elements. * Ensure the sorting is stable, meaning the relative order of equal elements should be preserved in the sorted output. * Avoid using built-in sort functions or libraries. # Example ```python # Example 1 input: [4, 2, 5, 1, 6, 3] output: [1, 2, 3, 4, 5, 6] # Example 2 input: [1] output: [1] # Example 3 input: [] output: [] ``` # Implementation You should write the `merge_sort` function and any helper functions needed for merging subarrays. Good luck!","solution":"def merge_sort(arr): Sorts a list of integers using the Merge Sort algorithm. if len(arr) <= 1: return arr def merge(left, right): Merges two sorted lists into one sorted list. merged = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 # Collecting the remaining elements merged.extend(left[i:]) merged.extend(right[j:]) return merged mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"# Question: Calculate Maximum Depth of Binary Tree Given a binary tree, write a function to find its maximum depth. The maximum depth is defined as the number of nodes along the longest path from the root node down to the farthest leaf node. You are to implement this function using an iterative Breadth-First Search (BFS) approach. Function Signature ```python def max_depth(root: TreeNode) -> int: pass ``` Input * `root` (TreeNode): The root node of the binary tree. The value of the root node and subsequent nodes in the tree are integers. The tree can be empty (None). Output * `int`: The maximum depth of the binary tree. Constraints * The number of nodes `N` in the binary tree is in the range `0 <= N <= 10^5`. * Each node value is an integer in the range `-10^9 <= Node.val <= 10^9`. Example # Example 1: Input: ```plaintext root = [3,9,20,None,None,15,7] ``` Output: ```plaintext 3 ``` Explanation: The binary tree is: ``` 3 / 9 20 / 15 7 ``` The longest path is 3 -> 20 -> 15 or 3 -> 20 -> 7 which have length of 3. # Example 2: Input: ```plaintext root = [1,None,2] ``` Output: ```plaintext 2 ``` Explanation: The binary tree: ``` 1 2 ``` The longest path is 1 -> 2 which has a length of 2. # Example 3: Input: ```plaintext root = [] ``` Output: ```plaintext 0 ``` Explanation: The tree is empty, so the depth is 0. Implementation Guidelines 1. Use an iterative Breadth-First Search (BFS) approach. 2. Consider edge cases like an empty tree or a single-node tree. 3. Ensure to handle large inputs efficiently within the given constraints. Note: The function should be able to handle very large trees efficiently. Consider using a deque instead of a list for the queue to optimize pop operations.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: Returns the maximum depth of the binary tree. if not root: return 0 queue = deque([(root, 1)]) # pair: (node, current_depth) max_depth = 0 while queue: node, depth = queue.popleft() if node: max_depth = max(max_depth, depth) queue.append((node.left, depth + 1)) queue.append((node.right, depth + 1)) return max_depth"},{"question":"# Question You are required to implement a **stable counting sort** function that can handle both positive and negative integers. Counting sort is an efficient sorting technique suitable for small ranges of integers. Your task is to modify the given algorithm to improve performance and ensure it handles negative values properly. # Function Signature ```python def stable_counting_sort(arr: List[int]) -> List[int]: pass ``` # Input and Output Formats - **Input**: - `arr` (List[int]): A list of integers which may contain both positive and negative values. - **Output**: - Returns a new list containing the sorted integers in ascending order. # Constraints - The length of `arr` is between 1 and 10^5. - The elements of `arr` are integers, ranging from -10^5 to 10^5. # Example ```python assert stable_counting_sort([3, -1, 2, 0, -2, 3, -3]) == [-3, -2, -1, 0, 2, 3, 3] assert stable_counting_sort([4, 4, 4, 4, 4]) == [4, 4, 4, 4, 4] assert stable_counting_sort([]) == [] ``` # Explanation In the example: 1. The first case involves both positive and negative integers, showing that the function should handle mixed values. 2. The second case demonstrates that the function should handle identical values effectively. 3. The third case confirms that the function handles empty arrays without errors. # Notes - Ensure the sorting maintains the stability property. If two identical elements appear in the input array, they must maintain their relative position in the output. - Consider performance and space efficiency, especially for large arrays and wide ranges of input values.","solution":"from typing import List def stable_counting_sort(arr: List[int]) -> List[int]: if not arr: return arr # Find the range of the numbers in the input array min_value = min(arr) max_value = max(arr) range_of_elements = max_value - min_value + 1 # Initialize count array count = [0] * range_of_elements output = [0] * len(arr) # Store the count of each element for num in arr: count[num - min_value] += 1 # Change count[i] so that it contains the actual position of this element in the output array for i in range(1, len(count)): count[i] += count[i - 1] # Build the output array to ensure stable sorting for num in reversed(arr): output[count[num - min_value] - 1] = num count[num - min_value] -= 1 return output"},{"question":"# Problem You are given an array of integers and you need to sort this array in ascending order using the Comb Sort algorithm. Implement the function `comb_sort` that takes a list of integers as input and returns the sorted list. # Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: a list of integers, where `1 <= len(arr) <= 10000` and `-10^6 <= arr[i] <= 10^6` for each element `arr[i]`. # Output - A list of integers sorted in ascending order. # Example ```python >>> comb_sort([5, 3, 1, 4, 2]) [1, 2, 3, 4, 5] >>> comb_sort([9, 7, 3, 1, 6, 5, 2]) [1, 2, 3, 5, 6, 7, 9] ``` # Constraints - The function should complete in a reasonable time for an input size up to 10,000 elements. # Edge Cases - Sorting an empty list should return an empty list. - Sorting a list with a single element should return the same list. # Notes - You are not allowed to use built-in sorting functions. - Consider edge cases such as repeated elements and performance for large arrays.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: def get_next_gap(gap): # Shrinks the gap by the shrink factor new_gap = (gap * 10) // 13 return max(1, new_gap) # Ensure we do not return 0 as gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: # Find the next gap gap = get_next_gap(gap) swapped = False # Compare elements with current gap for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] # Swap swapped = True return arr"},{"question":"Climbing Stairs with Constraints You are climbing a staircase, and it takes `n` steps to reach the top. Each time you can either climb 1 or 2 steps. You have a particular constraint: you cannot take two 1-step climbs consecutively more than twice. Given an integer `n`, write a function `climb_stairs_constrained(n)` that returns the number of distinct ways you can reach the top of the staircase while adhering to the constraint. # Input * An integer `n` (1 <= n <= 10^5) representing the number of steps. # Output * An integer representing the number of distinct ways to climb the staircase. # Constraints * You cannot take more than two consecutive 1-step climbs. # Examples ``` climb_stairs_constrained(3) # returns 3 (climb scenarios: [(1,1,1), (1,2), (2,1)]) climb_stairs_constrained(4) # returns 5 (climb scenarios: [(1,1,1,1), (1,1,2), (1,2,1), (2,1,1), (2,2)]) ``` # Notes * The input size requires an efficient algorithm both in terms of time and space complexity. * Edge cases such as `n = 1` or `n = 2` should be handled seamlessly. * Ensure your implementation is optimized for higher values of `n` without causing memory overflow or excessive computation time.","solution":"def climb_stairs_constrained(n): Returns the number of distinct ways to climb a staircase of `n` steps where you cannot take more than two consecutive 1-step climbs. if n == 1: return 1 if n == 2: return 2 if n == 3: return 4 # Dynamic programming approach dp = [0] * (n + 1) # Base cases dp[1] = 1 # [1] dp[2] = 2 # [1, 1], [2] dp[3] = 4 # [1, 1, 1], [1, 2], [2, 1], [1, 1, 1] for i in range(4, n + 1): dp[i] = dp[i-1] + dp[i-2] + dp[i-3] return dp[n]"},{"question":"Context In the following exercise, you are required to enhance the given Resizable Hash Table implementation by adding an additional feature for automatic shrinking, thus allowing it to scale down when the number of key-value pairs decreases significantly. This will ensure efficient memory utilization. Task 1. **Implement Shrink Feature**: Modify the `ResizableHashTable` to automatically shrink its size by half when the number of entries falls below 1/3 of its current size. 2. **Function Implementation**: You will need to implement the following methods: - `def shrink(self)`: This method will halve the size of the hash table while maintaining existing key-value pairs. 3. **Ensure Functionality**: - `put`: Handles resizes when necessary. - `del_`: Triggers shrink when required. - Ensure all edge cases are managed. 4. **Performance Requirements**: The shrink operation should rehash the existing keys efficiently into the new, smaller table size. Constraints: - Assume the keys are positive integers. - The initial minimum size of the hash table should remain 8, even after shrinking. Input and Output Formats: - **No explicit input/output functions are required**. This task revolves around augmenting the class\'s internal mechanisms. Example: ```python # Example usage: ht = ResizableHashTable() for i in range(20): ht.put(i, i*100) print(len(ht)) # Should be 20 for i in range(10): del ht[i] print(len(ht)) # Should be 10 # Shrink should have been triggered if size goes down to 8 after deletions. ``` Ensure you test the implementation thoroughly to validate the shrinking behavior.","solution":"class ResizableHashTable: def __init__(self): self.initial_size = 8 self.size = self.initial_size self.count = 0 self.table = [None] * self.size def put(self, key, value): if self.count > 2 * self.size / 3: # Load factor exceeds 2/3 self.resize(self.size * 2) index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = (key, value) return index = (index + 1) % self.size self.table[index] = (key, value) self.count += 1 def get(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.size return None def del_(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.count -= 1 if self.count < self.size / 3: # Shrink when count falls below 1/3 of size self.shrink() return index = (index + 1) % self.size def resize(self, new_size): old_table = self.table self.size = new_size self.table = [None] * self.size self.count = 0 for entry in old_table: if entry is not None: self.put(entry[0], entry[1]) def shrink(self): new_size = max(self.initial_size, self.size // 2) self.resize(new_size) def _hash(self, key): return key % self.size def __len__(self): return self.count"},{"question":"# Base Conversion Implementation You are required to enhance and implement a base conversion function for a new application that processes numbers in various numeral systems. The implemented modules should handle conversion from base 10 integers to a specified base and vice versa. # Function Specifications 1. Implement the following function: ```python def int_to_base(num, base): Converts a base 10 integer to a specified base. :param num: an integer number :param base: the base to convert to (2-36) :return: string representation of the number in the specified base ``` 2. Implement the following function: ```python def base_to_int(str_to_convert, base): Converts a number from a specified base to base 10. :param str_to_convert: a string representing the number in the specified base :param base: the base of the input number (2-36) :return: integer representation of the number in base 10 ``` # Requirements & Constraints - The `base` will always be between 2 and 36 inclusive. - For `int_to_base`, if `num` is 0, the function should return \'0\'. - For `base_to_int`, if the input string contains invalid characters for the base, handle the error gracefully by returning `None`. - Handle negative numbers correctly in `int_to_base`. Note that `base_to_int` assumes non-negative input for simplicity. - You are not allowed to use the built-in `int()` function with base conversion in `base_to_int`. # Example ```python # Example usage: print(int_to_base(42, 2)) # Output: \'101010\' print(base_to_int(\'101010\', 2)) # Output: 42 print(int_to_base(-27, 16)) # Output: \'-1B\' print(base_to_int(\'1B\', 16)) # Output: 27 ``` Write your solutions below:","solution":"def int_to_base(num, base): Converts a base 10 integer to a specified base. :param num: an integer number :param base: the base to convert to (2-36) :return: string representation of the number in the specified base if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36.\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" is_negative = num < 0 num = abs(num) result = \\"\\" while num > 0: result = digits[num % base] + result num //= base if is_negative: result = \'-\' + result return result def base_to_int(str_to_convert, base): Converts a number from a specified base to base 10. :param str_to_convert: a string representing the number in the specified base :param base: the base of the input number (2-36) :return: integer representation of the number in base 10 if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36.\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" value_map = {char: idx for idx, char in enumerate(digits[:base])} str_to_convert = str_to_convert.upper() # Validate characters for char in str_to_convert: if char not in value_map: return None result = 0 for char in str_to_convert: result = result * base + value_map[char] return result"},{"question":"# Question: Find the Smallest Letter Greater Than Target Given a sorted list of characters `letters` containing only lowercase letters, and a target character `target`, write a function `find_smallest_letter` to find the smallest element in the list that is larger than the given target. Note that this function should consider the list to be cyclic, meaning if the target is greater than or equal to the last element in the list, it should return the first element. Requirements: - **Input/Output**: - Input: A sorted list of lowercase characters `letters` and a single lowercase character `target`. - Output: A single character from the `letters` list. - **Constraints**: - All characters in `letters` are in lowercase. - The list `letters` has at least 2 characters. - The target character will be a single lowercase letter. Examples: 1. **Example 1**: - Input: `letters = [\\"c\\", \\"f\\", \\"j\\"]`, `target = \\"a\\"` - Output: `\\"c\\"` 2. **Example 2**: - Input: `letters = [\\"c\\", \\"f\\", \\"j\\"]`, `target = \\"c\\"` - Output: `\\"f\\"` 3. **Example 3**: - Input: `letters = [\\"c\\", \\"f\\", \\"j\\"]`, `target = \\"d\\"` - Output: `\\"f\\"` Implementation Guidance: 1. Implement the function using binary search to achieve optimal time complexity (O(log N)). 2. Consider the wrap-around nature of the array. 3. Carefully handle the edge cases mentioned in the analysis. Function Signature: ```python def find_smallest_letter(letters: List[str], target: str) -> str: pass ``` Ensure your implementation adheres to the constraints and efficiently handles the input list size up to 10^4.","solution":"from typing import List def find_smallest_letter(letters: List[str], target: str) -> str: low, high = 0, len(letters) - 1 while low <= high: mid = (low + high) // 2 if letters[mid] > target: high = mid - 1 else: low = mid + 1 return letters[low % len(letters)]"},{"question":"**Context**: You are given the task of sorting a list of floating-point numbers, ensuring that the algorithm performs efficiently for values uniformly distributed between [0, 1). The implementation should use the bucket sort algorithm, followed by insertion sort for sorting individual buckets. **Function Signature**: ```python def bucket_sort_floats(arr: List[float]) -> List[float]: ``` **Input**: - An array `arr` of `n` floating-point numbers, where (0 leq text{arr}[i] < 1). **Output**: - An array of `n` floating-point numbers sorted in ascending order. **Constraints**: - The length of `arr` (i.e., `n`) can be up to (10^6). - The elements are floating-point numbers uniformly distributed in the range [0, 1). **Performance Requirements**: - The algorithm should aim to achieve (O(n + klogn)) average time complexity, where `k` is the number of buckets, and space complexity of (O(n + k)). **Example**: ```python assert bucket_sort_floats([0.22, 0.45, 0.12, 0.36, 0.80, 0.72]) == [0.12, 0.22, 0.36, 0.45, 0.72, 0.80] assert bucket_sort_floats([0.91, 0.45, 0.67, 0.28, 0.33, 0.19]) == [0.19, 0.28, 0.33, 0.45, 0.67, 0.91] ``` Implement the `bucket_sort_floats` function based on the given criteria.","solution":"from typing import List def insertion_sort(arr: List[float]) -> List[float]: Helper function to perform insertion sort on a list. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def bucket_sort_floats(arr: List[float]) -> List[float]: Sorts a list of floating-point numbers using bucket sort. if not arr: return arr n = len(arr) # Initialize buckets buckets = [[] for _ in range(n)] # Distribute elements into buckets for num in arr: index = int(num * n) # Bucket index buckets[index].append(num) # Sort individual buckets using insertion sort for i in range(n): buckets[i] = insertion_sort(buckets[i]) # Concatenate sorted buckets sorted_arr = [] for bucket in buckets: sorted_arr.extend(bucket) return sorted_arr"},{"question":"# **Anagram Grouping Challenge** You are given a list of strings. Your task is to write a function that groups the strings that are anagrams of each other together. Two or more strings are anagrams if they contain the same characters with the same frequency but possibly in different orders. * **Function Name**: `group_anagrams` * **Input**: - `strs`(List[str]): A list of strings consisting of lowercase alphabets. * **Output**: - `List[List[str]]`: A list of lists, where each sublist contains strings that are anagrams of each other. # **Constraints**: * All strings in the input list are in lowercase. * The length of all strings is at most 100. * The total number of strings in the input list does not exceed 10^4. # **Performance Requirements**: * The implementation should handle up to 10^4 strings efficiently. # **Examples**: * Example 1: * **Input**: `[\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]` * **Output**: `[[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]]` * *Explanation*: \\"eat\\", \\"tea\\", and \\"ate\\" are anagrams. \\"tan\\" and \\"nat\\" are anagrams. \\"bat\\" has no anagrams. * Example 2: * **Input**: `[\\"\\"]` * **Output**: `[[\\"\\"]]` * *Explanation*: An empty string is an anagram of another empty string. * Example 3: * **Input**: `[\\"a\\"]` * **Output**: `[[\\"a\\"]]` # **Implementation Challenge**: Implement the `group_anagrams` function such that it effectively groups the anagrams without unnecessary overhead.","solution":"from collections import defaultdict from typing import List def group_anagrams(strs: List[str]) -> List[List[str]]: Groups a list of strings into anagrams. Args: strs (List[str]): List of strings consisting of lowercase alphabets. Returns: List[List[str]]: A list of lists where each sublist contains strings that are anagrams of each other. anagrams = defaultdict(list) for s in strs: sorted_str = \'\'.join(sorted(s)) anagrams[sorted_str].append(s) return list(anagrams.values())"},{"question":"# Strings One Edit Distance Apart Your task is to implement a function to determine if two strings are exactly one edit distance apart. An edit is defined as: 1. Inserting a single character into either string. 2. Deleting a single character from either string. 3. Replacing a single character in either string. # Function Signature ```python def is_one_edit_away(s: str, t: str) -> bool: :param s: A string input :param t: A string input :return: A boolean indicating if s and t are one edit distance apart ``` # Input - `s` (string): the first string input (1 ≤ |s| ≤ 10^4). - `t` (string): the second string input (1 ≤ |t| ≤ 10^4). # Output - Return a boolean `True` if the two strings are one edit distance apart, `False` otherwise. # Examples Example 1: ```python s = \\"kitten\\" t = \\"sitting\\" assert is_one_edit_away(s, t) == False ``` Example 2: ```python s = \\"pale\\" t = \\"ple\\" assert is_one_edit_away(s, t) == True ``` Example 3: ```python s = \\"abc\\" t = \\"abcd\\" assert is_one_edit_away(s, t) == True ``` # Constraints 1. Both strings are non-empty and have a length of at most 10,000 characters. 2. You need to handle cases where strings can be equal or differ by more than one character. 3. The implementation should be efficient with a time complexity of O(n). # Special Notes - Consider edge cases where the strings differ by more than one character, or are identical. - You may assume strings contain only lowercase letters (a-z).","solution":"def is_one_edit_away(s: str, t: str) -> bool: :param s: A string input :param t: A string input :return: A boolean indicating if s and t are one edit distance apart if abs(len(s) - len(t)) > 1: return False if len(s) > len(t): s, t = t, s if len(s) == len(t): found_difference = False for i in range(len(s)): if s[i] != t[i]: if found_difference: return False found_difference = True return found_difference else: i = j = 0 found_difference = False while i < len(s) and j < len(t): if s[i] != t[j]: if found_difference: return False found_difference = True j += 1 else: i += 1 j += 1 return True"},{"question":"You are required to develop an algorithm that transforms a given stack by duplicating each element in place. You have to implement two versions of this algorithm: one using an auxiliary stack and another using an auxiliary queue. Implement these as two separate functions: `first_stutter(stack)` and `second_stutter(stack)`. Input: - A list of integers `stack` following the stack properties (last-in, first-out). Output: - The modified `stack` which has each of its original elements duplicated adjacently. Constraints: - Elements in the input stack can be any integer. - You must not use any additional data structure beyond the mentioned auxiliary stack or queue for each respective function. Performance Requirements: - Time Complexity should be `O(n)`, where `n` is the number of elements in the stack. - Space Complexity should be `O(n)` due to the auxiliary storage used. # Example: ```python # Given stack before function call stack = [3, 7, 1, 14, 9] # After calling first_stutter print(first_stutter(stack)) # Expected output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] # Prepare the stack again stack = [3, 7, 1, 14, 9] # After calling second_stutter print(second_stutter(stack)) # Expected output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Implement the functions `first_stutter` and `second_stutter` as specified.","solution":"def first_stutter(stack): Duplicates each element in the stack using an auxiliary stack. auxiliary_stack = [] # Move all elements to the auxiliary stack while stack: auxiliary_stack.append(stack.pop()) # Move back to original stack, duplicating each element while auxiliary_stack: element = auxiliary_stack.pop() stack.append(element) stack.append(element) return stack from collections import deque def second_stutter(stack): Duplicates each element in the stack using an auxiliary queue. auxiliary_queue = deque() # Move all elements to the auxiliary queue while stack: auxiliary_queue.append(stack.pop()) # Move back to original stack, duplicating each element while auxiliary_queue: element = auxiliary_queue.pop() stack.append(element) stack.append(element) return stack"},{"question":"You have been tasked to implement a variation of the Bogo Sort called **Smart Bogo Sort**. This algorithm tries to sort the array in the least number of shuffles by checking smaller sections of the array in each shuffle. Function Signature ```python def smart_bogo_sort(arr: list, simulation: bool = False) -> list: Sorts an array using an improved version of Bogo Sort. Args: arr (list): A list of integers to sort. simulation (bool): If True, print the internal state after each iteration. Default is False. Returns: list: The sorted array. Raise: ValueError: if the array contains non-integer elements. ``` # Details 1. Check if the array is already sorted. If so, return it immediately. 2. Iterate by progressively checking larger sections of the array for sorting, starting by shuffling the last 2 elements, then the last 3 elements, and so on until the entire array is sorted. 3. Print the internal state after each iteration if `simulation` is set to True. Constraints: * The array can contain up to 1000 integers. * Each integer in the array can range from -10^6 to 10^6. * The array may contain duplicate integers. * All elements in the array should be integers, otherwise raise a `ValueError`. # Example 1. **Input**: arr = [3, 2, 1, 4], simulation = True **Output**: [1, 2, 3, 4] 2. **Input**: arr = [7, -3, 5, 2, -1] **Output**: [-3, -1, 2, 5, 7] # Additional Notes - Ensure the implementation is reasonably efficient and handle printing as needed for debugging purposes. - Think carefully about the edge cases.","solution":"import random def smart_bogo_sort(arr: list, simulation: bool = False) -> list: Sorts an array using an improved version of Bogo Sort. Args: arr (list): A list of integers to sort. simulation (bool): If True, print the internal state after each iteration. Default is False. Returns: list: The sorted array. Raise: ValueError: if the array contains non-integer elements. # Check for non-integer elements for elem in arr: if not isinstance(elem, int): raise ValueError(\\"All elements must be integers.\\") n = len(arr) # Function to check if array is sorted def is_sorted(array): for i in range(len(array) - 1): if array[i] > array[i + 1]: return False return True # If the array is already sorted if is_sorted(arr): return arr sorted_array = arr[:] # Make a copy of the input array # Start by checking and shuffling progressively larger sections for size in range(2, n + 1): is_subarray_sorted = False subarray = sorted_array[-size:] while not is_subarray_sorted: random.shuffle(subarray) sorted_array[-size:] = subarray if simulation: print(f\\"Current array: {sorted_array}\\") is_subarray_sorted = is_sorted(subarray) return sorted_array"},{"question":"Move Zeros To End You are given a list containing various elements, including integers and other data types. Your task is to implement a function `move_zeros` that moves all integer zeros (`0`s) to the end of the list while preserving the order of the other elements. It is important to note that you should not consider boolean values (`True`, `False`) as zeros. # Function Signature ```python def move_zeros(arr: list) -> list: ``` # Input * `arr`: A list containing elements of various types. The list may contain integers, floating point numbers, strings, booleans, and other objects. # Output * Returns a list with all the integer zeros moved to the end while preserving the order of the other elements. # Constraints * The input list may contain up to `10^6` elements. * Use efficient O(n) time complexity and O(1) extra space if possible. # Example ```python # Example 1: # Input: [False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"] # Output: [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] # Example 2: # Input: [0, 0, 0, 1, 2, 3] # Output: [1, 2, 3, 0, 0, 0] # Example 3: # Input: [1, 2, 3] # Output: [1, 2, 3] ``` # Additional Notes: * Ensure that the relative order of non-zero elements and other types remains unchanged. * Implement the function efficiently to handle large lists.","solution":"def move_zeros(arr: list) -> list: Move all integer 0s to the end of the list. Parameters: arr (list): The input list containing various elements. Returns: list: A list with all integer 0s moved to the end of the list. # Initialize two pointers non_zero_index = 0 # Loop through the list for i in range(len(arr)): # Check if the element is a non-zero integer if arr[i] != 0 or isinstance(arr[i], bool): arr[non_zero_index] = arr[i] non_zero_index += 1 # Fill the remaining part of the list with zeros for i in range(non_zero_index, len(arr)): arr[i] = 0 return arr"},{"question":"# Consecutive Sequence Validator As a systems developer, you are tasked with developing a function to verify that a stack of integers maintains a sequence of consecutive numbers starting from the bottom of the stack to the top. Given that stacks operate in a Last In First Out (LIFO) manner, devise an algorithm to validate the sequence and ensure the original stack remains unchanged. Input - A stack of integers represented as a list in Python where the last element is considered the top of the stack. Output - A boolean value: `True` if all numbers form a sequence of consecutive integers, `False` otherwise. Function Signature ```python def is_consecutive_sequence(stack: list[int]) -> bool: pass ``` Constraints 1. We must use either a stack (LIFO) or a queue (FIFO) as auxiliary storage. 2. The algorithm should maintain the original order of elements in the stack. 3. You cannot use any additional external libraries, other than Python\'s built-in data structures. Example ```python stack = [3, 4, 5, 6, 7] assert is_consecutive_sequence(stack) == True stack = [1, 2, 4, 3, 5] assert is_consecutive_sequence(stack) == False stack = [7, 8, 9] assert is_consecutive_sequence(stack) == True stack = [] assert is_consecutive_sequence(stack) == True ``` Points to Consider 1. How would you handle a single integer stack, an empty stack, or very large stacks? 2. Consider typical performance bottlenecks in handling many push and pop operations. 3. Think about maintaining the stack\'s state without loss or modification. Implement the function `is_consecutive_sequence` according to the specifications provided.","solution":"def is_consecutive_sequence(stack: list[int]) -> bool: This function checks if a stack of integers maintains a sequence of consecutive numbers. The original stack order is preserved. if not stack: return True # We use a queue to temporarily store the elements temp_queue = [] # Checking if the stack contains consecutive elements from the bottom to the top prev = stack[0] temp_queue.append(stack.pop(0)) while stack: current = stack[0] if current != prev + 1: stack.insert(0, temp_queue.pop()) # Restore the stack before returning False while temp_queue: stack.insert(0, temp_queue.pop()) return False prev = stack[0] temp_queue.append(stack.pop(0)) # Restore the original stack while temp_queue: stack.insert(0, temp_queue.pop()) return True"},{"question":"Find Missing Ranges Context: You are a software engineer working on a system that monitors sequences of integers for completeness. Given an array of integers within a specified range, you must identify the contiguous ranges of numbers that are missing. Objective: Implement a function `findMissingRanges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]` that: - Accepts a sorted list `arr` of unique integers, and two integers `lo` and `hi` representing the bounds of the range to check. - Returns a list of tuples where each tuple represents a contiguous range of missing numbers within the range `[lo, hi]`. Example: ``` Input: arr = [3, 5], lo = 1, hi = 10 Output: [(1, 2), (4, 4), (6, 10)] Input: arr = [], lo = 1, hi = 5 Output: [(1, 5)] ``` Constraints: 1. The array will be sorted and contain unique integers. 2. `lo` and `hi` will be integers such that `lo <= hi`. 3. The list `arr` length will be in the range [0, 10^4], and `lo` and `hi` will be within [-10^4, 10^4]. Requirements: - Your function should have a time complexity of O(n), where n is the length of the array. - The space complexity should be O(k), where k is the number of missing ranges identified. Notes: 1. Handle edge cases such as an empty array or the `lo` greater than `hi`. 2. Ensure to cover all numbers between `lo` and `hi`, inclusive. Implement the function `findMissingRanges` in Python: ```python def findMissingRanges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: # Implementation here ``` Make sure to test your function with multiple test cases to validate its correctness.","solution":"from typing import List, Tuple def findMissingRanges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: missing_ranges = [] previous = lo - 1 # Go through the array and find gaps between previous element and current element for num in arr: if num - previous > 1: missing_ranges.append((previous + 1, num - 1)) previous = num # Check for any remaining range after the last element in the array if hi - previous > 0: missing_ranges.append((previous + 1, hi)) return missing_ranges"},{"question":"Context You are working for a financial data analytics company, and one common task is to quickly compute the sum of daily stock prices over a specific range of days, as well as update the price for a specific day when new data comes in. Given that these operations need to be highly efficient due to the large volume of data, you have decided to use a Fenwick Tree (Binary Indexed Tree) for this purpose. Task Implement a Fenwick Tree that supports the following operations for an array representing daily stock prices: 1. **Initialize the tree with given stock prices.** 2. **Compute the sum of prices from day 1 to day i.** 3. **Update the price for a specific day.** Requirements 1. **Function 1**: `construct_tree(prices: List[int]) -> List[int]` * **Input**: A list of integers `prices` where `prices[i]` represents the stock price on the (i+1)th day. * **Output**: A list representing the constructed Fenwick Tree. 2. **Function 2**: `get_sum(bit_tree: List[int], i: int) -> int` * **Input**: - `bit_tree`: The Binary Indexed Tree constructed. - `i`: The index up to which the sum is to be computed (0-based index). * **Output**: Sum of elements from 1 to i+1 3. **Function 3**: `update(bit_tree: List[int], i: int, val: int)` * **Input**: - `bit_tree`: The Binary Indexed Tree. - `i`: The index at which the update is to be made (0-based index). - `val`: The new value of the stock price at index `i`. Constraints * The input list `prices` will have a length `n` where 1 ≤ n ≤ 10^6. * All prices will be non-negative integers ≤ 10^5. * Multiple queries and updates may be performed on the structure. Performance Requirements * Both the queries (`get_sum`) and updates (`update`) should be performed in O(log n) time complexity. * The `construct_tree` function should initialize the BIT efficiently. Example ```python prices = [3, 2, -1, 6, 5, 4, -3] bit_tree = construct_tree(prices) print(get_sum(bit_tree, 3)) # Output: 10 (3 + 2 + (-1) + 6) update(bit_tree, 3, 7) # Update index 3 to new value 7 print(get_sum(bit_tree, 3)) # Output: 11 (3 + 2 + (-1) + 7) ```","solution":"def construct_tree(prices): Construct the Fenwick Tree (Binary Indexed Tree) from the given stock prices. n = len(prices) bit_tree = [0] * (n + 1) for i in range(n): update(bit_tree, i, prices[i]) return bit_tree def get_sum(bit_tree, i): Compute the prefix sum from day 1 to day i (0-based index) in the BIT. sum_ = 0 i += 1 # Convert to 1-based index while i > 0: sum_ += bit_tree[i] i -= i & -i return sum_ def update(bit_tree, i, val): Update the BIT for a specific day with a new value. n = len(bit_tree) i += 1 # Convert to 1-based index while i < n: bit_tree[i] += val i += i & -i"},{"question":"# Context You are developing a subsystem for a computer simulation project which involves binary data manipulations. One of the key operations is to perform binary addition on two binary numbers represented as strings. # Task Write a function `add_binary(a: str, b: str) -> str` that takes two binary string arguments and returns their sum as a binary string. # Function Implementation ```python def add_binary(a: str, b: str) -> str: :param a: The first binary string. :param b: The second binary string. :return: The sum of the binary strings as a binary string. # Your code here ``` # Input Format - The input strings `a` and `b` will be non-empty and contain only characters \'0\' or \'1\'. # Output Format - The function should return a single binary string representing the sum of the input binary strings. # Constraints 1. The length of each input string will not exceed 10^4. 2. The input strings are valid binary strings (contains only \'0\' and \'1\'). # Example ```python assert add_binary(\\"11\\", \\"1\\") == \\"100\\" # example from the code provided assert add_binary(\\"1010\\", \\"1011\\") == \\"10101\\" assert add_binary(\\"0\\", \\"0\\") == \\"0\\" assert add_binary(\\"1111\\", \\"1111\\") == \\"11110\\" ``` # Performance Requirements - Ensure your implementation runs efficiently within the provided constraints of 10^4 length for each input string. # Notes - Remember to consider the edge cases such as different lengths of binary strings and carry-over scenarios. - Your implementation should not rely on built-in functions that directly perform binary to decimal conversion and vice versa; instead, manually carry out the binary addition process.","solution":"def add_binary(a: str, b: str) -> str: Adds two binary numbers represented as strings and returns the result as a binary string. :param a: The first binary string. :param b: The second binary string. :return: The sum of the binary strings as a binary string. max_len = max(len(a), len(b)) # Normalize lengths by padding with leading zeros a = a.zfill(max_len) b = b.zfill(max_len) carry = 0 result = [] # Add each binary digit from right to left for i in range(max_len - 1, -1, -1): total_sum = carry total_sum += int(a[i]) total_sum += int(b[i]) carry = total_sum // 2 result.append(str(total_sum % 2)) # If carry is left after final addition if carry != 0: result.append(str(carry)) # The addition result will be in reverse order return \'\'.join(reversed(result))"},{"question":"Scenario You are tasked with modifying binary representations of integers for an embedded systems application. This often requires manipulating specific bits in the representation to optimize data storage and processing. Problem Implement the function `remove_kth_bit(num: int, k: int) -> int` that removes the k-th bit (0-based from the right) from the binary representation of `num` and returns the resulting number. # Input * `num`: An integer, where 0 <= num <= 10^9. * `k`: An integer, the position of the bit to be removed (k >= 0). # Output * Returns an integer which is the binary representation of `num` with the k-th bit removed. Function Signature ```python def remove_kth_bit(num: int, k: int) -> int: pass ``` # Constraints 1. Assume `k` is always a valid bit position in `num` (0 <= k < the bit-length of num). Examples 1. **Input**: `num = 21 (10101 in binary)`, `k = 2` **Output**: `9 (1001 in binary)` 2. **Input**: `num = 21 (10101 in binary)`, `k = 4` **Output**: `5 (101 in binary)` 3. **Input**: `num = 10 (1010 in binary)`, `k = 0` **Output**: `5 (101 in binary)` # Explanation * In the first example, removing the second bit from `10101` (from right, 0-based) results in `1001`. * In the second example, by removing the fourth bit from `10101`, we get `101`. * Lastly, removing the zeroth bit from `1010` results in `101`. # Notes * Ensure that you handle edge cases, such as removing the most significant or least significant bits. * Consider the performance implications for large numbers, even though the operation itself is constant time. Implement the function and test with various cases to validate your solution.","solution":"def remove_kth_bit(num: int, k: int) -> int: Removes the k-th bit (0-based from the right) from the binary representation of num and returns the resulting number. # Step 1: Get the bit mask for removing the k-th bit bit_mask = (1 << k) - 1 # Step 2: Separate the parts before and after the k-th bit, then join them lower_part = num & bit_mask # Bits lower than k-th upper_part = num >> (k + 1) # Bits higher than k-th, shifted right to remove the k-th bit # Step 3: Combine the upper and lower parts to get the result and return result = (upper_part << k) | lower_part return result"},{"question":"Given the fundamental numerical concepts demonstrated in the provided code snippets, you are required to implement a function that computes the LCM of an array of integers efficiently. # Problem Statement Implement a function `lcm_array(arr: List[int]) -> int` that takes a list of non-negative integers `arr` and returns their Least Common Multiple (LCM). * **Input**: A list of non-negative integers, `arr`, where 1 ≤ len(arr) ≤ 100 and 0 ≤ arr[i] ≤ 10^6. * **Output**: The LCM of all integers in the list. # Constraints * The list will contain at least one non-zero integer. * You must handle large integer products efficiently to avoid overflow. # Example ```python lcm_array([2, 7, 3]) # Returns: 42 lcm_array([0, 6, 9]) # Returns: 18 lcm_array([4]) # Returns: 4 ``` # Function Signature ```python from typing import List def lcm_array(arr: List[int]) -> int: pass ``` # Notes * You may utilize the provided `gcd` and `lcm` functions (or implement your versions if you find any shortcomings). * Pay attention to edge cases, such as the presence of zero, as the LCM of zero with any number is undefined and should be ignored for calculation purposes.","solution":"from typing import List from math import gcd def lcm(x, y): return x * y // gcd(x, y) def lcm_array(arr: List[int]) -> int: result = 1 for num in arr: if num == 0: continue result = lcm(result, num) return result # Example usage # print(lcm_array([2, 7, 3])) # Should return 42 # print(lcm_array([0, 6, 9])) # Should return 18 # print(lcm_array([4])) # Should return 4"},{"question":"# Problem: Graph Traversal Applications You are given an unweighted, undirected graph represented as an adjacency list, and you need to implement two different traversal methods for this graph: Depth-First Search (DFS) and Breadth-First Search (BFS). Task 1. **DFS Method**: - Implement an iterative Depth-First Search (DFS) traversal function `dfs_traverse` that visits all nodes starting from a given node. 2. **BFS Method**: - Implement a Breadth-First Search (BFS) traversal function `bfs_traverse` that visits all nodes starting from a given node. Function Signatures ```python def dfs_traverse(graph: Dict[int, List[int]], start: int) -> List[int]: pass def bfs_traverse(graph: Dict[int, List[int]], start: int) -> List[int]: pass ``` Input * `graph`: A dictionary where keys are node identifiers (integers) and values are lists of adjacent nodes. * `start`: An integer representing the starting node for the traversal. Output * Return a list of nodes in the order they are visited during the traversal. Constraints * The graph is connected and can contain cycles. * All node identifiers are unique. * Node identifiers are non-negative integers. Example ```python graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2] } start = 0 dfs_result = dfs_traverse(graph, start) print(dfs_result) # Possible Output: [0, 2, 3, 1] or [0, 1, 2, 3] bfs_result = bfs_traverse(graph, start) print(bfs_result) # Output: [0, 1, 2, 3] ``` Notes * Both functions should handle graph traversal efficiently. * Take care of cycles and ensure each node is visited only once. * The order of traversal for DFS might differ but must follow depth-first rules.","solution":"from collections import deque from typing import List, Dict def dfs_traverse(graph: Dict[int, List[int]], start: int) -> List[int]: Perform an iterative Depth-First Search (DFS) traversal of the graph starting from `start` node. visited = set() stack = [start] result = [] while stack: node = stack.pop() if node not in visited: visited.add(node) result.append(node) # Add nodes in reverse order to visit in the given order when popped stack.extend(reversed(graph[node])) return result def bfs_traverse(graph: Dict[int, List[int]], start: int) -> List[int]: Perform a Breadth-First Search (BFS) traversal of the graph starting from `start` node. visited = set() queue = deque([start]) result = [] while queue: node = queue.popleft() if node not in visited: visited.add(node) result.append(node) queue.extend(graph[node]) return result"},{"question":"# Question: Implement a Modified Inorder Tree Traversal **Context**: A software system uses a binary tree to represent a set of hierarchical data. As a new feature, your task is to implement a modified in-order traversal that performs extra operations on each node. Specifically, increment each node\'s value by a given integer k during traversal. **Requirements**: - Implement the function `modified_inorder(root, k)`, where `root` is the root node of the binary tree, and `k` is the integer to be added to each node\'s value. - Your function should return a list of the node values post-modification in in-order sequence. **Constraints**: - You may assume that all node values are integers. - Each node in the binary tree follows the given class structure: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` **Performance Requirements**: - The function should run in O(n) time complexity. - The function should use O(h) space complexity. **Function Signature**: ```python def modified_inorder(root: Node, k: int) -> list: # Your code here pass ``` **Example**: ```python # Construct the binary tree # 100 # / # 50 150 # / / # 25 75 125 175 n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 # Modify values with k = 10 result = modified_inorder(n1, 10) assert result == [35, 60, 85, 110, 135, 160, 185] # The tree after modification should look like: # 110 # / # 60 160 # / / # 35 85 135 185 ```","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def modified_inorder(root, k): def inorder(node): if not node: return [] # Traverse the left subtree left_values = inorder(node.left) # Modify the node\'s value node.val += k # Traverse the right subtree right_values = inorder(node.right) # Return in-order traversal of the tree return left_values + [node.val] + right_values return inorder(root)"},{"question":"# Question: You are given a directed graph represented as an adjacency list and need to write a function to determine whether the graph contains a cycle. Your task is to implement the cycle detection algorithm described in the analysis. Function Signature: ```python def contains_cycle(graph: dict) -> bool: pass ``` Input: - `graph` (dict): A dictionary representing the directed graph where keys are vertices and values are lists of adjacent vertices indicating directed edges. Output: - (bool): Returns `True` if the graph contains a cycle, otherwise `False`. Constraints: - The graph is non-empty. - The graph can contain self-loops and disconnected components. - Vertices are identified by unique strings (e.g., \'A\', \'B\', \'C\'). Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(contains_cycle(graph)) # Output: True ``` Note: - The graph in the example contains a cycle, hence the output is `True`. Context: Imagine you are developing a system to manage dependencies between various components of a project. Each component is represented by a vertex in the graph and dependencies are directed edges between these vertices. You need to ensure that there\'s no cyclic dependency in the project structure. Your implementation should efficiently detect if any component dependencies form a cycle, potentially leading to a dependency deadlock.","solution":"def contains_cycle(graph: dict) -> bool: Determines if the directed graph contains a cycle. Args: graph (dict): A dictionary representing the directed graph. Returns: bool: True if the graph contains a cycle, False otherwise. visited = set() rec_stack = set() def dfs(v): visited.add(v) rec_stack.add(v) for neighbor in graph.get(v, []): if neighbor not in visited: if dfs(neighbor): return True elif neighbor in rec_stack: return True rec_stack.remove(v) return False for node in graph: if node not in visited: if dfs(node): return True return False"},{"question":"# Sliding Window Maximum Challenge Context You are tasked with analyzing a large data stream. To better understand peak values, you need to maintain a sliding window of a given size and retrieve the maximum value within each window as it moves across the array. Task Implement a function `max_sliding_window(arr, k)` that: - Takes an array of integers `arr` and an integer `k` representing the size of the window. - Returns a list of integers representing the maximum values in each sliding window. Input Format - `arr` (list of int): The array of integers where `1 <= len(arr) <= 10^5` and `-10^4 <= arr[i] <= 10^4`. - `k` (int): The size of the sliding window where `1 <= k <= len(arr)`. Output Format - A list of integers containing the maximum value in each sliding window. Constraints - Function should be optimized to run with a time complexity of O(n) where `n` is the length of the array. Example Input: ```python arr = [1,3,-1,-3,5,3,6,7] k = 3 ``` Output: ```python [3, 3, 5, 5, 6, 7] ``` Hints - Utilize a deque to keep track of indices of potential candidates for the maximum value. - Ensure that the elements in the deque are in descending order. Implement the function below: ```python def max_sliding_window(arr, k): import collections qi = collections.deque() # queue storing indexes of elements result = [] for i, n in enumerate(arr): while qi and arr[qi[-1]] < n: qi.pop() qi.append(i) if qi[0] == i - k: qi.popleft() if i >= k - 1: result.append(arr[qi[0]]) return result ```","solution":"from collections import deque def max_sliding_window(arr, k): Returns a list of integers representing the maximum values in each sliding window of size k. Parameters: arr (list): List of integers representing the array. k (int): The size of the sliding window. Returns: list: List of integers representing the maximum values in each sliding window. if not arr or k == 0: return [] qi = deque() # Queue storing indexes of elements result = [] for i in range(len(arr)): # Remove elements not within the sliding window if qi and qi[0] < i - k + 1: qi.popleft() # Maintain the deque such that the front is the largest element index while qi and arr[qi[-1]] < arr[i]: qi.pop() qi.append(i) # Only start recording results once the first window is complete if i >= k - 1: result.append(arr[qi[0]]) return result"},{"question":"# Scenario: You are tasked with designing a very inefficient sorting function for a hypothetical application where time complexity is intentionally required to be poor due to some experimental reasons. You have chosen the Stooge Sort algorithm for this purpose. # Objective: Implement the Stooge Sort algorithm in Python to sort an array of integers in non-decreasing order. # Requirements: - Your function should be called `stooge_sort(arr)`. - It should take a single parameter, `arr`, which is a list of integers. - It should modify `arr` in place to sort the elements. - Arrays can have from 0 to 100 elements, values ranging from -1000 to 1000. - Do not use any built-in sorting functions like `sorted()` or `sort()`. # Example: ```python input_array = [1, 4, 3, 2, 5] stooge_sort(input_array) print(input_array) # Output should be: [1, 2, 3, 4, 5] ``` # Constraints: - Focus on the correctness of the implementation. - Ensure your algorithm follows the principles of Stooge Sort. - Handle edge cases such as empty arrays or arrays with a single element.","solution":"def stooge_sort(arr, l=0, h=None): Sorts the array arr[l..h] using Stooge Sort. This function modifies the array in place. :param arr: List of integers to be sorted :param l: Starting index of the sublist :param h: Ending index of the sublist if h is None: h = len(arr) - 1 if l >= h: return # If the element at l is greater than the element at h, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array if h - l + 1 > 2: # Find the two-thirds point t = (h - l + 1) // 3 # Recursively sort the first two-thirds stooge_sort(arr, l, h - t) # Recursively sort the last two-thirds stooge_sort(arr, l + t, h) # Recursively sort the first two-thirds again stooge_sort(arr, l, h - t)"},{"question":"# Question: Word Pattern Matching Checker Given a pattern string `pattern` and an input string `s`, write a function `follows_pattern(pattern: str, s: str) -> bool` which checks if the input string `s` follows the given pattern `pattern`. To follow a pattern means: - There exists a one-to-one correspondence between the characters in `pattern` and non-empty words in `s`. - Each character in `pattern` maps to exactly one unique word in the string `s`, and each word in `s` maps to exactly one unique character in the `pattern`. # Constraints: - The `pattern` only contains lowercase letters from \'a\' to \'z\'. - The input string `s` contains lowercase words separated by single spaces. - The `pattern` and `s` are both non-empty and do not contain any leading or trailing spaces. # Input - `pattern`: a string representing the pattern. - `s`: a string of words separated by single spaces. # Output - Return `True` if the input string `s` follows the pattern, otherwise `False`. # Examples Example 1: ``` Input: pattern = \\"abba\\", s = \\"dog cat cat dog\\" Output: True ``` Example 2: ``` Input: pattern = \\"abba\\", s = \\"dog cat cat fish\\" Output: False ``` Example 3: ``` Input: pattern = \\"aaaa\\", s = \\"dog cat cat dog\\" Output: False ``` Example 4: ``` Input: pattern = \\"abba\\", s = \\"dog dog dog dog\\" Output: False ``` # Additional Notes - You may assume that `pattern` only contains lowercase letters and `s` contains lowercase words separated by a single space. - Aim to implement the function efficiently considering both time and space complexity.","solution":"def follows_pattern(pattern: str, s: str) -> bool: words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"# Context: You are working on a text processing application that needs to suggest the nearest correct word to a misspelled input with minimal changes. A core part of this feature is determining whether two given strings are one edit distance apart. An edit is defined as inserting, removing, or replacing a single character in one string to obtain the other. # Task: Write a function `is_one_edit_distance(s: str, t: str) -> bool` that checks if two input strings `s` and `t` are one edit distance apart. The function should return `True` if the strings are one edit distance apart, otherwise `False`. # Input: - `s`, `t`: Two strings composed of lowercase English letters. # Output: - A boolean value (`True` or `False`) indicating whether the two strings are one edit distance apart. # Constraints: - `0 <= len(s), len(t) <= 10^4` # Requirements: - The solution must run in linear time O(n), where n is the length of the shorter string. - Use O(1) additional space. # Examples: ```python assert is_one_edit_distance(\\"abc\\", \\"ab\\") == True assert is_one_edit_distance(\\"abc\\", \\"abcd\\") == True assert is_one_edit_distance(\\"abc\\", \\"abx\\") == True assert is_one_edit_distance(\\"abc\\", \\"abc\\") == False assert is_one_edit_distance(\\"abc\\", \\"abxy\\") == False ```","solution":"def is_one_edit_distance(s: str, t: str) -> bool: Check if two input strings s and t are one edit distance apart. if abs(len(s) - len(t)) > 1: return False if len(s) > len(t): s, t = t, s # Ensure s is the shorter string i, j, found_difference = 0, 0, False while i < len(s) and j < len(t): if s[i] != t[j]: if found_difference: return False found_difference = True if len(s) < len(t): j += 1 # Try to insert a character in s continue i += 1 j += 1 return found_difference or (len(s) < len(t))"},{"question":"# Matrix Transformation Challenge You have been provided with functions that rotate and invert matrices in various ways. A matrix is represented as a 2D list of integers in Python. Your task is to extend this functionality by implementing the following new transformations: 1. **Rotate the matrix 180 degrees**. 2. **Invert the matrix from top-right to bottom-left**. 3. **Invert the matrix from bottom-right to top-left**. Write a function each for these transformations with the following signatures: ```python def rotate_180(matrix): pass def top_right_invert(matrix): pass def bottom_right_invert(matrix): pass ``` # Input - **matrix**: A 2D list of integers, where each sublist represents a row in the matrix. # Output - The transformed matrix corresponding to the specific transformation. # Constraints - The matrix can have up to 10^3 rows and an equal number of columns (square matrix). - Elements are integers within the range -10^5 to 10^5. # Example Given the matrix: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` * **rotate_180(matrix)** should return: ```python [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] ``` * **top_right_invert(matrix)** should return: ```python [ [3, 2, 1], [6, 5, 4], [9, 8, 7] ] ``` * **bottom_right_invert(matrix)** should return: ```python [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Make sure to handle edge cases (e.g., empty matrix, single element matrix) appropriately.","solution":"def rotate_180(matrix): Rotates the matrix 180 degrees. return [row[::-1] for row in matrix[::-1]] def top_right_invert(matrix): Inverts the matrix from top-right to bottom-left. return [row[::-1] for row in matrix] def bottom_right_invert(matrix): Inverts the matrix from bottom-right to top-left. return matrix[::-1]"},{"question":"You\'re given an integer array `arr` which needs to be sorted using a variant of insertion sort that employs binary search to find the correct insertion point efficiently. The overall algorithm should refine the searching step, though the insertion step remains standard. Implement the function `binary_insertion_sort` that sorts the input array in ascending order. # Function Signature: ```python def binary_insertion_sort(arr: List[int]) -> List[int]: pass ``` # Input: * A list of integers `arr` where `1 <= len(arr) <= 10^3`. # Output: * A new list of integers sorted in ascending order. # Constraints: * Elements in `arr` are not necessarily distinct and may range in value between `-10^4` and `10^4`. * Your solution should leverage `search_insert` for determining the insertion point. # Example: ```python assert binary_insertion_sort([4, 2, 9, 1, 5]) == [1, 2, 4, 5, 9] assert binary_insertion_sort([12, 11, 13, 5, 6]) == [5, 6, 11, 12, 13] assert binary_insertion_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert binary_insertion_sort([5, -3, 10, 2, -1]) == [-3, -1, 2, 5, 10] ``` # Scenario: Imagine you are working for a library sorting system where new books (represented by unique IDs) arrive incrementally. The system needs to insert each new book in a way such that the list of books remains sorted. Writing this efficient insertion sort will help manage the library database efficiently.","solution":"from typing import List def search_insert(arr: List[int], val: int, start: int, end: int) -> int: Uses binary search to find the index at which val should be inserted in the subarray arr[start:end]. while start < end: mid = (start + end) // 2 if arr[mid] < val: start = mid + 1 else: end = mid return start def binary_insertion_sort(arr: List[int]) -> List[int]: Sorts the array arr using an insertion sort variant with binary search for locating the insertion point. for i in range(1, len(arr)): key = arr[i] j = search_insert(arr, key, 0, i) arr = arr[:j] + [key] + arr[j:i] + arr[i+1:] return arr"},{"question":"You are tasked with implementing a function `is_consecutive_squares` to check if a stack contains a sequence of consecutive square numbers starting from the bottom. Function Signature ```python def is_consecutive_squares(stack: list) -> bool: ``` Input - A list `stack` representing a stack of integers (with at least one element). Output - Returns a boolean: `True` if the stack contains a sequence of consecutive square numbers starting from the bottom, and `False` otherwise. Constraints 1. The function should not modify the original stack. 2. Use a single auxiliary data structure (either stack or queue). Example ```plaintext Example 1: Input: stack = [1, 4, 9, 16, 25] Output: True Example 2: Input: stack = [1, 4, 9, 25] Output: False Example 3: Input: stack = [4, 9, 16, 25] Output: False ``` Performance Requirements The solution should run in O(n) time where n is the number of elements in the stack, and use O(n) auxiliary space. Notes - The function should handle standard edge cases, such as a single-element stack or a stack with gaps in the sequence. Implement the `is_consecutive_squares` function in Python.","solution":"def is_consecutive_squares(stack: list) -> bool: Checks if the given stack contains a sequence of consecutive square numbers starting from the bottom. Args: stack (list): A list representing a stack of integers (non-empty). Returns: bool: True if the stack contains a sequence of consecutive square numbers starting from the bottom, False otherwise. if not stack: return False from math import isqrt n = len(stack) expected_square = 1 for i in range(n): if stack[i] != expected_square: return False expected_square = (isqrt(expected_square) + 1) ** 2 return True"},{"question":"# Stack Implementation and Critical Problems You have studied the Stack (abstract data type) and its two primary implementations - using arrays and linked lists. Now, it\'s time to demonstrate your understanding by solving a critical problem using a stack. # Problem: Balanced Parentheses Given a string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', determine if the input string is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. Write a function `is_valid_parentheses` to solve this problem. Function Signature ```python def is_valid_parentheses(s: str) -> bool: pass ``` Input - `s`: A string containing characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', where 1 ≤ `len(s)` ≤ 10^4. Output - Returns `True` if the input string is valid; otherwise, returns `False`. # Constraints 1. The solution must run in linear time O(n), where n is the length of the input string. 2. Use either array-based stack or linked list-based stack to solve this problem. # Example ```python assert is_valid_parentheses(\\"()\\") == True assert is_valid_parentheses(\\"()[]{}\\") == True assert is_valid_parentheses(\\"(]\\") == False assert is_valid_parentheses(\\"([)]\\") == False assert is_valid_parentheses(\\"{[]}\\") == True ``` # Note Think about the stack operations and how they can help determine the sequence and matching pairs of parentheses. Utilize the push and pop functionality to maintain the order and match closing brackets with their corresponding opening ones.","solution":"def is_valid_parentheses(s: str) -> bool: Returns True if the input string has valid parentheses, False otherwise. stack = [] bracket_map = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if stack == [] or bracket_map[char] != stack.pop(): return False else: return False return stack == []"},{"question":"# Curious Numbers Challenge Problem Statement: A curious number is an integer that is equal to the sum of its digits each raised to the power of their respective positions (starting from 1). For instance, the number `135` is calculated as follows: [ 135 = 1^1 + 3^2 + 5^3 = 1 + 9 + 125 = 135 ] Write a Python function `find_curious_numbers(low, high)` that takes two integers `low` and `high` as input (where (1 leq text{low} leq text{high})) and returns a list of all curious numbers within this inclusive range. Input: * `low`: (integer) the lower bound of the range. * `high`: (integer) the upper bound of the range. Output: * A list of integers representing all curious numbers between `low` and `high`. Constraints: * (1 leq text{low} leq text{high} leq 10^6) Example: For example, calling `find_curious_numbers(1, 150)` should return: * `[1, 2, 3, 4, 5, 6, 7, 8, 9, 89, 135]` Visibility: * Ensure your function runs efficiently for large ranges approaching the upper limit of the constraint. Guidance: * Consider precomputing powers of digits to optimize the calculation. * Validate edge cases where `low` might be equal to `high`. ```python def find_curious_numbers(low, high): result = [] for number in range(low, high + 1): exponent = 1 summation = 0 number_as_string = str(number) tokens = list(map(int, number_as_string)) for k in tokens: summation += (k ** exponent) exponent += 1 if summation == number: result.append(number) return result # Example usage: assert find_curious_numbers(1, 150) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89, 135] ```","solution":"def find_curious_numbers(low, high): def is_curious_number(n): return n == sum(int(digit) ** (idx + 1) for idx, digit in enumerate(str(n))) return [n for n in range(low, high + 1) if is_curious_number(n)]"},{"question":"# Problem: Finding Unique Elements in Array Scenario You are given an array of integers where exactly two elements appear only once, and all the other elements appear exactly twice. Your task is to identify the two unique elements. Instructions Implement a function `find_unique_elements(nums)` that takes a list of integers `nums` and returns a list containing the two unique elements. Input * A list of integers `nums` where exactly two elements appear only once and all the other elements appear twice. * The list will always contain at least two elements. Output * A list of two integers that appear only once in the input list. The order of the results does not matter. Constraints * The solution must be implemented with a time complexity of O(N) and a space complexity of O(1). Example Given the list of numbers `nums = [4, 1, 2, 1, 2, 5]`, the function should return `[4, 5]` (or `[5, 4]`). Implementation Use the properties of XOR operation to isolate the two unique numbers.","solution":"def find_unique_elements(nums): Returns a list containing the two unique elements in the given list of integers where all elements except two appear exactly twice. # XOR all the elements to get the XOR of the two unique numbers xor_all = 0 for num in nums: xor_all ^= num # Find a set bit in the result (this will help in separating the two unique numbers) set_bit = xor_all & -xor_all # Initialize variables to hold the two unique numbers unique1, unique2 = 0, 0 # Divide all numbers into two groups based on the set bit for num in nums: if num & set_bit: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"# Permutations of a List **Context**: You are tasked with developing a function to generate all possible permutations of a given list of distinct integers. This functionality is critical in various scenarios like solving puzzles, creating game heuristics, optimization problems, etc. Your implementation must handle different input sizes efficiently, and it should generate permutations without redundancies. **Problem Statement**: Implement the function `generate_permutations` that takes a list of distinct integers and returns a list of all possible permutations of those integers. **Function Signature**: ```python def generate_permutations(nums: List[int]) -> List[List[int]]: ``` **Input**: * `nums` (List[int]): A list of distinct integers (1 <= len(nums) <= 10, -100 <= nums[i] <= 100). **Output**: * Returns: (List[List[int]]) A list containing all permutations of the input list. **Examples**: ```python generate_permutations([1, 2, 3]) # Output: # [ # [1, 2, 3], # [1, 3, 2], # [2, 1, 3], # [2, 3, 1], # [3, 1, 2], # [3, 2, 1] # ] generate_permutations([0, -1]) # Output: # [ # [0, -1], # [-1, 0] # ] ``` **Constraints**: * You must explore all possible permutations. * You should avoid using excessive memory. Optimizations such as using in-place modifications and generators are encouraged but not required. **Evaluation Criteria**: * **Correctness**: The function should return the correct and complete set of permutations. * **Efficiency**: Handle the input size efficiently within the given constraints. * **Code Quality**: Use clear, readable code with appropriate variable naming and comments as necessary.","solution":"from typing import List def generate_permutations(nums: List[int]) -> List[List[int]]: Generate all possible permutations of a given list of distinct integers. :param nums: List of distinct integers :return: A list of all possible permutations of the input list if len(nums) == 0: return [[]] if len(nums) == 1: return [nums] permutations = [] for i in range(len(nums)): current_num = nums[i] remaining_nums = nums[:i] + nums[i+1:] for perm in generate_permutations(remaining_nums): permutations.append([current_num] + perm) return permutations"},{"question":"# Question Scenario Imagine you are implementing a feature for a time logging application. Users can log time intervals, and you need to provide a summarized view of these intervals. Task Write a function `summarize_ranges` that takes a sorted list of integers representing individual time points and returns a list of summarized ranges. Specifications * **Function Signature**: ```python def summarize_ranges(array: List[int]) -> List[str]: ``` * **Input**: * `array` (List[int]): A sorted list of unique integers. * **Output**: * List[str]: A list of string representations of summarized ranges. * A range is represented as \\"start-end\\" if it includes more than one element. * Single elements are represented as \\"start\\". Constraints * All elements in the input list are unique. * The input list is sorted in ascending order. Examples ```python summarize_ranges([0, 1, 2, 4, 5, 7]) # Output: [\\"0-2\\", \\"4-5\\", \\"7\\"] summarize_ranges([3, 4, 5, 7, 8, 10]) # Output: [\\"3-5\\", \\"7-8\\", \\"10\\"] summarize_ranges([1, 3, 4, 5, 7]) # Output: [\\"1\\", \\"3-5\\", \\"7\\"] summarize_ranges([1]) # Output: [\\"1\\"] ``` Additional Requirements * Make sure your implementation runs efficiently for large inputs. Ensure it operates within linear time complexity relative to the input size. * Properly handle edge cases such as an empty input list.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: Summarizes a sorted list of integers into a list of ranges. Parameters: - array: List[int] - a sorted list of unique integers. Returns: - List[str]: a list of string representations of summarized ranges. if not array: return [] ranges = [] start = array[0] end = array[0] for i in range(1, len(array)): if array[i] == end + 1: end = array[i] else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = array[i] end = array[i] if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"# Priority Queue with Linear Array You are tasked with implementing a priority queue using a linear array. Your priority queue should maintain elements in descending order based on their priority such that extracting the element with the lowest priority is efficient (O(1) complexity). **Function Implementation:** 1. **push(item, priority)** - **Input**: `item` - an integer value, `priority` - an integer priority value associated with the item. - **Output**: None - **Behavior**: Inserts the item into the priority queue following the correct order based on priority. 2. **pop()** - **Input**: None - **Output**: An integer which is the item associated with the lowest priority. - **Behavior**: Removes and returns the item with the lowest priority from the queue. It is assumed that pop will never be called on an empty queue. 3. **size()** - **Input**: None - **Output**: An integer representing the number of elements in the queue. - **Behavior**: Returns the size of the priority queue. 4. **__repr__()** - **Input**: None - **Output**: A string representing the internal state of the priority queue for debugging purposes. - **Behavior**: Provides a string representation of the priority queue. **Performance Requirements**: - The `push` method should have a time complexity of O(n). - The `pop` method should have a time complexity of O(1). **Constraints**: - You can assume that the priority queue will never reach more than 1000 elements. **Example:** ```python pq = PriorityQueue() pq.push(4, 10) pq.push(1, 5) pq.push(3, 7) print(pq.size()) # Output: 3 print(pq.pop()) # Output: 1 print(pq.pop()) # Output: 3 print(pq.size()) # Output: 1 print(pq) # Output: PriorityQueue([4: 10]) ``` **Note**: Ensure your implementation handles inserting elements with duplicate priorities correctly and maintains the correct order.","solution":"class PriorityQueue: def __init__(self): self.queue = [] def push(self, item, priority): Inserts the item into the priority queue following the correct order based on priority. self.queue.append((item, priority)) self.queue.sort(key=lambda x: x[1]) def pop(self): Removes and returns the item with the lowest priority from the queue. return self.queue.pop(0)[0] def size(self): Returns the number of elements in the priority queue. return len(self.queue) def __repr__(self): Provides a string representation of the priority queue. return f\\"PriorityQueue({[f\'{item}: {priority}\' for item, priority in self.queue]})\\""},{"question":"# Question: Custom In-Place Sorting Algorithm Your task is to implement a custom sorting function called `custom_sort`. This function will take an array and sort it using a variation of the insertion sort algorithm. Unlike traditional insertion sort that sorts in ascending order, this custom sort will sort the array in descending order. # Function Signature: ```python def custom_sort(arr: list) -> list: ``` # Input: - `arr` (List of integers): An unsorted array of integers. # Output: - A sorted array in descending order. # Constraints: - The function should sort the array in-place. - The function should have O(1) additional space complexity. - The array length will be in the range [0, 1000]. # Requirements: - Do not use Python\'s built-in sorting functions or libraries. - Ensure your implementation is efficient and handles edge cases appropriately. # Examples: ```python # Example 1 input_array = [4, 2, 9, 1] output_array = custom_sort(input_array) print(output_array) # Output: [9, 4, 2, 1] # Example 2 input_array = [5, 5, 5, 5] output_array = custom_sort(input_array) print(output_array) # Output: [5, 5, 5, 5] # Example 3 input_array = [] output_array = custom_sort(input_array) print(output_array) # Output: [] # Example 4 input_array = [1] output_array = custom_sort(input_array) print(output_array) # Output: [1] ``` # Evaluation Criteria: 1. **Correctness**: The array should be sorted in descending order. 2. **Efficiency**: Properly optimizes for space and handles the given constraints. 3. **Edge Cases**: Should correctly handle edge cases like empty arrays and arrays with duplicate elements or single elements.","solution":"def custom_sort(arr: list) -> list: Sorts the input list in-place in descending order using a variation of the insertion sort algorithm. n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 # Move elements of arr[0...i-1], that are less than key, to one position ahead of their current position while j >= 0 and arr[j] < key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Question: Implementing Range Sum Query with Fenwick Tree **Scenario**: You are tasked with managing a financial report system that repetitively handles updates to various transactions and needs to fetch the cumulative sum of transactions up to a specific point in time efficiently. Given an initial list of daily transactions, you will need to build a structure that supports these operations. **Task**: Implement a class `FenwickTree` that supports the following functionalities using a Binary Indexed Tree (Fenwick Tree): 1. **Initialization**: Given an initial array of integers (daily transaction amounts), construct the Fenwick Tree. 2. **Update Operation**: Update the transaction amount at a specific index. 3. **Prefix Sum Query**: Return the sum of all transactions from the start up to a given index. Class Definition and Function Signatures Your implementation should include: - `__init__(self, transactions: List[int]) -> None`: Initializes the Fenwick Tree with a given list of transactions. - `update(self, index: int, value: int) -> None`: Updates the transaction amount at the specified index to the provided value. - `sum_up_to(self, index: int) -> int`: Returns the cumulative sum of transactions from the start up to the specified index. Constraints - The initial list of transactions\' length (n) will be between 1 and 200,000. - Each \\"update\\" operation should be performed in O(log n) time. - Each \\"sum_up_to\\" query should be resolved in O(log n) time. Example ```python # Example Usage transactions = [10, 20, 30, 40, 50] tree = FenwickTree(transactions) # Update operation, changing the transaction at index 1 to 25 tree.update(1, 25) # Query the cumulative sum from the start up to index 3 print(tree.sum_up_to(3)) # Should output 95 ```","solution":"class FenwickTree: def __init__(self, transactions): Initializes the Fenwick Tree with a given list of transactions. self.n = len(transactions) self.tree = [0] * (self.n + 1) self.transactions = transactions.copy() for i, val in enumerate(transactions): self._update_tree(i + 1, val) def _update_tree(self, index, value): Helper function to update the tree for internal use. while index <= self.n: self.tree[index] += value index += index & -index def update(self, index, value): Updates the transaction amount at the specified index to the provided value. if 0 <= index < self.n: delta = value - self.transactions[index] self.transactions[index] = value self._update_tree(index + 1, delta) else: raise IndexError(\\"Index out of bounds\\") def sum_up_to(self, index): Returns the cumulative sum of transactions from the start up to the specified index. if not 0 <= index < self.n: raise IndexError(\\"Index out of bounds\\") index += 1 # To match 1-based indexing of Fenwick Tree result = 0 while index > 0: result += self.tree[index] index -= index & -index return result"},{"question":"Scenario You are developing a file management tool that requires converting various forms of file paths to their absolute equivalents for consistent handling across different modules of the application. As part of this tool, you need to write a function that resolves any given file path (including relative paths and user-specific paths) to its absolute form. Problem Statement Implement the function `resolve_file_path` that takes a string `file_path` as input and returns the absolute path of the file. The function should handle user-specific paths (not just the current user but also specified users) and should resolve any relative paths to their absolute form. # Input: * `file_path` (string): A file path which can be relative, absolute, or user-specific (using `~` or `~user`). # Output: * Returns a string that represents the absolute path of the given `file_path`. # Constraints: * The input path is a valid string. * The length of the input string will not exceed 1000 characters. # Examples: ```python assert resolve_file_path(\\"~/my_folder/file.txt\\") == \\"/home/current_user/my_folder/file.txt\\" # Example, specific to the current user assert resolve_file_path(\\"/etc/config\\") == \\"/etc/config\\" # Absolute path assert resolve_file_path(\\"docs/readme.md\\") == \\"/current/directory/docs/readme.md\\" # Relative path converted ``` # Requirements: * Ensure that your function efficiently converts relative and user-specific paths. * Handle cases where the input is already an absolute path correctly. * The function should not necessarily check if the file exists at the resolved path but should reliably convert the path format. ```python import os def resolve_file_path(file_path): Function to resolve the absolute file path from various forms. :param file_path: str : input file path which can be relative, absolute, or user-specific :return: str : absolute file path return os.path.abspath(os.path.expanduser(file_path)) # Test cases print(resolve_file_path(\\"~/my_folder/file.txt\\")) print(resolve_file_path(\\"/etc/config\\")) print(resolve_file_path(\\"docs/readme.md\\")) ```","solution":"import os def resolve_file_path(file_path): Function to resolve the absolute file path from various forms. :param file_path: str : input file path which can be relative, absolute, or user-specific :return: str : absolute file path return os.path.abspath(os.path.expanduser(file_path))"},{"question":"Efficient Duplicate Removal from an Array In this question, you\'ll implement an optimized version of an algorithm to remove duplicates from a list (array). The goal is to ensure the result contains only the first occurrence of each element, maintaining the initial order, but with an improved time complexity. Implement the function `efficient_remove_duplicates(array)` that takes a list `array` as input and returns a new list with all duplicates removed. The function should be efficient, aiming for a linear time complexity, O(n). Input and Output Formats * **Input**: A list `array` which may contain integers, strings, booleans, or a combination of these types. - Example: `[1, 1 ,1 ,2 ,2 ,3 ,4 ,4 ,\\"hey\\", \\"hey\\", \\"hello\\", True, True]` * **Output**: A list with duplicated elements removed, keeping only the first occurrence and maintaining the initial order. - Example: `[1, 2, 3, 4, \'hey\', \'hello\', True]` Constraints and Limitations * You should handle arrays with up to 10^6 elements. * The elements in the array may include mixed data types (integers, strings, etc.). Performance Requirements * The implementation should operate efficiently with a time complexity of O(n). * Extra space usage should remain reasonable. Example ```python # Example Input array = [1, 1, \'test\', 2, \'test\', 3, 1, 3, 4] # Expected Output output = [1, \'test\', 2, 3, 4] ``` Implement the function `efficient_remove_duplicates(array)` as described.","solution":"def efficient_remove_duplicates(array): Returns a new list with duplicates removed, keeping only the first occurrence and maintaining the initial order. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"**Problem Statement**: You are tasked with implementing a function that utilizes Euler\'s Totient function to determine the number of integers between 1 and `n` (inclusive) which are coprime to `n`. Given an integer `n`, your function should compute the value of ϕ(n) efficiently. **Function Signature**: ```python def euler_totient(n: int) -> int: pass ``` **Input**: * An integer `n` (1 ≤ n ≤ 10^6) **Output**: * Returns an integer representing ϕ(n). **Constraints**: * Your solution should run efficiently for the given input size. * Consider memory usage and ensure your solution does not exceed space complexity of O(1) beyond the input size. **Example**: ```python assert euler_totient(1) == 1 assert euler_totient(2) == 1 assert euler_totient(3) == 2 assert euler_totient(9) == 6 assert euler_totient(12) == 4 ``` **Edge Cases to consider**: * Smallest possible values of `n` (e.g., n=1, n=2) * Prime numbers as input * Powers of prime (e.g., n=27) * Large composite numbers **Question Goals**: * Test understanding and implementation of number theoretic functions. * Ensure proper handling of edge cases and efficiency constraints. * Evaluate student\'s ability to break down and solve problems related to algorithms and data structures.","solution":"def euler_totient(n: int) -> int: Compute the Euler\'s Totient function for an integer n. Euler\'s Totient function, ϕ(n), is the number of integers between 1 and n (inclusive) which are coprime to n. if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: # If p is a factor of n, then count all multiples of p while n % p == 0: n //= p result -= result // p p += 1 # If n is a prime number greater than sqrt(n), then reduce n directly if n > 1: result -= result // n return result"},{"question":"# Pigeonhole Sort Implementation You are given an array of integers. Implement a function `pigeonhole_sort(arr)` that sorts the array using the Pigeonhole Sort algorithm. Ensure that your implementation includes checks to handle typical edge cases, and consider the constraints provided. Your function should be structured as follows: ```python def pigeonhole_sort(arr): # Your code here ``` # Input Format: - `arr`: A list of integers to be sorted. The list can contain positive and negative integers. # Output Format: - Return a new sorted list of integers. # Constraints: - The size of `arr` will be at most (10^4). - The values in `arr` will be between (-10^4) and (10^4). # Example: ```python assert pigeonhole_sort([8, 3, 2, 7, 4, 6, 8]) == [2, 3, 4, 6, 7, 8, 8] assert pigeonhole_sort([-5, 0, -2, -1, 3, 1, 0]) == [-5, -2, -1, 0, 0, 1, 3] ``` # Performance Requirements: - Ensure that the function runs with appropriate efficiency given the constraints on input size and value range. - Optimize the memory usage wherever possible without affecting the time complexity. Consider the edge cases like: - An array with a single element. - An array that is already sorted. - An array with all elements being the same.","solution":"def pigeonhole_sort(arr): if not arr: return [] min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 holes = [[] for _ in range(size)] for number in arr: holes[number - min_val].append(number) sorted_arr = [num for hole in holes for num in hole] return sorted_arr"},{"question":"Given a text and a pattern, implement the Rabin-Karp algorithm to find the starting index of the first occurrence of the pattern in the text. If the pattern is not found, return None. Both text and pattern consist of lowercase English letters only. Requirements: - Implement the function `rabin_karp_search(pattern: str, text: str) -> int`. - The function should return the starting index of the first occurrence of the pattern in the text. - If the pattern is not found, return `None`. Constraints: - `1 <= len(text) <= 10^5` - `1 <= len(pattern) <= 10^5` - Both `text` and `pattern` consist only of lowercase English letters (\'a\'-\'z\'). Example: ```python assert rabin_karp_search(\\"abc\\", \\"ababcabcabc\\") == 2 assert rabin_karp_search(\\"xyz\\", \\"ababcabcabc\\") == None assert rabin_karp_search(\\"a\\", \\"a\\") == 0 assert rabin_karp_search(\\"\\", \\"ababcabcabc\\") == None assert rabin_karp_search(\\"abc\\", \\"\\") == None ``` Instructions: You are given an initial implementation of a rolling hash as a class and the Rabin-Karp algorithm. Extend it to accomplish the given task. Ensure your code handles edge cases efficiently. ```python class RollingHash: def __init__(self, text, size_word): self.text = text self.hash = 0 self.size_word = size_word for i in range(0, size_word): self.hash += (ord(self.text[i]) - ord(\\"a\\")+1)*(26**(size_word - i -1)) self.window_start = 0 self.window_end = size_word def move_window(self): if self.window_end <= len(self.text) - 1: self.hash -= (ord(self.text[self.window_start]) - ord(\\"a\\")+1)*26**(self.size_word-1) self.hash *= 26 self.hash += ord(self.text[self.window_end])- ord(\\"a\\")+1 self.window_start += 1 self.window_end += 1 def window_text(self): return self.text[self.window_start:self.window_end] def rabin_karp_search(pattern, text): if pattern == \\"\\" or text == \\"\\": return None if len(pattern) > len(text): return None rolling_hash = RollingHash(text, len(pattern)) pattern_hash = RollingHash(pattern, len(pattern)) for i in range(len(text) - len(pattern) + 1): if rolling_hash.hash == pattern_hash.hash: if rolling_hash.window_text() == pattern: return i rolling_hash.move_window() return None ```","solution":"class RollingHash: def __init__(self, text, size_word): self.text = text self.hash = 0 self.size_word = size_word for i in range(0, size_word): self.hash += (ord(self.text[i]) - ord(\\"a\\") + 1) * (26**(size_word - i - 1)) self.window_start = 0 self.window_end = size_word def move_window(self): if self.window_end <= len(self.text) - 1: self.hash -= (ord(self.text[self.window_start]) - ord(\\"a\\") + 1) * 26**(self.size_word - 1) self.hash *= 26 self.hash += ord(self.text[self.window_end]) - ord(\\"a\\") + 1 self.window_start += 1 self.window_end += 1 def window_text(self): return self.text[self.window_start:self.window_end] def rabin_karp_search(pattern, text): if pattern == \\"\\" or text == \\"\\": return None if len(pattern) > len(text): return None rolling_hash = RollingHash(text, len(pattern)) pattern_hash = 0 for i in range(len(pattern)): pattern_hash += (ord(pattern[i]) - ord(\\"a\\") + 1) * (26**(len(pattern) - i - 1)) for i in range(len(text) - len(pattern) + 1): if rolling_hash.hash == pattern_hash: if rolling_hash.window_text() == pattern: return i rolling_hash.move_window() return None"},{"question":"Finding the Nth Digit in Infinite Sequence Problem Statement: Given a positive integer `n`, find the nth digit of the sequence formed by concatenating all positive integers: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, ... For example: * If `n` = 3, the 3rd digit in the sequence is `3`. * If `n` = 11, the 11th digit in the sequence is `0` (from the number 10). Input: * An integer `n` (1 ≤ n ≤ 2 * 10^9). Output: * An integer representing the nth digit in the infinite sequence. Constraints: * The solution should have the time complexity of O(log n). * You are not allowed to generate the entire sequence. Function Signature: ```python def find_nth_digit(n: int) -> int: pass ``` Example: ```python assert find_nth_digit(3) == 3 assert find_nth_digit(11) == 0 assert find_nth_digit(15) == 2 ``` Notes: * Consider potential edge cases, such as the transitions between digit lengths (e.g., from single-digit to double-digit numbers). * Handle large values of `n` efficiently.","solution":"def find_nth_digit(n: int) -> int: Find the nth digit in the infinite sequence of concatenated positive integers. length = 1 # The digit length of the numbers we\'re currently considering count = 9 # The number of integers that have the current digit length start = 1 # The first number that has the current digit length while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the exact number where the nth digit is located start += (n - 1) // length # Find the exact digit in the number digit_str = str(start) digit_index = (n - 1) % length return int(digit_str[digit_index])"},{"question":"# Question: Implement a Hybrid Quick Sort Your task is to implement a Hybrid Quick Sort algorithm that uses the standard quick sort algorithm but switches to insertion sort when the size of the subarray is below a certain threshold. This hybrid approach helps to optimize the sorting of smaller subarrays, leveraging the strengths of both sorting algorithms. # Input - An integer `n` representing the number of elements in the array (1 ≤ n ≤ 10^5). - An array of `n` integers, where each integer is in the range [-10^6, 10^6]. # Output - A single list of sorted integers in non-decreasing order. # Constraints - Implement the hybrid method by switching to insertion sort for subarrays of size ≤ 10 for better performance. - Your solution should aim for a time complexity close to O(n log n) on average. - Minimize the auxiliary space usage, aiming for O(log n) due to recursion stack. # Performance Requirements - The function should complete in a reasonable time for large arrays up to 100,000 elements. # Function Signature ```python def hybrid_quick_sort(arr: List[int]) -> List[int]: pass ``` # Example ```python # Example 1 input: n = 6 arr = [3, 6, 2, 8, 7, 1] output: [1, 2, 3, 6, 7, 8] # Example 2 input: n = 4 arr = [4, 3, 1, 2] output: [1, 2, 3, 4] ``` You are provided with the following components to assist in your implementation: - A `quick_sort` function similar to the one in the provided code snippet. - An `insertion_sort` function to be implemented for the base case of small subarrays. # Additional Notes - Be mindful of the edge cases such as already sorted arrays, arrays with all identical elements, and arrays with a single element. - Test your implementation through a variety of test cases including largest possible input sizes for performance validation.","solution":"from typing import List def insertion_sort(arr: List[int], left: int, right: int) -> None: for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def partition(arr: List[int], low: int, high: int) -> int: pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def hybrid_quick_sort(arr: List[int], low: int, high: int) -> None: THRESHOLD = 10 if low < high: if high - low + 1 <= THRESHOLD: insertion_sort(arr, low, high) else: pivot_index = partition(arr, low, high) hybrid_quick_sort(arr, low, pivot_index - 1) hybrid_quick_sort(arr, pivot_index + 1, high) def sort_array(arr: List[int]) -> List[int]: if not arr: return [] hybrid_quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"You are climbing a staircase. It takes `steps` number of steps to reach the top. Each time you can either climb 1 or 2 steps. The goal is to determine how many distinct ways can you climb to the top. # Function Signature ```python def count_ways_to_climb(steps: int) -> int: ``` # Input * An integer `steps` (1 ≤ steps ≤ 10^5), represents the number of steps to the top. # Output * Return an integer representing the number of distinct ways to climb to the top. # Constraints * You can either take 1 step or 2 steps at a time. # Example ```python assert count_ways_to_climb(2) == 2 # Output Explanation: Two ways (1 + 1 and 2) assert count_ways_to_climb(3) == 3 # Output Explanation: Three ways (1 + 1 + 1, 1 + 2, and 2 + 1) assert count_ways_to_climb(4) == 5 # Output Explanation: Five ways (1 + 1 + 1 + 1, 1 + 1 + 2, 1 + 2 + 1, 2 + 1 +1, 2 + 2) ``` # Detailed Instructions Using dynamic programming: 1. Define the base cases where `steps` is 0 or 1. 2. Use an iterative approach to fill the values based on the relation of counting the number of ways to climb to a pair of previously calculated steps. 3. Optimize the space usage by maintaining only the last two computed counts. # Additional Notes Consider focusing on optimizing both the time and space complexity. Handle edge cases and validate input appropriately.","solution":"def count_ways_to_climb(steps: int) -> int: Returns the number of distinct ways to climb to the top of a staircase with \'steps\' steps, where each time you can either climb 1 or 2 steps. if steps == 0: return 0 if steps == 1: return 1 # Initialize base cases prev1, prev2 = 1, 1 # prev1: f(1), prev2: f(0) for i in range(2, steps + 1): current = prev1 + prev2 # current: f(i) = f(i-1) + f(i-2) # Update the previous two values prev2 = prev1 prev1 = current return prev1"},{"question":"**Context**: Stooge Sort is a fascinatingly inefficient sorting algorithm that sorts elements by recursively dividing and sorting segments of the array. Your task is to modify Stooge Sort to handle arrays with floating-point numbers and an additional list of allowed indices. Only the elements at the specified indices should be sorted according to the Stooge Sort algorithm. **Problem Statement**: Implement a function `custom_stoogesort(arr, indices)` that takes a list `arr` of floating-point numbers and a list of `indices` specifying which elements to sort using Stooge Sort. The array should be modified in place, sorting only the specified indices. **Function Signature**: ```python def custom_stoogesort(arr: List[float], indices: List[int]) -> None: # Implement your function here ``` **Input**: - `arr` (List[float]): A list of floating-point numbers of size n, where 0 < n ≤ 10^3. - `indices` (List[int]): A list of integers representing positions in `arr` that should be sorted. All indices will be valid and unique. **Output**: - The function returns nothing. Modify `arr` in place sorting only the elements at positions specified in `indices`. **Constraints**: - The function should handle arrays with up to 1000 floating-point numbers. **Example**: ```python arr = [3.1, 1.4, 4.1, 5.9, 2.6, 5.3] indices = [1, 2, 4] custom_stoogesort(arr, indices) print(arr) # Output: [3.1, 1.4, 2.6, 5.9, 4.1, 5.3] ``` **Explanation**: Initially, the elements at indices 1, 2, and 4 are [1.4, 4.1, 2.6]. After sorting them using Stooge Sort, the elements at these positions should be [1.4, 2.6, 4.1], while the rest of the array remains unchanged. **Tips**: - Focus on modifying the Stooge Sort to work specifically on segments of the array defined by the `indices`. - Make sure to handle edge cases like empty `indices` list or single element to be sorted.","solution":"from typing import List def custom_stoogesort(arr: List[float], indices: List[int]) -> None: Sorts only the elements at the specified indices using Stooge Sort. Modifies the array in place. def stoogesort(arr, l, h): if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t) # Extracting the subarray that needs to be sorted subarray = [arr[i] for i in indices] # Applying stoogesort on the extracted subarray stoogesort(subarray, 0, len(subarray) - 1) # Putting the sorted subarray back into the original array at correct positions for i, index in enumerate(indices): arr[index] = subarray[i]"},{"question":"You are tasked with analyzing and improving an existing algorithm to determine if a given string `s` can be constructed by interleaving two strings `part1` and `part2` while maintaining the original order from both parts. You need to implement a function that improves the current recursive and iterative solutions to handle larger input sizes more efficiently. # Function Signature ```python def is_merge(s: str, part1: str, part2: str) -> bool: pass ``` # Inputs - `s`: A string of length n (0 <= n <= 1000). - `part1`: A string (0 <= length of part1 <= n). - `part2`: A string (0 <= length of part2 <= n). # Outputs - Returns `True` if `s` can be formed by interleaving `part1` and `part2`, otherwise `False`. # Constraints - The characters in `part1` and `part2` must be in the same order as in `s`. - The length of the strings may be large, hence the solution should be optimized for performance. # Example ```python print(is_merge(\'codewars\', \'cdw\', \'oears\')) # True print(is_merge(\'abc\', \'a\', \'bc\')) # True print(is_merge(\'abcdef\', \'abc\', \'def\')) # True print(is_merge(\'aabcc\', \'abc\', \'abc\')) # False print(is_merge(\'\', \'\', \'\')) # True ``` # Guidelines 1. The current implementation is inefficient due to its exponential time complexity. Implement a solution that optimizes this. 2. Consider using dynamic programming to store intermediate results and avoid redundant calculations. 3. Ensure your solution can handle edge cases efficiently.","solution":"def is_merge(s: str, part1: str, part2: str) -> bool: Determines if string `s` can be formed by interleaving `part1` and `part2` while maintaining the order of characters from both parts. Parameters: s (str): The target string. part1 (str): First part string. part2 (str): Second part string. Returns: bool: True if `s` can be formed by interleaving `part1` and `part2`, otherwise False. m, n = len(part1), len(part2) # If lengths don\'t match, return False early if len(s) != m + n: return False # DP table to store results of subproblems dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True # Fill the DP table for i in range(m + 1): for j in range(n + 1): if i > 0: dp[i][j] |= dp[i - 1][j] and part1[i - 1] == s[i + j - 1] if j > 0: dp[i][j] |= dp[i][j - 1] and part2[j - 1] == s[i + j - 1] return dp[m][n]"},{"question":"# Pathfinding in Graphs **Objective**: Write a function that finds the longest path between two nodes in an unweighted directed acyclic graph (DAG). # Problem Statement: Given an unweighted directed acyclic graph (DAG) represented by an adjacency list, two given nodes `start` and `end`, and you need to implement a function `find_longest_path(graph, start, end)` that returns the longest path from `start` to `end`. If no such path exists, return `None`. # Input Format: * `graph`: A dictionary where the keys are nodes and the values are lists of adjacent nodes. * `start`: A node representing the starting point. * `end`: A node representing the end point. # Output Format: * A list representing the longest path from `start` to `end`. If no such path exists, return `None`. # Constraints: * All nodes are integers or strings. * The graph is a directed acyclic graph (DAG). * There is at most one edge between any pair of nodes. * Node values can be 0 or any positive or negative integers or even strings. # Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [\'G\'], \'E\': [\'G\'], \'F\': [\'G\'], \'G\': [] } start = \'A\' end = \'G\' find_longest_path(graph, start, end) # Should return [\'A\', \'B\', \'D\', \'G\'] ``` # Edge Cases: 1. The `start` or `end` node is not in the graph. 2. No path exists from `start` to `end`. 3. Graph with one node. 4. Multiple paths with the same longest length. # Notes: - Ensure the implementation expunges cycles even if the input is ensured to be a DAG. - The solution should handle medium-sized graphs efficiently within reasonable constraints.","solution":"def find_longest_path(graph, start, end): Finds the longest path in a directed acyclic graph (DAG) from `start` to `end`. If no path exists, returns None. def topological_sort(graph): visited = set() stack = [] def dfs(node): if node in visited: return visited.add(node) for neighbor in graph.get(node, []): dfs(neighbor) stack.append(node) for node in graph: if node not in visited: dfs(node) return stack[::-1] def relax(u, v, dist, parent): if dist[v] < dist[u] + 1: dist[v] = dist[u] + 1 parent[v] = u # Topological sort of the graph topo_order = topological_sort(graph) if start not in topo_order or end not in topo_order: return None # Initialize distances and parent pointers dist = {node: float(\'-inf\') for node in graph} parent = {node: None for node in graph} dist[start] = 0 # Relax edges according to topological order for u in topo_order: for v in graph.get(u, []): relax(u, v, dist, parent) # Check if there\'s a valid path if dist[end] == float(\'-inf\'): return None # Reconstruct the longest path path = [] current = end while current is not None: path.append(current) current = parent[current] return path[::-1]"},{"question":"# Question: Implement an Optimized Moving Average Calculator You are required to implement an optimized version of the `MovingAverage` class that avoids recalculating the complete sum of the window each time a new element is added. This should significantly improve the efficiency, especially for larger window sizes. **Requirements**: 1. Create a class `OptimizedMovingAverage` with: - An initializer accepting the window size. - A method `next(val: int) -> float` that adds a new integer to the window and returns the updated moving average. 2. Optimize the algorithm to have an amortized time complexity of (O(1)). # Input/Output Format: - `__init__(size: int)`: Initialize the object with a specific window size. - `next(val: int) -> float`: Add `val` to the current window and return the moving average of the integers in the window. # Constraints: - The window size will be a positive integer not exceeding (10^4). - The input values (`val`) will be integers in the range ([-10^4, 10^4]). # Example: ```python if __name__ == \'__main__\': m = OptimizedMovingAverage(3) assert m.next(1) == 1.0 assert m.next(10) == 5.5 assert m.next(3) == 4.666666666666667 assert m.next(5) == 6.0 ``` Make sure to handle potential edge cases, such as when fewer elements than the window size are present.","solution":"from collections import deque class OptimizedMovingAverage: def __init__(self, size: int): Initialize the data structure with the specified window size. self.size = size self.queue = deque() self.current_sum = 0 def next(self, val: int) -> float: Add a new value to the window and return the updated moving average. if len(self.queue) == self.size: self.current_sum -= self.queue.popleft() self.queue.append(val) self.current_sum += val return self.current_sum / len(self.queue)"},{"question":"Scenario: You are tasked with securing a simple message by using a historical cipher technique. The Atbash cipher is a substitution cipher where each letter in the alphabet is mapped to its reverse. Specifically, \'a\' becomes \'z\', \'b\' becomes \'y\', and so on. This transformation is case-sensitive, meaning \'A\' is mapped to \'Z\' and \'a\' to \'z\'. Characters that are not letters (e.g., spaces, punctuation) should remain unchanged. Task: Write a function `atbash_cipher(text: str) -> str` that takes a string `text` as input and returns the encoded string using the Atbash cipher. Input: - `text` (1 <= len(text) <= 1000): A string containing any printable ASCII characters. Output: - A string with the same length as the input, where each alphabetic character is replaced by its Atbash cipher equivalent. Examples: ```python assert atbash_cipher(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash_cipher(\\"Hello, World!\\") == \\"Svool, Dliow!\\" assert atbash_cipher(\\"\\") == \\"\\" assert atbash_cipher(\\"12345\\") == \\"12345\\" ``` Constraints: 1. The function should maintain the case of the characters. 2. Non-alphabet characters should remain unchanged. 3. Ensure the function runs efficiently with a linear time complexity, O(n), relative to the length of the input string.","solution":"def atbash_cipher(text: str) -> str: Encodes the input text using the Atbash cipher, where each letter in the alphabet is mapped to its reverse (e.g. \'a\' becomes \'z\', \'b\' becomes \'y\', etc.). The function is case-sensitive and non-alphabet characters remain unchanged. result = [] for char in text: if char.isalpha(): if char.islower(): result.append(chr(219 - ord(char))) else: result.append(chr(155 - ord(char))) else: result.append(char) return \'\'.join(result)"},{"question":"# Matrix Transformation Challenge Background Matrix transformations are fundamental operations in many fields like computer graphics, game programming, data representation, and more. This task will test your ability to manipulate matrices through a series of transformations efficiently and correctly. Task Write a function `transform_matrix(matrix, transformation)` that performs various transformations on a given matrix based on the specified operation. The `transformation` parameter will be one of the following strings: - `\\"rotate_clockwise\\"`: Rotate the matrix 90 degrees clockwise. - `\\"rotate_counterclockwise\\"`: Rotate the matrix 90 degrees counterclockwise. - `\\"top_left_invert\\"`: Transpose the matrix (top-left to bottom-right diagonal). - `\\"bottom_left_invert\\"`: Reverse the matrix followed by a transpose (bottom-left to top-right diagonal). Function Signature: ```python def transform_matrix(matrix: List[List[int]], transformation: str) -> List[List[int]]: pass ``` Input: - `matrix`: A 2D list of integers representing the matrix. It is guaranteed that `matrix` will be well-formed (i.e., rectangular). - `transformation`: A string specifying the type of transformation to perform. Output: - Return the transformed matrix as a new 2D list of integers. Constraints: - Matrix dimensions will not exceed 1000x1000. - The matrix will contain integer values only. - The transformation string will be one of the specified valid transformations. Examples: ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] print(transform_matrix(matrix1, \\"rotate_clockwise\\")) # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3], # ] print(transform_matrix(matrix1, \\"rotate_counterclockwise\\")) # Output: [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7], # ] print(transform_matrix(matrix1, \\"top_left_invert\\")) # Output: [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9], # ] print(transform_matrix(matrix1, \\"bottom_left_invert\\")) # Output: [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1], # ] ``` Notes: * Be attentive to edge cases such as single row/column matrices. * Optimize your solution to handle large matrices efficiently.","solution":"from typing import List def transform_matrix(matrix: List[List[int]], transformation: str) -> List[List[int]]: if transformation == \\"rotate_clockwise\\": return [list(row) for row in zip(*matrix[::-1])] elif transformation == \\"rotate_counterclockwise\\": return [list(row) for row in zip(*matrix)][::-1] elif transformation == \\"top_left_invert\\": return [list(row) for row in zip(*matrix)] elif transformation == \\"bottom_left_invert\\": return [list(row) for row in zip(*matrix[::-1])][::-1] else: raise ValueError(\\"Invalid transformation type\\")"},{"question":"# Selection Sort with Trace **Scenario**: You\'re a software developer at a small startup. The team regularly needs to quickly sort small datasets and observe the sorting process for debugging and educational purposes. The current implementation of the selection sort algorithm works fine but lacks a detailed trace of its execution steps. **Task**: Implement the selection sort algorithm that sorts an array in ascending order. Modify the function to print detailed internal state information at each iteration, like the sample code provided previously. This can help in understanding the algorithm\'s progression step-by-step. **Constraints**: - The input array will contain at most 1000 integers. - Integers in the array will range between -10^6 and 10^6. **Function Signature**: ```python def selection_sort_with_trace(arr: List[int]) -> List[int]: pass ``` **Input**: - `arr`: A list of integers to be sorted. **Output**: - Return the sorted list. - Print the state of the array at the beginning and after each iteration of selection sort as shown in the example. **Example**: ```python # Input arr = [64, 25, 12, 22, 11] # Output & Prints iteration 0 : 64 25 12 22 11 iteration 1 : 11 25 12 22 64 iteration 2 : 11 12 25 22 64 iteration 3 : 11 12 22 25 64 iteration 4 : 11 12 22 25 64 # Returns [11, 12, 22, 25, 64] ``` **Performance Requirements**: - Your algorithm should run within O(n^2) time complexity. - Ensure the function handles all edge cases efficiently.","solution":"def selection_sort_with_trace(arr): n = len(arr) print(f\\"iteration 0 : {\' \'.join(map(str, arr))}\\") for i in range(n): min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] print(f\\"iteration {i + 1} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"Context You\'re tasked with working on a software module that handles different numeral systems. You\'ll need to implement functions that can convert integers to different bases and vice versa. Task Implement two functions: `int_to_base` and `base_to_int`. 1. **int_to_base(num, base)** * **Input**: - `num` (int): A base 10 integer. May be positive or negative. - `base` (int): The base to which the number should be converted. Value is between 2 and 36. * **Output**: Returns a string representing the number in the specified base. * **Constraints**: - If `num` is 0, return \\"0\\". - If `num` is negative, the first character of the result should be \'-\'. - The resulting representation should use the characters 0-9 for values 0 to 9, and A-Z for values 10 to 35. 2. **base_to_int(str_to_convert, base)** * **Input**: - `str_to_convert` (str): A string representing a number in the specified base. - `base` (int): The base in which the number string is given. Value is between 2 and 36. * **Output**: Returns an integer representing the number in base 10. * **Constraints**: - The input string will only contain valid characters for the base. - The input string will not contain any fractional parts. - The input string may contain leading zeroes which should be ignored in the conversion. Example ```python print(int_to_base(5, 2)) # Output: \'101\' print(int_to_base(-255, 16)) # Output: \'-FF\' print(base_to_int(\'101\', 2)) # Output: 5 print(base_to_int(\'FF\', 16)) # Output: 255 ``` **Note**: Consider both performance and edge cases (like leading zeroes, empty input, negative numbers) in your solution.","solution":"def int_to_base(num, base): Convert an integer to a string in the given base. if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" is_negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if is_negative: result.append(\'-\') return \'\'.join(reversed(result)) def base_to_int(str_to_convert, base): Convert a string in a given base to an integer. str_to_convert = str_to_convert.lstrip(\'0\') or \'0\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" if str_to_convert[0] == \'-\': is_negative = True str_to_convert = str_to_convert[1:] else: is_negative = False result = 0 for char in str_to_convert: result = result * base + digits.index(char) return -result if is_negative else result"},{"question":"Problem Statement You are given two positive integers, `x` and `y`. Your task is to implement a function that calculates the **Hamming Distance** between the two integers. The Hamming Distance between two integers is defined as the number of positions at which the corresponding bits are different when the numbers are represented in binary format. Function Signature ```python def hamming_distance(x: int, y: int) -> int: pass ``` Input * `x` and `y` (1 <= x, y <= 10^9): Two positive integers. Output * An integer representing the Hamming Distance between `x` and `y`. Example ```python assert hamming_distance(1, 4) == 2 assert hamming_distance(3, 1) == 1 ``` Explanation 1. For `hamming_distance(1, 4)`: - Binary of 1: `0001` - Binary of 4: `0100` - They differ at two positions (bit index 2 and 0). 2. For `hamming_distance(3, 1)`: - Binary of 3: `0011` - Binary of 1: `0001` - They differ at one position (bit index 1). Constraints - The function should have a time complexity of O(log(min(x,y))) and a space complexity of O(1). Additional Information - You may use bitwise operators to achieve an efficient solution. Objective Write a program that computes the Hamming Distance by using efficient bitwise operations. Ensure to handle large inputs within the given constraints.","solution":"def hamming_distance(x: int, y: int) -> int: Calculate the Hamming distance between two positive integers. Args: x (int): First positive integer. y (int): Second positive integer. Returns: int: Hamming distance between x and y. xor_result = x ^ y distance = 0 while xor_result: distance += xor_result & 1 xor_result >>= 1 return distance"},{"question":"You are given an array of integers representing the frequency of certain events. Your task is to create a data structure that efficiently supports the following operations: 1. **Update** the frequency of an event at a specific index. 2. **Query** the cumulative frequency of events up to a specific index. To implement this, you are to use the Fenwick Tree (Binary Indexed Tree) data structure. # Instructions: 1. **Class Definition**: Create a class `FenwickTree` with the following methods: - `__init__(self, arr: List[int])`: Initializes the Fenwick Tree with the given frequency array. - `update(self, index: int, value: int)`: Updates the frequency at the specified index by adding the given value. - `query(self, index: int) -> int`: Returns the cumulative frequency up to the given index. 2. **Method Details**: - `update(self, index: int, value: int)`: Updates the array `arr[index]` with the given value and propagates this change through the Fenwick Tree. - `query(self, index: int) -> int`: Calculates the cumulative sum from the start of the array to the provided index. 3. **Constraints**: - The input array will have at most (10^5) elements. - The value for update can be negative, representing a decrement in frequency. - Index for both update and query operations starts from 0 and is up to (n-1) where (n) is the size of the input array. # Example: ```python # Initialize the Fenwick Tree with an array of frequencies events = [1, 2, 3, 4, 5] ft = FenwickTree(events) # Update the frequency of the event at index 2 by adding 5 ft.update(2, 5) # Query the cumulative frequency up to index 4 print(ft.query(4)) # Output should reflect the update, i.e., 1+2+(3+5)+4+5 = 20 ``` # Additional Note: Ensure that your solution has a clear understanding of handling both 0-based and 1-based indexing, and manage the Fenwick Tree operations correctly.","solution":"class FenwickTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (self.n + 1) for idx, val in enumerate(arr): self.add(idx, val) def add(self, index, value): index += 1 # Convert to 1-based index while index <= self.n: self.tree[index] += value index += index & -index def update(self, index, value): self.add(index, value) def query(self, index): index += 1 # Convert to 1-based index result = 0 while index > 0: result += self.tree[index] index -= index & -index return result"},{"question":"# Question: Count Digit Occurrences **Problem Statement**: You are given a list of integers, both positive and negative. Your task is to write a function `digit_occurrence_count` that computes the total count of each digit (0-9) across all numbers in the list. For instance, the numbers `123` and `321` should contribute three `1`’s, two `2`’s, and two `3`’s to the final count. **Function Signature**: ```python def digit_occurrence_count(numbers: List[int]) -> Dict[int, int]: ``` **Input**: * A list of integers, `numbers` where `1 <= len(numbers) <= 1000`. **Output**: * A dictionary where keys are digits (0-9) and values represent their respective occurrence counts across all numbers. **Constraints**: * The numbers can be positive, negative, or zero. * Consider only the absolute value of the numbers for counting digits. **Example**: ```python numbers = [123, -456, 100, 321, 0] # The output should be: # { # 0: 2, # 1: 3, # 2: 2, # 3: 2, # 4: 1, # 5: 1, # 6: 1, # 7: 0, # 8: 0, # 9: 0 # } ``` **Explanation**: * The digit `0` appears twice (once in `100` and once in `0`). * The digit `1` appears three times (once in `123`, once in `100`, and once in `321`), etc. **Performance Requirements**: * Your solution should be efficient in terms of time and space complexity, considering the constraints on input sizes provided. **Additional Notes**: * Make sure to handle edge cases such as the list containing zero, large numbers, and negative numbers. * Make use of existing mathematical concepts to keep the implementation simple yet efficient.","solution":"from typing import List, Dict def digit_occurrence_count(numbers: List[int]) -> Dict[int, int]: Computes the total count of each digit (0-9) across all numbers in the given list. Negative numbers are considered by their absolute value. Args: numbers (List[int]): A list of integers (positive, negative, or zero). Returns: Dict[int, int]: A dictionary where keys are digits (0-9) and values are their counts. count = {i: 0 for i in range(10)} for number in numbers: for char in str(abs(number)): count[int(char)] += 1 return count"},{"question":"# Question: Sparse Matrix Multiplication You are given two sparse matrices `A` and `B`. Your task is to implement a function to multiply these matrices and return the result. Sparse matrices are matrices that are mainly composed of zero values, with only a few non-zero elements. # Function Signature ```python def multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: pass ``` # Input - `A` : List of List of integers where: - `A[i][j]` is an integer representing the element in the ith row and jth column of matrix A. - `B` : List of List of integers where: - `B[i][j]` is an integer representing the element in the ith row and jth column of matrix B. # Output - A List of List of integers that represents the result of the matrix multiplication `AB`. # Constraints - The number of columns in `A` will be equal to the number of rows in `B`. - Both matrices `A` and `B` will be at least of size 1x1. - The elements of `A` and `B` will be in the range [-100, 100]. # Examples ```python A = [ [ 1, 0, 0], [-1, 0, 3] ] B = [ [ 7, 0, 0], [ 0, 0, 0], [ 0, 0, 1] ] assert multiply(A, B) == [ [ 7, 0, 0], [-7, 0, 3] ] ``` # Explanation In the example: - The matrix `A` has dimensions 2x3. - The matrix `B` has dimensions 3x3. - The result `AB` will have dimensions 2x3, computed using only the non-zero values from `A` and `B`. # Notes - Consider optimizing the solution by taking advantage of the sparse nature of the matrices. - Handle edge cases like empty or very sparse matrices. - Raise appropriate errors if input matrices `A` and `B` have incompatible dimensions.","solution":"from typing import List def multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: if not A or not B: raise ValueError(\\"Input matrices should not be empty\\") rows_A, cols_A = len(A), len(A[0]) rows_B, cols_B = len(B), len(B[0]) if cols_A != rows_B: raise ValueError(\\"Number of columns in A must be equal to number of rows in B\\") # Initialize the result matrix with zeros result = [[0] * cols_B for _ in range(rows_A)] # Efficiently compute the product of sparse matrices for i in range(rows_A): for k in range(cols_A): if A[i][k] != 0: for j in range(cols_B): if B[k][j] != 0: result[i][j] += A[i][k] * B[k][j] return result"},{"question":"You are provided with an undirected graph where each node contains a label and a list of its neighbors. Your task is to write a function that clones the graph using the Breadth-First Search (BFS) algorithm. The function should ensure that each node and its neighbors are correctly cloned. # Function Signature ```python def clone_graph_bfs(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': ``` # Input - `node`: An instance of `UndirectedGraphNode` representing the starting node of the graph. If the graph is empty, `node` will be `None`. # Output - Returns a new graph which is a clone of the original graph starting from the given node. # Constraints - The graph can contain self-loops. - All node labels are unique. - The number of nodes in the graph will not exceed 1000. # Example Consider the serialized graph `{0,1,2#1,2#2,2}`: ``` 1 / / 0 ---- 2 / _/ ``` Calling `clone_graph_bfs` with the node labeled 0 should result in a cloned graph with the same structure. # Notes - Ensure that you are not simply returning the same graph structure, but instead creating a new, cloned copy based on BFS traversal. - Your function should handle all edge cases mentioned, such as single nodes, graphs with self-loops, and multiple components. # Implementation Provide your implementation below: ```python def clone_graph_bfs(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': # Your implementation here pass ```","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_graph_bfs(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if not node: return None old_to_new = {} queue = [node] old_to_new[node] = UndirectedGraphNode(node.label) while queue: current = queue.pop(0) for neighbor in current.neighbors: if neighbor not in old_to_new: old_to_new[neighbor] = UndirectedGraphNode(neighbor.label) queue.append(neighbor) old_to_new[current].neighbors.append(old_to_new[neighbor]) return old_to_new[node]"},{"question":"Scenario/Context You\'ve joined a team working on a low-level system, and one of the tasks is to optimize data compression algorithms. A common task is swapping odd and even bits of integers efficiently. You need to write a function to achieve this within the constraints of minimal operations. Task Write a function `swap_pair` that takes an integer `num` and returns a new integer where all the odd bits are swapped with even bits. Input Format * An integer `num` where `0 <= num <= 2^32 - 1`. Output Format * An integer representing the new value after odd and even bits have been swapped. Constraints * You must use bitwise operations to achieve this, with minimal instructions. * Ensure the solution executes in constant time, i.e., O(1) complexity. * Consider typical 32-bit integer values. Do not account for bit shifts beyond 32 bits. Example ```python # Example 1 num = 22 # binary: 010110 # After swapping: 101001 (binary), which is 41 in decimal swap_pair(22) # Output: 41 # Example 2 num = 10 # binary: 1010 # After swapping: 0101 (binary), which is 5 in decimal swap_pair(10) # Output: 5 ``` Implement the function `swap_pair` as described. Use hexadecimal constants to simplify your bit masking.","solution":"def swap_pair(num): Swaps all the odd bits with even bits in a given integer `num`. # 0xAAAAAAAA is a mask for all even bits in a 32-bit integer # 0x55555555 is a mask for all odd bits in a 32-bit integer even_bits = num & 0xAAAAAAAA odd_bits = num & 0x55555555 even_bits >>= 1 odd_bits <<= 1 return even_bits | odd_bits"},{"question":"# Graph Traversal Challenge Scenario You are tasked with implementing two core graph traversal methods to assist in a network analysis project. Your job is to implement functions that traverse the nodes of a graph using Depth First Search (DFS) and Breadth First Search (BFS) starting from a given node. Task Implement the following two functions: 1. `dfs_traverse(graph: dict, start: int) -> set` - Traverses the graph using Depth First Search (DFS) starting from the \'start\' node. It should return a set of visited nodes. 2. `bfs_traverse(graph: dict, start: int) -> set` - Traverses the graph using Breadth First Search (BFS) starting from the \'start\' node. It should return a set of visited nodes. Input - `graph`: A dictionary representation of the graph where the keys are node identifiers and the values are lists of neighboring nodes. - `start`: The starting node for the traversal. Output - A set of nodes visited during the traversal. Example Input: ```python graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } start = 2 ``` Output: - For `dfs_traverse(graph, start)`, it might return `{2, 0, 1, 3}` - For `bfs_traverse(graph, start)`, it might return `{2, 0, 3, 1}` Constraints - Assume the graph is directed and can contain cycles. - Node identifiers are non-negative integers. - The graph may be disconnected but the starting node will always be part of the graph. Notes - Ensure your DFS implementation avoids infinite recursion in cyclic graphs by properly marking visited nodes. - Ensure your BFS implementation similarly avoids revisiting nodes.","solution":"def dfs_traverse(graph, start): Traverses the graph using Depth First Search (DFS) starting from the \'start\' node. Returns a set of visited nodes. visited = set() def dfs(node): if node not in visited: visited.add(node) for neighbor in graph.get(node, []): dfs(neighbor) dfs(start) return visited def bfs_traverse(graph, start): Traverses the graph using Breadth First Search (BFS) starting from the \'start\' node. Returns a set of visited nodes. visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) queue.extend([neighbor for neighbor in graph.get(node, []) if neighbor not in visited]) return visited"},{"question":"You are working on a linear algebra library focusing on matrix operations. One of the tasks is to implement the Cholesky decomposition of a Hermitian positive-definite matrix. **Function Signature:** ```python def cholesky_decomposition(A: List[List[float]]) -> Optional[List[List[float]]]: pass ``` **Input:** - `A` (List[List[float]]): a Hermitian positive-definite matrix of dimensions ( n times n ) **Output:** - A lower triangular matrix ( V ) (List[List[float]]) such that ( V times V^T = A ). - Return `None` if the matrix ( A ) does not meet the required conditions. **Constraints:** - Ensure the matrix ( A ) is square (i.e., the number of rows equals the number of columns). - Handle matrices of size up to ( 100 times 100 ). **Requirements:** - The solution\'s time complexity should be ( O(n^3) ). - Ensure the implementation validates that ( A ) is Hermitian and positive-definite. **Examples:** 1. **Example 1:** ``` python A = [ [4.0, 12.0, -16.0], [12.0, 37.0, -43.0], [-16.0, -43.0, 98.0], ] cholesky_decomposition(A) -> [ [2.0, 0.0, 0.0], [6.0, 1.0, 0.0], [-8.0, 5.0, 3.0] ] ``` 2. **Example 2:** ``` python A = [ [1.0, 0.0], [0.0, -1.0], ] cholesky_decomposition(A) -> None ``` **Edge Cases to Consider:** - Non-positive definite matrix. - Non-square matrix. - Negative or zero diagonal elements affecting the decomposition. - Handling float precision during calculations. Good luck, and ensure your code is clean, efficient, and well-documented!","solution":"from typing import List, Optional import math def cholesky_decomposition(A: List[List[float]]) -> Optional[List[List[float]]]: Perform Cholesky decomposition of a Hermitian positive-definite matrix A. Returns a lower triangular matrix V such that V * V^T = A. Returns None if A is not Hermitian positive-definite. n = len(A) # Check if the matrix is square if any(len(row) != n for row in A): return None # Create an n x n zero matrix for the lower triangular result V = [[0.0] * n for _ in range(n)] for i in range(n): for j in range(i + 1): sum = A[i][j] for k in range(j): sum -= V[i][k] * V[j][k] if i == j: if sum <= 0: return None # Not positive-definite V[i][j] = math.sqrt(sum) else: V[i][j] = sum / V[j][j] return V"},{"question":"Problem Statement You are required to design a system that can handle arithmetic operations involving the greatest common divisor (GCD) and least common multiple (LCM). Additionally, you must devise a utility to count the trailing zeros in a binary representation of a number. This assessment covers different implementations of these calculations, emphasizing your understanding of number theory and bit manipulation. Objective Implement the following functions: 1. **Function: gcd(a: int, b: int) -> int** * Computes the greatest common divisor of two integers using Euclid\'s algorithm. * **Input**: Two integers `a` and `b` where ( a, b neq 0 ) and ( a, b > 0 ). * **Output**: The greatest common divisor of `a` and `b`. 2. **Function: gcd_bit(a: int, b: int) -> int** * Computes the greatest common divisor using bitwise operations. * **Input**: Two non-negative integers `a` and `b`. * **Output**: The greatest common divisor of `a` and `b`. 3. **Function: lcm(a: int, b: int) -> int** * Computes the lowest common multiple of two integers using the GCD function. * **Input**: Two integers `a` and `b` where ( a, b neq 0 ) and ( a, b > 0 ). * **Output**: The lowest common multiple of `a` and `b`. 4. **Function: trailing_zero(x: int) -> int** * Computes the number of trailing zeros in the binary representation of an integer. * **Input**: A positive integer `x`. * **Output**: The count of trailing zeros in the binary representation of `x`. Constraints * The integers provided as input will be in the range of (1 leq a, b leq 10^9). * The input for `trailing_zero` will be a positive integer ( x > 0 ). Example ```python >>> gcd(48, 18) 6 >>> gcd_bit(48, 18) 6 >>> lcm(48, 18) 144 >>> trailing_zero(40) 3 ``` Notes * Do not use any built-in libraries or math functions to directly compute the GCD, LCM. * Ensure memory efficiency and graceful handling of inputs. * Consider edge cases and test your functions thoroughly.","solution":"def gcd(a: int, b: int) -> int: Computes the greatest common divisor of two integers using Euclid\'s algorithm. while b: a, b = b, a % b return a def gcd_bit(a: int, b: int) -> int: Computes the greatest common divisor of two non-negative integers using bitwise operations. if a == 0: return b if b == 0: return a shift = 0 while ((a | b) & 1) == 0: shift += 1 a >>= 1 b >>= 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b = b - a return a << shift def lcm(a: int, b: int) -> int: Computes the lowest common multiple of two integers using the GCD function. return a * b // gcd(a, b) def trailing_zero(x: int) -> int: Computes the number of trailing zeros in the binary representation of an integer. count = 0 while (x & 1) == 0: x >>= 1 count += 1 return count"},{"question":"# Question: Post-order Traversal of a Binary Tree You are required to implement an algorithm to perform a post-order traversal on a binary tree. **Objective**: - Write a function that takes the root of a binary tree and returns a list containing the post-order traversal of its nodes\' values. - Implement both iterative and recursive approaches. **Function Signature**: ```python def postorder_iterative(root: Optional[Node]) -> List[int]: # Your code here def postorder_recursive(root: Optional[Node], res: Optional[List[int]] = None) -> List[int]: # Your code here ``` # Constraints: - The number of nodes in the tree can be up to 10,000. - The tree can have duplicate values. - You may assume the input tree is a binary tree (each node has at most two children). # Input: - `root`: The root node of the binary tree. Can be `None` if the tree is empty. - For the recursive function, an additional argument `res` which is used to store the traversal result. This argument should have a default value of `None`. # Output: - A list of integers representing the values of the nodes in post-order traversal. # Examples: ```python # Example 1 # Input: [1, None, 2, 3] (where 1 is the root, 2 is the right child of 1, 3 is the left child of 2) # Tree structure: # 1 # # 2 # / # 3 # Output: [3, 2, 1] # Example 2 # Input: [1, 2, 3, 4, 5] (where 1 is the root, 2 and 3 are left and right of 1, 4 and 5 are left and right of 2) # Tree structure: # 1 # / # 2 3 # / # 4 5 # Output: [4, 5, 2, 3, 1] ``` # Requirements: - Account for edge cases like empty trees and single-node trees. - Validate if your iterative approach and recursive approach give the same result. Make sure to write clean, efficient, and well-documented code.","solution":"from typing import List, Optional class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorder_iterative(root: Optional[Node]) -> List[int]: if root is None: return [] result = [] stack = [] last_visited_node = None current = root while stack or current: if current: stack.append(current) current = current.left else: peek_node = stack[-1] if peek_node.right and last_visited_node != peek_node.right: current = peek_node.right else: stack.pop() result.append(peek_node.val) last_visited_node = peek_node return result def postorder_recursive(root: Optional[Node], res: Optional[List[int]] = None) -> List[int]: if res is None: res = [] if root is None: return res postorder_recursive(root.left, res) postorder_recursive(root.right, res) res.append(root.val) return res"},{"question":"# Longest Common Subsequence with Optimizations You have been tasked with improving the algorithm for finding the Longest Common Subsequence (L.C.S.) between two strings. Your goal is to implement a memory-efficient variant of the current algorithm provided in the code snippet. Objective Write a function `optimized_longest_common_subsequence(s_1, s_2)` that computes the length of the longest common subsequence between `s_1` and `s_2` using a space-optimized approach. Requirements * Optimize the space complexity of the provided algorithm while maintaining its time complexity. * Input: Two strings `s_1` and `s_2` containing lowercase English alphabets. * Output: An integer representing the length of the L.C.S. of the given strings. Constraints * 1 ≤ len(s_1), len(s_2) ≤ 1000 # Example ```python Input: \'abcdgh\' \'aedfhr\' Output: 3 Explanation: The longest subsequence common to both the strings is \'adh\' ``` Notes 1. The primary goal is to reduce the space complexity of the algorithm while correctly maintaining L.C.S. computation. 2. Discuss any trade-offs or edge cases that need to be considered. 3. Ensure your code handles the maximum input sizes efficiently.","solution":"def optimized_longest_common_subsequence(s_1, s_2): Returns the length of the longest common subsequence between s_1 and s_2 using a space-optimized approach. m, n = len(s_1), len(s_2) # We only need two rows to store previous and current results previous = [0] * (n + 1) current = [0] * (n + 1) for i in range(1, m + 1): for j in range(1, n + 1): if s_1[i - 1] == s_2[j - 1]: current[j] = previous[j - 1] + 1 else: current[j] = max(previous[j], current[j - 1]) previous, current = current, previous # swap rows return previous[n]"},{"question":"**Title**: Stooge Sort Implementation and Optimization **Objective**: Implement Stooge Sort and then write an optimized version using a more efficient sorting algorithm. Context Stooge Sort is a theoretical and inefficient sorting algorithm known for its impracticality. Nevertheless, understanding it can be instructive in learning about recursive sorting methods. Once you have implemented Stooge Sort, your task is to recognize its inefficiency and replace it with a more practical sorting algorithm of your choice (e.g., QuickSort, MergeSort). Task 1. Implement the Stooge Sort based on the provided specifications. 2. Write a separate, optimized version using a more efficient sorting algorithm. 3. Ensure both implementations sort the array in ascending order. Function Signatures ```python def stoogesort(arr: list, l: int, h: int) -> None: Perform Stooge Sort on the array from index l to index h. Parameters: arr (list): The list to be sorted. l (int): The starting index of the range to be sorted. h (int): The ending index of the range to be sorted. pass def optimized_sort(arr: list) -> None: Perform an optimized sorting on the array. Parameters: arr (list): The list to be sorted. pass ``` Input - Two functions to implement: 1. `stoogesort(arr: list, l: int, h: int) -> None` - to sort the sublist `arr[l...h]` using Stooge Sort. 2. `optimized_sort(arr: list) -> None` - to sort the entire list `arr` using a more efficient sorting algorithm. - The list `arr` can have up to 1000 elements, each being an integer between -10^5 and 10^5. Output - No direct output is expected. The function(s) should modify the input list `in-place`. Constraints 1. The array can be of any length from 0 to 1000. 2. You must handle edge cases like empty arrays and arrays with one element. 3. Ensure no additional data structures are used for sorting and that sorting is done in-place. Example ```python arr1 = [3, 2, 1] stoogesort(arr1, 0, len(arr1) - 1) print(arr1) # Output should be: [1, 2, 3] arr2 = [4, 6, 2, 3, 1, 9, 7] optimized_sort(arr2) print(arr2) # Output should be: [1, 2, 3, 4, 6, 7, 9] ``` The first function will demonstrate your implementation of the Stooge Sort algorithm, while the second will provide and validate your understanding of practical, efficient sorting techniques.","solution":"def stoogesort(arr, l, h): Perform Stooge Sort on the array from index l to index h. Parameters: arr (list): The list to be sorted. l (int): The starting index of the range to be sorted. h (int): The ending index of the range to be sorted. if l >= h: return # If first element is smaller than last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # Recursively sorting the three parts if h-l+1 > 2: t = (h-l+1) // 3 stoogesort(arr, l, h-t) stoogesort(arr, l+t, h) stoogesort(arr, l, h-t) def optimized_sort(arr): Perform an optimized sorting on the array. Parameters: arr (list): The list to be sorted. arr.sort()"},{"question":"You are tasked with writing a function that takes a digit string and returns all possible letter combinations that the number could represent, based on typical telephone buttons\' letter mappings. Each digit (from \'2\' to \'9\') maps to a specific set of letters. # Function Signature ```python def letter_combinations(digits: str) -> List[str]: ``` # Input - `digits`: A string of digits (0-9) representing the input. (1 ≤ length of digits ≤ 10) - Example: \\"23\\" # Output - A list of strings, where each string is a possible letter combination represented by the input digits. - Example: [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] # Constraints - Input will contain only digits between \'2\' to \'9\'. - The output should be a list of strings containing all possible letter combinations. # Performance Requirement - The solution should efficiently handle the combinations without excessive resource usage, bearing the exponential nature in mind. # Example ```python assert letter_combinations(\\"23\\") == [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] assert letter_combinations(\\"\\") == [] assert letter_combinations(\\"2\\") == [\\"a\\", \\"b\\", \\"c\\"] ``` # Edge Cases to Consider 1. Empty input should return an empty list. 2. Single digit input should return all possible characters. 3. Validate that inputs containing digits \'0\' and \'1\' are not provided (handling inputs strictly defined by constraints). # Notes - You may assume that the mapping to letters follows traditional phone keypads, i.e.,: ``` 2: \\"abc\\", 3: \\"def\\", 4: \\"ghi\\", 5: \\"jkl\\", 6: \\"mno\\", 7: \\"pqrs\\", 8: \\"tuv\\", 9: \\"wxyz\\" ```","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: if not digits: return [] # Mapping of digits to letters phone_map = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index: int, path: str): # If the path is the same length as digits, we\'ve found a valid combination if index == len(digits): combinations.append(path) return # Get the letters that the current digit maps to, and loop through them possible_letters = phone_map[digits[index]] for letter in possible_letters: backtrack(index + 1, path + letter) combinations = [] backtrack(0, \\"\\") return combinations"},{"question":"Context You are tasked with writing a program to detect cyclic dependencies in a software build system. The build system can be represented as a directed graph where each node represents a software component and an edge from node A to node B signifies that component A depends on component B being built first. Your objective is to determine if there are any circular dependencies in the build system. Task Write a function `detect_cycle(graph: Dict[str, List[str]]) -> bool` that takes in a directed graph `graph` represented by a dictionary and returns `True` if there is a cycle in the graph, and `False` otherwise. Input * `graph`: A dictionary where each key is a node represented by a string and its value is a list of strings representing the nodes it points to (i.e., its dependencies). Output * Returns `True` if the graph contains a cycle, otherwise `False`. Constraints * Nodes are represented as unique strings. * The graph does not contain any self-loops (an edge from a node to itself). * The graph may have zero or more vertices and edges. Examples 1. `graph = {\'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': []}` * Output: `True` (Cycle exists: E -> B -> D -> E) 2. `graph = {\'A\': [\'B\'], \'B\': [\'C\'], \'C\': []}` * Output: `False` 3. `graph = {\'A\': [\'B\'], \'B\': [], \'C\': [\'D\'], \'D\': []}` * Output: `False` Function Signature ```python from typing import List, Dict def detect_cycle(graph: Dict[str, List[str]]) -> bool: pass ``` Notes * Consider the provided core steps of the Depth-First Search algorithm and the state tracking mechanism to develop your function. * Carefully handle disconnected components in the graph.","solution":"from typing import List, Dict def detect_cycle(graph: Dict[str, List[str]]) -> bool: \'\'\' This function determines if there is a cycle in the given directed graph. Parameters: graph (Dict[str, List[str]]): A directed graph represented as a dictionary. Returns: bool: True if there is a cycle, False otherwise. \'\'\' def dfs(node, visited, stack): A helper function that uses Depth-First Search to detect a cycle in the graph. visited[node] = True stack[node] = True for neighbor in graph.get(node, []): if not visited[neighbor]: if dfs(neighbor, visited, stack): return True elif stack[neighbor]: return True stack[node] = False return False visited = {key: False for key in graph} stack = {key: False for key in graph} for node in graph: if not visited[node]: if dfs(node, visited, stack): return True return False"},{"question":"You are given an integer where you can flip exactly one bit from 0 to 1. Write a Python function to find the length of the longest sequence of 1s you can create by flipping one bit in the binary representation of the integer. Function Signature ```python def flip_bit_longest_seq(num: int) -> int: pass ``` Input - An integer `num`. Output - An integer representing the length of the longest sequence of 1s possible by flipping one bit. Constraints - You can assume that `num` is a non-negative integer. Example - **Input**: `1775` - **Output**: `8` Scenario Imagine you have a set of servers identified by unique integer IDs where the binary representation of the ID can signal some status (0 for inactive and 1 for active). Due to a constraint in the protocol, you can flip exactly one bit from 0 to 1 to maximize a sequence of active times. Your task is to find out the maximum contiguous active time sequences by flipping just one bit. Write a function `flip_bit_longest_seq(num: int) -> int` to solve the problem.","solution":"def flip_bit_longest_seq(num: int) -> int: if ~num == 0: return len(bin(num)) - 2 current_length = 0 previous_length = 0 max_length = 1 # we can always have at least one 1 by flipping one bit while num != 0: if num & 1 == 1: # Current bit is 1 current_length += 1 else: # Current bit is 0 # Update to 0 if next bit is 0, else current_length previous_length = 0 if (num & 2) == 0 else current_length current_length = 0 max_length = max(previous_length + current_length + 1, max_length) num >>= 1 return max_length"},{"question":"# ZigZag Iterator for M lists We have discussed a ZigZag iterator for two lists. Now, let\'s extend the concept to handle multiple lists. **Problem Statement**: Implement a ZigZag Iterator that can traverse \'k\' number of lists in a zigzag manner. Your iterator should: 1. Initialize with multiple lists. 2. Provide a method `next()` that returns the next element in the zigzag sequence. 3. Provide a method `has_next()` that returns `True` if there are remaining elements to traverse, otherwise `False`. # Input and Output Formats - Your `__init__(self, lists: List[List[int]])` should initialize the iterator. - Your `next(self) -> int` should return the next element in the sequence. - Your `has_next(self) -> bool` should return whether there are more elements to iterate. # Constraints - 1 <= k <= 1000 - 0 <= number of elements in any list <= 1000 - The elements in the lists can be any integer within the range -10^6 to 10^6. # Example ```python it = ZigZagIterator([[1, 3, 5], [2, 4, 6, 8], [7, 9]]) result = [] while it.has_next(): result.append(it.next()) # The result should be [1, 2, 7, 3, 4, 9, 5, 6, 8] print(result) ``` # Implementation Challenge Keep in mind handling empty lists effectively without causing unnecessary performance overhead. Think about minimizing space and time complexity.","solution":"from collections import deque from typing import List class ZigZagIterator: def __init__(self, lists: List[List[int]]): self.queues = deque() for lst in lists: if lst: self.queues.append(deque(lst)) def next(self) -> int: if self.has_next(): current_queue = self.queues.popleft() # Get the first list in the queue next_elem = current_queue.popleft() # Get the first element from that list if current_queue: self.queues.append(current_queue) # If there are more elements, put it back at the end return next_elem else: raise Exception(\\"No more elements to iterate.\\") def has_next(self) -> bool: return bool(self.queues)"},{"question":"**Missing Number Finder** You are given an unsorted list of unique integers in the range [0, n]. Each integer appears exactly once, and the difference between consecutive integers in the original sequence cannot be more than 1. One integer from the sequence is missing. Your task is to implement a function that finds the missing integer. If no number is missing, return the next integer in the sequence. **Function Signature**: ```python def find_missing_number(nums: List[int]) -> int: ``` **Input**: - `nums` (List[int]): Unsorted list of unique integers in the range [0, n]. **Output**: - `int`: The missing integer from the sequence, or the next integer if no integer is missing. **Constraints**: - The size of the list (`len(nums)`) will be at most 10^6. - All integers in `nums` are unique and within the range [0, n]. - The difference between consecutive integers in the sequence is no more than 1. **Examples**: ```python assert find_missing_number([3, 0, 1]) == 2 assert find_missing_number([0, 1, 2, 4]) == 3 assert find_missing_number([4, 2, 1, 0, 5]) == 3 assert find_missing_number([]) == 0 ``` **Scenario**: Consider a scenario where you\'re processing sensor data sequences. The data is recorded as a series of integers in chronological order, but sometimes a data point might be missed. You need to identify the missing data point from the readings.","solution":"def find_missing_number(nums): Returns the missing number in the sequence or the next integer if no number is missing. if not nums: return 0 n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) missing_number = expected_sum - actual_sum return missing_number"},{"question":"# Filtering Array Based on Range **Context:** You are working on a data processing application that frequently needs to filter datasets to include only values within certain ranges. To streamline this process, you want to create a robust and efficient function. **Objective:** Write a function `limit` that filters an array of numerical values. The function should include only the elements that fall within a specified minimum and maximum range, inclusive. **Function Signature:** ```python def limit(arr: list, min_lim: int = None, max_lim: int = None) -> list: ``` **Input:** - `arr`: a list of integers, not sorted, may contain duplicates and/or negative values. - `min_lim`: an integer or `None`. If `None`, the function should use the minimum value in `arr`. - `max_lim`: an integer or `None`. If `None`, the function should use the maximum value in `arr`. **Output:** - Returns a list of integers containing all the elements from `arr` that are greater than or equal to `min_lim` and less than or equal to `max_lim`. **Constraints:** - The function should handle arrays of up to 10^5 elements. - Both `min_lim` and `max_lim` can be `None`. - If `arr` is empty, the function should return an empty list. - Elements in the resulting array should appear in the same order as they do in `arr`. **Example Cases:** **Example Case 1:** ```python assert limit([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] ``` **Example Case 2:** ```python assert limit([1, 2, 3, 4, 5], 2, None) == [2, 3, 4, 5] ``` **Example Case 3:** ```python assert limit([10, 20, 30, 40, 50], 15, 35) == [20, 30] ``` **Example Case 4:** ```python assert limit([], 5, 15) == [] ``` **Additional Requirements:** - Handle edge cases such as all elements lower/higher than the limits. - Optimize for speed and efficiency within the limits of the given constraints.","solution":"def limit(arr, min_lim=None, max_lim=None): Filters the array to include only values within the specified range [min_lim, max_lim]. :param arr: List of integers, not necessarily sorted. :param min_lim: Minimum limit (inclusive). Defaults to the minimum value in arr if None. :param max_lim: Maximum limit (inclusive). Defaults to the maximum value in arr if None. :return: A list containing values within the specified range. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"You are tasked with implementing a function to compute the least common multiple (LCM) and greatest common divisor (GCD) of two integers using both traditional and bitwise methods. This task will test your understanding of the Euclidean algorithm, bitwise operations, and handling edge cases. # Function Specifications **Function 1**: `compute_gcd(a: int, b: int) -> int` * **Input**: - Two integers, `a` and `b`, where `a, b` are in the range `[-10^9, 10^9]` but not both zero at the same time. * **Output**: - An integer representing the GCD of `a` and `b`. * **Constraints**: - If either `a` or `b` is zero, raise a `ValueError` indicating invalid input. - Handle both positive and negative integers. **Function 2**: `compute_gcd_bitwise(a: int, b: int) -> int` * **Input**: - Two non-negative integers, `a` and `b`, where `a, b` are in the range `[0, 10^9]`. * **Output**: - An integer representing the GCD of `a` and `b` using bitwise operations. * **Constraints**: - If either `a` or `b` is zero, raise a `ValueError` indicating invalid input. **Function 3**: `compute_lcm(a: int, b: int) -> int` * **Input**: - Two integers, `a` and `b`, where `a, b` are in the range `[-10^9, 10^9]` but not both zero at the same time. * **Output**: - An integer representing the LCM of `a` and `b`. * **Constraints**: - Compute the LCM based on the GCD calculated from `compute_gcd(a, b)` function. # Example Example 1 ```python compute_gcd(15, 20) ``` **Expected Output**: ```python 5 ``` Example 2 ```python compute_gcd_bitwise(15, 20) ``` **Expected Output**: ```python 5 ``` Example 3 ```python compute_lcm(15, 20) ``` **Expected Output**: ```python 60 ``` # Additional Requirements * Ensure your implementation handles invalid input cases by throwing appropriate exceptions. * Your solution should be efficient in terms of both time and space complexity.","solution":"def compute_gcd(a: int, b: int) -> int: Returns the greatest common divisor (GCD) of a and b using the traditional Euclidean method. if a == 0 or b == 0: raise ValueError(\\"Input values cannot be zero\\") a, b = abs(a), abs(b) while b: a, b = b, a % b return a def compute_gcd_bitwise(a: int, b: int) -> int: Returns the greatest common divisor (GCD) of a and b using bitwise operations. if a == 0 or b == 0: raise ValueError(\\"Input values cannot be zero\\") if a == b: return a if a < b: a, b = b, a while b != 0: if a % 2 == 0 and b % 2 == 0: a, b = a >> 1, b >> 1 elif a % 2 == 0: a = a >> 1 elif b % 2 == 0: b = b >> 1 elif a > b: a = (a - b) >> 1 else: b = (b - a) >> 1 return a def compute_lcm(a: int, b: int) -> int: Returns the least common multiple (LCM) of a and b. if a == 0 or b == 0: raise ValueError(\\"Input values cannot be zero\\") gcd = compute_gcd(a, b) return abs(a * b) // gcd"},{"question":"# Remove Duplicates from an Array **Objective**: Write a function `remove_duplicates(array)` that removes duplicate values from an input array and returns a new array with only the unique values. The order of the first occurrences of each unique element should be maintained. **Input**: * An array `array` containing `n` elements of potentially different data types (integers, floats, strings, booleans). **Output**: * A new array containing only the unique elements from `array`, in the same order as their first occurrence. **Constraints**: 1. `0 <= n <= 10^5` 2. Elements can be of any hashable data type. **Performance Requirements**: - The solution must run in O(n) time complexity. **Function Signature**: ```python def remove_duplicates(array): # Your code here pass ``` **Example**: ```python # Example 1: Input: [1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True] Output: [1, 2, 3, 4, \'hey\', \'hello\', True] # Example 2: Input: [] Output: [] # Example 3: Input: [\'a\', \'b\', \'a\', \'c\', \'b\', \'a\'] Output: [\'a\', \'b\', \'c\'] ``` **Additional Information**: - To achieve the performance requirement, consider using a set to track the elements that have already been seen. - Remember to handle edge cases such as empty inputs and arrays with only repeated elements correctly. - Ensure your solution maintains the order of the first occurrence of each element.","solution":"def remove_duplicates(array): seen = set() unique_array = [] for item in array: if item not in seen: unique_array.append(item) seen.add(item) return unique_array"},{"question":"# Segment Tree for Range Sum Queries You are required to implement a `SegmentTree` class that supports efficient range sum queries. Specifically, this segment tree will handle several operation types: 1. **Initialization**: Given an array of integers, initialize the `SegmentTree` to allow efficient querying. 2. **Query**: Return the sum of elements within a specified inclusive range [L, R]. # Implementation Details **Class Structure**: Your class should be named `SegmentTree` and should support the following methods: - `__init__(self, arr)`: Constructor to initialize the segment tree with an array of integers. - `query(self, L, R)`: Method to return the sum of elements in the range [L, R]. **Example**: ```python # Initialization with an array arr = [1, 3, 5, 7, 9, 11] tree = SegmentTree(arr) # Queries assert tree.query(1, 3) == 15 # 3 + 5 + 7 assert tree.query(0, 5) == 36 # 1 + 3 + 5 + 7 + 9 + 11 assert tree.query(2, 2) == 5 # Single element query ``` # Constraints: 1. The input array will have at most (10^5) elements. 2. Each element in the array is an integer within the range [-10^4, 10^4]. 3. Assume the range for queries will always be valid. # Additional Notes: - Ensure the segment tree is initialized efficiently. - Minimize unnecessary computational overhead for range queries. - Handle edge cases such as range consisting of a single element or querying the entire range. # Your Task: Complete the implementation of the `SegmentTree` class and ensure that it passes the provided example along with other test cases that will be used to validate the correctness. Good luck!","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr): # Initialize the leaves in the segment tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def query(self, L, R): # Initialize the result res = 0 L += self.n R += self.n + 1 while L < R: if L % 2 == 1: res += self.tree[L] L += 1 if R % 2 == 1: R -= 1 res += self.tree[R] L //= 2 R //= 2 return res"},{"question":"# Question: Tree Structure and Equality Validation Background: You are working on a version control system for binary trees, where you need to ensure that two trees at different stages are identical in terms of structure and node values. This validation helps in maintaining consistency across different versions of tree structures used in the system. Task: Implement the function `is_same_tree(tree_p, tree_q)` that determines if two given binary trees, `tree_p` and `tree_q`, are identical. Two binary trees are considered identical if: - They have the same structure. - Corresponding nodes have the same values. Function Signature: ```python def is_same_tree(tree_p: TreeNode, tree_q: TreeNode) -> bool: # your code here ``` Input: - `tree_p` and `tree_q`: Root nodes of the two binary trees. (0 <= number of nodes <= 10^4) Each `TreeNode` has the following attributes: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output: - Returns `True` if the trees are identical, `False` otherwise. Constraints: - You may assume that each node\'s values are integers and not null. Example: ```python # Example 1: tree_p = TreeNode(1) tree_p.left = TreeNode(2) tree_p.right = TreeNode(3) tree_q = TreeNode(1) tree_q.left = TreeNode(2) tree_q.right = TreeNode(3) assert is_same_tree(tree_p, tree_q) == True # Example 2: tree_p = TreeNode(1) tree_p.left = TreeNode(2) tree_q = TreeNode(1) tree_q.right = TreeNode(2) assert is_same_tree(tree_p, tree_q) == False ``` Note: - Be sure to handle all edge cases, such as when one or both trees are empty. - Aim to write a solution that is efficient in terms of both time and space complexity.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(tree_p: TreeNode, tree_q: TreeNode) -> bool: # If both are None, they are identical if not tree_p and not tree_q: return True # If one is None and the other is not, they are not identical if not tree_p or not tree_q: return False # If the values of the current nodes are different, they are not identical if tree_p.val != tree_q.val: return False # Recursively check left subtree and right subtree return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)"},{"question":"You are given a sorted array of integers in ascending order and a list of queries. Your task is to implement a function that returns the positions of each query value within the sorted array using binary search. If the query value does not exist in the array, return -1 for that query. Function Signature ```python def multi_query_binary_search(array: List[int], queries: List[int]) -> List[int]: pass ``` # Input * `array`: A list of sorted integers in ascending order. (1 ≤ len(array) ≤ 10^6) * `queries`: A list of integers to search in the array. (1 ≤ len(queries) ≤ 10^6) # Output * A list of integers where each element corresponds to the index of the query in the `queries` list within the `array`. If a query is not found, return -1 for that query. # Constraints * You must use binary search for this problem. * Your solution should be optimized for time complexity. # Examples Example 1 ```python array = [1, 2, 3, 4, 5] queries = [3, 5, 6] multi_query_binary_search(array, queries) # Output: [2, 4, -1] ``` Example 2 ```python array = [10, 20, 30, 40] queries = [25, 40] multi_query_binary_search(array, queries) # Output: [-1, 3] ``` # Additional Information - Ensure to handle edge cases such as when the array is empty, when all elements of the query are not in the array, and when there are duplicates in the array.","solution":"from typing import List def multi_query_binary_search(array: List[int], queries: List[int]) -> List[int]: def binary_search(arr, target): left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1 return [binary_search(array, query) for query in queries]"},{"question":"You are given a set of distinct integers `nums`. Your task is to write a function `generate_subsets(nums)` that returns all possible subsets of the given set. The solution set must not contain duplicate subsets, and the order within subsets does not matter. Input Format - A list of distinct integers `nums` of length `n (0 <= n <= 10)`. Output Format - A list of lists, where each list is a subset of the input list. Constraints - Elements in the list are distinct. - Do not include duplicate subsets in the solution. Example **Input:** ```python nums = [1, 2, 3] ``` **Output:** ```python [[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]] ``` Scenario Imagine you are working on a project to analyze different combinations of features in a product. For each new feature set, you need to evaluate all possible combinations to verify compatibility and performance. Use this function to generate all possible combinations from a given set of features. # Function Signature ```python def generate_subsets(nums: List[int]) -> List[List[int]]: pass ``` # Performance Requirements Ensure the function operates within O(2^n) time complexity and handles up to n=10 efficiently.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: Returns all possible subsets of the given list of distinct integers. Parameters: nums (List[int]): A list of distinct integers. Returns: List[List[int]]: A list containing all possible subsets. def backtrack(first=0, curr=[]): # if the current combination is done if len(curr) == k: output.append(curr[:]) return for i in range(first, n): # add nums[i] into the current combination curr.append(nums[i]) # use next integers to complete the combination backtrack(i + 1, curr) # backtrack curr.pop() output = [] n = len(nums) for k in range(n + 1): backtrack() return output"},{"question":"# Scenario: You are a developer tasked with creating a utility in a software that needs to find the next closest permutation of a given numeric input. This functionality is crucial for dynamically generating new test cases with incremental changes from a base case. # Task: Write a function `next_bigger(num: int) -> int` that takes in a non-negative integer `num` and returns the next higher number that can be formed using the exact same set of digits in `num`. If no such number exists, the function should return -1. # Implementation Details: 1. The input is a non-negative integer. 2. The function should return an integer output. 3. If no larger permutation exists, return -1. 4. You must handle edge cases effectively. # Example: ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(54321) == -1 assert next_bigger(999) == -1 assert next_bigger(1528452) == 1528524 ``` # Constraints: * The input number will be in the range: (0 leq text{num} leq 10^{18}). * Perform the function efficiently, keeping in mind the potential size of input.","solution":"def next_bigger(num): Returns the next higher number that can be formed using the exact same set of digits in `num`. If no such number exists, returns -1. num_list = list(str(num)) n = len(num_list) # Find the first digit that is smaller than the digit next to it, starting from the end i = n - 2 while i >= 0 and num_list[i] >= num_list[i + 1]: i -= 1 # If such a digit is found if i >= 0: # Find the smallest digit on the right side of num_list[i] which is greater than num_list[i] j = n - 1 while num_list[j] <= num_list[i]: j -= 1 # Swap the two found digits num_list[i], num_list[j] = num_list[j], num_list[i] # Reverse the digits after the position i num_list = num_list[:i + 1] + num_list[i + 1:][::-1] # Join the list back to a number and return it return int(\'\'.join(num_list)) else: # If no such digit is found, return -1 return -1"},{"question":"# Caesar Cipher Decryption In a Caesar Cipher, each letter in the plaintext is shifted a certain number of places down the alphabet. To decrypt a message encoded with a Caesar Cipher, you need to shift each letter in the ciphertext back the same number of places up the alphabet. Write a function `caesar_decipher` to decrypt a given ciphertext string. Function Signature ```python def caesar_decipher(s: str, k: int) -> str: ``` Input * `s`: a string, the ciphertext (1 ≤ |s| ≤ 10^5), composed of uppercase, lowercase English letters, and non-alphabet characters. * `k`: an integer, the number of positions each letter in the ciphertext was shifted to the right (0 ≤ k ≤ 10^5). Output * Return a string which represents the decrypted plaintext. Constraints * Assume that shifting by `k` is always valid and properly encrypted. Performance Requirements * Your function should have a time complexity of O(n), where n is the length of the input string. * The space complexity should also be O(n). Example ```python assert caesar_decipher(\\"def\\", 3) == \\"abc\\" assert caesar_decipher(\\"abc xyz\\", 3) == \\"xyz uvw\\" assert caesar_decipher(\\"Khoor Zruog!\\", 3) == \\"Hello World!\\" ``` Edge Cases 1. The input string `s` can include numbers, spaces, and special characters which should remain unchanged. 2. Large values of `k` should be appropriately handled by taking `k % 26`.","solution":"def caesar_decipher(s: str, k: int) -> str: Decrypts a given ciphertext encoded with a Caesar Cipher with a given shift \'k\'. # Reduce k in modulo 26 to handle large shifts k = k % 26 decrypted_message = [] for char in s: if char.isalpha(): if char.islower(): # Shift within lowercase letters shifted = ord(char) - k if shifted < ord(\'a\'): shifted += 26 decrypted_message.append(chr(shifted)) elif char.isupper(): # Shift within uppercase letters shifted = ord(char) - k if shifted < ord(\'A\'): shifted += 26 decrypted_message.append(chr(shifted)) else: # Non-alphabet characters remain unchanged decrypted_message.append(char) return \'\'.join(decrypted_message)"},{"question":"You have a list of integer values, some of which may represent sensor readings. Your task is to write a function `limit_within_bounds` that filters this list to include only the values within a specific range [min_limit, max_limit]. # Function Signature ```python def limit_within_bounds(arr: list[int], min_limit: int = None, max_limit: int = None) -> list[int]: ``` # Input - `arr`: A list of integers, representing the sensor readings. (length: 0 ≤ len(arr) ≤ 10^6, each element -10^6 ≤ arr[i] ≤ 10^6) - `min_limit`: An integer that specifies the inclusive lower bound of the range. If `None`, there should be no lower bound. - `max_limit`: An integer that specifies the inclusive upper bound of the range. If `None`, there should be no upper bound. # Output - A new list of integers containing only the values from `arr` that are within the specified range [min_limit, max_limit]. # Constraints - If both `min_limit` and `max_limit` are `None`, return the original list. - The input list may be empty, and in such a case, the function should also return an empty list. # Performance Requirements - The algorithm should have an average-case time complexity of O(n), where n is the length of the input list. - Space complexity should be O(n) in the worst case. # Examples ```python assert limit_within_bounds([1, 5, 3, 2, 8, 6], 3, 6) == [5, 3, 6] assert limit_within_bounds([10, 20, 30, 40, 50], None, 30) == [10, 20, 30] assert limit_within_bounds([100, 200, 300], 150, None) == [200, 300] assert limit_within_bounds([], None, None) == [] assert limit_within_bounds([1, 2, 3], 2, 2) == [2] assert limit_within_bounds([-5, 0, 5], None, -1) == [-5] ``` # Note - Take care of edge cases like an empty list, or all elements being outside the specified range. - Ensure the function is efficient and handles large inputs within acceptable time limits.","solution":"def limit_within_bounds(arr: list[int], min_limit: int = None, max_limit: int = None) -> list[int]: Returns a list of integers from arr that are within the specified range [min_limit, max_limit]. # If both limits are None, return the original list if min_limit is None and max_limit is None: return arr # Create a new list to store the filtered results filtered_list = [] # Iterate through each element in the input list for value in arr: # Apply the bounds conditions if (min_limit is None or value >= min_limit) and (max_limit is None or value <= max_limit): filtered_list.append(value) # Return the filtered list return filtered_list"},{"question":"# Scenario and Context Suppose you are tasked with a system where sorting numbers efficiently from a large list is a frequent requirement. Your team has decided to use Radix Sort due to its efficiency in cases where comparisons between numbers are computationally expensive. The integers in the dataset have a bounded digit length. # Problem Statement Write a function to implement Radix Sort that sorts a list of integers in ascending order. You need to handle edge cases and ensure the function is robust against various inputs. # Function Signature ```python def radix_sort(arr: List[int]) -> List[int]: pass ``` # Input - A list of integers, `arr`, where each integer is within the range from 0 to 1,000,000. The list can have up to 100,000 elements. # Output - A sorted list of integers in ascending order. # Constraints - 0 ≤ arr[i] ≤ 1,000,000 for each integer `i` in the input list. - The input list size, 0 ≤ len(arr) ≤ 100,000. # Performance Requirements - The implementation must have an average-case time complexity of O(nk + n), with n as the number of elements and k as the maximum number of digits in the largest number. # Example ```python example_input = [170, 45, 75, 90, 802, 24, 2, 66] sorted_list = radix_sort(example_input) print(sorted_list) # Output: [2, 24, 45, 66, 75, 90, 170, 802] ``` # Notes - You may assume that all input numbers are non-negative integers. - Ensure your implementation is efficient and consider any possible edge cases while testing.","solution":"def counting_sort(arr, exp): A function to help with the counting sort of the digits, based on the exponent. n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(n): arr[i] = output[i] def radix_sort(arr): The main function to sort an array of non-negative integers using Radix Sort. if not arr: return arr max1 = max(arr) exp = 1 while max1 // exp > 0: counting_sort(arr, exp) exp *= 10 return arr"},{"question":"# Description You have been tasked with implementing a mathematical algorithm to facilitate certain operations on square matrices. Specifically, you must implement a function that performs matrix exponentiation using the method of repeated squaring, leveraging matrix multiplication and identity matrix functions as helper routines. # Task Implement the function `matrix_power(matrix: list, power: int) -> list` that calculates the matrix raised to a given power. This function should use the provided matrix multiplication (`multiply`) and identity matrix creation (`identity`) functions. # Input and Output * **Input**: - `matrix`: A list of lists where each inner list represents one row of an n x n square matrix (n can be assumed to be at most 10 for the context of this problem). - `power`: A non-negative integer indicating the power to which the matrix is to be raised. * **Output**: - A list of lists representing the matrix raised to the specified power. # Constraints * The matrix will always be a square matrix with dimensions at most 10 x 10. * The power will be a non-negative integer no greater than 1000. * Elements of the matrix will be integers. # Examples ```python # Example 1 matrix = [ [1, 2], [3, 4] ] power = 2 print(matrix_power(matrix, power)) # Expected output: # [ # [7, 10], # [15, 22] # ] # Example 2 matrix = [ [0, 1], [1, 0] ] power = 3 print(matrix_power(matrix, power)) # Expected output: # [ # [0, 1], # [1, 0] # ] ``` # Notes * You are required to use the `multiply` and `identity` functions provided in the starter code. * Consider edge cases such as when power is 0 or 1. # Starter Code The following starter code is provided: ```python def multiply(matA: list, matB: list) -> list: # Provided implementation (see code above) ... def identity(n: int) -> list: # Provided implementation (see code above) ... def matrix_power(matrix: list, power: int) -> list: # Your implementation here ```","solution":"def multiply(matA, matB): Multiplies two square matrices matA and matB. n = len(matA) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[i][j] = sum(matA[i][k] * matB[k][j] for k in range(n)) return result def identity(n): Returns the identity matrix of size n. return [[1 if i == j else 0 for j in range(n)] for i in range(n)] def matrix_power(matrix, power): Raises the matrix to the given power using repeated squaring. def power_recursive(matrix, power): if power == 0: return identity(len(matrix)) if power == 1: return matrix half_power = power_recursive(matrix, power // 2) half_power_squared = multiply(half_power, half_power) if power % 2 == 0: return half_power_squared else: return multiply(half_power_squared, matrix) return power_recursive(matrix, power)"},{"question":"You are provided with a class to iterate over a binary search tree (BST) in ascending order using an explicit stack. Your task is to implement a similar iterator that supports both forward and backward traversal in O(1) time for each iteration. # Requirements 1. **Class Name**: `BSTBidirectionalIterator` 2. **Initialization**: * `__init__(self, root)` – initialize the iterator with the root of the BST. 3. **Methods**: * `has_next(self) -> bool` – returns `True` if there is a next element in the iteration. * `next(self) -> int` – returns the next element in the iteration. * `has_prev(self) -> bool` – returns `True` if there is a previous element in the iteration. * `prev(self) -> int` – returns the previous element in the iteration. # Input/Output Formats - Each node of the BST is represented by an instance of the `TreeNode` class. - The `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Constraints * You may assume that the BST contains unique values. * The BST will have no more than 10^4 nodes. * The `next()` method should return the values in ascending order while the `prev()` method should return the values in descending order. # Example Given the following BST: ``` 7 / 3 15 / 9 20 ``` Initialization: ```python root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) iterator = BSTBidirectionalIterator(root) ``` Usage: ```python iterator.next() # returns 3 iterator.next() # returns 7 iterator.next() # returns 9 iterator.prev() # returns 7 iterator.prev() # returns 3 iterator.next() # returns 7 iterator.has_next() # returns True iterator.has_prev() # returns True ``` Implement the class `BSTBidirectionalIterator` with the specifications provided above.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BSTBidirectionalIterator: def __init__(self, root): self.stack = [] self._push_left(root) self.reverse_stack = [] self.curr = None self._traverse(root) self.rev_index = len(self.reverse_stack) - 1 def _push_left(self, node): while node: self.stack.append(node) node = node.left def _traverse(self, node): if node: self._traverse(node.left) self.reverse_stack.append(node.val) self._traverse(node.right) def has_next(self) -> bool: return bool(self.stack) def next(self) -> int: node = self.stack.pop() self.curr = node self._push_left(node.right) self.rev_index = self.reverse_stack.index(self.curr.val) return node.val def has_prev(self) -> bool: return self.rev_index > 0 def prev(self) -> int: self.rev_index -= 1 self.curr = self.reverse_stack[self.rev_index] return self.curr"},{"question":"# RSA Key Generation and Encryption/Decryption You are tasked with implementing a simplified version of the RSA encryption algorithm, focusing on key generation and message encryption/decryption. The RSA system relies on generating three key numbers: `n`, `e`, and `d`. You will implement a function to generate these keys and functions to encrypt and decrypt a message. Function Signature ```python def generate_key(k: int, seed: int = None) -> Tuple[int, int, int]: pass def encrypt(data: int, e: int, n: int) -> int: pass def decrypt(data: int, d: int, n: int) -> int: pass ``` Expected Input and Output 1. `generate_key(k: int, seed: int = None) -> Tuple[int, int, int]`: - **Input**: `k` is the number of bits in the modulus `n`. `seed` is an optional integer to seed the random number generator for reproducibility. - **Output**: Returns a tuple `(n, e, d)` where: * `n` is the product of two k/2-bit prime numbers. * `e` is a prime number used for encryption. * `d` is a number that satisfies `(x ** e) ** d) % n == x % n`. 2. `encrypt(data: int, e: int, n: int) -> int`: - **Input**: `data` is the number to be encrypted, `e` is the encryption exponent, and `n` is the modulus. - **Output**: Returns the encrypted number. 3. `decrypt(data: int, d: int, n: int) -> int`: - **Input**: `data` is the encrypted number, `d` is the decryption exponent, and `n` is the modulus. - **Output**: Returns the decrypted number. Constraints * The key size `k` must be at least 16 bits for testing purposes, but in practical applications, it is significantly larger (at least 2048 bits). * Ensure efficient generation of prime numbers and computation of modular inverse. Performance Requirements * Key generation should complete within reasonable time for small bit sizes. Edge Cases to Consider * Avoid infinite loops or excessive delay in prime number generation. * Ensure `data` falls within the valid range for encryption and decryption. Example ```python n, e, d = generate_key(16, seed=42) data = 65 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data, \\"Decrypted data should match the original data\\" ```","solution":"from typing import Tuple, Optional import random import sympy def generate_key(k: int, seed: Optional[int] = None) -> Tuple[int, int, int]: if seed is not None: random.seed(seed) # Ensure k is at least 16 bits if k < 16: raise ValueError(\\"Key size must be at least 16 bits\\") # Generate two distinct k//2 bit prime numbers p and q bit_length = k // 2 p = sympy.randprime(2**(bit_length-1), 2**bit_length) q = sympy.randprime(2**(bit_length-1), 2**bit_length) while p == q: q = sympy.randprime(2**(bit_length-1), 2**bit_length) n = p * q phi = (p - 1) * (q - 1) # Choose e such that 1 < e < phi and gcd(e, phi) == 1 e = 65537 # Commonly used prime number for e if sympy.gcd(e, phi) != 1: e = sympy.nextprime(e) # Compute the modular inverse of e modulo phi to get d d = pow(e, -1, phi) return (n, e, d) def encrypt(data: int, e: int, n: int) -> int: return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: return pow(data, d, n)"},{"question":"# Integer Partitioning Challenge You are given a positive integer, `n`. Your task is to write a function `partition_count(n)` that returns the number of ways to decompose the integer `n` into sums of non-negative integers. Specifically, you should count the distinct ways the integer `n` can be represented as a sum, where the order of addends does not matter. Function Signature ```python def partition_count(n: int) -> int: pass ``` Input: * A single integer `n` such that `1 <= n <= 100`. Output: * An integer representing the number of distinct partitions of `n`. Example: ```python assert partition_count(4) == 5 # Explanation: # The possible partitions are: # 4 = 4 # 4 = 3 + 1 # 4 = 2 + 2 # 4 = 2 + 1 + 1 # 4 = 1 + 1 + 1 + 1 assert partition_count(7) == 15 # Explanation: # The possible partitions are: # 7 = 7 # 7 = 6 + 1 # 7 = 5 + 2 # 7 = 5 + 1 + 1 # 7 = 4 + 3 # 7 = 4 + 2 + 1 # 7 = 4 + 1 + 1 + 1 # 7 = 3 + 3 + 1 # 7 = 3 + 2 + 2 # 7 = 3 + 2 + 1 + 1 # 7 = 3 + 1 + 1 + 1 + 1 # 7 = 2 + 2 + 2 + 1 # 7 = 2 + 2 + 1 + 1 + 1 # 7 = 2 + 1 + 1 + 1 + 1 + 1 # 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` Use the provided information to develop your solution. Ensure your implementation handles edge cases effectively and performs within the given constraints. # Constraints: * 1 <= n <= 100","solution":"def partition_count(n: int) -> int: Returns the number of distinct ways to partition the integer n into sums of non-negative integers. # Create a list to store the number of partitions for each integer up to n partitions = [0] * (n + 1) # There is exactly one way to partition 0, which is using no number at all partitions[0] = 1 # Compute the number of partitions for each number from 1 to n for i in range(1, n + 1): for j in range(i, n + 1): partitions[j] += partitions[j - i] return partitions[n]"},{"question":"# K-th Smallest Element in a Binary Search Tree Given a Binary Search Tree (BST) and an integer `k`, write a function to find the k-th smallest element in the BST. To demonstrate your understanding of different traversal methods, you must implement both an iterative solution and a recursive solution. Input: - A binary search tree `root` where each node has an integer value. - An integer `k` representing the k-th position (1-indexed). Output: - An integer representing the k-th smallest element in the BST. Constraints: - The number of nodes `n` in the BST will be `1 <= n <= 10^4`. - `1 <= k <= n`. Performance Requirements: - Your solution must adhere to O(N) time complexity where N is the number of nodes. - Your space complexity should be considered and reasoned out for both implementations. Example: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): # iterative solution here class Solution(object): def kth_smallest(self, root, k): # recursive solution here # Example usage: if __name__ == \'__main__\': n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 print(kth_smallest(n1, 2)) # Expected output: 50 print(Solution().kth_smallest(n1, 2)) # Expected output: 50 ``` Implement both methods in a clear and efficient manner. Analyze their time and space complexities and comment on potential performance improvements, if any.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest_iterative(root, k): Iteratively finds the k-th smallest element in a BST. stack = [] current = root count = 0 while stack or current: while current: stack.append(current) current = current.left current = stack.pop() count += 1 if count == k: return current.val current = current.right class Solution: def kth_smallest(self, root, k): Recursively finds the k-th smallest element in a BST. def inorder(node): if node: yield from inorder(node.left) yield node.val yield from inorder(node.right) gen = inorder(root) for _ in range(k): res = next(gen) return res"},{"question":"You are given an array of integers `nums` where exactly two elements appear only once and all other elements appear exactly twice. Your task is to write a function `findUniqueNumbers` that returns the two elements that appear only once. # Function Signature: ```python def findUniqueNumbers(nums: List[int]) -> List[int]: :param nums: List[int] - a non-empty list of integers where exactly two elements appear only once and all others appear twice. :return: List[int] - a list containing the two unique integers. ``` # Input: - `nums` - List of integers of length between 2 and 3 * 10^4. - All elements in nums are integers where each integer can be between -3 * 10^4 and 3 * 10^4 (both inclusive). # Output: - Return a list of two integers, the order does not matter, which appear only once in the input array. # Constraints: - Your solution must have linear runtime complexity O(N). - Use only constant extra space O(1). # Examples: ```python assert findUniqueNumbers([1, 2, 1, 3, 2, 5]) == [3, 5] or [5, 3] assert findUniqueNumbers([4, 1, 2, 1, 2, 3, 4, 3, 5, 6]) == [5, 6] or [6, 5] assert findUniqueNumbers([0, 1, 2, 0, 1, 99, 98, 99]) == [2, 98] or [98, 2] ``` # Notes: - If the input is `[1, 1, 2, 2, 3, 4]`, the output should be `[3, 4]` or `[4, 3]`. - Focus on handling edge cases as described above. - Consider how your code minimizes space usage and ensure there are no extraneous operations that could be avoided for better performance.","solution":"from typing import List def findUniqueNumbers(nums: List[int]) -> List[int]: Finds the two unique numbers among the list where all other numbers appear exactly twice. :param nums: List[int] - a non-empty list of integers :return: List[int] - a list containing the two unique integers. xor_result = 0 # First step is to XOR all the elements in the array for num in nums: xor_result ^= num # Find a rightmost set bit in xor_result (it differentiates the two unique numbers) rightmost_set_bit = xor_result & -xor_result num1, num2 = 0, 0 # Divide numbers into two groups and XOR separately for num in nums: if num & rightmost_set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"Efficient Combination Calculation Given non-negative integers n and r (where 0 ≤ r ≤ n), you are to calculate the number of combinations of n items taken r at a time (denoted as nCr). This can be mathematically defined as the number of ways to choose r items from n items without regard to the order of selection. # Function Signature `def nCr(n: int, r: int) -> int:` # Input * `n`: a non-negative integer representing the total number of items. * `r`: a non-negative integer less than or equal to n representing the number of items to choose. # Output * The function should return an integer, the number of ways to choose r items from n items. # Constraints - 0 ≤ r ≤ n ≤ 1000 # Example ```python assert nCr(5, 2) == 10 assert nCr(6, 3) == 20 assert nCr(0, 0) == 1 assert nCr(10, 0) == 1 assert nCr(1000, 0) == 1 assert nCr(1000, 1000) == 1 ``` # Notes - Your implementation should be optimized to handle large values of n and r efficiently utilizing memoization to improve the performance over the naive approach. - You should handle edge cases appropriately such as when r > n or n and r being 0. # Additional Challenge **Optimization**: Can you implement the solution using iterative dynamic programming to further minimize memory usage and avoid deep recursion stack issues?","solution":"def nCr(n: int, r: int) -> int: Calculate the number of combinations (nCr) of n items taken r at a time. Uses iterative dynamic programming to handle large values efficiently. :param n: Non-negative integer representing the total number of items. :param r: Non-negative integer less than or equal to n representing the number of items to choose. :return: The number of ways to choose r items from n items. if r > n: return 0 if r == 0 or r == n: return 1 if r > n - r: # since C(n, r) == C(n, n-r) to minimize the number of multiplications r = n - r res = 1 for i in range(r): res *= (n - i) res //= (i + 1) return res"},{"question":"**Problem: Counting Distinct Paths to Climb a Mountain** You are a mountain climber trying to reach the summit of a mountain. You are currently at the basecamp, situated at an elevation of 0 meters, and you aim to get to the summit which is `height` meters above the basecamp. Each time you can either climb exactly 1 meter or exactly 2 meters. You need to determine the number of distinct ways to reach the summit. Write a function `count_climbing_ways(height)` that calculates the number of ways to climb to the summit. # Input * A single integer `height` (1 ≤ height ≤ 10^5) representing the height of the summit. # Output * Return an integer representing the number of distinct ways to reach the summit. # Constraints - You can only climb either 1 or 2 meters at a time. - The minimum `height` will always be 1. # Example ```python def count_climbing_ways(height): # your code here print(count_climbing_ways(2)) # 2 print(count_climbing_ways(3)) # 3 print(count_climbing_ways(4)) # 5 ``` # Explanation * For `height` = 2, you have the following ways to reach the summit: * 1 meter + 1 meter * 2 meters Thus, there are 2 distinct ways. * For `height` = 3, you have the following ways to reach the summit: * 1 meter + 1 meter + 1 meter * 1 meter + 2 meters * 2 meters + 1 meter Thus, there are 3 distinct ways. * For `height` = 4, you have the following ways to reach the summit: * 1 meter + 1 meter + 1 meter + 1 meter * 1 meter + 1 meter + 2 meters * 1 meter + 2 meters + 1 meter * 2 meters + 1 meter + 1 meter * 2 meters + 2 meters Thus, there are 5 distinct ways. Note: The function should be optimized for both time and space. Ensure that your implementation handles large values of `height` efficiently.","solution":"def count_climbing_ways(height): Returns the number of distinct ways to reach the summit of a mountain with the given height. if height == 1: return 1 if height == 2: return 2 dp = [0] * (height + 1) dp[1] = 1 dp[2] = 2 for i in range(3, height + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[height]"},{"question":"# Scenario You work for a search engine company, and you are tasked with implementing an efficient search function to be used in a vast database. The database is represented as a rotated sorted array and you need to locate specific data entries within it. # Problem Statement Given an array `arr` that has been sorted in ascending order and then rotated at some unknown pivot, write a function `search_in_rotated_array` that searches for a target value `target`. If the target is found in the array, return its index. Otherwise, return -1. Your algorithm\'s runtime complexity must be O(log n). Function Signature ```python def search_in_rotated_array(arr: List[int], target: int) -> int: pass ``` # Input * A list of integers `arr` where the integers were initially sorted in ascending order and then rotated. * An integer `target` representing the target value to search for. # Output * An integer representing the index of `target` if it is present in `arr`, otherwise -1. # Constraints * `arr` will have at least 1 integer and at most 10^4 integers. * All integers in `arr` are unique. * The function should operate with O(log n) time complexity. # Examples 1. **Example 1**: - **Input**: `arr = [4,5,6,7,0,1,2]`, `target = 0` - **Output**: `4` 2. **Example 2**: - **Input**: `arr = [4,5,6,7,0,1,2]`, `target = 3` - **Output**: `-1` 3. **Example 3**: - **Input**: `arr = [1]`, `target = 0` - **Output**: `-1` 4. **Example 4**: - **Input**: `arr = [1]`, `target = 1` - **Output**: `0` # Note In the rotated sorted array, each half may still be considered sorted. Utilize the properties of the sorted halves for efficient searching without sequentially looking through each element.","solution":"from typing import List def search_in_rotated_array(arr: List[int], target: int) -> int: Searches for a target value in a rotated sorted array and returns its index. If the target is not found, returns -1. :param arr: List[int] - Rotated sorted array :param target: int - Target value to search for :return: int - Index of target if found, otherwise -1 if not arr: return -1 left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid # Check if the left half is sorted if arr[left] <= arr[mid]: if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 # Right half must be sorted else: if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Two Sum Problem - Customized Routes You are provided with a sorted array of integers and a target integer. Your task is to write a function that will find two distinct elements in the array such that their sum equals the target integer. The indices of these two elements must be returned, and the indices should not be zero-based. **Function Signature**: ```python def find_two_sum(numbers: List[int], target: int) -> List[int]: pass ``` # Input * `numbers`: A list of integers `numbers`, sorted in ascending order. (1 <= len(numbers) <= 10^4) * `target`: An integer `target` which is the sum to be formed. # Output * Returns a list containing the indices of the two numbers such that they add up to the target. The indices are not zero-based, meaning the first element has index 1. Return the indices in ascending order. # Constraints * Each input will have exactly one solution. * You may not use the same element twice. # Example: ```python numbers = [2, 7, 11, 15] target = 9 output = [1, 2] ``` # Scenario: A company is tracking the transaction rates of various products in a sorted list. To maintain competitive pricing, they need to identify a pair of transaction rates that sum up to a specific index-based target rate. # Hints: * Consider edge cases such as lists with less than 2 elements or arrays containing negative numbers. * Focus on time complexity to ensure solutions are optimized for large inputs. * Ensure proper handling of positive and negative target values.","solution":"from typing import List def find_two_sum(numbers: List[int], target: int) -> List[int]: Find two numbers in the sorted list `numbers` such that they add up to `target`. Returns the 1-based indices of these two numbers in a list. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] # Convert to 1-based index elif current_sum < target: left += 1 else: right -= 1 return [] # This line should never be reached due to problem constraints"},{"question":"# Pathfinding in a Graph: Optimized Algorithms You are given a graph represented as an adjacency list and tasked with implementing more optimized and efficient pathfinding algorithms. The primary goal is to reduce the time complexity of finding paths in the graph while maintaining accuracy. # Problem Statement Implement three functions to find paths in a graph: 1. **Single Path**: `def find_any_path(graph, start, end):` - **Input**: * `graph`: Dictionary representing the adjacency list of the graph. Keys are node identifiers and values are lists of neighbors. * `start`: The starting node identifier. * `end`: The target node identifier. - **Output**: A list representing any valid path from `start` to `end`, or `None` if no path exists. 2. **All Paths**: `def find_all_paths_optimized(graph, start, end):` - **Input**: * `graph`: Dictionary representing the adjacency list of the graph. * `start`: The starting node identifier. * `end`: The target node identifier. - **Output**: A list of lists, where each inner list is a valid path from `start` to `end`. 3. **Shortest Path**: `def find_shortest_path_bfs(graph, start, end):` - **Input**: * `graph`: Dictionary representing the adjacency list of the graph. * `start`: The starting node identifier. * `end`: The target node identifier. - **Output**: A list representing the shortest path from `start` to `end`, or `None` if no path exists. # Requirements 1. **find_any_path** should be optimized using an iterative approach, avoiding recursion to prevent stack overflow on large graphs. 2. **find_all_paths_optimized** should use memoization to store already visited paths and avoid redundant computations. 3. **find_shortest_path_bfs** should use the Breadth-First Search (BFS) algorithm to ensure that the shortest path is found in linear time. # Constraints * 1 ≤ Number of nodes in the graph ≤ 10^4 * 1 ≤ Number of edges in the graph ≤ 5 × 10^4 * Node identifiers are non-negative integers. # Performance * Optimize for the longest paths and largest graphs possible within the constraints. * Minimize unnecessary recursive calls and enhance efficiency with appropriate algorithmic strategies. # Example ```python graph = { 0: [1, 2], 1: [3], 2: [3, 4], 3: [4], 4: [] } print(find_any_path(graph, 0, 4)) # Output: [0, 1, 3, 4] or any other valid path print(find_all_paths_optimized(graph, 0, 4)) # Output: [[0, 1, 3, 4], [0, 2, 3, 4], [0, 2, 4]] print(find_shortest_path_bfs(graph, 0, 4)) # Output: [0, 2, 4] ``` Ensure your implementation passes the above example and efficiently handles large graphs as per the given constraints.","solution":"def find_any_path(graph, start, end): Find any path from start to end using iterative depth-first search. Args: graph (dict): The graph\'s adjacency list representation. start (int): The starting node identifier. end (int): The target node identifier. Returns: list: A list representing any valid path from start to end, or None if no path exists. stack = [(start, [start])] while stack: (vertex, path) = stack.pop() for next in set(graph[vertex]) - set(path): if next == end: return path + [next] else: stack.append((next, path + [next])) return None def find_all_paths_optimized(graph, start, end): Find all paths from start to end using DFS with memoization. Args: graph (dict): The graph\'s adjacency list representation. start (int): The starting node identifier. end (int): The target node identifier. Returns: list: A list of lists, where each inner list is a valid path from start to end. memo = {} def dfs(current, end, path): if current in memo: return memo[current] if current == end: return [path] paths = [] for neighbor in graph[current]: if neighbor not in path: paths.extend(dfs(neighbor, end, path + [neighbor])) memo[current] = paths return paths return dfs(start, end, [start]) def find_shortest_path_bfs(graph, start, end): Find the shortest path from start to end using Breadth-First Search (BFS). Args: graph (dict): The graph\'s adjacency list representation. start (int): The starting node identifier. end (int): The target node identifier. Returns: list: A list representing the shortest path from start to end, or None if no path exists. from collections import deque queue = deque([(start, [start])]) visited = set() while queue: (vertex, path) = queue.popleft() if vertex not in visited: if vertex == end: return path visited.add(vertex) for neighbor in graph[vertex]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return None"},{"question":"You are tasked with creating a function `advanced_gcd_and_lcm` that will compute the greatest common divisor (GCD) and the least common multiple (LCM) of two given integers using the algorithms provided. The function should handle edge cases including negative integers and non-integer inputs gracefully, providing appropriate error handling. # Function Signature ```python def advanced_gcd_and_lcm(a: int, b: int) -> dict: pass ``` # Input - **a**: An integer ((-10^6 leq a leq 10^6)) - **b**: Another integer ((-10^6 leq b leq 10^6)) # Output - A dictionary with two keys: `\\"gcd\\"` and `\\"lcm\\"`, where the values are the greatest common divisor and the least common multiple of the given integers, respectively. # Constraints - Both input integers should be non-zero. # Examples 1. `advanced_gcd_and_lcm(56, 98)` should return a dictionary `{ \\"gcd\\": 14, \\"lcm\\": 392 }` 2. `advanced_gcd_and_lcm(-25, 75)` should return a dictionary `{ \\"gcd\\": 25, \\"lcm\\": 75 }` 3. `advanced_gcd_and_lcm(0, 15)` should raise a ValueError with the message \\"One or more input arguments equals zero\\" 4. `advanced_gcd_and_lcm(7, -21)` should return a dictionary `{ \\"gcd\\": 7, \\"lcm\\": 21 }` # Notes - Use the Euclidean algorithm for computing the GCD. - Use the relationship between GCD and LCM to compute the LCM. - The input will be in the range of signed integers from (-10^6) to (10^6). # Requirements - Demonstrate strong error-handling capabilities. - Efficiently handle large numbers and edge cases. - No usage of built-in library functions for GCD or LCM calculations directly.","solution":"def advanced_gcd_and_lcm(a: int, b: int) -> dict: Returns a dictionary with the GCD and LCM of two integers a and b. if not isinstance(a, int) or not isinstance(b, int): raise ValueError(\\"Both input arguments must be integers\\") if a == 0 or b == 0: raise ValueError(\\"One or more input arguments equals zero\\") def gcd(x, y): while y: x, y = y, x % y return abs(x) def lcm(x, y): return abs(x * y) // gcd(x, y) gcd_result = gcd(a, b) lcm_result = lcm(a, b) return {\\"gcd\\": gcd_result, \\"lcm\\": lcm_result}"},{"question":"# Scenario Imagine you are working on an application that processes URLs for a search engine. One of your tasks is to ensure the URLs are clean before storing or processing them. You need to write a function that removes any duplicate query string parameters from the URL and removes any query string parameters specified within an optional filter array. # Task Write a function `clean_url(url: str, params_to_strip: List[str] = []) -> str` that performs the following: 1. Removes any duplicate query string parameters from the URL, keeping only the first occurrence. 2. Removes any query string parameters specified within the `params_to_strip` list. The function should handle URLs with or without query parameters appropriately. # Expected Input and Output * **Input**: * `url`: A string representing the URL to be cleaned. * `params_to_strip`: An optional list of strings representing the parameters to be removed. * **Output**: * A string representing the cleaned URL. # Constraints * The URL will be a well-formed string. * The parameter names and values will be alphanumeric. # Example ```python # Example 1 url = \\"www.saadbenn.com?a=1&b=2&a=2\\" params_to_strip = [] output = clean_url(url, params_to_strip) # Expected output: \\"www.saadbenn.com?a=1&b=2\\" # Example 2 url = \\"www.saadbenn.com?a=1&b=2&a=2\\" params_to_strip = [\\"b\\"] output = clean_url(url, params_to_strip) # Expected output: \\"www.saadbenn.com?a=1\\" ``` # Requirements * Ensure the resulting URL preserves the first occurrence of each query parameter. * If the input URL has no query parameters, return it as is. * Handle possible edge cases such as empty `params_to_strip`, no query parameters in the URL, etc. * Implement the function with a focus on readability and efficiency. ```python def clean_url(url: str, params_to_strip: List[str] = []) -> str: # Your implementation here pass # Test your implementation with the provided examples print(clean_url(\\"www.saadbenn.com?a=1&b=2&a=2\\")) # Should print \\"www.saadbenn.com?a=1&b=2\\" print(clean_url(\\"www.saadbenn.com?a=1&b=2&a=2\\", [\\"b\\"])) # Should print \\"www.saadbenn.com?a=1\\" ```","solution":"from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse from typing import List def clean_url(url: str, params_to_strip: List[str] = []) -> str: Cleans the given URL by removing duplicate query parameters and parameters specified in the params_to_strip list. Parameters: url (str) : The URL to be cleaned. params_to_strip (List[str]) : List of query parameters to be removed. Returns: str : The cleaned URL. # Parse the URL parsed_url = urlparse(url) # Parse the query string into a list of (name, value) pairs query_params = parse_qsl(parsed_url.query, keep_blank_values=True) # Use an ordered dictionary to maintain insertion order and unique keys seen_params = {} for key, value in query_params: if key not in seen_params: if key not in params_to_strip: seen_params[key] = value # Construct the cleaned query string cleaned_query = urlencode(seen_params) # Build the cleaned URL cleaned_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, parsed_url.params, cleaned_query, parsed_url.fragment)) return cleaned_url"},{"question":"# Base Conversion Extended Application You are tasked with implementing a system that can store and retrieve data in various numeral bases efficiently. The system is required to: 1. Convert an integer to any base from 2 to 36. 2. Convert a string representation of a number in any base back to an integer. 3. Handle large integers and ensure the system works for various edge cases, including handling invalid inputs gracefully. Implement the following two functions: 1. **`int_to_base(num, base)`**: * Converts a given integer `num` to the string representation of its value in the given `base`. * **Parameters**: * `num` (int): The integer to be converted. * `base` (int): The base to which the integer should be converted. * **Returns**: (str) The base `base` representation of `num`. 2. **`base_to_int(str_to_convert, base)`**: * Converts a given string `str_to_convert` representing a number in the specified `base` back to an integer. * **Parameters**: * `str_to_convert` (str): The string representation of the number. * `base` (int): The base in which the number is represented. * **Returns**: (int) The integer representation of `str_to_convert`. **Constraints**: * -10^18 ≤ num ≤ 10^18 * 2 ≤ base ≤ 36 * The input string will be a valid representation in the given base. **Examples**: ```python # Examples for int_to_base print(int_to_base(5, 2)) # Output: \'101\' print(int_to_base(-15, 16)) # Output: \'-F\' # Examples for base_to_int print(base_to_int(\'101\', 2)) # Output: 5 print(base_to_int(\'-F\', 16)) # Output: -15 ```","solution":"def int_to_base(num, base): Converts a given integer `num` to the string representation of its value in the given `base`. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \'0\' negative = num < 0 num = abs(num) digits = [] while num: remainder = num % base if remainder >= 10: digits.append(chr(55 + remainder)) # Convert 10-35 to \'A\'-\'Z\' else: digits.append(chr(48 + remainder)) # Convert 0-9 to \'0\'-\'9\' num = num // base if negative: digits.append(\'-\') return \'\'.join(digits[::-1]) def base_to_int(str_to_convert, base): Converts a given string `str_to_convert` representing a number in the specified `base` back to an integer. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") negative = str_to_convert[0] == \'-\' if negative: str_to_convert = str_to_convert[1:] num = 0 for char in str_to_convert: if \'0\' <= char <= \'9\': value = ord(char) - 48 elif \'A\' <= char <= \'Z\': value = ord(char) - 55 else: raise ValueError(f\\"Invalid character {char} for base {base}\\") num = num * base + value if negative: num = -num return num"},{"question":"# Euler\'s Totient Function Implementation and Usage Euler\'s totient function, also known as ϕ(n), is extremely useful in number theory and cryptographic algorithms. Given the significance of this function, your task is to implement the Euler\'s totient function and use it to solve a specific problem involving an array of integers. Problem Statement Implement a function named `euler_totient(n)` that computes the Euler\'s totient function for an integer n. Then, use this function to derive another function named `sum_of_totients(arr)` that takes an array of integers and returns the sum of their totient values. Function Signature ```python def euler_totient(n: int) -> int: pass def sum_of_totients(arr: list[int]) -> int: pass ``` Input Format * `euler_totient(n: int)`: An integer n (1 ≤ n ≤ 10^6). * `sum_of_totients(arr: list[int])`: A list of integers `arr` where each integer `arr[i]` satisfies (1 ≤ arr[i] ≤ 10^6). Output Format * `euler_totient(n: int)`: Returns an integer representing the value of ϕ(n). * `sum_of_totients(arr: list[int])`: Returns an integer representing the sum of the totient values of the integers in `arr`. Constraints 1. The integer n provided to `euler_totient` should be at least 1 and at most 10^6. 2. The list `arr` will contain up to 10^5 integers, each in the range 1 to 10^6. Example ```python # Example Input arr = [10, 12, 15] # Using euler_totient function, you get the following: # euler_totient(10) = 4 # euler_totient(12) = 4 # euler_totient(15) = 8 # Example Output sum_of_totients(arr) => 4 + 4 + 8 = 16 ``` # Note: - Ensure your implementation is efficient and can handle the upper limits of the input constraints. - Your solution should consider execution time and space optimally.","solution":"def euler_totient(n: int) -> int: Euler\'s Totient function, also known as ϕ(n), computes the count of integers up to n that are relatively prime to n. if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def sum_of_totients(arr: list[int]) -> int: Given an array of integers, computes the sum of their Euler\'s Totient function values. return sum(euler_totient(x) for x in arr)"},{"question":"# Ternary Search Implementation **Objective**: Implement a function that uses the Ternary Search algorithm to find an element in a sorted array. **Function Signature**: ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: ``` **Description**: Write a function that searches for a given `key` in a sorted list `arr`. It should return the index of the `key` if found, and `-1` otherwise. The search should be conducted within the bounds specified by `left` and `right`. **Parameters**: - `left` (int): Left boundary index for the search (inclusive). - `right` (int): Right boundary index for the search (inclusive). - `key` (int): The element to search for. - `arr` (List[int]): A list of sorted integers in ascending order. **Returns**: - `int`: The index of the `key` in the array if found; otherwise `-1`. **Examples**: ```python assert ternary_search(0, 4, 3, [1, 2, 3, 4, 5]) == 2 assert ternary_search(0, 4, 6, [1, 2, 3, 4, 5]) == -1 assert ternary_search(1, 3, 2, [1, 2, 3, 4, 5]) == 1 assert ternary_search(0, 0, 1, [1]) == 0 assert ternary_search(0, 0, 2, [1]) == -1 ``` **Constraints**: - The array `arr` will always be sorted in non-decreasing order. - If `left > right`, return `-1`. **Notes**: - Ensure the algorithm efficiently finds the key using the ternary search method. - Consider edge cases and optimize comparisons to avoid unnecessary computations.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Perform a ternary search on a sorted array. Args: left (int): Left boundary index for the search (inclusive). right (int): Right boundary index for the search (inclusive). key (int): The element to search for. arr (List[int]): A list of sorted integers in ascending order. Returns: int: The index of the key if found, otherwise -1. while left <= right: third1 = left + (right - left) // 3 third2 = right - (right - left) // 3 if arr[third1] == key: return third1 if arr[third2] == key: return third2 if key < arr[third1]: right = third1 - 1 elif key > arr[third2]: left = third2 + 1 else: left = third1 + 1 right = third2 - 1 return -1"},{"question":"You are working on a sorting algorithm for a small embedded system with limited resources. Given its simplicity, your client has requested to use Bubble Sort for their application. However, they also requested some modifications to fit their unique needs. You are required to implement a modified version of the Bubble Sort algorithm that supports both ascending and descending order sorting. Additionally, they want to optimize the sorting process by incorporating a check for early termination when the list is already sorted. Task Write a function `modified_bubble_sort(arr, order=\'asc\')` that sorts an array either in ascending or descending order. # Function Signature ```python def modified_bubble_sort(arr: List[int], order: str = \'asc\') -> List[int]: ``` # Input 1. `arr`: A list of integers to be sorted. (0 ≤ len(arr) ≤ 10^3) 2. `order`: A string that may be either \'asc\' or \'desc\'. Defaults to \'asc\' for ascending order sorting. # Output - Returns the sorted list of integers in the specified order. # Constraints - You must use Bubble Sort for this implementation. - Optimize for performance by including an early termination check. - Do not use Python\'s built-in sort functions. # Examples ```python >>> modified_bubble_sort([5, 3, 8, 4, 2], \'asc\') [2, 3, 4, 5, 8] >>> modified_bubble_sort([5, 3, 8, 4, 2], \'desc\') [8, 5, 4, 3, 2] >>> modified_bubble_sort([1, 2, 3, 4, 5], \'asc\') [1, 2, 3, 4, 5] >>> modified_bubble_sort([1, 2, 3, 4, 5], \'desc\') [5, 4, 3, 2, 1] ```","solution":"from typing import List def modified_bubble_sort(arr: List[int], order: str = \'asc\') -> List[int]: n = len(arr) if n <= 1: return arr for i in range(n): swapped = False for j in range(0, n-i-1): if (order == \'asc\' and arr[j] > arr[j+1]) or (order == \'desc\' and arr[j] < arr[j+1]): arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr"},{"question":"# Subset Generation Assessment Question Context: You are given a set of distinct integers and you need to generate all possible subsets of this set. This task is fundamental in understanding backtracking and iterative approaches to combinatorial problems. Task: Write a function `generate_subsets(nums)` that generates all possible subsets of a given list of integers using both backtracking and iterative methods. Ensure that your function returns all subsets without any duplication. Function Signature: ```python def generate_subsets(nums: List[int]) -> List[List[int]]: # Your implementation here pass ``` Input: - `nums` (List[int]): A list of distinct integers. * `1 <= len(nums) <= 20` * `-10 <= nums[i] <= 10` Output: - Returns a list containing all possible subsets, including the empty set and the set itself. Constraints: - The solution should not contain any duplicate subsets. - The subsets can be returned in any order. Performance Requirements: - Time complexity should be O(2^n) - Space complexity should handle O(n * 2^n) due to the growing number of subsets. Example: ```python print(generate_subsets([1, 2, 3])) # Expected Output: # [ # [], # [1], # [2], # [3], # [1, 2], # [1, 3], # [2, 3], # [1, 2, 3] # ] ``` **Note**: You can use either the backtracking approach or the iterative approach as discussed, but ensure that your solution is robust and handles all edge cases appropriately.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: Generates all possible subsets of a given list of distinct integers. # Iterative approach to generating subsets res = [] res.append([]) # Start with the empty subset for num in nums: # For every element in nums, add it to all existing subsets new_subsets = [] for subset in res: new_subsets.append(subset + [num]) res.extend(new_subsets) return res"},{"question":"# Problem Description Your task is to implement a function that computes the n-th Fibonacci number using the most efficient approach possible. Given a positive integer n, the function should return the n-th Fibonacci number. The Fibonacci sequence is defined as follows: * F0 = 0 * F1 = 1 * Fn = F(n-1) + F(n-2) for n ≥ 2 # Input Format * A single integer n (0 <= n <= 10^18) # Output Format * A single integer which is the n-th Fibonacci number. # Constraints * You must handle very large values of n efficiently. * Your solution should have a time complexity close to O(log n). * Your solution should have a space complexity close to O(1). # Example ```python Input: 10 Output: 55 Input: 50 Output: 12586269025 ``` # Guidelines 1. You are encouraged to use matrix exponentiation or any other optimization technique to compute large Fibonacci numbers efficiently. 2. Ensure that your solution is well-tested for extremely large values of n to prevent overflow and performance issues.","solution":"def fib(n): Returns the n-th Fibonacci number. Uses matrix exponentiation for efficient computation. if n == 0: return 0 elif n == 1: return 1 def matrix_mult(A, B): return [ [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]], [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]] ] def matrix_power(matrix, power): result = [[1, 0], [0, 1]] base = matrix while power: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result F = [[1, 1], [1, 0]] result_matrix = matrix_power(F, n-1) return result_matrix[0][0]"},{"question":"# Priority Queue Enhancement Task You are tasked with improving the PriorityQueue class provided below that maintains a priority queue using a linear array. Currently, the `push` method takes O(n) time because it maintains the ordered list by iterating through it to find the correct position for the new element. The `pop` method takes O(1) time. Your objective is to improve the overall performance of the priority queue operations by re-implementing it using a binary heap. This reduces the insertion time complexity to O(log n). Implement a class `BinaryHeapPriorityQueue` that provides the same interface as `PriorityQueue`, but performs insertions more efficiently using a binary heap. Your solution should include the following methods: - `__init__(self, items=None, priorities=None)`: Initializes the priority queue. - `size(self)`: Returns the size of the priority queue. - `push(self, item, priority=None)`: Adds an element to the priority queue with an associated priority. - `pop(self)`: Removes and returns the element with the lowest priority. # Expected Input and Output - `__init__(self, items=None, priorities=None)`: Initializes the queue. If no items or priorities are given, sets up an empty queue. - `size(self) -> int`: Returns the number of elements in the queue. - `push(self, item: Any, priority: Optional[int] = None) -> None`: Inserts an item with the given priority. - `pop(self) -> Any`: Returns the item with the lowest priority (breaking ties arbitrarily) and removes it from the queue. # Example ```python pq = BinaryHeapPriorityQueue() pq.push(\'item1\', 2) pq.push(\'item2\', 1) pq.push(\'item3\', 3) print(pq.pop()) # Outputs \'item2\' print(pq.size()) # Outputs 2 ``` # Constraints - You may assume all priorities are integers. - The queue should function correctly for typical use cases as well as edge cases (e.g., popping from an empty queue should raise an appropriate exception).","solution":"import heapq class BinaryHeapPriorityQueue: def __init__(self, items=None, priorities=None): Initializes the priority queue. If items and priorities are provided, initializes with these. self.heap = [] if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) def size(self): Returns the number of elements in the priority queue. return len(self.heap) def push(self, item, priority): Adds an element to the priority queue with an associated priority. heapq.heappush(self.heap, (priority, item)) def pop(self): Removes and returns the element with the lowest priority. if not self.heap: raise IndexError(\\"pop from an empty priority queue\\") return heapq.heappop(self.heap)[1]"},{"question":"Problem Statement # Context A zombie apocalypse has begun, and you have been tasked with managing an evacuation order. You need to process evacuees based on their priority – evacuees added late would be processed first due to urgency (LIFO priority). To manage this, you need to implement a stack structure for efficient evacuation handling. # Task Implement a stack using a linked list that supports the following operations: 1. `push(item)` - Add an evacuee to the stack. 2. `pop()` - Remove the most urgent evacuee from the stack. 3. `peek()` - Return the most urgent evacuee without removing them from the stack. 4. `is_empty()` - Check if the stack is empty. # Requirements: 1. **Input**: Your stack should manage evacuees. Each evacuee has a unique name (a string). 2. **Output**: The specified operations should return the appropriate values or perform the described actions. # Constraints: 1. Your implementation should use a linked list data structure. 2. All operations should operate in O(1) time. 3. Be mindful of edge cases such as popping from an empty stack. # Example: ```python stack = EvacuationStack() stack.push(\\"John\\") stack.push(\\"Alice\\") print(stack.peek()) # Output: \\"Alice\\" print(stack.pop()) # Output: \\"Alice\\" print(stack.is_empty()) # Output: False print(stack.pop()) # Output: \\"John\\" print(stack.is_empty()) # Output: True ``` # Notes: 1. You may use the `StackNode` and `AbstractStack` classes provided above. 2. Ensure proper error handling for operations on an empty stack. Your goal is to implement the `EvacuationStack` class using the skeleton provided below: ```python class StackNode: Represents a single stack node. def __init__(self, value): self.value = value self.next = None class AbstractStack(metaclass=ABCMeta): Abstract Class for Stacks. def __init__(self): self._top = -1 def __len__(self): return self._top + 1 def is_empty(self): return self._top == -1 @abstractmethod def push(self, value): pass @abstractmethod def pop(self): pass @abstractmethod def peek(self): pass class EvacuationStack(AbstractStack): def __init__(self): super().__init__() self.head = None def __iter__(self): probe = self.head while True: if probe is None: return yield probe.value probe = probe.next def push(self, value): node = StackNode(value) node.next = self.head self.head = node self._top += 1 def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") value = self.head.value self.head = self.head.next self._top -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.head.value ```","solution":"class StackNode: Represents a single stack node. def __init__(self, value): self.value = value self.next = None class AbstractStack: Abstract Class for Stacks. def __init__(self): self._top = -1 def __len__(self): return self._top + 1 def is_empty(self): return self._top == -1 def push(self, value): pass def pop(self): pass def peek(self): pass class EvacuationStack(AbstractStack): Implementation of a Stack using a Linked List for managing evacuees. def __init__(self): super().__init__() self.head = None def push(self, value): Add an evacuee to the stack. node = StackNode(value) node.next = self.head self.head = node self._top += 1 def pop(self): Remove the most urgent evacuee from the stack. if self.is_empty(): raise IndexError(\\"Stack is empty\\") value = self.head.value self.head = self.head.next self._top -= 1 return value def peek(self): Return the most urgent evacuee without removing them from the stack. if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.head.value def is_empty(self): Check if the stack is empty. return super().is_empty()"},{"question":"**Scenario**: You\'re a developer at a tech company tasked with improving search functionalities within large datasets. Your current task involves implementing a function to find the starting and ending positions of a specified target value in a sorted list of integers. The list may contain duplicate values. If the target value does not exist in the list, the function should return [-1, -1]. Considering time efficiency due to large possible input sizes, aim to achieve O(log n) time complexity for your solution. **Objective**: Implement the function `search_range(nums, target)` which: * Takes two inputs: - `nums` (List[int]): a list of integers sorted in ascending order. - `target` (int): the target integer to search for. * Returns a list of two integers representing the starting and ending positions of the target value. If the target is not found, return `[-1, -1]`. **Function Signature**: ```python def search_range(nums: List[int], target: int) -> List[int]: ``` **Constraints**: * The length of `nums` is in the range [0, 10^5]. * -10^9 <= nums[i] <= 10^9 * All integers in `nums` are sorted in ascending order. * -10^9 <= target <= 10^9 **Examples**: 1. `search_range([5, 7, 7, 8, 8, 8, 10], 8)` should return `[3, 5]`. 2. `search_range([5, 7, 7, 8, 8, 8, 10], 11)` should return `[-1, -1]`. 3. `search_range([], 3)` should return `[-1, -1]`. 4. `search_range([1], 1)` should return `[0, 0]`. **Performance Requirements**: Optimize your solution to ensure it runs in O(log n) time complexity for efficiency with large lists.","solution":"from typing import List def search_range(nums: List[int], target: int) -> List[int]: def find_left_index(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_right_index(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right left_index = find_left_index(nums, target) right_index = find_right_index(nums, target) if left_index <= right_index < len(nums) and nums[left_index] == target and nums[right_index] == target: return [left_index, right_index] return [-1, -1]"},{"question":"# Word Search Data Structure Implementation You are tasked to implement a data structure that supports adding words and searching them efficiently. The search functionality should be able to handle regular words and words with wildcard characters represented by \'.\' (dot), where the dot can represent any character. **Functionality Requirement:** 1. `add_word(word: str) -> None`: Method to add a word into the data structure. 2. `search(word: str) -> bool`: Method to search for a word in the data structure. A word can contain dots (\'.\'), which should be treated as any one letter. **Input:** * `add_word`: A single string `word` where 1 <= length(word) <= 50 * `search`: A single string `word` where 1 <= length(word) <= 50, and `word` contains lowercase English letters or dot \'.\' characters. **Output:** * `add_word`: None * `search`: Boolean value indicating if the word (or regex word) exists in the data structure. # Constraints: * The total number of words added to the data structure will not exceed 10^4. * The total number of searches performed will not exceed 10^4. # Task: Implement the `WordDictionary` class based on the requirements above. Ensure your solution handles both Trie and HashMap bucket based approaches to handle the word searches efficiently. ```python class WordDictionary: def __init__(self): Initialize your data structure here. # Your code here def add_word(self, word: str) -> None: Add a word into the data structure. # Your code here def search(self, word: str) -> bool: Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter. # Your code here ``` **Scenario:** Imagine you are building a search engine for a dictionary application where users query words directly or using patterns. How would you manage the operations of adding new words and searching given the constraints?","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): Initialize your data structure here. self.root = TrieNode() def add_word(self, word: str) -> None: Add a word into the data structure. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter. def search_in_node(node, word, index): if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if search_in_node(child, word, index + 1): return True return False else: if char not in node.children: return False return search_in_node(node.children[char], word, index + 1) return search_in_node(self.root, word, 0)"},{"question":"# Assignment: Minimum Perfect Squares Problem Scenario In a mathematical game, you are given a number and your task is to determine the minimum number of perfect squares that sum up to this number. Lagrange\'s four-square theorem ensures any positive integer can be represented as the sum of four or fewer perfect squares. Problem Statement Write a function `num_perfect_squares(number: int) -> int` that takes a single integer `number` and returns the minimum number of perfect squares required to sum to that number. Constraints - `1 <= number <= 10^4` - The function should return an integer value between 1 and 4. Input - `number`: A positive integer representing the number to be decomposed into perfect squares. Output - Return the minimum number of perfect squares that sum up to the given number. Example ```python print(num_perfect_squares(9)) # Output: 1 print(num_perfect_squares(10)) # Output: 2 print(num_perfect_squares(12)) # Output: 3 print(num_perfect_squares(31)) # Output: 4 ``` Additional Details 1. If the number is already a perfect square, return 1. 2. If the number can be represented as the sum of two perfect squares, return 2. 3. If the number fits the specific mathematical form `4^a(8b + 7)`, return 4. 4. Otherwise, determine if it can be expressed as a sum of three perfect squares, and return 3. Implement the function focusing on both correctness and efficiency to handle all valid inputs within the specified constraints.","solution":"import math def num_perfect_squares(number: int) -> int: Determine the minimum number of perfect squares that sum to the given number. # Check if the number is a perfect square if int(math.isqrt(number)) ** 2 == number: return 1 # Check if the number can be written as the sum of two perfect squares for i in range(1, int(math.isqrt(number)) + 1): remainder = number - i * i if int(math.isqrt(remainder)) ** 2 == remainder: return 2 # Check if the number can be written as the sum of four perfect squares # using the form of 4^a(8b + 7) while number % 4 == 0: number //= 4 if number % 8 == 7: return 4 # If not, it must be a sum of three perfect squares return 3"},{"question":"# Word Dictionary Implementation You are tasked with designing an efficient data structure that supports adding words and searching for words (with support for wildcard characters). Specifications: 1. Implement a data structure that can add words and search words efficiently. 2. The search function should allow exactly matching words or matching words with wildcard characters. The wildcard character `\'.\'` can be used to represent any letter. 3. Optimize for time complexity in both adding and searching operations. # Function Signatures: ```python class WordDictionary: def __init__(self): Initialize your data structure pass def add_word(self, word: str) -> None: Add a word into the data structure :param word: a string representing the word to be added pass def search(self, word: str) -> bool: Search a word or a regular expression with \'.\' where \'.\' can represent any letter. :param word: a string representing the word or regex pattern :return: True if the word or pattern matches any word in the dictionary, False otherwise pass ``` # Constraints: - The number of words added will be in the range `[1, 50000]`. - The length of each word will be in the range `[1, 100]`. - Searching words may include the wildcard character `\'.\'`. - The search function should return a boolean indicating whether the word or pattern exists within the dictionary. # Example Usage: ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") print(wd.search(\\"pad\\")) # Output: False print(wd.search(\\"bad\\")) # Output: True print(wd.search(\\".ad\\")) # Output: True print(wd.search(\\"b..\\")) # Output: True ``` # Evaluation Criteria: - **Correctness**: Make sure the implementation meets all specifications. - **Efficiency**: Consider both time and space complexity, especially for large datasets. - **Edge Cases**: Handle edge cases, including empty strings and strings with multiple wildcards. - **Code Quality**: Maintain clear, readable, and well-documented code.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_in_node(word, self.root) def _search_in_node(self, word: str, node: TrieNode) -> bool: for i, char in enumerate(word): if char == \\".\\": for child in node.children.values(): if self._search_in_node(word[i+1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word"},{"question":"# Coding Challenge Context: You are working for a company that needs to highlight specific technical terms (symbols) within documents (words). Each term should be highlighted by wrapping it in square brackets. If multiple symbols match a word, the longest matching symbol should be highlighted. Problem: You are provided with two lists: 1. `words`: A list of strings representing words/documents. 2. `symbols`: A list of symbols to be highlighted within the words. Write a function `match_symbols(words, symbols)` that returns a new list where each word has the longest matching symbol highlighted. **Function Signature:** ```python def match_symbols(words: List[str], symbols: List[str]) -> List[str]: ``` **Input:** - `words`: A list of words (strings), `1 <= len(words) <= 10^4` - `symbols`: A list of symbols (strings), `1 <= len(symbols) <= 10^3` **Output:** - A list of words with the longest matching symbol highlighted in square brackets. **Constraints:** - All words and symbols contain only lowercase and uppercase letters. - If multiple symbols match the same substring, choose the one with the longest length. If they have the same length, choose the first one appearing in the symbols list. **Example:** ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] output = match_symbols(words, symbols) print(output) # Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` **Notes:** - Consider using efficient data structures to optimize performance. - Make sure to handle edge cases such as no matching symbols and overlapping symbols correctly.","solution":"from typing import List def match_symbols(words: List[str], symbols: List[str]) -> List[str]: symbol_set = set(symbols) def find_longest_symbol_match(word): longest_match = \\"\\" for i in range(len(word)): for j in range(i + 1, len(word) + 1): substring = word[i:j] if substring in symbol_set and len(substring) > len(longest_match): longest_match = substring if longest_match: return word.replace(longest_match, f\'[{longest_match}]\', 1) return word return [find_longest_symbol_match(word) for word in words] # Example usage words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] output = match_symbols(words, symbols) print(output) # Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\']"},{"question":"# Problem Description You are provided with a partially implemented B-tree class with functionalities to insert, search, delete, and traverse keys. B-trees are balanced trees that maintain sorted data and allow binary searches, insertions, and deletions in logarithmic space. # Tasks You are required to implement the following tasks: 1. **Count Keys** - Implement a method `count_keys()` in the BTree class that returns the total number of keys present in the B-tree. 2. **Find Minimum Key** - Implement a method `find_min_key()` in the BTree class that finds and returns the minimum key in the B-tree. 3. **Find Maximum Key** - Implement a method `find_max_key()` in the BTree class that finds and returns the maximum key in the B-tree. # Method Signatures ```python class BTree: ... def count_keys(self) -> int: Returns the total number of keys present in the B-tree. pass def find_min_key(self) -> int: Returns the minimum key in the B-tree. pass def find_max_key(self) -> int: Returns the maximum key in the B-tree. pass ``` # Input and Output - `count_keys()` must return an integer representing the total number of keys. - `find_min_key()` must return the minimum integer key in the tree or `None` if the tree is empty. - `find_max_key()` must return the maximum integer key in the tree or `None` if the tree is empty. # Constraints - All keys inserted in the B-tree are unique integers. - There will be at least one key inserted in the B-tree when `find_min_key()` or `find_max_key()` is called. - Assume the B-tree is correctly implemented and is balanced after any insertions or deletions. # Example Scenario Consider a B-tree of degree t = 3. If the following keys are inserted in the given order: [20, 15, 10, 5, 30, 25, 24, 35, 40, 45]. - `count_keys()` should return 10. - `find_min_key()` should return 5. - `find_max_key()` should return 45. # Implementation Guide - **count_keys()**: Traverse the entire B-tree and maintain a count of all keys encountered. - **find_min_key()**: Traverse left from the root until reaching a leaf node. - **find_max_key()**: Traverse right from the root until reaching a leaf node. **Function Implementation Expected in Python**","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] class BTree: def __init__(self, t): self.root = BTreeNode(t, True) self.t = t def insert(self, k): root = self.root if len(root.keys) == (2 * self.t) - 1: temp = BTreeNode(self.t) self.root = temp temp.children.insert(0, root) self._split_child(temp, 0) self._insert_non_full(temp, k) else: self._insert_non_full(root, k) def _split_child(self, x, i): t = self.t y = x.children[i] z = BTreeNode(y.t, y.leaf) x.children.insert(i + 1, z) x.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t) - 1] y.keys = y.keys[0:t - 1] if not y.leaf: z.children = y.children[t:(2 * t)] y.children = y.children[0:t - 1] def _insert_non_full(self, x, k): if x.leaf: x.keys.append(k) x.keys.sort() else: i = len(x.keys) - 1 while i >= 0 and k < x.keys[i]: i -= 1 i += 1 if len(x.children[i].keys) == (2 * self.t) - 1: self._split_child(x, i) if k > x.keys[i]: i += 1 self._insert_non_full(x.children[i], k) def count_keys(self) -> int: def _count_keys(node): count = len(node.keys) if not node.leaf: for child in node.children: count += _count_keys(child) return count return _count_keys(self.root) def find_min_key(self) -> int: current = self.root while not current.leaf: current = current.children[0] return current.keys[0] if current.keys else None def find_max_key(self) -> int: current = self.root while not current.leaf: current = current.children[-1] return current.keys[-1] if current.keys else None"},{"question":"You are required to implement a `CircularQueue` class using an array. A circular queue overcomes the memory wastage issue of a simple array-based queue by reusing the space once items are dequeued. Your implementation should strictly adhere to the FIFO principle and handle wraparounds effectively. Implement the following methods for the `CircularQueue` class: 1. `__init__(self, k: int)`: Initialize the circular queue with a given capacity `k`. 2. `enqueue(self, value: int) -> bool`: Insert an element into the circular queue. Return `True` if the operation is successful, `False` otherwise. 3. `dequeue(self) -> bool`: Delete an element from the circular queue. Return `True` if the operation is successful, `False` otherwise. 4. `front(self) -> int`: Get the front item from the queue. Return -1 if the queue is empty. 5. `rear(self) -> int`: Get the last item from the queue. Return -1 if the queue is empty. 6. `isEmpty(self) -> bool`: Check if the circular queue is empty. 7. `isFull(self) -> bool`: Check if the circular queue is full. # Constraints: - All integers are in the range 0 to 1000. - The initial capacity of the circular queue (`k`) is in the range 1 to 1000. - The queue is implemented using a fixed-size array. # Input/Output Format: - `__init__(k: int)` - Input: Integer `k` specifying the capacity of the circular queue. - `enqueue(value: int)` returns: Boolean (`True`/`False`) - `dequeue()` returns: Boolean (`True`/`False`) - `front()` returns: Integer (value or `-1` if empty) - `rear()` returns: Integer (value or `-1` if empty) - `isEmpty()` returns: Boolean (`True`/`False`) - `isFull()` returns: Boolean (`True`/`False`) # Example: ```python cq = CircularQueue(3) # Initialize a circular queue with capacity 3 print(cq.enqueue(1)) # Returns True print(cq.enqueue(2)) # Returns True print(cq.enqueue(3)) # Returns True print(cq.enqueue(4)) # Returns False (queue is full) print(cq.rear()) # Returns 3 print(cq.isFull()) # Returns True print(cq.dequeue()) # Returns True print(cq.enqueue(4)) # Returns True print(cq.rear()) # Returns 4 print(cq.front()) # Returns 2 ``` Your task is to complete the implementation of the above-specified methods for the `CircularQueue` class, ensuring the circular nature of the queue is maintained.","solution":"class CircularQueue: def __init__(self, k: int): Initialize the circular queue with a given capacity `k`. self.queue = [0] * k self.max_size = k self.front_idx = 0 self.rear_idx = -1 self.size = 0 def enqueue(self, value: int) -> bool: Insert an element into the circular queue. Return True if the operation is successful, False otherwise. if self.isFull(): return False self.rear_idx = (self.rear_idx + 1) % self.max_size self.queue[self.rear_idx] = value self.size += 1 return True def dequeue(self) -> bool: Delete an element from the circular queue. Return True if the operation is successful, False otherwise. if self.isEmpty(): return False self.front_idx = (self.front_idx + 1) % self.max_size self.size -= 1 return True def front(self) -> int: Get the front item from the queue. Return -1 if the queue is empty. if self.isEmpty(): return -1 return self.queue[self.front_idx] def rear(self) -> int: Get the last item from the queue. Return -1 if the queue is empty. if self.isEmpty(): return -1 return self.queue[self.rear_idx] def isEmpty(self) -> bool: Check if the circular queue is empty. return self.size == 0 def isFull(self) -> bool: Check if the circular queue is full. return self.size == self.max_size"},{"question":"# Decode Ways Challenge **Context:** A message containing letters from A-Z can be encoded as follows: - \'A\' -> 1 - \'B\' -> 2 - ... - \'Z\' -> 26 You are given an encoded message containing digits. Your task is to determine the total number of ways to decode it. For example, given the encoded message \\"12\\", it could be decoded as \\"AB\\" (1 2) or \\"L\\" (12), resulting in 2 possible ways. **Problem:** Write a function named `decode_ways` that takes a string `encoded_message` as input and returns the number of ways to decode it. **Function Signature:** ```python def decode_ways(encoded_message: str) -> int: pass ``` **Input:** * `encoded_message` (str): A non-empty string containing only numeric characters representing the encoded message. * Constraints: The string will be composed of digits and have a maximum length of 100. **Output:** * Returns an integer representing the number of ways to decode the given message. **Examples:** ```python assert decode_ways(\\"12\\") == 2 assert decode_ways(\\"226\\") == 3 assert decode_ways(\\"\\") == 0 ``` **Notes:** - \'0\' cannot be decoded. - Any substring that contains invalid mappings like \'30\', \'40\' (i.e., any number greater than 26 but not exactly 20 or 10) should result in 0 ways. **Edge Cases:** - Input string starts with \'0\'. - Input string contains invalid two-digit mappings such as \'30\', \'40\'. - Single-character input strings, e.g., \\"2\\". - Long encoded strings. Implement the function considering optimal time and space complexity.","solution":"def decode_ways(encoded_message: str) -> int: if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 if encoded_message[0] != \'0\' else 0 for i in range(2, n + 1): one_digit = int(encoded_message[i-1:i]) two_digits = int(encoded_message[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"You are given an encoded message containing digits, and your task is to determine the total number of ways to decode it based on the mapping \'A\'->1, \'B\'->2, ..., \'Z\'->26. **Function Signature**: ```python def decode_ways(encoded_message: str) -> int: pass ``` # Input: - `encoded_message` (string): encoded message containing digits from \'0\' to \'9\'. - Constraints: `1 <= len(encoded_message) <= 100`, `encoded_message` contains only digits without spaces or other characters. # Output: - (integer): the total number of ways to decode the message. # Constraints: - The encoded message will not start with \'0\'. - Segments like \'30\' or \'40\' are invalid. # Example: ```python assert decode_ways(\\"12\\") == 2 # \\"AB\\" (1 2) or \\"L\\" (12) assert decode_ways(\\"226\\") == 3 # \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6) assert decode_ways(\\"06\\") == 0 # No valid decoding as \'0\' can’t map alone ``` To solve this problem, follow these steps: 1. Check edge cases where the message is empty or starts with \'0\'. 2. Use dynamic programming to iterate through the string once. 3. Keep track of decoding ways for substrings using history of up to the last two decoded characters. 4. Ensure to handle segments of \'0\' correctly – they must be part of \'10\' or \'20\' and cannot stand alone. Implement the decode_ways function with the goal of evaluating students\' understanding of dynamic programming principles, attention to edge cases, and efficient solution structuring.","solution":"def decode_ways(encoded_message: str) -> int: if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) dp = [0] * (n + 1) dp[0] = 1 # Base case: empty string dp[1] = 1 # Base case: single character string (not \'0\') for i in range(2, n + 1): one_digit = int(encoded_message[i - 1]) two_digit = int(encoded_message[i - 2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i - 1] if 10 <= two_digit <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"You are tasked to implement a custom string reversal function using a recursive approach. The goal is to gain a deep understanding of recursion and manage its challenges. Function Signature ```python def custom_reverse(s: str) -> str: ``` Input * `s` : A string that needs to be reversed. Output * A new string which is the reversed version of the input string. Constraints * The input string\'s length should not exceed 10^4 characters. * You must ensure your implementation handles strings with special characters, digits and spaces. Performance Requirements * The solution should efficiently handle the worst-case scenario within the allowed input size. # Example ```python assert custom_reverse(\\"hello\\") == \\"olleh\\" assert custom_reverse(\\"world\\") == \\"dlrow\\" assert custom_reverse(\\"A man, a plan, a canal, Panama\\") == \\"amanaP ,lanac a ,nalp a ,nam A\\" assert custom_reverse(\\"\\") == \\"\\" assert custom_reverse(\\"s\\") == \\"s\\" ``` # Additional Notes * Consider any potential pitfalls with recursive depth, especially for large inputs. * Handle edge cases effectively: - Empty string. - Single-character string.","solution":"def custom_reverse(s: str) -> str: Recursively reverses the given string `s`. # base case: empty string or single character string if len(s) <= 1: return s # recursive case: the reverse of the string is the last character plus the reverse of the rest of the string return s[-1] + custom_reverse(s[:-1])"},{"question":"# Description Given a string `num` that contains only digits 0-9 and an integer `target`, write a function `find_expressions(num, target)` that returns all possible ways to insert binary operators (\'+\', \'-\', \'*\') between the digits so that the evaluated expression matches the target value. # Function Signature ```python def find_expressions(num: str, target: int) -> List[str]: pass ``` # Input * `num` - A string containing only digits (0-9). * `target` - An integer representing the required evaluation result. # Output * A list of strings representing the expressions that match the target value. # Constraints * 1 <= len(num) <= 10 * num consists of only digits (0-9). * The given target is within the range of a 32-bit integer. # Requirements * Your implementation should systematically generate all potential expressions. * Ensure the precedence of \'*\' over \'+\' and \'-\'. * Handle leading zeros appropriately. # Example ```python assert find_expressions(\\"123\\", 6) == [\\"1+2+3\\", \\"1*2*3\\"] assert find_expressions(\\"232\\", 8) == [\\"2*3+2\\", \\"2+3*2\\"] assert find_expressions(\\"105\\", 5) == [\\"1*0+5\\",\\"10-5\\"] assert find_expressions(\\"00\\", 0) == [\\"0+0\\", \\"0-0\\", \\"0*0\\"] assert find_expressions(\\"3456237490\\", 9191) == [] ``` # Scenario * You are creating an interactive educational tool to help students understand the insertion of arithmetic operators to form valid expressions equating to a target value. Your tool should evaluate whether student-provided expressions correctly solve the posed problem.","solution":"from typing import List def find_expressions(num: str, target: int) -> List[str]: def helper(path: str, pos: int, evaluated: int, prev: int): # If we have reached the end of the string, check if the current evaluated value is the target if pos == len(num): if evaluated == target: results.append(path) return for i in range(pos, len(num)): # Avoid numbers with leading zeros if i != pos and num[pos] == \'0\': break # The current number segment current_str = num[pos:i+1] current_num = int(current_str) if pos == 0: # First number, start the path helper(current_str, i + 1, current_num, current_num) else: # Try addition helper(path + \'+\' + current_str, i + 1, evaluated + current_num, current_num) # Try subtraction helper(path + \'-\' + current_str, i + 1, evaluated - current_num, -current_num) # Try multiplication helper(path + \'*\' + current_str, i + 1, evaluated - prev + prev * current_num, prev * current_num) results = [] helper(\\"\\", 0, 0, 0) return results"},{"question":"# Scenario: You are working on implementing a self-balancing AVL tree for a system that requires efficient insertions and lookups. Your task is to practice implementing the insertion and traversal operations for the AVL tree. # Task: Implement the `insert` method and `in_order_traverse` method for the AVL Tree, ensuring that the tree remains balanced after each insertion. The `in_order_traverse` method should return the elements in ascending order. # Requirements: 1. **Insert Method:** - Insert a given key into the AVL tree while maintaining its balance. - You might need to update the heights and balance factors and perform rotations accordingly. 2. **In order Traversal:** - The method should perform an in-order traversal of the AVL tree and return a list of sorted elements. # Input: - For the `insert` method: Integer key to be inserted into the AVL tree. - For the `in_order_traverse` method: No input (operate on the current tree structure). # Output: - For the `insert` method: No output, perform the insertion operation only. - For the `in_order_traverse` method: Return a list of integers representing the elements in the AVL tree, in ascending order. # Constraints: - You can assume the keys are integers within the range of -10^6 to 10^6. - The maximum number of elements that the AVL tree will hold is 10^5. # Performance Requirements: - The `insert` method should have a time complexity of O(log n), where n is the number of nodes in the AVL Tree. - The `in_order_traverse` method should have a time complexity of O(n). Here is the class definition you need to complete: ```python class TreeNode: def __init__(self, key): self.val = key self.left = None self.right = None class AvlTree(object): def __init__(self): self.node = None self.height = -1 self.balance = 0 def insert(self, key): Insert new key into AVL tree Arguments: key -- integer, key to be inserted # Implement this method def in_order_traverse(self): In-order traversal of the AVL tree. Returns a list of integers. # Implement this method # Add any additional methods if needed (like rotations, balance updates, etc.) ``` # Example: ```python tree = AvlTree() tree.insert(10) tree.insert(20) tree.insert(30) tree.insert(40) tree.insert(50) print(tree.in_order_traverse()) # Output: [10, 20, 30, 40, 50] tree.insert(25) print(tree.in_order_traverse()) # Output: [10, 20, 25, 30, 40, 50] ``` # Notes: - Make sure to handle the balancing with rotations appropriately. - Ensure the in-order traversal returns the list in a sorted order of the inserted keys.","solution":"class TreeNode: def __init__(self, key): self.val = key self.left = None self.right = None self.height = 1 # Height of node starts from 1 class AvlTree(object): def __init__(self): self.root = None def insert(self, key): Insert new key into AVL tree Arguments: key -- integer, key to be inserted def insert_recursive(node, key): if not node: return TreeNode(key) elif key < node.val: node.left = insert_recursive(node.left, key) else: node.right = insert_recursive(node.right, key) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) balance = self.get_balance(node) # Balance the tree # Left Left Case if balance > 1 and key < node.left.val: return self.right_rotate(node) # Right Right Case if balance < -1 and key > node.right.val: return self.left_rotate(node) # Left Right Case if balance > 1 and key > node.left.val: node.left = self.left_rotate(node.left) return self.right_rotate(node) # Right Left Case if balance < -1 and key < node.right.val: node.right = self.right_rotate(node.right) return self.left_rotate(node) return node self.root = insert_recursive(self.root, key) def in_order_traverse(self): In-order traversal of the AVL tree. Returns a list of integers. result = [] def in_order(node): if node: in_order(node.left) result.append(node.val) in_order(node.right) in_order(self.root) return result def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def get_height(self, node): if not node: return 0 return node.height def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right)"},{"question":"Sort a List with Gnome Sort You are given a list of integers. Your task is to implement the `gnome_sort` function that sorts the list using the Gnome Sort algorithm. Function Signature ```python def gnome_sort(arr: List[int]) -> List[int]: ``` # Input - A list of integers, `arr` (0 <= len(arr) <= 10^4). # Output - A sorted list of integers in ascending order. # Constraints - The function must use the Gnome Sort algorithm. - Sorting must be done in-place, using O(1) additional space. # Example Input ```python arr = [34, 2, 23, 78, 54, 10] ``` Output ```python [2, 10, 23, 34, 54, 78] ``` # Explanation Starting from the beginning of the list, the function compares adjacent elements and swaps them if they are in the incorrect order. It continues this process, moving backward if it performed a swap, until it reaches the end of the list. # Notes - Handle edge cases such as an empty list or a single-element list gracefully. - Ensure the function is efficient enough to handle lists with up to 10,000 elements within a reasonable time frame.","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: Sorts a given list using the Gnome Sort algorithm. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"**Scenario**: You are working on a data analysis project, and one of the tasks is to identify the most commonly occurring elements in a given dataset of numerical values. This information is crucial for understanding the predominant trends and making data-driven decisions. **Task**: Write a function `find_modes` that takes an array of integers and returns a list of the most frequent elements. If multiple elements have the same highest frequency, the function should return all of them. # Function Signature ```python def find_modes(arr: List[int]) -> List[int]: This function finds and returns the mode(s) of a given list of integers. Parameters: arr (List[int]): List of integers to be analyzed. Returns: List[int]: List of integers that are the mode(s) of the array. ``` # Input * An array `arr` of `n` integers where `1 <= n <= 10^5`. # Output * A list of integers containing the mode(s) of the input array. # Constraints 1. The input array can contain both positive and negative integers. 2. There will always be at least one mode. 3. The algorithm should operate within O(n) time complexity. # Example ```python assert find_modes([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_modes([4, 4, 4, 5, 5, 5, 6]) == [4, 5] assert find_modes([10, 10, -1, -1, 2]) == [10, -1] assert find_modes([1]) == [1] assert find_modes([]) == [] ``` **Hint**: Consider using a dictionary to keep track of the frequency of each element in the array.","solution":"from typing import List from collections import Counter def find_modes(arr: List[int]) -> List[int]: This function finds and returns the mode(s) of a given list of integers. Parameters: arr (List[int]): List of integers to be analyzed. Returns: List[int]: List of integers that are the mode(s) of the array. if not arr: return [] # Use Counter to count the frequency of each element count = Counter(arr) # Find the highest frequency max_freq = max(count.values()) # Extract all elements that have the highest frequency modes = [key for key, freq in count.items() if freq == max_freq] return modes"},{"question":"# Question You are given access to a node in a singly linked list. Write a function `delete_node(node)` that removes this node from the linked list. You are guaranteed that the node is neither the first node nor the last node in the list and you do not have access to the head of the linked list. The function should have the following signature: ```python def delete_node(node: Node) -> None: pass ``` Input: * `node`: A node object that is an instance of the `Node` class. * `Node` class is defined as: ```python class Node: def __init__(self, x): self.val = x self.next = None ``` Output: * The function should not return anything. It modifies the linked list in place. Constraints: * You cannot modify any other nodes in the linked list except the node being deleted and potentially the node following it. * The function should not use any extra space beyond a couple of variables, i.e., O(1) space complexity. * The time complexity of the function should be O(1). Example: Suppose the linked list is `1 -> 2 -> 3 -> 4 -> 5` and you are given access to the third node with value `3`. After calling `delete_node(node)`, the linked list should become `1 -> 2 -> 4 -> 5`. Test: You can use the following test case in a test suite to validate your solution. ```python class TestSuite(unittest.TestCase): def test_delete_node(self): # make linkedlist 1 -> 2 -> 3 -> 4 -> 5 head = Node(1) curr = head for i in range(2, 6): curr.next = Node(i) curr = curr.next # node3 = 3 node3 = head.next.next # after delete_node => 1 -> 2 -> 4 -> 5 delete_node(node3) curr = head self.assertEqual(1, curr.val) curr = curr.next self.assertEqual(2, curr.val) curr = curr.next self.assertEqual(4, curr.val) curr = curr.next self.assertEqual(5, curr.val) tail = curr self.assertIsNone(tail.next) ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node: Node) -> None: Replace the value and pointer of the node to be deleted with the value and pointer of the next node in the list. if node is None or node.next is None: raise ValueError(\\"The node to be deleted is invalid or has no next node.\\") next_node = node.next node.val = next_node.val node.next = next_node.next next_node.next = None # optional: help GC by removing reference from the old node"},{"question":"# Bogo Sort Improved - Coding Challenge Scenario: You work as a software engineer at a company that produces educational tools. Your task is to develop a more efficient, albeit still humorous, variant of the Bogo Sort algorithm named **Optimized Bogo Sort**. It should retain the \\"random shuffle until sorted\\" nature but demonstrate an understanding of improving inefficiencies. Specifically, you\'ll implement an optimization that shuffles the array less frequently when it is already nearly sorted. Task: Write a function `optimized_bogo_sort` to sort a list of integers following these steps: 1. Implement a randomized swap strategy for sorting. 2. On each iteration, only shuffle adjacent elements with a certain probability if they are out of order, reducing the randomness over time if the array becomes more sorted. The function should have the following signature: ```python def optimized_bogo_sort(arr: List[int]) -> List[int] ``` Input: - A list of integers `arr` (length ( n leq 100 )). Output: - A sorted list of integers. Constraint: - You must use a probabilistic shuffling approach to reduce the overall number of shuffles. - The function must terminate and return the sorted list. Performance Requirement: - While still inefficient, the implementation should improve upon the pure Bogo Sort in expected performance, intelligently reducing unproductive shuffling. Here is an example of the initial behavior that your implementation should adopt (additional enhancements are encouraged): 1. Shuffle probability decreases as elements become closer to sorted order. Example: ```python import random def optimized_bogo_sort(arr): # Define your function here with the improved logic def is_sorted(arr): for i in range(len(arr)-1): if arr[i] > arr[i+1]: return False return True while not is_sorted(arr): for i in range(len(arr)-1): if arr[i] > arr[i+1]: # Swap elements with a probability that decreases over time if random.random() > 0.5: # or any other heuristic arr[i], arr[i+1] = arr[i+1], arr[i] return arr # Test the function arr = [3, 2, 5, 1, 4] print(optimized_bogo_sort(arr)) ```","solution":"import random from typing import List def optimized_bogo_sort(arr: List[int]) -> List[int]: Sorts the list using an optimized variant of Bogo Sort. def is_sorted(arr): for i in range(len(arr)-1): if arr[i] > arr[i+1]: return False return True attempts = 0 while not is_sorted(arr): for i in range(len(arr)-1): if arr[i] > arr[i+1]: # Swap elements with a probability that decreases over time if random.random() > 0.2 + attempts * 0.01: arr[i], arr[i+1] = arr[i+1], arr[i] attempts += 1 return arr"},{"question":"# Merge Sort Implementation Challenge **Scenario**: You are tasked with optimizing a large dataset processing system. Given that stable, consistent sorting is crucial to preserve the integrity of records, you decide to implement the Merge Sort algorithm. The primary requirement is to sort an array of integers. **Task**: Implement the `merge_sort` algorithm along with an optimized `merge` function. **Specifications**: * **Input**: * `arr`: A list of integers that need to be sorted. The length of the list is between 0 and 10^5. * **Output**: * A sorted list of integers in ascending order. **Constraints**: * The algorithm must achieve O(n log n) time complexity. * The algorithm must maintain stable sorting. * Direct usage of Python\'s built-in sorting is not permitted. **Performance Requirements**: * Minimize auxiliary space usage where possible. **Function Signatures**: * You must implement: ```python def merge_sort(arr): # Your code goes here def merge(left, right, merged): # Your code goes here ``` **Example**: ```python assert merge_sort([38, 27, 43, 3, 9, 82, 10]) == [3, 9, 10, 27, 38, 43, 82] assert merge_sort([5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9] assert merge_sort([]) == [] assert merge_sort([1]) == [1] ```","solution":"def merge_sort(arr): Sorts the array `arr` using the merge sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): Merges two sorted lists `left` and `right` into a single sorted list. merged = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 while left_index < len(left): merged.append(left[left_index]) left_index += 1 while right_index < len(right): merged.append(right[right_index]) right_index += 1 return merged"},{"question":"**Question**: Implement an efficient algorithm to sort an array of integers. Describe the algorithm clearly and ensure it handles various edge cases effectively. # Objective Given the inefficiency of Bogo Sort, demonstrate an understanding of more efficient sorting algorithms by implementing an optimized sorting function. # Requirements * Implement a sorting function `optimized_sort(arr)` that sorts the input list of integers in ascending order. * You may use any efficient sorting algorithm (e.g., Merge Sort, Quick Sort, Heap Sort). * Analyze and explain the choice of sorting algorithm, its time complexity, and space complexity. # Input and Output Format **Input**: A list `arr` of `n` integers, where `0 ≤ n ≤ 10^6` and `-10^9 ≤ arr[i] ≤ 10^9`. **Output**: The sorted list of integers in ascending order. # Constraints and Performance Requirements * The solution should handle lists containing up to 10^6 integers efficiently. * The algorithm should be able to handle edge cases effectively (e.g., lists with negative numbers, duplicate values, already sorted lists). # Example **Example Input**: ```python arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] ``` **Example Output**: ```python [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` # Analysis Describe the algorithm, its time complexity, space complexity, and reasons for choosing it. Ensure the description includes potential pitfalls and optimizations used in the implementation.","solution":"def optimized_sort(arr): Sorts an input list of integers in ascending order using the Quick Sort algorithm. # Base case: if the list is empty or has one element, it is already sorted if len(arr) <= 1: return arr # Choose the pivot as the middle element of the list pivot = arr[len(arr) // 2] # Partition the list into three parts: less than, equal to, and greater than the pivot less = [x for x in arr if x < pivot] equal = [x for x in arr if x == pivot] greater = [x for x in arr if x > pivot] # Recursively sort the \'less\' and \'greater\' lists, then concatenate all three parts return optimized_sort(less) + equal + optimized_sort(greater) # Explanation: # Quick Sort is chosen for its average-case O(n log n) time complexity, which is efficient for large datasets. # It has a worst-case time complexity of O(n^2), but with good pivot selection (e.g., median of the array), it performs well in practice. # Quick Sort uses O(log n) space complexity due to the recursive stack space."},{"question":"You are tasked with implementing an additional method for both `ArrayStack` and `LinkedListStack` classes to return all elements in the stack as a Python list from top to bottom. This method should be named `to_list()`. Ensure that your implementation maintains the integrity and behaviors expected of the stack. # Function Signature: ```python class ArrayStack(AbstractStack): def to_list(self) -> list: pass class LinkedListStack(AbstractStack): def to_list(self) -> list: pass ``` # Constraints: 1. The elements should be returned in a list from the top element to the bottom element. 2. The method should have a time complexity of O(n) where n is the number of elements in the stack. 3. The stack should not be modified after the method execution. # Example: ```python # ArrayStack example stack = ArrayStack() stack.push(1) stack.push(2) stack.push(3) print(stack.to_list()) # Output: [3, 2, 1] # LinkedListStack example stack = LinkedListStack() stack.push(4) stack.push(5) stack.push(6) print(stack.to_list()) # Output: [6, 5, 4] ``` (Note: Assume the necessary classes and methods (`push`, `pop`, `peek`, `is_empty`) are already defined as given in the snippet).","solution":"class AbstractStack: def push(self, value): raise NotImplementedError def pop(self): raise NotImplementedError def peek(self): raise NotImplementedError def is_empty(self): raise NotImplementedError class ArrayStack(AbstractStack): def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def is_empty(self): return len(self.stack) == 0 def to_list(self): Returns a list of elements in the stack from top to bottom. # Return the reversed list since the last element in the list # is the top of the stack return self.stack[::-1] class Node: def __init__(self, value=None, next=None): self.value = value self.next = next class LinkedListStack(AbstractStack): def __init__(self): self.head = None def push(self, value): new_node = Node(value, self.head) self.head = new_node def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") popped_value = self.head.value self.head = self.head.next return popped_value def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.head.value def is_empty(self): return self.head is None def to_list(self): Returns a list of elements in the stack from top to bottom. result = [] current = self.head while current: result.append(current.value) current = current.next # The elements are collected from top to bottom return result"},{"question":"# Coding Challenge: Three-Array Combinatorial Sum Objective: Given three arrays of integers `A`, `B`, and `C`, and an integer `target`, write a function `find_combinations` that finds all unique three-element combinations (taking one element from each array) that sum up to the `target`. Input: - Three arrays of integers: `A`, `B`, and `C`. - An integer `target`. Output: - A list of lists, where each sublist is a unique combination of three integers (one from each array) that sums up to `target`. Constraints: - All input arrays contain at most 1000 elements. - Elements within each array are integers within the range -10^6 to 10^6. Performance Requirements: - The function should be efficient enough to handle large lists within the given constraints. - Aim to reduce the total number of combinations checked as much as possible. Example: ```python A = [1, 2, 3, 3] B = [2, 3, 3, 4] C = [2, 3, 3, 4] target = 7 find_combinations(A, B, C, target) # Output: [[1, 2, 4], [1, 3, 3], [2, 2, 3], [1, 4, 2], [2, 3, 2], [3, 2, 2]] ``` Implementation Notes: - Ensure all output combinations are unique. - Account for possible duplicate elements within the input arrays. - Consider edge cases like empty arrays and when no valid combination is found. ```python def find_combinations(A, B, C, target): # Your implementation here. pass # Sample Usage: A = [1, 2, 3, 3] B = [2, 3, 3, 4] C = [2, 3, 3, 4] target = 7 print(find_combinations(A, B, C, target)) ```","solution":"def find_combinations(A, B, C, target): Finds all unique three-element combinations taking one element from each of the arrays A, B, and C that sum up to the target value. seen_combinations = set() result = [] for a in A: for b in B: for c in C: if a + b + c == target: combination = tuple(sorted([a, b, c])) if combination not in seen_combinations: seen_combinations.add(combination) result.append([a, b, c]) return result"},{"question":"# Question Context You are given a directed graph represented as an adjacency list. Your task is to determine if there exists a path between two specified nodes (source and target) in the graph. The graph may have cycles and disconnected components. Task Implement a function `is_reachable(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool` that returns `True` if there is a path from the `source` node to the `target` node, and `False` otherwise. Input 1. `vertex_count` (int): The total number of vertices in the graph (0-indexed). 2. `edges` (List[Tuple[int, int]]): A list of edges where each edge is represented as a tuple (source, target), indicating a directed edge from source to target. 3. `source` (int): The starting node for the path. 4. `target` (int): The end node for the path. Output * `bool`: A boolean value `True` if there is a path from `source` to `target`, and `False` otherwise. Constraints * Assume 0 ≤ source, target < vertex_count. * The graph may contain up to 10,000 vertices and 50,000 edges. Examples ```python def is_reachable(vertex_count, edges, source, target): from collections import defaultdict graph = defaultdict(list) for edge in edges: graph[edge[0]].append(edge[1]) def dfs(node): if node == target: return True visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor): return True return False visited = set() return dfs(source) # Example 1 vertex_count = 4 edges = [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)] source = 1 target = 3 print(is_reachable(vertex_count, edges, source, target)) # Output: True # Example 2 vertex_count = 4 edges = [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)] source = 3 target = 1 print(is_reachable(vertex_count, edges, source, target)) # Output: False ``` Performance Requirements * Aim for a time complexity of O(V + E) and a space complexity of O(V).","solution":"from typing import List, Tuple from collections import defaultdict, deque def is_reachable(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: Determines if there is a path from source to target in a given graph. :param vertex_count: Total number of vertices in the graph (0-indexed). :param edges: A list of edges where each edge is a tuple (source, target). :param source: The starting node for the path. :param target: The end node for the path. :return: True if there is a path from source to target, False otherwise. graph = defaultdict(list) for edge in edges: graph[edge[0]].append(edge[1]) def bfs(start): queue = deque([start]) visited = set() while queue: node = queue.popleft() if node == target: return True if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return False return bfs(source)"},{"question":"# Regular Expression Matching You are to implement a function `is_match` that determines whether a given input string matches a given pattern. The pattern could include the characters `.` and `*`, where: * `.` matches any single character. * `*` matches zero or more of the preceding element. The matching should cover the entire input string (not just a part of it). Function Signature ```python def is_match(s: str, p: str) -> bool: ``` Input * `s` (string): the input string containing only lowercase letters. * `p` (string): the pattern string containing only lowercase letters, `.` and `*`. Output * Returns `True` if `s` matches the pattern `p`. Otherwise, returns `False`. Constraints * `0 <= len(s) <= 1000` * `0 <= len(p) <= 1000` Examples ```python is_match(\\"aa\\",\\"a\\") → False is_match(\\"aa\\",\\"aa\\") → True is_match(\\"aaa\\",\\"aa\\") → False is_match(\\"aa\\", \\"a*\\") → True is_match(\\"aa\\", \\".*\\") → True is_match(\\"ab\\", \\".*\\") → True is_match(\\"aab\\", \\"c*a*b\\") → True ``` Your task is to implement the function `is_match` to solve the problem based on the given description and constraints.","solution":"def is_match(s: str, p: str) -> bool: Determines if the input string s matches the pattern p. Pattern p can include \'.\' which matches any single character and \'*\' which matches zero or more of the preceding element. dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Handle patterns like a*, a*b*, a*b*c* which can match empty string for j in range(2, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (p[j - 2] == s[i - 1] or p[j - 2] == \'.\')) return dp[len(s)][len(p)]"},{"question":"# Question: You are tasked to enhance and expand the existing function `pythagoras` to meet the following requirements: 1. Improve the current input validation. Ensure that the function raises appropriate errors if more than one side is unknown or if any non-positive values are provided (as these are geometrically invalid for a triangle). 2. Extend the function to handle cases where all three sides are provided and confirm whether they form a right-angled triangle. 3. Follow the existing format for the output strings while ensuring the results are rounded to two decimal places for better readability. Function Signature: ```python def pythagoras(opposite, adjacent, hypotenuse): Returns length of the third side of a right-angled triangle or verifies the triangle if all sides are provided. Passing \\"?\\" will indicate the unknown side. pass ``` Input: * `opposite` - length of the opposite side (integer or float or \\"?\\"). * `adjacent` - length of the adjacent side (integer or float or \\"?\\"). * `hypotenuse` - length of the hypotenuse (integer or float or \\"?\\"). Output: * A string indicating the calculated length of the unknown side, rounded to two decimal places. * If all sides are known, a string verifying whether they form a right-angled triangle or not. Constraints: 1. Only one side can be `\\"?\\"`. 2. All numeric inputs should be positive. 3. Ensure the result is correct to two decimal places. Examples: ```python # Example 1: # Input: opposite=3, adjacent=4, hypotenuse=\\"?\\" # Output: \\"Hypotenuse = 5.00\\" # Example 2: # Input: opposite=\\"?\\", adjacent=4, hypotenuse=5 # Output: \\"Opposite = 3.00\\" # Example 3: # Input: opposite=3, adjacent=4, hypotenuse=5 # Output: \\"The given sides form a right-angled triangle\\" # Example 4: # Input: opposite=3, adjacent=4, hypotenuse=6 # Output: \\"The given sides do not form a right-angled triangle\\" # Example 5: # Input: opposite=3, adjacent=\\"?\\", hypotenuse=5 # Output: \\"Adjacent = 4.00\\" ```","solution":"import math def pythagoras(opposite, adjacent, hypotenuse): Returns length of the third side of a right-angled triangle or verifies the triangle if all sides are provided. Passing \\"?\\" will indicate the unknown side. values = [opposite, adjacent, hypotenuse] # Ensure only one value is unknown if values.count(\\"?\\") > 1: raise ValueError(\\"Only one side can be unknown.\\") # Ensure all numeric values are positive for value in values: if value != \\"?\\" and value <= 0: raise ValueError(\\"All numeric inputs should be positive.\\") if hypotenuse == \\"?\\": # Calculate hypotenuse result = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {result:.2f}\\" elif opposite == \\"?\\": # Calculate opposite side result = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {result:.2f}\\" elif adjacent == \\"?\\": # Calculate adjacent side result = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {result:.2f}\\" else: # Verify if all sides form a right-angled triangle if math.isclose(hypotenuse**2, opposite**2 + adjacent**2, rel_tol=1e-9): return \\"The given sides form a right-angled triangle\\" else: return \\"The given sides do not form a right-angled triangle\\""},{"question":"# Task Description Given the implementation of a basic Binary Search Tree (BST), enhance it to handle the scenario of maintaining the balance of the tree. You need to implement an AVL Tree (a self-balancing binary search tree) which ensures the tree height is balanced after each insertion. # Function Requirements Methods to Implement 1. **insert(data):** Insert data into the AVL Tree. 2. **search(data):** Search for data in the AVL Tree, returning True if found, else False. 3. **size():** Return the number of elements in the AVL Tree. 4. **order_traversal(traversal_type=\'inorder\'):** Return a list of elements in the specified traversal order (`inorder`, `preorder`, `postorder`). # Input and Output Formats * `insert(data: int) -> None` * `search(data: int) -> bool` * `size() -> int` * `order_traversal(traversal_type: str = \'inorder\') -> List[int]` # Constraints 1. Elements will be distinct integers. 2. Traversal types can be either `inorder`, `preorder`, or `postorder`. # Performance Requirements The operations (insertion and search) should maintain an average time complexity of O(log N). # Scenario and Context Imagine you\'re developing a software system that requires handling a balanced data structure to ensure optimal performance of insert and lookup operations. The balanced tree helps in maintaining efficient data retrieval and storage. ```python class AVLNode: def __init__(self, data): self.data = data self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, data): pass def search(self, data): pass def size(self): pass def order_traversal(self, traversal_type=\'inorder\'): pass # Your implementation here! # Example Tests (unittest) import unittest class TestAVLTree(unittest.TestCase): def setUp(self): self.tree = AVLTree() def test_insert_search_size(self): elements = [30, 20, 40, 10, 25, 35, 50, 5, 15, 27, 45, 60] for elem in elements: self.tree.insert(elem) self.assertTrue(self.tree.search(25)) self.assertFalse(self.tree.search(100)) self.assertEqual(self.tree.size(), len(elements)) def test_traversal(self): elements = [30, 20, 40, 10, 25, 35, 50] for elem in elements: self.tree.insert(elem) self.assertEqual(self.tree.order_traversal(\'inorder\'), [10, 20, 25, 30, 35, 40, 50]) self.assertEqual(self.tree.order_traversal(\'preorder\'), [30, 20, 10, 25, 40, 35, 50]) self.assertEqual(self.tree.order_traversal(\'postorder\'), [10, 25, 20, 35, 50, 40, 30]) if __name__ == \'__main__\': unittest.main() ``` # Important Notes Ensure the AVL Tree remains balanced after each insertion by rotating nodes accordingly.","solution":"class AVLNode: def __init__(self, data): self.data = data self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None self._size = 0 def insert(self, data): if not self.root: self.root = AVLNode(data) else: self.root = self._insert(self.root, data) self._size += 1 def _insert(self, node, data): if not node: return AVLNode(data) if data < node.data: node.left = self._insert(node.left, data) else: node.right = self._insert(node.right, data) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and data < node.left.data: return self._right_rotate(node) if balance < -1 and data > node.right.data: return self._left_rotate(node) if balance > 1 and data > node.left.data: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and data < node.right.data: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def search(self, data): return self._search(self.root, data) def _search(self, node, data): if not node: return False if data == node.data: return True elif data < node.data: return self._search(node.left, data) else: return self._search(node.right, data) def size(self): return self._size def order_traversal(self, traversal_type=\'inorder\'): if traversal_type == \'inorder\': return self._inorder_traversal(self.root, []) elif traversal_type == \'preorder\': return self._preorder_traversal(self.root, []) elif traversal_type == \'postorder\': return self._postorder_traversal(self.root, []) def _inorder_traversal(self, node, traversal): if node: self._inorder_traversal(node.left, traversal) traversal.append(node.data) self._inorder_traversal(node.right, traversal) return traversal def _preorder_traversal(self, node, traversal): if node: traversal.append(node.data) self._preorder_traversal(node.left, traversal) self._preorder_traversal(node.right, traversal) return traversal def _postorder_traversal(self, node, traversal): if node: self._postorder_traversal(node.left, traversal) self._postorder_traversal(node.right, traversal) traversal.append(node.data) return traversal def _get_height(self, node): return node.height if node else 0 def _get_balance(self, node): return self._get_height(node.left) - self._get_height(node.right) if node else 0 def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y"},{"question":"Binary Tree Path Summation In this question, you are required to write a function that computes all the root-to-leaf paths in a given binary tree and returns their respective path summations. Problem Statement Given the root of a binary tree, you need to implement a function `binary_tree_path_sums(root) -> List[int]` that finds all root-to-leaf paths and returns a list of integers, where each integer represents the sum of node values along a root-to-leaf path. Each node in the binary tree contains a single integer value. # Example Consider the following binary tree: ``` 1 / 2 3 / 4 5 6 ``` The root-to-leaf paths in this tree are: * 1 -> 2 -> 4 * 1 -> 2 -> 5 * 1 -> 3 -> 6 The corresponding path sums would be: * 7 (1+2+4) * 8 (1+2+5) * 10 (1+3+6) Therefore, the call `binary_tree_path_sums(root)` should return `[7, 8, 10]`. # Input Format * The input is a binary tree node (the root of the tree). Each node is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output Format * The function should return a list of integers. # Constraints * The number of nodes in the tree is in the range [0, 1000]. * The values of the nodes are in the range [-1000, 1000]. # Implementation Requirements * Utilize Depth-First Search (DFS) to traverse the tree. * Consider edge cases like empty trees and trees with a single node. * Ensure the solution is efficient in terms of both time and space complexity. Good luck!","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_path_sums(root: Optional[TreeNode]) -> List[int]: def dfs(node, path_sum): if not node: return path_sum += node.val if not node.left and not node.right: # It\'s a leaf results.append(path_sum) return dfs(node.left, path_sum) dfs(node.right, path_sum) results = [] dfs(root, 0) return results"},{"question":"# B-Tree Implementation Enhancement: Efficient Deletion **Context**: B-Trees are used in various systems to handle large datasets efficiently. One key operation of B-Trees is deletion, where a key can be removed while maintaining the tree\'s balanced nature. Implementing efficient deletion is crucial to ensure that repeated deletions do not degrade performance. **Task**: Enhance the provided B-Tree implementation by modifying the `remove_key` function to handle cases where keys inside non-leaf nodes are repeatedly deleted. Ensure that the tree remains balanced while minimizing unnecessary split and merge operations. # Function Specification **Function**: `remove_key` **Input**: - `self` - Instance of the BTree. - `key` - Key to be removed from the BTree. **Output**: - The function updates the BTree by removing the specified key. The function should not return anything. # Constraints - The BTree will contain integer keys. - All keys in the BTree are unique. - The degree `t` of the BTree will be greater than or equal to 2. # Example Given a BTree instance `btree` with degree 2, populated with keys `[1,2,3,4,5,6,7,8,9]`: 1. `btree.remove_key(6)`: After removal, node keys should be rearranged, maintaining balance. 2. `btree.remove_key(4)`: Ensure remaining keys are in proper order and tree remains balanced. # Edge Cases 1. Removing a key from a leaf node that does not affect tree balance. 2. Removing a key where the node has the minimum number of keys and must undermerge siblings. # Performance Requirements Ensure the function operates in `O(log n)` time complexity. Note: Focus on enhancing the efficiency of the deletion algorithm. Other parts of the BTree implementation can remain unchanged.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] class BTree: def __init__(self, t): self.root = BTreeNode(t, leaf=True) self.t = t def traverse(self): keys = [] self._traverse(self.root, keys) return keys def _traverse(self, node, keys): i = 0 while i < len(node.keys): if not node.leaf: self._traverse(node.children[i], keys) keys.append(node.keys[i]) i += 1 if not node.leaf: self._traverse(node.children[i], keys) def search(self, k, x=None): if x is None: x = self.root i = 0 while i < len(x.keys) and k > x.keys[i]: i += 1 if i < len(x.keys) and k == x.keys[i]: return (x, i) if x.leaf: return None else: return self.search(k, x.children[i]) def insert(self, k): root = self.root if len(root.keys) == (2*self.t) - 1: temp = BTreeNode(self.t) self.root = temp temp.children.insert(0, root) self._split_child(temp, 0) self._insert_non_full(temp, k) else: self._insert_non_full(root, k) def _split_child(self, x, i): t = self.t y = x.children[i] z = BTreeNode(t, y.leaf) x.children.insert(i + 1, z) x.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t: (2*t) - 1] y.keys = y.keys[0: t - 1] if not y.leaf: z.children = y.children[t: 2*t] y.children = y.children[0: t] def _insert_non_full(self, x, k): i = len(x.keys) - 1 if x.leaf: x.keys.append(0) while i >= 0 and k < x.keys[i]: x.keys[i + 1] = x.keys[i] i -= 1 x.keys[i + 1] = k else: while i >= 0 and k < x.keys[i]: i -= 1 i += 1 if len(x.children[i].keys) == (2*self.t) - 1: self._split_child(x, i) if k > x.keys[i]: i += 1 self._insert_non_full(x.children[i], k) def remove_key(self, k): self._remove(self.root, k) if len(self.root.keys) == 0: if not self.root.leaf: self.root = self.root.children[0] else: self.root = BTreeNode(self.t, leaf=True) def _remove(self, x, k): t = self.t if x.leaf: if k in x.keys: x.keys.remove(k) return for i, key in enumerate(x.keys): if key == k: if x.leaf: x.keys.pop(i) elif len(x.children[i].keys) >= t: x.keys[i] = self._get_predecessor(x, i) self._remove(x.children[i], x.keys[i]) elif len(x.children[i + 1].keys) >= t: x.keys[i] = self._get_successor(x, i) self._remove(x.children[i + 1], x.keys[i]) else: self._merge(x, i) self._remove(x.children[i], k) return for i, key in enumerate(x.keys): if k < key: if len(x.children[i].keys) >= t: self._remove(x.children[i], k) else: if i > 0 and len(x.children[i - 1].keys) >= t: self._borrow_from_prev(x, i) elif i < len(x.keys) and len(x.children[i + 1].keys) >= t: self._borrow_from_next(x, i) else: if i != len(x.keys): self._merge(x, i) else: self._merge(x, i - 1) self._remove(x.children[i if len(x.children[i].keys) < t else i - 1], k) return if not x.leaf: self._remove(x.children[len(x.keys)], k) def _get_predecessor(self, x, i): current = x.children[i] while not current.leaf: current = current.children[-1] return current.keys[-1] def _get_successor(self, x, i): current = x.children[i + 1] while not current.leaf: current = current.children[0] return current.keys[0] def _merge(self, x, i): t = self.t child = x.children[i] sibling = x.children[i + 1] child.keys.append(x.keys[i]) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) x.keys.pop(i) x.children.pop(i + 1) def _borrow_from_prev(self, x, i): child = x.children[i] sibling = x.children[i - 1] child.keys.insert(0, x.keys[i - 1]) if not child.leaf: child.children.insert(0, sibling.children.pop(-1)) x.keys[i - 1] = sibling.keys.pop(-1) def _borrow_from_next(self, x, i): child = x.children[i] sibling = x.children[i + 1] child.keys.append(x.keys[i]) if not child.leaf: child.children.append(sibling.children.pop(0)) x.keys[i] = sibling.keys.pop(0)"},{"question":"# Wiggle Sort Problem Scenario You are working as a software developer for a company that processes large volumes of numeric data. Your goal is to ensure that certain datasets follow a specific non-monotonic pattern for better visualization and data presentation. You need a function that can convert an unsorted array of integers into a \\"wiggle\\" format to meet the presentation standards. Requirements Write a Python function `wiggle_sort(nums)` that reorders a given array `nums` such that every even-indexed element is less than or equal to the following odd-indexed element, and every odd-indexed element is greater than or equal to the following even-indexed element. Function Signature ```python def wiggle_sort(nums: List[int]) -> None: Modify nums to follow the wiggle pattern in place. Args: nums (List[int]): The input list of integers to be reordered. Returns: None: This function should modify the list in place. ``` Input - A list of integers `nums` (0 ≤ len(nums) ≤ 10^4) Output - The given list should be modified in place to follow the wiggle pattern. The function does not return anything. Example ```python nums = [3, 5, 2, 1, 6, 4] wiggle_sort(nums) print(nums) # Output can vary, one possible valid output is [3, 5, 1, 6, 2, 4] ``` Constraints - You must achieve the desired order pattern with a single scan (linear time complexity, O(n)). - The space complexity must remain constant, O(1). Additional Notes - The function must handle edge cases such as empty arrays or arrays with only one element gracefully.","solution":"from typing import List def wiggle_sort(nums: List[int]) -> None: Modify nums to follow the wiggle pattern in place. Args: nums (List[int]): The input list of integers to be reordered. Returns: None: This function should modify the list in place. for i in range(len(nums) - 1): if i % 2 == 0: if nums[i] > nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i] else: if nums[i] < nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"# Question: Flatten Nested Arrays You are tasked with implementing a function to flatten nested arrays into a single list of values. Objective Given an input array which may contain nested arrays, you should produce a flattened array containing all the elements in the nested structures. Requirements 1. Implement a function `deep_flatten` that takes a single parameter `input_arr`, a nested array, and returns a single flattened array containing all the elements in `input_arr`. 2. You should also handle the case where `input_arr` may contain other iterables such as sets or tuples but not strings (they should not be flattened). Detailed Specifications - **Input**: - `input_arr`: an array that may include nested arrays, sets, or tuples. For example: `[1, [2, [3, 4], 5], (6, 7), {8, 9}]` - **Output**: - A single list of integers, characters, or strings. For example, for the above input, the output should be `[1, 2, 3, 4, 5, 6, 7, 8, 9]`. - **Constraints**: - Do not use the `flatten` or `flatten_iter` functions provided. - You may not use any external libraries. - Your function should handle nested structures of arbitrary depth. Performance Requirements - The function should be optimized for input arrays up to a depth of 10. - Time Complexity: O(n), where n is the total number of elements in the nested arrays. - Space Complexity: Preferably O(d), where d is the maximum nesting depth. Sample Input and Output - **Input**: `[1, [2, [3, 4], 5], (6, 7), {8, 9}]` - **Output**: `[1, 2, 3, 4, 5, 6, 7, 8, 9]` - **Input**: `[\'a\', [\'b\', ([\'c\', \'d\'], 5)], 10]` - **Output**: `[\'a\', \'b\', \'c\', \'d\', 5, 10]` Scenario You are processing complex JSON data received from an API which is of the form: ```json { \\"data\\": [ 1, [2, [3, 4], 5], (6, 7), {8, 9} ] } ``` You\'ve extracted the `data` array and now need to flatten it into a single list of values before further processing.","solution":"def deep_flatten(input_arr): Flattens a nested array, which may contain nested arrays, tuples, or sets, into a single list. :param input_arr: A nested array (list, tuple, or set) of arbitrary depth. :return: A single flattened list of values. result = [] def flatten(element): if isinstance(element, (list, tuple, set)): for item in element: flatten(item) else: result.append(element) flatten(input_arr) return result"},{"question":"In a circular arrangement of `n` people, every third member is to be removed until all members are eliminated. Given an input list of integers representing the people and an integer `k` (where k = 3 in this context), implement a function to determine the order in which people are removed from the circle. # Function Signature ```python def josephus_sequence(int_list: List[int], k: int) -> List[int]: ``` # Input * `int_list`: A list of integers representing the people, with size `n` (1 <= n <= 10^4). * `k`: An integer representing the step count for removal (k = 3 for this problem). # Output * A list of integers in the order they were removed from the circle. # Constraints 1. The list must contain unique integers. 2. `k` will be a positive integer. # Example ```python assert josephus_sequence([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) == [3, 6, 9, 4, 8, 5, 2, 7, 1] assert josephus_sequence([1, 2, 3, 4, 5], 3) == [3, 1, 5, 2, 4] assert josephus_sequence([], 3) == [] assert josephus_sequence([1], 3) == [1] ``` # Task Write the function `josephus_sequence` to solve the Josephus problem using the circular elimination method described.","solution":"from typing import List def josephus_sequence(int_list: List[int], k: int) -> List[int]: Solves the Josephus problem for a list of unique integers and a step count k. result = [] index = 0 while int_list: index = (index + k - 1) % len(int_list) result.append(int_list.pop(index)) return result"},{"question":"# Scenario: As part of a software library for binary tree operations, you are asked to implement an algorithm that can convert a binary search tree to a doubly linked list in sorted order. # Objective: Write a function to flatten a binary search tree to a sorted doubly linked list. Your function should maintain the in-order traversal properties and ensure that the doubly linked list retains the node order. # Function Signature: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def bst_to_doubly_linked_list(root: Node) -> Node: pass ``` # Input: * `root` (Node) - Root of the binary search tree. # Output: * Returns the head of the doubly linked list. # Constraints: * The number of nodes in the tree is in the range `[0, 10^4]`. * `-10^5 <= Node.val <= 10^5` # Example: Given the following binary search tree: ``` 4 / 2 5 / 1 3 ``` Your function should return a doubly linked list that represents: `1 <-> 2 <-> 3 <-> 4 <-> 5`. **Explanation:** * Perform an in-order traversal of the binary search tree. * Convert the nodes into a doubly linked list where the `left` pointer of a node acts as a `prev` link in a doubly linked list and the `right` pointer acts as the `next` link. # Notes: * Ensure the final list does not have any cycles. * Handle edge cases such as an empty tree and trees with only one node effectively. * Optimize for both time and space complexities.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left = left self.right = right = right def bst_to_doubly_linked_list(root: Node) -> Node: Converts a binary search tree to a sorted doubly linked list. if not root: return None def inorder_traversal(node): nonlocal last, head if not node: return inorder_traversal(node.left) # Link the current node with the last node in the list if last: last.right = node node.left = last else: # This establishes the head of the linked list head = node last = node inorder_traversal(node.right) last, head = None, None inorder_traversal(root) return head"},{"question":"Scenario: You\'re developing a data preprocessing module for a data science project, and you need to filter datasets based on certain criteria. One of the tasks involves limiting the array elements to a specified range for further analysis. Task: Write a Python function `custom_limit(arr, min_lim=None, max_lim=None)` that takes an array of integers `arr` and optional parameters `min_lim` and `max_lim`. The function should return a new array containing elements that are greater than or equal to `min_lim` and less than or equal to `max_lim`. * If `min_lim` is not provided (`None`), the function should consider the minimum element in the array as `min_lim`. * If `max_lim` is not provided (`None`), the function should consider the maximum element in the array as `max_lim`. * If both `min_lim` and `max_lim` are not provided (`None`), the function should return the original array. * If `min_lim` is greater than `max_lim`, the function should return an empty array. Input: * `arr`: List of integers (1 ≤ len(arr) ≤ 10^6, -10^9 ≤ arr[i] ≤ 10^9) * `min_lim`: Integer or `None` (default: `None`) * `max_lim`: Integer or `None` (default: `None`) Output: * A list of integers containing the filtered values within the specified range. Constraints: * The function should run in linear time O(n). * The use of additional storage should be minimized. Examples: ```python print(custom_limit([1, 2, 3, 4, 5], None, 3)) # Output: [1, 2, 3] print(custom_limit([1, 2, 3, 4, 5], 2, 4)) # Output: [2, 3, 4] print(custom_limit([1, 2, 3, 4, 5], 3, None)) # Output: [3, 4, 5] print(custom_limit([1, 2, 3, 4, 5], None, None)) # Output: [1, 2, 3, 4, 5] print(custom_limit([1, 2, 3, 4, 5], 5, 2)) # Output: [] print(custom_limit([], 5, 10)) # Output: [] ``` Function Signature: ```python def custom_limit(arr, min_lim=None, max_lim=None): pass ```","solution":"def custom_limit(arr, min_lim=None, max_lim=None): if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) if min_lim > max_lim: return [] return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Question: Implement Enhanced Ternary Search Problem Statement: You are tasked with implementing an enhanced version of the ternary search algorithm. Write a Python function `enhanced_ternary_search` that not only finds the index of a given key in a sorted array but also returns whether the search was efficient compared to binary search for the given input. You need to simulate binary search to count comparisons for the same input and compare the counts. Function Signature: ```python def enhanced_ternary_search(arr: List[int], key: int) -> Tuple[int, bool]: pass ``` Input: * A sorted array of integers `arr` (1 ≤ len(arr) ≤ 10^5) * An integer `key` Output: * A tuple with: * The index of the `key` in `arr` (or -1 if key is not found). * A boolean indicating if ternary search was more efficient (i.e., had fewer or equal comparisons) compared to binary search. Constraints: * You need to implement both ternary and binary search comparison counts. Sample Input: ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 5 ``` Sample Output: ```python (4, False) ``` Note: * Ensure that your function handles edge cases, such as an empty array or the key not present in the array. * The boolean value indicates efficiency in terms of the number of comparisons made. Return `True` if ternary search makes fewer or the same number of comparisons as binary search in processing the given input, otherwise return `False`.","solution":"from typing import List, Tuple def binary_search(arr: List[int], key: int) -> Tuple[int, int]: Binary search, returning the index of the key in the array and the number of comparisons made. left, right = 0, len(arr) - 1 comparisons = 0 while left <= right: comparisons += 1 mid = left + (right - left) // 2 if arr[mid] == key: return mid, comparisons elif arr[mid] < key: left = mid + 1 else: right = mid - 1 return -1, comparisons def ternary_search(arr: List[int], key: int) -> Tuple[int, int]: Ternary search, returning the index of the key in the array and the number of comparisons made. left, right = 0, len(arr) - 1 comparisons = 0 while left <= right: comparisons += 1 mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1, comparisons if arr[mid2] == key: return mid2, comparisons if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1, comparisons def enhanced_ternary_search(arr: List[int], key: int) -> Tuple[int, bool]: index_binary, comp_binary = binary_search(arr, key) index_ternary, comp_ternary = ternary_search(arr, key) return index_ternary, comp_ternary <= comp_binary"},{"question":"Scenario You are working on enhancing a library for handling binary data efficiently. A key component of this is the ability to manipulate individual bits of an integer. To demonstrate your understanding of bitwise operations, you are required to write additional utility functions that perform specific advanced bit manipulations. Task Implement the following functions: 1. **toggle_bit(num, i)**: Toggles (flips) the bit at the i-th position from 0 to 1 or from 1 to 0. 2. **is_power_of_two(num)**: Checks if the given number is a power of 2. Function Signatures ```python def toggle_bit(num, i): # toggles bit at position i pass def is_power_of_two(num): # checks if num is a power of two pass ``` Input and Output Formats * **toggle_bit(num, i)**: * **Input**: - `num`: Integer to manipulate ( 0 <= num <= 2^31 - 1). - `i`: The bit position to toggle ( 0 <= i < 31). * **Output**: Returns the integer after toggling the bit at position `i`. * **is_power_of_two(num)**: * **Input**: - `num`: Integer to check (0 <= num <= 2^31 - 1). * **Output**: Returns a boolean `True` if `num` is a power of 2, otherwise `False`. Constraints - Ensure that all bit indices are within the proper range for a 31-bit integer. - For `is_power_of_two`, handle edge cases like 0 and negative values properly. Examples ```python toggle_bit(5, 0) # Explanation: 5 in binary is 101. Toggling the 0-th bit results in 100 (binary), which is 4. # Output: 4 is_power_of_two(4) # Explanation: 4 in binary is 100, which is a power of two (2^2). # Output: True is_power_of_two(5) # Explanation: 5 in binary is 101, which is not a power of two. # Output: False ```","solution":"def toggle_bit(num, i): Toggles the bit at the i-th position in the integer num. :param num: Integer to manipulate (0 <= num <= 2^31 - 1). :param i: The bit position to toggle (0 <= i < 31). :return: Integer after toggling the bit at position `i`. return num ^ (1 << i) def is_power_of_two(num): Checks if the given number is a power of 2. :param num: Integer to check (0 <= num <= 2^31 - 1). :return: Boolean `True` if `num` is a power of 2, otherwise `False`. if num <= 0: return False return (num & (num - 1)) == 0"},{"question":"You are tasked with implementing a segment tree to efficiently handle range queries and point updates on a dynamic array. Function Definitions 1. **Constructor**: `__init__(self, arr: List, function: Callable[[Any, Any], Any])` - **Parameters**: - `arr`: List of initial elements in the segment tree. - `function`: A commutative function that takes two arguments and returns a value of the same type. 2. **build_tree(self)**: Builds the segment tree using the provided array and function. 3. **update(self, p: int, v: Any)**: Updates the element at index `p` to `v` and updates the necessary nodes in the segment tree. - **Parameters**: - `p`: Index of the element in the original array to update. - `v`: New value to update the element to. 4. **query(self, l: int, r: int) -> Any**: Returns the result of applying the function to the elements in the range `[l, r]`. - **Parameters**: - `l`: Left index of the range (inclusive). - `r`: Right index of the range (inclusive). # Input - The initial array `arr` (list of integers or tuples). - The commutative function for the segment tree. # Output - Results of range queries after performing point updates on the segment tree. # Example ```python mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Output: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Output: (4, 10) ``` # Constraints - The length of the input array will be between 1 and 100,000. - Each element\'s value range depends on the type of operation being performed. # Notes - Implement the class `SegmentTree` with the methods detailed above. - Use efficient methods to ensure that the time complexity constraints are met.","solution":"from typing import List, Callable, Any class SegmentTree: def __init__(self, arr: List, function: Callable[[Any, Any], Any]): self.n = len(arr) self.function = function self.tree = [None] * (2 * self.n) # Build the tree by setting the leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Compute the internal nodes self.build_tree() def build_tree(self): for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, p: int, v: Any): p += self.n self.tree[p] = v while p > 1: p //= 2 self.tree[p] = self.function(self.tree[2 * p], self.tree[2 * p + 1]) def query(self, l: int, r: int) -> Any: l += self.n r += self.n result = None while l <= r: if l % 2 == 1: result = self.tree[l] if result is None else self.function(result, self.tree[l]) l += 1 if r % 2 == 0: result = self.tree[r] if result is None else self.function(result, self.tree[r]) r -= 1 l //= 2 r //= 2 return result"},{"question":"Prim\'s Algorithm for Minimum Spanning Tree Context You are tasked with implementing Prim\'s algorithm to find the weight of the minimum spanning tree (MST) for a given connected undirected graph. The graph is provided as an adjacency list. Problem Statement Write a function `prims_minimum_spanning(graph)` that takes in a connected undirected graph represented in dictionary format and returns the weight of its minimum spanning tree. The graph dictionary\'s structure is: ```python graph = { \'a\': [ [3, \'b\'], [8,\'c\'] ], \'b\': [ [3, \'a\'], [5, \'d\'] ], \'c\': [ [8, \'a\'], [2, \'d\'], [4, \'e\'] ], \'d\': [ [5, \'b\'], [2, \'c\'], [6, \'e\'] ], \'e\': [ [4, \'c\'], [6, \'d\'] ] } ``` In this example, \'a\', \'b\', \'c\', \'d\', \'e\' are nodes, and edges are represented as lists containing the edge weight and the connected node. The nodes can be any hashable data type and need not be numerical. Implementation Details * Your function should assume that the input graph is always connected and undirected. * Do not use any built-in graph library functions. * The priority queue should be implemented using `heapq`. * Start the algorithm arbitrarily from any node. Input/Output Specification * **Input**: A dictionary `graph` representing the adjacency list of a connected undirected graph. * **Output**: An integer representing the weight of the minimum spanning tree. ```python def prims_minimum_spanning(graph): Function to compute weight of minimum spanning tree using Prim\'s Algorithm. Parameters: graph (dict): A dictionary representing the graph in adjacency list format. Returns: int: The weight of the minimum spanning tree. # Implement the function here ``` Constraints * The graph dictionary sizes will be in the range 1 ≤ |V| ≤ 1000 and 0 ≤ |E| ≤ 2000. * The weights of the edges are non-negative integers. Example ```python graph = { \'a\': [ [3, \'b\'], [8,\'c\'] ], \'b\': [ [3, \'a\'], [5, \'d\'] ], \'c\': [ [8, \'a\'], [2, \'d\'], [4, \'e\'] ], \'d\': [ [5, \'b\'], [2, \'c\'], [6, \'e\'] ], \'e\': [ [4, \'c\'], [6, \'d\'] ] } print(prims_minimum_spanning(graph)) # Output: 14 ``` *In the above graph, the MST can have edges with weights 3, 2, 4, and 5, totaling to 14.*","solution":"import heapq def prims_minimum_spanning(graph): Function to compute weight of the minimum spanning tree using Prim\'s Algorithm. Parameters: graph (dict): A dictionary representing the graph in adjacency list format. Returns: int: The weight of the minimum spanning tree. # Start with an arbitrary node, let\'s pick the first key in the dictionary start_node = next(iter(graph)) # Priority queue to store (weight, node) and a set to track visited nodes min_heap = [(0, start_node)] visited = set() total_weight = 0 while min_heap: weight, node = heapq.heappop(min_heap) if node not in visited: visited.add(node) total_weight += weight for edge_weight, adjacent in graph[node]: if adjacent not in visited: heapq.heappush(min_heap, (edge_weight, adjacent)) return total_weight"},{"question":"# Question: Implement a Rolling Sum for a Moving Average Given a stream of integers and a window size, write a class `MovingAverageOptimized` to calculate the moving average of all integers using a sliding window, just like the above `MovingAverage` class but with optimized time complexity for the `next` method. Requirements: * The solution should use a rolling sum to maintain the current sum of the elements within the sliding window efficiently. * The `next` method should have an expected time complexity of O(1). Implementation: 1. Define a class `MovingAverageOptimized` with an initializer that takes the size of the sliding window. 2. Implement the `next` method which: - Takes the next integer in the stream. - Updates the rolling sum. - Returns the current moving average of the last `size` elements. Notes: * You may assume that the sliding window size will always be a positive integer. * The stream of integers will always be valid integers. * Handle edge cases like the first few elements when the queue size is less than the specified window size appropriately. Example: ```python class MovingAverageOptimized: def __init__(self, size: int): Initialize your data structure here. :param size: int self.size = size self.queue = deque(maxlen=size) self.current_sum = 0 # To maintain the rolling sum def next(self, val: int) -> float: :param val: int :return: float if len(self.queue) == self.size: self.current_sum -= self.queue[0] # Subtract the oldest element from the sum self.queue.append(val) self.current_sum += val # Add the new element to the sum return self.current_sum / len(self.queue) # Test the implementation if __name__ == \'__main__\': m = MovingAverageOptimized(3) assert m.next(1) == 1.0 assert m.next(10) == 5.5 assert m.next(3) == 4.666666666666667 assert m.next(5) == 6.0 ``` In this question, the student is expected to optimize the `next` method by maintaining a rolling sum and thus achieving a time complexity of O(1) for each call. This requires a good understanding of data structures (deque) and algorithm optimization techniques.","solution":"from collections import deque class MovingAverageOptimized: def __init__(self, size: int): Initialize your data structure here. :param size: int self.size = size self.queue = deque(maxlen=size) self.current_sum = 0 # To maintain the rolling sum def next(self, val: int) -> float: :param val: int :return: float if len(self.queue) == self.size: self.current_sum -= self.queue[0] # Subtract the oldest element from the sum self.queue.append(val) self.current_sum += val # Add the new element to the sum return self.current_sum / len(self.queue)"},{"question":"# Question: Implement a Word Dictionary with Wildcard Support You\'re tasked with designing a data structure that supports adding new words and searching for words using literal matches or wildcards. This structure should efficiently manage search queries which might include the wildcard character `\'.\'`, representing any letter. Implement the WordDictionary Class with the Following Methods: 1. **`add_word(self, word: str) -> None`**: Adds a `word` to the data structure. 2. **`search(self, word: str) -> bool`**: Returns `True` if the `word` (possibly with wildcards) is in the data structure, otherwise returns `False`. Input and Output - **`add_word(self, word: str)`**: - **Parameters**: `word` (string) - the word to be added into the dictionary. - **Returns**: none. - **`search(self, word: str) -> bool`**: - **Parameters**: `word` (string) - the word to be searched in the dictionary, potentially containing `\'.\'` which can represent any letter. - **Returns**: `True` if `word` is found in the dictionary, otherwise `False`. Constraints: - The word only contains lowercase alphabetical characters `[a-z]` and the wildcard character `\'.\'`. - The length of any word will be in the range `[1, 500]`. - The methods `add_word` and `search` will be called at most `3 * 10^4` times in total. # Example ```python wordDictionary = WordDictionary() wordDictionary.add_word(\\"bad\\") wordDictionary.add_word(\\"dad\\") wordDictionary.add_word(\\"mad\\") print(wordDictionary.search(\\"pad\\")) # -> False print(wordDictionary.search(\\"bad\\")) # -> True print(wordDictionary.search(\\".ad\\")) # -> True print(wordDictionary.search(\\"b..\\")) # -> True ``` # Notes - You should leverage an efficient data structure to handle the wildcard searches. - Consider the trade-offs in memory usage and search performance. - Think about the edge cases and handle them appropriately.","solution":"class WordDictionary: def __init__(self): self.word_set = set() def add_word(self, word: str) -> None: self.word_set.add(word) def search(self, word: str) -> bool: if word in self.word_set: return True import re # We\'ll use regular expressions to handle wildcard matching pattern = \\"^\\" + word.replace(\\".\\", \\"[a-z]\\") + \\"\\" for w in self.word_set: if re.match(pattern, w): return True return False"},{"question":"You are given a large sequence of positive integers concatenated together in a continuous stream, starting from number 1. Write a function `find_nth_digit(n)` that finds and returns the nth digit in this sequence. Function Signature ```python def find_nth_digit(n: int) -> int: ``` Input: - An integer `n` where (1 leq n leq 2 times 10^9). Output: - An integer representing the nth digit in the concatenated sequence of numbers. Example: ```python find_nth_digit(3) -> 3 # the sequence is \\"123\\", and the 3rd digit is \\"3\\" find_nth_digit(11) -> 0 # 12345678910, and the 11th digit is \\"0\\" find_nth_digit(15) -> 2 # 123456789101112, and the 15th digit is \\"2\\" find_nth_digit(189) -> 9 # last digit of the two-digit numbers sequence find_nth_digit(190) -> 1 # first digit in the three-digit numbers sequence ``` Constraints: - The function should handle finding the nth digit in an efficient manner given that `n` can go up to (2 times 10^9). - Ensure optimized execution considering the potentially large values of `n`. # Testing Tips: - Consider various edge cases such as the beginning and end of different range sizes (e.g., single-digit, two-digit, three-digit numbers). - Test with large values of `n` to verify the efficiency and correctness of the solution.","solution":"def find_nth_digit(n: int) -> int: length = 1 count = 9 start = 1 # Identify the range while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Identify the exact number start += (n - 1) // length # Identify the exact digit s = str(start) return int(s[(n - 1) % length])"},{"question":"# Quick Sort Implementation You have been provided with a partial implementation of the Quick Sort algorithm. Your task is to complete it by implementing the quick_sort function that uses the helper functions quick_sort_recur and partition given. # Function Signature ```python def quick_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Input - **arr**: a list of integers that you need to sort. - **simulation** (optional): a boolean flag. If set to `True`, the function should print the array\'s state at each iteration of the sorting process. Example: ```python quick_sort([3, 6, 8, 10, 1, 2, 1]) ``` # Output - Return the sorted list of integers. # Constraints - The list `arr` will contain integers. - The length of the list will be in the range [0, 10^5]. - if `simulation` is `True`, output the state of the array after each pass (iteration) through the primary recursive call. # Performance Requirements - Your implementation should handle time and space complexity efficiently. # Testing - Ensure to account for edge cases such as: - An empty array - Arrays with all duplicate elements - Already sorted arrays - Arrays with one element # Example - Input: ```python quick_sort([3, 6, 8, 10, 1, 2, 1]) ``` - Output: ```python [1, 1, 2, 3, 6, 8, 10] ``` - Input: ```python quick_sort([5, 5, 5, 5], simulation=True) ``` - Output: ```python iteration 0 : 5 5 5 5 iteration 1 : 5 5 5 5 [5, 5, 5, 5] ```","solution":"from typing import List def quick_sort(arr: List[int], simulation: bool = False) -> List[int]: def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_recur(arr, low, high, iteration): if low < high: pi = partition(arr, low, high) if simulation: print(f\\"iteration {iteration} : {\' \'.join(map(str, arr))}\\") quick_sort_recur(arr, low, pi - 1, iteration + 1) quick_sort_recur(arr, pi + 1, high, iteration + 1) quick_sort_recur(arr, 0, len(arr) - 1, 0) return arr"},{"question":"You are working on a project that requires efficient string searching within large datasets. Your task is to develop a function that can find all occurrences of a given pattern within a given text using the Knuth-Morris-Pratt (KMP) algorithm. This will help in tasks such as finding keywords within large documents or monitoring network traffic for certain patterns. # Function Specification **Function Name**: `knuth_morris_pratt` **Input**: * `text` - A sequence (string) where you need to search for the pattern. Length of the text, N, is such that 0 ≤ N ≤ 10^6. * `pattern` - A sequence (string) representing the pattern to search. Length of the pattern, M, is such that 0 ≤ M ≤ 10^6. **Output**: * A list containing all starting indices in the text where the pattern is found. # Constraints - If the pattern is an empty string, return an empty list. - The result list should be sorted in ascending order of indices. # Example ```python >>> knuth_morris_pratt(\'hello there hero!\', \'he\') [0, 7, 12] >>> knuth_morris_pratt(\'abracadabra\', \'abra\') [0, 7] >>> knuth_morris_pratt(\'mississippi\', \'issi\') [1, 4] >>> knuth_morris_pratt(\'mississippi\', \'\') [] ``` # Requirements - Efficiently handle edge cases such as empty text or pattern. - Implement the KMP algorithm correctly to ensure that the time complexity remains O(N + M) and the space complexity stays O(M). # Notes By solving this problem, you will demonstrate your understanding of efficient string searching algorithms and their practical applications in computational problems. Pay special attention to the construction of the prefix table and the matching logic to ensure optimal performance.","solution":"def knuth_morris_pratt(text, pattern): Implements the Knuth-Morris-Pratt (KMP) algorithm to find all occurrences of a pattern in a text. Parameters: text (str): The text in which to search for the pattern. pattern (str): The pattern to search for in the text. Returns: list: A list of all starting indices in the text where the pattern is found. if not pattern: return [] def compute_lps(pattern): lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(pattern) indices = [] i = 0 j = 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): indices.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"# Euler\'s Totient Function Challenge You are challenged to implement an enhanced version of Euler\'s Totient Function. This function ϕ(n) calculates the number of positive integers up to a given integer `n` that are coprime to `n`. Input and Output Format * **Input**: Integer `n` (1 ≤ n ≤ 10^6) * **Output**: Integer representing the count of numbers from 1 to `n` that are coprime to `n`. Constraints * The function needs to handle large integers efficiently. Ensure your implementation has a time complexity not exceeding O(sqrt(n)). * Incorporate error handling for invalid inputs (e.g., non-positive integers). Task Implement a function `enhanced_euler_totient(n)` that meets the following criteria: * Efficiently calculates the Euler\'s Totient Function for the given input. * Leverages concepts from number theory to ensure optimal performance. Example * **Input**: `n = 9` * **Output**: `6` (The numbers 1, 2, 4, 5, 7, and 8 are coprime to 9) ```python def enhanced_euler_totient(n): Calculate Euler\'s Totient Function (phi(n)) for a given integer n. Args: n (int): The positive integer to calculate the totient function for. Returns: int: The number of integers from 1 to n that are coprime to n. # Your implementation goes here # Feel free to add additional tests to validate your implementation. print(enhanced_euler_totient(9)) # Example test case ```","solution":"def enhanced_euler_totient(n): Calculate Euler\'s Totient Function (phi(n)) for a given integer n. Args: n (int): The positive integer to calculate the totient function for. Returns: int: The number of integers from 1 to n that are coprime to n. if n <= 0: raise ValueError(\\"Input must be a positive integer.\\") result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result"},{"question":"Design and implement a function `kmp_search(haystack: str, needle: str) -> int` that locates the first occurrence of the substring `needle` in the string `haystack`, using the Knuth-Morris-Pratt (KMP) string matching algorithm. Return the starting index of the substring if found, otherwise return -1. # Function Signature ```python def kmp_search(haystack: str, needle: str) -> int: pass ``` # Input - `haystack`: A string, representing the larger text. (1 <= len(haystack) <= 10^5) - `needle`: A string, representing the substring to be searched for. (1 <= len(needle) <= 10^5) # Output - An integer: The starting index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not a substring of `haystack`. # Constraints - Implement the Knuth-Morris-Pratt (KMP) algorithm to handle potential large input efficiently. - Your solution should have a time complexity of O(n + m), where \'n\' is the length of haystack and \'m\' is the length of needle. # Performance Requirements - The function should work efficiently even for the upper limit constraints. # Context Consider you are building a basic text editor that needs to implement a \'find\' feature. The editor should quickly highlight the first occurrence of a provided search term within a large document. # Examples ```python assert kmp_search(\\"hello\\", \\"ll\\") == 2 assert kmp_search(\\"aaaaa\\", \\"bba\\") == -1 assert kmp_search(\\"needleinhaystack\\", \\"hay\\") == 9 ```","solution":"def kmp_search(haystack: str, needle: str) -> int: def build_lps(pattern): lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps if not needle: return 0 m, n = len(needle), len(haystack) lps = build_lps(needle) i = j = 0 while i < n: if needle[j] == haystack[i]: i += 1 j += 1 if j == m: return i - j elif i < n and needle[j] != haystack[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"# Objective Write a function that simplifies a Unix-style absolute file path. The function should handle common path simplification rules such as resolving \\"..\\", \\".\\", and multiple slashes. # Function Signature ```python def simplify_path(path: str) -> str: Args: path (str): An absolute path for a file (Unix-style). Returns: str: The simplified canonical path. pass ``` # Input * `path` (str): A string representing an absolute Unix-style path to be simplified. The path contains only English letters, digits, periods (\'.\'), slashes (\'/\'), and underscores (\'_\'). # Output * (str): A canonicalized absolute path. # Constraints * The path length is at most 10^4. * The path always starts with a \'/\'. * Paths may contain consecutive slashes (e.g., \\"/home//foo/\\"). # Examples * Input: `\\"/home/\\"` Output: `\\"/home\\"` * Input: `\\"/a/./b/../../c/\\"` Output: `\\"/c\\"` * Input: `\\"/../\\"` Output: `\\"/\\"` * Input: `\\"/home//foo/\\"` Output: `\\"/home/foo\\"` # Scenario Imagine you are designing a file management system where you need to simplify user-given file paths to their most canonical form for efficient storage and retrieval. Your task is to implement a component that handles this path simplification as described above. # Implementation Notes Ensure your function comprehensively handles all edge cases such as multiple slashes, self-references with \\".\\", and traversals with \\"..\\". Aim for an efficient and clear solution leveraging appropriate data structures like stacks.","solution":"def simplify_path(path: str) -> str: Simplifies a Unix-style absolute file path. Args: path (str): An absolute path for a file (Unix-style). Returns: str: The simplified canonical path. # Use a stack to handle the simplification process stack = [] # Split the path by \'/\' and process each part for part in path.split(\'/\'): if part == \'\' or part == \'.\': # Skip empty parts and current directory references continue elif part == \'..\': # Go up one directory (pop from stack if possible) if stack: stack.pop() else: # Add the directory to the stack stack.append(part) # Return the simplified path return \'/\' + \'/\'.join(stack)"},{"question":"# Question You are provided with a binary search tree (BST) class and two methods for in-order tree traversal. Your task is to implement a method to transform a given BST into a sorted doubly linked list using in-order traversal. Requirements: * **Function Signature**: `def bst_to_doubly_linked_list(root: Optional[Node]) -> Optional[DoublyLinkedNode]:` * **Input**: * `root` is the root node of a BST, defined as an instance of the `Node` class. * **Output**: * Returns the head of a doubly linked list (DLL). * **Constraints**: * The BST will have at most 10^4 nodes. * Node values are distinct and represent integers. * **Performance Requirements**: * The solution must run in O(n) time, where n is the number of nodes. Scenario: You are working on a data serialization problem where sorted order of elements needs to be preserved in a different data structure. A doubly linked list provides an efficient data structure for list-like operations with bidirectional traversal linked through nodes. Doubly Linked List Node Definition: ```python class DoublyLinkedNode: def __init__(self, val: int, prev: \\"DoublyLinkedNode\\" = None, next: \\"DoublyLinkedNode\\" = None): self.val = val self.prev = prev self.next = next ``` # Instructions: 1. Implement the function `bst_to_doubly_linked_list`. 2. You may use the provided `Node` and `DoublyLinkedNode` class definitions. 3. Your function should construct a sorted doubly linked list through in-order traversal and return the head of the list. # Example: Given BST: ``` 4 / 2 5 / 1 3 ``` Transformed Doubly Linked List: ``` 1 <-> 2 <-> 3 <-> 4 <-> 5 ```","solution":"class Node: def __init__(self, val: int, left: \\"Node\\" = None, right: \\"Node\\" = None): self.val = val self.left = left self.right = right class DoublyLinkedNode: def __init__(self, val: int, prev: \\"DoublyLinkedNode\\" = None, next: \\"DoublyLinkedNode\\" = None): self.val = val self.prev = prev self.next = next def bst_to_doubly_linked_list(root: Node) -> DoublyLinkedNode: if not root: return None # Helper function to perform in-order traversal def in_order_traversal(node): stack = [] current = node while stack or current: while current: stack.append(current) current = current.left current = stack.pop() yield current current = current.right dummy = DoublyLinkedNode(0) prev = dummy for current in in_order_traversal(root): dll_node = DoublyLinkedNode(current.val) prev.next = dll_node dll_node.prev = prev prev = dll_node head = dummy.next if head: head.prev = None return head"},{"question":"# Programming Problem: Word Break Count Problem Description You are provided with a string and a dictionary of words. Your task is to write a function that determines the number of valid sentences that can be formed from the given string using words from the dictionary. A valid sentence is defined as a sequence of contiguous substrings from the given string where each substring exists in the provided dictionary. Function Signature ```python def count_valid_sentences(s: str, word_dict: Set[str]) -> int: pass ``` Input - `s`: A string containing only lowercase letters (1 ≤ len(s) ≤ 300). - `word_dict`: A set of words provided as a dictionary (1 ≤ len(word_dict) ≤ 1000). Output - Returns an integer representing the number of valid sentences that can be formed. Constraints - The input string and dictionary contain only lowercase alphabetic characters. - The same word can be used multiple times from the dictionary in constructing a sentence. Example ```python assert count_valid_sentences(\\"appletablet\\", {\\"apple\\", \\"tablet\\", \\"applet\\", \\"able\\", \\"table\\", \\"let\\", \\"t\\"}) == 4 assert count_valid_sentences(\\"thing\\", {\\"thing\\"}) == 1 assert count_valid_sentences(\\"catsanddog\\", {\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"}) == 2 ``` Description - In the first example, \\"appletablet\\" can be split as: 1. \\"apple\\" + \\"tablet\\" 2. \\"applet\\" + \\"able\\" + \\"t\\" 3. \\"apple\\" + \\"table\\" + \\"t\\" 4. \\"app\\" + \\"let\\" + \\"able\\" + \\"t\\" - In the second example, \\"thing\\" can only be split using the word \\"thing\\". Your task is to implement the function `count_valid_sentences` that meets the above requirements. You may utilize memoization to optimize performance.","solution":"from typing import Set def count_valid_sentences(s: str, word_dict: Set[str]) -> int: # Implement memoization to store count of ways for substrings memo = {} def helper(sub_s): if sub_s in memo: return memo[sub_s] if not sub_s: return 1 # Base case: empty string has one way (do nothing) total_ways = 0 for i in range(1, len(sub_s) + 1): if sub_s[:i] in word_dict: total_ways += helper(sub_s[i:]) memo[sub_s] = total_ways return total_ways return helper(s)"},{"question":"# Eureka Numbers within a Range You are to write a function that finds all Eureka numbers within a given range. A Eureka number is a number for which the sum of its digits each raised to the power of their position (starting from 1) equals the number itself. For example, the number 89 is a Eureka number because 8^1 + 9^2 = 89. Function Signature: ```python def sum_dig_pow(low: int, high: int) -> List[int]: ``` Input: - `low` (int): The lower bound of the range (inclusive). - `high` (int): The upper bound of the range (inclusive). Output: - List of integers: A list of all Eureka numbers within the specified range. Constraints: - 1 ≤ `low` ≤ `high` ≤ 1000 Performance Requirements: - The solution should be efficient enough to handle the maximum input size within reasonable time limits. Examples: ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert sum_dig_pow(50, 150) == [89, 135] ``` Explanation: Consider each number in the given range. Split the number into its digits and compute the sum of each digit raised to its respective positional power. Check if this sum equals the number itself. If it does, it is a Eureka number and should be included in the result list. Your task is to implement the `sum_dig_pow` function to satisfy the above requirements.","solution":"from typing import List def sum_dig_pow(low: int, high: int) -> List[int]: Returns a list of Eureka numbers within the given range [low, high]. def is_eureka_number(n: int) -> bool: digits = [int(d) for d in str(n)] total = sum(d ** (idx + 1) for idx, d in enumerate(digits)) return total == n return [num for num in range(low, high + 1) if is_eureka_number(num)]"},{"question":"You have been tasked to implement a segment tree for efficient range queries with the capability of range updates. A segment tree allows you to perform range queries and updates efficiently using a tree-based structure. You will implement a range sum query for this exercise. Requirements: 1. **Initialization**: - You will initialize a segment tree with an array of integers. 2. **Range Query**: - Implement a method to get the sum of elements in a given range [L, R]. 3. **Range Update**: - Implement a method to increment all elements in a given range [L, R] by a given value. Function Signatures: - `class SegmentTree: def __init__(self, arr: List[int]): # initializes the segment tree pass def range_query(self, L: int, R: int) -> int: # returns the sum of elements between indices L and R pass def range_update(self, L: int, R: int, value: int): # increments all elements in the range [L, R] by \'value\' pass` Input/Output: 1. **Initialization**: - An array of integers. 2. **Range Query** (`range_query`): - **Input**: - Two integers `L` and `R` representing the range (inclusive). - **Output**: - An integer representing the sum of the elements in the specified range. 3. **Range Update** (`range_update`): - **Input**: - Two integers `L` and `R` representing the range (inclusive). - An integer `value` to add to each element in the specified range. - **Output**: - None (this operation modifies the segment tree). Constraints: - 1 <= length of the initial array <= 10^5 - -10^6 <= array elements, query values, and update values <= 10^6 - 0 <= L <= R < length of array Example Scenario: Consider an array `[1, 3, 5, 7, 9, 11]`. 1. Initialize the segment tree with the array: - `seg_tree = SegmentTree([1, 3, 5, 7, 9, 11])` 2. Perform a range query: - Query the sum from index 1 to 3: `seg_tree.range_query(1, 3)` - Output: `15` (since 3 + 5 + 7 = 15) 3. Perform a range update: - Increment all elements from index 0 to 2 by 1: `seg_tree.range_update(0, 2, 1)` 4. Perform another range query: - Query again the sum from index 1 to 3: `seg_tree.range_query(1, 3)` - Output: `16` (since 4 + 6 + 7 = 17) Implement the `SegmentTree` class with the described methods to handle this scenario efficiently.","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (4 * self.n) self.lazy = [0] * (4 * self.n) self._build(arr, 0, 0, self.n - 1) def _build(self, arr, node, start, end): if start == end: self.tree[node] = arr[start] else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self._build(arr, left_child, start, mid) self._build(arr, right_child, mid + 1, end) self.tree[node] = self.tree[left_child] + self.tree[right_child] def _update_range(self, node, start, end, l, r, value): # If there\'s a lazy value to propagate if self.lazy[node] != 0: self.tree[node] += (end - start + 1) * self.lazy[node] if start != end: self.lazy[2 * node + 1] += self.lazy[node] self.lazy[2 * node + 2] += self.lazy[node] self.lazy[node] = 0 if start > end or start > r or end < l: return if start >= l and end <= r: self.tree[node] += (end - start + 1) * value if start != end: self.lazy[2 * node + 1] += value self.lazy[2 * node + 2] += value return mid = (start + end) // 2 self._update_range(2 * node + 1, start, mid, l, r, value) self._update_range(2 * node + 2, mid + 1, end, l, r, value) self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2] def range_update(self, L, R, value): self._update_range(0, 0, self.n - 1, L, R, value) def _query_range(self, node, start, end, l, r): if start > end or start > r or end < l: return 0 if self.lazy[node] != 0: self.tree[node] += (end - start + 1) * self.lazy[node] if start != end: self.lazy[2 * node + 1] += self.lazy[node] self.lazy[2 * node + 2] += self.lazy[node] self.lazy[node] = 0 if start >= l and end <= r: return self.tree[node] mid = (start + end) // 2 left_sum = self._query_range(2 * node + 1, start, mid, l, r) right_sum = self._query_range(2 * node + 2, mid + 1, end, l, r) return left_sum + right_sum def range_query(self, L, R): return self._query_range(0, 0, self.n - 1, L, R)"},{"question":"Enhanced Insertion Sort Given an array of integers, implement the Insertion Sort algorithm with an additional feature to count and return the number of comparisons made during the sorting process. This will not only test your understanding of the sorting mechanism but also evaluates the efficiency of your implementation by counting the necessary comparisons to fully sort the array. Task: Write a function `insertion_sort_with_comparisons(arr: List[int]) -> Tuple[List[int], int]` that: * Sorts the given list of integers using the Insertion Sort algorithm. * Returns a tuple containing the sorted array and the count of comparisons made during the process. Input: * An unsorted list of integers, `arr` of length `n` (1 ≤ n ≤ 10^3). Output: * A tuple consisting of: * The sorted list of integers. * The number of comparisons made during the sorting process. Constraints: * The algorithm should retain the stable sorting property. * Ensure the time complexity aligns with the traditional Insertion Sort, i.e., O(n^2) in the worst case. Example: **Input** ```python arr = [4, 3, 2, 1] ``` **Output** ```python ([1, 2, 3, 4], 6) ``` In this example, the algorithm makes 6 comparisons in total to sort the array. Note: Provide meaningful comments in your code to explain the key parts of your implementation.","solution":"from typing import List, Tuple def insertion_sort_with_comparisons(arr: List[int]) -> Tuple[List[int], int]: comparisons = 0 for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 comparisons += 1 arr[j + 1] = key # If the while loop condition fails on the first check, # an additional check is made here. if j >= 0: comparisons += 1 return arr, comparisons"},{"question":"You are part of a team developing secure communication protocols and have been assigned to implement a Diffie-Hellman key exchange mechanism. To verify the robustness of the implementation, you need to stretch beyond just performing the key exchange. You must ensure that the keys exchanged are indeed shared securely and meet the required cryptographic properties. # Task Your task is to implement a suite of functions for the Diffie-Hellman key exchange process. The functions should: 1. Generate private keys. 2. Compute public keys. 3. Calculate shared keys. 4. Validate the chosen prime number and primitive root. # Implementation Requirements 1. **Private Key Generation**: - `def generate_private_key(p: int) -> int` - Inputs: ( p ) (int): A large prime number. - Output: An integer in the range [1, ( p-1 )]. 2. **Public Key Computation**: - `def generate_public_key(private_key: int, a: int, p: int) -> int` - Inputs: - `private_key` (int): The private key. - ( a ) (int): The primitive root of ( p ). - ( p ) (int): The prime number. - Output: The corresponding public key as an integer. 3. **Shared Key Calculation**: - `def calculate_shared_key(public_key: int, private_key: int, p: int) -> int` - Inputs: - `public_key` (int): The other party\'s public key. - `private_key` (int): The user\'s private key. - ( p ) (int): The prime number. - Output: The shared secret key as an integer. 4. **Validation of Prime and Primitive Root**: - `def validate_parameters(a: int, p: int) -> bool` - Inputs: - ( a ) (int): The potential primitive root. - ( p ) (int): The prime number. - Output: True if ( a ) is a valid primitive root of ( p ), otherwise False. # Constraints - ( p ) should be a prime number greater than 2. - ( a ) should be a valid primitive root of ( p ). # Scenario Alice and Bob need to use your implementation to securely establish a shared secret key. The validation function should ensure they are using appropriate parameters before proceeding with the exchange process. # Example ```python # Prime number and primitive root p = 23 a = 5 if validate_parameters(a, p): alice_private_key = generate_private_key(p) alice_public_key = generate_public_key(alice_private_key, a, p) bob_private_key = generate_private_key(p) bob_public_key = generate_public_key(bob_private_key, a, p) alice_shared_key = calculate_shared_key(bob_public_key, alice_private_key, p) bob_shared_key = calculate_shared_key(alice_public_key, bob_private_key, p) assert alice_shared_key == bob_shared_key print(f\\"Shared Secret Key: {alice_shared_key}\\") else: print(f\\"Invalid parameters: a = {a}, p = {p}\\") ```","solution":"import random def generate_private_key(p: int) -> int: Generates a private key in the range [1, p-1]. return random.randint(1, p - 1) def generate_public_key(private_key: int, a: int, p: int) -> int: Computes the public key using the private key, primitive root, and prime number. return pow(a, private_key, p) def calculate_shared_key(public_key: int, private_key: int, p: int) -> int: Calculates the shared secret key using the other party\'s public key, own private key, and the prime number. return pow(public_key, private_key, p) def validate_parameters(a: int, p: int) -> bool: Validates that a is a primitive root of the prime number p. if not is_prime(p): return False # Check if a is a primitive root mod p required_set = set(num for num in range(1, p) if gcd(num, p) == 1) actual_set = set(pow(a, powers, p) for powers in range(1, p)) return required_set == actual_set def is_prime(n: int) -> bool: Simple check to determine if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def gcd(a: int, b: int) -> int: Computes the greatest common divisor of a and b. while b: a, b = b, a % b return a"},{"question":"# Prime Detection and Summation Implement a function `prime_sum(limit)` that computes the sum of all prime numbers less than the given input `limit`. **Function Signature**: ```python def prime_sum(limit: int) -> int: ``` **Input**: * An integer `limit` (1 <= limit <= 10^6). **Output**: * The sum of all prime numbers less than `limit`. **Example**: ```python assert prime_sum(10) == 17 # primes are 2, 3, 5, 7 assert prime_sum(20) == 77 # primes are 2, 3, 5, 7, 11, 13, 17, 19 ``` **Constraints**: * The function should handle large input sizes efficiently. * You should use the `prime_check` function (or equivalent logic) to identify prime numbers. **Scenario**: You are developing a feature for a mathematical software package that requires summing prime numbers up to a certain value. This will be useful for users needing quick access to prime sums for various computational tasks in number theory. **Implementation Tips**: * Reuse the prime-checking logic provided to avoid redundant code. * Consider an efficient way to iterate and sum prime numbers using optimized prime checking.","solution":"def prime_sum(limit: int) -> int: Computes the sum of all prime numbers less than the given input limit. if limit <= 2: return 0 primes = [True] * limit primes[0] = primes[1] = False # 0 and 1 are not prime numbers for start in range(2, int(limit**0.5) + 1): if primes[start]: for multiple in range(start * start, limit, start): primes[multiple] = False return sum(index for index, is_prime in enumerate(primes) if is_prime)"},{"question":"You are working on a combinatorial problem that requires calculating the number of combinations, nCr, which represents the number of ways to choose r items from a set of n items. The basic recursive formulation of this problem can become inefficient for large values of n and r. Therefore, you need to implement a more efficient solution using memoization. Write a function `calculate_combinations` that efficiently calculates nCr using memoization to avoid redundant calculations. # Function Signature ```python def calculate_combinations(n: int, r: int) -> int: ``` # Expected Input and Output - **Input**: Two non-negative integers, `n` and `r`, where `n >= r`. - **Output**: An integer representing the number of combinations, nCr. # Constraints and Limitations - `0 <= r <= n <= 30` - Ensure that the solution is optimized to handle the given constraints efficiently. # Performance Requirements The implemented solution should optimize both time and space complexity by leveraging memoization. # Example ```python # Example 1 assert calculate_combinations(5, 3) == 10 # Example 2 assert calculate_combinations(10, 2) == 45 # Example 3 assert calculate_combinations(0, 0) == 1 ``` # Additional Notes The function should handle special cases where `r` is 0 or equal to `n`. **Hint**: Use a dictionary to store intermediate results and consult this dictionary to avoid redundant calculations.","solution":"def calculate_combinations(n: int, r: int, memo=None) -> int: if memo is None: memo = {} if r == 0 or r == n: return 1 if (n, r) in memo: return memo[(n, r)] memo[(n, r)] = calculate_combinations(n-1, r-1, memo) + calculate_combinations(n-1, r, memo) return memo[(n, r)]"},{"question":"# Binary Search in a Sorted Array You have been provided with a sorted array of integers. You need to implement two functions: 1. An iterative binary search function. 2. A recursive binary search function. Both functions will search for a given target value within the array and return the index of the target value if it exists. If the target value does not exist in the array, return `-1`. # Input and Output Formats Input: - A sorted array of integers, `array`. - An integer `targetValue`. Output: - Integer - Index of `targetValue` in `array` if present, otherwise `-1`. # Constraints - The length of the array will not exceed 10^6. - Each integer in the array will be in the range `[-10^9, 10^9]`. - Assume that all integers in the array are distinct. # Example Input/Output Example 1: ``` Input: array = [1, 2, 3, 4, 5, 6, 7] targetValue = 4 Output: 3 ``` Example 2: ``` Input: array = [1, 2, 3, 4, 5, 6, 7] targetValue = 8 Output: -1 ``` # Requirements 1. Implement the iterative function `iterative_binary_search(array, targetValue)`. 2. Implement the recursive function `recursive_binary_search(array, low, high, targetValue)`. # Function Signatures ```python def iterative_binary_search(array: List[int], targetValue: int) -> int: pass def recursive_binary_search(array: List[int], low: int, high: int, targetValue: int) -> int: pass ``` Note: These functions should be efficient and handle edge cases well, as described in the analysis above.","solution":"from typing import List def iterative_binary_search(array: List[int], targetValue: int) -> int: Performs an iterative binary search to find the index of `targetValue` in `array`. Returns the index if found, otherwise returns -1. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == targetValue: return mid elif array[mid] < targetValue: low = mid + 1 else: high = mid - 1 return -1 def recursive_binary_search(array: List[int], low: int, high: int, targetValue: int) -> int: Performs a recursive binary search to find the index of `targetValue` in `array`. Returns the index if found, otherwise returns -1. if low > high: return -1 mid = (low + high) // 2 if array[mid] == targetValue: return mid elif array[mid] < targetValue: return recursive_binary_search(array, mid + 1, high, targetValue) else: return recursive_binary_search(array, low, mid - 1, targetValue)"},{"question":"**Scenario**: You have been tasked to implement another highly inefficient sorting algorithm known for educational purposes called \\"Quantum Bogo Sort\\". Similar to Bogo Sort, the Quantum Bogo Sort relies on the principle of simultaneously trying all permutations, but for educational simplicity, you\'ll simulate this in a linear execution environment. Your task is to create a function that attempts to sort the list in this quantum-inspired manner by iterating through random shuffles, counting each unique permutation until the sorted permutation is reached. Although we cannot physically execute all permutations simultaneously, we\'ll measure the hypothetical attempt count. # Function Implementation Implement the function `quantum_bogo_sort`, which takes a list of integers and simulates the Quantum Bogo Sort by counting the number of unique permutations attempted before sorting the list. Input: * List of integers `arr` with `1 <= len(arr) <= 10` and `-100 <= arr[i] <= 100`. Output: * A tuple containing the sorted list and the count of unique permutations attempted. Constraints: * Lists will not have duplicate permutations; all elements are unique. * You must count each permutation your function attempts. * You should not use deterministic sorting methods within your algorithm. Performance Requirement: * Even though the nature is inefficient, ensure that the function runs efficiently within the provided constraints. # Example: ```python print(quantum_bogo_sort([3, 2, 1])) ``` Expected Output: ([1, 2, 3], `x`), where `x` is the count of unique permutations attempted.","solution":"import random from itertools import permutations def quantum_bogo_sort(arr): Simulate Quantum Bogo Sort by counting unique permutations attempted to sort the array. Parameters: arr (list): List of integers to sort Returns: tuple: Sorted list and count of unique permutations attempted if len(arr) <= 1: return (arr, 0) sorted_arr = sorted(arr) unique_permutations = set() while True: shuffled_arr = tuple(random.sample(arr, len(arr))) unique_permutations.add(shuffled_arr) if list(shuffled_arr) == sorted_arr: break return sorted_arr, len(unique_permutations)"},{"question":"# Prime Number Validation Scenario In a computer security course, understanding the fundamental properties of prime numbers is essential for cryptographic applications. This problem requires implementing a function that validates whether a given number is prime. Task Write a function `is_prime_list(numbers)` that takes a list of integers and returns a list of boolean values indicating whether each number in the input list is a prime number. Input and Output Format * **Input**: - An integer list `numbers` where ( 1 leq text{len(numbers)} leq 10^6 ). - Each element ( n ) in the list satisfies ( 1 leq n leq 10^6 ). * **Output**: - A list of boolean values where each value corresponds to whether the respective input number is prime. Constraints * The function should be efficient enough to handle the upper limits of the inputs. Example ```python def is_prime_list(numbers): # Your implementation here # Example usage: print(is_prime_list([2, 3, 4, 5])) # Output: [True, True, False, True] print(is_prime_list([10, 17, 19])) # Output: [False, True, True] ``` Notes: * You should optimize the function for large input sizes. * Consider the edge cases as discussed in the analysis.","solution":"import math def is_prime_list(numbers): Return a list of boolean values indicating whether each number in the input list is prime. def is_prime(num): if num <= 1: return False if num == 2: return True # 2 is the only even prime number if num % 2 == 0: return False # other even numbers are not prime for i in range(3, int(math.sqrt(num)) + 1, 2): if num % i == 0: return False return True return [is_prime(number) for number in numbers]"},{"question":"Scenario A software engineer is optimizing a video game engine that often needs to determine whether certain sizes (e.g., buffer sizes) are powers of two. Given the efficiency requirement, it is crucial to implement a function that determines whether a given integer is a power of two in constant time. Task Implement the function `is_power_of_two(n)` that returns `True` if the given integer `n` is a power of two, otherwise returns `False`. # Function Signature ```python def is_power_of_two(n: int) -> bool: :type n: int :rtype: bool ``` # Input - `n`: A single integer, which can be positive, negative, or zero. # Output - Returns a boolean value `True` if `n` is a power of two, otherwise returns `False`. # Constraints - The input `n` can be any integer within the range of a 32-bit signed integer. - Performance should be optimal with a time complexity of O(1). # Examples ```python assert is_power_of_two(1) == True # 2^0 assert is_power_of_two(2) == True # 2^1 assert is_power_of_two(16) == True # 2^4 assert is_power_of_two(218) == False assert is_power_of_two(0) == False assert is_power_of_two(-2) == False ``` # Notes - Consider non-positive cases carefully. - Ensure you handle edge cases effectively.","solution":"def is_power_of_two(n: int) -> bool: Determines whether a given integer is a power of two. :param n: int - The integer to check. :return: bool - True if n is a power of two, otherwise False. # A power of two in binary form has only one \'1\' # and all other bits are \'0\' (e.g., 1, 10, 100, 1000, etc). # Therefore, n > 0 is a power of two if and only if (n & (n - 1)) == 0 # For example: 8 (1000 in binary) & 7 (0111 in binary) == 0 return n > 0 and (n & (n - 1)) == 0"},{"question":"# Question You are given a binary tree. Your task is to implement a function `zigzag_level(root)` that returns the zigzag level order traversal of the binary tree\'s nodes\' values. In zigzag level order traversal, the nodes are traversed as follows: 1. The first level is visited left to right. 2. The second level is visited right to left. 3. The third level is visited left to right. 4. This left to right and right to left traversal continues alternately for each level. Input - `root`: The root node of the binary tree. Output - A list of lists representing the zigzag level order traversal of the binary tree. Constraints - The number of nodes in the tree will be in the range [0, 10^4]. - The values of the nodes will be integers. Example ```python # Binary tree representation: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) # Expected output: # [ # [3], # [20, 9], # [15, 7] # ] print(zigzag_level(root)) # Output: [[3], [20, 9], [15, 7]] ``` Functional Requirements The function should run efficiently with a time complexity of O(n) and a space complexity of O(n).","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level(root): if not root: return [] results = [] level_nodes = deque([root]) left_to_right = True while level_nodes: level_result = [] for _ in range(len(level_nodes)): if left_to_right: node = level_nodes.popleft() level_result.append(node.val) if node.left: level_nodes.append(node.left) if node.right: level_nodes.append(node.right) else: node = level_nodes.pop() level_result.append(node.val) if node.right: level_nodes.appendleft(node.right) if node.left: level_nodes.appendleft(node.left) results.append(level_result) left_to_right = not left_to_right return results"},{"question":"You are given a serialized string of a binary tree which can be derived from the following data structure: ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None ``` Implement two functions, `serialize` and `deserialize`, to convert between a binary tree and its string representation using the following preorder serialization format: - Nodes are serialized in preorder. - `None` nodes are represented by the character `#`. The tree structure should be maintained exactly during the conversion processes. You may assume that the serialization format is valid. **Function Signatures**: ```python def serialize(root: TreeNode) -> str: pass def deserialize(data: str) -> TreeNode: pass ``` Example: Given the tree: 1 / 2 3 / 4 5 *Serialization*: ```python serialized_tree = serialize(root) # serialized_tree should be \\"1 2 # # 3 4 # # 5 # #\\" ``` *Deserialization*: ```python root = deserialize(\\"1 2 # # 3 4 # # 5 # #\\") # root should reconstruct the given tree structure ``` Constraints: 1. The input data (serialized tree string) is always valid. 2. Tree nodes contain integer values. 3. The tree can have at most 10^4 nodes. Implement the following: 1. Serialize a binary tree to a string. 2. Deserialize a string to return the original binary tree structure. **Note**: Make sure that your implementation handles deep trees gracefully to avoid recursion limit issues.","solution":"class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: Encodes a tree to a single string. def helper(node): if node is None: return \\"#\\" return f\\"{node.val} {helper(node.left)} {helper(node.right)}\\" return helper(root) def deserialize(data: str) -> TreeNode: Decodes your encoded data to tree. def helper(nodes): val = next(nodes) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = helper(nodes) node.right = helper(nodes) return node nodes = iter(data.split()) return helper(nodes)"},{"question":"# Coding Challenge: Integer Decomposition You are tasked with writing a function that finds the number of ways a given positive integer can be decomposed into the sum of smaller positive integers. This problem explores advanced dynamic programming concepts. Function Signature ```python def count_decompositions(n: int) -> int: pass ``` Input - An integer `n` where (1 leq n leq 100). Output - An integer representing the number of possible decompositions of `n`. Example ```python print(count_decompositions(4)) # Output: 5 print(count_decompositions(7)) # Output: 15 ``` Description In the context of decompositions: - `n=4` has the decompositions: `[4], [3+1], [2+2], [2+1+1], [1+1+1+1]` - `n=7` has 15 different ways to be decomposed into sums of smaller integers as illustrated in the example above. Constraints - Optimize the function to handle the upper limit efficiently. - Consider using dynamic programming to store intermediate results. Use the following rules to fill the 2D Dynamic Programming table: - `arr[i][j]` indicates how many ways `i` can be decomposed with integers up to `j`. - Utilize the transitions: - If `i < j`, set `arr[i][j] = arr[i][i]` - If `i == j`, set `arr[i][j] = 1 + arr[i][j-1]` - Otherwise, set `arr[i][j] = arr[i][j-1] + arr[i-j][j]` Implement the `count_decompositions` function to solve the problem.","solution":"def count_decompositions(n: int) -> int: Calculate the number of ways a given positive integer n can be decomposed into the sum of smaller positive integers. # Initialize a 2D array to store the number of ways to decompose `i` using integers up to `j` arr = [[0] * (n + 1) for _ in range(n + 1)] # Fill the table for i in range(n + 1): for j in range(n + 1): if i == 0: arr[i][j] = 1 # There\'s one way to decompose 0 elif j == 0: arr[i][j] = 0 # No way to decompose unless we use positive integers elif i < j: arr[i][j] = arr[i][i] # If i < j, use the number of ways to decompose i with itself as the limit else: arr[i][j] = arr[i][j - 1] + arr[i - j][j] # Use the sum of ways to decompose i with j-1 and i-j with j return arr[n][n]"},{"question":"**Problem Statement**: Given the class definitions for `Node` and `BTree`, your task is to implement additional functionality to check if the B-tree is valid. A B-tree is valid if it adheres to the following rules: 1. All leaves are at the same level. 2. Keys within each node are sorted in ascending order. 3. Each non-root node has at least `t-1` keys and at most `2*t - 1` keys, where `t` is the degree of the tree. 4. The root has at least 1 key. **Function Signature**: ```python def is_valid_btree(tree: BTree) -> bool: # Your code here ``` # Input - An instance of the `BTree` class. # Output - Return `True` if the B-tree is valid based on the rules above. - Return `False` otherwise. # Constraints - The degree `t` is at least 2. - The given `BTree` instance will only contain integers as keys. # Example ```python # Example tree (Degree t=2) btree = BTree(t_val=2) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) print(is_valid_btree(btree)) # Output: True ``` **Note**: You do not need to write the insertion or deletion logic; assume the given `BTree` insertion and deletion methods are correctly implemented. # Explanation The function `is_valid_btree` should traverse the tree to ensure that it satisfies all the constraints of a B-tree: 1. Check if all leaves are at the same level. 2. Ensure that keys within each node are sorted. 3. Validate that non-root nodes have between `t-1` and `2*t-1` keys. 4. Ensure the root has at least one key. Hints: - Use a level-order (BFS) traversal to check leaf levels. - Use recursion or iteration to validate keys and node properties.","solution":"class Node: def __init__(self, keys=None): if keys is None: self.keys = [] else: self.keys = keys self.children = [] self.leaf = True # By default, a new node is assumed to be a leaf class BTree: def __init__(self, t_val): self.root = Node() self.t = t_val # Assume functionality for insert_key, delete_key are provided elsewhere def is_valid_btree(tree: BTree) -> bool: if not tree.root: return True # An empty tree is trivially valid t = tree.t def depth_leaves(node): if node.leaf: return 1 if not node.children: return 1 child_depths = [depth_leaves(child) for child in node.children] if min(child_depths) != max(child_depths): return -1 # Invalid, leaves at different levels return child_depths[0] + 1 def validate_node(node, is_root): if len(node.keys) > (2 * t - 1): return False if not is_root and len(node.keys) < (t - 1): return False if not all(node.keys[i] <= node.keys[i + 1] for i in range(len(node.keys) - 1)): return False if not node.leaf: for i in range(len(node.keys) + 1): if not validate_node(node.children[i], False): return False return True # Check if all leaves are at the same level if depth_leaves(tree.root) == -1: return False # Validate all nodes return validate_node(tree.root, True)"},{"question":"Two Sum Target Problem Scenario You are tasked with creating a utility for an e-commerce platform that validates certain transaction constraints. Specifically, given a list of transaction amounts that is sorted in ascending order, find two amounts that sum to a specific target. Your task is to implement a function that returns the 1-based indices of these two amounts. Problem Statement Write a function `find_two_sum_indices(numbers, target)` that takes a list `numbers` of integers sorted in ascending order and an integer `target`, and returns a list of two integers representing the 1-based indices of the two numbers such that they add up to the target sum. Function Signature ```python def find_two_sum_indices(numbers: List[int], target: int) -> List[int]: ``` Input - `numbers`: A list of integers sorted in ascending order. (2 leq text{len(numbers)} leq 10^4) - `target`: An integer representing the target sum. Output - A list of two integers, representing the 1-based indices of the two numbers that add up to the target. The indices must satisfy `index1 < index2`. Constraints - Each input has exactly one solution. - You may not use the same element twice. - 1-based indexing is required for the returned indices. Example ```python # Example 1 numbers = [2, 7, 11, 15] target = 9 # Output: [1, 2] # Example 2 numbers = [1, 2, 3, 4, 4, 9, 56, 90] target = 8 # Output: [4, 5] ``` Notes - Ensure your solution runs within the time complexity constraints. - Consider edge cases where the sum involves the first and last elements of the array. Performance Requirements - Optimize your solution to run in O(n) time complexity with O(1) additional space complexity.","solution":"from typing import List def find_two_sum_indices(numbers: List[int], target: int) -> List[int]: Given an array `numbers` sorted in ascending order and a target `target`, returns the 1-based indices of the two numbers that add up to the target. left = 0 right = len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 # Should not reach here since exactly one solution is guaranteed return []"},{"question":"Problem Statement You are given an array of integers where every element appears exactly three times except for one, which appears exactly once. Implement a function to find and return that single unique number. Your algorithm should have a linear runtime complexity, and you should not use any extra memory beyond a few integer variables. Leverage bitwise operations to achieve this goal. Function Signature ```python def find_unique_number(nums: List[int]) -> int: This function receives a list of integers, `nums`, where every integer appears exactly three times except for one integer that appears only once. It returns the integer that appears exactly once. :param nums: List[int] - a list of integers :return: int - the single integer that appears once pass ``` Input - `nums`: A list of integers (1 <= len(nums) <= 10^5). Each integer in the list appears exactly three times except for one which appears only once. Output - Return the integer that appears exactly once. Constraints - The algorithm must have a linear runtime complexity O(n). - No additional memory should be used beyond a few integer variables. Example ```python assert find_unique_number([2, 2, 3, 2]) == 3 assert find_unique_number([0, 1, 0, 1, 0, 1, 99]) == 99 ``` Explanation In the first example, the integer `3` appears exactly once while `2` appears three times. Therefore, the function returns `3`. In the second example, `99` is the unique integer appearing once while `0` and `1` appear three times each.","solution":"def find_unique_number(nums): This function receives a list of integers, `nums`, where every integer appears exactly three times except for one integer that appears only once. It returns the integer that appears exactly once. :param nums: List[int] - a list of integers :return: int - the single integer that appears once one = two = 0 for num in nums: two |= one & num one ^= num three = one & two one &= ~three two &= ~three return one"},{"question":"Problem Statement You are given an integer `n` which represents the position in an infinitely long sequence of concatenated positive integers. For example, if we concatenate all integers, the sequence starts as \\"123456789101112131415...\\". Write a function `find_nth_digit(n)` that returns the nth digit in this sequence. # Input * An integer `n` where `1 <= n <= 2 * 10^9`. # Output * An integer representing the nth digit in the infinite sequence. # Constraints * The input `n` will always be a valid positive integer within the given range. # Performance Requirements * The solution should have a logarithmic time complexity, ideally O(log n). * The solution should use constant space, ideally O(1). # Example ```python def find_nth_digit(n): find the nth digit of given number. 1. find the length of the number where the nth digit is from. 2. find the actual number where the nth digit is from 3. find the nth digit and return length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n-1) // length s = str(start) return int(s[(n-1) % length]) # Example Test Cases print(find_nth_digit(3)) # Prints: 3 print(find_nth_digit(11)) # Prints: 0 print(find_nth_digit(189)) # Prints: 9 print(find_nth_digit(190)) # Prints: 1 ``` Implement the function and test against the provided examples to ensure its correctness.","solution":"def find_nth_digit(n): Returns the nth digit in the infinitely long sequence of concatenated positive integers. length = 1 count = 9 start = 1 # Find the length of the number where the nth digit is while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the actual number where the nth digit is start += (n - 1) // length # Find the nth digit and return s = str(start) return int(s[(n - 1) % length])"},{"question":"**Question: Word Pattern Matching** Given a pattern and a string \'s\', determine if \'s\' follows the same pattern as the given pattern string. Every character in the pattern should map to a word in the string, and vice versa, ensuring a one-to-one relationship. # Function Signature ```python def word_pattern(pattern: str, string: str) -> bool: pass ``` # Input * `pattern` (string): A pattern containing only lowercase letters. * `string` (string): A sentence containing words separated by a single space. # Output * Returns `True` if `string` follows the same pattern as `pattern`. * Returns `False` otherwise. # Constraints * The pattern string may contain only lowercase characters (\'a\'-\'z\'). * The string contains words separated by spaces and no leading or trailing spaces. * You may assume both the pattern and the string are non-empty. # Performance Requirements * The solution should ideally run in O(n) time complexity and utilize O(k) extra space, where n is the length of the string and k is the number of unique pattern characters or words. # Examples Example 1: ```python assert word_pattern(\\"abba\\", \\"dog cat cat dog\\") == True ``` Example 2: ```python assert word_pattern(\\"abba\\", \\"dog cat cat fish\\") == False ``` Example 3: ```python assert word_pattern(\\"aaaa\\", \\"dog cat cat dog\\") == False ``` Example 4: ```python assert word_pattern(\\"abba\\", \\"dog dog dog dog\\") == False ``` # Explanation: * In Example 1, each character in the pattern maps to a unique word bijectively. * In Example 2, the second \'a\' maps to \'dog\' instead of the second \'c\'. * In Example 3, multiple pattern characters map to different words. * In Example 4, single pattern character maps to multiple words. Implement the `word_pattern` function to find whether the given string follows the given pattern.","solution":"def word_pattern(pattern: str, string: str) -> bool: words = string.split() if len(pattern) != len(words): return False pattern_to_word = {} word_to_pattern = {} for p, w in zip(pattern, words): if p in pattern_to_word: if pattern_to_word[p] != w: return False else: if w in word_to_pattern: if word_to_pattern[w] != p: return False pattern_to_word[p] = w word_to_pattern[w] = p return True"},{"question":"Context You are working for a geospatial data company analyzing terrain elevation data stored in a matrix where each row and column is sorted in non-decreasing order. To help local governments and agencies in their planning and assessments, you need to efficiently locate specific elevation points within large datasets. Task Write a function `find_elevation(matrix: List[List[int]], m: int, n: int, target: int) -> Tuple[int, int]` to search for and return the position of a specific elevation (key) in a `m x n` matrix where every row and every column is sorted in non-decreasing order. If the target elevation is not found, return (-1, -1). Input - `matrix`: A 2D list of integers representing the elevation matrix. - `m`: An integer representing the number of rows in the matrix. - `n`: An integer representing the number of columns in the matrix. - `target`: An integer representing the elevation level that needs to be found. Output - A tuple of two integers `(row, col)` representing the position of the target elevation in the matrix. Indices should be 0-based. - If the target is not found, return `(-1, -1)`. Constraints - The elements of the matrix and the target value are integers. - The matrix is sorted in non-decreasing order row-wise and column-wise. - It is guaranteed that each element in the matrix is unique. Performance Requirements - Expected time complexity: O(m+n) - Expected space complexity: O(1) Example ```python def find_elevation(matrix, m, n, target): i, j = m - 1, 0 while i >= 0 and j < n: if target == matrix[i][j]: return (i, j) if target < matrix[i][j]: i -= 1 else: j += 1 return (-1, -1) # Test cases matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] print(find_elevation(matrix, 4, 3, 13)) # Output: (1, 2) print(find_elevation(matrix, 4, 3, 6)) # Output: (-1, -1) ```","solution":"from typing import List, Tuple def find_elevation(matrix: List[List[int]], m: int, n: int, target: int) -> Tuple[int, int]: i, j = m - 1, 0 while i >= 0 and j < n: if target == matrix[i][j]: return (i, j) if target < matrix[i][j]: i -= 1 else: j += 1 return (-1, -1)"},{"question":"# String Merge Validation You\'ve just joined a startup that is developing an advanced text editor. Part of your job is to help build an efficient merging feature that checks if a given string can be constructed by interweaving two other strings in their existing order. The goal is to understand the string interleaving problem thoroughly and optimize the solution to perform efficiently even for larger inputs. **Your task**: Write a function `is_merge(s: str, part1: str, part2: str) -> bool` that determines if `s` can be formed by merging `part1` and `part2` while preserving the character order of each string. Both recursive and iterative approaches are provided as references. # Constraints * All strings can contain lowercase letters (a-z) only. * Length of `s` is at most 1000. * Length of `part1` and `part2` can be up to 500 each. # Function Signature ```python def is_merge(s: str, part1: str, part2: str) -> bool: pass ``` # Input * `s`: String of length `n`. * `part1`: String of length `m`. * `part2`: String of length `k`. # Output * Returns `True` if `s` can be formed by interleaving `part1` and `part2` while preserving their order. * Returns `False` otherwise. # Examples ```python is_merge(\\"codewars\\", \\"cdw\\", \\"oears\\") # should return True is_merge(\\"codewars\\", \\"cdw\\", \\"oearsx\\") # should return False ``` # Requirements * Your solution should aim to be efficient in terms of both time and space. * Handling edge cases like empty strings should be done effectively. * Avoiding redundant calculations through optimizations is encouraged but not mandatory.","solution":"def is_merge(s: str, part1: str, part2: str) -> bool: if len(s) != len(part1) + len(part2): return False # Create a 2D DP table dp = [[False] * (len(part2) + 1) for _ in range(len(part1) + 1)] # Base case: empty part1 and part2 can form an empty s dp[0][0] = True # Fill the DP table for i in range(len(part1) + 1): for j in range(len(part2) + 1): if i > 0 and dp[i - 1][j] and s[i + j - 1] == part1[i - 1]: dp[i][j] = True if j > 0 and dp[i][j - 1] and s[i + j - 1] == part2[j - 1]: dp[i][j] = True return dp[len(part1)][len(part2)]"},{"question":"# Problem: Merging Two Sorted Linked Lists Description: You are given two non-empty linked lists representing two non-negative integers sorted in non-decreasing order. Your task is to merge these two linked lists into one sorted linked list and return it as a new sorted list. Function Signature: ```python def merge_two_sorted_lists(l1: Node, l2: Node) -> Node: ``` Input: * `l1` and `l2` - Two linked lists of integers in sorted order. Each linked list is composed of `Node` objects. * Each `Node` has an `int` `val` and a `Node` `next`. Output: * Returns a linked list that represents the merged result containing all the nodes from `l1` and `l2` in sorted order. Example: ```python # Creating two linked lists l1 = Node(1) l1.next = Node(2) l1.next.next = Node(4) l2 = Node(1) l2.next = Node(3) l2.next.next = Node(4) # Expected Output: 1->1->2->3->4->4 merged_list = merge_two_sorted_lists(l1, l2) # Function to print linked list values. def print_list(node): while node: print(node.val, end=\'->\') node = node.next print_list(merged_list) # Output: 1->1->2->3->4->4 ``` Constraints: * The number of nodes in both linked lists is in the range [0, 50]. * Each linked list is already sorted in non-decreasing order. * Both `l1` and `l2` are of type `Node` as defined above. Requirements: * Implement the function `merge_two_sorted_lists` that merges the two input linked lists. * The solution should perform efficiently with a time complexity of O(n + m) where n and m are the lengths of the two linked lists. * The function should handle edge cases, including empty linked lists or varying lengths.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: Node, l2: Node) -> Node: dummy = Node() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # Append the remaining nodes of l1 or l2 if l1: current.next = l1 elif l2: current.next = l2 return dummy.next"},{"question":"# RandomizedSet Implementation Context You are tasked with developing a `RandomizedSet` data structure that supports efficient insertion, deletion, and random element access. This structure is particularly useful in scenarios requiring quick membership tests and random sampling of elements, such as game development or load balancing algorithms. Objective Implement the `RandomizedSet` with the following operations: - **insert(val)**: Inserts an integer `val` into the set if not already present. - **remove(val)**: Removes an integer `val` from the set if present. - **getRandom()**: Returns a random element from the set with equal probability. Expected Function Signatures ```python def __init__(self) def insert(self, val: int) -> bool def remove(self, val: int) -> bool def get_random(self) -> int ``` Input and Output Formats - **insert(val)**: - Input: `val` (an integer to insert) - Output: Returns `True` if the element was successfully inserted; `False` otherwise. - **remove(val)**: - Input: `val` (an integer to remove) - Output: Returns `True` if the element was successfully removed; `False` otherwise. - **get_random()**: - Input: None - Output: Returns a randomly selected element from the set. Constraints - Elements should be integers within the range `-10^9 <= val <= 10^9`. - There should be at most `10^5` operations performed on the set. Performance Requirements - The average-case time complexity for all operations should be O(1). - The space complexity should be O(n), where n is the number of unique elements in the set. # Example ```python if __name__ == \\"__main__\\": rs = RandomizedSet() print(\\"insert 1: \\", rs.insert(1)) # True print(\\"insert 2: \\", rs.insert(2)) # True print(\\"insert 3: \\", rs.insert(3)) # True print(\\"insert 4: \\", rs.insert(4)) # True print(\\"remove 3: \\", rs.remove(3)) # True print(\\"remove 3: \\", rs.remove(3)) # False print(\\"remove 1: \\", rs.remove(1)) # True print(\\"random: \\", rs.get_random()) # Randomly returns one of the remaining elements: [2, 4] print(\\"random: \\", rs.get_random()) # Randomly returns one of the remaining elements: [2, 4] print(\\"random: \\", rs.get_random()) # Randomly returns one of the remaining elements: [2, 4] print(\\"random: \\", rs.get_random()) # Randomly returns one of the remaining elements: [2, 4] ``` Implement the RandomizedSet class according to the specifications above.","solution":"import random class RandomizedSet: def __init__(self): self.val_to_index = {} self.values = [] def insert(self, val: int) -> bool: if val in self.val_to_index: return False self.val_to_index[val] = len(self.values) self.values.append(val) return True def remove(self, val: int) -> bool: if val not in self.val_to_index: return False idx_to_remove = self.val_to_index[val] last_element = self.values[-1] self.values[idx_to_remove] = last_element self.val_to_index[last_element] = idx_to_remove self.values.pop() del self.val_to_index[val] return True def get_random(self) -> int: return random.choice(self.values)"},{"question":"# Question: Implement an In-Place Merge Sort Algorithm Merge Sort is an efficient, stable, and commonly used sorting algorithm. Typically, Merge Sort is not in-place because it requires additional space proportional to the input size to hold the merged arrays. However, it is possible to implement an in-place version of Merge Sort, which requires sorting and merging directly within the original array without using extra space. Task You are required to implement an in-place Merge Sort function that sorts an array of integers in ascending order. Function Signature ```python def in_place_merge_sort(arr): In-Place Merge Sort :param arr: List[int] - A list of integers to sort :return: None - The list should be sorted in-place # Your code here ``` Input * `arr` (List[int]): A list of `n` integers where `0 <= n <= 10^5` and `-10^9 <= arr[i] <= 10^9`. Output * The function should return None. The list `arr` should be sorted in-place. Constraints * The algorithm should have an average time complexity of O(n log n). * The algorithm should not use more than O(1) additional space. Example ```python arr = [38, 27, 43, 3, 9, 82, 10] in_place_merge_sort(arr) print(arr) # Output: [3, 9, 10, 27, 38, 43, 82] arr = [5, 2, 9, 1, 5, 6] in_place_merge_sort(arr) print(arr) # Output: [1, 2, 5, 5, 6, 9] arr = [] in_place_merge_sort(arr) print(arr) # Output: [] ``` Notes 1. You are required to implement the sorting algorithm without relying on any other in-built sorting functions. 2. Any additional memory usage apart from the input array will disqualify the solution.","solution":"def in_place_merge_sort(arr): def merge(arr, start, mid, end): start2 = mid + 1 # If the direct merge is already sorted if arr[mid] <= arr[start2]: return while start <= mid and start2 <= end: if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 while index != start: arr[index] = arr[index - 1] index -= 1 arr[start] = value start += 1 mid += 1 start2 += 1 def merge_sort(arr, left, right): if left < right: mid = left + (right - left) // 2 merge_sort(arr, left, mid) merge_sort(arr, mid + 1, right) merge(arr, left, mid, right) merge_sort(arr, 0, len(arr) - 1)"},{"question":"# Bubble Sort Coding Challenge Scenario: You are tasked with helping a school library to sort a list of student names alphabetically to maintain an organized record. The school uses an ancient system that requires you to implement the sorting algorithm manually without relying on built-in sorting functions. Task: Write a function `custom_bubble_sort(names)` that sorts a list of strings `names` (representing student names) alphabetically using the Bubble Sort algorithm. Function Signature: ```python def custom_bubble_sort(names: List[str]) -> List[str]: pass ``` Input * `names` (List[str]): A list of strings where each string is a student\'s name (1 ≤ len(names) ≤ 100). Output * Returns a list of strings sorted in alphabetical order. Example ```python assert custom_bubble_sort([\\"John\\", \\"Alice\\", \\"Bob\\"]) == [\\"Alice\\", \\"Bob\\", \\"John\\"] assert custom_bubble_sort([\\"Zed\\", \\"Yann\\", \\"Abbey\\"]) == [\\"Abbey\\", \\"Yann\\", \\"Zed\\"] ``` Constraints: * All names are unique. * Names contain only alphabetical characters and have a length of at least 1 and at most 100. Performance Requirements: * Your implementation should have a time complexity of O(N^2) in the worst-case scenario. Good luck!","solution":"from typing import List def custom_bubble_sort(names: List[str]) -> List[str]: Sorts a list of strings \'names\' using the Bubble Sort algorithm. Args: names (List[str]): A list of strings representing student names. Returns: List[str]: The list of strings sorted in alphabetical order. n = len(names) for i in range(n): for j in range(0, n-i-1): if names[j] > names[j+1]: names[j], names[j+1] = names[j+1], names[j] return names"},{"question":"# Binary Search Extended Problem Context: You\'ve been hired by a tech company to improve the efficiency of their data retrieval systems. The system handles millions of sorted records and needs to quickly find the presence and positions of given records. To help the system, you need to implement an advanced version of Binary Search that not only finds if an element exists in the array but also counts the frequency of the given element if it does exist. Task: Write a function `binary_search_extended(array, query)` that performs a binary search to determine if `query` is in the sorted list `array`. If found, the function should return the count of how many times `query` occurs in the `array`. If the element is not found, it should return 0. Implement an efficient solution with O(log n) time complexity for finding the element and an additional pass to count, summing up the complexity to O(log n) + O(c) where c is the count of occurrences. Function Signature: ```python def binary_search_extended(array: List[int], query: int) -> int: pass ``` Input: * `array` : A list of integers sorted in ascending order. * `query` : An integer value to search within the `array`. Output: * An integer representing the number of occurrences of `query` in `array`. Constraints: * The array will have at most `10^6` elements. * Each element in the array is an integer within the range `-10^6` to `10^6`. Example: ```python assert binary_search_extended([1, 1, 2, 2, 2, 3, 4], 2) == 3 assert binary_search_extended([5, 6, 6, 6, 9], 6) == 3 assert binary_search_extended([1, 2, 3, 4, 5], 6) == 0 ``` # Additional Information: * Ensure your solution is optimized for large datasets. * Avoid iterating the array more than necessary. * Consider edge cases such as very large arrays and values not present in the array.","solution":"from typing import List def binary_search_extended(array: List[int], query: int) -> int: def find_left_index(): lo, hi = 0, len(array) while lo < hi: mid = (lo + hi) // 2 if array[mid] < query: lo = mid + 1 else: hi = mid return lo def find_right_index(): lo, hi = 0, len(array) while lo < hi: mid = (lo + hi) // 2 if array[mid] <= query: lo = mid + 1 else: hi = mid return lo left_index = find_left_index() right_index = find_right_index() if left_index == len(array) or array[left_index] != query: return 0 return right_index - left_index"},{"question":"# Context You are tasked with implementing a function to solve a word search puzzle. Given a board of characters and a list of words, the function should return all words from the list that can be formed by letters sequentially adjacent and without reusing any cell. # Function Signature ```python def find_words(board: List[List[str]], words: List[str]) -> List[str]: pass ``` # Description You need to implement the `find_words` function that searches for words from a list on a given board of characters using Trie and backtracking. # Input 1. `board`: A 2D list of characters (size: `m x n`) representing the board. - For example, `[ [\'a\', \'b\'], [\'c\', \'d\'] ]`. 2. `words`: A list of strings representing the words to be searched from the board. - For example, `[\'abc\', \'bce\', \'cae\']`. # Output - A list of strings containing all the words found in the board from the input list. - For example, `[\'abc\', \'cae\']`. # Constraints 1. The dimensions of the board (`m x n`) can be up to `12 x 12`. 2. The length of words is at most 10. 3. Words are case-sensitive; all letters are lowercase. # Requirements 1. **Efficiency**: Utilize a Trie for efficient prefix searching combined with backtracking for exploring board cells. 2. **Edge Cases**: Handle cases where words may overlap, are absent, or cover multiple rows and columns correctly. 3. **Accuracy**: Ensure no cell is reused in forming a word and all positions are properly backtracked. # Example ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"] print(find_words(board, words)) # Output: [\'oath\', \'eat\'] ``` Implement the function `find_words` in Python to solve this problem.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.end_of_word = True def find_words(board: List[List[str]], words: List[str]) -> List[str]: def dfs(board, node, i, j, path, res): if node.end_of_word: res.add(path) node.end_of_word = False # Avoid duplicate words in result if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] not in node.children: return temp = board[i][j] board[i][j] = \'#\' # Mark the current cell as visited node = node.children[temp] # Explore all possible directions for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]: dfs(board, node, x, y, path + temp, res) board[i][j] = temp # Restore the current cell trie = Trie() for word in words: trie.insert(word) result = set() for i in range(len(board)): for j in range(len(board[0])): if board[i][j] in trie.root.children: dfs(board, trie.root, i, j, \'\', result) return list(result)"},{"question":"Scenario In cryptographic algorithms and advanced number theory operations, modular arithmetic is performed extensively, particularly the calculation of modular inverses. Given two integers `a` and `m` that are coprime, your task is to write a function that computes the modular inverse of `a` under modulo `m` such that `(a * x) % m = 1`. Challenging Requirement Write a function `find_modular_inverse(a: int, m: int) -> int` that returns the modular inverse of `a` with respect to `m`. # Specifications * **Functions to Implement**: `find_modular_inverse` * **Input**: * Two integers `a` and `m` where 1 <= `a`, `m` <= 10^6 * `a` and `m` are guaranteed to be coprime. * **Output**: * A single integer, the modular inverse of `a` with respect to `m` such that `(a * x) % m = 1`. * **Constraints**: * You must utilize the Extended Euclidean Algorithm to calculate the modular inverse. * You may assume both `a` and `m` are positive integers. # Examples * Input: `find_modular_inverse(3, 11)` * Output: `4` * Explanation: `3 * 4 % 11 = 12 % 11 = 1` * Input: `find_modular_inverse(10, 17)` * Output: `12` * Explanation: `10 * 12 % 17 = 120 % 17 = 1` ***Note**: Raising exceptions for invalid input (non-coprime pairs) is not necessary as inputs are guaranteed to be valid.* ```python def find_modular_inverse(a: int, m: int) -> int: # Your solution here ```","solution":"def find_modular_inverse(a: int, m: int) -> int: Find the modular inverse of a under modulo m using the Extended Euclidean Algorithm. def extended_gcd(aa, bb): # Base case if bb == 0: return aa, 1, 0 gcd, x, y = extended_gcd(bb, aa % bb) return gcd, y, x - (aa // bb) * y gcd, x, y = extended_gcd(a, m) if gcd != 1: # This should never happen since a and m are guaranteed to be coprime return None else: return x % m"},{"question":"Context: You are developing a feature for an application that deals with binary sequences and digital signal processing. One common operation is to determine how altering an existing binary sequence could optimize the signal based on certain criteria. Problem: Given an integer `num`, you can flip exactly one bit from `0` to `1`. Write a function that finds the length of the longest sequence of `1`s you can create by making this one bit flip. Function Signature: ```python def flip_bit_longest_seq(num: int) -> int: # Implementation here ``` Input: - An integer `num` (0 <= num <= 2^31 - 1) Output: - An integer representing the length of the longest sequence of `1`s possible after flipping one bit. Constraints: - You must use bitwise operations to solve this problem. Example: ```python # Example 1: input: 1775 output: 8 # Example 2: input: 0 output: 1 # Example 3: input: 15 output: 5 ``` Requirements: - Your solution should run efficiently within the constraints. - Handle edge cases carefully, including the binary representations where all bits are already `1`s or `0`s.","solution":"def flip_bit_longest_seq(num: int) -> int: if num == 0: return 1 current_len = 0 prev_len = 0 max_len = 0 while num != 0: if (num & 1) == 1: current_len += 1 else: prev_len = current_len if (num & 2) else 0 # check next bit current_len = 0 max_len = max(max_len, current_len + prev_len + 1) num >>= 1 return max_len"},{"question":"Given two strings `s1` and `s2`, where `s2` contains all distinct characters, write a function `max_common_sub_string(s1: str, s2: str) -> int` to find the length of the longest common subsequence. Input - Two strings `s1` and `s2`. * `0 <= len(s1), len(s2) <= 10^4` * `s2` contains unique characters. Output - Return the length of the longest common subsequence between `s1` and `s2`. Constraints - Aim for a time complexity of O(n log n) if possible, otherwise a clearly optimized solution. Example ```python # Example 1: s1 = \\"abcde\\" s2 = \\"ace\\" # Output: 3 # Explanation: The longest common subsequence is \\"ace\\" with a length of 3. # Example 2: s1 = \\"abc\\" s2 = \\"def\\" # Output: 0 # Explanation: There are no common subsequences between s1 and s2. # Example 3: s1 = \\"abcdaf\\" s2 = \\"acbcf\\" # Output: 4 # Explanation: The longest common subsequence is \\"abcf\\" with a length of 4. ``` Instructions 1. Design an algorithm that effectively utilizes dynamic programming or memoization. 2. Implement the function and include edge cases for empty strings or no common characters.","solution":"def max_common_sub_string(s1: str, s2: str) -> int: Returns the length of the longest common subsequence between s1 and s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"**Context**: You are given a string consisting only of digits and a target integer value. Your task is to evaluate all possible expressions by inserting \'+\', \'-\', and \'*\' between the digits to determine all the possible strings that can evaluate to the target value. # Problem Statement Implement the function `add_operators(num, target)` which takes in: * A string `num` consisting only of digits (\'0\'-\'9\') * An integer `target` which is the desired value of expressions formed from `num` Return all strings that evaluate to the `target` value when expression. # Input Format: * A string `num` where `1 <= len(num) <= 10` consisting only of digits. * An integer `target` which can be any integer including negative values. # Output Format: * A list of strings representing all valid expressions that evaluate to the target value. If no valid expressions exist, return an empty list. # Constraints: * You must use all the digits in `num`. * Leading zeros in any number part of an expression are not allowed unless the number itself is \'0\'. # Examples: ```python # Example 1 num = \\"123\\" target = 6 add_operators(num, target) # Expected Output: [\\"1+2+3\\", \\"1*2*3\\"] # Example 2 num = \\"232\\" target = 8 add_operators(num, target) # Expected Output: [\\"2*3+2\\", \\"2+3*2\\"] # Example 3 num = \\"105\\" target = 5 add_operators(num, target) # Expected Output: [\\"1*0+5\\", \\"10-5\\"] # Example 4 num = \\"00\\" target = 0 add_operators(num, target) # Expected Output: [\\"0+0\\", \\"0-0\\", \\"0*0\\"] # Example 5 num = \\"3456237490\\" target = 9191 add_operators(num, target) # Expected Output: [] ``` # Task Provide a comprehensive implementation of the function `add_operators(num, target)`. Your solution should handle the constraints efficiently and account for various edge cases such as leading zeros and non-existent valid expressions for given input.","solution":"def add_operators(num, target): def dfs(index, prev_operand, current_operand, value, expression): # If we\'ve reached the end of the string, check if the current value equals the target if index == len(num): if value == target and current_operand == 0: results.append(\\"\\".join(expression[1:])) # skip the first dummy \'+\' return # Extend the current operand by one digit current_operand = current_operand * 10 + int(num[index]) str_op = str(current_operand) # We can\'t have numbers with multiple digits where the first is \'0\' if current_operand > 0: # No operator before dfs(index + 1, prev_operand, current_operand, value, expression) # + expression.append(\'+\') expression.append(str_op) dfs(index + 1, current_operand, 0, value + current_operand, expression) expression.pop() expression.pop() if expression: # - expression.append(\'-\') expression.append(str_op) dfs(index + 1, -current_operand, 0, value - current_operand, expression) expression.pop() expression.pop() # * expression.append(\'*\') expression.append(str_op) dfs(index + 1, prev_operand * current_operand, 0, value - prev_operand + (prev_operand * current_operand), expression) expression.pop() expression.pop() results = [] dfs(0, 0, 0, 0, []) return results"},{"question":"# Scenario You are a programmer working on a mathematical software library, and you need to implement functions that can compute the Greatest Common Divisor (GCD) and the number of trailing zeros efficiently. The software you are contributing to is used in high-performance environments, hence both the correctness and the efficiency of the algorithms are crucial. Also, a newer bitwise approach should be optimized for GCD computation in this library. # Question Function 1: gcd Implement a function `gcd(a, b)` that computes the greatest common divisor (GCD) of two non-negative integers `a` and `b` using Euclid\'s Algorithm. **Function Signature** ```python def gcd(a: int, b: int) -> int: ``` **Input** - `a` and `b`: Non-negative integers (0 <= a, b <= 10^18) **Output** - Returns the GCD of `a` and `b`. **Constraints** - If both `a` and `b` are zero, return 0 to indicate invalid GCD. Function 2: trailing_zero Implement a function `trailing_zero(x)` that computes the number of trailing zeros in the binary representation of a non-negative integer `x`. **Function Signature** ```python def trailing_zero(x: int) -> int: ``` **Input** - `x`: Non-negative integer (0 <= x <= 10^18) **Output** - Returns the count of trailing zeros in the binary representation of `x`. **Constraints** - If `x` is 0, return 0. Function 3: gcd_bit Implement a function `gcd_bit(a, b)` that computes the greatest common divisor (GCD) using bitwise operations. **Function Signature** ```python def gcd_bit(a: int, b: int) -> int: ``` **Input** - `a` and `b`: Non-negative integers (0 <= a, b <= 10^18) **Output** - Returns the GCD of `a` and `b`. **Constraints** - Use bitwise operations where possible for efficiency. # Examples ```python assert gcd(48, 18) == 6 assert trailing_zero(34) == 1 assert trailing_zero(40) == 3 assert gcd_bit(48, 18) == 6 ``` # Notes - Ensure all functions handle edge cases, such as zero inputs, appropriately. - Aim to optimize for time complexity in your implementations. - Provide meaningful error messages for invalid inputs.","solution":"def gcd(a: int, b: int) -> int: Uses Euclid\'s algorithm to compute the greatest common divisor of a and b. if a == 0 and b == 0: return 0 # Undefined GCD condition while b: a, b = b, a % b return abs(a) def trailing_zero(x: int) -> int: Counts the number of trailing zeros in the binary representation of x. if x == 0: return 0 count = 0 while (x & 1) == 0: count += 1 x >>= 1 return count def gcd_bit(a: int, b: int) -> int: Computes the greatest common divisor using bitwise operations. if a == 0: return b if b == 0: return a if a == b: return a # Both numbers are even if (a & 1) == 0 and (b & 1) == 0: return gcd_bit(a >> 1, b >> 1) << 1 # a is even, b is odd if (a & 1) == 0: return gcd_bit(a >> 1, b) # a is odd, b is even if (b & 1) == 0: return gcd_bit(a, b >> 1) # Both numbers are odd, reduce the larger number if a > b: return gcd_bit((a - b) >> 1, b) return gcd_bit(a, (b - a) >> 1)"},{"question":"Given a singly linked list and an integer k, write a function `find_kth_to_last(head: Node, k: int) -> Node` that returns the k-th to last node of the linked list. Return `None` if the specified node does not exist due to invalid k or an empty list. # Constraints * The linked list contains at least 0 and up to 10^5 nodes * k is an integer such that 0 <= k < 10^5 # Input * A linked list node `head` that represents the head of a singly linked list. * An integer `k` which is the index from the end (0-based). # Output * Return the node which is the k-th to last in the list. # Example Consider the linked list: ``` A -> B -> C -> D -> E ``` - For k = 0, output should be the node with value `E`. - For k = 2, output should be the node with value `C`. - For k = 5, output should be `None` because the list has less than 6 elements. # Scenario You are working on a file processing system where each file\'s history is managed as a linked list for various operations. You need to efficiently access recent file modifications by their relative ending position. # Implementation Implement the function: ```python class Node: def __init__(self, val=None): self.val = val self.next = None def find_kth_to_last(head: Node, k: int) -> Node: # Your code goes here pass ``` # Constraints & Notes 1. Ensure that you handle cases where k is larger than the list size. 2. Optimize for both time and space complexity.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_kth_to_last(head: Node, k: int) -> Node: Returns the k-th to last node of the linked list. # Use the two-pointer technique to find the k-th to last node slow = fast = head # Move fast k steps ahead for _ in range(k): if not fast: return None # k is larger than the length of the list fast = fast.next # If fast is None at this point, it means the list size is k if not fast: return None # Move slow and fast pointers together until fast reaches the end while fast.next: slow = slow.next fast = fast.next return slow"},{"question":"# Binary Search Tree Level Order Traversal Given the provided implementation of a Binary Search Tree (BST) above, please extend the BST class to include a method for level order traversal. Level order traversal visits nodes level by level from top to bottom and left to right at each level. # Level Order Traversal Definition In a level order traversal, nodes are visited as follows: 1. Start at the root node. 2. Visit all nodes at the current level from left to right. 3. Move to the next level below and repeat the process. # Function Signature ```python def level_order_traversal(self, root: Node) -> List[int]: Perform level order traversal of the tree starting from the given root. :param root: Node, the root of the binary search tree :return: List[int], a list of node values in level order pass ``` # Input * BST instance with the root node. * Example tree similar to the one described above. # Output * List of node values representing the level order traversal of the tree. # Constraints * Your solution should efficiently handle trees with up to 10^4 nodes. * Utilize optimal space complexity within O(N) bound and optimal time complexity of O(N). # Example Scenario Given the BST defined above: ``` 10 / 6 15 / / 4 9 12 24 / / 7 20 30 / 18 ``` The level order traversal of this tree should return: ``` [10, 6, 15, 4, 9, 12, 24, 7, 20, 30, 18] ``` # Task 1. Implement the `level_order_traversal` method within the BST class. 2. Ensure correctness by creating appropriate unittests that validate your implementation using the provided example and additional test cases of your own design. # Additional Points * Consider using a queue to manage the nodes at each level. * Handle edge cases like an empty tree gracefully. * Write clear and concise code with appropriate documentation.","solution":"from collections import deque from typing import List, Optional class Node: def __init__(self, key: int): self.data = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key: int): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node: Node, key: int): if key < node.data: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) def level_order_traversal(self, root: Optional[Node]) -> List[int]: if not root: return [] result = [] queue = deque([root]) while queue: node = queue.popleft() result.append(node.data) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"# Matrix Operations Challenge Implement a function that utilizes matrix exponentiation to compute a special kind of power sum for a given square matrix. Task Write a function `matrix_power_sum(mat: list, power: int) -> list` that accepts: - `mat`: A square matrix of integers of size n x n. - `power`: An integer `p` representing the power to which matrices will be raised. The function should return the sum of matrices from `mat^0` to `mat^p` (inclusive). Utilize matrix exponentiation by repeated squaring to compute the powers efficiently. Input - A square matrix `mat` of size `n x n` where `1 <= n <= 50`. - An integer `power` where `0 <= power <= 50`. Output - A square matrix of size `n x n` which represents the sum of matrices from `mat^0` to `mat^p`. Constraints - Ensure that the solution is efficient, leveraging matrix exponentiation by repeated squaring. - Avoid manually multiplying the matrices in a loop for each power due to performance constraints. Example ```python mat = [ [1, 1], [1, 0] ] power = 3 The result should be: [ [4, 3], [3, 2] ] ``` Explanation: The sum S can be broken down as follows: ``` S = mat^0 + mat^1 + mat^2 + mat^3 Where: mat^1 = [[1, 1], [1, 0]] mat^2 = [[2, 1], [1, 1]] mat^3 = [[3, 2], [2, 1]] So, S = [[1, 0], [0, 1]] + [[1, 1], [1, 0]] + [[2, 1], [1, 1]] + [[3, 2], [2, 1]] = [[1+1+2+3, 0+1+1+2], [0+1+1+2, 1+0+1+1]] = [[7, 4], [4, 3]] ``` Implement the function `matrix_power_sum(mat, power)` to achieve this result.","solution":"def matrix_power_sum(mat, power): def matrix_mult(A, B): n = len(A) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[i][j] = sum(A[i][k] * B[k][j] for k in range(n)) return result def matrix_identity(n): return [[1 if i == j else 0 for i in range(n)] for j in range(n)] def matrix_pow(A, p): n = len(A) result = matrix_identity(n) base = A while p: if p % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) p //= 2 return result def matrix_add(A, B): n = len(A) return [[A[i][j] + B[i][j] for j in range(n)] for i in range(n)] n = len(mat) sum_matrix = matrix_identity(n) current_powered_matrix = matrix_identity(n) for p in range(1, power + 1): current_powered_matrix = matrix_mult(current_powered_matrix, mat) sum_matrix = matrix_add(sum_matrix, current_powered_matrix) return sum_matrix"},{"question":"# Rabin-Karp Pattern Matching **Background**: Imagine you are designing a text search engine that needs to find the first occurrence of a given word (pattern) in a large text document. You decide to use the Rabin-Karp algorithm due to its efficient average-case performance. **Task**: Implement the Rabin-Karp algorithm to find the first occurrence of a pattern in a given text. Your task is to write a function `find_word` that returns the starting index of the first occurrence of the word in the text, or `None` if the word is not found. **Function Signature**: ```python def find_word(pattern: str, text: str) -> int: ``` # Input: * `pattern` (string): The word to be searched within the text. * `text` (string): The text document in which the word is to be searched. # Output: * An integer representing the starting index of the first occurrence of the word in the text or `None` if the word is not found. # Constraints: * 1 <= len(pattern) <= 10^4 * 1 <= len(text) <= 10^5 * The text and the pattern consist of lowercase English letters only. # Example: ```python find_word(\\"test\\", \\"this is a simple test string\\") # Returns 17 find_word(\\"notfound\\", \\"this is a simple test string\\") # Returns None find_word(\\"a\\", \\"aaa\\") # Returns 0 ``` # Requirements: * Your implementation must handle edge cases such as empty text or pattern. * Optimize your solution for performance; minimize hash collisions.","solution":"def find_word(pattern: str, text: str) -> int: Implements the Rabin-Karp algorithm to find the first occurrence of a pattern in the given text. Returns the starting index of the first occurrence of the pattern in the text, or None if not found. if not pattern or not text or len(pattern) > len(text): return None base = 256 prime = 101 pattern_len = len(pattern) text_len = len(text) pattern_hash = 0 text_hash = 0 h = 1 for i in range(pattern_len - 1): h = (h * base) % prime for i in range(pattern_len): pattern_hash = (base * pattern_hash + ord(pattern[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime for i in range(text_len - pattern_len + 1): if pattern_hash == text_hash: if text[i:i + pattern_len] == pattern: return i if i < text_len - pattern_len: text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + pattern_len])) % prime if text_hash < 0: text_hash += prime return None"},{"question":"Run-Length Encoding and Decoding Extensions Context: Run-length encoding (RLE) is a simple and widely used data compression algorithm. Given its straightforward implementation, it is often used to demonstrate the principles of compression algorithms. This task will extend your understanding and application of the RLE algorithm by modifying it to handle more complex cases of repeating sequences. Task: You are required to implement an extended version of the run-length encoding (RLE) algorithm, where the input might contain various characters including non-alphanumeric symbols, and you will need to handle sequences of up to length 999. Requirements: 1. Implement a function `extended_encode_rle(input: str) -> str` that compresses the input string using an extended RLE approach. 2. Implement a function `extended_decode_rle(input: str) -> str` that decompresses the encoded string back to its original form. Specifications: - **Input Format**: - `extended_encode_rle` receives a string `input` which can contain any printable ASCII characters. - `extended_decode_rle` receives a string `input` which is the encoded RLE string. - **Output Format**: - `extended_encode_rle` returns a string representing the encoded RLE. - `extended_decode_rle` returns the decoded original string. - **Constraints**: - The length of the input string should not exceed 10^6 characters. - The repeating count for characters should be handled up to length 999. Example: ```python # Encoding Example input_str = \\"aaabbbbccddddd\\" encoded_str = extended_encode_rle(input_str) print(encoded_str) # Expected Output: \\"3a4b2c5d\\" # Decoding Example encoded_str = \\"3a4b2c5d\\" decoded_str = extended_decode_rle(encoded_str) print(decoded_str) # Expected Output: \\"aaabbbbccddddd\\" ``` Performance Requirements: - The solution should be optimized for both time and space, considering the constraints provided.","solution":"def extended_encode_rle(input: str) -> str: Compresses the input string using an extended RLE approach. if not input: return \\"\\" encoded_str = [] count = 1 for i in range(1, len(input)): if input[i] == input[i-1]: count += 1 else: encoded_str.append(f\\"{count}{input[i-1]}\\") count = 1 # Append the last sequence encoded_str.append(f\\"{count}{input[-1]}\\") return \'\'.join(encoded_str) def extended_decode_rle(input: str) -> str: Decompresses the encoded string using an extended RLE approach back to its original form. if not input: return \\"\\" decoded_str = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: decoded_str.append(char * count) count = 0 return \'\'.join(decoded_str)"},{"question":"# Comb Sort Implementation and Enhancement **Scenario:** You are tasked with enhancing a sorting function for a data processing system that deals with logs of events. The current bubble sort algorithm needs optimization to handle larger datasets efficiently. You\'ve learned about Comb Sort and its improvements over Bubble Sort. Your task is to implement this algorithm and test it under various scenarios. **Task:** Implement a function `enhanced_comb_sort(arr: List[int]) -> List[int]` that performs Comb Sort on the provided list of integers. Additionally, your function should optimize the choice of the shrink factor and handle different edge cases effectively. # Requirements: 1. **Function Signature**: ```python from typing import List def enhanced_comb_sort(arr: List[int]) -> List[int]: pass ``` 2. **Input/Output**: - Input: A list of integers `arr` where `0 <= len(arr) <= 10^6` and each element `-10^9 <= arr[i] <= 10^9`. - Output: The sorted list of integers. 3. **Performance Constraints**: - Aim for better average-case performance than Bubble Sort (O(N^2)). - Ensure the function runs within acceptable limits for large sized lists (up to 10^6 elements). 4. **Edge Cases**: - Arrays with one element. - Empty arrays. - Arrays with all identical elements. - Arrays sorted in reverse order. - Arrays already sorted. # Notes: - Pay close attention to the choice of the shrink factor. - Ensure your implementation is robust against the aforementioned edge cases. - Write clean and efficient code to handle large datasets. # Example: ```python assert enhanced_comb_sort([5, 3, 8, 4, 2]) == [2, 3, 4, 5, 8] assert enhanced_comb_sort([]) == [] assert enhanced_comb_sort([1]) == [1] assert enhanced_comb_sort([5, 5, 5, 5, 5]) == [5, 5, 5, 5, 5] assert enhanced_comb_sort([9, -3, 5, 0, -2, 3]) == [-3, -2, 0, 3, 5, 9] ``` --- Ensure to test your implementation with additional test cases to validate its efficiency and correctness.","solution":"from typing import List def enhanced_comb_sort(arr: List[int]) -> List[int]: Perform Comb Sort on the provided list of integers. n = len(arr) gap = n shrink_factor = 1.3 sorted = False while not sorted: gap = int(gap // shrink_factor) if gap <= 1: gap = 1 sorted = True for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr"},{"question":"# Symmetric Binary Tree Checker Scenario Given a binary tree, determine if it is symmetric around its center. A tree is symmetric if a line drawn through its root splits the tree into two mirror-image halves. Function Specifications * **Function Name**: `is_symmetric` * **Input**: A reference to the root node of a binary tree, where nodes have integer values. * **Output**: A boolean value - `True` if tree is symmetric, `False` otherwise. # Recursive Approach: Implement a recursive helper function that determines if two trees are mirrors of each other. # Iterative Approach: Implement an iterative function utilizing a stack to simulate the recursive mirror check between nodes. Constraints * The number of nodes in the tree is in the range `[0, 1000]`. * Node values are integers in the range `[-1000, 1000]`. Example ```python # Define TreeNode class for the below inputs class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example 1: Symmetric tree # To construct the following symmetric tree # 1 # / # 2 2 # / / # 3 4 4 3 tree1 = TreeNode(1) tree1.left = TreeNode(2) tree1.right = TreeNode(2) tree1.left.left = TreeNode(3) tree1.left.right = TreeNode(4) tree1.right.left = TreeNode(4) tree1.right.right = TreeNode(3) assert is_symmetric(tree1) == True # Example 2: Non-symmetric tree # To construct the following non-symmetric tree # 1 # / # 2 2 # # 3 3 tree2 = TreeNode(1) tree2.left = TreeNode(2) tree2.right = TreeNode(2) tree2.left.right = TreeNode(3) tree2.right.right = TreeNode(3) assert is_symmetric(tree2) == False ``` Implement both the recursive and iterative methods to achieve the desired results. **Bonus**: Provide a discussion on the differences in efficiency and any trade-offs between the recursive and iterative approaches.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_symmetric(root): Determines if a binary tree is symmetric around its center. if not root: return True def is_mirror(left, right): if not left and not right: return True if not left or not right: return False if left.val != right.val: return False return is_mirror(left.left, right.right) and is_mirror(left.right, right.left) return is_mirror(root.left, root.right)"},{"question":"# Cycle Sort Implementation Given an array of integers, implement the Cycle Sort algorithm to sort the array in ascending order. Your implementation should maintain the properties of Cycle Sort, in particular, minimizing the number of writes. # Input Format * An integer array `arr` where each element ( arr[i] ) is an integer. # Output Format * Return the sorted array `arr` in ascending order. # Constraints * (1 leq text{length of } arr leq 10^5) * (-10^6 leq arr[i] leq 10^6) # Example **Input** ```python arr = [4, 3, 2, 1] ``` **Output** ```python [1, 2, 3, 4] ``` **Input** ```python arr = [5, 6, 1, 2, 9] ``` **Output** ```python [1, 2, 5, 6, 9] ``` # Additional Notes * Your code should aim to perform sorting with minimal overwrite operations. * Pay particular attention to handling of edge cases such as arrays with duplicate elements.","solution":"def cycle_sort(arr): Perform Cycle Sort on the array and return the sorted array. writes = 0 # Loop through the array to find cycles to rotate for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find where to put the item pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Skip duplicate elements while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Mode Finder Given an array of integers, write a function `find_mode(arr)` that returns a list of the most frequently occurring element(s). The function should be efficient in both time and space. **Function Signature**: ```python def find_mode(arr: List[int]) -> List[int]: pass ``` # Input * `arr` (List[int]): A list of integers, which may contain duplicates. The list can be empty. # Output * Returns a list of integers which are the most frequently occurring element(s) in `arr`. The order of elements in the output list does not matter. # Constraints * Each element in the array should be considered an integer. * You need to implement the function to perform with the optimal time complexity (O(n)) and reasonable space efficiency. # Example ```python assert find_mode([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_mode([5, 5, 5, 3, 3, 2]) == [5] assert find_mode([]) == [] assert find_mode([1, 2, 3, 4]) == [1, 2, 3, 4] ``` # Instructions: 1. Implement the function `find_mode` as per the specifications. 2. Make sure your function handles edge cases such as empty arrays and arrays with all unique elements. 3. Use appropriate data structures to optimize space usage.","solution":"from typing import List from collections import Counter def find_mode(arr: List[int]) -> List[int]: if not arr: return [] counter = Counter(arr) max_count = max(counter.values()) return [key for key, count in counter.items() if count == max_count]"},{"question":"**Linked List Partitioning:** Given a singly linked list and an integer `x`, write a function to partition the linked list such that all nodes less than `x` come before nodes greater than or equal to `x`. The relative order of nodes in each partition should remain the same as in the original linked list. Example: ```plaintext Input: 3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1, partition=5 Output: 3 -> 2 -> 1 -> 5 -> 8 -> 5 -> 10 ``` # Function Signature ```python class Node: def __init__(self, val=None): self.val = int(val) self.next = None def partition(head: Node, x: int) -> Node: # Implement this function ``` # Constraints * The input linked list contains at most 10^4 nodes. * The linked list values can range from -10^4 to 10^4. * The partition value `x` can also range from -10^4 to 10^4. # Implementation Details 1. You are provided with a `Node` class to construct linked list nodes. 2. Implement the `partition` function to rearrange nodes in place. # Additional Functions * Provide a helper function `print_linked_list(head: Node) -> None` to visualize the linked list before and after partitioning. # Testing Create several test cases ensuring to cover edge cases such as: * Empty list. * List with all nodes having values less than `x`. * List with all nodes having values greater than or equal to `x`.","solution":"class Node: def __init__(self, val=None): self.val = int(val) self.next = None def partition(head: Node, x: int) -> Node: less_head = Node(0) # Dummy head for less than x sublist greater_head = Node(0) # Dummy head for greater than or equal to x sublist less = less_head greater = greater_head current = head while current: if current.val < x: less.next = current less = less.next else: greater.next = current greater = greater.next current = current.next # Combine the two lists greater.next = None # End of greater list less.next = greater_head.next # Combine return less_head.next def print_linked_list(head: Node) -> None: current = head while current: print(current.val, end=\\" -> \\" if current.next else \\"n\\") current = current.next"},{"question":"You are tasked with writing a function to remove reoccurring characters from a given string while maintaining the order of their first appearance. This problem often appears in coding interviews, and it assesses your understanding of string manipulation and set operations. # Function Signature ```python def delete_reoccurring_characters(string: str) -> str: ``` # Input - **string**: A string `string` (1 ≤ |string| ≤ 10^5) consisting of uppercase and lowercase English letters. # Output - **output_string**: A string with all duplicated characters removed, keeping only the first occurrence of each character. # Constraints - The function should handle case sensitivity; \'a\' and \'A\' are considered distinct characters. - The function must have a time complexity of O(n) and a space complexity of O(n). # Example Input: ```python string = \\"aabcbcbac\\" ``` Output: ```python \\"abc\\" ``` Input: ```python string = \\"abcd\\" ``` Output: ```python \\"abcd\\" ``` # Edge Cases - Input: \\"aaaa\\", should return \\"a\\". - Input: \\"\\", should return \\"\\" (empty string). - Input: \\"a\\", should return \\"a\\". # Notes 1. Assume the input string contains only standard English letters. 2. Handle empty strings gracefully without errors. Write a function `delete_reoccurring_characters` that meets the above specifications and constraints.","solution":"def delete_reoccurring_characters(string: str) -> str: Remove reoccurring characters from the given string while maintaining the order of their first appearance. seen = set() output = [] for char in string: if char not in seen: seen.add(char) output.append(char) return \'\'.join(output)"},{"question":"# Find the Extra Character **Scenario**: You are given two strings, `s` and `t`. The string `t` is generated from string `s` by shuffling its characters and adding one extra character at a random position. **Task**: Write a function `find_extra_char(s, t)` that computes the extra character added to t. **Function Signature**: ```python def find_extra_char(s: str, t: str) -> str: pass ``` **Input**: - `s` (string): A string consisting of lowercase letters. - `t` (string): A string that is a permutation of `s` with one additional lowercase letter. **Output**: - (string): The extra character added to `t`. **Example**: ```python assert find_extra_char(\\"abcd\\", \\"abecd\\") == \'e\' assert find_extra_char(\\"hello\\", \\"hlello\\") == \'l\' assert find_extra_char(\\"\\", \\"z\\") == \'z\' ``` **Constraints**: - All characters are lowercase letters. - The length of string `t` is equal to the length of string `s` plus one.","solution":"def find_extra_char(s: str, t: str) -> str: from collections import Counter count_s = Counter(s) count_t = Counter(t) for char in count_t: if count_t[char] != count_s.get(char, 0): return char # Example usage: # find_extra_char(\\"abcd\\", \\"abecd\\") == \'e\' # find_extra_char(\\"hello\\", \\"hlello\\") == \'l\' # find_extra_char(\\"\\", \\"z\\") == \'z\'"},{"question":"**Objective**: Implement an optimized function to remove duplicates from an input array and return a new array maintaining the order of first occurrences of each element. Context You are tasked with processing a large list of data entries where some entries are repeated. Your goal is to efficiently remove duplicates to ensure each entry appears only once in the list while preserving the original order. Input and Output Formats * **Input**: A list `array` containing elements of any data type (integers, strings, booleans, etc.). - Example: `[1, 1, 2, 2, 3, 4, \\"hello\\", \\"hello\\", 5, True, True, False]` * **Output**: A list containing the unique elements from the input list, maintaining their order of first occurrence. - Example: `[1, 2, 3, 4, \\"hello\\", 5, True, False]` Constraints 1. The input list can be of length up to 100,000. 2. The elements within the list can contain mixed data types. 3. Time complexity: O(n) 4. Space complexity: O(n) Function Signature ```python def remove_duplicates_optimized(array: list) -> list: # Your implementation here ``` Implementation Requirements 1. Use a data structure that supports efficient membership checking and insertion. 2. Ensure that the order of first occurrences is preserved. 3. Handle edge cases (e.g., empty list, lists with all elements same). You are expected to: 1. Write the optimized function `remove_duplicates_optimized`. 2. Ensure that your solution meets the performance requirements for large inputs. 3. Provide function-level documentation. Example ```python assert remove_duplicates_optimized([1, 2, 2, 3, 1]) == [1, 2, 3] assert remove_duplicates_optimized([\\"a\\", \\"b\\", \\"a\\", \\"c\\"]) == [\\"a\\", \\"b\\", \\"c\\"] assert remove_duplicates_optimized([]) == [] assert remove_duplicates_optimized([True, False, True]) == [True, False] ```","solution":"def remove_duplicates_optimized(array): Removes duplicate elements from the input array while maintaining the order of their first occurrences. Args: array (list): The input list containing elements of any data type. Returns: list: A new list containing unique elements from the input list, preserving the original order. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Maximum Network Flow: Deep River Crossing You\'re working on a network flow problem where you must determine the maximum flow of materials from the upstream source (node 0) to the downstream sink (the last node) over a series of pathways represented in matrix form. Write a function `maximum_flow_bfs(adjacency_matrix)` that computes the maximum flow from the source to the sink. Function Signature: ```python def maximum_flow_bfs(adjacency_matrix: List[List[int]]) -> int: ``` Parameters: - `adjacency_matrix`: A 2D list of integers `n x n` where each entry `adjacency_matrix[i][j]` represents the capacity of the directed edge from node `i` to node `j`. An entry of `0` means there is no direct path between these nodes. Returns: - `int`: The maximum possible flow from the source (node `0`) to the sink (last node). Constraints: - The matrix will be non-empty and of size `n x n` where `1 <= n <= 100`. - Capacity values will be non-negative integers. Example: ```python graph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]] assert maximum_flow_bfs(graph) == 23 ``` Explanation: Using BFS to find valid augmentations through the network, the algorithm computes the highest possible flow from the source to the sink following constraints discussed in the function. Ensure your function handles edge cases such as: - No available path between source and sink. - Varying capacities across different nodes. - Different graph sizes and sparsities.","solution":"from typing import List from collections import deque def bfs(residual_graph, source, sink, parent): visited = [False] * len(residual_graph) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, capacity in enumerate(residual_graph[u]): if not visited[v] and capacity > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def maximum_flow_bfs(adjacency_matrix: List[List[int]]) -> int: source = 0 sink = len(adjacency_matrix) - 1 residual_graph = [row[:] for row in adjacency_matrix] parent = [-1] * len(adjacency_matrix) max_flow = 0 while bfs(residual_graph, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] residual_graph[u][v] -= path_flow residual_graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"You are given an unsorted list of integers. Your task is to write a function that finds and returns the index of the first occurrence of a specified integer in the list using the linear search algorithm. If the integer is not found, the function should return -1. # Function Signature ```python def find_index(arr: list[int], target: int) -> int: Find and return the index of the first occurrence of \'target\' in \'arr\'. Parameters: - arr: List of integers (this list is unsorted and can contain duplicates). - target: Integer to find in the list. Returns: - The index of the first occurrence of \'target\'. If target is not found, return -1. # Input * arr: A list of n integers where 0 <= n <= 10^6. * target: An integer to search in arr. # Output Return the index of the first occurrence of target in arr. If target is not present, return -1. # Constraints * The maximum size of the array (n) will be 10^6. * The array can contain negative numbers and duplicates. # Example ```python # Example 1 arr = [4, 2, 7, 1, 3, 6] target = 7 print(find_index(arr, target)) # Output: 2 # Example 2 arr = [4, 2, 7, 1, 3, 6] target = 5 print(find_index(arr, target)) # Output: -1 # Example 3 arr = [] target = 5 print(find_index(arr, target)) # Output: -1 ``` # Notes * Your solution should be optimized for clarity and correctness. The efficiency in terms of time complexity should be O(n), and the space complexity should be O(1).","solution":"def find_index(arr: list[int], target: int) -> int: Find and return the index of the first occurrence of \'target\' in \'arr\'. Parameters: - arr: List of integers (this list is unsorted and can contain duplicates). - target: Integer to find in the list. Returns: - The index of the first occurrence of \'target\'. If target is not found, return -1. for index, value in enumerate(arr): if value == target: return index return -1"},{"question":"**Problem Statement**: Given a stack represented as a list of integers, implement two functions `first_stutter(stack)` and `second_stutter(stack)` that take a stack as a parameter and replace every value in the stack with two occurrences of that value. 1. `first_stutter`: Should use an auxiliary stack. 2. `second_stutter`: Should use an auxiliary queue. **Input**: - An argument `stack` which is a list of integers representing a stack, where the last element of the list is considered the top of the stack. **Output**: - The function should modify the input stack in place and return it such that every element in the stack is duplicated, maintaining the original order. **Constraints**: - The stack can contain up to `10^5` elements. - The values in the stack will be integers between `-10^9` and `10^9`. # Examples: 1. **Input**: stack = [3, 7, 1, 14, 9] - **Output**: bottom [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] top 2. **Input**: stack = [5] - **Output**: bottom [5, 5] top 3. **Input**: stack = [] - **Output**: bottom [] top # Implementation Tips: - Think through the steps needed to separately use a stack and a queue as auxiliary storage. - Ensure you correctly manage the stack\'s order when transferring elements back from the auxiliary data structures. - Carefully handle edge cases such as empty or single element stacks. You will be scoring primarily on: 1. **Correctness**: Producing the correct output for all provided test cases. 2. **Efficiency**: Adhering to the optimal time complexity requirements. 3. **Code Quality**: Writing clean, readable, and well-documented code.","solution":"def first_stutter(stack): This function takes a stack and duplicates each element using an auxiliary stack. aux_stack = [] # Transfer elements to auxiliary stack, duplicating each one while stack: value = stack.pop() aux_stack.append(value) aux_stack.append(value) # Transfer elements back to the original stack to maintain order while aux_stack: stack.append(aux_stack.pop()) return stack def second_stutter(stack): This function takes a stack and duplicates each element using an auxiliary queue. from collections import deque aux_queue = deque() # Transfer elements to auxiliary queue, duplicating each one while stack: value = stack.pop() aux_queue.appendleft(value) aux_queue.appendleft(value) # Transfer elements back to the original stack to maintain order while aux_queue: stack.append(aux_queue.popleft()) return stack"},{"question":"# Question: Implement and Enhance Radix Sort You are required to implement a radix sort algorithm and extend its functionality. The primary goal is to ensure your implementation can handle negative numbers as well. **Problem Statement**: Implement the `radix_sort` function to sort an array of integers, including both positive and negative numbers. Ensure the algorithm maintains its linear time complexity characteristics under the conditions provided. **Function Signature**: ```python def radix_sort(arr, simulation=False): pass ``` **Input**: * `arr`: A list of integers which may include both positive and negative numbers (e.g., [-10, -1, 0, 7, 100, 45, -3]). * `simulation` (optional): A boolean flag to indicate whether to print intermediate iterations (default is False). **Output**: * Return a list sorted in ascending order. **Constraints**: * 1 <= len(arr) <= 10^6 (The list can have up to 1 million elements) * -10^9 <= arr[i] <= 10^9 (Each element of the list can be as large in magnitude as one billion) * Your solution should have a time complexity of O(nk), where n is the size of the input list and k is the digit length of the largest number (in absolute value) **Performance Requirement**: * Aim for efficient memory usage and handle up to 1 million entries within reasonable time and space limits. **Special Notes**: * You should handle negative integers effectively. * Consider optimizations to maintain linear time complexity. **Example**: ```python print(radix_sort([-10, -1, 0, 7, 100, 45, -3])) # Expected Output: [-10, -3, -1, 0, 7, 45, 100] ``` **Explanation**: * The original array has both positive and negative numbers. * The sorted array should correctly place negative numbers in ascending order before positive numbers.","solution":"def radix_sort(arr, simulation=False): if not arr: # If the list is empty, return it immediately return [] # Helper function to do counting sort based on a specific digit def counting_sort(arr, exp, simulation): n = len(arr) output = [0] * n count = [0] * 10 if simulation: print(f\\"Sorting by exponent {exp}: {arr}\\") # Storing count of occurrences in count[] for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Changing count[i] so that count[i] contains actual position of # the digit in output[] for i in range(1, 10): count[i] += count[i - 1] if simulation: print(f\\"Count array after filling positions for exp {exp}: {count}\\") # Building the output array for i in range(n - 1, -1, -1): index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 # Copying the output array to arr[] for i in range(n): arr[i] = output[i] if simulation: print(f\\"Array after sorting by exponent {exp}: {arr}\\") # Find the maximum absolute number to determine the number of digits max_num = max(arr, key=abs) max_num = abs(max_num) # Sort the array using counting sort for every digit exp = 1 while max_num // exp > 0: counting_sort(arr, exp, simulation) exp *= 10 # Handle negative numbers neg = [x for x in arr if x < 0] pos = [x for x in arr if x >= 0] return neg + pos"},{"question":"# Keyboard Row Problem You are given a list of words. Each word can contain only lowercase or uppercase letters. Your task is to return the words that can be typed using letters of the alphabet on only one row of an American keyboard. The three rows of the keyboard are defined as follows: 1. Row 1: `qwertyuiop` 2. Row 2: `asdfghjkl` 3. Row 3: `zxcvbnm` # Input - A list of words (with 1 ≤ |words| ≤ 100), - Each word can be composed of English letters only (1 ≤ |word_length| ≤ 100). # Output - A list of words that can be typed using letters of alphabet on only one row of the keyboard. # Constraints - The function should be case insensitive; treat uppercase and lowercase letters as equivalent. - Optimize for the case where words can be of arbitrary length and content within the allowed constraints. # Example Input: `[\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]` Output: `[\\"Alaska\\", \\"Dad\\"]` # Performance Requirements - The solution should run efficiently, i.e. within O(n * m) time complexity where `n` is the number of words and `m` is the average length of a word. Function Signature ```python def find_keyboard_row(words): :type words: List[str] :rtype: List[str] ``` Implementation Note Consider using sets for each keyboard row and checking each word against these sets. Once a word is matched with a row, avoid unnecessary checks with other rows.","solution":"def find_keyboard_row(words): Returns a list of words that can be typed using letters of the alphabet on only one row of an American keyboard. # Define sets for each row of the keyboard row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") def can_type_with_one_row(word): lowercase_word = word.lower() if all(letter in row1 for letter in lowercase_word): return True if all(letter in row2 for letter in lowercase_word): return True if all(letter in row3 for letter in lowercase_word): return True return False result = [word for word in words if can_type_with_one_row(word)] return result"},{"question":"# Graph Traversal Challenge Context You are a software developer tasked with designing algorithms to explore and understand the structure of social networks. The social network can be represented as a graph where each node represents a user, and each edge represents a connection between two users. Problem Statement Implement both Depth First Search (DFS) and Breadth First Search (BFS) graph traversal algorithms. Your implementation should be flexible to handle any graph represented as an adjacency list. Function Signature 1. `def dfs_traverse(graph: Dict[int, List[int]], start: int) -> Set[int]:` 2. `def bfs_traverse(graph: Dict[int, List[int]], start: int) -> Set[int]:` Input - `graph`: A dictionary representing an adjacency list of the graph where keys are nodes and values are lists of connected nodes. - `start`: An integer representing the starting node for the traversal. Output - Return a set of nodes that are reachable from the starting node using the respective traversal algorithm. Constraints - The graph may contain cycles. - The graph is undirected. - Nodes are labeled with unique integer values. Example ```python graph = { 0: [1, 2], 1: [0, 3], 2: [0], 3: [1] } start = 0 # Expected output for DFS # print(dfs_traverse(graph, start)) -> {0, 1, 2, 3} # Expected output for BFS # print(bfs_traverse(graph, start)) -> {0, 1, 2, 3} ``` # Tasks 1. Implement the `dfs_traverse` function for Depth First Search. 2. Implement the `bfs_traverse` function for Breadth First Search. 3. Ensure both functions handle cycles and disconnected components properly. 4. Validate your functions against various test cases, including edge cases like empty graphs and graphs with single nodes. Notes - Consider using a stack for DFS and a queue for BFS. - Do not use built-in traversal algorithms or libraries.","solution":"from typing import Dict, List, Set from collections import deque def dfs_traverse(graph: Dict[int, List[int]], start: int) -> Set[int]: visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend(neighbor for neighbor in graph[node] if neighbor not in visited) return visited def bfs_traverse(graph: Dict[int, List[int]], start: int) -> Set[int]: visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited) return visited"},{"question":"You are given a singly linked list of integers. Your task is to determine whether the list is a palindrome. A palindrome is a sequence that reads the same backward as forward. Implement a function `is_palindrome_linked_list(head)` that determines whether the given linked list is a palindrome. Function Signature ```python def is_palindrome_linked_list(head: Optional[ListNode]) -> bool: ``` Input - `head`: The head node of a singly linked list where each node contains an integer. Output - Return `True` if the linked list is a palindrome, otherwise return `False`. Constraints - The number of nodes in the linked list is in the range `[1, 10^5]`. - Each node\'s value is an integer in the range `[-10^9, 10^9]`. # Example ```plaintext Input: 1 -> 2 -> 2 -> 1 Output: True Input: 1 -> 2 -> 3 -> 2 -> 1 Output: True Input: 1 -> 2 Output: False ``` # Scenario Consider a situation where the linked list represents a sequence of timestamps in log entries for an application. You need to quickly verify if the sequence forms a symmetrical pattern, indicating certain errors or repeated activities. # Guidelines - Utilize one of the methods discussed (reverse the second half, use a stack, or use a dictionary) to solve this problem. - Ensure your solution handles various edge cases such as lists with a single element or even/odd length lists. - Optimize your solution for time and space complexity, considering the constraints.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome_linked_list(head): Determines whether the given linked list is a palindrome. if not head or not head.next: return True # Find midpoint using the fast and slow pointer technique. slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the list. prev = None while slow: next_node = slow.next slow.next = prev prev = slow slow = next_node # Compare both halves. left, right = head, prev while right: if left.val != right.val: return False left = left.next right = right.next return True"},{"question":"# Histogram Calculation Challenge Objective Given a list of unordered values, your task is to implement a function that calculates the frequency of each unique element in the list and returns this frequency distribution as a dictionary. Requirements: 1. **Function Name:** `calculate_histogram` 2. **Input:** - A single list of integers. - Each element in the list can be any valid integer. 3. **Output:** - A dictionary where keys are the unique integers from the list and values are their respective frequencies. Constraints: - The input list can be empty. - The values in the list are integers within the range of typical 32-bit signed integer limits. Performance Requirements: - The function should operate efficiently with a time complexity of O(n). - It should use appropriate data structures to ensure a space complexity of O(k), where k is the number of unique elements in the input list. Example ```python list_1 = [3, 3, 2, 1] # Output: {3: 2, 2: 1, 1: 1} list_2 = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} list_3 = [] # Output: {} ``` Implementation: Implement the function `calculate_histogram` using the guidelines provided above. ```python def calculate_histogram(input_list: list) -> dict: Calculate frequency distribution of elements in the input list. :param input_list: List of integers :return: Dictionary with frequency distribution # Initialize an empty dictionary to store histogram histogram = {} # Traverse each element in the input list for i in input_list: # Update the count for each element histogram[i] = histogram.get(i, 0) + 1 # Return the populated histogram dictionary return histogram ``` Feel free to test your function against the provided examples and consider additional edge cases for thorough validation.","solution":"def calculate_histogram(input_list): Calculate frequency distribution of elements in the input list. :param input_list: List of integers :return: Dictionary with frequency distribution histogram = {} for item in input_list: if item in histogram: histogram[item] += 1 else: histogram[item] = 1 return histogram"},{"question":"# Stooge Sort Implementation Challenge **Background**: You have recently learned about Stooge Sort, a curiosity in the world of sorting algorithms known for its high theoretical complexity but simple recursive structure. As an exercise, you are required to implement this sorting algorithm and test it on various cases. **Problem**: Implement the Stooge Sort algorithm in Python. The function should be able to sort a list of integers in ascending order. **Function Signature**: ```python def stooge_sort(arr: List[int], l: int, h: int) -> None: pass ``` **Input**: * `arr` - a list of integers to be sorted. * `l` - the starting index of the list (usually 0). * `h` - the ending index of the list (usually len(arr) - 1). **Output**: * The function should modify the list `arr` in-place. **Constraints**: * 0 <= len(arr) <= 100 * -10^5 <= arr[i] <= 10^5 **Performance Requirement**: While the Stooge Sort is intrinsically slow, make sure your implementation runs within reasonable time for the given constraints. **Example**: ```python arr = [5, 3, 2, 1, 4] stooge_sort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 2, 3, 4, 5] ``` **Hints**: * Pay attention to the base case of recursion. * Ensure correct swapping and recursive calls. **Note**: Focus on the correctness and recursive nature of the Stooge Sort rather than its performance, as this is more of an academic exercise.","solution":"from typing import List def stooge_sort(arr: List[int], l: int, h: int) -> None: if l >= h: return # If the first element is greater than the last, then swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the list if h - l + 1 > 2: t = (h - l + 1) // 3 stooge_sort(arr, l, h - t) # Sort the initial 2/3rd stooge_sort(arr, l + t, h) # Sort the final 2/3rd stooge_sort(arr, l, h - t) # Sort the initial 2/3rd again"},{"question":"# Question: You are given an array of integers that need to be sorted. Implement a function to sort this array using the Comb Sort algorithm. Given the constraints, ensure your implementation is both efficient and handles various edge cases effectively. Function Signature: ```python def comb_sort(arr: List[int]) -> List[int]: ``` Input: - `arr`: A list of integers to be sorted. Output: - A list of integers sorted in ascending order. Constraints: - The array can have up to 10^6 elements. - Each element in the array is an integer between -10^9 and 10^9. Example: ```python >>> comb_sort([8, 4, 1, 56, 3, -44, 23]) [-44, 1, 3, 4, 8, 23, 56] >>> comb_sort([5. 2, -2]) [-2, 2, 5] ``` Additional Note: - Consider edge cases such as an empty array, a single-element array, or arrays with all elements identical. - Ensure the final implementation is efficient and meets the constraints.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts the given list using the Comb Sort algorithm. def get_next_gap(gap): # Shrink gap by a factor of 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Caesar Cipher Decryptor You are given an encrypted string that was encoded using a Caesar Cipher. In a Caesar Cipher, each letter in the plaintext is shifted a certain number of places (known as the key, `k`) down or up the alphabet. Your task is to write a function that decodes the encrypted message back to its original form using the given key. Function Signature ```python def caesar_cipher_decryptor(s: str, k: int) -> str: pass ``` Input - `s` (str): A string of length `n` (1 ≤ n ≤ 10^5) representing the encrypted message. - `k` (int): An integer (0 ≤ k ≤ 25) that represents the number of places each letter was shifted in the encryption process. Output - Returns a string that represents the original, decrypted message. Constraints - Only alphabetic characters and spaces are encrypted; non-alphabetic characters should be skipped during decryption. - Both uppercase and lowercase letters should be appropriately unshifted. Example ```python encrypted_message = \\"Khoor Zruog\\" shift_key = 3 print(caesar_cipher_decryptor(encrypted_message, shift_key)) # Output: \\"Hello World\\" ``` Explanation In the example provided, each letter of \\"Hello World\\" was shifted by 3 positions to create \\"Khoor Zruog\\". The decryption process involves shifting the letters back by 3 positions. Note: Handle both uppercase and lowercase letters separately, ensuring the characters wrap around correctly within their respective character sets.","solution":"def caesar_cipher_decryptor(s: str, k: int) -> str: decrypted_message = [] for char in s: if \'a\' <= char <= \'z\': new_char = chr((ord(char) - ord(\'a\') - k) % 26 + ord(\'a\')) elif \'A\' <= char <= \'Z\': new_char = chr((ord(char) - ord(\'A\') - k) % 26 + ord(\'A\')) else: new_char = char decrypted_message.append(new_char) return \'\'.join(decrypted_message)"},{"question":"You are tasked with implementing a **Doubly Linked List** data structure with the following capabilities: 1. **Insertion**: Insert an element at the beginning, middle, or end of the list. 2. **Deletion**: Delete an element from the beginning, middle, or end of the list. 3. **Traversal**: Traverse the list forward and backward. 4. **Searching**: Find the position of an element in the list. # Functional Requirements You need to implement the following methods: 1. `insert_at_position(value, position)`: Insert a node with the given `value` at the specified `position` in the list. If the position is greater than the length of the list, append the node to the end. 2. `delete_at_position(position)`: Delete a node at the given `position` in the list. If the position is out of bounds, do nothing. 3. `traverse_forward() -> list`: Return a list of the values in the nodes while traversing from head to tail. 4. `traverse_backward() -> list`: Return a list of the values in the nodes while traversing from tail to head. 5. `search(value) -> int`: Return the position of the first node with the given `value` in the list. If the value is not found, return -1. # Input and Output Formats * **Input**: * `insert_at_position(value, position)`: An integer `value` and an integer `position` (0-based index). * `delete_at_position(position)`: An integer `position` (0-based index). * `search(value)`: An integer `value`. * **Output**: * `insert_at_position(value, position)`: No output. * `delete_at_position(position)`: No output. * `traverse_forward()`: List of integers. * `traverse_backward()`: List of integers. * `search(value)`: An integer. # Constraints * The given positions are 0-based. * Values in the list are integers. # Example ```python dll = DoublyLinkedList() # Insert elements dll.insert_at_position(10, 0) dll.insert_at_position(20, 1) dll.insert_at_position(30, 2) dll.insert_at_position(15, 1) # Traverse forward print(dll.traverse_forward()) # Output: [10, 15, 20, 30] # Traverse backward print(dll.traverse_backward()) # Output: [30, 20, 15, 10] # Search elements print(dll.search(20)) # Output: 2 print(dll.search(25)) # Output: -1 # Delete elements dll.delete_at_position(1) print(dll.traverse_forward()) # Output: [10, 20, 30] ``` # Implementation ```python class DoublyLinkedListNode(object): def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList(object): def __init__(self): self.head = None self.tail = None # Implement the methods here based on the problem statement ```","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_position(self, value, position): new_node = DoublyLinkedListNode(value) if position <= 0 or not self.head: # Insert at the beginning if self.head: new_node.next = self.head self.head.prev = new_node self.head = new_node if not self.tail: self.tail = new_node return current = self.head index = 0 while current.next and index < position - 1: current = current.next index += 1 if not current.next: # Insert at the end new_node.prev = self.tail self.tail.next = new_node self.tail = new_node else: # Insert in the middle new_node.next = current.next new_node.prev = current current.next.prev = new_node current.next = new_node def delete_at_position(self, position): if not self.head or position < 0: return current = self.head if position == 0: # Delete the head self.head = current.next if self.head: self.head.prev = None else: self.tail = None return index = 0 while current and index < position: current = current.next index += 1 if current: if current.next: current.next.prev = current.prev if current.prev: current.prev.next = current.next if not current.next: self.tail = current.prev def traverse_forward(self): values = [] current = self.head while current: values.append(current.value) current = current.next return values def traverse_backward(self): values = [] current = self.tail while current: values.append(current.value) current = current.prev return values def search(self, value): current = self.head position = 0 while current: if current.value == value: return position current = current.next position += 1 return -1"},{"question":"# Heap Sort Algorithm Implementation **Scenario**: A logistics company needs to sort a list of delivery times to optimize their delivery sequence. To ensure the process is efficient, they have chosen to use heap sort. As part of their software development team, you are tasked with implementing the heap sort algorithm using both max heap sort and min heap sort. **Task**: Implement two functions `max_heap_sort_optimized` and `min_heap_sort_optimized` to sort a list of integers in ascending order using max heap and min heap strategies, respectively. # Function Specifications `max_heap_sort_optimized(arr)` * **Input**: * `arr`: A list of integers to be sorted. * **Output**: * A sorted list of integers in ascending order. * **Constraints**: * Do **not** use any additional libraries for sorting. * The solution should be implemented in O(n log n) time complexity. `min_heap_sort_optimized(arr)` * **Input**: * `arr`: A list of integers to be sorted. * **Output**: * A sorted list of integers in ascending order. * **Constraints**: * Do **not** use any additional libraries for sorting. * The solution should be implemented in O(n log n) time complexity. **Performance Requirements**: * The sorting should be done in-place with O(1) additional space complexity. * You may assume that the elements of the array are distinct integers within a reasonable range. # Example ```python # Example usage arr1 = [4, 10, 3, 5, 1] # Sorting with max heap sort sorted_max_heap = max_heap_sort_optimized(arr1.copy()) print(sorted_max_heap) # Output: [1, 3, 4, 5, 10] # Sorting with min heap sort sorted_min_heap = min_heap_sort_optimized(arr1.copy()) print(sorted_min_heap) # Output: [1, 3, 4, 5, 10] ``` # Constraints * The input list `arr` will have at most 10^5 elements. * Each integer in the list will be in the range from -10^6 to 10^6. **Note**: Your implementations should not print any debug information or use print statements. Good luck, and ensure your code handles all edge cases effectively!","solution":"def max_heapify(arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[largest] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] max_heapify(arr, n, largest) def max_heap_sort_optimized(arr): n = len(arr) for i in range(n//2 - 1, -1, -1): max_heapify(arr, n, i) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] max_heapify(arr, i, 0) return arr def min_heapify(arr, n, i): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[smallest] > arr[left]: smallest = left if right < n and arr[smallest] > arr[right]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] min_heapify(arr, n, smallest) def min_heap_sort_optimized(arr): n = len(arr) for i in range(n//2 - 1, -1, -1): min_heapify(arr, n, i) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] min_heapify(arr, i, 0) return arr[::-1]"},{"question":"# Question: Letter Combinations of a Phone Number You are given a string containing digits from 2 to 9. Each digit maps to a set of characters, similar to the old telephone buttons: - `2`: \\"abc\\" - `3`: \\"def\\" - `4`: \\"ghi\\" - `5`: \\"jkl\\" - `6`: \\"mno\\" - `7`: \\"pqrs\\" - `8`: \\"tuv\\" - `9`: \\"wxyz\\" Your task is to write a function `letter_combinations(digits)` that takes the digit string as input and returns all possible letter combinations that the number could represent. Return the combinations in any order. # Input - A string `digits` containing digits from \\"2\\" to \\"9\\" (1 <= len(digits) <= 20). # Output - A list of strings containing all possible letter combinations. # Constraints - The string `digits` will only contain digits from \\"2\\" to \\"9\\". - You can assume that the input is always valid. # Example **Input:** ```python digits = \\"23\\" ``` **Output:** ```python [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] ``` # Additional Notes Consider using backtracking, depth-first search, or combinatorial generation techniques to solve this problem efficiently. Pay attention to performance and edge cases. Write your function signature as follows: ```python def letter_combinations(digits): # Your code here ```","solution":"def letter_combinations(digits): Returns all possible letter combinations that the number could represent. :param digits: A string containing digits from 2 to 9 :return: A list of strings containing all possible letter combinations if not digits: return [] digit_to_char = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = digit_to_char[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"# Subset Generation with Additional Constraints **Objective**: Write a function to generate all possible subsets of a given set of distinct integers. Additionally, add a constraint that no subset can have two consecutive integers from the original set. **Function Specification**: ```python def constrained_subsets(nums): :param nums: List[int] - list of distinct integers. :return: Set[tuple] - set of tuples representing valid subsets without consecutive integers. pass ``` **Input**: - `nums`: List of distinct integers with a length of at most 15. **Output**: - A set of tuples, where each tuple represents a valid subset not containing consecutive integers from the input list. **Constraints**: - Subsets should be unique and should be subsets of the input list. - No subset can contain consecutive integers from the original list. **Performance Requirements**: - The solution should run in reasonable time for the input constraint (15 integers). **Example**: ```python nums = [1, 2, 3] constrained_subsets(nums) # Expected Output: # {(), (1,), (2,), (3,), (1, 3)} ``` **Explanation**: - Subsets like (1, 2), (2, 3) are not allowed because they contain consecutive integers. # Context: This problem adds a realistic constraint to the subset generation algorithm, often encountered in combinatorial problems where certain combinations are disallowed.","solution":"from itertools import combinations def constrained_subsets(nums): Generates all subsets of the given list of integers such that the subsets do not contain consecutive integers. :param nums: List[int] - list of distinct integers. :return: Set[tuple] - set of tuples representing valid subsets without consecutive integers. nums.sort() # Sort to ensure consecutive integer detection result = set() for r in range(len(nums) + 1): for combo in combinations(nums, r): if not any(combo[i] + 1 == combo[i + 1] for i in range(len(combo) - 1)): result.add(combo) return result"},{"question":"You are asked to write a function to identify all numbers within a given range that exhibit a unique property: the sum of their digits raised to the power of their respective positions equals the number itself. These numbers are sometimes termed \\"powerful digit sum numbers.\\" # Function Signature ```python def find_powerful_digit_sums(low: int, high: int) -> List[int]: pass ``` # Input * Two integers, `low` and `high` that define the inclusive range ([low, high]). # Output * A list of integers that exhibit the stated property within the given range. # Constraints * (1 leq low leq high leq 10^6) # Scenario You are tasked with developing a number verification system for a mathematical exploration app. This feature will help users to identify unique numbers that fit specific criteria based on their digits and positions. # Example ```python assert find_powerful_digit_sums(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_powerful_digit_sums(10, 150) == [89, 135] assert find_powerful_digit_sums(90, 150) == [135] ``` # Clarity * Ensure to handle the edge cases where ranges might just wrap around powerful digit sum numbers. * Optimize the function to handle upper constraint limits effectively.","solution":"def find_powerful_digit_sums(low, high): def is_powerful_digit_sum(num): str_num = str(num) return num == sum(int(digit) ** (position + 1) for position, digit in enumerate(str_num)) result = [] for number in range(low, high + 1): if is_powerful_digit_sum(number): result.append(number) return result"},{"question":"# Scenario You are given the task of managing project dependencies. Projects and their direct dependencies are represented as a directed graph where each node represents a project and directed edges indicate dependency relationships (i.e., project `A` must be completed before project `B` starts). Implement a function to return one possible order of project completion. If there is a cycle, indicating that the project dependencies can\'t be resolved, your function should raise an error. # Task Description Implement the function `find_project_order` which performs topological sorting on a directed graph. Function Signature ```python def find_project_order(projects, dependencies): pass ``` Input * `projects` (list of str): A list of project names. * `dependencies` (list of tuple): A list of tuples where each tuple `(a, b)` represents a dependency indicating project `a` must be completed before project `b`. Output * A list of strings representing one possible order to complete the projects. If a cycle is detected, raise `ValueError(\\"cycle detected\\")`. Constraints * The graph is directed and may be disconnected. * The number of projects `P` and the number of dependencies `D` are such that ( 1 le P le 1000 ) and ( 0 le D le P*(P-1) ). Example ```python projects = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] dependencies = [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"a\\", \\"c\\"), (\\"c\\", \\"d\\")] assert find_project_order(projects, dependencies) in [[\\"a\\", \\"b\\", \\"c\\", \\"d\\"], [\\"a\\", \\"c\\", \\"b\\", \\"d\\"]] projects = [\\"a\\", \\"b\\", \\"c\\"] dependencies = [(\\"a\\", \\"b\\"), (\\"b\\", \\"a\\")] try: find_project_order(projects, dependencies) except ValueError as e: assert str(e) == \\"cycle detected\\" ``` # Notes * Ensure to handle edge cases such as cyclic dependencies and isolated projects. * Consider both breadth-first and depth-first approaches for different perspectives.","solution":"from collections import defaultdict, deque def find_project_order(projects, dependencies): Perform topological sorting on the given project dependency graph. :param projects: A list of project names. :param dependencies: A list of tuple dependencies (a, b) indicating project `a` must be completed before `b`. :return: A list of strings representing one possible order to complete the projects. :raises ValueError: If there is a cycle in the dependency graph. # Initialize all projects and their in-degree count in_degree = {project: 0 for project in projects} adjacency_list = defaultdict(list) # Build the graph with the adjacency list and in-degree count for a, b in dependencies: adjacency_list[a].append(b) in_degree[b] += 1 # Queue for the projects which have no dependencies (in-degree 0) zero_in_degree_queue = deque([project for project in projects if in_degree[project] == 0]) project_order = [] while zero_in_degree_queue: current_project = zero_in_degree_queue.popleft() project_order.append(current_project) # Decrease the in-degree of neighboring projects by 1 for neighbor in adjacency_list[current_project]: in_degree[neighbor] -= 1 # If in-degree becomes 0, add it to the queue if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If order length matches the number of projects, return order if len(project_order) == len(projects): return project_order else: raise ValueError(\\"cycle detected\\")"},{"question":"# Euler\'s Totient Function Implementation **Background**: You are a developer working on a cryptographic application, and you need to implement a function that calculates Euler\'s Totient Function, ϕ(n). Euler\'s Totient Function counts the number of integers from 1 to n that are coprime with n. Two numbers are considered coprime if their greatest common divisor (GCD) is 1. **Algorithm Description**: 1. Start with the result initialized to n. 2. For each number i from 2 to √n (inclusive): 1. If i divides n, then: 1. Divide n by i repeatedly until n is no longer divisible by i. 2. Reduce the result by the proportion of numbers that are not coprime due to the factor i. 3. If after the loop n is still greater than 1, decrement the result by the proportion of the remaining factor. **Task**: Write a function `euler_totient(n)` that takes an integer n (1 ≤ n ≤ 10^6) and returns the value of ϕ(n). **Input**: - A single integer n. **Output**: - An integer representing the value of ϕ(n). **Constraints**: - 1 ≤ n ≤ 10^6 # Example: **Example 1**: - Input: 9 - Output: 6 - Explanation: The numbers between 1 and 9 that are coprime with 9 are 1, 2, 4, 5, 6, 7, and 8 (total 6 numbers). **Example 2**: - Input: 7 - Output: 6 - Explanation: The numbers between 1 and 7 that are coprime with 7 are 1, 2, 3, 4, 5, and 6 (total 6 numbers). You should handle edge cases such as n being prime, 1, or other special values efficiently.","solution":"def euler_totient(n): Returns the value of Euler\'s Totient function ϕ(n) if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result"},{"question":"Implement a Caesar Cipher Function You are required to write a function `caesar_cipher` that encrypts a given string using the Caesar Cipher technique. Each letter in the input string should be shifted by a given number of positions in the alphabet. If the shift takes you past the end of the alphabet, wrap around to the beginning. Function Signature ```python def caesar_cipher(s: str, k: int) -> str: pass ``` Input * `s`: A string consisting of alphabetic characters and possibly some non-alphabetic characters. * `k`: An integer representing the shift amount. The shift can be positive or negative. Output * Return the encrypted string where each letter in the input string is shifted by `k` positions. Constraints * The shift amount `k` can be any integer (positive or negative). * The input string `s` can contain both uppercase and lowercase alphabetic characters, as well as non-alphabetic characters which should remain unchanged. Example ```python assert caesar_cipher(\\"abc\\", 3) == \\"def\\" assert caesar_cipher(\\"xyz\\", 3) == \\"abc\\" assert caesar_cipher(\\"Hello, World!\\", 5) == \\"Mjqqt, Btwqi!\\" assert caesar_cipher(\\"def\\", -3) == \\"abc\\" assert caesar_cipher(\\"Caesar Cipher!\\", 2) == \\"Ecguct Ekrjgt!\\" ``` Explanation In the first example, shifting each character in \\"abc\\" by 3 positions gives \\"def\\". In the second example, shifting \\"xyz\\" by 3 positions wraps around to the beginning of the alphabet, resulting in \\"abc\\". In the third example, non-alphabetic characters (e.g., \',\', \'!\', \' \') are unchanged, and the rest are shifted by 5 positions. Make sure your code handles edge cases, including non-alphabetic characters and large values of `k`, efficiently and correctly.","solution":"def caesar_cipher(s: str, k: int) -> str: def shift_character(char, shift): if char.isalpha(): shift = shift % 26 base = ord(\'A\') if char.isupper() else ord(\'a\') return chr(base + (ord(char) - base + shift) % 26) else: return char return \'\'.join(shift_character(char, k) for char in s)"},{"question":"# Scenario You are a software engineer working on a networking project that requires converting IP addresses from their typical dotted-decimal format to binary format for lower-level bitwise operations. Ensuring each IP address is correctly and consistently converted is crucial for ensuring the accuracy of further operations. # Task Write a function `validate_and_convert_ip(ip: str) -> str` that, given an IP address in the form of a string, validates its format and converts it into its binary representation. The function should first check whether the IP address is valid: * The IP address should have exactly four segments separated by dots. * Each segment should be a valid integer between 0 and 255. Once validated, the function should convert the IP address into its binary form, similar to the provided snippets but enhanced with validation. # Input * A single string representing the IP address in dotted-decimal format. # Output * A string representing the IP address in binary format if valid. * Return \\"Invalid IP address\\" in case of an invalid input. # Constraints * The IP address string will contain only numbers and dots. * The function should complete in O(1) time per segment and use O(1) space per segment. # Example **Input:** ```python validate_and_convert_ip(\\"192.168.1.1\\") ``` **Output:** ```python \'11000000.10101000.00000001.00000001\' ``` **Input:** ```python validate_and_convert_ip(\\"999.10.10.10\\") ``` **Output:** ```python \'Invalid IP address\' ```","solution":"def validate_and_convert_ip(ip: str) -> str: Validate the given IP address and convert it to its binary form if valid. Args: ip (str): The IP address in dotted-decimal format. Returns: str: The binary representation of the IP address, or \\"Invalid IP address\\" if the IP is invalid. parts = ip.split(\'.\') if len(parts) != 4: return \\"Invalid IP address\\" binary_parts = [] for part in parts: try: num = int(part) except ValueError: return \\"Invalid IP address\\" if num < 0 or num > 255: return \\"Invalid IP address\\" binary_part = format(num, \'08b\') binary_parts.append(binary_part) return \'.\'.join(binary_parts)"},{"question":"# Matrix Rotation and Inversion Assessment Objective: You are asked to implement four matrix manipulation functions to rotate and invert matrices, which will test your understanding of matrix transformations. Input and Output: Each function will take a 2D list (matrix) as input and return a new 2D list that represents the transformed matrix. Description: 1. `rotate_clockwise(matrix)`: Rotate the given matrix 90 degrees clockwise. 2. `rotate_counterclockwise(matrix)`: Rotate the given matrix 90 degrees counterclockwise. 3. `top_left_invert(matrix)`: Invert the matrix from top-left to bottom-right. 4. `bottom_left_invert(matrix)`: Invert the matrix from bottom-left to top-right. # Constraints: 1. The input matrix can be of arbitrary size (n x m), including non-square matrices. 2. Elements in the matrix will be integers. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] rotate_clockwise(matrix) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3], ] rotate_counterclockwise(matrix) == [ [3, 6, 9], [2, 5, 8], [1, 4, 7], ] top_left_invert(matrix) == [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] bottom_left_invert(matrix) == [ [9, 8, 7], [6, 5, 4], [3, 2, 1], ] ``` # Tasks: 1. Implement the function `rotate_clockwise(matrix)`. 2. Implement the function `rotate_counterclockwise(matrix)`. 3. Implement the function `top_left_invert(matrix)`. (Note: This is essentially the identity matrix transformation, as the matrix stays the same). 4. Implement the function `bottom_left_invert(matrix)`. # Performance Requirement: 1. Aim to optimize both time and space complexity, keeping the operations as efficient as possible. 2. Consider special handling for edge cases, such as empty matrices or single element matrices.","solution":"def rotate_clockwise(matrix): Rotate the given matrix 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix): Rotate the given matrix 90 degrees counterclockwise. return [list(row) for row in zip(*matrix)][::-1] def top_left_invert(matrix): Invert the matrix from top-left to bottom-right. This is essentially an identity transformation. return matrix def bottom_left_invert(matrix): Invert the matrix from bottom-left to top-right. return [row[::-1] for row in matrix[::-1]]"},{"question":"You have recently been assigned to refactor a software system where sorting performance has taken a backseat. During this endeavor, you discovered that the existing code uses an extremely inefficient sorting algorithm known as Bogo Sort. Your task is two-fold: 1. **Improve and Optimize**: - Replace the Bogo Sort algorithm with one of the more efficient sorting algorithms (e.g., Quicksort). - Ensure that the new sorting algorithm maintains an average-case time complexity of O(n log n) and space complexity of O(n). - Implement the solution to handle the standard edge cases effectively. 2. **Explain and Evaluate**: - Provide brief documentation inside the code explaining your choice of sorting algorithm. - Include comments to justify why your implementation is superior to Bogo Sort in terms of performance. The input will be an array of integers, which might include duplicates and can have a length up to 100,000 elements. **Function Signature:** ```python def optimized_sort(arr: list) -> list: ``` **Input:** 1. A list of integers `arr` with elements in arbitrary order (e.g., [3, 1, 4, 1, 5]). **Output:** 1. A sorted list of integers in ascending order. **Constraints:** 1. The length of the list will be `0 <= len(arr) <= 100,000`. 2. Each integer in the list might be negative or positive. **Example:** ```python # Example 1: # Input: arr = [3, 1, 4, 1, 5] # Output: [1, 1, 3, 4, 5] # Example 2: # Input: arr = [10, -1, 2, -10, 7, 8] # Output: [-10, -1, 2, 7, 8, 10] ``` Note: Ensure your code is efficient and well-documented as it will be a crucial part of the grading criteria.","solution":"def optimized_sort(arr: list) -> list: Sorts the input list using Quicksort algorithm. Quicksort is chosen due to its efficiency with average-case time complexity of O(n log n) and space complexity of O(n). This makes it a robust choice for handling the given problem constraints with input lengths up to 100,000 elements. Bogo Sort, which this function replaces, has a time complexity of O((n-1)!) on average, making it highly inefficient and impractical for all but the smallest arrays. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return optimized_sort(left) + middle + optimized_sort(right)"},{"question":"Implementation and Extension of Diffie-Hellman Key Exchange Context: Alice and Bob need to securely exchange keys over a public channel. You are tasked with implementing the Diffie-Hellman key exchange protocol. To ensure a robust solution, you will also implement auxiliary functions used within this protocol, which include checking for prime numbers and finding primitive roots. Task: Implement the following functions: 1. **prime_check(num) -> bool**: Determines if `num` is a prime number. 2. **euler_totient(n) -> int**: Calculates the Euler’s totient (ϕ function) of `n`. 3. **find_order(a, n) -> int**: Finds the order of `a` modulo `n`. 4. **find_primitive_root(n) -> List[int]**: Finds all primitive roots of `n`. 5. **exec_diffie_hellman(a, p) -> Tuple[int, int]**: - Use the provided auxiliary functions to implement the Diffie-Hellman Key Exchange. - Return the shared key computed by both Alice and Bob, ensuring they match. Expected Input and Output: - **prime_check(num)**: - **Input**: `num` (int) - **Output**: `True/False` - **euler_totient(n)**: - **Input**: `n` (int) - **Output**: ϕ(n) (int) - **find_order(a, n)**: - **Input**: `a` (int), `n` (int) - **Output**: `k` (int) - **find_primitive_root(n)**: - **Input**: `n` (int) - **Output**: List of primitive roots (List[int]) - **exec_diffie_hellman(a, p)**: - **Input**: `a` (int), `p` (int, large prime) - **Output**: `(shared_key, shared_key)` (Tuple[int, int]) Constraints: - Assume `a` and `p` are integers such that: - `1 <= a < p` - `prime_check(p) == True` - `a` is a primitive root of `p` Performance Requirements: - Your functions should be optimized for efficiency, particularly those involving prime number operations and modular arithmetic. Example: ```python # Example test case a = 5 p = 23 shared_key, _ = exec_diffie_hellman(a, p) print(f\\"The shared key is: {shared_key}\\") ``` Note: - Ensure you handle all edge cases efficiently. - Use mathematical libraries where sensibly applicable to optimize performance. - Document your code with clear comments explaining each step.","solution":"from sympy import isprime, totient, primitive_root def prime_check(num): Determines if num is a prime number. Args: num (int): The number to check for primality. Returns: bool: True if num is prime, False otherwise. return isprime(num) def euler_totient(n): Calculates Euler’s totient (ϕ function) of n. Args: n (int): The number for which to calculate the totient. Returns: int: Totient of n. return totient(n) def find_order(a, n): Finds the order of a modulo n. Args: a (int): The base. n (int): The modulus. Returns: int: The order of a modulo n. for k in range(1, n): if pow(a, k, n) == 1: return k return -1 def find_primitive_root(n): Finds all primitive roots of n. Args: n (int): The number to find primitive roots for. Returns: list of int: List of primitive roots of n. if not isprime(n): return [] return [primitive_root(n)] def exec_diffie_hellman(a, p): Executes the Diffie-Hellman key exchange protocol. Args: a (int): Chosen primitive root. p (int): Large prime number. Returns: tuple: Shared key by both parties. assert prime_check(p), \\"p must be a prime number.\\" # Generate private keys private_a = 6 # Randomly chosen for this example private_b = 15 # Randomly chosen for this example # Calculate public keys public_A = pow(a, private_a, p) public_B = pow(a, private_b, p) # Calculate shared keys shared_key_Alice = pow(public_B, private_a, p) shared_key_Bob = pow(public_A, private_b, p) return shared_key_Alice, shared_key_Bob"},{"question":"Context You are tasked with implementing a function to detect cycles in activity workflow processes represented as directed graphs. This is particularly useful in systems to detect deadlocks. Failure to identify such cycles could lead to system freeze or resource lock-up issues. Task Description Implement the function `detect_cycle(graph: Dict[str, List[str]]) -> bool` that takes a directed graph represented as an adjacency list and determines if there is a cycle present in the graph. The function should return `True` if there is a cycle, otherwise, it should return `False`. Input Format - A dictionary `graph` where each key is a vertex (string) and each value is a list of vertices (strings) that the key vertex directs to. Output Format - A boolean value `True` if there is at least one cycle detected in the graph. - A boolean value `False` if there are no cycles detected. Constraints - The graph will have at most 10^5 vertices and 10^6 edges. - The graph could be disconnected. Examples ```python graph1 = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } graph2 = { \'A\': [\'B\'], \'B\': [], } graph3 = { \'A\': [\'B\'], \'B\': [\'A\'], } print(detect_cycle(graph1)) # Output: True (because of the cycle B -> D -> E -> B) print(detect_cycle(graph2)) # Output: False (no cycles) print(detect_cycle(graph3)) # Output: True (because of the cycle A -> B -> A) ``` Additional Requirements - Your implementation should handle large graphs efficiently. - Consider edge cases such as isolated nodes and self-loops. - Ensure the code logic is clear with sufficient comments.","solution":"def detect_cycle(graph): Detects if there\'s a cycle in a directed graph. :param graph: Dictionary representing the adjacency list of the graph. :return: Boolean value indicating if there\'s a cycle in the graph. def visit(node): if node in temp_marks: return True if node in perm_marks: return False temp_marks.add(node) for neighbour in graph.get(node, []): if visit(neighbour): return True temp_marks.remove(node) perm_marks.add(node) return False temp_marks = set() perm_marks = set() for node in graph: if visit(node): return True return False"},{"question":"# Scenario: You are working as a software developer for a company that manages large amounts of hierarchical data. The data is stored in binary trees, and often you need to determine the lowest common ancestor (LCA) of two nodes in these trees for various analyses. Your task is to implement an efficient solution for this problem. # Problem: Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. # Function Signature: ```python def lca(root, p, q): :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode ``` # Input: - `root`: The root node of the binary tree. - `p`: The first node. - `q`: The second node. # Output: - The lowest common ancestor node of `p` and `q`. # Constraints: - The number of nodes in the tree is in the range `[2, 10^5]`. - Values in the binary tree nodes are unique. - Both `p` and `q` are different and both values will always exist in the binary tree. # Examples: Example 1: ![Example 1](https://assets.leetcode.com/uploads/2021/03/06/lowest-common-ancestor-of-a-binary-tree.png) ```plaintext Input: root = [3, 5, 1, 6, 2, 0, 8, NULL, NULL, 7, 4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. ``` Example 2: ![Example 2](https://assets.leetcode.com/uploads/2021/03/06/lowest-common-ancestor-of-a-binary-tree.png) ```plaintext Input: root = [3, 5, 1, 6, 2, 0, 8, NULL, NULL, 7, 4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. ``` # Notes: - Make sure to handle the common edge cases. - Consider space optimization for deep binary trees. # Solution: Implement the function following the algorithm outline and validate it with the provided examples.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lca(root, p, q): :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode if root is None or root == p or root == q: return root left = lca(root.left, p, q) right = lca(root.right, p, q) if left is not None and right is not None: return root return left if left is not None else right"},{"question":"# Scenario You are developing a file management system and need to write a function that splits file paths and URLs into directory parts and file parts. This function should work correctly for various input formats, including URLs and Unix-style file paths. # Task Implement a function `split_path_and_filename` that splits input paths into directory part and filename. Ensure your function handles edge cases such as paths ending with a `/` or paths without any slashes. # Function Signature ```python def split_path_and_filename(path: str) -> tuple: pass ``` # Input * **path**: A string representing a URL or a Unix-style file path. Examples include `https://example.com/path/to/file` and `/home/user/file.txt`. # Output * A tuple where: * The first element is the directory part of the path. * The second element is the file part of the path. # Constraints * The input string has up to 1000 characters. * For simplicity, assume paths do not include spaces and are well-formed (no query strings or parameters for URLs). # Examples ```python assert split_path_and_filename(\\"https://example.com/path/to/file\\") == (\\"https://example.com/path/to\\", \\"file\\") assert split_path_and_filename(\\"/home/user/file.txt\\") == (\\"/home/user\\", \\"file.txt\\") assert split_path_and_filename(\\"/file.txt\\") == (\\"\\", \\"file.txt\\") assert split_path_and_filename(\\"noslash\\") == (\\"\\", \\"noslash\\") assert split_path_and_filename(\\"/path/missing/slash/\\") == (\\"/path/missing/slash\\", \\"\\") ``` Note: Be sure to consider edge cases in your implementation to handle paths with no slashes appropriately.","solution":"def split_path_and_filename(path: str) -> tuple: Splits the input path into directory part and filename. Handles both URLs and Unix-style file paths. if not path: return (\\"\\", \\"\\") # If the path ends with \'/\', treat as a directory if path.endswith(\'/\'): return (path.rstrip(\'/\'), \\"\\") # Split the path from the last \'/\' character last_slash_position = path.rfind(\'/\') if last_slash_position == -1: # No slash in the path return (\\"\\", path) else: return (path[:last_slash_position], path[last_slash_position+1:])"},{"question":"# Introduction: In number theory, there are certain numbers whose digit-wise manipulations yield unique properties. For this task, you are to extend the identification of numbers where the digits raised consecutively to increasing powers sum up to the number itself. This problem tests your understanding of iterative processing and digit manipulation in numeric algorithms. # Task: Write a function `sequential_power_sum_numbers(low, high)` that finds all numbers in the range `[low, high]` where the sum of their digits raised to consecutive powers (starting from 1) equals the number itself. # Input: - `low` (int) - the lower bound of the range (inclusive). - `high` (int) - the upper bound of the range (inclusive). # Output: - Return a list of integers that satisfy the above property within the given range. # Constraints: - `1 <= low <= high <= 10^6` # Performance Requirements: - Ensure code efficiency considering the constraints to avoid timeouts for large ranges. # Example: ```python def sequential_power_sum_numbers(low, high): result = [] for number in range(low, high + 1): str_num = str(number) sum_pow = sum(int(digit) ** (index + 1) for index, digit in enumerate(str_num)) if sum_pow == number: result.append(number) return result # Example Cases assert sequential_power_sum_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sequential_power_sum_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] ``` **Focus on performance optimizations when handling the extended range limits. Ensure correct handling of digit powers and efficient summation to ensure the function runs within acceptable time frames.**","solution":"def sequential_power_sum_numbers(low, high): result = [] for number in range(low, high + 1): str_num = str(number) sum_pow = sum(int(digit) ** (index + 1) for index, digit in enumerate(str_num)) if sum_pow == number: result.append(number) return result"},{"question":"# Deep Clone of a Linked List with Random Pointers **Context:** You are a software engineer responsible for developing a backup system for complex linked lists where each node contains a random pointer that can point to any node in the list or be null. Your task is to implement an algorithm that creates a deep copy of such a linked list. **Problem Statement:** You have a class `RandomListNode` that represents a node in a linked list with an additional random pointer. Implement a function `copy_random_pointer(head: RandomListNode) -> RandomListNode` that returns a deep copy of the linked list. ```python class RandomListNode: def __init__(self, label: int = 0, next: \'RandomListNode\' = None, random: \'RandomListNode\' = None): self.label = label self.next = next self.random = random ``` **Function Signature:** ```python def copy_random_pointer(head: RandomListNode) -> RandomListNode: pass ``` **Input:** * `head` (RandomListNode): The head of the linked list with random pointers. **Output:** * RandomListNode: The head of the deep-copied linked list. **Constraints:** * The number of nodes in the linked list will be in the range [0, 1000]. * `-10000 <= RandomListNode.label <= 10000` * The linked list might contain cycles in terms of the random pointers. **Requirements:** 1. Time complexity must be O(n). 2. Space complexity must be O(n). **Instructions:** * Implement the function `copy_random_pointer` that performs a deep copy of the linked list. * Consider edge cases including an empty list or a list where all random pointers are None. * Assume the input list does not contain any invalid pointers and does not point outside the list.","solution":"class RandomListNode: def __init__(self, label: int = 0, next: \'RandomListNode\' = None, random: \'RandomListNode\' = None): self.label = label self.next = next self.random = random def copy_random_pointer(head: RandomListNode) -> RandomListNode: if not head: return None # Dictionary to store the mapping from original nodes to copied nodes old_to_new = {} # First pass to copy all nodes and create mapping current = head while current: old_to_new[current] = RandomListNode(current.label) current = current.next # Second pass to set next and random pointers current = head while current: if current.next: old_to_new[current].next = old_to_new[current.next] if current.random: old_to_new[current].random = old_to_new[current.random] current = current.next return old_to_new[head]"},{"question":"You are tasked with creating a file management system that ensures consistent and absolute file paths in any environment, regardless of user input. Develop a function that accepts a list of file paths (relative or containing user directory symbols such as `~`) and returns a list of their respective absolute paths. # Implementation Details Write a function `resolve_paths(paths: List[str]) -> List[str]` that takes the following: Input: - `paths` - A list of strings where each string is a file path. Output: - A list of strings, each representing the absolute path corresponding to the input list. # Constraints: - Paths can contain relative segments such as `./` or `../`. - Paths can include the user directory symbol `~`. - There will be no invalid paths or symbols to handle. - Assume the number of paths (`n`) provided in the list is within the range 1 <= n <= 10^4. # Example ```python Input: paths = [\'~/documents/file.txt\', \'../otherfile.txt\', \'./thisfile.txt\'] Output: [\'/home/username/documents/file.txt\', \'/home/username/otherfile.txt\', \'/home/username working dir/thisfile.txt\'] ``` # Performance Requirements - The implementation should be efficient to handle up to 10,000 paths within a reasonable time frame, ideally under one second. # Notes - Do not assume a specific OS for the example, replace `/home/username` with the home directory of the user on your system. - Make sure to test your function on different kinds of paths to ensure robustness.","solution":"import os from typing import List def resolve_paths(paths: List[str]) -> List[str]: This function accepts a list of file paths (relative or containing user directory symbols such as `~`) and returns a list of their respective absolute paths. absolute_paths = [os.path.abspath(os.path.expanduser(path)) for path in paths] return absolute_paths"},{"question":"# Randomized Set Implementation and Usage You have been hired by a software company to help design a data structure that supports efficient operations for an upcoming project. Specifically, you need to implement a `RandomizedSet` class that supports inserting, removing, and retrieving random elements. Implement the `RandomizedSet` class with the following methods: 1. **`__init__()`**: Initializes the data structure. 2. **`insert(val: int) -> bool`**: Inserts an item `val` to the set if not already present. Returns `True` if the element was not present, `False` otherwise. 3. **`remove(val: int) -> bool`**: Removes an item `val` from the set if present. Returns `True` if the element was present, `False` otherwise. 4. **`random_element() -> int`**: Returns a random element from the current set of elements. Each element must have the same probability of being returned. You are also provided with a testing function where you will need to instantiate the `RandomizedSet` and demonstrate the functionality of the methods above. Input/Output Format: * **`insert(val: int) -> bool`** * **Input**: An integer value `val`. * **Output**: Boolean value indicating success of insertion. * **`remove(val: int) -> bool`** * **Input**: An integer value `val`. * **Output**: Boolean value indicating success of removal. * **`random_element() -> int`** * **Output**: Random integer value from the current set of elements. Constraints: * The integers inserted into the `RandomizedSet` are in the range `[-10^6, 10^6]`. * No input/output constraints on the limits of insertion/removal operations. Performance Requirements: * All operations must run in O(1) average time complexity. Example Usage: ```python def example_usage(): rand_set = RandomizedSet() print(rand_set.insert(1)) # True print(rand_set.remove(2)) # False print(rand_set.insert(2)) # True print(rand_set.random_element()) # Randomly returns 1 or 2 print(rand_set.remove(1)) # True print(rand_set.insert(2)) # False, already present print(rand_set.random_element()) # Only element 2 ``` Coding Task: Write the implementation of the `RandomizedSet` class and the `example_usage()` function to demonstrate its usage.","solution":"import random class RandomizedSet: def __init__(self): self.dict = {} self.list = [] def insert(self, val: int) -> bool: if val not in self.dict: self.dict[val] = len(self.list) self.list.append(val) return True return False def remove(self, val: int) -> bool: if val in self.dict: last_element = self.list[-1] index = self.dict[val] self.list[index] = last_element self.dict[last_element] = index self.list.pop() del self.dict[val] return True return False def random_element(self) -> int: return random.choice(self.list) def example_usage(): rand_set = RandomizedSet() print(rand_set.insert(1)) # True print(rand_set.remove(2)) # False print(rand_set.insert(2)) # True print(rand_set.random_element()) # Randomly returns 1 or 2 print(rand_set.remove(1)) # True print(rand_set.insert(2)) # False, already present print(rand_set.random_element()) # Only element 2"},{"question":"# Prime Sum Problem Scenario: You are hired to optimize the performance of a cryptographic system which relies on checking the sum of prime numbers from a list. Given a list of integers, you need to implement a function that returns the sum of all prime numbers within the list. Task: You will implement the function: ```python def sum_of_primes(numbers): Given a list of integers, return the sum of all prime numbers in the list. :param numbers: List of integers :return: Sum of prime numbers pass ``` Input: - A list of integers `numbers` where the length of the list is between (1) and (10^6). Output: - Return a single integer which is the sum of all prime numbers in the list. Constraints: - Each integer in the list will be in the range ([1, 10^6]). Performance Requirements: - The solution should be efficient enough to handle the upper constraints within a reasonable time limit. Example: ```python numbers = [2, 3, 4, 5, 6, 7, 8, 9, 10] print(sum_of_primes(numbers)) # Output should be 17 (2 + 3 + 5 + 7) ``` # Guidelines: 1. You may use the provided prime-checking function as a helper function within your implementation. 2. Consider optimizing the code to handle large lists and numbers efficiently. 3. Account for edge cases such as empty lists or lists with no prime numbers.","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def sum_of_primes(numbers): Given a list of integers, return the sum of all prime numbers in the list. :param numbers: List of integers :return: Sum of prime numbers return sum(n for n in numbers if is_prime(n))"},{"question":"Problem Statement You are given a sorted array of integers and a target value. Implement the ternary search algorithm to find the target value in the array. If the target value is found, return its index. If the target value is not found, return -1. Your solution should handle various edge cases and optimize for performance as described in the analysis. # Function Signature ```python def ternary_search(array: List[int], target: int) -> int: pass ``` # Input * `array`: A sorted list of integers (sorted in ascending order) with (0 leq text{length of array} leq 10^6). * `target`: An integer, the value you need to find in the array. # Output * Return the index of the target in the array if found, otherwise return -1. # Constraints * The list is non-empty and sorted in non-decreasing order. * The list length will be at most (10^6), requiring efficient search. # Example ```python # Input array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] target = 5 # Output 4 # Input array = [1, 2, 3, 4, 5] target = 6 # Output -1 ``` Write a function `ternary_search` that implements this logic in Python.","solution":"from typing import List def ternary_search(array: List[int], target: int) -> int: Performs the ternary search on a sorted array to find the index of target. Returns -1 if the target is not found. def search(left, right): if left > right: return -1 # Divide the array into three parts third = (right - left) // 3 mid1 = left + third mid2 = right - third if array[mid1] == target: return mid1 if array[mid2] == target: return mid2 if target < array[mid1]: return search(left, mid1 - 1) # Search in the first third elif target > array[mid2]: return search(mid2 + 1, right) # Search in the third third else: return search(mid1 + 1, mid2 - 1) # Search in the middle third return search(0, len(array) - 1)"},{"question":"Consider the problem of searching words from a given list in a 2D grid of characters. This task involves implementing an efficient algorithm using both a Trie data structure and a backtracking method. You are provided with a grid (board) and a list of words. # Goals: 1. Build a Trie data structure from the list of words. 2. Implement a backtracking function to search the words within the grid using the Trie for quick prefix searches. # Function Signature ```python def find_words(board: List[List[str]], words: List[str]) -> List[str]: ``` # Input: - `board`: A list of lists of characters, representing the 2D grid (1 <= len(board), len(board[0]) <= 12). - `words`: A list of strings, representing the words to be searched in the grid (1 <= len(words) <= 3 * 10^4, 1 <= len(words[i]) <= 10). # Output: - A list containing all words from the given list that can be found in the board. # Constraints: - Each cell in the board can be used at most once in a word. - Words are formed by concatenating adjacent (up, down, left, or right) letters. - Words cannot wrap around in the grid. # Example: ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"] assert find_words(board, words) == [\\"oath\\", \\"eat\\"] ``` # Additional Requirements: - Your implementation should be efficient in terms of both time and space complexity. - Handle edge cases and avoid redundant traversals or searches by leveraging the properties of the Trie. The provided code structure is a good starting point. You need to enhance or tailor it to meet the objectives and manage constraints effectively.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False def build_trie(words): root = TrieNode() for word in words: node = root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True return root def find_words(board, words): def backtrack(row, col, parent, path): char = board[row][col] cur_node = parent.children[char] if cur_node.is_end_of_word: result.add(\\"\\".join(path)) cur_node.is_end_of_word = False board[row][col] = \'#\' for (row_offset, col_offset) in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_row, new_col = row + row_offset, col + col_offset if 0 <= new_row < len(board) and 0 <= new_col < len(board[0]): if board[new_row][new_col] in cur_node.children: backtrack(new_row, new_col, cur_node, path + [board[new_row][new_col]]) board[row][col] = char if not cur_node.children: parent.children.pop(char) result = set() root = build_trie(words) for row in range(len(board)): for col in range(len(board[0])): if board[row][col] in root.children: backtrack(row, col, root, [board[row][col]]) return list(result)"},{"question":"# Question: Robot Circle Detection Context: A utility robot starts at the origin point (0, 0) on a 2D grid. It can receive a sequence of commands represented by a string, where each command directs it to move one step in one of the four cardinal directions: * \'U\' for upward * \'D\' for downward * \'L\' for leftward * \'R\' for rightward. Your task is to implement a function `detect_circle` that takes a string of commands and determines whether the robot returns to the starting position (i.e., forms a closed loop). Function Signature: ```python def detect_circle(moves: str) -> bool: pass ``` Input: - `moves`: a string, consisting of characters \'U\', \'D\', \'L\', \'R\' only (1 ≤ len(moves) ≤ 1000). The string represents the sequence of moves made by the robot. Output: - Returns a boolean value `True` if the robot returns to the starting point after executing all the moves, and `False` otherwise. Constraints: - You should not consider an invalid input for this task. - The algorithm should run in O(n) time, where n is the length of the input string. # Example: **Example 1** Input: `\\"UD\\"` Output: `True` **Example 2** Input: `\\"LL\\"` Output: `False`","solution":"def detect_circle(moves: str) -> bool: Determines if the robot returns to the starting position. :param moves: A string consisting of characters \'U\', \'D\', \'L\', \'R\' only. :return: True if the robot returns to the starting position, False otherwise. x, y = 0, 0 # Robot starts at origin (0, 0) for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"Context Imagine you are working on an application that processes large audio signals for sound frequency analysis. One of the key requirements is to transform a time-domain signal into its frequency-domain representation using the Fast Fourier Transform (FFT) algorithm. You will need to implement the well-known Cooley-Tukey FFT algorithm to accomplish this task. Task Your task is to write a Python function `fft` that performs the Fast Fourier Transform on an array of complex numbers. The size of the input array will always be a power of 2. Function Signature ```python def fft(x: List[complex]) -> List[complex]: ``` Input * `x` (List[complex]): An array of complex numbers with a length that is a power of 2. Each complex number is represented by `a + bj` where `a` and `b` are float values. Output * (List[complex]): An array of complex numbers representing the frequency-domain transformation of the input array. Constraints * The length of the input array (N) is (1 leq N leq 2^{20}). * The input array elements are valid Python `complex` numbers. Example ```python # Example input input_array = [2.0 + 2j, 1.0 + 3j, 3.0 + 1j, 2.0 + 2j] # Calling fft function result = fft(input_array) # Expected output print(result) # Output: [(8+8j), (2j), (2-2j), (-2+0j)] ``` Notes * Demonstrate your understanding of complex numbers and recursion in this problem. * Optimize your function for large inputs where possible while maintaining readability. * Consider common edge cases, such as input arrays of minimal size (e.g., length 1).","solution":"from typing import List import cmath def fft(x: List[complex]) -> List[complex]: N = len(x) if N <= 1: return x even = fft(x[0::2]) odd = fft(x[1::2]) T = [cmath.exp(-2j * cmath.pi * k / N) * odd[k] for k in range(N // 2)] return [even[k] + T[k] for k in range(N // 2)] + [even[k] - T[k] for k in range(N // 2)]"},{"question":"Scenario: You are a software developer at a security company. Your task is to enhance their home security system by developing a feature that helps users determine the maximum amount of money they can securely rob from a series of houses. Each house in the neighborhood has a certain amount of money stashed, and due to security concerns, no two adjacent houses can be robbed on the same night. Given this situation, write a function that computes the maximum money one can rob from non-adjacent houses. Function: ```python def house_robber(houses): Determine the maximum amount of money one can rob from non-adjacent houses. Arguments: houses -- a list of non-negative integers indicating the amount of money in each house. Returns: int -- the maximum amount that can be robbed without triggering the security system. ``` Expected Input and Output * **Input**: A list of non-negative integers, `houses`, where `houses[i]` represents the amount of money in the i-th house. * **Output**: An integer representing the maximum amount of money that can be robbed. Constraints * The length of the list `houses` is at most 10,000. * Values in `houses` are non-negative integers between 0 and 1000. Performance Requirements The solution should efficiently handle large inputs up to the given constraint limits. Examples 1. **Input**: `[2, 7, 9, 3, 1]` **Output**: `12` **Explanation**: Robbing house 1 (money = 2) and house 3 (money = 9) results in a maximum rob amount of 2 + 9 = 11. Robbing house 2 (money = 7) and house 4 (money = 3) results in a maximum rob amount of 7 + 3 = 10. Robbing house 1 (money = 2), house 2 (money = 7), and house 4 (money = 3) isn\'t viable since houses 1 and 2, and houses 2 and 4 are adjacent. Therefore, the optimal solution is to rob house 2 and house 3 for a total of 7 + 3 = 10. 2. **Input**: `[1, 2, 3, 1]` **Output**: `4` **Explanation**: Robbing house 1 (money = 1) and house 3 (money = 3) results in a maximum rob amount of 1 + 3 = 4. It is more than robbing house 2 (money = 2) and house 4 (money = 1). Implement the function with thorough handling of edge cases and optimize the runtime to satisfy the performance requirements.","solution":"def house_robber(houses): Determine the maximum amount of money one can rob from non-adjacent houses. Arguments: houses -- a list of non-negative integers indicating the amount of money in each house. Returns: int -- the maximum amount that can be robbed without triggering the security system. if not houses: return 0 n = len(houses) if n == 1: return houses[0] dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1]"},{"question":"# Stooge Sort Challenge Stooge sort is a recursive sorting algorithm with a particularly high time complexity. While usually not used in practical applications, it serves as an excellent exercise for understanding recursion and divide-and-conquer algorithms. In this challenge, you will implement the stooge sort algorithm. **Task**: Write a function `stoogesort(arr)` to sort a list of integers using the stooge sort algorithm. # Function Signature ```python def stoogesort(arr, l, h): pass ``` # Input * `arr`: A list of integers (1 ≤ length of arr ≤ 1000, -10^4 ≤ arr[i] ≤ 10^4), where 0 ≤ l < h < length of arr. # Output * The function should sort the input list `arr` in non-decreasing order. # Example ```python arr = [5, 3, 2, 4, 1] stoogesort(arr, 0, len(arr) - 1) print(arr) ``` *Output*: [1, 2, 3, 4, 5] # Constraints * Your implementation should consider the inefficiencies of stooge sort but should stick to the algorithm\'s core principles. * Recursive function calls should respect depth and index bounds to avoid stack overflow and out-of-bounds errors. * Aim to manage time complexity within reason given the limitations of stooge sort. # Guidelines: 1. Define and initialize the base cases for the recursion. 2. Implement the compare-and-swap step. 3. Recursive steps to sort and confirm order. This question will test your understanding of recursion, array manipulation, and handling edge cases in algorithm implementation.","solution":"def stoogesort(arr, l, h): if l >= h: return arr if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t) return arr"},{"question":"You are given a matrix of integers where every row and every column is sorted in non-decreasing order. Implement a function `search_in_sorted_matrix(matrix, key)` that returns the position of a given key in the matrix. If the key is not present, the function should return `(-1, -1)` indicating the key was not found. # Input * `matrix`: A 2-D list of integers of size `m x n` where `1 <= m, n <= 1000`. * `key`: An integer which you aim to find in the matrix. # Output * Return a tuple (i, j) representing the row and column (1-indexed) where the key is found. If the key is not found, return (-1, -1). # Constraints * Each row and column of the matrix are sorted in non-decreasing order. * Avoid using extra space for the search. * Aim for a time complexity of O(m + n). # Example ```python def search_in_sorted_matrix(matrix, key): # Your code here # Example 1 matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] key = 5 print(search_in_sorted_matrix(matrix, key)) # Output: (2, 2) # Example 2 matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] key = 20 print(search_in_sorted_matrix(matrix, key)) # Output: (-1, -1) ``` # Notes * The matrix is guaranteed to be non-empty and valid. * The indices returned are 1-based, meaning the first row and first column are indexed as (1,1).","solution":"def search_in_sorted_matrix(matrix, key): Returns the position (1-based index) of the key in a sorted matrix. If the key is not present, returns (-1, -1). if not matrix or not matrix[0]: return (-1, -1) m = len(matrix) n = len(matrix[0]) # Start from the top-right corner of the matrix row = 0 col = n - 1 while row < m and col >= 0: if matrix[row][col] == key: return (row + 1, col + 1) elif matrix[row][col] > key: col -= 1 else: row += 1 return (-1, -1)"},{"question":"Context You are a software developer working on a predictive text feature for a chat application. Given a user’s previous message, you aim to suggest the next word they are likely to type based on historical data of word sequences. You will utilize a Markov Chain to model this behavior. Task Implement a function `generate_predictions(chain, start_state, num_predictions)` that generates a list of the next `num_predictions` states based on a given initial state and a provided Markov Chain. This can be used to predict the sequence of words a user might type next. Input * `chain` (dict): A dictionary representing the Markov chain where keys are states and values are dictionaries mapping possible next states to their transition probabilities. * `start_state` (str): The initial state from which to start the predictions. * `num_predictions` (int): The number of predictions to generate sequentially. Output * A list of predicted states (str) in the order they are generated. Constraints * The sum of probabilities for each state\'s transitions must be 1. * You can assume `chain`, `start_state`, and `num_predictions` are valid and provided correctly. Performance Requirements * Efficient handling of up to 1000 states and at least 100 possible transitions per state. Example ```python chain = { \'hello\': {\'world\': 0.5, \'there\': 0.5}, \'world\': {\'hello\': 1.0}, \'there\': {\'hello\': 1.0} } start_state = \'hello\' num_predictions = 5 generate_predictions(chain, start_state, num_predictions) ``` Expected Output (one possible sequence): ``` [\'there\', \'hello\', \'world\', \'hello\', \'there\'] ``` Function Signature ```python def generate_predictions(chain, start_state, num_predictions): pass ```","solution":"import random def generate_predictions(chain, start_state, num_predictions): Generates a list of the next `num_predictions` states based on a given initial state and a provided Markov Chain. Params: chain (dict): A dictionary representing the Markov chain where keys are states and values are dictionaries mapping possible next states to their transition probabilities. start_state (str): The initial state from which to start the predictions. num_predictions (int): The number of predictions to generate sequentially. Returns: List[str]: A list of predicted states in the order they are generated. predictions = [] current_state = start_state for _ in range(num_predictions): next_states = list(chain[current_state].keys()) probabilities = list(chain[current_state].values()) current_state = random.choices(next_states, probabilities)[0] predictions.append(current_state) return predictions"},{"question":"# Pattern Matching Validation You are given a pattern and a string, `str`, separated by spaces. Your task is to write a function `is_pattern_match(pattern, string)` that determines if the input string follows the same pattern. Follow means that there is a one-to-one correspondence between a character in the pattern and a non-empty word in the string. # Constraints - `pattern` will contain only lowercase letters and will be at least 1 character long. - `str` contains lowercase letters and words are separated by a single space. - Both inputs will be non-empty. # Input - `pattern`: A string of lowercase letters (1 ≤ length of pattern ≤ 1000). - `str`: A space-separated string of lowercase words (1 ≤ number of words ≤ 1000, 1 ≤ length of each word ≤ 10). # Output - Return `True` if the string follows the pattern. - Return `False` otherwise. # Example ```python print(is_pattern_match(\\"abba\\", \\"dog cat cat dog\\")) # Output: True print(is_pattern_match(\\"abba\\", \\"dog cat cat fish\\")) # Output: False print(is_pattern_match(\\"aaaa\\", \\"dog cat cat dog\\")) # Output: False print(is_pattern_match(\\"abba\\", \\"dog dog dog dog\\")) # Output: False ``` Note: - You should ensure that there is no repeated character-to-word mapping that conflicts (for example, a character from the pattern should not map to different words). - Consider edge cases such as patterns and strings with differing lengths. # Function Signature ```python def is_pattern_match(pattern: str, string: str) -> bool: # Implementation ```","solution":"def is_pattern_match(pattern, string): Determines if the input string follows the same pattern. words = string.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False if word in word_to_char: if word_to_char[word] != char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"# Scenario You are implementing a simple text editor, and you need to manage changes in the document. Implement a Undo feature using a stack data structure. You will be provided with a sequence of operations, which can either be inserting a string at a certain position or undoing the last operation. Use the given stack design to implement this feature. # Task 1. Implement a class `TextEditor` that utilizes the stack functionalities: 2. Implement the following methods: - `insert(self, position: int, value: str)`: Inserts the string `value` starting from the given `position`. This operation should be recorded in a stack to allow undoing. - `undo(self)`: Undoes the last operation. Throws an error if there are no operations to undo. - `get_text(self)`: Returns the current state of the text as a string. # Constraints - The initial text is an empty string. - Operations are provided in a sequence, and each operation is either an insert or undo. - Insertions and undo operations are guaranteed to be valid based on the sequence provided. # Example ```python operations = [ (\\"insert\\", 0, \\"Hello\\"), (\\"insert\\", 5, \\" World\\"), (\\"undo\\"), (\\"insert\\", 5, \\", Stack\\") ] editor = TextEditor() for op in operations: if op[0] == \\"insert\\": editor.insert(op[1], op[2]) elif op[0] == \\"undo\\": editor.undo() print(editor.get_text()) # Output should be: \\"Hello, Stack\\" ``` # Requirements 1. `TextEditor` should use a stack internally to manage undo operations. 2. Ensure that the undo feature can handle multiple undos and correctly revert the state to previous states.","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] def insert(self, position: int, value: str): before = self.text[:position] after = self.text[position:] self.history.append(self.text) self.text = before + value + after def undo(self): if not self.history: raise IndexError(\\"No operations to undo\\") self.text = self.history.pop() def get_text(self): return self.text"},{"question":"# Decoding an Encoded String You are given an encoded string, where the encoding rule is represented as `k[encoded_string]`. This means that the substring inside the brackets should be repeated exactly `k` times. Your task is to decode this string. Input - A single string `s` representing the encoded string. - `s` will have valid format: square brackets are well-formed, no extra white spaces, and the digits only represent repeat counts. Output - Return the decoded string which expands all the encodings. Constraints - `1 <= len(s) <= 30,000` - Digits are only for repeat counts and all repeat counts are positive integers. - The original data does not contain any digits. Example Input: \\"3[a]2[bc]\\" Output: \\"aaabcbc\\" Input: \\"3[a2[c]]\\" Output: \\"accaccacc\\" Input: \\"2[abc]3[cd]ef\\" Output: \\"abcabccdcdcdef\\" Performance Requirements - Your solution should efficiently handle strings up to the maximum length. # Task Implement the function `decode_string(s: str) -> str` that decodes the given encoded string and returns the decoded string. ```python def decode_string(s): :type s: str :rtype: str # Your code here ```","solution":"def decode_string(s): def helper(index): decoded_string = \\"\\" while index < len(s) and s[index] != \']\': if s[index].isdigit(): k = 0 while s[index].isdigit(): k = k * 10 + int(s[index]) index += 1 index += 1 # skip \'[\' encoded_string, index = helper(index) index += 1 # skip \']\' decoded_string += encoded_string * k else: decoded_string += s[index] index += 1 return decoded_string, index decoded_string, _ = helper(0) return decoded_string"},{"question":"Scenario You are working on a search engine\'s backend that needs to efficiently find the range of document IDs that contain a particular keyword. The document IDs are stored in a list in ascending order for fast search operations. Problem Statement Given a list of integers `document_ids` sorted in ascending order, implement a function `find_keyword_range` to find the starting and ending position of a given `keyword_id`. If the `keyword_id` is not found in the list, the function should return `[-1, -1]`. Function Signature ```python def find_keyword_range(document_ids: List[int], keyword_id: int) -> List[int]: pass ``` Input * `document_ids` (List[int]): A list of integer document IDs sorted in ascending order. * `keyword_id` (int): The target keyword ID to search for. Output * Return a list of two integers `[start, end]` representing the range of positions where `keyword_id` is found. If the `keyword_id` is not found, return `[-1, -1]`. Constraints * The length of `document_ids` will be in the range [0, 10⁵]. * The document IDs and keyword ID values will be in the range [−10⁶, 10⁶]. Example ```python # Example 1 document_ids = [5, 7, 7, 8, 8, 8, 10] keyword_id = 8 # Output: [3, 5] # Example 2 document_ids = [5, 7, 7, 8, 8, 8, 10] keyword_id = 11 # Output: [-1, -1] ``` # Notes * Ensure that your solution efficiently finds the keyword range by leveraging the fact that `document_ids` is sorted. * Handle edge cases such as empty lists, single-element lists, and lists with all identical elements.","solution":"from typing import List def find_keyword_range(document_ids: List[int], keyword_id: int) -> List[int]: def binary_search(arr, target, find_first): low, high = 0, len(arr) - 1 result = -1 while low <= high: mid = (low + high) // 2 if arr[mid] == target: result = mid if find_first: high = mid - 1 # Look on the left side else: low = mid + 1 # Look on the right side elif arr[mid] < target: low = mid + 1 else: high = mid - 1 return result start = binary_search(document_ids, keyword_id, True) if start == -1: return [-1, -1] end = binary_search(document_ids, keyword_id, False) return [start, end]"},{"question":"# Spiral Order Matrix Traversal Challenge Objective Write a function that takes in a 2D matrix and returns a list of its elements in spiral order. Function Signature ```python def spiral_traversal(matrix: List[List[int]]) -> List[int]: ``` Input * `matrix`: A 2D list of integers of dimensions m x n (0 ≤ m, n ≤ 100) * Example: ```python matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] ``` Output * A list of integers representing the elements of the matrix in spiral order. * Example: ```python output = [1, 2, 3, 6, 9, 8, 7, 4, 5] ``` Constraints * The function should handle empty matrices. * The matrix will have at most 100 rows and 100 columns. * The matrix will be properly rectangular (all rows will have the same number of columns). Example ```python assert spiral_traversal([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == [1, 2, 3, 6, 9, 8, 7, 4, 5] assert spiral_traversal([[2, 3]]) == [2, 3] assert spiral_traversal([[]]) == [] ``` Task Implement function `spiral_traversal` that efficiently returns elements of a given matrix in spiral order. Hint: Utilize four pointers to track the boundaries and iterate over the matrix accordingly.","solution":"from typing import List def spiral_traversal(matrix: List[List[int]]) -> List[int]: if not matrix or not matrix[0]: return [] spiral_order = [] top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right along the top boundary for col in range(left, right + 1): spiral_order.append(matrix[top][col]) top += 1 # Traverse from top to bottom along the right boundary for row in range(top, bottom + 1): spiral_order.append(matrix[row][right]) right -= 1 if top <= bottom: # Traverse from right to left along the bottom boundary for col in range(right, left - 1, -1): spiral_order.append(matrix[bottom][col]) bottom -= 1 if left <= right: # Traverse from bottom to top along the left boundary for row in range(bottom, top - 1, -1): spiral_order.append(matrix[row][left]) left += 1 return spiral_order"},{"question":"Binary Search Assessment Question # Objective Your task is to implement a function that utilizes the binary search algorithm to locate the position of a target element within a sorted array of integers. Both iterative and recursive implementations are required. # Function Signature ```python def binary_search_iter(array: List[int], query: int) -> int: pass def binary_search_recur(array: List[int], query: int) -> int: pass ``` # Input and Output - **Input**: - `array` (List[int]): A list of integers sorted in ascending order. - `query` (int): The target integer to be searched within the array. - **Output**: - Returns the index (int) of the target element if it is present in the array, otherwise returns -1. # Constraints - All elements in the array are unique. - The array length is between 1 and (10^5). - All elements are in the range of (-10^9) to (10^9). - Solve the problem with a time complexity of O(log(n)) and a space complexity of O(1) for the iterative solution, and O(log(n)) for the recursive solution. # Example ```python # Example 1 assert binary_search_iter([1, 3, 5, 7, 9], 5) == 2 assert binary_search_recur([1, 3, 5, 7, 9], 5) == 2 # Example 2 assert binary_search_iter([1, 3, 5, 7, 9], 6) == -1 assert binary_search_recur([1, 3, 5, 7, 9], 6) == -1 ``` # Requirements - **binary_search_iter**: Implement the binary search algorithm iteratively. - **binary_search_recur**: Implement a recursively based binary search. - Handle edge cases such as an empty array or a single-element array. # Hints 1. Carefully consider base cases for the recursive function. 2. Use integer division to find the mid-point to avoid floating point arithmetic issues.","solution":"from typing import List def binary_search_iter(array: List[int], query: int) -> int: This function performs an iterative binary search on a sorted array. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == query: return mid elif array[mid] < query: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recur(array: List[int], query: int) -> int: This function performs a recursive binary search on a sorted array. def search(low, high): if low > high: return -1 mid = (low + high) // 2 if array[mid] == query: return mid elif array[mid] < query: return search(mid + 1, high) else: return search(low, mid - 1) return search(0, len(array) - 1)"},{"question":"# Comb Sort Implementation Challenge Comb Sort is a comparison-based sorting algorithm that improves on Bubble Sort by using a gap size to compare and swap elements, decreasing the gap over time until it becomes 1 (at which point it functions like Bubble Sort). The typical shrink factor used is 1.3, meaning the gap is divided by 1.3 in each iteration until it becomes 1. Your task is to implement a slightly modified version of Comb Sort, which uses a user-defined shrink factor and behaves robustly under various input scenarios. Ensure maximum efficiency and handle edge cases effectively. **Function Signature**: ```python def comb_sort_custom(arr: List[int], shrink: float) -> List[int]: ``` **Input**: * A list `arr` of `n` integers (1 ≤ n ≤ 10^6). * A float `shrink` (1 < shrink ≤ 2.2), which represents the shrink factor for the sorting process. **Output**: * A sorted list of integers in ascending order. **Constraints**: * The function should work within a time complexity close to O(N log N) for average cases. * The function should handle empty lists and single-element lists gracefully. **Examples**: ```python assert comb_sort_custom([5, 3, 8, 4, 2], 1.3) == [2, 3, 4, 5, 8] assert comb_sort_custom([], 1.3) == [] assert comb_sort_custom([1], 1.3) == [1] assert comb_sort_custom([1, 4, 6, 3, 7], 1.5) == [1, 3, 4, 6, 7] assert comb_sort_custom([3, 3, 3, 3, 3], 1.3) == [3, 3, 3, 3, 3] ``` **Performance Requirements**: * The function should efficiently handle up to `10^6` elements. **Additional Notes**: * Be mindful of index boundaries when updating and comparing elements. * Ensure the solution avoids infinite loops and correctly handles the edge cases specified.","solution":"def comb_sort_custom(arr, shrink): if not arr: # Easy edge case for empty list return [] if len(arr) == 1: return arr # Easy edge case for single element list gap = len(arr) swapped = True while gap > 1 or swapped: gap = max(1, int(gap // shrink)) # Ensuring the gap is always at least 1 swapped = False for i in range(len(arr) - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Cosine Similarity Calculation You have been tasked with writing a function to calculate the cosine similarity between two vectors. Cosine similarity is a measure of similarity between two non-zero vectors of an inner product space that measures the cosine of the angle between them. The cosine of 0° is 1, and it is less than 1 for any other angle. The cosine similarity is computed as: [ cos(theta) = frac{A cdot B}{||A||_2 cdot ||B||_2} ] Where ( A cdot B ) is the dot product of the vectors, and ( ||A||_2 ) and ( ||B||_2 ) are their Euclidean norms. # Your Task: Implement the function `cosine_similarity(vec1, vec2)` that calculates the cosine similarity between `vec1` and `vec2`. # Function Signature: ```python def cosine_similarity(vec1: list, vec2: list) -> float: ``` # Input: * `vec1`: List of integers/floats representing the first vector. * `vec2`: List of integers/floats representing the second vector. # Output: * Returns a float value representing the cosine similarity between `vec1` and `vec2`. # Constraints: * Both vectors must have the same length. * Each vector can have up to (10^6) elements. * Elements in vectors can be in the range of ([-10^6, 10^6]). # Example: Input: ```python cosine_similarity([1, 1, 1], [1, 2, -1]) ``` Output: ```python 0.47140452079103173 ``` # Additional Information: * Raise a `ValueError` if the vectors differ in length. * Handle cases where one or both vectors have all-zero values by returning 0 as the cosine similarity. Make sure your implementation is optimized for performance within the given constraints.","solution":"import math def cosine_similarity(vec1, vec2): Calculates the cosine similarity between two vectors. Args: vec1 (list): First vector vec2 (list): Second vector Returns: float: Cosine similarity between vec1 and vec2 if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") dot_product = sum(a * b for a, b in zip(vec1, vec2)) norm_a = math.sqrt(sum(a * a for a in vec1)) norm_b = math.sqrt(sum(b * b for b in vec2)) if norm_a == 0 or norm_b == 0: return 0.0 return dot_product / (norm_a * norm_b)"},{"question":"# Coding Challenge: Sentence Formation with Dictionary Words **Context**: In text processing and natural language processing, there are scenarios where you need to determine how a given string can be segmented into valid words according to a predefined dictionary. This is similar to the word break problem, where the goal is to find all possible ways to segment the string into dictionary words. **Problem Statement**: Given a string and a set of dictionary words, write a function `sentenceCount` that returns the number of valid sentences that can be formed. A sentence is valid if every word in the sentence is found in the dictionary. Your function should compute this efficiently to handle larger inputs. **Function Signature**: ```python def sentenceCount(input_str: str, dictionary: set) -> int: pass ``` **Input**: - `input_str` : A string of lowercase characters (1 <= len(input_str) <= 100). - `dictionary` : A set of words (1 <= len(dictionary) <= 1000), where each word has a length between 1 and 15. **Output**: - An integer representing the number of valid sentences. **Constraints**: - Dictionary words consist of lowercase alphabets only. - Assume that the input string and dictionary are non-empty. **Example**: 1. `input_str = \\"appletablet\\", dictionary = {\\"apple\\", \\"tablet\\", \\"applet\\", \\"able\\", \\"t\\", \\"app\\", \\"let\\"}` - Output: `4` - Explanation: The valid sentences are \\"apple tablet\\", \\"applet\\", \\"apple t able t\\", \\"app let able t\\". 2. `input_str = \\"thing\\", dictionary = {\\"thing\\"}` - Output: `1` - Explanation: Only one sentence possible: \\"thing\\". **Performance Requirements**: - Optimize for time complexity using memoization or other techniques to avoid redundant computations. **Hint**: Dynamic programming can be a very efficient approach to optimize recursive backtracking problems.","solution":"def sentenceCount(input_str: str, dictionary: set) -> int: Returns the number of valid sentences that can be formed from input_str using dictionary words. memo = {} def helper(s): if not s: return 1 if s in memo: return memo[s] count = 0 for end in range(1, len(s) + 1): if s[:end] in dictionary: count += helper(s[end:]) memo[s] = count return count return helper(input_str)"},{"question":"Next Higher Permutation # Context You are tasked to find the next higher number that can be formed using the exact same digits as the given number. This is useful in combinatorial problems where you need to generate the next lexicographical permutation of a given number. # Problem Write a Python function `next_bigger(num: int) -> int` that takes an integer `num` and returns the next higher permutation of its digits. If no such permutation exists, return `-1`. # Input Format * A single integer, `num`, where `1 <= num <= 10^9`. # Output Format * A single integer representing the next higher permutation. If no such permutation exists, return `-1`. # Constraints * You should handle up to 1 billion, which means your solution should be efficient in terms of time complexity. * Consider edge cases such as numbers with repeated digits, the smallest and largest possible valid numbers, etc. # Performance Requirements * The solution should have a linear time complexity O(n) relative to the number of digits. # Example Example 1: * Input: 38276 * Output: 38627 Example 2: * Input: 99999 * Output: -1 # Implementation Your function signature should look as follows: ```python def next_bigger(num: int) -> int: pass ```","solution":"def next_bigger(num: int) -> int: Returns the next higher permutation of the digits of the input number. If no such permutation exists, returns -1. digits = list(str(num)) n = len(digits) # Find the rightmost digit that is smaller than the digit next to it. i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such digit is found, no greater permutation is possible. if i == -1: return -1 # Find the smallest digit on right side of (i) which is larger than digits[i] j = n - 1 while digits[j] <= digits[i]: j -= 1 # Swap the found digits[i] and digits[j] digits[i], digits[j] = digits[j], digits[i] # Reverse digits after the position i digits = digits[:i + 1] + digits[i + 1:][::-1] # Convert list of digits back to integer return int(\'\'.join(digits))"},{"question":"You are given a 2D grid map of \'1\'s (land) and \'0\'s (water). Your task is to write a function `num_islands(grid)` that returns the number of distinct islands in the grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. # Inputs: - **grid**: A 2D list of integers where 1 represents land and 0 represents water. # Outputs: - **count**: An integer representing the number of islands. # Constraints: - The dimensions of the grid are guaranteed to be non-negative and grid[i][j] ∈ {0, 1}. - You must handle grids of varying sizes efficiently. # Example Input and Output: Example 1: ``` grid = [ [1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0] ] Output: 1 ``` Example 2: ``` grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] Output: 3 ``` # Guidelines: 1. Implement the `num_islands` function such that it accurately counts islands by traversing the grid. 2. Ensure to handle edge cases like an empty grid or grid with all 0s or 1s. 3. Optimize for time and space complexity considering large grid sizes. 4. Consider converting the recursive DFS approach to an iterative one if you\'re comfortable to avoid stack depth issues. # Function Signature ```python def num_islands(grid: List[List[int]]) -> int: ``` Write your implementation below:","solution":"def num_islands(grid): if not grid: return 0 num_rows = len(grid) num_cols = len(grid[0]) count = 0 def dfs(r, c): if (0 <= r < num_rows) and (0 <= c < num_cols) and grid[r][c] == 1: grid[r][c] = 0 # Mark the land as visited # Visit all adjacent land cells: left, right, top, bottom dfs(r - 1, c) dfs(r + 1, c) dfs(r, c - 1) dfs(r, c + 1) for r in range(num_rows): for c in range(num_cols): if grid[r][c] == 1: count += 1 dfs(r, c) return count"},{"question":"# Merging k Sorted Linked Lists Using Heaps Given k sorted linked lists, each represented by a singly-linked list object, write a Python function to merge all the linked lists into one sorted linked list. You should use a min-heap to always extract the smallest element at any step efficiently. Function Signature ```python def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: ``` Input * A list `lists` of k linked list heads, where each linked list head is an instance of `ListNode` or `None`. * `1 <= k <= 10000` * The total number of nodes across all linked lists <= 1,000,000. * Node values can be negative or positive integers and are in sorted order within each list. Output * A single linked list head, representing the merged and sorted linked list of all input lists. Example ```python # Example Definition for LinkedList class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def create_linked_list(arr): head = ListNode(arr[0]) current = head for value in arr[1:]: new_node = ListNode(value) current.next = new_node current = current.next return head list1 = create_linked_list([1, 4, 5]) list2 = create_linked_list([1, 3, 4]) list3 = create_linked_list([2, 6]) lists = [list1, list2, list3] merged_list = merge_k_sorted_lists(lists) # Expected Output: # The merged list should be: 1->1->2->3->4->4->5->6 ``` Constraints * The input lists can vary in length and some may be empty. * Designed to handle very large values of k and many nodes efficiently. Requirements * You must use a min-heap to solve this problem, ensuring an efficient solution with a time complexity of O(n log k).","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def __repr__(self): return f\\"{self.val}->\\" + (repr(self.next) if self.next else \\"None\\") def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap = [] # Initialize the heap for i, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, i, node)) # Dummy head and pointer for result linked list dummy = ListNode() current = dummy while min_heap: value, index, node = heapq.heappop(min_heap) current.next = ListNode(value) current = current.next # If the popped node has a next node, push it to the heap if node.next: heapq.heappush(min_heap, (node.next.val, index, node.next)) return dummy.next # Helper function to create a linked list from a list of values. def create_linked_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for value in arr[1:]: new_node = ListNode(value) current.next = new_node current = current.next return head"},{"question":"Scenario You are working as a software developer at a company that processes large volumes of numerical data. One of your tasks is to optimize the sorting process for a series of dynamically incoming data arrays. The company values not only the efficiency but also the stability of the sorting algorithm. Objective Write a function `merge_sort_inplace(arr)` that implements the Merge Sort algorithm, sorting the array in-place to minimize additional space usage. You should also ensure the stability of the sorting algorithm. Function Signature ```python def merge_sort_inplace(arr: List[int]) -> None: # Sort the array in-place ``` Input * `arr`: A list of integers `arr[0], arr[1], ..., arr[n-1]` where `0 <= n <= 10^5`. Output * The function should modify the input array `arr` to be sorted in non-decreasing order. Constraints * You are not allowed to use additional arrays or lists with lengths proportional to the input array during sorting. * The implementation must be stable such that the relative order of equal elements is maintained. Performance Requirements * Time Complexity: O(n log n) * Space Complexity: O(log n) (due to recursion stack) Additional Notes * You cannot use built-in sort functions. * Consider different edge cases such as empty arrays, already sorted arrays, and arrays with duplicate elements. Examples ```python arr = [38, 27, 43, 3, 9, 82, 10] merge_sort_inplace(arr) print(arr) # Output: [3, 9, 10, 27, 38, 43, 82] arr = [1, 2, 3, 4, 5] merge_sort_inplace(arr) print(arr) # Output: [1, 2, 3, 4, 5] arr = [5, 4, 3, 2, 1] merge_sort_inplace(arr) print(arr) # Output: [1, 2, 3, 4, 5] arr = [] merge_sort_inplace(arr) print(arr) # Output: [] ```","solution":"def merge_sort_inplace(arr): Performs in-place merge sort on the provided array. def merge(start, mid, end): # Create temporary arrays for merging left = arr[start:mid+1] right = arr[mid+1:end+1] # Initial indexes for left, right and merged array i = j = 0 k = start # Merging the subarrays back into arr while i < len(left) and j < len(right): if left[i] <= right[j]: arr[k] = left[i] i += 1 else: arr[k] = right[j] j += 1 k += 1 # Copy the remaining elements of left, if any while i < len(left): arr[k] = left[i] i += 1 k += 1 # Copy the remaining elements of right, if any while j < len(right): arr[k] = right[j] j += 1 k += 1 def split_and_merge(start, end): if start < end: mid = (start + end) // 2 split_and_merge(start, mid) split_and_merge(mid+1, end) merge(start, mid, end) split_and_merge(0, len(arr) - 1)"},{"question":"Given a nested dictionary representing a hierarchical structure, design and implement a function that converts this dictionary into a formatted string for better visualization. The formatting should align with the levels of nesting: # Function Signature ```python def format_tree(tree: dict) -> str: pass ``` # Input - A dictionary `tree` representing a hierarchical structure. Each key maps to a list of values, where values can be either strings or nested sub-dictionaries. # Constraints - Each value list can contain mixed types: strings, sub-dictionaries, or other lists. - The depth of nesting is not predefined but assumed to be manageable within typical stack limits. # Output - A string representing the formatted hierarchy, with indentation representing the levels of nesting. # Example For example, given the dictionary: ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', { \'Computer\': 5, \'TV\': 6, }, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', { \'Details\': 3, \'Models\': 3, }], \'e\': [\'Quin\', \'Book\', 5, { \'TV\': 2, }], \'f\': [\'Adam\', \'Computer\', 7] } ``` The output should be: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> Details -> 3 -> Models -> 3 e -> Quin -> Book -> 5 TV -> 2 f -> Adam -> Computer -> 7 ``` # Performance Requirement The function should be able to handle nested dictionaries with up to 10 levels of nesting and process them efficiently in linear time relative to the size of the dictionary. # Notes - Focus on managing the depth and structured indentation correctly. - Ensure output is human-readable and respects the hierarchy. Implement the function `format_tree` to solve the problem. Consider edge cases, performance concerns, and potential improvements.","solution":"def format_tree(tree: dict) -> str: def traverse(node, depth): if isinstance(node, dict): results = [] for key, value in node.items(): results.append(\' \' * depth + f\\"{key}\\") if isinstance(value, list): for item in value: results.extend(traverse(item, depth + 4)) else: results.extend(traverse(value, depth + 4)) return results else: return [\' \' * depth + \'-> \' + str(node)] results = [] for key, value in tree.items(): results.append(key) for item in value: results.extend(traverse(item, 4)) return \'n\'.join(results)"},{"question":"Scenario You are provided with a list of timestamps in a sorted order, representing moments when a particular event occurred. You are asked to insert new timestamps dynamically while maintaining the sorted order of the list efficiently. Task Implement a function `insert_timestamp` that takes a sorted list of timestamps and a new timestamp, and returns the list with the new timestamp inserted in the correct position. Your implementation should use the binary search technique for finding the correct insertion point to ensure efficient performance. Function Signature ```python def insert_timestamp(timestamps: List[str], new_timestamp: str) -> List[str]: Inserts a new timestamp into the sorted list of timestamps maintaining the order. Args: timestamps (List[str]): A sorted list of timestamp strings in \'YYYY-MM-DD HH:MM:SS\' format. new_timestamp (str): A new timestamp string to be inserted in the list. Returns: List[str]: A new list with the new timestamp inserted maintaining the sorted order. pass ``` Constraints * The timestamps are in string format following \'YYYY-MM-DD HH:MM:SS\'. * Timestamps are unique. * The list can be empty. * Do not use any library functions for sorting. Example ```python # Example 1 timestamps = [\\"2022-01-01 12:00:00\\", \\"2022-01-02 13:00:00\\", \\"2022-01-03 14:00:00\\"] new_timestamp = \\"2022-01-02 12:30:00\\" assert insert_timestamp(timestamps, new_timestamp) == [\\"2022-01-01 12:00:00\\", \\"2022-01-02 12:30:00\\", \\"2022-01-02 13:00:00\\", \\"2022-01-03 14:00:00\\"] # Example 2 timestamps = [] new_timestamp = \\"2022-01-01 12:00:00\\" assert insert_timestamp(timestamps, new_timestamp) == [\\"2022-01-01 12:00:00\\"] ``` Performance Requirements * The function should run in O(log n) time for finding the insertion point and O(n) for insertion in the list, making the overall complexity O(n).","solution":"from typing import List def insert_timestamp(timestamps: List[str], new_timestamp: str) -> List[str]: Inserts a new timestamp into the sorted list of timestamps maintaining the order. Args: timestamps (List[str]): A sorted list of timestamp strings in \'YYYY-MM-DD HH:MM:SS\' format. new_timestamp (str): A new timestamp string to be inserted in the list. Returns: List[str]: A new list with the new timestamp inserted maintaining the sorted order. def binary_search(timestamps, target): low, high = 0, len(timestamps) - 1 while low <= high: mid = (low + high) // 2 if timestamps[mid] < target: low = mid + 1 else: high = mid - 1 return low index = binary_search(timestamps, new_timestamp) return timestamps[:index] + [new_timestamp] + timestamps[index:]"},{"question":"# Problem: Custom Square Root Calculation You are required to implement a function to compute the square root of a given positive integer `N` with a specified precision `P` using an iterative method. The function should return a value that is within the maximum absolute error `P` of the actual square root of `N`. # Function Specification Function Signature: ```python def custom_square_root(n: int, precision: float) -> float: pass ``` Input: * `n` (int): A positive integer representing the number whose square root is to be computed. * `precision` (float): A float representing the maximum absolute error allowed in the square root calculation. Output: * Returns a float representing the computed square root of `n` within the specified precision. Constraints: * `1 <= n <= 10^9` * `0 < precision < 1` # Performance Requirements * Your solution should efficiently converge to the square root, handling large values of `N` within acceptable time limits. * Ensure the function operates within a strict precision as dictated by the input. # Context A scientific application requires computing square roots of various measurements with customizable precision. The standard library functions either do not provide the necessary precision control or are not usable within the given environment constraints. Implementing the calculation manually allows the application to meet its specific needs. # Examples 1. `custom_square_root(5, 0.001)` should return a value such as 2.236, which lies between 2.235 and 2.237. 2. `custom_square_root(16, 0.0001)` should return a value such as 4.0. Implementation: Implement the function ensuring it handles edge cases such as very large `n` or very high precision requirements properly.","solution":"def custom_square_root(n: int, precision: float) -> float: Returns the square root of n calculated to within the given precision using an iterative method. if n < 0 or precision <= 0: raise ValueError(\\"n must be a positive integer and precision must be a positive float\\") low, high = 0, n mid = (low + high) / 2.0 while abs(mid**2 - n) > precision: if mid**2 < n: low = mid else: high = mid mid = (low + high) / 2.0 return mid"},{"question":"# Question: Context: You have been hired as a software developer for a logistics company that needs to implement efficient routing algorithms for their delivery trucks. Problem: Implement the Dijkstra algorithm to find the shortest path from a source city to all other cities in a weighted graph representing the logistic network. The cities are represented as vertices and the roads with travel times as edge weights. Ensure your solution is optimized for graphs with a large number of vertices. Task: Write a function `shortest_path_from_source(city_count, edges, source)` that computes the shortest path from the source city to all other cities using Dijkstra\'s algorithm. Input: * `city_count` (int): Number of cities (vertices). * `edges` (List[Tuple[int, int, int]]): List of tuples representing edges in the format (source_city, target_city, travel_time), where `travel_time` is a positive integer. * `source` (int): The source city index. Output: * Returns a list of integers where the ith element is the shortest travel time from the source city to the ith city. If a city is unreachable, the travel time for that city should be `float(\\"inf\\")`. Constraints: * 1 <= city_count <= 1000 * 1 <= number of edges <= 10000 * 0 <= travel_time <= 1000 * 0 <= source, target city indices < city_count Performance Requirements: * Optimize the solution to handle large inputs efficiently, using appropriate data structures to reduce time complexity. # Example: ```python # Example input city_count = 6 edges = [ (0, 1, 4), (0, 2, 1), (2, 1, 2), (1, 3, 1), (2, 3, 5), (3, 4, 3), (4, 5, 1) ] source = 0 # Example output # [0, 3, 1, 4, 7, 8] print(shortest_path_from_source(city_count, edges, source)) ``` Implementation: ```python from heapq import heappop, heappush import math def shortest_path_from_source(city_count, edges, source): # Create adjacency list graph = [[] for _ in range(city_count)] for u, v, w in edges: graph[u].append((v, w)) # Initialize distances and min-heap (priority queue) dist = [float(\\"inf\\")] * city_count dist[source] = 0 heap = [(0, source)] while heap: current_dist, u = heappop(heap) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heappush(heap, (distance, v)) return dist # Test the function with the example input city_count = 6 edges = [ (0, 1, 4), (0, 2, 1), (2, 1, 2), (1, 3, 1), (2, 3, 5), (3, 4, 3), (4, 5, 1) ] source = 0 print(shortest_path_from_source(city_count, edges, source)) # Expected output: [0, 3, 1, 4, 7, 8] ```","solution":"from heapq import heappop, heappush def shortest_path_from_source(city_count, edges, source): Computes the shortest path from the source city to all other cities using Dijkstra\'s algorithm. :param city_count: Number of cities (vertices). :param edges: List of tuples representing edges in the format (source_city, target_city, travel_time). :param source: The source city index. :return: A list of integers where the ith element is the shortest travel time from the source city to the ith city. If a city is unreachable, the travel time for that city is \'float(\\"inf\\")\'. # Create adjacency list graph = [[] for _ in range(city_count)] for u, v, w in edges: graph[u].append((v, w)) # Initialize distances and min-heap (priority queue) dist = [float(\\"inf\\")] * city_count dist[source] = 0 heap = [(0, source)] while heap: current_dist, u = heappop(heap) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heappush(heap, (distance, v)) return dist"},{"question":"# Coding Assessment: Bucket Sort Enhancement Objective Enhance and implement the bucket sort algorithm to manage edge cases efficiently and improve overall performance. Task Write a function `optimized_bucket_sort` that sorts an array of integers using the bucket sort algorithm. Your function should include the following enhancements: 1. Dynamically adjust the number of buckets based on the range and distribution of input data. 2. Use a more efficient sorting algorithm for sorting elements within each bucket. # Function Signature ```python def optimized_bucket_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr` (List[int]): A list of integers. # Output * Return a list of integers sorted in ascending order. # Constraints * The length of `arr` will be between 0 and 10^6. * Individual elements in `arr` will range from -10^6 to 10^6. # Performance Requirements * Your algorithm should aim for an average-case time complexity of O(n log n). * Optimize for both time and space complexity. # Example ```python # Example input arr = [29, 25, 3, 49, 9, 37, 21, 43] # Example output sorted_arr = [3, 9, 21, 25, 29, 37, 43, 49] ``` # Additional Notes Consider edge cases such as arrays with a large range of values, empty arrays, or arrays with duplicate elements. Ensure your implementation is robust and handles such scenarios gracefully.","solution":"from typing import List def optimized_bucket_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr min_value = min(arr) max_value = max(arr) bucket_range = (max_value - min_value) / len(arr) + 1 buckets = [[] for _ in range(len(arr))] for num in arr: bucket_index = int((num - min_value) / bucket_range) buckets[bucket_index].append(num) sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"# Context You have learned various sorting algorithms and their efficiency. Now, your task is to understand the limitations of certain inefficient algorithms by implementing one of the least efficient algorithms known: **Bogo Sort**. # Task Write a Python function `optimized_bogo_sort(arr)` that uses the Bogo Sort algorithm to sort an array. Additionally, enhance the algorithm to log and return the number of iterations it took to sort the list. This will help illustrate just how inefficient this algorithm can be. # Requirements 1. **Function Signature**: ```python def optimized_bogo_sort(arr: list) -> tuple: Sorts an array using the Bogo Sort algorithm. Parameters: arr (list): The list of integers to be sorted. Returns: tuple: A tuple containing the sorted list and the number of iterations. ``` 2. **Input**: - A list of integers `arr` with length `n` where `0 <= n <= 10`. For larger values of `n`, the function may not return in a reasonable amount of time. 3. **Output**: - A tuple containing: - The sorted list. - The number of iterations performed to achieve the sorted list. 4. **Constraints**: - Use the Bogo Sort algorithm as described. - Log and return the number of iterations it took to sort the list. - Ensure the function handles an empty list or a list with a single element correctly. 5. **Performance Requirements**: - There are no performance requirements other than ensuring the function runs correctly for the given constraint (list length up to 10). # Examples ```python assert optimized_bogo_sort([3, 1, 4, 1, 5, 9, 2, 6]) == ([1, 1, 2, 3, 4, 5, 6, 9], [some iteration count]) assert optimized_bogo_sort([]) == ([], 0) assert optimized_bogo_sort([42]) == ([42], 0) ```","solution":"import random def is_sorted(arr): Helper function to check if a list is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def optimized_bogo_sort(arr: list) -> tuple: Sorts an array using the Bogo Sort algorithm. Parameters: arr (list): The list of integers to be sorted. Returns: tuple: A tuple containing the sorted list and the number of iterations. iterations = 0 while not is_sorted(arr): random.shuffle(arr) iterations += 1 return arr, iterations"},{"question":"**Scenario**: You are working on a financial software package that tracks stock market prices in real-time. One of the features you need to implement is to calculate the moving average of closing prices over a fixed period. This involves a sliding window approach where the average changes dynamically as new prices are added and old ones are removed. **Your Task**: Implement a `MovingAverage` class that calculates the moving average of a stream of integers within a given window size. This class should handle a stream of closing prices efficiently, providing the average of the most recent prices according to the window size. **Function Signature**: ```python class MovingAverage: def __init__(self, size: int): Initialize the data structure with the given window size. :param size: int - the size of the window. def next(self, val: int) -> float: Calculate the moving average with the new value. :param val: int - the new value to be added to the current window. :return: float - the updated moving average. ``` **Example**: ```python # Example usage: m = MovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.666666666666667 (which is (1+10+3)/3) print(m.next(5)) # Output: 6.0 (which is (10+3+5)/3) ``` **Constraints**: * The window size (`size`) will be a positive integer. * The stream of integers provided to the `next` method will be valid integers. * You should optimize the class to handle a high-throughput stream of integers efficiently, with quick updates to the moving average. *Performance Requirements*: * Ensure that each `next` operation runs in constant time O(1). **Hint**: Consider using a deque from the collections module for efficient appending and removal of elements.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize the data structure with the given window size. :param size: int - the size of the window. self.size = size self.queue = deque() self.window_sum = 0 def next(self, val: int) -> float: Calculate the moving average with the new value. :param val: int - the new value to be added to the current window. :return: float - the updated moving average. if len(self.queue) == self.size: self.window_sum -= self.queue.popleft() self.queue.append(val) self.window_sum += val return self.window_sum / len(self.queue)"},{"question":"# Question **Anagram Checker** Scenario You are writing a text processing library for a language with a standard lower-case alphabet. One common task is verifying if two words are anagrams, meaning they contain the exact same letters in the exact same quantities, but potentially in a different order. Task Implement the `anagram` function that checks if two given strings are anagrams of each other. Function Signature ```python def anagram(s1: str, s2: str) -> bool: pass ``` Input * `s1` (string) - The first string consisting of lower-case English letters. * `s2` (string) - The second string consisting of lower-case English letters. Output * Boolean - Return `True` if the strings are anagrams, `False` otherwise. Constraints * The length of each input string will be at most 1000. * The input strings will only contain lower-case English letters. Example ```python print(anagram(\\"apple\\", \\"pleap\\")) # True print(anagram(\\"apple\\", \\"cherry\\")) # False print(anagram(\\"listen\\", \\"silent\\")) # True print(anagram(\\"triangle\\", \\"integral\\")) # True ``` Notes * Be mindful of edge cases, such as strings of different lengths or completely empty strings. * Ensure the solution runs efficiently for the given constraints. * Do not assume the strings contain spaces, upper-case, or special characters.","solution":"def anagram(s1: str, s2: str) -> bool: Checks if two given strings are anagrams of each other. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if the strings are anagrams, False otherwise. if len(s1) != len(s2): return False return sorted(s1) == sorted(s2)"},{"question":"You are given an array of `n` real numbers. Your task is to implement a function `bucket_sort(arr: List[float]) -> List[float]`, that takes this array and returns a sorted array using the Bucket Sort algorithm. Here\'s what you need to consider: 1. **Input**: The function receives a list of `n` real numbers, `arr`, where `0 <= arr[i] <= 1` for all `i`. 2. **Output**: The function should return a list of `n` real numbers sorted in non-decreasing order. # Constraints: * You must use the Bucket Sort algorithm. * You should use Insertion Sort to sort individual buckets. * The function should handle an empty array by returning an empty array. * The solution should be efficient in both time and space. # Example: ```python # Test case 1 arr = [0.897, 0.565, 0.656, 0.123, 0.665, 0.343] print(bucket_sort(arr)) # Expected Output: [0.123, 0.343, 0.565, 0.656, 0.665, 0.897] # Test case 2 arr = [0.5, 0.25, 0.75, 0.1, 0.9] print(bucket_sort(arr)) # Expected Output: [0.1, 0.25, 0.5, 0.75, 0.9] # Test case 3 arr = [] print(bucket_sort(arr)) # Expected Output: [] ``` # Implementation Details: * The `next_sort` function should sort arrays using Insertion Sort. * Handle edge cases like empty arrays and arrays with one element. Your implementation will be evaluated based on correctness, efficiency, and readability. Please ensure your code is well commented.","solution":"from typing import List def insertion_sort(arr: List[float]) -> List[float]: Helper function to perform Insertion Sort on a list of floats. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def bucket_sort(arr: List[float]) -> List[float]: Perform Bucket Sort on a list of floats in the range [0, 1). if len(arr) == 0: return arr n = len(arr) # Create n empty buckets buckets = [[] for _ in range(n)] # Put elements into different buckets for num in arr: index = int(num * n) # Index in bucket buckets[index].append(num) # Sort individual buckets using insertion sort for i in range(n): buckets[i] = insertion_sort(buckets[i]) # Concatenate all sorted buckets sorted_array = [] for bucket in buckets: sorted_array.extend(bucket) return sorted_array"},{"question":"Scenario Imagine you\'re given a large dataset of uniformly distributed numbers stored in a sorted array. You are required to search for specific keys within this array efficiently. Task Write a function named `optimized_interpolation_search` that efficiently performs the search operation using the interpolation search algorithm. Additionally, enhance the function to handle edge cases and avoid potential errors like division by zero. Function Signature ```python def optimized_interpolation_search(array: List[int], search_key: int) -> int: Searches for a given search_key in a sorted array using an optimized interpolation search algorithm. :param array: List[int] - The sorted array to search within. :param search_key: int - The key to search for. :returns: int - The index of the search_key if found, otherwise -1. Constraints: - The array is guaranteed to be sorted in increasing order. - Elements in the array and the search_key will be integers. - The length of array (n) will be within the range 0 ≤ n ≤ 10^5. Examples: >>> optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], 14) 3 >>> optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> optimized_interpolation_search([], 5) -1 >>> optimized_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> optimized_interpolation_search([10, 10, 10, 10, 10], 10) 0 # [Your implementation here] ``` To validate your understanding, your implementation should handle all edge cases (like division by zero, non-existing keys, empty arrays, uniform arrays, etc.) and should perform efficiently for large input sizes.","solution":"from typing import List def optimized_interpolation_search(array: List[int], search_key: int) -> int: Searches for a given search_key in a sorted array using an optimized interpolation search algorithm. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Probing the position with keeping bounds if array[high] == array[low]: if array[low] == search_key: return low return -1 pos = low + int((float(high - low) / (array[high] - array[low]) * (search_key - array[low]))) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Successor in a Binary Search Tree **Context**: Given a binary search tree (BST), finding the inorder successor of a node is a common requirement. The inorder successor of a node in a BST is the next node in the inorder traversal of the BST. Write a function `find_inorder_successor` that finds the inorder successor of a given node in a BST. **Function Signature**: ```python def find_inorder_successor(root: TreeNode, node: TreeNode) -> Optional[TreeNode]: pass ``` # Input * `root`: A TreeNode representing the root of the binary search tree. The tree is guaranteed to follow the properties of a BST. * `node`: A TreeNode representing the node whose inorder successor is to be found. It is guaranteed to be a node in the BST. # Output * Returns the TreeNode that is the inorder successor of the given node. If there is no inorder successor, return `None`. # Constraints * Each node in the BST has a unique value. * The input tree has `n` nodes where `1 ≤ n ≤ 10^5`. # Example Scenarios 1. **Example 1**: - Input: ```plaintext root: [20, 10, 30, 5, 15, 25, 35] node: [10] ``` - Output: ```plaintext 15 ``` 2. **Example 2**: - Input: ```plaintext root: [20, 10, 30, 5, 15, 25, 35] node: [30] ``` - Output: ```plaintext 35 ``` 3. **Example 3**: - Input: ```plaintext root: [20, 10, 30, 5, 15] node: [15] ``` - Output: ```plaintext 20 ``` **Implementation Notes**: - Students should consider edge cases such as nodes with no right child, nodes being the maximum, and when the BST has only one node. - Ensure to maintain (O(h)) time complexity for the solution.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_inorder_successor(root: TreeNode, node: TreeNode) -> TreeNode: Function to find the inorder successor of a given node in a Binary Search Tree. successor = None if node.right: # The successor is the leftmost node in the right subtree successor = node.right while successor.left: successor = successor.left return successor # If no right subtree, the successor is one of the ancestors while root: if node.val < root.val: successor = root root = root.left elif node.val > root.val: root = root.right else: break return successor"},{"question":"# Truncated Mean Calculation **Context:** In evaluations, such as athlete scores or performance assessments, extreme values (both high and low) can skew the average result. To get a more reliable mean, we often discard a certain percentage of the highest and lowest values. This method is known as a truncated or trimmed mean. **Objective:** Write a function `trimmean` that calculates the truncated mean of a list of numerical values. The function will discard a specified percentage of the highest and lowest values and compute the mean of the remaining values. **Function Signature:** ```python def trimmean(arr: list, per: float) -> float: ``` **Input:** * `arr`: A list of integers or floats; the values to compute the truncated mean from. * `per`: A float in the interval [0, 100], representing the total percentage of values to be discarded (half from the lowest end and half from the highest end). **Output:** * Return the truncated mean as a float. **Constraints:** 1. The length of `arr` will be between 3 and 10^5. 2. The percentage `per` will be between 0 and 100 inclusive. **Examples:** ```python assert trimmean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20) == 5.5 assert trimmean([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 40) == 55.0 ``` **Note:** 1. For a 20% trim, remove the lowest 10% and the highest 10%. 2. When computing indices to trim, make sure to handle cases where the slicing results in non-integer indices appropriately. **Edge Cases:** 1. The array has very few elements. 2. The percentage is 0, meaning no elements should be trimmed. 3. The percentage is very high (close to 100), meaning the majority of elements are removed. Design and implement the function with efficiency in mind.","solution":"def trimmean(arr, per): Calculate the truncated mean of a list of numerical values by discarding a specified percentage of the highest and lowest values. Parameters: arr (list): List of integers or floats to compute the truncated mean from. per (float): Percentage of total values to discard (half from the lowest end and half from the highest end). Returns: float: The truncated mean of the remaining values. arr_sorted = sorted(arr) # Sort the array n = len(arr) num_to_trim = int(n * per / 100 / 2) # Calculate number of elements to trim from each end # Trim the calculated number of elements from both ends trimmed_list = arr_sorted[num_to_trim : n - num_to_trim] # Calculate the mean of the remaining elements return sum(trimmed_list) / len(trimmed_list)"},{"question":"# Question: Validate HTML-like Tags Implement a function that validates a string containing HTML-like tags. Tags are denoted by `<tag>` for opening and `</tag>` for closing. The function should ensure that all tags are properly closed and nested. Example: - Input: `\\"<div><p>Hello</p></div>\\"` - Output: `True` - Input: `\\"<div><p>Hello</div>\\"` - Output: `False` - Input: `\\"<div><p>Hello</p></div><div></div>\\"` - Output: `True` Write the function `is_valid_html(s: str) -> bool:` that takes a single string `s` as input and returns `True` if the string is valid or `False` otherwise. Input Constraints: - The string `s` contains only printable ASCII characters. - Tag names are alphanumeric and do not start with a number. - The string length is between 0 and 10^4. Function Signature: ```python def is_valid_html(s: str) -> bool: pass ``` Requirements: 1. The function should have a time complexity of O(n). 2. Careful attention to proper nesting and closure of tags. 3. Handle edge cases like: - An empty string, which should be considered valid. - Invalid sequences such as `<div><p></div></p>`.","solution":"def is_valid_html(s: str) -> bool: from collections import deque import re tag_pattern = re.compile(r\'<(/?)([a-zA-Z][a-zA-Z0-9]*)>\') stack = deque() for match in tag_pattern.finditer(s): tag_type, tag_name = match.groups() if tag_type == \'/\': # Closing tag if not stack or stack[-1] != tag_name: return False stack.pop() else: # Opening tag stack.append(tag_name) return not stack"},{"question":"You are working on designing a database search functionality to quickly locate records based on a specific key. Given a sorted array of integer IDs and a search key, implement the `interpolation_search` method as a subroutine to find the index of the search key. If the search key is not present in the array, the function should return -1. # Function Signature ```python def interpolation_search(array: List[int], search_key: int) -> int: :param array: List of integers (sorted in ascending order). :param search_key: The integer key to search for in the array. :return: Index of the search_key if present; otherwise, -1. ``` # Inputs * `array`: A list of integers sorted in ascending order, with length `n` where (0 leq n leq 10^6). * `search_key`: An integer key to find within the array. # Outputs * Returns the index (0-based) of `search_key` if it is found in the array, otherwise returns -1. # Constraints * The array must be non-decreasing. * Time complexity ideally should be O(log log n) in average cases. # Examples 1. `interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1)` should return `2`. 2. `interpolation_search([5, 10, 12, 14, 17, 20, 21], 55)` should return `-1`. 3. `interpolation_search([5, 10, 12, 14, 17, 20, 21], -5)` should return `-1`. # Guidelines * Your solution should handle edge cases such as an empty array and non-existent elements correctly. * Consider performance optimization particularly in the presence of non-uniform data elements. # Tips * Ensure to validate against edge cases including possibly large data sets to check performance and correctness.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: Performs interpolation search on a sorted array of integers. :param array: List of integers (sorted in ascending order). :param search_key: The integer key to search for in the array. :return: Index of the search_key if present; otherwise, -1. n = len(array) if n == 0: return -1 low, high = 0, n - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"Context Given the provided implementations of `ArrayStack` and `LinkedListStack`, students are required to implement a modified version of the stack data structure that supports an additional operation, `min()`, which returns the minimum element in the stack in O(1) time. Task Implement a class `MinStack` that extends `ArrayStack` and supports the following operations: * `push(int value)`: Pushes the value onto the stack. * `pop() -> int`: Removes the value from the top of the stack and returns it. * `peek() -> int`: Returns the value at the top of the stack without removing it. * `is_empty() -> bool`: Returns True if the stack is empty, False otherwise. * `min() -> int`: Returns the minimum element in the stack in O(1) time. Expected Input and Output Formats * **Input**: No direct input; operations will be called on an instance of `MinStack`. * **Output**: Returns as specified by the operations. Constraints * All operations (push, pop, peek, is_empty, min) must perform in O(1) time complexity. * The stack can hold a maximum of 10^4 elements at any time. Example Scenario ```python stack = MinStack() stack.push(3) stack.push(5) print(stack.min()) # Output: 3 stack.push(2) stack.push(1) print(stack.min()) # Output: 1 stack.pop() print(stack.min()) # Output: 2 ``` Implementation Start class MinStack(ArrayStack): def __init__(self, size=10): super().__init__(size) self._min_stack = [] # Stack to keep track of minimums def push(self, value): super().push(value) if self.is_empty(): self._min_stack.append(value) else: self._min_stack.append(min(value, self._min_stack[-1])) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") self._min_stack.pop() return super().pop() def min(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self._min_stack[-1]","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, value): self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): if not self.stack: raise IndexError(\\"Stack is empty\\") value = self.stack.pop() if value == self.min_stack[-1]: self.min_stack.pop() return value def peek(self): if not self.stack: raise IndexError(\\"Stack is empty\\") return self.stack[-1] def is_empty(self): return len(self.stack) == 0 def min(self): if not self.min_stack: raise IndexError(\\"Stack is empty\\") return self.min_stack[-1]"},{"question":"# Context In the field of data analysis, it\'s often necessary to compute mean values that are resistant to extreme outliers. This ensures that the resulting average is not overly affected by unusually high or low values. # Problem Statement Write a Python function `trimmean(arr: List[int], per: float) -> float` that computes a trimmed mean of a dataset. The function should discard a specified percentage of the lowest and highest values before computing the mean of the remaining values. # Input * `arr`: A list of integers representing the dataset. * `per`: A floating-point number representing the percentage of values to be trimmed from each end of the sorted dataset. # Output * A floating-point number representing the trimmed mean of the dataset. # Constraints 1. The percentage value `per` will be between 0 and 100. 2. The length of the list `arr` will be between 1 and (10^5). 3. If the effective number of elements after trimming is zero, the function should return 0.0. # Performance Requirements * The solution should be efficient with time complexity no worse than O(n log n). # Example ```python def trimmean(arr, per): ratio = per/200 cal_sum = 0 arr.sort() neg_val = int(len(arr) * ratio) arr = arr[neg_val: len(arr)-neg_val] for i in arr: cal_sum += i return cal_sum / len(arr) # Example usage: print(trimmean([1, 2, 3, 4, 100], 20)) # Output should be 3.0 print(trimmean([1, 2, 2, 2, 3], 40)) # Output should be 2.0 print(trimmean([1, 1, 1, 1, 1], 40)) # Output should be 1.0 ``` **Note**: Ensure to handle edge cases such as very high trimming percentages, empty lists after trimming, and integer division where applicable.","solution":"from typing import List def trimmean(arr: List[int], per: float) -> float: Computes the trimmed mean of a dataset. Parameters: arr (List[int]): List of integers representing the dataset. per (float): Percentage of values to be trimmed from each end of the sorted dataset. Returns: float: The trimmed mean of the dataset. if not arr: return 0.0 n = len(arr) if n == 0 or per <= 0: return sum(arr) / n arr.sort() count_to_trim = int(n * (per / 100)) trimmed_arr = arr[count_to_trim : n - count_to_trim] if not trimmed_arr: return 0.0 return sum(trimmed_arr) / len(trimmed_arr)"},{"question":"# Tree Height Calculation As a software developer, you frequently deal with various data structures. One such data structure is the binary search tree (BST), which allows for efficient data operations. In this problem, your task is to implement a function to calculate the height of a BST. Function Signature ```python def height(root) -> int: Calculates the height of a given binary search tree based on the root node. :param root: Root node of the binary search tree. :return: Height of the tree (integer). ``` Input * `root`: A `Node` object representing the root of the binary search tree. If the tree is empty, `root` will be `None`. Output * An integer representing the height of the tree. Constraints * The height of an empty tree is 0. * A tree with only one node (just the root) has a height of 1. * Each node has attributes `left` and `right` that are either `None` or point to another `Node` object. # Required Class Definitions You will need to define the class `Node` and the class `BST` to build and manipulate the tree. If the classes are not defined, the provided unit test will not work. Here\'s a sample structure for the `Node` and `BST` classes: ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert_rec(self.root, key) def _insert_rec(self, current, key): if key < current.val: if current.left is None: current.left = Node(key) else: self._insert_rec(current.left, key) elif key > current.val: if current.right is None: current.right = Node(key) else: self._insert_rec(current.right, key) ``` # Example Consider the following tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` Calling `height(root)` where `root` is the node with value 9, should return `4`. # Task Implement the `height` function and use the provided unit test to verify your solution. Unit Test ```python import unittest class TestSuite(unittest.TestCase): def setUp(self): self.tree = BST() self.tree.insert(9) self.tree.insert(6) self.tree.insert(12) self.tree.insert(3) self.tree.insert(8) self.tree.insert(10) self.tree.insert(15) self.tree.insert(7) self.tree.insert(18) def test_height(self): self.assertEqual(4, height(self.tree.root)) if __name__ == \'__main__\': unittest.main() ``` Ensure your function passes this test before submitting.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert_rec(self.root, key) def _insert_rec(self, current, key): if key < current.val: if current.left is None: current.left = Node(key) else: self._insert_rec(current.left, key) elif key > current.val: if current.right is None: current.right = Node(key) else: self._insert_rec(current.right, key) def height(root) -> int: Calculates the height of a given binary search tree based on the root node. :param root: Root node of the binary search tree. :return: Height of the tree (integer). if root is None: return 0 return 1 + max(height(root.left), height(root.right))"},{"question":"**Problem Statement**: You are provided with Euler\'s Totient Function, which is used to determine the number of integers from 1 to n that are coprime with n. Your task is to implement an optimized version of this function to handle multiple test cases and provide results efficiently. **Function Signature**: ```python def batch_euler_totient(test_cases: List[int]) -> List[int]: :param test_cases: A list of positive integers for which the Euler\'s Totient function needs to be computed :type test_cases: List[int] :return: A list of results where each element is the Euler\'s Totient function value for the corresponding integer in `test_cases` :rtype: List[int] ``` **Input**: - An array of integers `test_cases` where each integer is at least 1 and at most 10^6. The length of `test_cases` will not exceed 10^4. - Example: [10, 1, 16, 17, 33] **Output**: - An array of integers where each integer is the output of Euler\'s Totient function for the corresponding input in `test_cases`. - Example: [4, 1, 8, 16, 20] **Constraints**: - You must ensure the function runs efficiently even for the upper limits of the input size. - Consider optimizing the preprocessing step or utilizing caching techniques to handle repeated calls efficiently. **Performance Requirements**: - Your solution should aim for fast execution, particularly focusing on the preprocessing approach for handling repeated computations. **Example**: ```python assert batch_euler_totient([10, 1, 16, 17, 33]) == [4, 1, 8, 16, 20] ``` **Additional Notes**: - Be aware of edge cases such as `n = 1` and large prime numbers. - Ensure your implementation handles the constraints effectively without performance degradation.","solution":"from typing import List def batch_euler_totient(test_cases: List[int]) -> List[int]: Function to compute Euler\'s Totient function for each number in the test cases. :param test_cases: A list of positive integers for which the Euler\'s Totient function needs to be computed :type test_cases: List[int] :return: A list of results where each element is the Euler\'s Totient function value for the corresponding integer in `test_cases` :rtype: List[int] # Find the maximum number in the test cases for efficient precomputation max_n = max(test_cases) # Create an array to store the totient values phi = list(range(max_n + 1)) # Use a sieve-like approach to calculate the totient function for all numbers up to max_n for i in range(2, max_n + 1): if phi[i] == i: # i is a prime number for j in range(i, max_n + 1, i): phi[j] *= (i - 1) phi[j] //= i # Prepare the result based on precomputed values return [phi[n] for n in test_cases]"},{"question":"You are tasked with writing a function that sorts an array of floating-point numbers using the Bucket Sort algorithm. The given array can contain both positive and negative numbers, and can have a length of up to `10^6` elements. Implement a function `bucket_sort(arr: List[float]) -> List[float]` in Python that accepts an unsorted list of float numbers and returns a sorted list using the Bucket Sort algorithm. # Requirements: 1. **Input Format**: - An unsorted list `arr` of floating-point numbers. 2. **Output Format**: - A sorted list of floating-point numbers. 3. **Constraints**: - You can assume that all elements in `arr` are within range [-1000.0, 1000.0]. - The length of the list, `len(arr) <= 10^6`. 4. **Performance**: - Aim for an average time complexity of O(n + k), and space complexity of O(n + k), where `n` is the number of elements and `k` is the number of buckets. # Example: ```python Input: arr = [0.42, -0.95, 0.32, 0.65, -0.28, 0.75, 0.15, 0.99] Output: [-0.95, -0.28, 0.15, 0.32, 0.42, 0.65, 0.75, 0.99] ``` # Instructions: 1. **Bucket Creation**: Distribute the elements into a set of buckets based on their value range. 2. **Handling Negative Values**: Ensure the bucket assignment handles negative values appropriately. 3. **Sorting Within Buckets**: You can either implement a simple sorting algorithm (like insertion sort) within each bucket, or any other efficient sorting algorithm if needed. 4. **Merging**: Concatenate the sorted buckets to get the final sorted array.","solution":"from typing import List def bucket_sort(arr: List[float]) -> List[float]: if len(arr) == 0: return arr # Determine the number of buckets bucket_count = 10 # Find the minimum and maximum in the array min_value, max_value = min(arr), max(arr) # Initialize the buckets buckets = [[] for _ in range(bucket_count)] # Each bucket will have a range of values bucket_range = (max_value - min_value) / bucket_count # Place each element in a bucket for num in arr: # Determine the appropriate bucket if num == max_value: bucket_idx = bucket_count - 1 else: bucket_idx = int((num - min_value) / bucket_range) buckets[bucket_idx].append(num) # Sort individual buckets and concatenate results sorted_array = [] for bucket in buckets: sorted_bucket = sorted(bucket) sorted_array.extend(sorted_bucket) return sorted_array"},{"question":"# Matrix Inversion Challenge Problem Description You are given an n x n matrix and are tasked with computing its inverse, if it exists. Matrix inversion is a fundamental operation in linear algebra with applications ranging from solving linear systems to computer graphics. Input Format 1. A single integer `n` representing the size of the matrix. 2. A 2D list `matrix` of size n x n containing integers. Output Format * If the matrix is valid and invertible, output the inverse of the matrix as a 2D list of floating-point numbers. * If the matrix is invalid or non-invertible, output an appropriate error value as specified: * `-1` for non-square matrix * `-2` for matrix size smaller than 2x2 * `-3` for singular matrix (determinant = 0) Example **Input:** ```json { \\"n\\": 3, \\"matrix\\": [ [2, -1, 0], [-1, 2, -1], [0, -1, 2] ] } ``` **Output:** ```json { \\"inverse\\": [ [0.75, 0.5, 0.25], [0.5, 1.0, 0.5], [0.25, 0.5, 0.75] ] } ``` **Constraints**: * Matrix `matrix` will contain only integers. * Ensure that matrix has non-zero dimensions. Notes * The inverse of a matrix A is another matrix B such that AB = BA = I, where I is the identity matrix. * You can use fractions or floating-point arithmetic to calculate the inverse. Task 1. Write the function `invert_matrix(matrix: List[List[int]]) -> Union[List[List[float]], int]` to compute the inverse of the matrix. 2. Implement all necessary helper functions (e.g., get_determinant, get_minor) to support the inversion process. Performance Requirements * The function should efficiently compute the inverse for matrices up to size 10x10 within acceptable time limits. Solution Skeleton Provide skeleton code as per the required function: ```python def invert_matrix(matrix): # Your implementation to compute matrix inverse pass def get_determinant(m): # Helper function to compute determinant pass def get_minor(m, row, col): # Helper function to compute minor matrix pass def transpose_and_multiply(m, multiplier): # Helper function to perform adjugate and multiply pass def array_is_matrix(m): # Helper function to check if input is a valid matrix pass def get_matrix_of_minors(m): # Helper function to compute matrix of minors pass ```","solution":"from typing import List, Union def get_determinant(matrix: List[List[float]]) -> float: Computes the determinant of a matrix recursively. n = len(matrix) if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(n): determinant += ((-1) ** c) * matrix[0][c] * get_determinant(get_minor(matrix, 0, c)) return determinant def get_minor(matrix: List[List[float]], i: int, j: int) -> List[List[float]]: Returns the minor matrix after removing the i-th row and j-th column. return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def transpose(matrix: List[List[float]]) -> List[List[float]]: Transposes the input matrix. return list(map(list, zip(*matrix))) def invert_matrix(matrix: List[List[int]]) -> Union[List[List[float]], int]: Computes the inverse of a matrix if it exists. n = len(matrix) if not all(len(row) == n for row in matrix): return -1 if n < 2: return -2 # Convert to float for precision matrix = [[float(ele) for ele in row] for row in matrix] determinant = get_determinant(matrix) if determinant == 0: return -3 minors = [[get_determinant(get_minor(matrix, i, j)) for j in range(n)] for i in range(n)] cofactors = [[(-1) ** (i + j) * minors[i][j] for j in range(n)] for i in range(n)] adjugate = transpose(cofactors) inverse = [[adjugate[i][j] / determinant for j in range(n)] for i in range(n)] return inverse"},{"question":"# Coding Task Scenario You have been tasked with processing a list of numbers for a data analysis preparation pipeline. The requirement is to limit the frequency of each number within the list to a specified maximum without changing the order of elements. Objective Write a Python function `filter_list_by_frequency` that accepts a list of integers and a maximum allowed frequency for each element. The function should return a new list where each element appears no more than the specified number of times. Function Signature ```python def filter_list_by_frequency(lst: list, max_freq: int) -> list: ``` Input * `lst`: A list of integers (0 <= length of lst <= 10^5) * `max_freq`: An integer representing the maximum allowable frequency of any element (1 <= max_freq <= 100) Output * Returns a filtered list containing elements from the input list without changing their order, ensuring no element appears more than `max_freq` times. Constraints * You should implement an efficient solution with an average time complexity close to O(n). * Use of extra space should be optimized; however, O(n) additional space for data structures like hash tables is acceptable. Example ```python assert filter_list_by_frequency([1, 2, 3, 1, 2, 1, 2, 3], 2) == [1, 2, 3, 1, 2, 3] assert filter_list_by_frequency([20, 37, 20, 21, 37, 21, 21], 1) == [20, 37, 21] assert filter_list_by_frequency([], 5) == [] assert filter_list_by_frequency([1, 1, 1, 1], 2) == [1, 1] ``` Notes * Consider edge cases, such as empty lists and lists with only one repeated element. * Ensure your solution adheres to the specified complexities.","solution":"def filter_list_by_frequency(lst, max_freq): count_map = {} result = [] for num in lst: if num not in count_map: count_map[num] = 0 if count_map[num] < max_freq: result.append(num) count_map[num] += 1 return result"},{"question":"Longest Common Subsequence with Unique Constraint # Context Given two strings `a` and `b`, where string `b` contains all distinct characters (no character repeats), your task is to find the length of the longest common subsequence (LCS) between the two strings. # Details - **Input**: - Two strings `a` and `b` where `b` is guaranteed to have all unique characters. - **Output**: - An integer representing the length of the LCS. # Constraints - `1 <= len(a), len(b) <= 10^5` - Each character in `a` and `b` is a valid ASCII character. # Requirements - Aim to achieve O(n log n) complexity. # Function Signature ```python def longest_common_subsequence_length(a: str, b: str) -> int: pass ``` # Example ```python # Example 1 a = \\"abcde\\" b = \\"ace\\" # Longest common subsequence is \\"ace\\" with length 3 assert longest_common_subsequence_length(a, b) == 3 # Example 2 a = \\"abc\\" b = \\"def\\" # No common subsequence, so result is 0 assert longest_common_subsequence_length(a, b) == 0 ``` # Guidelines 1. Make use of the provided unique properties of string `b` to optimize your solution. 2. Consider edge cases such as empty strings or strings with no common characters. 3. Minimize unnecessary computations to maintain the required computational complexity.","solution":"def longest_common_subsequence_length(a: str, b: str) -> int: Returns the length of the longest common subsequence between the strings a and b. # Map each character in b to its index pos_in_b = {char: idx for idx, char in enumerate(b)} # Filter a to include only characters that exist in b, preserving their order filtered_a = [pos_in_b[char] for char in a if char in pos_in_b] # Function to find the length of the LIS using binary search def length_of_LIS(sequence): from bisect import bisect_left lis = [] for x in sequence: pos = bisect_left(lis, x) if pos == len(lis): lis.append(x) else: lis[pos] = x return len(lis) return length_of_LIS(filtered_a)"},{"question":"# Stooge Sort Algorithm You are given an unsorted array of integers and your task is to sort this array using the Stooge Sort algorithm. Stooge Sort is a recursive sorting algorithm with a time complexity of O(n^2.709). Despite its inefficiency, it offers an interesting example of a divide-and-conquer approach. # Function Signature Your function should have the following signature: ```python def stoogesort(arr: List[int], l: int, h: int) -> None: pass ``` # Input - `arr`: List[int] - A list of integers to be sorted. - `l`: int - The starting index of the sub-array to be sorted. - `h`: int - The ending index of the sub-array to be sorted. # Output - The function should sort the `arr` in-place and should not return any value. # Constraints - 1 <= len(arr) <= 1000 - -10^6 <= arr[i] <= 10^6 for all valid i # Requirements 1. Please avoid using Python\'s built-in sorting methods. 2. Try to handle the recursion stack efficiently to avoid stack overflow for large arrays within the given bound. 3. Document any assumptions or specific cases you consider. # Example ```python if __name__ == \\"__main__\\": array = [1, 3, 64, 5, 7, 8] n = len(array) stoogesort(array, 0, n-1) print(array) # Output should be [1, 3, 5, 7, 8, 64] ``` # Note This question assesses your familiarity with recursive algorithms and your ability to implement a sorting mechanism from scratch.","solution":"def stoogesort(arr, l, h): Performs Stooge Sort on the given list of integers. Parameters: arr: List[int] - A list of integers to be sorted. l: int - The starting index of the sub-array to be sorted. h: int - The ending index of the sub-array to be sorted. Returns: None if l >= h: return # if the element at the end is smaller than the element at the begin, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the sub-array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort first 2/3 stoogesort(arr, l, h - t) # Recursively sort last 2/3 stoogesort(arr, l + t, h) # Recursively sort first 2/3 again stoogesort(arr, l, h - t)"},{"question":"Array Rotation Challenge You are given an array of integers and a positive integer, k. Your task is to rotate the array to the right by k steps in-place. You need to implement the functionality using two different approaches: the reversal algorithm and the direct shifting approach (version v2 and v1 as analyzed). # Function Signatures ```python def rotate_reversal(array: List[int], k: int) -> None: pass def rotate_shift(array: List[int], k: int) -> None: pass ``` # Input * `array`: A list of integers, `array` (1 <= len(array) <= 10^5). * `k`: A positive integer (1 <= k <= 10^9). # Output * The function does not return anything but modifies the array in-place. # Constraints * You must implement the rotation in-place. * Focus on optimizing the performance such that the solution is as time-efficient as possible. * Assume that the elements of the array are distinct integers. # Example ```python # Example 1 nums = [1,2,3,4,5,6,7] k = 3 rotate_reversal(nums, k) print(nums) # Output: [5,6,7,1,2,3,4] # Example 2 nums = [1,2,3,4,5,6,7] k = 3 rotate_shift(nums, k) print(nums) # Output: [5,6,7,1,2,3,4] ``` # Explanation * In **Example 1** and **Example 2**, the array `[1, 2, 3, 4, 5, 6, 7]` is rotated right three times to become `[5, 6, 7, 1, 2, 3, 4]`. * The implementation for `rotate_reversal` should use the array reversal method. * The implementation for `rotate_shift` should use the direct shifting method. **Note**: While this problem can be solved using slicing and concatenation, the challenge is to implement the reversal and direct shifting approach instead.","solution":"from typing import List def rotate_reversal(array: List[int], k: int) -> None: Rotate array to the right by k steps using the reversal algorithm. n = len(array) k %= n # In case k is greater than n if k == 0: return # Helper function to reverse elements in array between start and end indices def reverse(nums, start, end): while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 # Reverse the entire array reverse(array, 0, n - 1) # Reverse the first k elements reverse(array, 0, k - 1) # Reverse the remaining n - k elements reverse(array, k, n - 1) def rotate_shift(array: List[int], k: int) -> None: Rotate array to the right by k steps using the direct shifting approach. n = len(array) k %= n # In case k is greater than n if k == 0: return count = 0 # Number of elements moved start = 0 # Initialize start pointer while count < n: current = start prev = array[start] while True: next_idx = (current + k) % n array[next_idx], prev = prev, array[next_idx] current = next_idx count += 1 if start == current: break start += 1"},{"question":"# Problem: Increment Large Number Represented as Array Given a non-negative number represented as a list of digits, write a function that adds one to the number. The digits are stored in such a way that the most significant digit is at the head of the list. # Function Signature ```python def increment_number(digits: List[int]) -> List[int]: ``` # Input - `digits`: A list of integers where each integer `i` is in the range [0, 9], representing the digits of a large number. # Output - A list of integers representing the number incremented by one. # Constraints - The input list will not be empty. - The input list may contain leading zeroes only if the number is zero itself. # Examples 1. Example 1: - Input: `[1, 2, 3]` - Output: `[1, 2, 4]` - Explanation: 123 + 1 = 124. 2. Example 2: - Input: `[9, 9, 9]` - Output: `[1, 0, 0, 0]` - Explanation: 999 + 1 = 1000. 3. Example 3: - Input: `[0]` - Output: `[1]` - Explanation: 0 + 1 = 1. # Notes - You must not convert the input list to an integer directly to perform the addition. - The solution should handle edge cases efficiently and consider space optimization where possible.","solution":"from typing import List def increment_number(digits: List[int]) -> List[int]: n = len(digits) carry = 1 for i in range(n - 1, -1, -1): new_val = digits[i] + carry if new_val == 10: digits[i] = 0 carry = 1 else: digits[i] = new_val carry = 0 break if carry == 1: digits.insert(0, 1) return digits"},{"question":"# Question: Implement an Efficient Insertion Sort You are to implement the `insertion_sort` function that sorts a list of integers in non-decreasing order using the binary search method provided. Function Signature ```python def insertion_sort(arr: List[int]) -> List[int]: ``` Description * Implement the `insertion_sort` function: - Uses the binary search method `search_insert` to properly place each element. - The binary search should help reduce the average number of comparisons during insertion. - You may not use Python\'s built-in sort functions (e.g., `sort()` or `sorted()`). Input * `arr` (List[int]): A list of integers that needs to be sorted. Output * Returns a list of integers sorted in non-decreasing order. Example ```python assert insertion_sort([4, 2, 7, 1, 3]) == [1, 2, 3, 4, 7] assert insertion_sort([10, 9, 8, 7, 6]) == [6, 7, 8, 9, 10] assert insertion_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] ``` Notes * You are expected to use the `search_insert` method provided above to find the position for each element. * Ensure you maintain the stability of sorting, meaning the relative order of elements should not change if they are equal. * Consider edge cases like an empty list or a list with one element. Constraints * 0 ≤ len(arr) ≤ 10^3 * -10^6 ≤ arr[i] ≤ 10^6 for any arr[i] in arr","solution":"from typing import List def search_insert(arr: List[int], val: int) -> int: Uses binary search to find the index at which val should be inserted. Assumes arr is sorted. low, high = 0, len(arr) while low < high: mid = (low + high) // 2 if arr[mid] < val: low = mid + 1 else: high = mid return low def insertion_sort(arr: List[int]) -> List[int]: Sorts a list of integers in non-decreasing order using the insertion sort algorithm and binary search to find the correct insertion point. sorted_arr = [] for val in arr: pos = search_insert(sorted_arr, val) sorted_arr.insert(pos, val) return sorted_arr"},{"question":"# Context In computer systems, numbers are often represented in different bases (binary, octal, hexadecimal) for various purposes like storage efficiency, data encoding, and digital circuit design. To assess your understanding of base conversion algorithms, you need to implement two functions to convert integers to a specified base and back from such bases to integers. This task will evaluate your grasp of numeral systems and conversion logic. # Problem Statement Implement two functions: 1. `int_to_base(num, base)`: Converts a given integer `num` to its string representation in the specified `base`. 2. `base_to_int(str_to_convert, base)`: Converts a string `str_to_convert` representing a number in the specified `base` back to its integer form. Function Signatures ```python def int_to_base(num: int, base: int) -> str: pass def base_to_int(str_to_convert: str, base: int) -> int: pass ``` # Input - `int_to_base(num, base)`: - `num`: An integer in the range [-2^31, 2^31-1]. - `base`: An integer between 2 and 36 inclusive. - `base_to_int(str_to_convert, base)`: - `str_to_convert`: A string representation of a number with characters in [0-9, A-Z]. - `base`: An integer between 2 and 36 inclusive. # Output - `int_to_base(num, base)`: A string representing the integer in the given base. - `base_to_int(str_to_convert, base)`: The integer form of the given string in the specified base. # Constraints - The input integer `num` might be negative. - The input base is always valid (between 2 and 36). - For `base_to_int`, the string `str_to_convert` will always consist of valid characters for the given base. # Example ```python assert int_to_base(42, 2) == \'101010\' assert int_to_base(255, 16) == \'FF\' assert base_to_int(\'101010\', 2) == 42 assert base_to_int(\'FF\', 16) == 255 assert int_to_base(-10, 16) == \'-A\' assert base_to_int(\'-A\', 16) == -10 ``` # Notes - Handle edge cases, such as zero and negative numbers. - Ensure correct mapping of characters for bases greater than 10.","solution":"def int_to_base(num: int, base: int) -> str: if num == 0: return \'0\' hex_chars = \'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\' result = \'\' negative = num < 0 num = abs(num) while num > 0: result = hex_chars[num % base] + result num //= base if negative: result = \'-\' + result return result def base_to_int(str_to_convert: str, base: int) -> int: hex_chars = \'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\' str_to_convert = str_to_convert.upper() negative = str_to_convert[0] == \'-\' if negative: str_to_convert = str_to_convert[1:] result = 0 power = 0 for char in reversed(str_to_convert): result += hex_chars.index(char) * (base ** power) power += 1 return -result if negative else result"},{"question":"Enhanced Linear Search You have recently been hired by a tech company, and your first task is to improve the performance of their search functionality over a collection of records. The existing system uses a simple linear search which has become inefficient for their large datasets. **Objective**: Write a function `optimized_linear_search` that not only performs a linear search but also optimizes subsequent searches by storing the positions of previously searched queries for quicker access in the future. Function Signature ```python def optimized_linear_search(array: List[int], query: int, previous_searches: Dict[int, int]) -> int: ``` Input * `array` (List[int]): A list of integers where the search is to be performed. * `query` (int): The integer element you need to search for in the array. * `previous_searches` (Dict[int, int]): A dictionary storing previously searched queries and their corresponding indices. Output * `int`: The index of the query in the array if found; otherwise, return -1. Constraints * The array can be of any size (up to 10^6 elements). * The integer elements in the array can be within the range (-10^9, 10^9). Performance Requirements * The function should ideally take advantage of the `previous_searches` dictionary to minimize the time complexity for repeated query searches. Approach 1. **Check Previous Searches**: First, check if the `query` is already stored in the `previous_searches` dictionary. 2. **Perform Linear Search**: If not found in previous searches, perform a linear search on the array. 3. **Store Result**: Store the resulting index of the query in the `previous_searches` dictionary for future reference. Example Scenario: You are implementing a system that frequently searches within a list of user IDs to retrieve user data. To optimize repeat searches, keeping a record of search indices allows you to quickly access them without performing the search again. Example Usage: ```python array = [10, 20, 30, 40, 50, 60, 70, 80] previous_searches = {} index1 = optimized_linear_search(array, 50, previous_searches) # Returns index 4 print(index1) index2 = optimized_linear_search(array, 20, previous_searches) # Returns index 1 print(index2) index3 = optimized_linear_search(array, 50, previous_searches) # Returns index 4 (cached result) print(index3) ```","solution":"def optimized_linear_search(array, query, previous_searches): Performs an optimized linear search by storing the positions of previously searched queries. Parameters: array (List[int]): The list of integers to search within. query (int): The integer to search for in the array. previous_searches (Dict[int, int]): Dictionary storing previously searched queries and their indices. Returns: int: The index of the query in the array if found, otherwise -1. # Check if the query is already stored in previous_searches if query in previous_searches: return previous_searches[query] # Perform a linear search for the query in the array for index, element in enumerate(array): if element == query: # Store the search result in previous_searches previous_searches[query] = index return index # If the query was not found previous_searches[query] = -1 return -1"},{"question":"# Pancake Sort Enhancement Problem Statement You are given an array of integers, and your task is to implement an enhanced version of the Pancake Sort algorithm that improves its performance by reducing the number of flips required. Your implementation should incorporate any optimizations you see fit while maintaining the core principles of Pancake Sort. Requirements: 1. Implement the `enhanced_pancake_sort` function to sort a given array of integers. 2. Your function should aim to reduce the number of operations (flips). 3. Ensure that your solution handles edge cases effectively, such as arrays with one element, already sorted arrays, or arrays with duplicate elements. Input: - An array `arr` of integers where ( 1 leq |arr| leq 10^3 ). Output: - The sorted array. Constraints: - Optimize for fewer flipping operations. - Preserve the stability of sorting (relative order of equal elements should remain the same). Example: ```python assert enhanced_pancake_sort([3, 2, 4, 1]) == [1, 2, 3, 4] assert enhanced_pancake_sort([5, 3, 1, 4, 2]) == [1, 2, 3, 4, 5] assert enhanced_pancake_sort([0, 0, 1, 0]) == [0, 0, 0, 1] assert enhanced_pancake_sort([1]) == [1] assert enhanced_pancake_sort([1, 2, 3]) == [1, 2, 3] ``` Write your implementation of `enhanced_pancake_sort` below: ```python def enhanced_pancake_sort(arr): # Your optimized pancake sort implementation here pass ```","solution":"def enhanced_pancake_sort(arr): An enhanced version of the pancake sort algorithm that reduces the number of flip operations required. def flip(sub_arr, k): sub_arr[:k] = sub_arr[:k][::-1] # Edge case: if the array has one element or is empty if len(arr) <= 1: return arr n = len(arr) for current_size in range(n, 1, -1): # Find the index of the maximum element in the arr[:current_size] max_index = max(range(current_size), key=arr.__getitem__) # If the maximum element is not at its correct place, we need to move it if max_index != current_size - 1: # Move the maximum element to the beginning if it\'s not already there if max_index != 0: flip(arr, max_index + 1) # Move the maximum element to its final position flip(arr, current_size) return arr"},{"question":"You are given a sorted array of integers and a target value. Implement a function named `custom_binary_search` that takes in an array and a target value and returns the index of the target value if it is present in the array. If the target value is not present, the function should return -1. Function Signature: ```python def custom_binary_search(array: List[int], target: int) -> int: ``` **Input:** - `array`: A list of integers sorted in ascending order. - `target`: An integer value that needs to be searched within the array. **Output:** - An integer representing the index of the target value if present, otherwise -1. # Example ```python # Example 1 array = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 5 assert custom_binary_search(array, target) == 4 # Example 2 array = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 10 assert custom_binary_search(array, target) == -1 # Example 3 array = [2, 3, 4, 10, 40] target = 2 assert custom_binary_search(array, target) == 0 # Example 4 array = [] target = 3 assert custom_binary_search(array, target) == -1 ``` # Constraints - The elements in the `array` are distinct. - The array length will not exceed 10^6. - The target value will be within the range of -10^9 to 10^9. # Performance Requirements The implementation should have a time complexity of O(log(n)) and a space complexity of O(1). # Scenario Imagine you are a data engineer working in a search engine company. Your task is to optimize the search algorithm for finding specific keywords in indexed data. To achieve this, you are required to implement the `custom_binary_search` function which helps in quickly locating the keyword in a sorted list.","solution":"from typing import List def custom_binary_search(array: List[int], target: int) -> int: Perform a binary search on a sorted array to find the target value. Arguments: array : List[int] -- A list of integers sorted in ascending order. target : int -- The target value to search for in the array. Returns: int -- The index of the target if found, else -1. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == target: return mid elif array[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Scenario You are developing a recommendation system that suggests products to users based on their preferences. For each user, their preferences are represented as a vector of their ratings for a predefined set of features (e.g., product categories). Each user will be represented as a point in a multi-dimensional space. # Problem Statement Write a function `nearest_neighbor` that finds the most similar user (nearest neighbor) from a training set to a given user based on their preference vectors. # Function Signature ```python def nearest_neighbor(x: tuple, tSet: dict) -> any: pass ``` # Input * `x`: A tuple representing the preference vector of the user for whom the nearest neighbor is being found. The vector can have any dimension. * `tSet`: A dictionary where the keys are tuples representing preference vectors of other users in the training set, and the values are any user-related data (which can be of any type). # Output * Returns the value associated with the vector in `tSet` that is nearest to `x`, according to Euclidean distance. # Constraints * The length of `x` and each key in `tSet` will always be the same. * The function should handle empty dictionaries gracefully and return `None`. # Examples ```python # Training set with users and their preferences train_set = { (1, 2): \'User A\', (2, 3): \'User B\', (3, 4): \'User C\' } # Query user preferences query_user = (2, 2) # Function call should return \'User A\' because (1, 2) is nearest to (2, 2) print(nearest_neighbor(query_user, train_set)) # Output: \'User A\' ``` # Notes 1. Ensure that all vectors (both `x` and the keys in `tSet`) have the same dimension. 2. Optimize the implementation for readability and correctness rather than performance, considering that the typical use case involves relatively small datasets.","solution":"import math def nearest_neighbor(x: tuple, tSet: dict) -> any: Finds the most similar user (nearest neighbor) from a training set to the given user based on their preference vectors. Args: x : tuple A tuple representing the preference vector of the user for whom the nearest neighbor is being found. tSet : dict A dictionary where keys are tuples representing preference vectors of other users in the training set, and values are any user-related data. Returns: any: The value associated with the vector in tSet that is nearest to x, according to Euclidean distance. Returns None if tSet is empty. def euclidean_distance(v1, v2): return math.sqrt(sum((a - b) ** 2 for a, b in zip(v1, v2))) if not tSet: return None nearest = None min_distance = float(\'inf\') for vector, user in tSet.items(): distance = euclidean_distance(x, vector) if distance < min_distance: min_distance = distance nearest = user return nearest"},{"question":"# Question: Path Existence in a Graph You are given a directed graph that consists of `N` vertices numbered from `0` to `N-1` and a list of directed edges. Your task is to determine if there\'s a path from a given source node to a target node. Implement the function `is_path_exist` to accomplish this task. Function Signature ```python def is_path_exist(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: pass ``` # Parameters * `vertex_count`: an integer denoting the number of vertices in the graph (`0 <= vertex_count <= 10^4`). * `edges`: a list of tuples where each tuple contains two integers, indicating a directed edge from the first vertex to the second vertex. * `source`: an integer representing the starting vertex (`0 <= source < vertex_count`). * `target`: an integer representing the ending vertex (`0 <= target < vertex_count`). # Returns * Returns `True` if there is a path from `source` to `target`, otherwise returns `False`. # Constraints * The graph does not contain multiple edges between two vertices. * The graph might contain cycles. # Example ```python vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 0)] source = 0 target = 3 print(is_path_exist(vertex_count, edges, source, target)) # Output: True vertex_count = 5 edges = [(0, 1), (0, 2), (3, 4)] source = 0 target = 3 print(is_path_exist(vertex_count, edges, source, target)) # Output: False ``` # Notes 1. Your solution must use Depth First Search (DFS) to explore paths from the source to the target. 2. Ensure to handle edge cases effectively as described in the analysis. 3. Consider optimizing the DFS implementation to avoid potential deep recursion issues. # Hint - Use a helper function to perform the DFS recursively. Ensure to keep track of visited nodes to prevent revisiting and infinite loops.","solution":"from typing import List, Tuple def is_path_exist(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: if source == target: return True graph = {i: [] for i in range(vertex_count)} for u, v in edges: graph[u].append(v) def dfs(node, visited): if node == target: return True visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, visited): return True return False return dfs(source, set())"},{"question":"# Binary Search Optimization **Context**: You have been given a sorted array of integers. Your task is to search for a target integer within this array. The array may contain duplicate elements, and it is guaranteed to be sorted in ascending order. # Task Write a function named `find_first_and_last_position` to return the first and last positions of a target value in the sorted array. If the target is not present in the array, return [-1, -1]. # Specifications * **Function signature**: `def find_first_and_last_position(array: List[int], target: int) -> List[int]:` * **Input**: * `array`: A sorted list of integers. (1 <= len(array) <= 10^5, -10^6 <= array[i] <= 10^6) * `target`: An integer (-10^6 <= target <= 10^6) * **Output**: * A list of two integers representing the first and last positions of the target in the array. If the target is not found, return [-1, -1]. # Constraints 1. Utilize the binary search algorithm to achieve the task. 2. Aim for O(log n) time complexity. 3. The function should handle edge cases such as an empty array or the absence of the target value efficiently. # Example ```python assert find_first_and_last_position([5, 7, 7, 8, 8, 10], 8) == [3, 4] assert find_first_and_last_position([5, 7, 7, 8, 8, 10], 6) == [-1, -1] assert find_first_and_last_position([], 0) == [-1, -1] assert find_first_and_last_position([1], 1) == [0, 0] ``` # Notes * You need to write both an iterative or recursive binary search function to find the first and last positions separately if needed. * Maintain clarity and efficiency in your algorithm to get desired results within the constraints mentioned.","solution":"from typing import List def find_first_and_last_position(array: List[int], target: int) -> List[int]: def find_position(left): lo, hi = 0, len(array) while lo < hi: mid = (lo + hi) // 2 if array[mid] > target or (left and target == array[mid]): hi = mid else: lo = mid + 1 return lo left_idx = find_position(True) if left_idx == len(array) or array[left_idx] != target: return [-1, -1] right_idx = find_position(False) - 1 return [left_idx, right_idx]"},{"question":"**Scenario**: You are working on a feature in an interactive whiteboard application where users can add and delete nodes representing different components dynamically. Your task is to implement the `delete_node` function which efficiently removes a given node from a singly linked list without access to the list\'s head. Function Signature ```python def delete_node(node): # your implementation here ``` Input * `node` (Node): The node to remove from the linked list. It is guaranteed that this node is not the tail and is part of a non-empty list. Output * None. The function manipulates the linked list in place. Constraints * The function must raise a `ValueError` if given a `None` node or if the node is the last node in the list (i.e., without a `next` node). Example ```python class Node: def __init__(self, x): self.val = x self.next = None # Linked List: 1 -> 2 -> 3 -> 4 head = Node(1) a = Node(2) b = Node(3) c = Node(4) head.next = a a.next = b b.next = c # Part to remove the node containing \'3\' delete_node(b) # Expected output Linked List: 1 -> 2 -> 4 ``` Performance Requirements * Time Complexity: O(1) * Space Complexity: O(1) Note Ensure that your implementation correctly handles the edge case where a node to be removed is neither `None` nor the tail. Add necessary error handling for edge scenarios.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node): Remove the given node from the linked list. The node to be deleted is guaranteed not to be the tail, and the list is non-empty. if node is None or node.next is None: raise ValueError(\\"Cannot delete a None node or the last node.\\") # Copy the data from the next node to the current node next_node = node.next node.val = next_node.val node.next = next_node.next"},{"question":"# Problem: Optimized Matrix Power Calculation You are given a square matrix `mat` of size `d x d` and an integer `n`. Your task is to compute the matrix raised to the power `n` efficiently. # Input - `mat`: A list of lists representing a `d x d` matrix, where `d` is an integer (1 <= d <= 100). - `n`: An integer (0 <= n <= 10^9), the power to which the matrix should be raised. # Output - A list of lists representing the resulting `d x d` matrix after raising `mat` to the power `n`. # Constraints - The elements of the matrix will not exceed 10^3 by absolute value. - The result should be computed efficiently, using O(d^3 log(n)) time complexity. # Example ```python mat = [ [1, 2], [3, 4] ] n = 2 ``` Output: ```python [ [7, 10], [15, 22] ] ``` # Note - If `n = 0`, return the identity matrix of size `d x d`. Implement the function `matrix_power(mat: list, n: int) -> list` that performs the required computation.","solution":"def matrix_multiply(A, B): Multiplies two matrices A and B d = len(A) result = [[0] * d for _ in range(d)] for i in range(d): for j in range(d): for k in range(d): result[i][j] += A[i][k] * B[k][j] return result def identity_matrix(d): Returns an identity matrix of size d x d I = [[0] * d for _ in range(d)] for i in range(d): I[i][i] = 1 return I def matrix_power(mat, n): Computes the power of a matrix mat to the nth power using exponentiation by squaring if n == 0: return identity_matrix(len(mat)) if n == 1: return mat half_power = matrix_power(mat, n // 2) half_power_squared = matrix_multiply(half_power, half_power) if n % 2 == 0: return half_power_squared else: return matrix_multiply(half_power_squared, mat)"},{"question":"You are tasked with implementing a function `simplify_path` that simplifies a given Unix-style absolute path to its canonical form. The canonical path should resolve all instances of: - Intermediate steps indicated by \\".\\". - Moves up one level in the filesystem denoted by \\"..\\". - Redundant sequential slashes \\"//\\" to a single slash \\"/\\". The canonical path must always begin with a single slash \'/\' and should not end with a slash (unless it is the root \\"/\\"). Input A single string `path`, representing the Unix-style absolute path. Constraints: - The length of `path` is in the range [1, 10^4]. - `path` contains only characters from the set {\'/\', \'.\', a-z}. Output Return a simplified canonical path string. Examples 1. Input: `\\"/home/\\"` Output: `\\"/home\\"` 2. Input: `\\"/a/./b/../../c/\\"` Output: `\\"/c\\"` 3. Input: `\\"/../\\"` Output: `/` 4. Input: `\\"/home//foo/\\"` Output: `\\"/home/foo\\"` 5. Input: `\\"/a/b/c/../../d/../e/\\"` Output: `\\"/a/e\\"` Explanation 1. The first example has no special tokens, so the path remains the same. 2. The second example moves up levels according to \\"..\\", leading to \\"c\\". 3. The third example tries to move up from the root (..), which just returns the root. 4. The fourth example normalizes the redundant slashes. 5. The fifth example demonstrates a combination of movements and simplifications, resulting in \\"/a/e\\". Your function should be as efficient as possible keeping in line with the provided constraints. Function Signature ```python def simplify_path(path: str) -> str: # Your code here pass ```","solution":"def simplify_path(path: str) -> str: Simplifies the given Unix-style absolute path to its canonical form. parts = path.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() else: stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"Consider you are working on a project that requires transforming data strings while maintaining specific patterns. As part of this task, you need to ensure that two given strings can be transformed into each other based on character mappings. **Problem Statement:** Given two strings `s` and `t`, determine if they are isomorphic. Two strings are isomorphic if the characters in `s` can be replaced to get `t`. A character from `s` can only map to one character in `t` while preserving the order of characters. No two characters from `s` may map to the same character in `t`, but a character from `s` may map to itself. **Input:** * Two strings `s` and `t`. (1 ≤ length of s, t ≤ 1000) **Output:** * Return `True` if both strings are isomorphic, otherwise `False`. **Constraints:** * The strings `s` and `t` must have the same length. **Examples:** ```python Example 1: Input: s = \\"egg\\", t = \\"add\\" Output: True Example 2: Input: s = \\"foo\\", t = \\"bar\\" Output: False Example 3: Input: s = \\"paper\\", t = \\"title\\" Output: True Example 4: Input: s = \\"abc\\", t = \\"def\\" Output: True Example 5: Input: s = \\"ab\\", t = \\"aa\\" Output: False ``` **Performance Requirements:** * Ensure that your solution works efficiently with the maximum string length constraint (up to 1000 characters). Implement the function `is_isomorphic(s, t)`: ```python def is_isomorphic(s, t): :type s: str :type t: str :rtype: bool # Your code here ```","solution":"def is_isomorphic(s, t): Determine if two strings s and t are isomorphic. :type s: str :type t: str :rtype: bool if len(s) != len(t): return False s_to_t_mapping = {} t_to_s_mapping = {} for char_s, char_t in zip(s, t): if char_s in s_to_t_mapping: if s_to_t_mapping[char_s] != char_t: return False else: s_to_t_mapping[char_s] = char_t if char_t in t_to_s_mapping: if t_to_s_mapping[char_t] != char_s: return False else: t_to_s_mapping[char_t] = char_s return True"},{"question":"# Context Given an implementation of a Red-Black Tree, we need to add additional functionality to efficiently check whether the tree contains a given value. This involves writing a search method that maintains the core properties and structure of the Red-Black Tree. # Task Your task is to implement the `search` method for the `RBTree` class. This method should allow searching for a given value in the Red-Black Tree while preserving the tree\'s properties. # Function Details * **Function Name**: `search` * **Input**: * `self` - representing the instance of the `RBTree` class. * `value` - an integer representing the value to search in the tree. * **Output**: * Returns `True` if the value is found in the tree, `False` otherwise. # Scenario Your Red-Black Tree is populated with several nodes, and you need to implement an efficient way to check if a specific value exists without disrupting the tree’s balance and properties. # Constraints 1. **Assumptions**: All node values are unique. 2. **Performance**: Your solution should maintain O(log n) complexity. 3. **Edge Cases**: Ensure you handle cases where the tree is empty. # Example Assume the tree structure from the provided code, and we search for different values. ```python rb = RBTree() children = [11, 2, 14, 1, 7, 15, 5, 8, 4] for child in children: node = RBNode(child, 1) rb.insert(node) # Search Test Cases print(rb.search(7)) # Expected Output: True print(rb.search(3)) # Expected Output: False print(rb.search(15)) # Expected Output: True print(rb.search(20)) # Expected Output: False ``` # Code Implementation Now, implement the `search` method within the `RBTree` class. ```python class RBTree: # ... [other methods from the original code] def search(self, value): # Your implementation goes here pass # ... [other methods from the original code] ``` Ensure that your method works correctly by integrating it with the provided Red-Black Tree code structure.","solution":"class RBNode: def __init__(self, data, color, left=None, right=None, parent=None): self.data = data self.color = color # 1 . Red, 0 . Black self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.NULL = RBNode(0, 0) self.root = self.NULL def search(self, value): def _search(node, value): if node == self.NULL or value == node.data: return node != self.NULL if value < node.data: return _search(node.left, value) else: return _search(node.right, value) return _search(self.root, value) def insert(self, key): # Insertion code pass # Other methods for balancing, rotations etc. # Dummy insert method for test creation purposes, real method would include balancing logic. def insert(self, node): if self.root == self.NULL: self.root = node self.root.color = 0 self.root.left = self.NULL self.root.right = self.NULL else: self._insert_node(self.root, node) def _insert_node(self, root, node): if node.data < root.data: if root.left == self.NULL: root.left = node node.parent = root node.left = self.NULL node.right = self.NULL node.color = 1 else: self._insert_node(root.left, node) else: if root.right == self.NULL: root.right = node node.parent = root node.left = self.NULL node.right = self.NULL node.color = 1 else: self._insert_node(root.right, node)"},{"question":"# Coding Challenge: Maximum Sum Subarray Finder Problem Statement You are given an integer array `arr`. Your task is to implement a function `max_subarray(arr)` that computes the maximum sum of a contiguous subarray in the given array. Function Signature ```python def max_subarray(arr: List[int]) -> int: ``` Input - A list `arr` of integers, where `1 <= len(arr) <= 10^5` and `-10^4 <= arr[i] <= 10^4`. Output - An integer representing the maximum sum of a contiguous subarray. Constraints - The list will contain at least one element. - The algorithm should run in O(n) time complexity and O(1) space complexity. Examples 1. `arr = [1, 2, -3, 4, 5, -7, 23]` - Output: `25` 2. `arr = [-1, -2, -3, -4]` - Output: `-1` 3. `arr = [4, -1, 2, 1]` - Output: `6` Explanation - Example 1: The maximum subarray is `[4, 5, -7, 23]` with sum `25`. - Example 2: The maximum subarray is `[-1]` with sum `-1`. - Example 3: The maximum subarray is `[4, -1, 2, 1]` with sum `6`. Constraints to Note: - Your solution should handle large arrays efficiently. - Pay attention to edge cases such as arrays with all negative numbers. Hint: - You can achieve this by using a dynamic programming approach similar to Kadane’s Algorithm.","solution":"def max_subarray(arr): Returns the maximum sum of a contiguous subarray in the given array using Kadane\'s Algorithm. # Initialize variables max_current = max_global = arr[0] for i in range(1, len(arr)): max_current = max(arr[i], max_current + arr[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Insertion Sort with Custom Conditions **Objective**: Implement an enhanced version of the Insertion Sort algorithm that sorts a list of numbers with the following custom conditions: 1. The list must be sorted in ascending order by default but should also support descending order sorting based on an optional parameter. 2. The algorithm should be able to handle lists containing duplicate values and ensure the stability of the sorting. 3. If the list contains non-numeric elements, the function should filter them out before sorting. 4. Provide a simulation mode that prints each iteration of the sorting process, showing the state of the list after each element is inserted into its correct position. # Function Signature ```python def enhanced_insertion_sort(arr, ascending=True, simulation=False): Sorts a list of numeric values using the insertion sort algorithm with optional customization. Parameters: arr (list): The list of elements to sort. ascending (bool): If True, sort in ascending order. Otherwise, sort in descending order. simulation (bool): If True, prints each iteration of the sorting process. Returns: list: The sorted list. ``` # Inputs * **arr**: A list of elements to be sorted. The elements can be numeric or non-numeric, but non-numeric elements should be ignored. * **ascending** (optional): A boolean flag indicating whether to sort the list in ascending (`True`) or descending (`False`) order. Defaults to `True`. * **simulation** (optional): A boolean flag to print each iteration of the sorting process. Defaults to `False`. # Outputs * A list of numeric elements sorted according to the specified order. # Constraints * The list can contain a mixture of numeric and non-numeric elements, but only numeric elements should be sorted. * The function must handle an empty list gracefully. * The function must maintain sorting stability. # Example ```python # Example 1: Basic ascending sort print(enhanced_insertion_sort([3, 1, 2, 4])) # Output: [1, 2, 3, 4] # Example 2: Descending sort print(enhanced_insertion_sort([3, 1, 2, 4], ascending=False)) # Output: [4, 3, 2, 1] # Example 3: List with non-numeric values print(enhanced_insertion_sort([3, \\"apple\\", 1, 2, \\"banana\\", 4])) # Output: [1, 2, 3, 4] # Example 4: Simulation of sorting process print(enhanced_insertion_sort([3, 1, 2, 4], simulation=True)) # Output: # iteration 0 : 3 1 2 4 # iteration 1 : 1 3 2 4 # iteration 2 : 1 2 3 4 # iteration 3 : 1 2 3 4 # [1, 2, 3, 4] ``` # Notes * Implement the function `enhanced_insertion_sort()` to fulfill the requirements. * Ensure proper handling of edge cases and erroneous inputs. * Focus on demonstrating understanding of the insertion sort algorithm, handling non-numeric elements, and providing the simulation of the sorting process.","solution":"def enhanced_insertion_sort(arr, ascending=True, simulation=False): Sorts a list of numeric values using the insertion sort algorithm with optional customization. Parameters: arr (list): The list of elements to sort. ascending (bool): If True, sort in ascending order. Otherwise, sort in descending order. simulation (bool): If True, prints each iteration of the sorting process. Returns: list: The sorted list. # Filter out non-numeric elements numeric_list = [elem for elem in arr if isinstance(elem, (int, float))] # Perform insertion sort for i in range(1, len(numeric_list)): current_value = numeric_list[i] position = i if ascending: while position > 0 and numeric_list[position - 1] > current_value: numeric_list[position] = numeric_list[position - 1] position -= 1 else: while position > 0 and numeric_list[position - 1] < current_value: numeric_list[position] = numeric_list[position - 1] position -= 1 numeric_list[position] = current_value # Print the intermediate state for simulation if simulation: print(f\\"iteration {i}: {\' \'.join(map(str, numeric_list))}\\") return numeric_list"},{"question":"# ZigZag Iterator for Multiple Lists As an experienced software developer, you need to implement a general version of the `ZigZagIterator` that can work with an arbitrary number of input lists. Your task is to design a generalized `ZigZagIterator` class that supports an arbitrary number of lists and performs the iteration in a zigzag manner. Requirements: - Implement the `ZigZagIterator` class. - Include methods `next()` and `has_next()` similar to the provided implementation. - The constructor should take a list of lists as its input. - Ensure the lists are not modified during iteration. Input: - A list of lists of integers, where each inner list represents a separate sequence. Output: - `next()`: Returns the next integer in zigzag order from the list of lists. - `has_next()`: Returns a boolean indicating if there are more elements to iterate over. Constraints: - The number of lists, ( k ), and the total number of elements in all lists combined, ( n ), will be reasonable enough to fit in memory. - All lists are non-null, though some may be empty. Example: ```python l1 = [1, 2] l2 = [3, 4, 5, 6] l3 = [7, 8, 9] it = ZigZagIterator([l1, l2, l3]) while it.has_next(): print(it.next()) ``` Expected output: ``` 1 3 7 2 4 8 5 9 6 ``` Notes: - Use a queue-like structure to manage the lists for efficiency. - Ensure that after iterating over one step from each list, the iterator continues from where it left off. - Ensure no original lists are modified, meaning copying the list content is mandatory if you plan to manipulate them. Implement the `ZigZagIterator` class: ```python from collections import deque from typing import List class ZigZagIterator: def __init__(self, lists: List[List[int]]): self.queue = deque([deque(lst) for lst in lists if lst]) def next(self) -> int: if not self.has_next(): raise Exception(\\"No more elements\\") current_list = self.queue.popleft() next_element = current_list.popleft() if current_list: self.queue.append(current_list) return next_element def has_next(self) -> bool: return len(self.queue) > 0 ```","solution":"from collections import deque from typing import List class ZigZagIterator: def __init__(self, lists: List[List[int]]): self.queue = deque([deque(lst) for lst in lists if lst]) def next(self) -> int: if not self.has_next(): raise Exception(\\"No more elements\\") current_list = self.queue.popleft() next_element = current_list.popleft() if current_list: self.queue.append(current_list) return next_element def has_next(self) -> bool: return len(self.queue) > 0"},{"question":"Context: You are working for a company that deals with organizing hierarchical data structures, particularly binary trees. Your task is to implement functions that help analyze the structure of these trees. Objective: Write a function that computes the minimum depth of a binary tree using an iterative BFS approach and another function that prints the tree nodes in pre-order traversal. Instructions: 1. Implement the function `min_depth_bfs(root)` which computes the minimum depth of a binary tree using the BFS approach. - **Input**: A binary tree root node, defined as: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` - **Output**: An integer representing the minimum depth of the tree. If the tree is empty, return 0. 2. Implement the function `print_pre_order(root)` which prints the nodes of a binary tree in a pre-order traversal. - **Input**: A binary tree root node (same structure as above). - **Output**: The function should print each node value in pre-order to the standard output. Constraints: - The number of nodes in the tree will be in the range [0, 1000]. - Node values are within the range [-1000, 1000]. Example: Input: ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) ``` Output of `min_depth_bfs(root)`: ``` 2 ``` Output of `print_pre_order(root)`: ``` 1 2 4 5 3 ``` Performance Requirement: - Your BFS approach should run within O(N) time complexity and use O(N) space complexity.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def min_depth_bfs(root): Computes the minimum depth of a binary tree using BFS approach. Args: root (TreeNode): The root of the binary tree. Returns: int: The minimum depth of the binary tree. If the tree is empty, return 0. if not root: return 0 queue = deque([(root, 1)]) # (current node, current depth) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) def print_pre_order(root): Prints the nodes of a binary tree in pre-order traversal. Args: root (TreeNode): The root of the binary tree. def _pre_order(node): if not node: return print(node.val) _pre_order(node.left) _pre_order(node.right) _pre_order(root)"},{"question":"Context: We want to clean a set of textual inputs to remove any recurring characters while maintaining the original order of first appearances. This task ensures that input strings are preprocessed for further processing or storage where unique characters are required. Task: Write a function `remove_duplicates` that takes a string as input and returns a string with all recurring characters removed, preserving their first appearance order. Function Signature: ```python def remove_duplicates(input_string: str) -> str: ``` Inputs: - `input_string` (str): A string consisting of uppercase/lowercase alphabets and possibly digits or symbols. (1 <= len(input_string) <= 10^6) Output: - (str): A string containing only the first appearance of each character from the input string. Constraints: - Your solution should be efficient in terms of both time and space complexity. - You should handle edge cases such as empty strings or strings with all identical characters gracefully. Examples: 1. `remove_duplicates(\\"programming\\")` should return `\\"progamin\\"`. 2. `remove_duplicates(\\"aabbcc\\")` should return `\\"abc\\"`. 3. `remove_duplicates(\\"abcdef\\")` should return `\\"abcdef\\"`. 4. `remove_duplicates(\\"\\")` should return `\\"\\"`. 5. `remove_duplicates(\\"aabbccddeeff\\")` should return `\\"abcdef\\"`. Notes: - Any additional optimizations and clear handling of edge cases will be considered in the evaluation of your solution.","solution":"def remove_duplicates(input_string: str) -> str: Removes all recurring characters from the input string while preserving the order of first appearance of characters. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"**Problem Statement** You are tasked with extending the implementation of RSA encryption above. The implementation provided already covers key generation, encryption, and decryption. Your task is to implement the following additional functionalities to further improve the RSA encryption system: 1. **Efficient Prime Checking**: Rewrite the `is_prime` function to use the Miller-Rabin primality test for efficient prime checking. 2. **Key Size Validation**: Implement a function to validate the key size (i.e., the number of bits in **n**) and ensure that it\'s appropriate for the security level required. 3. **Message Padding**: Implement a simple method to handle padding of data before encryption and stripping of padding after decryption to support encrypting/decrypting strings that might have lengths not supported directly by RSA. **Function Signatures** ```python def is_prime(num: int, k: int = 40) -> bool: pass def validate_key_size(k: int) -> bool: pass def pad_message(message: str, n: int) -> int: pass def unpad_message(padded_message: int, n: int) -> str: pass ``` **Input and Output Formats** 1. **is_prime(num: int, k: int = 40) -> bool** * `num`: a positive integer, the number to check for primality. * `k`: an optional integer, the number of accuracy iterations for the Miller-Rabin test. * **Output**: `True` if `num` is prime, otherwise `False`. 2. **validate_key_size(k: int) -> bool** * `k`: an integer, the number of bits in the key. * **Output**: `True` if the key size is considered secure, otherwise `False`. 3. **pad_message(message: str, n: int) -> int** * `message`: a string, the message to be encrypted. * `n`: an integer, the modulus of the RSA key. * **Output**: an integer, the padded message suitable for RSA encryption. 4. **unpad_message(padded_message: int, n: int) -> str** * `padded_message`: an integer, the padded message to be decrypted. * `n`: an integer, the modulus of the RSA key. * **Output**: a string, the original message after removing padding. **Constraints and Limitations** 1. Ensure that the key size `k` is at least 2048 bits for a secure RSA. 2. The message length must be such that it can be encrypted within the given modulus `n`. 3. Padding method should ensure that the message is always less than `n`. **Example** ```python # Suppose n, e, d are already generated by generate_key message = \\"Hello, RSA!\\" padded_message = pad_message(message, n) encrypted = encrypt(padded_message, e, n) decrypted = decrypt(encrypted, d, n) original_message = unpad_message(decrypted, n) assert message == original_message ```","solution":"import random def is_prime(num: int, k: int = 40) -> bool: Determines if a number is prime using the Miller-Rabin primality test. num: the number to check for primality. k: the number of accuracy iterations. output: True if num is a prime number, False otherwise. if num <= 1: return False if num <= 3: return True if num % 2 == 0: return False # Find d such that d * 2^r = num - 1 d = num - 1 r = 0 while d % 2 == 0: d //= 2 r += 1 def is_composite(a, d, num, r): x = pow(a, d, num) if x == 1 or x == num - 1: return False for _ in range(r - 1): x = pow(x, 2, num) if x == num - 1: return False return True for _ in range(k): a = random.randint(2, num - 2) if is_composite(a, d, num, r): return False return True def validate_key_size(k: int) -> bool: Validates whether the key size is considered secure. k: the number of bits in the key. output: True if the key size is secure (>= 2048 bits), False otherwise. return k >= 2048 def pad_message(message: str, n: int) -> int: Adds padding to a message to prepare it for RSA encryption. message: the message to encrypt. n: the modulus of the RSA key. output: the padded message as an integer suitable for RSA encryption. message_bytes = message.encode(\'utf-8\') message_int = int.from_bytes(message_bytes, byteorder=\'big\') max_msg_len = (n.bit_length() // 8) - 11 # 11 bytes padding if len(message_bytes) > max_msg_len: raise ValueError(\\"Message too long to be encrypted with provided n\\") return message_int def unpad_message(padded_message: int, n: int) -> str: Removes padding from a decrypted message. padded_message: the padded message as an integer. n: the modulus of the RSA key. output: the original message as a string. message_bytes = padded_message.to_bytes((padded_message.bit_length() + 7) // 8, byteorder=\'big\') return message_bytes.decode(\'utf-8\', errors=\'ignore\')"},{"question":"You are implementing a feature for a simple number game based on the \\"FizzBuzz\\" rules. Problem Statement Write a function `improved_fizzbuzz(n: int) -> List[Union[str, int]]` that returns a list of integers from 1 to n with the following modifications: - If a number is divisible by 3, replace it with the string \\"Fizz\\". - If a number is divisible by 5, replace it with the string \\"Buzz\\". - If a number is divisible by both 3 and 5, replace it with the string \\"FizzBuzz\\". Input - A single integer `n` where ( 1 leq n leq 10^6 ). Output - A list of length `n` where each element is either an integer or one of the specified strings. Constraints 1. The function should handle up to 10^6 efficiently (in terms of both time and space). 2. The input will always be a positive integer within the provided constraints. Examples ```python >>> improved_fizzbuzz(15) [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] >>> improved_fizzbuzz(5) [1, 2, \'Fizz\', 4, \'Buzz\'] ``` Implementation Notes - Consider edge cases like n = 1 or n = very large values. - Ensure the function handles and returns the correct data types. - Think about memory efficiency and avoid unnecessary repetitions or calculations.","solution":"from typing import List, Union def improved_fizzbuzz(n: int) -> List[Union[str, int]]: result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"Scenario You are tasked with creating a function that examines whether a given string adheres to a predetermined pattern. Your function must establish a one-to-one relationship between each character in the pattern and unique words in the string. Function Description Implement a function `word_pattern` that receives two parameters: * `pattern` (string): A string of characters where each character represents a specific type of word. * `str` (string): A sequence of words separated by a single space. Your function should return `True` if the string follows the pattern fully; otherwise, it should return `False`. # Example Usage ```python print(word_pattern(\\"abba\\", \\"dog cat cat dog\\")) # Output: True print(word_pattern(\\"abba\\", \\"dog cat cat fish\\")) # Output: False print(word_pattern(\\"aaaa\\", \\"dog cat cat dog\\")) # Output: False print(word_pattern(\\"abba\\", \\"dog dog dog dog\\")) # Output: False ``` Constraints * The pattern will only contain lowercase letters. * The string will only contain lowercase English letters and spaces, with words separated by a single space. * Assume that the input values are non-empty. Performance * Aim to achieve a function with linear time complexity O(n), where n is the length of the string. * Space complexity should ideally be O(m), where m is the total number of unique characters and words. # Input and Output * **Input**: * `pattern` - a string of lowercase letters (e.g., \\"abba\\"). * `str` - a string of words separated by a single space (e.g., \\"dog cat cat dog\\"). * **Output**: * Boolean value `True/False` indicating if the string adheres to the given pattern.","solution":"def word_pattern(pattern, str): words = str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: if word in word_to_char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"# Coding Problem: Enhanced Insertion Sort You are given an unsorted list of integers. Your task is to implement an insertion sort algorithm using the given helper function `search_insert`. The helper function can be used to find the index where an element belongs in the sorted portion of the list. Function Signature ```python def insertion_sort(array: List[int]) -> List[int]: pass ``` The function takes an unsorted list of integers and returns a list of integers sorted in non-decreasing order. Input * `array`: A list of `n` integers (0 <= n <= 10^5). Output * A list of integers sorted in non-decreasing order. Constraints * The function should efficiently handle cases where `n = 0`. * The function should correctly handle arrays with duplicate values. * Your implementation should have a time complexity of O(n^2) in the average and worst-case scenarios. * Maintain the stability of the insertion sort. Example ```python array = [4, 2, 7, 1, 3] print(insertion_sort(array)) # Output: [1, 2, 3, 4, 7] ``` ```python array = [10, -1, 2, -10, 0] print(insertion_sort(array)) # Output: [-10, -1, 0, 2, 10] ``` Note Your implementation should use the `search_insert` function provided below. The `search_insert` function finds the appropriate position for a given value in a sorted list. ```python def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low ``` Implement the insertion sort utilizing the provided helper function and make sure your code passes tests with larger lists efficiently.","solution":"from typing import List def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low def insertion_sort(array: List[int]) -> List[int]: for i in range(1, len(array)): key = array[i] # Find the index where key should be inserted in the sorted sublist array[0:i] insert_index = search_insert(array[:i], key) # Insert key at the found index and shift the rest array = array[:insert_index] + [key] + array[insert_index:i] + array[i+1:] return array"},{"question":"# RSA Key Generation and Encryption/Decryption You are asked to implement the RSA encryption algorithm including key generation, encryption, and decryption functions. For this task, you need to demonstrate your understanding of the RSA algorithm by implementing an optimized key generation algorithm and use it to encrypt and decrypt data. # Requirements 1. **Key Generation**: - Generate two large prime numbers ( p ) and ( q ) of specified bit lengths. - Compute ( n = p * q ). - Compute φ(n) = (p - 1) * (q - 1). - Choose an encryption exponent ( e ) (it can be a small prime like 65537) and ensure ( e ) and φ(n) are coprime. - Calculate the decryption exponent ( d ) which is the modular multiplicative inverse of ( e ) modulo φ(n). 2. **Encryption**: - Write a function to encrypt a given integer data using the public key (n, e). 3. **Decryption**: - Write a function to decrypt the encrypted data using the private key (n, d). # Function Signatures ```python def generate_key(k: int) -> Tuple[int, int, int]: Generate RSA key pair. Args: - k: The bit length for the modulus n. Returns: - Tuple containing (n, e, d). pass def encrypt(data: int, e: int, n: int) -> int: Encrypt data using the public key (n, e). Args: - data: The integer data to be encrypted. - e: The encryption exponent. - n: The modulus. Returns: - Encrypted data as an integer. pass def decrypt(data: int, d: int, n: int) -> int: Decrypt data using the private key (n, d). Args: - data: The encrypted data to be decrypted. - d: The decryption exponent. - n: The modulus. Returns: - Decrypted data as an integer. pass ``` # Constraints - The bit length k will be a positive integer such that ( k geq 8 ). - The data to be encrypted will be a non-negative integer less than n. - Use efficient algorithms for prime testing and modular inversion. # Example 1. Generate keys: ```python n, e, d = generate_key(16) ``` 2. Encrypt a message: ```python encrypted_data = encrypt(42, e, n) ``` 3. Decrypt the message: ```python decrypted_data = decrypt(encrypted_data, d, n) # decrypted_data should be 42 ``` # Note Ensure that your implementation handles edge cases and optimizes key generation and encryption/decryption efficiently.","solution":"import random from sympy import isprime, mod_inverse from typing import Tuple def generate_prime_candidate(bit_length: int) -> int: # Use the random library to generate a random odd integer of bit_length bits p = random.getrandbits(bit_length) # Ensure that it is odd by setting the last bit to 1 p |= (1 << bit_length - 1) | 1 return p def generate_large_prime(bit_length: int) -> int: p = generate_prime_candidate(bit_length) # Keep generating new candidates until a prime is found while not isprime(p): p = generate_prime_candidate(bit_length) return p def generate_key(k: int) -> Tuple[int, int, int]: bit_length = k // 2 p = generate_large_prime(bit_length) q = generate_large_prime(bit_length) while q == p: q = generate_large_prime(bit_length) n = p * q phi_n = (p - 1) * (q - 1) e = 65537 # Compute the decryption exponent d d = mod_inverse(e, phi_n) return n, e, d def encrypt(data: int, e: int, n: int) -> int: return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: return pow(data, d, n)"},{"question":"Consider an application where you need to evaluate perfect squares and progress to the next possible perfect square. Your task is to implement a function `find_next_perfect_square(sq)` that will take a single integer argument `sq`. The function should return the next perfect square if `sq` is a perfect square itself, otherwise, it should return -1. # Function Signature ```python def find_next_perfect_square(sq: int) -> int: pass ``` # Input * An integer `sq` (1 ≤ sq ≤ 10^12). # Output * An integer representing the next perfect square after `sq` if `sq` is a perfect square. * Return `-1` if `sq` is not a perfect square. # Example ```python assert find_next_perfect_square(121) == 144 assert find_next_perfect_square(625) == 676 assert find_next_perfect_square(114) == -1 ``` # Constraints 1. Ensure your solution is efficient and handles the upper constraint gracefully. 2. Do not use built-in functions that directly determine perfect squares. # Scenario Imagine you are working on a game system where players score points based on perfect squares. After achieving a score that is a perfect square, the game system should inform the player of the next target perfect square. Your function will help determine this next target.","solution":"import math def find_next_perfect_square(sq: int) -> int: Returns the next perfect square if `sq` is a perfect square itself, otherwise returns -1. if sq < 1: return -1 root = int(math.isqrt(sq)) if root * root == sq: next_root = root + 1 return next_root * next_root else: return -1"},{"question":"# Question: Wiggle Sort Challenge You are given an unsorted array `nums`. Write a function `wiggle_sort(nums)` that reorders the array in place such that `nums[0] < nums[1] > nums[2] < nums[3]` and so on. Input * An array `nums` of size `n`, where `1 <= n <= 10^5`. Output * Modify the input array such that it satisfies the wiggle sort property. Constraints * The function should run in O(n) time complexity. * The function should have O(1) space complexity, modifying the array in place. Example ```python >>> array = [3, 5, 2, 1, 6, 4] >>> wiggle_sort(array) >>> print(array) [3, 5, 1, 6, 2, 4] ``` Notes * Your function should handle arrays of different sizes, including edge cases such as arrays with a single element. * Duplicate values in the array should still respect the wiggle sort property. Implement the `wiggle_sort(nums)` function that follows the above requirements.","solution":"def wiggle_sort(nums): Reorders the elements in nums in-place to satisfy the wiggle sort property. nums[0] < nums[1] > nums[2] < nums[3] > ... for i in range(len(nums)): if i % 2 == 1: if nums[i] < nums[i - 1]: nums[i], nums[i - 1] = nums[i - 1], nums[i] else: if i != 0 and nums[i] > nums[i - 1]: nums[i], nums[i - 1] = nums[i - 1], nums[i]"},{"question":"# Preorder Traversal Challenge Context You are provided with a binary tree, and you need to implement a function that performs a preorder traversal. Preorder traversal visits nodes in the order: root, left subtree, right subtree. Objective Write two functions: 1. `preorder(Node root)` - Performs iterative preorder traversal. 2. `preorder_rec(Node root)` - Performs recursive preorder traversal. Input * A reference to the root node of the binary tree. Output * A list of integers representing the preorder traversal of the tree\'s node values. Constraints * The number of nodes in the binary tree will not exceed 10^5. * Each node value is an integer and unique. Performance Requirements * Both functions should run in O(n) time where n is the number of nodes in the tree. * The iterative function should use O(h) space complexity, where h is the height of the tree. * The recursive function should avoid stack overflow by considering the limit of recursion depth. Example Consider the binary tree: ``` 1 / 2 3 / 4 5 ``` * The expected output for preorder traversal would be [1, 2, 4, 5, 3]. Starter Code You have a class `Node` as follows: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` Implement the following functions: ```python def preorder(root): # Your code here pass def preorder_rec(root, res=None): # Your code here pass ```","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def preorder(root): Performs iterative preorder traversal. :param Node root: The root of the binary tree. :return: List of integers representing the preorder traversal. if not root: return [] stack, result = [root], [] while stack: node = stack.pop() if node: result.append(node.val) # Push right first so that left is processed first if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result def preorder_rec(root, res=None): Performs recursive preorder traversal. :param Node root: The root of the binary tree. :param list res: List to collect the result, used for recursive traversal. :return: List of integers representing the preorder traversal. if res is None: res = [] if root: res.append(root.val) preorder_rec(root.left, res) preorder_rec(root.right, res) return res"},{"question":"# Problem Description You are tasked with implementing a sorting function using the Quick Sort algorithm. Your function should take an array of integers and return a sorted version of that array. # Function Signature ```python def quick_sort(arr: List[int]) -> List[int]: ``` # Input * `arr` (List[int]): The array of integers to be sorted. The length of the array will be between `1` and `10^4`. # Output * `List[int]`: A new list containing all the elements from `arr` in ascending order. # Constraints * Input array can have repeated elements. * You must implement the sorting in-place, meaning you cannot use additional arrays for sorting. * You need to implement a median-of-three strategy for selecting the pivot in your `partition` function to optimize performance and avoid the worst-case scenario as much as possible. # Example ```python # Input arr = [3, 6, 8, 10, 1, 2, 1] # Output [1, 1, 2, 3, 6, 8, 10] ``` # Additional Guidelines 1. You must implement the median-of-three technique for choosing the pivot. 2. Your solution should handle all edge cases such as arrays with all identical elements, sorted arrays, and reverse sorted arrays. 3. Consider time and space complexity when submitting your solution.","solution":"from typing import List def quick_sort(arr: List[int]) -> List[int]: Perform quicksort on the provided list. Implements the median-of-three strategy for pivot selection. def median_of_three(low, high): mid = (low + high) // 2 a, b, c = arr[low], arr[mid], arr[high] if a > b: if a < c: return low elif b > c: return mid else: return high else: if a > c: return low elif b < c: return mid else: return high def partition(low, high): pivot_index = median_of_three(low, high) arr[high], arr[pivot_index] = arr[pivot_index], arr[high] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_recursive(low, high): if low < high: pi = partition(low, high) quick_sort_recursive(low, pi - 1) quick_sort_recursive(pi + 1, high) quick_sort_recursive(0, len(arr) - 1) return arr"},{"question":"# Nearest Neighbor Classification Algorithm Implementation You are given a dataset of multi-dimensional points, where each point has an associated label. The Nearest Neighbor algorithm aims to classify a new point based on its proximity to points in the dataset. Your task is to implement a `nearest_neighbor` function that returns the label of the nearest point from the dataset. Input - A tuple `x` representing the target point, with the same dimensionality as the points in the dataset. - A dictionary `tSet` where keys are tuples representing points, and values are the labels associated with these points. Output - The label of the nearest point from the dataset. Constraints - All points (both the target point `x` and the points in `tSet`) will have the same dimensionality. - The dataset will contain at least one point. Performance Requirement - The time complexity should remain O(n*k), where n is the number of points in the dataset and k is the dimensionality of the points. # Example ```python tSet = { (1.0, 2.0): \'A\', (3.0, 4.0): \'B\', (1.5, 1.8): \'A\', (-1.0, -2.0): \'C\' } x = (0.0, 0.0) print(nearest_neighbor(x, tSet)) # Output should be \'A\' ``` # Implementation ```python def distance(x, y): Calculate the Euclidean distance between vectors x and y. assert len(x) == len(y), \\"The vectors must have the same length\\" sum_of_squares = 0 for i in range(len(x)): sum_of_squares += (x[i] - y[i]) ** 2 return math.sqrt(sum_of_squares) def nearest_neighbor(x, tSet): Find the nearest neighbor of x in the training set tSet. assert isinstance(x, tuple) and isinstance(tSet, dict) current_key = () min_distance = float(\'inf\') for key in tSet: d = distance(x, key) if d < min_distance: min_distance = d current_key = key return tSet[current_key] ``` Points to Consider - Ensure handling of edge cases like equidistant points. - Think about the potential for optimization in larger datasets or higher dimensions. - Make sure your implementation is robust against invalid inputs.","solution":"import math def distance(x, y): Calculate the Euclidean distance between vectors x and y. assert len(x) == len(y), \\"The vectors must have the same length\\" sum_of_squares = 0 for i in range(len(x)): sum_of_squares += (x[i] - y[i]) ** 2 return math.sqrt(sum_of_squares) def nearest_neighbor(x, tSet): Find the nearest neighbor of x in the training set tSet. assert isinstance(x, tuple) and isinstance(tSet, dict) current_key = () min_distance = float(\'inf\') for key in tSet: d = distance(x, key) if d < min_distance: min_distance = d current_key = key return tSet[current_key]"},{"question":"Implement a function `decode_string(s)` that decodes an encoded string according to the specified encoding rule `k[encoded_string]`, where the encoded string inside the square brackets is repeated exactly `k` times. # Function Signature ```python def decode_string(s: str) -> str: ``` # Input * **s (str)**: A valid encoded string which only includes digits, square brackets (`[ ]`), and lowercase English letters. The string is well-formed (matching square brackets, no digits outside repeat counts). # Output * **str**: The decoded string. # Constraints - The input string `s` has a length between 1 and 30,000. - All square brackets are matching and well-formed. - There are no extra white spaces in the string. # Examples Example 1 ```python s = \\"3[a]2[bc]\\" decode_string(s) ``` Output: ```python \\"aaabcbc\\" ``` Example 2 ```python s = \\"3[a2[c]]\\" decode_string(s) ``` Output: ```python \\"accaccacc\\" ``` Example 3 ```python s = \\"2[abc]3[cd]ef\\" decode_string(s) ``` Output: ```python \\"abcabccdcdcdef\\" ``` # Explanation The algorithm processes the input string `s` character by character, using a stack to handle nested patterns: 1. When encountering a digit, accumulate it to form the repeat number `k`. 2. On encountering `[`, push the current string and repeat number onto the stack and reset them. 3. On encountering `]`, pop the stack to get the previous string and repeat number, combine them with the current string, and continue. 4. Append characters directly when they are not part of a repeat pattern. Implement the function considering these operational steps and edge cases.","solution":"def decode_string(s): stack = [] current_num = 0 current_string = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \\"\\" current_num = 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + current_string * num else: current_string += char return current_string"},{"question":"# Problem Description You are given a set of distinct integers, `nums`. Write a function `subsets(nums)` that returns all possible subsets of the given set. The solution set must not contain duplicate subsets. # Function Signature ```python def subsets(nums: List[int]) -> List[List[int]]: pass ``` # Input * `nums`: A list of distinct integers with (0 leq |nums| leq 10). # Output * A list of lists, where each inner list is a possible subset of `nums`. # Constraints * The subsets can be returned in any order. * Ensure that your implementation does not output duplicate subsets. # Example ```python nums = [1, 2, 3] Subsets should be: [ [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3] ] ``` # Performance Requirements * Optimize for clarity and correctness. * Performance will be evaluated based on the ability to handle the upper constraint efficiently. # Context You are designing a solution that needs to evaluate every possible combination of settings or decisions. This problem is a typical use case in scenarios requiring combinatorial data analysis, resource management, and feature selection in machine learning.","solution":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: Returns all possible subsets of the given list of distinct integers. result = [] def backtrack(start, path): # Add the current subset to the result result.append(path[:]) for i in range(start, len(nums)): # Include nums[i] in the current subset and move forward path.append(nums[i]) backtrack(i + 1, path) # Exclude nums[i] from the current subset before moving to the next element path.pop() backtrack(0, []) return result"},{"question":"Coding Assessment Question # Problem Statement You are given a directed graph represented by an adjacency list, and your task is to implement an algorithm that identifies all strongly connected components (SCCs) within this graph using Tarjan\'s Algorithm. # Function Signature ```python def find_strongly_connected_components(adj_list): Given a directed graph\'s adjacency list, returns all SCCs in the graph. :param adj_list: A dictionary representing the graph, where keys are nodes and values are lists of adjacent nodes. :return: A list of lists, where each sublist contains nodes that form a strongly connected component. ``` # Input * `adj_list`: Dictionary where keys are nodes (integers or strings) and values are lists of adjacent nodes. # Output * Return a list of lists where each inner list contains nodes belonging to the same SCC, sorted in ascending order. # Constraints * The graph might contain self-loops and/or disconnected nodes. * Each node and edge will appear in the graph at most once. # Performance Requirements * The solution should have a time complexity of O(V + E) where V is the number of vertices and E is the number of edges in the graph. * Space complexity should be linear in terms of the number of vertices. # Example ```python adj_list = { 1: [2], 2: [3], 3: [1, 4], 4: [], 5: [6], 6: [5] } print(find_strongly_connected_components(adj_list)) # Output: [[1, 2, 3], [4], [5, 6]] ``` # Additional Notes * Ensure that all nodes in the input graph have their SCCs identified correctly. * Consider edge cases such as a graph with no edges, a graph with all nodes having out-degree of zero, and graphs with only self-loops. # Scenario/Context Imagine there is a software system consisting of several modules, where each module depends on several other modules. The dependency graph is represented as a directed graph. To analyze the system, it\'s critical to identify cycles within dependencies, which represent modules that are interdependent on each other. Your task is to use Tarjan\'s algorithm to find these cycles, helping to optimize and maintain the software system better.","solution":"def find_strongly_connected_components(adj_list): Given a directed graph\'s adjacency list, returns all SCCs in the graph. :param adj_list: A dictionary representing the graph, where keys are nodes and values are lists of adjacent nodes. :return: A list of lists, where each sublist contains nodes that form a strongly connected component. index = 0 stack = [] indices = {} lowlinks = {} on_stack = {} sccs = [] def strongconnect(node): nonlocal index indices[node] = index lowlinks[node] = index index += 1 stack.append(node) on_stack[node] = True for neighbor in adj_list.get(node, []): if neighbor not in indices: strongconnect(neighbor) lowlinks[node] = min(lowlinks[node], lowlinks[neighbor]) elif on_stack.get(neighbor, False): lowlinks[node] = min(lowlinks[node], indices[neighbor]) if lowlinks[node] == indices[node]: scc = [] while True: n = stack.pop() on_stack[n] = False scc.append(n) if n == node: break sccs.append(sorted(scc)) for node in adj_list: if node not in indices: strongconnect(node) return sorted(sccs, key=lambda scc: scc[0])"},{"question":"You have been assigned to implement an algorithm that finds the next higher number with the same digits as the given input number. Given a number as input, your task is to find the smallest number that can be formed using the same digits which are larger than the given number. If no such permutation is possible, return `-1`. # Function Signature ```python def next_higher_permutation(num: int) -> int: pass ``` # Input - `num`: An integer between 1 and (10^9). # Output - Returns an integer representing the next higher permutation of the original number\'s digits. - Returns `-1` if no such permutation exists. # Constraints - The input number `num` will contain digits only (0-9) and will be within the range as specified above. # Example 1. `next_higher_permutation(38276)` should return `38627`. 2. `next_higher_permutation(12345)` should return `12354`. 3. `next_higher_permutation(99999)` should return `-1`. 4. `next_higher_permutation(54321)` should return `-1`. # Hints - Consider conversion of the number into a list of digits for easier manipulation. - Identify the rightmost pair of adjacent digits to determine the pivot. - Apply the steps to swap and reverse parts of the number as needed to find the correct permutation. Implement the function `next_higher_permutation(num: int) -> int` and ensure that it meets the provided tests.","solution":"def next_higher_permutation(num: int) -> int: digits = list(str(num)) n = len(digits) # Find the rightmost digit that is smaller than the digit next to it i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If there is no such digit, return -1 as no higher permutation is possible if i == -1: return -1 # Find the smallest digit on right side of (i) and greater than digits[i] j = n - 1 while digits[j] <= digits[i]: j -= 1 # Swap the found digits[d] and digits[i] digits[i], digits[j] = digits[j], digits[i] # Reverse the digits after index i digits = digits[:i + 1] + digits[i + 1:][::-1] # Convert list back to int return int(\\"\\".join(digits))"},{"question":"# Stuttering a Sentence Using a Stack Scenario You are working on an educational tool that helps students understand the behavior of stacks. As part of this, you need to simulate a scenario in which every word in a sentence is repeated consecutively in a stack. For this task, you are given a sentence, and you need to use stacks to duplicate each word. Task Implement a function `stutter_sentence_using_stack(sentence)` that takes a string `sentence` consisting of words separated by spaces. The function should use a stack to duplicate each word consecutively and then return the modified sentence with duplicated words. Input - A single string `sentence` where each word is separated by a single space. Output - A single string in which each word from the input sentence appears twice consecutively, separated by spaces. Constraints - The input string will contain only alphabetic characters and spaces. - No leading, trailing, or consecutive spaces will be present. Example - Input: `\\"hello world good morning\\"` - Output: `\\"hello hello world world good good morning morning\\"` Performance Requirements - Your implementation should use stacks efficiently. - You may use auxiliary data structures if necessary. Implementation Write your implementation below: ```python def stutter_sentence_using_stack(sentence): # Write your solution here pass # Test cases print(stutter_sentence_using_stack(\\"hello world good morning\\")) # Expected output: \\"hello hello world world good good morning morning\\" print(stutter_sentence_using_stack(\\"data structures stacks\\")) # Expected output: \\"data data structures structures stacks stacks\\" ```","solution":"def stutter_sentence_using_stack(sentence): Takes a sentence and duplicates each word using a stack. Returns the modified sentence with each word duplicated. words = sentence.split() stack = [] for word in words: stack.append(word) stack.append(word) return \' \'.join(stack)"},{"question":"# Question You are given the task to analyze a set of numerical data points and compute their frequency distribution. This will help in understanding the occurrence frequency of each distinct element in the dataset, which is a crucial step in data analysis and statistical computation. Your task is to write a function `compute_histogram` that takes a list of integers as input and returns a dictionary representing the histogram of the data. The dictionary should have each unique element of the list as a key, and the count of its occurrences as the corresponding value. # Input * A list of integers `data` (0 <= len(data) <= 10^6). # Output * A dictionary where each key is a unique integer from the list, and the corresponding value is the count of occurrences of that integer. # Constraints * The input list can be very large (up to 1,000,000 elements). * The list may contain negative numbers and duplicates. * The input list may be unsorted. # Example ```python data = [3, 3, 2, 1] # Expected output: {1: 1, 2: 1, 3: 2} data = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Expected output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} data = [] # Expected output: {} ``` # Instructions 1. Write the function `compute_histogram(data: list) -> dict`. 2. Ensure the function performs efficiently given the constraints. 3. Consider edge cases such as an empty list or lists with large numbers of unique elements.","solution":"def compute_histogram(data): Computes the frequency distribution of the list of integers `data`. Parameters: data (list): A list of integers. Returns: dict: A dictionary where each key is a unique integer from the list, and the corresponding value is the count of occurrences of that integer. histogram = {} for number in data: if number in histogram: histogram[number] += 1 else: histogram[number] = 1 return histogram"},{"question":"# Description You are tasked with improving a task scheduling application that manages a large number of tasks with different priorities. The existing implementation of the priority queue uses a linear array for storing tasks, making the insertions slow. Your goal is to implement a more efficient priority queue using a binary heap, which offers better performance for both insertions and extractions. # Requirements 1. Implement a priority queue using a binary heap. 2. The priority queue should support the following operations: - **push(item, priority)**: Insert `item` with the given `priority`. - **pop()**: Remove and return the item with the lowest priority. - **size()**: Return the number of elements in the priority queue. # Input Format - `push(item, priority)`: - `item`: A string representing the task name. - `priority`: An integer representing the task priority (lower values indicate higher priority). - `pop()` and `size()` do not require input parameters. # Output Format - `pop()`: Return the item with the lowest priority. - `size()`: Return an integer indicating the number of items in the priority queue. # Constraints - The priority values will be integers and can be negative, zero, or positive. - The priority queue can contain up to (10^5) elements. - Each `item` will be a string with a maximum length of 100 characters. # Example ```python # Sample Operations pq = PriorityQueue() pq.push(\\"task1\\", 3) pq.push(\\"task2\\", 1) pq.push(\\"task3\\", 2) # Checking the size of the queue print(pq.size()) # Output: 3 # Popping elements based on priority print(pq.pop()) # Output: \\"task2\\" (highest priority) print(pq.pop()) # Output: \\"task3\\" print(pq.pop()) # Output: \\"task1\\" # Checking the size of the queue after pops print(pq.size()) # Output: 0 ```","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def push(self, item, priority): # Push a new item along with its priority into the heap heapq.heappush(self.heap, (priority, item)) def pop(self): # Pop and return the item with the lowest priority if self.heap: return heapq.heappop(self.heap)[1] return None # Return None if the heap is empty def size(self): # Return the number of elements in the priority queue return len(self.heap)"},{"question":"# Find the Longest Substring without Repeating Characters **Objective**: Implement a function that finds and returns the length of the longest substring without repeating characters and the substring itself. **Function Signature**: ```python def longest_unique_substr(string: str) -> (int, str): ``` **Input**: * A single input string `string` containing characters. **Output**: * A tuple containing two elements: 1. An integer representing the length of the longest unique substring. 2. A string representing the longest substring without repeating characters. **Constraints**: 1. The input string can contain any printable ASCII characters. 2. The length of the input string is between 0 and 10^4. 3. If there are multiple substrings with the same maximum length, return the first one encountered. **Examples**: ```python assert longest_unique_substr(\\"abcabcbb\\") == (3, \\"abc\\") assert longest_unique_substr(\\"bbbbb\\") == (1, \\"b\\") assert longest_unique_substr(\\"pwwkew\\") == (3, \\"wke\\") ``` **Notes**: * You should handle cases where the string is empty. * Optimize for performance considering both time and space complexity. **Scenario**: Imagine you\'re developing a component for user input validation where usernames must not have any repeating characters within a certain segment of their name. This function will help in identifying the longest segment of a username that meets this requirement.","solution":"def longest_unique_substr(s: str) -> (int, str): Find the longest substring without repeating characters and return its length and the substring itself. n = len(s) if n == 0: return (0, \\"\\") char_index_map = {} start = 0 max_length = 0 longest_substr = \\"\\" for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end if end - start + 1 > max_length: max_length = end - start + 1 longest_substr = s[start:end+1] return (max_length, longest_substr)"},{"question":"# Problem Context Grace is working with a Binary Search Tree (BST) where each node has a unique integer value. She needs to find the inorder predecessor of a specified node. The inorder predecessor of a node is the node with the greatest value less than the given node\'s value in the entire tree. Given the root of the BST and the target node, implement an efficient solution to determine the inorder predecessor. # Task Write a function `find_inorder_predecessor(root, target)` that returns the inorder predecessor value of the given `target` node. If the `target` node has no predecessor, return `None`. # Input - `root`: The root node of a BST, where each node is an object with attributes `val`, `left`, and `right`. - `target`: The node (object) whose inorder predecessor is to be found. # Output - The value of the inorder predecessor node if it exists, otherwise `None`. # Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_inorder_predecessor(root: TreeNode, target: TreeNode) -> Optional[int]: # Your implementation here pass ``` # Constraints * Each node value is unique. * Assume the `target` node is always part of the tree. * Nodes are implemented using the class `TreeNode`. # Example ```python # Example BST: # 20 # / # 10 30 # / / # 5 15 25 35 root = TreeNode(20, TreeNode(10, TreeNode(5), TreeNode(15)), TreeNode(30, TreeNode(25), TreeNode(35))) target = root.left # Node with value 10 output = find_inorder_predecessor(root, target) print(output) # Should return 5 ``` **Note**: Ensure to handle cases where the `target` node has no predecessor.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_inorder_predecessor(root: TreeNode, target: TreeNode) -> int: predecessor = None current = root while current: if target.val > current.val: predecessor = current current = current.right else: current = current.left if predecessor is None: return None if target.left: predecessor = target.left while predecessor.right: predecessor = predecessor.right return predecessor.val return predecessor.val if predecessor else None"},{"question":"**Problem Statement:** Write a function `int_to_roman(n)` that converts an integer to a Roman numeral. The function should handle inputs within the range from 1 to 3999. The algorithm should utilize efficient look-up tables to perform the conversion. Input * `n` (int): An integer within the range [1, 3999]. Output * (str): The Roman numeral representation of the input integer. Example ```python print(int_to_roman(9)) # Output: \\"IX\\" print(int_to_roman(58)) # Output: \\"LVIII\\" print(int_to_roman(1994)) # Output: \\"MCMXCIV\\" ``` Constraints 1. 1 ≤ n ≤ 3999. Requirements 1. The solution must run in constant time, (O(1)). 2. Use predefined lists for thousands, hundreds, tens, and ones places to assemble the final Roman numeral string. Guidelines: * You should handle both edge cases and normal cases adequately. * Aim for clarity and maintainability in your code. * Do not use any built-in conversion libraries. **Additional Context:** Roman numerals do not have a standard representation for zero or negative numbers. Ensure your function gracefully handles input validation. ```python def int_to_roman(n): # Your code goes here pass # Example usage: print(int_to_roman(9)) # Output: \\"IX\\" print(int_to_roman(58)) # Output: \\"LVIII\\" print(int_to_roman(1994)) # Output: \\"MCMXCIV\\" ```","solution":"def int_to_roman(n): Converts an integer to a Roman numeral. Args: n (int): An integer within the range [1, 3999]. Returns: (str): The Roman numeral representation of the input integer. if not (1 <= n <= 3999): raise ValueError(\\"Input must be in the range 1 to 3999\\") # Define the Roman numeral mappings thousands = [\\"\\", \\"M\\", \\"MM\\", \\"MMM\\"] hundreds = [\\"\\", \\"C\\", \\"CC\\", \\"CCC\\", \\"CD\\", \\"D\\", \\"DC\\", \\"DCC\\", \\"DCCC\\", \\"CM\\"] tens = [\\"\\", \\"X\\", \\"XX\\", \\"XXX\\", \\"XL\\", \\"L\\", \\"LX\\", \\"LXX\\", \\"LXXX\\", \\"XC\\"] ones = [\\"\\", \\"I\\", \\"II\\", \\"III\\", \\"IV\\", \\"V\\", \\"VI\\", \\"VII\\", \\"VIII\\", \\"IX\\"] # Build the Roman numeral using the lookup tables roman = ( thousands[n // 1000] + hundreds[n % 1000 // 100] + tens[n % 100 // 10] + ones[n % 10] ) return roman"},{"question":"# Question: Segment Tree with Ranges You are tasked with implementing a `SegmentTree` class explicitly geared towards efficient range queries using a dynamic operation (sum, min, max, etc.). Your implementation should allow the creation of the segment tree from an input array and support query operations in logarithmic time. The purpose is to assess your understanding of segment trees and your ability to handle various combinations of range queries. # Function Signature: ```python class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]): pass def query(self, left: int, right: int) -> int: pass # Example usage: array = [2, 4, 5, 3, 4] seg_tree_max = SegmentTree(array, max) print(seg_tree_max.query(2, 4)) # Output: 5 print(seg_tree_max.query(0, 3)) # Output: 5 seg_tree_sum = SegmentTree([4, 5, 2, 3, 4, 43, 3], sum) print(seg_tree_sum.query(1, 5)) # Output: 57 ``` # Input: * `arr` : List of integers : Elements to build the segment tree upon. * `function`: A function to apply in order to combine elements (sum, min, max, etc). # Output: * The `query` function should return the result of applying the `function` on the specified range (using zero-based indexing). # Constraints: * The input array length ( N ) will be between 1 and ( 10^5 ). * Values in the input array will be between (-10^9) and ( 10^9). * Query will always be within valid range indices of the array. # Points to consider: * Handle edge cases where query ranges could be single elements or entire array. * Ensure the SegmentTree class is efficient both in time (logarithmic queries) and space (linear storage). * Validate understanding of segment tree construction, range queries, and function use cases. Make sure your code passes example test cases and handles potential pitfalls common with such data structures.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.tree = [None] * (2 * self.n) self.function = function # Build the tree # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, left, right): # Adjust the input indices to the tree indices left += self.n right += self.n res = None while left <= right: if left % 2 == 1: if res is None: res = self.tree[left] else: res = self.function(res, self.tree[left]) left += 1 if right % 2 == 0: if res is None: res = self.tree[right] else: res = self.function(res, self.tree[right]) right -= 1 left //= 2 right //= 2 return res"},{"question":"# Filter Data by Value **Scenario**: You are working on a data processing application where incoming data values must be filtered to ensure they fall within a specified range. The data is represented in a list of integers, and for data validation purposes, you need to extract all values that fall within a specific minimum and maximum limit. **Objective**: Write a function `filter_by_value` that takes an input list of integers and filters out only those values that fall within a specified range (inclusive). # Function Signature ```python def filter_by_value(arr: list, min_val: int = None, max_val_int: int = None) -> list: pass ``` # Input * `arr`: A list of integers (1 <= len(arr) <= 10^6). * `min_val`: An integer representing the minimum limit (inclusive). Can be `None`, in which case no minimum limit is considered. * `max_val`: An integer representing the maximum limit (inclusive). Can be `None`, in which case no maximum limit is considered. # Output * Returns a list of integers that fall within the specified range [min_val, max_val]. # Constraints * If `min_val` and `max_val` are both `None`, return the entire input list. * If the array is empty, return an empty array. * Consider only integers for both minimum and maximum limits. # Example ```python # Example 1: input_arr = [1, 2, 3, 4, 5] min_val = 2 max_val = 4 output = filter_by_value(input_arr, min_val, max_val) # Output: [2, 3, 4] # Example 2: input_arr = [10, 20, 30, 40, 50] min_val = None max_val = 30 output = filter_by_value(input_arr, min_val, max_val) # Output: [10, 20, 30] # Example 3: input_arr = [5, 15, 25, 35, 45] min_val = 100 max_val = 200 output = filter_by_value(input_arr, min_val, max_val) # Output: [] ``` # Notes * Ensure that the code handles edge cases properly as described. * Pay attention to performance as the input array may be very large.","solution":"def filter_by_value(arr: list, min_val: int = None, max_val: int = None) -> list: filtered_list = [] for value in arr: if (min_val is None or value >= min_val) and (max_val is None or value <= max_val): filtered_list.append(value) return filtered_list"},{"question":"# **Problem Statement** You are given a list of integers. You need to sort the list using an algorithm suitable for when the number of distinct values in the list is relatively low and close in range. Implement the Pigeonhole Sort algorithm to sort the given list. # **Function Signature** ```python def pigeonhole_sort(arr: list) -> list: ``` # **Input** - A list of integers, `arr` where (1 leq |arr| leq 10^5) and (-10^5 leq arr[i] leq 10^5 ). # **Output** - Return a sorted list of integers. # **Constraints** - The integers in the list are between (-10^5) and (10^5). - The length of the list can be up to (10^5). # **Examples** ```python assert pigeonhole_sort([8, 3, 5, 3, 8, 1]) == [1, 3, 3, 5, 8, 8] assert pigeonhole_sort([9, 8, 7, 6, 5, 3]) == [3, 5, 6, 7, 8, 9] assert pigeonhole_sort([0, 0, 0, 0]) == [0, 0, 0, 0] assert pigeonhole_sort([]) == [] ``` # **Explanation** 1. **Example 1**: The input list `[8, 3, 5, 3, 8, 1]` after sorting becomes `[1, 3, 3, 5, 8, 8]`. 2. **Example 2**: The input list `[9, 8, 7, 6, 5, 3]` after sorting becomes `[3, 5, 6, 7, 8, 9]`. 3. **Example 3**: The input list `[0, 0, 0, 0]` contains all same elements, thus remains `[0, 0, 0, 0]`. 4. **Example 4**: An empty list remains empty after sorting, `[]`. # **Guidelines** - Handle edge cases such as empty lists or lists with very large ranges. - Ensure the algorithm runs efficiently within the provided constraints, especially focusing on time and auxiliary space complexities.","solution":"def pigeonhole_sort(arr: list) -> list: if not arr: return [] min_value = min(arr) max_value = max(arr) size = max_value - min_value + 1 holes = [[] for _ in range(size)] for number in arr: holes[number - min_value].append(number) sorted_arr = [] for hole in holes: sorted_arr.extend(hole) return sorted_arr"},{"question":"# Question: Flatten Nested Lists You are given the task of writing two functions to flatten nested arrays (or lists) in Python. Arrays may contain other arrays, and so forth to any level. Write two functions: 1. `flatten(input_arr)`: This function takes a nested list and returns a single, flat list containing all the elements from the nested lists. 2. `flatten_iter(iterable)`: This function takes a nested iterable and returns a generator that produces a single sequence of all elements in the nested iterables. The functions should handle various types of nested iterables correctly. **Function Specifications:** 1. **Function:** `flatten(input_arr)` - **Input:** A nested list, where elements can be integers, strings, or other lists. - **Output:** A flat list containing all elements from the nested lists. - **Constraints:** - You may assume that the maximum depth of nesting is manageable within the recursion limit. 2. **Function:** `flatten_iter(iterable)` - **Input:** A nested iterable that can contain mixtypes of iterables and other elements. - **Output:** A generator that yields elements from the nested iterables in a flattened structure. - **Constraints:** - You should handle any depth of nested iterables efficiently. **Example Usage:** ```python # Example input for flatten nested_list = [1, [2, [3, 4]], [5, 6], 7] print(flatten(nested_list)) # Output: [1, 2, 3, 4, 5, 6, 7] # Example input for flatten_iter nested_iterable = [1, [2, [3, [4, 5], 6], 7], [8], 9] print(list(flatten_iter(nested_iterable))) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` **Performance Requirements:** - Ensure that the `flatten` function executes within a reasonable time for nested lists containing up to 10^5 elements in total. - The `flatten_iter` function should be memory efficient and able to handle very large nested structures by yielding elements one at a time. Consider edge cases such as empty arrays, arrays with only one type of element, and very deep nesting. Ensure that your code handles strings correctly within the nested arrays.","solution":"from collections.abc import Iterable def flatten(input_arr): Flattens a nested list into a single list. :param input_arr: A nested list. :return: A flat list containing all elements from input_arr. flat_list = [] for item in input_arr: if isinstance(item, list): flat_list.extend(flatten(item)) else: flat_list.append(item) return flat_list def flatten_iter(iterable): Flattens a nested iterable into a single sequence of elements. :param iterable: A nested iterable. :return: A generator yielding elements from the nested iterables. for item in iterable: if isinstance(item, Iterable) and not isinstance(item, (str, bytes)): yield from flatten_iter(item) else: yield item"},{"question":"# Graph Pathfinding Challenge **Objective**: Implement a function that determines pathfinding in a graph with specific constraints. The function should find the longest path from a given start node to an end node. # Function Signature You need to implement the following function: ```python def find_longest_path(graph, start, end): Find the longest path between two nodes in the graph. Parameters: graph (dict): adjacency list representing the graph, where keys are nodes and values are lists of adjacent nodes. start: The starting node. end: The ending node. Returns: list: A list of nodes representing the longest path from start to end. If no path exists, return an empty list. pass ``` # Input * `graph`: A dictionary where keys are node identifiers (might be `int` or `str`) and values are lists of adjacent nodes. * `start`, `end`: `start` is the node where the path should begin, and `end` is the node where the path should end. Nodes can be any hashable type (int, str). # Output * A list representing the longest path from `start` to `end`. If there is no path from `start` to `end`, return an empty list. # Constraints * Handle both cyclic and acyclic graphs. * Nodes in the path should be distinct, with no repeated nodes. # Performance Requirements * The solution should be optimized to handle reasonably large graphs effectively. * Consider time and space complexity while designing the solution. # Edge Cases to Consider * The graph is empty. * The start or end nodes do not exist in the graph. * No path exists between the start and end nodes. * The graph contains cycles. # Example ```python graph = { \'A\': [\'B\', \'C\', \'D\'], \'B\': [\'E\'], \'C\': [\'F\'], \'D\': [\'G\'], \'E\': [\'H\'], \'F\': [\'I\'], \'G\': [\'J\'], \'H\': [\'K\'], \'I\': [], \'J\': [], \'K\': [] } print(find_longest_path(graph, \'A\', \'K\')) # Expected Output: [\'A\', \'B\', \'E\', \'H\', \'K\'] print(find_longest_path(graph, \'A\', \'I\')) # Expected Output: [\'A\', \'C\', \'F\', \'I\'] print(find_longest_path(graph, \'A\', \'Z\')) # Expected Output: [] ``` # Notes * Ensure that your solution properly handles large graph traversal and optimizes the recursive calls to avoid excessive stack depth or time inefficiency. * Proper backtracking should be done to explore different paths and select the longest one.","solution":"def find_longest_path(graph, start, end): Find the longest path between two nodes in the graph. Parameters: graph (dict): adjacency list representing the graph, where keys are nodes and values are lists of adjacent nodes. start: The starting node. end: The ending node. Returns: list: A list of nodes representing the longest path from start to end. If no path exists, return an empty list. def dfs(current, end, path, visited): if current == end: return path longest = [] for neighbor in graph.get(current, []): if neighbor not in visited: new_path = dfs(neighbor, end, path + [neighbor], visited | {neighbor}) if len(new_path) > len(longest): longest = new_path return longest if start not in graph or end not in graph: return [] return dfs(start, end, [start], {start})"},{"question":"# Problem: Advanced Radix Sort Implementation Context: Given that radix sort is powerful for sorting large lists of non-negative integers, we need to enhance its functionality to handle integers with leading negative values efficiently. Task: Write a function `enhanced_radix_sort(arr: List[int]) -> List[int]` that sorts an input list of integers, including both negative and non-negative values. You need to account for varied digit lengths and ensure stability with negative values being sorted correctly. The function should be optimized to handle typical edge cases and performance bottlenecks efficiently. Function Signature: ```python def enhanced_radix_sort(arr: List[int]) -> List[int]: ``` Input: - `arr`: A list of integers `arr` where each integer can be negative or non-negative. Output: - A sorted list of integers in ascending order. Constraints: - The list can contain up to 10^6 elements. - Each integer in the list will be within the range of -10^9 to 10^9. # Requirements: 1. **Efficiency:** The implementation should aim to have a linearithmic time complexity. 2. **Edge Cases:** Handle arrays with negative numbers, large values, empty arrays, and arrays with repeated elements. 3. **Stable Sorting:** Ensure stability of sorting during digit extraction and insertion phases to avoid altering the original order of equal elements. # Example: ```python assert enhanced_radix_sort([170, 45, 75, -90, -802, 24, 2, 66]) == [-802, -90, 2, 24, 45, 66, 75, 170] assert enhanced_radix_sort([]) == [] assert enhanced_radix_sort([-1, -1, -1, 3, 3, 3]) == [-1, -1, -1, 3, 3, 3] ```","solution":"def enhanced_radix_sort(arr): Enhanced Radix Sort to handle both positive and negative numbers. if not arr: return arr # Separate positive and negative values pos_arr = [num for num in arr if num >= 0] neg_arr = [-num for num in arr if num < 0] # Perform radix sort on positive and negative arrays sorted_pos = radix_sort(pos_arr) sorted_neg = radix_sort(neg_arr) # Combine sorted negative array (reversed and converted back to negative) # with sorted positive array return [-num for num in reversed(sorted_neg)] + sorted_pos def radix_sort(arr): Performs radix sort on a list of non-negative integers. if not arr: return arr max_num = max(arr) exp = 1 while max_num // exp > 0: counting_sort(arr, exp) exp *= 10 return arr def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in arr: index = (i // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 for i in range(n): arr[i] = output[i]"},{"question":"# Question: You are given an array of integers and need to filter this array such that it only contains values within a specified range. This is particularly useful for processing large datasets to exclude outliers or data outside of a required range. Function Signature: ```python def range_filter(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: pass ``` Input: * `arr`: A list of integers `[int, int, ...]`, `[-10^6 <= int <= 10^6]`. * `min_lim`: An optional integer specifying the minimum limit (`int`), or `None` to indicate no lower limit. * `max_lim`: An optional integer specifying the maximum limit (`int`), or `None` to indicate no upper limit. Output: * Returns a list of integers that are greater than or equal to `min_lim` and less than or equal to `max_lim`. Constraints: * If `min_lim` is `None`, no lower limit should be applied. * If `max_lim` is `None`, no upper limit should be applied. * The array can have up to `10^6` elements. Example: ```python # Example 1: print(range_filter([1, 2, 3, 4, 5], None, 3)) # Output: [1, 2, 3] # Example 2: print(range_filter([1, 2, 3, 4, 5], 2, None)) # Output: [2, 3, 4, 5] # Example 3: print(range_filter([1, 2, 3, 4, 5], 2, 4)) # Output: [2, 3, 4] # Example 4: print(range_filter([], 1, 3)) # Output: [] # Example 5: print(range_filter([-10, 0, 10, 20], -5, 15)) # Output: [0, 10] ``` Requirements: - Ensure the function runs efficiently and can handle large lists up to `10^6` elements. - Carefully consider edge cases such as empty arrays or all values being out of the range.","solution":"from typing import List, Optional def range_filter(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: Filters the array `arr` such that it only contains values within the specified range [min_lim, max_lim]. If min_lim is None, no lower bound is considered. If max_lim is None, no upper bound is considered. if min_lim is None and max_lim is None: return arr elif min_lim is None: return [x for x in arr if x <= max_lim] elif max_lim is None: return [x for x in arr if x >= min_lim] else: return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Question You are tasked with enhancing a Markov Chain implementation, specifically modifying the `iterating_markov_chain` function to include a stopping criterion. Instead of running indefinitely, this function should now take an additional parameter, `steps`, that dictates the number of transitions to perform. After `steps` transitions, the function should return a list of the visited states. Function Signature ```python def iterating_markov_chain(chain: dict, initial_state: str, steps: int) -> list: pass ``` Input - `chain` (dict): A dictionary representing the Markov chain where key is the current state and value is another dictionary representing the next state along with their transition probabilities. - `initial_state` (str): The state from which the iterations should begin. - `steps` (int): The number of transitions to perform. Output - List of states (list): A list of states visited in order. Constraints - The `chain` dictionary is non-empty and probabilities in state mappings always sum up to 1. - `steps` is a positive integer. Example Given the following Markov chain: ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } ``` And the initial state \'A\' with steps = 5, the function should return a list of 5 states, for example: ``` [\'A\', \'E\', \'A\', \'A\', \'A\'] ``` Note: The exact order of states may vary due to the stochastic nature of Markov Chains. Performance Requirements The function should efficiently handle up to 10,000 steps and chains with up to 100 states.","solution":"import random def iterating_markov_chain(chain: dict, initial_state: str, steps: int) -> list: Simulates a Markov chain for a given number of steps starting from an initial state. Args: chain (dict): A dictionary representing the Markov chain where key is the current state and value is another dictionary representing the next state along with their transition probabilities. initial_state (str): The state from which the iterations should begin. steps (int): The number of transitions to perform. Returns: list: A list of states visited in order. current_state = initial_state visited_states = [current_state] for _ in range(steps): current_state = next_state(chain, current_state) visited_states.append(current_state) return visited_states def next_state(chain, current_state): Determines the next state in the Markov chain based on the current state and transition probabilities. Args: chain (dict): The Markov chain represented as a dictionary. current_state (str): The current state in the chain. Returns: str: The next state. next_state_probs = chain[current_state] states = list(next_state_probs.keys()) probabilities = list(next_state_probs.values()) next_state = random.choices(states, probabilities)[0] return next_state"},{"question":"You are tasked with implementing a highly efficient function to find the longest common prefix among an array of strings. You need to use the \\"Divide and Conquer\\" strategy to enhance performance for large datasets. # Function Signature ```python def longest_common_prefix(strings: List[str]) -> str: pass ``` # Input * `strings`: A list of strings `(0 <= len(strings) <= 10^3)` # Output * A single string which represents the longest common prefix. # Constraints * Each string in `strings` can have a length between `1` and `200`. * Strings consist of only lowercase English letters. # Examples ```python assert longest_common_prefix([\\"flower\\",\\"flow\\",\\"flight\\"]) == \\"fl\\" assert longest_common_prefix([\\"dog\\",\\"racecar\\",\\"car\\"]) == \\"\\" assert longest_common_prefix([\\"interview\\",\\"intermediate\\",\\"internal\\"]) == \\"inter\\" ``` # Performance Requirements * Your solution should handle the upper edge of constraints efficiently, ensuring optimized divide and conquer operations. # Scenario Imagine you are building an auto-completion feature for a search engine. Each time a user starts typing, the engine needs to suggest common search queries that share the same starting characters. The provided list of strings represents previous searches, and you need to efficiently find the longest common prefix.","solution":"from typing import List def longest_common_prefix(strings: List[str]) -> str: if not strings: return \\"\\" def common_prefix(str1, str2): min_length = min(len(str1), len(str2)) for i in range(min_length): if str1[i] != str2[i]: return str1[:i] return str1[:min_length] def divide_and_conquer(start, end): if start == end: return strings[start] mid = (start + end) // 2 left_prefix = divide_and_conquer(start, mid) right_prefix = divide_and_conquer(mid + 1, end) return common_prefix(left_prefix, right_prefix) return divide_and_conquer(0, len(strings) - 1)"},{"question":"Context: Exchange Sort is a basic sorting algorithm that involves comparing each pair of elements and swapping them if they are in the wrong order. Although simple, it is inefficient for sorting large arrays due to its quadratic time complexity. Problem Statement: Given an array of integers, implement a sorting function using Exchange Sort to sort the array in ascending order. Function Signature: ```python def exchange_sort(arr: list) -> list: pass ``` Input: * `arr` (list of int): A list of integers to be sorted. * `1 <= len(arr) <= 1000` * `-10^6 <= arr[i] <= 10^6` for all valid `i`. Output: * The function should return a new list of integers sorted in ascending order. Examples: ```python assert exchange_sort([4, 2, 5, 1, 3]) == [1, 2, 3, 4, 5] assert exchange_sort([10, -1, 2, 5, 0]) == [-1, 0, 2, 5, 10] assert exchange_sort([1]) == [1] assert exchange_sort([]) == [] assert exchange_sort([2, 3, 2, 1]) == [1, 2, 2, 3] ``` Constraints: * Implement the function using the Exchange Sort algorithm. * Ensure the function handles edge cases such as empty lists and lists with duplicate elements. Instructions: 1. Write the `exchange_sort` function without using built-in sort functions. 2. Ensure that your implementation follows the Exchange Sort mechanism. 3. Optimize for correctness and clarity rather than performance.","solution":"def exchange_sort(arr: list) -> list: Sorts a list of integers in ascending order using Exchange Sort algorithm. n = len(arr) for i in range(n-1): for j in range(i+1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Scenario In many projects, converting a relative file path or a path using the `~` shortcut into an absolute path is a common requirement. For instance, when dealing with file operations, it\'s crucial to have absolute paths to avoid ambiguities and potential errors. # Objective Write a function `full_path` that takes a single argument, `file`, representing a file path, and returns its absolute path. Your implementation should handle user directory shortcuts (e.g., `~`) and relative paths correctly. # Function Signature ```python def full_path(file: str) -> str: pass ``` # Input * `file` (str): A file path, which could be relative, absolute, or using the home directory shortcut `~`. # Output * (str): The absolute path corresponding to the input file path. # Constraints * The input will be a valid string. * Assume the environment supports standard path formats and expansions. # Requirements * You must use the `os.path` module to perform path resolution. * Your solution should handle typical edge cases such as: * Already absolute paths. * Paths that contain `~` for the home directory. * Paths with relative components like `.` and `..`. # Example ```python print(full_path(\\"~/Documents/project.txt\\")) # Should print an absolute path like \\"/home/username/Documents/project.txt\\" print(full_path(\\"../project.txt\\")) # Depending on the current directory, should print an absolute path like \\"/home/username/project.txt\\" ``` # Performance While the typical use cases involve short to moderately long file paths, your logic should be efficient and accurate even for longest conceivable valid file paths.","solution":"import os def full_path(file: str) -> str: Given a file path, return its absolute path. Handles \'~\' for home directory and relative paths. # Expanding the \'~\' to the full home directory if present expanded_path = os.path.expanduser(file) # Converting the path to an absolute path absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"# Background Context You are required to enhance a library that manages a collection of data organized in a Binary Search Tree (BST). Specifically, you need to add functionality to retrieve the in-order predecessor of a given node. This feature is essential in various operations, including tree balancing and deletion algorithms. # Task Implement a function `find_predecessor(root, node)` that finds the predecessor of a given node in a BST. # Function Signature ```python def find_predecessor(root: TreeNode, node: TreeNode) -> Optional[TreeNode]: pass ``` # Input and Output Formats - **Input**: - `root`: The root node of the BST, defined by the `TreeNode` class. - `node`: A node in the BST for which the predecessor is to be found. - **Output**: - Return the predecessor node of the given `node`. If no predecessor exists (i.e., the given `node` is the smallest or the tree is empty), return `None`. # Constraints - Each node has a unique value determined by the BST properties. - The BST can contain up to 10^5 nodes. - The function should aim for O(h) time complexity where h is the height of the tree. # Example ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Usage root = TreeNode(20) root.left = TreeNode(10) root.right = TreeNode(30) root.left.left = TreeNode(5) root.left.right = TreeNode(15) node = root.left.right # Node with value 15 # Expected Output: Node with value 10 assert find_predecessor(root, node) == root.left ``` Implement the function based on the provided signature, ensuring that it adheres to the constraints and handles edge cases.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_predecessor(root: TreeNode, node: TreeNode) -> TreeNode: Finds in-order predecessor of the given node in BST. predecessor = None # If left subtree exists, the predecessor is the rightmost node of the left subtree. if node.left: predecessor = node.left while predecessor.right: predecessor = predecessor.right return predecessor # Otherwise, traverse from root to the given node, tracking the last node where we turned right current = root while current: if node.val > current.val: predecessor = current current = current.right elif node.val < current.val: current = current.left else: break return predecessor"},{"question":"Problem Statement Implement a Python function that increments a large non-negative number represented as a list of digits by one. The function should handle digits stored in big-endian format, where the most significant digit is at the head of the list. **Function Signature**: ```python def increment_number(digits: List[int]) -> List[int]: ... ``` Input * A list of integers `digits` such that each element of the list represents a single digit of the number (0 <= digits[i] <= 9). Output * A list `result` representing the digits of the number after incrementing it by one. Constraints * The list should not contain leading zeros, except for the number zero itself. * The function should modify the given list in-place or return a new list with the correct result. * Do not use any built-in big number libraries to handle the computation. Example ```python # Example 1 digits = [1, 2, 3] # Explanation: The number is 123, and after incrementing by one, it becomes 124. print(increment_number(digits)) # Output: [1, 2, 4] # Example 2 digits = [9, 9, 9] # Explanation: The number is 999, and after incrementing by one, it becomes 1000. print(increment_number(digits)) # Output: [1, 0, 0, 0] # Example 3 digits = [0] # Explanation: The number is 0, and after incrementing by one, it becomes 1. print(increment_number(digits)) # Output: [1] ``` **Note**: Ensure to handle edge cases efficiently and consider performance requirements as the input size can be very large.","solution":"def increment_number(digits): Increments a large non-negative number represented as a list of digits by one. n = len(digits) # Traverse from the end of the list for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits else: digits[i] = 0 # If all digits are 9, we need an additional digit at the beginning return [1] + digits"},{"question":"# ZigZag Iterator with Multiple Lists Context You are tasked with creating a generalized ZigZag Iterator that can handle iterating over multiple lists in an alternating fashion. This will combine elements from several lists, switching between them as you iterate. Objective Implement a class `ZigZagIterator` that initializes with a list of lists (2D list) and provides two methods, `next()` and `has_next()`, to fetch elements in a zigzag manner. Function Signature ```python class ZigZagIterator: def __init__(self, vecs: List[List[int]]): Initialize the iterator with multiple lists. :type vecs: List[List[int]] def next(self) -> int: Fetch the next element in zigzag order. Returns: int: The next element. def has_next(self) -> bool: Check if there are more elements to be fetched. Returns: bool: True if more elements are available, False otherwise. ``` Requirements * The `__init__` method should initialize the iterator with multiple lists. * The `next` method should return the next element in zigzag order. * The `has_next` method should return `True` if there are more elements remaining; otherwise, `False`. * You may assume all input lists contain non-negative integers and the total number of elements across all lists will not exceed 10^4. Example ```python vecs = [ [1, 2, 3], [4, 5, 6, 7], [8, 9] ] iterator = ZigZagIterator(vecs) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) # Expected Output: [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` Constraints * Ensure the solution runs efficiently with respect to both time and space complexity.","solution":"from collections import deque from typing import List class ZigZagIterator: def __init__(self, vecs: List[List[int]]): Initialize the iterator with multiple lists. :type vecs: List[List[int]] self.queue = deque((v for v in vecs if v)) self.indexes = {id(v): 0 for v in vecs} def next(self) -> int: Fetch the next element in zigzag order. Returns: int: The next element. if self.has_next(): current_vec = self.queue.popleft() idx = self.indexes[id(current_vec)] value = current_vec[idx] if idx + 1 < len(current_vec): self.indexes[id(current_vec)] = idx + 1 self.queue.append(current_vec) return value else: raise Exception(\\"No more elements to iterate.\\") def has_next(self) -> bool: Check if there are more elements to be fetched. Returns: bool: True if more elements are available, False otherwise. return bool(self.queue)"},{"question":"You are given a large dataset that contains repeated characters which you need to transmit over a limited-bandwidth communication channel. To effectively achieve this, you decide to implement a run-length encoding algorithm to compress the string before transmission and decompress it upon reception. # Task Implement two functions: 1. **encode_rle(input: str) -> str**: Takes a string as input and returns the run-length encoded string. 2. **decode_rle(input: str) -> str**: Takes a run-length encoded string as input and returns the decoded original string. # Input and Output * The encoding function `encode_rle` should take a string (input) and output a string (compressed). * The decoding function `decode_rle` should take a run-length encoded string (input) and output a string (decompressed). # Constraints 1. The input string for the `encode_rle` function will only contain uppercase and lowercase alphabets. 2. The encoded string for the `decode_rle` function will only contain numeric digits followed by uppercase or lowercase alphabetic characters. # Examples Example 1: **Input**: encode_rle(\\"aaabbbccc\\") **Output**: \\"3a3b3c\\" Example 2: **Input**: decode_rle(\\"3a3b3c\\") **Output**: \\"aaabbbccc\\" Example 3: **Input**: encode_rle(\\"a\\") **Output**: \\"1a\\" Example 4: **Input**: decode_rle(\\"10a\\") **Output**: \\"aaaaaaaaaa\\" # Explanation * In example 1, the string \\"aaabbbccc\\" is compressed into \\"3a3b3c\\" by counting consecutive repeated characters. * In example 2, the encoded string \\"3a3b3c\\" is decompressed back to \\"aaabbbccc\\". * In example 3, a single character is represented by its count followed by the character itself. * In example 4, the count `10` indicates ten of \'a\' are to be constructed.","solution":"def encode_rle(input: str) -> str: Encodes a given string using Run-Length Encoding. if not input: return \\"\\" encoded_str = [] count = 1 previous_char = input[0] for char in input[1:]: if char == previous_char: count += 1 else: encoded_str.append(f\\"{count}{previous_char}\\") previous_char = char count = 1 # append the last run encoded_str.append(f\\"{count}{previous_char}\\") return \'\'.join(encoded_str) def decode_rle(input: str) -> str: Decodes a given Run-Length Encoded string. if not input: return \\"\\" decoded_str = [] count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded_str.append(char * int(count)) count = \\"\\" return \'\'.join(decoded_str)"},{"question":"# Anagram Verification Function As a part of a text processing library, you are required to write a function that checks if two given strings are anagrams of each other. An anagram is formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. # Function Signature ```python def is_anagram(s: str, t: str) -> bool: ``` # Input Parameters * **s**: a string containing only lowercase alphabets (1 <= len(s) <= 10^4). * **t**: a string containing only lowercase alphabets (1 <= len(t) <= 10^4). # Output * **bool**: Returns `True` if `t` is an anagram of `s`, otherwise `False`. # Constraints * Both strings will contain only lowercase English letters (\'a\' to \'z\'). * Your solution should be efficient in terms of time complexity, ideally O(n), where n is the length of the strings. # Example ```python assert is_anagram(\\"listen\\", \\"silent\\") == True assert is_anagram(\\"triangle\\", \\"integral\\") == True assert is_anagram(\\"apple\\", \\"pale\\") == False assert is_anagram(\\"rat\\", \\"car\\") == False assert is_anagram(\\"\\", \\"\\") == True ``` # Additional Requirements 1. Consider edge cases such as empty strings and strings of different lengths. 2. Optimize to use minimal memory while ensuring the correct result efficiently. Write the function `is_anagram` that implements this anagram check based on the provided requirements and examples.","solution":"from collections import Counter def is_anagram(s: str, t: str) -> bool: Returns True if t is an anagram of s, else returns False. return Counter(s) == Counter(t)"},{"question":"You are given two equal length one-dimensional lists of integers or floats representing vector components. Your task is to write a function `calculate_angular_distance(vec1, vec2)` that calculates the angular distance between the two vectors. The angular distance is defined as the arccosine (inverse cosine) of the cosine similarity of the two vectors, expressed in radians. # Function Signature ```python def calculate_angular_distance(vec1: list, vec2: list) -> float: ``` # Input - `vec1`: A list of integers or floats. - `vec2`: A list of integers or floats. Must be of the same length as `vec1`. # Output - Returns a float value representing the angular distance in radians. # Constraints - Both `vec1` and `vec2` will have a length `n` where `1 <= n <= 10^4`. - All elements in `vec1` and `vec2` will be in the range of `-10^9` to `10^9`. # Example ```python # Example 1 vec1 = [1, 1, 1] vec2 = [1, 2, -1] print(calculate_angular_distance(vec1, vec2)) # Expected output: 1.0799136482258955 # Example 2 vec1 = [0, 1] vec2 = [1, 0] print(calculate_angular_distance(vec1, vec2)) # Expected output: 1.5707963267948966 ``` # Notes - Use the `math.acos` function from the math module to compute the arccosine. - Reuse the previous `cosine_similarity` function, ensuring that edge cases (such as vectors leading to division by zero) are appropriately handled. - Consider scenarios where elements might lead to precision issues with floating-point operations.","solution":"import math def calculate_angular_distance(vec1, vec2): def dot_product(v1, v2): return sum(x * y for x, y in zip(v1, v2)) def magnitude(v): return math.sqrt(sum(x ** 2 for x in v)) # Calculate dot product and magnitudes of vectors dot = dot_product(vec1, vec2) mag1 = magnitude(vec1) mag2 = magnitude(vec2) # Ensure we do not divide by zero if mag1 == 0 or mag2 == 0: raise ValueError(\\"One of the vectors has zero magnitude\\") # Calculate cosine similarity cosine_similarity = dot / (mag1 * mag2) # Ensure the cosine similarity is within the range [-1, 1] to avoid math domain errors cosine_similarity = max(min(cosine_similarity, 1), -1) # Return the angular distance return math.acos(cosine_similarity)"},{"question":"As a city planner, you are tasked with managing a dynamically growing city grid where parcels of land can turn into islands as they get developed, potentially connecting with adjacent parcels to form larger islands. Your task is to implement a function that simulates this process and keeps track of the number of islands after each development. **Function Signature**: ```python def num_islands(positions: List[List[int]]) -> List[int]: ``` **Input**: - `positions`: A list of lists containing pairs of integers, where each pair represents the coordinates (row, col) of a new land addition in a 2D grid. **Output**: - A list of integers representing the number of islands after each land addition. **Constraints**: - The grid is initially filled with water (represented implicitly, so positions only contain land additions). - An island is formed by connecting adjacent lands horizontally or vertically, but not diagonally. - The coordinates provided are all valid and within reasonable ranges. **Example**: ```python positions = [[0, 0], [0, 1], [1, 2], [2, 1]] print(num_islands(positions)) # Output: [1, 1, 2, 3] ``` **Scenario**: You are given a 2D grid where initially all cells are water. Each position in the `positions` list represents a location where land will be developed. After each land addition, determine the number of distinct islands formed in the grid. Implement the Union-Find data structure to manage and merge sets representing these cells effectively. **Performance Requirements**: Ensure your implementation handles up to a few thousand operations efficiently, leveraging appropriate optimizations like path compression and union by size/rank for near-constant time union-find operations. **Tip**: Consider creating a helper class similar to the `Union` from the provided snippet to manage the union-find operations for the grid-based problem. Ensure you update the island count correctly after each land addition by checking and merging adjacent cells.","solution":"from typing import List class UnionFind: def __init__(self): self.parent = {} self.rank = {} self.count = 0 def add(self, p): if p in self.parent: return self.parent[p] = p self.rank[p] = 0 self.count += 1 def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def get_count(self): return self.count def num_islands(positions: List[List[int]]) -> List[int]: uf = UnionFind() results = [] directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] for position in positions: x, y = position uf.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if (nx, ny) in uf.parent: uf.union((x, y), (nx, ny)) results.append(uf.get_count()) return results"},{"question":"# Algorithm and Data Structure Assessment Context In mathematical sequences or computing problems, it\'s sometimes necessary to find specific elements directly rather than generating or storing the whole sequence, which can be infeasible due to space or time constraints. Problem Statement You are required to write a function `find_nth_digit(n)`, which finds the nth digit in an infinite sequence that consists of concatenating all positive integers in order: `123456789101112...`. # Function Specification Input - A single integer `n` where `1 <= n <= 2^31 - 1`. Output - An integer representing the nth digit in the concatenated sequence. # Constraints - You should not construct the sequence explicitly due to memory constraints. - You may assume the input `n` will always be valid and within the given range. # Example ```python assert find_nth_digit(3) == 3 assert find_nth_digit(11) == 0 assert find_nth_digit(15) == 2 ``` Additional Information 1. Identify the length of the number segment where the nth digit falls. 2. Isolate the exact number and determine the required digit within it. 3. Handle large indices efficiently without precision loss.","solution":"def find_nth_digit(n): Finds the nth digit in the infinite sequence of concatenated positive integers. digit_length = 1 count = 9 start = 1 while n > digit_length * count: n -= digit_length * count digit_length += 1 count *= 10 start *= 10 start += (n - 1) // digit_length s = str(start) return int(s[(n - 1) % digit_length])"},{"question":"International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes. For each letter of the alphabet, there is a specific Morse code as follows: ```python morse_code = { \'a\':\\".-\\", \'b\':\\"-...\\", \'c\':\\"-.-.\\", \'d\': \\"-..\\", \'e\':\\".\\", \'f\':\\"..-.\\", \'g\':\\"--.\\", \'h\':\\"....\\", \'i\':\\"..\\", \'j\':\\".---\\", \'k\':\\"-.-\\", \'l\':\\".-..\\", \'m\':\\"--\\", \'n\':\\"-.\\", \'o\':\\"---\\", \'p\':\\".--.\\", \'q\':\\"--.-\\", \'r\':\\".-.\\", \'s\':\\"...\\", \'t\':\\"-\\", \'u\':\\"..-\\", \'v\':\\"...-\\", \'w\':\\".--\\", \'x\':\\"-..-\\", \'y\':\\"-.--\\", \'z\':\\"--..\\" } ``` Given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \'cab\' can be written as \\"-.-.-....-\\". Your task is to write a function `count_unique_morse_transformations(words: List[str]) -> int` that computes the number of unique Morse code transformations among all given words. # Input * words (List[str]): A list of n words (1 <= n <= 100), where each word consists of lowercase English letters. # Output * Returns an integer representing the count of unique Morse code transformations among the words. # Function Signature ```python def count_unique_morse_transformations(words: List[str]) -> int: pass ``` # Examples ```python words = [\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"] # Transformations are: \\"--...-.\\", \\"--...-.\\", \\"--...--.\\", \\"--...--.\\" # There are 2 unique transformations: \\"--...-.\\" and \\"--...--.\\" assert count_unique_morse_transformations(words) == 2 words = [\\"a\\", \\"b\\", \\"c\\"] # Transformations are: \\".-\\", \\"-...\\", \\"-.-.\\" # There are 3 unique transformations: \\".-\\", \\"-...\\", \\"-.-.\\" assert count_unique_morse_transformations(words) == 3 ``` # Constraints * Each word will have at most 12 letters. * Use the Morse code mappings provided above. # Notes - Use the `morse_code` provided for letter-to-Morse code transformations. - Consider edge cases such as duplicate transformations and single-letter words.","solution":"from typing import List morse_code = { \'a\':\\".-\\", \'b\':\\"-...\\", \'c\':\\"-.-.\\", \'d\': \\"-..\\", \'e\':\\".\\", \'f\':\\"..-.\\", \'g\':\\"--.\\", \'h\':\\"....\\", \'i\':\\"..\\", \'j\':\\".---\\", \'k\':\\"-.-\\", \'l\':\\".-..\\", \'m\':\\"--\\", \'n\':\\"-.\\", \'o\':\\"---\\", \'p\':\\".--.\\", \'q\':\\"--.-\\", \'r\':\\".-.\\", \'s\':\\"...\\", \'t\':\\"-\\", \'u\':\\"..-\\", \'v\':\\"...-\\", \'w\':\\".--\\", \'x\':\\"-..-\\", \'y\':\\"-.--\\", \'z\':\\"--..\\" } def count_unique_morse_transformations(words: List[str]) -> int: unique_transformations = set() for word in words: transformation = \\"\\".join(morse_code[letter] for letter in word) unique_transformations.add(transformation) return len(unique_transformations)"},{"question":"# Graph Pathfinding Exercise Context You are tasked with improving the navigation system of a logistics company. The company uses a framework of cities, represented as a graph, to optimize delivery routes. Your task is to implement three essential functions for route optimization: finding any route, finding all routes, and finding the shortest route between two cities. Problem Statement **Objective**: Implement the following three functions to navigate the city\'s logistical framework: 1. `find_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]` 2. `find_all_paths(graph: Dict[str, List[str]], start: str, end: str) -> List[List[str]]` 3. `find_shortest_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]` Each function should traverse the graph represented as an adjacency list to find paths between the given start and end nodes. Function Specifications 1. **find_path** - **Input**: - `graph`: A dictionary representing the adjacency list of a graph. - `start`: A string representing the starting node. - `end`: A string representing the ending node. - **Output**: A list representing a single path between the start and end nodes. 2. **find_all_paths** - **Input**: - `graph`: A dictionary representing the adjacency list of a graph. - `start`: A string representing the starting node. - `end`: A string representing the ending node. - **Output**: A list of lists, each containing a path between the start and end nodes. 3. **find_shortest_path** - **Input**: - `graph`: A dictionary representing the adjacency list of a graph. - `start`: A string representing the starting node. - `end`: A string representing the ending node. - **Output**: A list representing the shortest path between the start and end nodes, based on the number of edges. Constraints - The graph is unweighted and represented as a dictionary of lists. - Nodes are represented as strings. - There are no duplicate edges or self-loops. - Assume inputs are always valid and no need for additional validation. - Performance: - `find_path`: Must be able to handle up to 1,000 nodes without exceeding time limits. - `find_all_paths`: Must be optimized for graphs with few paths (not dense). - `find_shortest_path`: Should return the shortest path efficiently. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [], \'E\': [\'F\'], \'F\': [] } assert find_path(graph, \'A\', \'F\') in [[\'A\', \'C\', \'F\'], [\'A\', \'B\', \'E\', \'F\']] assert find_all_paths(graph, \'A\', \'F\') == [[\'A\', \'B\', \'E\', \'F\'], [\'A\', \'C\', \'F\']] assert find_shortest_path(graph, \'A\', \'F\') == [\'A\', \'C\', \'F\'] assert find_path(graph, \'A\', \'A\') == [\'A\'] assert find_all_paths(graph, \'A\', \'A\') == [[\'A\']] assert find_shortest_path(graph, \'A\', \'A\') == [\'A\'] ```","solution":"from typing import List, Dict def find_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]: path = [] def dfs(current, end, path, visited): if current in visited: return False visited.add(current) path.append(current) if current == end: return True for neighbor in graph.get(current, []): if dfs(neighbor, end, path, visited): return True path.pop() visited.remove(current) return False dfs(start, end, path, set()) return path def find_all_paths(graph: Dict[str, List[str]], start: str, end: str) -> List[List[str]]: paths = [] def dfs(current, end, path, visited): if current in visited: return path.append(current) visited.add(current) if current == end: paths.append(path[:]) else: for neighbor in graph.get(current, []): dfs(neighbor, end, path, visited) path.pop() visited.remove(current) dfs(start, end, [], set()) return paths def find_shortest_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]: from collections import deque queue = deque([(start, [start])]) visited = set() while queue: current, path = queue.popleft() if current in visited: continue visited.add(current) if current == end: return path for neighbor in graph.get(current, []): if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return []"},{"question":"You have been given the task of writing a sorting function using the Insertion Sort algorithm. This function will not only sort the given list but will also return the number of iterations required to completely sort the list. Additionally, the function should handle various edge cases efficiently. # Function Signature ```python def enhanced_insertion_sort(arr: list) -> tuple: Sorts the list using the Insertion Sort algorithm and returns a tuple containing the sorted list and the number of iterations. :param arr: List of integers to sort :return: A tuple - (sorted_list, iteration_count) ``` # Input * A list of integers `arr`. (0 ≤ len(arr) ≤ 10^6, -10^9 ≤ arr[i] ≤ 10^9) # Output * A tuple containing: * The sorted list. * The number of iterations taken to sort the list. # Constraints * Optimize to handle up to 10^6 elements. * Ensure that no extra space beyond a feasible constant amount is used. * Handle edge cases such as an empty list, list with one element, and list with all identical elements. # Example ```python enhanced_insertion_sort([]) # Output: ([], 0) enhanced_insertion_sort([3]) # Output: ([3], 0) enhanced_insertion_sort([5, 2, 4, 6, 1, 3]) # Output: ([1, 2, 3, 4, 5, 6], 6) enhanced_insertion_sort([1, 2, 3, 4, 5, 6]) # Output: ([1, 2, 3, 4, 5, 6], 0) enhanced_insertion_sort([9, 7, 5, 3, 1, 0]) # Output: ([0, 1, 3, 5, 7, 9], 5) ``` # Notes * The number of iterations is increased after each complete pass through the outer for loop. * Ensure the function is well-commented and that you include any assumptions made.","solution":"def enhanced_insertion_sort(arr: list) -> tuple: Sorts the list using the Insertion Sort algorithm and returns a tuple containing the sorted list and the number of iterations. :param arr: List of integers to sort :return: A tuple - (sorted_list, iteration_count) n = len(arr) # Length of the list iterations = 0 # Initialize iteration counter for i in range(1, n): key = arr[i] j = i - 1 # Insert arr[i] into the sorted sequence arr[0...i-1] while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key iterations += 1 # Increment iteration counter at the end of each outer loop return arr, iterations"},{"question":"# FFT Computation of Signal Data Context: In digital signal processing, the Fast Fourier Transform (FFT) is widely used for analyzing the frequency components of signals. Your task is to implement the Cooley-Tukey FFT algorithm to enable fast computation of the discrete Fourier transform. This function will be used to process signal data for a new audio analysis tool. Task: Implement the function `compute_fft` that computes the FFT of a given list of complex numbers representing signal values. The input size will always be a power of 2. Function Signature: ```python def compute_fft(signal: List[complex]) -> List[complex]: pass ``` Input: * `signal`: A list of complex numbers of size N (where N is a power of 2) representing the signal values. Output: * Returns a list of complex numbers representing the Fourier-transformed signal. Constraints: * 1 <= N <= 1024, where N is always a power of 2. Performance: * The implementation should run in O(N log N) time complexity. * Aim to use O(N) additional space. Example: ```python signal = [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] output = compute_fft(signal) # Expected output: [(8+8j), 2j, (2-2j), (-2+0j)] ``` Notes: * Handle the twiddle factor calculations efficiently. * Ensure proper handling of complex number arithmetic to avoid inaccuracies.","solution":"from typing import List import cmath def compute_fft(signal: List[complex]) -> List[complex]: Computes the FFT of given list of complex numbers. N = len(signal) # base case if N <= 1: return signal # divide even_array = compute_fft(signal[0::2]) odd_array = compute_fft(signal[1::2]) # combine result = [0] * N for k in range(N // 2): twiddle_factor = cmath.exp(-2j * cmath.pi * k / N) * odd_array[k] result[k] = even_array[k] + twiddle_factor result[k + N // 2] = even_array[k] - twiddle_factor return result"},{"question":"# Question: Counting Islands in a Dynamic Land-Water Grid You are given a 2D `m x n` grid initialized entirely with water (represented by 0). There are a series of operations, where each operation adds a piece of land (represented by 1) at a specified coordinate. Implement the function `num_islands(m, n, positions)` that tracks the number of islands after each land addition. An island is formed by connecting adjacent lands horizontally or vertically. Function Definition ```python def num_islands(m: int, n: int, positions: List[Tuple[int, int]]) -> List[int]: pass ``` Input * `m` (int): Number of rows in the grid. * `n` (int): Number of columns in the grid. * `positions` (List[Tuple[int, int]]): List of tuples where each tuple represents the coordinates of a land addition. Output * List of integers where each entry represents the number of islands after each corresponding land addition. Constraints * 1 <= m, n <= 1000 * 1 <= len(positions) <= 10^4 * 0 <= positions[i][0] < m * 0 <= positions[i][1] < n Example ```python m = 3 n = 3 positions = [(0, 0), (0, 1), (1, 2), (2, 1)] # Output: [1, 1, 2, 3] ``` * After the first land addition, there is 1 island. * After the second land addition, there is still 1 island (connected to the first). * After the third land addition, there are now 2 separate islands. * After the fourth land addition, there are 3 separate islands. Explanation Use a Union-Find data structure to manage the merging of land pieces and the counting of distinct sets that represent islands. Ensure that path compression and union by size/rank are implemented to maintain efficient operations.","solution":"from typing import List, Tuple def num_islands(m: int, n: int, positions: List[Tuple[int, int]]) -> List[int]: def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 return True return False parent = {} rank = {} count = 0 result = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] grid = [[0] * n for _ in range(m)] for (r, c) in positions: if grid[r][c] == 1: result.append(count) continue grid[r][c] = 1 index = (r, c) parent[index] = index rank[index] = 0 count += 1 for dr, dc in directions: nr, nc = r + dr, c + dc neighbor_index = (nr, nc) if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1: if union(index, neighbor_index): count -= 1 result.append(count) return result"},{"question":"# Merge Sort Implementation with Input Validation and Enhanced Performance Merge Sort is a classic, highly efficient, and stable sorting algorithm based on the divide-and-conquer technique. It is often used in scenarios where large datasets need sorting, especially when stability is a priority. Problem Statement Implement the `merge_sort` function, an enhanced version of the Merge Sort algorithm. Your implementation should handle edge cases effectively and aim to optimize space and time utilization as much as possible. Here is the signature of the function you need to implement: ```python def merge_sort(arr: list) -> list: Sort a provided list of integers using the Merge Sort algorithm. :param arr: A list of integers to be sorted. :return: A new list with sorted integers. # Your implementation goes here ``` Requirements: 1. **Input**: A list of integers to be sorted. 2. **Output**: A new list of integers, sorted in ascending order. 3. **Constraints**: * The input list can be empty or contain up to 10^6 elements. * Duplicates should be maintained in their original relative order for the same values (stability). 4. **Performance**: Your implementation should have an average-case time complexity of O(n log n) and auxiliary space complexity of O(n). Sample Input/Output: 1. **Input**: `[4, 1, 3, 9, 7]` **Output**: `[1, 3, 4, 7, 9]` 2. **Input**: `[10, 7, 8, 9, 1, 5]` **Output**: `[1, 5, 7, 8, 9, 10]` 3. **Input**: `[1, 2, 2, 1]` **Output**: `[1, 1, 2, 2]` Notes: - Consider edge cases such as an empty list or a list with a single element. - Ensure the function does not modify the input list and returns a new sorted list. - Minimize unnecessary memory usage by managing temporary arrays and pointer swaps effectively.","solution":"def merge_sort(arr): Sort a provided list of integers using the Merge Sort algorithm. :param arr: A list of integers to be sorted. :return: A new list with sorted integers. if len(arr) <= 1: return arr def merge(left, right): result = [] i = 0 j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"# Subtree Check for Binary Trees **Context:** You are given two binary trees and need to determine if one tree is a subtree of another. A subtree of a tree `t` is a tree consisting of a node in `t` and all of its descendants in `t`. **Problem:** Write a function `is_subtree(big, small)` that takes two binary trees `big` and `small` and returns `True` if `small` is a subtree of `big`, otherwise returns `False`. **Input:** - `big`, `small`: Nodes representing the roots of the two binary trees. - Each node contains: - `val`: an integer representing the node value. - `left`: a pointer to the left child node. - `right`: a pointer to the right child node. **Output:** - Return a boolean value `True` if the smaller tree `small` is a subtree of the bigger tree `big`, otherwise return `False`. **Examples:** Example 1: ```plaintext Input: big: 3 / 4 5 / 1 2 small: 4 / 1 2 Output: True ``` Example 2: ```plaintext Input: big: 3 / 4 5 / 1 2 / 0 small: 4 / 1 2 Output: False ``` # Constraints: - The number of nodes in either tree will not exceed (10^4). - Node values are integers, which are unique within the given tree. **Performance Requirements:** - The solution should efficiently accommodate large trees. Try to design optimal code performance-wise, considering potential optimization techniques for deeper comparisons. **Function Signature:** ```python def is_subtree(big: Node, small: Node) -> bool: ``` **Note:** - Assume the `Node` class for the binary tree is defined as follows: ```python class Node: def __init__(self, val:int=0, left:\'Node\'=None, right:\'Node\'=None): self.val = val self.left = left self.right = right ``` # Instructions: 1. Implement the function `is_subtree` using the given information. 2. Consider and handle edge cases during the implementation. 3. Ensure to provide a solution that balances between clarity and performance.","solution":"class Node: def __init__(self, val:int=0, left:\'Node\'=None, right:\'Node\'=None): self.val = val self.left = left self.right = right def is_subtree(big: Node, small: Node) -> bool: if not small: return True if not big: return False if are_identical(big, small): return True return is_subtree(big.left, small) or is_subtree(big.right, small) def are_identical(tree1: Node, tree2: Node) -> bool: if not tree1 and not tree2: return True if not tree1 or not tree2: return False return ( tree1.val == tree2.val and are_identical(tree1.left, tree2.left) and are_identical(tree1.right, tree2.right) )"},{"question":"# Question: Interval Merging and Membership Testing You are given a custom implementation of an Interval class that represents intervals of real numbers. Your task is to extend the functionality by correctly implementing interval membership testing and creating an efficient function to merge overlapping intervals. Part 1: Fixing Membership Testing The current implementation of the `__contains__` method in the Interval class is incorrect. Fix it so that it correctly determines if a given number is within the interval. Part 2: Merging Intervals Write an efficient function that merges overlapping intervals from a list of Interval objects. You should return a list of non-overlapping intervals sorted by their start value. # Specifications: 1. Implement the corrected `__contains__` method in the Interval class. 2. Write a function `merge_intervals(intervals: List[Interval]) -> List[Interval]` to merge overlapping intervals. Input * A list of `Interval` objects. Output * A list of merged and non-overlapping `Interval` objects. Example ```python intervals = [Interval(1, 3), Interval(2, 6), Interval(8, 10), Interval(15, 18)] # After merging the intervals should be: # output = [Interval(1, 6), Interval(8, 10), Interval(15, 18)] ``` # Constraints 1. Intervals are provided as `Interval` class objects with integer boundaries. 2. Intervals are valid (start < end for all intervals). # Performance Requirements * The merge function should execute in O(n log n) time complexity and use O(n) additional space.","solution":"from typing import List class Interval: def __init__(self, start: int, end: int): self.start = start self.end = end def __contains__(self, number: int) -> bool: return self.start <= number < self.end def merge_intervals(intervals: List[Interval]) -> List[Interval]: if not intervals: return [] # Sort the intervals based on the start time intervals.sort(key=lambda x: x.start) merged = [] current_start = intervals[0].start current_end = intervals[0].end for i in range(1, len(intervals)): interval = intervals[i] if interval.start <= current_end: # There is an overlap, so we merge the intervals current_end = max(current_end, interval.end) else: # No overlap, add the current interval to the merged list merged.append(Interval(current_start, current_end)) current_start = interval.start current_end = interval.end # Add the last interval merged.append(Interval(current_start, current_end)) return merged"},{"question":"You\'ve been assigned to create a utility for determining the transitive closure of an organizational hierarchy. An organizational hierarchy is represented as a directed graph where vertices represent employees and directed edges represent the \\"reports to\\" relationship between them. Your task is to implement a function that computes the transitive closure of this hierarchy graph, indicating which employees are reachable from each other through these direct or indirect reporting lines. # Function Signature ```python def compute_transitive_closure(vertices: int, edges: List[Tuple[int, int]]) -> List[List[int]]: ``` # Input * **vertices**: An integer `vertices` representing the number of employees. * **edges**: A list of tuples `(i, j)` where each tuple indicates a direct \\"reports to\\" relationship from employee `i` to employee `j`. # Output * **Return**: A 2D list representing the transitive closure matrix. The element at position `[i][j]` is 1 if there is a path from employee `i` to employee `j` and 0 otherwise. # Constraints 1. 0 ≤ vertices ≤ 100 (employee count) 2. 0 ≤ len(edges) ≤ vertices * (vertices - 1) # Performance Requirement - Your implementation should handle the transitive closure computation within practical limits considering the constraints provided. # Example ```python vertices = 4 edges = [(0, 2), (2, 1), (1, 3)] computed_closure = compute_transitive_closure(vertices, edges) print(computed_closure) ``` Output: ``` [ [1, 1, 1, 1], [0, 1, 0, 1], [0, 1, 1, 1], [0, 0, 0, 1] ] ``` # Notes 1. In the example above, employee `0` can reach employees `1`, `2`, and `3` through the chain of reporting. 2. Employee relationships are unidirectional and hierarchical without cyclic dependencies. Implement the function `compute_transitive_closure` to solve the problem using DFS-based approach as analyzed.","solution":"def compute_transitive_closure(vertices, edges): # Initialize the transitive closure matrix with 0s closure = [[0] * vertices for _ in range(vertices)] # Add 1s for the diagonal elements (self-loops) for i in range(vertices): closure[i][i] = 1 # Add the direct edges to the closure matrix for (i, j) in edges: closure[i][j] = 1 # Using Floyd-Warshall algorithm to compute the transitive closure for k in range(vertices): for i in range(vertices): for j in range(vertices): if closure[i][k] and closure[k][j]: closure[i][j] = 1 return closure"},{"question":"# Context You\'ve been hired as a software engineer at a company that develops tracking and analysis tools for large datasets. One of your tasks is to work with hierarchical data structures like trees. You are provided with a binary tree and must find all root-to-leaf paths where the sum of node values equals a given target sum. # Task Implement the function `find_paths_with_sum(root, target_sum)` that takes the root of a binary tree and a target sum as input, and returns a list of paths (each path represented as a list of node values) that sum up to the target sum. You need to employ an iterative DFS approach using a stack. # Function Signature ```python def find_paths_with_sum(root: TreeNode, target_sum: int) -> List[List[int]]: ``` # Input - `root` (TreeNode): The root of the binary tree. - `target_sum` (int): The target sum to find in the root-to-leaf paths. # Output - Return a list of lists, where each inner list represents a path from root to a leaf with the sum equal to `target_sum`. # Constraints - The number of nodes in the tree will be in the range [0, 1000]. - `-1000 <= Node.value <= 1000` - `-10^5 <= target_sum <= 10^5` # Example ```python # Example given tree # 5 # / # 4 8 # / / # 11 13 4 # / / # 7 2 5 1 root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.right.left = TreeNode(5) root.right.right.right = TreeNode(1) target_sum = 22 # Paths with sum 22 are: # [5, 4, 11, 2] # [5, 8, 4, 5] print(find_paths_with_sum(root, target_sum)) # Output: [[5, 4, 11, 2], [5, 8, 4, 5]] ``` # Note Ensure the implementation is robust and handles edge cases such as empty tree, negative values, and trees with only one path correctly.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_paths_with_sum(root: Optional[TreeNode], target_sum: int) -> List[List[int]]: if not root: return [] result = [] stack = [(root, root.val, [root.val])] while stack: node, current_sum, path = stack.pop() # Check if we are at a leaf node and current sum equals the target sum if not node.left and not node.right and current_sum == target_sum: result.append(path) if node.right: stack.append((node.right, current_sum + node.right.val, path + [node.right.val])) if node.left: stack.append((node.left, current_sum + node.left.val, path + [node.left.val])) return result"},{"question":"**Scenario**: You are a famous architect designing staircases for high-rise buildings. Your designs are renowned for their beauty and the meticulous attention you pay to functional details. Recently, a client requested a complex design feature: they want a system to track the number of ways one can reach the top of a staircase with `n` steps, if a person can only take 1 or 2 steps at a time. To ensure design efficiency and correctness, you need a program that calculates this for any given `n`. **Task**: Write a function named `number_of_ways(n: int) -> int` that takes a positive integer `n` representing the number of steps in a staircase and returns the number of distinct ways to reach the top when each time you can either climb 1 or 2 steps. **Function Signature**: ```python def number_of_ways(n: int) -> int: ``` # Input: - `n` (1 <= n <= 10^6): An integer representing the number of steps. # Output: - Return an integer representing the number of distinct ways to reach the top of the staircase. # Constraints: - Time complexity should be O(n). - Space complexity should be O(1) for optimal performance. # Example: ```python assert number_of_ways(2) == 2 # Two ways: [1 step + 1 step] or [2 steps] assert number_of_ways(3) == 3 # Three ways: [1+1+1], [1+2], or [2+1] assert number_of_ways(5) == 8 # Eight ways to climb 5 steps ``` # Notes: - This is a core problem in dynamic programming, and understanding it will help you with other complex problems involving sequence calculations and combinatorial problems. - Ensure your solution handles large inputs efficiently.","solution":"def number_of_ways(n: int) -> int: Returns the number of distinct ways to reach the top of a staircase with n steps when one can take 1 or 2 steps at a time. if n == 1: return 1 elif n == 2: return 2 a, b = 1, 2 for i in range(3, n + 1): a, b = b, a + b return b"},{"question":"**Problem Statement:** You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees clockwise in-place. # Input * A two-dimensional list (n x n matrix) where `1 <= n <= 1000`. # Output * The same matrix, but rotated 90 degrees clockwise. # Constraints * The matrix must be changed in-place. * No extra space should be used apart from a small, constant amount required for auxiliary operations. # Example ```python mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] After rotation: mat = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Function Signature: ```python def rotate(mat: List[List[int]]) -> None: pass ``` # Instructions: 1. Implement the `rotate(mat: List[List[int]]) -> None` function to perform in-place rotation of the given image-matrix. 2. The function has no return value as the transformation must occur within the provided matrix. 3. Ensure your solution efficiently handles the matrix within the provided constraints.","solution":"from typing import List def rotate(mat: List[List[int]]) -> None: Rotates the input n x n matrix by 90 degrees clockwise in-place. :param mat: A 2D list representing the n x n matrix to be rotated. n = len(mat) # First step: transpose the matrix for i in range(n): for j in range(i, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j] # Second step: reverse each row for i in range(n): mat[i].reverse()"},{"question":"# Scenario You are developing a program that needs to efficiently calculate the number of ways to choose `r` items from `n` items. You are provided with two functions: a basic recursive combination calculator and a memoized recursive combination calculator. Your task is to implement a combination calculator that further optimizes space complexity while maintaining the improved time efficiency of memoization. # Task Based on the provided algorithms, write an optimized function `combination_optimized(n, r)`, which calculates `nCr` with reduced space complexity. Use an iterative approach without recursion and ensure that your implementation can handle large inputs efficiently. # Function Signature ```python def combination_optimized(n: int, r: int) -> int: pass ``` # Input - `n` (int): The total number of items. - `r` (int): The number of items to choose. Constraints: - `0 <= r <= n <= 1000` # Output - Return the integer value of `nCr`. # Examples ```python assert combination_optimized(5, 2) == 10 assert combination_optimized(10, 5) == 252 assert combination_optimized(20, 10) == 184756 # Edge cases assert combination_optimized(1, 0) == 1 assert combination_optimized(0, 0) == 1 ``` # Notes - Optimize for both time and space complexity. - If `n` or `r` are extremely large, your solution should still handle the input within a reasonable amount of time.","solution":"def combination_optimized(n: int, r: int) -> int: Calculate nCr using an iterative approach to optimize space complexity. if r > n: return 0 if r == 0 or r == n: return 1 # Since C(n, r) = C(n, n-r) r = min(r, n - r) # Initialize an array to store the values of C(i, j) C = [0] * (r + 1) C[0] = 1 # nC0 is 1 for any n # Calculate value of Binomial Coefficient in bottom-up manner for i in range(1, n + 1): # Compute next row of the pascal triangle using the previous row # but we\'re able to overwrite since we only need the current state\'s values for j in range(min(i, r), 0, -1): C[j] = C[j] + C[j - 1] return C[r]"},{"question":"# Minimum Spanning Tree using Kruskal\'s Algorithm You have been tasked with implementing a function to calculate the sum of weights of the Minimum Spanning Tree (MST) of an undirected, connected graph using Kruskal\'s algorithm. The function will also make use of a Disjoint Set data structure for efficient union-find operations. Function Signature ```python def kruskals_mst(vertex_count: int, edge_list: List[Tuple[int, int, int]]) -> int: pass ``` Input * `vertex_count` (int): An integer `V` representing the number of vertices in the graph. * `edge_list` (List[Tuple[int, int, int]]): A list of tuples, each representing an edge `(u, v, weight)` where `u` and `v` are the vertices connected by the edge, and `weight` is the weight of the edge. Output * Returns an integer, the sum of weights of the edges in the Minimum Spanning Tree (MST). Constraints * 1 <= V <= 1000 (number of vertices) * 0 <= E <= 10000 (number of edges) * 1 <= weight <= 10000 (weight of each edge) * The given graph is guaranteed to be connected and undirected. Context You work at a network design company, and a new project requires designing a network that connects several cities with the least possible fiber optic cable length. You are provided with a list of potential connections between city pairs (each with a certain length of cable needed) and need to determine the minimum length of cable required to connect all cities. Example ```python vertex_count = 5 edge_list = [ (0, 1, 3), (0, 2, 8), (1, 3, 5), (2, 3, 2), (2, 4, 4), (3, 4, 6) ] assert kruskals_mst(vertex_count, edge_list) == 14 ``` Instructions: 1. Implement the `kruskals_mst` function using Kruskal\'s algorithm approach. 2. Ensure you are using an efficient edge sorting method. 3. Implement the union-find operations with path compression and union by rank for optimal performance. 4. Test your implementation with various edge cases, including edge cases mentioned earlier.","solution":"from typing import List, Tuple class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) # Path compression return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskals_mst(vertex_count: int, edge_list: List[Tuple[int, int, int]]) -> int: edge_list.sort(key=lambda edge: edge[2]) # Sort edges by weight ds = DisjointSet(vertex_count) mst_weight = 0 mst_edges = 0 for u, v, weight in edge_list: if ds.find(u) != ds.find(v): ds.union(u, v) mst_weight += weight mst_edges += 1 if mst_edges == vertex_count - 1: # Stop if we\'ve included V-1 edges break return mst_weight"},{"question":"# Coding Assessment: Reverse Words with Punctuation Handling Context: Given a string, the task is to reverse the order of words while keeping the characters within the words in the same order. Besides the basic requirement of reversing the words, you must handle punctuation marks correctly, ensuring they stay attached to their respective words. Requirements: * Implement a function `reverse_words_with_punctuation(sentence: str) -> str` that meets the following criteria: * Input: `sentence` - a string that may contain multiple words separated by spaces and punctuated appropriately. * Output: A string with the words in reverse order, maintaining the integrity of punctuation around words. * Constraints: - The input string `sentence` will have at most 10^5 characters. - Assume proper punctuation usage within sentences (e.g., words followed by commas, periods, exclamations, etc.) Input and Output Examples: ```python reverse_words_with_punctuation(\\"Hello, world!\\") # Output: \\"world! Hello,\\" reverse_words_with_punctuation(\\"I love Python, very much!\\") # Output: \\"much! very Python, love I\\" reverse_words_with_punctuation(\\" Enjoy coding. \\") # Output: \\"coding. Enjoy\\" reverse_words_with_punctuation(\\"!a !b !c\\") # Output: \\"!c !b !a\\" ``` Key Points: * You should handle any extra spaces gracefully. * Do not use extra memory excessively outside the splitting and reversing processes. * Ensure that punctuation attached to words remains attached in the right reversed positions. Function Signature: ```python def reverse_words_with_punctuation(sentence: str) -> str: # Implementation here ```","solution":"def reverse_words_with_punctuation(sentence: str) -> str: Reverses the order of words in a sentence, while preserving punctuation attached to words and extra spaces between words. # Splitting the sentence into words words = sentence.split() # Reversing the list of words reversed_words = words[::-1] # Joining the reversed list of words into a string reversed_sentence = \' \'.join(reversed_words) return reversed_sentence"},{"question":"# Binary Search Tree Operations with Duplicate Values Handling **Scenario:** We are extending the functionality of a Binary Search Tree (BST) to handle insertion of duplicate values. The requirement is to maintain the properties of the BST while allowing multiple occurrences of a value. # Task Your task is to implement a BST class with methods to handle insertion, search, size calculation, and traversal. Additionally, you will modify the insertion method to handle duplicate values efficiently. Instead of rejecting duplicates as in traditional BSTs, duplicate values should be stored in a separate list at the corresponding node. # Instructions 1. **Insert Method**: Modify the `insert` method to handle duplicates. If a duplicate value is encountered, store it in a list associated with the node. 2. **Search Method**: Modify the `search` method to return the number of occurrences of a given value. 3. **Size Method**: Ensure the `size` method correctly counts the total number of nodes, including duplicates. # Function Signatures The class `BST` should expose the following methods: * `insert(data: int) -> None` * `search(data: int) -> int` * `size() -> int` * `preorder() -> List[int]` * `inorder() -> List[int]` * `postorder() -> List[int]` # Expected Input and Output Format: * `insert(data: int)`: Adds the given data to the BST. * `search(data: int) -> int`: Returns the number of occurrences of `data` in the BST. * `size() -> int`: Returns the number of nodes including duplicates. * `preorder() -> List[int]`: Returns a list of values after pre-order traversal. * `inorder() -> List[int]`: Returns a list of values after in-order traversal. * `postorder() -> List[int]`: Returns a list of values after post-order traversal. # Performance Requirements: - Ensure that your implementation maintains the BST property and handles the insertion of duplicate values efficiently. # Constraints: - Each node can store any number of duplicates. - Ensure your implementation correctly counts and handles nodes with duplicates. # Example ```python tree = BST() tree.insert(10) tree.insert(15) tree.insert(10) # duplicate value print(tree.search(10)) # Output: 2 print(tree.size()) # Output: 3 print(tree.inorder()) # Output: [10, 10, 15] ``` Implement the required `BST` class and methods accordingly.","solution":"class BST: class Node: def __init__(self, data): self.data = data self.count = 1 self.left = None self.right = None def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = self.Node(data) else: self._insert(self.root, data) def _insert(self, node, data): if data < node.data: if node.left is None: node.left = self.Node(data) else: self._insert(node.left, data) elif data > node.data: if node.right is None: node.right = self.Node(data) else: self._insert(node.right, data) else: # data == node.data node.count += 1 def search(self, data): return self._search(self.root, data) def _search(self, node, data): if node is None: return 0 if data < node.data: return self._search(node.left, data) elif data > node.data: return self._search(node.right, data) else: return node.count def size(self): return self._size(self.root) def _size(self, node): if node is None: return 0 return node.count + self._size(node.left) + self._size(node.right) def preorder(self): result = [] self._preorder(self.root, result) return result def _preorder(self, node, result): if node: for _ in range(node.count): result.append(node.data) self._preorder(node.left, result) self._preorder(node.right, result) def inorder(self): result = [] self._inorder(self.root, result) return result def _inorder(self, node, result): if node: self._inorder(node.left, result) for _ in range(node.count): result.append(node.data) self._inorder(node.right, result) def postorder(self): result = [] self._postorder(self.root, result) return result def _postorder(self, node, result): if node: self._postorder(node.left, result) self._postorder(node.right, result) for _ in range(node.count): result.append(node.data)"},{"question":"# Advanced Coding Assessment: Stack Implementation and Application Problem Description: You are tasked with implementing a `ReverseWords` function using the stack data structures provided. The function should reverse the order of words in a given sentence. Requirements: 1. **Function Definition**: ```python def ReverseWords(sentence: str) -> str: pass ``` 2. **Input**: A string `sentence` consisting of words separated by spaces (1 ≤ len(sentence) ≤ 10^6). 3. **Output**: A string with the words in the `sentence` reversed. 4. **Constraints**: * Utilize the stack data structure (either `ArrayStack` or `LinkedListStack`). * Assume words are separated by single spaces and there are no leading, trailing, or multiple spaces between words. 5. **Performance Requirements**: * Your solution should efficiently handle input strings of length up to 10^6 characters. Aim for O(n) time complexity. Example: ```python # Example usage: assert ReverseWords(\\"Hello world\\") == \\"world Hello\\" assert ReverseWords(\\"The quick brown fox\\") == \\"fox brown quick The\\" ``` Notes: * You may use the provided `ArrayStack` or `LinkedListStack`. * Focus on correctly utilizing the stack operations to achieve the desired output efficiently. * Handle edge cases such as empty strings or single-word sentences appropriately.","solution":"class ArrayStack: def __init__(self): self.items = [] def is_empty(self): return len(self.items) == 0 def push(self, item): self.items.append(item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.items.pop() def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.items[-1] def size(self): return len(self.items) def ReverseWords(sentence: str) -> str: stack = ArrayStack() words = sentence.split() for word in words: stack.push(word) reversed_sentence = [] while not stack.is_empty(): reversed_sentence.append(stack.pop()) return \' \'.join(reversed_sentence)"},{"question":"# Question: Scenario: You are tasked with developing a tool to analyze the structure of binary trees. One key feature is to measure the maximum depth of these trees, which can help diagnose how unbalanced a tree might be. Problem: Write a function `calculate_max_depth` that takes the root of a binary tree and returns its maximum depth. Utilize an iterative approach with a queue to implement the solution. Input: * The root of the binary tree (Node with potentially `None` left and right children). Output: * An integer representing the maximum depth of the tree. Constraints: * The number of nodes in the tree is in the range `[0, 10^5]`. * The value of each node is an integer. Example: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example usage: # tree = TreeNode(3) # tree.left = TreeNode(9) # tree.right = TreeNode(20) # tree.right.left = TreeNode(15) # tree.right.right = TreeNode(7) # The maximum depth of the given tree is 3. assert calculate_max_depth(tree) == 3 ``` Performance Requirement: * Your implementation should run in O(N) time and use O(N) space where N is the number of nodes in the tree.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def calculate_max_depth(root): Calculate the maximum depth of a binary tree iteratively using a queue. Args: root (TreeNode): The root node of the binary tree. Returns: int: The maximum depth of the tree. if not root: return 0 queue = deque([(root, 1)]) max_depth = 0 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return max_depth"},{"question":"Scenario You are developing a feature for an educational website that helps students learn vocabularies and detect anagrams. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Task Write a function `are_anagrams(s1: str, s2: str) -> bool` that checks whether two given strings are anagrams of each other, without considering case sensitivity and any non-alphabet characters. Input and Output Formats - **Input**: Two strings `s1` and `s2`. - `s1` and `s2` can contain any printable characters. - Length of strings, 0 leq text{len}(s1), text{len}(s2) leq 1000. - **Output**: - Return `True` if `s1` and `s2` are anagrams. - Return `False` otherwise. Constraints and Conditions - Ignore case when comparing characters. - Ignore any non-alphabet characters. - Performance requirement: Your solution should run efficiently with a time complexity of O(n). Example ```python >>> are_anagrams(\\"Apple\\", \\"ppl e A\\") True >>> are_anagrams(\\"Hello, World!\\", \\"dlroW, olleH!\\") True >>> are_anagrams(\\"Test\\", \\"Best\\") False ``` Guidelines 1. Define the function signature: `def are_anagrams(s1: str, s2: str) -> bool:` 2. Preprocess the inputs to filter out non-alphabet characters and convert all characters to lower case. 3. Count the frequency of each character using a fixed-size list or dictionary. 4. Compare the frequency counts of the two strings. You may include additional helper functions as needed.","solution":"from collections import Counter import re def are_anagrams(s1: str, s2: str) -> bool: Returns True if s1 and s2 are anagrams (case insensitive and ignoring non-alphabet characters). # Helper function to preprocess the strings def preprocess(s: str) -> str: return re.sub(r\'[^a-zA-Z]\', \'\', s).lower() # Preprocess both strings s1_processed = preprocess(s1) s2_processed = preprocess(s2) # Compare the frequency counts of the two processed strings return Counter(s1_processed) == Counter(s2_processed)"},{"question":"You are tasked with implementing a memory-efficient flag storage system for a large-scale IoT infrastructure, where each device has a unique set of configuration flags that can be either on or off. Each device\'s configuration needs to be manipulated using precise and efficient operations. Write four functions in Python that manipulate bits of an integer representing the configuration of a device. Each bit in the integer represents a specific configuration flag (on or off). You need to implement the following: 1. **get_bit(num, i)**: Retrieves the value of the bit at index `i`. 2. **set_bit(num, i)**: Sets the bit at index `i` to 1. 3. **clear_bit(num, i)**: Clears the bit at index `i` to 0. 4. **update_bit(num, i, bit)**: Updates the bit at index `i` to the value of `bit` (either 0 or 1). # Input - For `get_bit`: an integer `num` and an integer `i` where `0 <= i < 32`. - For `set_bit`: an integer `num` and an integer `i` where `0 <= i < 32`. - For `clear_bit`: an integer `num` and an integer `i` where `0 <= i < 32`. - For `update_bit`: an integer `num`, an integer `i` where `0 <= i < 32`, and a `bit` which can be either 0 or 1. # Output - For `get_bit`: returns a boolean (True if the bit is 1, False if the bit is 0). - For `set_bit`: returns an integer representing the new state of the number after setting the bit. - For `clear_bit`: returns an integer representing the new state of the number after clearing the bit. - For `update_bit`: returns an integer representing the new state of the number after updating the bit. # Constraints - You can assume that `num` is a 32-bit unsigned integer. - `0 <= num <= 2^32 - 1` - `0 <= i < 32` # Example ```python # Example print(get_bit(5, 0)) # Output: True (binary: 101 -> bit at index 0 is 1) print(set_bit(5, 1)) # Output: 7 (binary: 101 -> 111) print(clear_bit(5, 0)) # Output: 4 (binary: 101 -> 100) print(update_bit(5, 1, 0)) # Output: 5 (binary: 101 -> 101 because bit at index 1 is already 0) print(update_bit(5, 0, 0)) # Output: 4 (binary: 101 -> 100) ```","solution":"def get_bit(num, i): Retrieves the value of the bit at index i. Returns True if the bit is 1, otherwise returns False. return (num & (1 << i)) != 0 def set_bit(num, i): Sets the bit at index i to 1. Returns the new state of the number after setting the bit. return num | (1 << i) def clear_bit(num, i): Clears the bit at index i to 0. Returns the new state of the number after clearing the bit. return num & ~(1 << i) def update_bit(num, i, bit): Updates the bit at index i to the value of bit (either 0 or 1). Returns the new state of the number after updating the bit. mask = ~(1 << i) num &= mask return num | (bit << i)"},{"question":"Context You are tasked with designing a custom arithmetic module for a low-level system where the use of typical arithmetic operators is restricted due to operational constraints. One key function is to implement integer addition using only bitwise operations. Problem Statement Write a Python function `add_bitwise(x: int, y: int) -> int` that performs the addition of two positive integers using bitwise operations, adhering to the following specifications: - **Input**: Two positive integers `x` and `y` such that `1 <= x, y <= 10^9`. - **Output**: A single integer which is the sum of `x` and `y`. Your task is to implement this function without using the `+` operator, ensuring efficiency in time and space. Examples ```python assert add_bitwise(2, 3) == 5 assert add_bitwise(15, 25) == 40 assert add_bitwise(123456789, 987654321) == 1111111110 ``` Constraints - The function should use only bitwise operations (`&`, `|`, `^`, `<<`, `>>`). - While recursion is allowed, ensure that the solution does not overflow the call stack for the given input constraints. - Pay attention to edge cases, such as the inputs being the same or one input being a power of two.","solution":"def add_bitwise(x: int, y: int) -> int: Returns the sum of x and y using only bitwise operations. while y != 0: carry = x & y x = x ^ y y = carry << 1 return x"},{"question":"# Scenario You are working on building an efficient autocomplete and keyword suggestion feature for a large text-based dataset. The goal is to implement a Trie that supports inserting words, searching for words, and checking if any word in the data starts with a given prefix efficiently. # Problem Implement a class Trie with the following methods: 1. **insert(word: str) -> None** - Insert a word into the Trie. 2. **search(word: str) -> bool** - Return `True` if the word is in the Trie, otherwise return `False`. 3. **starts_with(prefix: str) -> bool** - Return `True` if there is any word in the Trie that starts with the given prefix, otherwise return `False`. # Input/Output Formats * **Input**: - `insert(word: str)`: A string `word` consisting of lowercase letters a-z. - `search(word: str)`: A string `word` consisting of lowercase letters a-z. - `starts_with(prefix: str)`: A string `prefix` consisting of lowercase letters a-z. * **Output**: - `insert(word: str)`: No return value. - `search(word: str)`: Boolean value, `True` or `False`. - `starts_with(prefix: str)`: Boolean value, `True` or `False`. # Example ```python trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Returns True print(trie.search(\\"app\\")) # Returns False print(trie.starts_with(\\"app\\")) # Returns True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Returns True ``` # Constraints - Assume all inputs are lowercase. - The functions should run in O(n) time where n is the length of the word/prefix. - Optimize the data structure to handle up to 1,000,000 words efficiently. Implement the `Trie` class and its methods.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_end_of_word = True def search(self, word: str) -> bool: current_node = self.root for char in word: if char not in current_node.children: return False current_node = current_node.children[char] return current_node.is_end_of_word def starts_with(self, prefix: str) -> bool: current_node = self.root for char in prefix: if char not in current_node.children: return False current_node = current_node.children[char] return True"},{"question":"# Graph Cycle Detection using DFS Consider the problem of detecting cycles in directed graphs, which is crucial for applications such as deadlock detection in operating systems or ensuring correctness in workflow dependencies. Problem Statement You are given a directed graph represented as a dictionary where: - **Key**: A node in the graph. - **Value**: A list of nodes to which there is a directed edge from the key node. You need to write a function `has_cycle(graph: Dict[str, List[str]]) -> bool` that determines whether there is a cycle in the graph. **Input Format**: - `graph`: A dictionary where keys are nodes (strings) and values are lists of strings representing directed edges. **Output Format**: - Return `True` if the graph contains a cycle, otherwise `False`. **Constraints**: - All node names in the graph are unique. - The graph may be disconnected. - Nodes can have self-loops. Function Signature ```python def has_cycle(graph: Dict[str, List[str]]) -> bool: pass ``` Examples ```python graph1 = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } assert has_cycle(graph1) == True graph2 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'], \'D\': [] } assert has_cycle(graph2) == True graph3 = { \'A\': [\'B\', \'C\'], \'B\': [], \'C\': [] } assert has_cycle(graph3) == False graph4 = { \'A\': [] } assert has_cycle(graph4) == False graph5 = { \'A\': [\'A\'] } assert has_cycle(graph5) == True ```","solution":"def has_cycle(graph): def dfs(node): if node in visited: return False if node in visiting: return True visiting.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False visiting = set() visited = set() for node in graph: if dfs(node): return True return False"},{"question":"# Missing Sequence Number Identification You are given a list of unique integers in the range [0..n] where the list is missing exactly one number from the range. Your task is to efficiently determine the missing number. If the sequence is already complete, return the number that immediately follows the largest number in the list. Function Signature ```python def find_missing_number(nums: List[int]) -> int: ``` Input * `nums: List[int]` - a list of unique integers in the range `[0, n]`. Output * The missing number in the range `[0, n]`. # Constraints * `1 ≤ len(nums) ≤ 10^6` * The list contains all unique numbers. * The integers in the list are within the range [0..n]. # Examples: Example 1: ```python Input: [4, 1, 3, 0, 6, 5, 2] Output: 7 ``` Example 2: ```python Input: [0, 1, 2, 4] Output: 3 ``` Example 3: ```python Input: [0, 1, 2, 3, 4, 5] Output: 6 ``` Note For the list `[0, 1, 2, 3, 4, 5]`, since it\'s already a complete sequence, the function should return `6`, which is the next number in the sequence. # Requirements * Your solution should run in `O(n)` time complexity and use `O(1)` additional space.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Finds the missing number in the list of unique integers ranging from 0 to n. Arguments: nums: List[int] -- List of unique integers ranging from 0 to n Returns: int -- The missing number in the list n = len(nums) total_sum = n * (n + 1) // 2 actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"# Question You are working on an advanced linked list manipulation utility for a software system. Your task is to implement a function that reverses a cyclic singly linked list. In a cyclic linked list, the last node points back to one of the earlier nodes, potentially creating cycles. Your function should break this cycle and reverse the list. Ensure you handle edge cases like empty lists and single-element lists accurately. # Function Signature ```python def reverse_cyclic_list(head: ListNode) -> ListNode: pass ``` # Input Format - `head` (ListNode): The head of the cyclic singly linked list. `head` is `None` if the list is empty. # Output Format - Returns the new head of the reversed list with no cycles. # Constraints - All node values are unique. - The list must be properly restructured into a non-cyclical reversed list. # Examples 1. Input: `1 --> 2 --> 3 --> 4 --|` (4 points back to `2`) Output: `4 --> 3 --> 2 --> 1` 2. Input: `5 --> 6 --|` (6 points back to `5`) Output: `6 --> 5`","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_cyclic_list(head: ListNode) -> ListNode: if not head: return None # Detect cycle and remove it slow, fast = head, head cycle_detected = False while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: cycle_detected = True break if cycle_detected: # Find the start of the cycle slow = head # Fast is now at the meeting point in the cycle while slow != fast: slow = slow.next fast = fast.next # To remove the cycle, move to the node just before the start of the cycle start_of_cycle = slow while fast.next != start_of_cycle: fast = fast.next # Remove the cycle fast.next = None # Reverse the list prev = None curr = head while curr: next = curr.next curr.next = prev prev = curr curr = next return prev"},{"question":"# Prime Sum Challenge You\'re given a large number ( n ). You need to compute the sum of all prime numbers less than ( n ). For efficiency, you need to use an optimized version of the Sieve of Eratosthenes algorithm, where you only consider odd numbers in the sieve (except for the prime number 2). Input: - A single integer ( n ) where ( n > 0 ). Output: - A single integer representing the sum of all prime numbers less than ( n ). Constraints: - ( 1 leq n leq 10^7 ) - The program should be optimized for both time and space. Example: ```plaintext Input: 10 Output: 17 ``` Explanation: The prime numbers less than 10 are 2, 3, 5, and 7. Their sum is 17. ```python def sum_of_primes(n): Compute the sum of all prime numbers less than n using an optimized Sieve of Eratosthenes. :param n: Integer, the upper limit to find primes. :return: Integer, the sum of all primes less than n. if n <= 1: return 0 sieve_size = (n // 2 - 1) if n % 2 == 0 else (n // 2) sieve = [True] * sieve_size prime_sum = 2 if n > 2 else 0 for i in range(sieve_size): if sieve[i]: prime = i * 2 + 3 prime_sum += prime for multiple in range(i + prime, sieve_size, prime): sieve[multiple] = False return prime_sum # Testing the function print(sum_of_primes(10)) # Should output 17 ``` Notes: Ensure your function handles edge cases such as ( n = 1, n = 2 ) appropriately, and is efficient enough for the upper limit ( n = 10^7 ).","solution":"def sum_of_primes(n): Compute the sum of all prime numbers less than n using an optimized Sieve of Eratosthenes. :param n: Integer, the upper limit to find primes. :return: Integer, the sum of all primes less than n. if n <= 1: return 0 # Create a boolean array \\"prime[0..n)\\" and initialize all entries it as true. # A value in prime[i] will be false if i is Not a prime, else true. sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers p = 2 while p * p < n: # If prime[p] is not changed, then it is a prime if sieve[p]: # Updating all multiples of p to not prime for i in range(p * p, n, p): sieve[i] = False p += 1 # Sum all prime numbers prime_sum = sum(idx for idx, is_prime in enumerate(sieve) if is_prime) return prime_sum"},{"question":"Scenario: You are managing an application where tasks are prioritized based on their importance, and tasks with the highest priority need to be executed first. To efficiently manage this, you decide to use a specialized stack that maintains elements in a sorted order. Task: Implement a class `OrderedStack` that supports basic stack operations (`push`, `pop`, `peek`, and `is_empty`) but ensures that elements in the stack are always sorted in such a way that the largest element is at the top. You should maintain the order of the elements by using an auxiliary stack during the `push` operation. Your implementation should include: 1. The constructor to initialize the stack. 2. `push(item)` method to insert an element in the stack maintaining the sorted order. 3. `pop()` method to remove and return the top element of the stack. 4. `peek()` method to return the top element without removing it. 5. `is_empty()` method to check whether the stack is empty. # Function Specification **Input**: - `push(item)`: an integer value `item` to be inserted. - `pop()`, `peek()`, and `is_empty()` do not take any input. **Output**: - `push(item)` does not return anything. - `pop()`: returns and removes the top element of the stack. - `peek()`: returns the top element of the stack without removal. - `is_empty()`: returns `True` if the stack is empty, otherwise `False`. **Constraints**: - The values inserted will be integers. - All `pop` and `peek` operations are valid (i.e., you will never call them on an empty stack). **Example**: ``` os = OrderedStack() os.push(10) os.push(20) os.push(30) print(os.peek()) # Should return 30 os.push(25) print(os.peek()) # Should return 30 os.pop() print(os.peek()) # Should return 25 print(os.is_empty()) # Should return False ``` Implement the `OrderedStack` class with the specified methods below: ```python class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def push(self, item): temp_stack = OrderedStack() if self.is_empty() or item > self.peek(): self.items.append(item) else: while item < self.peek() and not self.is_empty(): temp_stack.items.append(self.items.pop()) self.items.append(item) while not temp_stack.is_empty(): self.items.append(temp_stack.items.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): return self.items[-1] ```","solution":"class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return len(self.items) == 0 def push(self, item): temp_stack = [] # Move elements that are less than the item to the auxiliary stack while not self.is_empty() and self.peek() > item: temp_stack.append(self.pop()) # Push the new item to the original stack self.items.append(item) # Return elements back from auxiliary stack to the original stack while temp_stack: self.items.append(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items[-1]"},{"question":"Context You work as a software engineer for a company that processes large datasets of numerical values. Your current task is to implement an efficient sorting algorithm suitable for datasets where the range of values is limited and known in advance. Problem Statement Given an array of integers `arr` which can contain both positive and negative numbers, write a function `efficient_counting_sort` that sorts the array in non-decreasing order using the Counting Sort algorithm. Requirements 1. Correctly handle arrays with negative values. 2. Maintain the stability of the sort (preserve the relative order of equal elements). 3. Ensure that the time complexity remains O(n + k) where `k` is the range of the input values and `n` is the number of elements in the array. 4. The function signature should be: `def efficient_counting_sort(arr: List[int]) -> List[int]:` Constraints - The input array can contain up to 10^5 elements. - The range of values in the array is at most 10^5 (from the minimum to the maximum value). Input/Output Formats - **Input**: - `arr`: List of integers, where -10^5 <= arr[i] <= 10^5 - **Output**: - The function should return a sorted list of integers. Example Test Case ```python def test_case(): arr = [4, -1, 2, -3, 5, 3, -2, 0] sorted_arr = efficient_counting_sort(arr) assert sorted_arr == [-3, -2, -1, 0, 2, 3, 4, 5], \\"Test case failed!\\" test_case() ``` Explanation In this example, the array `arr` contains both negative and positive integers. The function should correctly sort the array by first converting all elements to non-negative values using an offset, applying the counting sort algorithm, and then converting the sorted array back to the original values before returning.","solution":"from typing import List def efficient_counting_sort(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) offset = -min_val # Initialize the count array count = [0] * (max_val - min_val + 1) # Store the count of each element for num in arr: count[num + offset] += 1 # Build the sorted array sorted_arr = [] for i, c in enumerate(count): sorted_arr.extend([i - offset] * c) return sorted_arr"},{"question":"# Insertion Sort with Custom Comparator **Scenario**: You are given an array of integers and a custom comparator function. The comparator function is defined such that `comparator(a, b)` returns a negative number if `a` comes before `b`, zero if they are equal, and a positive number if `a` comes after `b`. Your task is to sort the array using the insertion sort algorithm, but instead of using the natural order, you must use the provided comparator function to determine the order of elements. **Function Signature**: ```python def custom_insertion_sort(arr: List[int], comparator: Callable[[int, int], int]) -> List[int]: ``` **Input**: * `arr`: A list of integers to be sorted. * `comparator`: A function that takes two integers and returns an integer. **Output**: * A list of integers sorted according to the custom comparator. **Constraints**: * The length of `arr` will be between 0 and 1000. * The values in `arr` will be between -10^6 and 10^6. **Performance Requirements**: * Expected time complexity: O(n^2). * Expected space complexity: O(1). **Example**: ```python def comparator(a, b): return a - b arr = [4, 2, 3, 1] print(custom_insertion_sort(arr, comparator)) # Output: [1, 2, 3, 4] ``` **Additional Information**: Make sure to handle edge cases such as an empty array or an array with one element. The comparator function should be used to determine the order, and you should not rely on the natural order of the elements.","solution":"from typing import List, Callable def custom_insertion_sort(arr: List[int], comparator: Callable[[int, int], int]) -> List[int]: Performs insertion sort on the given list `arr` using the provided `comparator` function. for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, # to one position ahead of their current position according to the comparator. while j >= 0 and comparator(arr[j], key) > 0: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Question Inverting Large Square Matrices Efficiently **Context**: You are a software engineer working on advanced computational modules for matrix operations. One of the most common and computationally intensive operations is solving linear equations via matrix inversion. Although you have access to a matrix inversion function, it struggles with performance for larger matrices due to its recursive determinants calculation approach. **Task**: Implement an optimized function to invert a given square matrix using an efficient decomposition method. Specifically, use LU Decomposition (or similar) to enhance performance and maintain accuracy. Function Signature ```python def invert_matrix_optimized(m: List[List[float]]) -> List[List[float]]: pass ``` Input * A square matrix `m` of size `n x n` where `2 ≤ n ≤ 100` and each element is a floating-point number. Output * The inverse of the input matrix `m` as a new `n x n` matrix. * If the matrix is singular and cannot be inverted, return `[[0]*n for _ in range(n)]`. Constraints * Matrix is guaranteed to be square. * Matrix entries are guaranteed to be floating numbers. * Edge case where `det(det(m)) == 0` must be handled appropriately. Example ```python # Input m = [ [4, 7], [2, 6] ] # Output result = invert_matrix_optimized(m) # Expected (approx) # [ # [0.6, -0.7], # [-0.2, 0.4] # ] ``` Hints * Consider LU, QR, or similar matrix decomposition methods to optimize the inversion process. * Ensure precise floating-point arithmetic handling, particularly for edge cases when determinant approaches zero. * Remember to handle zero-determinant matrices gracefully by returning an appropriate placeholder matrix.","solution":"from typing import List import numpy as np def invert_matrix_optimized(m: List[List[float]]) -> List[List[float]]: Inverts a given square matrix efficiently using LU decomposition. If the matrix is singular, returns a zero matrix of the same size. n = len(m) matrix = np.array(m) try: inv_matrix = np.linalg.inv(matrix) return inv_matrix.tolist() except np.linalg.LinAlgError: return [[0]*n for _ in range(n)]"},{"question":"# Assessing Nearest Neighbor Classification in Higher-Dimensional Space Problem Description: You are given an implementation of a nearest neighbor algorithm that classifies an input vector `x` based on the closest match from a training set `tSet`. Your task is to improve this implementation, ensuring correctness and efficiency while extending its capabilities to handle higher-dimensional spaces smoothly. Goals: 1. **Function Optimization:** Optimize the nearest neighbor search process considering high-dimensional data. 2. **Edge Case Handling:** Implement comprehensive edge case handling within the algorithm. 3. **Extend Functionality:** Improve the distance function to handle more robust cases, potentially using advanced distance metrics. 4. **Enhance Readability and Efficiency:** Ensure the code is comprehensive, concise, and efficient. Input: 1. A tuple `x` representing the coordinates of the input vector with dimensionality `m`. 2. A dictionary `tSet` where the key is a tuple representing the coordinates of the training vectors and the value is the classification label. Example: ```python x = (1.0, 2.0, 3.0) tSet = { (2.0, 3.0, 4.0): \'A\', (1.0, 2.1, 2.9): \'B\', (0.0, 0.0, 0.0): \'C\' } ``` Output: The function should return the classification label of the nearest neighbor to `x`. # Constraints: 1. You may assume the length of training set vectors equals the length of the input vector `x`. 2. All vectors in `tSet` have the same dimensionality. 3. In case of multiple nearest neighbors with the same minimum distance, return any one of the corresponding labels. 4. The dimensionality `m` can be large (e.g., greater than 100). # Function Signature: ```python def nearest_neighbor(x: tuple, tSet: dict) -> str: # Your optimized code here ``` # Example: ```python x = (1.0, 2.0, 3.0) tSet = { (2.0, 3.0, 4.0): \'A\', (1.0, 2.1, 2.9): \'B\', (0.0, 0.0, 0.0): \'C\' } print(nearest_neighbor(x, tSet)) # Output: \'B\' ``` Requirements: - Ensure the function is efficient for large `tSet`. - Include comments explaining your logic. - Handle typical edge cases robustly.","solution":"from typing import Tuple, Dict import math def euclidean_distance(point1: Tuple[float, ...], point2: Tuple[float, ...]) -> float: Computes the Euclidean distance between two points in k-dimensional space. return math.sqrt(sum((a - b) ** 2 for a, b in zip(point1, point2))) def nearest_neighbor(x: Tuple[float, ...], tSet: Dict[Tuple[float, ...], str]) -> str: Finds the nearest neighbor of the input vector x in the training set tSet and returns the corresponding classification label. if not tSet: raise ValueError(\\"Training set cannot be empty\\") if not all(len(vector) == len(x) for vector in tSet): raise ValueError(\\"All vectors in the training set must have the same dimensionality as the input vector x\\") nearest_point = min(tSet.keys(), key=lambda point: euclidean_distance(point, x)) return tSet[nearest_point]"},{"question":"# Subtree Check in Binary Trees Given two binary trees `s` and `t`, determine if `t` is a subtree of `s`. A subtree of a binary tree `s` is any node `n` of `s` and all of its descendants. Input: - `s`: The root node of a binary tree. - `t`: The root node of another binary tree to check if it is a subtree of `s`. The `TreeNode` structure is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output: - Return `True` if `t` is a subtree of `s`, and `False` otherwise. Constraints: - The number of nodes in `s` and `t` is in the range [1, 2000]. - Both `s` and `t` are binary trees. # Example: **Example 1:** ```plaintext Input: s = [3, 4, 5, 1, 2], t = [4, 1, 2] Output: True ``` **Example 2:** ```plaintext Input: s = [3, 4, 5, 1, 2, null, null, null, null, 0], t = [4, 1, 2] Output: False ``` # Function Signature: Using the `TreeNode` class, implement the function: ```python def is_subtree(s: TreeNode, t: TreeNode) -> bool: ``` Write a solution that is efficient and can handle a potential scenario where one tree is significantly larger than the other.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(s: TreeNode, t: TreeNode) -> bool: if not s: return False if is_same_tree(s, t): return True return is_subtree(s.left, t) or is_subtree(s.right, t) def is_same_tree(s: TreeNode, t: TreeNode) -> bool: if not s and not t: return True if not s or not t: return False if s.val != t.val: return False return is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right)"},{"question":"**Problem Statement:** A researcher needs to determine the number of distinct wildlife reserves in a vast forest region. The forest is represented as a 2D grid where \'1\'s indicate land, and \'0\'s indicate water. Reserves are defined as contiguous blocks of land connected either horizontally or vertically. **Objective:** Write a function `count_wildlife_reserves(grid)` that takes a list of lists `grid` (containing only \'1\'s and \'0\'s) and returns an integer representing the total number of distinct wildlife reserves. **Constraints:** - The grid dimensions are given by `m` x `n` (1 ≤ m, n ≤ 300). - Each cell in the grid is either \'1\' (land) or \'0\' (water). **Example:** ```python grid = [ [1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0] ] assert count_wildlife_reserves(grid) == 1 grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] assert count_wildlife_reserves(grid) == 3 ``` **Notes:** - Your function should modify the input grid to mark the visited cells (this modifies the in-place grid during execution). - Ensure your solution handles edge cases, including but not limited to empty grids and entirely water-filled grids. Consider using an iterative approach to prevent recursion limit issues, especially for large grids. **Function Signature:** ```python def count_wildlife_reserves(grid: List[List[int]]) -> int: # Implementation here ``` Ensure your solution is efficient and scales for large grid sizes while maintaining readability and robust handling of edge cases.","solution":"def count_wildlife_reserves(grid): Returns the number of distinct wildlife reserves in the given grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) def dfs(i, j): Depth-First Search to mark all parts of a connected reserve stack = [(i, j)] while stack: x, y = stack.pop() if 0 <= x < m and 0 <= y < n and grid[x][y] == 1: grid[x][y] = 0 # Mark as visited # Add neighbors to the stack stack.extend([(x-1, y), (x+1, y), (x, y-1), (x, y+1)]) reserve_count = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: reserve_count += 1 dfs(i, j) return reserve_count"},{"question":"# Context Radix Sort is an efficient non-comparative integer sorting algorithm that sorts numbers by processing individual digits. This algorithm sorts the elements by iteratively processing digits from the least significant to the most significant digit using a bucket-based approach. # Task Implement a modified version of the Radix Sort algorithm that includes the following features: 1. The algorithm should also handle negative integers. 2. The implementation should offer customization to sort floating-point numbers based on digit precision. 3. You must ensure the algorithm works on arrays with both integers and floating-point numbers of varying digit lengths. # Function Signature ```python def radix_sort_enhanced(arr: List[Union[int, float]], precision: int) -> List[Union[int, float]]: pass ``` # Input 1. `arr`: A list containing integers and floating-point numbers. 2. `precision`: An integer that specifies the number of significant digits to consider for sorting floating-point numbers. # Output - Returns a list that is sorted in ascending order. # Constraints - The input list can be of any size up to 10^6 elements. - Floating-point numbers will be limited to two decimal places. - Both positive and negative numbers can be present in the list. # Example ```python arr = [170, -45.67, 73, -902, 7.89, 802, 2.32] precision = 2 print(radix_sort_enhanced(arr, precision)) # Output: [-902, -45.67, 2.32, 7.89, 73, 170, 802] ``` # Notes - Ensure the algorithm maintains the relative order for elements with the same digit values (stability). - Consider both integer and floating-point number handling separately while ensuring the final combined list is sorted. - Thoroughly test edge cases such as empty lists, single element lists, and lists with same digit variations.","solution":"from typing import List, Union def get_digit(number, digit_index, base=10): Extracts the digit at the specified index from the right. return (abs(number) // base ** digit_index) % base def counting_sort(arr, digit_index, base=10): Performs a counting sort on the given digit index. n = len(arr) output = [0] * n count = [0] * base # Count occurrences of digits for number in arr: digit = get_digit(number, digit_index, base) count[digit] += 1 # Change count[i] so it contains the actual position of this digit in output[] for i in range(1, base): count[i] += count[i - 1] # Build the output array for i in range(n - 1, -1, -1): digit = get_digit(arr[i], digit_index, base) output[count[digit] - 1] = arr[i] count[digit] -= 1 # Return the sorted array according to the current digit index return output def radix_sort(arr): Perform a radix sort on integers. if len(arr) == 0: return [] max_number = max(abs(num) for num in arr) num_digits = len(str(max_number)) for digit_index in range(num_digits): arr = counting_sort(arr, digit_index) return arr def handle_negative_numbers(arr): Separates positive and negative integers, sorts them individually, and recombines. pos = [num for num in arr if num >= 0] neg = [-num for num in arr if num < 0] pos_sorted = radix_sort(pos) neg_sorted = radix_sort(neg) return [-num for num in reversed(neg_sorted)] + pos_sorted def handle_floats(arr, precision): Adjusts floats to be sorted based on given precision. factor = 10**precision adjusted_arr = [int(num * factor) for num in arr] pos = [(num, idx) for idx, num in enumerate(adjusted_arr) if arr[idx] >= 0] neg = [(num, idx) for idx, num in enumerate(adjusted_arr) if arr[idx] < 0] pos_sorted = radix_sort([num for num, _ in pos]) neg_sorted = radix_sort([num for num, _ in neg]) pos_with_orig = [arr[idx] for _, idx in sorted(pos, key=lambda x: x[0])] neg_with_orig = [arr[idx] for _, idx in sorted(neg, key=lambda x: x[0])] return neg_with_orig + pos_with_orig def radix_sort_enhanced(arr: List[Union[int, float]], precision: int) -> List[Union[int, float]]: if not arr: return [] ints = [num for num in arr if isinstance(num, int)] floats = [num for num in arr if isinstance(num, float)] sorted_ints = handle_negative_numbers(ints) sorted_floats = handle_floats(floats, precision) merged = sorted(sorted_ints + sorted_floats) return merged"},{"question":"# Question: URL Query Parameter Normalizer You are tasked with writing a function that normalizes the query string parameters of a given URL. Specifically: 1. **Remove any duplicate query string parameters, retaining only the first occurrence.** 2. **Optionally, remove any query string parameters specified within a second argument (an optional list).** **Function Signature:** ```python def normalize_url(url: str, params_to_remove: List[str] = []) -> str: pass ``` **Input:** - `url` (string): A valid URL which may contain query string parameters. - `params_to_remove` (list of strings, optional): A list of query string parameter names to be removed from the URL. **Output:** - A string representing the URL with normalized query string parameters. **Constraints:** 1. URLs will follow the standard format `scheme://netloc/path;parameters?query#fragment`. 2. Each query string parameter will follow the format `key=value`. 3. If a query string appears more than once with different values, the first occurrence should be retained. 4. Parameters specified in `params_to_remove` should be completely removed if present. 5. You may assume the given `url` is always a valid URL and the encoding is proper. **Performance Requirements:** - The solution should be efficient with a time complexity of O(n) where n is the length of the query string. **Example:** - Example 1: ```python url = \\"www.example.com?a=1&b=2&a=3&c=4\\" params_to_remove = [] assert normalize_url(url, params_to_remove) == \\"www.example.com?a=1&b=2&c=4\\" ``` - Example 2: ```python url = \\"www.example.com?a=1&b=2&c=3&b=4\\" params_to_remove = [\\"b\\"] assert normalize_url(url, params_to_remove) == \\"www.example.com?a=1&c=3\\" ``` - Example 3: ```python url = \\"www.example.com\\" params_to_remove = [\\"a\\"] assert normalize_url(url, params_to_remove) == \\"www.example.com\\" ``` **Instructions:** - Implement the function `normalize_url` without using external libraries for URL parsing. - Ensure to handle the edge cases, such as URLs without query strings or with complex query formats. - Write clean, readable, and efficient code.","solution":"from urllib.parse import urlparse, parse_qs, urlencode, urlunparse def normalize_url(url: str, params_to_remove: list = []) -> str: # Parse the URL into components parsed_url = urlparse(url) # Parse the query string into a dictionary (with lists of values) query_dict = parse_qs(parsed_url.query) # Create a new dictionary that retains only the first value for each key new_query_dict = {k: v[0] for k, v in query_dict.items() if k not in params_to_remove} # Reconstruct the query string new_query_string = urlencode(new_query_dict, doseq=False) # Rebuild the full URL with normalized query string normalized_url = urlunparse( parsed_url._replace(query=new_query_string) ) return normalized_url"},{"question":"You are given the task of ensuring consistency in saving and retrieving binary trees for a cloud-based data storage system. The system requires the ability to serialize (convert a binary tree to a string) and deserialize (reconstruct the binary tree from a string). Your solution should be efficient and handle large datasets. Function Signature - For serialization: ```python def serialize(root: TreeNode) -> str: ``` - For deserialization: ```python def deserialize(data: str) -> TreeNode: ``` Input - **For `serialize` function**: * `root`: The root node of the binary tree (or None for an empty tree). - **For `deserialize` function**: * `data`: The string representation of the serialized binary tree. Output - **For `serialize` function**: * A string representing the pre-order traversal of the binary tree with \\"#\\" indicating null nodes. - **For `deserialize` function**: * The root node of the reconstructed binary tree. Constraints - The number of nodes in the binary tree will not exceed 100,000. - Node values are integers ranging from -1000 to 1000. - The length of the serialized string will be within the limits of typical string handling in Python. Example ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None # Example Binary Tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized = serialize(root) print(serialized) # \\"1 2 # # 3 4 # # 5 # #\\" deserialized = deserialize(serialized) print(serialize(deserialized)) # \\"1 2 # # 3 4 # # 5 # #\\" ``` Requirements 1. Implement the `serialize` function to convert a binary tree to its string representation. 2. Implement the `deserialize` function to convert the string back to the original binary tree structure. 3. Ensure edge cases like empty trees and highly unbalanced trees are handled correctly. 4. Your solution should be efficient in terms of time and space complexity, even for large binary trees.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: Encodes a binary tree to a single string. def helper(node): if node is None: return \\"#\\" return f\\"{node.val} {helper(node.left)} {helper(node.right)}\\" return helper(root) def deserialize(data: str) -> TreeNode: Decodes your encoded data to tree. def helper(nodes): val = next(nodes) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = helper(nodes) node.right = helper(nodes) return node nodes = iter(data.split()) return helper(nodes)"},{"question":"# Gnome Sort Variant Implementation Objective You are tasked with implementing a variant of the Gnome Sort algorithm in Python that supports sorting a list of tuples by any specified index of the tuples. Detailed Requirements * Input: A list `arr` of tuples where each tuple contains two integer values, and an index `idx` indicating which element of the tuple should be used for sorting. * Output: A list of tuples sorted in non-decreasing order based on the elements at the specified index. * Constraints: * (1 leq text{len}(arr) leq 10^5) * Each tuple will contain exactly two integers. * The specified index `idx` is either `0` or `1`. Example * Input: `arr = [(4, 5), (3, 2), (1, 8)]`, `idx = 1` * Output: `[(3, 2), (4, 5), (1, 8)]` * Input: `arr = [(9, 4), (3, 2), (1, 5)]`, `idx = 0` * Output: `[(1, 5), (3, 2), (9, 4)]` Function Signature ```python def gnome_sort_tuples(arr: List[Tuple[int, int]], idx: int) -> List[Tuple[int, int]]: pass ``` Implementation Write a function `gnome_sort_tuples` that: * Uses Gnome Sort logic to sort based on the index specified. * Efficiently handles the edge cases mentioned in the analysis section.","solution":"from typing import List, Tuple def gnome_sort_tuples(arr: List[Tuple[int, int]], idx: int) -> List[Tuple[int, int]]: Sorts the list of tuples by the specified index using the Gnome Sort algorithm. n = len(arr) pos = 0 while pos < n: if pos == 0 or arr[pos][idx] >= arr[pos - 1][idx]: pos += 1 else: arr[pos], arr[pos - 1] = arr[pos - 1], arr[pos] pos -= 1 return arr"},{"question":"# Stock Buy and Sell Maximum Profit Suppose you have an array of integers where the (i)-th element represents the price of a given stock on day (i). You are only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock). Your task is to design an algorithm that finds the maximum profit possible from this one transaction. If no transaction results in a profit, the maximum profit should be zero. # Input and Output * **Input**: - An integer array `prices` of length (n), where (n geq 1). - Each element (prices[i]) (where (0 leq i < n)) represents the price of the stock on the (i)-th day. * **Output**: - An integer value representing the maximum profit you can achieve from a single transaction. # Constraints - (1 leq n leq 10^5) - (0 leq prices[i] leq 10^4) # Example Example 1 **Input**: [7, 1, 5, 3, 6, 4] **Output**: 5 **Explanation**: The best day to buy the stock is day 1 (price = 1) and the best day to sell it is day 4 (price = 6). The maximum profit is (6 - 1 = 5). Example 2 **Input**: [7, 6, 4, 3, 1] **Output**: 0 **Explanation**: No transaction is possible such that buying price is less than the selling price. Hence, the maximum profit is zero. # Function Signature ```python def maxProfit(prices: List[int]) -> int: # Your code here ``` # Requirements - Implement an efficient solution with linear time complexity and constant space usage. - Consider edge cases and ensure your solution handles them appropriately.","solution":"from typing import List def maxProfit(prices: List[int]) -> int: Finds the maximum profit that could be achieved from a single buy and sell transaction. Args: prices (List[int]): List of stock prices where prices[i] is the price of a given stock on day i. Returns: int: Maximum profit achievable, or 0 if no profit is possible. if not prices: return 0 min_price = prices[0] max_profit = 0 for price in prices: if price < min_price: min_price = price profit = price - min_price if profit > max_profit: max_profit = profit return max_profit"},{"question":"Given a stack, your task is to implement a function `remove_min` that removes the smallest value from the stack. The function should retain the order and properties of the original stack, except for the missing smallest element. Your solution should handle edge cases, such as an empty stack, gracefully. Your implementation should adhere to the following constraints and requirements: Input and Output Specifications * **Input**: A stack represented as a list of integers. * **Output**: The modified stack with the smallest value removed. Constraints and Assumptions * The input stack can be empty. * The stack can contain duplicate values, including multiple instances of the minimum value. * You must use the stack operations (push and pop) provided directly and cannot use built-in functions that directly manipulate the list structure globally. ```python def remove_min(stack): Remove the smallest value from the stack without violating the stack\'s LIFO properties. :param stack: List of integers representing the stack. :return: Modified stack with the smallest value removed. # Your implementation here ``` Scenario: Imagine you are in charge of maintaining a track of the lowest elevation points during a trek. You have a stack that records the elevations in the order they were traversed. In order to report the lowest elevation point encountered during the trek, you need to remove it from your records stack. Test Examples: 1. Given Stack: [2, 8, 3, -6, 7, 3] After `remove_min`: [2, 8, 3, 7, 3] 2. Given Stack: [5, 4, 2, 1, 3] After `remove_min`: [5, 4, 2, 3] 3. Given Stack: [] After `remove_min`: [] Write `remove_min` to pass these scenarios efficiently and correctly. Ensure your solution considers and handles edge cases such as an empty stack or multiple instances of the minimum value.","solution":"def remove_min(stack): Remove the smallest value from the stack without violating the stack\'s LIFO properties. :param stack: List of integers representing the stack. :return: Modified stack with the smallest value removed. if not stack: return stack # Step 1: Find the minimum value in the stack min_value = float(\'inf\') for value in stack: if value < min_value: min_value = value # Step 2: Create a temporary stack to hold elements except the first occurrence of the minimum value temp_stack = [] min_removed = False # Step 3: Transfer elements to the temp stack, skipping the first occurrence of min_value while stack: value = stack.pop() if value == min_value and not min_removed: min_removed = True else: temp_stack.append(value) # Step 4: Transfer elements back to the original stack to maintain order while temp_stack: stack.append(temp_stack.pop()) return stack"},{"question":"# Scenario You are tasked with implementing additional functionalities for a system using a min binary heap. The system is used in a scheduler where tasks with varying priorities are managed. Each task has a unique priority, and the scheduler needs to efficiently manage these tasks. # Question Implement a function in Python that extends the given `BinaryHeap` class to include: 1. **Find Min**: A method to find and return the value of the minimum element without removing it. 2. **Change Priority**: A method to change the priority of an existing element and reheapify the heap accordingly. # Implementation Requirements - **Input**: - For the `find_min` method: No input parameter. - For the `change_priority` method: Two parameters - the current value of the element and its new priority. - **Output**: - `find_min` should return the value of the minimum element. - `change_priority` should return the updated heap. # Constraints - Avoid using any external libraries except for standard Python collections. - Ensure that both methods operate within acceptable time complexities, optimizing where possible. # Expected Function Signatures ```python class ExtendedBinaryHeap(BinaryHeap): def find_min(self): pass def change_priority(self, current_value, new_priority): pass ``` # Example ```python # Example usage of ExtendedBinaryHeap # Create min heap and insert elements heap = ExtendedBinaryHeap() heap.insert(4) heap.insert(50) heap.insert(7) heap.insert(55) heap.insert(90) heap.insert(87) # Initial heap time: # 4 # / # 50 7 # / / #55 90 87 # Find minimum element print(heap.find_min()) # Output: 4 # Change priority of 50 to 3 heap.change_priority(50, 3) # New heap time: # 3 # / # 4 7 # / / #55 90 87 ``` # Notes - Properly handle cases where the element to change priority is not found. - Maintain the heap property after performing changes.","solution":"class ExtendedBinaryHeap: def __init__(self): self.heap = [] def insert(self, item): self.heap.append(item) self._perc_up(len(self.heap) - 1) def _perc_up(self, i): while (i - 1) // 2 >= 0: parent_idx = (i - 1) // 2 if self.heap[i] < self.heap[parent_idx]: self.heap[i], self.heap[parent_idx] = self.heap[parent_idx], self.heap[i] i = parent_idx def _perc_down(self, i): while (2 * i + 1) < len(self.heap): min_child_idx = self._min_child(i) if self.heap[i] > self.heap[min_child_idx]: self.heap[i], self.heap[min_child_idx] = self.heap[min_child_idx], self.heap[i] i = min_child_idx def _min_child(self, i): if (2 * i + 2) >= len(self.heap): return 2 * i + 1 else: if self.heap[2 * i + 1] < self.heap[2 * i + 2]: return 2 * i + 1 else: return 2 * i + 2 def find_min(self): if self.heap: return self.heap[0] return None def change_priority(self, current_value, new_priority): if current_value not in self.heap: return \\"Value not found in heap.\\" idx = self.heap.index(current_value) if new_priority > current_value: self.heap[idx] = new_priority self._perc_down(idx) else: self.heap[idx] = new_priority self._perc_up(idx) return self.heap"},{"question":"# Hailstone Alignment Challenge In this task, you are required to write a Python function that generates the hailstone sequence (Collatz sequence) from a given starting integer `n` and then aligns the elements of the sequence into pairs. Each pair consists of the current number and the next, stopping before the final `1`. Function Signature ```python def hailstone_pairs(n: int) -> List[Tuple[int, int]]: pass ``` Input - An integer `n` where `1 <= n <= 10^6`. Output - A list of tuples, where each tuple contains two integers representing consecutive elements of the hailstone sequence. Constraints - You must ensure that the input `n` is a positive integer. - You must handle large values efficiently to avoid performance issues. Example ```python assert hailstone_pairs(10) == [(10, 5), (5, 16), (16, 8), (8, 4), (4, 2), (2, 1)] assert hailstone_pairs(6) == [(6, 3), (3, 10), (10, 5), (5, 16), (16, 8), (8, 4), (4, 2), (2, 1)] ``` # Requirements 1. Implement the `hailstone_pairs` function using the hailstone sequence generation rules. 2. Ensure your solution handles the large inputs efficiently within reasonable time limits. 3. Your function should work correctly for all integers between 1 and 1,000,000. # Evaluation Criteria 1. **Correctness**: The function returns the correct pairs based on the hailstone sequence rules. 2. **Efficiency**: The solution handles large input sizes and does not show performance degradation. 3. **Edge Cases**: The function correctly processes all lower and upper bound cases. 4. **Code Quality**: Clean and readable code, with appropriate comments and consistent naming conventions.","solution":"from typing import List, Tuple def hailstone_pairs(n: int) -> List[Tuple[int, int]]: Generates the hailstone sequence pairs from a given starting integer n. :param n: Starting integer for the hailstone sequence. :return: A list of tuples where each tuple contains two consecutive elements of the hailstone sequence. if n < 1: raise ValueError(\\"Input must be a positive integer.\\") sequence = [] while n != 1: if n % 2 == 0: next_n = n // 2 else: next_n = 3 * n + 1 sequence.append((n, next_n)) n = next_n return sequence"},{"question":"You are required to implement a function that increments a non-negative number represented as an array of its digits. The function should take in a list of integers where each integer is a single digit (0-9), with the most significant digit at the start of the list, and should return a new list representing the incremented number. # Function Signature ```python def plus_one(digits: List[int]) -> List[int]: ``` # Input - `digits`: A list of integers `[d1, d2, ... dn]` where `0 <= di <= 9`. # Output - A list of integers representing the incremented number. # Constraints - The number does not contain leading zeros except when the number itself is zero. - The input list is non-empty. # Example Example 1 **Input**: ```python digits = [1, 2, 3] ``` **Output**: ```python [1, 2, 4] ``` **Explanation**: Incrementing 123 by one gives 124. Example 2 **Input**: ```python digits = [9, 9, 9] ``` **Output**: ```python [1, 0, 0, 0] ``` **Explanation**: Incrementing 999 by one gives 1000, hence the result. # Edge Cases to Consider - Adding one to numbers represented with trailing zeros. - Dealing with carry-over propagation. - Lists with a single digit. Design an optimal and efficient implementation that reflects a strong understanding of array-based manipulations and handling carry operations effectively.","solution":"from typing import List def plus_one(digits: List[int]) -> List[int]: Increments a number represented as a list of digits by one. Parameters: digits (List[int]): List of integers where each integer is a single digit Returns: List[int]: New list of integers representing the incremented number n = len(digits) for i in reversed(range(n)): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If we reach here, it means all the digits were 9. return [1] + [0] * n"},{"question":"You are given an array of integers representing daily temperature changes. Your task is to implement a function that finds the maximum sum of any contiguous subarray, which would represent the period with the highest overall increase in temperature. # Function Definition Implement the following function: ```python def max_contiguous_subsequence_sum(arr: List[int]) -> int: ``` # Input * `arr`: A list of integers where each integer represents a change in temperature on a given day. # Output * Returns the maximum sum of any contiguous subarray of the given array of integers. # Constraints * The array will have at most `10^5` elements. * The integers will be in the range `[-10^4, 10^4]`. # Example ```python assert max_contiguous_subsequence_sum([-2, 3, 8, -1, 4]) == 14 # The subarray is [3, 8, -1, 4] assert max_contiguous_subsequence_sum([-1, 1, 0]) == 1 # The subarray is [1] assert max_contiguous_subsequence_sum([-1, -3, -4]) == -1 # The subarray is [-1] assert max_contiguous_subsequence_sum([]) == 0 # Edge case for an empty array ``` # Performance Requirements * The function should run in linear time, O(n). * The function should utilize constant space, O(1). # Special Notes 1. Your implementation should handle cases when the array is empty by returning 0. 2. You should consider negative numbers and the possibility of the entire array containing negative values, in which case picking the least negative number is optimal.","solution":"from typing import List def max_contiguous_subsequence_sum(arr: List[int]) -> int: if not arr: return 0 max_sum = arr[0] current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are required to implement a dynamic set that optimizes the following operations to run in average O(1) time: 1. Adding an element to the set (`insert`). 2. Removing an element from the set (`remove`). 3. Fetching a random element from the set (`random_element`). Function Signature: ```python class RandomizedSet: def __init__(self): pass def insert(self, val: int) -> bool: pass def remove(self, val: int) -> bool: pass def random_element(self) -> int: pass ``` # Inputs: - `insert(val: int) -> bool`: Adds the provided integer `val` to the set if not already present. Returns `True` if the element was inserted, and `False` if it was already present. - `remove(val: int) -> bool`: Removes the provided integer `val` from the set if present. Returns `True` if the element was removed, and `False` if it didn\'t exist in the set. - `random_element() -> int`: Returns a random element from the set. If the set is empty, should raise an appropriate exception. # Constraints: - You may assume that all elements are integers. - The operations should achieve average O(1) time complexity. # Example: ```python rset = RandomizedSet() print(rset.insert(1)) # True print(rset.insert(1)) # False print(rset.remove(1)) # True print(rset.remove(1)) # False print(rset.insert(2)) # True print(rset.random_element()) # 2 ``` Please ensure your solution handles edge cases like empty set and non-existent element deletions smoothly.","solution":"import random class RandomizedSet: def __init__(self): self.data = [] self.index_map = {} def insert(self, val: int) -> bool: if val in self.index_map: return False self.index_map[val] = len(self.data) self.data.append(val) return True def remove(self, val: int) -> bool: if val not in self.index_map: return False last_element = self.data[-1] idx_to_remove = self.index_map[val] self.data[idx_to_remove] = last_element self.index_map[last_element] = idx_to_remove self.data.pop() del self.index_map[val] return True def random_element(self) -> int: if not self.data: raise Exception(\\"Set is empty\\") return random.choice(self.data)"},{"question":"# Context: Given a Red-Black tree implementation, you\'re required to modify the tree to ensure it supports range queries. Specifically, you\'ll add a method to find all nodes within a specified range [a, b]. # Task: Implement a function `range_query(self, a: int, b: int) -> List[int]` in the `RBTree` class. This function should return a list of all node values that fall within the inclusive range ([a, b]). The returned list should be sorted in ascending order. # Input: - `a` (int): Lower bound of the range. - `b` (int): Upper bound of the range. # Output: - List of integers containing the values of the nodes within the specified range, sorted in ascending order. # Constraints: - The lower bound `a` and upper bound `b` will always satisfy (a leq b). - The values within the tree are unique. # Example: Suppose the tree contains the values: [11, 2, 14, 1, 7, 15, 5, 8, 4]. Calling `range_query(4, 10)` should return `[4, 5, 7, 8]`. # Requirements: - Implementation should maintain the logarithmic complexity where possible. - Ensure that the property of the Red-Black tree is not violated after the query (though range query typically doesn’t modify the tree structure).","solution":"class TreeNode: def __init__(self, data, color, left=None, right=None, parent=None): self.data = data self.color = color self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.TNULL = TreeNode(0, \'black\') self.root = self.TNULL def range_query(self, a: int, b: int): result = [] self._range_query_helper(self.root, a, b, result) return result def _range_query_helper(self, node, a, b, result): if node == self.TNULL or node is None: return if a < node.data: self._range_query_helper(node.left, a, b, result) if a <= node.data <= b: result.append(node.data) if b > node.data: self._range_query_helper(node.right, a, b, result) # Helper methods for inserting nodes, maintaining the Red-Black Tree properties, etc., would go here. # For simplicity, I am not including the full Red-Black Tree implementation as the focus is on the range query."},{"question":"# Decoding Count Problem Given an encoded message containing digits, your task is to determine the total number of ways it can be decoded. The mapping from letters to numbers is as follows: ``` \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 ``` For example, the encoded message \\"12\\" can be decoded as: - \\"AB\\" (1 2) - \\"L\\" (12) Thus, the number of ways to decode \\"12\\" is 2. Write a function `num_decodings(s)` that takes a single string `s` containing the encoded message and returns the total number of ways to decode it. Function Signature: ```python def num_decodings(s: str) -> int: ``` # Input * A single string `s` containing the encoded message. * Constraints: * 1 <= `len(s)` <= 100 * `s` contains only digits and does not contain leading zeros. # Output * An integer representing the total number of ways to decode the string. # Example 1. Input: `\\"12\\"` Output: `2` Explanation: `\\"12\\"` can be decoded as \\"AB\\" (1 2) or \\"L\\" (12). 2. Input: `\\"226\\"` Output: `3` Explanation: `\\"226\\"` can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). 3. Input: `\\"0\\"` Output: `0` Explanation: `\\"0\\"` cannot be decoded. 4. Input: `\\"06\\"` Output: `0` Explanation: `\\"06\\"` is an invalid encoding. # Notes: * Your solution should handle edge cases efficiently. * Your function should consider performance and avoid unnecessary space usage.","solution":"def num_decodings(s: str) -> int: if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 if s[0] != \'0\' else 0 for i in range(2, n + 1): one_digit = int(s[i-1:i]) two_digits = int(s[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"Counting the Number of Digits Context: You are working on a project that requires frequent validation of input numbers based on the number of digits they have. A function is required to determine the number of digits in any integer. This will be a utility function that can then be reused across various parts of the project. Task: Write a Python function `count_digits(n)` that takes an integer `n` as input and returns the number of digits in the integer. Function Signature: ```python def count_digits(n: int) -> int: pass ``` Input: * An integer `n` where -10^9 <= n <= 10^9. Output: * An integer representing the number of digits in the input integer. Constraints: * The function must handle all edge cases, including zero and negative numbers. * Aim to implement the function with time complexity O(1) and space complexity O(1). Examples: * `count_digits(12345)` should return `5` * `count_digits(-12345)` should return `5` * `count_digits(0)` should return `1` * `count_digits(1000000)` should return `7` Performance Requirements: Ensure the function is optimized to handle the largest and smallest possible values efficiently.","solution":"def count_digits(n: int) -> int: Returns the number of digits in the integer n. # Handle the negative number by taking its absolute value return len(str(abs(n)))"},{"question":"# Question: Reverse a Segment of a Singly Linked List **Context**: You are given a singly linked list and two integer positions `m` and `n` where 1 <= m <= n <= length of the list. Your task is to reverse the nodes of the list from position `m` to `n`. **Function Definition**: Write a function `reverse_segment(head, m, n)` that reverses the nodes of the list from position `m` to `n` and returns the modified list. ```python def reverse_segment(head, m, n): :type head: ListNode :type m: int :type n: int :rtype: ListNode ``` **Input**: - `head`: The head of the singly linked list (ListNode). - `m`: An integer indicating the start position of the segment to be reversed (1-indexed). - `n`: An integer indicating the end position of the segment to be reversed (1-indexed). **Output**: - The head of the modified linked list (ListNode). **Example**: ```python Input: 1 -> 2 -> 3 -> 4 -> 5, and m = 2, n = 4 Output: 1 -> 4 -> 3 -> 2 -> 5 ``` **Constraints**: - The number of nodes in the list will not exceed 10^4. - 1 <= m <= n <= length of the linked list. - Your algorithm should run in O(n) time and use only O(1) extra space.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def reverse_segment(head, m, n): if m == n: return head dummy = ListNode(0) dummy.next = head prev = dummy # Move prev to right before the segment to be reversed for _ in range(m - 1): prev = prev.next reverse_start = prev.next then = reverse_start.next # Reverse the defined part of the linked list for _ in range(n - m): reverse_start.next = then.next then.next = prev.next prev.next = then then = reverse_start.next return dummy.next"},{"question":"# RSA Key Generation and Encryption/Decryption Exercise **Objective**: Implement the RSA encryption, decryption, and key generation algorithms and demonstrate basic understanding by applying the RSA algorithm to encrypt and decrypt a given number. **Description**: - **Step 1**: Implement the RSA key generation function to create a public and private key pair. - **Step 2**: Implement the encrypt and decrypt functions to illustrate the encryption and decryption process. **Function Signature**: 1. `def generate_key(k: int, seed: int = None) -> Tuple[int, int, int]:` 2. `def encrypt(data: int, e: int, n: int) -> int:` 3. `def decrypt(data: int, d: int, n: int) -> int:` # Requirements 1. **generate_key function**: Given the bit length `k` of the modulus `n`, generate the public and private key pair `(public_key, private_key, modulus)`. - **Input**: - `k` (integer): Number of bits in modulus. - `seed` (integer, optional): Seed value for random number generator. - **Output**: - Tuple of three integers `(n, e, d)`. - **Constraints**: `k >= 16` 2. **encrypt function**: Given a number `data`, the public key exponent `e`, and modulus `n`, encrypt the `data`. - **Input**: - `data` (integer): Number to be encrypted. - `e` (integer): Public key exponent. - `n` (integer): Modulus. - **Output**: - Encrypted integer. 3. **decrypt function**: Given an encrypted number `data`, the private key exponent `d`, and modulus `n`, decrypt the data. - **Input**: - `data` (integer): Encrypted number. - `d` (integer): Private key exponent. - `n` (integer): Modulus. - **Output**: - Decrypted integer. # Example Usage ```python # Generate RSA keys n, e, d = generate_key(16) # Original data data = 20 # Encrypt the data encrypted = encrypt(data, e, n) # Decrypt the encrypted data decrypted = decrypt(encrypted, d, n) # Validate the decryption matches the original data assert decrypted == data, \\"Decryption failed\\" ``` # Additional Information: - Consider edge cases where small primes might be selected. - Validate the inputs to ensure that the keys generated are valid for RSA encryption/decryption. - Optimize prime number generation for better performance.","solution":"import random import sympy def generate_key(k: int, seed: int = None): Generates an RSA key pair. :param k: Number of bits of the modulus n. :param seed: Seed for the random number generator. :return: A tuple (n, e, d) if seed is not None: random.seed(seed) # Generate two distinct prime numbers p and q p = sympy.randprime(2**(k//2 - 1), 2**(k//2)) q = sympy.randprime(2**(k//2 - 1), 2**(k//2)) while p == q: q = sympy.randprime(2**(k//2 - 1), 2**(k//2)) n = p * q phi = (p - 1) * (q - 1) # Select integer e such that 1 < e < phi(n) and gcd(e, phi(n)) = 1 e = random.randrange(2, phi) while sympy.gcd(e, phi) != 1: e = random.randrange(2, phi) # Calculate d, the modular inverse of e: d = pow(e, -1, phi) return n, e, d def encrypt(data: int, e: int, n: int) -> int: Encrypts a message with RSA encryption. :param data: Integer representation of the message. :param e: Public key exponent. :param n: Modulus. :return: Encrypted data. return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: Decrypts a message with RSA encryption. :param data: Encrypted integer data. :param d: Private key exponent. :param n: Modulus. :return: Decrypted data. return pow(data, d, n)"},{"question":"# Pancake Sort Implementation Context Pancake Sort is a unique and interesting sorting algorithm that sorts an array of numbers by repeatedly reversing segments (\\"flips\\") of the array. This problem will help you understand the fundamentals of sorting algorithms and their complexity. Problem Statement Implement the Pancake Sort algorithm. Your function should take an unsorted list of integers and return the list sorted in ascending order. The sorting has to be done in-place, i.e., without using extra space for another list. # Function Signature ```python def pancake_sort(arr: list[int]) -> list[int]: # Your code here ``` # Input - `arr`: A list of integers (1 ≤ len(arr) ≤ 1000). # Output - Return a list of integers sorted in ascending order. # Constraints - The list may contain duplicate elements. - The elements in the list are within the range of -10^4 to 10^4. # Example ```python # Example 1 input = [3, 2, 4, 1] output = [1, 2, 3, 4] # Example 2 input = [10, 5, 4, 3, 2, 1] output = [1, 2, 3, 4, 5, 10] ``` # Performance Requirement - The function should sort the list with a time complexity of O(N^2). # Edge Cases - Your implementation should handle: - Input lists with a single element. - List already sorted in descending and ascending order. - Lists with all identical elements.","solution":"def pancake_sort(arr: list[int]) -> list[int]: def flip(sublist, k): start = 0 while start < k: sublist[start], sublist[k] = sublist[k], sublist[start] start += 1 k -= 1 n = len(arr) for size in range(n, 1, -1): max_idx = max(range(size), key=arr.__getitem__) if max_idx != size - 1: flip(arr, max_idx) flip(arr, size - 1) return arr"},{"question":"Scenario You are a software developer for an e-commerce website that receives real-time data about the prices of products from multiple vendors. However, the range of these prices is known to be limited. To ensure that the product prices are always sorted to facilitate efficient searching, you need to write a function to sort this data efficiently. Task Implement the function `pigeonhole_sort` that takes a list of integers `arr` and returns the list sorted in non-decreasing order using the Pigeonhole Sorting algorithm. Input Format - A list of integers `arr` where `1 <= len(arr) <= 10^6` and `-10^5 <= arr[i] <= 10^5`. Output Format - A list of integers sorted in non-decreasing order. Constraints - Assume all elements in `arr` are within a manageable range, ensuring the efficiency of the pigeonhole sort. Example ```python >>> pigeonhole_sort([8, 3, -1, 7, 0, 3, 4]) [-1, 0, 3, 3, 4, 7, 8] >>> pigeonhole_sort([-5, -10, 0, 2, 1]) [-10, -5, 0, 1, 2] ``` Performance Requirements - Your implementation should have a time complexity of O(n + Range) and should be able to handle the given constraints efficiently.","solution":"def pigeonhole_sort(arr): Function to sort a list of integers using the Pigeonhole Sorting algorithm. Args: arr (list of int): A list of integers. Returns: list of int: The sorted list of integers. if not arr: return arr min_value = min(arr) max_value = max(arr) size = max_value - min_value + 1 holes = [0] * size # Populate the holes for item in arr: holes[item - min_value] += 1 # Flatten the holes back into the sorted array sorted_arr = [] for i in range(size): sorted_arr.extend([i + min_value] * holes[i]) return sorted_arr"},{"question":"# Question: Enhance and Optimize Insertion Sort Problem Statement Given an array of integers, sort the array in ascending order using an optimized version of the insertion sort algorithm. Your task is to design a modified insertion sort function that incorporates both early termination when the array is already sorted and leverages binary search to find the correct insertion position of elements to reduce the number of comparisons. Function Signature ```python def optimized_insertion_sort(arr: List[int]) -> List[int]: ``` Input - A list `arr` of integers where (1 leq len(arr) leq 10^6). Output - A sorted list of integers in ascending order. Constraints - Your solution should improve the average case performance without worsening the best-case performance. - Assume that the elements of the array are within the range of ( pm10^9 ). Performance Requirements - The optimized insertion sort should handle arrays of up to (10^6) elements efficiently. - Aim for an average case performance better than O(n^2). Example ```python >>> optimized_insertion_sort([12, 11, 13, 5, 6]) [5, 6, 11, 12, 13] >>> optimized_insertion_sort([4, 3, 2, 10, 12, 1, 5, 6]) [1, 2, 3, 4, 5, 6, 10, 12] >>> optimized_insertion_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> optimized_insertion_sort([]) [] ``` Explanation - For the first example, the array is not sorted initially and thus multiple operations are required to sort it. - For the second and third examples, showcase handling of varying array sizes and scenarios like already sorted array or empty array respectively. Notes - Ensure that the function handles large inputs efficiently. - Consider using binary search to find the correct position for insertion to reduce the number of comparisons. - Implement early termination to check if the array is already sorted.","solution":"from typing import List import bisect def optimized_insertion_sort(arr: List[int]) -> List[int]: n = len(arr) if n <= 1: return arr for i in range(1, n): key = arr[i] if arr[i-1] <= key: continue # Using binary search to find the correct position for arr[i] pos = bisect.bisect_left(arr, key, 0, i) # Shift elements from position `pos` to `i-1` one step to the right arr = arr[:pos] + [key] + arr[pos:i] + arr[i+1:] return arr"},{"question":"# Question: **Minimum Edit Distance to Equalize Strings** You are given two words, `word1` and `word2`. Your task is to write a Python function `min_distance_dp(word1, word2)` to find the minimum number of steps required to make the words identical, where in each step you can delete one character in either string. Function Signature: ```python def min_distance_dp(word1: str, word2: str) -> int: Finds the minimum number of deletions required for two strings to make them identical. :param word1: First word (length <= 500). :param word2: Second word (length <= 500). :returns: Minimum number of deletion steps to make the words the same. ``` Input: - `word1` (1 ≤ len(word1) ≤ 500): A string consisting of lowercase English letters. - `word2` (1 ≤ len(word2) ≤ 500): A string consisting of lowercase English letters. Output: - Return the minimum number of deletion steps required to make `word1` and `word2` the same. Constraints: - The input strings will only contain lowercase English letters. - Please take necessary considerations to ensure your implementation can handle edge cases efficiently. Examples: - Example 1: - Input: `word1 = \\"sea\\"`, `word2 = \\"eat\\"` - Output: `2` - Explanation: You can delete \\"s\\" from \\"sea\\" and \\"t\\" from \\"eat\\" to get \\"ea\\". - Example 2: - Input: `word1 = \\"a\\"`, `word2 = \\"ab\\"` - Output: `1` - Explanation: You can delete \\"b\\" from \\"ab\\" to get \\"a\\". **Note:** Use dynamic programming approach to optimize the problem solving.","solution":"def min_distance_dp(word1: str, word2: str) -> int: Finds the minimum number of deletions required for two strings to make them identical. :param word1: First word (length <= 500). :param word2: Second word (length <= 500). :returns: Minimum number of deletion steps to make the words the same. m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): dp[i][0] = i for j in range(1, n + 1): dp[0][j] = j for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# Coin Change Combinations **Context**: You are working for a company that specializes in vending machines. One of their common requirements is to determine the number of ways to dispense a given amount of change using available coin denominations. **Task**: Implement a function `count_combinations` that calculates the number of distinct ways to make the given change amount (`value`) using the specified set of coin denominations (`coins`). Function Signature ```python def count_combinations(coins: List[int], value: int) -> int: pass ``` Input * `coins`: A list of integers representing the denominations of the coins. (1 <= len(coins) <= 100, 1 <= coin <= 50) * `value`: An integer representing the amount of change required. (0 <= value <= 1000) Output * Return an integer which is the number of distinct ways to make the given amount using the available coin denominations. Constraints * You have an infinite supply of each type of coin. * Order of coins in the combination does not matter (i.e., [1, 1, 2] is considered the same as [1, 2, 1]). Example ```python assert count_combinations([1, 2, 3], 4) == 4 assert count_combinations([2, 5, 3, 6], 10) == 5 assert count_combinations([2], 3) == 0 ``` Explanation For the example with `coins = [1, 2, 3]` and `value = 4`, the distinct ways to make the change are: - [1, 1, 1, 1] - [1, 1, 2] - [2, 2] - [1, 3] For the example with `coins = [2, 5, 3, 6]` and `value = 10`, the distinct ways to make the change are: - [2, 2, 2, 2, 2] - [2, 2, 3, 3] - [2, 2, 6] - [2, 3, 5] - [5, 5] Remember to handle edge cases, for example, when `value` is 0 (return 1) and when `coins` is an empty array (return 0).","solution":"from typing import List def count_combinations(coins: List[int], value: int) -> int: # Initialize a list to store the ways to make each value up to the given value dp = [0] * (value + 1) dp[0] = 1 # There\'s one way to make the value 0: use no coins # Iterate over each coin for coin in coins: # Update dp array values from coin to value for i in range(coin, value + 1): dp[i] += dp[i - coin] return dp[value]"},{"question":"# Question: Extended Insertion Sort with Early Termination You have been given a list of integers `arr` which you need to sort using an optimized version of the Insertion Sort algorithm. The optimized algorithm should include early termination if the array is already sorted after any iteration of the outer loop. Implement a function `optimized_insertion_sort` that: 1. Sorts the given list `arr` using the Insertion Sort algorithm. 2. Includes early termination if the array is found to be sorted at any point during the sort process. Input: * A list of integers `arr` with a maximum length of 1000. Output: * A list of integers which is the sorted version of the input list. Constraints: * `1 <= len(arr) <= 1000` * `-10^6 <= arr[i] <= 10^6` for all `0 <= i < len(arr)` Example: ```python Input: [4, 3, 2, 10, 12, 1, 5, 6] Output: [1, 2, 3, 4, 5, 6, 10, 12] Input: [1, 2, 3, 4, 5] Output: [1, 2, 3, 4, 5] ``` Note: * Your solution should aim to terminate early if the array is detected to be sorted before all iterations of the outer loop are complete. * You may use a flag or similar logic to check if any swaps occurred in the current pass. ```python def optimized_insertion_sort(arr): # write your code here pass # Example test cases print(optimized_insertion_sort([4, 3, 2, 10, 12, 1, 5, 6])) # Output: [1, 2, 3, 4, 5, 6, 10, 12] print(optimized_insertion_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] ```","solution":"def optimized_insertion_sort(arr): Sorts the given list arr using an optimized version of the Insertion Sort algorithm. It includes early termination if the array is already sorted during the process. n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key # Check if the array is already sorted sorted_flag = True for k in range(1, n): if arr[k] < arr[k - 1]: sorted_flag = False break if sorted_flag: break return arr"},{"question":"**Problem Statement: Maximum Depth of Binary Tree** Given a binary tree, write a function to find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Your solution should use an iterative approach with a queue to store nodes of each level, following a level-order traversal (BFS). # Function Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_depth(root: TreeNode) -> int: pass ``` # Input * `root`: A tree node representing the root of a binary tree. # Output * An integer value representing the maximum depth of the binary tree. # Constraints * The number of nodes in the tree is in the range [0, 10^4]. * -100 <= Node.val <= 100 # Example ```python # Example Definition and Usage tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(3) tree.left.left = TreeNode(4) tree.left.right = TreeNode(5) print(max_depth(tree)) # Output: 3 ``` # Requirements * Ensure you handle edge cases such as empty trees. * Aim for a solution with a time complexity of O(n) and space complexity of O(w) where n is the number of nodes and w is the maximum width of the tree. **Challenge**: Optimize the memory usage by making use of data structures that offer efficient operations for the queue (e.g., using `collections.deque`).","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_depth(root: TreeNode) -> int: if not root: return 0 queue = deque([(root, 1)]) # (node, current depth) max_depth = 0 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return max_depth"},{"question":"# Integer Decomposition You are tasked with implementing a function that determines the number of distinct ways to decompose a given positive integer into sums of non-negative integers. The order of terms does not matter, meaning different permutations of the same sum are considered the same. Implement a function `int_decompose` that takes an integer `n` as input and returns the number of possible decompositions of `n`. Function Signature ```python def int_decompose(n: int) -> int: pass ``` Input * `n` - a non-negative integer (0 <= n <= 100). Output * Returns an integer representing the number of different ways to decompose `n`. Example ```python assert int_decompose(4) == 5 assert int_decompose(7) == 15 assert int_decompose(0) == 1 ``` Explanation * `int_decompose(4)` can be decomposed into: - `4=4` - `4=3+1` - `4=2+2` - `4=2+1+1` - `4=1+1+1+1` - Total = 5 ways * `int_decompose(7)` can be decomposed into: - `7=7` - `7=6+1` - `7=5+2` - `7=5+1+1` - `7=4+3` - `7=4+2+1` - `7=4+1+1+1` - `7=3+3+1` - `7=3+2+2` - `7=3+2+1+1` - `7=3+1+1+1+1` - `7=2+2+2+1` - `7=2+2+1+1+1` - `7=2+1+1+1+1+1` - `7=1+1+1+1+1+1+1` - Total = 15 ways * `int_decompose(0)` can only be decomposed into itself, i.e., `0`. So, there is 1 way. Your task is to capture the logic described above and apply it to determine the total number of decompositions for any valid input `n`.","solution":"def int_decompose(n: int) -> int: Returns the number of distinct ways to decompose an integer n into the sum of non-negative integers. # Create a table to store results of subproblems dp = [0] * (n + 1) # Base case: There is exactly one way to sum to zero dp[0] = 1 # Fill the dp table using bottom-up approach for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"**Range Minimum Query with Segment Tree** # Context: Given a `SegmentTree` class designed to support range queries and updates efficiently using a commutative function, adapt it to solve range minimum query problems. For this task, you will utilize the provided `SegmentTree` class to efficiently handle multiple range minimum queries and point updates on an array of integers. # Problem Statement: Implement a function `range_minimum_query(arr, queries)` that takes an array `arr` of integers and a list of `queries`. The `queries` consist of tuples, where each tuple can be either: 1. `(\'q\', l, r)` representing a query to find the minimum in the subarray from index `l` to `r` (inclusive). 2. `(\'u\', i, v)` representing an update operation to set the element at index `i` to value `v`. Your task is to process all queries and return a list of results for the range minimum queries in the order they are given. # Input: - `arr`: A list of integers of size `N` (1 <= N <= 10^5). - `queries`: A list of tuples representing the queries (1 <= |queries| <= 10^5). # Output: - A list of integers where each integer corresponds to the result of a range minimum query. # Example: ```python arr = [1, 3, 2, 7, 9, 11] queries = [(\'q\', 1, 4), (\'u\', 3, 0), (\'q\', 1, 4)] # Expected Output: [2, 0] # Explanation: # The initial array is [1, 3, 2, 7, 9, 11] # - The first query (\'q\', 1, 4) asks for the minimum from index 1 to 4, which is min(3, 2, 7, 9) = 2. # - The update (\'u\', 3, 0) changes the array to [1, 3, 2, 0, 9, 11] # - The second query (\'q\', 1, 4) now asks for the minimum from index 1 to 4 again, and the min is now min(3, 2, 0, 9) = 0. ``` # Constraints: - The range of each query can extend across the entire array. - Each query must be answered in O(log N) time; updates must also be handled in O(log N) time. # Template: ```python def range_minimum_query(arr, queries): # Your code here pass ``` Extend the `SegmentTree` class accordingly and use it within the function to facilitate efficient range minimum queries and updates. Ensure you handle all edge cases as discussed in the analysis.","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.seg_tree = [0] * (2 * self.n) # Initialize the segment tree with the given data self.build(data) def build(self, data): # Build the segment tree in O(n) time for i in range(self.n): self.seg_tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.seg_tree[i] = min(self.seg_tree[2 * i], self.seg_tree[2 * i + 1]) def update(self, pos, value): # Update the value at index pos to value pos += self.n self.seg_tree[pos] = value while pos > 1: pos //= 2 self.seg_tree[pos] = min(self.seg_tree[2 * pos], self.seg_tree[2 * pos + 1]) def range_min(self, left, right): # Query the range minimum from index left to right left += self.n right += self.n minimum = float(\'inf\') while left <= right: if left % 2 == 1: minimum = min(minimum, self.seg_tree[left]) left += 1 if right % 2 == 0: minimum = min(minimum, self.seg_tree[right]) right -= 1 left //= 2 right //= 2 return minimum def range_minimum_query(arr, queries): seg_tree = SegmentTree(arr) results = [] for query in queries: if query[0] == \'q\': _, l, r = query results.append(seg_tree.range_min(l, r)) elif query[0] == \'u\': _, i, v = query seg_tree.update(i, v) return results"},{"question":"# Question: Implement Custom Pancake Sort You are tasked with implementing a custom version of the Pancake Sort algorithm. Your function should sort an array of integers in ascending order by utilizing a series of \\"flips\\" as described below: 1. Find the maximum element in the current unsorted segment of the array. 2. Rotate (flip) the sub-array from the beginning up to the index of this maximum element to move it to the front. 3. Flip the sub-array from the start to the end of the unsorted segment to move this maximum element to its final sorted position. 4. Repeat the above steps on the remaining unsorted portion of the array. Function Signature ```python def custom_pancake_sort(arr: list[int]) -> list[int]: ``` Input * A list of integers `arr` (0 <= len(arr) <= 1000) with values such that -10000 <= arr[i] <= 10000 Output * A list of integers sorted in ascending order. Constraints * Your solution must operate in-place, meaning you should not use additional data structures proportional to the input size. * Consider performance and avoid redundant operations. Example ```python arr = [3, 2, 4, 1] print(custom_pancake_sort(arr)) # Output: [1, 2, 3, 4] arr = [1, 5, 3, 2, 4] print(custom_pancake_sort(arr)) # Output: [1, 2, 3, 4, 5] ``` Hint Think carefully about how to determine the maximum element and perform the flips correctly. Handle edge cases such as already sorted arrays or arrays with repeated elements efficiently.","solution":"def custom_pancake_sort(arr: list[int]) -> list[int]: def flip(sublist, k): start = 0 while start < k: sublist[start], sublist[k] = sublist[k], sublist[start] start += 1 k -= 1 n = len(arr) for size in range(n, 1, -1): # Find the maximum element in the current unsorted segment max_index = arr.index(max(arr[:size])) # Move this maximum element to the front if max_index != 0: flip(arr, max_index) # Move the maximum element to its final sorted position flip(arr, size - 1) return arr"},{"question":"# Scenario Cryptography is vital for security in digital communications. The RSA algorithm is one of the most widely used encryption systems. You are required to implement a function that utilizes given RSA keys to encrypt and decrypt messages. Your task will also involve generating the RSA key pair. # Objective Implement the necessary functions to generate RSA keys, encrypt a message, and decrypt a message using those keys. # Function Specifications 1. `generate_key(k: int, seed: int = None) -> Tuple[int, int, int]` - **Input**: - `k` (int): The number of bits desired for the modulus `n`. - `seed` (int, optional): A seed value for the random number generator. If provided, it should result in deterministic key generation. - **Output**: A tuple (n, e, d), where: - `n` (int): The modulus. - `e` (int): The public exponent. - `d` (int): The private exponent. - **Constraints**: Ensure that `e` is coprime to the totient and that both `p` and `q` are large primes. 2. `encrypt(data: int, e: int, n: int) -> int` - **Input**: - `data` (int): The plaintext data to be encrypted. - `e` (int): The public exponent. - `n` (int): The modulus. - **Output**: The encrypted data (ciphertext). 3. `decrypt(data: int, d: int, n: int) -> int` - **Input**: - `data` (int): The ciphertext data to be decrypted. - `d` (int): The private exponent. - `n` (int): The modulus. - **Output**: The decrypted data (plaintext). # Guidelines - **Edge Cases**: Consider values of `k` that are very small or very large. - **Error Handling**: Handle cases where prime number generation fails or is inefficient. - **Performance**: Ensure that your implementations of RSA key generation and encryption/decryption are efficient for reasonably large values of `k`. # Example Suppose you wish to generate a key pair with a modulus size of 16 bits: ```python n, e, d = generate_key(16) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` This example showcases generating a pair of keys, encrypting a given piece of data, and ensuring the original data can be retrieved after decryption.","solution":"import random from sympy import isprime, gcd, mod_inverse, randprime def generate_key(k: int, seed: int = None) -> tuple: Generates an RSA key pair of bit length k. Args: k (int): The number of bits for the modulus n. seed (int, optional): Seed for the random number generator. Returns: tuple: The modulus n, public exponent e, and private exponent d. if seed is not None: random.seed(seed) # Step 1: Generate two distinct large prime numbers p and q p = randprime(2**(k//2 - 1), 2**(k//2)) q = randprime(2**(k//2 - 1), 2**(k//2)) while p == q: q = randprime(2**(k//2 - 1), 2**(k//2)) # Step 2: Compute n = pq and the totient phi(n) = (p-1)(q-1) n = p * q phi_n = (p - 1) * (q - 1) # Step 3: Choose e such that 1 < e < phi(n) and gcd(e, phi(n)) = 1 e = 65537 # A common choice for e is 65537 if gcd(e, phi_n) != 1: # If e is not coprime with phi, choose another e for e in range(3, phi_n, 2): if gcd(e, phi_n) == 1: break # Step 4: Compute d such that ed ≡ 1 (mod phi(n)) d = mod_inverse(e, phi_n) return (n, e, d) def encrypt(data: int, e: int, n: int) -> int: Encrypts the data using the public key (e, n). Args: data (int): The plaintext data to encrypt. e (int): The public exponent. n (int): The modulus. Returns: int: The encrypted data (ciphertext). return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: Decrypts the data using the private key (d, n). Args: data (int): The ciphertext data to decrypt. d (int): The private exponent. n (int): The modulus. Returns: int: The decrypted data (plaintext). return pow(data, d, n)"},{"question":"# Question: Path Verification in Directed Graph You are working on a project involving route planning, and you need to verify connectivity between different locations represented by nodes in a directed graph. Your task is to implement a function to determine if there is a path between two nodes. Function Signature ```python def is_reachable(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: # implement this function ``` Input * `vertex_count`: An integer `V`, the number of nodes in the graph. * `edges`: A list of `Tuple` pairs where each pair `(source, target)` represents a directed edge from the `source` node to the `target` node. * `source`: An integer representing the starting node. * `target`: An integer representing the target node. Output Return a boolean value: * `True` if there exists a path from the `source` node to the `target` node. * `False` otherwise. Constraints * All node values are integers from `0` to `vertex_count - 1`. * There might be no edges in the graph. * No duplicate edges between the same source and target. Example ```python # Example 1 vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3)] source = 0 target = 3 # Expected output: True # Example 2 vertex_count = 5 edges = [(0, 1), (0, 2), (1, 3), (1, 4)] source = 0 target = 4 # Expected output: True # Example 3 vertex_count = 5 edges = [(0, 1), (0, 2), (1, 3), (1, 4)] source = 3 target = 0 # Expected output: False ``` You need to create the `is_reachable` function to solve the examples provided. Here\'s a structure you can follow: 1. Create a Graph class with methods to add edges and perform DFS. 2. Implement the `is_reachable` function that initializes the Graph object, adds edges, and employs DFS to check for the path. **Note**: Ensure that your implementation is efficient for large inputs and handles edge cases robustly.","solution":"from typing import List, Tuple def is_reachable(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: # Create adjacency list for the graph graph = [[] for _ in range(vertex_count)] for edge in edges: graph[edge[0]].append(edge[1]) # Perform BFS to check if target is reachable from source visited = [False] * vertex_count queue = [source] while queue: node = queue.pop(0) if node == target: return True if not visited[node]: visited[node] = True queue.extend(graph[node]) return False"},{"question":"# Coding Exercise You are required to implement a function to check if a given sequence of parentheses is balanced using the Stack data structure. A sequence of parentheses is considered balanced if every opening parenthesis has a corresponding closing parenthesis in the correct order. **Function Signature**: `def is_balanced_parentheses(sequence: str) -> bool:` **Input**: - **sequence** (str): A string containing only parentheses characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. The length of the string is between 1 and 1000. **Output**: - (bool): Returns `True` if the sequence of parentheses is balanced, `False` otherwise. **Constraints**: - You must use a stack data structure to solve this problem. - Consider all types of parentheses: `()`, `{}`, `[]`. **Examples**: ```python assert is_balanced_parentheses(\\"(){}[]\\") == True assert is_balanced_parentheses(\\"([{}])\\") == True assert is_balanced_parentheses(\\"([)]\\") == False assert is_balanced_parentheses(\\"{[}\\") == False ``` **Explanation**: 1. The sequence \\"(){}[]\\" is balanced as every opening parenthesis has a corresponding closing parenthesis. 2. The sequence \\"([{}])\\" is balanced as it correctly nest and closes each opening. 3. The sequence \\"([)]\\" is not balanced as the opening \'(\' does not close correctly with \')\'. 4. The sequence \\"{[}\\" is not balanced as the opening \'{\' doesn\'t close correctly. Make sure your implementation uses the stack operations (`push`, `pop`, and `peek`) efficiently to determine if the sequence is balanced.","solution":"def is_balanced_parentheses(sequence: str) -> bool: Returns True if the sequence of parentheses is balanced, False otherwise. stack = [] opening_brackets = {\'(\': \')\', \'{\': \'}\', \'[\': \']\'} for char in sequence: if char in opening_brackets: stack.append(char) else: if not stack: return False top = stack.pop() if opening_brackets[top] != char: return False return len(stack) == 0"},{"question":"# Question: Implement a Function to Check if a Given Tree is a Valid Red-Black Tree Given a binary tree, write a function `is_valid_rbtree` in Python to determine if it satisfies the properties of a Red-Black Tree. Your function should return True if the tree is a valid Red-Black Tree, and False otherwise. Input * A binary tree represented by its root node of class `RBNode`. Output * A boolean value indicating whether the input tree is a valid Red-Black Tree. Constraints * The nodes of the binary tree are defined using the class `RBNode` with attributes: `val`, `color`, `parent`, `left`, and `right`. * The color attribute is `1` for red and `0` for black. Example ```python # Define the Node class class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red # Example tree root = RBNode(10, 0) node1 = RBNode(5, 1, root) node2 = RBNode(15, 1, root) root.left = node1 root.right = node2 print(is_valid_rbtree(root)) # Output: True ``` # Explanation 1. **Node & Color Validity**: Ensure every node is either red or black. 2. **Root**: The root must be black. 3. **Red Node Children**: Red nodes cannot have red children. 4. **Black Path**: Every path from a node to its descendant null nodes must have the same number of black nodes. Notes To solve this, you should: * Traverse the tree to check if it adheres to the properties of a Red-Black Tree. * Ensure no two consecutive red nodes appear in any path. * Validate the equality of black node counts on all simple paths from the root to the leaves.","solution":"class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red def is_valid_rbtree(root): def is_red(node): return node and node.color == 1 def check_rbtree_properties(node, current_black_count, path_black_counts): # Base case: Null nodes (leaves) if node is None: if path_black_counts is None: path_black_counts = current_black_count elif path_black_counts != current_black_count: return False return True # Root must be black if node == root and is_red(node): return False # Red node cannot have red children if is_red(node): if is_red(node.left) or is_red(node.right): return False # Increment black count if the node is black if not is_red(node): current_black_count += 1 # Recursively check the left and right subtrees return check_rbtree_properties(node.left, current_black_count, path_black_counts) and check_rbtree_properties(node.right, current_black_count, path_black_counts) if root is None: return True return check_rbtree_properties(root, 0, None)"},{"question":"# Context: You are building a predictive text input system for a mobile keyboard, where each key press can correspond to multiple letters (similar to the classic phone keypads). To enhance the user experience, you need to generate all possible letter combinations for a given sequence of keypresses. # Task: Write a function `letter_combinations(digits)` that takes a string of digits (from \'2\' to \'9\') and returns all possible letter combinations that the number could represent. The digit-to-letter mapping is as follows: ``` 2: \\"abc\\" 3: \\"def\\" 4: \\"ghi\\" 5: \\"jkl\\" 6: \\"mno\\" 7: \\"pqrs\\" 8: \\"tuv\\" 9: \\"wxyz\\" ``` # Input and Output Formats: * Input: A string `digits` containing only digits from \'2\' to \'9\'. The length of `digits` will not exceed 4. * Output: A list of strings representing all possible letter combinations. # Constraints: * If the input `digits` is an empty string, the output should be an empty list. * The function should be efficient and handle inputs of maximum allowed length (up to 4 digits). # Example: ```python # Input digits = \\"23\\" # Output [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] # Input digits = \\"\\" # Output [] ``` # Performance Requirements: * The function should handle up to 4 digits efficiently within reasonable time constraints. Implement the function `letter_combinations(digits)` in Python.","solution":"def letter_combinations(digits): Given a string consisting of digits from 2 to 9, returns all possible letter combinations that the number could represent based on the classic phone keypad layout. if not digits: return [] # Mapping of digit to corresponding letters phone_map = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } # Initial list with the empty string to facilitate the combination process combinations = [\'\'] for digit in digits: letters = phone_map[digit] new_combinations = [] for combination in combinations: for letter in letters: new_combinations.append(combination + letter) combinations = new_combinations return combinations"},{"question":"# URL Parameter Stripping Function You are tasked with implementing a function that takes a URL and processes its query parameters. The function should achieve two objectives: 1. Remove any duplicate query string parameters, keeping the first occurrence. 2. Optionally remove specific query string parameters if they are listed in a second argument. Requirements: - Your function should maintain the order of parameters as they appear in the original URL. - If a parameter appears multiple times in the query string, retain only the first occurrence. - If a list of parameters to remove is provided, remove those parameters from the query string as well. - If the URL has no query parameters, return it unchanged. - If no parameters are left after processing, return the base URL without the trailing `?`. Input: - `url`: A string representing the input URL. - `params_to_strip`: An optional list of strings representing the query parameters to remove. Output: - A string representing the processed URL. Constraints: - The URL will always be a valid URL. - The parameters to strip, if given, will be valid query parameter names. - Perform the task in O(N) time complexity. Examples: 1. Input: - `url = \\"www.example.com?a=1&b=2&a=2\\"` - `params_to_strip = []` - Output: `\\"www.example.com?a=1&b=2\\"` 2. Input: - `url = \\"www.example.com?a=1&b=2&c=3\\"` - `params_to_strip = [\\"b\\"]` - Output: `\\"www.example.com?a=1&c=3\\"` 3. Input: - `url = \\"www.example.com?a=1&a=2&b=2&c=3&c=5\\"` - `params_to_strip = [\\"a\\", \\"c\\"]` - Output: `\\"www.example.com?b=2\\"` # Function Signature ```python def strip_url_params(url: str, params_to_strip: list = []) -> str: pass ```","solution":"def strip_url_params(url: str, params_to_strip: list = []) -> str: from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse # Parse the URL parsed_url = urlparse(url) query_params = parse_qsl(parsed_url.query) # Use an ordered dictionary to maintain the first occurrence and order of query params unique_params = {} for key, value in query_params: if key not in unique_params and key not in params_to_strip: unique_params[key] = value # Encode the cleaned query parameters back to a query string cleaned_query = urlencode(unique_params) # Create the full URL from its components [scheme, netloc, path, params, query, fragment] cleaned_url = urlunparse(parsed_url._replace(query=cleaned_query)) return cleaned_url"},{"question":"# Question Write a function named `subsets_unique` that generates all unique subsets of a given list of integers, which may contain duplicates. Each subset must be unique and the order of subsets and the order of numbers within subsets does not matter. Function Signature ```python def subsets_unique(nums: List[int]) -> List[List[int]]: ``` Input * `nums`: A list of integers `[a1, a2, ..., an]` where 0 <= len(nums) <= 10, and -10 <= ai <= 10. Output * Returns a list of lists, where each inner list is a unique subset of `nums`. Constraints * The solution set must not contain duplicate subsets. Examples ```python assert subsets_unique([1, 2, 2]) == [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] ``` Explanation For the input `[1, 2, 2]`, the function should generate all unique subsets. Note that [2, 1] and [1, 2] are considered the same subset and only one should be included in the final result, as order within subsets does not matter. Scenario Imagine you are working on a project that involves generating user access levels based on their roles, where each access level is a subset of possible permissions. However, there should be no duplicate access levels. You can consider the list of permissions as an input to your function, which will generate all unique sets of permissions. Additional Notes Focus on ensuring the subsets generated are unique and consider edge cases where the input list may be empty or contain all duplicates.","solution":"from typing import List def subsets_unique(nums: List[int]) -> List[List[int]]: nums.sort() result = [] def backtrack(start, path): result.append(path) for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue backtrack(i + 1, path + [nums[i]]) backtrack(0, []) return result"},{"question":"You are provided with a list of numerical values (integers or floats) and a percentage. Your task is to compute the trimmed mean of the list. The trimmed mean is calculated by removing the smallest and largest values according to the given percentage, and then computing the mean of the remaining values. # Function Signature ```python def trimmed_mean(values: List[Union[int, float]], trim_percentage: float) -> float: # Your code here ``` # Input Constraints * `values`: A list of integers or floats. The length of the list will be at least 3 and at most 10^6. * `trim_percentage`: A float representing the percentage of values to trim from both ends of the list. It will be between 0 and 100 inclusive. # Output * A single float representing the trimmed mean of the given list after removing the specified percentage of the smallest and largest values. # Performance Requirements * The function should handle large inputs efficiently within reasonable time limits. # Examples ```python assert abs(trimmed_mean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20) - 5.5) < 1e-9 assert abs(trimmed_mean([10, 20, 30, 40, 50, 60, 70], 30) - 40) < 1e-9 assert abs(trimmed_mean([1, 2, 5, 7, 10], 40) - 5) < 1e-9 ``` # Explanation of Examples 1. For the list `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` and 20%, after trimming the lowest 10% and the highest 10%, the values `[1, 10]` are removed, leaving `[2, 3, 4, 5, 6, 7, 8, 9]`. The mean of these values is 5.5. 2. For the list `[10, 20, 30, 40, 50, 60, 70]` and 30%, after removing 30% of the lowest and highest values, we remove `[10, 20, 60, 70]`, leaving `[30, 40, 50]`. The mean of these values is 40. 3. For `[1, 2, 5, 7, 10]` and 40%, after trimming the lowest and highest 20% each, we remove `[1, 10]`, leaving `[2, 5, 7]`. The mean of these values is 5.","solution":"from typing import List, Union def trimmed_mean(values: List[Union[int, float]], trim_percentage: float) -> float: Computes the trimmed mean of the list `values` by removing the specified `trim_percentage` of the smallest and largest values and then calculating the mean of the remaining values. # Check if the trim_percentage is valid if trim_percentage < 0 or trim_percentage > 100: raise ValueError(\\"Trim percentage must be between 0 and 100 inclusive.\\") # Sort the values sorted_values = sorted(values) # Calculate the number of elements to remove from each end n = len(values) k = int(n * trim_percentage / 100) # Trim the values trimmed_values = sorted_values[k:n-k] # Compute and return the mean of the trimmed values return sum(trimmed_values) / len(trimmed_values) if trimmed_values else float(\'nan\')"},{"question":"**Problem Statement:** You are given two inputs, a `pattern` and a string `sentence`. The objective is to verify if the `sentence` follows the same pattern as specified by the `pattern` string. Each character in the `pattern` string corresponds to a word in the `sentence`, such that each unique character in `pattern` maps to a unique word in the `sentence`. Write a function `is_following_pattern(pattern: str, sentence: str) -> bool` to check if the `sentence` follows the `pattern`. # Input: * `pattern`: A string containing only lowercase letters (1 ≤ len(pattern) ≤ 100). * `sentence`: A string containing lowercase words separated by a single space (1 ≤ len(sentence) ≤ 1000). # Output: * Return `True` if `sentence` follows the `pattern`, otherwise return `False`. # Examples: ```python assert is_following_pattern(\\"abba\\", \\"dog cat cat dog\\") == True assert is_following_pattern(\\"abba\\", \\"dog cat cat fish\\") == False assert is_following_pattern(\\"aaaa\\", \\"dog cat cat dog\\") == False assert is_following_pattern(\\"abba\\", \\"dog dog dog dog\\") == False ``` # Constraints: * Each word in the `sentence` is a non-empty sequence of lowercase letters. * The number of words in `sentence` is equal to the number of characters in `pattern`. # Notes: - Make sure to handle edge cases such as different lengths of `pattern` and `sentence`, or duplicate mappings of pattern characters to words. - Emphasize handling of unique mappings and ensure the function returns correct results for any valid input as per the given constraints.","solution":"def is_following_pattern(pattern, sentence): Checks if the sentence follows the same pattern specified by the pattern string. words = sentence.split() # Check if lengths match if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False if word in word_to_char: if word_to_char[word] != char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"Enhanced Hailstone Sequence with Memoization Context You are given the task to enhance the standard hailstone/Collatz sequence generation function. Your goal is to implement a function that not only returns the sequence for a given starting integer ( n ) but also leverages memoization to optimize repeated calculations for known starting values of ( n ). Requirements 1. Write a function `hailstone_memo(n, memo={})` that generates the hailstone sequence for a given integer ( n ). 2. Use a dictionary `memo` to store previously computed sequences\' lengths to efficiently handle large ( n ) values. 3. Return both the generated sequence and the length of the sequence. Input - A positive integer ( n ) (1 <= n <= 10^6) - An optional `memo` dictionary to store previously computed sequence lengths. Output - A list representing the hailstone sequence starting from ( n ) down to 1. - The length of the generated sequence. Constraints - Use memoization to optimize performance. - Ensure that the function handles large integers efficiently and avoids overflow issues. - Optimize for time complexity. Example ```python def hailstone_memo(n, memo={}): ... # Example usage: sequence, length = hailstone_memo(7) print(sequence) # Output: [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1] print(length) # Output: 17 # Another example with memo: sequence, length = hailstone_memo(10, memo) print(sequence) # Output: [10, 5, 16, 8, 4, 2, 1] print(length) # Output: 7 ``` Hints - Store intermediate sequence lengths in `memo` to reduce redundant calculations. - Handle the base case ( n = 1 ) directly. - Carefully consider edge cases such as large starting ( n ) values and ensure that the solution efficiently manages computational load.","solution":"def hailstone_memo(n, memo={}): Function to generate the hailstone sequence for a given integer n using memoization to store previously computed sequence lengths for optimization. Args: n (int): The starting integer for the hailstone sequence, 1 <= n <= 10^6. memo (dict): Optional dictionary to store previously computed sequence lengths. Returns: tuple: A list representing the hailstone sequence starting from n down to 1, and the length of the generated sequence. if n in memo: return memo[n] sequence = [] current = n while current != 1: sequence.append(current) if current in memo: sequence.extend(memo[current][0]) length = len(sequence) + memo[current][1] - 1 break if current % 2 == 0: current = current // 2 else: current = 3 * current + 1 sequence.append(1) length = len(sequence) memo[n] = (sequence, length) return sequence, length"},{"question":"Problem Statement Given a binary tree where each node contains a distinct integer value, write a function `bin_tree_to_sorted_doubly_list(root)` that converts the binary tree to a sorted doubly linked list **in-place**, such that the left and right child pointers now function as predecessor and successor pointers in the linked list respectively. # Function Signature ```python def bin_tree_to_sorted_doubly_list(root: TreeNode) -> TreeNode: pass ``` # Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * `-10^5 <= Node.val <= 10^5` * The tree may be unbalanced. # Input * `root`: The root node of the binary tree. # Output * The head of the resulting doubly linked list. # Example ```python # Define the TreeNode class first as given below: class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Construct the binary tree: # 4 # / # 2 5 # / # 1 3 root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) # Convert binary tree to sorted doubly linked list. head = bin_tree_to_sorted_doubly_list(root) # The resulting doubly linked list should be: # 1 <-> 2 <-> 3 <-> 4 <-> 5 # Traversing the list should yield: 1, 2, 3, 4, 5 current = head while current: print(current.val, end=\' \') current = current.right # Output: 1 2 3 4 5 ``` # Notes * The conversion must be performed in-place; you are not allowed to allocate any extra space for another data structure. * Ensure that the function handles edge cases such as empty trees properly.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def bin_tree_to_sorted_doubly_list(root): if not root: return None def inorder_traversal(node): nonlocal last, head if not node: return # Traverse left subtree inorder_traversal(node.left) # Process current node if last: last.right = node node.left = last else: head = node last = node # Traverse right subtree inorder_traversal(node.right) last, head = None, None inorder_traversal(root) return head"},{"question":"# Question: Array Value Limitation **Scenario**: Imagine you are working on data preprocessing for a scientific experiment where you need to filter out measurements that fall outside a specific range. Each measurement is stored in a list, and you need to ensure only those measurements that fall within the given range are considered for further analysis. The range might not always be fully specified, so if no lower or upper bound is provided, the algorithm should consider using the minimum or maximum values in the list as bounds accordingly. **Task**: Write a function `limit(arr, min_lim=None, max_lim=None)` that takes a list of numeric measurements, and optional minimum (`min_lim`) and maximum (`max_lim`) bounds, and returns a new list containing only those measurements that fall within the specified range (inclusive). **Function Signature**: ```python def limit(arr: list, min_lim: float = None, max_lim: float = None) -> list: pass ``` **Input**: - `arr`: List of numeric (integer or float) measurements. - `min_lim`: Optional boundary for minimum acceptable value. Default is `None`. - `max_lim`: Optional boundary for maximum acceptable value. Default is `None`. **Output**: - A list with values from the original list that fall between `min_lim` and `max_lim` (inclusive). **Constraints**: - If `min_lim` is `None`, use the smallest element in the list as the minimum bound. - If `max_lim` is `None`, use the largest element in the list as the maximum bound. - The input list `arr` can be empty. - In case both `min_lim` and `max_lim` are `None`, the function should return the entire list. **Examples**: ```python assert limit([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert limit([10, 20, 30, 40, 50], 15, 45) == [20, 30, 40] assert limit([1.5, 2.5, 3.5], 2.0, None) == [2.5, 3.5] assert limit([], 1, 3) == [] assert limit([7, 5, 4, 3, 2], None, None) == [7, 5, 4, 3, 2] ``` This question tests your understanding of array manipulation, conditional boundaries, and efficient filtering of elements within a specified range.","solution":"def limit(arr: list, min_lim: float = None, max_lim: float = None) -> list: if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"Context: You are working on implementing a back-end service for a product catalog that allows adding, removing, and searching for products based on their unique IDs. To efficiently manage and handle these operations, you will use a Binary Search Tree (BST). Task: Implement a class `BinarySearchTree` that supports the following operations: 1. **Insert a Value**: Add a new node with a given value to the BST. 2. **Delete a Value**: Remove a node with the given value from the BST. 3. **Search for a Value**: Check whether a node with the given value exists in the BST. Requirements: * Implement the `insert`, `delete`, and `search` methods. * Each node should hold an integer value. * You may assume values inserted into the BST are unique. * Optimize the BST for typical operations to avoid performance degradation. # Method Signatures: ```python class BinarySearchTree: def __init__(self): # Initialize an empty BST pass def insert(self, value: int): # Inserts a value into the BST pass def delete(self, value: int): # Deletes a value from the BST if it exists pass def search(self, value: int) -> bool: # Searches for a value in the BST, returns True if found, else False pass ``` # Input 1. Method `insert(value: int)` 2. Method `delete(value: int)` 3. Method `search(value: int) -> bool` # Output 1. Method `insert`: No return value 2. Method `delete`: No return value 3. Method `search`: Returns `True` if value is found, else `False` # Constraints * Value inserted, deleted, or searched may range from `-10^9` to `10^9`. * Number of operations (n) in a single run: ( 1 leq n leq 10^4 ). # Example: ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) assert bst.search(3) == True bst.delete(3) assert bst.search(3) == False ```","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int): if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def delete(self, value: int): self.root = self._delete_recursive(self.root, value) def _delete_recursive(self, node, value): if not node: return node if value < node.value: node.left = self._delete_recursive(node.left, value) elif value > node.value: node.right = self._delete_recursive(node.right, value) else: # Node with only one child or no child if node.left is None: return node.right elif node.right is None: return node.left # Node with two children: get the inorder successor (smallest in the right subtree) node.value = self._min_value_node(node.right).value # Delete the inorder successor node.right = self._delete_recursive(node.right, node.value) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def search(self, value: int) -> bool: return self._search_recursive(self.root, value) def _search_recursive(self, node, value): if node is None: return False if node.value == value: return True elif value < node.value: return self._search_recursive(node.left, value) else: return self._search_recursive(node.right, value)"},{"question":"Pattern Matching using Backtracking You are given a pattern and a string. Your task is to implement a function that determines whether the string follows the given pattern. **Follow** means a full match, such that there is a one-to-one correspondence between letters in the pattern and non-empty substrings in the string. # Function Signature ```python def pattern_match(pattern: str, string: str) -> bool ``` # Input - `pattern` (a non-empty string of lowercase letters) - `string` (a non-empty string of lowercase letters) # Output - Returns a boolean value indicating whether the string follows the pattern. # Constraints - You may assume both `pattern` and `string` contain only lowercase letters. - The bijection must be complete, i.e., all characters of the pattern must map to non-empty substrings and vice versa. # Examples ```python assert pattern_match(\\"abab\\", \\"redblueredblue\\") == True assert pattern_match(\\"aaaa\\", \\"asdasdasdasd\\") == True assert pattern_match(\\"aabb\\", \\"xyzabcxzyabc\\") == False ``` # Scenario Imagine you are tasked with developing a text analysis tool that aligns repeating patterns within strings of texts. This function could serve as a foundational piece for interpreting textual patterns and generating structured mappings. # Guidelines - Ensure to incorporate recursive backtracking for exploring possible mappings. - Use a dictionary to keep track of the bijection between pattern characters and the substrings. - Handle edge cases where pattern or string lengths are incompatible for a bijection. - Optimize for early termination whenever possible. Good luck and happy coding!","solution":"def pattern_match(pattern: str, string: str) -> bool: def is_match(p_idx, s_idx, mapping, used): if p_idx == len(pattern) and s_idx == len(string): return True if p_idx == len(pattern) or s_idx == len(string): return False char = pattern[p_idx] if char in mapping: word = mapping[char] if string.startswith(word, s_idx): return is_match(p_idx + 1, s_idx + len(word), mapping, used) return False for end in range(s_idx + 1, len(string) + 1): word = string[s_idx:end] if word in used: continue mapping[char] = word used.add(word) if is_match(p_idx + 1, s_idx + len(word), mapping, used): return True del mapping[char] used.remove(word) return False return is_match(0, 0, {}, set())"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: Wiggle Sort * **Type**: Sorting algorithm * **Main Purpose**: To reorder an unsorted array such that elements at odd indices are greater than their preceding elements, and elements at even indices are lesser than or equal to their preceding elements. # Complexity * **Time Complexity**: O(n), where n is the number of elements in the array. * **Space Complexity**: O(1), as it performs the sorting in-place. # Principles The core operational mechanism involves iterating over the array and swapping elements to satisfy the wiggle condition: - If `i` is odd, then `nums[i-1]` should be less than `nums[i]`. - If `i` is even, then `nums[i-1]` should be greater than or equal to `nums[i]`. # Characteristics & Applications * **Properties**: - Sorting stability is not preserved. - Ensures that peaks and valleys alternate in the array. * **Common Use Cases**: - Rearranging data for visualization to highlight local maximum and minimum. - Certain scheduling problems where tasks have alternating priority levels. # Strengths/Limitations * **Strengths**: - Linear time complexity makes it efficient for large arrays. - In-place sorting conserves memory. * **Limitations**: - Limited to reordering elements; does not provide a generalized sort. # Implementation Challenges * **Edge Cases**: - Arrays with less than two elements (the function should handle this gracefully). - Arrays with many duplicate elements. * **Performance Bottlenecks**: - The for loop runs linearly but involves a constant-time swap operation. * **Error Scenarios**: - None specified as long as input constraints are satisfied. * **Optimization Points**: - The algorithm already runs in optimal time complexity for its purpose. <|Analysis End|> <|Question Begin|> # Problem Statement Write a function `wiggle_sort(nums)` that reorders an unsorted list `nums` such that `nums[0] < nums[1] > nums[2] < nums[3]...`. # Input * A list `nums` of integers (`1 ≤ len(nums) ≤ 10^4`) # Output * The function should modify the list `nums` in-place to meet the wiggle sort condition described above. # Constraints * The function should perform the sorting in O(n) time. * The solution should not use extra space beyond the given list. # Example ```python # Example 1 input: nums = [3, 5, 2, 1, 6, 4] output: nums = [3, 5, 1, 6, 2, 4] # Example 2 input: nums = [2, 2, 1, 3] output: nums = [2, 3, 1, 2] ``` Note: The output is not unique; any valid wiggle sorted list is acceptable. # Explanation - For the first example, consider the input list `[3, 5, 2, 1, 6, 4]`. After wiggle sorting, possible valid outputs include `[3, 5, 1, 6, 2, 4]`, `[3, 6, 1, 5, 2, 4]`, and `[2, 6, 3, 5, 1, 4]`. # Performance Requirements * Your implementation should run in O(n) time complexity and should not use any additional data structures that scale with input size. # Test the Edge Cases: 1. Test with list sizes at the boundary conditions, such as empty list and single-element list. 2. Handle arrays with repeated elements correctly. 3. Ensure your function performs well with large lists up to size 10^4. You can assume the input list contains at least one element and at most 10^4 elements.","solution":"def wiggle_sort(nums): Reorders the array such that nums[0] < nums[1] > nums[2] < nums[3]... for i in range(1, len(nums)): if (i % 2 == 1 and nums[i-1] > nums[i]) or (i % 2 == 0 and nums[i-1] < nums[i]): nums[i-1], nums[i] = nums[i], nums[i-1]"},{"question":"# Crout Matrix Decomposition You are required to implement a function `crout_matrix_decomposition` that performs the Crout matrix decomposition on a given square matrix (A). The function should return two matrices (L) and (U) such that (L times U = A). # Function Signature ```python def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: ``` # Input - `A`: A square matrix of size (n times n) where (n geq 1). # Output - Returns a tuple `(L, U)`: - `L`: Lower triangular matrix of size (n times n) such that all elements above the diagonal are zero. - `U`: Upper triangular matrix of size (n times n) with ones on the diagonal and all elements below the diagonal are zero. # Constraints - Matrix (A) contains only float or integer values. - The decomposition must be numerically stable for small or near-zero pivot elements. # Example Given the matrix (A): [ begin{bmatrix} 1 & 2 & 3 3 & 4 & 5 6 & 7 & 8 end{bmatrix} ] The function should return: [ L = begin{bmatrix} 1.0 & 0.0 & 0.0 3.0 & -2.0 & 0.0 6.0 & -5.0 & 0.0 end{bmatrix}, quad U = begin{bmatrix} 1.0 & 2.0 & 3.0 0.0 & 1.0 & 2.0 0.0 & 0.0 & 1.0 end{bmatrix} ] Here\'s a template to get you started: ```python from typing import List, Tuple def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: n = len(A) L = [[0.0] * n for i in range(n)] U = [[0.0] * n for i in range(n)] for j in range(n): U[j][j] = 1.0 for i in range(j, n): alpha = float(A[i][j]) for k in range(j): alpha -= L[i][k]*U[k][j] L[i][j] = float(alpha) for i in range(j+1, n): tempU = float(A[j][i]) for k in range(j): tempU -= float(L[j][k]*U[k][i]) if L[j][j] == 0: L[j][j] = float(0.1**40) U[j][i] = float(tempU/L[j][j]) return (L, U) ``` Ensure to test your solution with various matrix sizes and values, including edge cases with zero or near-zero pivots.","solution":"from typing import List, Tuple def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: n = len(A) L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] for j in range(n): U[j][j] = 1.0 for i in range(j, n): alpha = A[i][j] for k in range(j): alpha -= L[i][k] * U[k][j] L[i][j] = alpha for i in range(j + 1, n): tempU = A[j][i] for k in range(j): tempU -= L[j][k] * U[k][i] if L[j][j] == 0: L[j][j] = 1e-10 # Small number to avoid division by zero U[j][i] = tempU / L[j][j] return (L, U)"},{"question":"**Problem Statement**: You are given an array of integers, and you need to support two types of operations efficiently: 1. Update the value of a specified element in the array. 2. Compute the sum of elements from the beginning of the array to a given index. To accomplish these tasks, you are required to implement a Fenwick Tree. # Function Signature ```python class FenwickTree: def __init__(self, arr: List[int]): Initializes the Fenwick Tree with the given array. :param arr: A list of integers representing the initial values. def update(self, index: int, value: int): Updates the value at the specified index to value. :param index: The index of the element to update. :param value: The new value to set at the specified index. def query(self, index: int) -> int: Returns the sum of the elements from the beginning of the array to the specified index (inclusive). :param index: The index up to which the sum is required. :return: The sum of the elements from the beginning to the index. ``` # Constraints - The input array will have a length between (1) and (10^5). - Each element in the array will be an integer between (-10^4) and (10^4). - There will be at most (10^5) update and query operations combined. # Examples ```python # Example usage of the FenwickTree class: ft = FenwickTree([1, 7, 3, 0, 7, 8, 3]) print(ft.query(3)) # Output: 11 (1+7+3+0) ft.update(3, 5) print(ft.query(3)) # Output: 16 (1+7+3+5) ft.update(0, 2) print(ft.query(3)) # Output: 17 (2+7+3+5) ``` **Notes**: 1. You should maintain the internal state of the Fenwick Tree such that both update and query operations are efficient. 2. Ensure that your implementation handles edge cases, such as updates to the first or last elements of the array.","solution":"from typing import List class FenwickTree: def __init__(self, arr: List[int]): Initializes the Fenwick Tree with the given array. :param arr: A list of integers representing the initial values. self.n = len(arr) self.tree = [0] * (self.n + 1) self.arr = arr.copy() # Keep a copy of the original array for reference in updates for i in range(self.n): self._add(i + 1, arr[i]) def _add(self, index: int, value: int): while index <= self.n: self.tree[index] += value index += index & -index def update(self, index: int, value: int): Updates the value at the specified index to value. :param index: The index of the element to update. :param value: The new value to set at the specified index. current_value = self.arr[index] delta = value - current_value self.arr[index] = value self._add(index + 1, delta) def query(self, index: int) -> int: Returns the sum of the elements from the beginning of the array to the specified index (inclusive). :param index: The index up to which the sum is required. :return: The sum of the elements from the beginning to the index. index += 1 result = 0 while index > 0: result += self.tree[index] index -= index & -index return result"},{"question":"# Regex Pattern Matching Context: You are developing a text search utility that leverages regular expressions for advanced pattern matching. You need to implement a function that checks if a given text string matches a certain pattern. The pattern can include two special characters: - `.` matches any single character. - `*` matches zero or more of the character immediately preceding it. Problem Statement: Given two strings `s` and `p`, where `s` is the text string and `p` is the pattern string, implement a function: ```python def is_match(s: str, p: str) -> bool: ``` that returns a boolean value indicating if the text string `s` matches the pattern `p`. Input: - `s`: A string of length `0 <= len(s) <= 100`. - `p`: A string containing the characters `a-z`, `.`, and `*`, of length `0 <= len(p) <= 100`. Output: - Return `True` if the text string `s` matches the pattern `p`, otherwise `False`. Example Cases: 1. `is_match(\\"aa\\", \\"a\\")` should return `False`. 2. `is_match(\\"aa\\", \\"a*\\")` should return `True`. 3. `is_match(\\"ab\\", \\".*\\")` should return `True`. 4. `is_match(\\"aab\\", \\"c*a*b\\")` should return `True`. 5. `is_match(\\"\\", \\".*\\")` should return `True`. Constraints: - The function should cover the entire input string `s`, not just a part of it. - The solution should handle both empty input strings `s` and pattern strings `p` correctly. Additional Information: - Ensure to account for edge cases such as patterns ending with \'*\', patterns starting with \'.\', or having consecutive \'*\' characters. - Aim to implement the function efficiently, with consideration for both time and space complexity. Function Signature: ```python def is_match(s: str, p: str) -> bool: pass ```","solution":"def is_match(s: str, p: str) -> bool: def dp(i, j): if j == len(p): return i == len(s) first_match = i < len(s) and p[j] in {s[i], \'.\'} if j + 1 < len(p) and p[j + 1] == \'*\': return (dp(i, j + 2) or first_match and dp(i + 1, j)) else: return first_match and dp(i + 1, j + 1) return dp(0, 0)"},{"question":"# Problem Description You are tasked with designing a highly reliable system for saving and restoring binary trees. To achieve this, you need to provide functionality to serialize binary trees to a string representation and deserialize them back into tree structure. # Function Signature You are required to implement the following two functions: 1. `serialize(root: TreeNode) -> str` 2. `deserialize(data: str) -> TreeNode` # Requirements - Implement the `serialize` function which takes in the root of a binary tree and returns a string representation of the tree. - Implement the `deserialize` function which takes in a string representation and reconstructs the corresponding binary tree. # Input - `serialize(root: TreeNode) -> str`: - `root`: The root node of the binary tree (could be `None`). - `deserialize(data: str) -> TreeNode`: - `data`: A string representation of the binary tree. # Output - `serialize(root: TreeNode) -> str`: - Returns a string representing the serialized binary tree. - `deserialize(data: str) -> TreeNode`: - Returns the root node of the deserialized binary tree. # Constraints - The tree node values are integers (could be positive or negative). - A valid tree structure is always provided as input to the serialization and deserialization functions. - Tree structure can be as large as required, but should realistically fit within memory. # Example ```python # Example tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) # Serializing the binary tree serialized_tree = serialize(root) # serialized_tree should be \\"1 2 # # 3 4 # # 5 # #\\" # Deserializing the string back to binary tree deserialized_tree = deserialize(serialized_tree) # The deserialized_tree should have the same structure as the original tree ``` # Scenario Imagine you are working for a company that deals with a large number of customer transactions. Each transaction can be represented as a binary tree, and you need a method to efficiently store these trees in a database and retrieve them for processing and analysis. # Performance Requirements - Your solution should handle binary trees with up to 100,000 nodes efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. def _serialize(node): if node is None: return \\"#\\" return f\\"{node.val} {_serialize(node.left)} {_serialize(node.right)}\\" return _serialize(root) def deserialize(data): Decodes your encoded data to tree. def _deserialize(nodes): val = next(nodes) if val == \'#\': return None node = TreeNode(int(val)) node.left = _deserialize(nodes) node.right = _deserialize(nodes) return node return _deserialize(iter(data.split()))"},{"question":"You are given an array of integers where every element appears exactly twice, except for one unique element that appears only once. Implement a function that finds and returns the unique element. # Detailed Requirements * Your solution must operate in linear runtime complexity, O(n). * Your solution must not use extra memory (space complexity should be O(1)). # Function Signature ```python def find_unique_number(nums: List[int]) -> int: ``` # Input * `nums (List[int])`: A list of integers where each integer appears exactly twice except for one unique integer. # Output * An integer representing the unique number that occurs only once in the list. # Examples 1. Input: `[2, 2, 1]` Output: `1` 2. Input: `[4, 1, 2, 1, 2]` Output: `4` 3. Input: `[1]` Output: `1` # Constraints 1. The input list will have at least one element. 2. The length of the list is odd. 3. All elements are integers between -3 * 10^4 and 3 * 10^4. 4. Every element except one appears exactly twice. # Notes * If there is an empty list or all numbers appear twice without any single occurrence, return `0`. # Context This problem is often used in coding interviews to test candidates\' understanding of bit manipulation and their ability to devise solutions with efficient time and space complexities.","solution":"def find_unique_number(nums): Given a list of integers where every element appears exactly twice except for one unique element, this function returns the unique element. Args: nums (List[int]): List of integers. Returns: int: The unique element. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Problem Context: You have been tasked to help optimize the score processing system for a sports competition platform. The system receives numerous athlete scores which need to be sorted efficiently to generate ranking and statistical analyses. The scores range uniformly between 0 and 100. # Problem Statement: Implement a function `optimized_bucket_sort` using bucket sort. The elements in each bucket should be sorted using an algorithm of your choice, different from insertion sort. This function should handle scores uniformly distributed between 0 and 100. # Function Signature: ```python def optimized_bucket_sort(scores: List[float]) -> List[float]: pass ``` # Input: - `scores`: A list of float numbers representing scores, `0 <= scores[i] <= 100`. # Output: - Returns the list of scores sorted in ascending order. # Constraints: - The number of scores could be as large as 10^6. - Execution time should be within acceptable range for large inputs (You want it to outperform O(n^2) times). # Requirements: - Use bucket sort. - Use a different algorithm (not insertion sort) to sort individual buckets. - The complexity of bucket sort’s auxiliary sorting algorithm should outperform O(n^2) for large data sets. # Example: Input: ```python scores = [52.5, 49.3, 66.8, 30.1, 90.4, 89.9, 45.3, 22.2] ``` Output: ```python [22.2, 30.1, 45.3, 49.3, 52.5, 66.8, 89.9, 90.4] ``` # Edge Cases: - An empty list of scores should return an empty list. - Uniform scores should be returned as is. - List with `0` and `100` included should still be sorted correctly. # Performance Considerations: - The function should handle up to 10^6 scores efficiently. - Ensure minimal additional memory usage for large inputs. # Note: Explain your choice of sorting algorithm for the bucket and its time complexity.","solution":"from typing import List def quicksort(arr): Quicksort algorithm to sort elements within each bucket. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right) def optimized_bucket_sort(scores: List[float]) -> List[float]: if not scores: return [] # Create buckets buckets = [[] for _ in range(101)] # Distribute scores into buckets for score in scores: bucket_index = int(score) buckets[bucket_index].append(score) # Sort each bucket using quicksort and concatenate the results sorted_scores = [] for bucket in buckets: sorted_scores.extend(quicksort(bucket)) return sorted_scores"},{"question":"# Question: Checking for a Palindrome Linked List Scenario You are given a singly linked list. Your task is to determine whether the linked list is a palindrome. A linked list is a palindrome if it reads the same forwards and backwards. Problem Description You are to write a function `is_palindrome_optimized(head)` that accepts the `head` node of a singly linked list and returns `True` if the list is a palindrome and `False` otherwise. Input - `head`: A node that represents the head of the singly linked list. Each node is an instance of a class `ListNode`, defined as: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Output - Returns `True` if the linked list is a palindrome, otherwise `False`. Constraints - The linked list is non-empty and contains at most 10^5 nodes. - The elements of the linked list will vary between -10^9 and 10^9. Example ```python # Define your ListNode class here class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Create a linked list 1 -> 2 -> 2 -> 1 head = ListNode(1, ListNode(2, ListNode(2, ListNode(1)))) # Pass it to the function print(is_palindrome_optimized(head)) # Output: True ``` Requirements - The solution should operate in O(n) time complexity and O(1) space complexity. - The linked list should remain unaltered after checking. Constraints - Handle lists with a single element, and large lists. - Ensure there is no alteration in the original linked list. **Hint**: You might consider modifying and then restoring the list for the check.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome_optimized(head): if not head or not head.next: return True # Find the middle of the linked list slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the linked list prev = None while slow: next_temp = slow.next slow.next = prev prev = slow slow = next_temp # Compare the first half and the reversed second half first_half, second_half = head, prev while second_half: # only need to check the second half if first_half.val != second_half.val: return False first_half = first_half.next second_half = second_half.next return True"},{"question":"# ZigZag Iterator Problem Implement a ZigZag iterator that alternates between two provided lists (`v1` and `v2`) and returns their elements one by one. When one list is exhausted, the iterator should continue with the remaining elements of the other list. Your implementation should provide three methods: 1. `__init__(self, v1: List[int], v2: List[int])`: Initializes the iterator with two lists. 2. `next(self) -> int`: Returns the next element in the zigzag order. 3. `has_next(self) -> bool`: Returns `True` if there are further elements to be returned in the zigzag order, `False` otherwise. # Input - Two lists, `v1` and `v2`, which may contain integers. # Output - `next()` returns the next integer in the zigzag order until both lists are exhausted. - `has_next()` returns a boolean indicating if there are more elements available. # Constraints - The input lists `v1` and `v2` can have different lengths. - Both lists may be empty. # Example: Input: ```python v1 = [1, 2] v2 = [3, 4, 5, 6] ``` Expected Output: ```python it = ZigZagIterator(v1, v2) output = [] while it.has_next(): output.append(it.next()) print(output) # Expected: [1, 3, 2, 4, 5, 6] ``` Edge Case Example: 1. For both empty lists: ```python v1 = [] v2 = [] it = ZigZagIterator(v1, v2) # Expected: False for has_next(), and no elements to return for next(). ``` 2. For lists of significantly different lengths: ```python v1 = [1, 2, 3, 4, 5] v2 = [6] it = ZigZagIterator(v1, v2) # Expected: [1, 6, 2, 3, 4, 5] ``` # Note 1. Aim to keep your implementation efficient and clean. 2. Handle all edge cases and scenarios as discussed in the analysis.","solution":"from typing import List class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): self.lists = [v1, v2] self.indices = [0, 0] # Starting indices for each list self.turn = 0 # Which list\'s turn to pop an element def next(self) -> int: while self.indices[self.turn] >= len(self.lists[self.turn]): self.turn = (self.turn + 1) % 2 # Switch turn result = self.lists[self.turn][self.indices[self.turn]] self.indices[self.turn] += 1 self.turn = (self.turn + 1) % 2 return result def has_next(self) -> bool: return self.indices[0] < len(self.lists[0]) or self.indices[1] < len(self.lists[1])"},{"question":"# Problem Description Given an array of integers `nums`, every element in the array appears exactly three times, except for one element which appears exactly once. Write a function `find_unique_element` that finds and returns that single unique element. # Function Signature ```python def find_unique_element(nums: List[int]) -> int: ``` # Input * An array of integers `nums` where `1 <= len(nums) <= 10^5`. Every element in the array will repeat exactly three times except for one unique element which will appear only once. # Output * Return the integer which appears exactly once. # Example ```python assert find_unique_element([2, 2, 3, 2]) == 3 assert find_unique_element([0, 1, 0, 1, 0, 1, 99]) == 99 ``` # Constraints * The algorithm must have a linear runtime complexity. * No extra memory should be used (constant space complexity). # Notes Use bitwise manipulation to achieve the desired time and space complexity. Consider the following explanation: * Each bit position (i.e., 32 bits) will sum up over all numbers in the array. * Each bit\'s sum modulo 3 will yield the unique number\'s corresponding bit. # Scenario Imagine you are designing a system that logs the number of visitors to a website. Each visitor\'s ID appears three times in the log for each visit except for one visitor whose ID appears only once due to a logging error. You need to identify this unique visitor efficiently. Write an implementation of the function `find_unique_element` for this purpose.","solution":"from typing import List def find_unique_element(nums: List[int]) -> int: ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"# Permutation Generator Enhanced Given a collection of distinct numbers, implement an enhanced permutation generator with the following specifications: 1. **Functionality**: - Return all possible permutations of the list of numbers. - Provide an option to generate permutations using an iterative approach to handle larger inputs efficiently. 2. **Implement two methods**: 1. **`generate_permutations(elements)`**: This should return a list containing all permutations. 2. **`generate_permutations_iter(elements)`**: This should return a generator that yields permutations one by one. 3. **Input**: - A list of distinct integers, `elements`. 4. **Output**: - For `generate_permutations(elements)`: A list of lists, where each sublist is a permutation of the input list. - For `generate_permutations_iter(elements)`: A generator yielding lists that are permutations of the input list. # Performance Requirements: * Both methods should handle input sizes up to 7-8 distinct integers efficiently considering the (O(n!)) complexity. # Constraints: * Elements of the given list are distinct integers. * Input list length ( leq 8). # Example: ```python print(generate_permutations([1, 2, 3])) # Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] for perm in generate_permutations_iter([1, 2, 3]): print(perm) # Output (order may vary): # [1, 2, 3] # [1, 3, 2] # [2, 1, 3] # [2, 3, 1] # [3, 1, 2] # [3, 2, 1] ``` **Hint**: You may leverage the recursive and iterative approaches outlined in the provided snippets as a reference.","solution":"from itertools import permutations def generate_permutations(elements): Returns all possible permutations of the input list elements. return list(permutations(elements)) def generate_permutations_iter(elements): Yields all possible permutations of the input list elements one by one. for perm in permutations(elements): yield perm"},{"question":"You are given a positive integer n. Your task is to write a function `find_nth_digit(n)` that finds and returns the nth digit of a sequence formed by concatenating the positive integers: \\"123456789101112...\\". Function Signature ```python def find_nth_digit(n: int) -> int: pass ``` # Example ```python assert find_nth_digit(3) == 3 assert find_nth_digit(11) == 0 assert find_nth_digit(12) == 1 ``` # Input Constraints 1. `1 <= n <= 10^9` # Output The return type should be an integer representing the nth digit in the sequence. # Explanation 1. For n = 3, the sequence \\"123456789...\\" yields the 3rd digit as 3. 2. For n = 11, the sequence is \\"1234567891011...\\", making the 11th digit 0 (from number 10). 3. For n = 12, it is positioned such that it\'s the next digit after 0 in \\"10\\", hence 1. To solve this problem, you\'ll need to: 1. Determine the length of the number where the nth digit is located. 2. Identify the precise number and digit within that number. 3. Return the digit as an output. **Considerations**: - Optimize to avoid direct sequence generation. - Handle large values of n efficiently. - Account for extraneous edge cases where n spans across different digit lengths. **Performance**: Ensure your solution runs efficiently within the given constraints to handle up to 10^9 input size.","solution":"def find_nth_digit(n: int) -> int: length = 1 # start with single digit numbers count = 9 start = 1 # Find the range that contains the nth digit while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the exact number containing the nth digit start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"You are tasked with finding the next higher number that has the same set of digits as a given number. If no such number exists, return -1. This problem tests your understanding of permutations and the ability to manipulate arrays efficiently. # Function Signature ```python def next_bigger(num: int) -> int: pass ``` # Input - `num` (integer): A positive integer whose next higher permutation (as a number) needs to be found. # Output - Return the next higher permutation of `num` as an integer. If no such permutation is possible, return -1. # Constraints - `1 <= num <= 10^18` # Example ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(1528452) == 1528524 assert next_bigger(138654) == 143568 assert next_bigger(54321) == -1 assert next_bigger(999) == -1 assert next_bigger(5) == -1 ``` # Explanation 1. For `38276`, the next higher permutation is `38627`. 2. For `12345`, the next higher permutation is `12354`. 3. For `54321`, no higher permutation is possible so the output is `-1`. Implement the function `next_bigger` to solve this problem. Do not import external libraries and ensure your solution handles large numbers efficiently.","solution":"def next_bigger(num: int) -> int: Finds the next higher number with the same set of digits as given number. :param num: int: The given number. :return: int: The next higher permutation or -1 if none exists. # Convert the number to string to access digits num_str = list(str(num)) n = len(num_str) # Step 1: Find the rightmost character which is smaller than its next character. # Let us call it \'first decreasing\' i = n - 2 while i >= 0 and num_str[i] >= num_str[i + 1]: i -= 1 # If no such element is found, return -1 since the number is in descending order if i == -1: return -1 # Step 2: Find the smallest character on the right side of \'first decreasing\' # which is greater than num_str[i] j = n - 1 while num_str[j] <= num_str[i]: j -= 1 # Step 3: Swap the found characters num_str[i] and num_str[j] num_str[i], num_str[j] = num_str[j], num_str[i] # Step 4: Reverse the sequence after the (i+1)th position to get the smallest permutation num_str = num_str[:i+1] + num_str[i+1:][::-1] return int(\'\'.join(num_str))"},{"question":"You are tasked with implementing a matrix decomposition function using Crout\'s method. The input will be a square matrix A (n x n), and your function should produce two matrices, L and U, such that A = LU. # Function Signature ```python def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: pass ``` # Input: - A: a list of n lists, each containing n floating-point numbers, representing an n x n matrix. # Output: - A tuple of two lists: - L: a list of n lists, each containing n floating-point numbers, representing the lower triangular matrix. - U: a list of n lists, each containing n floating-point numbers, representing the upper triangular matrix. # Constraints: - 1 ≤ n ≤ 100 - Elements of A are finite floating-point numbers. # Example: ```python A = [ [1.0, 2.0, 3.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0] ] L, U = crout_matrix_decomposition(A) print(\\"L =\\") for row in L: print(row) print(\\"U =\\") for row in U: print(row) ``` Output should be: ``` L = [1.0, 0.0, 0.0] [3.0, -2.0, 0.0] [6.0, -5.0, 0.0] U = [1.0, 2.0, 3.0] [0.0, 1.0, 2.0] [0.0, 0.0, 1.0] ``` # Notes: - Ensure your implementation avoids division by zero by handling cases where elements of A may be very close to zero. - Test your function with edge cases such as singular matrices, which have a determinant of zero. Implement this function to demonstrate your understanding of Crout\'s matrix decomposition.","solution":"from typing import List, Tuple def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: n = len(A) L = [[0.0]*n for _ in range(n)] U = [[0.0]*n for _ in range(n)] for j in range(n): U[j][j] = 1.0 for i in range(j, n): sum_l = sum(L[i][k] * U[k][j] for k in range(j)) L[i][j] = A[i][j] - sum_l for i in range(j+1, n): sum_u = sum(L[j][k] * U[k][i] for k in range(j)) if L[j][j] == 0: raise ZeroDivisionError(\\"Matrix is singular, cannot perform decomposition.\\") U[j][i] = (A[j][i] - sum_u) / L[j][j] return L, U"},{"question":"# Pattern Matching Problem You are given a pattern and a string. Write a function `pattern_match` that determines if the string `str` follows the same pattern specified. The follow means a full match, such that there is a bijection between a letter in pattern and a non-empty substring in `str`. # Function Signature ```python def pattern_match(pattern: str, string: str) -> bool: pass ``` # Input - `pattern` (string): The pattern to be matched, consisting of only lowercase letters. - `string` (string): The string to be checked against the pattern, consisting of only lowercase letters. # Output - Returns a boolean value indicating whether the string follows the pattern. # Constraints - 1 <= len(pattern) <= 15 - 1 <= len(string) <= 50 # Example Example 1: - **Input**: `pattern = \\"abab\\"`, `string = \\"redblueredblue\\"` - **Output**: `True` - **Explanation**: \'a\' and \'b\' map to \\"red\\" and \\"blue\\" respectively. Example 2: - **Input**: `pattern = \\"aaaa\\"`, `string = \\"asdasdasdasd\\"` - **Output**: `True` - **Explanation**: \'a\' maps to \\"asd\\". Example 3: - **Input**: `pattern = \\"aabb\\"`, `string = \\"xyzabcxzyabc\\"` - **Output**: `False` # Note You may assume that both the `pattern` and `string` contain only lowercase letters. # Task Implement the `pattern_match` function using a backtracking algorithm, ensuring it handles various edge cases and performs efficiently for the given constraints.","solution":"def pattern_match(pattern: str, string: str) -> bool: def backtrack(pattern, string, p_to_s_map, s_to_p_map): if not pattern and not string: return True if not pattern or not string: return False char = pattern[0] for end in range(1, len(string) - len(pattern) + 2): substr = string[:end] if char in p_to_s_map: if p_to_s_map[char] == substr: if backtrack(pattern[1:], string[end:], p_to_s_map, s_to_p_map): return True else: if substr in s_to_p_map: continue p_to_s_map[char] = substr s_to_p_map[substr] = char if backtrack(pattern[1:], string[end:], p_to_s_map, s_to_p_map): return True del p_to_s_map[char] del s_to_p_map[substr] return False return backtrack(pattern, string, {}, {})"},{"question":"**Context**: You are tasked with identifying strongly connected components (SCCs) in a directed social network graph. Each node represents a user, and each directed edge represents a \\"follows\\" relationship from one user to another. **Problem Statement**: Write a function `find_sccs` that takes in a directed graph represented as an adjacency list and returns the SCCs in the graph. Each SCC should be represented as a list of nodes, and the overall result should be a list of these SCC lists. Ensure the SCC lists are sorted. **Input and Output Formats**: * Input: A dictionary `graph` where keys are nodes and values are lists of neighboring nodes. ```python graph = { \'A\': [\'B\'], \'B\': [\'C\', \'E\', \'F\'], \'C\': [\'D\', \'G\'], \'D\': [\'C\', \'H\'], \'E\': [\'A\', \'F\'], \'F\': [\'G\'], \'G\': [\'F\'], \'H\': [\'D\', \'G\'] } ``` * Output: A list of lists, each containing the nodes in a strongly connected component. ```python [[\'G\', \'F\'], [\'D\', \'H\'], [\'C\', \'B\', \'A\', \'E\']] ``` **Constraints**: * The graph is non-empty. * Nodes are represented as strings. * All nodes in the graph are unique. * Ensure your solution is efficient, with a time complexity of O(V + E). **Function Signature**: ```python def find_sccs(graph: dict) -> list: pass ```","solution":"def find_sccs(graph: dict) -> list: Returns the strongly connected components of a directed graph. index = [0] stack = [] indices = {} lowlinks = {} result = [] def strongconnect(node): # Set the depth index for node to the smallest unused index indices[node] = index[0] lowlinks[node] = index[0] index[0] += 1 stack.append(node) # Consider successors of node for successor in graph.get(node, []): if successor not in indices: # Successor has not yet been visited; recurse on it strongconnect(successor) lowlinks[node] = min(lowlinks[node], lowlinks[successor]) elif successor in stack: # Successor is in the stack and hence in the current SCC lowlinks[node] = min(lowlinks[node], indices[successor]) # If node is a root node, pop the stack and generate an SCC if lowlinks[node] == indices[node]: scc = [] while True: successor = stack.pop() scc.append(successor) if successor == node: break result.append(sorted(scc)) for node in graph: if node not in indices: strongconnect(node) return result"},{"question":"You are tasked with implementing an optimized bucket sort algorithm. Given an array of non-negative integers, distribute the elements into a fixed number of buckets, sort each bucket using insertion sort, and then concatenate the buckets to get the final sorted list. # Function Signature ```python def bucket_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr` (List[int]): A list of non-negative integers to be sorted. # Output - List[int]: A list of integers sorted in non-decreasing order. # Constraints - The input list can contain up to `10^6` elements. - The values of elements in the list will be in the range `[0, 10^6]`. # Example ```python assert(bucket_sort([4, 2, 2, 8, 3, 3, 1]) == [1, 2, 2, 3, 3, 4, 8]) assert(bucket_sort([5, 1, 4, 2]) == [1, 2, 4, 5]) assert(bucket_sort([]) == []) assert(bucket_sort([5]) == [5]) ``` # Explanation 1. **Bucket Distribution**: - Divide the array elements into a fixed number of buckets based on their values. 2. **Sorting within Buckets**: - Sort each bucket using insertion sort. - Example: If an element belongs to bucket `i`, it should be sorted with other elements in that bucket. 3. **Concatenation**: - Concatenate all the sorted buckets to form the final sorted array. **Note**: Ensure efficiency by optimizing bucket size and number according to the input distribution.","solution":"from typing import List def insertion_sort(arr: List[int]) -> List[int]: for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def bucket_sort(arr: List[int]) -> List[int]: if not arr: return [] bucket_count = 10 max_value = max(arr) bucket_size = (max_value // bucket_count) + 1 buckets = [[] for _ in range(bucket_count)] for num in arr: bucket_index = num // bucket_size buckets[bucket_index].append(num) sorted_arr = [] for bucket in buckets: if bucket: sorted_arr.extend(insertion_sort(bucket)) return sorted_arr"},{"question":"Optimized Shuffle Sort Challenge Given the highly inefficient nature of bogo sort, it\'s paramount to leverage randomness efficiently. Design and implement a new sorting algorithm that uses randomness but ensures better performance than bogo sort while maintaining simplicity. Question Write a Python function `optimized_shuffle_sort(arr: List[int], simulation: bool = False) -> List[int]` which sorts an array `arr` using a combination of shuffling and partial sorting. Specifically: 1. Implement a function that breaks the array into smaller chunks. 2. Sort each chunk using an efficient algorithm (e.g., insertion sort). 3. Randomly shuffle these sorted chunks. 4. Merge the chunks into one sorted array. Constraints * The array contains at most `100` elements. * Each element in the array is an integer in the range `[-10^6, 10^6]`. Input * `arr` (List[int]): Array of integers to be sorted. * `simulation` (bool): If True, print the details of each iteration for debugging purposes. Output * List[int]: A sorted array of integers. Example ```python # Example 1: input_arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] result = optimized_shuffle_sort(input_arr) print(result) # Output should be a sorted array [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] # Example 2: input_arr = [1, 2, 3, 4, 5] result = optimized_shuffle_sort(input_arr) print(result) # Output is [1, 2, 3, 4, 5] ``` Your function should be reasonably efficient and should complete execution within a few seconds for the maximum input size.","solution":"import random from typing import List def insertion_sort(arr: List[int]) -> List[int]: for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def merge_sorted_chunks(chunks: List[List[int]]) -> List[int]: merged = [] for chunk in chunks: merged.extend(chunk) return sorted(merged) # Use Python\'s in-built sort for the final merging def optimized_shuffle_sort(arr: List[int], simulation: bool = False) -> List[int]: if simulation: print(f\\"Original array: {arr}\\") # Step 1: Break array into smaller chunks chunk_size = max(1, len(arr) // 10) # Choose a reasonable chunk size chunks = [arr[i:i + chunk_size] for i in range(0, len(arr), chunk_size)] if simulation: print(f\\"Chunks before sorting: {chunks}\\") # Step 2: Sort each chunk using insertion sort sorted_chunks = [insertion_sort(chunk) for chunk in chunks] if simulation: print(f\\"Chunks after sorting: {sorted_chunks}\\") # Step 3: Randomly shuffle sorted chunks random.shuffle(sorted_chunks) if simulation: print(f\\"Chunks after shuffling: {sorted_chunks}\\") # Step 4: Merge the chunks into one sorted array sorted_array = merge_sorted_chunks(sorted_chunks) if simulation: print(f\\"Final sorted array: {sorted_array}\\") return sorted_array"},{"question":"Context Run-Length Encoding (RLE) is a fundamental compression algorithm used to reduce size by encoding repeated elements. It takes a string as input and compresses it by converting sequences of repeated characters to a count followed by the character. RLE is widely used for compressing data with lots of repeats, such as simple image or text data. Task Implement functions to encode and decode a given string using Run-Length Encoding (RLE). Your implementation should correctly handle and optimize common edge cases, and it should operate within the time and space constraints outlined. Function Specifications **Function 1: `encode_rle`** - **Input**: A string of characters (e.g., `\'aaabbc\'`). - **Output**: A Run-Length Encoded string (e.g., `\'3a2b1c\'`). **Function 2: `decode_rle`** - **Input**: A Run-Length Encoded string (e.g., `\'3a2b1c\'`). - **Output**: The original decoded string (e.g., `\'aaabbc\'`). Constraints - The input string for `encode_rle` will have a length `1 ≤ |input| ≤ 10^5`. - The encoded string for `decode_rle` will be correctly formatted. - Your solution should handle the worst case in `O(n)` time complexity, where n is the length of the input string. Edge Cases to Consider 1. Empty input string. 2. String with no repeated characters (e.g., `\'abcdefg\'`). 3. String with a single character repeated (e.g., `\'aaaaaa\'`). Example ```python # Example for encode_rle input_string = \\"aaabbc\\" print(encode_rle(input_string)) # Expected output is \\"3a2b1c\\" # Example for decode_rle encoded_string = \\"3a2b1c\\" print(decode_rle(encoded_string)) # Expected output is \\"aaabbc\\" ``` Write your two functions in Python below: ```python def encode_rle(input): # Implementation here def decode_rle(input): # Implementation here ``` Ensure that your code is efficient and handles all the edge cases properly.","solution":"def encode_rle(input): Encodes a given string using Run-Length Encoding (RLE). :param input: Input string to encode :return: RLE encoded string if not input: return \\"\\" encoded_string = [] count = 1 for i in range(1, len(input)): if input[i] == input[i-1]: count += 1 else: encoded_string.append(f\\"{count}{input[i-1]}\\") count = 1 encoded_string.append(f\\"{count}{input[-1]}\\") return \'\'.join(encoded_string) def decode_rle(input): Decodes a given RLE string back to its original form. :param input: RLE encoded string to decode :return: Decoded original string decoded_string = [] count = \'\' for char in input: if char.isdigit(): count += char else: decoded_string.append(char * int(count)) count = \'\' return \'\'.join(decoded_string)"},{"question":"Problem Statement You are given a binary tree and your task is to determine its height. The height of a binary tree is defined as the length of the longest path from the root to a leaf. An empty tree has a height of 0. **Function Signature:** ```python def calculate_tree_height(root: Optional[Node]) -> int: ``` # Input - `root` (Optional[Node]): The root node of the binary tree. `Node` class is defined as follows: ```python class Node: def __init__(self, value: int = 0, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.value = value self.left = left self.right = right ``` # Output - `int`: The height of the tree. # Constraints - The height of the tree is a non-negative integer. - The function should be optimized to handle large trees efficiently. # Examples 1. Given the following binary tree: ``` 5 / 3 8 / 2 4 9 ``` The function should return 3. 2. Given the following binary tree: ``` 10 / 7 / 5 6 ``` The function should return 4. 3. Given an empty tree (root is None), the function should return 0. # Explanation: In example 1, the length of the longest path from the root (5) to a leaf is 3 (5 -> 3 -> 2 or 5 -> 3 -> 4 or 5 -> 8 -> 9). In example 2, the longest path from the root (10) to the leaf (6) is 4 (10 -> 7 -> 5 -> 6). # Performance Requirements: - Ensure the solution avoids stack overflow for very deep trees and handles large inputs efficiently.","solution":"from typing import Optional class Node: def __init__(self, value: int = 0, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.value = value self.left = left self.right = right def calculate_tree_height(root: Optional[Node]) -> int: if root is None: return 0 left_height = calculate_tree_height(root.left) right_height = calculate_tree_height(root.right) return 1 + max(left_height, right_height)"},{"question":"# Transitive Closure Implementation Scenario You have been given the task of analyzing the connectivity of a network represented as a directed graph. To accomplish this, you need to compute the transitive closure of the graph. The transitive closure of a graph gives a matrix that shows which vertices are reachable from other vertices, either directly or through intermediate vertices. Your goal is to implement an algorithm that computes this matrix using Depth-First Search (DFS). Your Task Write a function `transitive_closure(graph_adj_list, n)` that computes the transitive closure of the given directed graph using DFS. Input * `graph_adj_list`: A dictionary representing the adjacency list of the directed graph. Each key is a source vertex, and its value is a list of target vertices. * `n`: An integer representing the number of vertices in the graph. Output * A 2D list (matrix) of size `n x n`, where entry `(i, j)` is 1 if vertex `i` can reach vertex `j`, and 0 otherwise. Constraints * `0 ≤ n ≤ 100` * The vertices are labeled from 0 to n-1. Example ```python graph_adj_list = { 0: [1], 1: [2], 2: [0, 3], 3: [] } n = 4 print(transitive_closure(graph_adj_list, n)) ``` Expected output: ``` [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [0, 0, 0, 1]] ``` Function Signature ```python def transitive_closure(graph_adj_list: dict, n: int) -> list: pass ``` # Notes 1. Ensure to handle graphs with no edges appropriately. 2. Consider graphs with disconnected subgraphs. 3. Optimize your DFS to avoid unnecessary computations.","solution":"def transitive_closure(graph_adj_list, n): Computes the transitive closure of the given directed graph using DFS. :param graph_adj_list: Dictionary representing the adjacency list of the graph. :param n: The number of vertices in the graph. :return: 2D list (matrix) of size n x n representing the transitive closure. # Initialize the transitive closure matrix with 0s. closure = [[0] * n for _ in range(n)] # Helper function to run DFS and mark the reachability. def dfs(source, v): for neighbor in graph_adj_list.get(v, []): if closure[source][neighbor] == 0: closure[source][neighbor] = 1 dfs(source, neighbor) # Run DFS for each vertex to find all reachable vertices. for i in range(n): closure[i][i] = 1 dfs(i, i) return closure"},{"question":"# Question You are an engineer working on a system that maintains dynamic connectivity information. You are required to implement a function that counts the number of islands in a grid after each addLand operation. An island is a group of `1`s (land) connected 4-directionally (horizontal or vertical). You will be given a grid of size `m x n` filled with `0`s (water). You will be provided multiple addLand operations where each operation turns the water at a specific location into a land. Write a function `countIslands(m, n, positions)` that accepts the following parameters: - `int m`: The number of rows in the grid. - `int n`: The number of columns in the grid. - `List[Tuple[int, int]] positions`: A list of tuples, where each tuple represents a position to add land (turn from 0 to 1). Your function should return a list of integers indicating the number of islands after each addLand operation. Function Signature ```python def countIslands(m: int, n: int, positions: List[Tuple[int, int]]) -> List[int]: ``` Constraints - `1 <= m, n <= 1000` - `0 <= positions[i][0] < m` - `0 <= positions[i][1] < n` - All positions are unique and the function is called in an online manner. Example ```python # Example Usage m, n = 3, 3 positions = [(0, 0), (0, 1), (1, 2), (2, 1)] print(countIslands(m, n, positions)) # Output: [1, 1, 2, 3] ``` Explanation: 1. After adding land at (0, 0): - Grid: 1 0 0 0 0 0 0 0 0 - Islands: 1 2. After adding land at (0, 1): - Grid: 1 1 0 0 0 0 0 0 0 - Islands: 1 3. After adding land at (1, 2): - Grid: 1 1 0 0 0 1 0 0 0 - Islands: 2 4. After adding land at (2, 1): - Grid: 1 1 0 0 0 1 0 1 0 - Islands: 3","solution":"from typing import List, Tuple def countIslands(m: int, n: int, positions: List[Tuple[int, int]]) -> List[int]: def find(x): while x != parent[x]: parent[x] = parent[parent[x]] # path compression x = parent[x] return x def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY return True return False parent = {} rank = {} directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] count = 0 result = [] for r, c in positions: if (r, c) in parent: # already land result.append(count) continue parent[(r, c)] = (r, c) count += 1 for dr, dc in directions: nr, nc = r + dr, c + dc if (nr, nc) in parent: if union((r, c), (nr, nc)): count -= 1 result.append(count) return result"},{"question":"**Context**: You are working on a real-time data analytics system that processes massive amounts of streaming data. To ensure efficient processing, you need to determine if the stream of numeric data contains one unique number that is not canceled out by others. **Task**: Implement the function `one_sparse(array)` that takes a list of tuples representing a stream of numbers and their sign (either \'+\' or \'-\'). The function should return the unique number that remains after canceling out other numbers if the stream is 1-sparse. If the stream is not 1-sparse, return `None`. # Function Signature ```python def one_sparse(array): 1-sparse algorithm Keyword arguments: array -- stream of tuples ``` # Input - **array**: A list of tuples, where each tuple contains a non-negative integer and a sign (\'+\' or \'-\') indicating the addition or subtraction of the number in the stream. ```python array = [(number_1, sign_1), (number_2, sign_2), ..., (number_n, sign_n)] ``` # Output - Return the unique number if the stream is 1-sparse; otherwise, return `None`. # Constraints - The numbers in the tuples are non-negative integers. - The sign is either \'+\' or \'-\'. - The length of the array can be up to (10^6) elements. - The numbers are within the range from 0 to (10^6). # Example 1. **Input**: `[(4, \'+\'), (2, \'+\'), (2, \'-\'), (4, \'+\'), (3, \'+\'), (3, \'-\')]` **Output**: `4` Comment: All other numbers cancel each other out leaving only 4. 2. **Input**: `[(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\')]` **Output**: `2` Comment: There are only 2s. 3. **Input**: `[(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (1, \'+\')]` **Output**: `None` Comment: The stream is not 1-sparse as there is more than one unique number (2 and 1). Write your implementation of `one_sparse` to solve the problem.","solution":"def one_sparse(array): Returns the unique number if the stream is 1-sparse; otherwise, returns None. Keyword arguments: array -- stream of tuples containing a non-negative integer and a sign (\'+\' or \'-\'). num_count = {} # Calculate the net effect of each number for number, sign in array: if sign == \'+\': num_count[number] = num_count.get(number, 0) + 1 elif sign == \'-\': num_count[number] = num_count.get(number, 0) - 1 remaining_numbers = [num for num, count in num_count.items() if count != 0] if len(remaining_numbers) == 1: return remaining_numbers[0] else: return None"},{"question":"You are tasked with implementing a function that multiplies two non-negative integers represented as strings and returns the product, also as a string. # Function Signature `def multiply(num1: str, num2: str) -> str:` # Input Description * `num1` (string): A non-negative integer represented as a string with length < 110. * `num2` (string): A non-negative integer represented as a string with length < 110. # Output Description * Return the product of `num1` and `num2` as a string. # Constraints 1. The input strings `num1` and `num2` will only contain digits `0-9`. 2. Neither input string will contain a leading zero, except the number \\"0\\". # Example ```python assert multiply(\\"2\\", \\"3\\") == \\"6\\" assert multiply(\\"123\\", \\"456\\") == \\"56088\\" assert multiply(\\"123456789\\", \\"987654321\\") == \\"121932631112635269\\" ``` # Context This function simulates large number multiplication, bypassing limitations of built-in integer handling for large values. This is crucial in high-precision calculations and applications needing custom number data types. # Requirements Implement the function efficiently to handle the maximum input size under the given constraints, ensuring correctness for edge cases such as very small and very large values.","solution":"def multiply(num1: str, num2: str) -> str: Multiplies two non-negative integers represented as strings and returns the product as a string. # Edge case for multiplication by zero if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" len1, len2 = len(num1), len(num2) # Initialize result list to store intermediate positions sum result = [0] * (len1 + len2) # Reverse the numbers to facilitate easier place-value multiplications num1, num2 = num1[::-1], num2[::-1] # Perform the multiplication in a manner similar to manual multiplication for i in range(len1): for j in range(len2): # Multiply digit by digit and add to the corresponding position in the result result[i + j] += int(num1[i]) * int(num2[j]) # Handle carrying to the next position result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 # Convert result list back to a string and strip any leading zeros result = result[::-1] return \'\'.join(map(str, result)).lstrip(\'0\')"},{"question":"# Move Zeros to End - Coding Challenge Context: You are working on optimizing a system that processes data arrays. Oftentimes the datasets contain zeros that do not hold value in computations and need to be moved to the end while keeping the order of valid entries the same. This task is crucial for enhancing data processing throughput. Problem Statement: Write a function `move_zeros(array)` that takes an array and moves all the zeros to the end, preserving the order of other elements. The function should return the transformed array. - The function should NOT use any auxiliary arrays or other collections (i.e., it should be an in-place operation). - Maintain the order of non-zero elements. - Ensure the function accounts for edge cases such as mixed data types. Input Format: * A list `array` of length `n` (0 < n <= 10^4) containing integers, floats, booleans, and strings. Output Format: * A list where all zero values are moved to the end, and the order of other elements is preserved. Constraints: * Do not use extra space for another array. * Follow a linear time complexity O(n). Example: ```python assert move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) == [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] assert move_zeros([0, 1, 0, 3, 12]) == [1, 3, 12, 0, 0] assert move_zeros([0, 0, 1]) == [1, 0, 0] assert move_zeros([0]) == [0] assert move_zeros([1, 2, 3]) == [1, 2, 3] ``` Notes: - Consider that `False` is treated differently from `0` and should remain at its original position in the resulting array. - No need to handle arrays with data types other than those mentioned above. You may assume the input array will not contain any nested lists or dictionaries. Performance Requirements: - The function should have a linear runtime complexity, O(n).","solution":"def move_zeros(array): Move all zeros to the end of the list while preserving the order of non-zero elements. Arguments: array -- list of integers, floats, booleans, and strings Returns: list with zeros moved to the end last_non_zero_found_at = 0 for i in range(len(array)): if array[i] != 0 or isinstance(array[i], bool): array[last_non_zero_found_at] = array[i] last_non_zero_found_at += 1 for i in range(last_non_zero_found_at, len(array)): array[i] = 0 return array"},{"question":"# FizzBuzz++ Algorithm **Scenario**: You\'ve been tasked with enhancing the classic FizzBuzz algorithm to make it more challenging. This time, instead of substituting fixed strings for multiples of 3 and 5, you will use custom substitution rules. Create a function that takes a number N and two dictionaries: one mapping specific multiples to their replacement strings, and the other for specific numbers to their replacement strings. Your function should replace numbers according to these rules and only fall back to the classic behavior when no custom rule applies. **Function Signature**: ```python def fizzbuzz_plus(n: int, multiple_replacements: dict, number_replacements: dict) -> list: pass ``` **Input**: - `n` (int): The end of the range (inclusive) to generate the sequence. `n` will never be less than 1. - `multiple_replacements` (dict): A dictionary where the keys are positive integers and the values are strings. Replace numbers that are multiples of these keys with the corresponding values. - `number_replacements` (dict): A dictionary where the keys are positive integers and the values are strings. Replace exact numbers with the corresponding values. **Output**: - A list containing the transformed sequence as per the described rules. **Constraints**: - If a number qualifies for multiple replacements from `multiple_replacements`, concatenate the corresponding values (e.g., if a number is both a multiple of 3 and 5 replace it with the concatenation of both values). - `number_replacements` has higher priority over `multiple_replacements`. - If a number does not meet any custom rule, fall back to the classic FizzBuzz behavior (replace multiples of 3 with \\"Fizz\\", multiples of 5 with \\"Buzz\\", multiples of both with \\"FizzBuzz\\"). **Examples**: ```python assert fizzbuzz_plus(15, {3: \'Three\', 5: \'Five\'}, {7: \'Seven\'}) == [\'1\', \'2\', \'Three\', \'4\', \'Five\', \'Three\', \'Seven\', \'8\', \'Three\', \'Five\', \'11\', \'Three\', \'13\', \'14\', \'ThreeFive\'] assert fizzbuzz_plus(5, {}, {1: \'One\', 2: \'Two\'}) == [\'One\', \'Two\', \'Fizz\', \'4\', \'Buzz\'] ``` **Additional Notes**: - Ensure to handle invalid inputs gracefully by raising appropriate exceptions. - Your function should be efficient even if `n` is large (up to 10,000).","solution":"def fizzbuzz_plus(n: int, multiple_replacements: dict, number_replacements: dict) -> list: result = [] for i in range(1, n + 1): if i in number_replacements: # Exact number replacement has the highest priority result.append(number_replacements[i]) else: # Check for multiple replacements and concatenate if needed replacement = \'\' for multiple, replacement_str in multiple_replacements.items(): if i % multiple == 0: replacement += replacement_str # Fallback to classic FizzBuzz if no custom replacements matched if not replacement: if i % 3 == 0 and i % 5 == 0: replacement = \'FizzBuzz\' elif i % 3 == 0: replacement = \'Fizz\' elif i % 5 == 0: replacement = \'Buzz\' else: replacement = str(i) result.append(replacement) return result"},{"question":"Suppose you are developing software to determine the minimum travel cost from the starting point to a destination in a transport network where each station is identified by an index starting from 0 to N-1. The costs between stations are given by a cost matrix where cost[i][j] (i < j) represents the cost of going from station i to station j. Any invalid or unavailable paths are represented by a cost of INF (-1 in the context of input). Given the following requirements: * The number of stations N will always be at least 2. * The cost matrix is guaranteed to have at least one valid path from station 0 to station N-1. * The cost[i][j] will always be a non-negative integer or INF for i >= j. Write a function `min_travel_cost(cost_matrix: List[List[int]]) -> int:` that computes the minimum travel cost needed to reach station N-1 from station 0. # Function Signature ```python def min_travel_cost(cost_matrix: List[List[int]]) -> int: pass ``` # Input * `cost_matrix`: A list of N lists (each containing N integers), where `cost[i][j]` represents the cost of travel from station i to station j (for i < j). For `i >= j`, `cost[i][j]` will be -1. # Output * Returns an integer representing the minimum cost to travel from station 0 to station N-1. # Constraints * 2 <= N <= 1000 * If it\'s impossible to reach station N-1 from station 0, the function should return -1. # Example ```python cost_matrix = [ [0, 10, 75, 94], [-1, 0, 35, 50], [-1, -1, 0, 80], [-1, -1, -1, 0] ] assert min_travel_cost(cost_matrix) == 60 ``` Explanation: * The minimum cost path from station 0 -> 1 -> 3 is of cost `10 + 50 = 60`.","solution":"from typing import List import heapq def min_travel_cost(cost_matrix: List[List[int]]) -> int: N = len(cost_matrix) INF = float(\'inf\') # Create a list to hold the minimum cost to reach each station min_cost = [INF] * N min_cost[0] = 0 # Starting point # Using a priority queue to implement Dijkstra\'s algorithm pq = [(0, 0)] # (cost, station) while pq: current_cost, u = heapq.heappop(pq) if u == N - 1: return current_cost for v in range(u + 1, N): if cost_matrix[u][v] != -1: new_cost = current_cost + cost_matrix[u][v] if new_cost < min_cost[v]: min_cost[v] = new_cost heapq.heappush(pq, (new_cost, v)) return -1 if min_cost[N - 1] == INF else min_cost[N - 1]"},{"question":"# Intersection of Two Linked Lists You are given two singly linked lists. Each node in these lists contains an integer value and a pointer to the next node. The two linked lists may or may not intersect at some node. Write a function to determine the node at which the two lists intersect. If the lists do not intersect, return `None`. Implement the function `get_intersection_node(head1: Node, head2: Node) -> Node`. # Requirements * The function should have a time complexity of O(N + M), where N and M are the lengths of the two linked lists. * The function should have a space complexity of O(1). # Input * `head1: Node` - Head of the first linked list. * `head2: Node` - Head of the second linked list. # Output * Return the intersecting `Node` if the lists intersect; otherwise, return `None`. # Constraints * The input linked lists will not contain cycles. * Elements are represented by a `Node` class with properties `val` and `next`. # Example ```python # Definition for singly-linked list node. class Node: def __init__(self, val=0, next=None): self.val = val self.next = next # Example Input. # List1: 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # List2: 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f # Example Call: result = get_intersection_node(a1, a2) assert result.val == 7 # Since node with value 7 is the intersection node. ``` # Note * The above code defines an example with two intersecting linked lists and shows the expected intersection node to demonstrate the implementation.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def get_intersection_node(head1: Node, head2: Node) -> Node: # Helper function to get the length of a linked list def get_length(head: Node) -> int: length = 0 while head: length += 1 head = head.next return length length1 = get_length(head1) length2 = get_length(head2) # Adjust the starting point for the longer list while length1 > length2: head1 = head1.next length1 -= 1 while length2 > length1: head2 = head2.next length2 -= 1 # Traverse both lists together until a common node is found while head1 and head2: if head1 == head2: return head1 head1 = head1.next head2 = head2.next return None"},{"question":"Scenario You are working as a software engineer for a company that needs to maximize the profit of task scheduling. Each task can be represented by its start time, finish time, and associated profit. The goal is to select non-overlapping tasks to maximize the total profit. Problem Statement Write a function `max_profit` that takes a list of jobs, where each job is represented as a dictionary with keys `\'start\'`, `\'finish\'`, and `\'profit\'`. The function should return the maximum profit achievable by scheduling non-overlapping jobs. Function Signature ```python def max_profit(jobs: List[Dict[str, int]]) -> int: pass ``` Input * A list of dictionaries `jobs`, where each dictionary represents a job with the following keys: * `\'start\'`: An integer denoting the start time of the job. * `\'finish\'`: An integer denoting the finish time of the job. * `\'profit\'`: An integer denoting the profit of the job. * 1 <= Number of jobs <= 10^4 * 1 <= start time, finish time, profit <= 10^6 Output * An integer representing the maximum achievable profit from the non-overlapping scheduled jobs. Constraints * Each job\'s start time is less than its finish time. * Jobs may overlap. Example ```python jobs = [ {\'start\': 1, \'finish\': 3, \'profit\': 5}, {\'start\': 2, \'finish\': 5, \'profit\': 6}, {\'start\': 4, \'finish\': 6, \'profit\': 5}, {\'start\': 6, \'finish\': 7, \'profit\': 4}, {\'start\': 5, \'finish\': 8, \'profit\': 11}, {\'start\': 7, \'finish\': 9, \'profit\': 2} ] print(max_profit(jobs)) # Output: 17 ``` In this example, the maximum profit is achieved by selecting jobs with start and finish times (1,3), (5,8), and (6,7) to get a profit of 5 + 11 + 4 = 20. Hints * Consider sorting the jobs by their finish time to leverage optimal substructure. * Use a dynamic programming table to store the maximum profit up to each job. * Apply binary search to find the last non-conflicting job efficiently.","solution":"from typing import List, Dict import bisect def max_profit(jobs: List[Dict[str, int]]) -> int: # Sort jobs by their finish time jobs.sort(key=lambda x: x[\'finish\']) # Initialize dp array to store the maximum profit up to each job dp = [0] * len(jobs) # Function to find the latest job that doesn\'t conflict with the job at index \'i\' def find_last_non_conflicting(i): lo, hi = 0, i - 1 while lo <= hi: mid = (lo + hi) // 2 if jobs[mid][\'finish\'] <= jobs[i][\'start\']: if jobs[mid + 1][\'finish\'] <= jobs[i][\'start\']: lo = mid + 1 else: return mid else: hi = mid - 1 return -1 # Calculate dp[i] for all jobs dp[0] = jobs[0][\'profit\'] for i in range(1, len(jobs)): include_profit = jobs[i][\'profit\'] l = find_last_non_conflicting(i) if l != -1: include_profit += dp[l] dp[i] = max(dp[i-1], include_profit) # The last entry in dp is the result return dp[-1]"},{"question":"You are provided with a custom class implementation for representing **polynomials** and **monomials** in the given code snippet. The `Monomial` class encapsulates single-variable monomials while the `Polynomial` class handles sums of such monomials. Your task is to demonstrate the understanding of the classes\' functionality by implementing a function `polynomial_derivative` that computes the derivative of a given polynomial with respect to a specified variable. # Objectives 1. Implement a function `polynomial_derivative` that computes the derivative of a given polynomial with respect to a given variable. 2. Ensure your function respects the constraints and utilizes effective use of the provided `Monomial` and `Polynomial` classes. # Input: - A `Polynomial` instance representing the polynomial to be derived. - An integer `variable_index` representing the index of the variable with respect to which the derivation will be performed. # Output: - A new `Polynomial` instance representing the derivative of the input polynomial with respect to the specified variable. # Constraints: 1. You may assume that `variable_index` is a valid variable index present in the polynomial. 2. Your solution should efficiently handle polynomials with up to 100 monomials and monomials with up to 10 variables. 3. You should preserve the rational coefficient representation in the derivatives. # Example: ```python from fractions import Fraction # Example Polynomial: 5(a_1)^2(a_2)^3 - 3(a_1)(a_3) + 7 p = Polynomial([ Monomial({1:2, 2:3}, 5), Monomial({1:1, 3:1}, -3), Monomial({}, 7) ]) # Derivative with respect to variable a_1 dp_d1 = polynomial_derivative(p, 1) print(dp_d1) # Expected output: Polynomial of 10a1a2^3 - 3a3 # Derivative with respect to variable a_2 dp_d2 = polynomial_derivative(p, 2) print(dp_d2) # Expected output: Polynomial of 15a1^2a2^2 ``` # Function Signature ```python def polynomial_derivative(polynomial: Polynomial, variable_index: int) -> Polynomial: pass ``` # Additional Notes - Ensure that your function handles edge cases such as terms canceling out and resulting in a zero polynomial. - Implement the function in such a way that it leverages the existing methods in `Monomial` and `Polynomial` classes for arithmetic operations.","solution":"from fractions import Fraction class Monomial: def __init__(self, degrees, coefficient): self.degrees = degrees # A dictionary where key is variable index and value is the degree self.coefficient = coefficient # A rational number (Fraction) def differentiate(self, variable_index): if variable_index in self.degrees and self.degrees[variable_index] > 0: new_degrees = self.degrees.copy() new_degrees[variable_index] -= 1 if new_degrees[variable_index] == 0: del new_degrees[variable_index] new_coefficient = self.coefficient * self.degrees[variable_index] return Monomial(new_degrees, new_coefficient) else: return Monomial({}, Fraction(0)) # the derivative is zero if the variable index is not present or the degree is zero class Polynomial: def __init__(self, monomials=[]): self.monomials = monomials # A list of Monomials def add_monomial(self, monomial): self.monomials.append(monomial) def polynomial_derivative(polynomial, variable_index): derived_monomials = [] for monomial in polynomial.monomials: derived_monomial = monomial.differentiate(variable_index) if derived_monomial.coefficient != 0: derived_monomials.append(derived_monomial) return Polynomial(derived_monomials)"},{"question":"Scenario: You are tasked with implementing a function that determines the smallest perfect square greater than a given non-negative integer. A perfect square is a number that can be expressed as the square of an integer. For example, 16 is a perfect square because it equals 4^2. Task: Write a function called `find_next_square` that takes a non-negative integer `num` as input and returns the smallest perfect square greater than `num`. If `num` itself is not a perfect square, return `-1`. Function Signature: ```python def find_next_square(num: int) -> int: # Your code here ``` Input: * A single non-negative integer `num` (0 ≤ num ≤ 10^10). Output: * A single integer representing the smallest perfect square greater than `num` if `num` is a perfect square, or `-1` if `num` is not a perfect square. Constraints: * You must achieve the result in constant time O(1). * Do not use any built-in functions that can directly determine if a number is a perfect square. Examples: 1. `find_next_square(121)` should return `144` (since 121 is 11^2, and the next perfect square is 12^2 = 144). 2. `find_next_square(625)` should return `676` (since 625 is 25^2, and the next perfect square is 26^2 = 676). 3. `find_next_square(114)` should return `-1` (since 114 is not a perfect square). Additional Notes: * Pay attention to edge cases such as very large numbers or inputs that are just less than perfect squares (e.g., num = 120).","solution":"def find_next_square(num: int) -> int: Determines the smallest perfect square greater than a given non-negative integer if the input is a perfect square, returns it. Otherwise, returns -1. sqrt = int(num**0.5) if sqrt * sqrt == num: return (sqrt + 1) * (sqrt + 1) else: return -1"},{"question":"# Question: Enhanced Prime Detection for Cryptographic Applications Background: In cryptographic systems, it is vital to use large prime numbers for creating secure keys. While the traditional Rabin-Miller primality test provides good results, there are scenarios where higher confidence and handling for small primes are necessary. Your task is to implement an enhanced version of the Rabin-Miller primality test. This version will not only improve the test for larger numbers but also handle smaller prime checks more efficiently. Function Signature: ```python def enhanced_is_prime(n: int, k: int = 10) -> bool: Determine if a given integer is prime using an enhanced Rabin-Miller primality test. :param n: Integer to test for primality. :param k: Number of iterations for accuracy, default is 10. :return: True if n is probably prime, False if n is composite. ``` Input: - **n**: An integer ( n ) (( 1 leq n leq 10^{18} )) to be tested for primality. - **k**: An optional integer number of iterations ( k ), with a default value of 10. Output: - A boolean value: - `True` if ( n ) is probably prime. - `False` if ( n ) is composite. Constraints: 1. Do not use any non-standard Python libraries. 2. Ensure the method runs efficiently for all values of ( n ) up to ( 10^{18} ). Example Usages: 1. `enhanced_is_prime(17)` should return `True`. 2. `enhanced_is_prime(18)` should return `False`. 3. `enhanced_is_prime(561)` should return `False` since 561 is a Carmichael number and not prime. Hint: - Focus on optimizing modular exponentiation and initial checks for small numbers.","solution":"import random def is_prime_trial_division(n): Check for small primes using trial division up to 20. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def power_mod(a, d, n): Efficiently compute (a^d) % n result = 1 a = a % n while d > 0: if (d % 2) == 1: result = (result * a) % n d = d >> 1 a = (a * a) % n return result def rabin_miller(n, d, k): Perform the Rabin-Miller test for k iterations. for _ in range(k): a = random.randint(2, n - 2) x = power_mod(a, d, n) if x == 1 or x == n - 1: continue while d != n - 1: x = (x * x) % n d *= 2 if x == 1: return False if x == n - 1: break else: return False return True def enhanced_is_prime(n, k=10): Determine if a given integer is prime using an enhanced Rabin-Miller primality test. :param n: Integer to test for primality. :param k: Number of iterations for accuracy, default is 10. :return: True if n is probably prime, False if n is composite. if is_prime_trial_division(n): return True if n < 2 or n % 2 == 0: return False # Find d such that n-1 = d * 2^r for some r >= 1 d = n - 1 while d % 2 == 0: d //= 2 return rabin_miller(n, d, k)"},{"question":"You are given a partial implementation of a Binary Search Tree (BST) node. Your task is to implement a class `BST` with the following functionalities: 1. **Insert**: Insert a value into the BST. 2. **Search**: Search for a value in the BST and return `True` if the value exists, otherwise return `False`. 3. **Inorder Traversal**: Return a list of all values in the BST in ascending order. # Implementation Details 1. **Insert**: * Function Signature: `def insert(self, root: TreeNode, val: int) -> TreeNode` * Input: `root` - the root node of the BST, `val` - the value to be inserted. * Output: Return the root node of the BST after the insertion. 2. **Search**: * Function Signature: `def search(self, root: TreeNode, val: int) -> bool` * Input: `root` - the root node of the BST, `val` - the value to be searched. * Output: Return `True` if the value exists in the BST, otherwise return `False`. 3. **Inorder Traversal**: * Function Signature: `def inorderTraversal(self, root: TreeNode) -> List[int]` * Input: `root` - the root node of the BST. * Output: Return a list of values obtained from an inorder traversal of the BST. # Example ```python # Create an instance of BST bst = BST() # Initialize the root node root = TreeNode(10) # Insert values bst.insert(root, 5) bst.insert(root, 15) bst.insert(root, 3) bst.insert(root, 7) # Search values print(bst.search(root, 7)) # Output: True print(bst.search(root, 18)) # Output: False # Inorder traversal print(bst.inorderTraversal(root)) # Output: [3, 5, 7, 10, 15] ``` # Constraints * The value of nodes will be unique (no duplicate values allowed). * Implementations should handle the case of inserting the first node (when the tree is initially empty). # Notes * You can assume consistent input according to the constraints. * Focus on maintaining the BST properties during insertion and search operations. * The tree should remain balanced to ensure optimal performance for search operations if the input distribution is unknown.","solution":"from typing import Optional, List class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right class BST: def insert(self, root: Optional[TreeNode], val: int) -> TreeNode: Insert a value into the BST and return the root node. if root is None: return TreeNode(val) if val < root.val: root.left = self.insert(root.left, val) else: root.right = self.insert(root.right, val) return root def search(self, root: Optional[TreeNode], val: int) -> bool: Search for a value in the BST. Return True if the value exists, otherwise False. if root is None: return False if root.val == val: return True elif val < root.val: return self.search(root.left, val) else: return self.search(root.right, val) def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]: Return a list of all values in the BST in ascending order. def inorder(node: Optional[TreeNode]) -> List[int]: return inorder(node.left) + [node.val] + inorder(node.right) if node else [] return inorder(root)"},{"question":"# Prime Number Counting _A respected mathematician requests your help to determine the number of prime numbers less than a given integer n. A prime number is defined as any natural number greater than 1 that is not divisible by any number other than itself and 1._ Your task is to write a function `count_primes(n)` that counts all prime numbers less than n. Function Signature ```python def count_primes(n: int) -> int: Returns the number of prime numbers less than a non-negative number n. Parameters: n (int): The upper limit (exclusive) for counting prime numbers. Returns: int: Count of prime numbers less than n. ``` Constraints - The function should handle n in the range 0 ≤ n ≤ 10^6. - Aim for an efficient solution; a simple O(n√n) solution might work, but try to optimize further if possible. Input/Output Format - Input: A single integer `n`. - Output: An integer representing the count of prime numbers less than `n`. Example - `count_primes(10)` should return `4` because there are four prime numbers less than 10: 2, 3, 5, and 7. Notes - Use the `prime_check` function provided in the code snippet to check if individual numbers are prime. - Consider edge cases like `n = 0` or `n = 1`. Performance Requirement - The function should run efficiently even for the upper limit of n (n = 10^6).","solution":"def count_primes(n: int) -> int: Returns the number of prime numbers less than a non-negative number n. Parameters: n (int): The upper limit (exclusive) for counting prime numbers. Returns: int: Count of prime numbers less than n. if n <= 2: return 0 is_prime = [True] * n is_prime[0] = is_prime[1] = False for start in range(2, int(n ** 0.5) + 1): if is_prime[start]: for multiple in range(start * start, n, start): is_prime[multiple] = False return sum(is_prime)"},{"question":"# Maximum Flow Project Allocation You are assigned to manage a project allocation network for a company. The network is represented as an adjacency matrix where the value of `graph[i][j]` indicates the capacity (maximum units of work that can be transferred) from node `i` to node `j`. The goal is to determine the maximum flow of work from the source node `0` to the sink node `n-1`, where `n` is the number of nodes in the graph. Function Specification **Function Name**: `maximum_flow_dfs` **Parameters**: ```python def maximum_flow_dfs(adjacency_matrix): # implementation ``` * `adjacency_matrix`: A list of lists, where `adjacency_matrix[i][j]` is an integer representing the capacity of an edge from node `i` to node `j`. **Returns**: An integer representing the maximum flow from the source to the sink. Constraints * The size of the graph `n` (number of nodes) is such that 2 ≤ n ≤ 100. * The capacities are non-negative integers and can be as large as 1,000. Example ```python graph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]] result = maximum_flow_dfs(graph) print(result) # Output: 23 ``` Scenario Imagine a tech company organizing its projects, wherein each project must pass through several stages (nodes). Each stage has different capacities due to resource constraints. Your task is to write an algorithm that computes the maximum flow of projects from the entrance to the final deployment, ensuring optimal utilization of available capacities. **Note**: Assume the first node (index 0) is the source, and the last node (index n-1) is the sink. Additional Information 1. Your function should handle edge cases like disconnected graphs (where no path exists from source to sink). 2. Consider any performance improvements if feasible.","solution":"def maximum_flow_dfs(adjacency_matrix): Returns the maximum flow from the source node 0 to the sink node n-1 using DFS. n = len(adjacency_matrix) # number of nodes source = 0 # source node sink = n - 1 # sink node # Create a residual graph and fill the residual graph with the given capacities in the original graph residual_graph = [row[:] for row in adjacency_matrix] # This array is filled by DFS and to store the path parent = [-1] * n def dfs(source, sink): Returns True if there is a path from source to sink in residual graph. Fills parent[] to store the path. visited = [False] * n stack = [source] visited[source] = True while stack: u = stack.pop() for v, capacity in enumerate(residual_graph[u]): if not visited[v] and capacity > 0: # Maintain the path in parent stack.append(v) visited[v] = True parent[v] = u if v == sink: return True return False max_flow = 0 # There is no flow initially while dfs(source, sink): # Find the maximum flow through the path found by DFS path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] # update residual capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] residual_graph[u][v] -= path_flow residual_graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Minimum Spanning Tree Construction with Kruskal’s Algorithm **Objective**: Implement Kruskal’s algorithm to find the Minimum Spanning Tree (MST) for a given connected, undirected graph involving integer-weighted edges. **Problem Statement**: You are given an undirected, weighted graph with `n` vertices and `m` edges. Each edge connects two vertices `u` and `v` and has a weight `w`. Your task is to compute the sum of weights of the edges in the MST. **Input**: * The first line contains two integers `n` (1 ≤ n ≤ 1000) and `m` (1 ≤ m ≤ 10000) - the number of vertices and edges, respectively. * The next `m` lines each contain three integers `u`, `v`, and `w` (1 ≤ u, v ≤ n, 1 ≤ w ≤ 10000) - detailing an edge between vertex `u` and vertex `v` with weight `w`. Note that the graph may contain multiple edges between the same pair of vertices. **Output**: * Print one integer - the sum of the weights of the edges in the MST. **Function Signature**: ```python def compute_mst(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: # Your implementation here ``` # Example: **Example 1**: ```plaintext Input: 5 6 1 2 3 1 3 8 2 4 5 3 4 2 3 5 4 4 5 6 Output: 14 ``` **Example 2**: ```plaintext Input: 3 3 2 1 20 3 1 20 2 3 100 Output: 40 ``` # Constraints: * Ensure efficient handling of disjoint sets with path compression and union by rank. * Assume input vertices are 1-indexed. * Make sure to handle graphs with multiple edges and unique weights correctly. * Avoid any unnecessary recomputation or scanning of edge lists. Hints: - Utilize the disjoint set (union-find) for cycle detection while processing the edges. - Sort the edges by their weight before processing them.","solution":"from typing import List, Tuple def compute_mst(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: # Helper functions for the Union-Find data structure def find(parent, i): if parent[i] == i: return i else: # Path compression heuristic parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Sort all the edges in non-decreasing order of their weight edges.sort(key=lambda x: x[2]) # Initialize union-find structure parent = [i for i in range(n)] rank = [0] * n mst_weight_sum = 0 edges_in_mst = 0 for u, v, w in edges: u, v = u - 1, v - 1 # Convert to 0-based index for our union-find structure if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_weight_sum += w edges_in_mst += 1 # If we already have n-1 edges in MST, we can break early if edges_in_mst == n - 1: break return mst_weight_sum"},{"question":"# Atbash Cipher Implementation **Objective**: Implement a function that encrypts a given string using the Atbash Cipher and returns the encrypted string. The Atbash Cipher is a simple substitution cipher where each letter of the alphabet is mapped to its reverse (e.g., \'a\' is mapped to \'z\', \'b\' to \'y\', and so on). Non-letter characters should remain unchanged. **Function Signature**: ```python def atbash(s: str) -> str: # your code here ``` **Input**: * A single string `s` (1 <= len(s) <= 1000) consisting of uppercase letters, lowercase letters, and non-letter characters. **Output**: * Return the encrypted string. **Constraints**: * The input string can contain any printable characters. **Scenario**: For example, consider an ancient manuscript where the text needs to be obfuscated. Using the Atbash cipher, we can convert easy-to-read text into something less immediately understandable. **Example**: ```python assert atbash(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash(\\"Hello, World!\\") == \\"Svool, Dliow!\\" assert atbash(\\"123 456\\") == \\"123 456\\" ``` **Explanation**: * The input \\"Attack at dawn\\" is transformed character wise: \'A\' -> \'Z\', \'t\' -> \'g\', \'a\' -> \'z\', \'c\' -> \'x\', \'k\' -> \'p\', and so on. * Non-letter characters such as spaces and punctuation marks remain unchanged. **Performance Requirements**: * The function should run efficiently within the constraints (O(n) time complexity).","solution":"def atbash(s: str) -> str: Encrypts the given string using the Atbash Cipher. Each letter is substituted with its reverse in the alphabet. Non-letter characters remain unchanged. def atbash_char(c): if \'a\' <= c <= \'z\': return chr(ord(\'z\') - (ord(c) - ord(\'a\'))) elif \'A\' <= c <= \'Z\': return chr(ord(\'Z\') - (ord(c) - ord(\'A\'))) else: return c return \'\'.join(atbash_char(c) for c in s)"},{"question":"You are given a square matrix, and your task is to implement functions that perform various transformations on this matrix. Demonstrate your understanding of matrix manipulations by implementing the following functions in Python: 1. **Rotate Clockwise**: Rotate the matrix 90 degrees clockwise. 2. **Rotate Counterclockwise**: Rotate the matrix 90 degrees counterclockwise. 3. **Top Left Invert**: Perform a vertical mirror inversion on the top-left to bottom-right diagonal. 4. **Bottom Left Invert**: Perform a horizontal mirror inversion on the bottom-left to top-right diagonal. # Function Signatures ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: pass def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: pass def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Input Format - A 2D list `matrix` containing integers. - The matrix will always be square (`N x N` where `N >= 0`). # Output Format - Return the transformed matrix as a 2D list for each function. # Constraints - Your functions should handle an empty matrix: `matrix = []`. - Make sure to handle matrices with odd and even dimensions correctly. # Performance Requirements - Aim for O(n^2) time complexity for each function. - Aim for O(n^2) space complexity due to new matrix creation. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Example usage: rotate_clockwise(matrix) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 3, 0] # ] rotate_counterclockwise(matrix) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] top_left_invert(matrix) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] bottom_left_invert(matrix) # Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ``` Implement the above functions correctly handling all specified transformations.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: if not matrix: return [] N = len(matrix) return [[matrix[N - j - 1][i] for j in range(N)] for i in range(N)] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: if not matrix: return [] N = len(matrix) return [[matrix[j][N - i - 1] for j in range(N)] for i in range(N)] def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: if not matrix: return [] N = len(matrix) inverted = [[matrix[j][i] for j in range(N)] for i in range(N)] return inverted def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: if not matrix: return [] N = len(matrix) inverted = [[matrix[N - j - 1][N - i - 1] for j in range(N)] for i in range(N)] return inverted"},{"question":"You are given two strings, `haystack` and `needle`. Implement an algorithm to find the first occurrence of the substring `needle` in the string `haystack`. Return the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Detailed Requirements - The function should be named `search_substring`. - The input consists of two strings: - `haystack`: A string in which you will search for the substring. - `needle`: The substring that needs to be searched within the `haystack`. - The output should be a single integer: - Return the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Constraints - `0 <= len(haystack), len(needle) <= 10^4` - The input strings are composed of lowercase English letters. # Examples 1. Example 1: - Input: `haystack = \\"hello\\"`, `needle = \\"ll\\"` - Output: `2` 2. Example 2: - Input: `haystack = \\"aaaaa\\"`, `needle = \\"bba\\"` - Output: `-1` 3. Example 3: - Input: `haystack = \\"abcdef\\"`, `needle = \\"\\"` - Output: `0` 4. Example 4: - Input: `haystack = \\"pineapple\\"`, `needle = \\"apple\\"` - Output: `4` # Additional Notes - If `needle` is an empty string, the function should return 0. - Consider optimizing the brute force approach for better performance, especially for larger strings. Options include the Knuth-Morris-Pratt (KMP) algorithm or the Boyer-Moore algorithm for bonus challenges. # Function Signature ```python def search_substring(haystack: str, needle: str) -> int: pass ```","solution":"def search_substring(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. if needle == \\"\\": return 0 return haystack.find(needle)"},{"question":"**Problem Statement**: Implement an optimized version of Bucket Sort that accounts for non-uniformly distributed data using a more efficient sorting algorithm for the buckets. Specifically, replace Insertion Sort with QuickSort for sorting the contents of each bucket to enhance performance for larger datasets. **Function Signature**: ```python def bucket_sort(arr: List[int]) -> List[int]: pass ``` **Input**: * `arr`: A list of integers where (0 leq arr[i] leq 10^6) and (0 leq len(arr) leq 10^6). **Output**: * Returns a list of integers sorted in ascending order. **Constraints**: * The input list can be empty, and the function should handle this case gracefully. * You should ensure the algorithm runs efficiently even with larger datasets. **Detailed Requirements**: 1. Partition the input list into a plausible number of buckets. 2. Distribute the values from the input list into the corresponding buckets based on their value range. 3. Implement QuickSort for individually sorting the elements within each bucket. 4. Concatenate the contents of all buckets in order to form the output list. 5. Ensure that the space complexity is minimized as much as possible, adhering to constraints. **Example**: ```python # Example 1: print(bucket_sort([4, 1, 2, 3, 5, 7, 6, 8])) # Output: [1, 2, 3, 4, 5, 6, 7, 8] # Example 2: print(bucket_sort([8, 5, 2, 7, 4, 0])) # Output: [0, 2, 4, 5, 7, 8] # Example 3: print(bucket_sort([10, 20, 30, 40, 50])) # Output: [10, 20, 30, 40, 50] ``` **Notes**: * While QuickSort is chosen here for better performance, ensure proper implementation to achieve O(n log n) performance in average cases. * Think about the most efficient way to partition the buckets given the constraints.","solution":"from typing import List def quicksort(arr): if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right) def bucket_sort(arr: List[int]) -> List[int]: if not arr: return [] min_value = min(arr) max_value = max(arr) bucket_count = len(arr) bucket_size = (max_value - min_value) / bucket_count + 1 buckets = [[] for _ in range(bucket_count)] for num in arr: bucket_index = int((num - min_value) / bucket_size) buckets[bucket_index].append(num) sorted_arr = [] for bucket in buckets: sorted_arr.extend(quicksort(bucket)) return sorted_arr"},{"question":"# Problem: Optimized Exchange Sort You are given an array of integers, and your task is to implement an optimized version of the **Exchange Sort** algorithm. The optimized version should include: 1. A mechanism to detect if the array is already sorted to avoid unnecessary iterations. 2. Handling of edge cases such as empty arrays and arrays with a single element. Each element in the array can be any integer value (positive, negative, or zero). Function Signature ```python def optimized_exchange_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr`: A list of integers `arr` of size `n` (0 ≤ n ≤ 10^4). Output * A sorted list (in ascending order) of integers. Constraints * Do not use built-in sorting methods. * Ensure the algorithm remains O(n^2) in worst-case scenarios but includes optimizations for best-case scenarios. * Handle edge cases like empty lists or single-element lists gracefully. Example ```python # Example 1 input_arr = [64, 25, 12, 22, 11] output_arr = optimized_exchange_sort(input_arr) # Expected output: [11, 12, 22, 25, 64] # Example 2 input_arr = [1] output_arr = optimized_exchange_sort(input_arr) # Expected output: [1] # Example 3 input_arr = [] output_arr = optimized_exchange_sort(input_arr) # Expected output: [] # Example 4 input_arr = [5, 1, 2, 2, 3, 1] output_arr = optimized_exchange_sort(input_arr) # Expected output: [1, 1, 2, 2, 3, 5] ``` Description 1. **Core Operational Steps**: - Implement nested loops for pairwise comparison and swapping, as done in the traditional Exchange Sort. - Introduce an optimization flag to check if any swaps were made during an iteration. If no swaps occur, the array is already sorted, and the algorithm should terminate early to save computations. 2. **Edge Cases**: - Ensure your algorithm efficiently handles cases where the input array is empty or contains only one element. - Maintain correctness for arrays containing duplicate elements and negative numbers. 3. **Performance**: - Analyze and ensure your implementation works efficiently within the constraints provided.","solution":"from typing import List def optimized_exchange_sort(arr: List[int]) -> List[int]: n = len(arr) if n <= 1: return arr for i in range(n - 1): # A flag to detect any swaps swapped = False for j in range(n - 1 - i): if arr[j] > arr[j + 1]: # Swap the elements arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True # If no swaps occurred, the array is already sorted if not swapped: break return arr"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: This is an algorithm for reconstructing a queue based on given conditions (a form of a greedy algorithm). * **Complexity**: * **Time Complexity**: Sorting the list takes (O(n log n)) and inserting each person into the queue takes up to (O(n)). Hence, the overall time complexity is (O(n^2)) where (n) is the number of people. * **Space Complexity**: The space complexity is (O(n)) to store the final queue. * **Principles**: The algorithm sorts people in descending order of height and, within each height group, in ascending order of k. This ensures that when a person is inserted into the queue, the people already placed before them satisfy the required criteria. The insertion is done at the index specified by k. # Characteristics & Applications * **Properties**: * The algorithm leverages a greedy approach to ensure that once placed, each person meets the constraints of people taller than or equal to them being correctly positioned. * It utilizes sorting and insertion operations. * **Common Use Cases**: * Reconstructing scenarios where relative position based on constraints needs to be maintained. * Practical applications could include seating arrangements, line formations, or scheduling problems where order matters. * **Strengths/Limitations**: * **Strengths**: * The clarity and efficiency of the approach given the problem constraints. * Guarantees that the solution meets the relative positioning requirements. * **Limitations**: * The algorithm may not be optimal for larger datasets due to (O(n^2)) complexity. * Insertion operations can get costly in terms of time with larger datasets. # Implementation Challenges * **Edge Cases**: * Empty input list. * All people having the same height. * People with (k) values that are zero. * **Performance Bottlenecks**: * Frequent insertions into the list, especially if the list grows larger. * **Error Scenarios**: * Misinterpreting the criteria for sorting and insertion can lead to incorrect queue reconstructions. * **Optimization Points**: * Use of data structures that optimize insertions (e.g., linked lists) to potentially enhance performance. <|Analysis End|> <|Question Begin|> # Queue Reconstruction Question You are given a list of people standing in a queue. Each person is described by a pair of integers ((h, k)) where: * ( h ) is the height of the person. * ( k ) is the number of people in front of this person who have a height greater than or equal to ( h ). Your task is to write a function to reconstruct the queue based on these criteria. # Function Signature ```python def reconstruct_queue(people: List[List[int]]) -> List[List[int]]: ``` # Input * `people`: A list of integers of dimensions (N times 2) where (N) is the number of people, and each person is represented by a list ([h, k]). * The input list is such that (0 leq k < N) and (1 leq h leq 10^6). # Output * The function should return a list of integers of dimensions (N times 2) representing the reconstructed queue. # Constraints * It is guaranteed that the number of people is less than 1,100. * The reconstructed queue must ensure all individuals are positioned correctly based on their height and the number of people taller (or of equal height) in front of them. # Example ```python # Example Input people = [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]] # Example Output # The reconstructed queue should be: # [[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]] ``` # Hints * Think about sorting the individuals first to decide the insertion order. * Understand how the sorting criteria affect the insertion positions. |Question End|>","solution":"from typing import List def reconstruct_queue(people: List[List[int]]) -> List[List[int]]: # Sort the people to place taller people (and higher k values first) people.sort(key=lambda x: (-x[0], x[1])) queue = [] # Iterate over the sorted list and insert each person into the queue for person in people: queue.insert(person[1], person) return queue"},{"question":"# Context You\'ve been hired to work on a legacy system that employs a sorting mechanism for small datasets using a simple but outdated algorithm, Exchange Sort. Your task is to implement this algorithm and ensure it handles various edge cases effectively. # Task Write a function `exchange_sort_improved(arr)` that implements the exchange sort algorithm to sort an array of integers. Optimize the function to handle different edge cases and ensure the robustness of the algorithm. # Function Signature ```python def exchange_sort_improved(arr: List[int]) -> List[int]: pass ``` # Constraints * The input will be a list of integers. * The function must sort the array in place and also return it for convenience. * Your implementation should handle edge cases and ensure it gracefully handles invalid inputs. # Input * `arr`: List of integers to be sorted, `0 ≤ len(arr) ≤ 10^3`. # Output * Returns the sorted list of integers. # Examples ```python assert exchange_sort_improved([]) == [] assert exchange_sort_improved([1]) == [1] assert exchange_sort_improved([3, 1, 2]) == [1, 2, 3] assert exchange_sort_improved([5, -1, 3, 2, 4, 1]) == [-1, 1, 2, 3, 4, 5] assert exchange_sort_improved([1, 1, 1]) == [1, 1, 1] ``` # Edge Cases to Consider 1. The array is empty. 2. The array has one element. 3. The array is already sorted. 4. The array is sorted in reverse order. 5. The array contains duplicate values. 6. An invalid input is passed (e.g., a non-list argument). **Note:** Be cautious of the performance limitations imposed by the O(n^2) complexity of this algorithm when handling the maximum constraints.","solution":"from typing import List def exchange_sort_improved(arr: List[int]) -> List[int]: if not isinstance(arr, list): raise ValueError(\\"Input must be a list of integers.\\") if not all(isinstance(x, int) for x in arr): raise ValueError(\\"All elements of the list must be integers.\\") n = len(arr) for i in range(n - 1): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Question: Implement a Delete Operation for Binary Search Tree Scenario A software system needs a dynamically-updating tree data structure for storing and retrieving ordered elements. You are required to extend the provided `Binary Search Tree (BST)` implementation by adding a `delete` operation. This operation should correctly remove a node with a specified value, ensuring that the BST property is maintained after deletion. Requirements 1. **Function Signature**: ```python def delete(self, data): Deletes a node with the given data from the BST. Returns True if the node was deleted, False if the node was not found. ``` 2. **Handling Deletion**: * Nodes with no children should be removed straightforwardly. * Nodes with one child should have the child replace them. * Nodes with two children should be replaced by the smallest value node in the right subtree (successor), or largest value node in the left subtree (predecessor). Input/Output * **Input**: * `data`: An integer value to delete from the BST. * **Output**: * Returns `True` if the node was found and deleted. * Returns `False` if the node was not found in the BST. Constraints 1. BST properties must be maintained after deletion. 2. The solution should aim for O(log N) complexity on average, but may be O(N) in the worst case. Example Consider the following operations on the BST: ```python bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) bst.insert(12) bst.insert(17) bst.delete(15) # Delete a node with two children bst.delete(5) # Delete a node with one child bst.delete(3) # Delete a node with no children bst.delete(42) # Attempt to delete a non-existent node ``` Expected behavior: * Deleting `15` rearranges the subtree rooted at `15` such that the BST property is maintained. * Deleting `5` should rearrange nodes accordingly. * Deleting `3` should simply remove the node. * Deleting `42` should return `False` as the node does not exist.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def delete(self, key): self.root, deleted = self._delete(self.root, key) return deleted def _delete(self, root, key): if root is None: return root, False if key < root.val: root.left, deleted = self._delete(root.left, key) elif key > root.val: root.right, deleted = self._delete(root.right, key) else: deleted = True if root.left is None: return root.right, deleted elif root.right is None: return root.left, deleted temp_val = self._min_value_node(root.right).val root.val = temp_val root.right, _ = self._delete(root.right, temp_val) return root, deleted def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def inorder(self): return self._inorder(self.root) def _inorder(self, root): res = [] if root is not None: res = self._inorder(root.left) res.append(root.val) res = res + self._inorder(root.right) return res"},{"question":"You are tasked with implementing a function to calculate the n-th Fibonacci number. The function should demonstrate understanding of different algorithms and their efficiencies. Additionally, the implementation should handle edge cases and optimize performance based on the approach used. # Requirements 1. **Function Name**: `calculate_fibonacci` 2. **Input**: An integer n (0 ≤ n ≤ 10^6) 3. **Output**: An integer representing the n-th Fibonacci number. # Constraints - The function must be efficient and handle large values of n up to 10^6. - Use memoization or an iterative approach to ensure optimal performance. # Example ```python def calculate_fibonacci(n): # Your implementation here pass print(calculate_fibonacci(0)) # => 0 print(calculate_fibonacci(1)) # => 1 print(calculate_fibonacci(10)) # => 55 print(calculate_fibonacci(100)) # => 354224848179261915075 ``` # Hints - Consider using memoization to optimize the recursive approach if chosen. - The iterative approach is recommended for its optimal time and space complexity. # Performance Requirements - The implementation should run efficiently for values up to 10^6.","solution":"def calculate_fibonacci(n): Calculate the n-th Fibonacci number. Parameters: n (int): The position in the Fibonacci sequence (0 ≤ n ≤ 10^6). Returns: int: The n-th Fibonacci number. if n == 0: return 0 if n == 1: return 1 fib_0, fib_1 = 0, 1 for _ in range(2, n + 1): fib_0, fib_1 = fib_1, fib_0 + fib_1 return fib_1"},{"question":"Given a list of floating-point numbers, implement an optimized version of the bucket sort algorithm. Ensure your implementation addresses potential performance bottlenecks and handles edge cases effectively. Function Signature: ```python def optimized_bucket_sort(arr: List[float]) -> List[float]: ``` Input: - A list of floating-point numbers `arr` where ( 0 le arr[i] < 1 ) Output: - A list of floating-point numbers sorted in ascending order. Constraints: - The length of `arr` can be up to ( 10^6 ) Performance Requirement: - The function should run within a reasonable time limit considering the input size. Example: ```python assert optimized_bucket_sort([0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]) == [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94] assert optimized_bucket_sort([0.42, 0.32, 0.37, 0.47, 0.51]) == [0.32, 0.37, 0.42, 0.47, 0.51] ``` Notes: - Ensure that your implementation remains efficient even when most of the elements are concentrated in a narrow range. - Use Python\'s built-in sorting functions to sort individual buckets if beneficial.","solution":"from typing import List def optimized_bucket_sort(arr: List[float]) -> List[float]: This function implements an optimized version of the bucket sort algorithm to sort a list of floating-point numbers where each number is in the range [0, 1). if not arr: return [] n = len(arr) buckets = [[] for _ in range(n)] # Distribute input array values into buckets for num in arr: index = int(num * n) buckets[index].append(num) # Sort individual buckets and concatenate results sorted_array = [] for bucket in buckets: sorted_array.extend(sorted(bucket)) return sorted_array"},{"question":"# Question: Extended Selection Sort Function with Logging You are given the task of extending the basic `selection_sort` function to not only sort the array but also log the internal steps for review. Your function should handle the following: 1. **Function Signature**: ```python def extended_selection_sort(arr, log=False): ``` 2. **Input**: - `arr`: A list of integers to be sorted. - `log`: A boolean flag indicating whether to log the sorting process steps. 3. **Output**: - The function should return a list of tuples. Each tuple should contain the intermediate array state after each iteration of the outer loop and the swapped elements in that iteration if the `log` flag is `True`. If `log` is `False`, the function should behave like a standard selection sort returning the sorted array without logs. 4. **Constraints**: - The array can contain integers, including duplicates, positive, and negative values. - The length of the array, `n`, will be in the range [0, 10^3]. # Scenario: Consider a situation where a software engineer is debugging an ancient codebase using selection sort and needs to understand its internal operations clearly to verify its function and performance. You need to provide an implementation that not only sorts the array but also provides meaningful logs of the internal state for each iteration if requested. # Example: ```python # Example usage: arr = [64, 25, 12, 22, 11] result = extended_selection_sort(arr, log=True) # Expected output: # [(12, 25, 64, 22, 11), (0, 2)] - After iteration 0, swapped elements at indices 0 and 2 # [(12, 11, 64, 22, 25), (1, 4)] - After iteration 1, swapped elements at indices 1 and 4 # [(12, 11, 22, 64, 25), (2, 3)] - After iteration 2, swapped elements at indices 2 and 3 # [(12, 11, 22, 25, 64), (3, 4)] - After iteration 3, swapped elements at indices 3 and 4 # Example without logging: arr = [64, 25, 12, 22, 11] result = extended_selection_sort(arr, log=False) # Expected output: # [11, 12, 22, 25, 64] ``` Implement the `extended_selection_sort` function described above.","solution":"def extended_selection_sort(arr, log=False): Extended selection sort that logs the internal sorting process. Parameters: arr (list of int): List of integers to be sorted. log (bool): Flag to indicate whether to log the sorting steps. Returns: list: The sorted array with or without logs. n = len(arr) logs = [] for i in range(n): min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] if log: logs.append((arr[:], (i, min_idx))) return logs if log else arr"},{"question":"# Set Cover Problem with Costs You are tasked with solving a variant of the Set Cover problem where each subset in the solution has an associated cost. Your job is to find a collection of subsets that cover the entire universe set with the minimum possible cost. Problem Description: You are given: 1. A universe set `U` of `n` elements. 2. A collection of subsets `S` where each subset has elements from `U` and an associated cost. 3. Your goal is to find the minimum-cost subcollection of `S` that covers all elements of `U`. Input Format: 1. `U`: A list of integers representing the universe set. 2. `subsets`: A dictionary where keys are subset names and values are sets containing the elements. 3. `costs`: A dictionary where keys are subset names and values are the respective costs. Output Format: A single list representing the names of the selected subsets that provide the minimum cost cover for the universe. Constraints: 1. Each element in the universe must be covered. 2. All subsets are unique with non-negative costs. 3. The sum of the costs needs to be minimized. Example: ```python universe = [1, 2, 3, 4, 5] subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} # Expected Output (one of the valid outputs) [\'S2\', \'S3\'] ``` Write a function `find_min_cost_set_cover` that solves the above problem: Function Signature: ```python def find_min_cost_set_cover(universe: list, subsets: dict, costs: dict) -> list: pass ``` Requirements: 1. The solution must accurately compute the minimal cost set cover. 2. Handle both small and large input sizes appropriately, possibly choosing between the optimal and greedy strategies accordingly. 3. Consider and handle any potential edge cases.","solution":"def find_min_cost_set_cover(universe, subsets, costs): This function finds the minimum cost collection of subsets that cover the entire universe. remaining_elements = set(universe) selected_subsets = [] while remaining_elements: # Find the subset with the best cost per new element covered best_subset = None best_cost = float(\'inf\') best_cover = set() for subset_name, subset_elements in subsets.items(): new_cover = remaining_elements & subset_elements if new_cover: current_cost = costs[subset_name] / len(new_cover) if current_cost < best_cost: best_cost = current_cost best_subset = subset_name best_cover = new_cover if best_subset is None: raise ValueError(\\"No valid subset cover found for the universe\\") # Add the chosen subset to the selected list and remove its elements from the remaining set selected_subsets.append(best_subset) remaining_elements -= best_cover return selected_subsets"},{"question":"**Objective**: Implement a function to find the missing number from a sequence of unique integers in the range [0..n]. Problem Statement Given a list of unique integers `nums` that represent a continuous range [0..n] but with one number missing, you are required to find the missing number. If the sequence is already complete, return the next integer in the sequence. Function Signature ```python def find_missing_number(nums: List[int]) -> int: ``` Input * `nums` (List[int]): A list of unique integers in the range [0..n], where exactly one integer is missing from the sequence. Output * `int`: The missing integer from the given sequence. If the sequence is complete, return the next integer in the sequence. Constraints * The list contains `n` unique integers, where n ranges from 0 to 1000. * The integers in the list range from 0 to n inclusive with exactly one integer missing. * The list should only contain integers and be within the given range. Examples ```python # Example 1 input: [4, 2, 3, 0, 5] output: 1 # Example 2 input: [0, 1, 2, 3] output: 4 # Example 3 input: [1] output: 0 # Example 4 input: [] output: 0 ``` Additional Notes * Ensure that your function works efficiently with both small and large sequences within the given range. * Consider edge cases, such as when the list is empty or contains only one element. **Scenario/Context**: You might be working on a system that requires verification of continuous ID ranges, like employee IDs or product serial numbers. This function can help identify a missing range value or the next available ID efficiently.","solution":"def find_missing_number(nums): Given a list of unique integers in the range [0..n], find the missing number. If no number is missing, return the next integer in the sequence. n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"# Question: Reverse a Sublist of a Singly Linked List You are given a singly linked list and two integers `m` and `n` such that 1 ≤ m ≤ n ≤ length of the list. Write a function to reverse the nodes of the singly linked list from position `m` to `n`, both inclusive. **Function signature**: `def reverse_sublist(head: ListNode, m: int, n: int) -> ListNode:` # Input * `head`: The head of the singly linked list. * `m`: An integer specifying the start position of the sublist to reverse. * `n`: An integer specifying the end position of the sublist to reverse. # Output * The head of the modified linked list after reversing the sublist from position `m` to `n`. # Constraints * 1 ≤ m ≤ n ≤ length of the list. # Example Consider the linked list: `h -> 1 -> 2 -> 3 -> 4 -> 5` * If m = 2 and n = 4, the list should become `h -> 1 -> 4 -> 3 -> 2 -> 5`. # Instructions 1. Create a linked list structure for nodes, and implement the reverse_sublist function. 2. Ensure the function handles all edge cases. 3. Keep the overall time complexity within O(n) and space complexity within O(1). **Hint**: To simplify the problem, first identify the sublist starting at position `m` and ending at position `n`, reverse it using any standard reversal technique, and then reconnect the reversed sublist back to the original list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_sublist(head: ListNode, m: int, n: int) -> ListNode: if not head or m == n: return head dummy = ListNode(0) dummy.next = head prev = dummy # Move `prev` to the node before sublist starts for _ in range(m - 1): prev = prev.next # `start` will eventually be the last node in the reversed sublist start = prev.next then = start.next # Reverse the sublist by changing the next pointers for _ in range(n - m): start.next = then.next then.next = prev.next prev.next = then then = start.next return dummy.next"},{"question":"Problem Statement You are tasked with implementing an algorithm that multiplies two positive integers without using the \'*\' operator. The function should utilize only bitwise operations (e.g., AND, OR, XOR, NOT, SHIFT). # Input Two positive integers `a` and `b`. # Output A single integer which is the product of `a` and `b`. # Constraints - ( 1 leq a, b leq 10^5 ) - Both `a` and `b` are non-negative and within the range of standard integer size limits. # Example ```python Input: 3, 4 Output: 12 Input: 2, 3 Output: 6 ``` # Function Signature ```python def multiply_bitwise_operator(a: int, b: int) -> int: # your code here pass ``` # Explanation - **Multiplication using bitwise operations**: - Addition of `a` repeatedly `b` times would traditionally use a loop. - To multiply using bitwise operations, leverage properties of doubling (left shift) and addition until the multiplication result is achieved.","solution":"def multiply_bitwise_operator(a: int, b: int) -> int: Multiplies two positive integers using bitwise operations. result = 0 while b > 0: # If the lowest bit of b is set, add current value of a to result if b & 1: result = add_bitwise(result, a) # Double the value of a and halve the value of b a = a << 1 b = b >> 1 return result def add_bitwise(x: int, y: int) -> int: Adds two positive integers using bitwise operations. while y != 0: carry = x & y x = x ^ y y = carry << 1 return x"},{"question":"**Problem Statement**: You are given a positive integer `n`, and you are tasked to determine the nth digit in the infinitely long sequence of digits formed by concatenating positive integers consecutively (i.e., 123456789101112...). Your function should return the nth digit. **Function Signature**: ```python def find_nth_digit(n: int) -> int: pass ``` **Input**: * A single integer `n` (1 ≤ n ≤ 2 * 10^9) **Output**: * The nth digit in the concatenated sequence as an integer. **Examples**: ```python assert find_nth_digit(1) == 1 # The first digit is 1 assert find_nth_digit(11) == 0 # The 11th digit is 0 (within \'10\') assert find_nth_digit(12) == 1 # The 12th digit is 1 (within \'10\') assert find_nth_digit(15) == 2 # The 15th digit is 2 (within \'12\') ``` **Constraints/Limitations**: * Ensure your solution is optimized for high values of `n` up to 2 billion. * Consider precision issues with large numbers especially in languages with limited integer precision. * Handle edge cases where `n` is very small (e.g., n = 1) or specifically around changes in the digit length (e.g., n = 10 transitioning from single digit to two digits). **Performance Requirements**: * Your solution should have a time complexity of O(log n) and use O(1) additional space.","solution":"def find_nth_digit(n: int) -> int: Determine the nth digit in the infinitely long sequence of digits formed by concatenating positive integers consecutively. # Determine the digit count range length, count, start = 1, 9, 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Determine the exact number and digit start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"Given a singly linked list, create a function `is_sorted(head)` that returns `True` if the linked list is sorted in an increasing order, and `False` otherwise. An empty linked list is considered sorted by default. Function Signature ```python def is_sorted(head): pass ``` # Input - `head`: The head node of the singly linked list. The node structure is given by ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` # Output - Return `True` if the list is sorted in non-decreasing (increasing or stable) order. - Return `False` otherwise. # Constraints - The number of nodes in the list is in the range [0, 10^5]. - -10^9 <= Node.val <= 10^9 # Detailed Requirements 1. Implement the function strictly using an iterative approach to traverse through the list. 2. The function should handle empty lists. 3. Ensure performance meets the linear time complexity and constant space complexity criteria. # Examples 1. **Example 1:** - Input: `head = [1, 2, 3, 4]` - Output: `True` - Explanation: The list is sorted in increasing order. 2. **Example 2:** - Input: `head = [1, 2, -1, 3]` - Output: `False` - Explanation: The list is not sorted as `2` is followed by `-1`. 3. **Example 3:** - Input: `head = []` - Output: `True` - Explanation: An empty list is considered sorted. 4. **Example 4:** - Input: `head = [1, 1, 1]` - Output: `True` - Explanation: The list contains the same value, so it\'s sorted in non-decreasing order.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head): # An empty list is considered sorted if not head: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"# Question: Implement a Circular Buffer Queue **Scenario**: You are to implement a circular buffer queue using an array with a fixed capacity. Circular buffer queues are an efficient way to utilize memory for queues without the need to resize the underlying array frequently. **Requirements**: - Implement the CircularBufferQueue class inheriting from the AbstractQueue. - Implement the following methods: - `enqueue(value)`: Adds a value to the end of the queue. - `dequeue()`: Removes the value from the front of the queue. - `peek()`: Returns the front value without removing it. - `__iter__`: Iterate through the elements in FIFO order. - `__len__` and `is_empty`: Already implemented in AbstractQueue. **Constraints**: - You should use a fixed-size array. - Handle the circular nature of the queue by wrapping indices appropriately. - Raise `IndexError` when attempting invalid operations on an empty queue. - The maximum capacity of the queue will be specified during initialization. **Input Format**: - You will be given the maximum capacity during class instantiation. - The `enqueue` method takes a single value of any data type. - The `dequeue` and `peek` methods do not take any parameters. **Output Format**: - `enqueue` does not return anything. - `dequeue` returns the value from the front of the queue. - `peek` returns the value from the front without removing it. - `__iter__` yields elements in FIFO order. # Example ```python # Creating a CircularBufferQueue with a capacity of 5 queue = CircularBufferQueue(5) # Enqueueing elements queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) # Peeking the first element print(queue.peek()) # Output: 1 # Dequeueing elements print(queue.dequeue()) # Output: 1 print(queue.dequeue()) # Output: 2 # Checking the size of the queue print(len(queue)) # Output: 1 # Iterating over the queue elements for element in queue: print(element) # Output: 3 ``` Implement the `CircularBufferQueue` class below: ```python class CircularBufferQueue(AbstractQueue): def __init__(self, capacity): super().__init__() self._array = [None] * capacity self._capacity = capacity self._front = 0 self._rear = 0 def __iter__(self): start = self._front for i in range(self._size): yield self._array[(start + i) % self._capacity] def enqueue(self, value): if self._size == self._capacity: raise IndexError(\\"Queue is full\\") self._array[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._array[self._front] ```","solution":"class AbstractQueue: def __init__(self): self._size = 0 def __len__(self): return self._size def is_empty(self): return self._size == 0 class CircularBufferQueue(AbstractQueue): def __init__(self, capacity): super().__init__() self._array = [None] * capacity self._capacity = capacity self._front = 0 self._rear = 0 def __iter__(self): start = self._front for i in range(self._size): yield self._array[(start + i) % self._capacity] def enqueue(self, value): if self._size == self._capacity: raise IndexError(\\"Queue is full\\") self._array[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._array[self._front]"},{"question":"# Scenario: You\'ve been hired by a company to optimize their record keeping system which involves a huge number of insertions and deletions of records. To ensure efficient operations, you decide to use a Red-Black Tree data structure. You\'ve been provided with the base implementation of a Red-Black Tree, including basic insertion, deletion, and balancing functions. # Task: Your task is to implement a `search` function and a function to return a list of all elements at a specific depth (distance from the root) in a given Red-Black Tree. # Function Specifications 1. **search**: - **Input**: An integer `value` to be searched in the tree. - **Output**: Returns the node if the value exists, otherwise returns `None`. 2. **elements_at_depth**: - **Input**: An integer `depth` specifying the distance from the root. - **Output**: A list of node values at the specified depth. # Constraints: - The tree will contain at most 10^5 nodes. - The depth value will always be a non-negative integer and within the maximum depth of the tree. # Example: ```python rb = RBTree() elements = [11, 2, 14, 1, 7, 15, 5, 8, 4] for element in elements: node = RBNode(element, 1) rb.insert(node) # Example usage assert rb.search(7).val == 7 assert rb.search(10) == None assert rb.elements_at_depth(2) == [1, 14] ``` **Note: Implement the `search` method and `elements_at_depth` method inside the `RBTree` class without altering the provided base structure.**","solution":"class RBNode: def __init__(self, val, color): self.val = val self.color = color # 1: Red, 0: Black self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) self.TNULL.left = None self.TNULL.right = None self.root = self.TNULL def insert(self, key): node = RBNode(key, 1) node.left = self.TNULL node.right = self.TNULL node.parent = None y = None x = self.root # Traverse the tree to find the insertion point while x != self.TNULL: y = x if node.val < x.val: x = x.left else: x = x.right node.parent = y if y is None: self.root = node elif node.val < y.val: y.left = node else: y.right = node if node.parent == None: node.color = 0 return if node.parent.parent == None: return self.__fix_insert(node) def __fix_insert(self, k): # Fix the tree pass def _search_tree_helper(self, node, key): if node == self.TNULL or key == node.val: return node if key < node.val: return self._search_tree_helper(node.left, key) return self._search_tree_helper(node.right, key) def search(self, key): Search the tree for a node with a given value. :param key: Value to be searched :return: Node with the key value or None if not found node = self._search_tree_helper(self.root, key) return node if node != self.TNULL else None def _elements_at_depth_helper(self, node, depth, current_depth, result): if node == self.TNULL: return if current_depth == depth: result.append(node.val) else: self._elements_at_depth_helper(node.left, depth, current_depth + 1, result) self._elements_at_depth_helper(node.right, depth, current_depth + 1, result) def elements_at_depth(self, depth): Return a list of all values at a specific depth. :param depth: Integer representing the depth from the root :return: List of node values at the specified depth result = [] self._elements_at_depth_helper(self.root, depth, 0, result) return result"},{"question":"# Combination Sum Problem with Constraints You are given a list of distinct positive integers `nums` and a target integer `target`. Your task is to implement functions to determine the number of possible combinations of elements in `nums` that add up to `target`. Each combination should be considered unique based on its ordering. Requirements 1. Implement two functions: `combination_sum_topdown(nums, target)` and `combination_sum_bottom_up(nums, target)`. 2. The `combination_sum_topdown` function should use a top-down approach with memoization. 3. The `combination_sum_bottom_up` function should use a bottom-up dynamic programming approach. Input and Output * **Input**: - `nums`: List of positive integers with no duplicates. (e.g., [1, 2, 3]) - `target`: Positive integer (e.g., 4) * **Output**: - Integer representing the number of distinct combinations that add up to `target`. Constraints * All elements of `nums` are positive and distinct. * The target is a positive integer. * Consider different sequences (permutations) of the same elements as different combinations. Example ```python nums = [1, 2, 3] target = 4 # Expected Output: 7 # Explanation: # The possible combination ways are: # (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), # (2, 1, 1), (2, 2), (3, 1) ``` # Additional Challenge 1. Discuss what if `nums` contained negative numbers. How does this change the problem? 2. Propose any additional constraints to handle the scenario with negative numbers to prevent infinite combinations.","solution":"def combination_sum_topdown(nums, target): Top-down approach for combination sum with memoization. memo = {} def dfs(remain): if remain == 0: return 1 if remain < 0: return 0 if remain in memo: return memo[remain] total_combinations = 0 for num in nums: total_combinations += dfs(remain - num) memo[remain] = total_combinations return total_combinations return dfs(target) def combination_sum_bottom_up(nums, target): Bottom-up Dynamic Programming approach for combination sum. dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target]"},{"question":"# Question: Implement an Enhanced Heap Sort Algorithm Given an unsorted array `arr`, implement an enhanced version of heap sort. This version should provide stability without using extra memory and maintain an iteration count for each swap operation. # Requirements 1. **Function Name**: `enhanced_heap_sort(arr)` 2. **Input**: * `arr` (List[int]): An unsorted array of integers. 3. **Output**: * Tuple(List[int], int): A tuple containing two elements: * The first element is the sorted array in ascending order. * The second element is the number of iteration/swap operations performed. # Constraints: 1. The sorting should be stable. 2. No extra-memory should be used. 3. You must implement a min heap sort for sorting. # Example: ```python arr = [4, 1, 3, 9, 7] result = enhanced_heap_sort(arr) print(result) # Expected Output: ([1, 3, 4, 7, 9], appropriate iteration count) ``` # Your Task: Implement the function `enhanced_heap_sort(arr)` that adheres to the requirements and constraints provided. Ensure your function handles edge cases effectively.","solution":"def enhanced_heap_sort(arr): def heapify(arr, n, i): count = 0 largest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and arr[largest] < arr[l]: largest = l if r < n and arr[largest] < arr[r]: largest = r if largest != i: arr[i], arr[largest] = arr[largest], arr[i] count += 1 count += heapify(arr, n, largest) return count n = len(arr) swap_count = 0 for i in range(n // 2 - 1, -1, -1): swap_count += heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] swap_count += 1 swap_count += heapify(arr, i, 0) return (arr, swap_count)"},{"question":"# Coding Exercise: Implementing Improved Selection Sort **Problem Statement**: You are provided with an array of integers. Your task is to implement an improved version of selection sort that reduces the number of swaps. Specifically, instead of swapping every time a smaller element is found, it should keep track of the position of the minimum element and swap once at the end of each pass through the array. # Function Signature: ```python def improved_selection_sort(arr: List[int]) -> List[int]: Sorts the array using an improved selection sort algorithm, which minimizes the number of swaps. Parameters: arr (List[int]): A list of integers to sort. Returns: List[int]: A sorted list of integers. ``` # Input: - A list of integers `arr` where ( 1 leq text{len(arr)} leq 1000 ) and the elements of `arr` are in the range `-1000` to `1000`. # Output: - A sorted list of integers using the improved selection sort algorithm. # Constraints: - You may not use any built-in sorting functions. - Your implementation should have a worst-case time complexity of ( O(n^2) ). # Example: ```python assert improved_selection_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64] assert improved_selection_sort([5, 3, 8, 4, 2]) == [2, 3, 4, 5, 8] assert improved_selection_sort([21, 21, 21, 21, 21]) == [21, 21, 21, 21, 21] assert improved_selection_sort([]) == [] assert improved_selection_sort([-1, 2, -8, 4, 0]) == [-8, -1, 0, 2, 4] ``` # Scenario Imagine you have a small RAM memory and you\'ve been given a dataset with up to 1000 integer elements to sort. Performance-wise, it’s not optimal to use algorithms with high space complexity. Despite their quadratic time complexity, improving the traditional algorithm might still be beneficial given the limited space requirement. Implement the `improved_selection_sort` function to handle this type of scenario.","solution":"from typing import List def improved_selection_sort(arr: List[int]) -> List[int]: Sorts the array using an improved selection sort algorithm, which minimizes the number of swaps. Parameters: arr (List[int]): A list of integers to sort. Returns: List[int]: A sorted list of integers. n = len(arr) for i in range(n): min_idx = i for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first element of the unsorted part if min_idx != i: arr[i], arr[min_idx] = arr[min_idx], arr[i] return arr"},{"question":"You are tasked with optimizing the packing of a knapsack to maximize its value. Given a list of items, where each item has a value and a weight, determine the maximum value you can achieve without exceeding the knapsack\'s weight capacity. This follows the classic 0/1 Knapsack Problem. # Function Signature `def get_maximum_value(items: List[Tuple[int, int]], capacity: int) -> int:` # Input - `items`: A list of tuples, where each tuple `(value, weight)` represents the value and the weight of the item. Note that all values and weights are positive integers. - `capacity`: An integer representing the maximum weight capacity of the knapsack (0 ≤ `capacity` ≤ 10^4). # Output - Returns the maximum value that can be achieved within the given knapsack capacity. # Constraints 1. The number of items can be up to 10^3. 2. Ensure your solution runs efficiently with the provided constraints. # Example ```python items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 assert get_maximum_value(items, capacity) == 80 # Explanation: Items with value 50 and 30 can both be fit in the knapsack (3 + 2 <= 5) items = [(10, 1), (40, 3), (30, 2)] capacity = 6 assert get_maximum_value(items, capacity) == 80 # Explanation: Items with value 40, 30 and 10 can all be fit in the knapsack (3 + 2 + 1 <= 6) items = [] capacity = 5 assert get_maximum_value(items, capacity) == 0 # Explanation: No items to choose from, so the maximum value is 0 items = [(100, 10), (200, 20)] capacity = 5 assert get_maximum_value(items, capacity) == 0 # Explanation: No items can be fit within the given capacity ``` # Edge Cases to Consider - No items provided. - Knapsack capacity of zero. - All items have weights greater than the capacity. # Notes 1. Optimize your implementation for both time and space complexity. 2. Do not use any external libraries or packages; only the standard library is allowed.","solution":"from typing import List, Tuple def get_maximum_value(items: List[Tuple[int, int]], capacity: int) -> int: Determine the maximum value achievable within the given knapsack capacity. :param items: List of tuples where each tuple is (value, weight) of an item :param capacity: Maximum weight capacity of the knapsack :return: Maximum value achievable n = len(items) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): value, weight = items[i - 1] for w in range(1, capacity + 1): if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"**Question**: Implement a function named `modified_prims_minimum_spanning` which takes in a graph and a starting node. This function should find and return the weight of the minimum spanning tree using Prim\'s Algorithm. Modify the algorithm to handle non-integer node identifiers and consider performance optimization for sparse graphs. # Input Format: - The function will take two inputs: 1. `graph_used`: A dictionary representing the weighted graph. Keys are nodes and values are lists of two elements, [weight, adjacent]. 2. `start`: A node from where the algorithm starts. # Output Format: - Return an integer which is the weight of the MST. # Constraints: - The graph is connected. - The graph has at most 1000 nodes and edges. - Edge weights are positive integers. # Example: ```python graph = { \'a\': [ [3, \'b\'], [8, \'c\'] ], \'b\': [ [3, \'a\'], [5, \'d\'] ], \'c\': [ [8, \'a\'], [2, \'d\'], [4, \'e\'] ], \'d\': [ [5, \'b\'], [2, \'c\'], [6, \'e\'] ], \'e\': [ [4, \'c\'], [6, \'d\'] ] } start = \'a\' assert modified_prims_minimum_spanning(graph, start) == 14 ``` # Detailed Explanation: 1. Start with the node `start` and initialize the MST and priority queue. 2. At each step, add the smallest edge connecting MST to a new node. 3. Continue until all nodes are in the MST. 4. Return the total weight of the MST. Implement the function by ensuring efficiency, considering the key operations of priority queue management and handling typical edge cases.","solution":"import heapq def modified_prims_minimum_spanning(graph_used, start): Returns the weight of the Minimum Spanning Tree (MST) using a modified Prim\'s algorithm that handles non-integer node identifiers and optimizes performance for sparse graphs. mst_set = set() min_heap = [] total_weight = 0 def add_edges(node): Adds all edges from the given node to the priority queue. for weight, adj in graph_used.get(node, []): if adj not in mst_set: heapq.heappush(min_heap, (weight, adj)) # Start with the initial node mst_set.add(start) add_edges(start) while min_heap and len(mst_set) < len(graph_used): weight, node = heapq.heappop(min_heap) if node not in mst_set: mst_set.add(node) total_weight += weight add_edges(node) if len(mst_set) == len(graph_used): return total_weight else: return float(\'inf\') # Graph is not connected"},{"question":"# Longest Common Prefix Problem You have been given an array of strings, and your task is to find the longest common prefix string amongst these strings. If there is no common prefix, the function should return an empty string \\"\\". You are required to implement the solution using the **Vertical Scanning** method. Function Signature: ```python def longest_common_prefix(strings: List[str]) -> str: ``` Input: - `strings`: A list of strings. Constraints: - The list can have up to `2 * 10^4` strings. - Each string may be up to `200` characters long. - Strings consist of lowercase English letters. Output: - A single string that represents the longest common prefix. Examples: Example 1: ```python strings = [\\"flower\\", \\"flow\\", \\"flight\\"] assert longest_common_prefix(strings) == \\"fl\\" ``` Example 2: ```python strings = [\\"dog\\", \\"racecar\\", \\"car\\"] assert longest_common_prefix(strings) == \\"\\" ``` Example 3: ```python strings = [\\"interspecies\\", \\"interstellar\\", \\"interstate\\"] assert longest_common_prefix(strings) == \\"inters\\" ``` Example 4: ```python strings = [\\"throne\\", \\"throne\\"] assert longest_common_prefix(strings) == \\"throne\\" ``` Example 5: ```python strings = [] assert longest_common_prefix(strings) == \\"\\" ``` **Constraints**: - Do not use any additional space for another data structure. Notes: - You must use the Vertical Scanning method. - Your solution should handle edge cases efficiently. - The function should return quickly for large input sizes (adhering to the time complexity).","solution":"from typing import List def longest_common_prefix(strings: List[str]) -> str: if not strings: return \\"\\" # Start with the full length of the first string for i in range(len(strings[0])): char = strings[0][i] for string in strings[1:]: if i >= len(string) or string[i] != char: return strings[0][:i] return strings[0]"},{"question":"# Nearest Neighbor Optimization Challenge You are given a dataset represented as a dictionary where keys are tuples (representing vectors in a multi-dimensional space), and values are labels corresponding to those points. Implement an optimized version of the nearest neighbor search algorithm to handle large datasets more efficiently. Function Signature: ```python def optimized_nearest_neighbor(x: tuple, tSet: dict) -> Any: pass ``` Input * `x`: A tuple of integers/floats representing the query vector. * `tSet`: A dictionary where keys are tuples representing vectors, and values are their corresponding labels. Output * Return the label of the nearest neighbors\' point in the training set. Constraints * The length of `x` and keys in `tSet` will range between 1 and 1000. * The number of entries in `tSet` will range between 1 and 100,000. * All components in vectors are guaranteed to be numeric (integers or floats). Performance Requirements Your solution should be efficient enough to handle up to 100,000 vectors in the training set. Consider optimizing algorithm performance using efficient data structures or preprocessing techniques. Example ```python training_set = { (1, 2, 3): \'A\', (2, 3, 4): \'B\', (0, 1, 2): \'C\', (4, 5, 6): \'D\' } x = (1, 2, 1) print(optimized_nearest_neighbor(x, training_set)) # Expected output: \'C\' ``` **Note**: You need to find an efficient way to determine the nearest neighbor. Use any suitable optimization techniques or data structures to ensure your solution is scalable.","solution":"import heapq from typing import Any, Dict, Tuple def optimized_nearest_neighbor(x: Tuple[float, ...], tSet: Dict[Tuple[float, ...], Any]) -> Any: Given a query vector `x`, return the label of the nearest neighbor from the `tSet`. Args: - x: tuple of floats representing the query vector. - tSet: dictionary where keys are tuples representing vectors, and values are labels. Returns: - The label of the nearest neighbor\'s point in the training set. if not tSet: return None def euclidean_distance(vec1, vec2): return sum((v1 - v2) ** 2 for v1, v2 in zip(vec1, vec2)) ** 0.5 # Priority queue to store the closest points min_heap = [] for point, label in tSet.items(): dist = euclidean_distance(x, point) heapq.heappush(min_heap, (dist, label)) # The nearest neighbor will be at the root of the heap return min_heap[0][1]"},{"question":"# Problem: Word Dictionary with Trie Given a WordDictionary class, your task is to implement it using a Trie structure with add_word and search methods. The Trie should allow adding words and searching with support for exact matches or pattern searches with the \\".\\" wildcard representing any letter. Functions to be Implemented: * `add_word(word: str) -> None`: Adds a word to the WordDictionary. * `search(word: str) -> bool`: Returns True if there exists any string in the dictionary that matches the given word (including support for \\".\\" wildcard). Example ```python # Add words wordDictionary = WordDictionary() wordDictionary.add_word(\\"bad\\") wordDictionary.add_word(\\"dad\\") wordDictionary.add_word(\\"mad\\") # Search words print(wordDictionary.search(\\"pad\\")) # Should return False print(wordDictionary.search(\\"bad\\")) # Should return True print(wordDictionary.search(\\".ad\\")) # Should return True print(wordDictionary.search(\\"b..\\")) # Should return True ``` Constraints * Words are composed of lowercase English letters. * Avoid excessive memory usage. * Handle edge cases such as empty string, words with multiple wildcards. Requirements * The implementation should emphasize efficiency in both time and space. * Manage wildcard searches effectively and ensure correctness. * Ensure code readability and follow best practices in coding. Good luck!","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class WordDictionary: def __init__(self): Initialize your data structure here. self.root = TrieNode() def add_word(self, word: str) -> None: Adds a word into the data structure. current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.end_of_word = True def search(self, word: str) -> bool: Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter. return self._search_in_node(word, self.root) def _search_in_node(self, word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if self._search_in_node(word[i+1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.end_of_word"},{"question":"# Scenario You are a software engineer tasked with optimizing the internal systems for a financial app. The app requires a sorting function to efficiently handle and sort large datasets of floating point numbers representing financial metrics. The team has chosen to use Bucket Sort for its properties with uniformly distributed data. # Task Implement the `bucket_sort_optimized` function, which sorts a given list of floating point numbers using the Bucket Sort algorithm. Pay careful attention to optimizing time complexity with appropriate distribution of elements into buckets and the choice of sorting algorithm within each bucket. # Function Signature ```python def bucket_sort_optimized(arr: List[float]) -> List[float]: pass ``` # Input * A list `arr` containing n floating point numbers where 0 ≤ arr[i] < 1. # Output * A list of n floating point numbers sorted in non-decreasing order. # Constraints 1. The input list `arr` will have length 0 ≤ len(arr) ≤ 10^5. 2. Each element in `arr` is a floating point number within the inclusive range `[0, 1)`. # Requirements 1. The algorithm should handle edge cases like an empty list or a list with identical elements. 2. Optimize the function to run as efficiently as possible given the constraints. # Example ```python assert bucket_sort_optimized([0.23, 0.12, 0.75, 0.34, 0.51]) == [0.12, 0.23, 0.34, 0.51, 0.75] assert bucket_sort_optimized([0.9, 0.8, 0.7, 0.6, 0.5]) == [0.5, 0.6, 0.7, 0.8, 0.9] assert bucket_sort_optimized([]) == [] assert bucket_sort_optimized([0.3, 0.3, 0.3]) == [0.3, 0.3, 0.3] ```","solution":"from typing import List def bucket_sort_optimized(arr: List[float]) -> List[float]: if not arr: return arr n = len(arr) buckets = [[] for _ in range(n)] for num in arr: index = int(num * n) buckets[index].append(num) sorted_array = [] for bucket in buckets: sorted_array.extend(sorted(bucket)) return sorted_array"},{"question":"# Scenario: You are given a task to develop a mathematical module to support matrix operations in a scientific computing application. One of the critical operations is matrix multiplication, which is fundamental to various calculations in the application. # Objective: Implement a function `matrix_multiply` that takes two matrices as input and computes their product. Ensure the function handles potential edge cases and is optimized for performance. # Function Signature: ```python def matrix_multiply(multiplicand: list, multiplier: list) -> list: :param multiplicand: List[List[int]], a 2D list representing the first matrix :param multiplier: List[List[int]], a 2D list representing the second matrix :return: List[List[int]], a 2D list representing the product of the matrices pass ``` # Input Format: * `multiplicand`: A list of n lists, each containing m integers, representing an n x m matrix. * `multiplier`: A list of p lists, each containing q integers, representing a p x q matrix. # Output Format: * A list of n lists, each containing q integers, representing the resultant product matrix of dimensions n x q. # Constraints: * 1 ≤ n, m, p, q ≤ 100 * Ensure that the number of columns in `multiplicand` (m) is equal to the number of rows in `multiplier` (p). # Performance Requirements: * Consider space optimization where possible since the resultant matrix must fit within the allocated space. * Handle exceptions gracefully with appropriate error messages. # Example: Example 1: ```python multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] result = matrix_multiply(multiplicand, multiplier) # Result should be: # [ # [58, 64], # [139, 154] # ] ``` Example 2: ```python multiplicand = [ [2, 4], [3, 4] ] multiplier = [ [1, 2], [1, 3] ] result = matrix_multiply(multiplicand, multiplier) # Result should be: # [ # [6, 16], # [7, 18] # ] ``` # Evaluation Criteria: * Correctness of the implementation. * Handling of edge cases and exceptions. * Code efficiency and readability. * Proper use of function signatures and type annotations.","solution":"def matrix_multiply(multiplicand: list, multiplier: list) -> list: Multiplies two matrices (lists of lists). :param multiplicand: List[List[int]], a 2D list representing the first matrix :param multiplier: List[List[int]], a 2D list representing the second matrix :return: List[List[int]], a 2D list representing the product of the matrices if not multiplicand or not multiplier: raise ValueError(\\"Matrices should not be empty\\") num_rows_multiplicand = len(multiplicand) num_cols_multiplicand = len(multiplicand[0]) num_rows_multiplier = len(multiplier) num_cols_multiplier = len(multiplier[0]) if num_cols_multiplicand != num_rows_multiplier: raise ValueError(\\"Number of columns in the first matrix must be equal to the number of rows in the second matrix\\") # Initialize the result matrix with zeros result = [[0 for _ in range(num_cols_multiplier)] for _ in range(num_rows_multiplicand)] # Perform matrix multiplication for i in range(num_rows_multiplicand): for j in range(num_cols_multiplier): for k in range(num_cols_multiplicand): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Question: Compute The Trimmed Mean You are provided with a list of numerical values representing the scores in a competition. However, to ensure fairness, the mean score should not be influenced by outliers. To achieve this, you need to compute the trimmed mean by removing a certain percentage of the highest and lowest scores before calculating the mean. Function Signature ```python def trimmed_mean(scores: List[float], trim_percent: float) -> float: ``` Input - `scores`: A list of floating-point numbers (0 <= len(scores) <= 10^6) representing the scores. - `trim_percent`: A floating-point number (0 <= trim_percent < 100) representing the total percentage of scores to be trimmed from both ends. For example, if `trim_percent` is 20%, then 10% from the lowest and 10% from the highest scores will be removed. Output - Returns a floating-point number representing the trimmed mean of the remaining scores after removing the specified percentage of extreme values. Constraints - The function should handle edge cases where there are not enough scores to trim. - Always round the result to 2 decimal places. Example ```python assert trimmed_mean([10, 20, 15, 25, 30, 35, 5], 20) == 20.00 assert trimmed_mean([1, 2, 3, 4, 5], 40) == 3.00 assert trimmed_mean([1, 1, 1, 1, 1], 30) == 1.00 assert trimmed_mean([100, 200, 300, 400, 500], 10) == 300.00 ``` Explanation 1. In the first example, with 20% trimming, the lowest 10% and highest 10% values are removed. The remaining scores are [10, 15, 20, 25], and their average is 17.5, rounded to 2 decimal places is 20.00. 2. In the second example, 40% of values are to be trimmed, the 20% lowest and 20% highest values are removed. The remaining value is [3]. 3. In the third example, since all values are the same, trimming any percentage wouldn\'t change the mean. 4. In the fourth example, 10% trimming results in removing the lowest and highest values, [200, 300, 400] is left and their mean is 300. Implement the `trimmed_mean` function to compute the trimmed mean as specified.","solution":"from typing import List def trimmed_mean(scores: List[float], trim_percent: float) -> float: if not scores: return 0.0 n = len(scores) trim_count = int(n * (trim_percent / 100) / 2) if trim_count == 0: return round(sum(scores) / n, 2) trimmed_scores = sorted(scores)[trim_count:-trim_count] if not trimmed_scores: return 0.0 return round(sum(trimmed_scores) / len(trimmed_scores), 2)"},{"question":"You are given an array of integers and a series of operations to perform on it. Your task is to implement the `SegmentTree` class that supports sum, maximum, and minimum range queries efficiently along with point updates. # Key Functions: 1. **`__init__(self, arr, function)`**: Initialize the segment tree with an array `arr` and a commutative function `function`. 2. **`update(self, index, value)`**: Update the element at `index` in the array to `value`. 3. **`query(self, left, right)`**: Query the function result over the range `[left, right]` inclusive. # Input and Output: ```python # Input: # A list of integers and a query type among [\'sum\', \'max\', \'min\'] # Example operations: # seg_tree = SegmentTree([4, 5, 2, 3, 4, 43, 3], \'sum\') # seg_tree.query(0, 5) # seg_tree.update(3, 6) # seg_tree.query(1, 4) # # Output: # Should print the result of range query using the specified function ``` # Constraints: - 1 ≤ len(arr) ≤ 10^5 - -10^9 ≤ arr[i] ≤ 10^9 - Function type will be one of [\'sum\', \'max\', \'min\'] - All queries and updates are valid (within bounds). # Example: ```python arr = [1, 3, 5, 7, 9, 11] seg_tree = SegmentTree(arr, \'sum\') print(seg_tree.query(1, 3)) # Output: 15 (3 + 5 + 7) seg_tree.update(1, 10) print(seg_tree.query(1, 3)) # Output: 22 (10 + 5 + 7) ``` **Implement the `SegmentTree` class according to the specification.**","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.function = function self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr): for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self._merge(self.tree[i * 2], self.tree[i * 2 + 1]) def _merge(self, left, right): if self.function == \'sum\': return left + right elif self.function == \'max\': return max(left, right) elif self.function == \'min\': return min(left, right) else: raise ValueError(\\"Unsupported function type\\") def update(self, index, value): pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self._merge(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, left, right): left += self.n right += self.n result = None while left <= right: if left % 2 == 1: result = self._merge(result, self.tree[left]) if result is not None else self.tree[left] left += 1 if right % 2 == 0: result = self._merge(result, self.tree[right]) if result is not None else self.tree[right] right -= 1 left //= 2 right //= 2 return result"},{"question":"# Question: Next Bigger Number with Same Digits Given an integer, find the next higher number that contains the same digits. If no such number exists, return -1. Your solution should be efficient and handle large inputs gracefully. Implement the function `next_bigger(num: int) -> int`. Input * `num`: A positive integer. (1 ≤ num ≤ 10^9) Output * An integer that is the next permutation larger than `num` which uses the exact same digits, or -1 if no such permutation exists. # Constraints * The function should have a time complexity of O(n), where n is the number of digits in the input number. * The function should not use extra space beyond O(n). # Example ```python def next_bigger(num: int) -> int: digits = [int(i) for i in str(num)] idx = len(digits) - 1 while idx >= 1 and digits[idx-1] >= digits[idx]: idx -= 1 if idx == 0: return -1 # no such number exists pivot = digits[idx-1] swap_idx = len(digits) - 1 while pivot >= digits[swap_idx]: swap_idx -= 1 digits[swap_idx], digits[idx-1] = digits[idx-1], digits[swap_idx] digits[idx:] = digits[:idx-1:-1] # prefer slicing instead of reversed(digits[idx:]) return int(\'\'.join(str(x) for x in digits)) # Test and validate print(next_bigger(38276)) # Output: 38627 print(next_bigger(12345)) # Output: 12354 print(next_bigger(99999)) # Output: -1 ``` # Notes: - Your implementation will be tested against several cases, including edge cases with repeated digits and the maximum allowed input size. - Ensure the function does not fail for special cases such as numbers containing all identical digits or already the highest permutation.","solution":"def next_bigger(num: int) -> int: digits = [int(d) for d in str(num)] n = len(digits) # Step 1: Find the rightmost digit that is smaller than the digit next to it. for i in range(n-2, -1, -1): if digits[i] < digits[i + 1]: break else: # If no such digit is found, that means we are already at the largest permutation return -1 # Step 2: Find the smallest digit on right side of (i) which is larger than digits[i] for j in range(n-1, i, -1): if digits[j] > digits[i]: break # Step 3: Swap digits[i] and digits[j] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits after index i digits = digits[:i+1] + digits[i+1:][::-1] return int(\'\'.join(map(str, digits)))"},{"question":"# Unique Paths in a Grid You are implementing a function to calculate the number of unique paths in an (m times n) grid. You start from the top-left cell (0,0) and can only move either to the right or down at any point in time until you reach the bottom-right cell (m-1, n-1). Write a function `count_paths(m, n)` that computes this number of unique paths. # Function Signature ```python def count_paths(m: int, n: int) -> int: ``` # Input - `m` (1 ≤ m ≤ 100): An integer representing the number of rows in the grid. - `n` (1 ≤ n ≤ 100): An integer representing the number of columns in the grid. # Output - Return the number of unique paths from the top-left to the bottom-right of the grid. # Constraints - The function should handle up to 10,000 cells with given constraints efficiently. - Ensure edge cases such as `m` or `n` being 1 are handled correctly. # Example Inputs and Outputs 1. **Example 1:** - Input: `m = 3, n = 7` - Output: `28` 2. **Example 2:** - Input: `m = 5, n = 5` - Output: `70` 3. **Example 3:** - Input: `m = 1, n = 5` - Output: `1` 4. **Example 4:** - Input: `m = 3, n = 3` - Output: `6` # Scenario You are working on a robotics project where you need to determine how many different ways a robot can move from the starting point to the destination in a grid-based layout factory. Each movement can only be either to the right or down, ensuring that the robot reaches all required stations optimally.","solution":"def count_paths(m: int, n: int) -> int: Returns the number of unique paths in an m x n grid. # Create a 2D array to store the number of paths to each cell dp = [[1] * n for _ in range(m)] # Iterate over the grid starting from (1, 1) for i in range(1, m): for j in range(1, n): # Number of ways to reach dp[i][j] is the sum of the ways to reach dp[i-1][j] and dp[i][j-1] dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Priority Queue Implementation and Usage **Background**: A priority queue allows you to store elements along with their priority levels and ensures that elements with higher priority are accessed first. It’s a vital data structure for various applications such as CPU scheduling, Dijkstra\'s algorithm for shortest path, and managing resources in simulations. You are given an incomplete implementation of a priority queue using a linear array (list). Your task is to complete the implementation and further extend its functionality. # Task: Part 1: Complete the Priority Queue Finish implementing the `PriorityQueue` class by completing the missing methods: 1. **peek()**: Should return the data of the item with the lowest priority without removing it from the queue. 2. **update_priority(item, new_priority)**: Should update the priority of a given item and reposition it in the queue according to its new priority. Part 2: Use the Priority Queue Using the `PriorityQueue` class, implement a function `schedule_tasks(tasks, priorities)` which takes a list of tasks and their corresponding list of priorities, inserts them into the priority queue, and returns a list of tasks in the order they should be executed (from highest priority to lowest). # Input: - The function `schedule_tasks(tasks, priorities)` receives two lists: * `tasks`: A list of tasks to be scheduled (0 < len(tasks) <= 1000). * `priorities`: A list of integers representing the priorities (same length as tasks, values can be positive or negative). # Output: - Return a list of tasks sorted by their priority (highest priority first). # Constraints: - The priorities are integers and can include negative, zero, and positive values. - The same priority value can appear more than once. - Each task is unique. # Implementation Across Multiple Files: - This code should work even if the class definition and the task scheduling function are in different files. # Expected Function Signature: You should implement two parts: 1. **In Priority Queue class**: ```python class PriorityQueue: ... def peek(self): # Your code here def update_priority(self, item, new_priority): # Your code here ``` 2. **Function to Schedule Tasks**: ```python def schedule_tasks(tasks, priorities): # Your code here ``` # Example: ```python # Example usage tasks = [\\"Task1\\", \\"Task2\\", \\"Task3\\"] priorities = [5, 2, 8] # Calls your function scheduled_tasks = schedule_tasks(tasks, priorities) print(scheduled_tasks) # Expected: [\'Task3\', \'Task1\', \'Task2\'] ```","solution":"from typing import List class PriorityQueue: def __init__(self): self.queue = [] def is_empty(self): return len(self.queue) == 0 def insert(self, item, priority): self.queue.append((item, priority)) self.queue.sort(key=lambda x: x[1]) # sort by priority def pop(self): if not self.is_empty(): return self.queue.pop(0) else: raise IndexError(\\"pop from empty priority queue\\") def peek(self): if not self.is_empty(): return self.queue[0] else: raise IndexError(\\"peek from empty priority queue\\") def update_priority(self, item, new_priority): for index, (queued_item, priority) in enumerate(self.queue): if queued_item == item: self.queue[index] = (item, new_priority) self.queue.sort(key=lambda x: x[1]) # re-sort by priority return raise ValueError(f\\"Item {item} not found in the priority queue\\") # Function to schedule tasks def schedule_tasks(tasks: List[str], priorities: List[int]) -> List[str]: pq = PriorityQueue() for task, priority in zip(tasks, priorities): pq.insert(task, priority) scheduled_tasks = [] while not pq.is_empty(): task, priority = pq.pop() scheduled_tasks.append(task) return scheduled_tasks"},{"question":"# Question: You are given a set of distinct integers. Your task is to write a function that returns all possible subsets (the power set) of the given set. The solution should not contain duplicate subsets. Implement the function in two different ways: 1. Using recursive backtracking. 2. Using an iterative approach. # Function Signature: ```python def generate_subsets_recursive(nums: List[int]) -> List[List[int]]: pass def generate_subsets_iterative(nums: List[int]) -> List[List[int]]: pass ``` # Input: * `nums`: A list of distinct integers with up to 20 elements (e.g., `[1, 2, 3]`). # Output: * A list of lists containing all possible subsets of the given set. The order of the subsets does not matter. # Constraints: * The input list `nums` contains distinct integers. * Each number in `nums` is unique. * The solution should not contain duplicate subsets. # Example: ```python nums = [1, 2, 3] generate_subsets_recursive(nums) # Possible Output: # [ # [3], # [1], # [2], # [1,2,3], # [1,3], # [2,3], # [1,2], # [] # ] generate_subsets_iterative(nums) # Possible Output: # [ # [3], # [1], # [2], # [1,2,3], # [1,3], # [2,3], # [1,2], # [] # ] ```","solution":"from typing import List def generate_subsets_recursive(nums: List[int]) -> List[List[int]]: def backtrack(start=0, path=[]): result.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) result = [] backtrack() return result def generate_subsets_iterative(nums: List[int]) -> List[List[int]]: result = [[]] for num in nums: result += [curr + [num] for curr in result] return result"},{"question":"# Problem Context You are given a large series formed by concatenating all positive integers in ascending order: \\"1234567891011121314...\\". Your task is to determine the digit positioned at the nth place in this sequence. # Challenge Write a function that efficiently determines the nth digit in this theoretically infinite concatenated series. # Function Signature ```python def find_nth_digit(n: int) -> int: Given an integer n, return the digit at the nth position in the concatenated series of all positive integers. Args: n (int): The position in the concatenated sequence (1-indexed). Returns: int: The digit at the nth position. ``` # Input Constraints - `1 ≤ n ≤ 2 * 10^9` (n is a positive integer) # Expected Output - Return a single digit (0-9) that corresponds to the nth position in the concatenated series of numbers. # Example ```python print(find_nth_digit(3)) # Output: 3 print(find_nth_digit(11)) # Output: 0 print(find_nth_digit(15)) # Output: 2 ``` # Special Notes - Keep in mind edge cases such as the transition between numbers with differing digit lengths. - Consider the efficiency for large values of `n`. - Ensure your solution handles input within the constraints effectively.","solution":"def find_nth_digit(n: int) -> int: Given an integer n, return the digit at the nth position in the concatenated series of all positive integers. Args: n (int): The position in the concatenated sequence (1-indexed). Returns: int: The digit at the nth position. # The length of the number segments (1-digit, 2-digit, 3-digit, etc.) length = 1 count = 9 # Number of integers for the current length start = 1 # Starting number for the current length while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Determine the exact number that contains the desired digit num = start + (n - 1) // length # Determine the position of the desired digit within that number digit_index = (n - 1) % length return int(str(num)[digit_index])"},{"question":"Task Implement a new version of a queue, named `OptimizedArrayQueue`, that uses a circular buffer to avoid the overhead of shifting elements when dequeuing, and improves the efficiency of the array expansion. # Requirements * **enqueue(item)**: Adds a new item to the rear of the queue. * **dequeue()**: Removes the front item from the queue and returns it. * **peek()**: Returns the front item without removing it. * **isEmpty()**: Checks if the queue has no elements. * **size()**: Returns the number of items in the queue. # Constraints * You cannot use any external collections (like deque) from Python’s standard library. * Initial capacity of the queue should be 10. * If the queue is full upon enqueue, the size should double. # Implementation Details * Use a circular buffer to manage the queue internally. * When the internal array needs to expand, ensure that all elements maintain their correct order. # Input/Output Examples ```python q = OptimizedArrayQueue() q.enqueue(1) q.enqueue(2) q.enqueue(3) assert q.size() == 3 assert q.peek() == 1 assert q.dequeue() == 1 assert q.size() == 2 assert not q.isEmpty() q.enqueue(4) assert q.dequeue() == 2 assert q.dequeue() == 3 assert q.dequeue() == 4 assert q.isEmpty() ``` Implement the `OptimizedArrayQueue` class in Python. ```python class OptimizedArrayQueue: def __init__(self, capacity=10): # Initialize the queue with the specified capacity pass def enqueue(self, item): # Add item to the queue pass def dequeue(self): # Remove and return the front item from the queue pass def peek(self): # Return the front item without removing it pass def isEmpty(self): # Check if the queue is empty pass def size(self): # Return the number of items in the queue pass def _expand(self): # Expand the capacity of the array used internally in the queue pass ``` You need to define the internal mechanisms for managing the circular buffer, handling edge cases, expanding the queue size appropriately, and ensuring all read and write operations maintain the expected FIFO order.","solution":"class OptimizedArrayQueue: def __init__(self, capacity=10): # Initialize the queue with the specified capacity self._capacity = capacity self._data = [None] * capacity self._size = 0 self._front = 0 self._rear = -1 def enqueue(self, item): # Add item to the queue if self._size == self._capacity: self._expand() self._rear = (self._rear + 1) % self._capacity self._data[self._rear] = item self._size += 1 def dequeue(self): # Remove and return the front item from the queue if self.isEmpty(): raise IndexError(\\"dequeue from empty queue\\") item = self._data[self._front] self._data[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return item def peek(self): # Return the front item without removing it if self.isEmpty(): raise IndexError(\\"peek from empty queue\\") return self._data[self._front] def isEmpty(self): # Check if the queue is empty return self._size == 0 def size(self): # Return the number of items in the queue return self._size def _expand(self): # Expand the capacity of the array used internally in the queue new_capacity = self._capacity * 2 new_data = [None] * new_capacity for i in range(self._size): new_data[i] = self._data[(self._front + i) % self._capacity] self._data = new_data self._capacity = new_capacity self._front = 0 self._rear = self._size - 1"},{"question":"**Problem Statement**: You are tasked with designing a more robust function to judge if a robot\'s movement sequence makes a circle. The robot starts at position (0, 0) on a 2D plane and can move in four possible directions: Right (\'R\'), Left (\'L\'), Up (\'U\'), and Down (\'D\'). The function should analyze the move sequence represented as a string and determine if the moves return the robot to the original position. Additionally, you need to handle invalid moves by ignoring them and consider case insensitivity for the moves. **Function Signature**: ```python def judge_circle(moves: str) -> bool: ``` **Input**: - `moves`: a string containing the sequence of moves the robot makes. **Output**: - Return `True` if the robot returns to the original position (0, 0), otherwise return `False`. **Constraints**: - The input string may contain any characters. Assume only \'R\', \'L\', \'U\', \'D\' (case-insensitive) are valid moves; ignore non-valid characters. **Examples**: 1. `judge_circle(\\"UD\\")` should return `True`. 2. `judge_circle(\\"LL\\")` should return `False`. 3. `judge_circle(\\"RRDDLLUU\\")` should return `True`. 4. `judge_circle(\\"UDLR PP\\")` should return `True` as it ignores invalid characters. **Instructions**: Implement the function with appropriate error handling and efficient processing for potentially long move sequences. Ensure to ignore any invalid characters and treat all valid moves in a case-insensitive manner.","solution":"def judge_circle(moves: str) -> bool: Determines if the sequence of moves returns the robot to the original position. :param moves: A string depicting the move sequence of the robot. :return: True if the robot returns to the original position, False otherwise. x, y = 0, 0 move_dict = { \'R\': (1, 0), \'L\': (-1, 0), \'U\': (0, 1), \'D\': (0, -1) } for move in moves.upper(): if move in move_dict: dx, dy = move_dict[move] x += dx y += dy return x == 0 and y == 0"},{"question":"# Matrix Exponentiation in an Optimized Iterative Approach You are provided with functions for matrix multiplication, identity matrix creation, and matrix exponentiation using recursion. Your task is to re-implement the `matrix_exponentiation` function iteratively to avoid potential stack overflow issues with deep recursion. Function Signature ```python def iterative_matrix_exponentiation(mat: list, n: int) -> list: Calculates mat^n by repeated squaring using an iterative approach. :param mat: A square matrix represented as a list of lists. :param n: A non-negative integer representing the power to which the matrix will be raised. :return: A list of lists representing the matrix raised to the power n. pass ``` # Input * `mat` is a two-dimensional list representing an `d x d` square matrix. * `n` is an integer where `0 <= n`. # Output * Returns a two-dimensional list representing the matrix raised to the power `n`. # Constraints * The dimension `d` of the matrix `mat` will not exceed `10`. * The value of `n` will not exceed `10^9`. * Consider performance implications due to the high possible value of `n`. # Examples 1. ```python iterative_matrix_exponentiation([[1, 1], [1, 0]], 5) # Output: [[8, 5], [5, 3]] ``` 2. ```python iterative_matrix_exponentiation([[2, 0], [0, 2]], 3) # Output: [[8, 0], [0, 8]] ``` # Explanation * For the first example, the matrix exponentiation result is based on the Fibonacci recurrence relation. * In the second example, the matrix is a diagonal matrix, and raising it to a power results in its diagonal elements raised to that power.","solution":"def matrix_multiply(A, B): d = len(A) result = [[0] * d for _ in range(d)] for i in range(d): for j in range(d): for k in range(d): result[i][j] += A[i][k] * B[k][j] return result def identity_matrix(size): I = [[0 if i != j else 1 for j in range(size)] for i in range(size)] return I def iterative_matrix_exponentiation(mat, n): if n == 0: return identity_matrix(len(mat)) result = identity_matrix(len(mat)) base = mat while n > 0: if n % 2 == 1: result = matrix_multiply(result, base) base = matrix_multiply(base, base) n //= 2 return result"},{"question":"**Balanced Binary Tree Check** You are given a binary tree and need to determine if it is height-balanced. A binary tree is balanced if the depth of the two subtrees of every node never differs by more than 1. **Function Signature:** ```python def is_balanced(root: TreeNode) -> bool: ``` **Input:** - `root` (TreeNode): The root node of a binary tree. **Output:** - `bool`: Returns True if the tree is height-balanced, otherwise False. **Constraints:** - The number of nodes in the tree is in the range [0, 10^4]. - The values of the nodes are arbitrary. **Example:** 1. Input: ```python 3 / 9 20 / 15 7 ``` Output: `True` 2. Input: ```python 1 / 2 2 / 3 3 / 4 4 ``` Output: `False` **Scenario:** You are working on a project that requires maintaining a balanced binary search tree for efficient data operations. To ensure the tree stays balanced after multiple insertions and deletions, you need to implement a function to verify the balance status of the tree. Combine the insights from the analysis to write a function `is_balanced(root: TreeNode) -> bool` that checks whether a given binary tree is balanced. **Hints:** - You\'ll need to recursively check the depth of each subtree. - Utilize the helper functions to manage depth calculations and balance checks efficiently.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Determine whether a binary tree is height-balanced. A binary tree is balanced if the depth of the two subtrees of every node never differs by more than 1. def check_balance_and_depth(node): # Base case: An empty node is balanced with a depth of 0 if not node: return (True, 0) # Check the left subtree left_balanced, left_depth = check_balance_and_depth(node.left) # Check the right subtree right_balanced, right_depth = check_balance_and_depth(node.right) # Is current node balanced? Check both subtrees\' balance and depth difference balanced = left_balanced and right_balanced and abs(left_depth - right_depth) <= 1 # The depth of the current node is max of left/right depths plus 1 depth = max(left_depth, right_depth) + 1 return (balanced, depth) # Only the balance status is needed for the final output return check_balance_and_depth(root)[0]"},{"question":"# Binary Tree Balance Check A balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one. You are tasked with writing a function that checks if a given binary tree is balanced. Implement the function `is_balanced(root)` which takes the root node of a binary tree as input and returns a boolean value indicating whether the binary tree is balanced. Function Signature ```python def is_balanced(root): ``` # Input * `root`: The root node of a binary tree (either an integer or None for an empty tree). # Output * Return `True` if the binary tree is balanced, otherwise return `False`. # Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * The tree node values are unique integers. # Examples Example 1 ```python Input: 1 / 2 3 Output: True ``` Example 2 ```python Input: 1 / 2 / 3 Output: False ``` Example 3 ```python Input: None Output: True ``` # Notes - Your solution should be optimized to run with a time complexity of O(N). - You should account for edge cases, such as an empty tree and very unbalanced trees. - Base your solution on the depth analysis approach to ensure efficiency.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Returns True if the binary tree is balanced, False otherwise. def check_balance_and_height(node): if not node: return (True, 0) left_balanced, left_height = check_balance_and_height(node.left) right_balanced, right_height = check_balance_and_height(node.right) balanced = (left_balanced and right_balanced and abs(left_height - right_height) <= 1) height = max(left_height, right_height) + 1 return (balanced, height) return check_balance_and_height(root)[0]"},{"question":"on Diffie-Hellman Key Exchange # Objective Your task is to implement a validated variation of the Diffie-Hellman Key Exchange algorithm. You need to ensure that the inputs, particularly the prime number and its primitive root, are valid and lead to a successful key exchange. # Function to Implement Implement the function `secure_diffie_hellman_key_exchange(a: int, p: int) -> bool`. Input * `a` (int): A candidate primitive root. * `p` (int): A large candidate prime number. Output * `bool`: - `True` if the Diffie-Hellman Key Exchange is successful. - `False` if the inputs are invalid or the key exchange fails. Constraints * ( 2 leq a < p leq 10^6 ) * Ensure ( p ) is prime. * Ensure ( a ) is a primitive root of ( p ) using the provided functions. # Requirements * Validate `p` using the `prime_check` function. * Verify that `a` is a primitive root of `p` using the `find_primitive_root` function. * Perform the Diffie-Hellman Key Exchange to compute shared keys and check if they match. * Use the provided supporting functions for the implementation details. # Example ```python # Example 1 secure_diffie_hellman_key_exchange(2, 5) # Output: True # Example 2 secure_diffie_hellman_key_exchange(4, 15) # Output: False, as 15 is not a prime number ``` # Scenario Imagine you are securing a communication channel between two servers using the Diffie-Hellman Key Exchange. Both servers need to agree on a shared secret key to encrypt their messages securely. Implement and validate this secure key exchange ensuring you use only valid inputs (a large prime ( p ) and its primitive root ( a )).","solution":"from math import isqrt def is_prime(p): Check if a number p is a prime number. if p <= 1: return False if p <= 3: return True if p % 2 == 0 or p % 3 == 0: return False i = 5 while i * i <= p: if p % i == 0 or p % (i + 2) == 0: return False i += 6 return True def gcd(a, b): Compute the greatest common divisor of a and b. while b: a, b = b, a % b return a def power_mod(base, exp, mod): Efficiently compute (base ** exp) % mod. result = 1 base = base % mod while exp > 0: if (exp % 2) == 1: result = (result * base) % mod exp = exp >> 1 base = (base * base) % mod return result def find_primitive_root(p): Find a primitive root for prime p if one exists. if not is_prime(p): return None p_minus_1 = p - 1 factors = set() n = p_minus_1 for i in range(2, isqrt(p_minus_1) + 1): while n % i == 0: factors.add(i) n //= i if n > 1: factors.add(n) def is_primitive_root(a): return all(power_mod(a, p_minus_1 // factor, p) != 1 for factor in factors) for a in range(2, p): if is_primitive_root(a): return a return None def secure_diffie_hellman_key_exchange(a, p): if not is_prime(p): return False if find_primitive_root(p) != a: return False # Alice\'s private key private_key_a = 6 # Bob\'s private key private_key_b = 15 # Alice computes her public value public_value_a = power_mod(a, private_key_a, p) # Bob computes his public value public_value_b = power_mod(a, private_key_b, p) # Alice computes the shared secret using Bob\'s public value shared_secret_a = power_mod(public_value_b, private_key_a, p) # Bob computes the shared secret using Alice\'s public value shared_secret_b = power_mod(public_value_a, private_key_b, p) # They both should have the same shared secret return shared_secret_a == shared_secret_b"},{"question":"# Problem Context You are working on a system that processes event logs. The logs are represented as integer timestamps in a list and they are sorted in ascending order. Two events are considered to be consecutive if their timestamps differ by exactly one. Your task is to summarize these consecutive timestamps into ranges. # Function Signature ```python def summarize_ranges(array: List[int]) -> List[str]: ``` # Input - A sorted list of integers without duplicates, representing timestamps: `array` (1 ≤ len(array) ≤ 10^4). # Output - A list of strings where consecutive integers are summarized in the form \\"start-end\\". Single integers are represented as \\"start\\". # Example ```python # Example 1 array = [0, 1, 2, 4, 5, 7] # Expected Output: [\\"0-2\\", \\"4-5\\", \\"7\\"] # Example 2 array = [3, 4, 6, 8, 9, 10] # Expected Output: [\\"3-4\\", \\"6\\", \\"8-10\\"] # Example 3 array = [1] # Expected Output: [\\"1\\"] ``` # Constraints - The input array is guaranteed to be sorted in ascending order and contain no duplicate values. - Minimum length of array is 1. # Problem Description Write a function `summarize_ranges` that takes a sorted list of unique integers and returns a list of strings summarizing the ranges of consecutive numbers. The output format should be \\"start-end\\" for ranges or simply \\"start\\" for single numbers. # Scoring Criteria - Correctness: Ensure that all edge cases and examples are covered. - Efficiency: Your solution should handle the input size efficiently within the given constraints. - Code quality: Maintain readability and clarity in your implementation, including appropriate comments.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] result = [] start = array[0] end = array[0] for i in range(1, len(array)): if array[i] == end + 1: end = array[i] else: if start == end: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{end}\\") start = array[i] end = array[i] if start == end: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{end}\\") return result"}]'),O={name:"App",components:{PoemCard:N},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},L={class:"card-container"},z={key:0,class:"empty-state"},F=["disabled"],R={key:0},j={key:1};function Y(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),y(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[_,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",L,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",z,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",j,"Loading...")):(n(),i("span",R,"See more"))],8,F)):u("",!0)])}const P=c(O,[["render",Y],["__scopeId","data-v-80858a68"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/53.md","filePath":"drive/53.md"}'),D={name:"drive/53.md"},U=Object.assign(D,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,U as default};
