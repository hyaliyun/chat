import{_,o as s,c as r,a as t,m as c,t as d,C as p,M as g,U as b,f as l,F as x,p as y,e as w,q as v}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},A={class:"review-content"};function R(n,e,u,m,i,a){return s(),r("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",A,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(u.poem.solution),1)])])])}const N=_(q,[["render",R],["__scopeId","data-v-999afc86"]]),C=JSON.parse(`[{"question":"from typing import List def can_reach_last_tank(tanks: List[int]) -> bool: Determine if you can reach the last tank given a list of fuel in different tanks. You start at the first tank and want to reach the last tank. Each tank can be used to jump to another tank that is at most a certain number of positions away, based on the amount of fuel in the current tank. Examples: >>> can_reach_last_tank([2, 3, 1, 1, 4]) True >>> can_reach_last_tank([3, 2, 1, 0, 4]) False def test_can_reach_last_tank(): assert can_reach_last_tank([2, 3, 1, 1, 4]) == True assert can_reach_last_tank([3, 2, 1, 0, 4]) == False assert can_reach_last_tank([0]) == True assert can_reach_last_tank([2, 0, 0, 0, 0]) == False assert can_reach_last_tank([1, 1, 1, 1, 1]) == True assert can_reach_last_tank([5, 0, 0, 0, 0]) == True","solution":"from typing import List def can_reach_last_tank(tanks: List[int]) -> bool: max_reach = 0 n = len(tanks) for i in range(n): if i > max_reach: return False max_reach = max(max_reach, i + tanks[i]) if max_reach >= n - 1: return True return False"},{"question":"from typing import List def diagonalOrder(matrix: List[List[int]]) -> List[int]: Returns the diagonals of a matrix in a zigzag order. >>> diagonalOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [1, 2, 4, 7, 5, 3, 6, 8, 9] >>> diagonalOrder([[1, 2], [3, 4], [5, 6]]) [1, 2, 3, 5, 4, 6] >>> diagonalOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) [1, 2, 5, 9, 6, 3, 4, 7, 10, 11, 8, 12] >>> diagonalOrder([[5, 6], [7, 8]]) [5, 6, 7, 8] >>> diagonalOrder([[1]]) [1]","solution":"from typing import List def diagonalOrder(matrix: List[List[int]]) -> List[int]: if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) result = [] for d in range(rows + cols - 1): if d % 2 == 0: # Collect upward diagonal (bottom to top) r = min(d, rows - 1) c = d - r while r >= 0 and c < cols: result.append(matrix[r][c]) r -= 1 c += 1 else: # Collect downward diagonal (top to bottom) c = min(d, cols - 1) r = d - c while c >= 0 and r < rows: result.append(matrix[r][c]) r += 1 c -= 1 return result"},{"question":"def can_form_word(grid: List[List[str]], word: str) -> bool: Determine if the word can be formed by consecutively adjacent cells in the grid. >>> can_form_word([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E']], \\"ABCCED\\") True >>> can_form_word([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E']], \\"SEE\\") True >>> can_form_word([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E']], \\"ABCB\\") False","solution":"def can_form_word(grid, word): if not grid or not word: return False rows, cols = len(grid), len(grid[0]) def dfs(r, c, index): if index == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != word[index]: return False temp = grid[r][c] grid[r][c] = '#' found = (dfs(r+1, c, index+1) or dfs(r, c+1, index+1) or dfs(r-1, c, index+1) or dfs(r, c-1, index+1)) grid[r][c] = temp return found for row in range(rows): for col in range(cols): if dfs(row, col, 0): return True return False # Example use case grid = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ] word1 = \\"ABCCED\\" word2 = \\"SEE\\" word3 = \\"ABCB\\" print(can_form_word(grid, word1)) # Output: True print(can_form_word(grid, word2)) # Output: True print(can_form_word(grid, word3)) # Output: False"},{"question":"def min_unattractiveness(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Returns the minimum unattractiveness for each test case. :param T: Integer, the number of test cases. :param test_cases: List of tuples, where each tuple contains: - N, M: Integers, dimensions of the grid. - colors: List of integers, the colors on tiles in the bag. :return: List of integers, the minimum unattractiveness for each test case. >>> T = 2 >>> test_cases = [(2, 2, [1, 2, 3, 4]), (3, 3, [7, 9, 8, 6, 1, 3, 4, 2, 5])] >>> min_unattractiveness(T, test_cases) [1, 1]","solution":"def min_unattractiveness(T, test_cases): Returns the minimum unattractiveness for each test case. :param T: Integer, the number of test cases. :param test_cases: List of tuples, where each tuple contains: - N, M: Integers, dimensions of the grid. - colors: List of integers, the colors on tiles in the bag. :return: List of integers, the minimum unattractiveness for each test case. results = [] for test in test_cases: N, M, colors = test colors.sort() # In sorted order, the minimum difference between any two adjacent tiles is minimized. min_diff = float('inf') for i in range(1, len(colors)): min_diff = min(min_diff, abs(colors[i] - colors[i-1])) results.append(min_diff) return results"},{"question":"def game_result(s: str, tom: List[int], jerry: List[int]) -> str: Determine the winner between Tom and Jerry based on the lexicographic comparison of strings formed by the given indices from a string of digits. >>> game_result(\\"58213\\", [1, 3, 0], [4, 2, 1]) == 'Tom wins' >>> game_result(\\"12345\\", [0, 2, 4], [1, 3, 0]) == 'Jerry wins' >>> game_result(\\"987654\\", [0, 1, 2], [0, 1, 2]) == 'It's a tie' >>> game_result(\\"11111\\", [0, 1, 2], [3, 4, 1]) == 'It's a tie' >>> game_result(\\"3498712\\", [0, 2], [1, 4, 6]) == 'Jerry wins' >>> game_result(\\"12345\\", [], []) == 'It's a tie' >>> game_result(\\"12345\\", [0], []) == 'Tom wins' >>> game_result(\\"12345\\", [], [0]) == 'Jerry wins'","solution":"def game_result(s, tom, jerry): tom_string = ''.join(s[i] for i in tom) jerry_string = ''.join(s[i] for i in jerry) if tom_string > jerry_string: return 'Tom wins' elif tom_string < jerry_string: return 'Jerry wins' else: return 'It's a tie'"},{"question":"from typing import List, Tuple def solve(T: int, test_cases: List[Tuple[int, List[int], List[Tuple[int, int]]]]) -> List[List[int]]: Computes the maximum power level for each animal's subtree in a magical forest. Args: T : int : number of test cases test_cases : List[Tuple[int, List[int], List[Tuple[int, int]]]] : List of test cases where each test case contains: - An integer N representing the number of mystical animals. - A list of N integers representing the power levels of the mystical animals. - A list of N-1 tuples representing the parent-child relationships. Returns: List[List[int]] : A list containing the results for each test case. Each result is a list of N integers where the ith integer is the maximum power level in the subtree of the ith animal. Test cases: >>> solve(1, [(5, [10, 5, 6, 7, 15], [(1, 2), (1, 3), (3, 4), (3, 5)])]) [[15, 5, 15, 7, 15]] >>> solve(1, [(1, [10], [])]) [[10]] >>> solve(1, [(2, [10, 20], [(1, 2)])]) [[20, 20]] >>> solve(2, [(3, [5, 10, 20], [(1, 2), (1, 3)]), (4, [15, 5, 8, 3], [(1, 2), (2, 3), (2, 4)])]) [[20, 10, 20], [15, 8, 8, 3]] >>> solve(1, [(6, [1, 2, 3, 4, 5, 6], [(1, 2), (2, 3), (2, 4), (1, 5), (5, 6)])]) [[6, 4, 3, 4, 6, 6]] # Your implementation here","solution":"def calculate_max_power_subtree(N, power_levels, tree_edges): from collections import defaultdict, deque # Build the tree tree = defaultdict(list) in_degree = [0] * (N + 1) for u, v in tree_edges: tree[u].append(v) in_degree[v] += 1 # Find the root (King of the forest), which has no parents root = next(x for x in range(1, N + 1) if in_degree[x] == 0) # Function to perform DFS and compute maximum power levels def dfs(node): max_power = power_levels[node - 1] for child in tree[node]: max_power = max(max_power, dfs(child)) max_powers[node - 1] = max_power return max_powers[node - 1] # Array to store the maximum power level in subtree of each animal max_powers = [0] * N dfs(root) return max_powers def solve(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] power_levels = test_cases[i][1] tree_edges = test_cases[i][2] result = calculate_max_power_subtree(N, power_levels, tree_edges) results.append(result) return results"},{"question":"def filter_suspects(crime_timestamp: str, suspects: List[Dict[str, Union[int, List[str]]]]) -> List[int]: Filters out suspects who have a matching alibi for the crime timestamp. :param crime_timestamp: The timestamp of the crime in \\"YYYY-MM-DD HH:MM:SS\\" format. :param suspects: A list of dictionaries where each dictionary has two keys: \\"id\\" (int) and \\"alibis\\" (list of strings with timestamps). :return: A list of suspect IDs who have at least one alibi matching the crime_timestamp. >>> crime_timestamp = \\"2023-09-15 18:30:00\\" >>> suspects = [ ... {\\"id\\": 1, \\"alibis\\": [\\"2023-09-15 18:30:00\\", \\"2023-09-16 20:00:00\\"]}, ... {\\"id\\": 2, \\"alibis\\": [\\"2023-09-14 08:00:00\\"]}, ... {\\"id\\": 3, \\"alibis\\": [\\"2023-09-15 17:30:00\\", \\"2023-09-16 18:30:00\\"]} ... ] >>> filter_suspects(crime_timestamp, suspects) [1] >>> crim3_timestamp = \\"2023-09-15 18:30:00\\" >>> suspects = [ ... {\\"id\\": 1, \\"alibis\\": [\\"2023-09-14 18:30:00\\", \\"2023-09-16 20:00:00\\"]}, ... {\\"id\\": 2, \\"alibis\\": [\\"2023-09-14 08:00:00\\"]}, ... {\\"id\\": 3, \\"alibis\\": [\\"2023-09-15 17:30:00\\", \\"2023-09-16 18:30:00\\"]} ... ] >>> filter_suspects(crime_timestamp, suspects) [] >>> crim3_timestamp = \\"2023-09-15 18:30:00\\" >>> suspects = [] >>> filter_suspects(crime_timestamp, suspects) [] >>> crim3_timestamp = \\"2023-09-15 18:30:00\\" >>> suspects = [ ... {\\"id\\": 1, \\"alibis\\": []}, ... {\\"id\\": 2, \\"alibis\\": []} ... ] >>> filter_suspects(crime_timestamp, suspects) []","solution":"def filter_suspects(crime_timestamp, suspects): Filters out suspects who have a matching alibi for the crime timestamp. :param crime_timestamp: The timestamp of the crime in \\"YYYY-MM-DD HH:MM:SS\\" format. :param suspects: A list of dictionaries where each dictionary has two keys: \\"id\\" (int) and \\"alibis\\" (list of strings with timestamps). :return: A list of suspect IDs who have at least one alibi matching the crime_timestamp. matching_suspects = [] for suspect in suspects: if crime_timestamp in suspect['alibis']: matching_suspects.append(suspect['id']) return matching_suspects"},{"question":"class NumMatrix: Initialize the 2D matrix and handle multiple queries of update and sumRegion. Args: matrix (List[List[int]]): 2D array of integers Methods: update(row: int, col: int, val: int) -> None: Updates the element at position (row, col) to val. sumRegion(row1: int, col1: int, row2: int, col2: int) -> int: Calculates the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). def __init__(self, matrix: List[List[int]]): pass def update(self, row: int, col: int, val: int) -> None: pass def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int: pass def test_sumRegion_initial(): matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] num_matrix = NumMatrix(matrix) assert num_matrix.sumRegion(2, 1, 4, 3) == 8 assert num_matrix.sumRegion(1, 1, 2, 2) == 11 assert num_matrix.sumRegion(1, 2, 2, 4) == 12 def test_update_and_sumRegion(): matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] num_matrix = NumMatrix(matrix) assert num_matrix.sumRegion(2, 1, 4, 3) == 8 num_matrix.update(3, 2, 2) assert num_matrix.sumRegion(2, 1, 4, 3) == 10 def test_update_and_sumRegion_edge(): matrix = [ [1] ] num_matrix = NumMatrix(matrix) assert num_matrix.sumRegion(0, 0, 0, 0) == 1 num_matrix.update(0, 0, -1) assert num_matrix.sumRegion(0, 0, 0, 0) == -1","solution":"class NumMatrix: def __init__(self, matrix): if not matrix or not matrix[0]: return self.matrix = matrix self.rows, self.cols = len(matrix), len(matrix[0]) self.tree = [[0] * (self.cols + 1) for _ in range(self.rows + 1)] self.nums = [[0] * self.cols for _ in range(self.rows)] for r in range(self.rows): for c in range(self.cols): self.update(r, c, matrix[r][c]) def update(self, row, col, val): if not self.matrix: return delta = val - self.nums[row][col] self.nums[row][col] = val r, c = row + 1, col + 1 while r <= self.rows: while c <= self.cols: self.tree[r][c] += delta c += c & -c r += r & -r c = col + 1 # reset c for the next iteration of r def sumRegion(self, row1, col1, row2, col2): if not self.matrix: return 0 return (self._sum(row2 + 1, col2 + 1) - self._sum(row1, col2 + 1) - self._sum(row2 + 1, col1) + self._sum(row1, col1)) def _sum(self, row, col): total = 0 r, c = row, col while r > 0: while c > 0: total += self.tree[r][c] c -= c & -c r -= r & -r c = col # reset c for the next iteration of r return total"},{"question":"def longest_increasing_sequence_length(temperatures): Returns the length of the longest increasing sequence of temperatures. >>> longest_increasing_sequence_length([30, 31, 32, 28, 29, 30, 31]) == 4 >>> longest_increasing_sequence_length([25, 27, 30, 29, 30, 31]) == 3 >>> longest_increasing_sequence_length([-5, -4, -3, -2, -1, 0, 1]) == 7 >>> longest_increasing_sequence_length([1, 2, 3, 1, 2, 3, 4, 5]) == 5 >>> longest_increasing_sequence_length([10]) == 1 >>> longest_increasing_sequence_length([1, 1, 1, 1, 1, 1]) == 1 >>> longest_increasing_sequence_length([]) == 0 >>> longest_increasing_sequence_length([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10 def process_test_cases(test_cases): Processes multiple test cases of temperature readings. >>> process_test_cases([[30, 31, 32, 28, 29, 30, 31], [25, 27, 30, 29, 30, 31], [-5, -4, -3, -2, -1, 0, 1]]) == [4, 3, 7] >>> process_test_cases([[1, 2], [1, 1], [10]]) == [2, 1, 1] >>> process_test_cases([[1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [10, 20, 30, 40]]) == [5, 1, 4] >>> process_test_cases([[]]) == [0]","solution":"def longest_increasing_sequence_length(temperatures): Returns the length of the longest increasing sequence of temperatures. if not temperatures: return 0 max_length = 1 current_length = 1 for i in range(1, len(temperatures)): if temperatures[i] > temperatures[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length def process_test_cases(test_cases): results = [] for temperatures in test_cases: results.append(longest_increasing_sequence_length(temperatures)) return results"},{"question":"from typing import List def can_split_into_k_primes(N: int, K: int, A: List[int]) -> str: Determine if it's possible to split the array into exactly K non-empty continuous subarrays such that the sum of each subarray is a prime number. Args: N (int): Length of array A. K (int): Number of subarrays. A (List[int]): List of integers representing the array. Returns: str: \\"YES\\" if possible, \\"NO\\" otherwise. Examples: >>> can_split_into_k_primes(5, 3, [3, 7, 1, 2, 11]) 'YES' >>> can_split_into_k_primes(5, 2, [4, 6, 2, 5, 9]) 'NO' pass def test_example_1(): assert can_split_into_k_primes(5, 3, [3, 7, 1, 2, 11]) == \\"YES\\" def test_example_2(): assert can_split_into_k_primes(5, 2, [4, 6, 2, 5, 9]) == \\"NO\\" def test_single_element_prime(): assert can_split_into_k_primes(1, 1, [2]) == \\"YES\\" def test_single_element_not_prime(): assert can_split_into_k_primes(1, 1, [4]) == \\"NO\\" def test_no_possible_split(): assert can_split_into_k_primes(6, 2, [10, 10, 15, 15, 20, 25]) == \\"NO\\" def test_large_array_all_primes(): assert can_split_into_k_primes(10, 3, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]) == \\"YES\\" def test_large_array_no_primes(): assert can_split_into_k_primes(10, 3, [4, 6, 8, 9, 10, 12, 14, 15, 16, 18]) == \\"NO\\"","solution":"def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def can_split_into_k_primes(N, K, A): # Helper function to compute prefix sums def prefix_sums(arr): p_sum = [0] * (len(arr) + 1) for i in range(1, len(arr) + 1): p_sum[i] = p_sum[i - 1] + arr[i - 1] return p_sum p_sum = prefix_sums(A) # Memoization array dp = [[False] * (N + 1) for _ in range(K + 1)] dp[0][0] = True for k in range(1, K + 1): for i in range(1, N + 1): for j in range(i): if dp[k - 1][j] and is_prime(p_sum[i] - p_sum[j]): dp[k][i] = True break return \\"YES\\" if dp[K][N] else \\"NO\\" def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) K = int(data[1]) A = list(map(int, data[2:])) print(can_split_into_k_primes(N, K, A)) if __name__ == \\"__main__\\": main()"},{"question":"def rescale_numbers(numbers, new_min, new_max): Rescale the list of numbers to a new range [new_min, new_max]. Parameters: - numbers (list of int or float): List of numbers to rescale. - new_min (int or float): New minimum value in the range. - new_max (int or float): New maximum value in the range. Returns: - list of int or float: Rescaled list of numbers. Examples: >>> rescale_numbers([10, 20, 30, 40, 50], 0, 1) [0.0, 0.25, 0.5, 0.75, 1.0] >>> rescale_numbers([-1, 0, 1], 0, 10) [0, 5, 10]","solution":"def rescale_numbers(numbers, new_min, new_max): Rescale the list of numbers to a new range [new_min, new_max]. Parameters: - numbers (list of int or float): List of numbers to rescale. - new_min (int or float): New minimum value in the range. - new_max (int or float): New maximum value in the range. Returns: - list of int or float: Rescaled list of numbers. if not numbers: return numbers old_min = min(numbers) old_max = max(numbers) if old_min == old_max: midpoint = (new_min + new_max) / 2 return [midpoint] * len(numbers) def rescale(x): return new_min + (new_max - new_min) * (x - old_min) / (old_max - old_min) return [rescale(x) for x in numbers]"},{"question":"from typing import List def verify_password(password: str) -> bool: This function verifies if the provided password meets the specified security company requirements: 1. Must be at least 8 characters long. 2. Must contain at least one uppercase letter. 3. Must contain at least one lowercase letter. 4. Must contain at least one digit. 5. Must contain at least one special character from the set \`!@#%^&*()-_+=\`. Args: password (str): The password string to be verified. Returns: bool: True if the password meets all requirements, False otherwise. pass def test_valid_password(): assert verify_password(\\"Password123!\\") == True assert verify_password(\\"P@ssword1\\") == True def test_password_too_short(): assert verify_password(\\"Pass1!\\") == False def test_missing_uppercase(): assert verify_password(\\"password123!\\") == False def test_missing_lowercase(): assert verify_password(\\"PASSWORD123!\\") == False def test_missing_digit(): assert verify_password(\\"Password!\\") == False def test_missing_special(): assert verify_password(\\"Password123\\") == False def test_edge_case_min_length(): assert verify_password(\\"P@ssw123\\") == True assert verify_password(\\"P@ssw1234\\") == True def test_all_requirements_missing(): assert verify_password(\\"abcdefgh\\") == False assert verify_password(\\"ABCDEFGH\\") == False assert verify_password(\\"12345678\\") == False assert verify_password(\\"!@#%^&*\\") == False def test_only_special_chars(): assert verify_password(\\"!@#%^&*()\\") == False def test_special_chars_edge_cases(): assert verify_password(\\"A1b!@#%^&*()-_+XYZ\\") == True","solution":"def verify_password(password): This function verifies if the provided password meets the specified security company requirements: 1. Must be at least 8 characters long. 2. Must contain at least one uppercase letter. 3. Must contain at least one lowercase letter. 4. Must contain at least one digit. 5. Must contain at least one special character from the set \`!@#%^&*()-_+=\`. Args: password (str): The password string to be verified. Returns: bool: True if the password meets all requirements, False otherwise. if len(password) < 8: return False has_upper = any(char.isupper() for char in password) has_lower = any(char.islower() for char in password) has_digit = any(char.isdigit() for char in password) has_special = any(char in \\"!@#%^&*()-_+=\\" for char in password) return has_upper and has_lower and has_digit and has_special"},{"question":"import heapq from typing import List, Tuple def shortest_paths(T: int, testcases: List[Tuple[int, int, int, List[Tuple[int, int, int]]]]) -> List[str]: Calculate the shortest path from the starting warehouse to every other warehouse. Args: T (int): Number of testcases. testcases (List[Tuple[int, int, int, List[Tuple[int, int, int]]]]): List containing testcases. Returns: List[str]: Shortest travel times from the starting warehouse to all other warehouses. Examples: >>> shortest_paths(2, [(4, 4, 1, [(1, 2, 4), (1, 3, 2), (2, 3, 3), (3, 4, 1)]), (3, 3, 2, [(1, 2, 2), (1, 3, 2), (2, 3, 1)])]) [\\"0 4 2 3\\", \\"2 0 1\\"] pass def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, int, int, List[Tuple[int, int, int]]]]]: Parse input string and return the test cases. Args: input_str (str): Input string containing the test cases. Returns: Tuple: Parsed number of test cases and the list of test cases. Examples: >>> parse_input(\\"1n4 4n1n1 2 4n1 3 2n2 3 3n3 4 1n\\") (1, [(4, 4, 1, [(1, 2, 4), (1, 3, 2), (2, 3, 3), (3, 4, 1)])]) pass def main(input_str: str) -> str: Main function to execute the shortest_paths function and produce output. Args: input_str (str): Input string containing the test cases. Returns: str: Results for all test cases as output string. Examples: >>> main(\\"2n4 4n1n1 2 4n1 3 2n2 3 3n3 4 1n3 3n2n1 2 2n1 3 2n2 3 1n\\") \\"0 4 2 3n2 0 1\\" pass def test_shortest_paths_single_case(): input_str = \\"1n4 4n1n1 2 4n1 3 2n2 3 3n3 4 1\\" expected_output = \\"0 4 2 3\\" assert main(input_str) == expected_output def test_shortest_paths_multiple_cases(): input_str = \\"2n4 4n1n1 2 4n1 3 2n2 3 3n3 4 1n3 3n2n1 2 2n1 3 2n2 3 1\\" expected_output = \\"0 4 2 3n2 0 1\\" assert main(input_str) == expected_output def test_unreachable_nodes(): input_str = \\"1n4 2n1n1 2 4n2 3 3\\" expected_output = \\"0 4 7 -1\\" assert main(input_str) == expected_output def test_no_edges(): input_str = \\"1n4 0n1\\" expected_output = \\"0 -1 -1 -1\\" assert main(input_str) == expected_output def test_self_loops(): input_str = \\"1n3 3n1n1 1 2n2 2 1n3 3 1\\" expected_output = \\"0 -1 -1\\" assert main(input_str) == expected_output","solution":"import heapq def shortest_paths(T, testcases): # Helper function to perform Dijkstra's algorithm def dijkstra(N, edges, start): graph = [[] for _ in range(N)] for u, v, w in edges: graph[u-1].append((w, v-1)) graph[v-1].append((w, u-1)) dist = [float('inf')] * N dist[start-1] = 0 min_heap = [(0, start-1)] while min_heap: current_dist, u = heapq.heappop(min_heap) if current_dist > dist[u]: continue for weight, v in graph[u]: if current_dist + weight < dist[v]: dist[v] = current_dist + weight heapq.heappush(min_heap, (dist[v], v)) return [-1 if d == float('inf') else d for d in dist] results = [] for testcase in testcases: N, M, S, edges = testcase result = dijkstra(N, edges, S) results.append(' '.join(map(str, result))) return results def parse_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) index = 1 testcases = [] for _ in range(T): N, M = map(int, input_lines[index].split()) S = int(input_lines[index + 1]) edges = [] for j in range(M): U, V, W = map(int, input_lines[index + 2 + j].split()) edges.append((U, V, W)) testcases.append((N, M, S, edges)) index += 2 + M return T, testcases def main(input_str): T, testcases = parse_input(input_str) results = shortest_paths(T, testcases) return 'n'.join(results)"},{"question":"def max_consecutive_ones(n: int) -> int: Returns the length of the longest consecutive sequence of ones in the binary representation of a given positive integer n. >>> max_consecutive_ones(15) == 4 >>> max_consecutive_ones(13) == 2 >>> max_consecutive_ones(1) == 1 >>> max_consecutive_ones(0) == 0 >>> max_consecutive_ones(255) == 8 >>> max_consecutive_ones(1023) == 10 >>> max_consecutive_ones(1022) == 9 >>> max_consecutive_ones(170) == 1","solution":"def max_consecutive_ones(n: int) -> int: Returns the length of the longest consecutive sequence of ones in the binary representation of a given positive integer n. binary_representation = bin(n)[2:] max_ones = 0 current_ones = 0 for digit in binary_representation: if digit == '1': current_ones += 1 max_ones = max(max_ones, current_ones) else: current_ones = 0 return max_ones"},{"question":"from typing import List def min_cost_path(matrix: List[List[int]]) -> int: Given a matrix of integers where each element represents the cost associated with visiting that cell, find the minimum cost path from the top-left cell to the bottom-right cell. You are allowed to move either right or down from any cell in the matrix. >>> min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 >>> min_cost_path([[1, 2, 3, 4, 5]]) 15 >>> min_cost_path([[1], [2], [3], [4], [5]]) 15 >>> min_cost_path([[42]]) 42 >>> min_cost_path([]) 0 pass","solution":"from typing import List def min_cost_path(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) # Initialize a 2D list to store the minimum costs dp = [[0 for _ in range(cols)] for _ in range(rows)] # Set the cost of the starting point dp[0][0] = matrix[0][0] # Fill in the minimum costs for the first row for j in range(1, cols): dp[0][j] = dp[0][j - 1] + matrix[0][j] # Fill in the minimum costs for the first column for i in range(1, rows): dp[i][0] = dp[i - 1][0] + matrix[i][0] # Fill in the remaining cells for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j] return dp[rows - 1][cols - 1]"},{"question":"from typing import List, Tuple def animal_sightings(sightings: List[str], n: int) -> Tuple[int, List[Tuple[str, int]]]: Returns the number of unique animals sighted and the top n most frequently sighted animals with their counts. >>> animal_sightings([\\"elephant\\", \\"tiger\\", \\"elephant\\", \\"deer\\", \\"monkey\\", \\"tiger\\", \\"tiger\\", \\"elephant\\"], 2) (4, [(\\"elephant\\", 3), (\\"tiger\\", 3)]) >>> animal_sightings([\\"lion\\", \\"cheetah\\", \\"leopard\\", \\"lion\\", \\"leopard\\", \\"leopard\\"], 3) (3, [(\\"leopard\\", 3), (\\"lion\\", 2), (\\"cheetah\\", 1)]) >>> animal_sightings([\\"elephant\\"], 1) (1, [(\\"elephant\\", 1)]) >>> animal_sightings([\\"elephant\\", \\"tiger\\", \\"deer\\"], 2) (3, [(\\"deer\\", 1), (\\"elephant\\", 1)]) >>> animal_sightings([\\"elephant\\", \\"tiger\\", \\"deer\\", \\"tiger\\", \\"elephant\\"], 2) (3, [(\\"elephant\\", 2), (\\"tiger\\", 2)])","solution":"from collections import Counter def animal_sightings(sightings, n): Returns the number of unique animals sighted and the top n most frequently sighted animals with their counts. count_dict = Counter(sightings) unique_animal_count = len(count_dict) # Get the most common n animals, sorted lexicographically in case of ties most_common_sorted = sorted(count_dict.items(), key=lambda x: (-x[1], x[0])) return unique_animal_count, most_common_sorted[:n]"},{"question":"def max_operations(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determines the maximum number of consecutive operations starting from the first operation for each test case. >>> max_operations(1, [(5, 9, [4, 3, 2, 6, 5])]) [4] >>> max_operations(1, [(3, 5, [3, 3, 3])]) [1] >>> max_operations(2, [(5, 10, [1, 2, 3, 4, 5]), (4, 4, [1, 3, 3, 1])]) [5, 2] >>> max_operations(1, [(6, 7, [1, 2, 3, 1, 2, 3])]) [6] >>> max_operations(1, [(4, 9, [10, 10, 10, 10])]) [1]","solution":"def max_operations(T, test_cases): results = [] for t in range(T): N, X = test_cases[t][:2] difficulties = test_cases[t][2] max_ops = 1 current_ops = 1 for i in range(1, N): if difficulties[i] + difficulties[i-1] <= X: current_ops += 1 max_ops = max(max_ops, current_ops) else: break results.append(max_ops) return results"},{"question":"def movie_rental_system(commands: List[str], N: int, M: int) -> List[str]: Process the list of commands and return the results of the 'query' commands. Args: commands (list): List of strings representing the operations. N (int): Number of operations. M (int): Number of movies. Returns: list: List of results for 'query' commands. pass # Unit Tests def test_movie_rental_system(): commands = [ \\"rent 1\\", \\"rent 2\\", \\"query 1\\", \\"return 1\\", \\"query 1\\", \\"query 2\\", \\"query 3\\" ] N = 7 M = 5 expected = [ \\"Rented\\", \\"Available\\", \\"Rented\\", \\"Available\\" ] assert movie_rental_system(commands, N, M) == expected def test_movie_rental_system_all_available(): commands = [ \\"query 1\\", \\"query 2\\", \\"query 3\\", \\"query 4\\", \\"query 5\\" ] N = 5 M = 5 expected = [ \\"Available\\", \\"Available\\", \\"Available\\", \\"Available\\", \\"Available\\" ] assert movie_rental_system(commands, N, M) == expected def test_movie_rental_system_rent_and_return(): commands = [ \\"rent 1\\", \\"rent 2\\", \\"query 1\\", \\"query 2\\", \\"return 1\\", \\"return 2\\", \\"query 1\\", \\"query 2\\" ] N = 8 M = 5 expected = [ \\"Rented\\", \\"Rented\\", \\"Available\\", \\"Available\\" ] assert movie_rental_system(commands, N, M) == expected def test_movie_rental_system_edge_cases(): commands = [ \\"return 1\\", \\"return 2\\", \\"rent 3\\", \\"query 3\\", \\"query 1\\", \\"query 2\\", \\"rent 1\\", \\"query 1\\" ] N = 8 M = 3 expected = [ \\"Rented\\", \\"Available\\", \\"Available\\", \\"Rented\\" ] assert movie_rental_system(commands, N, M) == expected","solution":"def movie_rental_system(commands, N, M): Process the list of commands and return the results of the 'query' commands. Args: commands (list): List of strings representing the operations. N (int): Number of operations. M (int): Number of movies. Returns: list: List of results for 'query' commands. movies = [True] * (M + 1) # A list to track the availability of each movie, index 0 is unused results = [] for command in commands: parts = command.split() action = parts[0] movie_id = int(parts[1]) if action == \\"rent\\": movies[movie_id] = False elif action == \\"return\\": movies[movie_id] = True elif action == \\"query\\": if movies[movie_id]: results.append(\\"Available\\") else: results.append(\\"Rented\\") return results"},{"question":"from typing import List, Dict def get_top_student(students: List[Dict[str, List[int]]]) -> str: Returns the name of the student with the highest average grade. Parameters: students (list): A list of dictionaries, where each dictionary contains the keys 'name' (string) and 'grades' (list of integers). Returns: str: The name of the student with the highest average grade. >>> students = [ ... {\\"name\\": \\"Alice\\", \\"grades\\": [88, 90, 92]}, ... {\\"name\\": \\"Bob\\", \\"grades\\": [75, 85, 89]}, ... {\\"name\\": \\"Charlie\\", \\"grades\\": [95, 97, 99]} ... ] >>> get_top_student(students) 'Charlie' >>> students = [ ... {\\"name\\": \\"Alice\\", \\"grades\\": [0, 0, 0]}, ... {\\"name\\": \\"Bob\\", \\"grades\\": [0, 0, 0]} ... ] >>> get_top_student(students) 'Alice' >>> get_top_student([]) None # Your code here pass","solution":"def get_top_student(students): Returns the name of the student with the highest average grade. Parameters: students (list): A list of dictionaries, where each dictionary contains the keys 'name' (string) and 'grades' (list of integers). Returns: str: The name of the student with the highest average grade. if not students: return None def average(grades): return sum(grades) / len(grades) if grades else 0 top_student = max(students, key=lambda student: average(student['grades'])) return top_student['name']"},{"question":"def findMissingLetter(pattern: str) -> str: Returns the missing letter in the given pattern. Args: pattern (str): a non-empty string containing lowercase alphabetical letters, missing exactly one letter. Returns: str: a single lowercase letter which is missing from the pattern. Examples: >>> findMissingLetter(\\"abdefg\\") 'c' >>> findMissingLetter(\\"acdfghi\\") 'b' alphabet = \\"abcdefghijklmnopqrstuvwxyz\\" for letter in alphabet: if letter not in pattern: return letter","solution":"def findMissingLetter(pattern: str) -> str: Returns the missing letter in the given pattern. alphabet = \\"abcdefghijklmnopqrstuvwxyz\\" for letter in alphabet: if letter not in pattern: return letter"},{"question":"def find_arithmetic_sequence(arr, target_sum): Given an array of integers and a target sum, find whether an arithmetic sequence of length greater than or equal to 3 exists in the array such that the sum of the sequence is equal to the target sum. An arithmetic sequence is a sequence of numbers in which the difference between consecutive terms is constant. Parameters: arr (List[int]): The array of integers target_sum (int): The target sum Returns: str: \\"Yes\\" if such a sequence exists, \\"No\\" otherwise >>> find_arithmetic_sequence([1, 2, 4, 5, 6, 8], 15) \\"Yes\\" >>> find_arithmetic_sequence([3, 6, 9, 12, 15], 12) \\"No\\" pass def is_arithmetic_sequence_possible(test_cases): Parameters: test_cases (List[Tuple[Tuple[int, int], List[int]]]): List of test cases where each test case is a tuple containing a tuple with the length of the array and the target sum, and a list of integers representing the array. Returns: List[str]: List of results for each test case with either \\"Yes\\" or \\"No\\" >>> test_cases = [((6, 15), [1, 2, 4, 5, 6, 8]), ((5, 12), [3, 6, 9, 12, 15])] >>> is_arithmetic_sequence_possible(test_cases) [\\"Yes\\", \\"No\\"] pass","solution":"def find_arithmetic_sequence(arr, target_sum): n = len(arr) for i in range(n-2): for j in range(i+1, n-1): diff = arr[j] - arr[i] seq_sum = arr[i] + arr[j] k = j + 1 count = 2 while k < n and seq_sum < target_sum: if arr[k] - arr[k-1] == diff: seq_sum += arr[k] count += 1 k += 1 if seq_sum == target_sum and count >= 3: return \\"Yes\\" return \\"No\\" def is_arithmetic_sequence_possible(test_cases): results = [] for case in test_cases: n, s = case[0] arr = case[1] results.append(find_arithmetic_sequence(arr, s)) return results"},{"question":"def compress_string(s: str) -> str: Compress the given string by reducing sequences of the same character to the character followed by the number of occurrences. If the compressed sequence is not shorter than the original sequence, leave it as it is. The function is case-sensitive. >>> compress_string('aaabbcc') == 'a3b2c2' >>> compress_string('abcd') == 'abcd'","solution":"def compress_string(s): Compress the given string by reducing sequences of the same character to the character followed by the number of occurrences. If the compressed sequence is not shorter than the original sequence, leave it as it is. The function is case-sensitive. Parameters: s (str): The input string to be compressed. Returns: str: The compressed string or the original string if compression does not reduce the length. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 # To account for the last sequence compressed.append(s[-1] + str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def maximumSubstring(s1: str, s2: str) -> int: Write a function named \`maximumSubstring\` that takes two strings as input and returns the length of the longest substring that appears in both strings. >>> maximumSubstring(\\"abcdef\\", \\"zcdemf\\") 3 >>> maximumSubstring(\\"abc\\", \\"xyz\\") 0 >>> maximumSubstring(\\"abc\\", \\"abc\\") 3 >>> maximumSubstring(\\"\\", \\"\\") 0 >>> maximumSubstring(\\"abc\\", \\"\\") 0 >>> maximumSubstring(\\"\\", \\"xyz\\") 0 >>> maximumSubstring(\\"abcdxyz\\", \\"xyzabcd\\") 4 >>> maximumSubstring(\\"a\\", \\"a\\") 1 >>> maximumSubstring(\\"a\\", \\"b\\") 0","solution":"def maximumSubstring(s1, s2): Returns the length of the longest substring that appears in both s1 and s2. n = len(s1) m = len(s2) # Create a 2D list to store lengths of longest common suffixes of substrings. dp = [[0] * (m + 1) for _ in range(n + 1)] max_length = 0 # Initialize maximum length of common substring # Build the dp array from bottom to top and right to left for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) else: dp[i][j] = 0 return max_length"},{"question":"from typing import List def max_temp_diff(temps: List[int]) -> int: Returns the maximum temperature difference between any two days such that the later day has a higher temperature than the earlier day. >>> max_temp_diff([30, 25, 27, 40, 50, 10, 35]) == 25 >>> max_temp_diff([10, 8, 6, 4]) == 0 >>> max_temp_diff([1, 2, 3, 4, 5]) == 4 >>> max_temp_diff([5, 10, 4, 6, 12, 3, 9]) == 8 >>> max_temp_diff([]) == 0 >>> max_temp_diff([5]) == 0 >>> max_temp_diff([5, 10]) == 5 >>> max_temp_diff([10, 5]) == 0 pass","solution":"from typing import List def max_temp_diff(temps: List[int]) -> int: Returns the maximum temperature difference between any two days such that the later day has a higher temperature than the earlier day. if not temps: return 0 min_temp_so_far = temps[0] max_diff = 0 for temp in temps[1:]: if temp > min_temp_so_far: max_diff = max(max_diff, temp - min_temp_so_far) else: min_temp_so_far = temp return max_diff"},{"question":"def digit_game_winner(sequence: str) -> str: Determine the winner of the digit game and their score. >>> digit_game_winner(\\"31245\\") 'Bob 531' >>> digit_game_winner(\\"4826\\") 'Alice 8642' >>> digit_game_winner(\\"13579\\") 'Bob 97531' >>> digit_game_winner(\\"50321\\") 'Bob 531' >>> digit_game_winner(\\"1\\") 'Bob 1' >>> digit_game_winner(\\"2\\") 'Alice 2' >>> digit_game_winner(\\"2468\\") 'Alice 8642' >>> digit_game_winner(\\"1357\\") 'Bob 7531' >>> digit_game_winner(\\"\\") 'Draw'","solution":"def digit_game_winner(sequence): even_digits = [] odd_digits = [] for digit in sequence: if int(digit) % 2 == 0: even_digits.append(digit) else: odd_digits.append(digit) even_digits.sort(reverse=True) odd_digits.sort(reverse=True) alice_score = int(''.join(even_digits)) if even_digits else 0 bob_score = int(''.join(odd_digits)) if odd_digits else 0 if alice_score > bob_score: return f\\"Alice {alice_score}\\" elif bob_score > alice_score: return f\\"Bob {bob_score}\\" else: return \\"Draw\\" # Example usage sequence = \\"31245\\" print(digit_game_winner(sequence)) # Output: Bob 531"},{"question":"from collections import Counter def count_characters(S: str) -> str: Prints each unique character in the string S along with its count of occurrences, in the order of appearance. >>> count_characters('a') 'a 1' >>> count_characters('aaa') 'a 3' >>> count_characters('abracadabra') 'a 5nb 2nr 2nc 1nd 1' >>> count_characters('banana') 'b 1na 3nn 2' >>> count_characters('abcdef') 'a 1nb 1nc 1nd 1ne 1nf 1'","solution":"from collections import Counter def count_characters(S): Prints each unique character in the string S along with its count of occurrences, in the order of appearance. counter = Counter(S) output = [] seen = set() for char in S: if char not in seen: seen.add(char) output.append(f\\"{char} {counter[char]}\\") return 'n'.join(output)"},{"question":"from typing import List, Tuple def create_hierarchy(n: int, texts_importances: List[Tuple[str, int]]) -> Tuple[int, List[Tuple[int, int]]]: Creates a hierarchy of texts based on their importance levels, ensuring each text's importance is greater than its parent's. The hierarchy aims to maximize the length of the chain from the root to the deepest leaf. Parameters: n (int): Number of pieces of text. texts_importances (list of tuple): List of tuples where each tuple consists of a string and an integer. Returns: tuple: Number of levels in the hierarchy and the connections between the texts. def test_create_hierarchy_example1(): n = 4 texts_importances = [(\\"a\\", 5), (\\"b\\", 3), (\\"c\\", 8), (\\"d\\", 7)] chain_length, connections = create_hierarchy(n, texts_importances) assert chain_length == 4 assert connections == [(1, 2), (2, 3), (3, 4)] def test_create_hierarchy_example2(): n = 5 texts_importances = [(\\"apple\\", 1), (\\"banana\\", 2), (\\"cherry\\", 3), (\\"date\\", 4), (\\"elderberry\\", 5)] chain_length, connections = create_hierarchy(n, texts_importances) assert chain_length == 5 assert connections == [(1, 2), (2, 3), (3, 4), (4, 5)] def test_create_hierarchy_varied_importance(): n = 4 texts_importances = [(\\"x\\", 10), (\\"y\\", 15), (\\"z\\", 5), (\\"w\\", 7)] chain_length, connections = create_hierarchy(n, texts_importances) assert chain_length == 4 assert connections == [(1, 2), (2, 3), (3, 4)] def test_create_hierarchy_identical_length(): n = 3 texts_importances = [(\\"p\\", 5), (\\"q\\", 6), (\\"r\\", 4)] chain_length, connections = create_hierarchy(n, texts_importances) assert chain_length == 3 assert connections == [(1, 2), (2, 3)]","solution":"def create_hierarchy(n, texts_importances): Creates a hierarchy of texts based on their importance levels, ensuring each text's importance is greater than its parent's. The hierarchy aims to maximize the length of the chain from the root to the deepest leaf. Parameters: n (int): Number of pieces of text. texts_importances (list of tuple): List of tuples where each tuple consists of a string and an integer Returns: tuple: Number of levels in the hierarchy and the connections between the texts. # Sort texts based on importance sorted_texts = sorted(texts_importances, key=lambda x: x[1]) chain_length = n connections = [(i + 1, i + 2) for i in range(n - 1)] return chain_length, connections # Example usage n = 4 texts_importances = [(\\"a\\", 5), (\\"b\\", 3), (\\"c\\", 8), (\\"d\\", 7)] result = create_hierarchy(n, texts_importances) print(result[0]) for connection in result[1]: print(connection[0], connection[1])"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string s. If there are multiple longest palindromic substrings of the same length, returns the one which appears first in the string. >>> longest_palindromic_substring(\\"babad\\") \\"bab\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"bb\\") \\"bb\\" >>> longest_palindromic_substring(\\"forgeeksskeegfor\\") \\"geeksskeeg\\" >>> longest_palindromic_substring(\\"abcd\\") \\"a\\" >>> longest_palindromic_substring(\\"racecar\\") \\"racecar\\" >>> longest_palindromic_substring(\\"abacdfgdcaba\\") \\"aba\\" >>> longest_palindromic_substring(\\"\\") \\"\\"","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string s. If there are multiple longest palindromic substrings of the same length, returns the one which appears first in the string. if not s or len(s) == 1: return s def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): p1 = expand_around_center(s, i, i) p2 = expand_around_center(s, i, i + 1) if len(p1) > len(longest): longest = p1 if len(p2) > len(longest): longest = p2 return longest"},{"question":"def stringBalance(s1: str, s2: str) -> bool: Returns true if the second string contains all characters of the first string in the same order (not necessarily consecutively). >>> stringBalance(\\"abc\\", \\"aebdc\\") True >>> stringBalance(\\"abc\\", \\"axbycz\\") True >>> stringBalance(\\"abc\\", \\"acb\\") False","solution":"def stringBalance(s1, s2): Returns true if s2 contains all characters of s1 in the same order. it = iter(s2) return all(char in it for char in s1)"},{"question":"def calculate_total_weight(requests): Calculates the total weight of food to be delivered for all requests. Each request is a list where: - requests[i][0] represents quantity of grains - requests[i][1] represents quantity of vegetables - requests[i][2] represents quantity of protein The weight is calculated as follows: - Grains: 1 weight unit per unit of quantity - Vegetables: 2 weight units per unit of quantity - Protein: 4 weight units per unit of quantity Arguments: requests -- list of requests where each request is a list [grains, vegetables, protein] Returns: integer -- total weight of food to be delivered >>> calculate_total_weight([[2, 3, 1], [1, 0, 2], [4, 2, 1]]) 33 >>> calculate_total_weight([[0, 0, 0]]) 0 >>> calculate_total_weight([[100, 200, 300]]) 1700 >>> calculate_total_weight([[2, 3, 1]]) 12 >>> calculate_total_weight([[1, 0, 2]]) 9","solution":"def calculate_total_weight(requests): Calculates the total weight of food to be delivered for all requests. Each request is a list where: - requests[i][0] represents quantity of grains - requests[i][1] represents quantity of vegetables - requests[i][2] represents quantity of protein The weight is calculated as follows: - Grains: 1 weight unit per unit of quantity - Vegetables: 2 weight units per unit of quantity - Protein: 4 weight units per unit of quantity Arguments: requests -- list of requests where each request is a list [grains, vegetables, protein] Returns: integer -- total weight of food to be delivered total_weight = 0 for request in requests: grains, vegetables, protein = request total_weight += grains * 1 + vegetables * 2 + protein * 4 return total_weight"},{"question":"from typing import List def find_missing_numbers(nums: List[int]) -> List[int]: Write a function \`find_missing_numbers\` that takes a list of integers as its argument and returns a list of the missing integers from the sequence. The input list always contains numbers between 1 and 100 (inclusive) and may have duplicates. The resulting list should be sorted in ascending order. >>> find_missing_numbers([]) == list(range(1, 101)) >>> find_missing_numbers(list(range(1, 101))) == [] >>> find_missing_numbers([1, 2, 3, 4, 6, 7, 8, 10]) == [5, 9] + list(range(11, 101)) >>> find_missing_numbers([1, 2, 2, 2, 4, 4, 7, 8, 10, 10]) == [3, 5, 6, 9] + list(range(11, 101)) >>> find_missing_numbers([99]) == list(range(1, 99)) + [100] >>> find_missing_numbers([0, 101]) == list(range(1, 101))","solution":"from typing import List def find_missing_numbers(nums: List[int]) -> List[int]: Returns a sorted list of missing integers from the sequence 1 to 100. complete_set = set(range(1, 101)) num_set = set(nums) missing_numbers = complete_set - num_set return sorted(list(missing_numbers))"},{"question":"def find_two_sum(nums, target): Returns the indices of the two numbers that add up to the target. Parameters: nums (list): List of integers. target (int): Target sum. Returns: tuple: Tuple of indices if such a pair exists, otherwise None. def test_find_two_sum(): assert find_two_sum([2, 7, 11, 15], 9) == (0, 1) assert find_two_sum([1, 2, 3, 4, 5], 10) == None assert find_two_sum([3, 2, 4], 6) == (1, 2) assert find_two_sum([10, 7, 10, 2], 9) == (1, 3) assert find_two_sum([1, 3, 4, 2], 6) == (2, 3) assert find_two_sum([1, 3, 3, 2], 6) == (1, 2) assert find_two_sum([], 5) == None assert find_two_sum([5], 5) == None assert find_two_sum([5, 5], 10) == (0, 1)","solution":"def find_two_sum(nums, target): Returns the indices of the two numbers that add up to the target. Parameters: nums (list): List of integers. target (int): Target sum. Returns: tuple: Tuple of indices if such a pair exists, otherwise None. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return None"},{"question":"def minimum_cost_to_buy_products(n: int, m: int, prices: List[int], pairings: List[Tuple[int, int, int]]) -> int: Determine the minimum cost to buy all products with possible double discounts. Args: n (int): The number of products. m (int): The number of possible pairings. prices (List[int]): The list of prices of the products. pairings (List[Tuple[int, int, int]]): The list of possible pairings and their discounts. Returns: int: The minimum cost to buy all the products. Example: >>> minimum_cost_to_buy_products(4, 3, [4, 7, 2, 5], [(1, 2, 3), (1, 3, 2), (3, 4, 4)]) 14 >>> minimum_cost_to_buy_products(3, 1, [6, 4, 5], [(1, 2, 2)]) 13 from typing import List, Tuple def test_example_1(): n = 4 m = 3 prices = [4, 7, 2, 5] pairings = [(1, 2, 3), (1, 3, 2), (3, 4, 4)] assert minimum_cost_to_buy_products(n, m, prices, pairings) == 14 def test_example_2(): n = 3 m = 1 prices = [6, 4, 5] pairings = [(1, 2, 2)] assert minimum_cost_to_buy_products(n, m, prices, pairings) == 13 def test_case_no_pairing(): n = 3 m = 0 prices = [6, 4, 5] pairings = [] assert minimum_cost_to_buy_products(n, m, prices, pairings) == 15 def test_multiple_pairings_with_same_discounts(): n = 5 m = 3 prices = [10, 20, 30, 40, 50] pairings = [(1, 2, 5), (3, 4, 5), (2, 5, 5)] assert minimum_cost_to_buy_products(n, m, prices, pairings) == 145 def test_large_discount(): n = 3 m = 2 prices = [10, 20, 30] pairings = [(1, 2, 25), (2, 3, 10)] assert minimum_cost_to_buy_products(n, m, prices, pairings) == 35","solution":"def minimum_cost_to_buy_products(n, m, prices, pairings): # Initialize the total cost as the sum of all product prices total_cost = sum(prices) # Initialize the best discount as 0 best_discount = 0 # Loop through each pairing to find the best discount achieved for a, b, discount in pairings: best_discount = max(best_discount, discount) # The minimum cost is the total cost minus the best discount available min_cost = total_cost - best_discount return min_cost"},{"question":"def longest_increasing_subsequence(nums: List[int]) -> int: Finds the length of the longest strictly increasing subsequence in the array. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7]) 1 >>> longest_increasing_subsequence([1]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([]) 0","solution":"def longest_increasing_subsequence(nums): Finds the length of the longest strictly increasing subsequence in the array. if not nums: return 0 # Initialize an array to store the length of the longest increasing subsequence ending at each index dp = [1] * len(nums) # Iterate through the array to fill the dp array for i in range(len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) # The result is the maximum value in the dp array return max(dp)"},{"question":"def is_valid_sentence(inputString: str) -> bool: Check if the input string is a valid sentence. A valid sentence must: 1. Start with an uppercase letter. 2. Each word must contain only alphabetical characters. 3. End with a single period (.) with no spaces before it. Parameters: inputString (str): The sentence to check. Returns: bool: True if the input string is a valid sentence, False otherwise. Examples: >>> is_valid_sentence(\\"Hello world.\\") True >>> is_valid_sentence(\\"hello world.\\") False >>> is_valid_sentence(\\"Hello world\\") False >>> is_valid_sentence(\\"Hello world. \\") False >>> is_valid_sentence(\\"Hello Wo123rld.\\") False","solution":"def is_valid_sentence(inputString): Check if the input string is a valid sentence. Parameters: inputString (str): The sentence to check. Returns: bool: True if the input string is a valid sentence, False otherwise. # Rule 1: Sentence must start with an uppercase letter if not inputString[0].isupper(): return False # Rule 2: Sentence must end with a single period with no space before it if not inputString.endswith(\\".\\") or (len(inputString) > 1 and inputString[-2] == \\" \\"): return False # Remove the ending period for further checks sentence_body = inputString[:-1] # Split the sentence into words words = sentence_body.split() # Rule 3: Each word must contain only alphabetical characters for word in words: if not word.isalpha(): return False return True"},{"question":"def largest_connected_group(n: int, m: int, grid: List[List[int]]) -> int: This function returns the size of the largest connected group of trees in the grid. Trees are connected if they are adjacent horizontally or vertically. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: 2D list representing the grid :return: Size of the largest connected group of trees Example: >>> largest_connected_group(4, 5, [ [1, 0, 1, 1, 0], [1, 1, 0, 0, 0], [0, 0, 1, 1, 1], [0, 1, 0, 1, 0] ]) 4 >>> largest_connected_group(3, 3, [ [1, 1, 0], [1, 0, 0], [0, 0, 1] ]) 3 def dfs(row: int, col: int) -> int: Depth First Search function to explore the connected trees. :param row: current row index :param col: current column index :return: size of the connected group found starting from (row, col) pass pass","solution":"def largest_connected_group(n, m, grid): This function returns the size of the largest connected group of trees in the grid. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: 2D list representing the grid :return: Size of the largest connected group of trees def dfs(row, col): Depth First Search function to explore the connected trees :param row: current row index :param col: current column index :return: size of the connected group found starting from (row, col) if row < 0 or row >= n or col < 0 or col >= m or grid[row][col] == 0: return 0 grid[row][col] = 0 # Mark this cell as visited by setting it to 0 size = 1 # Explore all 4 possible directions (up, down, left, right) size += dfs(row + 1, col) size += dfs(row - 1, col) size += dfs(row, col + 1) size += dfs(row, col - 1) return size max_size = 0 for row in range(n): for col in range(m): if grid[row][col] == 1: max_size = max(max_size, dfs(row, col)) return max_size"},{"question":"def canForm(m: int, n: int) -> bool: Determines if the integer \`n\` can be formed by concatenating the digits of the integer \`m\` in any order. >>> canForm(1234, 3412) True >>> canForm(1234, 4321) True >>> canForm(1234, 432) False >>> canForm(1234, 12345) False from collections import Counter","solution":"def canForm(m, n): Determines if the integer \`n\` can be formed by concatenating the digits of the integer \`m\` in any order. from collections import Counter # Convert both numbers to strings str_m = str(m) str_n = str(n) # Utilize Counter to count the frequency of digits and compare return Counter(str_m) == Counter(str_n)"},{"question":"def min_platforms_needed(arr, dep): Returns the minimum number of platforms required at the railway station so that no train has to wait. >>> min_platforms_needed([\\"09:00\\", \\"09:40\\", \\"09:50\\", \\"11:00\\", \\"15:00\\", \\"18:00\\"], [\\"09:10\\", \\"12:00\\", \\"11:20\\", \\"11:30\\", \\"19:00\\", \\"20:00\\"]) 3 >>> min_platforms_needed([\\"12:00\\", \\"12:10\\", \\"12:25\\"], [\\"12:30\\", \\"12:15\\", \\"12:40\\"]) 2","solution":"def min_platforms_needed(arr, dep): Returns the minimum number of platforms required at the railway station so that no train has to wait. arr_times = sorted([int(a[:2])*60 + int(a[3:]) for a in arr]) dep_times = sorted([int(d[:2])*60 + int(d[3:]) for d in dep]) platform_needed = 1 result = 1 i = 1 j = 0 n = len(arr) while (i < n and j < n): if arr_times[i] <= dep_times[j]: platform_needed += 1 i += 1 elif arr_times[i] > dep_times[j]: platform_needed -= 1 j += 1 if platform_needed > result: result = platform_needed return result"},{"question":"def min_cost_paths(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Find the number of unique paths that have the minimum cost in a grid. >>> input_data = \\"2n2 2n1 3n2 1n3 3n1 2 3n4 8 2n1 5 3n\\" >>> t, test_cases = process_input(input_data) >>> min_cost_paths(t, test_cases) [1, 1] >>> input_data = \\"1n3 3n0 0 0n0 0 0n0 0 0n\\" >>> t, test_cases = process_input(input_data) >>> min_cost_paths(t, test_cases) [6] >>> input_data = \\"1n1 1n42n\\" >>> t, test_cases = process_input(input_data) >>> min_cost_paths(t, test_cases) [1] >>> input_data = \\"1n3 3n1 1 1n1 1 1n1 1 1n\\" >>> t, test_cases = process_input(input_data) >>> min_cost_paths(t, test_cases) [6] >>> input_data = \\"1n3 3n1 1000 1000n1 1000 1000n1 1 1n\\" >>> t, test_cases = process_input(input_data) >>> min_cost_paths(t, test_cases) [1] def process_input(input_data: str) -> Tuple[int, List[Tuple[int, int, List[List[int]]]]]: Process the input data into the required format. >>> input_data = \\"2n2 2n1 3n2 1n3 3n1 2 3n4 8 2n1 5 3n\\" >>> process_input(input_data) (2, [(2, 2, [[1, 3], [2, 1]]), (3, 3, [[1, 2, 3], [4, 8, 2], [1, 5, 3]])])","solution":"def min_cost_paths(t, test_cases): MOD = 1000000007 results = [] for case in test_cases: n, m, grid = case dp = [[float('inf')] * m for _ in range(n)] paths = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] paths[0][0] = 1 for i in range(n): for j in range(m): if i > 0: if dp[i][j] > dp[i-1][j] + grid[i][j]: dp[i][j] = dp[i-1][j] + grid[i][j] paths[i][j] = paths[i-1][j] elif dp[i][j] == dp[i-1][j] + grid[i][j]: paths[i][j] = (paths[i][j] + paths[i-1][j]) % MOD if j > 0: if dp[i][j] > dp[i][j-1] + grid[i][j]: dp[i][j] = dp[i][j-1] + grid[i][j] paths[i][j] = paths[i][j-1] elif dp[i][j] == dp[i][j-1] + grid[i][j]: paths[i][j] = (paths[i][j] + paths[i][j-1]) % MOD results.append(paths[n-1][m-1]) return results def process_input(input_data): data = input_data.splitlines() t = int(data[0]) test_cases = [] index = 1 for _ in range(t): n, m = map(int, data[index].split()) index += 1 grid = [] for _ in range(n): grid.append(list(map(int, data[index].split()))) index += 1 test_cases.append((n, m, grid)) return t, test_cases"},{"question":"def max_removed_and_remaining_sum(n, k, sequence): This function calculates the maximum sum of removed k elements and the remaining sum of the sequence. :param n: int - the length of the sequence :param k: int - the number of elements to remove :param sequence: list of int - the sequence of integers :return: tuple - (maximum sum of removed k elements, remaining sum of the sequence) >>> max_removed_and_remaining_sum(5, 2, [3, 1, 9, 7, 5]) (16, 9) >>> max_removed_and_remaining_sum(6, 3, [5, 1, 3, 6, 8, 2]) (19, 6) >>> max_removed_and_remaining_sum(8, 4, [10, 20, 15, 5, 25, 30, 40, 35]) (130, 35) >>> max_removed_and_remaining_sum(1, 1, [10]) (10, 0) >>> max_removed_and_remaining_sum(4, 4, [4, 3, 2, 1]) (10, 0) >>> max_removed_and_remaining_sum(5, 0, [5, 3, 4, 2, 1]) (0, 15) >>> max_removed_and_remaining_sum(5, 3, [10, 20, 30, 40, 50]) (120, 30) >>> max_removed_and_remaining_sum(5, 2, [1, 2, 3, 4, 5]) (9, 6) >>> max_removed_and_remaining_sum(5, 3, [10, 20, 30, 40, 50]) (120, 30)","solution":"def max_removed_and_remaining_sum(n, k, sequence): This function calculates the maximum sum of removed k elements and the remaining sum of the sequence. :param n: int - the length of the sequence :param k: int - the number of elements to remove :param sequence: list of int - the sequence of integers :return: tuple - (maximum sum of removed k elements, remaining sum of the sequence) sorted_sequence = sorted(sequence, reverse=True) max_removed_sum = sum(sorted_sequence[:k]) remaining_sum = sum(sequence) - max_removed_sum return max_removed_sum, remaining_sum"},{"question":"def calculate_average_scores(students): Calculate the average test score for each student and return a list of tuples sorted by average score in descending order. If two students have the same average score, they should be listed in alphabetical order by their names. Parameters: students (list of tuples): List of student records, where each record is a tuple containing a student's name and a list of their test scores. Returns: list of tuples: List of tuples, each containing a student's name and their average score, sorted by average score in descending order. def test_calculate_average_scores(): students1 = [(\\"John\\", [88, 92, 85, 91]), (\\"Jane\\", [90, 92, 85, 89]), (\\"Dave\\", [85, 80, 83, 87])] expected_output1 = [(\\"Jane\\", 89.0), (\\"John\\", 89.0), (\\"Dave\\", 83.75)] assert calculate_average_scores(students1) == expected_output1 students2 = [(\\"Alice\\", [100, 98, 96, 97]), (\\"Bob\\", [95, 94, 92, 90]), (\\"Charlie\\", [80, 85, 88, 84])] expected_output2 = [(\\"Alice\\", 97.75), (\\"Bob\\", 92.75), (\\"Charlie\\", 84.25)] assert calculate_average_scores(students2) == expected_output2 students3 = [(\\"Tom\\", [90, 90, 90, 90]), (\\"Dick\\", [85, 85, 85, 85]), (\\"Harry\\", [95, 95, 95, 95])] expected_output3 = [(\\"Harry\\", 95.0), (\\"Tom\\", 90.0), (\\"Dick\\", 85.0)] assert calculate_average_scores(students3) == expected_output3 students4 = [(\\"Jake\\", [72, 75, 78, 80]), (\\"Amy\\", [88, 85, 91, 89]), (\\"Rosa\\", [83, 82, 85, 84])] expected_output4 = [(\\"Amy\\", 88.25), (\\"Rosa\\", 83.5), (\\"Jake\\", 76.25)] assert calculate_average_scores(students4) == expected_output4 students5 = [(\\"Bob\\", [70, 70, 70, 70]), (\\"Alice\\", [70, 70, 70, 70])] expected_output5 = [(\\"Alice\\", 70.0), (\\"Bob\\", 70.0)] assert calculate_average_scores(students5) == expected_output5","solution":"def calculate_average_scores(students): Calculate the average test score for each student and return a list of tuples sorted by average score in descending order. If two students have the same average score, they should be listed in alphabetical order by their names. Parameters: students (list of tuples): List of student records, where each record is a tuple containing a student's name and a list of their test scores. Returns: list of tuples: List of tuples, each containing a student's name and their average score, sorted by average score in descending order. avg_scores = [ (name, sum(scores) / len(scores)) for name, scores in students ] avg_scores_sorted = sorted(avg_scores, key=lambda x: (-x[1], x[0])) return avg_scores_sorted"},{"question":"from typing import List def pairSum(arr: List[int], target: int) -> bool: Returns True if there are two distinct numbers in the array that add up to the target sum, else False. >>> pairSum([1, 2, 4, 4], 8) True >>> pairSum([1, 2, 3, 9], 8) False >>> pairSum([], 8) False >>> pairSum([5], 8) False >>> pairSum([-1, 4, 2, -7], -5) True >>> pairSum([3, 3, 3], 6) True >>> pairSum([1, 5, 7, -1, 5], 6) True >>> pairSum([10**6, 10**7, -10**8, 10**8], 0) True >>> pairSum([10, 1, 7, 8, 3], 9) True","solution":"def pairSum(arr, target): Returns True if there are two distinct numbers in the array that add up to the target sum, else False. if len(arr) < 2: return False seen = set() for num in arr: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"def minSubArrayLen(nums, k): Returns the minimum length of a contiguous subarray of which the sum ≥ k. If there isn't one, returns 0 instead. >>> minSubArrayLen([2, 3, 1, 2, 4, 3], 7) == 2 >>> minSubArrayLen([1, 1, 1, 1, 1], 10) == 0 >>> minSubArrayLen([1, 2, 3, 4, 5], 15) == 5 >>> minSubArrayLen([1, 2, 3, 10, 4, 5], 10) == 1 >>> minSubArrayLen([1] * 10000, 5000) == 5000","solution":"def minSubArrayLen(nums, k): Returns the minimum length of a contiguous subarray of which the sum ≥ k. If there isn't one, returns 0 instead. n = len(nums) min_len = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= k: min_len = min(min_len, end - start + 1) current_sum -= nums[start] start += 1 return min_len if min_len != float('inf') else 0"},{"question":"def count_buildings_with_view(heights: List[int]) -> int: Returns the number of buildings that can view the horizon. >>> count_buildings_with_view([4, 2, 3, 1]) 3 >>> count_buildings_with_view([1, 2, 3, 4]) 1","solution":"def count_buildings_with_view(heights): Returns the number of buildings that can view the horizon. count = 0 max_height = 0 for height in reversed(heights): if height > max_height: count += 1 max_height = height return count"},{"question":"def factorial(n: int) -> int: Returns the factorial of the given integer n. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(5) 120 >>> factorial(12) 479001600 Raises: ValueError: If the input is a negative integer. # your code here # Reading input if __name__ == \\"__main__\\": n = int(input(\\"Enter an integer: \\")) print(factorial(n))","solution":"def factorial(n): Returns the factorial of the given integer n. if n < 0: raise ValueError(\\"Input should be a non-negative integer.\\") if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result # Reading input if __name__ == \\"__main__\\": n = int(input(\\"Enter an integer: \\")) print(factorial(n))"},{"question":"def is_palindrome(s: str) -> bool: Determine if a given string is a palindrome, ignoring spaces, punctuation, and case. >>> is_palindrome(\\"A man a plan a canal Panama\\") == True >>> is_palindrome(\\"Able, was I, ere I saw Elba!\\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"This is not a palindrome\\") == False","solution":"import string def is_palindrome(s): Returns True if the given string is a palindrome, ignoring spaces, punctuation, and case. Otherwise, returns False. # Convert the string to lowercase and remove any spaces or punctuation cleaned = ''.join(char.lower() for char in s if char.isalnum()) # Check if the cleaned string is the same forwards and backwards return cleaned == cleaned[::-1]"},{"question":"def second_smallest(numbers: List[int]) -> Optional[int]: Returns the second smallest number in the list. If the list is empty or contains less than two unique elements, returns None. >>> second_smallest([3, 1, 4, 1, 5, 9]) --> 3 >>> second_smallest([10, 20, 30, 20, 40, 10]) --> 20 >>> second_smallest([5]) --> None >>> second_smallest([]) --> None >>> second_smallest([7, 7, 7, 7]) --> None","solution":"def second_smallest(numbers): Returns the second smallest number in the list. If the list is empty or contains less than two unique elements, returns None. if not numbers or len(numbers) < 2: return None unique_numbers = list(set(numbers)) if len(unique_numbers) < 2: return None unique_numbers.sort() return unique_numbers[1]"},{"question":"from typing import List def distinct_substrings(s: str, k: int) -> int: Write a function that takes a string of lowercase characters and an integer k. The function should return the number of distinct substrings of length k found in the given string. If k is greater than the length of the string, return 0. Examples: >>> distinct_substrings(\\"abcabc\\", 3) == 3 >>> distinct_substrings(\\"aaaa\\", 2) == 1 >>> distinct_substrings(\\"abcd\\", 5) == 0 >>> distinct_substrings(\\"abcd\\", 4) == 1 >>> distinct_substrings(\\"aaaa\\", 1) == 1 >>> distinct_substrings(\\"abcdefghijkl\\", 2) == 11 >>> distinct_substrings(\\"abacabad\\", 3) == 5","solution":"def distinct_substrings(s, k): Returns the number of distinct substrings of length k found in the given string. if k > len(s): return 0 substrings = set() for i in range(len(s) - k + 1): substr = s[i:i + k] substrings.add(substr) return len(substrings)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a string representing a mathematical expression and return the result as an integer. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23 import operator def test_simple_addition(): assert evaluate_expression(\\"3+2\\") == 5 def test_simple_multiplication(): assert evaluate_expression(\\"3*2\\") == 6 def test_combined_operations(): assert evaluate_expression(\\"3+2*2\\") == 7 def test_parenthesis_override_precedence(): assert evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") == 23 def test_all_operators(): assert evaluate_expression(\\"10+2*6\\") == 22 assert evaluate_expression(\\"100*2+12\\") == 212 assert evaluate_expression(\\"100*(2+12)\\") == 1400 assert evaluate_expression(\\"100*(2+12)/14\\") == 100 def test_single_number(): assert evaluate_expression(\\"42\\") == 42 def test_division_and_subtraction(): assert evaluate_expression(\\"10-3*2\\") == 4 assert evaluate_expression(\\"10/2+7\\") == 12 assert evaluate_expression(\\"10/(2+3)\\") == 2 def test_complex_expression(): assert evaluate_expression(\\"2*(5+5*2)/3+(6/2+8)\\") == 21 def test_large_numbers(): assert evaluate_expression(\\"1000000000*2000000\\") == 2000000000000000 assert evaluate_expression(\\"(1000000000*2000000)/4000000\\") == 500000000 def test_negative_results(): assert evaluate_expression(\\"2-5*2\\") == -8 assert evaluate_expression(\\"10/(2+3)-3\\") == -1","solution":"def evaluate_expression(expression: str) -> int: def operate(op, second, first): if op == '+': return first + second elif op == '-': return first - second elif op == '*': return first * second elif op == '/': return int(first / second) def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_ops(ops, vals): while ops and ops[-1] != '(': vals.append(operate(ops.pop(), vals.pop(), vals.pop())) n = len(expression) vals = [] ops = [] i = 0 while i < n: if expression[i].isdigit(): value = 0 while i < n and expression[i].isdigit(): value = value * 10 + int(expression[i]) i += 1 vals.append(value) i -= 1 elif expression[i] == '(': ops.append(expression[i]) elif expression[i] == ')': apply_ops(ops, vals) ops.pop() else: while ops and precedence(ops[-1]) >= precedence(expression[i]): vals.append(operate(ops.pop(), vals.pop(), vals.pop())) ops.append(expression[i]) i += 1 apply_ops(ops, vals) return vals[0]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head: ListNode) -> bool: Determine if the number formed by the linked list is a palindrome. :param ListNode head: The head of the linked list. :return: True if the number is a palindrome, False otherwise. >>> head = ListNode(1, ListNode(2, ListNode(2, ListNode(1)))) >>> is_palindrome(head) True >>> head = ListNode(1, ListNode(2)) >>> is_palindrome(head) False >>> head = ListNode(1, ListNode(0, ListNode(0, ListNode(1)))) >>> is_palindrome(head) True >>> head = ListNode(5) >>> is_palindrome(head) True >>> head = ListNode(0) >>> is_palindrome(head) True >>> head = ListNode(1, ListNode(2, ListNode(3))) >>> is_palindrome(head) False","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head): Determine if the number formed by the linked list is a palindrome. :param ListNode head: The head of the linked list. :return: True if the number is a palindrome, False otherwise. # Convert linked list to string num_str = \\"\\" current = head while current is not None: num_str += str(current.val) current = current.next # Check if the string is a palindrome return num_str == num_str[::-1]"},{"question":"from typing import List def generate_combinations(S: str) -> List[str]: Given a string S consisting of uppercase letters and the wildcard character '*', return all possible letter combinations that the string could represent. >>> generate_combinations(\\"A*C\\") [\\"AAC\\", \\"ABC\\", \\"ACC\\", \\"ADC\\", \\"AEC\\", \\"AFC\\", \\"AGC\\", \\"AHC\\", \\"AIC\\", \\"AJC\\", \\"AKC\\", \\"ALC\\", \\"AMC\\", \\"ANC\\", \\"AOC\\", \\"APC\\", \\"AQC\\", \\"ARC\\", \\"ASC\\", \\"ATC\\", \\"AUC\\", \\"AVC\\", \\"AWC\\", \\"AXC\\", \\"AYC\\", \\"AZC\\"] >>> generate_combinations(\\"Z*Z*\\") (returns all possible combinations of \\"Z*Z*\\", such as [\\"ZAZA\\", \\"ZZZZ\\", \\"ZXZX\\", ...]) >>> generate_combinations(\\"***\\") (returns all possible combinations of \\"***\\", such as [\\"AAA\\", \\"AAB\\", \\"AAC\\", ..., \\"ZZX\\", \\"ZZY\\", \\"ZZZ\\"]) >>> generate_combinations(\\"HELLO\\") [\\"HELLO\\"] pass","solution":"def generate_combinations(S): Given a string S consisting of uppercase letters and the wildcard character '*', return all possible letter combinations that the string could represent. from itertools import product chars_options = [list('ABCDEFGHIJKLMNOPQRSTUVWXYZ') if c == '*' else [c] for c in S] return [\\"\\".join(p) for p in product(*chars_options)]"},{"question":"from typing import List, Tuple def frequency_count(s: str) -> List[Tuple[str, int]]: Returns the frequency count of each letter (ignoring case) and each digit, sorted by frequency and then by lexicographical order if frequencies are the same. >>> frequency_count(\\"aA11bB2Ccc\\") [('c', 3), ('1', 2), ('a', 2), ('b', 2), ('2', 1)] >>> frequency_count(\\"1\\") [('1', 1)] >>> frequency_count(\\"a\\") [('a', 1)] >>> frequency_count(\\"AaAa\\") [('a', 4)] >>> frequency_count(\\"11122233\\") [('1', 3), ('2', 3), ('3', 2)] >>> frequency_count(\\"a1b2c3\\") [('1', 1), ('2', 1), ('3', 1), ('a', 1), ('b', 1), ('c', 1)]","solution":"from collections import Counter def frequency_count(s: str) -> [(str, int)]: Returns the frequency count of each letter (ignoring case) and digit, sorted by frequency and then by lexicographical order if frequencies are the same. s = s.lower() counter = Counter(s) # Sorting first by frequency (in descending order), then by lexicographical order result = sorted(counter.items(), key=lambda x: (-x[1], x[0])) return result"},{"question":"def calculate_total_order(drink_prices: dict, order: list) -> float: Calculate the total cost of the coffee order. :param drink_prices: Dictionary mapping drink names to prices. :param order: List of strings representing the coffee drinks ordered. :return: Total cost of the order rounded to two decimal places. >>> drink_prices = { >>> \\"Espresso\\": 2.50, >>> \\"Latte\\": 3.50, >>> \\"Cappuccino\\": 3.00, >>> \\"Mocha\\": 4.00 >>> } >>> order = [\\"Espresso\\", \\"Latte\\", \\"Mocha\\"] >>> calculate_total_order(drink_prices, order) 10.00 >>> order = [] >>> calculate_total_order(drink_prices, order) 0.00 >>> order = [\\"Latte\\"] >>> calculate_total_order(drink_prices, order) 3.50 >>> order = [\\"Latte\\", \\"Latte\\", \\"Latte\\"] >>> calculate_total_order(drink_prices, order) 10.50 >>> order = [\\"Mocha\\", \\"Latte\\", \\"Espresso\\", \\"Cappuccino\\"] >>> calculate_total_order(drink_prices, order) 13.00 pass","solution":"def calculate_total_order(drink_prices: dict, order: list) -> float: Calculate the total cost of the coffee order. :param drink_prices: Dictionary mapping drink names to prices. :param order: List of strings representing the coffee drinks ordered. :return: Total cost of the order rounded to two decimal places. total_cost = sum(drink_prices[drink] for drink in order) return round(total_cost, 2)"},{"question":"def rle_compress(input_str: str) -> str: Compresses the input string using Run-Length Encoding (RLE). Args: input_str (str): The string to be compressed. Returns: str: The compressed Run-Length Encoded string. Example: >>> rle_compress(\\"AAAABBBCCDAA\\") '4A3B2C1D2A' >>> rle_compress(\\"WWWWXYZ\\") '4W1X1Y1Z' def rle_decompress(compressed_str: str) -> str: Decompresses the Run-Length Encoded string back to the original string. Args: compressed_str (str): The compressed Run-Length Encoded string. Returns: str: The decompressed original string. Example: >>> rle_decompress(\\"4A3B2C1D2A\\") 'AAAABBBCCDAA' >>> rle_decompress(\\"4W1X1Y1Z\\") 'WWWWXYZ'","solution":"def rle_compress(input_str: str) -> str: Compresses the input string using Run-Length Encoding (RLE). Args: input_str (str): The string to be compressed. Returns: str: The compressed Run-Length Encoded string. if not input_str: return \\"\\" compressed_str = [] current_char = input_str[0] count = 1 for char in input_str[1:]: if char == current_char: count += 1 else: compressed_str.append(f\\"{count}{current_char}\\") current_char = char count = 1 compressed_str.append(f\\"{count}{current_char}\\") return ''.join(compressed_str) def rle_decompress(compressed_str: str) -> str: Decompresses the Run-Length Encoded string back to the original string. Args: compressed_str (str): The compressed Run-Length Encoded string. Returns: str: The decompressed original string. if not compressed_str: return \\"\\" decompressed_str = [] count = \\"\\" for char in compressed_str: if char.isdigit(): count += char else: decompressed_str.append(char * int(count)) count = \\"\\" return ''.join(decompressed_str)"},{"question":"def is_lexicographically_sorted(lst: List[str]) -> bool: Determine if the list of strings is sorted in lexicographical order. :param lst: List of strings. :return: True if the list is sorted in ascending lexicographical order, else False. Examples: >>> is_lexicographically_sorted(['apple', 'banana', 'cherry']) True >>> is_lexicographically_sorted(['apple', 'banana', 'Banana']) False >>> is_lexicographically_sorted(['abc', 'bcd', 'cde']) True >>> is_lexicographically_sorted(['zebra', 'monkey', 'ape']) False >>> is_lexicographically_sorted([]) True >>> is_lexicographically_sorted(['single']) True >>> is_lexicographically_sorted(['a', 'a', 'a']) True >>> is_lexicographically_sorted(['1', '2', '10']) False","solution":"def is_lexicographically_sorted(lst): Determine if the list of strings is sorted in lexicographical order. :param lst: List of strings. :return: True if the list is sorted in ascending lexicographical order, else False. return lst == sorted(lst)"},{"question":"def reverse_words(text: str) -> str: Given a string \`text\` containing a mix of alphabetical characters, digits, and spaces, return a new string with the words reversed, while maintaining the order of non-alphabetic characters. >>> reverse_words(\\"hello world\\") == \\"world hello\\" >>> reverse_words(\\"hello 123 world\\") == \\"world 123 hello\\" >>> reverse_words(\\"a1 b2 c3\\") == \\"c1 b2 a3\\" >>> reverse_words(\\" a b c \\") == \\" c b a \\" >>> reverse_words(\\"123 456 789\\") == \\"123 456 789\\" >>> reverse_words(\\"\\") == \\"\\" >>> reverse_words(\\"hello! world!\\") == \\"world! hello!\\" >>> reverse_words(\\"hello, world!\\") == \\"world, hello!\\" >>> reverse_words(\\"a b c\\") == \\"c b a\\"","solution":"def reverse_words(text): Reverses the words in the given text while maintaining the order of non-alphabetic characters. words = [] non_alpha_parts = [] current_word = \\"\\" current_non_alpha = \\"\\" for char in text: if char.isalpha(): if current_non_alpha: non_alpha_parts.append(current_non_alpha) current_non_alpha = \\"\\" current_word += char else: if current_word: words.append(current_word) current_word = \\"\\" current_non_alpha += char if current_word: words.append(current_word) if current_non_alpha: non_alpha_parts.append(current_non_alpha) reversed_words = list(reversed(words)) result = \\"\\" # Merging back words with the non alphabet parts word_idx = 0 non_alpha_idx = 0 for char in text: if char.isalpha(): result += reversed_words[word_idx][0] reversed_words[word_idx] = reversed_words[word_idx][1:] if not reversed_words[word_idx]: word_idx += 1 else: result += non_alpha_parts[non_alpha_idx][0] non_alpha_parts[non_alpha_idx] = non_alpha_parts[non_alpha_idx][1:] if not non_alpha_parts[non_alpha_idx]: non_alpha_idx += 1 return result"},{"question":"def contains_cycle(n, adj_list): Given a directed graph represented as an adjacency list, determine if the graph contains a cycle. :param n: int, number of nodes :param adj_list: dict, adjacency list of the graph :return: bool, True if cycle exists, False otherwise >>> contains_cycle(6, {0: [1], 1: [2], 2: [0], 3: [4], 4: [5]}) True >>> contains_cycle(6, {0: [1], 1: [2], 2: [], 3: [4], 4: [5], 5: []}) False >>> contains_cycle(1, {0: []}) False >>> contains_cycle(2, {0: [1], 1: [0]}) True >>> contains_cycle(5, {0: [1], 1: [2], 2: [0], 3: [4], 4: [3]}) True >>> contains_cycle(5, {0: [1], 1: [2], 2: [], 3: [4], 4: []}) False >>> contains_cycle(7, {0: [1], 1: [2, 3], 2: [4], 3: [5], 4: [6], 5: [6], 6: [0]}) True","solution":"def contains_cycle(n, adj_list): Returns True if the graph contains at least one cycle, False otherwise. :param n: int, number of nodes :param adj_list: dict, adjacency list of the graph :return: bool, True if cycle exists, False otherwise def dfs(node, visited, rec_stack): # Mark the current node as visited and in recursion stack visited[node] = True rec_stack[node] = True # Recur for all neighbours for neighbour in adj_list.get(node, []): if not visited[neighbour]: # If not yet visited, recurse if dfs(neighbour, visited, rec_stack): return True elif rec_stack[neighbour]: # If visited and in rec_stack -> cycle return True # Remove the node from recursion stack rec_stack[node] = False return False # Mark all nodes as not visited visited = [False] * n rec_stack = [False] * n # Perform DFS from each node to detect cycle for node in range(n): if not visited[node]: # Only start a new DFS if the node has not been visited if dfs(node, visited, rec_stack): return True return False"},{"question":"def shift_right(arr: List[int], k: int) -> List[int]: Shifts the elements of the list \`arr\` to the right by \`k\` positions. Parameters: arr (list of int): The list of integers to be shifted. k (int): The number of positions to shift the elements. Returns: list of int: The shifted list of integers. >>> shift_right([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> shift_right([3, 8, 9, 7, 6], 3) [9, 7, 6, 3, 8] >>> shift_right([], 5) [] >>> shift_right([1, 2, 3], 0) [1, 2, 3] >>> shift_right([1, 2, 3], 1) [3, 1, 2]","solution":"def shift_right(arr, k): Shifts the elements of the list \`arr\` to the right by \`k\` positions. Parameters: arr (list of int): The list of integers to be shifted. k (int): The number of positions to shift the elements. Returns: list of int: The shifted list of integers. if not arr: return [] n = len(arr) # Ensure k is within the range of 0 to n-1 k = k % n return arr[-k:] + arr[:-k]"},{"question":"def is_permutation(s1: str, s2: str) -> bool: Checks if s1 is a permutation of s2. >>> is_permutation(\\"abc\\", \\"bca\\") True >>> is_permutation(\\"abcde\\", \\"edcba\\") True >>> is_permutation(\\"abc\\", \\"abd\\") False >>> is_permutation(\\"abc\\", \\"abcd\\") False >>> is_permutation(\\"\\", \\"\\") True >>> is_permutation(\\"a\\", \\"a\\") True >>> is_permutation(\\"a\\", \\"b\\") False","solution":"def is_permutation(s1: str, s2: str) -> bool: Checks if s1 is a permutation of s2. if len(s1) != len(s2): return False return sorted(s1) == sorted(s2)"},{"question":"from typing import List, Dict, Union def sort_fruits(fruits: List[Dict[str, Union[str, float]]]) -> List[Dict[str, Union[str, float]]]: Sorts an array of fruit objects first by their type (alphabetically), then by their weight in descending order. Examples: >>> fruits = [ >>> {'type': 'apple', 'weight': 1.2}, >>> {'type': 'banana', 'weight': 1.1}, >>> {'type': 'banana', 'weight': 1.3}, >>> {'type': 'apple', 'weight': 1.0} >>> ] >>> sort_fruits(fruits) >>> [ >>> {'type': 'apple', 'weight': 1.2}, >>> {'type': 'apple', 'weight': 1.0}, >>> {'type': 'banana', 'weight': 1.3}, >>> {'type': 'banana', 'weight': 1.1} >>> ] >>> fruits = [ >>> {'type': 'orange', 'weight': 0.5}, >>> {'type': 'orange', 'weight': 1.5}, >>> {'type': 'orange', 'weight': 1.0} >>> ] >>> sort_fruits(fruits) >>> [ >>> {'type': 'orange', 'weight': 1.5}, >>> {'type': 'orange', 'weight': 1.0}, >>> {'type': 'orange', 'weight': 0.5} >>> ] >>> fruits = [ >>> {'type': 'grapefruit', 'weight': 1.3}, >>> {'type': 'apple', 'weight': 1.3}, >>> {'type': 'banana', 'weight': 1.3} >>> ] >>> sort_fruits(fruits) >>> [ >>> {'type': 'apple', 'weight': 1.3}, >>> {'type': 'banana', 'weight': 1.3}, >>> {'type': 'grapefruit', 'weight': 1.3} >>> ] >>> fruits = [] >>> sort_fruits(fruits) >>> [] >>> fruits = [ >>> {'type': 'plum', 'weight': 0.8}, >>> {'type': 'plum', 'weight': 0.8}, >>> {'type': 'plum', 'weight': 0.8} >>> ] >>> sort_fruits(fruits) >>> [ >>> {'type': 'plum', 'weight': 0.8}, >>> {'type': 'plum', 'weight': 0.8}, >>> {'type': 'plum', 'weight': 0.8} >>> ]","solution":"from typing import List, Dict, Union def sort_fruits(fruits: List[Dict[str, Union[str, float]]]) -> List[Dict[str, Union[str, float]]]: Sorts an array of fruit objects first by their type (alphabetically), then by their weight in descending order. return sorted(fruits, key=lambda fruit: (fruit['type'], -fruit['weight']))"},{"question":"def solve_treasure_grid(test_cases): Calculate the largest area of treasure cells that can be found within a rectangular sub-section of the grid for multiple test cases. Parameters: test_cases (list): A list where each element is a tuple containing the grid (list of strings), number of rows (int), and number of columns (int). Returns: list: A list of integers corresponding to the largest area of treasure cells for each test case. >>> solve_treasure_grid([([\\".#..\\", \\"#..#\\", \\".#\\", \\"#..#\\"], 4, 4)]) [4] >>> solve_treasure_grid([([\\".\\", \\".\\", \\"#\\"], 3, 3)]) [1] pass Test cases: import pytest from solution import solve_treasure_grid def test_example(): test_cases = [([\\".#..\\", \\"#..#\\", \\".#\\", \\"#..#\\"], 4, 4), ([\\".\\", \\".\\", \\"#\\"], 3, 3)] expected_results = [4, 1] assert solve_treasure_grid(test_cases) == expected_results def test_single_row(): test_cases = [([\\".\\" * 5], 1, 5)] expected_results = [5] assert solve_treasure_grid(test_cases) == expected_results def test_single_column(): test_cases = [([\\".\\", \\"#\\", \\".\\", \\".\\", \\".\\"], 5, 1)] expected_results = [3] assert solve_treasure_grid(test_cases) == expected_results def test_no_treasure(): test_cases = [([\\"\\", \\"\\", \\"\\"], 3, 4)] expected_results = [0] assert solve_treasure_grid(test_cases) == expected_results def test_full_treasure(): test_cases = [([\\"....\\", \\"....\\", \\"....\\"], 3, 4)] expected_results = [12] assert solve_treasure_grid(test_cases) == expected_results if __name__ == \\"__main__\\": pytest.main()","solution":"def max_histogram_area(histogram): Calculate the maximum rectangular area in the histogram (a list of non-negative integers). stack = [] max_area = 0 index = 0 while index < len(histogram): # Push current bar onto stack if it is higher than bar at stack top if not stack or histogram[index] >= histogram[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with histogram[top_of_stack] as the smallest bar area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area max_area = max(max_area, area) # Calculate area for remaining bars in stack while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def largest_treasure_area(grid, N, M): Calculate the largest rectangular area with treasures ('.') in the 2D grid. if N == 0 or M == 0: return 0 # Initialize the heights array heights = [0] * M largest_area = 0 for row in grid: for col in range(M): if row[col] == '.': heights[col] += 1 else: heights[col] = 0 # Calculate the maximum area with the histogram heights largest_area = max(largest_area, max_histogram_area(heights)) return largest_area def solve_treasure_grid(test_cases): results = [] for grid, N, M in test_cases: result = largest_treasure_area(grid, N, M) results.append(result) return results"},{"question":"def maxCoins(grid): Returns the maximum number of coins collected from top-left to bottom-right of the grid. You can only move down or to the right at any point in time. >>> grid = [ ... [0, 3, 1, 1], ... [2, 0, 0, 4], ... [1, 5, 3, 1] ... ] >>> maxCoins(grid) 12 >>> grid = [ ... [0, 3, 1, 1] ... ] >>> maxCoins(grid) 5 >>> grid = [ ... [0], ... [3], ... [1], ... [1] ... ] >>> maxCoins(grid) 5 >>> grid = [ ... [42] ... ] >>> maxCoins(grid) 42 >>> grid = [ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ] >>> maxCoins(grid) 0 pass","solution":"def maxCoins(grid): Returns the maximum number of coins collected from top-left to bottom-right of the grid. You can only move down or to the right at any point in time. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Create a 2D array to store the maximum number of coins collected upto each cell dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the maximum number of coins collected return dp[rows-1][cols-1]"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Calculate the largest rectangular area that can be formed within the bounds of the given histogram. :param heights: List[int], A list of integers representing the heights of bars in a histogram :return: int, The largest rectangular area >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([5]) 5 >>> largest_rectangle_area([3, 3, 3, 3]) 12 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9","solution":"def largest_rectangle_area(heights): Calculate the largest rectangular area that can be formed within the bounds of the given histogram. :param heights: List[int], A list of integers representing the heights of bars in a histogram :return: int, The largest rectangular area stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List def is_balanced(s: str) -> bool: Given a string, it is considered a \\"balanced\\" string if the number of occurrences of each character is the same. This function checks if the input string is balanced. >>> is_balanced(\\"aabb\\") True >>> is_balanced(\\"aabbcc\\") True >>> is_balanced(\\"abcabc\\") True >>> is_balanced(\\"aabbccc\\") False >>> is_balanced(\\"a\\") True >>> is_balanced(\\"\\") False >>> is_balanced(\\"zzzzzzzz\\") True >>> is_balanced(\\"ab\\") True >>> is_balanced(\\"aaabbbcccaaa\\") False","solution":"def is_balanced(s): Returns True if the input string is balanced, False otherwise. A string is considered balanced if each character appears the same number of times. from collections import Counter if not s: return False char_count = Counter(s) counts = set(char_count.values()) return len(counts) == 1"},{"question":"def snailPath(matrix): Determines if there is a path for a snail to navigate from the top-left to the bottom-right corner of a 2D grid. The snail can only move through cells that contain the value \`1\` and can only travel in four directions: up, down, left, and right. Example: >>> matrix = [ ... [1, 0, 0, 1], ... [1, 1, 0, 0], ... [0, 1, 1, 0], ... [1, 0, 1, 1] ... ] >>> snailPath(matrix) True Test Cases: >>> matrix1 = [ ... [1, 1, 1], ... [0, 0, 1], ... [1, 1, 1] ... ] >>> snailPath(matrix1) True >>> matrix2 = [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ] >>> snailPath(matrix2) False >>> matrix3 = [ ... [1, 0, 1], ... [1, 1, 1], ... [0, 0, 1], ... [1, 1, 1] ... ] >>> snailPath(matrix3) True >>> matrix4 = [[1]] >>> snailPath(matrix4) True >>> matrix5 = [[0]] >>> snailPath(matrix5) False >>> matrix6 = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> snailPath(matrix6) False >>> matrix7 = [ ... [1, 0, 1, 1, 1], ... [1, 1, 0, 0, 1], ... [1, 0, 0, 1, 0], ... [1, 1, 1, 1, 1] ... ] >>> snailPath(matrix7) True >>> matrix8 = [[1, 1, 1, 1, 1]] >>> snailPath(matrix8) True >>> matrix9 = [[1], [1], [1], [1], [1]] >>> snailPath(matrix9) True","solution":"def snailPath(matrix): rows, cols = len(matrix), len(matrix[0]) if matrix[0][0] == 0 or matrix[rows-1][cols-1] == 0: return False def dfs(row, col, visited): if row == rows - 1 and col == cols - 1: return True visited.add((row, col)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and matrix[new_row][new_col] == 1: if dfs(new_row, new_col, visited): return True return False visited = set() return dfs(0, 0, visited)"},{"question":"class LRUCache: Implement an LRU Cache. An LRU Cache has two main operations: - get(key): Return the value of the key if it exists in the cache, otherwise return -1 - put(key, value): Insert or update the value of the key. If the cache exceeds its capacity, invalidate the least recently used item. Example Usage: >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) # returns 1 >>> cache.put(3, 3) # evicts key 2 >>> cache.get(2) # returns -1 (not found) def __init__(self, capacity: int): Initialize the LRU cache with a positive capacity. # Your implementation here def get(self, key: int) -> int: Retrieve the value of the key if found in the cache, otherwise return -1. # Your implementation here def put(self, key: int, value: int) -> None: Insert the value if the key is not already present. If the cache reaches its capacity, invalidate the least recently used item before inserting the new item. # Your implementation here # Unit Tests def test_get_existing_item(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # should return 1 def test_get_nonexisting_item(): cache = LRUCache(2) assert cache.get(3) == -1 # should return -1 because 3 is not present in cache def test_put_updates_order(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.get(1) cache.put(3, 3) assert cache.get(2) == -1 # should return -1 because 2 has been evicted def test_put_eviction(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) assert cache.get(1) == -1 # should return -1 because 1 has been evicted def test_cache_capacity(): cache = LRUCache(1) cache.put(1, 1) assert cache.get(1) == 1 # should return 1 cache.put(2, 2) assert cache.get(1) == -1 # should return -1 because 1 has been evicted assert cache.get(2) == 2 # should return 2 def test_update_value(): cache = LRUCache(2) cache.put(1, 1) cache.put(1, 2) assert cache.get(1) == 2 # should return 2 because it was updated","solution":"class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.order = [] def get(self, key: int) -> int: if key in self.cache: self.order.remove(key) self.order.append(key) return self.cache[key] else: return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.capacity: lru = self.order.pop(0) del self.cache[lru] self.cache[key] = value self.order.append(key)"},{"question":"def min_partition_difference(arr): Returns the minimum difference possible between the sums of two parts of the array. >>> min_partition_difference([1, 6, 11, 5]) 1 >>> min_partition_difference([10, 20, 15]) 5 >>> min_partition_difference([1, 2, 3, 9]) 3 >>> min_partition_difference([1, 2, 3, 4, 5, 6, 7, 8, 9]) 1 >>> min_partition_difference([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) 0 >>> min_partition_difference([1]) 1 pass def process_cases(T, cases): Processes multiple test cases and returns results for each case. >>> cases = [ ... (4, [1, 6, 11, 5]), ... (3, [10, 20, 15]) ... ] >>> process_cases(2, cases) [1, 5] >>> cases = [ ... (4, [1, 2, 3, 9]), ... (4, [1, 1, 1, 1]) ... ] >>> process_cases(2, cases) [3, 0] >>> cases = [ ... (2, [2, 3, 7, 10]) ... ] >>> process_cases(1, cases) [2] pass def test_min_partition_difference(): # Test cases from the example assert min_partition_difference([1, 6, 11, 5]) == 1 assert min_partition_difference([10, 20, 15]) == 5 # Additional test cases assert min_partition_difference([1, 2, 3, 9]) == 3 assert min_partition_difference([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 1 assert min_partition_difference([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 0 assert min_partition_difference([1]) == 1 def test_process_cases(): cases = [ (4, [1, 6, 11, 5]), (3, [10, 20, 15]) ] assert process_cases(2, cases) == [1, 5] cases = [ (4, [1, 2, 3, 9]), (4, [1, 1, 1, 1]) ] assert process_cases(2, cases) == [3, 0] cases = [ (2, [2, 3, 7, 10]) ] assert process_cases(1, cases) == [2]","solution":"def min_partition_difference(arr): Returns the minimum difference possible between the sums of two parts of the array. total_sum = sum(arr) n = len(arr) # Initialize a boolean DP array dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] # Initialize dp[i][0] = True for all i, because zero sum is possible with all subsets. for i in range(n + 1): dp[i][0] = True # Fill dp array for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if arr[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j - arr[i-1]] else: dp[i][j] = dp[i-1][j] # Find the maximum value of j such that dp[n][j] is True, which means a subset with sum j is possible for j in range(total_sum // 2, -1, -1): if dp[n][j]: break diff = total_sum - 2 * j return diff def process_cases(T, cases): results = [] for i in range(T): N = cases[i][0] array = cases[i][1] result = min_partition_difference(array) results.append(result) return results"},{"question":"def min_operations_to_balance(S: str) -> int: Calculate the minimum number of operations required to make both S1 and S2 balanced. A string S is considered balanced if the number of occurrences of the characters 'X' and 'Y' are the same. Given an initially empty strings S1 and S2, you are allowed to perform the following operations any number of times: 1. Append 'X' to either S1 or S2. 2. Append 'Y' to either S1 or S2. Return the minimum number of operations required to make both S1 and S2 balanced. >>> min_operations_to_balance(\\"XXYY\\") 0 >>> min_operations_to_balance(\\"XXXY\\") 2 >>> min_operations_to_balance(\\"XYXYXY\\") 0 >>> min_operations_to_balance(\\"XYXXY\\") 1 >>> min_operations_to_balance(\\"X\\") 1 >>> min_operations_to_balance(\\"Y\\") 1 >>> min_operations_to_balance(\\"\\") 0","solution":"def min_operations_to_balance(S): count_X = S.count('X') count_Y = S.count('Y') if count_X == count_Y: return 0 else: return abs(count_X - count_Y) # The function above calculates the minimum number of operations needed to make both strings balanced. # Since appending 'X' or 'Y' can be done any number of times on either S1 or S2, # we need to find out the difference between count of 'X' and 'Y', as they need to be equal for both strings to be balanced."},{"question":"def flatten_array(arr): Flattens a nested array into a single-level array. Args: - arr: list of nested lists Returns: - list: a single-level list with all elements >>> flatten_array([1, [2, 3], [4, [5, 6, [7]]]]) [1, 2, 3, 4, 5, 6, 7] >>> flatten_array([]) [] >>> flatten_array([1]) [1] >>> flatten_array([1, [2, 3]]) [1, 2, 3] >>> flatten_array([[1, [2, [3, [4]]]], 5]) [1, 2, 3, 4, 5] >>> flatten_array([\\"a\\", [\\"b\\", \\"c\\"], [4.5, [\\"d\\", 6, [\\"e\\"]]]]) [\\"a\\", \\"b\\", \\"c\\", 4.5, \\"d\\", 6, \\"e\\"]","solution":"def flatten_array(arr): Flattens a nested array into a single-level array. Args: - arr: list of nested lists Returns: - list: a single-level list with all elements flattened_list = [] def _flatten(sub_arr): for el in sub_arr: if isinstance(el, list): _flatten(el) else: flattened_list.append(el) _flatten(arr) return flattened_list"},{"question":"from typing import List def count_unique_elements(nums: List[int], k: int) -> int: Returns the number of unique elements that appear at least k times in nums. >>> count_unique_elements([1, 2, 3, 1, 2, 3, 1, 2, 3], 2) 3 >>> count_unique_elements([1, 2, 2, 3, 3, 3, 4], 2) 2 >>> count_unique_elements([1, 2, 3, 4], 2) 0","solution":"def count_unique_elements(nums, k): Returns the number of unique elements that appear at least k times in nums. from collections import Counter freq = Counter(nums) return sum(1 for count in freq.values() if count >= k)"},{"question":"def trap_rain_water(heights: List[int]) -> int: Calculate the total volume of water that would be trapped between the buildings. >>> trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap_rain_water([4,2,0,3,2,5]) == 9 >>> trap_rain_water([1,0,1]) == 1","solution":"def trap_rain_water(heights): Calculate the total volume of water that would be trapped between the buildings. :param heights: List of integers representing the heights of buildings. :return: Total volume of trapped water. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def calculate_percentiles(scores: List[int]) -> List[int]: This function takes a list of integer scores and returns a list of percentile scores. >>> calculate_percentiles([30, 40, 70, 80, 100]) [20, 40, 60, 80, 100] >>> calculate_percentiles([50]) [100] >>> calculate_percentiles([50, 50, 50, 50, 50]) [100, 100, 100, 100, 100] >>> calculate_percentiles([0, 0, 0, 0, 0]) [100, 100, 100, 100, 100] >>> calculate_percentiles([0, 25, 50, 75, 100]) [20, 40, 60, 80, 100] >>> calculate_percentiles([100, 0, 50, 25, 75]) [100, 20, 60, 40, 80] >>> calculate_percentiles([25, 75]) [50, 100] pass","solution":"def calculate_percentiles(scores): This function takes a list of integer scores and returns a list of percentile scores. n = len(scores) sorted_scores = sorted(scores) percentile_map = {} for rank, score in enumerate(sorted_scores): percentile_map[score] = round(((rank + 1) / n) * 100) percentiles = [percentile_map[score] for score in scores] return percentiles"},{"question":"def reverse_and_square(nums: List[int]) -> List[int]: Returns a list containing the square values of the integers but in reverse order of how they appeared in the input list. >>> reverse_and_square([1, 2, 3, 4, 5]) == [25, 16, 9, 4, 1] >>> reverse_and_square([10, -3, 7, 6]) == [36, 49, 9, 100] >>> reverse_and_square([0]) == [0] :param nums: List of integers :return: List of integers squared and reversed","solution":"def reverse_and_square(nums): Returns a list containing the square values of nums in reverse order. :param nums: List of integers :return: List of integers squared and reversed return [x ** 2 for x in reversed(nums)]"},{"question":"def min_travel_cost(N: int, costs: List[int]) -> int: Calculate the minimum travel cost from the first city to the last city. Parameters: N (int): Number of cities. costs (List[int]): List of travel costs between adjacent cities. Returns: int: Minimum travel cost from the first city to the last city. >>> min_travel_cost(5, [4, 1, 3, 2]) 10 >>> min_travel_cost(2, [5]) 5 >>> min_travel_cost(3, [100000, 100000]) 200000 >>> min_travel_cost(4, [2, 2, 2]) 6 >>> min_travel_cost(6, [3, 5, 8, 13, 21]) 50","solution":"def min_travel_cost(N, costs): Calculates the minimum travel cost from the first city to the last city. Parameters: N (int): Number of cities. costs (List[int]): List of travel costs between adjacent cities. Returns: int: Minimum travel cost from the first city to the last city. return sum(costs)"},{"question":"def string_combiner(list_of_strings, n): Write a function string_combiner(list_of_strings, n) that takes in a list of strings list_of_strings, and an integer n, and returns a new list where every n strings are combined into a single string. Parameters: list_of_strings (list): A list of strings. n (int): The number of strings to combine. Returns: list: A list with combined strings. Example: string_combiner([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\"], 2) -> [\\"ab\\", \\"cd\\", \\"ef\\"] string_combiner([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], 3) -> [\\"abc\\", \\"d\\"] string_combiner([\\"a\\", \\"b\\", \\"c\\"], 5) -> [\\"abc\\"] string_combiner([\\"a\\"], 1) -> [\\"a\\"]","solution":"def string_combiner(list_of_strings, n): Write a function string_combiner(list_of_strings, n) that takes in a list of strings list_of_strings, and an integer n, and returns a new list where every n strings are combined into a single string. Parameters: list_of_strings (list): A list of strings. n (int): The number of strings to combine. Returns: list: A list with combined strings. Example: string_combiner([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\"], 2) -> [\\"ab\\", \\"cd\\", \\"ef\\"] string_combiner([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], 3) -> [\\"abc\\", \\"d\\"] string_combiner([\\"a\\", \\"b\\", \\"c\\"], 5) -> [\\"abc\\"] string_combiner([\\"a\\"], 1) -> [\\"a\\"] combined_strings = [] temp_string = \\"\\" for i, s in enumerate(list_of_strings): temp_string += s if (i + 1) % n == 0: combined_strings.append(temp_string) temp_string = \\"\\" if temp_string: combined_strings.append(temp_string) return combined_strings"},{"question":"def custom_fibonacci(a: int, b: int, n: int) -> list: Generates a modified Fibonacci sequence starting with \`a\` and \`b\` of length \`n\`. Parameters: a (int): The first number in the sequence. b (int): The second number in the sequence. n (int): The length of the sequence to generate. Returns: list: A list containing the first \`n\` numbers of the modified Fibonacci sequence. Examples: >>> custom_fibonacci(2, 3, 5) [2, 3, 5, 8, 13] >>> custom_fibonacci(5, 5, 7) [5, 5, 10, 15, 25, 40, 65] >>> custom_fibonacci(0, 1, 10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def custom_fibonacci(a, b, n): Generates a modified Fibonacci sequence starting with \`a\` and \`b\` of length \`n\`. Parameters: a (int): The first number in the sequence. b (int): The second number in the sequence. n (int): The length of the sequence to generate. Returns: list: A list containing the first \`n\` numbers of the modified Fibonacci sequence. if n == 1: return [a] elif n == 2: return [a, b] sequence = [a, b] for _ in range(2, n): next_val = sequence[-1] + sequence[-2] sequence.append(next_val) return sequence"},{"question":"def char_frequency(s: str) -> List[Tuple[str, int]]: Computes the frequency of each character and digit in the string s and returns a list of tuples sorted by the ASCII values. >>> char_frequency(\\"a3b2c3a1d9e0\\") [('0', 1), ('1', 1), ('2', 1), ('3', 2), ('9', 1), ('a', 2), ('b', 1), ('c', 1), ('d', 1), ('e', 1)] >>> char_frequency(\\"abcd\\") [('a', 1), ('b', 1), ('c', 1), ('d', 1)]","solution":"def char_frequency(s): Computes the frequency of each character and digit in the string s and returns a list of tuples sorted by the ASCII values. # Using a dictionary to store frequencies of characters and digits freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 # Sort the dictionary keys based on their ASCII values and return sorted_freq = sorted(freq.items()) return sorted_freq"},{"question":"def is_palindrome(x: int) -> bool: Determines whether a given integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Negative numbers are not considered palindromes. >>> is_palindrome(121) == True >>> is_palindrome(-121) == False >>> is_palindrome(10) == False >>> is_palindrome(0) == True >>> is_palindrome(12321) == True pass # Unit Tests def test_positive_palindrome(): assert is_palindrome(121) == True assert is_palindrome(12321) == True def test_positive_non_palindrome(): assert is_palindrome(123) == False assert is_palindrome(10) == False def test_negative_numbers(): assert is_palindrome(-121) == False assert is_palindrome(-12321) == False def test_single_digit(): assert is_palindrome(0) == True assert is_palindrome(5) == True def test_larger_numbers(): assert is_palindrome(1001) == True assert is_palindrome(1002) == False assert is_palindrome(12345678987654321) == True def test_edge_cases(): assert is_palindrome(2147447412) == True assert is_palindrome(2147483647) == False","solution":"def is_palindrome(x: int) -> bool: Returns True if the integer x is a palindrome, False otherwise. A palindrome reads the same backward as forward. Negative numbers are not considered palindromes. if x < 0: return False original = x reversed_num = 0 while x != 0: digit = x % 10 reversed_num = reversed_num * 10 + digit x //= 10 return original == reversed_num"},{"question":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Calculate the number of unique paths for a robot to navigate a grid with obstacles. Args: grid (List[List[int]]): A 2D list representing the grid with obstacles (1) and free spaces (0). Returns: int: The number of unique paths from the top-left to the bottom-right corner of the grid. Examples: >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> unique_paths_with_obstacles(grid) 2 >>> grid = [ ... [0, 1], ... [0, 0] ... ] >>> unique_paths_with_obstacles(grid) 1 pass def test_no_obstacles(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 6 def test_with_obstacles(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 2 def test_start_obstacle(): grid = [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 0 def test_end_obstacle(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 1] ] assert unique_paths_with_obstacles(grid) == 0 def test_single_cell_free(): grid = [ [0] ] assert unique_paths_with_obstacles(grid) == 1 def test_single_cell_obstacle(): grid = [ [1] ] assert unique_paths_with_obstacles(grid) == 0","solution":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: m = len(grid) n = len(grid[0]) # If the start or end point is an obstacle, return 0 as there is no valid path if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Create a DP table to store the number of unique paths to each cell dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = 1 # Fill in the values for the first column for i in range(1, m): if grid[i][0] == 0: dp[i][0] = dp[i-1][0] # Fill in the values for the first row for j in range(1, n): if grid[0][j] == 0: dp[0][j] = dp[0][j-1] # Fill in the DP table by checking from top to bottom, left to right for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def solve(arr): Takes an array of integers and returns the sum of the integers with odd indices, multiplied by the last element of the array. If the input array is empty, return 0. >>> solve([1, 2, 3, 4, 5]) 30 >>> solve([7, 1, 8, 2, 3]) 9 >>> solve([1, 2, 3, 4]) 24 >>> solve([1, 0, 1, 0, 1]) 0 >>> solve([]) 0 >>> solve([10]) 0 >>> solve([10, 20]) 400 >>> solve([1000000000, 2000000000, 3000000000, 4000000000]) 24000000000000000000","solution":"def solve(arr): Takes an array of integers and returns the sum of integers with odd indices, multiplied by the last element of the array. If the input array is empty, return 0. if not arr: return 0 sum_odd_indices = sum(arr[i] for i in range(1, len(arr), 2)) return sum_odd_indices * arr[-1]"},{"question":"def most_frequent_bird(n: int, bird_observations: List[int]) -> int: Monica loves watching birds and likes to keep track of the different species she observes. She has a list of bird observations where each observation is a bird ID corresponding to the species. She wants to find out which bird species she has seen the most frequently. If multiple species have the same highest frequency, Monica prefers the species with the smallest ID number. >>> most_frequent_bird(6, [1, 4, 4, 4, 5, 3]) 4 >>> most_frequent_bird(8, [2, 2, 3, 3, 4, 4, 5, 5]) 2","solution":"def most_frequent_bird(n, bird_observations): from collections import Counter bird_count = Counter(bird_observations) most_frequent = max(bird_count.values()) most_frequent_birds = [bird for bird in bird_count if bird_count[bird] == most_frequent] return min(most_frequent_birds)"},{"question":"def minimal_cost(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the minimal number of operations required to make all elements of the array equal for each test case. Parameters: T (int): Number of test cases test_cases (list of tuples): A list where each tuple contains an integer n and a list of n integers Returns: list of int: A list containing the minimal number of operations for each test case from typing import List, Tuple def test_minimal_cost_example_cases(): assert minimal_cost(3, [(3, [1, 2, 3]), (5, [5, 5, 5, 5, 5]), (4, [-1, 2, -2, 4])]) == [2, 0, 9] def test_minimal_cost_all_equal(): assert minimal_cost(2, [(5, [7, 7, 7, 7, 7]), (3, [-5, -5, -5])]) == [0, 0] def test_minimal_cost_large_range(): assert minimal_cost(1, [(4, [-1000000000, 1000000000, -1000000000, 1000000000])]) == [4000000000] def test_minimal_cost_two_elements(): assert minimal_cost(1, [(2, [1, 1000000000])]) == [999999999] def test_minimal_cost_single_element(): assert minimal_cost(2, [(1, [42]), (1, [-999999999])]) == [0, 0] def test_minimal_cost_median_middle(): assert minimal_cost(1, [(7, [1, 2, 3, 4, 5, 6, 7])]) == [12]","solution":"def minimal_cost(T, test_cases): Returns the minimal number of operations required to make all elements of the array equal for each test case. Parameters: T (int): Number of test cases test_cases (list of tuples): A list where each tuple contains an integer n and a list of n integers Returns: list of int: A list containing the minimal number of operations for each test case results = [] for case in test_cases: n, array = case array.sort() median = array[n // 2] # optimal target sum is the median to minimize total operations cost = 0 for num in array: cost += abs(num - median) results.append(cost) return results"},{"question":"def is_prime(n: int) -> bool: Determines if a given integer n is a prime number. Args: n (int): The integer to be checked for primality. Returns: bool: True if n is a prime number, False otherwise. Examples: >>> is_prime(5) True >>> is_prime(4) False >>> is_prime(2) True >>> is_prime(11) True >>> is_prime(15) False from solution import is_prime def test_prime_number(): assert is_prime(5) == True assert is_prime(2) == True assert is_prime(11) == True def test_not_prime_number(): assert is_prime(4) == False assert is_prime(15) == False assert is_prime(1) == False def test_negative_number(): assert is_prime(-3) == False def test_large_prime_number(): assert is_prime(104729) == True def test_large_non_prime_number(): assert is_prime(104728) == False","solution":"def is_prime(n): Determines if a given integer n is a prime number. Args: n (int): The integer to be checked for primality. Returns: bool: True if n is a prime number, False otherwise. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True"},{"question":"def move_k_greatest(nums: List[int], k: int) -> List[int]: Move the k greatest elements in the nums array to the beginning of the array without changing their relative order. >>> move_k_greatest([4, 5, 1, 3, 2], 2) [5, 4, 1, 3, 2] >>> move_k_greatest([10, 9, 8, 7, 6], 3) [10, 9, 8, 7, 6] >>> move_k_greatest([3], 1) [3] >>> move_k_greatest([2, 1], 2) [2, 1] >>> move_k_greatest([1, 2, 4, 5, 3], 3) [5, 4, 3, 1, 2] >>> move_k_greatest([100, 300, 200, 400], 3) [400, 300, 200, 100]","solution":"def move_k_greatest(nums, k): Moves the k greatest elements to the beginning of the array without changing their relative order. # Step 1: Find the k greatest elements k_greatest = sorted(nums, reverse=True)[:k] # Step 2: Iterate through original list and create a new list with the k greatest elements first k_greatest_set = set(k_greatest) remaining_elements = [num for num in nums if num not in k_greatest_set] result = k_greatest + remaining_elements return result # Example usage: # nums = [4, 5, 1, 3, 2] # k = 2 # print(move_k_greatest(nums, k)) # Output: [5, 4, 1, 3, 2]"},{"question":"def battleship_simulation(ships, attacks): Simulate a simplified version of the \\"Battleship\\" game on a 5x5 grid. Given a 5x5 grid and a list of ship coordinates, determine the result of a list of attacks. Ships are represented by the letter 'S' and attacks will be represented by their coordinates. Returns one of these three possible outcomes as a string: - \`You sunk all battleships\` - \`Misses: X, Hits: Y\` - \`Congratulations! All ships destroyed after N attacks\` Args: ships: List[Tuple[int, int]] - list of tuples containing ship coordinates. attacks: List[Tuple[int, int]] - list of tuples containing attack coordinates. Example: >>> battleship_simulation([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)], [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]) \\"Congratulations! All ships destroyed after 5 attacks\\" >>> battleship_simulation([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)], [(0, 0), (0, 1), (1, 1), (1, 2), (4, 4)]) \\"Misses: 2, Hits: 3\\" >>> battleship_simulation([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)], [(0, 1), (1, 2), (3, 4), (4, 3)]) \\"Misses: 4, Hits: 0\\" >>> battleship_simulation([(0, 0), (1, 1), (2, 2)], [(0, 0), (3, 3), (1, 1), (4, 4), (2, 2)]) \\"Congratulations! All ships destroyed after 5 attacks\\" >>> battleship_simulation([(0, 0), (2, 2)], [(0, 0), (2, 2), (0, 0)]) \\"Congratulations! All ships destroyed after 2 attacks\\" # Your implementation here","solution":"def battleship_simulation(ships, attacks): ship_set = set(ships) hits = 0 misses = 0 for i, attack in enumerate(attacks): if attack in ship_set: hits += 1 ship_set.remove(attack) if len(ship_set) == 0: return f\\"Congratulations! All ships destroyed after {i + 1} attacks\\" else: misses += 1 return f\\"Misses: {misses}, Hits: {hits}\\""},{"question":"def can_alice_always_win(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determine if Alice can always find a sub-array such that her sum is greater than Bob's sum, irrespective of the sub-array Bob picks. Args: T: The number of test cases. test_cases: A list of tuples, each containing: - N: The number of elements in the array. - L: The length of the sub-arrays Alice and Bob will pick. - Array: A list of integers representing the array. Returns: A list of strings \\"YES\\" or \\"NO\\", for each test case respectively. Example: >>> can_alice_always_win(2, [(5, 2, [1, 2, 3, 4, 5]), (4, 2, [1, 1, 1, 1])]) [\\"YES\\", \\"NO\\"] >>> can_alice_always_win(1, [(6, 3, [1, -1, 1, -1, 1, -1])]) [\\"NO\\"] >>> can_alice_always_win(1, [(6, 2, [10, 2, 3, 4, 100, 6])]) [\\"YES\\"] >>> can_alice_always_win(2, [(3, 1, [2, 1, 4]), (4, 1, [-1, -2, -3, -4])]) [\\"YES\\", \\"NO\\"] pass","solution":"def can_alice_always_win(T, test_cases): results = [] for case in test_cases: N, L, array = case prefix_sums = [0] * (N + 1) for i in range(N): prefix_sums[i+1] = prefix_sums[i] + array[i] max_subarray_sum = float('-inf') min_subarray_sum = float('inf') for i in range(N - L + 1): subarray_sum = prefix_sums[i + L] - prefix_sums[i] if i + L <= N / 2: min_subarray_sum = min(min_subarray_sum, subarray_sum) else: max_subarray_sum = max(max_subarray_sum, subarray_sum) if max_subarray_sum > min_subarray_sum: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Returns the maximum rectangular area that can be formed in the skyline. >>> largest_rectangle_area([2,1,5,6,2,3]) == 10 >>> largest_rectangle_area([2,4]) == 4 >>> largest_rectangle_area([1]) == 1 >>> largest_rectangle_area([1, 2, 3, 4, 5, 6]) == 12 >>> largest_rectangle_area([3, 3, 3, 3, 3]) == 15 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) == 12 >>> large_input = [1] * 100000 >>> largest_rectangle_area(large_input) == 100000","solution":"def largest_rectangle_area(heights): Returns the maximum rectangular area that can be formed in the skyline. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def numDistinct(s: str, t: str) -> int: Returns the number of distinct subsequences of s that equal t. >>> numDistinct(\\"rabbbit\\", \\"rabbit\\") 3 >>> numDistinct(\\"babgbag\\", \\"bag\\") 5","solution":"def numDistinct(s, t): Returns the number of distinct subsequences of s that equal t. m, n = len(s), len(t) if n == 0: return 1 if m == 0: return 0 # dp[i][j] will be storing the count of subsequences of s[0..i-1] in t[0..j-1] dp = [[0] * (n + 1) for _ in range(m + 1)] # Initializing the first column, when t is an empty subsequence for i in range(m + 1): dp[i][0] = 1 for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] return dp[m][n]"},{"question":"def book_arrangement_pattern(T: int, test_cases: List[int]) -> List[List[str]]: Generate the book arrangement pattern for each test case. >>> book_arrangement_pattern(2, [3, 4]) [['1', '2 3', '4 5 6'], ['1', '2 3', '4 5 6', '7 8 9 10']] >>> book_arrangement_pattern(1, [1]) [['1']]","solution":"def book_arrangement_pattern(T, test_cases): Generate the book arrangement pattern for each test case. results = [] for N in test_cases: current_number = 1 arrangement = [] for i in range(1, N+1): line = ' '.join(str(current_number + j) for j in range(i)) arrangement.append(line) current_number += i results.append(arrangement) return results"},{"question":"def rotate_array(nums: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([-1, -100, 3, 99], 2) [3, 99, -1, -100] >>> rotate_array([1, 2, 3], 4) [3, 1, 2]","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. n = len(nums) k = k % n # to handle cases where k > n # Rotate the array using slicing rotated_array = nums[-k:] + nums[:-k] return rotated_array"},{"question":"def min_changes_to_passable(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given t test cases, return the minimum number of changes required to make each checkpoint array passable. Parameters: t (int): The number of test cases. test_cases (list of tuples): Each tuple contains an integer n (length of the checkpoint array) and a list a of n integers (checkpoint array elements). Returns: list of int: The minimum number of changes required for each test case. Example: >>> min_changes_to_passable(3, [(5, [0, 1, 0, 1, 0]), (3, [1, 1, 1]), (6, [0, 0, 0, 1, 0, 1])]) [2, 3, 2] >>> min_changes_to_passable(1, [(4, [0, 0, 0, 0])]) [0]","solution":"def min_changes_to_passable(t, test_cases): Given t test cases, return the minimum number of changes required to make each checkpoint array passable. Parameters: t (int): The number of test cases. test_cases (list of tuples): Each tuple contains an integer n (length of the checkpoint array) and a list a of n integers (checkpoint array elements). Returns: list of int: The minimum number of changes required for each test case. results = [] for n, a in test_cases: # Count the number of 1's in the array min_changes = sum(a) results.append(min_changes) return results # Example usage: # t = 3 # test_cases = [ # (5, [0, 1, 0, 1, 0]), # (3, [1, 1, 1]), # (6, [0, 0, 0, 1, 0, 1]) # ] # print(min_changes_to_passable(t, test_cases)) # Output: [2, 3, 2]"},{"question":"from typing import List def manipulate_array(arr: List[int], operation: str, k: int = 0) -> List[int]: Perform specific manipulations on a given array. Supported operations: - Rotate array to the right by \`k\` steps. - Rotate array to the left by \`k\` steps. - Reverse the order of the array. - Create a new array where each element is the sum of consecutive pairs in the original array. Parameters: arr (List[int]): the array to manipulate operation (str): the operation to perform (\\"rotate_right\\", \\"rotate_left\\", \\"reverse\\", \\"sum_pairs\\") k (int): the number of steps to rotate (when applicable) Returns: List[int]: the manipulated array Examples: >>> manipulate_array([1, 2, 3, 4, 5], \\"rotate_right\\", 2) [4, 5, 1, 2, 3] >>> manipulate_array([1, 2, 3, 4, 5], \\"rotate_left\\", 2) [3, 4, 5, 1, 2] >>> manipulate_array([1, 2, 3, 4, 5], \\"reverse\\") [5, 4, 3, 2, 1] >>> manipulate_array([1, 2, 3, 4, 5], \\"sum_pairs\\") [3, 7, 5] pass","solution":"from typing import List def manipulate_array(arr: List[int], operation: str, k: int = 0) -> List[int]: n = len(arr) if operation == \\"rotate_right\\": k = k % n return arr[-k:] + arr[:-k] elif operation == \\"rotate_left\\": k = k % n return arr[k:] + arr[:k] elif operation == \\"reverse\\": return arr[::-1] elif operation == \\"sum_pairs\\": result = [] for i in range(0, n, 2): if i + 1 < n: result.append(arr[i] + arr[i + 1]) else: # when length is odd, pair the last element with zero result.append(arr[i]) return result else: raise ValueError(\\"Unsupported operation.\\")"},{"question":"def top_k_competitors(nums: List[int], k: int) -> List[int]: Returns the indices of the top k competitors based on their scores. If there is a tie in scores, competitors are sorted by their index in ascending order. >>> top_k_competitors([50, 60, 70, 60, 80], 3) [4, 2, 1] >>> top_k_competitors([10, 20, 20, 30, 40], 2) [4, 3] >>> top_k_competitors([5, 5, 5, 5, 5], 1) [0] >>> top_k_competitors([50, 50, 50, 40, 30], 4) [0, 1, 2, 3] >>> top_k_competitors([100], 1) [0]","solution":"def top_k_competitors(nums, k): Returns the indices of the top k competitors based on their scores. If there is a tie in scores, competitors are sorted by their index in ascending order. # Combine scores with their indices indexed_scores = list(enumerate(nums)) # Sort the list based on the scores in descending order, # and by index in ascending order in case of a tie indexed_scores.sort(key=lambda x: (-x[1], x[0])) # Extract the indices of the top \`k\` competitors top_k_indices = [indexed_scores[i][0] for i in range(k)] return top_k_indices"},{"question":"def remove_duplicates(nums: List[int]) -> List[int]: Returns a new list containing only the unique elements from the original list, in the order of their first occurrence. Example: >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([4, 5, 4, 4, 5, 3]) [4, 5, 3] >>> remove_duplicates([1, 2, 3, 1, 2, 3]) [1, 2, 3]","solution":"def remove_duplicates(nums): Returns a new list containing only the unique elements from the original list, in the order of their first occurrence. seen = set() unique_nums = [] for num in nums: if num not in seen: seen.add(num) unique_nums.append(num) return unique_nums"},{"question":"from typing import List, Tuple def find_distinct_islands(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Given the number of test cases and a list of grids, for each grid, find the number of distinct islands. An island is defined as a group of contiguous cells containing the value 1 and contiguous cells are those that share an edge (top, bottom, left, or right). Two islands are considered distinct if and only if their shapes (relative positions of their 1's) are different. >>> find_distinct_islands(1, [(3, 3, [[1, 0, 1], [0, 1, 0], [1, 0, 1]])]) [1] >>> find_distinct_islands(2, [(3, 3, [[1, 0, 1], [0, 1, 0], [1, 0, 1]]), (4, 5, [[1, 1, 0, 0, 0], [1, 0, 0, 1, 1], [0, 0, 0, 0, 0], [1, 0, 1, 1, 0]])]) [1, 3] >>> find_distinct_islands(1, [(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]])]) [0] >>> find_distinct_islands(1, [(2, 2, [[1, 1], [1, 1]])]) [1] >>> find_distinct_islands(1, [(3, 3, [[1, 1, 0], [1, 0, 0], [0, 0, 1]])]) [2] >>> find_distinct_islands(1, [(1, 5, [[1, 1, 1, 1, 1]])]) [1]","solution":"from typing import List, Tuple def num_distinct_islands(grid: List[List[int]]) -> int: def dfs(r, c, direction): if 0 <= r < R and 0 <= c < C and grid[r][c] == 1: grid[r][c] = -1 # Mark the cell visited shape.append(direction) dfs(r - 1, c, 'u') # up dfs(r + 1, c, 'd') # down dfs(r, c - 1, 'l') # left dfs(r, c + 1, 'r') # right shape.append('b') # backtrack distinct_islands = set() R, C = len(grid), len(grid[0]) for r in range(R): for c in range(C): if grid[r][c] == 1: shape = [] dfs(r, c, 'o') # origin distinct_islands.add(tuple(shape)) return len(distinct_islands) def find_distinct_islands(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: results = [] for R, C, grid in test_cases: results.append(num_distinct_islands(grid)) return results"},{"question":"def levenshtein_distance(a, b): Calculate the Levenshtein distance between two strings. >>> levenshtein_distance(\\"kitten\\", \\"sitting\\") 3 >>> levenshtein_distance(\\"flaw\\", \\"lawn\\") 2 >>> levenshtein_distance(\\"\\", \\"abc\\") 3 >>> levenshtein_distance(\\"abc\\", \\"\\") 3 >>> levenshtein_distance(\\"abc\\", \\"abc\\") 0 def spell_checker(text: str, dictionary: list) -> str: Corrects all misspelled words in a given text based on a provided dictionary. >>> spell_checker(\\"helo wrld pytthon prgramming\\", [\\"hello\\", \\"world\\", \\"python\\", \\"programming\\"]) \\"hello world python programming\\" >>> spell_checker(\\"helllo wordl\\", [\\"hello\\", \\"world\\", \\"python\\", \\"programming\\"]) \\"hello world\\" >>> spell_checker(\\"python programming\\", [\\"hello\\", \\"world\\", \\"python\\", \\"programming\\"]) \\"python programming\\" >>> spell_checker(\\"pythno prgrammming\\", [\\"hello\\", \\"world\\", \\"python\\", \\"programming\\"]) \\"python programming\\"","solution":"def levenshtein_distance(a, b): Calculate the Levenshtein distance between two strings. if len(a) < len(b): return levenshtein_distance(b, a) if len(b) == 0: return len(a) previous_row = range(len(b) + 1) for i, c1 in enumerate(a): current_row = [i + 1] for j, c2 in enumerate(b): insertions = previous_row[j + 1] + 1 deletions = current_row[j] + 1 substitutions = previous_row[j] + (c1 != c2) current_row.append(min(insertions, deletions, substitutions)) previous_row = current_row return previous_row[-1] def spell_checker(text: str, dictionary: list) -> str: Corrects all misspelled words in a given text based on a provided dictionary. def find_closest_match(word): closest_distance = float('inf') closest_word = word for correct_word in dictionary: distance = levenshtein_distance(word, correct_word) if distance < closest_distance or (distance == closest_distance and correct_word < closest_word): closest_distance = distance closest_word = correct_word return closest_word words = text.split() corrected_words = [find_closest_match(word) for word in words] return ' '.join(corrected_words)"},{"question":"from typing import List def unique_order(orders: List[str]) -> List[str]: Processes each order to remove duplicate items and sort the items lexically. :param orders: A list of strings where each string is an order of comma-separated food items. :return: A list of strings with unique items sorted lexically for each order. pass # Example Input orders = [\\"burger,fries,soda\\", \\"pizza,pizza,burger\\", \\"soda,burger,fries,fries\\"] # Example Output expected_output = [\\"burger,fries,soda\\", \\"burger,pizza\\", \\"burger,fries,soda\\"] assert unique_order(orders) == expected_output # Unit Tests def test_unique_order_single_order(): assert unique_order([\\"burger,fries,soda\\"]) == [\\"burger,fries,soda\\"] def test_unique_order_multiple_orders(): assert unique_order([\\"burger,fries,soda\\", \\"burger,burger,fries\\", \\"soda,burger,fries,fries\\"]) == [ \\"burger,fries,soda\\", \\"burger,fries\\", \\"burger,fries,soda\\" ] def test_unique_order_with_duplicate_items(): assert unique_order([\\"pizza,pizza,burger\\", \\"soda,soda,soda\\"]) == [\\"burger,pizza\\", \\"soda\\"] def test_unique_order_empty_order(): assert unique_order([\\"\\"]) == [\\"\\"] def test_unique_order_mixed_order(): assert unique_order([\\"a,a,a\\", \\"c,b,a\\", \\"x,y,z\\", \\"f,e,d,d,c\\"]) == [ \\"a\\", \\"a,b,c\\", \\"x,y,z\\", \\"c,d,e,f\\" ]","solution":"def unique_order(orders): Processes each order to remove duplicate items and sort the items lexically. :param orders: A list of strings where each string is an order of comma-separated food items. :return: A list of strings with unique items sorted lexically for each order. result = [] for order in orders: items = order.split(',') unique_sorted_items = sorted(set(items)) result.append(','.join(unique_sorted_items)) return result"},{"question":"def max_height_difference(heights: List[int]) -> int: Determine the maximum difference in height between any two trees such that the shorter tree is to the left of the taller tree. :param heights: A list of integers representing the heights of trees. :return: Maximum height difference as a single integer. >>> max_height_difference([4, 5, 7, 3, 6]) 3 >>> max_height_difference([4, 2, 6, 5, 9]) 7 >>> max_height_difference([10, 1, 2, 3, 4, 5]) 4 >>> max_height_difference([10, 9, 8, 7]) 0 >>> max_height_difference([1, 2]) 1 >>> max_height_difference([7, 3, 5, 1, 6, 2]) 5 >>> max_height_difference([5, 5, 5, 5]) 0 >>> max_height_difference([1, 100]) 99 >>> max_height_difference([100, 1]) 0","solution":"def max_height_difference(heights): Returns the maximum height difference between any two trees such that the shorter tree is to the left of the taller tree. :param heights: A list of integers representing the heights of trees. :return: Maximum height difference. max_diff = 0 min_height = heights[0] for height in heights[1:]: if height > min_height: max_diff = max(max_diff, height - min_height) min_height = min(min_height, height) return max_diff"},{"question":"def sort_events(events: str) -> List[str]: Given a string representing a sequence of events with timestamps in the format \\"event:time\\", this function returns a list of events sorted by their timestamps in ascending order. >>> sort_events(\\"start:5,cook:10,eat:15,cleanup:20\\") [\\"start\\", \\"cook\\", \\"eat\\", \\"cleanup\\"] >>> sort_events(\\"wake:1,shower:2,breakfast:3,work:4\\") [\\"wake\\", \\"shower\\", \\"breakfast\\", \\"work\\"] def test_sort_events_single_event(): assert sort_events(\\"start:5\\") == [\\"start\\"] def test_sort_events_multiple_events(): assert sort_events(\\"start:5,cook:10,eat:15,cleanup:20\\") == [\\"start\\", \\"cook\\", \\"eat\\", \\"cleanup\\"] assert sort_events(\\"wake:1,shower:2,breakfast:3,work:4\\") == [\\"wake\\", \\"shower\\", \\"breakfast\\", \\"work\\"] def test_sort_events_unordered(): assert sort_events(\\"b:20,a:5,d:15,c:10\\") == [\\"a\\", \\"c\\", \\"d\\", \\"b\\"] def test_sort_events_same_initial_letters(): assert sort_events(\\"work:100,watch:10,wash:50\\") == [\\"watch\\", \\"wash\\", \\"work\\"] def test_sort_events_large_numbers(): assert sort_events(\\"event1:1000,event2:2000,event3:3000\\") == [\\"event1\\", \\"event2\\", \\"event3\\"]","solution":"def sort_events(events): Given a string representing a sequence of events with timestamps in the format \\"event:time\\", this function returns a list of events sorted by their timestamps in ascending order. # Split the input string into pairs of event:time event_pairs = events.split(',') # Create a list of tuples where each tuple is (event, time) event_list = [(event.split(':')[0], int(event.split(':')[1])) for event in event_pairs] # Sort the list of tuples by the time (second element of tuple) sorted_event_list = sorted(event_list, key=lambda x: x[1]) # Extract and return the sorted events return [event for event, _ in sorted_event_list]"},{"question":"def exists(board: List[List[str]], word: str) -> bool: Determine if the word can be constructed from letters of adjacent cells in the grid. You can move in four directions: up, down, left, and right, but not diagonally. A cell can only be used once in each constructed word. >>> exists([[\\"A\\", \\"B\\", \\"C\\", \\"E\\"], [\\"S\\", \\"F\\", \\"C\\", \\"S\\"], [\\"A\\", \\"D\\", \\"E\\", \\"E\\"]], \\"ABCCED\\") True >>> exists([[\\"A\\", \\"B\\", \\"C\\", \\"E\\"], [\\"S\\", \\"F\\", \\"C\\", \\"S\\"], [\\"A\\", \\"D\\", \\"E\\", \\"E\\"]], \\"SEE\\") True >>> exists([[\\"A\\", \\"B\\", \\"C\\", \\"E\\"], [\\"S\\", \\"F\\", \\"C\\", \\"S\\"], [\\"A\\", \\"D\\", \\"E\\", \\"E\\"]], \\"ABCB\\") False","solution":"def exists(board, word): def backtrack(row, col, suffix): if len(suffix) == 0: return True if row < 0 or row == len(board) or col < 0 or col == len(board[0]) or board[row][col] != suffix[0]: return False ret = False board[row][col], temp = '#', board[row][col] # mark the cell as visited for rowOffset, colOffset in [(0, 1), (1, 0), (0, -1), (-1, 0)]: ret = backtrack(row + rowOffset, col + colOffset, suffix[1:]) if ret: break board[row][col] = temp # unmark the cell return ret for row in range(len(board)): for col in range(len(board[0])): if backtrack(row, col, word): return True return False"},{"question":"def find_most_anagrams(words: List[str]) -> str: Find the word that has the most anagrams in the given list. >>> find_most_anagrams(['listen', 'silent', 'enlist', 'google', 'cinema', 'iceman']) 'listen' >>> find_most_anagrams(['abc', 'bca', 'cab', 'xyz', 'zyx']) 'abc' >>> find_most_anagrams(['aabb', 'abab', 'baba', 'baab', 'bbcc']) 'aabb' from solution import find_most_anagrams def test_find_most_anagrams_example_case1(): assert find_most_anagrams(['listen', 'silent', 'enlist', 'google', 'cinema', 'iceman']) == 'listen' def test_find_most_anagrams_example_case2(): assert find_most_anagrams(['abc', 'bca', 'cab', 'xyz', 'zyx']) == 'abc' def test_find_most_anagrams_example_case3(): assert find_most_anagrams(['aabb', 'abab', 'baba', 'baab', 'bbcc']) == 'aabb' def test_find_most_anagrams_single_word(): assert find_most_anagrams(['word']) == 'word' def test_find_most_anagrams_no_anagrams(): assert find_most_anagrams(['apple', 'banana', 'cherry']) == 'apple' def test_find_most_anagrams_multiple_with_same_count(): assert find_most_anagrams(['aabb', 'baba', 'baab', 'cddc', 'dcdc', 'ccdd']) == 'aabb' def test_find_most_anagrams_all_anagrams(): assert find_most_anagrams(['rat', 'tar', 'art', 'tra', 'rta', 'tla']) == 'rat'","solution":"def find_most_anagrams(words): from collections import defaultdict # Using a dictionary to group words by their sorted tuple of characters anagrams_dict = defaultdict(list) for word in words: key = tuple(sorted(word)) anagrams_dict[key].append(word) # Find the word with the most anagrams max_count = 0 result_word = None for word in words: key = tuple(sorted(word)) count = len(anagrams_dict[key]) if count > max_count: max_count = count result_word = word return result_word"},{"question":"def valid_knight_moves(position): Returns the number of valid moves a knight can make from the given position on a chessboard. >>> valid_knight_moves(\\"a1\\") 2 >>> valid_knight_moves(\\"d4\\") 8 >>> valid_knight_moves(\\"h8\\") 2 pass def get_valid_knight_moves(test_cases): Processes multiple test cases and returns a list of valid knight moves for each test case. >>> get_valid_knight_moves([\\"a1\\", \\"d4\\", \\"h8\\"]) [2, 8, 2] pass # Additional test cases from solution import valid_knight_moves, get_valid_knight_moves def test_valid_knight_moves_corner(): assert valid_knight_moves(\\"a1\\") == 2 assert valid_knight_moves(\\"h8\\") == 2 assert valid_knight_moves(\\"a8\\") == 2 assert valid_knight_moves(\\"h1\\") == 2 def test_valid_knight_moves_edge(): assert valid_knight_moves(\\"a4\\") == 4 assert valid_knight_moves(\\"h4\\") == 4 assert valid_knight_moves(\\"d1\\") == 4 assert valid_knight_moves(\\"d8\\") == 4 def test_valid_knight_moves_center(): assert valid_knight_moves(\\"d4\\") == 8 assert valid_knight_moves(\\"e5\\") == 8 def test_valid_knight_moves_near_center(): assert valid_knight_moves(\\"b2\\") == 4 assert valid_knight_moves(\\"g7\\") == 4 def test_get_valid_knight_moves(): test_cases = [\\"a1\\", \\"d4\\", \\"h8\\"] expected = [2, 8, 2] assert get_valid_knight_moves(test_cases) == expected","solution":"def valid_knight_moves(position): Returns the number of valid moves a knight can make from the given position on a chessboard. moves = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)] col = ord(position[0]) - ord('a') + 1 row = int(position[1]) valid_moves = 0 for move in moves: new_col = col + move[0] new_row = row + move[1] if 1 <= new_col <= 8 and 1 <= new_row <= 8: valid_moves += 1 return valid_moves def get_valid_knight_moves(test_cases): Processes multiple test cases and returns a list of valid knight moves for each test case. results = [] for position in test_cases: results.append(valid_knight_moves(position)) return results"},{"question":"def sumStrings(num1: str, num2: str) -> str: Returns the sum of two large numbers represented as strings. >>> sumStrings('12345678901234567890', '98765432109876543210') '111111111011111111100' >>> sumStrings('500', '500') '1000' >>> sumStrings('0', '0') '0' >>> sumStrings('999999999999999999', '1') '1000000000000000000' >>> sumStrings('123', '4567') '4690' >>> sumStrings('0', '999') '999' >>> sumStrings('1000', '0') '1000'","solution":"def sumStrings(num1, num2): Returns the sum of two large numbers represented as strings. # Reverse both strings to make it easier to process from the least significant digit num1 = num1[::-1] num2 = num2[::-1] max_length = max(len(num1), len(num2)) carry = 0 result = [] for i in range(max_length): digit1 = int(num1[i]) if i < len(num1) else 0 digit2 = int(num2[i]) if i < len(num2) else 0 # Calculate the sum of the current digits plus any carry from the previous digit digit_sum = digit1 + digit2 + carry carry = digit_sum // 10 # Append the current digit to the result list result.append(str(digit_sum % 10)) # If there's any carry left, append it if carry: result.append(str(carry)) # Reverse the result list back to a string and join return ''.join(result[::-1])"},{"question":"def max_treasures(grid, treasures): Calculate the maximum number of treasures Emily can collect on her way from the top-left corner to the bottom-right corner. Args: grid (list of list of int): n x m grid representing the city and its obstacles. 0 indicates an open path and 1 indicates an obstacle. treasures (list of tuple of int): List of coordinates where each tuple contains two integers representing the coordinates of a cell containing a treasure. Returns: int: The maximum number of treasures Emily can collect. Example: >>> grid = [ [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0], [0, 1, 0, 0] ] >>> treasures = [(0, 2), (2, 2), (3, 2)] >>> max_treasures(grid, treasures) 2 >>> grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] >>> treasures = [] >>> max_treasures(grid, treasures) 0 pass from solution import max_treasures def test_example_case(): grid = [ [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0], [0, 1, 0, 0] ] treasures = [(0, 2), (2, 2), (3, 2)] assert max_treasures(grid, treasures) == 2 def test_no_treasures(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] treasures = [] assert max_treasures(grid, treasures) == 0 def test_all_obstacles(): grid = [ [0, 1], [1, 0] ] treasures = [(1, 1)] assert max_treasures(grid, treasures) == 0 def test_treasure_at_start_and_end(): grid = [ [0, 0], [0, 0] ] treasures = [(0, 0), (1, 1)] assert max_treasures(grid, treasures) == 2 def test_multiple_paths(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] treasures = [(0, 1), (1, 1), (2, 1)] assert max_treasures(grid, treasures) == 3 def test_single_path(): grid = [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ] treasures = [(2, 0), (2, 2)] assert max_treasures(grid, treasures) == 2","solution":"def max_treasures(grid, treasures): n, m = len(grid), len(grid[0]) treasure_set = set(treasures) dp = [[-float('inf')] * m for _ in range(n)] dp[0][0] = 1 if (0, 0) in treasure_set else 0 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = -float('inf') else: if i > 0: dp[i][j] = max(dp[i][j], dp[i-1][j] + (1 if (i, j) in treasure_set else 0)) if j > 0: dp[i][j] = max(dp[i][j], dp[i][j-1] + (1 if (i, j) in treasure_set else 0)) return max(0, dp[n-1][m-1])"},{"question":"def reverse_sentence(sentence: str) -> str: Reverses each word in the given sentence while preserving the order of words and reducing multiple spaces to a single space. >>> reverse_sentence(\\"Hello world!\\") == \\"olleH !dlrow\\" >>> reverse_sentence(\\" This is an example \\") == \\"sihT si na elpmaxe\\" >>> reverse_sentence(\\"Python coding assessment\\") == \\"nohtyP gnidoc tnemssessa\\" >>> reverse_sentence(\\"Python\\") == \\"nohtyP\\" >>> reverse_sentence(\\"\\") == \\"\\"","solution":"def reverse_sentence(sentence): Reverses each word in the given sentence while preserving the order of words and reducing multiple spaces to a single space. words = sentence.split() reversed_words = [word[::-1] for word in words] return \\" \\".join(reversed_words)"},{"question":"def get_weighted_average(grades): Calculate the weighted average of a list of grades. Parameters: grades (list of tuples): List of tuples where each tuple contains a grade and its corresponding weight. Returns: float: The weighted average, rounded to two decimal places. >>> get_weighted_average([(90, 1), (80, 2), (70, 3)]) # Output: 78.33 >>> get_weighted_average([(50, 1), (50, 1), (50, 1)]) # Output: 50.00 >>> get_weighted_average([(95, 1), (85, 2)]) # Output: 88.33 from solution import get_weighted_average def test_weighted_average_single_entry(): assert get_weighted_average([(90, 1)]) == 90.00 def test_weighted_average_multiple_entries_equal_weight(): assert get_weighted_average([(90, 1), (80, 1), (70, 1)]) == 80.00 def test_weighted_average_multiple_entries_different_weights(): assert get_weighted_average([(90, 1), (80, 2), (70, 3)]) == 76.67 def test_weighted_average_identical_grades(): assert get_weighted_average([(50, 1), (50, 1), (50, 1)]) == 50.00 def test_weighted_average_varied_weights(): assert get_weighted_average([(95, 1), (85, 2)]) == 88.33 def test_weighted_average_large_grades(): assert get_weighted_average([(100, 5), (100, 4), (100, 1)]) == 100.00 def test_weighted_average_zero_weight(): assert get_weighted_average([(60, 1), (60, 2)]) == 60.00 # No weight of zero allowed but uniform weights def test_weighted_average_rounding_needed(): assert get_weighted_average([(91, 2), (76, 1)]) == 86.00 def test_weighted_average_with_zero_and_hundred(): assert get_weighted_average([(0, 1), (100, 1)]) == 50.00","solution":"def get_weighted_average(grades): Calculate the weighted average of a list of grades. Parameters: grades (list of tuples): List of tuples where each tuple contains a grade and its corresponding weight. Returns: float: The weighted average, rounded to two decimal places. total_weighted_score = 0 total_weight = 0 for grade, weight in grades: total_weighted_score += grade * weight total_weight += weight weighted_average = total_weighted_score / total_weight return round(weighted_average, 2)"},{"question":"def visible_buildings(heights: List[int]) -> List[int]: Returns the heights of the visible buildings from the left side. A building is visible if all the buildings before it (to the left in the array) are shorter. Parameters: heights (list of int): Array of building heights. Returns: list of int: Array containing the heights of the visible buildings from the left side. Example: >>> visible_buildings([3, 5, 4, 9, 6, 7, 8]) [3, 5, 9] >>> visible_buildings([1, 3, 2, 4, 3, 5, 4]) [1, 3, 4, 5]","solution":"def visible_buildings(heights): Returns the heights of the visible buildings from the left side. Parameters: heights (list of int): Heights of the buildings. Returns: list of int: Heights of the visible buildings. if not heights: return [] visible = [] max_height = -1 for height in heights: if height > max_height: visible.append(height) max_height = height return visible"},{"question":"from typing import List, Tuple def is_prime(number: int) -> bool: Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(1) False >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(19) True pass def count_prime_numbers(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Count the number of prime numbers in each sequence of test cases. >>> test_cases = [ ... (5, [2, 3, 4, 5, 6]), ... (3, [1, 2, 3]), ... (6, [8, 9, 10, 11, 12, 13]), ... (4, [14, 15, 16, 17]) ... ] >>> count_prime_numbers(test_cases) [3, 2, 2, 1] >>> test_cases = [ ... (5, [999983, 999999, 1000000, 100003, 100019]) ... ] >>> count_prime_numbers(test_cases) [3] pass","solution":"def is_prime(number): if number <= 1: return False if number == 2: return True if number % 2 == 0: return False i = 3 while i * i <= number: if number % i == 0: return False i += 2 return True def count_prime_numbers(test_cases): results = [] for test in test_cases: n, sequence = test prime_count = sum(is_prime(num) for num in sequence) results.append(prime_count) return results"},{"question":"def is_harshad(n: int) -> bool: Determines if a given positive integer n is a Harshad number. A number is a Harshad number if it is divisible by the sum of its digits. >>> is_harshad(18) True >>> is_harshad(19) False >>> is_harshad(21) True >>> is_harshad(22) False","solution":"def is_harshad(n): Determines if a given positive integer n is a Harshad number. A number is a Harshad number if it is divisible by the sum of its digits. digit_sum = sum(int(digit) for digit in str(n)) return n % digit_sum == 0"},{"question":"from typing import List, Tuple def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 def solve(test_cases: List[Tuple[int, str]]) -> List[int]: For each test case, computes and returns the length of the longest substring without repeating characters. >>> test_cases = [ >>> (8, \\"abcabcbb\\"), >>> (5, \\"bbbbb\\") >>> ] >>> solve(test_cases) [3, 1] def test_length_of_longest_substring(): assert length_of_longest_substring(\\"abcabcbb\\") == 3 assert length_of_longest_substring(\\"bbbbb\\") == 1 assert length_of_longest_substring(\\"pwwkew\\") == 3 assert length_of_longest_substring(\\"\\") == 0 assert length_of_longest_substring(\\"abcdefg\\") == 7 assert length_of_longest_substring(\\"abba\\") == 2 def test_solve(): test_cases = [ (8, \\"abcabcbb\\"), (5, \\"bbbbb\\"), ] results = solve(test_cases) assert results == [3, 1] test_cases = [ (6, \\"pwwkew\\"), (7, \\"abcdefg\\") ] results = solve(test_cases) assert results == [3, 7]","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for index, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = index longest = max(longest, index - start + 1) return longest def solve(test_cases): For each test case, computes and prints the length of the longest substring without repeating characters. results = [] for n, s in test_cases: results.append(length_of_longest_substring(s)) return results"},{"question":"def rob(nums: List[int]) -> int: Returns the maximum amount of wealth that can be robbed without alerting the police. >>> rob([2, 3, 2]) 3 >>> rob([1, 2, 3, 1]) 4 >>> rob([0]) 0 >>> rob([8, 5]) 8 >>> rob([5, 10]) 10 >>> rob([0, 0, 0, 0]) 0 >>> rob([2, 7, 9, 3, 1]) 11 >>> rob([6, 1, 6, 1, 6, 1]) 18","solution":"def rob(nums): Returns the maximum amount of wealth that can be robbed without alerting the police. if not nums: return 0 if len(nums) == 1: return nums[0] # Helper function to rob houses in a linear arrangement def rob_linear(houses): prev_max = 0 curr_max = 0 for house in houses: temp = curr_max curr_max = max(prev_max + house, curr_max) prev_max = temp return curr_max # Since houses are arranged in a circular manner, we need to consider two cases: return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"def longestSubstringKDistinct(s: str, k: int) -> int: Finds the length of the longest substring that contains at most k distinct characters. Args: s (str): The input string containing lowercase alphabet characters. k (int): The maximum number of distinct characters allowed in the substring. Returns: int: The length of the longest substring that contains at most k distinct characters. Examples: >>> longestSubstringKDistinct(\\"eceba\\", 2) 3 >>> longestSubstringKDistinct(\\"aa\\", 1) 2 >>> longestSubstringKDistinct(\\"aaabbccc\\", 2) 5","solution":"def longestSubstringKDistinct(s, k): Finds the length of the longest substring that contains at most k distinct characters. :param s: The input string containing lowercase alphabet characters. :param k: The maximum number of distinct characters allowed in the substring. :return: The length of the longest substring that contains at most k distinct characters. from collections import defaultdict n = len(s) if n == 0 or k == 0: return 0 left = 0 right = 0 max_len = 0 char_count = defaultdict(int) while right < n: char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be made by buying and selling the stock on different days. If no profit is possible, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 pass def test_typical_case(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 def test_no_profit_case(): assert max_profit([7, 6, 4, 3, 1]) == 0 def test_single_day_case(): assert max_profit([5]) == 0 def test_constant_prices_case(): assert max_profit([3, 3, 3, 3, 3]) == 0 def test_all_same_profit(): assert max_profit([1, 2, 3, 4, 5]) == 4 def test_empty_prices(): assert max_profit([]) == 0 def test_all_equal_prices(): assert max_profit([5, 5, 5, 5, 5]) == 0","solution":"def max_profit(prices): Returns the maximum profit that can be made by buying and selling the stock on different days. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def is_almost_prime(n: int) -> bool: Determines if a given number is \\"almost prime\\". A number is considered \\"almost prime\\" if it has exactly three distinct divisors: 1, itself, and another prime number. Examples: >>> is_almost_prime(4) True >>> is_almost_prime(9) True >>> is_almost_prime(25) True >>> is_almost_prime(6) False >>> is_almost_prime(10) False pass","solution":"def is_almost_prime(n: int) -> bool: Determines if a given number is \\"almost prime\\". A number is considered \\"almost prime\\" if it has exactly three distinct divisors: 1, itself, and another prime number. import math # Function to check if a number is prime def is_prime(num): if num < 2: return False for i in range(2, int(math.sqrt(num)) + 1): if num % i == 0: return False return True # Number must be a square of some prime number to have exactly three divisors root = int(math.isqrt(n)) if root * root == n and is_prime(root): return True return False"},{"question":"def contains_all_alphabets(s: str) -> str: Returns 'YES' if the string contains all characters from 'a' to 'z' (case insensitive). Otherwise, returns 'NO'. >>> contains_all_alphabets(\\"The quick brown fox jumps over the lazy dog\\") == \\"YES\\" >>> contains_all_alphabets(\\"Hello World\\") == \\"NO\\" >>> contains_all_alphabets(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"YES\\" >>> contains_all_alphabets(\\"abcdefghijklmnpqrstuvwxyz\\") == \\"NO\\" >>> contains_all_alphabets(\\"AbCdEfGhIjKlMnOpQrStUvWxYz\\") == \\"YES\\" >>> contains_all_alphabets(\\"1234567890!@#%^&*()_+{}|:<>?abcdefghijklmnopqrstuvwxyz\\") == \\"YES\\"","solution":"def contains_all_alphabets(s): Returns 'YES' if the string contains all characters from 'a' to 'z' (case insensitive). Otherwise, returns 'NO'. s = s.lower() alphabet_set = set('abcdefghijklmnopqrstuvwxyz') return 'YES' if alphabet_set <= set(s) else 'NO'"},{"question":"def movingAverage(nums: List[int], k: int) -> List[float]: Calculate the moving average of elements within a sliding window of a specified size. >>> movingAverage([1, 3, 2, 6, -1, 4, 1, 8, 2], 3) [2.0, 3.67, 2.33, 3.0, 1.33, 4.33, 3.67] >>> movingAverage([1, 2, 3, 4, 5], 1) [1.0, 2.0, 3.0, 4.0, 5.0] >>> movingAverage([5, 10, 15, 20], 4) [12.5] >>> movingAverage([-1, -2, -3, -4, -5], 2) [-1.5, -2.5, -3.5, -4.5] >>> movingAverage([0, 0, 0, 0, 0], 2) [0.0, 0.0, 0.0, 0.0] >>> movingAverage([4, 5, 6, 7, 8, 9, 10], 4) [5.5, 6.5, 7.5, 8.5]","solution":"def movingAverage(nums, k): result = [] for i in range(len(nums) - k + 1): window = nums[i:i + k] average = sum(window) / k result.append(round(average, 2)) return result"},{"question":"def count_groups_of_similar_strings(n: int, strings: List[str]) -> int: Returns the number of groups of similar strings. >>> count_groups_of_similar_strings(5, [\\"abc\\", \\"bca\\", \\"cab\\", \\"dac\\", \\"cad\\"]) 2 >>> count_groups_of_similar_strings(3, [\\"aabb\\", \\"bbaa\\", \\"abab\\"]) 1 >>> count_groups_of_similar_strings(4, [\\"xyz\\", \\"yxz\\", \\"zxy\\", \\"yyz\\"]) 2 >>> count_groups_of_similar_strings(1, [\\"abc\\"]) 1 >>> count_groups_of_similar_strings(3, [\\"abc\\", \\"abc\\", \\"abc\\"]) 1 >>> count_groups_of_similar_strings(4, [\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\"]) 4 >>> count_groups_of_similar_strings(6, [\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"yxz\\", \\"zxy\\"]) 2","solution":"def count_groups_of_similar_strings(n, strings): Returns the number of groups of similar strings. def get_signature(s): Get a sorted tuple of characters that represents the 'signature' of the string. return tuple(sorted(s)) similar_groups = {} for s in strings: signature = get_signature(s) if signature in similar_groups: similar_groups[signature].append(s) else: similar_groups[signature] = [s] return len(similar_groups)"},{"question":"def is_arithmetic_progression(lst: List[int]) -> bool: Determines if the given list is an arithmetic progression. :param lst: List of integers :return: True if the list is an arithmetic progression, otherwise False >>> is_arithmetic_progression([1, 3, 5, 7, 9]) True >>> is_arithmetic_progression([5, 10, 15, 20, 25]) True >>> is_arithmetic_progression([1, 2, 4, 8]) False >>> is_arithmetic_progression([7, 7, 7, 7]) True","solution":"def is_arithmetic_progression(lst): Determines if the given list is an arithmetic progression. :param lst: List of integers :return: True if the list is an arithmetic progression, otherwise False if len(lst) < 2: return False common_diff = lst[1] - lst[0] for i in range(2, len(lst)): if lst[i] - lst[i - 1] != common_diff: return False return True"},{"question":"def single_number(nums: List[int]) -> int: Finds the element that appears only once in the list where every other element appears twice. Args: nums (list): List of integers Returns: int: The single element that appears once >>> single_number([2, 2, 1]) 1 >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([1]) 1 >>> single_number([-1, -1, -2, -3, -3]) -2 >>> single_number(list(range(1, 100001)) * 2 + [123456]) 123456","solution":"def single_number(nums): Finds the element that appears only once in the list where every other element appears twice. Args: nums (list): List of integers Returns: int: The single element that appears once unique = 0 for num in nums: unique ^= num return unique"},{"question":"import heapq class MedianFinder: def __init__(self): Initialize your data structure here. def addNum(self, num: int) -> None: Adds a number to the data structure. >>> mf = MedianFinder() >>> mf.addNum(1) >>> mf.addNum(2) def findMedian(self) -> float: Returns the median of all numbers added so far. >>> mf = MedianFinder() >>> mf.addNum(1) >>> mf.addNum(2) >>> mf.findMedian() 1.5 from solution import MedianFinder def test_median_finder_one_element(): mf = MedianFinder() mf.addNum(1) assert mf.findMedian() == 1.0 def test_median_finder_two_elements(): mf = MedianFinder() mf.addNum(1) mf.addNum(2) assert mf.findMedian() == 1.5 def test_median_finder_three_elements(): mf = MedianFinder() mf.addNum(1) mf.addNum(2) mf.addNum(3) assert mf.findMedian() == 2.0 def test_median_finder_negative_elements(): mf = MedianFinder() mf.addNum(-1) mf.addNum(-2) mf.addNum(-3) assert mf.findMedian() == -2.0 def test_median_finder_mixed_elements(): mf = MedianFinder() mf.addNum(-1) mf.addNum(2) mf.addNum(3) assert mf.findMedian() == 2.0 def test_median_finder_multiple_operations(): mf = MedianFinder() mf.addNum(1) mf.addNum(2) assert mf.findMedian() == 1.5 mf.addNum(3) assert mf.findMedian() == 2.0 mf.addNum(4) assert mf.findMedian() == 2.5 mf.addNum(5) assert mf.findMedian() == 3.0","solution":"import heapq class MedianFinder: def __init__(self): self.small = [] # Max-heap for the lower half self.large = [] # Min-heap for the upper half def addNum(self, num: int) -> None: # Add to max-heap (inverted min-heap) heapq.heappush(self.small, -num) # Balance the heaps: The max number of small should be less than or equal to the min number of large if self.small and self.large and (-self.small[0] > self.large[0]): heapq.heappush(self.large, -heapq.heappop(self.small)) # Ensure size property: the heaps' sizes should be len(small) >= len(large) if len(self.small) > len(self.large) + 1: heapq.heappush(self.large, -heapq.heappop(self.small)) elif len(self.large) > len(self.small): heapq.heappush(self.small, -heapq.heappop(self.large)) def findMedian(self) -> float: if len(self.small) > len(self.large): return -self.small[0] return (-self.small[0] + self.large[0]) / 2"},{"question":"def is_palindrome(s: str) -> bool: Checks if the given string s is a valid palindrome, ignoring spaces, punctuation, and case differences. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"Race car!\\") == True >>> is_palindrome(\\"Hello, World!\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True","solution":"def is_palindrome(s): Checks if the given string s is a valid palindrome, ignoring spaces, punctuation, and case differences. # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [c.lower() for c in s if c.isalnum()] # Compare the filtered string with its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"def letter_frequency_analysis(ciphertext: str) -> dict: Analyzes the frequency distribution of letters in the provided ciphertext. Args: ciphertext (str): The input ciphertext containing only alphabetic characters. Returns: dict: A dictionary with the frequency of each letter from 'a' to 'z'. Example: >>> letter_frequency_analysis(\\"helloHElloHELlohello\\") { 'a': 0, 'b': 0, 'c': 0, 'd': 0, 'e': 5, 'f': 0, 'g': 0, 'h': 5, 'i': 0, 'j': 0, 'k': 0, 'l': 5, 'm': 0, 'n': 0, 'o': 5, 'p': 0, 'q': 0, 'r': 0, 's': 0, 't': 0, 'u': 0, 'v': 0, 'w': 0, 'x': 0, 'y': 0, 'z': 0 }","solution":"def letter_frequency_analysis(ciphertext: str) -> dict: Analyzes the frequency distribution of letters in the provided ciphertext. Args: ciphertext (str): The input ciphertext containing only alphabetic characters. Returns: dict: A dictionary with the frequency of each letter from 'a' to 'z'. # Initialize a dictionary with each letter from 'a' to 'z' set to 0 frequency_dict = {chr(i): 0 for i in range(ord('a'), ord('z') + 1)} # Convert the ciphertext to lowercase to ensure case insensitivity ciphertext = ciphertext.lower() # Count the frequency of each letter in the ciphertext for char in ciphertext: if char in frequency_dict: frequency_dict[char] += 1 return frequency_dict"},{"question":"from typing import List def merge_arrays(arr1: List[int], arr2: List[int], startArr: str) -> List[int]: Merges two arrays by alternating their elements, starting with the given array. Parameters: arr1 (List[int]): The first array. arr2 (List[int]): The second array. startArr (str): The array to start with (\\"arr1\\" or \\"arr2\\"). Returns: List[int]: The merged array. Examples: >>> merge_arrays([1, 3, 5], [2, 4, 6], \\"arr1\\") [1, 2, 3, 4, 5, 6] >>> merge_arrays([7, 8], [9, 10, 11, 12], \\"arr2\\") [9, 7, 10, 8, 11, 12]","solution":"def merge_arrays(arr1, arr2, startArr): Merges two arrays by alternating their elements, starting with the given array. result = [] i, j = 0, 0 # Determine the starting array and alternate appending elements from arr1 and arr2 while i < len(arr1) and j < len(arr2): if startArr == \\"arr1\\": result.append(arr1[i]) i += 1 startArr = \\"arr2\\" else: result.append(arr2[j]) j += 1 startArr = \\"arr1\\" # Append remaining elements from arr1, if any while i < len(arr1): result.append(arr1[i]) i += 1 # Append remaining elements from arr2, if any while j < len(arr2): result.append(arr2[j]) j += 1 return result"},{"question":"def check_winning_entry(entries: list, winning_number: int) -> str: Checks if the winning number is in any of the entries. Args: entries (list): A list of strings, each representing a series of numbers. winning_number (int): The winning number to check for. Returns: str: \\"Winner found!\\" if the winning number is found in any entry, otherwise \\"No winner found...\\". Examples: >>> check_winning_entry([\\"12,45,78,34,89\\", \\"11,23,45,67,78\\", \\"90,34,12,56,78\\"], 23) 'Winner found!' >>> check_winning_entry([\\"12,45,78,34,89\\", \\"13,23,46,67,79\\", \\"91,34,12,56,79\\"], 77) 'No winner found...' # Your code here","solution":"def check_winning_entry(entries: list, winning_number: int) -> str: Checks if the winning number is in any of the entries. Args: entries (list): A list of strings, each representing a series of numbers. winning_number (int): The winning number to check for. Returns: str: \\"Winner found!\\" if the winning number is found in any entry, otherwise \\"No winner found...\\". for entry in entries: numbers = entry.split(',') if str(winning_number) in numbers: return \\"Winner found!\\" return \\"No winner found...\\""},{"question":"def isValidISBN(isbn: str) -> bool: Validates whether the given ISBN is valid according to ISBN-10 and ISBN-13 rules. >>> isValidISBN(\\"0-306-40615-2\\") True >>> isValidISBN(\\"978-3-16-148410-0\\") True >>> isValidISBN(\\"123456789X\\") True >>> isValidISBN(\\"123456789\\") False","solution":"def isValidISBN(isbn): Validates whether the given ISBN is valid according to ISBN-10 and ISBN-13 rules isbn = isbn.replace('-', '') if len(isbn) == 10: return is_valid_isbn10(isbn) elif len(isbn) == 13: return is_valid_isbn13(isbn) return False def is_valid_isbn10(isbn): if not isbn[:-1].isdigit() or (isbn[-1] not in \\"0123456789X\\"): return False sum = 0 for i in range(9): sum += int(isbn[i]) * (10 - i) if isbn[-1] == 'X': sum += 10 else: sum += int(isbn[-1]) return sum % 11 == 0 def is_valid_isbn13(isbn): if not isbn.isdigit(): return False sum = 0 for i in range(12): if i % 2 == 0: sum += int(isbn[i]) else: sum += 3 * int(isbn[i]) sum += int(isbn[12]) return sum % 10 == 0"},{"question":"def update_inventory(T: int, test_cases: List[Tuple[List[Tuple[str, int]], List[Tuple[str, int]], List[Tuple[str, int]]]]) -> List[Dict[str, int]]: Update the inventory based on current stock, shipments received, and items sold. Args: T (int): Number of test cases. test_cases (List[Tuple[List[Tuple[str, int]], List[Tuple[str, int]], List[Tuple[str, int]]]]): Each test case contains a tuple with three lists: - Current inventory - Recent shipments - Items sold Returns: List[Dict[str, int]]: Updated inventory for each test case. Examples: >>> update_inventory(1, [([ ... ('apple', 50), ... ('banana', 30), ... ('orange', 20) ... ], [ ... ('apple', 10), ... ('grape', 25) ... ], [ ... ('banana', 10), ... ('orange', 25) ... ])]) [{'apple': 60, 'banana': 20, 'orange': 0, 'grape': 25}] >>> update_inventory(1, [([ ... ('apple', 50) ... ], [], [ ... ('apple', 60) ... ])]) [{'apple': 0}]","solution":"def update_inventory(T, test_cases): Update the inventory based on current stock, shipments received, and items sold. results = [] for i in range(T): current_inventory, shipments, sales = test_cases[i] # Create inventory dictionary inventory = {} for item_id, quantity in current_inventory: inventory[item_id] = quantity # Process shipments for item_id, quantity in shipments: if item_id in inventory: inventory[item_id] += quantity else: inventory[item_id] = quantity # Process sales for item_id, quantity in sales: if item_id in inventory: inventory[item_id] = max(0, inventory[item_id] - quantity) results.append(inventory) return results"},{"question":"from typing import List def can_attend_all_meetings(intervals: List[List[int]]) -> bool: Determine if a person could attend all meetings given a list of meeting time intervals. Arguments: intervals -- A list of lists, each inner list contains two integers [start, end]. Returns: boolean -- True if a person can attend all meetings, False otherwise. Examples: >>> can_attend_all_meetings([[0, 30],[5,10],[15,20]]) False >>> can_attend_all_meetings([[7,10],[2,4]]) True","solution":"def can_attend_all_meetings(intervals): Determine if a person could attend all meetings given a list of meeting time intervals. Arguments: intervals -- A list of lists, each inner list contains two integers [start, end]. Returns: boolean -- True if a person can attend all meetings, False otherwise. if not intervals: return True # Sort the intervals by starting time intervals.sort(key=lambda x: x[0]) # Check for overlapping meetings for i in range(1, len(intervals)): if intervals[i][0] < intervals[i - 1][1]: return False return True"},{"question":"def days_between_dates(start_date: str, end_date: str) -> int: Calculate the total number of days between two given dates. Args: start_date (str): The start date in the format 'YYYY-MM-DD'. end_date (str): The end date in the format 'YYYY-MM-DD'. Returns: int: The total number of days between the start and end date, inclusive. Examples: >>> days_between_dates('2022-09-01', '2022-09-01') 1 >>> days_between_dates('2022-09-01', '2022-09-05') 5 >>> days_between_dates('2022-08-30', '2022-09-02') 4 >>> days_between_dates('2022-12-30', '2023-01-02') 4 >>> days_between_dates('2020-02-27', '2020-03-01') 4 >>> days_between_dates('2022-01-01', '2022-12-31') 365 >>> days_between_dates('2020-01-01', '2020-12-31') 366","solution":"from datetime import datetime def days_between_dates(start_date: str, end_date: str) -> int: Calculate the total number of days between two given dates. Args: start_date (str): The start date in the format 'YYYY-MM-DD'. end_date (str): The end date in the format 'YYYY-MM-DD'. Returns: int: The total number of days between the start and end date, inclusive. # Convert the string dates to datetime objects start_date_obj = datetime.strptime(start_date, '%Y-%m-%d') end_date_obj = datetime.strptime(end_date, '%Y-%m-%d') # Calculate the difference in days between the two dates delta = end_date_obj - start_date_obj # Return the number of days between the dates, inclusive return delta.days + 1"},{"question":"from typing import List def find_missing_positive_integer(arr: List[int]) -> int: This function takes a list of integers and returns the minimum positive integer that is missing from the list. >>> find_missing_positive_integer([1, 2, 0, -1, 3]) 4 >>> find_missing_positive_integer([-1, -2, -3]) 1 >>> find_missing_positive_integer([3, 4, -1, 1]) 2 >>> find_missing_positive_integer([2, 3, 7, 6, 8]) 1 >>> find_missing_positive_integer([1, 2, 3, 4, 5]) 6 >>> find_missing_positive_integer([2, 1, 0, -10, 5, 7]) 3 >>> find_missing_positive_integer([]) 1 >>> find_missing_positive_integer([4, 5, 3, 6, 8, 9, 2, 1]) 7","solution":"def find_missing_positive_integer(arr): This function takes a list of integers and returns the minimum positive integer that is missing from the list. n = len(arr) present = [False] * (n + 1) for num in arr: if 1 <= num <= n: present[num] = True for i in range(1, n + 1): if not present[i]: return i return n + 1"},{"question":"def can_be_transformed_by_swaps(list1, list2): Determines if one list can be transformed into another by performing any number of swaps within the same list. Args: list1 (List[int]): The first list of integers. list2 (List[int]): The second list of integers. Returns: bool: True if one list can be transformed into the other by swaps, False otherwise. >>> can_be_transformed_by_swaps([1, 2, 3], [3, 2, 1]) True >>> can_be_transformed_by_swaps([4, 5, 6], [6, 5, 4]) True >>> can_be_transformed_by_swaps([1, 2, 3], [1, 4, 2, 3]) False >>> can_be_transformed_by_swaps([5, 5, 5], [5, 5, 5]) True >>> can_be_transformed_by_swaps([1, 2, 3], [4, 5, 6]) False","solution":"def can_be_transformed_by_swaps(list1, list2): Determines if one list can be transformed into another by performing any number of swaps within the same list. if len(list1) != len(list2): return False return sorted(list1) == sorted(list2)"},{"question":"def reverseWords(sentence: str) -> str: Reverses the characters of each word in the sentence while preserving the order of the words. Args: sentence (str): The input sentence containing words. Returns: str: The sentence with each word reversed. >>> reverseWords(\\"The sky is blue\\") \\"ehT yks si eulb\\" >>> reverseWords(\\"Hello World\\") \\"olleH dlroW\\" >>> reverseWords(\\"Python is fun\\") \\"nohtyP si nuf\\" >>> reverseWords(\\"OpenAI\\") \\"IAnepO\\"","solution":"def reverseWords(sentence): Reverses the characters of each word in the sentence while preserving the order of the words. Args: sentence (str): The input sentence containing words. Returns: str: The sentence with each word reversed. # Split the sentence into words words = sentence.split() # Reverse each word and join them back with a single space reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBST(root) -> bool: Determine if the binary tree is a binary search tree (BST). >>> node1 = TreeNode(val=1) >>> node3 = TreeNode(val=3) >>> root = TreeNode(val=2, left=node1, right=node3) >>> isBST(root) True >>> node1 = TreeNode(val=1) >>> node3 = TreeNode(val=3) >>> node4 = TreeNode(val=4, left=node3, right=TreeNode(val=6)) >>> root = TreeNode(val=5, left=node1, right=node4) >>> isBST(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBST(root) -> bool: def validate(node, low=-float('inf'), high=float('inf')): if not node: return True if not (low < node.val < high): return False return (validate(node.left, low, node.val) and validate(node.right, node.val, high)) return validate(root)"},{"question":"def analyze_war_instructions(commands: List[str]) -> dict: Processes a list of commands issued in a strategic war game and returns a summary. The function processes commands in the format \\"MOVE <source> <destination>\\" or \\"ATTACK <target> <force>\\". It returns a dictionary with the total number of move commands, total number of attack commands, points involved in more than one command, and points where attacks occurred. >>> analyze_war_instructions([\\"MOVE A B\\", \\"ATTACK C 30\\", \\"MOVE C D\\", \\"ATTACK A 20\\", \\"MOVE B C\\"]) {'total_moves': 3, 'total_attacks': 2, 'multiple_use_points': ['A', 'B', 'C'], 'attack_points': ['C', 'A']} >>> analyze_war_instructions([\\"MOVE X Y\\", \\"ATTACK Z 50\\"]) {'total_moves': 1, 'total_attacks': 1, 'multiple_use_points': [], 'attack_points': ['Z']} >>> analyze_war_instructions([\\"MOVE A B\\"]) {'total_moves': 1, 'total_attacks': 0, 'multiple_use_points': [], 'attack_points': []} >>> analyze_war_instructions([\\"ATTACK A 50\\", \\"ATTACK A 40\\", \\"MOVE A B\\"]) {'total_moves': 1, 'total_attacks': 2, 'multiple_use_points': ['A'], 'attack_points': ['A']} >>> analyze_war_instructions([]) {'total_moves': 0, 'total_attacks': 0, 'multiple_use_points': [], 'attack_points': []}","solution":"def analyze_war_instructions(commands): Processes a list of commands and returns a summary of moves, attacks, points involved in multiple commands, and points where attacks occurred. total_moves = 0 total_attacks = 0 point_usage = {} attack_points = set() for command in commands: parts = command.split() if parts[0] == \\"MOVE\\": _, source, destination = parts total_moves += 1 point_usage[source] = point_usage.get(source, 0) + 1 point_usage[destination] = point_usage.get(destination, 0) + 1 elif parts[0] == \\"ATTACK\\": _, target, _ = parts total_attacks += 1 point_usage[target] = point_usage.get(target, 0) + 1 attack_points.add(target) multiple_use_points = [point for point, count in point_usage.items() if count > 1] return { \\"total_moves\\": total_moves, \\"total_attacks\\": total_attacks, \\"multiple_use_points\\": multiple_use_points, \\"attack_points\\": list(attack_points) }"},{"question":"from typing import List def find_beautiful_words(words: List[str], k: int) -> List[str]: We have a list of words and an integer k. A word is considered \\"beautiful\\" if it can form a substring of itself that is a palindrome of at least length k. Write a function that returns the list of \\"beautiful\\" words from the given list. A palindrome is a string that reads the same backward as forward. >>> find_beautiful_words([\\"racecar\\", \\"radar\\", \\"helix\\", \\"refer\\"], 3) [\\"racecar\\", \\"radar\\", \\"refer\\"] >>> find_beautiful_words([\\"a\\", \\"b\\", \\"c\\"], 1) [\\"a\\", \\"b\\", \\"c\\"] >>> find_beautiful_words([\\"abc\\", \\"def\\", \\"ghi\\"], 2) [] >>> find_beautiful_words([\\"aa\\", \\"bb\\", \\"cc\\"], 2) [\\"aa\\", \\"bb\\", \\"cc\\"] >>> find_beautiful_words([\\"helloolleh\\", \\"abcdefgh\\", \\"noon\\", \\"wow\\"], 4) [\\"helloolleh\\", \\"noon\\"] >>> find_beautiful_words([\\"abacdfgdcaba\\", \\"abacdfgdcabaabacdfgdcaba\\"], 10) [\\"abacdfgdcabaabacdfgdcaba\\"] >>> find_beautiful_words([\\"a\\" * 100] * 100000, 50) [\\"a\\" * 100] * 100000","solution":"from typing import List def is_palindrome(s: str) -> bool: return s == s[::-1] def find_beautiful_words(words: List[str], k: int) -> List[str]: beautiful_words = [] for word in words: found = False for i in range(len(word) - k + 1): for j in range(i + k, len(word) + 1): if is_palindrome(word[i:j]): beautiful_words.append(word) found = True break if found: break return beautiful_words"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups words into anagram groups. Args: words (List[str]): A list of words to be grouped. Returns: List[List[str]]: A list of lists where each inner list contains anagram words. >>> group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gooegl\\", \\"rat\\", \\"tar\\", \\"art\\"]) [['listen', 'silent', 'enlist'], ['google', 'gooegl'], ['rat', 'tar', 'art']] >>> group_anagrams([\\"apple\\", \\"banana\\", \\"carrot\\"]) [['apple'], ['banana'], ['carrot']] >>> group_anagrams([\\"a\\", \\"b\\", \\"c\\", \\"a\\"]) [['a', 'a'], ['b'], ['c']] >>> group_anagrams([\\"aab\\", \\"aba\\", \\"baa\\", \\"xyz\\", \\"yxz\\"]) [['aab', 'aba', 'baa'], ['xyz', 'yxz']] >>> group_anagrams([]) []","solution":"from typing import List from collections import defaultdict def group_anagrams(words: List[str]) -> List[List[str]]: Groups words into anagram groups. Args: words (List[str]): A list of words to be grouped. Returns: List[List[str]]: A list of lists where each inner list contains anagram words. anagram_dict = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagram_dict[sorted_word].append(word) return list(anagram_dict.values())"},{"question":"def longest_binary_gap(n: int) -> int: Returns the length of the longest binary gap in the binary representation of n. A binary gap is defined as the maximum number of consecutive zeros that are surrounded by ones at both ends. >>> longest_binary_gap(9) 2 >>> longest_binary_gap(529) 4 >>> longest_binary_gap(20) 1 >>> longest_binary_gap(15) 0 >>> longest_binary_gap(2147483647) 0","solution":"def longest_binary_gap(n): Returns the length of the longest binary gap in the binary representation of n. A binary gap is defined as the maximum number of consecutive zeros that are surrounded by ones at both ends. binary_rep = bin(n)[2:] max_gap = 0 current_gap = 0 in_gap = False for bit in binary_rep: if bit == '1': if in_gap: max_gap = max(max_gap, current_gap) in_gap = True current_gap = 0 elif in_gap: current_gap += 1 return max_gap"},{"question":"def max_area_of_island(grid): Find the maximum area of an island in the grid. An island is a group of contiguous '1's connected horizontally or vertically (not diagonally). Args: grid: List[List[str]] - The grid of '0's (water) and '1's (land). Returns: int: The maximum area of an island in the grid. Test cases: >>> max_area_of_island([ ['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1'] ]) 4 >>> max_area_of_island([ ['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '0', '0'] ]) 4 >>> max_area_of_island([ ['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0'] ]) 0 >>> max_area_of_island([ ['1', '1', '1', '1', '1'], ['1', '1', '1', '1', '1'], ['1', '1', '1', '1', '1'], ['1', '1', '1', '1', '1'] ]) 20 >>> max_area_of_island([ ['1', '0', '1', '0', '1'], ['0', '1', '0', '1', '0'], ['1', '0', '1', '0', '1'], ['0', '1', '0', '1', '0'] ]) 1","solution":"def max_area_of_island(grid): if not grid: return 0 def dfs(r, c): if r < 0 or c < 0 or r >= len(grid) or c >= len(grid[0]) or grid[r][c] == '0': return 0 grid[r][c] = '0' # mark as visited area = 1 area += dfs(r + 1, c) area += dfs(r - 1, c) area += dfs(r, c + 1) area += dfs(r, c - 1) return area max_area = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == '1': max_area = max(max_area, dfs(r, c)) return max_area"},{"question":"def two_sum_exists(n: int, k: int, array: list[int]) -> str: Determines if there are two distinct indices i and j in the array such that the sum of array[i] and array[j] is equal to k. >>> two_sum_exists(5, 9, [2, 7, 11, 15, 1]) \\"YES\\" >>> two_sum_exists(5, 17, [2, 7, 11, 15, 1]) \\"YES\\" >>> two_sum_exists(5, 10, [2, 7, 11, 15, 1]) \\"NO\\" >>> two_sum_exists(3, 5, [3, 2, 1]) \\"YES\\" >>> two_sum_exists(3, 6, [3, 2, 1]) \\"NO\\" >>> two_sum_exists(2, 0, [-1, 1]) \\"YES\\" >>> two_sum_exists(3, 0, [-1, 1, 0]) \\"YES\\" >>> two_sum_exists(2, 2, [1, 1]) \\"YES\\" >>> two_sum_exists(3, 2, [1, 1, 2]) \\"YES\\" >>> two_sum_exists(4, 5, [5, 0, -5, 10]) \\"YES\\"","solution":"def two_sum_exists(n, k, array): Determines if there are two distinct indices i and j in the array such that the sum of array[i] and array[j] is equal to k. Parameters: n (int): The number of elements in the array. k (int): The target sum to find. array (list of int): The list of integers. Returns: str: \\"YES\\" if such indices exist, \\"NO\\" otherwise. seen = set() for num in array: if (k - num) in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"from typing import Dict def parse_formula(formula: str) -> Dict[str, int]: Parse the chemical formula and return a dictionary with the count of each atom. The function takes a string that represents a chemical formula (like \\"H2O\\", \\"Mg(OH)2\\", or \\"K4[ON(SO3)2]2\\") and returns a dictionary with the count of each atom in the molecule. Examples: >>> parse_formula(\\"H2O\\") {'H': 2, 'O': 1} >>> parse_formula(\\"Mg(OH)2\\") {'Mg': 1, 'O': 2, 'H': 2} >>> parse_formula(\\"K4[ON(SO3)2]2\\") {'K': 4, 'O': 14, 'N': 2, 'S': 4} >>> parse_formula(\\"CO2\\") {'C': 1, 'O': 2} >>> parse_formula(\\"C6H12O6\\") {'C': 6, 'H': 12, 'O': 6} >>> parse_formula(\\"Al2(SO4)3\\") {'Al': 2, 'S': 3, 'O': 12} >>> parse_formula(\\"\\") {} >>> parse_formula(\\"H2SO4NH4NO3\\") {'H': 6, 'S': 1, 'O': 7, 'N': 2}","solution":"import re from collections import defaultdict def parse_formula(formula): Parse the chemical formula and return a dictionary with the count of each atom. def multiply_counts(molecule_counts, multiplier): for atom in molecule_counts: molecule_counts[atom] *= multiplier return molecule_counts def merge_counts(count1, count2): result = defaultdict(int, count1) for atom, count in count2.items(): result[atom] += count return result def parse_segment(segment): atom_counts = defaultdict(int) stack = [] i = 0 while i < len(segment): if segment[i] == '(' or segment[i] == '[': stack.append((atom_counts, i)) atom_counts = defaultdict(int) i += 1 elif segment[i] == ')' or segment[i] == ']': i += 1 start_atom_counts, start_index = stack.pop() multiplier = 1 if i < len(segment) and segment[i].isdigit(): match = re.match(r'd+', segment[i:]) multiplier = int(match.group()) i += len(match.group()) atom_counts = multiply_counts(atom_counts, multiplier) atom_counts = merge_counts(start_atom_counts, atom_counts) else: match = re.match(r'[A-Z][a-z]*', segment[i:]) element = match.group() i += len(element) count = 1 if i < len(segment) and segment[i].isdigit(): match = re.match(r'd+', segment[i:]) count = int(match.group()) i += len(match.group()) atom_counts[element] += count return atom_counts return parse_segment(formula)"},{"question":"def sequence_statistics(sequence: List[int]) -> Tuple[int, int, int]: Takes a sequence of integers and returns the minimum, maximum, and sum. :param sequence: List[int] - A list of space-separated integers :return: Tuple[int, int, int] - (min_value, max_value, total_sum) >>> sequence_statistics([1, 2, 3, 4, 5]) (1, 5, 15) >>> sequence_statistics([-10, 5, 3, 99, -3]) (-10, 99, 94) from solution import sequence_statistics def test_sequence_statistics_basic(): assert sequence_statistics([1, 2, 3, 4, 5]) == (1, 5, 15) def test_sequence_statistics_negative(): assert sequence_statistics([-10, 5, 3, 99, -3]) == (-10, 99, 94) def test_sequence_statistics_mixed(): assert sequence_statistics([10, 0, -10]) == (-10, 10, 0) def test_sequence_statistics_single_element(): assert sequence_statistics([5]) == (5, 5, 5) def test_sequence_statistics_large_numbers(): assert sequence_statistics([1000000, -1000000, 999999, -999999]) == (-1000000, 1000000, 0)","solution":"def sequence_statistics(sequence): Takes a sequence of integers and returns the minimum, maximum, and sum. :param sequence: List[int] - A list of space-separated integers :return: Tuple[int, int, int] - (min_value, max_value, total_sum) min_value = min(sequence) max_value = max(sequence) total_sum = sum(sequence) return min_value, max_value, total_sum"},{"question":"import math from typing import List, Tuple def is_prime(number: int) -> bool: Returns whether a number is a prime number. pass def find_element_to_remove_for_prime_product(arr: List[int]) -> int: Tries to find an element whose removal makes the product of remaining elements a prime number. pass def solve_prime_product_problem(test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[str, int]]: Solves the prime product problem for each test case. pass def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(17) == True assert is_prime(18) == False def test_find_element_to_remove_for_prime_product(): assert find_element_to_remove_for_prime_product([2, 3, 4, 6]) == -1 assert find_element_to_remove_for_prime_product([6, 10, 15]) == -1 assert find_element_to_remove_for_prime_product([7, 9, 11, 13, 17]) == -1 def test_solve_prime_product_problem(): test_cases = [ (4, [2, 3, 4, 6]), (3, [6, 10, 15]), (5, [7, 9, 11, 13, 17]) ] expected_results = [ (\\"No\\",), (\\"No\\",), (\\"No\\",) ] assert solve_prime_product_problem(test_cases) == expected_results if __name__ == \\"__main__\\": test_is_prime() test_find_element_to_remove_for_prime_product() test_solve_prime_product_problem()","solution":"def is_prime(number): Returns whether a number is a prime number. if number <= 1: return False if number <= 3: return True if number % 2 == 0 or number % 3 == 0: return False i = 5 while i * i <= number: if number % i == 0 or number % (i + 2) == 0: return False i += 6 return True def find_element_to_remove_for_prime_product(arr): Tries to find an element whose removal makes the product of remaining elements a prime number. total_product = 1 for num in arr: total_product *= num for i, num in enumerate(arr): if total_product % num == 0 and is_prime(total_product // num): return i + 1 # Return 1-based index return -1 def solve_prime_product_problem(test_cases): results = [] for n, arr in test_cases: index = find_element_to_remove_for_prime_product(arr) if index != -1: results.append((\\"Yes\\", index)) else: results.append((\\"No\\",)) return results"},{"question":"def trap_rain_water(heights: List[int]) -> int: Computes the amount of water that can be trapped after a rainstorm given the heights of buildings. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([]) 0 >>> trap_rain_water([5]) 0 >>> trap_rain_water([3, 3, 3, 3]) 0 >>> trap_rain_water([1, 2, 3, 4, 5]) 0 >>> trap_rain_water([5, 4, 3, 2, 1]) 0 >>> trap_rain_water([0, 2, 0, 2]) 2 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) 9","solution":"def trap_rain_water(heights): Computes the amount of water that can be trapped after a rainstorm given the heights of buildings. :param heights: List[int] - List of non-negative integers representing the building heights. :return: Int - Total amount of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def evaluate_rpn(expression: str) -> float: Evaluates a Reverse Polish Notation (RPN) expression. Parameters: expression (str): A string containing the RPN expression. Returns: float: The result of the evaluation. >>> evaluate_rpn(\\"3 4 +\\") 7.0 >>> evaluate_rpn(\\"5 1 2 + 4 * + 3 -\\") 14.0 >>> evaluate_rpn(\\"2 3 * 5 +\\") 11.0 >>> evaluate_rpn(\\"15 7 1 1 + - / 3 * 2 1 1 + + -\\") 5.0 >>> evaluate_rpn(\\"10 2 /\\") 5.0 >>> evaluate_rpn(\\"4 2 + 3 5 1 - * +\\") 18.0","solution":"def evaluate_rpn(expression): Evaluates a Reverse Polish Notation (RPN) expression. Parameters: expression (str): A string containing the RPN expression. Returns: float: The result of the evaluation. stack = [] tokens = expression.split() for token in tokens: if token in {\\"+\\", \\"-\\", \\"*\\", \\"/\\"}: b = stack.pop() a = stack.pop() if token == \\"+\\": result = a + b elif token == \\"-\\": result = a - b elif token == \\"*\\": result = a * b elif token == \\"/\\": result = a / b stack.append(result) else: stack.append(float(token)) return stack[0]"},{"question":"def lap_metrics(times): Calculate various metrics from the list of lap times. Args: times (List[int]): A list of non-negative integers representing lap times in seconds. Returns: dict: A dictionary containing total_time, average_time, best_time, worst_time, and median_time. If the list is empty, returns a dictionary with all values set to None. Examples: >>> lap_metrics([120, 150, 98, 110, 135]) {'total_time': 613, 'average_time': 122.6, 'best_time': 98, 'worst_time': 150, 'median_time': 120} >>> lap_metrics([]) {'total_time': None, 'average_time': None, 'best_time': None, 'worst_time': None, 'median_time': None}","solution":"def lap_metrics(times): Calculate various metrics from the list of lap times. if not times: return { \\"total_time\\": None, \\"average_time\\": None, \\"best_time\\": None, \\"worst_time\\": None, \\"median_time\\": None } total_time = sum(times) average_time = round(total_time / len(times), 1) best_time = min(times) worst_time = max(times) sorted_times = sorted(times) mid = len(sorted_times) // 2 if len(sorted_times) % 2 == 0: median_time = (sorted_times[mid - 1] + sorted_times[mid]) / 2.0 else: median_time = sorted_times[mid] return { \\"total_time\\": total_time, \\"average_time\\": average_time, \\"best_time\\": best_time, \\"worst_time\\": worst_time, \\"median_time\\": median_time }"},{"question":"from typing import List, Optional from collections import deque class Node: def __init__(self, key): self.left = None self.right = None self.val = key def LevelOrderTraversal(root: Optional[Node]) -> List[int]: Perform a level order traversal of a binary tree. Args: root (Node): The root node of the binary tree. Returns: List[int]: A list of node values in level order. >>> root = Node(3) >>> root.left = Node(9) >>> root.right = Node(20) >>> root.right.left = Node(15) >>> root.right.right = Node(7) >>> LevelOrderTraversal(root) [3, 9, 20, 15, 7] >>> LevelOrderTraversal(None) [] >>> root = Node(1) >>> root.left = Node(2) >>> root.left.left = Node(3) >>> LevelOrderTraversal(root) [1, 2, 3]","solution":"from collections import deque class Node: def __init__(self, key): self.left = None self.right = None self.val = key def LevelOrderTraversal(root): Perform a level order traversal of a binary tree. Args: root (Node): The root node of the binary tree. Returns: List[int]: A list of node values in level order. if not root: return [] result = [] queue = deque([root]) while queue: node = queue.popleft() result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"def count_unique_colors(image_pixels): Returns the number of unique colors in the image. Parameters: image_pixels (list of lists): A list of pixels where each pixel is represented by a list containing three integers (R, G, B). Returns: int: The number of unique colors in the image. >>> count_unique_colors([[0, 0, 0], [0, 0, 0]]) 1 >>> count_unique_colors([[255, 0, 0], [0, 255, 0], [0, 0, 255], [255, 255, 0]]) 4 >>> count_unique_colors([[255, 0, 0], [255, 0, 0], [0, 255, 0], [0, 255, 0], [0, 0, 255]]) 3 >>> count_unique_colors([]) 0 >>> count_unique_colors([[10, 10, 10], [20, 20, 20], [30, 30, 30], [40, 40, 40], [50, 50, 50], [60, 60, 60], [70, 70, 70], [80, 80, 80]]) 8 >>> count_unique_colors([[128, 128, 128] for _ in range(100)]) 1","solution":"def count_unique_colors(image_pixels): Returns the number of unique colors in the image. Parameters: image_pixels (list of lists): A list of pixels where each pixel is represented by a list containing three integers (R, G, B). Returns: int: The number of unique colors in the image. unique_colors = {tuple(pixel) for pixel in image_pixels} return len(unique_colors)"},{"question":"def elements_with_even_indices(lst: List[int]) -> List[int]: Given a list of integers, return a new list containing only elements that have even indices. Args: lst (List[int]): A list of integers. Returns: List[int]: A list containing elements from even indices of the input list. Examples: >>> elements_with_even_indices([17, 42, 33, 80, 75, 19]) [17, 33, 75] >>> elements_with_even_indices([1, 3, 5, 7, 9]) [1, 5, 9] >>> elements_with_even_indices([]) [] >>> elements_with_even_indices([4, 4, 4, 4, 4, 4, 4, 4]) [4, 4, 4, 4] >>> elements_with_even_indices([10]) [10] def test_even_indices(): assert elements_with_even_indices([17, 42, 33, 80, 75, 19]) == [17, 33, 75] assert elements_with_even_indices([1, 3, 5, 7, 9]) == [1, 5, 9] assert elements_with_even_indices([]) == [] assert elements_with_even_indices([4, 4, 4, 4, 4, 4, 4, 4]) == [4, 4, 4, 4] assert elements_with_even_indices([10]) == [10] # Additional tests assert elements_with_even_indices([2, 3, 2, 3, 2, 3]) == [2, 2, 2] assert elements_with_even_indices([0, 1, 2, 3, 4, 5]) == [0, 2, 4]","solution":"def elements_with_even_indices(lst): Given a list of integers, return a new list containing only elements that have even indices. return [lst[i] for i in range(len(lst)) if i % 2 == 0]"},{"question":"def knight_moves(position: str) -> List[str]: Given a position of the knight on a chessboard, return a list of all possible positions the knight can move to in its next move. The positions are sorted lexicographically. >>> knight_moves(\\"g2\\") [\\"e1\\", \\"e3\\", \\"f4\\", \\"h4\\"] >>> knight_moves(\\"d5\\") [\\"b4\\", \\"b6\\", \\"c3\\", \\"c7\\", \\"e3\\", \\"e7\\", \\"f4\\", \\"f6\\"] from solution import knight_moves def test_knight_moves_edge_positions(): assert knight_moves(\\"a1\\") == [\\"b3\\", \\"c2\\"] assert knight_moves(\\"h8\\") == [\\"f7\\", \\"g6\\"] def test_knight_moves_center_positions(): assert knight_moves(\\"d4\\") == [\\"b3\\", \\"b5\\", \\"c2\\", \\"c6\\", \\"e2\\", \\"e6\\", \\"f3\\", \\"f5\\"] assert knight_moves(\\"e5\\") == [\\"c4\\", \\"c6\\", \\"d3\\", \\"d7\\", \\"f3\\", \\"f7\\", \\"g4\\", \\"g6\\"] def test_knight_moves_edge_case(): assert knight_moves(\\"b1\\") == [\\"a3\\", \\"c3\\", \\"d2\\"] def test_knight_moves_middle_of_board(): assert knight_moves(\\"g2\\") == [\\"e1\\", \\"e3\\", \\"f4\\", \\"h4\\"] assert knight_moves(\\"d5\\") == [\\"b4\\", \\"b6\\", \\"c3\\", \\"c7\\", \\"e3\\", \\"e7\\", \\"f4\\", \\"f6\\"] def test_knight_moves_corner_positions(): assert knight_moves(\\"a8\\") == [\\"b6\\", \\"c7\\"] assert knight_moves(\\"h1\\") == [\\"f2\\", \\"g3\\"]","solution":"def knight_moves(position): Given a position of the knight on a chessboard, this function returns all possible positions the knight can move to in its next move. The positions are sorted lexicographically. :param position: A string representing the knight's position on the chessboard (e.g., 'a1', 'e4'). :return: A list of strings representing all possible positions the knight can move to. col, row = position col = ord(col) - ord('a') + 1 row = int(row) moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)] next_positions = [] for dc, dr in moves: new_col = col + dc new_row = row + dr if 1 <= new_col <= 8 and 1 <= new_row <= 8: next_positions.append(f\\"{chr(ord('a') + new_col - 1)}{new_row}\\") return sorted(next_positions)"},{"question":"from typing import List, Tuple def find_extremes(timestamps: List[str]) -> Tuple[str, str]: Returns the earliest and latest timestamps from a list of timestamps. Parameters: timestamps (list): A list of timestamps represented as strings in the format 'YYYY-MM-DD HH:MM:SS'. Returns: tuple: A tuple containing the earliest and latest timestamps. >>> find_extremes([\\"2023-10-01 18:30:00\\", \\"2021-04-15 12:00:00\\", \\"2022-08-23 07:45:30\\"]) (\\"2021-04-15 12:00:00\\", \\"2023-10-01 18:30:00\\") >>> find_extremes([\\"2023-01-01 00:00:00\\", \\"2023-12-31 23:59:59\\", \\"2023-06-15 12:30:00\\"]) (\\"2023-01-01 00:00:00\\", \\"2023-12-31 23:59:59\\") >>> find_extremes([\\"2023-10-01 00:00:00\\", \\"2023-10-01 23:59:59\\", \\"2023-10-01 12:00:00\\"]) (\\"2023-10-01 00:00:00\\", \\"2023-10-01 23:59:59\\") >>> find_extremes([\\"2021-01-01 00:00:00\\", \\"2022-01-01 00:00:00\\", \\"2023-01-01 00:00:00\\"]) (\\"2021-01-01 00:00:00\\", \\"2023-01-01 00:00:00\\") >>> find_extremes([\\"2021-04-01 13:45:00\\", \\"2021-04-01 13:46:00\\"]) (\\"2021-04-01 13:45:00\\", \\"2021-04-01 13:46:00\\")","solution":"def find_extremes(timestamps): Returns the earliest and latest timestamps from a list of timestamps. Parameters: timestamps (list): A list of timestamps represented as strings in the format 'YYYY-MM-DD HH:MM:SS'. Returns: tuple: A tuple containing the earliest and latest timestamps. sorted_timestamps = sorted(timestamps) return (sorted_timestamps[0], sorted_timestamps[-1])"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root: TreeNode, targetSum: int) -> bool: Determines if there exists a path from the root node to any leaf node such that the sum of the node values in the path equals the target sum. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(1) >>> hasPathSum(root, 22) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> hasPathSum(root, 5) False >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> hasPathSum(root, 1) False pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root, targetSum): if not root: return False if not root.left and not root.right and root.val == targetSum: return True targetSum -= root.val return hasPathSum(root.left, targetSum) or hasPathSum(root.right, targetSum)"},{"question":"from typing import List, Tuple def preprocess_grid(grid: List[List[int]]) -> List[List[int]]: Preprocess the grid to find prefix sums. >>> preprocess_grid([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[0, 0, 0, 0], [0, 1, 3, 6], [0, 5, 12, 21], [0, 12, 27, 45]] def query_sum(prefix_sum: List[List[int]], r1: int, c1: int, r2: int, c2: int) -> int: Calculate the total number of spores in the subgrid. >>> prefix_sum = [[0, 0, 0, 0], [0, 1, 3, 6], [0, 5, 12, 21], [0, 12, 27, 45]] >>> query_sum(prefix_sum, 1, 1, 2, 2) 12 >>> query_sum(prefix_sum, 2, 2, 3, 3) 28 def solve(N: int, M: int, grid: List[List[int]], Q: int, queries: List[Tuple[int, int, int, int]]) -> List[int]: Return the number of spores for each query. >>> N = 3 >>> M = 3 >>> grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> Q = 2 >>> queries = [(1, 1, 2, 2), (2, 2, 3, 3)] >>> solve(N, M, grid, Q, queries) [12, 28]","solution":"def preprocess_grid(grid): N = len(grid) M = len(grid[0]) prefix_sum = [[0] * (M + 1) for _ in range(N + 1)] for i in range(1, N + 1): for j in range(1, M + 1): prefix_sum[i][j] = grid[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] return prefix_sum def query_sum(prefix_sum, r1, c1, r2, c2): return (prefix_sum[r2][c2] - prefix_sum[r1-1][c2] - prefix_sum[r2][c1-1] + prefix_sum[r1-1][c1-1]) def solve(N, M, grid, Q, queries): prefix_sum = preprocess_grid(grid) results = [] for r1, c1, r2, c2 in queries: results.append(query_sum(prefix_sum, r1, c1, r2, c2)) return results"},{"question":"def remove_vowels(s: str) -> str: Removes all vowels from the input string. >>> remove_vowels(\\"hello world\\") == \\"hll wrld\\" >>> remove_vowels(\\"Python Programming\\") == \\"Pythn Prgrmmng\\" >>> remove_vowels(\\"This is a TEST\\") == \\"Ths s TST\\" >>> remove_vowels(\\"AeIoU\\") == \\"\\" >>> remove_vowels(\\"bcdfg\\") == \\"bcdfg\\" >>> remove_vowels(\\"BCDFG\\") == \\"BCDFG\\" >>> remove_vowels(\\"\\") == \\"\\" >>> remove_vowels(\\"123!@#aeiou\\") == \\"123!@#\\" >>> remove_vowels(\\"AEIOU\\") == \\"\\"","solution":"def remove_vowels(s): Returns the string with all vowels removed. vowels = \\"aeiouAEIOU\\" return ''.join([char for char in s if char not in vowels])"},{"question":"def wave(s: str) -> list: Generates a wave pattern for the given string. Args: s (str): The input string, consisting of lowercase letters and spaces. Returns: list of str: A list of strings, each representing a step in the wave pattern. Example: >>> wave(\\"hello\\") [\\"Hello\\", \\"hEllo\\", \\"heLlo\\", \\"helLo\\", \\"hellO\\"] >>> wave(\\"two words\\") [\\"Two words\\", \\"tWo words\\", \\"twO words\\", \\"two Words\\", \\"two wOrds\\", \\"two woRds\\", \\"two worDs\\", \\"two wordS\\"]","solution":"def wave(s): Generates a wave pattern for the given string. Args: s (str): The input string, consisting of lowercase letters and spaces. Returns: list of str: A list of strings, each representing a step in the wave pattern. result = [] for i, char in enumerate(s): if char.isalpha(): wave_str = s[:i] + char.upper() + s[i+1:] result.append(wave_str) return result"},{"question":"def next_closest_time(time: str) -> str: Finds the next closest time that can be formed using the same digits currently present in the input time. >>> next_closest_time(\\"19:34\\") \\"19:39\\" >>> next_closest_time(\\"23:59\\") \\"22:22\\" >>> next_closest_time(\\"01:32\\") \\"01:33\\" >>> next_closest_time(\\"12:21\\") \\"12:22\\"","solution":"def next_closest_time(time): def get_all_possible_times(digits): # Generate all possible times sorted possible_times = set() for h1 in digits: for h2 in digits: if int(h1 + h2) < 24: for m1 in digits: for m2 in digits: if int(m1 + m2) < 60: possible_times.add(f\\"{h1}{h2}:{m1}{m2}\\") return sorted(possible_times) # Extract digits from the given time original_digits = sorted(time.replace(\\":\\", \\"\\")) # Get all valid times valid_times = get_all_possible_times(original_digits) # Find the next closest time in the list current_index = valid_times.index(time) next_index = (current_index + 1) % len(valid_times) return valid_times[next_index] # Example usage print(next_closest_time(\\"19:34\\")) # Output: \\"19:39\\" print(next_closest_time(\\"23:59\\")) # Output: \\"22:22\\""},{"question":"from typing import List def find_words(board: List[List[str]], words: List[str]) -> List[str]: Given a grid of characters and a list of words, return all words that can be found in the grid. Each word must be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once per word. Example 1: >>> find_words([['o','a','a','n'], ['e','t','a','e'], ['i','h','k','r'], ['i','f','l','v']], ['oath', 'pea', 'eat', 'rain']) ['oath', 'eat'] Example 2: >>> find_words([['a','b'], ['c','d']], ['abcb']) [] Constraints: * 1 <= board.length <= 12 * 1 <= board[i].length <= 12 * 1 <= words.length <= 10^3 * 1 <= words[i].length <= 10 * board[i][j] and words[i] consist of lowercase English letters.","solution":"def find_words(board, words): Given a 2D board and a list of words, return all words that can be found in the board. def dfs(board, word, i, j, k): if k == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]: return False temp, board[i][j] = board[i][j], \\"#\\" found = (dfs(board, word, i + 1, j, k + 1) or dfs(board, word, i - 1, j, k + 1) or dfs(board, word, i, j + 1, k + 1) or dfs(board, word, i, j - 1, k + 1)) board[i][j] = temp return found found_words = [] for word in words: if any(dfs(board, word, i, j, 0) for i in range(len(board)) for j in range(len(board[0]))): found_words.append(word) return found_words"},{"question":"from typing import List, Tuple def max_subarray_sum(arr: List[int]) -> int: Finds the maximum sum of a contiguous subarray. Args: arr: List of integers Returns: Integer representing the maximum sum of the contiguous subarray. Examples: >>> max_subarray_sum([1, 2, 3, -2, 5]) 9 >>> max_subarray_sum([-1, -2, -3, -4]) -1 pass def solve_max_subarray(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Solves the problem for the given test cases and returns the results. Args: test_cases: List of tuples, where each tuple contains an integer N and a list of integers Returns: List of integers representing the maximum sum of the contiguous subarrays for each test case. Examples: >>> solve_max_subarray([(5, [1, 2, 3, -2, 5]), (4, [-1, -2, -3, -4])]) [9, -1] pass def test_max_subarray_sum_examples(): assert max_subarray_sum([1, 2, 3, -2, 5]) == 9 assert max_subarray_sum([-1, -2, -3, -4]) == -1 def test_max_subarray_sum_single_element(): assert max_subarray_sum([1]) == 1 assert max_subarray_sum([-1]) == -1 def test_max_subarray_sum_mixed_numbers(): assert max_subarray_sum([4, -1, 2, 1]) == 6 assert max_subarray_sum([2, -1, 2, 3, 4, -5]) == 10 def test_solve_max_subarray(): test_cases = [ (5, [1, 2, 3, -2, 5]), (4, [-1, -2, -3, -4]) ] assert solve_max_subarray(test_cases) == [9, -1] test_cases = [ (4, [4, -1, 2, 1]), (6, [2, -1, 2, 3, 4, -5]) ] assert solve_max_subarray(test_cases) == [6, 10]","solution":"def max_subarray_sum(arr): Finds the maximum sum of a contiguous subarray using Kadane's algorithm. max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far def solve_max_subarray(test_cases): Solves the problem for the given test cases and returns the results. results = [] for case in test_cases: _, arr = case # We don't particularly need the length N, hence ignored results.append(max_subarray_sum(arr)) return results"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string s, find the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. if not s: return 0 max_length = 0 start = 0 char_index_map = {} for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def increment_by_index(lst: List[int]) -> List[int]: Takes a list of integers and returns a list with each integer incremented by its index in the original list. Returns an empty list if the input list is empty. >>> increment_by_index([]) [] >>> increment_by_index([0, 1, 2, 3]) [0, 2, 4, 6] >>> increment_by_index([-5, 0, 5]) [-5, 1, 7]","solution":"def increment_by_index(lst): Takes a list of integers and returns a list with each integer incremented by its index in the original list. Returns an empty list if the input list is empty. return [num + idx for idx, num in enumerate(lst)]"},{"question":"def are_all_characters_unique(s: str) -> bool: Check if all characters in the input string are unique. :param s: str: A string consisting of alphabetic characters :return: bool: True if all characters are unique, False otherwise >>> are_all_characters_unique('abcdef') True >>> are_all_characters_unique('abcdea') False >>> are_all_characters_unique('') True >>> are_all_characters_unique('a') True >>> are_all_characters_unique('aA') True >>> are_all_characters_unique('aAa') False","solution":"def are_all_characters_unique(s): Check if all characters in the input string are unique. :param s: str - A string consisting of alphabetic characters :return: bool - True if all characters are unique, False otherwise return len(set(s)) == len(s)"},{"question":"def longest_substring_without_repeating(s: str) -> int: Create a function that takes a single string word as input and returns the length of its longest substring without repeating characters. >>> longest_substring_without_repeating(\\"abcabcbb\\") 3 >>> longest_substring_without_repeating(\\"bbbbb\\") 1 >>> longest_substring_without_repeating(\\"pwwkew\\") 3 >>> longest_substring_without_repeating(\\"c\\") 1 >>> longest_substring_without_repeating(\\"aab\\") 2","solution":"def longest_substring_without_repeating(s): Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"import math def factorials_from_1_to_n(N: int) -> List[str]: Given an integer N, return a list of factorials of integers from 1 to N, formatted as 'i! = factorial'. >>> factorials_from_1_to_n(3) ['1! = 1', '2! = 2', '3! = 6'] >>> factorials_from_1_to_n(5) ['1! = 1', '2! = 2', '3! = 6', '4! = 24', '5! = 120'] pass def process_test_cases(T: int, cases: List[int]) -> str: Process all test cases and return the results for each case of calculating factorials from 1 to the given N. >>> process_test_cases(1, [3]) '1! = 1n2! = 2n3! = 6' >>> process_test_cases(2, [3, 5]) '1! = 1n2! = 2n3! = 6nn1! = 1n2! = 2n3! = 6n4! = 24n5! = 120' pass","solution":"import math def factorials_from_1_to_n(N): result = [] for i in range(1, N + 1): result.append(f\\"{i}! = {math.factorial(i)}\\") return result def process_test_cases(T, cases): results = [] for n in cases: results.append(\\"n\\".join(factorials_from_1_to_n(n))) return \\"nn\\".join(results)"},{"question":"def second_smallest(numbers: List[int]) -> Optional[int]: Finds the second smallest unique number in the given list. :param numbers: List of integers :return: Second smallest unique integer or None if there isn't one >>> second_smallest([4, 2, 7, 1, 8, 3, 6]) == 2 >>> second_smallest([10, 20, 30, 40]) == 20 >>> second_smallest([5, 5, 5, 5, 5]) == None >>> second_smallest([3, -1, 2, 0, 8]) == 0 def test_second_smallest_with_all_unique_numbers(): assert second_smallest([4, 2, 7, 1, 8, 3, 6]) == 2 def test_second_smallest_with_sorted_numbers(): assert second_smallest([10, 20, 30, 40]) == 20 def test_second_smallest_with_all_same_numbers(): assert second_smallest([5, 5, 5, 5, 5]) == None def test_second_smallest_with_negative_and_zero(): assert second_smallest([3, -1, 2, 0, 8]) == 0 def test_second_smallest_with_non_unique_numbers(): assert second_smallest([4, 2, 2, 7, 1, 8, 3, 6]) == 2 def test_second_smallest_with_less_than_two_unique_numbers(): assert second_smallest([1]) == None assert second_smallest([]) == None def test_second_smallest_with_all_negative_numbers(): assert second_smallest([-1, -2, -3, -4, -5]) == -4 def test_second_smallest_with_large_numbers(): assert second_smallest([1000, 2000, 3000, 4000]) == 2000","solution":"def second_smallest(numbers): Finds the second smallest unique number in the given list. :param numbers: List of integers :return: Second smallest unique integer or None if there isn't one unique_numbers = sorted(set(numbers)) if len(unique_numbers) < 2: return None return unique_numbers[1]"},{"question":"def longest_consecutive_subsequence(nums: List[int]) -> int: Given an integer array nums, return the length of the longest subsequence such that all elements of the subsequence are distinct and the difference between any two consecutive elements is exactly 1. If no such subsequence exists, return 0. >>> longest_consecutive_subsequence([1, 2, 2, 3, 1, 4, 5, 6]) 6 >>> longest_consecutive_subsequence([]) 0 >>> longest_consecutive_subsequence([10]) 1 >>> longest_consecutive_subsequence([10, 12, 14]) 1 >>> longest_consecutive_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_consecutive_subsequence([10, 10, 10, 11, 11, 11, 12, 12, 12]) 3 >>> longest_consecutive_subsequence([-2, -1, 0, 1]) 4","solution":"def longest_consecutive_subsequence(nums): Given an integer array nums, returns the length of the longest subsequence such that all elements of the subsequence are distinct and the difference between any two consecutive elements is exactly 1. If no such subsequence exists, return 0. if not nums: return 0 nums = list(set(nums)) nums.sort() longest_streak = 0 current_streak = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1] + 1: current_streak += 1 else: longest_streak = max(longest_streak, current_streak) current_streak = 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def longest_increasing_decreasing_subsequence(n: int, operations: List[int]) -> int: Determine the length of the longest subsequence of operations that fits the pattern: a strictly increasing sequence followed immediately by a strictly decreasing sequence. >>> longest_increasing_decreasing_subsequence(7, [1, 3, 5, 4, 2, 6, 8]) 5 >>> longest_increasing_decreasing_subsequence(6, [6, 5, 4, 3, 2, 1]) 6 >>> longest_increasing_decreasing_subsequence(5, [2, 2, 2, 1, 2]) 2 >>> longest_increasing_decreasing_subsequence(1, [5]) 1 >>> longest_increasing_decreasing_subsequence(5, [1, 3, 5, 7, 8]) 5 >>> longest_increasing_decreasing_subsequence(6, [1, 2, 3, 2, 1, 0]) 6 >>> longest_increasing_decreasing_subsequence(7, [1, 2, 2, 1, 0, 5, 4]) 3","solution":"def longest_increasing_decreasing_subsequence(n, operations): if n == 1: return 1 # dp_increasing[i] will store the length of the longest increasing subsequence ending at i dp_increasing = [1] * n for i in range(1, n): if operations[i] > operations[i - 1]: dp_increasing[i] = dp_increasing[i - 1] + 1 max_length = max(dp_increasing) # dp_decreasing[i] will store the length of the longest decreasing subsequence starting at i dp_decreasing = [1] * n for i in range(n - 2, -1, -1): if operations[i] > operations[i + 1]: dp_decreasing[i] = dp_decreasing[i + 1] + 1 max_length = max(max_length, max(dp_decreasing)) # Compute the longest sequence that first increases, then decreases result = 0 for i in range(1, n - 1): if operations[i - 1] < operations[i] > operations[i + 1]: result = max(result, dp_increasing[i - 1] + dp_decreasing[i + 1] + 1) return max(result, max_length)"},{"question":"def can_make_palindrome(s: str, k: int) -> bool: Determines if the string s can be made a palindrome by deleting at most k characters. >>> can_make_palindrome(\\"abca\\", 1) True >>> can_make_palindrome(\\"abcdef\\", 2) False >>> can_make_palindrome(\\"deeee\\", 1) True >>> can_make_palindrome(\\"racecar\\", 0) True >>> can_make_palindrome(\\"xyz\\", 3) True >>> can_make_palindrome(\\"abba\\", 1) True >>> can_make_palindrome(\\"aabbcc\\", 1) False >>> can_make_palindrome(\\"a\\", 0) True >>> can_make_palindrome(\\"a\\", 1) True >>> can_make_palindrome(\\"aa\\", 0) True >>> can_make_palindrome(\\"ab\\", 1) True >>> can_make_palindrome(\\"ab\\", 0) False","solution":"def can_make_palindrome(s, k): Determines if the string s can be made a palindrome by deleting at most k characters. def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1] longest_palindrome_subseq_length = longest_palindromic_subsequence(s) return len(s) - longest_palindrome_subseq_length <= k"},{"question":"def can_complete_circuit(gas: List[int], cost: List[int]) -> int: Determine if there is a starting gas station where you can complete a circuit. Parameters: gas (list of int): The amount of gas available at each gas station. cost (list of int): The amount of gas required to travel to the next gas station. Returns: int: The starting gas station index if a circuit is possible, otherwise -1. Example: >>> can_complete_circuit([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]) 3 >>> can_complete_circuit([2, 3, 4], [3, 4, 3]) -1","solution":"def can_complete_circuit(gas, cost): Determine if there is a starting gas station where you can complete a circuit. Parameters: gas (list of int): The amount of gas available at each gas station. cost (list of int): The amount of gas required to travel to the next gas station. Returns: int: The starting gas station index if a circuit is possible, otherwise -1. if sum(gas) < sum(cost): return -1 total_tank, current_tank = 0, 0 starting_station = 0 for i in range(len(gas)): total_tank += gas[i] - cost[i] current_tank += gas[i] - cost[i] # If at any point current tank is negative, reset the start position if current_tank < 0: starting_station = i + 1 current_tank = 0 return starting_station if total_tank >= 0 else -1"},{"question":"from typing import List, Tuple def longest_common_prefix(strings: List[str]) -> str: Find the longest common prefix among a list of strings. pass # replace with your solution def process_test_cases(test_cases: List[Tuple[int, List[Tuple[str, str]]]]) -> List[str]: Process multiple test cases to find longest common prefix for each. pass # replace with your solution # Example usage: # test_cases = [ # (3, [(\\"Emp1\\", \\"flower\\"), (\\"Emp2\\", \\"flow\\"), (\\"Emp3\\", \\"flight\\")]), # (2, [(\\"Emp1\\", \\"dog\\"), (\\"Emp2\\", \\"racecar\\")]), # ] # results = process_test_cases(test_cases) # print(results) # Output: [\\"fl\\", \\"\\"]","solution":"def longest_common_prefix(strings): if not strings: return \\"\\" # The minimum length string will define the maximum possible length of the common prefix min_length = min(len(s) for s in strings) # Find the longest common prefix for i in range(min_length): # Check if the current character is the same in all strings current_char = strings[0][i] if all(s[i] == current_char for s in strings): continue else: return strings[0][:i] # Return the common prefix up to current index return strings[0][:min_length] # All characters were the same up to the minimum string length def process_test_cases(test_cases): results = [] for case in test_cases: N, employees = case strings = [emp_string for emp_id, emp_string in employees] results.append(longest_common_prefix(strings)) return results"},{"question":"from typing import List def count_students_unable_to_eat(students: List[int], sandwiches: List[int]) -> int: Calculates the number of students that are unable to eat based on their sandwich preference. :param students: List of integers representing the students' sandwich preferences (0 or 1). :param sandwiches: List of integers representing the stack of sandwiches (0 or 1). :return: Integer representing the number of students that are unable to eat. pass # Unit Tests def test_example_1(): students = [1,1,0,0] sandwiches = [0,1,0,1] assert count_students_unable_to_eat(students, sandwiches) == 0 def test_example_2(): students = [1,1,1,0,0,1] sandwiches = [1,0,0,0,1,1] assert count_students_unable_to_eat(students, sandwiches) == 3 def test_all_preferences_satisfied(): students = [0, 1, 0, 1] sandwiches = [0, 0, 1, 1] assert count_students_unable_to_eat(students, sandwiches) == 0 def test_all_students_unable_to_eat(): students = [0, 0, 0, 0] sandwiches = [1, 1, 1, 1] assert count_students_unable_to_eat(students, sandwiches) == 4 def test_mixed_preference(): students = [1, 0, 1, 0, 1, 0] sandwiches = [0, 1, 1, 0, 0, 1] assert count_students_unable_to_eat(students, sandwiches) == 0 def test_single_student_matches_sandwich(): students = [1] sandwiches = [1] assert count_students_unable_to_eat(students, sandwiches) == 0 def test_single_student_no_match(): students = [0] sandwiches = [1] assert count_students_unable_to_eat(students, sandwiches) == 1","solution":"def count_students_unable_to_eat(students, sandwiches): Calculates the number of students that are unable to eat based on their sandwich preference. :param students: List of integers representing the students' sandwich preferences (0 or 1). :param sandwiches: List of integers representing the stack of sandwiches (0 or 1). :return: Integer representing the number of students that are unable to eat. from collections import deque student_queue = deque(students) sandwich_stack = deque(sandwiches) unable_to_eat_count = 0 while student_queue and sandwich_stack: if unable_to_eat_count == len(student_queue): break if student_queue[0] == sandwich_stack[0]: student_queue.popleft() sandwich_stack.popleft() unable_to_eat_count = 0 else: student_queue.append(student_queue.popleft()) unable_to_eat_count += 1 return len(student_queue)"},{"question":"from typing import List def wordLadder(startWord: str, endWord: str, wordList: List[str]) -> List[str]: Find the shortest transformation sequence from startWord to endWord using the given wordList. A Word Ladder is a sequence of words where each word in the sequence differs from the previous word by exactly one letter. Args: startWord (str): The initial word. endWord (str): The final word to reach. wordList (List[str]): A list of valid words for transformation. Returns: List[str]: The shortest transformation path from startWord to endWord. If no such transformation is possible, returns an empty list. Examples: >>> wordLadder(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] >>> wordLadder(\\"hit\\", \\"hot\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) [\\"hit\\", \\"hot\\"] # Unit tests def test_wordLadder(): assert wordLadder(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) in [ [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"], [\\"hit\\", \\"hot\\", \\"lot\\", \\"log\\", \\"cog\\"] ] def test_no_path(): assert wordLadder(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) == [] def test_single_step_transformation(): assert wordLadder(\\"hit\\", \\"hot\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) == [\\"hit\\", \\"hot\\"] def test_no_transformation_needed(): assert wordLadder(\\"hit\\", \\"hit\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"hit\\"]) == [\\"hit\\"] def test_multiple_paths(): result = wordLadder(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dop\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\", \\"cot\\"]) assert result in [ [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"], [\\"hit\\", \\"hot\\", \\"cot\\", \\"cog\\"], [\\"hit\\", \\"hot\\", \\"lot\\", \\"log\\", \\"cog\\"], ] def test_empty_wordList(): assert wordLadder(\\"hit\\", \\"cog\\", []) == []","solution":"from collections import deque from typing import List def wordLadder(startWord: str, endWord: str, wordList: List[str]) -> List[str]: if endWord not in wordList: return [] wordSet = set(wordList) queue = deque([[startWord]]) visited = set([startWord]) while queue: path = queue.popleft() current_word = path[-1] if current_word == endWord: return path for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word in wordSet and next_word not in visited: visited.add(next_word) new_path = list(path) new_path.append(next_word) queue.append(new_path) return []"},{"question":"def max_sum_subarray(arr, k): Returns the maximum sum of any contiguous subarray of length k. If k is larger than the length of the list, raise an error. >>> max_sum_subarray([1, 2, 3, 4, 5], 2) 9 >>> max_sum_subarray([1, -2, 3, -1, 2], 3) 4 >>> max_sum_subarray([1, 2, 3, 4, 5], 5) 15 >>> max_sum_subarray([-1, -2, -3, -4, -5], 2) -3 >>> max_sum_subarray([5, -1, 3, 2, 1], 1) 5","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of any contiguous subarray of length k. If k is larger than the length of the list, raise an error. if k > len(arr): raise ValueError(\\"k cannot be larger than the length of the list\\") max_sum = current_sum = sum(arr[:k]) for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def flatten_tree(root: dict) -> list: Flattens a tree into a list of values in depth-first order. >>> flatten_tree({ \\"value\\": 1, \\"children\\": [ { \\"value\\": 2, \\"children\\": [] }, { \\"value\\": 3, \\"children\\": [ { \\"value\\": 4, \\"children\\": [] }, { \\"value\\": 5, \\"children\\": [] } ]} ]}) [1, 2, 3, 4, 5] >>> flatten_tree({}) [] >>> flatten_tree({\\"value\\": 1, \\"children\\": []}) [1] >>> flatten_tree({ \\"value\\": 1, \\"children\\": [ { \\"value\\": 2, \\"children\\": [ { \\"value\\": 6, \\"children\\": [] } ]}, { \\"value\\": 3, \\"children\\": [ { \\"value\\": 4, \\"children\\": [ { \\"value\\": 7, \\"children\\": [] } ]}, { \\"value\\": 5, \\"children\\": [] } ]} ] }) [1, 2, 6, 3, 4, 7, 5] pass","solution":"def flatten_tree(root: dict) -> list: Flattens a tree into a list of values in depth-first order. if not root: return [] result = [] def dfs(node): result.append(node[\\"value\\"]) for child in node[\\"children\\"]: dfs(child) dfs(root) return result"},{"question":"def average_production_time(k: int, times: List[int], p: float) -> float: Calculate the average production time for an item to successfully pass the quality check. Parameters: k (int): number of different machines. times (list of int): processing times for each machine. p (float): probability of an item failing the quality check. Returns: float: average production time rounded to two decimal places. # Your implementation here from typing import List # Test cases def test_average_production_time_sample(): assert average_production_time(3, [2, 3, 4], 0.2) == 11.25 def test_average_production_time_no_failure(): assert average_production_time(1, [10], 0.0) == 10.0 assert average_production_time(3, [5, 5, 5], 0.0) == 15.0 def test_average_production_time_with_some_failure(): assert average_production_time(2, [1, 1], 0.5) == 4.0 assert average_production_time(3, [4, 4, 4], 0.1) == 13.33 def test_average_production_time_high_failure(): assert average_production_time(2, [3, 7], 0.9) == 100.0 def test_average_production_time_single_machine(): assert average_production_time(1, [50], 0.5) == 100.0","solution":"def average_production_time(k, times, p): Calculate the average production time for an item to successfully pass the quality check. Parameters: k (int): number of different machines. times (list of int): processing times for each machine. p (float): probability of an item failing the quality check. Returns: float: average production time rounded to two decimal places. total_processing_time = sum(times) success_rate = 1 - p expected_retries = 1 / success_rate average_time = total_processing_time * expected_retries return round(average_time, 2)"},{"question":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: You are given a matrix of size m x n, where each cell contains a non-negative integer number. Starting from the cell (0, 0), you can only move either right or down to the cell (m-1, n-1). Find the path from the top-left cell to the bottom-right cell, such that the sum of the numbers along the path is minimized. >>> grid_1 = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_path_sum(grid_1) 7 >>> grid_2 = [ ... [1, 2, 5], ... [3, 2, 1] ... ] >>> min_path_sum(grid_2) 6 >>> grid_3 = [[1, 2, 3]] >>> min_path_sum(grid_3) 6 >>> grid_4 = [[1], [2], [3]] >>> min_path_sum(grid_4) 6 >>> grid_5 = [] >>> min_path_sum(grid_5) 0 >>> grid_6 = [[5]] >>> min_path_sum(grid_6) 5 >>> grid_7 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> min_path_sum(grid_7) 21","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the first row and column with their respective sums for i in range(1, m): grid[i][0] += grid[i-1][0] for j in range(1, n): grid[0][j] += grid[0][j-1] # Calculate the minimum path sum for each cell for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[m-1][n-1]"},{"question":"from typing import List, Union from itertools import permutations def is_prime(num: int) -> bool: Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(29) True pass def can_reorder_to_prime_pairs(arr: List[int]) -> Union[List[int], int]: Check if the array can be reordered such that the sum of every pair of adjacent elements is a prime number. >>> can_reorder_to_prime_pairs([2, 3, 5]) != -1 # Possible reordering: [3, 2, 5] >>> can_reorder_to_prime_pairs([4, 6, 8, 10]) == -1 >>> can_reorder_to_prime_pairs([1, 6, 7, 10, 11]) != -1 # Possible reordering: [7, 10, 1, 6, 11] pass def process_test_cases(test_cases: List[List[int]]) -> List[Union[List[int], int]]: Process multiple test cases and return the results. >>> process_test_cases([[2, 3, 5], [4, 6, 8, 10], [1, 6, 7, 10, 11]]) == [ ... can_reorder_to_prime_pairs([2, 3, 5]), ... can_reorder_to_prime_pairs([4, 6, 8, 10]), ... can_reorder_to_prime_pairs([1, 6, 7, 10, 11]) ... ] pass","solution":"from itertools import permutations def is_prime(num): Check if a number is a prime number. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def can_reorder_to_prime_pairs(arr): Check if the array can be reordered such that the sum of every pair of adjacent elements is a prime number. for perm in permutations(arr): if all(is_prime(perm[i] + perm[i + 1]) for i in range(len(perm) - 1)): return list(perm) return -1 def process_test_cases(test_cases): Process multiple test cases and return the results. results = [] for arr in test_cases: results.append(can_reorder_to_prime_pairs(arr)) return results"},{"question":"def cumulative_power(T, test_cases): Compute the cumulative power of sequences of spells for each test case. Args: T (int): The number of test cases. test_cases (list of tuples): Each tuple contains: - N (int): The number of different spells. - spell_powers (list of ints): The power of each spell. - M (int): The number of spells in the sequence to be tested. - spell_indices (list of ints): The indices of the spells in Gandalf's list. Returns: list of int: The cumulative power for each sequence of spells. Examples: >>> cumulative_power(2, [(5, [10, 20, 30, 40, 50], 3, [1, 3, 5]), (4, [15, 25, 35, 45], 2, [2, 4])]) [90, 70] # Your implementation here def process_input(input_str): Convert input string to a format suitable for cumulative_power function. Args: input_str (str): The input string. Returns: tuple: Contains: - T (int): The number of test cases. - test_cases (list of tuples): Each tuple contains inputs for a test case. # Your implementation here def main(input_str): Compute cumulative spell power for given test cases from the input string. Args: input_str (str): The full input in string format. Returns: list of int: The cumulative power for each sequence of spells. Examples: >>> main(\\"2n5n10 20 30 40 50n3n1 3 5n4n15 25 35 45n2n2 4\\") [90, 70] T, test_cases = process_input(input_str) return cumulative_power(T, test_cases) if __name__ == \\"__main__\\": import sys input_str = sys.stdin.read() result = main(input_str) for res in result: print(res)","solution":"def cumulative_power(T, test_cases): results = [] for case in test_cases: N, spell_powers, M, spell_indices = case total_power = sum(spell_powers[idx-1] for idx in spell_indices) results.append(total_power) return results def process_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] i = 1 for _ in range(T): N = int(lines[i]) spell_powers = list(map(int, lines[i+1].split())) M = int(lines[i+2]) spell_indices = list(map(int, lines[i+3].split())) test_cases.append((N, spell_powers, M, spell_indices)) i += 4 return T, test_cases def main(input_str): T, test_cases = process_input(input_str) return cumulative_power(T, test_cases)"},{"question":"def calculate_class_time(intervals: str) -> str: Calculate the total time each student spent in the class from the check-in intervals. >>> calculate_class_time(\\"08:00-10:00,12:00-14:00\\") \\"Student 1: 4 hours 0 minutes\\" >>> calculate_class_time(\\"08:00-10:00,12:00-14:00; 09:30-11:30,13:00-15:00\\") \\"Student 1: 4 hours 0 minutes, Student 2: 4 hours 0 minutes\\" >>> calculate_class_time(\\"\\") \\"\\" >>> calculate_class_time(\\"08:00-11:00; 09:00-10:30,14:00-15:00\\") \\"Student 1: 3 hours 0 minutes, Student 2: 2 hours 30 minutes\\" >>> calculate_class_time(\\"08:00-09:00,09:00-10:00\\") \\"Student 1: 2 hours 0 minutes\\"","solution":"def calculate_class_time(intervals: str) -> str: if not intervals: return \\"\\" def time_to_minutes(t): hours, minutes = map(int, t.split(':')) return hours * 60 + minutes student_intervals = intervals.split(';') results = [] for i, student in enumerate(student_intervals): total_minutes = 0 for interval in student.split(','): start, end = interval.split('-') total_minutes += time_to_minutes(end) - time_to_minutes(start) hours = total_minutes // 60 minutes = total_minutes % 60 results.append(f\\"Student {i+1}: {hours} hours {minutes} minutes\\") return ', '.join(results)"},{"question":"from typing import List def find_words_by_length(s: str, length: int) -> List[str]: Returns a list of unique words from the given string \`s\` that have the target length. The words are treated case-insensitively but the returned list preserves the original casing. >>> find_words_by_length(\\"apple banana Apple banana grape\\", 5) ['apple', 'Apple', 'grape'] >>> find_words_by_length(\\"apple banana Apple banana grape\\", 4) [] >>> find_words_by_length(\\"hi by to of me\\", 2) ['hi', 'by', 'to', 'of', 'me'] >>> find_words_by_length(\\"An example An Other ExaMple an\\", 2) ['An', 'An', 'an'] >>> find_words_by_length(\\"Apple apple APPLE banana\\", 5) ['Apple', 'apple', 'APPLE']","solution":"from typing import List def find_words_by_length(s: str, length: int) -> List[str]: Returns a list of unique words from the given string \`s\` that have the target length. The words are treated case-insensitively but the returned list preserves the original casing. words = s.split() unique_words = set() for word in words: if len(word) == length: unique_words.add(word.lower()) matched_words = [word for word in words if word.lower() in unique_words and len(word) == length] return matched_words"},{"question":"def can_partition(nums: List[int]) -> bool: Determines if a list can be partitioned into two subsets with equal sums. Parameters: nums (list): List of integers Returns: bool: True if the list can be partitioned into two subsets with equal sums, False otherwise. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([]) True >>> can_partition([0]) True >>> can_partition([1]) False >>> can_partition([1, 1]) True >>> can_partition([1, 2]) False >>> can_partition([100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500]) True >>> can_partition([3, 3, 3, 3, 3]) False >>> can_partition([1, 1, 1, 1, 2, 2, 4, 4]) True","solution":"def can_partition(nums): Determines if a list can be partitioned into two subsets with equal sums. Parameters: nums (list): List of integers Returns: bool: True if the list can be partitioned into two subsets with equal sums, False otherwise. total_sum = sum(nums) # If the total sum is odd, we can't partition it into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"def process_queries(n, arr, m, queries): Returns the sum of the elements from index l to index r (inclusive) for each query. Args: - n (int): number of elements in the array - arr (list of int): the list of elements - m (int): number of queries - queries (list of tuples): each tuple contains two integers l and r Returns: - list of int: sums for each query import pytest from solution import process_queries def test_example_one(): assert process_queries(5, [1, 2, 3, 4, 5], 3, [(1, 3), (2, 4), (1, 5)]) == [6, 9, 15] def test_example_two(): assert process_queries(4, [10, 20, 30, 40], 2, [(2, 3), (1, 4)]) == [50, 100] def test_single_element_array(): assert process_queries(1, [42], 1, [(1, 1)]) == [42] def test_all_elements_sum(): assert process_queries(3, [1, 1, 1], 1, [(1, 3)]) == [3] def test_large_numbers(): assert process_queries(3, [1000000, 1000000, 1000000], 1, [(1, 3)]) == [3000000] def test_single_query_multiple_elements(): assert process_queries(5, [1, -1, 1, -1, 1], 1, [(1, 5)]) == [1] def test_negatives_in_array(): assert process_queries(5, [-1, -2, -3, -4, -5], 1, [(2, 4)]) == [-9]","solution":"def process_queries(n, arr, m, queries): Returns the sum of the elements from index l to index r (inclusive) for each query. Args: - n (int): number of elements in the array - arr (list of int): the list of elements - m (int): number of queries - queries (list of tuples): each tuple contains two integers l and r Returns: - list of int: sums for each query # Calculate prefix sums prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + arr[i - 1] # Process the queries result = [] for l, r in queries: result.append(prefix_sums[r] - prefix_sums[l - 1]) return result"},{"question":"def rearrange_string(s: str) -> str: Rearranges the input string such that all the digits appear before all the alphabet characters while maintaining their original relative order. :param s: Input string comprised of digits and lowercase alphabets. :return: Rearranged string with digits first and alphabets after. >>> rearrange_string(\\"a1b2c3\\") '123abc' >>> rearrange_string(\\"7x6y5z\\") '765xyz' >>> rearrange_string(\\"abc123\\") '123abc' >>> rearrange_string(\\"1a1b1c1\\") '1111abc'","solution":"def rearrange_string(s: str) -> str: Rearranges the input string such that all the digits appear before all the alphabet characters while maintaining their original relative order. :param s: Input string comprised of digits and lowercase alphabets. :return: Rearranged string with digits first and alphabets after. digits = [] alphabets = [] for char in s: if char.isdigit(): digits.append(char) else: alphabets.append(char) return ''.join(digits) + ''.join(alphabets)"},{"question":"class Library: A class to simulate a basic library system. The library can handle borrowing, returning, and checking the availability of books. >>> library = Library([{'title': 'Book A', 'copies': 3}, {'title': 'Book B', 'copies': 2}]) >>> print(library.borrow('Book A')) 'Borrowed: Book A' >>> print(library.check_availability('Book A')) 2 >>> library.return_book('Book A') >>> print(library.check_availability('Book A')) 3 >>> print(library.borrow('Book C')) 'Book C is not available' def __init__(self, books): self.books = {book['title']: book['copies'] for book in books} def borrow(self, title): if self.books.get(title, 0) > 0: self.books[title] -= 1 return f'Borrowed: {title}' else: return f'{title} is not available' def return_book(self, title): if title in self.books: self.books[title] += 1 else: self.books[title] = 1 def check_availability(self, title): return self.books.get(title, 0)","solution":"class Library: def __init__(self, books): self.books = {book['title']: book['copies'] for book in books} def borrow(self, title): if self.books.get(title, 0) > 0: self.books[title] -= 1 return f'Borrowed: {title}' else: return f'{title} is not available' def return_book(self, title): if title in self.books: self.books[title] += 1 else: self.books[title] = 1 def check_availability(self, title): return self.books.get(title, 0)"},{"question":"def inverted_pyramid(n): Generates an inverted pyramid of stars with n levels. Each level of the pyramid should be centered within a width of 2*n - 1. Parameters: n (int): The number of levels in the pyramid. Returns: list: A list of strings, where each string is a level in the inverted pyramid. pass # Unit tests def test_inverted_pyramid_5_levels(): result = inverted_pyramid(5) expected = [ '*********', ' ******* ', ' ***** ', ' *** ', ' * ' ] assert result == expected def test_inverted_pyramid_3_levels(): result = inverted_pyramid(3) expected = [ '*****', ' *** ', ' * ' ] assert result == expected def test_inverted_pyramid_1_level(): result = inverted_pyramid(1) expected = [ '*' ] assert result == expected def test_inverted_pyramid_4_levels(): result = inverted_pyramid(4) expected = [ '*******', ' ***** ', ' *** ', ' * ' ] assert result == expected","solution":"def inverted_pyramid(n): Generates an inverted pyramid of stars with n levels. Parameters: n (int): The number of levels in the pyramid. Returns: list: A list of strings, where each string is a level in the inverted pyramid. pyramid = [] max_width = 2 * n - 1 for i in range(n): stars = '*' * (max_width - 2 * i) line = stars.center(max_width, ' ') pyramid.append(line) return pyramid"},{"question":"def sums_except_self(arr): Returns a new array where each element is the sum of every other element except the one at the respective index. Parameters: arr (list): A list of integers. Returns: list: A new list with the described property or null if the input is invalid. >>> sums_except_self([1, 2, 3, 4]) [9, 8, 7, 6] >>> sums_except_self(\\"not a list\\") is None True >>> sums_except_self([1, 2, \\"three\\", 4]) is None True >>> sums_except_self([]) == [] True >>> sums_except_self([5]) [0]","solution":"def sums_except_self(arr): Returns a new array where each element is the sum of every other element except the one at the respective index. Parameters: arr (list): A list of integers. Returns: list: A new list with the described property or null if the input is invalid. if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): return None total_sum = sum(arr) return [total_sum - x for x in arr]"},{"question":"from typing import List def missing_number(nums: List[int]) -> int: Given an array of integers nums containing n distinct numbers in the range [0, n], this function finds the one number that is missing from the array. Args: nums (List[int]): An array of integers containing n distinct numbers in the range [0, n]. Returns: int: The one number that is missing from the array. Examples: >>> missing_number([3, 0, 1]) 2 >>> missing_number([0, 1]) 2 >>> missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) 8 >>> missing_number([]) 0 >>> missing_number([1]) 0 >>> missing_number([0]) 1","solution":"def missing_number(nums): This function takes an array of integers containing n distinct numbers in the range [0, n] and returns the one number that is missing from the array. n = len(nums) total_sum = n * (n + 1) / 2 # Sum of first n natural numbers array_sum = sum(nums) # Sum of elements in array return int(total_sum - array_sum)"},{"question":"def max_triplet_weight(n: int, A: List[int]) -> int: Given an array of integers \`A\` with size \`n\`, returns the maximum weight of any triplet in the array. The weight of a triplet (ai, aj, ak) is defined as (ak - ai). >>> max_triplet_weight(5, [5, 1, 9, 3, 7]) 8 >>> max_triplet_weight(4, [4, 3, 1, 2]) 2","solution":"def max_triplet_weight(n, A): Returns the maximum weight of any triplet in the array. # The weight of the triplet is defined as (ak - ai) # Hence, to find the maximum weight, we just need to find # the maximum and minimum elements in the array and compute # their difference. max_value = max(A) min_value = min(A) return max_value - min_value"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def closestValue(root: TreeNode, target: float) -> int: Find the value in the BST that is closest to the target value. >>> root = TreeNode(4) >>> root.left = TreeNode(2) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(3) >>> closestValue(root, 3.714286) 4 >>> root = TreeNode(1) >>> closestValue(root, 4.428571) 1","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def closestValue(root: TreeNode, target: float) -> int: def findClosest(node, target, closest): if node is None: return closest if abs(node.val - target) < abs(closest - target): closest = node.val if target < node.val: closest = findClosest(node.left, target, closest) elif target > node.val: closest = findClosest(node.right, target, closest) return closest return findClosest(root, target, root.val)"},{"question":"def count_ways_to_reach_end(grid: List[str], n: int, m: int) -> int: Count the number of ways to reach the bottom-right corner from the top-left corner in a grid. Args: grid: A list of strings representing the grid. n: Number of rows in the grid. m: Number of columns in the grid. Returns: An integer representing the number of ways to reach the bottom-right corner. Example: >>> count_ways_to_reach_end([ \\"...\\", \\".#.\\", \\"...\\" ], 3, 3) 2 >>> count_ways_to_reach_end([ \\"...\\", \\"#\\", \\"...\\" ], 3, 3) 0 def process_test_cases(T: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Process multiple test cases of the grid problem. Args: T: Number of test cases. test_cases: A list of tuples, each containing the number of rows, number of columns, and the grid for each test case. Returns: A list of integers, each representing the number of ways to reach the bottom-right corner for each test case. Example: >>> process_test_cases(2, [ (3, 3, [\\"...\\", \\".#.\\", \\"...\\"]), (3, 3, [\\"...\\", \\"#\\", \\"...\\"]) ]) [2, 0] if __name__ == \\"__main__\\": import pytest def test_count_ways_basic(): assert count_ways_to_reach_end([\\"...\\", \\".#.\\", \\"...\\"], 3, 3) == 2 assert count_ways_to_reach_end([\\"...\\", \\"#\\", \\"...\\"], 3, 3) == 0 def test_count_ways_single_row(): assert count_ways_to_reach_end([\\"...\\"], 1, 3) == 1 assert count_ways_to_reach_end([\\".#.\\"], 1, 3) == 0 def test_count_ways_single_column(): assert count_ways_to_reach_end([\\".\\", \\".\\", \\".\\"], 3, 1) == 1 assert count_ways_to_reach_end([\\".\\", \\"#\\", \\".\\"], 3, 1) == 0 def test_process_test_cases_basic(): test_cases = [ (3, 3, [\\"...\\", \\".#.\\", \\"...\\"]), (3, 3, [\\"...\\", \\"#\\", \\"...\\"]) ] assert process_test_cases(2, test_cases) == [2, 0] pytest.main()","solution":"def count_ways_to_reach_end(grid, n, m): # Initialize DP table to hold number of ways to get to each cell dp = [[0 for _ in range(m)] for _ in range(n)] # Start is always accessible dp[0][0] = 1 # Populate dp table for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] # The bottom-right corner will have the number of ways to get to (n, m) return dp[n-1][m-1] def process_test_cases(T, test_cases): results = [] for test_case in test_cases: n, m, grid = test_case result = count_ways_to_reach_end(grid, n, m) results.append(result) return results"},{"question":"def hourglass_sum(matrix): Returns the maximum hourglass sum in a given 2D matrix. An hourglass is defined as: a b c d e f g >>> matrix = [ ... [1, 2, 3, 0], ... [0, 4, 0, 0], ... [2, 1, 3, 4], ... [1, 2, 1, 5] ... ] >>> hourglass_sum(matrix) 16 >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> hourglass_sum(matrix) 35 >>> matrix = [ ... [-1, -1, 0, -9, -2, -2], ... [-2, -1, -6, -8, -2, -5], ... [-1, -1, -1, -2, -3, -4], ... [-1, -9, -2, -4, -4, -5], ... [-7, -3, -3, -2, -9, -9], ... [-1, -3, -1, -2, -4, -5] ... ] >>> hourglass_sum(matrix) -6 >>> matrix = [ ... [1, 1, 1, 0, 0, 0], ... [0, 1, 0, 0, 0, 0], ... [1, 1, 1, 0, 0, 0], ... [0, 0, 2, 4, 4, 0], ... [0, 0, 0, 2, 0, 0], ... [0, 0, 1, 2, 4, 0] ... ] >>> hourglass_sum(matrix) 19 >>> matrix = [ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ] >>> hourglass_sum(matrix) 0","solution":"def hourglass_sum(matrix): Returns the maximum hourglass sum in a given 2D matrix. An hourglass is defined as: a b c d e f g rows = len(matrix) cols = len(matrix[0]) max_sum = float('-inf') for i in range(rows - 2): for j in range(cols - 2): current_sum = ( matrix[i][j] + matrix[i][j+1] + matrix[i][j+2] + matrix[i+1][j+1] + matrix[i+2][j] + matrix[i+2][j+1] + matrix[i+2][j+2] ) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def find_pairs_with_sum(input_list, target_sum): Returns a list of unique pairs from input_list that add up to target_sum. Each pair is sorted in ascending order and the resulting list is sorted lexicographically. Example: >>> find_pairs_with_sum([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) [(1, 9), (2, 8), (3, 7), (4, 6)] >>> find_pairs_with_sum([1, 2, 3, 4], 8) [] >>> find_pairs_with_sum([-1, -2, -3, -4, 5, 7], 4) [(-3, 7), (-1, 5)] >>> find_pairs_with_sum([1, 3, 2, 2, 4, 6, 5], 6) [(1, 5), (2, 4)] >>> find_pairs_with_sum([1, 5, 1, 5], 6) [(1, 5)] >>> find_pairs_with_sum([], 0) []","solution":"def find_pairs_with_sum(input_list, target_sum): Returns a list of unique pairs from input_list that add up to target_sum. Each pair is sorted in ascending order and the resulting list is sorted lexicographically. seen = set() pairs = set() for number in input_list: complement = target_sum - number if complement in seen: pairs.add(tuple(sorted((number, complement)))) seen.add(number) return sorted(pairs)"},{"question":"from datetime import datetime from typing import List def sort_dates(date_list: List[str]) -> List[str]: Sorts a list of date strings in ascending order and returns them in the format YYYY-MM-DD. Args: date_list: List of date strings in the format DD/MM/YYYY. Returns: List of sorted date strings in the format YYYY-MM-DD. Examples: >>> sort_dates([\\"12/05/2021\\", \\"23/12/1999\\", \\"10/08/2010\\", \\"04/04/2004\\", \\"01/01/2020\\"]) ['1999-12-23', '2004-04-04', '2010-08-10', '2020-01-01', '2021-05-12'] >>> sort_dates([\\"12/05/2021\\"]) ['2021-05-12'] >>> sort_dates([\\"12/05/2021\\", \\"12/05/2021\\", \\"12/05/2021\\"]) ['2021-05-12', '2021-05-12', '2021-05-12'] >>> sort_dates([\\"01/01/2000\\", \\"12/12/2001\\", \\"15/08/2005\\"]) ['2000-01-01', '2001-12-12', '2005-08-15'] >>> sort_dates([\\"30/12/2050\\", \\"15/06/2035\\", \\"01/01/2025\\"]) ['2025-01-01', '2035-06-15', '2050-12-30']","solution":"from datetime import datetime def sort_dates(date_list): Sorts a list of date strings in ascending order and returns them in the format YYYY-MM-DD. Args: date_list: List of date strings in the format DD/MM/YYYY. Returns: List of sorted date strings in the format YYYY-MM-DD. # Convert the list of string dates to datetime objects date_objects = [datetime.strptime(date, '%d/%m/%Y') for date in date_list] # Sort the datetime objects sorted_date_objects = sorted(date_objects) # Convert sorted datetime objects back to strings in the format YYYY-MM-DD sorted_date_strings = [date_obj.strftime('%Y-%m-%d') for date_obj in sorted_date_objects] return sorted_date_strings"},{"question":"from typing import List def cumulative_sum(nums: List[int]) -> List[int]: Returns the cumulative sum list of the given list of integers. >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([4, 3, 2, 1]) [4, 7, 9, 10] >>> cumulative_sum([]) [] >>> cumulative_sum([5]) [5] >>> cumulative_sum([-1, -2, -3, -4]) [-1, -3, -6, -10] >>> cumulative_sum([1, -1, 2, -2, 3, -3, 4, -4]) [1, 0, 2, 0, 3, 0, 4, 0]","solution":"def cumulative_sum(nums): Returns the cumulative sum list of the given list of integers. result = [] current_sum = 0 for num in nums: current_sum += num result.append(current_sum) return result"},{"question":"def check_updates(n: int, updates: List[Tuple[int, List[int]]]) -> List[str]: Determine the validity and impact of software updates on App completion times. For each update, decide if it led to a \\"Drastic Slowdown\\". Args: n: An integer - number of updates. updates: A list of tuples, where each tuple contains an integer and a list of task times. Returns: A list of strings \\"Drastic Slowdown\\" or \\"No Drastic Slowdown\\" for each update. >>> check_updates(2, [(3, [100, 120, 300]), (4, [200, 220, 500, 150])]) [\\"Drastic Slowdown\\", \\"Drastic Slowdown\\"] >>> check_updates(2, [(3, [100, 120, 140]), (4, [200, 220, 240, 260])]) [\\"No Drastic Slowdown\\", \\"No Drastic Slowdown\\"]","solution":"def check_updates(n, updates): results = [] for i in range(n): m, times = updates[i] drastic_slowdown = False for j in range(1, m): if times[j] > times[j-1] * 1.5: drastic_slowdown = True break if drastic_slowdown: results.append(\\"Drastic Slowdown\\") else: results.append(\\"No Drastic Slowdown\\") return results"},{"question":"def find_smallest_unrepresentable_sum(arr): Finds the smallest positive integer that cannot be represented as the sum of any subset of the given array. >>> find_smallest_unrepresentable_sum([1, 2, 3, 10]) == 7 >>> find_smallest_unrepresentable_sum([1, 1, 1, 1]) == 5 >>> find_smallest_unrepresentable_sum([2, 4, 6, 8, 10]) == 1 >>> find_smallest_unrepresentable_sum([5, 5, 5, 5]) == 1 >>> find_smallest_unrepresentable_sum([1, 3, 6, 10, 11, 15]) == 2 >>> find_smallest_unrepresentable_sum([1, 1, 3, 4, 2, 1]) == 13 >>> find_smallest_unrepresentable_sum([1]) == 2 >>> find_smallest_unrepresentable_sum([2]) == 1 >>> find_smallest_unrepresentable_sum([10]) == 1 >>> find_smallest_unrepresentable_sum([]) == 1","solution":"def find_smallest_unrepresentable_sum(arr): Finds the smallest positive integer that cannot be represented as the sum of any subset of the given array. arr.sort() smallest_unrepresentable = 1 for num in arr: if num > smallest_unrepresentable: break smallest_unrepresentable += num return smallest_unrepresentable"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string \`s\`, find the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} start, max_length = 0, 0 for end in range(len(s)): if s[end] in char_map: start = max(start, char_map[s[end]] + 1) char_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def find_diagonal_order(matrix): Returns the elements of the matrix in diagonal order. >>> find_diagonal_order([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [1, 2, 4, 7, 5, 3, 6, 8, 9] >>> find_diagonal_order([[1, 2], [3, 4]]) [1, 2, 3, 4]","solution":"def find_diagonal_order(matrix): Returns the elements of the matrix in diagonal order. if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] for d in range(m + n - 1): # direction up-right if d is even, down-left if d is odd if d % 2 == 0: r = min(d, m - 1) c = max(0, d - m + 1) while r >= 0 and c < n: result.append(matrix[r][c]) r -= 1 c += 1 else: r = max(0, d - n + 1) c = min(d, n - 1) while r < m and c >= 0: result.append(matrix[r][c]) r += 1 c -= 1 return result"},{"question":"def top_three_expensive_items(items: dict) -> list: Returns a list of tuples with the three most expensive items. Each tuple contains the item and its price. >>> top_three_expensive_items({\\"item1\\": 10, \\"item2\\": 70, \\"item3\\": 30, \\"item4\\": 80, \\"item5\\": 20}) [(\\"item4\\", 80), (\\"item2\\", 70), (\\"item3\\", 30)] >>> top_three_expensive_items({\\"item1\\": 10, \\"item2\\": 70, \\"item3\\": 30}) [(\\"item2\\", 70), (\\"item3\\", 30), (\\"item1\\", 10)] >>> top_three_expensive_items({\\"item1\\": 10, \\"item2\\": 70}) [(\\"item2\\", 70), (\\"item1\\", 10)] >>> top_three_expensive_items({}) [] >>> try: ... top_three_expensive_items([1, 2, 3]) ... except ValueError as e: ... assert str(e) == 'Input must be a dictionary'","solution":"def top_three_expensive_items(items): Returns a list of tuples with the three most expensive items. Each tuple contains the item and its price. Parameters: items (dict): Dictionary containing items as keys and their respective prices as values. Returns: list: List of tuples with the top 3 most expensive items and their prices. if not isinstance(items, dict): raise ValueError(\\"Input must be a dictionary\\") if len(items) == 0: return [] if len(items) < 3: return sorted(items.items(), key=lambda x: x[1], reverse=True) sorted_items = sorted(items.items(), key=lambda x: x[1], reverse=True) return sorted_items[:3]"},{"question":"def validate_brackets(s: str) -> bool: Validates if the sequence of brackets in the string is valid. Args: s (str): Input string containing brackets. Returns: bool: True if the brackets string is valid, False otherwise. Examples: >>> validate_brackets(\\"()\\") True >>> validate_brackets(\\"()[]{}\\") True >>> validate_brackets(\\"(]\\") False >>> validate_brackets(\\"([)]\\") False >>> validate_brackets(\\"{[]}\\") True >>> validate_brackets(\\"{[()()]}\\") True >>> validate_brackets(\\"({[([{}])()]})\\") True >>> validate_brackets(\\"(\\") False >>> validate_brackets(\\"}\\") False >>> validate_brackets(\\"\\") True","solution":"def validate_brackets(s: str) -> bool: Validates if the sequence of brackets in the string is valid. Args: s (str): Input string containing brackets. Returns: bool: True if the brackets string is valid, False otherwise. stack = [] brackets_map = {'(': ')', '{': '}', '[': ']'} for char in s: if char in brackets_map: # If it's an opening bracket stack.append(char) elif stack and char == brackets_map[stack[-1]]: # If it's a closing bracket and matches the last opening one stack.pop() else: # It's a closing bracket but doesn't match or there's no opening bracket to match return False return not stack # If stack is empty, all brackets matched correctly"},{"question":"def bubble_sort(n: int, arr: List[int]) -> List[int]: Sorts a list of n integers in non-decreasing order without using built-in sorting functions. >>> bubble_sort(5, [3, 1, 4, 1, 5]) == [1, 1, 3, 4, 5] >>> bubble_sort(4, [10, 3, 2, 7]) == [2, 3, 7, 10] pass def test_bubble_sort_example_1(): assert bubble_sort(5, [3, 1, 4, 1, 5]) == [1, 1, 3, 4, 5] def test_bubble_sort_example_2(): assert bubble_sort(4, [10, 3, 2, 7]) == [2, 3, 7, 10] def test_bubble_sort_already_sorted(): assert bubble_sort(3, [1, 2, 3]) == [1, 2, 3] def test_bubble_sort_reverse_sorted(): assert bubble_sort(4, [4, 3, 2, 1]) == [1, 2, 3, 4] def test_bubble_sort_single_element(): assert bubble_sort(1, [42]) == [42] def test_bubble_sort_empty_list(): assert bubble_sort(0, []) == [] def test_bubble_sort_negative_numbers(): assert bubble_sort(4, [-3, -1, -4, -2]) == [-4, -3, -2, -1] def test_bubble_sort_mixed_numbers(): assert bubble_sort(5, [3, -1, 0, 10, -5]) == [-5, -1, 0, 3, 10]","solution":"def bubble_sort(n, arr): Sorts a list of n integers in non-decreasing order using bubble sort algorithm. for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr"},{"question":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def isBalanced(root: Node) -> bool: Determines if a binary tree is balanced. A binary tree is considered balanced if the height of the left and right subtree of every node differ by at most 1. :param root: Root node of the binary tree :return: True if the tree is balanced, else False >>> isBalanced(Node(3, Node(9), Node(20, Node(15), Node(7)))) True >>> isBalanced(Node(1, Node(2, Node(3, Node(4), Node(4)), Node(3)), Node(2))) False >>> isBalanced(Node(1, Node(2), Node(2, Node(3), Node(3)))) True >>> isBalanced(None) True >>> isBalanced(Node(1)) True >>> isBalanced(Node(1, Node(2, Node(3)), None)) False >>> isBalanced(Node(1, None, Node(2, None, Node(3)))) False","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def isBalanced(root): Determines if a binary tree is balanced. A binary tree is considered balanced if the height of the left and right subtree of every node differ by at most 1. :param root: Root node of the binary tree :return: True if the tree is balanced, else False def height_and_balance(node): if not node: return 0, True left_height, left_balanced = height_and_balance(node.left) right_height, right_balanced = height_and_balance(node.right) current_height = 1 + max(left_height, right_height) current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, current_balanced _, balanced = height_and_balance(root) return balanced"},{"question":"def list_partition(lst): Partitions a list of integers into even and odd numbers. :param lst: List of integers :return: Dictionary with two keys: 'even' and 'odd' >>> list_partition([1, 2, 3, 4, 5, 6, 7]) {'even': [2, 4, 6], 'odd': [1, 3, 5, 7]} >>> list_partition([]) {'even': [], 'odd': []} >>> list_partition([2, 4, 6, 8]) {'even': [2, 4, 6, 8], 'odd': []} >>> list_partition([1, 3, 5, 7]) {'even': [], 'odd': [1, 3, 5, 7]} >>> list_partition([10, 21, 32, 43, 54]) {'even': [10, 32, 54], 'odd': [21, 43]} >>> list_partition([-1, -2, -3, -4]) {'even': [-2, -4], 'odd': [-1, -3]} >>> list_partition([0, 1, 2, 3]) {'even': [0, 2], 'odd': [1, 3]}","solution":"def list_partition(lst): Partitions a list of integers into even and odd numbers. :param lst: List of integers :return: Dictionary with two keys: 'even' and 'odd' result = {'even': [], 'odd': []} for num in lst: if num % 2 == 0: result['even'].append(num) else: result['odd'].append(num) return result"},{"question":"def count_vowels(phrase: str) -> int: Returns the count of vowels (a, e, i, o, u) in the input string. The check is case-insensitive. >>> count_vowels(\\"Hello World\\") 3 >>> count_vowels(\\"Programming is fun!\\") 5 >>> count_vowels(\\"Why?\\") 0 >>> count_vowels(\\"aeiouAEIOU\\") 10 >>> count_vowels(\\"\\") 0 >>> count_vowels(\\"HELLO world\\") 3","solution":"def count_vowels(phrase): Returns the count of vowels (a, e, i, o, u) in the input string. The check is case-insensitive. vowels = 'aeiou' phrase = phrase.lower() return sum(1 for char in phrase if char in vowels)"},{"question":"from typing import List def count_occurrences(lst: List[int]) -> List[int]: This function takes a list of integers and returns a new list of integers where each element from the original list is replaced by the number of times it appears in the original list. >>> count_occurrences([4, 5, 4, 6, 4, 7, 5]) [3, 2, 3, 1, 3, 1, 2] >>> count_occurrences([1, 2, 2, 3, 4, 4, 4]) [1, 2, 2, 1, 3, 3, 3] >>> count_occurrences([10, 20, 10, 20, 30]) [2, 2, 2, 2, 1]","solution":"from typing import List def count_occurrences(lst: List[int]) -> List[int]: This function takes a list of integers and returns a new list of integers where each element from the original list is replaced by the number of times it appears in the original list. counts = {x: lst.count(x) for x in lst} return [counts[x] for x in lst]"},{"question":"from typing import List def largest_divisor(arr: List[int]) -> int: Returns the largest positive number that divides exactly all elements of the array. If such a number doesn't exist, return -1. >>> largest_divisor([8, 24, 16, 32]) 8 >>> largest_divisor([5, 5, 5, 5]) 5 >>> largest_divisor([3, 5, 7]) 1 >>> largest_divisor([20, 30, 40, 50]) 10 >>> largest_divisor([7, 11, 13]) 1 >>> largest_divisor([29]) 29 >>> largest_divisor([1000000, 500000, 250000]) 250000 >>> largest_divisor([-10, 20, 30]) -1 >>> largest_divisor([0, 20, 30]) -1 >>> largest_divisor([]) -1 >>> largest_divisor([0, 12, 24]) -1 >>> largest_divisor([1, 10]) 1 pass","solution":"import math from functools import reduce def largest_divisor(arr): Returns the largest positive number that divides exactly all elements of the array. If such a number doesn't exist, return -1. Parameters: arr (list): List of integers Returns: int: The largest positive divisor or -1 def gcd(a, b): Computes the Greatest Common Divisor (GCD) of a and b. while b: a, b = b, a % b return a if not arr or any(n <= 0 for n in arr): return -1 # Find the GCD of the entire array. overall_gcd = reduce(gcd, arr) # Check if the overall_gcd divides all elements in the array return overall_gcd if all(x % overall_gcd == 0 for x in arr) else -1"},{"question":"def exist(grid: List[List[str]], word: str) -> bool: Write a function that takes a 2D grid of characters (represented as a list of lists) and a target word, and checks if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. The function should return a boolean indicating whether the word can be found in the grid. >>> grid = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']] >>> word1 = \\"ABCCED\\" >>> word2 = \\"SEE\\" >>> word3 = \\"ABCB\\" >>> exist(grid, word1) True >>> exist(grid, word2) True >>> exist(grid, word3) False","solution":"def exist(grid, word): Checks if the word exists in the 2D grid. rows, cols = len(grid), len(grid[0]) def dfs(r, c, index): if index == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != word[index]: return False temp = grid[r][c] grid[r][c] = '#' found = (dfs(r+1, c, index+1) or # down dfs(r-1, c, index+1) or # up dfs(r, c+1, index+1) or # right dfs(r, c-1, index+1)) # left grid[r][c] = temp return found for i in range(rows): for j in range(cols): if grid[i][j] == word[0] and dfs(i, j, 0): return True return False"},{"question":"from typing import List from collections import Counter import heapq def reorganize_string(s: str) -> str: Reorganize the string so that no two adjacent characters are the same. Return an empty string if no valid reordering is possible. >>> reorganize_string(\\"aab\\") in [\\"aba\\"] >>> reorganize_string(\\"aaab\\") == \\"\\" >>> reorganize_string(\\"aaabbc\\") in [\\"ababac\\", \\"abacab\\", \\"abacba\\", \\"acabab\\", \\"acabba\\"] >>> reorganize_string(\\"aaa\\") == \\"\\" >>> reorganize_string(\\"a\\") == \\"a\\" >>> reorganize_string(\\"aa\\") == \\"\\" >>> reorganize_string(\\"ab\\") in [\\"ab\\", \\"ba\\"] >>> reorganize_string(\\"aabbcc\\") in [\\"abcabc\\", \\"acbacb\\", \\"bacbac\\", \\"bacabc\\", \\"bcabac\\", \\"ababab\\"]","solution":"from collections import Counter import heapq def reorganize_string(s): Reorganize the string so that no two adjacent characters are the same. Return an empty string if no valid reordering is possible. n = len(s) # Count frequency of each character frequency = Counter(s) # Use max heap to get the most frequent characters first max_heap = [(-freq, char) for char, freq in frequency.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) freq += 1 # decrement freq as we have used one occurrence of char prev_freq, prev_char = freq, char result_str = ''.join(result) # Check if the reorganized string length matches the input string if len(result_str) != n: return \\"\\" return result_str"},{"question":"def caesar_cipher(s: str, shift: int) -> str: Encrypts the input string \`s\` using a Caesar cipher with a given \`shift\`. Only letters are shifted; non-letters remain unchanged. Args: s (str): The input string to be encrypted. shift (int): The number of positions to shift each letter. Returns: str: The encrypted string. >>> caesar_cipher(\\"Hello, World!\\", 3) 'Khoor, Zruog!' >>> caesar_cipher(\\"xyz\\", 3) 'abc' >>> caesar_cipher(\\"XYZ\\", 3) 'ABC' pass # Your code here","solution":"def caesar_cipher(s, shift): Encrypts the input string \`s\` using a Caesar cipher with a given \`shift\`. Only letters are shifted; non-letters remain unchanged. Args: s (str): The input string to be encrypted. shift (int): The number of positions to shift each letter. Returns: str: The encrypted string. def shift_char(c, shift): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + shift) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + shift) % 26 + ord('A')) else: return c return ''.join(shift_char(c, shift) for c in s)"},{"question":"def check_password_strength(password): Check if the given password meets the criteria for being strong. Criteria: 1. Length between 6 and 12 characters (inclusive) 2. Contains at least one uppercase letter 3. Contains at least one lowercase letter 4. Contains at least one digit 5. Contains at least one special character from the set !@#%^&*()-+ >>> check_password_strength(\\"Passw0rd!\\") \\"Strong\\" >>> check_password_strength(\\"123456\\") \\"Weak\\" >>> check_password_strength(\\"Ab1@\\") \\"Weak\\" >>> check_password_strength(\\"SuperSecure1\\") \\"Weak\\" >>> check_password_strength(\\"Example1!\\") \\"Strong\\" >>> check_password_strength(\\"WeakPassword\\") \\"Weak\\" >>> check_password_strength(\\"Str0ng!\\") \\"Strong\\" >>> check_password_strength(\\"Short1!\\") \\"Strong\\" >>> check_password_strength(\\"1!Aa\\") \\"Weak\\" def password_strength_checker(passwords): Check the strength of a list of passwords. >>> passwords = [\\"Passw0rd!\\", \\"123456\\", \\"Ab1@\\", \\"SuperSecure1\\"] >>> password_strength_checker(passwords) [\\"Strong\\", \\"Weak\\", \\"Weak\\", \\"Weak\\"] >>> passwords = [\\"Example1!\\", \\"WeakPassword\\", \\"Str0ng!\\", \\"Short1!\\", \\"1!Aa\\"] >>> password_strength_checker(passwords) [\\"Strong\\", \\"Weak\\", \\"Strong\\", \\"Strong\\", \\"Weak\\"]","solution":"import re def check_password_strength(password): Check if the given password meets the criteria for being strong. Criteria: 1. Length between 6 and 12 characters (inclusive) 2. Contains at least one uppercase letter 3. Contains at least one lowercase letter 4. Contains at least one digit 5. Contains at least one special character from the set !@#%^&*()-+ :param password: String, the password to check :return: \\"Strong\\" if the password meets all criteria, otherwise \\"Weak\\" if not (6 <= len(password) <= 12): return \\"Weak\\" if not re.search(r'[A-Z]', password): return \\"Weak\\" if not re.search(r'[a-z]', password): return \\"Weak\\" if not re.search(r'[0-9]', password): return \\"Weak\\" if not re.search(r'[!@#%^&*()-+]', password): return \\"Weak\\" return \\"Strong\\" def password_strength_checker(passwords): Check the strength of a list of passwords. :param passwords: List of strings, the passwords to check :return: List of strings, where each element is \\"Strong\\" or \\"Weak\\" indicating the strength of the corresponding password return [check_password_strength(password) for password in passwords]"},{"question":"def longest_distinct_substring(S: str) -> int: Finds the length of the longest substring with all distinct characters in a given string S. >> longest_distinct_substring(\\"abcabcbb\\") 3 >> longest_distinct_substring(\\"bbbbb\\") 1 >> longest_distinct_substring(\\"pwwkew\\") 3","solution":"def longest_distinct_substring(S: str) -> int: Finds the length of the longest substring with all distinct characters in a given string S. n = len(S) char_index = {} longest_length = 0 start_idx = 0 for current_idx in range(n): if S[current_idx] in char_index: start_idx = max(start_idx, char_index[S[current_idx]] + 1) char_index[S[current_idx]] = current_idx longest_length = max(longest_length, current_idx - start_idx + 1) return longest_length"},{"question":"from typing import List, Tuple def is_palindrome(s: str) -> bool: Check if a given string is a palindrome. >>> is_palindrome(\\"madam\\") == True >>> is_palindrome(\\"racecar\\") == True >>> is_palindrome(\\"apple\\") == False def palindrome_pairs(words: List[str]) -> List[Tuple[int, int]]: Identify all pairs of indices (i, j) such that the concatenation of words[i] and words[j] forms a palindrome. >>> palindrome_pairs([\\"abcd\\", \\"dcba\\", \\"ll\\", \\"sssll\\"]) == [(0, 1), (1, 0), (2, 3)] >>> palindrome_pairs([\\"bat\\", \\"tab\\", \\"cat\\"]) == [(0, 1), (1, 0)] >>> palindrome_pairs([\\"abc\\", \\"def\\"]) == []","solution":"def is_palindrome(s): Check if a given string is a palindrome. return s == s[::-1] def palindrome_pairs(words): Identify all pairs of indices (i, j) such that the concatenation of words[i] and words[j] forms a palindrome. result = [] for i in range(len(words)): for j in range(len(words)): if i != j and is_palindrome(words[i] + words[j]): result.append((i, j)) return sorted(result)"},{"question":"def is_palindrome(n: int) -> bool: Determines whether an integer (positive, negative, or zero) is a palindrome. A number is considered a palindrome if it remains the same when its digits are reversed. Args: n (int): The integer to check. Returns: bool: True if n is a palindrome, False otherwise. >>> is_palindrome(121) True >>> is_palindrome(-121) False >>> is_palindrome(10) False >>> is_palindrome(0) True >>> is_palindrome(7) True >>> is_palindrome(-7) False >>> is_palindrome(1234321) True >>> is_palindrome(1234567) False","solution":"def is_palindrome(n): Determines whether an integer is a palindrome. A number is considered a palindrome if it remains the same when its digits are reversed. Args: n (int): The integer to check. Returns: bool: True if n is a palindrome, False otherwise. # Convert the integer to string str_n = str(n) # Check if the string is the same as its reverse return str_n == str_n[::-1]"},{"question":"def can_place_tulips(flowerbed: List[int], n: int) -> bool: Determines if n tulips can be planted in the flowerbed without violating the no-adjacent-plot rule. :param flowerbed: List[int] - a list representing the flowerbed :param n: int - the number of tulips to be planted :return: bool - True if the tulips can be planted, otherwise False >>> can_place_tulips([1, 0, 0, 0, 1], 1) == True >>> can_place_tulips([1, 0, 0, 0, 1], 2) == False >>> can_place_tulips([0, 0, 0, 0, 0], 3) == True >>> can_place_tulips([1, 1, 1, 1, 1], 1) == False >>> can_place_tulips([1, 0, 1, 0, 1, 0, 1], 0) == True >>> can_place_tulips([0, 0, 1, 0, 1, 0, 0], 1) == True >>> can_place_tulips([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 5) == True pass","solution":"def can_place_tulips(flowerbed, n): Determines if n tulips can be planted in the flowerbed without violating the no-adjacent-plot rule. :param flowerbed: List[int] - a list representing the flowerbed :param n: int - the number of tulips to be planted :return: bool - True if the tulips can be planted, otherwise False count = 0 length = len(flowerbed) for i in range(length): if (flowerbed[i] == 0 and (i == 0 or flowerbed[i - 1] == 0) and (i == length - 1 or flowerbed[i + 1] == 0)): flowerbed[i] = 1 count += 1 if count >= n: return True return count >= n"},{"question":"def hanoi_variation_moves(N: int, P: int) -> int: Calculate minimum number of moves to solve Tower of Hanoi problem with N disks and P pegs. >>> hanoi_variation_moves(2, 3) 3 >>> hanoi_variation_moves(3, 4) 5 >>> hanoi_variation_moves(4, 5) 7 def solve_hanoi_puzzles(cases: List[Tuple[int, int]]) -> List[int]: Solve multiple test cases of the Tower of Hanoi problem with variations. >>> solve_hanoi_puzzles([(2, 3), (3, 4), (4, 5)]) [3, 5, 7] >>> solve_hanoi_puzzles([(1, 3), (1, 4), (3, 3)]) [1, 1, 7]","solution":"def hanoi_variation_moves(N, P): Calculate minimum number of moves to solve Tower of Hanoi problem with N disks and P pegs. if P == 3: return (1 << N) - 1 if N == 1: return 1 moves = float('inf') for k in range(1, N): moves = min(moves, 2 * hanoi_variation_moves(k, P) + hanoi_variation_moves(N - k, P - 1)) return moves def solve_hanoi_puzzles(cases): results = [] for N, P in cases: results.append(hanoi_variation_moves(N, P)) return results"},{"question":"def sum_of_subarrays(arr, k): Given a list of integers, find the sum of all the contiguous subarrays within the list which have a length exactly equal to a given integer k. Parameters: arr (List[int]): A list of integers. k (int): The length of the subarrays. Returns: int: The sum of all the contiguous subarrays within the list of length k. Examples: >>> sum_of_subarrays([1, 2, 3, 4, 5], 2) 24 >>> sum_of_subarrays([-1, 2, 3, -4, 2], 3) 6 from sum_of_subarrays import sum_of_subarrays def test_example1(): assert sum_of_subarrays([1, 2, 3, 4, 5], 2) == 24 def test_example2(): assert sum_of_subarrays([-1, 2, 3, -4, 2], 3) == 6 def test_single_element_subarrays(): assert sum_of_subarrays([1, 2, 3], 1) == 6 def test_whole_array_as_subarray(): assert sum_of_subarrays([1, 2, 3, 4], 4) == 10 def test_edge_case_empty_array(): assert sum_of_subarrays([], 1) == 0 def test_edge_case_k_greater_than_array_length(): assert sum_of_subarrays([1, 2, 3], 4) == 0 def test_edge_case_k_zero(): assert sum_of_subarrays([1, 2, 3], 0) == 0 def test_large_k_small_array(): assert sum_of_subarrays([1], 1) == 1 def test_large_negative_value(): assert sum_of_subarrays([10**4, -10**4, 10**4], 2) == 0","solution":"def sum_of_subarrays(arr, k): Returns the total sum of all the contiguous subarrays within the list which have length exactly equal to k. if k > len(arr) or k <= 0: return 0 total_sum = 0 # sum of the first window of size k current_sum = sum(arr[:k]) total_sum += current_sum # use sliding window technique to find sum of other windows for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] total_sum += current_sum return total_sum"},{"question":"def number_of_clusters(n: int, m: int, grid: List[List[str]]) -> int: Determine the number of distinct clusters of cows in the grid. Args: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (List[List[str]]): The grid representation where 'C' represents a cell with a cow, and '.' represents an empty cell. Returns: int: The number of distinct clusters of cows. >>> number_of_clusters(4, 1, [['C'], ['C'], ['.'], ['C']]) 2 >>> number_of_clusters(1, 5, [['C', '.', 'C', '.', 'C']]) 3 >>> number_of_clusters(3, 3, [['C', 'C', 'C'], ['C', '.', 'C'], ['C', 'C', 'C']]) 1 >>> number_of_clusters(4, 5, [['C', '.', 'C', '.', 'C'], ['.', 'C', 'C', '.', '.'], ['.', '.', 'C', '.', 'C'], ['C', '.', '.', '.', 'C']]) 5 >>> number_of_clusters(3, 3, [['C', 'C', 'C'], ['C', 'C', 'C'], ['C', 'C', 'C']]) 1 >>> number_of_clusters(3, 3, [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) 0 >>> number_of_clusters(3, 4, [['C', '.', '.', 'C'], ['.', '.', '.', '.'], ['C', '.', '.', 'C']]) 4 pass","solution":"def number_of_clusters(n, m, grid): def dfs(i, j): if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] != 'C': return grid[i][j] = '.' # Mark the cell as visited by converting 'C' to '.' for direction in directions: ni, nj = i + direction[0], j + direction[1] dfs(ni, nj) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right clusters = 0 for i in range(n): for j in range(m): if grid[i][j] == 'C': dfs(i, j) clusters += 1 return clusters"},{"question":"def trap(height): Calculate the maximum amount of water that can be trapped between the buildings after raining. Each building's width is considered to be 1 unit. Args: height (List[int]): List of integers representing the height of each building. Returns: int: Maximum amount of trapped water. Examples: >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9 pass from solution import trap def test_example1(): assert trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 def test_example2(): assert trap([4,2,0,3,2,5]) == 9 def test_no_buildings(): assert trap([]) == 0 def test_no_water_trapped(): assert trap([3,3,3,3,3]) == 0 def test_all_different_heights(): assert trap([1,2,3,4,5]) == 0 assert trap([5,4,3,2,1]) == 0 def test_single_building(): assert trap([4]) == 0 def test_two_buildings(): assert trap([4,1]) == 0 assert trap([1,4]) == 0 def test_identical_buildings(): assert trap([0,0,0,0,0]) == 0 assert trap([1,1,1,1,1]) == 0","solution":"def trap(height): Calculate the maximum amount of water that can be trapped between the buildings after raining. Args: height (List[int]): List of integers representing the height of each building. Returns: int: Maximum amount of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def sorted_matrix_elements(matrix): Returns all elements of the matrix in ascending order as a single sorted list. >>> sorted_matrix_elements([ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ]) [1, 5, 9, 10, 11, 12, 13, 13, 15] >>> sorted_matrix_elements([ ... [-5, -3, 0], ... [-2, 1, 4], ... [2, 3, 5] ... ]) [-5, -3, -2, 0, 1, 2, 3, 4, 5] >>> sorted_matrix_elements([ ... [1, 2, 2], ... [2, 3, 4], ... [4, 5, 6] ... ]) [1, 2, 2, 2, 3, 4, 4, 5, 6] pass # Utility functions to read input in the specified format def read_matrix(input_string): Reads a matrix from a given input string. >>> read_matrix(\\"3n1 5 9n10 11 13n12 13 15\\") [[1, 5, 9], [10, 11, 13], [12, 13, 15]] pass def matrix_to_sorted_list_string(matrix): Converts the sorted matrix elements to a space-separated string. >>> matrix_to_sorted_list_string([ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ]) '1 5 9 10 11 12 13 13 15' pass","solution":"def sorted_matrix_elements(matrix): Returns all elements of the matrix in ascending order as a single sorted list. elements = [] for row in matrix: elements.extend(row) elements.sort() return elements # Utility functions to read input in the specified format def read_matrix(input_string): lines = input_string.strip().split('n') n = int(lines[0]) matrix = [] for i in range(1, n + 1): row = list(map(int, lines[i].split())) matrix.append(row) return matrix def matrix_to_sorted_list_string(matrix): sorted_elements = sorted_matrix_elements(matrix) return ' '.join(map(str, sorted_elements))"},{"question":"def zigzag(arr): Rearranges the input array into a zigzag sequence. >>> zigzag([1, 3, 5, 2]) [5, 1, 3, 2] >>> zigzag([9, 7, 10]) [10, 7, 9] def solve(test_cases): Processes multiple test cases to rearrange arrays into zigzag sequences. >>> solve([(4, [1, 3, 5, 2])]) [\\"5 1 3 2\\"] >>> solve([ (4, [1, 3, 5, 2]), (3, [9, 7, 10]) ]) [\\"5 1 3 2\\", \\"10 7 9\\"]","solution":"def zigzag(arr): Rearranges the input array into a zigzag sequence. arr.sort() n = len(arr) result = [] left = 0 right = n-1 while left <= right: if left == right: result.append(arr[left]) break result.append(arr[right]) result.append(arr[left]) left += 1 right -= 1 return result def solve(test_cases): results = [] for case in test_cases: N, arr = case if N <= 1: results.append(\\" \\".join(map(str, arr))) continue results.append(\\" \\".join(map(str, zigzag(arr)))) return results # Sample Input Handling def main(): import sys input = sys.stdin.read data = input().strip().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) arr = list(map(int, data[index + 1: index + 1 + N])) test_cases.append((N, arr)) index += 1 + N results = solve(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def safest_path(n, paths): Given the number of clearings, \`n\`, and a list of paths represented as tuples \`(u, v, s)\` where \`u\` and \`v\` are the connected clearings and \`s\` is the safety score, this function returns the maximum possible safety score for a path from clearing \`0\` to clearing \`n-1\`. If no such path exists, return \`-1\`. >>> safest_path(5, [(0, 1, 2), (0, 2, 5), (1, 2, 1), (2, 3, 8), (3, 4, 3), (1, 4, 4)]) 3 >>> safest_path(4, [(0, 1, 4), (1, 2, 3)]) -1 >>> safest_path(2, [(0, 1, 10)]) 10 >>> safest_path(6, [(0, 1, 5), (0, 2, 6), (1, 2, 2), (1, 3, 10), (2, 3, 4), (3, 4, 1), (4, 5, 9)]) 1 >>> safest_path(5, [(0, 1, 3), (0, 2, 4), (1, 2, 5), (1, 3, 8), (2, 4, 6), (3, 4, 7)]) 4","solution":"from heapq import heappop, heappush from collections import defaultdict from math import inf def safest_path(n, paths): # Create a graph representation graph = defaultdict(list) for u, v, s in paths: graph[u].append((v, s)) graph[v].append((u, s)) # Priority queue for Dijkstra's variant algorithm pq = [(-inf, 0)] safety_scores = [0] * n safety_scores[0] = inf # Dijkstra's variant to maximize safety scores while pq: current_safety, u = heappop(pq) current_safety = -current_safety for v, s in graph[u]: new_safety = min(current_safety, s) if new_safety > safety_scores[v]: safety_scores[v] = new_safety heappush(pq, (-new_safety, v)) # if safety_scores of destination is still 0, it means there's no path return safety_scores[n-1] if safety_scores[n-1] > 0 else -1"},{"question":"def warehouse_queries(N: int, Q: int, products: List[Tuple[int, int]], queries: List[int]) -> List[int]: Returns the list of quantities for each query. If product ID does not exist, returns -1 for that query. :param N: int - Number of different products :param Q: int - Number of queries :param products: list of tuples - Each tuple contains product ID and quantity (id_i, q_i) :param queries: list of int - Each int is a product ID to query (id_j) :return: list of int - Quantities for each query or -1 if the product does not exist >>> warehouse_queries(5, 3, [(1, 50), (2, 20), (5, 10), (6, 15), (8, 30)], [1, 3, 8]) [50, -1, 30] >>> warehouse_queries(0, 2, [], [1, 2]) [-1, -1] >>> warehouse_queries(3, 3, [(1, 10), (2, 20), (3, 30)], [1, 2, 3]) [10, 20, 30] >>> warehouse_queries(4, 3, [(1, 5), (2, 15), (3, 25), (4, 35)], [2, 4, 5]) [15, 35, -1] >>> warehouse_queries(2, 5, [(1, 100), (2, 200)], [1, 1, 2, 2, 1]) [100, 100, 200, 200, 100]","solution":"def warehouse_queries(N, Q, products, queries): Returns the list of quantities for each query. If product ID does not exist, returns -1 for that query. :param N: int - Number of different products :param Q: int - Number of queries :param products: list of tuples - Each tuple contains product ID and quantity (id_i, q_i) :param queries: list of int - Each int is a product ID to query (id_j) :return: list of int - Quantities for each query or -1 if the product does not exist product_dict = {product_id: quantity for product_id, quantity in products} result = [] for query in queries: if query in product_dict: result.append(product_dict[query]) else: result.append(-1) return result"},{"question":"def final_value_after_operations(nums: List[int]) -> int: Perform operations described in nums on a number starting from 0 and return the final value. Args: nums (List[int]): List of integers representing operations. Returns: int: The final value after performing all operations. >>> final_value_after_operations([5, -3, 4, 0, 2]) 2 >>> final_value_after_operations([10, -10, 10, -10, 10]) 10 >>> final_value_after_operations([1, 2, 3, 4, 5]) 15 >>> final_value_after_operations([-1, -2, -3, -4, -5]) -15 >>> final_value_after_operations([0, 0, 0, 0]) 0 >>> final_value_after_operations([3, -4, 10, 0, 5, -3]) 2 >>> final_value_after_operations([0, 0, 1, 2, 0, -1]) -1","solution":"def final_value_after_operations(nums): Perform operations described in nums on a number starting from 0 and return the final value. Args: nums (List[int]): List of integers representing operations. Returns: int: The final value after performing all operations. current = 0 for num in nums: if num > 0: current += num elif num < 0: current -= abs(num) else: current = 0 return current"},{"question":"def generate_spiral_matrix(n: int) -> List[List[int]]: Generates a n x n spiral matrix. >>> generate_spiral_matrix(1) [[1]] >>> generate_spiral_matrix(2) [[1, 2], [4, 3]] >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral_matrix(5) [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]","solution":"def generate_spiral_matrix(n): Generates a n x n spiral matrix. :param n: size of the matrix (integer) :return: 2-dimensional list representing the spiral matrix # Initialize an n x n matrix filled with zeros matrix = [[0] * n for _ in range(n)] num = 1 left, right, top, bottom = 0, n-1, 0, n-1 while left <= right and top <= bottom: # Traverse from left to right for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 # Traverse from right to left if top <= bottom: for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 # Traverse from bottom to top if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"def find_max_product(arr): Returns the maximum product of any two distinct elements in the array. If the array has fewer than two elements, return None. >>> find_max_product([1, 10, 2, 6, 5, 3]) 60 >>> find_max_product([-10, -20, 1, 3, 2]) 200 >>> find_max_product([-10, 7, 29, 30, -5, 20]) 870 >>> find_max_product([5]) None >>> find_max_product([5, 10]) 50 >>> find_max_product([-5, -10]) 50 >>> find_max_product([-5, 10]) -50 >>> find_max_product([]) None","solution":"def find_max_product(arr): Returns the maximum product of any two distinct elements in the array. If the array has fewer than two elements, return None. if len(arr) < 2: return None arr.sort() # Compare product of two largest with product of two smallest return max(arr[0] * arr[1], arr[-1] * arr[-2])"},{"question":"from typing import List def largest_plus_sign(grid: List[List[int]]) -> int: Determine the order of the largest plus sign in a given grid. :param grid: List of List of integers representing the grid :return: Integer representing the order of the largest plus sign >>> largest_plus_sign([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) 2 >>> largest_plus_sign([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) 0 >>> largest_plus_sign([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 1 >>> largest_plus_sign([[1, 1, 1, 1, 1]]) 0 >>> largest_plus_sign([[1], [1], [1], [1], [1]]) 0 >>> largest_plus_sign([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 def read_input_and_solve(n: int, m: int, input_grid: List[str]) -> int: Reads input grid from list of strings and solves for the largest plus sign order. :param n: Number of rows in the grid :param m: Number of columns in the grid :param input_grid: List of strings representing the grid rows :return: Integer representing the order of the largest plus sign def test_example_1(): n, m = 5, 5 input_grid = [ \\"1 1 1 1 1\\", \\"1 1 1 1 1\\", \\"1 1 1 1 1\\", \\"1 1 1 1 1\\", \\"1 1 1 1 1\\" ] assert read_input_and_solve(n, m, input_grid) == 2 def test_example_2(): n, m = 3, 3 input_grid = [ \\"1 0 1\\", \\"0 1 0\\", \\"1 0 1\\" ] assert read_input_and_solve(n, m, input_grid) == 0 def test_single_row(): n, m = 1, 5 input_grid = [\\"1 1 1 1 1\\"] assert read_input_and_solve(n, m, input_grid) == 0 def test_single_column(): n, m = 5, 1 input_grid = [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\"] assert read_input_and_solve(n, m, input_grid) == 0 def test_all_zeros(): n, m = 3, 3 input_grid = [ \\"0 0 0\\", \\"0 0 0\\", \\"0 0 0\\" ] assert read_input_and_solve(n, m, input_grid) == 0 def test_small_plus(): n, m = 3, 3 input_grid = [ \\"1 1 1\\", \\"1 1 1\\", \\"1 1 1\\" ] assert read_input_and_solve(n, m, input_grid) == 1","solution":"def largest_plus_sign(grid): Function to determine the order of the largest plus sign in a given grid :param grid: List of List of integers representing the grid :return: Integer representing the order of the largest plus sign n = len(grid) if n == 0: return 0 m = len(grid[0]) # Initialize dp arrays left = [[0] * m for _ in range(n)] right = [[0] * m for _ in range(n)] up = [[0] * m for _ in range(n)] down = [[0] * m for _ in range(n)] # Fill dp arrays for i in range(n): for j in range(m): if grid[i][j] == 1: left[i][j] = left[i][j-1] + 1 if j > 0 else 1 up[i][j] = up[i-1][j] + 1 if i > 0 else 1 for i in range(n-1, -1, -1): for j in range(m-1, -1, -1): if grid[i][j] == 1: right[i][j] = right[i][j+1] + 1 if j < m-1 else 1 down[i][j] = down[i+1][j] + 1 if i < n-1 else 1 # Calculate the max order of the plus sign max_order = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: order = min(left[i][j], right[i][j], up[i][j], down[i][j]) max_order = max(max_order, order) # The order of a plus sign is the number of 1s in each direction plus the center 1 return max_order - 1 if max_order > 0 else 0 def read_input_and_solve(n, m, input_grid): grid = [] for row in input_grid: grid.append(list(map(int, row.split()))) return largest_plus_sign(grid)"},{"question":"import re from collections import Counter def top_n_words(file_path: str, n: int) -> list: Reads the file at file_path, counts the occurrences of each word (case-insensitively), and returns a list of the n most frequent words in the text file. >>> top_n_words(\\"example.txt\\", 2) [\\"test\\", \\"this\\"] >>> top_n_words(\\"example.txt\\", 3) [\\"test\\", \\"this\\", \\"is\\"] >>> top_n_words(\\"example.txt\\", 0) [] from solution import top_n_words def test_top_n_words_valid_path(): # Create a temporary file for testing with open('temp_test_file.txt', 'w') as f: f.write(\\"This is a test. This test is only a test.\\") result = top_n_words('temp_test_file.txt', 2) assert result == [\\"test\\", \\"this\\"] # Cleanup import os os.remove('temp_test_file.txt') def test_top_n_words_zero_n(): result = top_n_words('nonexistent_file.txt', 0) assert result == [] def test_top_n_words_negative_n(): result = top_n_words('nonexistent_file.txt', -1) assert result == [] def test_top_n_words_file_does_not_exist(): result = top_n_words('nonexistent_file.txt', 3) assert result == [] def test_top_n_words_empty_file(): # Create a temporary empty file for testing with open('temp_empty_file.txt', 'w') as f: pass result = top_n_words('temp_empty_file.txt', 3) assert result == [] # Cleanup import os os.remove('temp_empty_file.txt') def test_top_n_words_case_insensitivity(): # Create a temporary file for testing with open('temp_case_file.txt', 'w') as f: f.write(\\"Word word WORD\\") result = top_n_words('temp_case_file.txt', 1) assert result == [\\"word\\"] # Cleanup import os os.remove('temp_case_file.txt') def test_top_n_words_with_punctuation(): # Create a temporary file for testing with open('temp_punctuation_file.txt', 'w') as f: f.write(\\"Hello, world! This is a test. Hello, test world.\\") result = top_n_words('temp_punctuation_file.txt', 3) assert result == [\\"hello\\", \\"world\\", \\"test\\"] # Cleanup import os os.remove('temp_punctuation_file.txt')","solution":"import re from collections import Counter def top_n_words(file_path, n): Reads the file at file_path, counts the occurrences of each word (case-insensitively), and returns a list of the n most frequent words in the text file. if n <= 0: return [] try: with open(file_path, 'r') as file: text = file.read() except Exception: return [] # Normalize text: convert to lowercase and remove punctuation words = re.findall(r'bw+b', text.lower()) if not words: return [] word_counts = Counter(words) most_common = word_counts.most_common(n) # Extract just the words from the most_common tuples return [word for word, count in most_common]"},{"question":"def can_form_palindrome(s: str) -> bool: Determine if any permutation of the input string can form a palindrome. Args: s (str): input string consisting of lowercase English alphabets and spaces Returns: bool: True if any permutation of the input string can form a palindrome, False otherwise Example: >>> can_form_palindrome(\\"tact coa\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aba\\") True","solution":"def can_form_palindrome(s): Determine if any permutation of the input string can form a palindrome. Args: s (str): input string consisting of lowercase English alphabets and spaces Returns: bool: True if any permutation of the input string can form a palindrome, False otherwise # Remove spaces and convert to lowercase s = s.replace(\\" \\", \\"\\").lower() # Use a set to track characters that appear an odd number of times odd_chars = set() for char in s: if char in odd_chars: odd_chars.remove(char) else: odd_chars.add(char) # For a string to be able to form a palindrome, at most one character can appear an odd number of times return len(odd_chars) <= 1"},{"question":"from typing import List, Tuple def count_consecutive_occurrences(lst: List[int]) -> List[Tuple[int, int]]: Takes a list of integers and returns a list of tuples. Each tuple contains an integer from the input list and the number of times that integer appears consecutively in the list. >>> count_consecutive_occurrences([1, 1, 2, 2, 2, 3]) [(1, 2), (2, 3), (3, 1)] >>> count_consecutive_occurrences([4, 4, 4, 4]) [(4, 4)] >>> count_consecutive_occurrences([1, 2, 3, 3, 3, 4, 4]) [(1, 1), (2, 1), (3, 3), (4, 2)] >>> count_consecutive_occurrences([]) []","solution":"def count_consecutive_occurrences(lst): if not lst: return [] result = [] count = 1 for i in range(1, len(lst)): if lst[i] == lst[i - 1]: count += 1 else: result.append((lst[i - 1], count)) count = 1 result.append((lst[-1], count)) return result"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index = {} start = 0 max_length = 0 for i, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def group_in_intervals(lst: List[int]) -> List[str]: Groups integers in intervals of five and returns interval counts in the format \\"start-end: count\\". >>> group_in_intervals([0, 1, 2, 5, 6, 10, 12, 14, 15, 20, 25]) [\\"0-4: 3\\", \\"5-9: 2\\", \\"10-14: 3\\", \\"15-19: 1\\", \\"20-24: 1\\", \\"25-29: 1\\"] >>> group_in_intervals([0, 2, 4, 6, 8, 9, 11, 15]) [\\"0-4: 3\\", \\"5-9: 3\\", \\"10-14: 1\\", \\"15-19: 1\\"] >>> group_in_intervals([0, 5, 10, 15]) [\\"0-4: 1\\", \\"5-9: 1\\", \\"10-14: 1\\", \\"15-19: 1\\"] >>> group_in_intervals([]) [] >>> group_in_intervals([10, 20, 30]) [\\"0-4: 0\\", \\"5-9: 0\\", \\"10-14: 1\\", \\"15-19: 0\\", \\"20-24: 1\\", \\"25-29: 0\\", \\"30-34: 1\\"]","solution":"def group_in_intervals(lst): Groups integers in intervals of five and returns interval counts in the format \\"start-end: count\\". if not lst: return [] max_val = max(lst) result = [] for start in range(0, max_val + 1, 5): end = start + 4 count = sum(1 for num in lst if start <= num <= end) result.append(f\\"{start}-{end}: {count}\\") return result"},{"question":"def execute_command(n: int, expressions: List[str], commands: List[str], variables: Dict[str, int]) -> str: Evaluates a list of boolean expressions against provided variables, and returns the corresponding command to be executed. :param n: Number of expressions and commands :param expressions: List of boolean expression strings :param commands: List of command strings :param variables: Dictionary of variable values :return: The command string to be executed >>> n = 3 >>> expressions = [\\"x > 10\\", \\"y == 5\\", \\"z != 0\\"] >>> commands = [ ... 'print(\\"Expression 1 is True\\")', ... 'print(\\"Expression 2 is True\\")', ... 'print(\\"Expression 3 is True\\")', ... 'print(\\"No expressions are True\\")' ... ] >>> variables = {\\"x\\": 7, \\"y\\": 5, \\"z\\": 0} >>> execute_command(n, expressions, commands, variables) 'print(\\"Expression 2 is True\\")' >>> n = 2 >>> expressions = [\\"a == 1\\", \\"b == 2\\"] >>> commands = [ ... 'print(\\"Expression 1 is True\\")', ... 'print(\\"Expression 2 is True\\")', ... 'print(\\"No expressions are True\\")' ... ] >>> variables = {\\"a\\": 3, \\"b\\": 2} >>> execute_command(n, expressions, commands, variables) 'print(\\"Expression 2 is True\\")'","solution":"def execute_command(n, expressions, commands, variables): Evaluates a list of boolean expressions against provided variables, and returns the corresponding command to be executed. :param n: Number of expressions and commands :param expressions: List of boolean expression strings :param commands: List of command strings :param variables: Dictionary of variable values :return: The command string to be executed for i in range(n): if eval(expressions[i], {}, variables): return commands[i] return commands[-1]"},{"question":"def largest_island(grid: List[List[str]]) -> int: Finds the size of the largest island of connected land cells in the given grid. Two land cells are considered connected if they share an edge horizontally or vertically. Args: grid (List of List of str): The 2D grid of 'L' and 'W' representing land and water. Returns: int: The size of the largest island. >>> largest_island([ ['L', 'L', 'W', 'L', 'L'], ['L', 'W', 'L', 'L', 'L'], ['W', 'W', 'W', 'L', 'L'], ['L', 'L', 'W', 'L', 'W'] ]) 8 >>> largest_island([ ['W', 'W', 'W'], ['W', 'L', 'W'], ['W', 'W', 'W'] ]) 1 >>> largest_island([ ['L', 'L', 'L'], ['L', 'L', 'L'], ['L', 'L', 'L'] ]) 9 >>> largest_island([ ['W', 'W', 'W', 'W'], ['W', 'W', 'W', 'W'], ['W', 'W', 'W', 'W'], ['W', 'W', 'W', 'W'] ]) 0 >>> largest_island([]) 0 >>> largest_island([[\\"W\\"]]) 0 >>> largest_island([[\\"L\\"]]) 1","solution":"def largest_island(grid): Finds the size of the largest island of connected land cells in the given grid. Args: grid (List of List of str): The 2D grid of 'L' and 'W' representing land and water. Returns: int: The size of the largest island. if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == 'W': return 0 grid[x][y] = 'W' # Mark the cell as visited by setting it as water size = 1 size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_island_size = 0 for i in range(n): for j in range(m): if grid[i][j] == 'L': max_island_size = max(max_island_size, dfs(i, j)) return max_island_size"},{"question":"def rearrange_books(shelf): Rearranges books on a shelf such that all books are in ascending order. Misplaced books are either correctly placed or removed. Args: shelf (list of int): List of integers representing the books on the shelf. Returns: list of int: The rearranged shelf in ascending order. def test_rearrange_books_sample(): assert rearrange_books([1, 2, 4, 3, 6, 5, 9, 7, 10]) == [1, 2, 3, 4, 5, 6, 7, 9, 10] def test_rearrange_books_no_misplaced(): assert rearrange_books([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6] def test_rearrange_books_all_misplaced(): assert rearrange_books([9, 7, 6, 5, 3, 2, 1, 4]) == [1, 2, 3, 4, 5, 6, 7, 9] def test_single_book(): assert rearrange_books([2]) == [2] def test_empty_shelf(): assert rearrange_books([]) == [] def test_all_missing_books(): assert rearrange_books([100, 200, 300, 400]) == [100, 200, 300, 400] def test_duplicates(): assert rearrange_books([4, 1, 2, 4, 3, 2, 5, 1]) == [1, 2, 3, 4, 5]","solution":"def rearrange_books(shelf): Rearranges books on a shelf such that all books are in ascending order. Misplaced books are either correctly placed or removed. Args: shelf (list of int): List of integers representing the books on the shelf. Returns: list of int: The rearranged shelf in ascending order. # Remove duplicates shelf = list(set(shelf)) # Sort and return the shelf shelf.sort() return shelf"},{"question":"def remove_duplicates(arr: List[int]) -> List[int]: This function receives an integer array as input and returns a new array containing only the unique elements, maintaining the order of their first occurrence. >>> remove_duplicates([1, 2, 3, 1, 2, 4]) [1, 2, 3, 4] >>> remove_duplicates([10, 20, 10, 30, 20, 40, 30]) [10, 20, 30, 40] >>> remove_duplicates([5, 5, 5, 5, 5]) [5] >>> remove_duplicates([]) [] # Implement your solution here from solution import remove_duplicates def test_remove_duplicates_with_repeated_elements(): assert remove_duplicates([1, 2, 3, 1, 2, 4]) == [1, 2, 3, 4] def test_remove_duplicates_with_all_unique_elements(): assert remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_remove_duplicates_with_all_identical_elements(): assert remove_duplicates([5, 5, 5, 5, 5]) == [5] def test_remove_duplicates_with_some_repeated_elements(): assert remove_duplicates([10, 20, 10, 30, 20, 40, 30]) == [10, 20, 30, 40] def test_remove_duplicates_with_empty_array(): assert remove_duplicates([]) == [] def test_remove_duplicates_with_single_element_array(): assert remove_duplicates([100]) == [100] def test_remove_duplicates_with_large_numbers(): assert remove_duplicates([-100000, 100000, -100000, 100000]) == [-100000, 100000] def test_remove_duplicates_with_mixed_positive_and_negative_numbers(): assert remove_duplicates([-1, 1, -1, -1, 1, 2, -2]) == [-1, 1, 2, -2]","solution":"def remove_duplicates(arr): This function receives an integer array as input and returns a new array containing only the unique elements, maintaining the order of their first occurrence. seen = set() unique_arr = [] for num in arr: if num not in seen: seen.add(num) unique_arr.append(num) return unique_arr"},{"question":"def can_be_palindrome(s: str) -> bool: Determine if the string can be rearranged to form a palindrome. :param s: A string containing only lowercase English letters :return: A boolean indicating whether the string can be rearranged to form a palindrome Examples: >>> can_be_palindrome(\\"civic\\") == True >>> can_be_palindrome(\\"ivicc\\") == True >>> can_be_palindrome(\\"hello\\") == False >>> can_be_palindrome(\\"aabbccdd\\") == True","solution":"def can_be_palindrome(s): Determine if the string can be rearranged to form a palindrome. :param s: A string containing only lowercase English letters :return: A boolean indicating whether the string can be rearranged to form a palindrome from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 == 1) # String can be rearranged to form a palindrome if at most one character has an odd frequency return odd_count <= 1"},{"question":"def sum_of_squares(lst: List[int]) -> int: Implement a function that takes a list of integers and returns the sum of the squares of all the even numbers in the list. If the list is empty or contains no even numbers, the function should return 0. >>> sum_of_squares([1, 2, 3, 4, 5]) 20 >>> sum_of_squares([1, 3, 5, 7]) 0 >>> sum_of_squares([]) 0 >>> sum_of_squares([10, -3, -2, 4]) 120 def test_sum_of_squares_with_mixed_numbers(): assert sum_of_squares([1, 2, 3, 4, 5]) == 20 def test_sum_of_squares_with_no_even_numbers(): assert sum_of_squares([1, 3, 5, 7]) == 0 def test_sum_of_squares_with_empty_list(): assert sum_of_squares([]) == 0 def test_sum_of_squares_with_negative_even_numbers(): assert sum_of_squares([10, -3, -2, 4]) == 120 def test_sum_of_squares_with_all_even_numbers(): assert sum_of_squares([2, 4, 6, 8]) == 120 def test_sum_of_squares_with_single_even_number(): assert sum_of_squares([4]) == 16 def test_sum_of_squares_with_single_odd_number(): assert sum_of_squares([3]) == 0 def test_sum_of_squares_with_negative_and_positive_even_numbers(): assert sum_of_squares([-4, -6, 3, 5, 6]) == 88","solution":"def sum_of_squares(lst): Returns the sum of the squares of all the even numbers in the list. If the list is empty or contains no even numbers, returns 0. return sum(x ** 2 for x in lst if x % 2 == 0)"},{"question":"import math from typing import List def is_factorial_sum_divisible(num: int) -> bool: Given a positive integer num, returns True if the sum of the factorial of each digit in num is divisible by the original number, else False. >>> is_factorial_sum_divisible(145) True >>> is_factorial_sum_divisible(123) False >>> is_factorial_sum_divisible(40585) True >>> is_factorial_sum_divisible(1) True >>> is_factorial_sum_divisible(2) True >>> is_factorial_sum_divisible(5) True >>> is_factorial_sum_divisible(9) True >>> is_factorial_sum_divisible(10) False >>> is_factorial_sum_divisible(25) False >>> is_factorial_sum_divisible(44) False >>> is_factorial_sum_divisible(1001) False >>> is_factorial_sum_divisible(99999) False","solution":"import math def is_factorial_sum_divisible(num): Returns True if the sum of the factorial of each digit in num is divisible by the original number, else False. digit_factorial_sum = sum(math.factorial(int(digit)) for digit in str(num)) return digit_factorial_sum % num == 0"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with unique characters. >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"aab\\") 2 >>> longest_unique_substring(\\"\\") 0 >>> longest_unique_substring(\\"a\\") 1 >>> longest_unique_substring(\\"aa\\") 1 >>> longest_unique_substring(\\"ab\\") 2 >>> longest_unique_substring(\\"dvdf\\") 3","solution":"def longest_unique_substring(s): Returns the length of the longest substring with unique characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: left = max(char_map[s[right]] + 1, left) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List def shortest_path_forest(grid: List[List[int]]) -> int: Find the shortest path from the top-left corner to the bottom-right corner of the grid. Parameters: grid (List[List[int]]): A 2D list representing the forest grid where 1 is a path and 0 is an obstacle. Returns: int: The length of the shortest path. If no path exists, return -1. Example: >>> shortest_path_forest([ ... [1, 0, 1, 1], ... [1, 1, 1, 0], ... [0, 1, 0, 1], ... [1, 1, 1, 1] ... ]) 5 >>> shortest_path_forest([ ... [1, 1], ... [1, 1] ... ]) 3 >>> shortest_path_forest([ ... [1, 0], ... [0, 1] ... ]) -1 >>> shortest_path_forest([ ... [1, 1, 0], ... [0, 1, 1], ... [1, 1, 1] ... ]) 5 >>> shortest_path_forest([ ... [1, 1, 1], ... [0, 0, 1], ... [1, 1, 1] ... ]) 5","solution":"from collections import deque def shortest_path_forest(grid): Returns the length of the shortest path from the top-left to the bottom-right corner of the grid. If no path exists, returns -1. if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # To track visited cells visited = [[False] * cols for _ in range(rows)] visited[0][0] = True # Queue for BFS (stores (row, col, distance)) queue = deque([(0, 0, 1)]) while queue: r, c, dist = queue.popleft() # If we've reached the bottom-right corner if r == rows - 1 and c == cols - 1: return dist # Explore all four possible directions for dr, dc in directions: new_r, new_c = r + dr, c + dc if 0 <= new_r < rows and 0 <= new_c < cols and grid[new_r][new_c] == 1 and not visited[new_r][new_c]: visited[new_r][new_c] = True queue.append((new_r, new_c, dist + 1)) # If no valid path is found return -1"},{"question":"def capitalize_sentence(s: str) -> str: Converts given string such that each word starts with an uppercase letter and all other letters are in lowercase. Words are separated by a single space. If the input string is None or empty, return an empty string. >>> capitalize_sentence(\\"hello world\\") == \\"Hello World\\" >>> capitalize_sentence(\\" multiple spaces between words \\") == \\"Multiple Spaces Between Words\\" >>> capitalize_sentence(\\"mixedCASE WoRdS\\") == \\"Mixedcase Words\\" >>> capitalize_sentence(None) == \\"\\" >>> capitalize_sentence(\\"\\") == \\"\\" >>> capitalize_sentence(\\"PYTHON\\") == \\"Python\\" >>> capitalize_sentence(\\" python \\") == \\"Python\\"","solution":"def capitalize_sentence(s): Converts given string such that each word starts with an uppercase letter and all other letters are in lowercase. Words are separated by a single space. If the input string is None or empty, returns an empty string. if s is None or s.strip() == \\"\\": return \\"\\" return ' '.join(word.capitalize() for word in s.split())"},{"question":"def total_pages(chapters): Calculates the total number of pages a person reads given the number of chapters and the pages in each chapter, considering the bonus chapters read every 3rd day. :param chapters: List of integers representing pages in each chapter :return: Total number of pages read >>> total_pages([10, 20, 30, 40, 50]) == 150 >>> total_pages([15, 25, 35, 45]) == 120 >>> total_pages([]) == 0 >>> total_pages([42]) == 42 >>> total_pages([10, 20, 30, 40, 50, 60, 70, 80, 90]) == 450 >>> total_pages([10, 15]) == 25 >>> total_pages([10, 20, 30, 40, 50, 60]) == 210 >>> total_pages([5, 10, 15, 20, 25, 30, 35, 40]) == 180","solution":"def total_pages(chapters): Calculates the total number of pages a person reads given the number of chapters and the pages in each chapter, considering the bonus chapters read every 3rd day. :param chapters: List of integers representing pages in each chapter :return: Total number of pages read total_pages_read = 0 chapter_count = len(chapters) day = 1 i = 0 while i < chapter_count: # Read the current chapter total_pages_read += chapters[i] i += 1 # Check for the bonus chapter if it's every 3rd day and there's at least one more chapter if day % 3 == 0 and i < chapter_count: total_pages_read += chapters[i] i += 1 day += 1 return total_pages_read"},{"question":"def majority_element(nums: List[int]) -> int: Returns the majority element in the array 'nums', which is the element that appears more than n/2 times. >>> majority_element([3, 2, 3]) 3 >>> majority_element([2, 2, 2, 2, 2]) 2 >>> majority_element([1]) 1 >>> majority_element([1, 1, 2, 2, 1]) 1 >>> majority_element([1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2]) 2","solution":"def majority_element(nums): Returns the majority element in the array 'nums', which is the element that appears more than n/2 times. count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate"},{"question":"def three_sum(arr: List[int]) -> List[List[int]]: Given an array of distinct integers, find all triplets (a, b, c) such that a + b + c = 0. Each triplet should be in ascending order, and the set of triplets should be sorted in lexicographic order. >>> three_sum([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, 3, 4, 5]) == [] >>> three_sum([0, 0, 0, 0]) == [[0, 0, 0]] >>> three_sum([-4, -2, -1, 0, 1, 2, 3]) == [[-4, 1, 3], [-2, -1, 3], [-2, 0, 2], [-1, 0, 1]] >>> three_sum([-1, -1, 2, 2]) == [[-1, -1, 2]]","solution":"def three_sum(arr): Given an array of distinct integers, find all triplets (a, b, c) such that a + b + c = 0. Each triplet is in ascending order, and the set of triplets is sorted in lexicographic order. arr.sort() triplets = [] for i in range(len(arr) - 2): # Skip duplicate elements to avoid duplicate triplets if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, len(arr) - 1 while left < right: s = arr[i] + arr[left] + arr[right] if s == 0: triplets.append([arr[i], arr[left], arr[right]]) left += 1 right -= 1 # Skip duplicates for left and right pointers while left < right and arr[left] == arr[left - 1]: left += 1 while left < right and arr[right] == arr[right + 1]: right -= 1 elif s < 0: left += 1 else: right -= 1 return triplets"},{"question":"def min_removals_to_increasing(heights): Returns the minimum number of students that need to be removed to make the remaining heights strictly increasing. >>> min_removals_to_increasing([5, 2, 3, 6, 4, 8]) 2 >>> min_removals_to_increasing([1, 2, 3, 4, 5]) 0 pass def process_test_cases(T, test_cases): Processes multiple test cases to find the minimum number of removals for each case. >>> process_test_cases(2, [(6, [5, 2, 3, 6, 4, 8]), (5, [1, 2, 3, 4, 5])]) [2, 0] >>> process_test_cases(1, [(4, [1, 2, 2, 2])]) [2] pass","solution":"def min_removals_to_increasing(heights): Returns the minimum number of students that need to be removed to make the remaining heights strictly increasing. n = len(heights) if n == 0: return 0 # Longest Increasing Subsequence (LIS) length calculation lis = [1] * n for i in range(1, n): for j in range(0, i): if heights[i] > heights[j]: lis[i] = max(lis[i], lis[j] + 1) # The minimum number of removals is n - length of LIS return n - max(lis) def process_test_cases(T, test_cases): results = [] for i in range(T): n, heights = test_cases[i] results.append(min_removals_to_increasing(heights)) return results"},{"question":"from typing import List def trap(walls: List[int]) -> int: Calculate the maximum volume of water that can be trapped between the walls after it rains. :param walls: List of non-negative integers representing wall heights. :return: Integer representing the maximum volume of water trapped. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9 # Unit tests def test_trap_example(): assert trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 def test_trap_all_zero_walls(): assert trap([0, 0, 0, 0]) == 0 def test_trap_no_walls(): assert trap([]) == 0 def test_trap_single_wall(): assert trap([4]) == 0 def test_trap_two_equal_walls(): assert trap([3, 3]) == 0 def test_trap_rising_walls(): assert trap([0, 1, 2, 3, 4]) == 0 def test_trap_descending_walls(): assert trap([4, 3, 2, 1, 0]) == 0 def test_trap_peak_and_valley(): assert trap([0, 1, 3, 1, 0]) == 0 def test_trap_complex_case(): assert trap([4, 2, 0, 3, 2, 5]) == 9","solution":"def trap(walls): Calculate the maximum volume of water trapped between the walls. :param walls: List of non-negative integers representing wall heights. :return: Integer representing maximum volume of water trapped. if not walls: return 0 left, right = 0, len(walls) - 1 left_max, right_max = walls[left], walls[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, walls[left]) water_trapped += max(0, left_max - walls[left]) else: right -= 1 right_max = max(right_max, walls[right]) water_trapped += max(0, right_max - walls[right]) return water_trapped"},{"question":"def longest_consecutive_subsequence(nums: List[int]) -> List[int]: Given a list of integers, returns the longest subsequence of consecutive integers in any order. If multiple sequences have the same length, returns the one that starts with the smallest integer. >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) == [1, 2, 3, 4] >>> longest_consecutive_subsequence([10, 5, 12, 3, 55, 6, 11]) == [10, 11, 12] >>> longest_consecutive_subsequence([1, 9, 3, 10, 2, 20]) == [1, 2, 3] import doctest doctest.testmod() from solution import longest_consecutive_subsequence def test_empty_list(): assert longest_consecutive_subsequence([]) == [] def test_single_element_list(): assert longest_consecutive_subsequence([1]) == [1] def test_no_consecutive_sequence(): assert longest_consecutive_subsequence([10, 20, 30]) == [10] def test_example_one(): assert longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) == [1, 2, 3, 4] def test_example_two(): assert longest_consecutive_subsequence([10, 5, 12, 3, 55, 6, 11]) == [10, 11, 12] def test_example_three(): assert longest_consecutive_subsequence([1, 9, 3, 10, 2, 20]) == [1, 2, 3] def test_multiple_same_length_sequences(): assert longest_consecutive_subsequence([1, 2, 10, 11, 12, 20]) == [10, 11, 12] def test_all_elements_consecutive(): assert longest_consecutive_subsequence([4, 5, 2, 3, 1]) == [1, 2, 3, 4, 5]","solution":"def longest_consecutive_subsequence(nums): Given a list of integers, returns the longest subsequence of consecutive integers in any order. If multiple sequences have the same length, returns the one that starts with the smallest integer. if not nums: return [] nums_set = set(nums) longest_sequence = [] for num in nums: # Check if this is the start of a sequence if num - 1 not in nums_set: current_sequence = [] current_num = num # Build the current sequence while current_num in nums_set: current_sequence.append(current_num) current_num += 1 # Update the longest sequence if necessary if (len(current_sequence) > len(longest_sequence) or (len(current_sequence) == len(longest_sequence) and current_sequence[0] < longest_sequence[0])): longest_sequence = current_sequence return longest_sequence"},{"question":"from typing import List def correct_filenames(filenames: List[str]) -> List[str]: Correct the extensions of the filenames according to the given rules. 1. If the file starts with 'IMG_' and has a '.mp3' extension, change it to '.jpg'. 2. If the file starts with 'VID_' and has a '.jpg' extension, change it to '.mp4'. 3. Any other files should remain unchanged. >>> correct_filenames(['IMG_1234.mp3', 'VID_5678.jpg', 'IMG_sunset.jpg', 'VID_trip.mp4', 'README.txt']) ['IMG_1234.jpg', 'VID_5678.mp4', 'IMG_sunset.jpg', 'VID_trip.mp4', 'README.txt'] >>> correct_filenames(['IMG_12.mp3', 'VID_34.jpg', 'IMG_sky.mp3', 'movie.mp4', 'TXT.doc']) ['IMG_12.jpg', 'VID_34.mp4', 'IMG_sky.mp3', 'movie.mp4', 'TXT.doc']","solution":"def correct_filenames(filenames): corrected_filenames = [] for name in filenames: if name.startswith('IMG_') and name.endswith('.mp3'): corrected_filenames.append(name[:-4] + '.jpg') elif name.startswith('VID_') and name.endswith('.jpg'): corrected_filenames.append(name[:-4] + '.mp4') else: corrected_filenames.append(name) return corrected_filenames"},{"question":"def smallest_unreachable_sum(t, test_cases): Find the smallest positive integer that cannot be represented as the sum of any subset of the given list for multiple test cases. Args: t: Number of test cases. test_cases: List of tuples, each containing an integer (size of the list) and a list of integers. Returns: List of integers, each representing the smallest positive integer that cannot be represented as the sum of any subset of the corresponding list. >>> smallest_unreachable_sum(\\"2n3n1 2 2n4n1 2 5 10n\\") [6, 4] >>> smallest_unreachable_sum(\\"1n1n2n\\") [1] >>> smallest_unreachable_sum(\\"1n4n1 2 3 4n\\") [11] >>> smallest_unreachable_sum(\\"1n3n1000000000 1000000001 1000000002n\\") [1] >>> smallest_unreachable_sum(\\"1n4n5 5 5 5n\\") [1] >>> smallest_unreachable_sum(\\"1n1n1n\\") [2] def parse_input(input_data): Parse the input data string to extract the number of test cases and the list of test cases. Args: input_data: A string representing the raw input data. Returns: A tuple containing an integer (number of test cases) and a list of tuples, each containing an integer (size of the list) and a list of integers. >>> parse_input(\\"2n3n1 2 2n4n1 2 5 10n\\") (2, [(3, [1, 2, 2]), (4, [1, 2, 5, 10])]) >>> parse_input(\\"1n1n2n\\") (1, [(1, [2])]) >>> parse_input(\\"1n4n1 2 3 4n\\") (1, [(4, [1, 2, 3, 4])]) >>> parse_input(\\"1n3n1000000000 1000000001 1000000002n\\") (1, [(3, [1000000000, 1000000001, 1000000002])]) >>> parse_input(\\"1n4n5 5 5 5n\\") (1, [(4, [5, 5, 5, 5])]) >>> parse_input(\\"1n1n1n\\") (1, [(1, [1])])","solution":"def smallest_unreachable_sum(t, test_cases): results = [] for test_case in test_cases: n, arr = test_case arr.sort() smallest_unreachable = 1 for num in arr: if num > smallest_unreachable: break smallest_unreachable += num results.append(smallest_unreachable) return results def parse_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0].strip()) test_cases = [] idx = 1 for _ in range(T): N = int(lines[idx].strip()) arr = list(map(int, lines[idx + 1].strip().split())) test_cases.append((N, arr)) idx += 2 return T, test_cases"},{"question":"def max_sum_subarray(arr: List[int], k: int) -> int: Write a function that takes a list of integers and an integer k, and returns the maximum sum of any contiguous subarray of size k. A subarray is a contiguous part of an array. The goal is to find the contiguous subarray of length k that has the maximum sum and return the sum. If the list has fewer than k elements, return -1. Parameters: arr (list of int): The list of integers. k (int): The size of the subarray. Returns: int: The maximum sum of any contiguous subarray of size k. Returns -1 if the list has fewer than k elements. Example: >>> max_sum_subarray([1, 2, 3, 4, 5], 2) 9 >>> max_sum_subarray([1, -1, 5, 2, 3], 3) 10 >>> max_sum_subarray([4, 3, 2, 1], 5) -1 from solution import max_sum_subarray def test_max_sum_subarray_example_1(): assert max_sum_subarray([1, 2, 3, 4, 5], 2) == 9 def test_max_sum_subarray_example_2(): assert max_sum_subarray([1, -1, 5, 2, 3], 3) == 10 def test_max_sum_subarray_example_3(): assert max_sum_subarray([4, 3, 2, 1], 5) == -1 def test_max_sum_subarray_empty_array(): assert max_sum_subarray([], 2) == -1 def test_max_sum_subarray_single_element(): assert max_sum_subarray([5], 1) == 5 def test_max_sum_subarray_same_elements(): assert max_sum_subarray([1, 1, 1, 1, 1], 2) == 2 def test_max_sum_subarray_large_k(): assert max_sum_subarray([1, 2, 3, 4, 5], 5) == 15 def test_max_sum_subarray_k_greater_than_len(): assert max_sum_subarray([1, 2, 3], 4) == -1","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of any contiguous subarray of size k. Parameters: arr (list of int): The list of integers. k (int): The size of the subarray. Returns: int: The maximum sum of any contiguous subarray of size k. Returns -1 if the list has fewer than k elements. n = len(arr) if n < k: return -1 # Compute the sum of the first subarray of size k window_sum = sum(arr[:k]) max_sum = window_sum # Slide the window over the rest of the array for i in range(n - k): window_sum = window_sum - arr[i] + arr[i + k] max_sum = max(max_sum, window_sum) return max_sum"},{"question":"def count_tallest_candles(n: int, heights: [int]) -> int: Returns the number of candles that have the tallest height. :param n: int, the number of candles :param heights: list of int, the heights of the candles :return: int, the number of tallest candles >>> count_tallest_candles(4, [3, 2, 1, 3]) 2","solution":"def count_tallest_candles(n, heights): Returns the number of candles that have the tallest height. :param n: int, the number of candles :param heights: list of int, the heights of the candles :return: int, the number of tallest candles tallest_height = max(heights) return heights.count(tallest_height)"},{"question":"def roman_to_int(s: str) -> int: Convert a Roman numeral to an integer. :param s: str - Roman numeral string. :return: int - Corresponding integer. >>> roman_to_int(\\"III\\") 3 >>> roman_to_int(\\"IV\\") 4 >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"LVIII\\") 58 >>> roman_to_int(\\"MCMXCIV\\") 1994 from solution import roman_to_int def test_roman_to_int(): # Example test cases assert roman_to_int(\\"III\\") == 3 assert roman_to_int(\\"IV\\") == 4 assert roman_to_int(\\"IX\\") == 9 assert roman_to_int(\\"LVIII\\") == 58 assert roman_to_int(\\"MCMXCIV\\") == 1994 def test_additional_cases(): assert roman_to_int(\\"XX\\") == 20 assert roman_to_int(\\"CCLIX\\") == 259 assert roman_to_int(\\"MMMCMXCIX\\") == 3999 assert roman_to_int(\\"DCCCXC\\") == 890 assert roman_to_int(\\"CM\\") == 900 def test_edge_cases(): assert roman_to_int(\\"I\\") == 1 assert roman_to_int(\\"MMM\\") == 3000","solution":"def roman_to_int(s): Convert a Roman numeral to an integer. :param s: str - Roman numeral string. :return: int - Corresponding integer. roman_to_integer = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_to_integer[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"def traffic_light_cycle(green_duration: int, yellow_duration: int, red_duration: int): Returns the traffic light cycle as a list of tuples representing the color and the duration for which the light stays in that color. Arguments: green_duration -- duration of the Green light in seconds yellow_duration -- duration of the Yellow light in seconds red_duration -- duration of the Red light in seconds Returns: A list of tuples representing the traffic light cycle. >>> traffic_light_cycle(10, 3, 7) [('Green', 10), ('Yellow', 3), ('Red', 7)] >>> traffic_light_cycle(0, 0, 0) [('Green', 0), ('Yellow', 0), ('Red', 0)] >>> traffic_light_cycle(120, 45, 150) [('Green', 120), ('Yellow', 45), ('Red', 150)] >>> traffic_light_cycle(5, 15, 10) [('Green', 5), ('Yellow', 15), ('Red', 10)]","solution":"def traffic_light_cycle(green_duration, yellow_duration, red_duration): Returns the traffic light cycle as a list of tuples representing the color and the duration for which the light stays in that color. Arguments: green_duration -- duration of the Green light in seconds yellow_duration -- duration of the Yellow light in seconds red_duration -- duration of the Red light in seconds Returns: A list of tuples representing the traffic light cycle. return [('Green', green_duration), ('Yellow', yellow_duration), ('Red', red_duration)]"},{"question":"def min_rolls_to_all_faces(dice_results: List[int]) -> int: Returns the minimum number of rolls required to get all the numbers from 1 to 6 at least once. If it is not possible to get all numbers with the given list, returns -1. Example: >>> min_rolls_to_all_faces([1, 2, 3, 4, 4, 6, 5, 3, 2]) 7 >>> min_rolls_to_all_faces([1, 2, 2, 4, 5]) -1","solution":"def min_rolls_to_all_faces(dice_results): Returns the minimum number of rolls required to get all the numbers from 1 to 6 at least once. If it is not possible to get all numbers with the given list, returns -1. required_faces = set(range(1, 7)) seen_faces = set() for index, roll in enumerate(dice_results): seen_faces.add(roll) if seen_faces == required_faces: return index + 1 # Return the number of rolls (1-based index count) return -1 # Not all faces were seen in the dice results"},{"question":"def unique_paths_in_grid(N: int, grid: List[List[int]]) -> int: Given a grid of size N x N with certain blocked cells, find the number of unique paths the robot can take to reach (N, N) from (1, 1) without passing through any blocked cells. >>> unique_paths_in_grid(3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_in_grid(2, [[0, 1], [1, 0]]) 0 import pytest def test_sample_case_1(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths_in_grid(3, grid) == 2 def test_sample_case_2(): grid = [ [0, 1], [1, 0] ] assert unique_paths_in_grid(2, grid) == 0 def test_full_obstructions(): grid = [ [0, 1, 1], [1, 1, 1], [1, 1, 0] ] assert unique_paths_in_grid(3, grid) == 0 def test_single_cell(): grid = [ [0] ] assert unique_paths_in_grid(1, grid) == 1 def test_all_open_cells(): grid = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] assert unique_paths_in_grid(4, grid) == 20","solution":"def unique_paths_in_grid(N, grid): if grid[0][0] == 1 or grid[N-1][N-1] == 1: return 0 dp = [[0] * N for _ in range(N)] dp[0][0] = 1 # Starting point for i in range(N): for j in range(N): if grid[i][j] == 1: dp[i][j] = 0 continue if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][N-1]"},{"question":"def int_to_roman(num: int) -> str: Converts a non-negative integer to a Roman numeral string. :param num: int: A non-negative integer :return: str: Roman numeral representation of the number. >>> int_to_roman(1) \\"I\\" >>> int_to_roman(4) \\"IV\\" >>> int_to_roman(9) \\"IX\\" >>> int_to_roman(58) \\"LVIII\\" >>> int_to_roman(1994) \\"MCMXCIV\\" >>> int_to_roman(2023) \\"MMXXIII\\" >>> int_to_roman(3999) \\"MMMCMXCIX\\" >>> int_to_roman(1987) \\"MCMLXXXVII\\"","solution":"def int_to_roman(num): Converts a non-negative integer to a Roman numeral string. :param num: int: A non-negative integer :return: str: Roman numeral representation of the number. if not (1 <= num <= 3999): raise ValueError(\\"Number out of range (must be 1-3999)\\") val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syms[i] num -= val[i] i += 1 return roman_num"},{"question":"def can_win_game(a: int, b: int) -> str: Determines if the starting player can guarantee a win in the game by playing optimally. >>> can_win_game(3, 5) 'Yes' >>> can_win_game(2, 2) 'Yes' >>> can_win_game(4, 7) 'No'","solution":"def can_win_game(a, b): Determines if the starting player can guarantee a win in the game by playing optimally. Parameters: a (int): Number of stones in pile A. b (int): Number of stones in pile B. Returns: str: \\"Yes\\" if the starting player can guarantee a win, otherwise \\"No\\". if abs(a - b) > 2 or (a == 0 and b > 1) or (b == 0 and a > 1): return \\"No\\" return \\"Yes\\" # Examples use cases print(can_win_game(3, 5)) # Output: Yes print(can_win_game(2, 2)) # Output: Yes print(can_win_game(4, 7)) # Output: No"},{"question":"def min_operations_to_unify_string(string): Calculate the minimum number of operations required to make all characters of the string the same. Parameters: string (str): The string of lowercase English letters. Returns: int: The minimum number of operations required. >>> min_operations_to_unify_string(\\"aabcc\\") 2 >>> min_operations_to_unify_string(\\"zzzzzz\\") 0 # Implement the function here def process_test_cases(T, test_cases): Process multiple test cases and calculate the result for each one. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, str]]): A list of tuples, where each tuple contains an integer N and a string of length N. Returns: List[int]: A list of integers representing the minimum number of operations required for each test case. >>> process_test_cases(2, [(5, \\"aabcc\\"), (6, \\"zzzzzz\\")]) [2, 0] >>> process_test_cases(3, [(3, \\"abc\\"), (1, \\"a\\"), (2, \\"ab\\")]) [2, 0, 1] # Implement the function here","solution":"def min_operations_to_unify_string(string): # Initialize the maximum character found in the string to the smallest possible char. max_char = 'a' # Find the lexicographically largest character in the string for char in string: if char > max_char: max_char = char # The number of operations is the number of unique characters from # the largest character found down to 'a'. unique_chars = set(string) return len(unique_chars) - 1 def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] string = test_cases[i][1] results.append(min_operations_to_unify_string(string)) return results"},{"question":"from typing import List, Tuple def process_queries(queries: List[Tuple[int, str, str, int]]) -> List[str]: Processes multiple queries to find the average grade for a particular student across all subjects they are enrolled in. >>> queries = [ ... (1, 'Alice', 'Physics', 85), ... (1, 'Alice', 'Math', 90), ... (1, 'Bob', 'Physics', 80), ... (2, 'Alice'), ... (2, 'Bob'), ... (2, 'Charlie') ... ] >>> process_queries(queries) [\\"87.50\\", \\"80.00\\", \\"No grades recorded\\"] >>> queries = [ ... (2, 'Alice'), ... (2, 'Bob') ... ] >>> process_queries(queries) [\\"No grades recorded\\", \\"No grades recorded\\"] >>> queries = [ ... (1, 'Alice', 'Physics', 85), ... (1, 'Alice', 'Math', 90), ... (1, 'Alice', 'Chemistry', 80), ... (2, 'Alice') ... ] >>> process_queries(queries) [\\"85.00\\"] >>> queries = [ ... (1, 'Alice', 'Physics', 85), ... (1, 'Bob', 'Math', 90), ... (2, 'Alice'), ... (2, 'Bob') ... ] >>> process_queries(queries) [\\"85.00\\", \\"90.00\\"] >>> queries = [ ... (1, 'Alice', 'Math', 90), ... (1, 'Alice', 'Math', 95), ... (2, 'Alice') ... ] >>> process_queries(queries) [\\"95.00\\"] pass","solution":"def process_queries(queries): students_grades = {} def add_grade(ID, subject, grade): if ID not in students_grades: students_grades[ID] = {} students_grades[ID][subject] = grade def get_average(ID): if ID not in students_grades or not students_grades[ID]: return \\"No grades recorded\\" grades = students_grades[ID].values() average = sum(grades) / len(grades) return f\\"{average:.2f}\\" results = [] for query in queries: if query[0] == 1: add_grade(query[1], query[2], query[3]) elif query[0] == 2: results.append(get_average(query[1])) return results"},{"question":"def longestWordLength(sentence: str) -> int: Given a string of words separated by spaces, return the length of the longest word. If the string is empty, return 0. Examples: >>> longestWordLength(\\"The quick brown fox jumps over the lazy dog\\") 5 >>> longestWordLength(\\"\\") 0 from typing import List import unittest class TestLongestWordLength(unittest.TestCase): def test_longest_word_length_example(self): self.assertEqual(longestWordLength(\\"The quick brown fox jumps over the lazy dog\\"), 5) def test_longest_word_length_with_empty_string(self): self.assertEqual(longestWordLength(\\"\\"), 0) def test_longest_word_length_single_word(self): self.assertEqual(longestWordLength(\\"hello\\"), 5) def test_longest_word_length_multiple_words_of_same_length(self): self.assertEqual(longestWordLength(\\"hi me do to\\"), 2) def test_longest_word_length_with_various_lengths(self): self.assertEqual(longestWordLength(\\"a ab abc abcd abcde\\"), 5) def test_longest_word_length_with_spaces(self): self.assertEqual(longestWordLength(\\" \\"), 0) def test_longest_word_length_with_punctuation(self): self.assertEqual(longestWordLength(\\"hello, world!\\"), 6) def test_longest_word_length_all_same_length(self): self.assertEqual(longestWordLength(\\"one two six ten\\"), 3) if __name__ == \\"__main__\\": unittest.main()","solution":"def longestWordLength(sentence): Given a string of words separated by spaces, return the length of the longest word. If the string is empty, return 0. if not sentence: return 0 words = sentence.split() max_length = max((len(word) for word in words), default=0) return max_length"},{"question":"def encode(string: str) -> str: Encodes the given string using a simplified version of the Run-Length Encoding (RLE) algorithm. >>> encode(\\"aaaabbbcc\\") \\"a4b3c2\\" >>> encode(\\"abc\\") \\"abc\\" >>> encode(\\"aabbcccc\\") \\"a2b2c4\\" >>> encode(\\"a\\") \\"a\\" >>> encode(\\"\\") \\"\\" >>> encode(\\"aaaaaa\\") \\"a6\\" >>> encode(\\"abcd\\") \\"abcd\\" >>> encode(\\"aabcccde\\") \\"a2bc3de\\" def decode(string: str) -> str: Decodes the given encoded string back to its original form using the rules of the simplified RLE algorithm. >>> decode(\\"a4b3c2\\") \\"aaaabbbcc\\" >>> decode(\\"abc\\") \\"abc\\" >>> decode(\\"a2b2c4\\") \\"aabbcccc\\" >>> decode(\\"a\\") \\"a\\" >>> decode(\\"\\") \\"\\" >>> decode(\\"a6\\") \\"aaaaaa\\" >>> decode(\\"abcd\\") \\"abcd\\" >>> decode(\\"a2bc3de\\") \\"aabcccde\\"","solution":"def encode(string): Encodes the given string using a simplified version of the Run-Length Encoding (RLE) algorithm. if not string: return \\"\\" encoded = [] count = 1 for i in range(1, len(string)): if string[i] == string[i - 1]: count += 1 else: if count > 1: encoded.append(f\\"{string[i - 1]}{count}\\") else: encoded.append(string[i - 1]) count = 1 # Add the last character/count if count > 1: encoded.append(f\\"{string[-1]}{count}\\") else: encoded.append(string[-1]) return \\"\\".join(encoded) def decode(string): Decodes the given encoded string back to its original form using the rules of the simplified RLE algorithm. decoded = [] i = 0 while i < len(string): char = string[i] if i + 1 < len(string) and string[i + 1].isdigit(): count = int(string[i + 1]) decoded.append(char * count) i += 2 else: decoded.append(char) i += 1 return \\"\\".join(decoded)"},{"question":"def min_operations_to_equal_elements(n: int, array: List[int]) -> int: Given an array of integers, find the minimum number of operations required to make all the elements of the array equal. In one operation, you can increment or decrement any element of the array by 1. Parameters: n (int): the number of elements in the array. array (List[int]): List of integers representing the elements of the array. Returns: int: the minimum number of operations required to make all elements equal. >>> min_operations_to_equal_elements(4, [1, 2, 3, 4]) 4 >>> min_operations_to_equal_elements(3, [5, 5, 5]) 0","solution":"def min_operations_to_equal_elements(n, array): Returns the minimum number of operations required to make all the elements in the array equal. # Sort the array to find the median. array.sort() # Find the median. median = array[n // 2] # Calculate the total number of operations needed. operations = sum(abs(x - median) for x in array) return operations"},{"question":"def max_speed(T: int, R: int, speed_boosts: List[Tuple[int, int, int]]) -> int: Determines the maximum speed achieved during the race. Args: T (int): Number of test cases. R (int): Duration of the race in seconds. speed_boosts (list of tuples): Each tuple contains (S_i, E_i, V_i) where S_i (int): Start time of the speed boost E_i (int): End time of the speed boost V_i (int): Speed increment for the given boost Returns: int: Maximum speed achieved during the race. >>> max_speed(4, 20, [(0, 5, 10), (4, 10, 15), (11, 15, 20), (10, 20, 5)]) 20 >>> max_speed(2, 10, [(0, 5, 10), (6, 10, 15)]) 15","solution":"def max_speed(T, R, speed_boosts): Determines the maximum speed achieved during the race. Args: T (int): Number of test cases. R (int): Duration of the race in seconds. speed_boosts (list of tuples): Each tuple contains (S_i, E_i, V_i) where S_i (int): Start time of the speed boost E_i (int): End time of the speed boost V_i (int): Speed increment for the given boost Returns: int: Maximum speed achieved during the race. max_speeds = [0] * (R + 1) for S_i, E_i, V_i in speed_boosts: for time in range(S_i, E_i + 1): max_speeds[time] = max(max_speeds[time], V_i) return max(max_speeds)"},{"question":"def decode_morse(encoded_message: str, morse_code_dict: dict) -> str: Decodes a Morse code encoded message if using the provided Morse code dictionary. Parameters: - encoded_message: str, Morse code message with each character separated by a single space and each word separated by three spaces. - morse_code_dict: dict, dictionary mapping Morse codes to their corresponding characters. Returns: - str, the decoded alphanumeric message. Example usage: >>> morse_code_dict = {\\".-\\": \\"A\\", \\"-...\\": \\"B\\", \\"-.-.\\": \\"C\\", \\"-..\\": \\"D\\", \\".\\": \\"E\\", \\"..-.\\": \\"F\\", \\"--.\\": \\"G\\", \\"....\\": \\"H\\", \\"..\\": \\"I\\", \\".---\\": \\"J\\", \\"-.-\\": \\"K\\", \\".-..\\": \\"L\\", \\"--\\": \\"M\\", \\"-.\\": \\"N\\", \\"---\\": \\"O\\", \\".--.\\": \\"P\\", \\"--.-\\": \\"Q\\", \\".-.\\": \\"R\\", \\"...\\": \\"S\\", \\"-\\": \\"T\\", \\"..-\\": \\"U\\", \\"...-\\": \\"V\\", \\".--\\": \\"W\\", \\"-..-\\": \\"X\\", \\"-.--\\": \\"Y\\", \\"--..\\": \\"Z\\", \\"-----\\": \\"0\\", \\".----\\": \\"1\\", \\"..---\\": \\"2\\", \\"...--\\": \\"3\\", \\"....-\\": \\"4\\", \\".....\\": \\"5\\", \\"-....\\": \\"6\\", \\"--...\\": \\"7\\", \\"---..\\": \\"8\\", \\"----.\\": \\"9\\"} >>> decode_morse(\\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\", morse_code_dict) 'HELLO WORLD' >>> decode_morse(\\"... --- ...\\", morse_code_dict) 'SOS'","solution":"def decode_morse(encoded_message, morse_code_dict): Decodes a Morse code encoded message if using the provided Morse code dictionary. Parameters: - encoded_message: str, Morse code message with each character separated by a single space and each word separated by three spaces. - morse_code_dict: dict, dictionary mapping Morse codes to their corresponding characters. Returns: - str, the decoded alphanumeric message. words = encoded_message.split(\\" \\") decoded_message = [] for word in words: decoded_word = ''.join([morse_code_dict[char] for char in word.split()]) decoded_message.append(decoded_word) return ' '.join(decoded_message)"},{"question":"def find_smallest_missing_positive(nums): Returns the smallest positive integer that does not appear in the array. >>> find_smallest_missing_positive([3, 4, -1, 1]) 2 >>> find_smallest_missing_positive([1, 2, 0]) 3 >>> find_smallest_missing_positive([-5, -3, -2, -1, 2, 3]) 1 # Your code here # Example Test Cases print(find_smallest_missing_positive([3, 4, -1, 1])) # Output: 2 print(find_smallest_missing_positive([1, 2, 0])) # Output: 3 print(find_smallest_missing_positive([-5, -3, -2, -1, 2, 3])) # Output: 1","solution":"def find_smallest_missing_positive(nums): Returns the smallest positive integer that does not appear in the array. nums_set = set(nums) smallest_missing = 1 while smallest_missing in nums_set: smallest_missing += 1 return smallest_missing"},{"question":"def flatten_dictionary(d): Create a function flatten_dictionary that takes a nested dictionary and returns a new dictionary with no nested structures, using \\"dot notation\\" to represent the hierarchy of the original dictionary keys. >>> flatten_dictionary({\\"key1\\": \\"1\\", \\"key2\\": {\\"a\\": \\"2\\"}}) {'key1': '1', 'key2.a': '2'} >>> flatten_dictionary({\\"key1\\": {\\"subkey1\\": \\"1\\"}}) {'key1.subkey1': '1'} # Implementation goes here","solution":"def flatten_dictionary(d, parent_key='', sep='.'): This function flattens a nested dictionary. items = [] for k, v in d.items(): new_key = f'{parent_key}{sep}{k}' if parent_key else k if isinstance(v, dict): items.extend(flatten_dictionary(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def grid_unique_paths(rows: int, cols: int) -> int: Calculate the number of unique paths from the top-left corner to the bottom-right corner of a grid. Args: rows (int): The number of rows in the grid. cols (int): The number of columns in the grid. Returns: int: The number of unique paths. Examples: >>> grid_unique_paths(2, 3) 3 >>> grid_unique_paths(3, 3) 6 from solution import grid_unique_paths def test_grid_unique_paths_2_3(): assert grid_unique_paths(2, 3) == 3 def test_grid_unique_paths_3_3(): assert grid_unique_paths(3, 3) == 6 def test_grid_unique_paths_1_1(): assert grid_unique_paths(1, 1) == 1 def test_grid_unique_paths_3_2(): assert grid_unique_paths(3, 2) == 3 def test_grid_unique_paths_4_4(): assert grid_unique_paths(4, 4) == 20","solution":"def grid_unique_paths(rows, cols): Calculate the number of unique paths from the top-left corner to the bottom-right corner of a grid. Args: rows (int): The number of rows in the grid. cols (int): The number of columns in the grid. Returns: (int): The number of unique paths. # Initialize a 2D array with all elements as 1 dp = [[1] * cols for _ in range(rows)] # Populate the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will have the result return dp[rows-1][cols-1]"},{"question":"from typing import List def find_frequent_elements(nums: List[int], k: int) -> List[int]: Write a function find_frequent_elements(nums, k) that accepts a list of integers nums and an integer k, and returns a list of the k most frequent elements in nums. The returned list should be sorted by the frequency of elements in descending order. If two elements have the same frequency, the element with the smaller value should come first. Examples: >>> find_frequent_elements([1,1,1,2,2,3], 2) [1, 2] >>> find_frequent_elements([4,4,1,2,2,3,3,3], 1) [3] >>> find_frequent_elements([1], 1) [1] >>> find_frequent_elements([1,2,2,3,3,3,4,4,4,4], 2) [4, 3] Constraints: - The function should run in O(n log n) time or better. - The input list nums will have at most 10^4 elements. - The integer k is guaranteed to be between 1 and the number of unique elements in nums. def test_find_frequent_elements_example_cases(): assert find_frequent_elements([1,1,1,2,2,3], 2) == [1, 2] assert find_frequent_elements([4,4,1,2,2,3,3,3], 1) == [3] assert find_frequent_elements([1], 1) == [1] assert find_frequent_elements([1,2,2,3,3,3,4,4,4,4], 2) == [4, 3] def test_find_frequent_elements_single_most_frequent(): assert find_frequent_elements([4,4,4,4,1,1,2,2], 1) == [4] def test_find_frequent_elements_multiple_with_same_frequency(): assert find_frequent_elements([5,3,3,2,2,1,1,1,1,5,5,5], 3) == [1, 5, 2] def test_find_frequent_elements_same_frequency_and_value(): assert find_frequent_elements([2,3,1,2,3,2], 3) == [2, 3, 1] def test_find_frequent_elements_partial_selection(): assert find_frequent_elements([1,2,3,4,2,1,2,3,4,4,4,4], 2) == [4, 2]","solution":"from collections import Counter def find_frequent_elements(nums, k): Returns a list of the k most frequent elements in nums, sorted by frequency in descending order. If two elements have the same frequency, the smaller element comes first. count = Counter(nums) # Create a sorted list of elements based on frequency (descending) and then by value (ascending) sorted_elements = sorted(count.items(), key=lambda x: (-x[1], x[0])) # Extract the top k elements result = [element for element, frequency in sorted_elements[:k]] return result"},{"question":"def rotate_matrix(matrix): Rotates the input square matrix 90 degrees clockwise. :param matrix: List[List[int]] - The input n x n matrix to be rotated. :return: List[List[int]] - The new matrix that has been rotated 90 degrees clockwise. >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]]","solution":"def rotate_matrix(matrix): Rotates the input square matrix 90 degrees clockwise. :param matrix: List[List[int]] - The input n x n matrix to be rotated. :return: List[List[int]] - The new matrix that has been rotated 90 degrees clockwise. n = len(matrix) # Create a new matrix to store the rotated version rotated = [[0] * n for _ in range(n)] # Perform the rotation for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"from typing import List, Optional def second_highest_unique(arr: List[int]) -> Optional[int]: Develop a function that identifies the second highest unique integer in a list of integers. Returns the second highest unique integer if present, otherwise returns None. >>> second_highest_unique([2, 3, 3, 5, 5, 4, 4]) 4 >>> second_highest_unique([10, 20, 30, 30, 40, 50, 50]) 40 >>> second_highest_unique([1, 1, 1, 1, 1]) None >>> second_highest_unique([1]) None pass","solution":"def second_highest_unique(arr): Returns the second highest unique integer in a list of integers. If there is no second highest unique integer, returns None. unique_numbers = list(set(arr)) if len(unique_numbers) < 2: return None unique_numbers.sort(reverse=True) return unique_numbers[1]"},{"question":"def is_well_formed_bracket_sequence(S: str) -> str: Determines if the string S is a well-formed bracket sequence. Args: S (str): A string consisting of bracket characters. Returns: str: \\"YES\\" if S is a well-formed bracket sequence, \\"NO\\" otherwise. >>> is_well_formed_bracket_sequence(\\"()[]{}\\") \\"YES\\" >>> is_well_formed_bracket_sequence(\\"([)]\\") \\"NO\\" >>> is_well_formed_bracket_sequence(\\"{[()]}\\") \\"YES\\"","solution":"def is_well_formed_bracket_sequence(S): Determines if the string S is a well-formed bracket sequence. Args: S (str): A string consisting of bracket characters. Returns: str: \\"YES\\" if S is a well-formed bracket sequence, \\"NO\\" otherwise. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in S: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return \\"NO\\" else: return \\"NO\\" if stack == []: return \\"YES\\" else: return \\"NO\\""},{"question":"def flatten(nested_list): Flattens a nested list into a single list. Parameters: nested_list (list): A list that can contain more lists or integers. Returns: list: A flattened version of the nested list. >>> flatten([1, [2, 3, [4]], 5]) [1, 2, 3, 4, 5] >>> flatten([[1, 2, [3, 4]], [5], 6]) [1, 2, 3, 4, 5, 6]","solution":"def flatten(nested_list): Flattens a nested list into a single list. Parameters: nested_list (list): A list that can contain more lists or integers. Returns: list: A flattened version of the nested list. result = [] for element in nested_list: if isinstance(element, list): result.extend(flatten(element)) else: result.append(element) return result"},{"question":"def minReplacements(n: int) -> int: Given an integer \`n\`, determine the minimum number of replacements needed for \`n\` to become \`1\`. You can perform the following operations on \`n\`: 1. If \`n\` is even, replace \`n\` with \`n / 2\`. 2. If \`n\` is odd, you can either replace \`n\` with \`n + 1\` or \`n - 1\`. >>> minReplacements(8) 3 >>> minReplacements(7) 4 >>> minReplacements(1) 0 >>> minReplacements(15) 5 >>> minReplacements(1024) 10","solution":"def minReplacements(n, memo=None): Returns the minimum number of replacements needed for n to become 1. if memo is None: memo = {} if n == 1: return 0 if n in memo: return memo[n] if n % 2 == 0: memo[n] = 1 + minReplacements(n // 2, memo) else: memo[n] = 1 + min(minReplacements(n + 1, memo), minReplacements(n - 1, memo)) return memo[n]"},{"question":"from typing import List, Tuple import itertools def find_combinations(numbers: List[int], k: int) -> List[Tuple[int, ...]]: Finds all possible combinations of the given list of integers of length k in lexicographical order. Args: numbers : list : list of integers k : int : length of each combination Returns: list of tuples : each tuple is a combination of k integers in lexicographical order >>> find_combinations([1, 2, 3, 4, 5], 3) [(1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5)] >>> find_combinations([1], 1) [(1,)] >>> find_combinations([1, 2, 3], 4) [] >>> find_combinations([], 2) [] >>> find_combinations([1, 2, 3], 0) [()] >>> find_combinations([3, 1, 2], 2) [(1, 2), (1, 3), (2, 3)]","solution":"import itertools def find_combinations(numbers, k): Finds all possible combinations of the given list of integers of length k in lexicographical order. Args: numbers : list : list of integers k : int : length of each combination Returns: list of tuples : each tuple is a combination of k integers in lexicographical order numbers.sort() combinations = itertools.combinations(numbers, k) return list(combinations)"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list of int): The first sorted array. arr2 (list of int): The second sorted array. Returns: list of int: A single sorted array containing all elements from arr1 and arr2. Examples: >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([0, 10, 20], [5, 15, 25]) [0, 5, 10, 15, 20, 25] >>> merge_sorted_arrays([-1, 0, 1], [-2, 2, 3]) [-2, -1, 0, 1, 2, 3] >>> merge_sorted_arrays([1, 2, 2, 3], [2, 3, 4]) [1, 2, 2, 2, 3, 3, 4]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list of int): The first sorted array. arr2 (list of int): The second sorted array. Returns: list of int: A single sorted array containing all elements from arr1 and arr2. merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 # If there are elements left in arr1 while i < len(arr1): merged.append(arr1[i]) i += 1 # If there are elements left in arr2 while j < len(arr2): merged.append(arr2[j]) j += 1 return merged"},{"question":"def can_rearrange_to_balanced(s: str) -> bool: Determines if the string can be rearranged to form a balanced string. Parameters: s (str): The input string. Returns: bool: True if the string can be rearranged to form a balanced string, False otherwise. Example: >>> can_rearrange_to_balanced(\\"aabbcc\\") True >>> can_rearrange_to_balanced(\\"aaabb\\") False >>> can_rearrange_to_balanced(\\"aabbccc\\") False >>> can_rearrange_to_balanced(\\"a\\") True >>> can_rearrange_to_balanced(\\"abcd\\") True","solution":"def can_rearrange_to_balanced(s): Determines if the string can be rearranged to form a balanced string. Parameters: s (str): The input string. Returns: bool: True if the string can be rearranged to form a balanced string, False otherwise. from collections import Counter char_counts = Counter(s) unique_counts = set(char_counts.values()) return len(unique_counts) == 1 if len(s) > 1 else True"},{"question":"from typing import List, Dict def reorder_posts(posts: List[Dict[str, int]]) -> List[int]: Return a list of post IDs sorted by interaction score in descending order. If two posts have the same interaction score, sort them by timestamp in ascending order. :param posts: List of dictionaries containing 'id', 'score', 'timestamp' :return: List of post IDs sorted according to the described criteria >>> reorder_posts([ ... {'id': 1, 'score': 50, 'timestamp': 1609459200}, ... {'id': 2, 'score': 30, 'timestamp': 1609459100}, ... {'id': 3, 'score': 50, 'timestamp': 1609459300} ... ]) == [1, 3, 2] >>> reorder_posts([ ... {'id': 1, 'score': 70, 'timestamp': 1609459200}, ... {'id': 2, 'score': 80, 'timestamp': 1609459100}, ... {'id': 3, 'score': 60, 'timestamp': 1609459300}, ... {'id': 4, 'score': 80, 'timestamp': 1609459500} ... ]) == [2, 4, 1, 3]","solution":"def reorder_posts(posts): Return a list of post IDs sorted by interaction score in descending order. If two posts have the same interaction score, sort them by timestamp in ascending order. :param posts: List of dictionaries containing 'id', 'score', 'timestamp' :return: List of post IDs sorted according to the described criteria sorted_posts = sorted(posts, key=lambda x: (-x['score'], x['timestamp'])) return [post['id'] for post in sorted_posts]"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the characters of the string 's' can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aab\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"ab\\") False pass def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes multiple test cases to determine if palindromes can be formed. >>> process_test_cases(3, [\\"civic\\", \\"ivicc\\", \\"hello\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases(2, [\\"aab\\", \\"racecar\\"]) [\\"YES\\", \\"YES\\"] >>> process_test_cases(1, [\\"a\\"]) [\\"YES\\"] >>> process_test_cases(1, [\\"ab\\"]) [\\"NO\\"] pass","solution":"def can_form_palindrome(s): Determines if the characters of the string 's' can be rearranged to form a palindrome. from collections import Counter freq = Counter(s) odd_count = sum(1 for count in freq.values() if count % 2 != 0) return odd_count <= 1 def process_test_cases(T, test_cases): Processes multiple test cases to determine if palindromes can be formed. results = [] for s in test_cases: if can_form_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from datetime import datetime, timedelta def validate_work_schedule(login_time, logout_time): Validates that an employee has worked at least 8 hours. :param login_time: str, the login time in \\"HH:MM\\" 24-hour format :param logout_time: str, the logout time in \\"HH:MM\\" 24-hour format :return: bool, whether the employee has worked at least 8 hours pass def test_validate_work_schedule_exact_8_hours(): assert validate_work_schedule(\\"09:00\\", \\"17:00\\") == True assert validate_work_schedule(\\"22:00\\", \\"06:00\\") == True def test_validate_work_schedule_less_than_8_hours(): assert validate_work_schedule(\\"09:00\\", \\"16:00\\") == False assert validate_work_schedule(\\"23:00\\", \\"06:00\\") == False def test_validate_work_schedule_more_than_8_hours(): assert validate_work_schedule(\\"08:00\\", \\"17:00\\") == True assert validate_work_schedule(\\"21:00\\", \\"06:00\\") == True assert validate_work_schedule(\\"22:00\\", \\"07:00\\") == True def test_validate_work_schedule_logout_next_day(): assert validate_work_schedule(\\"23:00\\", \\"07:00\\") == True assert validate_work_schedule(\\"15:00\\", \\"23:00\\") == True assert validate_work_schedule(\\"01:00\\", \\"09:00\\") == True assert validate_work_schedule(\\"01:00\\", \\"08:00\\") == False assert validate_work_schedule(\\"00:00\\", \\"07:59\\") == False","solution":"from datetime import datetime, timedelta def validate_work_schedule(login_time, logout_time): Validates that an employee has worked at least 8 hours. :param login_time: str, the login time in \\"HH:MM\\" 24-hour format :param logout_time: str, the logout time in \\"HH:MM\\" 24-hour format :return: bool, whether the employee has worked at least 8 hours fmt = '%H:%M' login_dt = datetime.strptime(login_time, fmt) logout_dt = datetime.strptime(logout_time, fmt) # Handle case where logout time is on the next day if logout_dt <= login_dt: logout_dt += timedelta(days=1) worked_hours = (logout_dt - login_dt).seconds / 3600 return worked_hours >= 8"},{"question":"from typing import List, Tuple def can_attend_all_meetings(intervals: List[Tuple[int, int]]) -> bool: Determine if a person can attend all given meetings without overlapping. Args: intervals (List[Tuple[int, int]]): List of tuples with start and end times of meetings. Returns: bool: True if no meetings overlap, False otherwise. >>> can_attend_all_meetings([]) True >>> can_attend_all_meetings([(1, 2)]) True >>> can_attend_all_meetings([(0, 30), (5, 10), (15, 20)]) False >>> can_attend_all_meetings([(7, 10), (2, 4), (12, 15)]) True >>> can_attend_all_meetings([(1, 5), (5, 10)]) True >>> can_attend_all_meetings([(1, 5), (4, 10)]) False >>> can_attend_all_meetings([(2, 4), (2, 4)]) False","solution":"from typing import List, Tuple def can_attend_all_meetings(intervals: List[Tuple[int, int]]) -> bool: Determine if a person can attend all given meetings without overlapping. Args: intervals (List[Tuple[int, int]]): List of tuples with start and end times of meetings. Returns: bool: True if no meetings overlap, False otherwise. # Sort the intervals by start time intervals.sort(key=lambda x: x[0]) for i in range(1, len(intervals)): # If the current meeting starts before the previous one ends, there is an overlap if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"def max_frequency_char(S: str) -> str: Returns the character with the highest frequency and its count in the string S. If multiple characters have the same highest frequency, the lexicographically smallest one is returned. >>> max_frequency_char(\\"ABBCC\\") \\"B 2\\" >>> max_frequency_char(\\"AABBBCC\\") \\"B 3\\" from collections import Counter # Your code here from solution import max_frequency_char def test_max_frequency_char_single_character(): assert max_frequency_char(\\"A\\") == \\"A 1\\" def test_max_frequency_char_multiple_max_chars(): assert max_frequency_char(\\"ABBCC\\") == \\"B 2\\" assert max_frequency_char(\\"AABBBCC\\") == \\"B 3\\" def test_max_frequency_char_all_unique(): assert max_frequency_char(\\"ABCDEFG\\") == \\"A 1\\" def test_max_frequency_char_tie_breaker(): assert max_frequency_char(\\"XYYZZZZ\\") == \\"Z 4\\" def test_max_frequency_char_large_string(): assert max_frequency_char(\\"A\\" * 500 + \\"B\\" * 499) == \\"A 500\\"","solution":"def max_frequency_char(S): Returns the character with the highest frequency and its count in the string S. If multiple characters have the same highest frequency, the lexicographically smallest one is returned. from collections import Counter # Counting frequency of each character in the string frequency = Counter(S) # Sorting characters first by frequency (descending), then lexicographically (ascending) most_common = sorted(frequency.items(), key=lambda item: (-item[1], item[0])) # The first item in the sorted list is the required character along with its frequency character, freq = most_common[0] return f\\"{character} {freq}\\""},{"question":"def is_permutation(s: str, t: str) -> bool: Checks if one string is a permutation of another string. >>> is_permutation(\\"abc\\", \\"bca\\") True >>> is_permutation(\\"abc\\", \\"abcd\\") False >>> is_permutation(\\"hello\\", \\"ollhe\\") True >>> is_permutation(\\"test\\", \\"ttew\\") False","solution":"def is_permutation(s: str, t: str) -> bool: Checks if string t is a permutation of string s. if len(s) != len(t): return False from collections import Counter return Counter(s) == Counter(t)"},{"question":"import numpy as np def compute_statistics(nums): Computes the mean, median, and standard deviation of a list of numbers. Parameters: nums (list): A list of integers. Returns: tuple: A tuple containing the mean, median, and standard deviation, each rounded to 2 decimal places. def test_compute_statistics_simple(): assert compute_statistics([1, 2, 3, 4]) == (2.5, 2.5, 1.12) def test_compute_statistics_single_element(): assert compute_statistics([5]) == (5.0, 5.0, 0.0) def test_compute_statistics_identical_elements(): assert compute_statistics([3, 3, 3, 3]) == (3.0, 3.0, 0.0) def test_compute_statistics_negative_numbers(): assert compute_statistics([-1, -2, -3, -4]) == (-2.5, -2.5, 1.12) def test_compute_statistics_mixed_numbers(): assert compute_statistics([-1, 0, 1]) == (0.0, 0.0, 0.82) def test_compute_statistics_sorted_numbers(): assert compute_statistics([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == (5.5, 5.5, 2.87)","solution":"import numpy as np def compute_statistics(nums): Computes the mean, median, and standard deviation of a list of numbers. Parameters: nums (list): A list of integers. Returns: tuple: A tuple containing the mean, median, and standard deviation, each rounded to 2 decimal places. mean_value = round(np.mean(nums), 2) median_value = round(np.median(nums), 2) std_deviation = round(np.std(nums), 2) return mean_value, median_value, std_deviation"},{"question":"def count_lakes(grid: List[List[int]], N: int, M: int) -> int: Given a grid of size N x M where cells with value 0 represent water and cells with value 1 represent land, count the number of lakes present in the grid. A lake is defined as a group of one or more connected water cells (0s) surrounded by land cells (1s) completely on all sides horizontally and vertically (not diagonally). Args: grid (List[List[int]]): The input grid. N (int): The number of rows. M (int): The number of columns. Returns: int: The number of lakes present in the grid. Example: >>> grid = [ ... [1, 0, 1, 1, 1, 1, 1, 1], ... [1, 0, 1, 0, 0, 1, 1, 1], ... [1, 1, 1, 0, 1, 1, 1, 1], ... [1, 1, 0, 0, 0, 1, 1, 1], ... [1, 1, 0, 1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1, 1, 1, 1] ... ] >>> count_lakes(grid, 6, 8) 2 def test_example_case(): grid = [ [1, 0, 1, 1, 1, 1, 1, 1], [1, 0, 1, 0, 0, 1, 1, 1], [1, 1, 1, 0, 1, 1, 1, 1], [1, 1, 0, 0, 0, 1, 1, 1], [1, 1, 0, 1, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1] ] assert count_lakes(grid, 6, 8) == 2 def test_no_lakes(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert count_lakes(grid, 3, 3) == 0 def test_all_water(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert count_lakes(grid, 3, 3) == 0 def test_single_lake(): grid = [ [1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1] ] assert count_lakes(grid, 5, 5) == 1 import pytest if __name__ == \\"__main__\\": pytest.main()","solution":"def count_lakes(grid, N, M): Returns the number of lakes in the grid. def is_valid(x, y): return 0 <= x < N and 0 <= y < M def dfs(x, y): # Depth First Search to mark connected water (0) cells stack = [(x, y)] while stack: cx, cy = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if is_valid(nx, ny) and grid[nx][ny] == 0: grid[nx][ny] = -1 # Mark the cell as visited stack.append((nx, ny)) def is_lake(x, y): if grid[x][y] != 0: return False # Check if the current 0 cell is surrounded by 1s for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_valid(nx, ny) and grid[nx][ny] == 1: return True return False lake_count = 0 for i in range(N): for j in range(M): if grid[i][j] == 0 and is_lake(i, j): lake_count += 1 dfs(i, j) return lake_count # Read input def main(): N, M = map(int, input().split()) grid = [] for _ in range(N): grid.append(list(map(int, input().split()))) print(count_lakes(grid, N, M)) if __name__ == \\"__main__\\": main()"},{"question":"def max_score(n: int) -> int: Returns the maximum possible score any single player can achieve if each player can pass their score at most once. >>> max_score(2) 3 >>> max_score(3) 5 >>> max_score(4) 7 >>> max_score(5) 9 >>> max_score(1000) 1999 def solve(t: int, cases: List[int]) -> List[int]: Processes multiple test cases and returns the results for each case. >>> solve(3, [2, 3, 4]) [3, 5, 7] >>> solve(2, [5, 6]) [9, 11] >>> solve(1, [1000]) [1999] from typing import List","solution":"def max_score(n): Returns the maximum possible score any single player can achieve if each player can pass their score at most once. Parameters: n (int): number of players Returns: int: maximum score # The maximum possible score for a single player is achieved by # the player who receives the score from the previous player. # The total score sum is the triangular number n*(n+1)/2, which # is maximized when one player doesn't pass their score. return n + (n-1) # this is equivalent to n + n - 1 = 2n - 1 def solve(t, cases): Processes multiple test cases and returns the results for each case. Parameters: t (int): number of test cases cases (list of int): list of players count for each test case Returns: list of int: maximum scores for each test case results = [] for n in cases: results.append(max_score(n)) return results"},{"question":"def flatten_list(nested_list: list) -> list: Flattens a nested list of integers and strings while preserving the order of the integers. Strings are ignored. Only the innermost integers are added to the final list. If the input is not a list, an empty list is returned. >>> flatten_list([1, 'a', [2, 'b', [3, [4, 'c']], 5], ['d'], 6]) [1, 2, 3, 4, 5, 6] >>> flatten_list(['a', ['b', ['c']]]) [] >>> flatten_list(5) [] >>> flatten_list([]) []","solution":"def flatten_list(nested_list): Flattens a nested list of integers and strings while preserving the order of the integers. Strings are ignored. Only the innermost integers are added to the final list. If the input is not a list, an empty list is returned. :param nested_list: list containing integers, strings, and sublists :return: a list containing all the integers from the input list in order def flatten(nested): for elem in nested: if isinstance(elem, list): yield from flatten(elem) elif isinstance(elem, int): yield elem if not isinstance(nested_list, list): return [] return list(flatten(nested_list))"},{"question":"def is_knights_safe(n, k, positions): Determines if all knights are safe from each other according to the rules of chess knight movements. Args: n : int : Size of the chessboard (n x n) k : int : Number of knights on the board positions : List[Tuple[int, int]] : List of tuples representing the positions of knights Returns: str : \\"YES\\" if all knights are safe, otherwise \\"NO\\" pass def knights_test_cases(test_cases): Processes multiple test cases to determine if knights are safe on given chessboards. Args: test_cases : list : List of dictionaries with test case data Returns: list : List of results for each test case pass # Unit Tests import pytest def test_no_knights(): assert is_knights_safe(4, 0, []) == \\"YES\\" def test_single_knight(): assert is_knights_safe(4, 1, [(1, 1, 1)]) == \\"YES\\" def test_knights_attacking(): assert is_knights_safe(4, 2, [(1, 1, 1), (3, 2, 2)]) == \\"NO\\" assert is_knights_safe(5, 3, [(1, 1, 1), (2, 3, 2), (4, 4, 3)]) == \\"NO\\" def test_knights_not_attacking(): assert is_knights_safe(4, 2, [(1, 1, 1), (4, 4, 2)]) == \\"YES\\" assert is_knights_safe(5, 3, [(1, 1, 1), (1, 3, 2), (4, 4, 3)]) == \\"YES\\" def test_multiple_test_cases(): test_cases = [ {'n': 4, 'k': 2, 'positions': [(1, 1, 1), (3, 2, 2)]}, {'n': 5, 'k': 3, 'positions': [(1, 1, 1), (1, 3, 2), (4, 4, 3)]} ] results = knights_test_cases(test_cases) assert results == [\\"NO\\", \\"YES\\"]","solution":"def is_knights_safe(n, k, positions): Determines if all knights are safe from each other according to the rules of chess knight movements. Args: n : int : Size of the chessboard (n x n) k : int : Number of knights on the board positions : List[Tuple[int, int]] : List of tuples representing the positions of knights Returns: str : \\"YES\\" if all knights are safe, otherwise \\"NO\\" knight_moves = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] knight_positions = set((x, y) for x, y, _ in positions) for x, y, _ in positions: for dx, dy in knight_moves: nx, ny = x + dx, y + dy if (nx, ny) in knight_positions: return \\"NO\\" return \\"YES\\" def knights_test_cases(test_cases): Processes multiple test cases to determine if knights are safe on given chessboards. Args: test_cases : list : List of dictionaries with test case data Returns: list : List of results for each test case results = [] for test_case in test_cases: n = test_case['n'] k = test_case['k'] positions = test_case['positions'] result = is_knights_safe(n, k, positions) results.append(result) return results"},{"question":"def robot_within_grid(T: int, test_cases: List[Tuple[int, int, str]]) -> List[str]: Determine if the robot stays within the grid after executing all the given commands. Args: T: The number of test cases. test_cases: A list of tuples, each containing the number of rows, the number of columns, and the commands string. Returns: A list of strings, \\"YES\\" if the robot stays within the grid for each test case, otherwise \\"NO\\". >>> robot_within_grid(3, [(3, 3, 'RRDD'), (4, 4, 'UUURRRDDD'), (2, 2, 'RUULD')]) [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def robot_within_grid(T, test_cases): results = [] for case in test_cases: M, N, S = case row, col = 0, 0 within_grid = True for command in S: if command == 'U': row -= 1 elif command == 'D': row += 1 elif command == 'L': col -= 1 elif command == 'R': col += 1 if row < 0 or row >= M or col < 0 or col >= N: within_grid = False break if within_grid: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_resource_stockpile(n: int, m: int, resources: List[int], trades: List[Tuple[int, int, int]]) -> int: Calculate the maximum resource stockpile for any player after all trades. Args: n : int - Number of players m : int - Number of trades resources : list of int - Initial resources of each player trades : list of tuple(int, int, int) - Each tuple represents a trade (x, y, z) where x gives z resources to y Returns: int - Maximum resource stockpile at the end of the day >>> max_resource_stockpile(6, 3, [10, 20, 30, 40, 50, 60], [(1, 2, 5), (2, 3, 10), (4, 5, 15)]) == 65 >>> max_resource_stockpile(4, 2, [5, 8, 7, 10], [(3, 1, 4), (4, 2, 3)]) == 11 >>> max_resource_stockpile(3, 0, [100, 200, 300], []) == 300 >>> max_resource_stockpile(2, 1, [50, 50], [(1, 2, 10)]) == 60 >>> max_resource_stockpile(2, 1, [1000000000, 0], [(1, 2, 500000000)]) == 500000000","solution":"def max_resource_stockpile(n, m, resources, trades): Calculate the maximum resource stockpile for any player after all trades. Args: n : int - Number of players m : int - Number of trades resources : list of int - Initial resources of each player trades : list of tuple(int, int, int) - Each tuple represents a trade (x, y, z) where x gives z resources to y Returns: int - Maximum resource stockpile at the end of the day # Adjust resources based on the trades for x, y, z in trades: resources[x - 1] -= z resources[y - 1] += z # Return the maximum resource stockpile return max(resources)"},{"question":"def multiply(a: int, b: int) -> int: Implement a function multiply(a, b) which takes two non-negative integers a and b, and returns the product of the two numbers. You must not use the multiplication operator (*). >>> multiply(3, 4) 12 >>> multiply(0, 5) 0 >>> multiply(10, 10) 100","solution":"def multiply(a: int, b: int) -> int: Returns the product of a and b without using the multiplication operator. result = 0 # Iterate b times, adding a each time to result for _ in range(b): result += a return result"},{"question":"import math def sum_of_factorials(n: int) -> int: Calculate the sum of the factorials of the digits of a given positive integer n. Parameters: n (int): The given positive integer (1 <= n <= 10^6) Returns: int: The sum of the factorials of the digits of n Examples: >>> sum_of_factorials(123) 9 >>> sum_of_factorials(405) 145","solution":"import math def sum_of_factorials(n: int) -> int: Calculate the sum of the factorials of the digits of a given positive integer n. Parameters: n (int): The given positive integer (1 <= n <= 10^6) Returns: int: The sum of the factorials of the digits of n return sum(math.factorial(int(digit)) for digit in str(n))"},{"question":"def count_friendship_triangles(n: int, m: int, friendships: List[Tuple[int, int]]) -> int: Count the number of friendship triangles in a social media platform. >>> count_friendship_triangles(5, 6, [(1, 2), (2, 3), (3, 1), (4, 5), (2, 1), (1, 3)]) 1 >>> count_friendship_triangles(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 0 pass if __name__ == \\"__main__\\": import doctest doctest.testmod() from solution import count_friendship_triangles def test_example_1(): n, m = 5, 6 friendships = [(1, 2), (2, 3), (3, 1), (4, 5), (2, 1), (1, 3)] assert count_friendship_triangles(n, m, friendships) == 1 def test_example_2(): n, m = 4, 4 friendships = [(1, 2), (2, 3), (3, 4), (4, 1)] assert count_friendship_triangles(n, m, friendships) == 0 def test_no_friendships(): n, m = 3, 0 friendships = [] assert count_friendship_triangles(n, m, friendships) == 0 def test_disconnected_graph(): n, m = 5, 3 friendships = [(1, 2), (3, 4), (4, 5)] assert count_friendship_triangles(n, m, friendships) == 0 def test_all_connected(): n, m = 3, 3 friendships = [(1, 2), (2, 3), (3, 1)] assert count_friendship_triangles(n, m, friendships) == 1 def test_multiple_triangles(): n, m = 4, 6 friendships = [(1, 2), (2, 3), (3, 1), (1, 3), (1, 4), (3, 4)] assert count_friendship_triangles(n, m, friendships) == 2 if __name__ == \\"__main__\\": test_example_1() test_example_2() test_no_friendships() test_disconnected_graph() test_all_connected() test_multiple_triangles() print(\\"All tests passed.\\")","solution":"def count_friendship_triangles(n, m, friendships): from collections import defaultdict graph = defaultdict(set) # Build the graph for u, v in friendships: graph[u].add(v) graph[v].add(u) triangle_count = 0 # Check for triangles for i in range(1, n + 1): for j in graph[i]: if j > i: # Ensure we only count once for k in graph[j]: if k > j and k in graph[i]: triangle_count += 1 return triangle_count"},{"question":"def find_missing_number(nums: List[int]) -> int: Write a function that takes an unsorted list of unique integers ranging from 1 to \`n\` (inclusive) with one number missing, and returns the missing number. The length of the list will be \`n-1\`. >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([1, 2, 4, 5, 6]) 3 >>> find_missing_number([9, 6, 4, 2, 3, 5, 7, 1]) 8 >>> find_missing_number([2, 3, 4, 5]) 1","solution":"def find_missing_number(nums): This function returns the missing number in the given list of unique integers ranging from 1 to n. n = len(nums) + 1 expected_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(expected_sum - actual_sum)"},{"question":"def is_valid_parentheses(s: str) -> bool: Determine if the input string is a valid combination of parentheses. Args: s (str): Input string consisting of '(', ')', '{', '}', '[' and ']'. Returns: bool: True if the string is valid, False otherwise. Examples: >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"()[]{}\\") True >>> is_valid_parentheses(\\"(]\\") False >>> is_valid_parentheses(\\"([)]\\") False >>> is_valid_parentheses(\\"{[]}\\") True","solution":"def is_valid_parentheses(s): Determine if the input string is a valid combination of parentheses. Args: s (str): Input string consisting of '(', ')', '{', '}', '[' and ']'. Returns: bool: True if the string is valid, False otherwise. stack = [] mapping = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def is_team_valid(team: List[int]) -> bool: Determine if the team formation in the given list is valid based on specified rules. Parameters: team (list): An integer list containing elements 1-8. Returns: bool: True if the team is valid, False otherwise. >>> is_team_valid([1, 3, 7]) == True >>> is_team_valid([7, 1, 2, 3]) == False >>> is_team_valid([1, 3, 5, 7]) == False >>> is_team_valid([1, 5, 6, 7, 3]) == True >>> is_team_valid([5, 6, 7]) == True >>> is_team_valid([5, 6, 7, 8]) == True >>> is_team_valid([6, 7, 8]) == False >>> is_team_valid([7, 8]) == True >>> is_team_valid([1, 2, 5]) == False >>> is_team_valid([4, 5, 6, 8]) == True >>> is_team_valid([8]) == True >>> is_team_valid([3, 4, 7, 8]) == False >>> is_team_valid([7]) == True >>> is_team_valid([1]) == False >>> is_team_valid([1, 6]) == False >>> is_team_valid([3, 5]) == False >>> is_team_valid([2, 8]) == True","solution":"def is_team_valid(team): Determine if the team formation in the given list is valid based on specified rules. Parameters: team (list): An integer list containing elements 1-8. Returns: bool: True if the team is valid, False otherwise. if 1 in team and 2 in team: return False if 3 in team and 4 in team: return False if (5 in team) != (6 in team): return False if 7 not in team and 8 not in team: return False return True"},{"question":"def max_length_subarray(arr: List[int], k: int) -> int: Given an integer array \`arr\` and an integer \`k\`, return the maximum elements that can be included in the subarray that has a sum less than or equal to \`k\`. A subarray is a contiguous part of the array. >>> max_length_subarray([3, 1, 2, 1, 3], 4) 3 >>> max_length_subarray([1, 2, 3, 4], 5) 2","solution":"def max_length_subarray(arr, k): Returns the maximum number of elements in a subarray that has a sum less than or equal to k. max_length = 0 current_sum = 0 start_index = 0 for end_index in range(len(arr)): current_sum += arr[end_index] while current_sum > k: current_sum -= arr[start_index] start_index += 1 max_length = max(max_length, end_index - start_index + 1) return max_length"},{"question":"from typing import List def min_trips(n: int, weights: List[int], W: int) -> int: Determine the minimum number of trips required to get all travelers across the river safely. >>> min_trips(5, [100, 200, 150, 80, 120], 200) 4 >>> min_trips(1, [150], 200) 1 >>> min_trips(1, [250], 200) 1 >>> min_trips(5, [100, 100, 100, 100, 100], 150) 5 >>> min_trips(5, [100, 100, 100, 100, 100], 200) 3 >>> min_trips(3, [300, 400, 500], 250) 3 >>> min_trips(4, [500, 500, 500, 500], 450) 4 >>> min_trips(1000, [i for i in range(1, 1001)], 1000) 501 pass","solution":"def min_trips(n, weights, W): weights.sort(reverse=True) trips = 0 i, j = 0, n - 1 while i <= j: if weights[i] + weights[j] <= W: j -= 1 i += 1 trips += 1 return trips # Example usage: # n = 5 # weights = [100, 200, 150, 80, 120] # W = 200 # print(min_trips(n, weights, W)) # Output: 4"},{"question":"def find_pair(l: List[int], target_sum: int) -> Optional[Tuple[int, int]]: Create a function that takes a list of integers and an integer target sum. The function should determine if there are any two distinct numbers in the list that add up to the target sum. If such a pair exists, return a tuple containing the two numbers. If no such pair exists, return None. >>> find_pair([10, 5, 2, 3, 7, 5], 10) in [(7, 3), (3, 7)] True >>> find_pair([1, 2, 3, 4, 5], 10) is None True >>> find_pair([1, 3, 5], 8) in [(3, 5), (5, 3)] True >>> find_pair([], 5) is None True >>> find_pair([5], 5) is None True","solution":"def find_pair(l, target_sum): Determines if there are any two distinct numbers in the list that add up to the target sum. If such a pair exists, return a tuple containing the two numbers. If no such pair exists, return None. seen = set() for number in l: complement = target_sum - number if complement in seen: return (complement, number) seen.add(number) return None"},{"question":"def min_water_units(fires): This function determines the minimum number of water units needed to extinguish fires in the forest without deploying units into two adjacent sections simultaneously. :param fires: List[int], a list of non-negative integers representing the intensity of fires :return: int, the minimum number of water units needed >>> min_water_units([1, 2, 3, 1]) 4 >>> min_water_units([2, 7, 9, 3, 1]) 12 >>> min_water_units([]) 0 >>> min_water_units([5]) 5 >>> min_water_units([1, 2]) 2 >>> min_water_units([400, 400, 400, 400]) 800 >>> min_water_units([10, 1, 10, 1, 10, 1, 10, 1]) 40 >>> min_water_units([5, 5, 5, 5, 5]) 15","solution":"def min_water_units(fires): This function determines the minimum number of water units needed to extinguish fires in the forest without deploying units into two adjacent sections simultaneously. :param fires: List[int], a list of non-negative integers representing the intensity of fires :return: int, the minimum number of water units needed # If the list is empty, no water units are needed if not fires: return 0 # If there's only one section, deploy water to that section if len(fires) == 1: return fires[0] # Use dynamic programming to find the minimum water units needed n = len(fires) dp = [0] * n # Initialize the first two values of dp dp[0] = fires[0] dp[1] = max(fires[0], fires[1]) # Fill the dp array for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + fires[i]) return dp[-1]"},{"question":"def sum_of_prime_factors(n: int) -> int: Returns the sum of the prime factors of n. >>> sum_of_prime_factors(10) 7 >>> sum_of_prime_factors(15) 8 def special_number_pattern(N: int, K: int) -> int: Returns the final number in the sequence generated after K steps starting from N. >>> special_number_pattern(10, 2) 34 >>> special_number_pattern(15, 3) 71 def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Processes multiple test cases and returns results for each case. >>> process_test_cases([(10, 2), (15, 3)]) [34, 71] >>> process_test_cases([(5, 0), (7, 1)]) [5, 14]","solution":"def sum_of_prime_factors(n): Returns the sum of the prime factors of n. sum_factors = 0 # Dividing n by 2 until it's odd while n % 2 == 0: sum_factors += 2 n //= 2 # n must be odd at this point. So we start from 3 and only check for odd factors for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: sum_factors += i n //= i # This condition is to check if n is a prime number greater than 2 if n > 2: sum_factors += n return sum_factors def special_number_pattern(N, K): Returns the final number in the sequence generated after K steps starting from N. current_number = N for _ in range(K): current_number += sum_of_prime_factors(current_number) return current_number def process_test_cases(test_cases): results = [] for N, K in test_cases: results.append(special_number_pattern(N, K)) return results"},{"question":"def alternatingSums(arr): Returns an array containing the sums of the integers at the even indices and odd indices, respectively. >>> alternatingSums([50, 60, 70, 80]) [120, 140] >>> alternatingSums([1]) [1, 0] >>> alternatingSums([5, 5, 5, 5]) [10, 10] >>> alternatingSums([]) [0, 0] >>> alternatingSums([-1, -2, -3, -4]) [-4, -6] >>> arr = list(range(1, 10001)) >>> expected_sum_even = sum(arr[i] for i in range(0, len(arr), 2)) >>> expected_sum_odd = sum(arr[i] for i in range(1, len(arr), 2)) >>> alternatingSums(arr) [expected_sum_even, expected_sum_odd] >>> alternatingSums([3, -2, 7, 10, 2, -1]) [12, 7]","solution":"def alternatingSums(arr): Returns an array containing the sums of the integers at the even indices and odd indices, respectively. sum_even = sum(arr[i] for i in range(0, len(arr), 2)) sum_odd = sum(arr[i] for i in range(1, len(arr), 2)) return [sum_even, sum_odd]"},{"question":"from typing import List def can_form_consecutive_sequence(arr: List[int]) -> bool: Determine if the array of distinct integers can be rearranged to form a sequence of consecutive integers. Args: arr (List[int]): Array of distinct integers. Returns: bool: True if the array can be rearranged to form a consecutive sequence, otherwise False. Examples: >>> can_form_consecutive_sequence([1, 3, 2]) True >>> can_form_consecutive_sequence([1, 2, 4]) False pass def test_consecutive_sequence(): assert can_form_consecutive_sequence([1, 3, 2]) == True assert can_form_consecutive_sequence([1, 2, 3, 4, 5]) == True assert can_form_consecutive_sequence([-1, 0, 1]) == True assert can_form_consecutive_sequence([10, 9, 8, 7, 6]) == True def test_non_consecutive_sequence(): assert can_form_consecutive_sequence([1, 2, 4]) == False assert can_form_consecutive_sequence([1, 3]) == False assert can_form_consecutive_sequence([5, 7, 8]) == False assert can_form_consecutive_sequence([1, 2, 2]) == False # Duplicates should return False def test_empty_and_single_element_sequences(): assert can_form_consecutive_sequence([]) == False assert can_form_consecutive_sequence([1]) == True assert can_form_consecutive_sequence([7]) == True def test_negative_values(): assert can_form_consecutive_sequence([-2, -1, 0, 1, 2]) == True assert can_form_consecutive_sequence([-3, 0, -1, -2]) == True assert can_form_consecutive_sequence([-5, -3]) == False","solution":"def can_form_consecutive_sequence(arr): Returns True if the array can be rearranged to form a consecutive sequence, otherwise returns False. if not arr: return False min_val = min(arr) max_val = max(arr) return len(arr) == (max_val - min_val + 1)"},{"question":"def max_subgrid_sum(n: int, m: int, k: int, grid: List[List[int]]) -> int: Calculate the maximum sum of a subgrid with exactly k elements. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. k (int): Number of elements in the subgrid. grid (List[List[int]]): 2D list representing the grid. Returns: int: Maximum sum of a subgrid with exactly k elements. Example: >>> max_subgrid_sum(3, 3, 4, [ >>> [1, 2, 3], >>> [4, 5, 6], >>> [7, 8, 9] >>> ]) == 30","solution":"def max_subgrid_sum(n, m, k, grid): from itertools import combinations # Flatten the grid into a single list flattened_grid = [num for row in grid for num in row] # Get all combinations of length k max_sum = 0 for comb in combinations(flattened_grid, k): max_sum = max(max_sum, sum(comb)) return max_sum"},{"question":"def count_islands(grid: List[str]) -> int: Returns the number of distinct islands of 'X' in the grid. >>> count_islands([ \\"XOOXX\\", \\"XOOOX\\", \\"OOXXO\\", \\"OXXXX\\", \\"XXOOO\\" ]) == 3 >>> count_islands([ \\"XXXX\\", \\"XXXX\\", \\"XXXX\\", \\"XXXX\\" ]) == 1 >>> count_islands([ \\"XOXOX\\", \\"OXOXO\\", \\"XOXOX\\", \\"OXOXO\\", \\"XOXOX\\" ]) == 13 >>> count_islands([ \\"OOOO\\", \\"OOOO\\", \\"OOOO\\", \\"OOOO\\" ]) == 0 >>> count_islands([ \\"XO\\", \\"OX\\" ]) == 2 >>> count_islands([]) == 0 >>> count_islands([\\"X\\"]) == 1 >>> count_islands([\\"O\\"]) == 0","solution":"def count_islands(grid): Returns the number of distinct islands of 'X' in the grid. if not grid: return 0 def dfs(grid, x, y, visited): stack = [(x, y)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 'X' and (nx, ny) not in visited: visited.add((nx, ny)) stack.append((nx, ny)) visited = set() island_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 'X' and (i, j) not in visited: visited.add((i, j)) dfs(grid, i, j, visited) island_count += 1 return island_count"},{"question":"def max_subarray_sum(sequence): Finds the largest sum of a contiguous subarray in the given sequence. Arguments: sequence -- list of integers Returns: int -- the largest sum of a contiguous subarray Example: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6","solution":"def max_subarray_sum(sequence): Finds the largest sum of a contiguous subarray in the given sequence. Arguments: sequence -- list of integers Returns: int -- the largest sum of a contiguous subarray max_ending_here = max_so_far = sequence[0] for x in sequence[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def compressString(s: str) -> str: Compresses the input string using run-length encoding. If the compressed string is not shorter than the original string, the original string is returned. >>> compressString(\\"aaabcccccaaa\\") \\"a3b1c5a3\\" >>> compressString(\\"abcdef\\") \\"abcdef\\"","solution":"def compressString(s: str) -> str: Compresses the input string using run-length encoding. If the compressed string is not shorter than the original string, the original string is returned. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 # Add the last set of characters compressed.append(s[-1] + str(count)) compressed_str = ''.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"from typing import List def move_value_to_end(arr: List[int], value: int) -> List[int]: Move all occurrences of 'value' to the end of the array while maintaining the relative order of the other elements. :param arr: List[int] - List of integers. :param value: int - The value to move to the end. :return: List[int] - Modified list with 'value' moved to the end. >>> move_value_to_end([4, 1, 2, 4, 3, 4, 5], 4) [1, 2, 3, 5, 4, 4, 4] >>> move_value_to_end([1, 2, 3, 3, 3, 4, 5], 3) [1, 2, 4, 5, 3, 3, 3] >>> move_value_to_end([5, 5, 5, 5, 5], 5) [5, 5, 5, 5, 5]","solution":"def move_value_to_end(arr, value): Move all occurrences of 'value' to the end of the array while maintaining the relative order of the other elements. :param arr: List[int] - List of integers. :param value: int - The value to move to the end. :return: List[int] - Modified list with 'value' moved to the end. other_elements = [x for x in arr if x != value] value_count = arr.count(value) other_elements.extend([value] * value_count) return other_elements"},{"question":"def generate_primes(n: int) -> list: Generates a list of prime numbers up to a given number n (inclusive). Parameters: n (int): The upper limit for generating prime numbers. Returns: list: A list of prime numbers up to n. Examples: >>> generate_primes(10) [2, 3, 5, 7] >>> generate_primes(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> generate_primes(1) [] >>> generate_primes(2) [2] >>> generate_primes(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]","solution":"def generate_primes(n): Generates a list of prime numbers up to a given number n (inclusive). Parameters: n (int): The upper limit for generating prime numbers. Returns: list: A list of prime numbers up to n. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False return [num for num in range(2, n + 1) if sieve[num]]"},{"question":"def water_plants(n: int, readings: List[int], threshold: int) -> str: Analyzes temperature readings to determine when to water plants. Parameters: n (int): Number of temperature readings. readings (list of int): List of temperature readings. threshold (int): Threshold temperature. Returns: str: Decision on whether to water the plants or not with the average temperature rounded to 2 decimal places. >>> water_plants(5, [15, 14, 16, 15, 14], 15) \\"Average temperature: 14.8 - Water plants\\" >>> water_plants(4, [15, 16, 14, 15], 15) \\"Average temperature: 15.0 - Do not water plants\\" >>> water_plants(3, [17, 18, 19], 16) \\"Average temperature: 18.0 - Do not water plants\\" >>> water_plants(4, [-5, -6, -7, -6], -6) \\"Average temperature: -6.0 - Do not water plants\\" >>> water_plants(4, [-5, -6, -7, -6], -5) \\"Average temperature: -6.0 - Water plants\\" >>> water_plants(1, [20], 20) \\"Average temperature: 20.0 - Do not water plants\\" >>> water_plants(1, [10], 20) \\"Average temperature: 10.0 - Water plants\\"","solution":"def water_plants(n, readings, threshold): Determines if the plants should be watered based on the average temperature. Parameters: n (int): Number of temperature readings. readings (list of int): List of temperature readings. threshold (int): Threshold temperature. Returns: str: Decision on whether to water the plants or not with the average temperature rounded to 2 decimal places. if n == 0: raise ValueError(\\"Number of readings should be greater than zero\\") average_temperature = sum(readings) / n average_temp_rounded = round(average_temperature, 2) if average_temp_rounded < threshold: return f\\"Average temperature: {average_temp_rounded} - Water plants\\" else: return f\\"Average temperature: {average_temp_rounded} - Do not water plants\\""},{"question":"def longestPalindrome(s: str) -> str: Given a string s, find and return the longest palindrome substring in s. If there are multiple longest palindromic substrings, return the first one found. A palindrome is a string that reads the same forwards and backwards. >>> longestPalindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longestPalindrome(\\"cbbd\\") \\"bb\\" >>> longestPalindrome(\\"a\\") \\"a\\" >>> longestPalindrome(\\"ac\\") in [\\"a\\", \\"c\\"] True","solution":"def longestPalindrome(s: str) -> str: Returns the longest palindromic substring in s. def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # Check for odd-length palindromes odd_palindrome = expand_around_center(i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Check for even-length palindromes even_palindrome = expand_around_center(i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest"},{"question":"def transform_string(s: str) -> str: Transforms the input string into a new string where each character is followed by its count of consecutive occurrences in the original string. :param s: The input string consisting of lowercase alphabetical characters. :return: A new string where each character is followed by its count. >>> transform_string(\\"aaabbc\\") 'a3b2c1' >>> transform_string(\\"aabcccccaaa\\") 'a2b1c5a3' >>> transform_string(\\"abcd\\") 'a1b1c1d1'","solution":"def transform_string(s: str) -> str: Transforms the input string into a new string where each character is followed by its count of consecutive occurrences in the original string. :param s: The input string consisting of lowercase alphabetical characters. :return: A new string where each character is followed by its count. if not s: return \\"\\" result = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: result.append(current_char + str(count)) current_char = char count = 1 result.append(current_char + str(count)) return ''.join(result)"},{"question":"def perform_operations(grid, N, M, operations): Perform a series of operations on a grid of characters, replacing specified characters in given sub-rectangles. Args: grid (list of list of str): The rectangular grid of characters. N (int): Number of rows in the grid. M (int): Number of columns in the grid. operations (list of tuples): A list of operations, each defined by (x1, y1, x2, y2, c, d). Returns: list of list of str: The modified grid after all operations. pass def test_perform_operations(): grid = [ ['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i'] ] operations = [ (1, 1, 2, 2, 'a', 'z'), (2, 2, 3, 3, 'f', 'k') ] expected = [ ['z', 'b', 'c'], ['d', 'e', 'k'], ['g', 'h', 'i'] ] result = perform_operations(grid, 3, 3, operations) assert result == expected def test_no_operations(): grid = [ ['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i'] ] operations = [] expected = [ ['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i'] ] result = perform_operations(grid, 3, 3, operations) assert result == expected def test_single_element_operations(): grid = [ ['a'] ] operations = [ (1, 1, 1, 1, 'a', 'z') ] expected = [ ['z'] ] result = perform_operations(grid, 1, 1, operations) assert result == expected if __name__ == \\"__main__\\": test_perform_operations() test_no_operations() test_single_element_operations() print(\\"All tests passed.\\")","solution":"def perform_operations(grid, N, M, operations): Perform a series of operations on a grid of characters, replacing specified characters in given sub-rectangles. Args: grid (list of list of str): The rectangular grid of characters. N (int): Number of rows in the grid. M (int): Number of columns in the grid. operations (list of tuples): A list of operations, each defined by (x1, y1, x2, y2, c, d). Returns: list of list of str: The modified grid after all operations. for (x1, y1, x2, y2, c, d) in operations: for i in range(x1-1, x2): for j in range(y1-1, y2): if grid[i][j] == c: grid[i][j] = d return grid def read_input(): N, M = map(int, input().strip().split()) grid = [list(input().strip()) for _ in range(N)] Q = int(input().strip()) operations = [] for _ in range(Q): x1, y1, x2, y2, c, d = input().strip().split() operations.append((int(x1), int(y1), int(x2), int(y2), c, d)) return grid, N, M, operations def main(): grid, N, M, operations = read_input() result_grid = perform_operations(grid, N, M, operations) for row in result_grid: print(\\"\\".join(row)) if __name__ == \\"__main__\\": main()"},{"question":"def levenshtein_distance(word1: str, word2: str) -> int: Calculate the total number of transformations needed to turn one word into another using only insertions, deletions, or substitutions of characters. >>> levenshtein_distance(\\"kitten\\", \\"sitting\\") 3 >>> levenshtein_distance(\\"flaw\\", \\"lawn\\") 2 >>> levenshtein_distance(\\"intention\\", \\"execution\\") 5 >>> levenshtein_distance(\\"\\", \\"execute\\") 7 >>> levenshtein_distance(\\"execute\\", \\"\\") 7 >>> levenshtein_distance(\\"same\\", \\"same\\") 0 >>> levenshtein_distance(\\"a\\", \\"b\\") 1 >>> levenshtein_distance(\\"abcd\\", \\"abcde\\") 1 >>> levenshtein_distance(\\"a\\" * 1000, \\"b\\" * 1000) 1000","solution":"def levenshtein_distance(word1: str, word2: str) -> int: n = len(word1) m = len(word2) if n == 0: return m if m == 0: return n dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): dp[i][0] = i for j in range(1, m + 1): dp[0][j] = j for i in range(1, n + 1): for j in range(1, m + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[n][m]"},{"question":"def minimum_swaps_to_see_front(T: int, test_cases: list) -> list: Given T test cases with each test case containing the number N and a list of heights, returns a list of minimum number of swaps required for each test case such that everyone can see the front. >>> minimum_swaps_to_see_front(3, [(4, [4, 1, 3, 2]), (5, [5, 1, 2, 3, 4]), (7, [2, 3, 4, 5, 6, 7, 8])]) [2, 4, 0] >>> minimum_swaps_to_see_front(1, [(1, [1])]) [0] >>> minimum_swaps_to_see_front(1, [(3, [1, 2, 3])]) [0] # Test cases def test_minimum_swaps_to_see_front_case_1(): T = 1 test_cases = [(4, [4, 1, 3, 2])] assert minimum_swaps_to_see_front(T, test_cases) == [2] def test_minimum_swaps_to_see_front_case_2(): T = 1 test_cases = [(5, [5, 1, 2, 3, 4])] assert minimum_swaps_to_see_front(T, test_cases) == [4] def test_minimum_swaps_to_see_front_case_3(): T = 1 test_cases = [(7, [2, 3, 4, 5, 6, 7, 8])] assert minimum_swaps_to_see_front(T, test_cases) == [0] def test_minimum_swaps_to_see_front_multiple_cases(): T = 3 test_cases = [ (4, [4, 1, 3, 2]), (5, [5, 1, 2, 3, 4]), (7, [2, 3, 4, 5, 6, 7, 8]) ] assert minimum_swaps_to_see_front(T, test_cases) == [2, 4, 0] def test_minimum_swaps_to_see_front_single_person(): T = 1 test_cases = [(1, [1])] assert minimum_swaps_to_see_front(T, test_cases) == [0] def test_minimum_swaps_to_see_front_already_sorted(): T = 1 test_cases = [(3, [1, 2, 3])] assert minimum_swaps_to_see_front(T, test_cases) == [0]","solution":"def minimum_swaps_to_see_front(T, test_cases): Given T test cases with each test case containing the number N and a list of heights, returns a list of minimum number of swaps required for each test case such that everyone can see the front. results = [] for case in test_cases: N, heights = case sorted_heights = sorted(heights) swaps = 0 for i in range(N): while heights[i] != sorted_heights[i]: swap_idx = heights.index(sorted_heights[i]) heights[i], heights[swap_idx] = heights[swap_idx], heights[i] swaps += 1 results.append(swaps) return results"},{"question":"def transform(s: str) -> str: Transforms the input string by replacing each group of consecutive identical characters with the character followed by the number of occurrences. For characters that appear only once consecutively, the number is not added. >>> transform(\\"aabccc\\") \\"a2bc3\\" >>> transform(\\"aaabbbccdd\\") \\"a3b3c2d2\\" >>> transform(\\"abcd\\") \\"abcd\\" >>> transform(\\"aabbcc\\") \\"a2b2c2\\" >>> transform(\\"abbbc\\") \\"ab3c\\"","solution":"def transform(s: str) -> str: Transforms the input string by replacing each group of consecutive identical characters with the character followed by the number of occurrences. For characters that appear only once consecutively, the number is not added. :param s: Input string consisting of lowercase alphabetic characters :return: Transformed string if not s: return \\"\\" transformed_string = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: transformed_string.append(s[i - 1]) if count > 1: transformed_string.append(str(count)) count = 1 # Append the last group transformed_string.append(s[-1]) if count > 1: transformed_string.append(str(count)) return ''.join(transformed_string)"},{"question":"def convert(s: str, numRows: int) -> str: Convert a given string into a zigzag pattern on a given number of rows. >>> convert(\\"PAYPALISHIRING\\", 3) \\"PAHNAPLSIIGYIR\\" >>> convert(\\"PAYPALISHIRING\\", 4) \\"PINALSIGYAHRPI\\" >>> convert(\\"A\\", 1) \\"A\\"","solution":"def convert(s: str, numRows: int) -> str: if numRows == 1 or numRows >= len(s): return s rows = [''] * numRows current_row, step = 0, -1 for char in s: rows[current_row] += char # Change direction at the first or last row if current_row == 0 or current_row == numRows - 1: step *= -1 current_row += step return ''.join(rows)"},{"question":"from typing import List def length_of_longest_subarray(arr: List[int]) -> int: Given an array of integers, find the length of the longest contiguous subarray that contains at most two distinct elements. >>> length_of_longest_subarray([1, 2, 1, 2, 3]) 4 >>> length_of_longest_subarray([4, 4, 4, 4, 4]) 5 >>> length_of_longest_subarray([1, 2, 3, 4, 5]) 2 >>> length_of_longest_subarray([1]) 1 >>> length_of_longest_subarray([1, 2]) 2 >>> length_of_longest_subarray([]) 0 >>> length_of_longest_subarray([1, 1, 1, 2, 2, 3, 3, 3]) 5 >>> length_of_longest_subarray([1, 2, 3, 4, 1, 2]) 2 >>> length_of_longest_subarray([7, 7, 7, 7, 7, 7]) 6","solution":"def length_of_longest_subarray(arr): from collections import defaultdict n = len(arr) if n == 0: return 0 if n == 1: return 1 left = 0 max_length = 0 freq = defaultdict(int) for right in range(n): freq[arr[right]] += 1 while len(freq) > 2: freq[arr[left]] -= 1 if freq[arr[left]] == 0: del freq[arr[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def deepest_string_length(nested_lists: list) -> int: Returns the length of the longest string in a series of nested lists. Args: nested_lists (list): A list which may contain nested lists and strings. Returns: int: The length of the longest string found within the nested lists. from solution import deepest_string_length def test_single_level_strings(): assert deepest_string_length([\\"hello\\", \\"world\\"]) == 5 def test_nested_strings(): assert deepest_string_length([\\"hello\\", [\\"world\\"]]) == 5 def test_deeply_nested_strings(): assert deepest_string_length([[\\"this\\", [\\"is\\", [\\"a\\", [\\"test\\"]]]]]) == 4 def test_empty_list(): assert deepest_string_length([]) == 0 def test_no_strings(): assert deepest_string_length([[], [[]], [[[]]]]) == 0 def test_various_length_strings(): assert deepest_string_length([\\"tiny\\", [\\"short\\", [\\"medium\\", [\\"verylong\\"]]]]) == 8 def test_mixed_data_types(): assert deepest_string_length([\\"hello\\", 123, [\\"world\\", 456.78, [True, [\\"longeststring\\"]]]]) == 13","solution":"def deepest_string_length(nested_lists): Recursively finds the length of the longest string in a series of nested lists. Args: nested_lists (list): A list which may contain nested lists and strings. Returns: int: The length of the longest string found within the nested lists. max_length = 0 def helper(nested): nonlocal max_length for item in nested: if isinstance(item, list): helper(item) elif isinstance(item, str): max_length = max(max_length, len(item)) helper(nested_lists) return max_length"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, return a list such that each element at index \`i\` is the product of all the numbers in the original list except the one at \`i\`. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5]) [1] >>> product_except_self([0, 1]) [1, 0] >>> product_except_self([0, 1, 0]) [0, 0, 0] >>> product_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_except_self([-1, 1, -1, 1]) [-1, 1, -1, 1] >>> product_except_self([]) [] >>> product_except_self([100, 200, 300, 400, 500]) [12000000000, 6000000000, 4000000000, 3000000000, 2400000000]","solution":"def product_except_self(nums): Given a list of integers, return a list such that each element at index \`i\` is the product of all the numbers in the original list except the one at \`i\`. :param nums: List of integers :return: List of integers with product except self length = len(nums) if length == 0: return [] # Initialize the result array result = [1] * length # left_products[i] will contain the product of all elements to the left of i left_products = [1] * length # right_products[i] will contain the product of all elements to the right of i right_products = [1] * length # Calculate left_products for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Calculate right_products for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Calculate result by multiplying left_products and right_products for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"def can_be_palindrome_with_one_removal(s: str) -> str: Determine if it is possible to remove at most one character from the string so that it becomes a palindrome. >>> can_be_palindrome_with_one_removal('abba') == \\"YES\\" >>> can_be_palindrome_with_one_removal('racecar') == \\"YES\\" >>> can_be_palindrome_with_one_removal('abca') == \\"YES\\" >>> can_be_palindrome_with_one_removal('deifiede') == \\"YES\\" >>> can_be_palindrome_with_one_removal('abc') == \\"NO\\" >>> can_be_palindrome_with_one_removal('abcdef') == \\"NO\\" >>> can_be_palindrome_with_one_removal('a') == \\"YES\\" >>> can_be_palindrome_with_one_removal('zzzz') == \\"YES\\" >>> can_be_palindrome_with_one_removal('aa') == \\"YES\\" >>> can_be_palindrome_with_one_removal('ab') == \\"YES\\"","solution":"def can_be_palindrome_with_one_removal(s): Returns 'YES' if it's possible to remove at most one character to make the string a palindrome, otherwise returns 'NO'. def is_palindrome_range(s, left, right): while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Check both scenarios: removing left or right character if is_palindrome_range(s, left + 1, right) or is_palindrome_range(s, left, right - 1): return \\"YES\\" else: return \\"NO\\" left += 1 right -= 1 # If the loop completes without finding mismatched characters, it's already a palindrome return \\"YES\\""},{"question":"def simple_hash(s: str) -> str: A simple hashing function that takes a string and returns its hash. >>> simple_hash(\\"\\") == \\"0\\" >>> simple_hash(\\"a\\") == \\"97\\" >>> simple_hash(\\"abc\\") == \\"96354\\" >>> simple_hash(\\"Alice pays Bob 10 BTC\\") != simple_hash(\\"Alice pays Bob 10 BTC \\") hash_value = 0 for char in s: hash_value = (hash_value * 31 + ord(char)) % 1_000_000_007 return str(hash_value) class Block: def __init__(self, data: str, prev_hash: str): Initializes a new block with data and the previous block's hash. self.data = data self.prev_hash = prev_hash self.hash = simple_hash(data + prev_hash) class Blockchain: def __init__(self): Initialize an empty blockchain with a genesis block. genesis_block = Block('', '0') self.blocks = [genesis_block] def add_block(self, data: str) -> None: Adds a new block to the blockchain with the given transaction data. prev_hash = self.blocks[-1].hash new_block = Block(data, prev_hash) self.blocks.append(new_block) def get_latest_hash(self) -> str: Returns the hash of the latest block in the blockchain. return self.blocks[-1].hash # Unit Tests def test_simple_hash(): assert simple_hash(\\"\\") == \\"0\\" assert simple_hash(\\"a\\") == \\"97\\" assert simple_hash(\\"abc\\") == \\"96354\\" assert simple_hash(\\"Alice pays Bob 10 BTC\\") != simple_hash(\\"Alice pays Bob 10 BTC \\") def test_block_creation(): block = Block(\\"Alice pays Bob 10 BTC\\", \\"0\\") assert block.data == \\"Alice pays Bob 10 BTC\\" assert block.prev_hash == \\"0\\" assert block.hash == simple_hash(\\"Alice pays Bob 10 BTC\\" + \\"0\\") def test_blockchain_initialization(): bc = Blockchain() # Check genesis block. assert len(bc.blocks) == 1 assert bc.blocks[0].data == '' assert bc.blocks[0].prev_hash == '0' assert bc.blocks[0].hash == simple_hash('0') def test_adding_blocks(): bc = Blockchain() bc.add_block(\\"Alice pays Bob 10 BTC\\") assert len(bc.blocks) == 2 assert bc.blocks[1].data == \\"Alice pays Bob 10 BTC\\" bc.add_block(\\"Bob pays Charlie 5 BTC\\") assert len(bc.blocks) == 3 assert bc.blocks[2].data == \\"Bob pays Charlie 5 BTC\\" def test_get_latest_hash(): bc = Blockchain() assert bc.get_latest_hash() == simple_hash('0') bc.add_block(\\"Alice pays Bob 10 BTC\\") assert bc.get_latest_hash() == simple_hash(\\"Alice pays Bob 10 BTC\\" + simple_hash('0')) bc.add_block(\\"Bob pays Charlie 5 BTC\\") assert bc.get_latest_hash() == simple_hash(\\"Bob pays Charlie 5 BTC\\" + simple_hash(\\"Alice pays Bob 10 BTC\\" + simple_hash('0')))","solution":"def simple_hash(s: str) -> str: hash_value = 0 for char in s: hash_value = (hash_value * 31 + ord(char)) % 1_000_000_007 return str(hash_value) class Block: def __init__(self, data: str, prev_hash: str): self.data = data self.prev_hash = prev_hash self.hash = simple_hash(data + prev_hash) class Blockchain: def __init__(self): genesis_block = Block('', '0') self.blocks = [genesis_block] def add_block(self, data: str) -> None: prev_hash = self.blocks[-1].hash new_block = Block(data, prev_hash) self.blocks.append(new_block) def get_latest_hash(self) -> str: return self.blocks[-1].hash"},{"question":"def has_identical_diagonals(matrix): Determine if all diagonals from top-left to bottom-right in a square matrix are identical. >>> has_identical_diagonals([ ... [1, 2, 3], ... [4, 1, 2], ... [5, 4, 1] ... ]) True >>> has_identical_diagonals([ ... [1, 2, 3], ... [5, 1, 2], ... [8, 5, 3] ... ]) False pass # Test cases matrix1 = [ [1, 2, 3], [4, 1, 2], [5, 4, 1] ] matrix2 = [ [1, 2, 3], [5, 1, 2], [8, 5, 3] ] print(has_identical_diagonals(matrix1)) # True print(has_identical_diagonals(matrix2)) # False","solution":"def has_identical_diagonals(matrix): size = len(matrix) if size == 0: # Empty matrix return True # Check diagonals starting from the first row for i in range(size): x, y = 0, i diag_val = matrix[x][y] while x < size and y < size: if matrix[x][y] != diag_val: return False x += 1 y += 1 # Check diagonals starting from the first column (excluding the top-left corner) for i in range(1, size): x, y = i, 0 diag_val = matrix[x][y] while x < size and y < size: if matrix[x][y] != diag_val: return False x += 1 y += 1 return True"},{"question":"def merge_dicts(dicts: List[Dict[Any, Any]]) -> Dict[Any, Any]: Merges a list of dictionaries into a single dictionary. If there are overlapping keys: - Numeric values are added together. - Non-numeric values: the value from the last dictionary is used. >>> merge_dicts([{ 'a': 1, 'b': 2, 'c': 'x' }, { 'a': 2, 'b': 3, 'd': 4 }, { 'a': 1, 'c': 'y', 'e': 5 }]) {'a': 4, 'b': 5, 'c': 'y', 'd': 4, 'e': 5} >>> merge_dicts([{'a': 1}, {'b': 2}, {'c': 3}]) {'a': 1, 'b': 2, 'c': 3} >>> merge_dicts([{'a': 'x'}, {'a': 'y'}]) {'a': 'y'} >>> merge_dicts([{'a': 1, 'b': 'x'}, {'a': 2, 'b': 'y'}]) {'a': 3, 'b': 'y'} >>> merge_dicts([]) {} >>> merge_dicts([{'a': 1, 'b': 2, 'c': 'x'}]) {'a': 1, 'b': 2, 'c': 'x'}","solution":"def merge_dicts(dicts): Merges a list of dictionaries into a single dictionary. If there are overlapping keys: - Numeric values are added together. - Non-numeric values: the value from the last dictionary is used. merged_dict = {} for d in dicts: for key, value in d.items(): if key in merged_dict: if isinstance(merged_dict[key], (int, float)) and isinstance(value, (int, float)): merged_dict[key] += value else: merged_dict[key] = value else: merged_dict[key] = value return merged_dict"},{"question":"def minimumJumps(stones: List[int]) -> int: Determines the minimum number of jumps a frog needs to reach the other side of a river. The frog can jump between different stones in the river, but not all stones are accessible. Each element in the list represents a stone with the maximum length of the jump the frog can make from that stone. A value of 0 means that the frog can't jump from that stone. The goal is to find the minimum number of jumps required to reach the other side of the river. If it's not possible to reach the other side, return -1. >>> minimumJumps([6, 2, 4, 0, 5, 1, 1, 4, 2, 9]) 3 >>> minimumJumps([1, 1, 0, 1]) -1 >>> minimumJumps([1]) 0 >>> minimumJumps([1, 1, 1, 0, 1]) -1 >>> minimumJumps([1000]) 0 >>> minimumJumps([1000, 1]) 1 >>> minimumJumps([5, 3, 0, 1, 1, 0, 1]) -1 >>> minimumJumps([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 4","solution":"def minimumJumps(stones): Determines the minimum number of jumps needed for the frog to cross the river. n = len(stones) if n == 1: return 0 jumps = 0 current_end = 0 farthest = 0 for i in range(n): farthest = max(farthest, i + stones[i]) if i == current_end: jumps += 1 current_end = farthest if current_end >= n: return jumps return -1"},{"question":"def final_value_after_operations(operations: List[str]) -> int: Returns the final value after performing all operations. Each operation is in one of the following two forms: - 'ADD x': This operation increases the current value by \`x\`. - 'MUL y': This operation multiplies the current value by \`y\`. The initial value is always 0. Parameters: operations (List[str]): A list of operations in the form \\"ADD x\\" or \\"MUL y\\". Returns: int: The final value after performing all operations. >>> final_value_after_operations([\\"ADD 5\\", \\"MUL 2\\", \\"ADD 3\\"]) 13 >>> final_value_after_operations([\\"MUL 5\\", \\"ADD 3\\", \\"ADD 2\\", \\"MUL 4\\"]) 20 >>> final_value_after_operations([\\"ADD 1\\", \\"ADD 1\\", \\"ADD 1\\"]) 3 >>> final_value_after_operations([\\"MUL 2\\", \\"MUL 3\\", \\"MUL 4\\"]) 0 >>> final_value_after_operations([\\"ADD 1\\", \\"MUL 10\\", \\"ADD 100\\", \\"MUL 5\\"]) 550 >>> final_value_after_operations([\\"ADD 0\\", \\"MUL 10\\", \\"ADD 100\\"]) 100","solution":"def final_value_after_operations(operations): Returns the final value after performing all operations. Parameters: operations (List[str]): A list of operations in the form \\"ADD x\\" or \\"MUL y\\". Returns: int: The final value after performing all operations. current_value = 0 for operation in operations: op, num = operation.split() num = int(num) if op == 'ADD': current_value += num elif op == 'MUL': current_value *= num return current_value"},{"question":"def can_form_palindrome(s: str) -> str: Determines if the given string can be rearranged to form a palindrome. Args: s (str): The input string consisting of lowercase English letters. Returns: str: \\"Yes\\" if the string can be rearranged into a palindrome, otherwise \\"No\\". >>> can_form_palindrome('civic') == \\"Yes\\" >>> can_form_palindrome('ivicc') == \\"Yes\\" >>> can_form_palindrome('aabb') == \\"Yes\\" >>> can_form_palindrome('abc') == \\"No\\" >>> can_form_palindrome('abcde') == \\"No\\" >>> can_form_palindrome('a') == \\"Yes\\" >>> can_form_palindrome('abccba') == \\"Yes\\" >>> can_form_palindrome('aabbccc') == \\"Yes\\" >>> can_form_palindrome('aaaa') == \\"Yes\\" >>> can_form_palindrome('aab') == \\"Yes\\" >>> can_form_palindrome('aaabbc') == \\"No\\"","solution":"def can_form_palindrome(s): Determines if the given string can be rearranged to form a palindrome. Args: s (str): The input string consisting of lowercase English letters. Returns: str: \\"Yes\\" if the string can be rearranged into a palindrome, otherwise \\"No\\". from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd count if odd_count > 1: return \\"No\\" return \\"Yes\\""},{"question":"def sequences(start, step, length, type): Generate a series of numbers based on the given sequence type. Parameters: start (int): The first number in the sequence. step (int): The difference/product between consecutive numbers or the second number in the fibonacci sequence. length (int): The total number of numbers in the sequence. type (str): The type of sequence to generate. One of \\"arithmetic\\", \\"geometric\\", \\"fibonacci\\". Returns: list: The generated sequence as a list of numbers. >>> sequences(2, 3, 5, \\"arithmetic\\") [2, 5, 8, 11, 14] >>> sequences(2, 3, 5, \\"geometric\\") [2, 6, 18, 54, 162] >>> sequences(0, 1, 5, \\"fibonacci\\") [0, 1, 1, 2, 3] Examples: assert sequences(2, 3, 5, \\"arithmetic\\") == [2, 5, 8, 11, 14] assert sequences(0, 1, 5, \\"arithmetic\\") == [0, 1, 2, 3, 4] assert sequences(1, -1, 5, \\"arithmetic\\") == [1, 0, -1, -2, -3] assert sequences(10, 0, 3, \\"arithmetic\\") == [10, 10, 10] assert sequences(5, 3, 0, \\"arithmetic\\") == [] assert sequences(2, 3, 5, \\"geometric\\") == [2, 6, 18, 54, 162] assert sequences(1, 2, 4, \\"geometric\\") == [1, 2, 4, 8] assert sequences(3, -1, 3, \\"geometric\\") == [3, -3, 3] assert sequences(5, 1, 4, \\"geometric\\") == [5, 5, 5, 5] assert sequences(2, 3, 0, \\"geometric\\") == [] assert sequences(0, 1, 5, \\"fibonacci\\") == [0, 1, 1, 2, 3] assert sequences(1, 1, 5, \\"fibonacci\\") == [1, 1, 2, 3, 5] assert sequences(0, 1, 1, \\"fibonacci\\") == [0] assert sequences(0, 1, 0, \\"fibonacci\\") == [] assert sequences(10, 20, 6, \\"fibonacci\\") == [10, 20, 30, 50, 80, 130] For invalid types: try: sequences(1, 2, 5, \\"invalid\\") except ValueError as e: assert str(e) == \\"Invalid sequence type\\"","solution":"def sequences(start, step, length, type): if length <= 0: return [] if type == \\"arithmetic\\": return [start + i * step for i in range(length)] elif type == \\"geometric\\": return [start * (step ** i) for i in range(length)] elif type == \\"fibonacci\\": if length == 1: return [start] sequence = [start, step] for i in range(2, length): next_value = sequence[-1] + sequence[-2] sequence.append(next_value) return sequence[:length] else: raise ValueError(\\"Invalid sequence type\\")"},{"question":"def maximum_product_of_three(nums: List[int]) -> int: Returns the maximum product of any three numbers from the list. >>> maximum_product_of_three([-10, -10, 5, 2]) == 500 >>> maximum_product_of_three([1, 10, 2, 6, 5, 3]) == 300","solution":"def maximum_product_of_three(nums): Returns the maximum product of any three numbers from the list. if len(nums) < 3: raise ValueError(\\"The input list must have at least three numbers.\\") nums.sort() # The maximum product of three numbers could be either # the product of the three largest numbers, # or the product of the two smallest numbers (both could be negative) and the largest number. return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def count_subarrays_with_sum_k(arr, k): Determine the number of subarrays of \`arr\` such that the sum of the elements in each subarray is equal to \`k\`. >>> count_subarrays_with_sum_k([1, 2, 3, 4, 5], 5) 2 >>> count_subarrays_with_sum_k([1, 1, 1], 2) 2 >>> count_subarrays_with_sum_k([1, -1, 1, -1], 0) 4 >>> count_subarrays_with_sum_k([3, 3, 3, 3], 6) 3 >>> count_subarrays_with_sum_k([1, 2, 3, 4], 10) 1 >>> count_subarrays_with_sum_k([1, 2, 3, 4], 100) 0 >>> count_subarrays_with_sum_k([4], 4) 1 >>> count_subarrays_with_sum_k([1, 1, 1, 1, 1, 1], 3) 4","solution":"def count_subarrays_with_sum_k(arr, k): from collections import defaultdict # This dictionary keeps track of the cumulative sum frequencies cum_sum_freq = defaultdict(int) cum_sum_freq[0] = 1 # Initialize with 0 sum cum_sum = 0 count = 0 for num in arr: cum_sum += num # If cum_sum - k exists in cum_sum_freq, it means there is a subarray that adds up to k if (cum_sum - k) in cum_sum_freq: count += cum_sum_freq[cum_sum - k] # Update the cumulative sum frequency cum_sum_freq[cum_sum] += 1 return count # Example usage: # n, k = 5, 5 # a = [1, 2, 3, 4, 5] # print(count_subarrays_with_sum_k(a, k)) # Output: 2"},{"question":"def product_except_self(nums): Given an integer array nums, return an array of the same length where each element is the product of all the elements of the input array except the element at the same index. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3, 4]) [24, 0, 0, 0, 0] >>> product_except_self([1]) [1] >>> product_except_self([0, 0, 0, 0]) [0, 0, 0, 0] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6]","solution":"def product_except_self(nums): Return an array where each element is the product of all the other elements in the array. length = len(nums) answer = [0] * length # Calculate prefixes and store in answer array answer[0] = 1 for i in range(1, length): answer[i] = nums[i - 1] * answer[i - 1] # Calculate suffixes and update the answer array R = 1 for i in reversed(range(length)): answer[i] = answer[i] * R R *= nums[i] return answer"},{"question":"def minCostClimbingStairs(nums): Returns the minimum cost to reach the top of the floor. >>> minCostClimbingStairs([10, 15, 20]) 15 >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]) 6 def test_example_1(): assert minCostClimbingStairs([10, 15, 20]) == 15 def test_example_2(): assert minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]) == 6 def test_single_step(): assert minCostClimbingStairs([10]) == 10 def test_two_steps(): assert minCostClimbingStairs([10, 15]) == 10 def test_large_nums(): assert minCostClimbingStairs([0, 0, 1, 0]) == 0 def test_all_same(): assert minCostClimbingStairs([1, 1, 1, 1, 1, 1]) == 3 def test_increasing_costs(): assert minCostClimbingStairs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 25","solution":"def minCostClimbingStairs(nums): Returns the minimum cost to reach the top of the floor. n = len(nums) if n == 1: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = nums[1] for i in range(2, n): dp[i] = nums[i] + min(dp[i-1], dp[i-2]) return min(dp[-1], dp[-2]) # because you can either end on the last or second last step"},{"question":"def longest_unique_substring_length(s: str) -> int: Finds the length of the longest substring with unique characters in the given string s. :param s: String input consisting of English letters. :return: The length of the longest unique character substring. >>> longest_unique_substring_length(\\"abcabcbb\\") 3 >>> longest_unique_substring_length(\\"bbbbb\\") 1 >>> longest_unique_substring_length(\\"pwwkew\\") 3 >>> longest_unique_substring_length(\\"\\") 0 >>> longest_unique_substring_length(\\"a\\") 1 >>> longest_unique_substring_length(\\"abcdefg\\") 7 >>> longest_unique_substring_length(\\"abacabad\\") 3 >>> longest_unique_substring_length(\\"aAbBcC\\") 6 >>> longest_unique_substring_length(\\"abcdefghijklmnopqrstuvwxyz\\" * 10) 26","solution":"def longest_unique_substring_length(s): Finds the length of the longest substring with unique characters in the given string s. :param s: String input consisting of English letters. :return: The length of the longest unique character substring. max_len = 0 start = 0 seen_chars = {} for end in range(len(s)): if s[end] in seen_chars: start = max(start, seen_chars[s[end]] + 1) seen_chars[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"class TreeNode: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def find_kth_inorder_node(n, k, nodes): Find the kth node in the inorder traversal of the binary tree. Args: n (int): Number of nodes in the tree. k (int): Position of the node in the inorder traversal. nodes (List[Tuple[int, int, int]]): List of tuples describing each node of the tree. Returns: int: Value of the kth node in the inorder traversal. Example: >>> n, k = 8, 4 >>> nodes = [(5, 3, 7), (3, 2, 4), (2, -1, -1), (4, -1, -1), (7, 6, 8), (6, -1, -1), (8, -1, -1)] >>> find_kth_inorder_node(n, k, nodes) 5","solution":"class TreeNode: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def find_kth_inorder_node(n, k, nodes): # Create a dictionary to store nodes and their children tree = {} for v, l, r in nodes: tree[v] = TreeNode(value=v, left=l if l != -1 else None, right=r if r != -1 else None) # Build the actual tree nodes for node in tree.values(): if node.left is not None: node.left = tree[node.left] if node.right is not None: node.right = tree[node.right] # The root of the tree will be the first node given in the input root = tree[nodes[0][0]] # Inorder traversal to find kth node def inorder_traversal(node): if not node: return [] # Traverse the left subtree, then visit the root, then traverse the right subtree return inorder_traversal(node.left) + [node.value] + inorder_traversal(node.right) inorder_result = inorder_traversal(root) return inorder_result[k - 1] # kth node in 1-indexed # Example usage # n, k = 8, 4 # nodes = [(5, 3, 7), (3, 2, 4), (2, -1, -1), (4, -1, -1), (7, 6, 8), (6, -1, -1), (8, -1, -1)] # print(find_kth_inorder_node(n, k, nodes)) # Output: 5"},{"question":"def rotate_string(s: str, n: int) -> str: Rotates the string s to the right n times. Each rotation moves the last character of the string to the front. For example: >>> rotate_string('abcde', 1) == 'eabcd' >>> rotate_string('abcde', 2) == 'deabc' >>> rotate_string('abcde', 5) == 'abcde' >>> rotate_string('abcde', 7) == 'deabc' Parameters: s (str): The string to rotate. n (int): The number of rotations. Returns: str: The rotated string.","solution":"def rotate_string(s, n): Rotates the string s to the right n times. Each rotation moves the last character of the string to the front. Parameters: s (str): The string to rotate. n (int): The number of rotations. Returns: str: The rotated string. if not s: return s n %= len(s) return s[-n:] + s[:-n]"},{"question":"def is_palindrome(s: str) -> bool: Returns True if the input string is a palindrome, False otherwise. Ignores spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") == True >>> is_palindrome(\\"hello\\") == False >>> is_palindrome(\\"Madam\\") == True >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"12345\\") == False","solution":"import re def is_palindrome(s): Returns True if the input string is a palindrome, False otherwise. Ignores spaces, punctuation, and capitalization. # Remove non-alphanumeric characters and convert to lower case cleaned_string = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the cleaned string reads the same forwards and backwards return cleaned_string == cleaned_string[::-1]"},{"question":"from typing import List def min_steps_to_cut_trees(forest: List[List[int]]) -> int: Given a 2D grid of integers representing a forest, where each cell's value indicates the height of a tree, determine the minimum number of steps required to cut off all the trees in a non-descending order of their heights. You can walk in four directions (up, down, left, right) from one cell to another, and you can only step on cells with a tree or ground (value 0). If it is impossible to cut off all the trees, return -1. You start at the top-left corner of the grid (0, 0) and must walk to each tree in order. Constraints: - m == forest.length - n == forest[i].length - 1 <= m, n <= 50 - 0 <= forest[i][j] <= 10^9 def test_min_steps_to_cut_trees_cases(): forest1 = [ [1,2,3], [0,0,4], [7,6,5] ] forest2 = [ [1,2,3], [0,0,0], [7,6,5] ] forest3 = [ [2,3,4], [0,0,5], [8,7,6] ] forest4 = [ [1, 2, 3, 4] ] forest5 = [ [1], [2], [3], [4] ] forest6 = [ [1, 2, 3], [0, 0, 0], [7, 0, 5] ] assert min_steps_to_cut_trees(forest1) == 6 assert min_steps_to_cut_trees(forest2) == -1 assert min_steps_to_cut_trees(forest3) == 6 assert min_steps_to_cut_trees(forest4) == 3 assert min_steps_to_cut_trees(forest5) == 3 assert min_steps_to_cut_trees(forest6) == -1","solution":"from collections import deque from typing import List, Tuple def min_steps_to_cut_trees(forest: List[List[int]]) -> int: def bfs(start: Tuple[int, int], goal: Tuple[int, int]) -> int: m, n = len(forest), len(forest[0]) visited = set() queue = deque([(start[0], start[1], 0)]) # store (x, y, steps) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: x, y, steps = queue.popleft() if (x, y) == goal: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited: if forest[nx][ny] > 0: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1 trees = sorted((height, r, c) for r, row in enumerate(forest) for c, height in enumerate(row) if height > 1) start = (0, 0) total_steps = 0 for height, r, c in trees: steps = bfs(start, (r, c)) if steps == -1: return -1 total_steps += steps start = (r, c) return total_steps"},{"question":"def convert_to_title(n: int) -> str: Converts a given column number in an Excel sheet to its corresponding column title. >>> convert_to_title(1) 'A' >>> convert_to_title(28) 'AB' >>> convert_to_title(701) 'ZY'","solution":"def convert_to_title(n): Converts a given column number in an Excel sheet to its corresponding column title. result = [] while n > 0: n -= 1 result.append(chr(n % 26 + ord('A'))) n //= 26 return ''.join(result[::-1])"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root: TreeNode) -> int: Given a binary tree, calculate the maximum path sum. A path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. :param root: TreeNode :return: int >>> root1 = TreeNode(1) ... root1.left = TreeNode(2) ... root1.right = TreeNode(3) ... maxPathSum(root1) 6 >>> root2 = TreeNode(-10) ... root2.left = TreeNode(9) ... root2.right = TreeNode(20) ... root2.right.left = TreeNode(15) ... root2.right.right = TreeNode(7) ... maxPathSum(root2) 42 >>> root3 = TreeNode(5) ... maxPathSum(root3) 5 >>> root4 = TreeNode(-3) ... root4.left = TreeNode(-2) ... root4.right = TreeNode(-1) ... maxPathSum(root4) -1 >>> root5 = TreeNode(2) ... root5.left = TreeNode(-1) ... root5.right = TreeNode(3) ... maxPathSum(root5) 5","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root: TreeNode) -> int: def dfs(node): nonlocal max_sum if not node: return 0 # Recursively calculate the maximum path sum of the left and right subtrees left_max = max(dfs(node.left), 0) right_max = max(dfs(node.right), 0) # Calculate the maximum path sum with the current node as the root current_max = node.val + left_max + right_max # Update the global maximum path sum if the current maximum is greater max_sum = max(max_sum, current_max) # Return the maximum sum of a path extending to the parent node return node.val + max(left_max, right_max) max_sum = float('-inf') dfs(root) return max_sum"},{"question":"import math from typing import List def find_perfect_squares(arr: List[int]) -> List[int]: Returns the array of integers that are perfect squares. Args: arr (list of int): The input array of integers. Returns: list of int: A list containing all perfect squares from the input array. Examples: >>> find_perfect_squares([1, 2, 3, 4, 5, 16, 20, 25]) [1, 4, 16, 25] >>> find_perfect_squares([10, 15, 21]) [] >>> find_perfect_squares([9, 1, 36, 8]) [9, 1, 36]","solution":"import math def find_perfect_squares(arr): Returns the array of integers that are perfect squares. Args: arr (list of int): The input array of integers. Returns: list of int: A list containing all perfect squares from the input array. return [x for x in arr if math.isqrt(x) ** 2 == x]"},{"question":"def normalize_scores(t: int, scores: List[int]) -> List[int]: Normalizes the scores according to the rules: - Square the score if it's even - Cube the score if it's odd Returns the normalized scores as a list. >>> normalize_scores(3, [2, 4, 6]) [4, 16, 36] >>> normalize_scores(3, [1, 3, 5]) [1, 27, 125] >>> normalize_scores(5, [2, 3, 4, 5, 6]) [4, 27, 16, 125, 36] >>> normalize_scores(1, [8]) [64] >>> normalize_scores(1, [7]) [343] >>> normalize_scores(3, [0, 2, 3]) [0, 4, 27] >>> normalize_scores(1, [100]) [10000] >>> normalize_scores(1, [0]) [0] >>> normalize_scores(5, [0, 0, 0, 0, 0]) [0, 0, 0, 0, 0]","solution":"def normalize_scores(t, scores): Normalizes the scores according to the rules: - Square the score if it's even - Cube the score if it's odd Returns the normalized scores as a list. result = [] for score in scores: if score % 2 == 0: result.append(score ** 2) else: result.append(score ** 3) return result"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns a list such that each element at index \`i\` of the new list is the product of all the numbers in the original list except the one at \`i\`. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 2, 3, 4]) [24, 0, 0, 0] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0]","solution":"def product_except_self(nums): Returns a list such that each element at index \`i\` of the new list is the product of all the numbers in the original list except the one at \`i\`. length = len(nums) if length == 1: return [1] # List to store the result result = [1] * length # Products to the left left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] # Products to the right and final result combined right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def remove_consecutive_duplicates(arr: List[int]) -> List[int]: Write a function that takes a list of integers as input and returns a list containing only the first integer from each group of consecutive identical integers. >>> remove_consecutive_duplicates([1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 1, 1]) == [1, 2, 3, 4, 5, 1] >>> remove_consecutive_duplicates([1, 1, 1, 1, 1, 1]) == [1] >>> remove_consecutive_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> remove_consecutive_duplicates([]) == [] >>> remove_consecutive_duplicates([7, 7, 8, 8, 9]) == [7, 8, 9] >>> remove_consecutive_duplicates([1]) == [1]","solution":"def remove_consecutive_duplicates(arr): Returns a list containing only the first integer from each group of consecutive identical integers. if not arr: return [] result = [arr[0]] for i in range(1, len(arr)): if arr[i] != arr[i-1]: result.append(arr[i]) return result"},{"question":"def beauty_of_segments(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Determines the beauty of each segment specified in the queries. Parameters: n (int): Number of elements in the array. q (int): Number of queries. array (list of int): The elements of the array. queries (list of tuples): Each tuple contains the starting and ending indices of a segment. Returns: list of int: The beauty of each segment. >>> beauty_of_segments(5, 3, [1, 3, 2, 5, 4], [(1, 3), (2, 5), (1, 5)]) [2, 3, 4] >>> beauty_of_segments(4, 2, [10, 20, 30, 40], [(1, 2), (2, 4)]) [10, 20] >>> beauty_of_segments(6, 1, [8, 12, 16, 24, 32, 48], [(3, 6)]) [32] >>> beauty_of_segments(3, 1, [5, 5, 5], [(1, 3)]) [0] >>> beauty_of_segments(5, 3, [15, 2, 6, 8, 20], [(1, 2), (3, 5), (1, 5)]) [13, 14, 18]","solution":"def beauty_of_segments(n, q, array, queries): Determines the beauty of each segment specified in the queries. Parameters: n (int): Number of elements in the array. q (int): Number of queries. array (list of int): The elements of the array. queries (list of tuples): Each tuple contains the starting and ending indices of a segment. Returns: list of int: The beauty of each segment. beauties = [] for l, r in queries: segment = array[l-1:r] beauty = max(segment) - min(segment) beauties.append(beauty) return beauties # Example usage: # beauty_of_segments(5, 3, [1, 3, 2, 5, 4], [(1, 3), (2, 5), (1, 5)]) # This will yield [2, 3, 4]"},{"question":"def convert_minutes_to_time(minutes: int) -> str: Converts a number of minutes past midnight to 'HH:MM' time format. >>> convert_minutes_to_time(75) \\"01:15\\" >>> convert_minutes_to_time(1445) \\"00:05\\" >>> convert_minutes_to_time(123) \\"02:03\\" >>> convert_minutes_to_time(1440) \\"00:00\\" >>> convert_minutes_to_time(2895) \\"00:15\\"","solution":"def convert_minutes_to_time(minutes): Converts a number of minutes past midnight to 'HH:MM' time format. # Handle spanning multiple days by using modulo with 1440 minutes (24 * 60) total_minutes = minutes % 1440 # Calculate hours and minutes hours = total_minutes // 60 mins = total_minutes % 60 # Return formatted time return f\\"{hours:02}:{mins:02}\\""},{"question":"from typing import List def filter_logs(logs: List[str], start_time: str, end_time: str) -> List[str]: Extracts and returns all status messages that have occurred within a given time range. Parameters: - logs (List[str]): A list of log entries in the format \\"YYYY-MM-DD HH:MM:SS - status_message\\". - start_time (str): The start time in the format \\"YYYY-MM-DD HH:MM:SS\\". - end_time (str): The end time in the same format \\"YYYY-MM-DD HH:MM:SS\\". Returns: - List[str]: A list of status messages within the given time range. >>> logs = [ ... \\"2023-10-01 10:00:00 - System started.\\", ... \\"2023-10-01 10:05:00 - User login.\\", ... \\"2023-10-01 10:10:00 - User logout.\\", ... \\"2023-10-01 10:15:00 - System shut down.\\" ... ] >>> filter_logs(logs, \\"2023-10-01 10:00:00\\", \\"2023-10-01 10:10:00\\") [\\"System started.\\", \\"User login.\\", \\"User logout.\\"] >>> filter_logs([], \\"2023-10-01 10:00:00\\", \\"2023-10-01 10:10:00\\") [] >>> logs = [ ... \\"2023-10-01 09:00:00 - System started.\\", ... \\"2023-10-01 09:05:00 - User login.\\", ... \\"2023-10-01 09:10:00 - User logout.\\", ... \\"2023-10-01 09:15:00 - System shut down.\\" ... ] >>> filter_logs(logs, \\"2023-10-01 10:00:00\\", \\"2023-10-01 10:10:00\\") [] >>> logs = [ ... \\"2023-10-01 10:00:00 - System started.\\", ... \\"2023-10-01 10:05:00 - User login.\\", ... \\"2023-10-01 10:10:00 - User logout.\\", ... \\"2023-10-01 10:15:00 - System shut down.\\" ... ] >>> filter_logs(logs, \\"2023-10-01 10:00:00\\", \\"2023-10-01 10:15:00\\") [\\"System started.\\", \\"User login.\\", \\"User logout.\\", \\"System shut down.\\"] >>> logs = [ ... \\"2023-10-01 09:59:59 - Before start.\\", ... \\"2023-10-01 10:00:00 - System started.\\", ... \\"2023-10-01 10:05:00 - User login.\\", ... \\"2023-10-01 10:10:00 - User logout.\\", ... \\"2023-10-01 10:15:00 - System shut down.\\", ... \\"2023-10-01 10:15:01 - After end.\\" ... ] >>> filter_logs(logs, \\"2023-10-01 10:00:00\\", \\"2023-10-01 10:15:00\\") [\\"System started.\\", \\"User login.\\", \\"User logout.\\", \\"System shut down.\\"]","solution":"from typing import List from datetime import datetime def filter_logs(logs: List[str], start_time: str, end_time: str) -> List[str]: Extracts and returns all status messages that have occurred within a given time range. Parameters: - logs (List[str]): A list of log entries in the format \\"YYYY-MM-DD HH:MM:SS - status_message\\". - start_time (str): The start time in the format \\"YYYY-MM-DD HH:MM:SS\\". - end_time (str): The end time in the same format \\"YYYY-MM-DD HH:MM:SS\\". Returns: - List[str]: A list of status messages within the given time range. start_dt = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_dt = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") filtered_logs = [] for log in logs: timestamp_str, message = log.split(\\" - \\", 1) timestamp_dt = datetime.strptime(timestamp_str, \\"%Y-%m-%d %H:%M:%S\\") if start_dt <= timestamp_dt <= end_dt: filtered_logs.append(message) return filtered_logs"},{"question":"class TextEditor: def __init__(self): self.text = \\"\\" self.operations = [] self.undo_stack = [] def insert_char(self, pos, char): Insert a character at a specific position pass def delete_char(self, pos): Delete a character at a specific position pass def undo(self): Undo the last operation performed pass def redo(self): Redo the last undone operation pass def process_action(self, action): Process an action based on its type (insert, delete, UNDO, REDO) pass def textEditor(operations, action): Perform actions (insert, delete, UNDO, REDO) on text editor. Args: operations (list): List of operations to be processed. action (tuple or str): Action to be performed. Returns: str: The current state of the text after performing the specified action. Examples: >>> textEditor([], ('insert', 0, 'A')) == \\"A\\" >>> textEditor([('insert', 0, 'A')], ('insert', 1, 'B')) == \\"AB\\" >>> textEditor([('insert', 0, 'A'), ('insert', 1, 'B')], 'UNDO') == \\"A\\" >>> textEditor([('insert', 0, 'A')], ('delete', 0)) == \\"\\" >>> textEditor([('insert', 0, 'A'), ('delete', 0)], 'UNDO') == \\"A\\" >>> textEditor([('insert', 0, 'A'), ('delete', 0), 'UNDO'], 'REDO') == \\"\\" pass","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.operations = [] self.undo_stack = [] def insert_char(self, pos, char): self.text = self.text[:pos] + char + self.text[pos:] self.operations.append(('insert', pos, char)) self.undo_stack.clear() def delete_char(self, pos): if 0 <= pos < len(self.text): removed_char = self.text[pos] self.text = self.text[:pos] + self.text[pos+1:] self.operations.append(('delete', pos, removed_char)) self.undo_stack.clear() def undo(self): if not self.operations: return last_op = self.operations.pop() if last_op[0] == 'insert': pos = last_op[1] self.text = self.text[:pos] + self.text[pos+1:] self.undo_stack.append(last_op) elif last_op[0] == 'delete': pos, char = last_op[1], last_op[2] self.text = self.text[:pos] + char + self.text[pos:] self.undo_stack.append(last_op) def redo(self): if not self.undo_stack: return last_undo = self.undo_stack.pop() if last_undo[0] == 'insert': self.insert_char(last_undo[1], last_undo[2]) elif last_undo[0] == 'delete': self.delete_char(last_undo[1]) def process_action(self, action): if isinstance(action, tuple): op_type = action[0] if op_type == 'insert': self.insert_char(action[1], action[2]) elif op_type == 'delete': self.delete_char(action[1]) elif action == 'UNDO': self.undo() elif action == 'REDO': self.redo() return self.text def textEditor(operations, action): editor = TextEditor() for op in operations: editor.process_action(op) return editor.process_action(action)"},{"question":"def remove_duplicates(lst: List[int]) -> List[int]: Removes duplicates from the input list while preserving the order of the first occurrence. >>> remove_duplicates([4, 5, 4, 1, 2, 3, 5, 2, 3]) [4, 5, 1, 2, 3] >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([5, 4, 3, 2, 1, 1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> remove_duplicates([]) [] >>> remove_duplicates([1, 1, 1, 1, 1]) [1]","solution":"def remove_duplicates(lst): Removes duplicates from the input list while preserving the order of the first occurrence. seen = set() result = [] for number in lst: if number not in seen: seen.add(number) result.append(number) return result"},{"question":"def calculate_spam_emails(T: int, cases: List[Dict[str, Any]]) -> List[int]: Determine how many emails are classified as spam. Args: T: int - Number of test cases. cases: List[Dict[str, Any]] - List of dictionaries with keys 'meta', 'keywords', and 'emails'. 'meta': Tuple containing (N, M, S), where N is the number of emails, M is the number of predefined keywords, and S is the spam score threshold. 'keywords': List of tuples containing (keyword, weight). 'emails': List of strings containing the content of each email. Returns: List[int] - List of integers where each integer represents the number of emails classified as spam for the test case. >>> calculate_spam_emails(1, [{'meta': (2, 3, 10), 'keywords': [('offer', 4), ('free', 5), ('win', 3)], 'emails': ['free offer now', 'you can win this']}]) == [0] >>> calculate_spam_emails(1, [{'meta': (1, 2, 5), 'keywords': [('spam', 3), ('alert', 4)], 'emails': ['spam alert here']}]) == [1]","solution":"def calculate_spam_emails(T, cases): result = [] for i in range(T): N, M, S = cases[i]['meta'] keywords = cases[i]['keywords'] emails = cases[i]['emails'] keyword_weights = {kw[0]: kw[1] for kw in keywords} spam_count = 0 for email in emails: spam_score = sum(keyword_weights.get(word, 0) for word in email.split()) if spam_score > S: spam_count += 1 result.append(spam_count) return result"},{"question":"from typing import List, Tuple def add_binary_strings(s1: str, s2: str) -> str: Returns the sum of two binary strings s1 and s2 without converting them to decimal form. # Implement the function to add two binary strings here pass def sum_binary_test_cases(test_cases: List[Tuple[str, str]]) -> List[str]: Given a list of test cases (each a tuple of two binary strings), return a list of the sums of each pair. # Implement the function that processes multiple test cases here pass def test_add_binary_strings(): assert add_binary_strings('1101', '101') == '10010' assert add_binary_strings('11', '1') == '100' assert add_binary_strings('1010', '1011') == '10101' assert add_binary_strings('1', '1') == '10' assert add_binary_strings('111', '1') == '1000' assert add_binary_strings('0', '0') == '0' assert add_binary_strings('100', '1100100') == '1101000' assert add_binary_strings('1010101010', '1010101010') == '10101010100' def test_sum_binary_test_cases(): test_cases = [('1101', '101'), ('11', '1'), ('1010', '1011')] results = ['10010', '100', '10101'] assert sum_binary_test_cases(test_cases) == results test_cases = [('1', '1'), ('111', '1'), ('0', '0'), ('100', '1100100')] results = ['10', '1000', '0', '1101000'] assert sum_binary_test_cases(test_cases) == results","solution":"def add_binary_strings(s1, s2): Returns the sum of two binary strings s1 and s2 without converting them to decimal form. max_len = max(len(s1), len(s2)) # Ensure both strings are of the same length by padding with leading zeros s1 = s1.zfill(max_len) s2 = s2.zfill(max_len) # Initialize the result result = '' # Initialize the carry carry = 0 # Traverse the two strings for i in range(max_len - 1, -1, -1): # Sum the bits from s1 and s2 plus the carry current_sum = carry + int(s1[i]) + int(s2[i]) # If current_sum is 2 or 3, set carry to 1, otherwise to 0 carry = current_sum >> 1 # Append computed bit to the result result = str(current_sum & 1) + result # If there's still a carry left, append it to the result if carry: result = '1' + result return result def sum_binary_test_cases(test_cases): Given a list of test cases (each a tuple of two binary strings), return a list of the sums of each pair. results = [] for s1, s2 in test_cases: results.append(add_binary_strings(s1, s2)) return results"},{"question":"def is_valid_parentheses(s: str) -> bool: Determines if the given string of parentheses is valid. Args: s (str): The input string containing parentheses and possibly other characters. Returns: bool: True if the string is valid, False otherwise. Examples: >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"()[]{}\\") True >>> is_valid_parentheses(\\"(]\\") False >>> is_valid_parentheses(\\"([)]\\") False >>> is_valid_parentheses(\\"{[]}\\") True","solution":"def is_valid_parentheses(s: str) -> bool: Determines if the given string of parentheses is valid. Args: s (str): The input string containing parentheses and possibly other characters. Returns: bool: True if the string is valid, False otherwise. stack = [] matching_parentheses = {')': '(', ']': '[', '}': '{'} for char in s: if char in matching_parentheses.values(): # opening brackets stack.append(char) elif char in matching_parentheses.keys(): # closing brackets if stack == [] or matching_parentheses[char] != stack.pop(): return False return stack == []"},{"question":"def create_zigzag_matrix(N, M): Creates a Zigzag Matrix of dimensions N x M. >>> create_zigzag_matrix(3, 4) [[1, 2, 3, 4], [8, 7, 6, 5], [9, 10, 11, 12]] >>> create_zigzag_matrix(2, 2) [[1, 2], [4, 3]] def zigzag_matrices(test_cases): Generates Zigzag Matrices for given test cases. >>> test_cases = [(3, 4), (2, 2)] >>> zigzag_matrices(test_cases) [[[1, 2, 3, 4], [8, 7, 6, 5], [9, 10, 11, 12]], [[1, 2], [4, 3]]]","solution":"def create_zigzag_matrix(N, M): matrix = [[0]*M for _ in range(N)] num = 1 for i in range(N): if i % 2 == 0: for j in range(M): matrix[i][j] = num num += 1 else: for j in range(M-1, -1, -1): matrix[i][j] = num num += 1 return matrix def zigzag_matrices(test_cases): results = [] for N, M in test_cases: matrix = create_zigzag_matrix(N, M) results.append(matrix) return results"},{"question":"def greatest_difference(lst: List[int]) -> int: Returns the greatest difference between any two integers in the list. >>> greatest_difference([1, 2, 3, 8, 9]) 8 >>> greatest_difference([5, 1, -10, 5, 10]) 20 >>> greatest_difference([-10, -20, -30, -40, -50]) 40 >>> greatest_difference([10, 20, 30, 40, 50]) 40 >>> greatest_difference([0, 5, -5, 10, -10]) 20 >>> greatest_difference([5, 5, 5, 5, 5]) 0","solution":"def greatest_difference(lst): Returns the greatest difference between any two integers in the list. return max(lst) - min(lst)"},{"question":"from typing import List, Dict def count_tlds(domains: List[str]) -> Dict[str, int]: Counts the number of unique domains for each top-level domain (TLD). Args: domains (List[str]): A list of domain names. Returns: Dict[str, int]: A dictionary where keys are TLDs and values are counts of unique domain names by TLD. Example: >>> count_tlds([ ... \\"example.com\\", ... \\"test.org\\", ... \\"domain.net\\", ... \\"anotherexample.com\\", ... \\"test.org\\", ... \\"website.com\\" ... ]) {\\".com\\": 3, \\".org\\": 1, \\".net\\": 1} pass","solution":"from typing import List, Dict def count_tlds(domains: List[str]) -> Dict[str, int]: Counts the number of unique domains for each top-level domain (TLD). tld_count = {} unique_domains = set() for domain in domains: domain = domain.lower() tld = f\\".{domain.split('.')[-1]}\\" if domain not in unique_domains: unique_domains.add(domain) if tld in tld_count: tld_count[tld] += 1 else: tld_count[tld] = 1 return tld_count"},{"question":"def max_profit(prices): Calculate the maximum profit possible from the list of stock prices while adhering to the buy-sell rules. Parameters: prices (list[int]): List of stock prices where prices[i] is the price of a given stock on day i. Returns: int: The maximum profit that can be achieved. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) 7 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([7, 6, 4, 3, 1]) 0 from solution import max_profit def test_max_profit_case_1(): assert max_profit([7, 1, 5, 3, 6, 4]) == 7 def test_max_profit_case_2(): assert max_profit([1, 2, 3, 4, 5]) == 4 def test_max_profit_case_3(): assert max_profit([7, 6, 4, 3, 1]) == 0 def test_max_profit_empty(): assert max_profit([]) == 0 def test_max_profit_single_day(): assert max_profit([5]) == 0 def test_max_profit_no_profit(): assert max_profit([2, 1, 2, 0, 1]) == 2 def test_max_profit_only_profits(): assert max_profit([1, 2, 3, 4, 5, 6, 7]) == 6 def test_max_profit_complex_case(): assert max_profit([6, 1, 3, 2, 4, 7, 3, 8, 0, 3]) == 15","solution":"def max_profit(prices): Calculates the maximum profit from a list of stock prices. Parameters: prices (list[int]): List of stock prices. Returns: int: Maximum profit. max_profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"def look_and_say(n: int) -> str: Function to return the nth term of the look-and-say sequence. >>> look_and_say(1) \\"1\\" >>> look_and_say(4) \\"1211\\" >>> look_and_say(6) \\"312211\\"","solution":"def look_and_say(n: int) -> str: Function to return the nth term of the look-and-say sequence. if n == 1: return \\"1\\" def next_term(term: str) -> str: Generate the next term in the look-and-say sequence given the current term. result = [] i = 0 while i < len(term): count = 1 while i + 1 < len(term) and term[i] == term[i + 1]: i += 1 count += 1 result.append(f\\"{count}{term[i]}\\") i += 1 return ''.join(result) current_term = \\"1\\" for _ in range(1, n): current_term = next_term(current_term) return current_term"},{"question":"def encode_string(s: str) -> str: Encodes a string replacing each character with its 1-based alphabet position. Each numeric value is separated by a hyphen. >>> encode_string(\\"abc\\") \\"1-2-3\\" >>> encode_string(\\"hello\\") \\"8-5-12-12-15\\" >>> encode_string(\\"xyz\\") \\"24-25-26\\" >>> encode_string(\\"a\\") \\"1\\" >>> encode_string(\\"\\") \\"\\" pass","solution":"def encode_string(s): Encodes a string replacing each character with its 1-based alphabet position. Each numeric value is separated by a hyphen. return \\"-\\".join(str(ord(char) - ord('a') + 1) for char in s)"},{"question":"def max_subarray_column(matrix: [[int]]) -> int: Returns the maximum sum of the subarray that can be formed by taking a full section of any column in any number of consecutive rows. >>> max_subarray_column([ [1, 2, -1, 4], [-3, 4, 5, -2], [3, -2, 2, 1], [2, -3, -2, 3] ]) 7 >>> max_subarray_column([ [-1, -1], [-3, -2], [-1, -4], [-1, -5] ]) -1","solution":"def max_subarray_column(matrix: [[int]]) -> int: Returns the maximum sum of the subarray that can be formed by taking a full section of any column in any number of consecutive rows. if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) max_sum = float('-inf') for col in range(cols): for start_row in range(rows): current_sum = 0 for end_row in range(start_row, rows): current_sum += matrix[end_row][col] max_sum = max(max_sum, current_sum) return max_sum # Example: # matrix = [ # [1, 2, -1, 4], # [-3, 4, 5, -2], # [3, -2, 2, 1], # [2, -3, -2, 3] # ] # max_subarray_column(matrix) should return 7"},{"question":"def max_pair_product(nums: List[int]) -> int: Returns the product of the largest pair of integers in the list. If the list has fewer than two integers, return None. >>> max_pair_product([3, 5, 1, 7, 9]) 63 >>> max_pair_product([1]) None >>> max_pair_product([12, 4, 6]) 72","solution":"def max_pair_product(nums): Returns the product of the largest pair of integers in the list. If the list has fewer than two integers, return None. if len(nums) < 2: return None # Sorting the list in descending order to find the two largest numbers nums.sort(reverse=True) return nums[0] * nums[1]"},{"question":"def filter_by_prefix(strings: List[str], prefix: str) -> List[str]: Filters the list of strings to only include those that start with the prefix. The matching is case-insensitive. >>> filter_by_prefix(['apple', 'banana', 'apricot', 'grape'], 'ap') == ['apple', 'apricot'] >>> filter_by_prefix(['Apple', 'banana', 'Apricot', 'grape'], 'ap') == ['Apple', 'Apricot'] >>> filter_by_prefix(['apple', 'banana', 'apricot', 'grape'], '') == ['apple', 'banana', 'apricot', 'grape'] >>> filter_by_prefix(['123start', 'banana', '!prefix', 'dollar'], '123') == ['123start']","solution":"def filter_by_prefix(strings, prefix): Filters the list of strings to only include those that start with the prefix. The matching is case-insensitive. Args: strings (list of str): The list of strings to filter. prefix (str): The prefix to match. Returns: list of str: A list containing only the strings from the original list that start with the prefix. prefix_lower = prefix.lower() return [string for string in strings if string.lower().startswith(prefix_lower)]"},{"question":"def longest_substring_with_k_distinct_characters(T: int, test_cases: List[Tuple[int, str]]) -> List[int]: Determine the length of the longest substring in a given string that contains at most K distinct characters. Parameters: T (int): Number of test cases. test_cases (List[Tuple[int, str]]): A list containing tuples with each tuple holding an integer K and a string S. Returns: List[int]: A list of integers indicating the length of the longest substring for each test case. Example: >>> longest_substring_with_k_distinct_characters(2, [(2, \\"eceba\\"), (3, \\"aaabbcc\\")]) [3, 7]","solution":"def longest_substring_with_k_distinct_characters(T, test_cases): from collections import defaultdict def longest_substring(S, K): n = len(S) if n == 0 or K == 0: return 0 left, right = 0, 0 char_count = defaultdict(int) max_len = 0 distinct_count = 0 while right < n: char_count[S[right]] += 1 if char_count[S[right]] == 1: distinct_count += 1 while distinct_count > K: char_count[S[left]] -= 1 if char_count[S[left]] == 0: distinct_count -= 1 left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len results = [] for i in range(T): K = int(test_cases[i][0]) S = test_cases[i][1] results.append(longest_substring(S, K)) return results"},{"question":"from typing import List def process_queries(n: int, arr: List[int], queries: List[List[int]]) -> List[int]: Process a list of queries on an array of integers. Args: n (int): The number of elements in the array. arr (List[int]): The list of elements in the array. queries (List[List[int]]): The list of queries where each query is represented as a list. Returns: List[int]: Results of the queries that request information (not updates). The possible queries are: 1. Report the value at index i: [1, i] 2. Update the value at index i to v: [2, i, v] 3. Report the sum of the subarray from l to r inclusive: [3, l, r] >>> process_queries(5, [1, 2, 3, 4, 5], [[1, 2], [3, 1, 3], [2, 4, 10]]) [3, 6] >>> process_queries(1, [1], [[1, 0], [2, 0, 10], [1, 0]]) [1, 10]","solution":"def process_queries(n, arr, queries): results = [] for query in queries: if query[0] == 1: # Report the value at index i idx = query[1] results.append(arr[idx]) elif query[0] == 2: # Update the value at index i to v idx = query[1] value = query[2] arr[idx] = value elif query[0] == 3: # Report the sum of the subarray from l to r inclusive l = query[1] r = query[2] results.append(sum(arr[l:r+1])) return results"},{"question":"def kth_perfect_number(k: int) -> int: Generates the k-th perfect number. A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding itself. Args: k (int): The ordinal position of the perfect number to find. Returns: int: The k-th perfect number. Examples: >>> kth_perfect_number(1) 6 >>> kth_perfect_number(2) 28 >>> kth_perfect_number(3) 496 >>> kth_perfect_number(4) 8128 pass def test_kth_perfect_number_1(): assert kth_perfect_number(1) == 6 def test_kth_perfect_number_2(): assert kth_perfect_number(2) == 28 def test_kth_perfect_number_3(): assert kth_perfect_number(3) == 496 def test_kth_perfect_number_4(): assert kth_perfect_number(4) == 8128","solution":"def is_perfect_number(num): Checks if a given number is a perfect number. if num < 2: return False divisors_sum = 1 for i in range(2, int(num**0.5) + 1): if num % i == 0: divisors_sum += i if i != num // i: divisors_sum += num // i return divisors_sum == num def kth_perfect_number(k): Returns the k-th perfect number. count = 0 num = 1 while True: if is_perfect_number(num): count += 1 if count == k: return num num += 1"},{"question":"def find_intersection(arr1, arr2): Returns the intersection of two arrays including duplicates. >>> find_intersection([1, 2, 2, 1], [2, 2]) [2, 2] >>> find_intersection([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9] >>> find_intersection([1, 2, 3], [4, 5, 6]) [] >>> find_intersection([1, 1, 2, 2, 3], [1, 1, 2, 4]) [1, 1, 2] >>> find_intersection([1, 2, 3], [3, 2, 1]) [1, 2, 3] >>> find_intersection([], [1, 2, 3]) [] >>> find_intersection([1, 2, 3], []) [] >>> find_intersection([], []) []","solution":"def find_intersection(arr1, arr2): Returns the intersection of two arrays including duplicates. # Dictionary to count the elements in arr1 counts = {} for num in arr1: if num in counts: counts[num] += 1 else: counts[num] = 1 # List to store the intersection intersection = [] for num in arr2: if num in counts and counts[num] > 0: intersection.append(num) counts[num] -= 1 return intersection"},{"question":"def sum_even_sequence(n): Returns the sum of all even numbers in the Fibonacci sequence up to but not exceeding n. If n is not an integer, returns \\"Invalid input\\". If n is negative, returns 0. >>> sum_even_sequence(10) 10 >>> sum_even_sequence(34) 44 >>> sum_even_sequence(100) 44 >>> sum_even_sequence(-10) 0 >>> sum_even_sequence(3.14) \\"Invalid input\\" >>> sum_even_sequence(\\"eight\\") \\"Invalid input\\"","solution":"def sum_even_sequence(n): Returns the sum of all even numbers in the Fibonacci sequence up to but not exceeding n. If n is not an integer, returns \\"Invalid input\\". If n is negative, returns 0. if not isinstance(n, int): return \\"Invalid input\\" if n < 0: return 0 sum_even = 0 a, b = 0, 1 # Initializing the first two numbers of the Fibonacci sequence while b <= n: if b % 2 == 0: sum_even += b a, b = b, a + b return sum_even"},{"question":"from typing import List from collections import Counter def max_partitions(nums: List[int], k: int) -> int: Returns the maximum number of times nums can be partitioned into subarrays of at least length k such that each subarray contains the same integer. >>> max_partitions([3, 3, 3, 3, 3, 3, 3], 3) 2 >>> max_partitions([1, 2, 1, 2, 1, 2, 1], 2) 3 >>> max_partitions([5, 5, 5, 6, 6, 6, 6], 4) 1 >>> max_partitions([1, 2, 3, 4, 5], 2) 0","solution":"def max_partitions(nums, k): Returns the maximum number of times nums can be partitioned into subarrays of at least length k such that each subarray contains the same integer. from collections import Counter # Count the occurrences of each integer in the array count = Counter(nums) # Initialize the result for partitions result = 0 # For each unique number, calculate the maximum subarrays for num in count: result += count[num] // k return result"},{"question":"def max_profit(prices): This function takes a list of stock prices and returns the maximum profit that can be achieved from one buy-sell transaction. If no profit can be achieved, it returns 0. pass # Replace this line with your code def solve(test_cases): This function takes a list of test cases, where each test case consists of a list of stock prices. It returns a list of results, one for each test case, representing the maximum profit that can be achieved from one buy-sell transaction for that test case's prices. pass # Replace this line with your code # Example test cases def test_max_profit(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 assert max_profit([7, 6, 4, 3, 1]) == 0 assert max_profit([3, 3, 3, 3, 3, 3]) == 0 assert max_profit([1, 2]) == 1 assert max_profit([2, 4, 1]) == 2 assert max_profit([2, 1, 4]) == 3 assert max_profit([]) == 0 assert max_profit([2]) == 0 def test_solve(): test_cases = [ ([7, 1, 5, 3, 6, 4], [5]), ([7, 6, 4, 3, 1], [0]), ([1, 2, 3, 4, 5], [4]), ([5, 4, 3, 2, 1], [0]) ] assert solve([case[0] for case in test_cases]) == [5, 0, 4, 0] assert solve([ [7, 1, 5, 3, 6, 4], [7, 6, 4, 3, 1] ]) == [5, 0] assert solve([[1, 2, 3, 4, 5]]) == [4] assert solve([[5, 4, 3, 2, 1]]) == [0]","solution":"def max_profit(prices): This function takes a list of stock prices and returns the maximum profit that can be achieved from one buy-sell transaction. If no profit can be achieved, it returns 0. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit def solve(test_cases): results = [] for prices in test_cases: results.append(max_profit(prices)) return results"},{"question":"def nth_prime(n: int) -> int: Returns the nth prime number. >>> nth_prime(1) == 2 >>> nth_prime(5) == 11 >>> nth_prime(10) == 29 >>> nth_prime(20) == 71","solution":"def nth_prime(n): Returns the nth prime number. Parameters: n (int): The position of the prime number to find. Returns: int: The nth prime number. if n < 1: raise ValueError(\\"n must be greater than 0\\") primes = [] candidate = 2 while len(primes) < n: is_prime = all(candidate % p != 0 for p in primes) if is_prime: primes.append(candidate) candidate += 1 return primes[n-1]"},{"question":"def fruits_for_visitors(T: int, cases: list) -> list: Determines how many fruits each visitor can pick from the park based on given constraints. Args: T (int): Number of test cases. cases (list): A list containing information for each test case. Returns: list: A list of lists, where each inner list contains the number of fruits picked by each visitor.","solution":"def fruits_for_visitors(T, cases): Determines how many fruits each visitor can pick from the park based on given constraints. Args: T (int): Number of test cases. cases (list): A list containing information for each test case. Returns: list: A list of lists, where each inner list contains the number of fruits picked by each visitor. results = [] for case in cases: N, F = case[0] fruits = case[1] M = case[2] visitors = case[3] case_result = [] for visitor in visitors: tree_index = visitor - 1 # converting to 0-based index pickable_fruits = min(fruits[tree_index], F) case_result.append(pickable_fruits) fruits[tree_index] -= pickable_fruits results.append(case_result) return results"},{"question":"def common_elements(matrix: List[List[int]]) -> List[int]: Returns a list of integers that appear in each row of the matrix. >>> common_elements([[1, 2, 3, 4, 5], [2, 4, 5, 8, 10], [2, 4, 8, 9, 12], [4, 8, 12, 16, 20]]) == [4] >>> common_elements([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [] >>> common_elements([[1, 3, 4, 7, 9], [1, 2, 4, 5, 9], [1, 3, 4, 9, 10]]) == [1, 4, 9] >>> common_elements([[2, 3], [2, 3, 4], [2, 3, 6], [2, 3, 8]]) == [2, 3]","solution":"def common_elements(matrix): Returns a list of integers that appear in each row of the matrix. Parameters: matrix (list of list of int): 2D list where each row is a sorted list of integers. Returns: list of int: List of integers that appear in each row. if not matrix or not matrix[0]: return [] common_elements = set(matrix[0]) for row in matrix[1:]: common_elements.intersection_update(row) return sorted(common_elements)"},{"question":"def longest_balanced_substring(s: str) -> int: Returns the length of the longest balanced substring in a string consisting only of 'a' and 'b'. A balanced substring is defined as a substring where the number of occurrences of 'a' and 'b' are equal. >>> longest_balanced_substring(\\"aababb\\") 6 >>> longest_balanced_substring(\\"abab\\") 4 >>> longest_balanced_substring(\\"aaaa\\") 0 from solution import longest_balanced_substring def test_example_cases(): assert longest_balanced_substring(\\"aababb\\") == 6 assert longest_balanced_substring(\\"abab\\") == 4 assert longest_balanced_substring(\\"aaaa\\") == 0 def test_no_balanced(): assert longest_balanced_substring(\\"aaaa\\") == 0 assert longest_balanced_substring(\\"bbbbb\\") == 0 def test_all_balanced(): assert longest_balanced_substring(\\"ab\\" * 50000) == 100000 def test_mixed(): assert longest_balanced_substring(\\"aaabbb\\") == 6 assert longest_balanced_substring(\\"aabab\\") == 4 def test_single_character(): assert longest_balanced_substring(\\"a\\") == 0 assert longest_balanced_substring(\\"b\\") == 0 def test_min_length_balanced(): assert longest_balanced_substring(\\"ab\\") == 2 assert longest_balanced_substring(\\"ba\\") == 2","solution":"def longest_balanced_substring(s): Returns the length of the longest balanced substring in a string consisting only of 'a' and 'b'. A balanced substring is defined as a substring where the number of occurrences of 'a' and 'b' are equal. max_length = 0 balance = 0 balance_map = {0: -1} # To handle the case when the whole string from the beginning is balanced for i, char in enumerate(s): if char == 'a': balance += 1 else: # char == 'b' balance -= 1 if balance in balance_map: max_length = max(max_length, i - balance_map[balance]) else: balance_map[balance] = i return max_length"},{"question":"from typing import List def shortest_path_in_grid(N: int, M: int, grid: List[List[str]]) -> int: Find the shortest path from the top-left corner to the bottom-right corner of the grid. The grid contains empty spaces ('.') and obstacles ('#'). You may move up, down, left, or right but cannot move through obstacles. If there is no valid path, return -1. >>> shortest_path_in_grid(5, 5, [ ... ['.', '.', '.', '.', '.'], ... ['.', '#', '#', '#', '.'], ... ['.', '.', '.', '#', '.'], ... ['.', '#', '.', '.', '.'], ... ['.', '.', '.', '#', '.']]) == 9 True >>> shortest_path_in_grid(3, 3, [ ... ['.', '#', '.'], ... ['#', '.', '#'], ... ['.', '#', '.']]) == -1 True >>> shortest_path_in_grid(1, 1, [ ... ['.']]) == 1 True >>> shortest_path_in_grid(3, 3, [ ... ['.', '#', '.'], ... ['.', '.', '.'], ... ['.', '#', '.']]) == 5 True >>> shortest_path_in_grid(3, 2, [ ... ['.', '.'], ... ['#', '#'], ... ['.', '.']]) == -1 True","solution":"from collections import deque def shortest_path_in_grid(N, M, grid): if not grid or grid[0][0] == '#' or grid[N-1][M-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == N-1 and y == M-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def max_operations_to_palindrome(s: str, k: int) -> int: Given a string s and an integer k, returns the minimum number of operations needed to make the string a palindrome by reversing any substring. Parameters: s (str): The input string k (int): The maximum length of the substring that can be reversed at once Returns: int: The minimum number of operations to make the string a palindrome Examples: >>> max_operations_to_palindrome(\\"ababa\\", 1) 0 >>> max_operations_to_palindrome(\\"abcd\\", 2) 2 >>> max_operations_to_palindrome(\\"a\\", 1) 0 >>> max_operations_to_palindrome(\\"racecar\\", 3) 0 >>> max_operations_to_palindrome(\\"abccba\\", 2) 0 >>> max_operations_to_palindrome(\\"abcde\\", 3) 2","solution":"def max_operations_to_palindrome(s: str, k: int) -> int: Given a string s and an integer k, returns the minimum number of operations needed to make the string a palindrome by reversing any substring. Parameters: s (str): The input string k (int): The maximum length of the substring that can be reversed at once Returns: int: The minimum number of operations to make the string a palindrome n = len(s) dp = [[0] * n for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]) return (dp[0][n - 1] + k - 1) // k"},{"question":"from sympy import isprime def count_prime_pairs(n: int) -> int: Returns the number of distinct pairs of prime numbers (p1, p2) such that p1 + p2 = n. >>> count_prime_pairs(10) 2 >>> count_prime_pairs(12) 1 >>> count_prime_pairs(15) 1 >>> count_prime_pairs(27) 0 >>> count_prime_pairs(2) 0 >>> count_prime_pairs(100) 0 # Example test for large number >>> count_prime_pairs(4) 1","solution":"from sympy import isprime def count_prime_pairs(n): Returns the number of distinct pairs of prime numbers (p1, p2) such that p1 + p2 = n. count = 0 for i in range(2, n//2 + 1): p1, p2 = i, n - i if isprime(p1) and isprime(p2): count += 1 return count"},{"question":"from typing import List def word_ladder(beginWord: str, endWord: str, wordList: List[str]) -> int: Compute the length of shortest transformation sequence from beginWord to endWord. >>> word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) 0","solution":"from collections import deque from typing import List def word_ladder(beginWord: str, endWord: str, wordList: List[str]) -> int: def add_next_words(word, word_set, queue, visited): for i in range(len(word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = word[:i] + c + word[i + 1:] if next_word in word_set and next_word not in visited: visited.add(next_word) queue.append((next_word, steps + 1)) if endWord not in wordList: return 0 word_set = set(wordList) queue = deque([(beginWord, 1)]) visited = set([beginWord]) while queue: current_word, steps = queue.popleft() if current_word == endWord: return steps add_next_words(current_word, word_set, queue, visited) return 0"},{"question":"def reverse_words_in_sentence(sentence: str) -> str: Returns a sentence with the words reversed in order while keeping the characters in each word the same. If the input is an empty string, it returns an empty string. >>> reverse_words_in_sentence(\\"Hello world\\") \\"world Hello\\" >>> reverse_words_in_sentence(\\"The quick brown fox\\") \\"fox brown quick The\\" >>> reverse_words_in_sentence(\\"\\") \\"\\" >>> reverse_words_in_sentence(\\"Hello world\\") \\"world Hello\\" >>> reverse_words_in_sentence(\\"Hello, world!\\") \\"world! Hello,\\"","solution":"def reverse_words_in_sentence(sentence): Returns a sentence with the words reversed in order while keeping the characters in each word the same. If the input is an empty string, it returns an empty string. if not sentence: return \\"\\" words = sentence.split() reversed_sentence = ' '.join(reversed(words)) return reversed_sentence"},{"question":"from typing import List def find_longest_subsequence(nums: List[int]) -> List[int]: Write a function find_longest_subsequence that takes a list of integers and returns the longest subsequence of consecutive integers. If there are multiple subsequences of the same length, return the one that appears first in the list. >>> find_longest_subsequence([1, 9, 3, 10, 4, 20, 2]) [1, 2, 3, 4] >>> find_longest_subsequence([36, 41, 56, 35, 44, 33, 34, 92, 43, 32]) [32, 33, 34, 35, 36] >>> find_longest_subsequence([1, 2, 9, 4, 5, 3]) [1, 2, 3, 4, 5] >>> find_longest_subsequence([]) [] >>> find_longest_subsequence([5]) [5] >>> find_longest_subsequence([10, 30]) [10] >>> find_longest_subsequence([1, 3, 2, 6, 5, 4, 7]) [1, 2, 3, 4, 5, 6, 7] >>> find_longest_subsequence([1, 2, 4, 5, 9, 10, 11, 12]) [9, 10, 11, 12]","solution":"def find_longest_subsequence(nums): if not nums: return [] nums = sorted(set(nums)) longest_subseq = [] current_subseq = [nums[0]] for i in range(1, len(nums)): if nums[i] == nums[i-1] + 1: current_subseq.append(nums[i]) else: if len(current_subseq) > len(longest_subseq): longest_subseq = current_subseq current_subseq = [nums[i]] if len(current_subseq) > len(longest_subseq): longest_subseq = current_subseq return longest_subseq"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def isBalanced(root: TreeNode) -> bool: Determines if a given binary tree is height-balanced. A tree is considered balanced if the depth of the two subtrees of every node never differs by more than 1. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> isBalanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> root.left.left.right = TreeNode(4) >>> isBalanced(root) False >>> root = None >>> isBalanced(root) True","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def isBalanced(root: TreeNode) -> bool: def check_depth(node): if not node: return 0, True left_depth, left_balanced = check_depth(node.left) right_depth, right_balanced = check_depth(node.right) current_balanced = left_balanced and right_balanced and abs(left_depth - right_depth) <= 1 current_depth = 1 + max(left_depth, right_depth) return current_depth, current_balanced _, balanced = check_depth(root) return balanced"},{"question":"def histogram_equalization(image): Perform histogram equalization on a given grayscale image represented as a 2D list of integers. >>> image = [ ... [0, 0, 0, 0], ... [255, 255, 255, 255], ... [127, 127, 127, 127], ... [63, 63, 63, 63] ... ] >>> histogram_equalization(image) [[0, 0, 0, 0], [255, 255, 255, 255], [170, 170, 170, 170], [85, 85, 85, 85]] >>> image = [ ... [50, 50], ... [50, 50] ... ] >>> histogram_equalization(image) [[255, 255], [255, 255]] >>> image = [ ... [52, 55, 61, 59], ... [79, 61, 76, 61], ... [62, 59, 55, 104], ... [94, 85, 59, 71] ... ] >>> equalized_image = histogram_equalization(image) >>> all(len(row) == 4 for row in equalized_image) True >>> image = [[50]] >>> histogram_equalization(image) [[255]] >>> image = [ ... [0, 1, 0, 1], ... [1, 0, 1, 0], ... [0, 1, 0, 1], ... [1, 0, 1, 0] ... ] >>> histogram_equalization(image) [[0, 255, 0, 255], [255, 0, 255, 0], [0, 255, 0, 255], [255, 0, 255, 0]]","solution":"def histogram_equalization(image): from itertools import accumulate # Flatten the 2D image into a 1D list flattened = [pixel for row in image for pixel in row] # Compute the histogram histogram = [0] * 256 for pixel in flattened: histogram[pixel] += 1 # Compute the cumulative distribution function (CDF) cdf = list(accumulate(histogram)) # Normalize the CDF cdf_min = min(cdf) cdf_max = max(cdf) cdf_normalized = [(c - cdf_min) / (len(flattened) - cdf_min) * 255 for c in cdf] cdf_normalized = [round(c) for c in cdf_normalized] # Apply the normalized CDF to the original image equalized_image = [ [cdf_normalized[pixel] for pixel in row] for row in image ] return equalized_image"},{"question":"def roman_to_integer(roman: str) -> int: Converts a Roman numeral to an integer. Args: roman (str): The Roman numeral as a string. Returns: int: The integer value of the Roman numeral. Examples: >>> roman_to_integer(\\"III\\") 3 >>> roman_to_integer(\\"IX\\") 9 >>> roman_to_integer(\\"MCMXCIV\\") 1994","solution":"def roman_to_integer(roman): Converts a Roman numeral to an integer. Args: roman (str): The Roman numeral as a string. Returns: int: The integer value of the Roman numeral. roman_to_int = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000, 'IV': 4, 'IX': 9, 'XL': 40, 'XC': 90, 'CD': 400, 'CM': 900 } i = 0 integer_value = 0 while i < len(roman): if i + 1 < len(roman) and roman[i:i+2] in roman_to_int: integer_value += roman_to_int[roman[i:i+2]] i += 2 else: integer_value += roman_to_int[roman[i]] i += 1 return integer_value"},{"question":"def longest_prefix_suffix(s: str) -> str: Given a string s consisting of only lowercase English letters, return the longest proper prefix of s which also a suffix. If no such prefix exists, return an empty string. >>> longest_prefix_suffix(\\"abab\\") \\"ab\\" >>> longest_prefix_suffix(\\"abcd\\") \\"\\" >>> longest_prefix_suffix(\\"aabaaab\\") \\"aab\\" >>> longest_prefix_suffix(\\"aaaa\\") \\"aaa\\" >>> longest_prefix_suffix(\\"abcabcabc\\") \\"abcabc\\" >>> longest_prefix_suffix(\\"a\\") \\"\\" >>> longest_prefix_suffix(\\"xyzuvw\\") \\"\\" >>> longest_prefix_suffix(\\"blablabla\\") \\"blabla\\"","solution":"def longest_prefix_suffix(s): Given a string s consisting of only lowercase English letters, return the longest proper prefix of s which also a suffix. If no such prefix exists, return an empty string. n = len(s) lps = [0] * n # lps[i] will be the longest proper prefix which is also a suffix in s[:i+1] length = 0 # length of the previous longest prefix suffix i = 1 while i < n: if s[i] == s[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 longest_proper_prefix_suffix_length = lps[-1] return s[:longest_proper_prefix_suffix_length] if longest_proper_prefix_suffix_length else \\"\\""},{"question":"def valid_chessboard(arr: List[List[str]]) -> bool: Checks if the given chessboard configuration is valid according to standard chess rules. >>> valid_chessboard([[\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\"P\\", \\".\\", \\".\\", \\"k\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\"P\\", \\".\\", \\".\\", \\".\\"], [\\"N\\", \\".\\", \\".\\", \\"r\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"K\\"]]) True >>> valid_chessboard([[\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\"K\\", \\".\\", \\".\\", \\"k\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\"P\\", \\".\\", \\".\\", \\".\\"], [\\"N\\", \\".\\", \\".\\", \\"r\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"K\\"]]) False >>> valid_chessboard([[\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\"P\\", \\"k\\", \\"P\\", \\"P\\", \\"P\\", \\"P\\"], [\\"P\\", \\"P\\", \\"P\\", \\"P\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\"P\\", \\".\\", \\".\\", \\".\\", \\"P\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\"r\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"K\\"]]) False >>> valid_chessboard([[\\"P\\", \\".\\", \\".\\", \\".\\", \\"P\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\"k\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\"P\\", \\".\\", \\".\\", \\".\\"], [\\"N\\", \\".\\", \\".\\", \\"r\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"K\\"]]) False >>> valid_chessboard([[\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"X\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\"k\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\"P\\", \\".\\", \\".\\", \\".\\"], [\\"N\\", \\".\\", \\".\\", \\"r\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"K\\"]]) False >>> valid_chessboard([[\\"K\\", \\"k\\"]]) True >>> valid_chessboard([[\\".\\", \\".\\"]]) False >>> valid_chessboard([[\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\"k\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\"p\\", \\"p\\", \\"p\\", \\"p\\", \\"p\\", \\"p\\", \\"p\\", \\"p\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\"P\\", \\"P\\", \\"P\\", \\"P\\", \\"P\\", \\"P\\", \\"P\\", \\"P\\"], [\\".\\", \\".\\", \\".\\", \\"Q\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"K\\"]]) True","solution":"def valid_chessboard(arr): Checks if the given chessboard configuration is valid according to standard chess rules. n = len(arr) # Initialize counters for pieces counts = { \\"K\\": 0, \\"k\\": 0, \\"P\\": 0, \\"p\\": 0, \\"N\\": 0, \\"n\\": 0, \\"B\\": 0, \\"b\\": 0, \\"R\\": 0, \\"r\\": 0, \\"Q\\": 0, \\"q\\": 0, \\".\\": 0 # We also keep track of empty cells for convenience } # Fill the counters for all pieces for row in arr: for cell in row: if cell not in counts: return False counts[cell] += 1 # There must be exactly one white king and exactly one black king if counts[\\"K\\"] != 1 or counts[\\"k\\"] != 1: return False # Each side can have a maximum of 8 pawns if counts[\\"P\\"] > 8 or counts[\\"p\\"] > 8: return False # No pawns should be on the first or last row for i in range(n): if arr[0][i] == \\"P\\" or arr[0][i] == \\"p\\" or arr[n-1][i] == \\"P\\" or arr[n-1][i] == \\"p\\": return False return True"},{"question":"def min_subarray_len(arr: List[int], x: int) -> int: Returns the minimum length of a contiguous subarray of which the sum is greater than or equal to \`x\`. If there isn't such a subarray, returns 0. pass from solution import min_subarray_len def test_min_subarray_len_case1(): arr = [2, 3, 1, 2, 4, 3] x = 7 assert min_subarray_len(arr, x) == 2 def test_min_subarray_len_case2(): arr = [1, 4, 4] x = 4 assert min_subarray_len(arr, x) == 1 def test_min_subarray_len_case3(): arr = [1, 1, 1, 1, 1, 1, 1, 1] x = 11 assert min_subarray_len(arr, x) == 0 def test_min_subarray_len_no_subarray(): arr = [1, 2, 3] x = 7 assert min_subarray_len(arr, x) == 0 def test_min_subarray_len_entire_array(): arr = [1, 2, 3, 4] x = 6 assert min_subarray_len(arr, x) == 2 def test_min_subarray_len_single_element_greater(): arr = [10, 5, 2] x = 9 assert min_subarray_len(arr, x) == 1 def test_min_subarray_len_all_elements_needed(): arr = [1, 1, 1, 1, 1, 1] x = 6 assert min_subarray_len(arr, x) == 6 def test_min_subarray_len_large_array(): arr = [1] * 100000 x = 10000 assert min_subarray_len(arr, x) == 10000","solution":"def min_subarray_len(arr, x): Returns the minimum length of a contiguous subarray of which the sum is greater than or equal to \`x\`. If there isn't such a subarray, returns 0. n = len(arr) start = 0 current_sum = 0 min_length = float('inf') for end in range(n): current_sum += arr[end] while current_sum >= x: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return 0 if min_length == float('inf') else min_length"},{"question":"def optimizeDanceRoutine(moves: List[str]) -> List[str]: Optimize the sequence of dance moves based on specific rules. 1. Replace *all* instances of \`\\"twist\\"\` with \`\\"spin\\"\`. 2. Replace *all* instances of \`\\"step forward\\"\` with \`\\"advance\\"\`. 3. Replace *all* instances of \`\\"step back\\"\` with \`\\"retreat\\"\`. 4. Replace *all* instances of \`\\"wave\\"\` with \`\\"sway\\"\`. 5. Replace *all* instances of \`\\"jump\\"\` with \`\\"leap\\"\`. 6. Replace *all* instances of \`\\"slide\\"\` with \`\\"glide\\"\`. Example usage: >>> optimizeDanceRoutine([\\"twist\\", \\"step forward\\", \\"step back\\", \\"wave\\", \\"jump\\", \\"slide.\\"]) [\\"spin\\", \\"advance\\", \\"retreat\\", \\"sway\\", \\"leap\\", \\"glide.\\"] # example unit test def test_optimizeDanceRoutine(): assert optimizeDanceRoutine([\\"twist\\", \\"step forward\\", \\"step back\\", \\"wave\\", \\"jump\\", \\"slide.\\"]) == [\\"spin\\", \\"advance\\", \\"retreat\\", \\"sway\\", \\"leap\\", \\"glide.\\"] assert optimizeDanceRoutine([\\"spin\\", \\"advance\\", \\"retreat\\", \\"sway\\", \\"leap\\", \\"glide.\\"]) == [\\"spin\\", \\"advance\\", \\"retreat\\", \\"sway\\", \\"leap\\", \\"glide.\\"] assert optimizeDanceRoutine([\\"Twist\\", \\"Step forward\\", \\"Step back\\", \\"Wave\\", \\"Jump\\", \\"Slide\\"]) == [\\"Twist\\", \\"Step forward\\", \\"Step back\\", \\"Wave\\", \\"Jump\\", \\"Slide\\"]","solution":"def optimizeDanceRoutine(moves): replacements = { \\"twist\\": \\"spin\\", \\"step forward\\": \\"advance\\", \\"step back\\": \\"retreat\\", \\"wave\\": \\"sway\\", \\"jump\\": \\"leap\\", \\"slide\\": \\"glide\\" } def replace_move(move): for old, new in replacements.items(): if move == old: return new elif move == old + \\".\\": return new + \\".\\" return move return [replace_move(move) for move in moves]"},{"question":"def generate_triangle_patterns(test_cases: List[int]) -> str: Generate a triangular pattern of plants for each test case. >>> generate_triangle_patterns([2]) == \\"*n**\\" >>> generate_triangle_patterns([4]) == \\"*n**n***n****\\" >>> generate_triangle_patterns([3]) == \\"*n**n***\\" >>> generate_triangle_patterns([2, 4]) == \\"*n**nn*n**n***n****\\" >>> generate_triangle_patterns([1, 2, 3]) == \\"*nn*n**nn*n**n***\\" >>> generate_triangle_patterns([5]) == \\"*n**n***n****n*****\\" >>> generate_triangle_patterns([]) == \\"\\"","solution":"def generate_triangle_patterns(test_cases): results = [] for L in test_cases: pattern = [] for i in range(1, L + 1): pattern.append('*' * i) results.append('n'.join(pattern)) return 'nn'.join(results)"},{"question":"class QueueWithTwoStacks: A class that simulates a queue using two stacks. Methods: enqueue(x): Add an item x to the end of the queue. dequeue(): Remove the item from the front of the queue and return it. If the queue is empty, return None. >>> queue = QueueWithTwoStacks() >>> queue.enqueue(1) >>> queue.enqueue(2) >>> queue.dequeue() 1 >>> queue.dequeue() 2 >>> queue.dequeue() is None True >>> queue.enqueue(3) >>> queue.enqueue(4) >>> queue.dequeue() 3 def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, x): pass def dequeue(self): pass def test_enqueue_dequeue(): queue = QueueWithTwoStacks() queue.enqueue(1) queue.enqueue(2) assert queue.dequeue() == 1 assert queue.dequeue() == 2 assert queue.dequeue() is None def test_mixed_operations(): queue = QueueWithTwoStacks() queue.enqueue(3) queue.enqueue(4) assert queue.dequeue() == 3 queue.enqueue(5) assert queue.dequeue() == 4 assert queue.dequeue() == 5 assert queue.dequeue() is None def test_empty_dequeue(): queue = QueueWithTwoStacks() assert queue.dequeue() is None queue.enqueue(6) assert queue.dequeue() == 6 assert queue.dequeue() is None def test_multiple_enqueues(): queue = QueueWithTwoStacks() numbers = list(range(10)) for num in numbers: queue.enqueue(num) for num in numbers: assert queue.dequeue() == num assert queue.dequeue() is None","solution":"class QueueWithTwoStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, x): self.stack1.append(x) def dequeue(self): if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: return None return self.stack2.pop()"},{"question":"def min_operations_to_equal_elements(nums: List[int]) -> int: Returns the minimum number of operations required to make all elements in the array equal by incrementing or decrementing element values by 1. >>> min_operations_to_equal_elements([1, 2, 3]) 2 >>> min_operations_to_equal_elements([1, 10, 2, 9]) 16","solution":"def min_operations_to_equal_elements(nums): Returns the minimum number of operations required to make all elements in the array equal by incrementing or decrementing element values by 1. nums.sort() median = nums[len(nums) // 2] # optimal value to make all elements equal return sum(abs(x - median) for x in nums)"},{"question":"from typing import Union, Dict def sum_nested_dict(d: Dict[str, Union[int, Dict]]) -> int: Computes the sum of all integers in a nested dictionary. :param d: Dictionary where values can be integers or other nested dictionaries :return: Sum of all integers in the dictionary >>> sum_nested_dict({\\"a\\": 1, \\"b\\": 2}) == 3 >>> sum_nested_dict({\\"a\\": {\\"b\\": 3, \\"c\\": 4}, \\"d\\": 5}) == 12 >>> sum_nested_dict({\\"a\\": {\\"b\\": {\\"c\\": {\\"d\\": 6}}}}) == 6 >>> sum_nested_dict({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3, \\"f\\": 4}}, \\"g\\": 5}) == 15 >>> sum_nested_dict({}) == 0 >>> sum_nested_dict({\\"a\\": {\\"b\\": {\\"c\\": {}}}}) == 0","solution":"def sum_nested_dict(d): Recursively calculates the sum of all integers in a nested dictionary. :param d: Dictionary with nested dictionaries and integer values :return: Sum of all integer values in the dictionary total_sum = 0 for value in d.values(): if isinstance(value, int): total_sum += value elif isinstance(value, dict): total_sum += sum_nested_dict(value) # Recursion for nested dictionaries return total_sum"},{"question":"from typing import List def process_transactions(transactions: List[str]) -> int: Processes a list of transactions and returns the final account balance. Each transaction is in the form \\"action amount\\", where \\"action\\" is either \\"D\\" for deposit or \\"W\\" for withdrawal. Withdrawals that would result in a negative balance are ignored. :param transactions: List of transaction strings :return: The final account balance as an integer pass # Example Usage transactions = [\\"D 300\\", \\"D 200\\", \\"W 500\\", \\"D 100\\", \\"W 250\\"] print(process_transactions(transactions)) # Expected output: 100","solution":"from typing import List def process_transactions(transactions: List[str]) -> int: Processes a list of transactions and returns the final account balance. Each transaction is in the form \\"action amount\\", where \\"action\\" is either \\"D\\" for deposit or \\"W\\" for withdrawal. Withdrawals that would result in a negative balance are ignored. :param transactions: List of transaction strings :return: The final account balance as an integer balance = 0 for transaction in transactions: action, amount_str = transaction.split() amount = int(amount_str) if action == \\"D\\": balance += amount elif action == \\"W\\": if balance >= amount: balance -= amount return balance"},{"question":"def count_substring(main_string: str, substring: str) -> int: Returns the number of times the substring is found within the main_string. >>> count_substring(\\"hello world\\", \\"l\\") 3 >>> count_substring(\\"abracadabra\\", \\"abra\\") 2 >>> count_substring(\\"Python programming is fun\\", \\"Python\\") 1","solution":"def count_substring(main_string, substring): Returns the number of times the substring is found within the main_string. return main_string.count(substring)"},{"question":"def max_abs_difference(numbers): Given a list of integers, determine the maximum absolute difference between any two elements in the list. The absolute difference between two integers \`a\` and \`b\` is given by \`|a - b|\`. >>> max_abs_difference([3, -7, 0, 9, -2]) 16 >>> max_abs_difference([-100, 100]) 200 >>> max_abs_difference([1, -1, 5, -5]) 10 >>> max_abs_difference([1, 1]) 0 >>> max_abs_difference([10, 2, 8, 7]) 8 >>> max_abs_difference([-10, -2, -8, -7]) 8 >>> max_abs_difference(list(range(-100, 101))) 200 # Your code here","solution":"def max_abs_difference(numbers): Returns the maximum absolute difference between any two elements in the list. if not numbers or len(numbers) < 2: raise ValueError(\\"The list must contain at least two elements.\\") min_value = min(numbers) max_value = max(numbers) return abs(max_value - min_value)"},{"question":"def longest_unique_word_length(words: List[str]) -> int: Takes a list of words and returns the length of the longest word that can be formed using only unique letters. If no such word exists, return 0. >>> longest_unique_word_length([]) 0 >>> longest_unique_word_length(['test', 'noon', 'letter']) 0 >>> longest_unique_word_length(['cat', 'dog', 'bird']) 4 >>> longest_unique_word_length(['test', 'coding', 'alphabet']) 6 >>> longest_unique_word_length(['test', 'abcde']) 5 >>> longest_unique_word_length(['abc', 'def', 'ghi']) 3","solution":"def longest_unique_word_length(words): Takes a list of words and returns the length of the longest word that can be formed using only unique letters. If no such word exists, return 0. max_length = 0 for word in words: if len(word) == len(set(word)): max_length = max(max_length, len(word)) return max_length"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Given a list of strings, identify all the anagram groups. Anagrams are strings made up of the same characters in the same frequency but can be in any order. :param words: List of strings :return: List of lists, where each sublist contains strings that are anagrams of each other.","solution":"from collections import defaultdict def group_anagrams(words): Groups anagram strings together. :param words: List of strings :return: List of lists, where each sublist contains strings that are anagrams of each other. anagrams = defaultdict(list) for word in words: # Use sorted word as the key key = ''.join(sorted(word)) anagrams[key].append(word) return list(anagrams.values())"},{"question":"def is_balanced_parentheses(s: str) -> bool: Returns True if the parentheses in the string are balanced, False otherwise. >>> is_balanced_parentheses(\\"a(b)c(d)e(f(g)h)i(j)k\\") True >>> is_balanced_parentheses(\\"a)b(c)d(e(f)g\\") False >>> is_balanced_parentheses(\\"((a)b)c)d((e)f\\") False >>> is_balanced_parentheses(\\"((a(b(c)d)e)f)g\\") True >>> is_balanced_parentheses(\\"\\") True >>> is_balanced_parentheses(\\"abcde\\") True","solution":"def is_balanced_parentheses(s): Returns True if the parentheses in the string are balanced, False otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"from typing import List, Tuple def longest_substring_with_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring with at most k distinct characters. >>> longest_substring_with_k_distinct(\\"abcba\\", 2) 3 >>> longest_substring_with_k_distinct(\\"aa\\", 1) 2 >>> longest_substring_with_k_distinct(\\"abaccc\\", 3) 6 pass def process_test_cases(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Processes multiple test cases and returns a list of results, each for the longest substring with at most k distinct characters. >>> test_cases = [(2, \\"abcba\\"), (1, \\"aa\\"), (3, \\"abaccc\\")] >>> process_test_cases(3, test_cases) [3, 2, 6] >>> test_cases = [(2, \\"a\\"), (1, \\"a\\"), (2, \\"ab\\"), (1, \\"ab\\"), (3, \\"abc\\")] >>> process_test_cases(5, test_cases) [1, 1, 2, 1, 3] pass","solution":"def longest_substring_with_k_distinct(s, k): Returns the length of the longest substring with at most k distinct characters. from collections import defaultdict char_count = defaultdict(int) left = 0 max_length = 0 for right in range(len(s)): char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length def process_test_cases(t, test_cases): results = [] for i in range(t): k, s = test_cases[i] results.append(longest_substring_with_k_distinct(s, k)) return results"},{"question":"from typing import List, Tuple def max_demolition_heights(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum height of demolished buildings starting from any building in various test cases. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer N and a list of N integers representing the heights of the buildings. Returns: List[int]: A list of integers where each integer represents the maximum height that can be demolished for the corresponding test case. Example: >>> max_demolition_heights(2, [(5, [1, 2, 3, 4, 5]), (3, [3, 2, 1])]) [15, 6] results = [] for i in range(T): N = test_cases[i][0] heights = test_cases[i][1] max_height = 0 # Compute max height demolishing to the right for j in range(N): current_height = 0 for k in range(j, N): current_height += heights[k] max_height = max(max_height, current_height) # Compute max height demolishing to the left for j in range(N): current_height = 0 for k in range(j, -1, -1): current_height += heights[k] max_height = max(max_height, current_height) results.append(max_height) return results # Unit tests def test_single_case(): T = 1 test_cases = [ (5, [1, 2, 3, 4, 5]) ] assert max_demolition_heights(T, test_cases) == [15] def test_multiple_cases(): T = 2 test_cases = [ (5, [1, 2, 3, 4, 5]), (3, [3, 2, 1]), ] assert max_demolition_heights(T, test_cases) == [15, 6] def test_minimal_case(): T = 1 test_cases = [ (1, [100]) ] assert max_demolition_heights(T, test_cases) == [100] def test_equal_height_buildings(): T = 1 test_cases = [ (4, [5, 5, 5, 5]) ] assert max_demolition_heights(T, test_cases) == [20] def test_varying_heights(): T = 1 test_cases = [ (5, [5, 10, 10, 5, 1]) ] assert max_demolition_heights(T, test_cases) == [31] def test_decreasing_heights(): T = 1 test_cases = [ (4, [10, 5, 3, 1]) ] assert max_demolition_heights(T, test_cases) == [19]","solution":"def max_demolition_heights(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] heights = test_cases[i][1] max_height = 0 # Compute max height demolishing to the right for j in range(N): current_height = 0 for k in range(j, N): current_height += heights[k] max_height = max(max_height, current_height) # Compute max height demolishing to the left for j in range(N): current_height = 0 for k in range(j, -1, -1): current_height += heights[k] max_height = max(max_height, current_height) results.append(max_height) return results"},{"question":"def encode_morse(input_string: str) -> str: Encodes a given string into Morse code. Spaces within the input string are retained as spaces in the output. The function ignores any characters not present in the Morse code mapping. >>> encode_morse(\\"Hello World\\") \\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\" >>> encode_morse(\\"SOS 123\\") \\"... --- ... / .---- ..--- ...--\\" >>> encode_morse(\\"\\") \\"\\" >>> encode_morse(\\" \\") \\"/ / / / /\\" >>> encode_morse(\\"LoWeRcAsE lEtTeRs\\") \\".-.. --- .-- . .-. -.-. .- ... . / .-.. . - - . .-. ...\\" >>> encode_morse(\\"H@e#ll^o&\\") \\".... . .-.. .-.. ---\\"","solution":"def encode_morse(input_string): Encodes a given string into Morse code. Spaces within the input string are retained as spaces in the output. The function ignores any characters not present in the Morse code mapping. morse_code_dict = { 'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--', 'z': '--..', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', '0': '-----', ' ': '/' } input_string = input_string.lower() encoded_string = \\" \\".join(morse_code_dict[char] for char in input_string if char in morse_code_dict) return encoded_string"},{"question":"def minChangesToPalindrome(s: str) -> int: Determines the minimum number of changes needed to convert the given string \`s\` into a palindrome. Parameters: s (str): the input string consisting of lowercase English letters. Returns: int: the minimum number of character changes needed. Examples: >>> minChangesToPalindrome(\\"abca\\") 1 >>> minChangesToPalindrome(\\"race\\") 2 >>> minChangesToPalindrome(\\"aabb\\") 2 >>> minChangesToPalindrome(\\"abbb\\") 1 >>> minChangesToPalindrome(\\"a\\") 0 >>> minChangesToPalindrome(\\"aa\\") 0 >>> minChangesToPalindrome(\\"ab\\") 1 >>> minChangesToPalindrome(\\"abcd\\") 2 >>> minChangesToPalindrome(\\"abcba\\") 0 >>> minChangesToPalindrome(\\"abcdefghefdbca\\") 5 >>> minChangesToPalindrome(\\"abccba\\") 0 >>> minChangesToPalindrome(\\"a\\" * 50000 + \\"b\\" * 50000) 50000","solution":"def minChangesToPalindrome(s: str) -> int: Determines the minimum number of changes needed to convert the given string \`s\` into a palindrome. Parameters: s (str): the input string consisting of lowercase English letters. Returns: int: the minimum number of character changes needed. n = len(s) changes = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: changes += 1 return changes"},{"question":"def rob(nums: List[int]) -> int: Determine the maximum amount of money you can rob tonight without alerting the police. Args: nums: List[int] - A list of non-negative integers representing the amount of money of each house. Returns: int - The maximum amount of money you can rob. Examples: >>> rob([1, 2, 3, 1]) 4 >>> rob([2, 7, 9, 3, 1]) 12","solution":"def rob(nums): Determine the maximum amount of money you can rob tonight without alerting the police. :param nums: List[int], the list of non-negative integers representing the amount of money in each house. :return: int, the maximum amount of money you can rob. if not nums: return 0 prev2, prev1 = 0, 0 for num in nums: current = max(prev1, prev2 + num) prev2 = prev1 prev1 = current return prev1"},{"question":"def largest_connected_region(grid): Finds the size of the largest connected region of the same character in the grid. pass def test_example1(): grid = [ ['a', 'b', 'b'], ['b', 'b', 'a'], ['a', 'a', 'b'] ] assert largest_connected_region(grid) == 4 def test_example2(): grid = [ ['a', 'a', 'a'], ['a', 'a', 'a'], ['a', 'a', 'a'] ] assert largest_connected_region(grid) == 9 def test_example3(): grid = [['x']] assert largest_connected_region(grid) == 1 def test_mixed_grid(): grid = [ ['a', 'b', 'c'], ['d', 'a', 'a'], ['e', 'a', 'f'] ] assert largest_connected_region(grid) == 3 def test_single_row(): grid = [['a', 'b', 'b', 'a', 'a']] assert largest_connected_region(grid) == 2 def test_single_column(): grid = [ ['a'], ['a'], ['b'], ['a'], ['a'] ] assert largest_connected_region(grid) == 2 def test_empty_grid(): grid = [] assert largest_connected_region(grid) == 0","solution":"def largest_connected_region(grid): Finds the size of the largest connected region of the same character in the grid. def dfs(x, y, char, visited): if (x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or visited[x][y] or grid[x][y] != char): return 0 visited[x][y] = True size = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: size += dfs(x + dx, y + dy, char, visited) return size if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] max_region_size = 0 for i in range(rows): for j in range(cols): if not visited[i][j]: max_region_size = max(max_region_size, dfs(i, j, grid[i][j], visited)) return max_region_size"},{"question":"def reduce_to_zero(n: int) -> int: Write a function that takes as input an integer and returns the number of steps required to reduce it to zero by continually removing squares of the largest possible integer. >>> reduce_to_zero(12) 4 >>> reduce_to_zero(18) 3 >>> reduce_to_zero(1) 1 >>> reduce_to_zero(2) 2 >>> reduce_to_zero(26) 2 >>> reduce_to_zero(10000) 1 >>> reduce_to_zero(1024) 1","solution":"import math def reduce_to_zero(n: int) -> int: steps = 0 while n > 0: largest_square = int(math.sqrt(n)) ** 2 n -= largest_square steps += 1 return steps"},{"question":"class ParkingLot: A class to manage parking lot and provide information about available parking spots. Methods: __init__(self, num_car_spots: int, num_bike_spots: int, num_bus_spots: int): Initializes the parking lot. park_vehicle(self, license_plate: str, vehicle_type: str) -> bool: Parks a vehicle in the parking lot. remove_vehicle(self, license_plate: str) -> bool: Removes a vehicle from the parking lot. get_available_spots(self) -> dict: Returns a dictionary with the count of available spots for each vehicle type. def __init__(self, num_car_spots: int, num_bike_spots: int, num_bus_spots: int): # Initializes the parking lot with the given number of car, bike, and bus spots. # All spots start out as vacant. pass def park_vehicle(self, license_plate: str, vehicle_type: str) -> bool: # Parks a vehicle with the given license plate number and vehicle type (which can be \\"car\\", \\"bike\\", or \\"bus\\") # in the parking lot. Returns \`True\` if the vehicle was successfully parked, and \`False\` otherwise. pass def remove_vehicle(self, license_plate: str) -> bool: # Removes the vehicle with the given license plate number from the parking lot. # Returns \`True\` if the vehicle was successfully removed, and \`False\` otherwise. pass def get_available_spots(self) -> dict: # Returns a dictionary with the count of available spots for each vehicle type. pass # Unit tests def test_parking_lot_initialization(): parking_lot = ParkingLot(3, 2, 1) assert parking_lot.get_available_spots() == {'car': 3, 'bike': 2, 'bus': 1} def test_park_vehicle(): parking_lot = ParkingLot(3, 2, 1) assert parking_lot.park_vehicle(\\"ABC123\\", \\"car\\") == True assert parking_lot.park_vehicle(\\"XYZ789\\", \\"bike\\") == True assert parking_lot.park_vehicle(\\"GHI101\\", \\"bus\\") == True assert parking_lot.get_available_spots() == {'car': 2, 'bike': 1, 'bus': 0} def test_park_vehicle_no_spots_left(): parking_lot = ParkingLot(1, 1, 1) assert parking_lot.park_vehicle(\\"ABC123\\", \\"car\\") == True assert parking_lot.park_vehicle(\\"DEF456\\", \\"car\\") == False def test_remove_vehicle(): parking_lot = ParkingLot(3, 2, 1) parking_lot.park_vehicle(\\"ABC123\\", \\"car\\") assert parking_lot.remove_vehicle(\\"ABC123\\") == True assert parking_lot.get_available_spots() == {'car': 3, 'bike': 2, 'bus': 1} def test_remove_nonexistent_vehicle(): parking_lot = ParkingLot(3, 2, 1) assert parking_lot.remove_vehicle(\\"NOP333\\") == False def test_parking_same_license_plate(): parking_lot = ParkingLot(3, 2, 1) assert parking_lot.park_vehicle(\\"ABC123\\", \\"car\\") == True assert parking_lot.park_vehicle(\\"ABC123\\", \\"car\\") == False assert parking_lot.park_vehicle(\\"ABC123\\", \\"bike\\") == False def test_invalid_vehicle_type(): parking_lot = ParkingLot(3, 2, 1) assert parking_lot.park_vehicle(\\"ABC123\\", \\"truck\\") == False","solution":"class ParkingLot: def __init__(self, num_car_spots: int, num_bike_spots: int, num_bus_spots: int): self.total_spots = { 'car': num_car_spots, 'bike': num_bike_spots, 'bus': num_bus_spots } self.available_spots = { 'car': num_car_spots, 'bike': num_bike_spots, 'bus': num_bus_spots } self.parked_vehicles = {} def park_vehicle(self, license_plate: str, vehicle_type: str) -> bool: if vehicle_type not in self.available_spots: return False if self.available_spots[vehicle_type] > 0 and license_plate not in self.parked_vehicles: self.parked_vehicles[license_plate] = vehicle_type self.available_spots[vehicle_type] -= 1 return True return False def remove_vehicle(self, license_plate: str) -> bool: if license_plate in self.parked_vehicles: vehicle_type = self.parked_vehicles.pop(license_plate) self.available_spots[vehicle_type] += 1 return True return False def get_available_spots(self) -> dict: return self.available_spots.copy()"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the sum of the contiguous subarray with the largest sum. >>> max_subarray_sum([2, 3, 4, 5]) == 14 >>> max_subarray_sum([-2, -3, -4, -5]) == -2 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([1, 2, 3, -2, 5]) == 9 >>> max_subarray_sum([-3, -2, 5, -1, -2, 2, 3, -4, 2]) == 7 >>> max_subarray_sum([]) == 0 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([-1]) == -1","solution":"def max_subarray_sum(nums): Returns the sum of the contiguous subarray with the largest sum. if not nums: return 0 max_end_here = nums[0] max_so_far = nums[0] for num in nums[1:]: max_end_here = max(num, max_end_here + num) max_so_far = max(max_so_far, max_end_here) return max_so_far"},{"question":"def calculate_fuel(amount: int, efficiency: float) -> int: Calculate the maximum distance a vehicle can travel given the amount of fuel and fuel efficiency. Parameters: amount (int): The amount of fuel in gallons. efficiency (float): The fuel efficiency in miles per gallon. Returns: int: The maximum distance in miles. Examples: >>> calculate_fuel(10, 20) 200 >>> calculate_fuel(3, 18.3) 54 >>> calculate_fuel(5, 0.0) 0 >>> calculate_fuel(7, 8.5) 59 >>> calculate_fuel(1, 12.75) 12 >>> calculate_fuel(4, 25.9) 103 # Your code here","solution":"def calculate_fuel(amount, efficiency): Calculate the maximum distance a vehicle can travel given the amount of fuel and fuel efficiency. Parameters: amount (int): The amount of fuel in gallons. efficiency (float): The fuel efficiency in miles per gallon. Returns: int: The maximum distance in miles. # Calculate the distance distance = amount * efficiency # Return the distance as an integer return int(distance)"},{"question":"def hasPairWithSum(arr, target): Create a function which receives an array of numbers and a target number as arguments. The function should return \`true\` if there are two distinct numbers in the array that sum up to the target number, and \`false\` otherwise. You should aim for a solution with a time complexity less than O(n^2). >>> hasPairWithSum([1, 2, 3, 9], 8) == False >>> hasPairWithSum([1, 2, 4, 4], 8) == True","solution":"def hasPairWithSum(arr, target): Returns True if there are two distinct numbers in the array that sum up to the target, False otherwise. Time complexity: O(n) seen_numbers = set() for number in arr: needed_value = target - number if needed_value in seen_numbers: return True seen_numbers.add(number) return False"},{"question":"from typing import List def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the given list of integers. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([1, 4, 6, 8, 10]) [] >>> filter_primes([]) [] >>> filter_primes([2, 3, 5, 7, 11, 13]) [2, 3, 5, 7, 11, 13] >>> filter_primes([3]) [3] >>> filter_primes([4]) []","solution":"from typing import List def is_prime(n: int) -> bool: Helper function to determine if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the given list of integers. return [num for num in numbers if is_prime(num)]"},{"question":"def smallest_armstrong_number(): This function returns the smallest Armstrong number. An Armstrong number (also known as Narcissistic number) is a number that is equal to the sum of its own digits each raised to the power of the number of digits.","solution":"def smallest_armstrong_number(): This function returns the smallest Armstrong number. An Armstrong number (also known as Narcissistic number) is a number that is equal to the sum of its own digits each raised to the power of the number of digits. # Smallest Armstrong number is always 1 as it satisfies the condition trivially. return 1"},{"question":"def compress_string(input_str: str) -> str: Implement a basic string compression algorithm such that consecutive repeated characters are substituted with a single character followed by its count. Return the original string if the compressed version is not shorter. >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abcdef\\") \\"abcdef\\"","solution":"def compress_string(input_str: str) -> str: if not input_str: return input_str compressed = [] count = 1 for i in range(1, len(input_str)): if input_str[i] == input_str[i - 1]: count += 1 else: compressed.append(input_str[i - 1] + str(count)) count = 1 compressed.append(input_str[-1] + str(count)) compressed_str = \\"\\".join(compressed) return compressed_str if len(compressed_str) < len(input_str) else input_str"},{"question":"def is_valid_parentheses(s: str) -> str: Determines if the given string of parentheses is valid. Args: s (str): A string containing only the characters '(' and ')'. Returns: str: \\"YES\\" if the string is valid, otherwise \\"NO\\". # Your code here def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases of parentheses strings for validity. Args: test_cases (list of str): A list of strings containing only the characters '(' and ')'. Returns: list of str: A list containing the results (\\"YES\\" or \\"NO\\") for each test case. # Your code here # Example Unit Test def test_is_valid_parentheses(): assert is_valid_parentheses(\\"()\\") == \\"YES\\" assert is_valid_parentheses(\\"(\\") == \\"NO\\" assert is_valid_parentheses(\\")\\") == \\"NO\\" assert is_valid_parentheses(\\"()()\\") == \\"YES\\" assert is_valid_parentheses(\\"(())\\") == \\"YES\\" assert is_valid_parentheses(\\"(()\\") == \\"NO\\" assert is_valid_parentheses(\\"())\\") == \\"NO\\" assert is_valid_parentheses(\\"((()))\\") == \\"YES\\" def test_process_test_cases(): test_cases = [\\"()\\", \\"((\\", \\"()()\\"] expected = [\\"YES\\", \\"NO\\", \\"YES\\"] assert process_test_cases(test_cases) == expected test_cases = [\\"\\", \\"()\\", \\"(()\\", \\"(())\\", \\"))((\\"] expected = [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] assert process_test_cases(test_cases) == expected test_cases = [\\"((()()\\", \\"())(\\", \\"(()())\\"] expected = [\\"NO\\", \\"NO\\", \\"YES\\"] assert process_test_cases(test_cases) == expected","solution":"def is_valid_parentheses(s): Determines if the given string of parentheses is valid. Args: s (str): A string containing only the characters '(' and ')'. Returns: str: \\"YES\\" if the string is valid, otherwise \\"NO\\". stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"NO\\" stack.pop() return \\"YES\\" if not stack else \\"NO\\" def process_test_cases(test_cases): Processes multiple test cases of parentheses strings for validity. Args: test_cases (list of str): A list of strings containing only the characters '(' and ')'. Returns: list of str: A list containing the results (\\"YES\\" or \\"NO\\") for each test case. results = [] for s in test_cases: results.append(is_valid_parentheses(s)) return results"},{"question":"def int_to_binary_strings(int_list): This function takes a list of integers as input and returns a list of strings where each string represents the corresponding integer in binary format, prefixed with '0b'. Args: int_list (List[int]): List of integers Returns: List[str]: List of binary string representations Examples: >>> int_to_binary_strings([3, 7, 10, 16]) ['0b11', '0b111', '0b1010', '0b10000'] >>> int_to_binary_strings([1, 256, 32, 8]) ['0b1', '0b100000000', '0b100000', '0b1000']","solution":"def int_to_binary_strings(int_list): This function takes a list of integers as input and returns a list of strings where each string represents the corresponding integer in binary format, prefixed with '0b'. return [bin(num) for num in int_list]"},{"question":"def count_ones(n: int) -> int: Count the number of 1s (bits that are set to 1) in the binary representation of an integer \`n\`. >>> count_ones(5) 2 >>> count_ones(13) 3 >>> count_ones(255) 8 from solution import count_ones def test_count_ones_basic(): assert count_ones(5) == 2 assert count_ones(13) == 3 assert count_ones(255) == 8 def test_count_ones_zero(): assert count_ones(0) == 0 def test_count_ones_all_bits_set(): assert count_ones(0xFFFFFFFF) == 32 # max 32-bit unsigned integer def test_count_ones_single_bit_set(): assert count_ones(1) == 1 assert count_ones(2) == 1 assert count_ones(4) == 1 def test_count_ones_large_number(): assert count_ones(123456789) == 16","solution":"def count_ones(n): Returns the number of 1s (bits that are set to 1) in the binary representation of the integer \`n\`. return bin(n).count('1')"},{"question":"def longestPalindrome(s: str) -> str: Given a string s, return the longest palindromic substring in s. A palindrome is a string that reads the same backward as forward. >>> longestPalindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longestPalindrome(\\"cbbd\\") == \\"bb\\" True from solution import longestPalindrome def test_example_cases(): assert longestPalindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] assert longestPalindrome(\\"cbbd\\") == \\"bb\\" def test_single_character(): assert longestPalindrome(\\"a\\") == \\"a\\" assert longestPalindrome(\\"aa\\") == \\"aa\\" def test_no_palindrome(): assert longestPalindrome(\\"abc\\") in [\\"a\\", \\"b\\", \\"c\\"] def test_multiple_palindromes(): assert longestPalindrome(\\"racecar\\") == \\"racecar\\" assert longestPalindrome(\\"bananas\\") == \\"anana\\" def test_empty_string(): assert longestPalindrome(\\"\\") == \\"\\" def test_palindrome_at_edges(): assert longestPalindrome(\\"abcdcba\\") == \\"abcdcba\\" assert longestPalindrome(\\"abccba\\") == \\"abccba\\" def test_mixed_case(): assert longestPalindrome(\\"Aba\\") == \\"A\\" def test_long_string(): long_str = \\"a\\" * 1000 assert longestPalindrome(long_str) == long_str","solution":"def longestPalindrome(s: str) -> str: Returns the longest palindromic substring in the given string s. if len(s) == 0: return \\"\\" def expandAroundCenter(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest_palindrome = \\"\\" for i in range(len(s)): # Check for odd-length palindromes odd_palindrome = expandAroundCenter(s, i, i) if len(odd_palindrome) > len(longest_palindrome): longest_palindrome = odd_palindrome # Check for even-length palindromes even_palindrome = expandAroundCenter(s, i, i + 1) if len(even_palindrome) > len(longest_palindrome): longest_palindrome = even_palindrome return longest_palindrome"},{"question":"from typing import List def top_3_high_avg_scores(usernames: List[str], scores: List[int]) -> List[str]: Determine the top 3 highest average scores of all users. If a user has fewer than 3 scores, they should not be considered in the calculation. Return a list of the usernames with the top 3 highest average scores in descending order. Note: If two users have the same average score, prioritize the user whose name comes first alphabetically. >>> top_3_high_avg_scores([\\"alice\\", \\"bob\\", \\"alice\\", \\"alice\\", \\"bob\\", \\"alice\\", \\"charlie\\", \\"charlie\\", \\"charlie\\"], ... [100, 90, 95, 80, 85, 90, 95, 100, 110]) [\\"charlie\\", \\"alice\\"] >>> top_3_high_avg_scores([\\"dan\\", \\"dan\\", \\"dan\\", \\"sam\\", \\"sam\\", \\"sam\\", \\"emma\\", \\"emma\\", \\"emma\\"], ... [67, 89, 78, 92, 91, 88, 85, 90, 93]) [\\"emma\\", \\"sam\\"]","solution":"def top_3_high_avg_scores(usernames, scores): from collections import defaultdict user_scores = defaultdict(list) for username, score in zip(usernames, scores): user_scores[username].append(score) valid_avg_scores = {} for user, score_list in user_scores.items(): if len(score_list) >= 3: avg_score = sum(score_list) / len(score_list) valid_avg_scores[user] = avg_score top_users = sorted( valid_avg_scores.keys(), key=lambda user: (-valid_avg_scores[user], user) )[:3] return top_users"},{"question":"def reverse_message(sentence: str) -> str: Returns the sentence with the words in reverse order. Parameters: sentence (str): The input sentence containing words separated by spaces. Returns: str: A new sentence with the words reversed. Examples: >>> reverse_message(\\"Hello World\\") 'World Hello' >>> reverse_message(\\"Python is amazing\\") 'amazing is Python' >>> reverse_message(\\"Keep calm and code on\\") 'on code and calm Keep'","solution":"def reverse_message(sentence: str) -> str: Returns the sentence with the words in reverse order. Parameters: sentence (str): The input sentence containing words separated by spaces. Returns: str: A new sentence with the words reversed. words = sentence.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def are_anagrams(A: str, B: str) -> bool: Determines if two strings are anagrams of each other. Args: A (str): The first string. B (str): The second string. Returns: bool: True if A and B are anagrams, False otherwise. Examples: >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"apple\\", \\"pale\\") False >>> are_anagrams(\\"rat\\", \\"car\\") False","solution":"def are_anagrams(A, B): Determines if two strings are anagrams of each other. Args: A (str): The first string. B (str): The second string. Returns: bool: True if A and B are anagrams, False otherwise. return sorted(A) == sorted(B)"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers that add up to target. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([-1, -2, -3, -4], -6) [1, 3] >>> two_sum([-1, 2, 3, -4], -5) [0, 3] >>> two_sum([1, 2], 3) [0, 1]","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers that add up to target. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return [seen[complement], i] seen[num] = i"},{"question":"from typing import List, Tuple def count_remaining_alices(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]], List[Tuple[int, int]]]]) -> List[int]: Given the information about the number of Alices and Boblins and their magical levels and schools, determine the number of Alices left after all possible rituals are performed. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]], List[Tuple[int, int]]]]): Test case details containing number of Alices, number of Boblins, and their corresponding magical power and school level. Returns: List[int]: Number of Alices left after all possible rituals for each test case. pass def parse_input(input_data: str) -> Tuple[int, List[Tuple[int, int, List[Tuple[int, int]], List[Tuple[int, int]]]]]: Parse the input data for the function. Args: input_data (str): Raw input data as a string. Returns: Tuple[int, List[Tuple[int, int, List[Tuple[int, int]], List[Tuple[int, int]]]]]: Structured input format with number of test cases and detailed information about each test case. pass # Unit Test import pytest from solution import count_remaining_alices, parse_input def test_example_case_1(): input_data = 2 3 3 10 1 15 2 20 1 5 1 25 2 5 1 2 2 30 3 40 4 10 3 20 4 T, test_cases = parse_input(input_data) results = count_remaining_alices(T, test_cases) assert results == [2, 2] def test_single_case_no_rituals(): input_data = 1 2 2 10 1 10 2 10 1 10 2 T, test_cases = parse_input(input_data) results = count_remaining_alices(T, test_cases) assert results == [2] def test_single_case_alice_wins(): input_data = 1 1 1 20 1 10 1 T, test_cases = parse_input(input_data) results = count_remaining_alices(T, test_cases) assert results == [1] def test_single_case_boblin_wins(): input_data = 1 1 1 10 1 20 1 T, test_cases = parse_input(input_data) results = count_remaining_alices(T, test_cases) assert results == [0] def test_equal_power_no_changes(): input_data = 1 2 2 10 1 10 1 10 1 10 1 T, test_cases = parse_input(input_data) results = count_remaining_alices(T, test_cases) assert results == [2] if __name__ == \\"__main__\\": pytest.main([__file__])","solution":"def count_remaining_alices(T, test_cases): results = [] for case in test_cases: N, M, alices, boblins = case alices_dict = {} boblins_dict = {} for power, level in alices: if level not in alices_dict: alices_dict[level] = [] alices_dict[level].append(power) for power, level in boblins: if level not in boblins_dict: boblins_dict[level] = [] boblins_dict[level].append(power) for level in alices_dict.keys(): alice_powers = sorted(alices_dict[level]) boblin_powers = sorted(boblins_dict[level]) alice_index = 0 boblin_index = 0 while alice_index < len(alice_powers) and boblin_index < len(boblin_powers): if alice_powers[alice_index] > boblin_powers[boblin_index]: alice_powers[alice_index] += boblin_powers[boblin_index] del boblin_powers[boblin_index] elif alice_powers[alice_index] < boblin_powers[boblin_index]: boblin_powers[boblin_index] += alice_powers[alice_index] del alice_powers[alice_index] else: alice_index += 1 boblin_index += 1 alices_dict[level] = alice_powers remaining_alices = sum(len(alices) for alices in alices_dict.values()) results.append(remaining_alices) return results # Function to gather and format the input data for the function. def parse_input(input_data): input_lines = input_data.strip().split(\\"n\\") T = int(input_lines[0]) current_line = 1 test_cases = [] for _ in range(T): N, M = map(int, input_lines[current_line].split()) current_line += 1 alices = [] for _ in range(N): P_i, L_i = map(int, input_lines[current_line].split()) alices.append((P_i, L_i)) current_line += 1 boblins = [] for _ in range(M): P_j, L_j = map(int, input_lines[current_line].split()) boblins.append((P_j, L_j)) current_line += 1 test_cases.append((N, M, alices, boblins)) return T, test_cases # Example usage and test input_data = 2 3 3 10 1 15 2 20 1 5 1 25 2 5 1 2 2 30 3 40 4 10 3 20 4 T, test_cases = parse_input(input_data) results = count_remaining_alices(T, test_cases) for result in results: print(result)"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") \\"wke\\" >>> longest_unique_substring(\\"\\") \\"\\" >>> longest_unique_substring(\\"a\\") \\"a\\" >>> longest_unique_substring(\\"abcdefg\\") \\"abcdefg\\" >>> longest_unique_substring(\\"123454321\\") \\"12345\\"","solution":"def longest_unique_substring(s): Returns the longest substring without repeating characters. if not s: return \\"\\" start = 0 max_length = 0 max_substring = \\"\\" used_chars = {} for i in range(len(s)): if s[i] in used_chars and start <= used_chars[s[i]]: start = used_chars[s[i]] + 1 else: if i - start + 1 > max_length: max_length = i - start + 1 max_substring = s[start:i+1] used_chars[s[i]] = i return max_substring"},{"question":"from typing import List from collections import Counter def is_palindrome_permutation(s: str) -> bool: Determine if any permutation of the string can form a palindrome. Args: s (str): Input string Returns: bool: True if any permutation can form a palindrome, False otherwise Examples: >>> is_palindrome_permutation(\\"civic\\") True >>> is_palindrome_permutation(\\"ivicc\\") True >>> is_palindrome_permutation(\\"hello\\") False >>> is_palindrome_permutation(\\"aabb\\") True Unit Test: def test_is_palindrome_permutation(): assert is_palindrome_permutation(\\"civic\\") == True assert is_palindrome_permutation(\\"ivicc\\") == True assert is_palindrome_permutation(\\"hello\\") == False assert is_palindrome_permutation(\\"aabb\\") == True assert is_palindrome_permutation(\\"a\\") == True assert is_palindrome_permutation(\\"\\") == True assert is_palindrome_permutation(\\"abcdefg\\") == False assert is_palindrome_permutation(\\"aabbccc\\") == True assert is_palindrome_permutation(\\"aaaaa\\") == True","solution":"from collections import Counter def is_palindrome_permutation(s: str) -> bool: Returns True if any permutation of the string can form a palindrome, otherwise False. # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # In order to form a palindrome, at most one character can have an odd count return odd_count <= 1"},{"question":"def longest_unique_substring(s: str) -> int: Determines the length of the longest substring with all unique characters in the given string. :param s: input string :returns: length of the longest unique substring >>> longest_unique_substring(\\"abrkaabcdefghijjxxx\\") == 10 >>> longest_unique_substring(\\"abcabcbb\\") == 3 >>> longest_unique_substring(\\"bbbbb\\") == 1 pass def test_case_1(): assert longest_unique_substring(\\"abrkaabcdefghijjxxx\\") == 10 def test_case_2(): assert longest_unique_substring(\\"abcabcbb\\") == 3 def test_case_3(): assert longest_unique_substring(\\"bbbbb\\") == 1 def test_case_4(): assert longest_unique_substring(\\"\\") == 0 def test_case_5(): assert longest_unique_substring(\\"abcdef\\") == 6 def test_case_6(): assert longest_unique_substring(\\"aab\\") == 2 def test_case_7(): assert longest_unique_substring(\\"dvdf\\") == 3","solution":"def longest_unique_substring(s): Determines the length of the longest substring with all unique characters in the given string. :param s: input string :returns: length of the longest unique substring n = len(s) i = 0 j = 0 max_length = 0 seen_chars = {} while j < n: if s[j] in seen_chars: # move i right i = max(seen_chars[s[j]] + 1, i) seen_chars[s[j]] = j max_length = max(max_length, j - i + 1) j += 1 return max_length"},{"question":"def convert_to_24_hour_format(time_str: str) -> str: Converts a 12-hour AM/PM time format string to 24-hour time format string. Parameters: time_str (str): A string representing time in \\"hh:mm AM/PM\\" format. Returns: str: A string representing time in \\"HH:MM\\" format, or \\"Invalid time format\\" if the input is invalid. pass # Example test cases def test_convert_valid_times(): assert convert_to_24_hour_format(\\"02:30 PM\\") == \\"14:30\\" assert convert_to_24_hour_format(\\"12:00 AM\\") == \\"00:00\\" assert convert_to_24_hour_format(\\"07:45 AM\\") == \\"07:45\\" assert convert_to_24_hour_format(\\"12:00 PM\\") == \\"12:00\\" assert convert_to_24_hour_format(\\"11:59 PM\\") == \\"23:59\\" assert convert_to_24_hour_format(\\"01:00 PM\\") == \\"13:00\\" def test_convert_invalid_times(): assert convert_to_24_hour_format(\\"13:00 PM\\") == \\"Invalid time format\\" assert convert_to_24_hour_format(\\"00:00 AM\\") == \\"Invalid time format\\" assert convert_to_24_hour_format(\\"24:00 PM\\") == \\"Invalid time format\\" assert convert_to_24_hour_format(\\"11:60 PM\\") == \\"Invalid time format\\" assert convert_to_24_hour_format(\\"11:59 XM\\") == \\"Invalid time format\\" def test_convert_incorrect_format(): assert convert_to_24_hour_format(\\"12:00PM\\") == \\"Invalid time format\\" assert convert_to_24_hour_format(\\"12-00 PM\\") == \\"Invalid time format\\" assert convert_to_24_hour_format(\\"Noon\\") == \\"Invalid time format\\" assert convert_to_24_hour_format(\\"Midnight\\") == \\"Invalid time format\\" assert convert_to_24_hour_format(\\"\\") == \\"Invalid time format\\"","solution":"def convert_to_24_hour_format(time_str): Converts a 12-hour AM/PM time format string to 24-hour time format string. Parameters: time_str (str): A string representing time in \\"hh:mm AM/PM\\" format. Returns: str: A string representing time in \\"HH:MM\\" format, or \\"Invalid time format\\" if the input is invalid. try: import datetime # Parse the input time string. time_obj = datetime.datetime.strptime(time_str, \\"%I:%M %p\\") # Format the time object to 24-hour format. return time_obj.strftime(\\"%H:%M\\") except ValueError: return \\"Invalid time format\\""},{"question":"from typing import List def reorderEVENFirst(arr: List[int]) -> List[int]: Reorganizes the elements of the array such that all even numbers appear before all odd numbers, without changing the relative order of the even and odd numbers. >>> reorderEVENFirst([1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5] >>> reorderEVENFirst([4, 3, 2, 1]) [4, 2, 3, 1] >>> reorderEVENFirst([2, 4, 6]) [2, 4, 6] >>> reorderEVENFirst([3, 1, 5]) [3, 1, 5] >>> reorderEVENFirst([]) [] >>> reorderEVENFirst([-3, -2, -1, 0]) [-2, 0, -3, -1] >>> reorderEVENFirst([1]) [1] >>> reorderEVENFirst([2]) [2]","solution":"def reorderEVENFirst(arr): Reorganizes the elements of the array such that all even numbers appear before all odd numbers, without changing the relative order of the even and odd numbers. evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds"},{"question":"def removeDuplicates(s: str) -> str: Returns a new string with all duplicate characters removed, keeping only the first occurrence of each character. Parameters: s (str): Input string containing lowercase alphabetic characters. Returns: str: A new string with duplicates removed. Examples: >>> removeDuplicates(\\"programming\\") 'progamin' >>> removeDuplicates(\\"hello\\") 'helo' >>> removeDuplicates(\\"aabbcc\\") 'abc'","solution":"def removeDuplicates(s): Returns a new string with all duplicate characters removed, keeping only the first occurrence of each character. Parameters: s (str): Input string containing lowercase alphabetic characters. Returns: str: A new string with duplicates removed. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"from typing import List, Tuple def find_isolated_teams(employees: List[int], collaborations: List[Tuple[int, int]]) -> List[List[int]]: Find and return a sorted list of isolated groups of employees. An isolated group of employees is defined as a set of employees who only collaborate with each other and have no collaborations with employees outside their group. Parameters: employees (List[int]): A list of all employees. collaborations (List[Tuple[int, int]]): A list of collaborations where each collaboration is represented as a tuple of two employee IDs. Returns: List[List[int]]: A sorted list of isolated groups of employees. Each group is a sorted list of employee IDs. >>> find_isolated_teams([0, 1, 2, 3, 4, 5], [(0, 1), (1, 2), (3, 4)]) [[0, 1, 2], [3, 4], [5]] >>> find_isolated_teams([0, 1, 2, 3, 4], []) [[0], [1], [2], [3], [4]] >>> find_isolated_teams([0, 1, 2, 3], [(0, 1), (1, 2), (2, 3)]) [[0, 1, 2, 3]] >>> find_isolated_teams([0, 1, 2, 3, 4, 5, 6, 7], [(0, 1), (2, 3), (4, 5), (6, 7)]) [[0, 1], [2, 3], [4, 5], [6, 7]] >>> find_isolated_teams([0, 1, 2, 3, 4, 5, 6], [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5)]) [[0, 1, 2], [3, 4, 5], [6]]","solution":"from collections import defaultdict, deque def find_isolated_teams(employees, collaborations): # Create an adjacency list for the employees graph adjacency_list = defaultdict(list) for a, b in collaborations: adjacency_list[a].append(b) adjacency_list[b].append(a) visited = set() isolated_teams = [] def bfs(start): queue = deque([start]) team = [] while queue: emp = queue.popleft() if emp not in visited: visited.add(emp) team.append(emp) for neighbor in adjacency_list[emp]: if neighbor not in visited: queue.append(neighbor) return team for emp in employees: if emp not in visited: isolated_group = bfs(emp) isolated_teams.append(sorted(isolated_group)) return sorted(isolated_teams)"},{"question":"from typing import List, Tuple def is_bipartite_graph(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determines if an undirected graph is bipartite. Parameters: n (int): Number of vertices m (int): Number of edges edges (list of tuples): List of edges in the form of tuples (u, v) Returns: str: \\"YES\\" if the graph is bipartite, otherwise \\"NO\\". Example: >>> is_bipartite_graph(4, 4, [(0, 1), (1, 2), (2, 3), (3, 0)]) \\"YES\\" >>> is_bipartite_graph(3, 3, [(0, 1), (1, 2), (2, 0)]) \\"NO\\"","solution":"from collections import deque, defaultdict def is_bipartite_graph(n, m, edges): Determines if an undirected graph is bipartite. Parameters: n (int): Number of vertices m (int): Number of edges edges (list of tuples): List of edges in the form of tuples (u, v) Returns: str: \\"YES\\" if the graph is bipartite, otherwise \\"NO\\". graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) color = [-1] * n # -1 denotes uncolored def bfs(src): queue = deque([src]) color[src] = 0 while queue: node = queue.popleft() current_color = color[node] for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = 1 - current_color queue.append(neighbor) elif color[neighbor] == current_color: return False return True for i in range(n): if color[i] == -1: if not bfs(i): return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Group the anagrams together from the given list of words. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] >>> group_anagrams([\\"abc\\", \\"bca\\", \\"cab\\"]) [[\\"abc\\", \\"bca\\", \\"cab\\"]] >>> group_anagrams([]) [] >>> group_anagrams([\\"bat\\"]) [[\\"bat\\"]] >>> group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) [[\\"abc\\"], [\\"def\\"], [\\"ghi\\"]] import pytest def test_group_anagrams_example(): words = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] result = group_anagrams(words) expected = [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected]) def test_group_anagrams_empty(): words = [] result = group_anagrams(words) assert result == [] def test_group_anagrams_single_word(): words = [\\"bat\\"] result = group_anagrams(words) expected = [[\\"bat\\"]] assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected]) def test_group_anagrams_no_anagrams(): words = [\\"abc\\", \\"def\\", \\"ghi\\"] result = group_anagrams(words) expected = [[\\"abc\\"], [\\"def\\"], [\\"ghi\\"]] assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected]) def test_group_anagrams_all_anagrams(): words = [\\"abc\\", \\"bca\\", \\"cab\\"] result = group_anagrams(words) expected = [[\\"abc\\", \\"bca\\", \\"cab\\"]] assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected])","solution":"def group_anagrams(words): from collections import defaultdict anagrams = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"def is_palindrome(s: str) -> bool: Checks if the provided string s is a palindrome. >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"Python\\") False >>> is_palindrome(\\"Madam\\") True >>> is_palindrome(\\"madam\\") True def check_palindromes(test_cases: List[str]) -> List[str]: Processes a list of test cases to determine if each string is a palindrome. :param test_cases: List of strings to check for palindrome property :return: List containing \\"Yes\\" or \\"No\\" for each input string >>> check_palindromes([\\"racecar\\", \\"Python\\", \\"Madam\\"]) [\\"Yes\\", \\"No\\", \\"Yes\\"] >>> check_palindromes([\\"Racecar\\", \\"python\\", \\"madam\\", \\"\\"]) [\\"Yes\\", \\"No\\", \\"Yes\\", \\"Yes\\"]","solution":"def is_palindrome(s): Checks if the provided string s is a palindrome. s = s.lower() return s == s[::-1] def check_palindromes(test_cases): Processes a list of test cases to determine if each string is a palindrome. :param test_cases: List of strings to check for palindrome property :return: List containing \\"Yes\\" or \\"No\\" for each input string results = [] for s in test_cases: if is_palindrome(s): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def dominantIndex(nums: List[int]) -> int: Given a non-empty array of integers, determine if the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, otherwise return -1. >>> dominantIndex([3, 6, 1, 0]) 1 >>> dominantIndex([1, 2, 3, 4]) -1 >>> dominantIndex([2, 2, 2, 2]) -1 >>> dominantIndex([1, 0]) 0","solution":"from typing import List def dominantIndex(nums: List[int]) -> int: if not nums: return -1 max_index = 0 for i in range(1, len(nums)): if nums[i] > nums[max_index]: max_index = i for i in range(len(nums)): if i != max_index and nums[max_index] < 2 * nums[i]: return -1 return max_index"},{"question":"def min_moves_to_fill_terrain(matrix): Returns the minimum number of moves required for the water to fill all the accessible areas in the terrain, starting from the lowest height. Args: matrix (List[List[int]]): n x n grid representing the heights of a terrain. Returns: int: Minimum number of moves, or -1 if it is not possible to fill the terrain. Examples: >>> min_moves_to_fill_terrain([ ... [0, 1, 2], ... [1, 2, 3], ... [2, 3, 4] ... ]) 4 >>> min_moves_to_fill_terrain([ ... [3, 3, 4], ... [2, 4, 5], ... [4, 5, 6] ... ]) -1","solution":"from collections import deque def min_moves_to_fill_terrain(matrix): n = len(matrix) if n == 0: return 0 # Initialize the queue with all cells of height 0 queue = deque() visited = [[False] * n for _ in range(n)] for i in range(n): for j in range(n): if matrix[i][j] == 0: queue.append((i, j)) visited[i][j] = True if not queue: return -1 moves = 0 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] while queue: for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and matrix[nx][ny] <= moves + 1: queue.append((nx, ny)) visited[nx][ny] = True moves += 1 # Check if all cells are visited for i in range(n): for j in range(n): if not visited[i][j]: return -1 return moves - 1"},{"question":"def word_frequency(text: str) -> Dict[str, int]: Returns a dictionary with the frequency count of each word in the input text. Words are considered case-insensitively and punctuation is excluded. >>> word_frequency(\\"Hello, how are you? Are you doing well? I'm doing well, thank you!\\") {'hello': 1, 'how': 1, 'are': 2, 'you': 3, 'doing': 2, 'well': 2, 'im': 1, 'thank': 1} >>> word_frequency(\\"Apple apple APPLE\\") {'apple': 3}","solution":"import re from collections import Counter def word_frequency(text): Returns a dictionary with the frequency count of each word in the input text. Words are considered case-insensitively and punctuation is excluded. # Normalize the text to lowercase text = text.lower() # Remove punctuation using regex text = re.sub(r'[^ws]', '', text) # Split text into words words = text.split() # Count the frequency of each word frequency = Counter(words) return dict(frequency)"},{"question":"def sum_positive_negative_numbers(numbers: str) -> (int, int): Given a string of integers separated by commas, returns a tuple containing: - The sum of the positive integers - The sum of the negative integers If the input string is empty, returns (0, 0). >>> sum_positive_negative_numbers(\\"1,2,-3,4,-5\\") == (7, -8) >>> sum_positive_negative_numbers(\\"-2,-3,-4\\") == (0, -9) >>> sum_positive_negative_numbers(\\"\\") == (0, 0) >>> sum_positive_negative_numbers(\\"5,10\\") == (15, 0) >>> sum_positive_negative_numbers(\\"7\\") == (7, 0) >>> sum_positive_negative_numbers(\\"-7\\") == (0, -7) >>> sum_positive_negative_numbers(\\"0\\") == (0, 0) >>> sum_positive_negative_numbers(\\"0,0,0\\") == (0, 0) >>> sum_positive_negative_numbers(\\"1,-1,0\\") == (1, -1)","solution":"def sum_positive_negative_numbers(numbers: str) -> (int, int): Given a string of integers separated by commas, returns a tuple containing: - The sum of the positive integers - The sum of the negative integers If the input string is empty, returns (0, 0). if not numbers: return (0, 0) positive_sum = 0 negative_sum = 0 # Split the string by comma and iterate through each number for num in numbers.split(','): n = int(num) if n > 0: positive_sum += n elif n < 0: negative_sum += n return (positive_sum, negative_sum)"},{"question":"def three_sum(nums: List[int], target: int) -> List[List[int]]: Find all unique triplets in the array that sum up to the given target. :param nums: List of integers :param target: Target sum for the triplets :return: List of unique triplets that sum up to the target from typing import List pass # Unit Tests def test_example_1(): assert three_sum([-1, 0, 1, 2, -1, -4], 0) == [[-1, -1, 2], [-1, 0, 1]] def test_example_2(): result = three_sum([1, 2, 3, 4, 5, 6], 10) expected = [[1, 3, 6], [1, 4, 5], [2, 3, 5]] assert all(triplet in result for triplet in expected) assert all(triplet in expected for triplet in result) def test_example_3(): assert three_sum([5, 5, 5, 5], 15) == [[5, 5, 5]] def test_no_triplets(): assert three_sum([1, 2, 3], 10) == [] def test_duplicates_in_input(): result = three_sum([-2, 0, 0, 2, 2], 0) expected = [[-2, 0, 2]] assert all(triplet in result for triplet in expected) assert all(triplet in expected for triplet in result)","solution":"def three_sum(nums, target): Find all unique triplets in the array that sum up to the given target. :param nums: List of integers :param target: Target sum for the triplets :return: List of unique triplets that sum up to the target nums.sort() res = [] n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == target: res.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return res"},{"question":"def min_max_sums(N: int, K: int, array: List[int]) -> Tuple[int, int]: Determine the minimum and maximum possible sums of selecting K integers from the array. Parameters: N (int): The number of integers in the array. K (int): The number of integers to select. array (List[int]): The array of integers. Returns: Tuple[int, int]: The minimum and maximum sums possible. >>> min_max_sums(5, 3, [3, 7, -2, 5, 1]) (2, 15) >>> min_max_sums(4, 2, [1, 2, 3, 4]) (3, 7) >>> min_max_sums(4, 2, [-1, -2, -3, -4]) (-7, -3) >>> min_max_sums(6, 3, [3, 5, -1, -2, 7, 8]) (0, 20)","solution":"def min_max_sums(N, K, array): Determine the minimum and maximum possible sums of selecting K integers from the array. Parameters: N (int): The number of integers in the array. K (int): The number of integers to select. array (List[int]): The array of integers. Returns: Tuple[int, int]: The minimum and maximum sums possible. # Sort the array to easily find the smallest and largest elements array.sort() # Minimum sum by selecting the smallest K elements min_sum = sum(array[:K]) # Maximum sum by selecting the largest K elements max_sum = sum(array[-K:]) return min_sum, max_sum"},{"question":"from typing import List def double_array(arr: List[int]) -> List[int]: Takes an array of integers and returns a new array with each value doubled. >>> double_array([1, 2, 3]) [2, 4, 6] >>> double_array([0, 5, 10]) [0, 10, 20] >>> double_array([-1, -2, -3]) [-2, -4, -6] >>> double_array([-1, 2, -3, 4]) [-2, 4, -6, 8] >>> double_array([7]) [14]","solution":"def double_array(arr): Returns a new array with each value doubled. return [x * 2 for x in arr]"},{"question":"def minPathSum(matrix): Returns the minimal path sum from the top left to the bottom right of the matrix, where you can only move to the right or downwards. Example: >>> matrix = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> minPathSum(matrix) 7 >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> minPathSum(matrix) 21 pass","solution":"def minPathSum(matrix): Returns the minimal path sum from the top left to the bottom right of the matrix, where you can only move to the right or downwards. n = len(matrix) # Initialize the dynamic programming table with the same dimensions as the matrix dp = [[0] * n for _ in range(n)] # Start with the top-left element dp[0][0] = matrix[0][0] # Fill the first row (only right moves) for j in range(1, n): dp[0][j] = dp[0][j - 1] + matrix[0][j] # Fill the first column (only downward moves) for i in range(1, n): dp[i][0] = dp[i - 1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j] # The bottom-right corner will have the result return dp[n - 1][n - 1]"},{"question":"def wiggle_sort(nums: List[int]) -> List[int]: Sort the given list in 'wiggle' order, where nums[0] <= nums[1] >= nums[2] <= nums[3]... >>> wiggle_sort([3, 5, 2, 1, 6, 4]) [3, 5, 1, 6, 2, 4] >>> wiggle_sort([1, 3, 2, 2, 3, 4]) [1, 3, 2, 4, 2, 3] >>> wiggle_sort([1]) [1] >>> wiggle_sort([2, 1]) [1, 2] >>> wiggle_sort([4, 4, 4, 4]) [4, 4, 4, 4] >>> wiggle_sort([6, 5, 4, 3, 2, 1]) [5, 6, 3, 4, 2, 1] >>> wiggle_sort([-1, -5, 0, 10, -4, -3]) [-5, 0, -4, 10, -3, -1]","solution":"def wiggle_sort(nums): Sort the given list in 'wiggle' order, where nums[0] <= nums[1] >= nums[2] <= nums[3]... for i in range(1, len(nums)): if (i % 2 == 1 and nums[i] < nums[i - 1]) or (i % 2 == 0 and nums[i] > nums[i - 1]): nums[i], nums[i - 1] = nums[i - 1], nums[i] return nums"},{"question":"def count_vowels(text: str) -> int: Returns the number of vowels in the given text. Vowels are a, e, i, o, u, both lowercase and uppercase. >>> count_vowels(\\"aeiou\\") == 5 >>> count_vowels(\\"AEIOU\\") == 5 >>> count_vowels(\\"aAeEiIoOuU\\") == 10 >>> count_vowels(\\"bcdfghjklmnpqrstvwxyz\\") == 0 >>> count_vowels(\\"Hello, World!\\") == 3 >>> count_vowels(\\"\\") == 0","solution":"def count_vowels(text): Returns the number of vowels in the given text. Vowels are a, e, i, o, u, both lowercase and uppercase. vowels = \\"aeiouAEIOU\\" return sum(1 for char in text if char in vowels)"},{"question":"def largest_number(arr): Given a list of non-negative integers, arrange them such that they form the largest possible number. >>> largest_number([10, 2]) \\"210\\" >>> largest_number([3, 30, 34, 5, 9]) \\"9534330\\"","solution":"from functools import cmp_to_key def largest_number(arr): Given a list of non-negative integers, arrange them such that they form the largest possible number. # Custom comparator to use for sorting def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert integers to strings for easy concatenation and comparison arr = list(map(str, arr)) # Sort using custom comparator arr.sort(key=cmp_to_key(compare)) # Edge case: if the largest number is '0', return it instead of '000...' if arr[0] == '0': return '0' # Join sorted array into a single string return ''.join(arr)"},{"question":"class Playlist: Implement the Playlist class which allows for the following functionalities: 1. Initializes the object with maxSize which is the maximum number of songs that can be added to the playlist. 2. Adds the song to the end of the playlist if it hasn't reached the maxSize. 3. Removes and returns the song from the start of the playlist. If the playlist is empty, return \\"No songs in playlist\\". 4. Returns the song at the start of the playlist without removing it. If the playlist is empty, return \\"No songs in playlist\\". 5. Removes all duplicate songs in the playlist except for the first occurrence of each song. Example: playlist = Playlist(5) playlist.addSong(\\"Song1\\") # Playlist becomes [\\"Song1\\"] playlist.addSong(\\"Song2\\") # Playlist becomes [\\"Song1\\", \\"Song2\\"] playlist.addSong(\\"Song1\\") # Playlist becomes [\\"Song1\\", \\"Song2\\", \\"Song1\\"] playlist.removeSong() # Returns \\"Song1\\", Playlist becomes [\\"Song2\\", \\"Song1\\"] playlist.playNext() # Returns \\"Song2\\" playlist.addSong(\\"Song3\\") # Playlist becomes [\\"Song2\\", \\"Song1\\", \\"Song3\\"] playlist.addSong(\\"Song4\\") # Playlist becomes [\\"Song2\\", \\"Song1\\", \\"Song3\\", \\"Song4\\"] playlist.removeDuplicateSongs() # Playlist becomes [\\"Song2\\", \\"Song1\\", \\"Song3\\", \\"Song4\\"] playlist.removeSong() # Returns \\"Song2\\", Playlist becomes [\\"Song1\\", \\"Song3\\", \\"Song4\\"] Constraints: - 1 <= maxSize <= 1000 - Songs are non-empty strings with a maximum length of 100. - At most 1000 calls will be made to each method of addSong, removeSong, playNext, and removeDuplicateSongs. >>> playlist = Playlist(5) >>> playlist.addSong(\\"Song1\\") >>> playlist.songs [\\"Song1\\"] >>> playlist.addSong(\\"Song2\\") [\\"Song1\\", \\"Song2\\"] >>> playlist.addSong(\\"Song1\\") >>> playlist.songs [\\"Song1\\", \\"Song2\\", \\"Song1\\"] >>> playlist.removeSong() \\"Song1\\" >>> playlist.songs [\\"Song2\\", \\"Song1\\"] >>> playlist.playNext() \\"Song2\\" >>> playlist.addSong(\\"Song3\\") >>> playlist.songs [\\"Song2\\", \\"Song1\\", \\"Song3\\"] >>> playlist.removeDuplicateSongs() >>> playlist.songs [\\"Song2\\", \\"Song1\\", \\"Song3\\", \\"Song4\\"] >>> playlist.removeSong() \\"Song2\\" def __init__(self, maxSize: int): pass def addSong(self, song: str): pass def removeSong(self) -> str: pass def playNext(self) -> str: pass def removeDuplicateSongs(self): pass","solution":"class Playlist: def __init__(self, maxSize: int): self.maxSize = maxSize self.songs = [] def addSong(self, song: str): if len(self.songs) < self.maxSize: self.songs.append(song) def removeSong(self) -> str: if self.songs: return self.songs.pop(0) else: return \\"No songs in playlist\\" def playNext(self) -> str: if self.songs: return self.songs[0] else: return \\"No songs in playlist\\" def removeDuplicateSongs(self): seen = set() new_songs = [] for song in self.songs: if song not in seen: new_songs.append(song) seen.add(song) self.songs = new_songs"},{"question":"def generate_pattern(N: int) -> list: Generates an array based on the given pattern. Parameters: - N: int, the number of elements in the array Returns: - list: generated array based on the pattern >>> generate_pattern(1) [1] >>> generate_pattern(2) [1, 3] >>> generate_pattern(4) [1, 3, 6, 10] def pattern_test_cases(T: int, cases: list) -> list: Outputs the array for the given number of test cases. Parameters: - T: int, number of test cases - cases: list of int, the test cases Returns: - list of list: the output arrays for each test case >>> pattern_test_cases(3, [1, 2, 4]) [[1], [1, 3], [1, 3, 6, 10]] >>> pattern_test_cases(1, [3]) [[1, 3, 6]]","solution":"def generate_pattern(N): Generates an array based on the given pattern. Parameters: - N: int, the number of elements in the array Returns: - list: generated array based on the pattern array = [1] for i in range(1, N): next_value = array[i-1] + 1 + i array.append(next_value) return array def pattern_test_cases(T, cases): Outputs the array for the given number of test cases. Parameters: - T: int, number of test cases - cases: list of int, the test cases Returns: - list of list: the output arrays for each test case results = [] for N in cases: results.append(generate_pattern(N)) return results"},{"question":"def remove_duplicates(s: str) -> str: Remove duplicates from the string s while maintaining the order of first occurrences. >>> remove_duplicates(\\"abacd\\") \\"abcd\\" >>> remove_duplicates(\\"mississippi\\") \\"misp\\" >>> remove_duplicates(\\"apple\\") \\"aple\\" def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Process multiple test cases. Parameters: - T (int): number of test cases. - test_cases (list): list of strings for each test case. Returns: - list of results for each test case. >>> process_test_cases(3, [\\"abacd\\", \\"mississippi\\", \\"apple\\"]) [\\"abcd\\", \\"misp\\", \\"aple\\"] >>> process_test_cases(2, [\\"aabbcc\\", \\"\\"]) [\\"abc\\", \\"\\"] >>> process_test_cases(1, [\\"abcdefghijklmnopqrstuvwxyz\\"]) [\\"abcdefghijklmnopqrstuvwxyz\\"] >>> process_test_cases(1, [\\"aaaaaaaaaa\\"]) [\\"a\\"] >>> process_test_cases(1, [\\"thequickbrownfoxjumpsoverthelazydog\\"]) [\\"thequickbrownfxjmpsvlazydg\\"]","solution":"def remove_duplicates(s): Remove duplicates from the string s while maintaining the order of first occurrences. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result) def process_test_cases(T, test_cases): Process multiple test cases. Parameters: - T (int): number of test cases. - test_cases (list): list of strings for each test case. Returns: - list of results for each test case. results = [] for s in test_cases: results.append(remove_duplicates(s)) return results"},{"question":"def is_palindrome_permutation(s: str) -> bool: Determines if a given string is a permutation of a palindrome. Args: s (str): The input string consisting of lowercase and uppercase English letters and spaces. Returns: bool: True if the input string is a permutation of a palindrome, otherwise False. Examples: >>> is_palindrome_permutation(\\"Tact Coa\\") == True >>> is_palindrome_permutation(\\"Hello\\") == False >>> is_palindrome_permutation(\\"aabb\\") == True >>> is_palindrome_permutation(\\"abc cba\\") == True >>> is_palindrome_permutation(\\"abc\\") == False","solution":"def is_palindrome_permutation(s: str) -> bool: Determines if a given string is a permutation of a palindrome. Args: s (str): The input string consisting of lowercase and uppercase English letters and spaces. Returns: bool: True if the input string is a permutation of a palindrome, otherwise False. from collections import Counter # Remove non-letter characters and convert to lowercase cleaned = [char.lower() for char in s if char.isalpha()] # Count the frequency of each character count = Counter(cleaned) # Check the number of characters that have an odd count odd_count = sum(1 for v in count.values() if v % 2 != 0) # A string can be rearranged to a palindrome if at most one character has an odd frequency return odd_count <= 1"},{"question":"def findPairsWithSum(arr, target): Finds all unique pairs in the array that add up to the given target sum. Each pair and the overall list should be sorted in ascending order. >>> findPairsWithSum([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> findPairsWithSum([1, 1, 2, 45, 46, 46], 47) [(1, 46), (2, 45)] >>> findPairsWithSum([1, -2, 3, -4, 5, -6], -1) [(-6, 5), (-4, 3), (-2, 1)] pass","solution":"def findPairsWithSum(arr, target): Finds all unique pairs in the array that add up to the given target sum. Each pair and the overall list should be sorted in ascending order. arr.sort() pairs = set() seen = set() for num in arr: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return sorted(pairs)"},{"question":"from typing import List, Tuple def weight_of_substring(S: str, L: int, R: int) -> int: Calculate the weight of the substring S from index L to R (both inclusive). The weight of a character is defined by its position in the English alphabet. L and R are 1-based indices. >>> weight_of_substring(\\"abcdefg\\", 1, 3) 6 >>> weight_of_substring(\\"abcdefg\\", 2, 4) 9 >>> weight_of_substring(\\"abcdefg\\", 1, 7) 28 pass # Implement the function logic here def process_queries(S: str, queries: List[Tuple[int, int]]) -> List[int]: Processes the list of queries on the string S. Each query is a tuple (L, R). Returns a list of results for each query. >>> process_queries(\\"abcdefg\\", [(1, 3), (2, 4), (1, 7)]) [6, 9, 28] >>> process_queries(\\"zzzzz\\", [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]) [26, 52, 78, 104, 130] >>> process_queries(\\"a\\", [(1, 1)]) [1] pass # Implement the function logic here","solution":"def weight_of_substring(S, L, R): Returns the weight of the substring S[L-1:R]. L and R are 1-based indices. return sum(ord(S[i]) - ord('a') + 1 for i in range(L-1, R)) def process_queries(S, queries): Processes the list of queries on the string S. Each query is a tuple (L, R). Returns a list of results for each query. results = [] for L, R in queries: results.append(weight_of_substring(S, L, R)) return results"},{"question":"import re def findAndReplace(text, target, replacement): Replace all instances of the target word in the text with the replacement word. The function is case-insensitive but maintains the case of the original word being replaced. >>> findAndReplace(\\"Hello World! Hello people!\\", \\"hello\\", \\"hi\\") 'Hi World! Hi people!' >>> findAndReplace(\\"The quick brown fox\\", \\"quick\\", \\"slow\\") 'The slow brown fox' >>> findAndReplace(\\"To be or not to be\\", \\"be\\", \\"exist\\") 'To exist or not to exist' def test_find_and_replace_basic(): assert findAndReplace(\\"Hello World! Hello people!\\", \\"hello\\", \\"hi\\") == \\"Hi World! Hi people!\\" def test_find_and_replace_different_case(): assert findAndReplace(\\"HELLO World! hello people!\\", \\"hello\\", \\"hi\\") == \\"HI World! hi people!\\" def test_find_and_replace_partial_word(): assert findAndReplace(\\"The quick brown fox\\", \\"quick\\", \\"slow\\") == \\"The slow brown fox\\" def test_find_and_replace_multiple_words(): assert findAndReplace(\\"To be or not to be\\", \\"be\\", \\"exist\\") == \\"To exist or not to exist\\" def test_find_and_replace_case_preservation(): assert findAndReplace(\\"Three Boats three BOATS\\", \\"boats\\", \\"ships\\") == \\"Three Ships three SHIPS\\" def test_find_and_replace_no_match(): assert findAndReplace(\\"Hello World!\\", \\"hi\\", \\"hello\\") == \\"Hello World!\\" def test_find_and_replace_special_characters(): assert findAndReplace(\\"Hey there!\\", \\"there\\", \\"world\\") == \\"Hey world!\\" def test_find_and_replace_full_word(): assert findAndReplace(\\"The thoughtful thinker\\", \\"thought\\", \\"idea\\") == \\"The ideaful thinker\\"","solution":"import re def findAndReplace(text, target, replacement): Replaces all instances of the target word in the text with the replacement word. The function is case-insensitive but maintains the case of the original word being replaced. # Define a function for replacement to preserve case def replace_with_case(match): # Get the matched text matched_text = match.group(0) # Determine and return the correct case if matched_text.isupper(): return replacement.upper() elif matched_text.istitle(): return replacement.title() elif matched_text.islower(): return replacement.lower() else: return replacement # Compile regex with case-insensitive flag target_re = re.compile(re.escape(target), re.IGNORECASE) # Use sub method to replace all instances with replacement function result = target_re.sub(replace_with_case, text) return result"},{"question":"def product_of_others(lst: List[int]) -> List[int]: Given a list of integers, return a new list where each element is the product of all the other elements except the one at that index. >>> product_of_others([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_of_others([2, 5, 3]) [15, 6, 10] >>> product_of_others([1, 1, 1]) [1, 1, 1]","solution":"def product_of_others(lst): Returns a new list where each element is the product of all other elements except the one at that index. n = len(lst) if n == 0: return [] # Initialize the result list result = [1] * n # Left product computation left_product = 1 for i in range(n): result[i] = left_product left_product *= lst[i] # Right product computation right_product = 1 for i in range(n - 1, -1, -1): result[i] *= right_product right_product *= lst[i] return result"},{"question":"def lengthOfLongestSubstringTwoDistinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. >>> lengthOfLongestSubstringTwoDistinct(\\"eceba\\") 3 >>> lengthOfLongestSubstringTwoDistinct(\\"ccaabbb\\") 5","solution":"def lengthOfLongestSubstringTwoDistinct(s: str) -> int: Calculate the length of the longest substring with at most two distinct characters. :param s: input string :return: length of the longest substring with at most two distinct characters if len(s) < 3: return len(s) # Dictionary to store the rightmost position of each character hashmap = {} left = 0 max_length = 2 for right in range(len(s)): hashmap[s[right]] = right # If the length of hashmap exceeds 2, remove the leftmost character if len(hashmap) > 2: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def find_triplets(arr: List[int]) -> bool: Determines whether any three integers in the array sum up to zero. >>> find_triplets([1, -1, 2, -2, 3]) == True >>> find_triplets([1, 2, 3, 4, 5]) == False >>> find_triplets([-1, 1, 0, 2, -2]) == True >>> find_triplets([1, 2, -1, -2]) == False >>> find_triplets([-1, -2, -3, -4, -5]) == False","solution":"def find_triplets(arr): Determines whether any three integers in the array sum up to zero. arr.sort() n = len(arr) for i in range(n - 2): a = arr[i] left, right = i + 1, n - 1 while left < right: sum_of_three = a + arr[left] + arr[right] if sum_of_three == 0: return True elif sum_of_three < 0: left += 1 else: right -= 1 return False"},{"question":"def fibonacci_tree_leaves_count(T: int, levels: List[int]) -> List[int]: Compute the total number of leaves in the first N levels of the Fibonacci Tree. >>> fibonacci_tree_leaves_count(3, [3, 5, 10]) [4, 12, 143] >>> fibonacci_tree_leaves_count(1, [0]) [0] >>> fibonacci_tree_leaves_count(1, [1]) [1] >>> fibonacci_tree_leaves_count(1, [2]) [2] >>> fibonacci_tree_leaves_count(1, [50]) [32951280098]","solution":"def fibonacci_tree_leaves_count(T, levels): # Precompute Fibonacci sequence up to F(50) fib = [0] * 51 fib[1] = 1 for i in range(2, 51): fib[i] = fib[i - 1] + fib[i - 2] # Precompute prefix sums of Fibonacci sequence prefix_sum = [0] * 51 for i in range(1, 51): prefix_sum[i] = prefix_sum[i - 1] + fib[i] # Find the total number of leaves for each level in levels results = [] for N in levels: results.append(prefix_sum[N]) return results"},{"question":"def fib(n: int) -> int: Returns the n-th term of the Fibonacci sequence using matrix exponentiation. Ensures an efficient O(log n) time complexity. Args: n (int): The position in the Fibonacci sequence (0-indexed). Returns: int: The n-th Fibonacci number. >>> fib(0) 0 >>> fib(1) 1 >>> fib(2) 1 >>> fib(3) 2 >>> fib(4) 3 >>> fib(5) 5 >>> fib(10) 55 >>> fib(20) 6765 >>> fib(30) 832040","solution":"def fib(n): Returns the n-th term of the Fibonacci sequence using matrix exponentiation. Ensures an efficient O(log n) time complexity. def matrix_mult(A, B): Multiplies two 2x2 matrices A and B. return [ [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]], [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]] ] def matrix_power(matrix, power): Raises the matrix to the specified power using exponentiation by squaring. result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power > 0: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result if n == 0: return 0 # Transformation matrix for Fibonacci; includes F(1) = 1, F(0) = 0 F = [[1, 1], [1, 0]] # Raise the transformation matrix to the (n-1)-th power result = matrix_power(F, n - 1) # The resulting matrix [ [F(n), F(n-1)], [F(n-1), F(n-2)] ] # So F(n) is the top left value return result[0][0]"},{"question":"def is_palindrome_before(s: str, k: int) -> bool: Check whether a given string can become a palindrome by rotating it \`k\` times. Args: s (str): The input string to check, its length is at most 1000 characters. k (int): The number of rotations to perform, an integer between 0 and 1000 inclusive. Returns: bool: True if the string can be made into a palindrome by rotating it up to \`k\` times, False otherwise. Examples: >>> is_palindrome_before(\\"aab\\", 2) True >>> is_palindrome_before(\\"racecar\\", 3) True >>> is_palindrome_before(\\"abcdef\\", 4) False >>> is_palindrome_before(\\"abc\\", 1) False","solution":"def is_palindrome_before(s: str, k: int) -> bool: Returns True if the string s can be made into a palindrome by rotating it up to k times. Otherwise, returns False. def is_palindrome(s: str) -> bool: return s == s[::-1] n = len(s) for i in range(k + 1): rotated_s = s[i:] + s[:i] if is_palindrome(rotated_s): return True return False"},{"question":"def update_dictionary(initial_pairs, updates): Update dictionary based on multiple updates. Parameters: - initial_pairs: A list of tuples where each tuple contains two integers (key, value) - updates: A list of lists where each inner list contains tuples of integers to be updated as key-value pairs Returns: - The updated dictionary after all updates. >>> update_dictionary([(1, 1), (2, 2)], [[(2, 3), (3, 4)]]) {1: 1, 2: 3, 3: 4} >>> update_dictionary([(1, 1)], [[(2, 2)], [(3, 3)]]) {1: 1, 2: 2, 3: 3} >>> update_dictionary([(1, 1), (2, 2)], []) {1: 1, 2: 2} >>> update_dictionary([], [[(1, 1), (2, 2)]]) {1: 1, 2: 2} >>> update_dictionary([(1, 1)], [[]]) {1: 1}","solution":"def update_dictionary(initial_pairs, updates): Update dictionary based on multiple updates. Parameters: - initial_pairs: A list of tuples where each tuple contains two integers (key, value) - updates: A list of lists where each inner list contains tuples of integers to be updated as key-value pairs Returns: - The updated dictionary after all updates. d = dict(initial_pairs) for update in updates: update_dict = dict(update) d.update(update_dict) return d"},{"question":"def reverse_words_in_sentence(sentence: str) -> str: Takes a string containing a sentence and returns the same sentence with each word reversed in order but keeping the words in their original positions. >>> reverse_words_in_sentence(\\"Hello World\\") \\"olleH dlroW\\" >>> reverse_words_in_sentence(\\"Python is fun\\") \\"nohtyP si nuf\\" >>> reverse_words_in_sentence(\\"Hello\\") \\"olleH\\" >>> reverse_words_in_sentence(\\"\\") \\"\\" >>> reverse_words_in_sentence(\\"Hello, World!\\") \\",olleH !dlroW\\"","solution":"def reverse_words_in_sentence(sentence): Takes a string containing a sentence and returns the same sentence with each word reversed in order but keeping the words in their original positions. words = sentence.split() reversed_words = [''.join(reversed(word)) for word in words] return ' '.join(reversed_words)"},{"question":"def did_students_pass(scores: List[int], passing_score: int) -> List[bool]: Given an array of students' scores and the passing score, returns an array of booleans indicating whether each student has passed. Parameters: scores (list): List of students' scores (integers). passing_score (int): The passing score. Returns: list: List of booleans indicating pass (True) or fail (False) for each student. >>> did_students_pass([80, 85, 90], 50) [True, True, True] >>> did_students_pass([30, 45, 25], 50) [False, False, False] pass def score_statistics(scores: List[int]) -> dict: Given an array of students' scores, returns an object containing: - The highest score \`highest\`. - The lowest score \`lowest\`. - The average score rounded to 2 decimals \`average\`. - The total number of students who scored above average \`aboveAverageCount\`. Parameters: scores (list): List of students' scores (integers). Returns: dict: Dictionary containing highest, lowest, average, aboveAverageCount. >>> score_statistics([70, 80, 90, 60, 50]) {\\"highest\\": 90, \\"lowest\\": 50, \\"average\\": 70.0, \\"aboveAverageCount\\": 2} >>> score_statistics([85]) {\\"highest\\": 85, \\"lowest\\": 85, \\"average\\": 85.0, \\"aboveAverageCount\\": 0} pass","solution":"def did_students_pass(scores, passing_score): Given an array of students' scores and the passing score, returns an array of booleans indicating whether each student has passed. Parameters: scores (list): List of students' scores (integers). passing_score (int): The passing score. Returns: list: List of booleans indicating pass (True) or fail (False) for each student. return [score >= passing_score for score in scores] def score_statistics(scores): Given an array of students' scores, returns an object containing: - The highest score \`highest\`. - The lowest score \`lowest\`. - The average score rounded to 2 decimals \`average\`. - The total number of students who scored above average \`aboveAverageCount\`. Parameters: scores (list): List of students' scores (integers). Returns: dict: Dictionary containing highest, lowest, average, aboveAverageCount. if not scores: return {\\"highest\\": None, \\"lowest\\": None, \\"average\\": None, \\"aboveAverageCount\\": 0} highest = max(scores) lowest = min(scores) average = round(sum(scores) / len(scores), 2) above_average_count = sum(1 for score in scores if score > average) return { \\"highest\\": highest, \\"lowest\\": lowest, \\"average\\": average, \\"aboveAverageCount\\": above_average_count }"},{"question":"def longest_active_period(test_cases): For each test case, return the length of the longest contiguous interval where there was at least one signup each day. >>> longest_active_period([(5, [1, 2, 0, 4, 5]), (6, [0, 0, 0, 0, 0, 0]), (8, [1, 1, 1, 0, 1, 1, 0, 1])]) [2, 0, 3] >>> longest_active_period([(1, [1]), (1, [0])]) [1, 0] def parse_input(input_str): Parses input string to extract number of test cases and corresponding data. >>> parse_input(\\"3n5n1 2 0 4 5n6n0 0 0 0 0 0n8n1 1 1 0 1 1 0 1\\") [(5, [1, 2, 0, 4, 5]), (6, [0, 0, 0, 0, 0, 0]), (8, [1, 1, 1, 0, 1, 1, 0, 1])] >>> parse_input(\\"2n1n1n1n0\\") [(1, [1]), (1, [0])] def solution(input_str): Process the given input string and return the result as specified. >>> solution(\\"3n5n1 2 0 4 5n6n0 0 0 0 0 0n8n1 1 1 0 1 1 0 1\\") '2n0n3' >>> solution(\\"2n1n1n1n0\\") '1n0'","solution":"def longest_active_period(test_cases): results = [] for case in test_cases: n, days = case max_length, current_length = 0, 0 for signup in days: if signup > 0: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 results.append(max_length) return results def parse_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): n = int(input_lines[index]) days = list(map(int, input_lines[index + 1].split())) test_cases.append((n, days)) index += 2 return test_cases def solution(input_str): test_cases = parse_input(input_str) results = longest_active_period(test_cases) return 'n'.join(map(str, results))"},{"question":"def reverse_alphanumeric(input_string: str) -> str: This function takes a string as input and returns a new string with the characters in reverse order, but with all non-alphanumeric characters removed. >>> reverse_alphanumeric(\\"a!b@c#1\\") '1cba' >>> reverse_alphanumeric(\\"AbC!\\") 'CbA' >>> reverse_alphanumeric(\\"a b c 1\\") '1cba' >>> reverse_alphanumeric(\\"!@#%^&*()\\") '' >>> reverse_alphanumeric(\\"abc123\\") '321cba' >>> reverse_alphanumeric(\\"\\") '' >>> reverse_alphanumeric(\\"A1b2C3!\\") '3C2b1A'","solution":"def reverse_alphanumeric(input_string): This function takes a string as input and returns a new string with the characters in reverse order, but with all non-alphanumeric characters removed. # Filter out non-alphanumeric characters alphanumeric_chars = [char for char in input_string if char.isalnum()] # Reverse the list of alphanumeric characters and join them to form a new string return ''.join(alphanumeric_chars[::-1])"},{"question":"def sum_from_a_to_b(a: int, b: int) -> int: Returns the sum of integers from a to b (inclusive). >>> sum_from_a_to_b(1, 10) == 55 >>> sum_from_a_to_b(15, 20) == 105 >>> sum_from_a_to_b(100, 105) == 615 def coding_marathon_sums(groups: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Computes the sum of integers from a to b for each participant in each group. :param groups: List of tuples, where each tuple is (P, [(a, b), ...]) :return: List of sums for all participants in all groups. >>> coding_marathon_sums([(3, [(1, 10), (15, 20), (100, 105)])]) == [55, 105, 615] >>> coding_marathon_sums([(3, [(1, 10), (15, 20), (100, 105)]), (2, [(5, 8), (10, 15)])]) == [55, 105, 615, 26, 75]","solution":"def sum_from_a_to_b(a, b): Returns the sum of integers from a to b (inclusive). return (b * (b + 1)) // 2 - ((a - 1) * a) // 2 def coding_marathon_sums(groups): Computes the sum of integers from a to b for each participant in each group. :param groups: List of tuples, where each tuple is (P, [(a, b), ...]) :return: List of sums for all participants in all groups. results = [] for group in groups: P, participants = group for a, b in participants: results.append(sum_from_a_to_b(a, b)) return results"},{"question":"from typing import List def get_nth_permutation(n: int, k: int) -> List[int]: Create a function that takes an integer n and an integer k as input and returns the kth permutation of the sequence of numbers [1, 2, ..., n] sorted in lexicographic order. >>> get_nth_permutation(3, 1) == [1, 2, 3] >>> get_nth_permutation(3, 4) == [2, 3, 1]","solution":"import math from typing import List def get_nth_permutation(n: int, k: int) -> List[int]: Returns the kth permutation (zero-indexed) of sequence [1, 2, ..., n] in lexicographic order. # List of numbers to get permutations from numbers = list(range(1, n + 1)) # Initialize permutation result result = [] # Adjust k to be zero-indexed k -= 1 while n > 0: n -= 1 # Calculate the factorial of the remaining numbers fact = math.factorial(n) # Calculate the index of the current number index = k // fact # Reduce k by removing the permuted index k %= fact # Append the number at the index and remove from the list result.append(numbers.pop(index)) return result"},{"question":"from typing import List def group_strings(strings: List[str]) -> List[List[str]]: Group strings by the frequency of their digits. >>> group_strings([\\"1122\\", \\"2211\\", \\"1212\\", \\"2112\\", \\"1234\\", \\"4321\\", \\"1211\\"]) [[\\"1122\\", \\"2211\\", \\"1212\\", \\"2112\\"], [\\"1234\\", \\"4321\\"], [\\"1211\\"]] >>> group_strings([\\"1\\", \\"2\\", \\"3\\"]) [[\\"1\\"], [\\"2\\"], [\\"3\\"]] >>> group_strings([\\"111\\", \\"111\\", \\"111\\"]) [[\\"111\\", \\"111\\", \\"111\\"]] >>> group_strings([\\"12\\", \\"21\\", \\"1111\\", \\"2345\\", \\"5432\\", \\"5555\\", \\"0011\\", \\"1100\\"]) [[\\"12\\", \\"21\\"], [\\"1111\\"], [\\"2345\\", \\"5432\\"], [\\"5555\\"], [\\"0011\\", \\"1100\\"]]","solution":"from collections import Counter, defaultdict from typing import List def group_strings(strings: List[str]) -> List[List[str]]: def get_frequency_key(s: str) -> tuple: count = Counter(s) key = tuple(count.get(str(i), 0) for i in range(10)) return key groups = defaultdict(list) for s in strings: freq_key = get_frequency_key(s) groups[freq_key].append(s) return list(groups.values())"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): Given the head of a singly linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k, then left-out nodes in the end should remain as it is. Example 1: Input: head = [1,2,3,4,5], k = 2 Output: [2,1,4,3,5] Example 2: Input: head = [1,2,3,4,5,6,7,8], k = 3 Output: [3,2,1,6,5,4,7,8] Example 3: Input: head = [1,2,3,4,5], k = 1 Output: [1,2,3,4,5] Note: The given linked list will have between 1 and 5000 nodes. 0 <= Node.val <= 10^9","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): Given the head of a singly linked list, reverse the nodes of the list k at a time, and return the modified list. dummy = ListNode(0) dummy.next = head curr, prev, nxt = dummy, dummy, dummy count = 0 while curr.next: curr = curr.next count += 1 while count >= k: curr = prev.next nxt = curr.next for _ in range(1, k): curr.next = nxt.next nxt.next = prev.next prev.next = nxt nxt = curr.next prev = curr count -= k return dummy.next"},{"question":"from typing import List def num_identical_pairs(nums: List[int]) -> int: Find the number of pairs (i, j) where 0 <= i < j < nums.length and nums[i] == nums[j]. Examples: >>> num_identical_pairs([1, 2, 3, 1, 1, 3]) 4 >>> num_identical_pairs([1, 1, 1, 1]) 6 >>> num_identical_pairs([1, 2, 3]) 0","solution":"def num_identical_pairs(nums): Returns the number of good pairs (i, j) where 0 <= i < j < nums.length and nums[i] == nums[j]. :param nums: List of integers :return: Integer - the count of good pairs count = 0 freq = {} for num in nums: if num in freq: count += freq[num] freq[num] += 1 else: freq[num] = 1 return count"},{"question":"from typing import List def maxProfit(prices: List[int]) -> int: Determine the maximum profit you can achieve by buying and selling one share of a stock. You are given an array of prices where the i-th element represents the price of a stock on day i. You are only allowed to complete at most one transaction (i.e., buy one and sell one share of the stock). - Input: A list of integers \`prices\` where each element represents the price of a stock on that particular day. - Output: An integer representing the maximum profit you can achieve from this transaction. If no profit is possible, return 0. >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([1, 2, 3, 4, 5]) 4 >>> maxProfit([]) 0 >>> maxProfit([3]) 0 pass","solution":"from typing import List def maxProfit(prices: List[int]) -> int: if not prices: return 0 min_price = prices[0] max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def is_secure_password(password: str) -> bool: Check if a given password is secure based on the following criteria: 1. It must be at least 12 characters long. 2. It must contain at least one uppercase letter. 3. It must contain at least one lowercase letter. 4. It must contain at least one numeric digit. 5. It must contain at least one special character from the following set: !@#%^&*()-_=+[]{}|;:,.<>?/ Examples: >>> is_secure_password(\\"Secure!Password123\\") True >>> is_secure_password(\\"short1!\\") False","solution":"def is_secure_password(password: str) -> bool: Check if the given password is secure based on specific criteria. Args: password (str): The password to be validated. Returns: bool: True if the password is secure, else False. if len(password) < 12: return False has_upper = any(c.isupper() for c in password) has_lower = any(c.islower() for c in password) has_digit = any(c.isdigit() for c in password) has_special = any(c in \\"!@#%^&*()-_=+[]{}|;:,.<>?/\\" for c in password) return has_upper and has_lower and has_digit and has_special"},{"question":"import math def min_packs_needed(T: int, testcases: List[Tuple[int, int]]) -> List[int]: Determines the minimum number of packs needed to buy at least C candies, when each pack holds exactly X candies. Parameters: T (int): number of testcases testcases (list of tuples): each tuple contains two integers C (number of candies needed) and X (number of candies each pack can hold) Returns: list: a list of minimum packs needed for each testcase >>> min_packs_needed(2, [(100, 7), (40, 8)]) [15, 5] >>> min_packs_needed(1, [(1, 1)]) [1] >>> min_packs_needed(1, [(1, 1000)]) [1]","solution":"import math def min_packs_needed(T, testcases): Determines the minimum number of packs needed to buy at least C candies, when each pack holds exactly X candies. Parameters: T (int): number of testcases testcases (list of tuples): each tuple contains two integers C (number of candies needed) and X (number of candies each pack can hold) Returns: list: a list of minimum packs needed for each testcase results = [] for C, X in testcases: packs_needed = math.ceil(C / X) results.append(packs_needed) return results"},{"question":"def diamond_shape(n: int) -> str: Construct a diamond shape of asterisks. :param n: The number of lines in the widest part of the diamond (the middle line) :return: A string representation of the diamond >>> print(diamond_shape(1)) * >>> print(diamond_shape(2)) * *** * >>> print(diamond_shape(3)) * *** ***** *** * >>> print(diamond_shape(4)) * *** ***** ******* ***** *** *","solution":"def diamond_shape(n: int) -> str: Construct a diamond shape of asterisks. :param n: The number of lines in the widest part of the diamond (the middle line) :return: A string representation of the diamond lines = [] for i in range(n): spaces = n - i - 1 stars = 2 * i + 1 lines.append(' ' * spaces + '*' * stars) for i in range(n - 2, -1, -1): spaces = n - i - 1 stars = 2 * i + 1 lines.append(' ' * spaces + '*' * stars) return 'n'.join(lines)"},{"question":"def largest_factorial(n: int) -> int: Given a positive integer n, returns the largest factorial number less than or equal to n. If there is no such number, returns 1 (since 0! = 1). Example usage: >>> largest_factorial(5) 2 >>> largest_factorial(24) 24 >>> largest_factorial(1) 1 >>> largest_factorial(0) 1","solution":"def largest_factorial(n): Returns the largest factorial number less than or equal to n. if n < 1: return 1 factorial = 1 i = 1 while True: next_factorial = factorial * i if next_factorial > n: return factorial factorial = next_factorial i += 1"},{"question":"def group_names_by_initial(names: List[str]) -> dict: Groups names by their starting character (case-insensitive). Parameters: names (list of str): The list of names to be grouped. Returns: dict: A dictionary where keys are uppercase initials and values are lists of names. >>> group_names_by_initial([\\"Alice\\", \\"adam\\", \\"Bob\\", \\"barbara\\", \\"Charlie\\", \\"carter\\"]) {'A': ['Alice', 'adam'], 'B': ['Bob', 'barbara'], 'C': ['Charlie', 'carter']} >>> group_names_by_initial([\\"Abby\\", \\"Alan\\", \\"alex\\"]) {'A': ['Abby', 'Alan', 'alex']} >>> group_names_by_initial([\\"Zach\\"]) {'Z': ['Zach']} >>> group_names_by_initial([\\"Ada\\", \\"Ben\\", \\"Chris\\"]) {'A': ['Ada'], 'B': ['Ben'], 'C': ['Chris']} >>> group_names_by_initial([\\"Albert\\", \\"betty\\", \\"CHARLES\\"]) {'A': ['Albert'], 'B': ['betty'], 'C': ['CHARLES']}","solution":"def group_names_by_initial(names): Groups names by their starting character (case-insensitive). Parameters: names (list of str): The list of names to be grouped. Returns: dict: A dictionary where keys are uppercase initials and values are lists of names. from collections import defaultdict grouped_names = defaultdict(list) for name in names: initial = name[0].upper() grouped_names[initial].append(name) return dict(grouped_names)"},{"question":"from typing import List def alien_order(words: List[str]) -> str: Given a list of words sorted lexicographically according to an unknown alphabet order, return a possible order of characters in the alien language. >>> alien_order([\\"wrt\\", \\"wrf\\", \\"er\\", \\"ett\\", \\"rftt\\"]) 'wertf' >>> alien_order([\\"word\\"]) 'word' >>> alien_order([\\"abc\\", \\"ab\\"]) '' >>> alien_order([\\"abc\\", \\"abc\\"]) 'abc' >>> alien_order([\\"z\\", \\"x\\", \\"z\\"]) '' >>> alien_order([\\"abc\\", \\"def\\"]) 'abcdef' >>> alien_order([\\"r\\", \\"rt\\", \\"rtt\\", \\"rttt\\", \\"rtttt\\", \\"rttttt\\", \\"rtttttt\\"]) 'rt'","solution":"from collections import defaultdict, deque def alien_order(words): Given a list of words sorted lexicographically according to an unknown alphabet order, return a possible order of characters in the alien language. def build_graph(words): graph = defaultdict(set) indegree = defaultdict(int) # Initialize the graph with all unique characters for word in words: for char in word: indegree[char] = 0 # Create edges between characters based on the given order in words for i in range(len(words) - 1): first_word = words[i] second_word = words[i + 1] min_length = min(len(first_word), len(second_word)) for j in range(min_length): if first_word[j] != second_word[j]: if second_word[j] not in graph[first_word[j]]: graph[first_word[j]].add(second_word[j]) indegree[second_word[j]] += 1 break else: # Check for a prefix condition; if so, the order is invalid if len(first_word) > len(second_word): return {}, {} return graph, indegree def topological_sort(graph, indegree): # Topological sorting using Kahn's algorithm zero_indegree_queue = deque([char for char in indegree if indegree[char] == 0]) order = [] while zero_indegree_queue: current = zero_indegree_queue.popleft() order.append(current) for neighbor in graph[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) if len(order) == len(indegree): return ''.join(order) else: return \\"\\" graph, indegree = build_graph(words) if not graph and not indegree: return \\"\\" return topological_sort(graph, indegree)"},{"question":"def stringMathExp(num1, op, num2): Performs a mathematical operation on two numbers based on the provided operator. Args: num1 (int, float): The first number. op (str): The operator, one of \\"+\\", \\"-\\", \\"*\\", \\"/\\". num2 (int, float): The second number. Returns: float, int, str: The result of the mathematical operation, \\"undefined\\" if division by zero, or \\"error\\" if the operator is invalid. Examples: >>> stringMathExp(10, \\"+\\", 5) 15 >>> stringMathExp(10, \\"-\\", 3) 7 >>> stringMathExp(10, \\"*\\", 5) 50 >>> stringMathExp(10, \\"/\\", 2) 5 >>> stringMathExp(10, \\"/\\", 0) \\"undefined\\" >>> stringMathExp(10, \\"^\\", 5) \\"error\\"","solution":"def stringMathExp(num1, op, num2): Performs a mathematical operation on two numbers based on the provided operator. if op == \\"+\\": return num1 + num2 elif op == \\"-\\": return num1 - num2 elif op == \\"*\\": return num1 * num2 elif op == \\"/\\": if num2 == 0: return \\"undefined\\" else: return num1 / num2 else: return \\"error\\""},{"question":"def is_palindrome(s: str) -> bool: Determines if the given string is a valid palindrome after removing all non-alphanumeric characters and ignoring case differences. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"madam in eden im adam\\") True >>> is_palindrome(\\"A Santa at Nasa!\\") True >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"123 321\\") True >>> is_palindrome(\\"123 234\\") False","solution":"def is_palindrome(s): Determines if the given string is a valid palindrome after removing all non-alphanumeric characters and ignoring case differences. # Convert string to lower case s = s.lower() # Filter out non-alphanumeric characters filtered_chars = [char for char in s if char.isalnum()] # Check if the filtered string is equal to its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"from typing import List, Tuple def find_anagram_pairs(words: List[str]) -> List[Tuple[str, str]]: Returns a list of tuples containing all anagram pairs from the input list of words. Args: words (List[str]): A list of strings. Returns: List[Tuple[str, str]]: A list of tuples representing anagram pairs. Examples: >>> find_anagram_pairs([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\", \\"elogog\\"]) [(\\"enlist\\", \\"listen\\"), (\\"enlist\\", \\"silent\\"), (\\"listen\\", \\"silent\\"), (\\"elogog\\", \\"gogole\\"), (\\"elogog\\", \\"google\\"), (\\"gogole\\", \\"google\\")] >>> find_anagram_pairs([\\"abc\\", \\"def\\", \\"ghi\\"]) [] pass def test_find_anagram_pairs_example(): words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\", \\"elogog\\"] expected = [ (\\"enlist\\", \\"listen\\"), (\\"enlist\\", \\"silent\\"), (\\"listen\\", \\"silent\\"), (\\"elogog\\", \\"gogole\\"), (\\"elogog\\", \\"google\\"), (\\"gogole\\", \\"google\\") ] assert sorted(find_anagram_pairs(words)) == sorted(expected) def test_find_anagram_pairs_no_anagrams(): words = [\\"abc\\", \\"def\\", \\"ghi\\"] expected = [] assert find_anagram_pairs(words) == expected def test_find_anagram_pairs_with_duplicates(): words = [\\"abc\\", \\"bca\\", \\"cab\\", \\"abc\\"] expected = [ (\\"abc\\", \\"abc\\"), (\\"abc\\", \\"bca\\"), (\\"abc\\", \\"cab\\"), (\\"abc\\", \\"bca\\"), (\\"abc\\", \\"cab\\"), (\\"bca\\", \\"cab\\") ] assert sorted(find_anagram_pairs(words)) == sorted(expected) def test_find_anagram_pairs_single_anagram(): words = [\\"abc\\", \\"def\\", \\"fed\\"] expected = [(\\"def\\", \\"fed\\")] assert find_anagram_pairs(words) == expected def test_find_anagram_pairs_large_input(): words = [\\"a\\" * 100, \\"a\\" * 99 + \\"b\\", \\"b\\" * 50 + \\"a\\" * 50, \\"aaaaa\\", \\"aaaaa\\"] expected = [(\\"aaaaa\\", \\"aaaaa\\")] assert find_anagram_pairs(words) == expected","solution":"from typing import List, Tuple from collections import defaultdict def find_anagram_pairs(words: List[str]) -> List[Tuple[str, str]]: Returns a list of tuples containing all anagram pairs from the input list of words. # Using a dictionary to group words by sorted tuple of characters anagram_dict = defaultdict(list) for word in words: sorted_word = tuple(sorted(word)) anagram_dict[sorted_word].append(word) anagram_pairs = [] # For each group of anagrams, we need to generate pair combinations for group in anagram_dict.values(): if len(group) > 1: sorted_group = sorted(group) for i in range(len(sorted_group)): for j in range(i + 1, len(sorted_group)): anagram_pairs.append((sorted_group[i], sorted_group[j])) return anagram_pairs"},{"question":"def sort_dict_list(dict_list, key_name): Write a function that takes a list of dictionaries and a key name, then returns a new list of dictionaries sorted by the values associated with the given key in ascending order. If the key is not present in a dictionary, that dictionary should be placed at the end of the list. :param dict_list: List of dictionaries to be sorted. :param key_name: Key name to sort the dictionaries by. :return: Sorted list of dictionaries. Examples: >>> sort_dict_list([{\\"id\\": 3, \\"name\\": \\"Alice\\"}, {\\"id\\": 1, \\"name\\": \\"Bob\\"}, {\\"id\\": 2}], \\"id\\") [{\\"id\\": 1, \\"name\\": \\"Bob\\"}, {\\"id\\": 2}, {\\"id\\": 3, \\"name\\": \\"Alice\\"}] >>> sort_dict_list([{\\"id\\": 3, \\"age\\": 25}, {\\"age\\": 22}, {\\"id\\": 2, \\"age\\": 23}, {\\"id\\": 1}], \\"id\\") [{\\"id\\": 1}, {\\"id\\": 2, \\"age\\": 23}, {\\"id\\": 3, \\"age\\": 25}, {\\"age\\": 22}] >>> sort_dict_list([{\\"name\\": \\"Charlie\\"}, {\\"name\\": \\"Alice\\"}, {\\"name\\": \\"Bob\\"}], \\"name\\") [{\\"name\\": \\"Alice\\"}, {\\"name\\": \\"Bob\\"}, {\\"name\\": \\"Charlie\\"}] >>> sort_dict_list([{\\"x\\": 5}, {\\"y\\": 7}, {\\"x\\": 3}], \\"x\\") [{\\"x\\": 3}, {\\"x\\": 5}, {\\"y\\": 7}]","solution":"def sort_dict_list(dict_list, key_name): Returns a new list of dictionaries sorted by the values associated with the given key in ascending order. If the key is not present in a dictionary, that dictionary is placed at the end of the list. :param dict_list: List of dictionaries to be sorted. :param key_name: Key name to sort the dictionaries by. :return: Sorted list of dictionaries. # Separate dictionaries with and without the specified key with_key = [d for d in dict_list if key_name in d] without_key = [d for d in dict_list if key_name not in d] # Sort dictionaries containing the specified key by the value associated with the key with_key_sorted = sorted(with_key, key=lambda x: x[key_name]) # Combine sorted dictionaries with key and those without key return with_key_sorted + without_key"},{"question":"def has_pair_with_diff(arr, K): Check if there exist two distinct indices i and j such that the absolute difference between arr[i] and arr[j] is at most K. def run_test_cases(test_cases): Run the test cases to determine if there exist two distinct indices with the specified conditions. >>> run_test_cases([(5, 2, [1, 5, 3, 2, 8])]) == [\\"YES\\"] >>> run_test_cases([(3, 0, [1, 2, 3])]) == [\\"NO\\"] >>> run_test_cases([(4, 5, [1, 3, 6, 9])]) == [\\"YES\\"] >>> run_test_cases([(2, 1, [10, 20])]) == [\\"NO\\"] >>> run_test_cases([(5, 10, [-5, 0, 5, 10, 15])]) == [\\"YES\\"] from solution import run_test_cases def test_case_1(): assert run_test_cases([(5, 2, [1, 5, 3, 2, 8])]) == [\\"YES\\"] def test_case_2(): assert run_test_cases([(3, 0, [1, 2, 3])]) == [\\"NO\\"] def test_case_3(): assert run_test_cases([(4, 5, [1, 3, 6, 9])]) == [\\"YES\\"] def test_case_4(): assert run_test_cases([(2, 1, [10, 20])]) == [\\"NO\\"] def test_case_5(): assert run_test_cases([(5, 10, [-5, 0, 5, 10, 15])]) == [\\"YES\\"] def test_multiple_cases(): test_cases = [ (5, 2, [1, 5, 3, 2, 8]), (3, 0, [1, 2, 3]), (4, 5, [1, 3, 6, 9]), (2, 1, [10, 20]), (5, 10, [-5, 0, 5, 10, 15]) ] expected_outputs = [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\", \\"YES\\"] assert run_test_cases(test_cases) == expected_outputs","solution":"def has_pair_with_diff(arr, K): Check if there exist two distinct indices i and j such that the absolute difference between arr[i] and arr[j] is at most K. arr = sorted(arr) n = len(arr) for i in range(n): for j in range(i + 1, n): if abs(arr[i] - arr[j]) <= K: return \\"YES\\" if abs(arr[i] - arr[j]) > K: break return \\"NO\\" def run_test_cases(test_cases): result = [] for N, K, arr in test_cases: result.append(has_pair_with_diff(arr, K)) return result"},{"question":"def fibonacci_recursive(n: int) -> int: Calculate the nth Fibonacci number using the recursive method. >>> fibonacci_recursive(0) == 0 >>> fibonacci_recursive(1) == 1 >>> fibonacci_recursive(2) == 1 >>> fibonacci_recursive(3) == 2 >>> fibonacci_recursive(4) == 3 >>> fibonacci_recursive(5) == 5 >>> fibonacci_recursive(6) == 8 pass def fibonacci_iterative(n: int) -> int: Calculate the nth Fibonacci number using the iterative method. >>> fibonacci_iterative(0) == 0 >>> fibonacci_iterative(1) == 1 >>> fibonacci_iterative(2) == 1 >>> fibonacci_iterative(3) == 2 >>> fibonacci_iterative(4) == 3 >>> fibonacci_iterative(5) == 5 >>> fibonacci_iterative(6) == 8 pass def fibonacci_memoized(n: int, memo: dict = {}) -> int: Calculate the nth Fibonacci number using the memoized (dynamic programming) method. >>> fibonacci_memoized(0) == 0 >>> fibonacci_memoized(1) == 1 >>> fibonacci_memoized(2) == 1 >>> fibonacci_memoized(3) == 2 >>> fibonacci_memoized(4) == 3 >>> fibonacci_memoized(5) == 5 >>> fibonacci_memoized(6) == 8 pass","solution":"def fibonacci_recursive(n): Calculates the nth Fibonacci number using the recursive method. if n <= 0: return 0 elif n == 1: return 1 else: return fibonacci_recursive(n-1) + fibonacci_recursive(n-2) def fibonacci_iterative(n): Calculates the nth Fibonacci number using the iterative method. if n <= 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def fibonacci_memoized(n, memo={}): Calculates the nth Fibonacci number using the memoized (dynamic programming) method. if n <= 0: return 0 elif n == 1: return 1 if n not in memo: memo[n] = fibonacci_memoized(n-1, memo) + fibonacci_memoized(n-2, memo) return memo[n]"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Checks if a string's characters can be rearranged to form a palindrome. # implementation goes here def check_palindromes(T: int, test_cases: List[str]) -> List[str]: For each string in test_cases, determine if its characters can be rearranged to form a palindromic string. # implementation goes here # Example usage: # print(check_palindromes(3, ['aabb', 'abc', 'aab'])) # Output: ['YES', 'NO', 'YES'] # Unit tests def test_palindrome_single_char(): assert can_form_palindrome('a') == True def test_palindrome_even_chars(): assert can_form_palindrome('aabb') == True def test_palindrome_odd_chars(): assert can_form_palindrome('aab') == True def test_palindrome_no(): assert can_form_palindrome('abc') == False def test_check_palindromes(): assert check_palindromes(3, ['aabb', 'abc', 'aab']) == ['YES', 'NO', 'YES'] assert check_palindromes(2, ['aaa', 'aabbcc']) == ['YES', 'YES'] assert check_palindromes(1, ['abcd']) == ['NO']","solution":"def can_form_palindrome(s): Checks if a string's characters can be rearranged to form a palindrome. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1 def check_palindromes(T, test_cases): For each string in test_cases, determine if its characters can be rearranged to form a palindromic string. results = [] for case in test_cases: if can_form_palindrome(case): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def number_to_words(num: int) -> str: Converts a non-negative integer less than 1000 to its English words representation. >>> number_to_words(0) 'zero' >>> number_to_words(123) 'one hundred twenty three' >>> number_to_words(45) 'forty five' >>> number_to_words(999) 'nine hundred ninety nine'","solution":"def number_to_words(num): Converts a non-negative integer less than 1000 to its English words representation. if num == 0: return \\"zero\\" ones = [\\"\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\"] teens = [\\"ten\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\"] tens = [\\"\\", \\"\\", \\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\"] result = [] # Handle hundreds place if num >= 100: result.append(ones[num // 100]) result.append(\\"hundred\\") num %= 100 # Handle tens and ones place if num >= 20: result.append(tens[num // 10]) num %= 10 if num > 0: result.append(ones[num]) elif num >= 10: result.append(teens[num - 10]) elif num > 0: result.append(ones[num]) return \\" \\".join(result)"},{"question":"def trap_rain_water(height): Returns the total amount of water that can be trapped after raining on the given elevation map. Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. Example 1: >>> trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 Example 2: >>> trap_rain_water([4,2,0,3,2,5]) 9 Constraints: - 0 <= height[i] <= 10^5 from solution import trap_rain_water def test_trap_rain_water_example1(): assert trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 def test_trap_rain_water_example2(): assert trap_rain_water([4,2,0,3,2,5]) == 9 def test_trap_rain_water_empty(): assert trap_rain_water([]) == 0 def test_trap_rain_water_no_trap(): assert trap_rain_water([0,1,2,3,4]) == 0 def test_trap_rain_water_not_enough_height(): assert trap_rain_water([4,4,4,4,4]) == 0 def test_trap_rain_water_single_peak(): assert trap_rain_water([0,4,0]) == 0","solution":"def trap_rain_water(height): Returns the total amount of water that can be trapped after raining on the given elevation map. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"def highest_occurrence(input_str: str, letter: str) -> str: Design a function that takes in a string and returns the word in the string with the highest occurrence of a particular letter. If multiple words have the same highest occurrence of that letter, return the first such word. If the string is empty or the letter does not appear in any word, return an empty string. >>> highest_occurrence(\\"hello world\\", \\"l\\") == \\"hello\\" >>> highest_occurrence(\\"test the function\\", \\"t\\") == \\"test\\" >>> highest_occurrence(\\"functional programming\\", \\"g\\") == \\"programming\\" >>> highest_occurrence(\\"\\", \\"a\\") == \\"\\" pass","solution":"def highest_occurrence(input_str: str, letter: str) -> str: words = input_str.split() max_count = 0 result_word = \\"\\" for word in words: count = word.count(letter) if count > max_count: max_count = count result_word = word return result_word"},{"question":"def flattenAndCount(nested_list): Flattens a nested list into a single-level list and returns the count of the original elements, including those within all nested sub-arrays. Parameters: nested_list (list): The nested list to flatten. Returns: dict: A dictionary with 'flattened' as the key for the flattened list and 'count' as the key for the count of original elements. >>> flattenAndCount([1, 2, 3]) {'flattened': [1, 2, 3], 'count': 3} >>> flattenAndCount([\\"x\\", \\"y\\", [\\"z\\"]]) {'flattened': [\\"x\\", \\"y\\", \\"z\\"], 'count': 4} >>> flattenAndCount([1, 2, [3, 4, [5]]]) {'flattened': [1, 2, 3, 4, 5], 'count': 7} >>> flattenAndCount([]) {'flattened': [], 'count': 0} >>> flattenAndCount([[], [[]], [[], []]]) {'flattened': [], 'count': 6} >>> flattenAndCount([1, [2, \\"three\\"], [[4, 5], \\"six\\"], []]) {'flattened': [1, 2, \\"three\\", 4, 5, \\"six\\"], 'count': 10}","solution":"def flattenAndCount(nested_list): Flattens a nested list into a single-level list and returns the count of the original elements, including those within all nested sub-arrays. Parameters: nested_list (list): The nested list to flatten. Returns: dict: A dictionary with 'flattened' as the key for the flattened list and 'count' as the key for the count of original elements. flattened_list = [] element_count = 0 def flatten(lst): nonlocal element_count for item in lst: if isinstance(item, list): element_count += 1 # Count the nested list itself as an element flatten(item) else: flattened_list.append(item) element_count += 1 # Count the item flatten(nested_list) return {'flattened': flattened_list, 'count': element_count}"},{"question":"def total_sum_of_prefix_lengths(n: int, s: str) -> int: Compute the total sum of the lengths of all prefixes for each character in the string. Args: n (int): Length of the string s (str): Input string consisting of lowercase English alphabets Returns: int: Total sum of the lengths of all prefixes Examples: >>> total_sum_of_prefix_lengths(5, \\"abcba\\") 15 >>> total_sum_of_prefix_lengths(7, \\"abcdefg\\") 28","solution":"def total_sum_of_prefix_lengths(n, s): Function to compute the total sum of the lengths of all prefixes for each character in the string. Args: n (int): Length of the string s (str): Input string consisting of lowercase English alphabets Returns: int: Total sum of the lengths of all prefixes total_sum = 0 for i in range(1, n+1): total_sum += i return total_sum"},{"question":"def longest_subarray_with_sum(arr: List[int], target: int) -> int: Returns the length of the longest subarray with the given sum 'target'. If no such subarray exists, returns 0. Args: arr : List[int] - List of integers. target : int - Target sum for the subarray. Returns: int - Length of the longest subarray with sum equals to target. Examples: >>> longest_subarray_with_sum([1, -1, 5, -2, 3], 3) 4 >>> longest_subarray_with_sum([-2, -1, 2, 1], 1) 2 >>> longest_subarray_with_sum([1, 2, 3], 5) 2 >>> longest_subarray_with_sum([1, 2, -1, 2], 3) 3 >>> longest_subarray_with_sum([1, 2, -1, 2], 6) 0 pass # Unit Tests def test_example_cases(): assert longest_subarray_with_sum([1, -1, 5, -2, 3], 3) == 4 assert longest_subarray_with_sum([-2, -1, 2, 1], 1) == 2 assert longest_subarray_with_sum([1, 2, 3], 5) == 2 assert longest_subarray_with_sum([1, 2, -1, 2], 3) == 3 assert longest_subarray_with_sum([1, 2, -1, 2], 6) == 0 def test_no_matching_subarray(): assert longest_subarray_with_sum([1, 1, 1, 1], 5) == 0 assert longest_subarray_with_sum([], 0) == 0 def test_single_element_cases(): assert longest_subarray_with_sum([3], 3) == 1 assert longest_subarray_with_sum([1], 0) == 0 assert longest_subarray_with_sum([0], 0) == 1 def test_large_input(): assert longest_subarray_with_sum([1] * 100000, 100000) == 100000 def test_negative_and_positive_numbers(): assert longest_subarray_with_sum([1, -1, 1, -1, 1, -1, 1, -1, 1], 0) == 8 assert longest_subarray_with_sum([-1, 2, 3, -1, -2, 1], 4) == 3","solution":"def longest_subarray_with_sum(arr, target): Returns the length of the longest subarray with the given sum 'target'. If no such subarray exists, returns 0. sum_index_map = {} current_sum = 0 max_length = 0 for i, num in enumerate(arr): current_sum += num if current_sum == target: max_length = i + 1 if (current_sum - target) in sum_index_map: max_length = max(max_length, i - sum_index_map[current_sum - target]) if current_sum not in sum_index_map: sum_index_map[current_sum] = i return max_length"},{"question":"def traffic_light_state(t: int) -> str: Simulates a simplified version of a traffic light system and determines the current light ('RED', 'GREEN', 'YELLOW') based on the elapsed time \`t\`. The traffic lights operate on a fixed-time cycle: - Red light lasts for 45 seconds. - Green light lasts for 30 seconds. - Yellow light lasts for 5 seconds. The complete cycle duration is 80 seconds. >>> traffic_light_state(60) 'GREEN' >>> traffic_light_state(90) 'RED' >>> traffic_light_state(75) 'YELLOW' pass","solution":"def traffic_light_state(t: int) -> str: Determines the current traffic light state based on the elapsed time \`t\`. cycle_time = 80 # Total duration for one complete cycle t = t % cycle_time # Normalize \`t\` to within one cycle if 0 <= t < 45: return 'RED' elif 45 <= t < 75: return 'GREEN' else: return 'YELLOW'"},{"question":"from collections import Counter def count_characters(s: str) -> str: Given a string s consisting of lowercase letters, count the occurrences of each letter and output in alphabetical order. Parameters: s (str): Input string. Returns: str: A string where each character and its count are in alphabetical order. pass def test_single_character(): assert count_characters(\\"a\\") == \\"a 1\\" def test_multiple_different_characters(): assert count_characters(\\"abc\\") == \\"a 1nb 1nc 1\\" def test_multiple_same_characters(): assert count_characters(\\"aabbbcc\\") == \\"a 2nb 3nc 2\\" def test_empty_string(): assert count_characters(\\"\\") == \\"\\" def test_repeated_single_character(): assert count_characters(\\"aaaa\\") == \\"a 4\\" def test_random_order_characters(): assert count_characters(\\"cbbaacc\\") == \\"a 2nb 2nc 3\\" def test_all_same_characters(): assert count_characters(\\"zzzzz\\") == \\"z 5\\"","solution":"from collections import Counter def count_characters(s): Given a string s consisting of lowercase letters, count the occurrences of each letter and output in alphabetical order. Parameters: s (str): Input string. Returns: str: A string where each character and its count are in alphabetical order. # Count occurrences of each character counter = Counter(s) # Sort the keys alphabetically sorted_keys = sorted(counter.keys()) # Create the output string result = \\"n\\".join(f\\"{char} {counter[char]}\\" for char in sorted_keys) return result"},{"question":"def extract_primes(numbers: List[int]) -> List[int]: Implement a function that takes a list of integers and returns a new list containing only the prime numbers from the original list, but in reverse order of their appearance. >>> extract_primes([10, 41, 22, 53, 37, 89]) == [89, 37, 53, 41] >>> extract_primes([31, 17, 12, 5, 6]) == [5, 17, 31] >>> extract_primes([4, 6, 8, 10, 12]) == [] >>> extract_primes([1, 4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20]) == [] >>> extract_primes([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]) == [31, 29, 23, 19, 17, 13, 11, 7, 5, 3, 2]","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False elif n == 2: return True elif n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def extract_primes(numbers): Returns a list of prime numbers from the original list in reverse order of their appearance. primes = [num for num in numbers if is_prime(num)] return primes[::-1]"},{"question":"def count_same_letters(str1: str, str2: str) -> int: Counts how many letters from the beginning are the same between two given strings. >>> count_same_letters(\\"hello\\", \\"hello\\") 5 >>> count_same_letters(\\"hello\\", \\"world\\") 0 >>> count_same_letters(\\"hello\\", \\"hellp\\") 4 >>> count_same_letters(\\"hello\\", \\"helicopter\\") 3 >>> count_same_letters(\\"\\", \\"\\") 0 >>> count_same_letters(\\"hello\\", \\"\\") 0 >>> count_same_letters(\\"\\", \\"world\\") 0 >>> count_same_letters(\\"hello\\", \\"he\\") 2 >>> count_same_letters(\\"hello\\", \\"helloooo\\") 5 >>> count_same_letters(\\"Hello\\", \\"hello\\") 0 >>> count_same_letters(\\"hello\\", \\"HELLO\\") 0","solution":"def count_same_letters(str1, str2): Counts how many letters from the beginning are the same between two given strings. count = 0 for a, b in zip(str1, str2): if a == b: count += 1 else: break return count"},{"question":"def shortest_consecutive_perfect_square_subset(n: int, difficulties: List[int]) -> int: Find the length of the shortest subset of consecutive trails such that the product of their difficulty levels is a perfect square. >>> shortest_consecutive_perfect_square_subset(5, [2, 4, 6, 8, 10]) 1 >>> shortest_consecutive_perfect_square_subset(3, [2, 3, 5]) -1","solution":"def is_perfect_square(x): if x < 0: return False root = int(x**0.5) return root * root == x def shortest_consecutive_perfect_square_subset(n, difficulties): from math import gcd from collections import defaultdict def product_is_perfect_square(product): return is_perfect_square(product) for length in range(1, n+1): cum_product = 1 product_map = defaultdict(int) for i in range(n): cum_product *= difficulties[i] if i >= length-1: if product_is_perfect_square(cum_product): return length cum_product //= difficulties[i - length + 1] return -1"},{"question":"def decode_base64_message(s: str) -> str: Decodes a series of base-64 encoded words separated by spaces. Parameters: s (str): A string containing base-64 encoded words separated by spaces. Returns: str: The original decoded string. Examples: >>> decode_base64_message(\\"VGVzdCBtZXNzYWdl\\") 'Test message' >>> decode_base64_message(\\"SGVsbG8gd29ybGQh U2FtcGxlIHRleHQgd2l0aCBjb21wbGV4IGVuY29kaW5nIQ==\\") 'Hello world! Sample text with complex encoding!'","solution":"import base64 def decode_base64_message(s): Decodes a series of base-64 encoded words separated by spaces. Parameters: s (str): A string containing base-64 encoded words separated by spaces. Returns: str: The original decoded string. words = s.split() decoded_words = [base64.b64decode(word).decode('utf-8') for word in words] return \\" \\".join(decoded_words)"},{"question":"def is_palindrome(s: str) -> str: Returns 'YES' if the string s is a palindrome, otherwise returns 'NO'. >>> is_palindrome(\\"madam\\") 'YES' >>> is_palindrome(\\"hello\\") 'NO' >>> is_palindrome(\\"a\\") 'YES' >>> is_palindrome(\\"ab\\") 'NO' >>> is_palindrome(\\"aa\\") 'YES' >>> is_palindrome(\\"a\\" * 50 + \\"b\\" * 50) 'NO' >>> is_palindrome(\\"abcba\\") 'YES' >>> is_palindrome(\\"\\") 'YES'","solution":"def is_palindrome(s): Returns 'YES' if the string s is a palindrome, otherwise returns 'NO'. if s == s[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix by 90 degrees clockwise. For example: >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] pass def test_rotate_matrix_3x3(): original = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(original) == rotated def test_rotate_matrix_2x2(): original = [ [1, 2], [3, 4] ] rotated = [ [3, 1], [4, 2] ] assert rotate_matrix(original) == rotated def test_rotate_matrix_1x1(): original = [ [1] ] rotated = [ [1] ] assert rotate_matrix(original) == rotated def test_rotate_matrix_4x4(): original = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotated = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix(original) == rotated def test_rotate_matrix_large(): original = [ [22, 13, 17], [60, 26, 72], [99, 88, 42] ] rotated = [ [99, 60, 22], [88, 26, 13], [42, 72, 17] ] assert rotate_matrix(original) == rotated","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix by 90 degrees clockwise. n = len(matrix) # Creating a new matrix to hold the rotated version rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - i - 1] = matrix[i][j] return rotated_matrix"},{"question":"def buddy_strings(A: str, B: str) -> bool: Given two strings A and B of equal length, return true if and only if we can swap exactly two characters in A to get B. >>> buddy_strings(\\"ab\\", \\"ba\\") True >>> buddy_strings(\\"ab\\", \\"ab\\") False >>> buddy_strings(\\"aa\\", \\"aa\\") True >>> buddy_strings(\\"aaaaaaabc\\", \\"aaaaaaacb\\") True >>> buddy_strings(\\"\\", \\"\\") False","solution":"def buddy_strings(A, B): Given two strings A and B, return true if and only if we can swap exactly two characters in A to get B. # If lengths are not equal, they cannot be buddy strings if len(A) != len(B): return False # If A and B are the same, check if there is any character with frequency more than 1 if A == B: return len(set(A)) < len(A) # Find characters in A that are different from characters in the same position in B diff = [] for a, b in zip(A, B): if a != b: diff.append((a, b)) # There must be exactly 2 differences and they must be reversible to be buddy strings return len(diff) == 2 and diff[0] == diff[1][::-1]"},{"question":"def product_of_list(lst: List[int]) -> int: Returns the product of all integers in the list. If the list contains a zero, returns zero immediately. >>> product_of_list([1, 2, 3, 4]) == 24 >>> product_of_list([1, 2, 0, 4]) == 0 >>> product_of_list([0, 5, 6]) == 0 >>> product_of_list([1, -2, 3]) == -6 >>> product_of_list([5]) == 5 >>> product_of_list([0]) == 0 >>> product_of_list([]) == 1","solution":"def product_of_list(lst): Returns the product of all integers in the list. If the list contains a zero, returns zero immediately. product = 1 for num in lst: if num == 0: return 0 product *= num return product"},{"question":"def digital_root(n: int) -> int: Compute the digital root of a given integer n. The digital root is obtained by repeatedly summing the digits until a single digit is left. :param n: The integer for which the digital root is to be computed. :return: The digital root of the integer n. >>> digital_root(9875) 2 >>> digital_root(12345) 6 >>> digital_root(456) 6 pass def solve_digital_root(test_cases: List[int]) -> List[int]: Process multiple test cases to compute the digital root of each. :param test_cases: A list of integers for which the digital roots are to be computed. :return: A list of digital roots corresponding to each input integer. >>> solve_digital_root([9875, 12345, 456]) [2, 6, 6] >>> solve_digital_root([1000000000]) [1] pass","solution":"def digital_root(n): Computes the digital root of a given integer n. while n >= 10: n = sum(int(digit) for digit in str(n)) return n def solve_digital_root(test_cases): Processes multiple test cases and computes the digital root for each. Parameters: test_cases (list): A list of integers for which to compute the digital root. Returns: list: A list of digital roots corresponding to the input test cases. results = [] for number in test_cases: results.append(digital_root(number)) return results"},{"question":"from typing import List def count_pairs_with_difference(nums: List[int], target: int) -> int: Given an array of integers and an integer target, return the number of distinct pairs (i, j) such that the difference between elements at index i and j is equal to the target. Note that (i, j) and (j, i) are considered the same pair, and i should not be equal to j. >>> count_pairs_with_difference([1, 5, 2, 2, 3, 1], 2) 2 >>> count_pairs_with_difference([1, 3, 1, 5, 4], 0) 1 pass","solution":"def count_pairs_with_difference(nums, target): Returns the number of distinct pairs (i, j) such that the difference between elements at index i and j is equal to the target, with i != j. # Use a set to keep track of numbers seen so far seen = set() pairs = set() for num in nums: if num + target in seen: pairs.add((min(num, num + target), max(num, num + target))) if num - target in seen: pairs.add((min(num, num - target), max(num, num - target))) seen.add(num) return len(pairs)"},{"question":"def compare_files(file1: str, file2: str) -> bool: Compares two text files to determine if they are identical, ignoring all whitespace characters. Args: file1 (str): Path to the first file. file2 (str): Path to the second file. Returns: bool: True if files are identical ignoring whitespace, False otherwise. # Example usage: # Assume file1.txt content is \\"Hello Worldn\\" # and file2.txt content is \\"HelloWorld\\" # result = compare_files(\\"file1.txt\\", \\"file2.txt\\") # print(result) # Output: True # Assume file3.txt content is \\"HellonWorld\\" # and file4.txt content is \\"HelloWorld\\" # result = compare_files(\\"file3.txt\\", \\"file4.txt\\") # print(result) # Output: False # Test cases from solution import compare_files def test_identical_files_same_content(): with open(\\"test1.txt\\", \\"w\\") as f: f.write(\\"Hello World\\") with open(\\"test2.txt\\", \\"w\\") as f: f.write(\\"Hello World\\") assert compare_files(\\"test1.txt\\", \\"test2.txt\\") def test_identical_files_different_whitespace(): with open(\\"test1.txt\\", \\"w\\") as f: f.write(\\"Hello Worldn\\") with open(\\"test2.txt\\", \\"w\\") as f: f.write(\\"HelloWorldn\\") assert compare_files(\\"test1.txt\\", \\"test2.txt\\") def test_files_different_content(): with open(\\"test1.txt\\", \\"w\\") as f: f.write(\\"Hello World\\") with open(\\"test2.txt\\", \\"w\\") as f: f.write(\\"HelloWorld!\\") assert not compare_files(\\"test1.txt\\", \\"test2.txt\\") def test_files_with_only_whitespace(): with open(\\"test1.txt\\", \\"w\\") as f: f.write(\\" nt \\") with open(\\"test2.txt\\", \\"w\\") as f: f.write(\\"nt\\") assert compare_files(\\"test1.txt\\", \\"test2.txt\\") def test_empty_files(): open(\\"test1.txt\\", \\"w\\").close() open(\\"test2.txt\\", \\"w\\").close() assert compare_files(\\"test1.txt\\", \\"test2.txt\\")","solution":"def compare_files(file1, file2): Compares two text files to determine if they are identical, ignoring all whitespace characters. Args: file1 (str): Path to the first file. file2 (str): Path to the second file. Returns: bool: True if files are identical ignoring whitespace, False otherwise. def load_and_process_file(file_path): content = \\"\\" with open(file_path, 'r') as f: for line in f: content += ''.join(line.split()) return content content1 = load_and_process_file(file1) content2 = load_and_process_file(file2) return content1 == content2"},{"question":"def findBalancedString(s: str) -> bool: Check if the given string is balanced in terms of parentheses. Args: s (str): The input string containing only parentheses. Returns: bool: True if the string is balanced, otherwise False. Examples: >>> findBalancedString(\\"()\\") True >>> findBalancedString(\\"(()\\") False >>> findBalancedString(\\"(()(()))\\") True >>> findBalancedString(\\"((())\\") False","solution":"def findBalancedString(s): Check if the given string is balanced in terms of parentheses. Args: s (str): The input string containing only parentheses. Returns: bool: True if the string is balanced, otherwise False. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def max_submatrix_sum(matrix): Function to find the maximum sum of any non-empty submatrix in a given matrix. >>> matrix = [ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ] >>> max_submatrix_sum(matrix) 29 >>> matrix = [ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ] >>> max_submatrix_sum(matrix) -1 >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> max_submatrix_sum(matrix) 45","solution":"def max_submatrix_sum(matrix): Function to find the maximum sum of any non-empty submatrix in a given matrix. n = len(matrix) m = len(matrix[0]) max_sum = float('-inf') for left in range(m): temp = [0] * n for right in range(left, m): for i in range(n): temp[i] += matrix[i][right] max_sum = max(max_sum, kadane(temp)) return max_sum def kadane(arr): Utility function to find the maximum sum subarray using Kadane's algorithm. max_ending_here = arr[0] max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far # Example usage matrix = [ [1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6] ] print(max_submatrix_sum(matrix)) # Output: 29"},{"question":"def most_expensive_product(products: List[Tuple[str, int]]) -> Union[str, None]: Returns the name of the most expensive product. Parameters: - products: list of tuples, where each tuple consists of (product_name, product_price) If the list is empty, return None. >>> most_expensive_product([('apple', 50), ('banana', 30), ('orange', 75)]) 'orange' >>> most_expensive_product([]) None >>> most_expensive_product([('apple', 50)]) 'apple' >>> most_expensive_product([('apple', 50), ('banana', 50), ('orange', 50)]) 'apple' >>> most_expensive_product([('apple', -50), ('banana', -30), ('orange', -75)]) 'banana' >>> most_expensive_product([('apple', 50), ('banana', -30), ('orange', 0)]) 'apple'","solution":"def most_expensive_product(products): Returns the name of the most expensive product. Parameters: - products: list of tuples, where each tuple consists of (product_name, product_price) If the list is empty, return None. if not products: return None return max(products, key=lambda x: x[1])[0]"},{"question":"def is_isogram(s: str) -> bool: Determines if a given string is an isogram. An isogram is a word or phrase without a repeating letter, however spaces and hyphens are allowed to appear multiple times. Parameters: s (str): The string to be checked. Returns: bool: True if the string is an isogram, False otherwise. >>> is_isogram(\\"lumberjack\\") True >>> is_isogram(\\"hello\\") False >>> is_isogram(\\"isogram\\") True >>> is_isogram(\\"six-year-old\\") True >>> is_isogram(\\"eleven\\") False >>> is_isogram(\\"Dermatoglyphics\\") True >>> is_isogram(\\"isOgram\\") True >>> is_isogram(\\"Alphabet\\") False >>> is_isogram(\\"repetition\\") False >>> is_isogram(\\"\\") True >>> is_isogram(\\"a b c-d e f\\") True >>> is_isogram(\\"a b c-d e e\\") False pass","solution":"def is_isogram(s): Determines if a given string is an isogram. An isogram is a word or phrase without a repeating letter, however spaces and hyphens are allowed to appear multiple times. Parameters: s (str): The string to be checked. Returns: bool: True if the string is an isogram, False otherwise. s = s.lower() seen = set() for char in s: if char.isalpha(): if char in seen: return False seen.add(char) return True"},{"question":"from typing import List, Tuple def count_anagram_pairs(T: int, test_cases: List[Tuple[int, List[str]]]) -> List[int]: Counts the number of anagram pairs for each test case. Parameters: - T: the number of test cases - test_cases: a list of tuples where each tuple contains: - an integer N: the number of words - a list of N words Returns: A list of integers where each integer is the number of anagram pairs in the corresponding test case. >>> count_anagram_pairs(1, [(4, ['listen', 'silent', 'enlist', 'inlets'])]) [6] >>> count_anagram_pairs(1, [(3, ['cat', 'act', 'tac'])]) [3]","solution":"from collections import defaultdict def count_anagram_pairs(T, test_cases): Counts the number of anagram pairs for each test case. Parameters: - T: the number of test cases - test_cases: a list of tuples where each tuple contains: - an integer N: the number of words - a list of N words Returns: A list of integers where each integer is the number of anagram pairs in the corresponding test case. results = [] for i in range(T): N, words = test_cases[i] anagram_dict = defaultdict(int) for word in words: sorted_word = ''.join(sorted(word)) anagram_dict[''.join(sorted_word)] += 1 # Count pairs pairs = 0 for count in anagram_dict.values(): if count > 1: pairs += count * (count - 1) // 2 results.append(pairs) return results"},{"question":"def findUniqueElement(arr): Finds the element that appears only once in an array where every other element appears exactly twice. :param arr: List[int] - The list of integers :return: int - The unique element # Your implementation here # Example usages: assert findUniqueElement([4, 1, 2, 1, 2]) == 4 assert findUniqueElement([2, 2, 1]) == 1 assert findUniqueElement([1]) == 1 assert findUniqueElement([1, 1, 2, 2, 3, 3, 4, 4, 5]) == 5 assert findUniqueElement([10, 1, 1, 2, 2]) == 10 assert findUniqueElement([100000, 99999, 99999]) == 100000","solution":"def findUniqueElement(arr): Finds the element that appears only once in an array where every other element appears exactly twice. :param arr: List[int] - The list of integers :return: int - The unique element unique = 0 for num in arr: unique ^= num return unique"},{"question":"def find_smallest_window_to_sort(arr: List[int]) -> List[int]: Write a function that takes an array of integers and returns the smallest contiguous subarray that, if sorted, would result in the entire array being sorted. If the array is already sorted, return an empty list. >>> find_smallest_window_to_sort([1, 3, 2, 4, 5]) == [3, 2] >>> find_smallest_window_to_sort([1, 2, 3, 4, 5]) == [] >>> find_smallest_window_to_sort([1, 5, 4, 3, 2, 6, 7]) == [5, 4, 3, 2] >>> find_smallest_window_to_sort([2, 6, 4, 8, 10, 9, 15]) == [6, 4, 8, 10, 9] >>> find_smallest_window_to_sort([1, 2, 5, 3, 4]) == [5, 3, 4]","solution":"def find_smallest_window_to_sort(arr): n = len(arr) if n <= 1: return [] start, end = -1, -1 for i in range(n - 1): if arr[i] > arr[i + 1]: start = i break if start == -1: return [] for i in range(n - 1, 0, -1): if arr[i] < arr[i - 1]: end = i break min_val = min(arr[start:end + 1]) max_val = max(arr[start:end + 1]) for i in range(start): if arr[i] > min_val: start = i break for i in range(n - 1, end, -1): if arr[i] < max_val: end = i break return arr[start:end + 1]"},{"question":"def tribonacci(n: int) -> int: Returns the N-th Tribonacci number (0-indexed). The sequence starts as 0, 1, 1, and each subsequent number is the sum of the last three numbers. Args: n (int): The index (0-indexed) of the desired Tribonacci number. Returns: int: The N-th Tribonacci number. Examples: >>> tribonacci(0) 0 >>> tribonacci(1) 1 >>> tribonacci(2) 1 >>> tribonacci(3) 2 >>> tribonacci(4) 4 >>> tribonacci(6) 13","solution":"def tribonacci(n): Returns the N-th Tribonacci number (0-indexed). The sequence starts as 0, 1, 1, and each subsequent number is the sum of the last three numbers. if n == 0: return 0 elif n == 1 or n == 2: return 1 t0, t1, t2 = 0, 1, 1 for i in range(3, n + 1): t_next = t0 + t1 + t2 t0, t1, t2 = t1, t2, t_next return t_next"},{"question":"def sum_between(a: int, b: int) -> int: Returns the sum of all the integers between a and b, inclusive. Args: a (int): First integer b (int): Second integer Returns: int: The sum of all integers between a and b, inclusive. Examples: >>> sum_between(3, 7) 25 >>> sum_between(-2, 2) 0 >>> sum_between(5, -1) 14","solution":"def sum_between(a, b): Returns the sum of all the integers between a and b, inclusive. Args: a (int): First integer b (int): Second integer Returns: int: The sum of all integers between a and b, inclusive. if a > b: a, b = b, a return sum(range(a, b + 1))"},{"question":"def generate_sequence(s: int, k: int) -> int: Generate the k-th term of the sequence starting with s. Each term is generated based on the sum of the digits of the previous term plus the previous term itself. >>> generate_sequence(5, 3) 11 >>> generate_sequence(9, 4) 36 >>> generate_sequence(1, 1) 1 >>> generate_sequence(0, 5) 0 >>> generate_sequence(12, 2) 15 >>> generate_sequence(123, 3) 141 # Your code here","solution":"def generate_sequence(s, k): Generate the k-th term of the sequence starting with s. Each term is generated based on the sum of the digits of the previous term plus the previous term itself. def digit_sum(n): return sum(int(digit) for digit in str(n)) current = s for _ in range(k - 1): current = current + digit_sum(current) return current"},{"question":"def roman_to_integer(s: str) -> int: Convert a Roman numeral to an integer. >>> roman_to_integer('III') 3 >>> roman_to_integer('IX') 9 >>> roman_to_integer('LVIII') 58 >>> roman_to_integer('MCMXCIV') 1994","solution":"def roman_to_integer(s: str) -> int: Converts a Roman numeral to an integer. :param s: A string representing a Roman numeral :return: An integer representing the Roman numeral roman_to_int = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_to_int[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"def letter_combinations(digits: str) -> List[str]: You are given the mapping of digits to letters of a typical mobile phone keypad and a string containing digits. Write a function that will return all possible letter combinations that the number could represent. The mapping of digits to letters is as follows: 2: \\"abc\\" 3: \\"def\\" 4: \\"ghi\\" 5: \\"jkl\\" 6: \\"mno\\" 7: \\"pqrs\\" 8: \\"tuv\\" 9: \\"wxyz\\" Args: digits (str): A string containing digits from 2-9 inclusive. Returns: List[str]: An array of all possible letter combinations that the number could represent, in lexicographical order. If the input is an empty string, return an empty array. Examples: >>> letter_combinations(\\"23\\") [\\"ad\\",\\"ae\\",\\"af\\",\\"bd\\",\\"be\\",\\"bf\\",\\"cd\\",\\"ce\\",\\"cf\\"] >>> letter_combinations(\\"\\") [] >>> letter_combinations(\\"2\\") [\\"a\\",\\"b\\",\\"c\\"]","solution":"def letter_combinations(digits): if not digits: return [] phone_map = { '2': \\"abc\\", '3': \\"def\\", '4': \\"ghi\\", '5': \\"jkl\\", '6': \\"mno\\", '7': \\"pqrs\\", '8': \\"tuv\\", '9': \\"wxyz\\" } result = [\\"\\"] for digit in digits: current_combinations = [] for combination in result: for letter in phone_map[digit]: current_combinations.append(combination + letter) result = current_combinations return result"},{"question":"def longest_consecutive_subsequence(arr): Determines the length of the longest subsequence of the array such that every consecutive element in the subsequence differs by 1. >>> longest_consecutive_subsequence([1, 2, 3, 4, 6, 5]) == 6 >>> longest_consecutive_subsequence([1, 2, 3, 5, 6]) == 3 >>> longest_consecutive_subsequence([8, 7, 9, 6, 5]) == 5 >>> longest_consecutive_subsequence([1, 9, 3, 10, 4, 20, 2]) == 4 >>> longest_consecutive_subsequence([10]) == 1 >>> longest_consecutive_subsequence([]) == 0 >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) == 4 pass def process_test_cases(test_cases): Processes multiple test cases and returns the results. >>> test_cases = [(6, [1, 2, 3, 4, 6, 5]), (5, [1, 2, 3, 5, 6])] >>> process_test_cases(test_cases) == [6, 3] >>> test_cases = [(7, [1, 9, 3, 10, 4, 20, 2]), (4, [10])] >>> process_test_cases(test_cases) == [4, 1] >>> test_cases = [(6, [100, 4, 200, 1, 3, 2])] >>> process_test_cases(test_cases) == [4] pass","solution":"def longest_consecutive_subsequence(arr): Determines the length of the longest subsequence of the array such that every consecutive element in the subsequence differs by 1. if not arr: return 0 arr = sorted(set(arr)) max_len = 1 current_len = 1 for i in range(1, len(arr)): if arr[i] == arr[i-1] + 1: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len def process_test_cases(test_cases): Processes multiple test cases and returns the results. results = [] for n, arr in test_cases: results.append(longest_consecutive_subsequence(arr)) return results"},{"question":"def dailyTemperatures(temperatures): Returns the number of days until a warmer temperature for each day in the temperatures list. :param temperatures: List[int] - List of daily temperatures :return: List[int] - List of days until a warmer temperature >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([76, 75, 74, 73, 72, 71, 70]) [0, 0, 0, 0, 0, 0, 0] >>> dailyTemperatures([70, 80, 70, 80, 70]) [1, 0, 1, 0, 0] >>> dailyTemperatures([72]) [0] >>> dailyTemperatures([70, 70, 70, 70]) [0, 0, 0, 0]","solution":"def dailyTemperatures(temperatures): Returns the number of days until a warmer temperature for each day in the temperatures list. n = len(temperatures) answer = [0] * n stack = [] for current_day in range(n): while stack and temperatures[current_day] > temperatures[stack[-1]]: previous_day = stack.pop() answer[previous_day] = current_day - previous_day stack.append(current_day) return answer"},{"question":"def longest_vowel_word(sentence: str) -> str: Given an input string of words separated by spaces, find the longest word that consists only of vowels (a, e, i, o, u). If there is a tie, return the word that appears first. If there are no such words, return an empty string. >>> longest_vowel_word(\\"this is an example input\\") \\"\\" >>> longest_vowel_word(\\"aeiou this is a test\\") \\"aeiou\\" >>> longest_vowel_word(\\"this oe ii ae i eio\\") \\"eio\\" >>> longest_vowel_word(\\"iou ae aei ao aiu\\") \\"iou\\" >>> longest_vowel_word(\\"a e i o u aeio aeioae\\") \\"aeioae\\" >>> longest_vowel_word(\\"\\") \\"\\" >>> longest_vowel_word(\\"AeIoU thiS IS ExaMPLe\\") \\"AeIoU\\"","solution":"def longest_vowel_word(sentence): Returns the longest word made up entirely of vowels from the given sentence. If there is a tie, the word that appears first is returned. If no such words exist, returns an empty string. vowels = set('aeiouAEIOU') def is_vowel_word(word): return all(char in vowels for char in word) words = sentence.split() longest = \\"\\" for word in words: if is_vowel_word(word) and len(word) > len(longest): longest = word return longest"},{"question":"from typing import List, Tuple, Dict def summarize_timeseries(data: List[Tuple[str, int]]) -> Dict[str, int]: Summarizes the time series data by date. Parameters: data (list of tuples): List of tuples where each tuple contains a timestamp (in format 'YYYY-MM-DD HH:MM:SS') and a numerical value. Returns: dict: Dictionary where keys are dates ('YYYY-MM-DD') and values are the sum of numerical values for that date. >>> summarize_timeseries([ ... (\\"2023-08-01 12:00:00\\", 10), ... (\\"2023-08-01 13:00:00\\", 20), ... (\\"2023-08-02 14:00:00\\", 30) ... ]) {'2023-08-01': 30, '2023-08-02': 30} >>> summarize_timeseries([ ... (\\"2023-08-01 12:00:00\\", 10), ... (\\"2023-08-02 13:00:00\\", 20), ... (\\"2023-08-03 14:00:00\\", 30) ... ]) {'2023-08-01': 10, '2023-08-02': 20, '2023-08-03': 30}","solution":"def summarize_timeseries(data): Summarizes the time series data by date. Parameters: data (list of tuples): List of tuples where each tuple contains a timestamp (in format 'YYYY-MM-DD HH:MM:SS') and a numerical value. Returns: dict: Dictionary where keys are dates ('YYYY-MM-DD') and values are the sum of numerical values for that date. summary = {} for timestamp, value in data: date = timestamp.split()[0] if date in summary: summary[date] += value else: summary[date] = value return summary"},{"question":"def generate_pattern(n): Generates a pattern with the given number of rows n. >>> generate_pattern(1) [\\"*\\"] >>> generate_pattern(3) [\\"*\\", \\"*.\\", \\"*..\\"] >>> generate_pattern(5) [\\"*\\", \\"*.\\", \\"*..\\", \\"*...\\", \\"*....\\"] def pattern_for_test_cases(test_cases): Generates patterns for each test case. Parameters: test_cases (list): A list of integers representing the number of rows for each test case. Returns: list: A list of strings where each string is the pattern for one test case. >>> pattern_for_test_cases([1, 3]) [\\"*\\", \\"*n*.n*..\\"] >>> pattern_for_test_cases([2]) [\\"*n*.\\"] >>> pattern_for_test_cases([3, 5]) [\\"*n*.n*..\\", \\"*n*.n*..n*...n*....\\"]","solution":"def generate_pattern(n): Generates a pattern with the given number of rows n. result = [] for i in range(1, n+1): row = '*' + '.' * (i - 1) result.append(row) return result def pattern_for_test_cases(test_cases): Generates patterns for each test case. Parameters: test_cases (list): A list of integers representing the number of rows for each test case. Returns: list: A list of strings where each string is the pattern for one test case. patterns = [] for n in test_cases: patterns.append('n'.join(generate_pattern(n))) return patterns"},{"question":"def create_batches(containers, max_weight): This function takes a list of containers with each container's id and weight, and a maximum weight limit for each batch, and returns a list of batches such that no batch exceeds the given weight limit. Args: containers: List of tuples where each tuple contains a string (container ID) and an integer (container weight). max_weight: An integer representing the maximum allowable weight for a batch of containers. Returns: A list of batches, where each batch is a list of container IDs, and the total weight of each batch does not exceed max_weight. Examples: >>> create_batches([('C1', 10), ('C2', 8), ('C3', 15), ('C4', 12)], 20) [['C1', 'C2'], ['C3'], ['C4']] >>> create_batches([('A', 5), ('B', 5), ('C', 5), ('D', 7), ('E', 8)], 10) [['A', 'B'], ['C'], ['D'], ['E']] pass","solution":"def create_batches(containers, max_weight): This function takes a list of containers with each container's id and weight, and a maximum weight limit for each batch, and returns a list of batches such that no batch exceeds the given weight limit. from itertools import combinations # Sort containers by weight descending containers.sort(key=lambda x: x[1], reverse=True) # Initialize result batches = [] # While there are containers left while containers: batch = [] batch_weight = 0 # Iterate over a copy of the list so we can modify the original list for container in containers[:]: container_id, container_weight = container if batch_weight + container_weight <= max_weight: batch.append(container_id) batch_weight += container_weight containers.remove(container) batches.append(batch) return batches"},{"question":"from typing import List class Logger: Logger class to store log entries with timestamps and retrieve them based on time ranges. Methods: - log(timestamp: str, message: str) -> None: Adds a new log entry. - retrieve(start_time: str, end_time: str) -> List[str]: Retrieves log messages within the specified time range. Examples: >>> logger = Logger() >>> logger.log(\\"2023-01-01 12:00:00\\", \\"User1 logged in\\") >>> logger.log(\\"2023-01-01 12:15:00\\", \\"User2 logged in\\") >>> logger.retrieve(\\"2023-01-01 12:00:00\\", \\"2023-01-01 12:30:00\\") ['User1 logged in', 'User2 logged in'] def __init__(self): self.logs = [] def log(self, timestamp: str, message: str) -> None: pass def retrieve(self, start_time: str, end_time: str) -> List[str]: pass def test_logger_add_and_retrieve_logs(): logger = Logger() logs = [ (\\"2023-01-01 12:00:00\\", \\"User1 logged in\\"), (\\"2023-01-01 12:15:00\\", \\"User2 logged in\\"), (\\"2023-01-01 12:30:00\\", \\"User1 performed action\\"), (\\"2023-01-01 12:45:00\\", \\"User3 logged in\\"), (\\"2023-01-01 12:50:00\\", \\"User2 logged out\\") ] for timestamp, message in logs: logger.log(timestamp, message) result1 = logger.retrieve(\\"2023-01-01 12:00:00\\", \\"2023-01-01 12:30:00\\") expected1 = [\\"User1 logged in\\", \\"User2 logged in\\", \\"User1 performed action\\"] assert result1 == expected1 result2 = logger.retrieve(\\"2023-01-01 12:15:00\\", \\"2023-01-01 12:50:00\\") expected2 = [\\"User2 logged in\\", \\"User1 performed action\\", \\"User3 logged in\\", \\"User2 logged out\\"] assert result2 == expected2 def test_logger_no_match(): logger = Logger() logger.log(\\"2023-01-01 12:00:00\\", \\"User1 logged in\\") result = logger.retrieve(\\"2023-02-01 12:00:00\\", \\"2023-02-01 12:30:00\\") assert result == [] def test_logger_single_log(): logger = Logger() logger.log(\\"2023-01-01 12:00:00\\", \\"User1 logged in\\") result = logger.retrieve(\\"2023-01-01 12:00:00\\", \\"2023-01-01 12:00:00\\") assert result == [\\"User1 logged in\\"] def test_logger_out_of_bounds_retrieve(): logger = Logger() logger.log(\\"2023-01-01 12:00:00\\", \\"User1 logged in\\") logger.log(\\"2023-01-01 12:15:00\\", \\"User2 logged in\\") result = logger.retrieve(\\"2023-01-01 11:00:00\\", \\"2023-01-01 13:00:00\\") assert result == [\\"User1 logged in\\", \\"User2 logged in\\"]","solution":"from typing import List class Logger: def __init__(self): self.logs = [] def log(self, timestamp: str, message: str) -> None: self.logs.append((timestamp, message)) def retrieve(self, start_time: str, end_time: str) -> List[str]: result = [] for timestamp, message in self.logs: if start_time <= timestamp <= end_time: result.append(message) return result"},{"question":"def tail(lines: List[str], n: int) -> List[str]: Simulates the behavior of the 'tail' command in UNIX. Given a list of lines and an integer \`n\`, return a list consisting of the last \`n\` lines of the input list. >>> lines = [ ... \\"This is the first line.\\", ... \\"This is the second line.\\", ... \\"This is the third line.\\", ... \\"This is the fourth line.\\", ... \\"This is the fifth line.\\", ... ] >>> n = 3 >>> tail(lines, n) [ \\"This is the third line.\\", \\"This is the fourth line.\\", \\"This is the fifth line.\\", ] >>> tail([\\"Line 1\\", \\"Line 2\\", \\"Line 3\\", \\"Line 4\\"], 4) [\\"Line 1\\", \\"Line 2\\", \\"Line 3\\", \\"Line 4\\"] >>> tail([\\"Line 1\\", \\"Line 2\\", \\"Line 3\\"], 0) [] >>> tail([\\"Line 1\\", \\"Line 2\\"], 5) [\\"Line 1\\", \\"Line 2\\"] >>> tail([\\"Line 1\\", \\"Line 2\\", \\"Line 3\\"], -1) [] >>> tail([], 3) [] >>> tail([\\"Only one line\\"], 1) [\\"Only one line\\"] pass","solution":"def tail(lines, n): Returns the last n lines from the given list of lines. Parameters: lines (list): A list of strings representing lines. n (int): The number of lines to return from the end of the list. Returns: list: A list of the last n lines. if n <= 0: return [] return lines[-n:]"},{"question":"def max_difference(arr): Finds the maximum difference between any two elements such that the larger element comes after the smaller element in the array. Parameters: arr (list): List of integers Returns: int: Maximum difference or 0 if no valid pair exists Examples: >>> max_difference([7, 1, 5, 3, 6, 4]) 5 >>> max_difference([7, 6, 4, 3, 1]) 0 >>> max_difference([2, 3, 10, 6, 4, 8, 1]) 8 >>> max_difference([1, 2]) 1 >>> max_difference([2, 1]) 0 >>> max_difference([1]) 0 >>> max_difference([]) 0 >>> max_difference([2, 2, 2, 2, 2]) 0 >>> max_difference([10, 20, 30, 40, 50, 50, 10, 50]) 40","solution":"def max_difference(arr): Finds the maximum difference between any two elements such that the larger element comes after the smaller element in the array. Parameters: arr (list): List of integers Returns: int: Maximum difference or 0 if no valid pair exists if len(arr) < 2: return 0 min_element = arr[0] max_diff = 0 for i in range(1, len(arr)): if arr[i] > min_element: max_diff = max(max_diff, arr[i] - min_element) min_element = min(min_element, arr[i]) return max_diff"},{"question":"def rotateMatrix(matrix): Rotates the given NxN matrix 90 degrees clockwise in-place. Do not return anything, modify the matrix in-place. Do not use any additional 2D array or list, all rotations should be done in the given matrix itself. The function should handle matrices of different sizes. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotateMatrix(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] # Your code here from solution import rotateMatrix def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] rotateMatrix(matrix) assert matrix == expected def test_rotate_4x4_matrix(): matrix = [ [ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] rotateMatrix(matrix) assert matrix == expected def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] rotateMatrix(matrix) assert matrix == expected def test_rotate_5x5_matrix(): matrix = [ [ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] expected = [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ] rotateMatrix(matrix) assert matrix == expected","solution":"def rotateMatrix(matrix): Rotates the given NxN matrix 90 degrees clockwise in-place. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row to get the 90 degree rotation for i in range(n): matrix[i].reverse()"},{"question":"def containsNearbyAlmostDuplicate(nums: List[int], k: int, t: int) -> bool: Given an array of integers, find out whether there are two distinct indices i and j such that the absolute difference between nums[i] and nums[j] is at most k, and the absolute difference between i and j is at most t. >>> containsNearbyAlmostDuplicate([1,2,3,1], 3, 0) == True >>> containsNearbyAlmostDuplicate([1,5,9,1,5,9], 2, 3) == False >>> containsNearbyAlmostDuplicate([], 3, 1) == False >>> containsNearbyAlmostDuplicate([1], 1, 1) == False >>> containsNearbyAlmostDuplicate([2, 4, 6, 8], 2, 7) == True >>> containsNearbyAlmostDuplicate([1, 0, 1, 1], 1, 2) == True >>> containsNearbyAlmostDuplicate([1, 5, 9], 2, -1) == False >>> containsNearbyAlmostDuplicate([1, 2, 3, 4, 5], 10, 1) == True","solution":"from typing import List def containsNearbyAlmostDuplicate(nums: List[int], k: int, t: int) -> bool: if t < 0 or k <= 0: return False bucket = {} for i, num in enumerate(nums): bucket_key = num // (t + 1) if bucket_key in bucket: return True if bucket_key - 1 in bucket and abs(num - bucket[bucket_key - 1]) <= t: return True if bucket_key + 1 in bucket and abs(num - bucket[bucket_key + 1]) <= t: return True bucket[bucket_key] = num if i >= k: del bucket[nums[i - k] // (t + 1)] return False"},{"question":"from typing import List def spiral_matrix(n: int) -> List[List[int]]: Generate a square matrix of size \`n x n\` filled with elements from 1 to \`n^2\` in a spiral order, starting from the top-left corner and moving inwards in a clockwise direction. >>> spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> spiral_matrix(1) [[1]] >>> spiral_matrix(2) [[1, 2], [4, 3]] >>> spiral_matrix(5) [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]","solution":"from typing import List def spiral_matrix(n: int) -> List[List[int]]: matrix = [[0] * n for _ in range(n)] num = 1 top, bottom, left, right = 0, n - 1, 0, n - 1 while top <= bottom and left <= right: # Traverse from left to right for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 if top <= bottom: # Traverse from right to left for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 if left <= right: # Traverse from bottom to top for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"def square_with_cross(n: int) -> list: Generates an nxn array with a centered cross. Parameters: n (int): The size of the array (n should be odd and greater than 1). Returns: list: An nxn array with a centered cross. Raises: ValueError: If n is not an odd integer greater than 1. Examples: >>> square_with_cross(5) [[0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]] >>> square_with_cross(7) [[0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0]] from solution import square_with_cross def test_square_with_cross_5(): result = square_with_cross(5) expected = [[0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]] assert result == expected def test_square_with_cross_7(): result = square_with_cross(7) expected = [[0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0]] assert result == expected def test_square_with_cross_invalid_even(): try: square_with_cross(4) except ValueError as e: assert str(e) == \\"n must be an odd integer greater than 1\\" def test_square_with_cross_invalid_less_equal_1(): try: square_with_cross(1) except ValueError as e: assert str(e) == \\"n must be an odd integer greater than 1\\" try: square_with_cross(-3) except ValueError as e: assert str(e) == \\"n must be an odd integer greater than 1\\"","solution":"def square_with_cross(n): Generates an nxn array with a centered cross. Parameters: n (int): The size of the array (n should be odd and greater than 1). Returns: list: An nxn array with a centered cross. if n % 2 == 0 or n <= 1: raise ValueError(\\"n must be an odd integer greater than 1\\") matrix = [[0 for _ in range(n)] for _ in range(n)] middle = n // 2 for i in range(n): matrix[i][middle] = 1 matrix[middle][i] = 1 return matrix"},{"question":"def weatherSummary(data: List[Dict[str, Union[str, int]]], date_range: Dict[str, str]) -> Dict[str, Union[float, str]]: Process an array of daily weather observations and output a summary of the weather conditions for a specified range of days. Args: data (List[Dict[str, Union[str, int]]]): Array of daily weather observations. Each observation is a dictionary containing 'date' (str), 'temperature' (int), and 'condition' (str). date_range (Dict[str, str]): Dictionary with 'start' and 'end' keys representing the start and end date, respectively. Returns: Dict[str, Union[float, str]]: Dictionary containing 'averageTemperature' (float) and 'mostCommonCondition' (str). >>> data = [ ... {'date': '2023-10-01', 'temperature': 22, 'condition': 'Sunny'}, ... {'date': '2023-10-02', 'temperature': 19, 'condition': 'Cloudy'}, ... {'date': '2023-10-03', 'temperature': 21, 'condition': 'Sunny'}, ... {'date': '2023-10-04', 'temperature': 18, 'condition': 'Rainy'}, ... {'date': '2023-10-05', 'temperature': 20, 'condition': 'Sunny'} ... ] >>> date_range = {'start': '2023-10-01', 'end': '2023-10-03'} >>> weatherSummary(data, date_range) == {'averageTemperature': 20.67, 'mostCommonCondition': 'Sunny'} >>> date_range = {'start': '2023-10-02', 'end': '2023-10-04'} >>> weatherSummary(data, date_range) == {'averageTemperature': 19.33, 'mostCommonCondition': 'Cloudy'} >>> date_range = {'start': '2023-10-01', 'end': '2023-10-05'} >>> weatherSummary(data, date_range) == {'averageTemperature': 20, 'mostCommonCondition': 'Sunny'} pass","solution":"def weatherSummary(data, date_range): from collections import Counter from datetime import datetime start_date = datetime.strptime(date_range['start'], '%Y-%m-%d') end_date = datetime.strptime(date_range['end'], '%Y-%m-%d') filtered_data = [ entry for entry in data if start_date <= datetime.strptime(entry['date'], '%Y-%m-%d') <= end_date ] total_temp = sum(entry['temperature'] for entry in filtered_data) count = len(filtered_data) average_temp = round(total_temp / count, 2) condition_counter = Counter(entry['condition'] for entry in filtered_data) most_common_condition = min( condition_counter.items(), key=lambda x: (-x[1], x[0]) )[0] return { 'averageTemperature': average_temp, 'mostCommonCondition': most_common_condition }"},{"question":"def palindrome_index_finder(s: str) -> int: Given a string s, this function returns the minimum index i such that when you remove the character at the index i in the string, the resulting string is a palindrome. If the string is already a palindrome, return -1. If no such index exists, return -1. >>> palindrome_index_finder(\\"abca\\") == 1 >>> palindrome_index_finder(\\"racecar\\") == -1 >>> palindrome_index_finder(\\"hello\\") == -1 >>> palindrome_index_finder(\\"a\\") == -1 >>> palindrome_index_finder(\\"aa\\") == -1 >>> palindrome_index_finder(\\"ab\\") == 0 >>> palindrome_index_finder(\\"abcddcbae\\") == 8 >>> palindrome_index_finder(\\"abcdef\\") == -1 >>> palindrome_index_finder(\\"baaa\\") == 0 >>> palindrome_index_finder(\\"aaab\\") == 3","solution":"def is_palindrome(s: str) -> bool: Helper function to check if the given string s is a palindrome. return s == s[::-1] def palindrome_index_finder(s: str) -> int: Given a string s, this function returns the minimum index i such that when you remove the character at the index i in the string, the resulting string is a palindrome. If the string is already a palindrome, return -1. If no such index exists, return -1. if is_palindrome(s): return -1 n = len(s) for i in range(n // 2): if s[i] != s[n - i - 1]: # Check if removing s[i] makes the remaining string a palindrome if is_palindrome(s[:i] + s[i + 1:]): return i # Check if removing s[n - i - 1] makes the remaining string a palindrome if is_palindrome(s[:n - i - 1] + s[n - i:]): return n - i - 1 return -1 return -1"},{"question":"from typing import List def rearrange_cost(s: str) -> int: Rearrange a given string so that no two identical characters are adjacent. The cost of swapping characters is given by the absolute difference between their positions. If it is not possible to rearrange the string, return -1. pass def solve(test_cases: List[str]) -> List[int]: results = [] for s in test_cases: results.append(rearrange_cost(s)) return results def test_rearrange_cost_simple_cases(): assert rearrange_cost(\\"aabbcc\\") == 0 assert rearrange_cost(\\"aa\\") == -1 assert rearrange_cost(\\"ab\\") == 0 assert rearrange_cost(\\"aaacccbb\\") == 4 def test_rearrange_cost_no_possible_reorder(): assert rearrange_cost(\\"aaa\\") == -1 def test_rearrange_cost_mixed_cases(): assert rearrange_cost(\\"aabbaacc\\") == 4 assert rearrange_cost(\\"aabbbccc\\") == 3 assert rearrange_cost(\\"bbba\\") == -1 def test_solve_multiple_test_cases(): test_cases = [\\"aabbcc\\", \\"aa\\", \\"ab\\", \\"aaacccbb\\"] results = solve(test_cases) assert results == [0, -1, 0, 4] def test_rearrange_cost_single_char_cases(): assert rearrange_cost(\\"a\\") == 0 assert rearrange_cost(\\"aaaa\\") == -1 assert rearrange_cost(\\"abc\\") == 0","solution":"from heapq import heappush, heappop from collections import Counter def rearrange_cost(s): freq = Counter(s) max_freq = max(freq.values()) if max_freq > (len(s) + 1) // 2: return -1 max_heap = [] for char, count in freq.items(): heappush(max_heap, (-count, char)) result = [] while len(max_heap) >= 2: count1, char1 = heappop(max_heap) count2, char2 = heappop(max_heap) result.append(char1) result.append(char2) if -count1 > 1: heappush(max_heap, (count1 + 1, char1)) if -count2 > 1: heappush(max_heap, (count2 + 1, char2)) if max_heap: result.append(max_heap[0][1]) return 0 def solve(test_cases): results = [] for s in test_cases: results.append(rearrange_cost(s)) return results"},{"question":"def merge_and_sort(list1, list2): Merges two lists of strings and returns a sorted list of unique strings. The sorting is case-insensitive. >>> merge_and_sort(['Banana', 'apple', 'Cherry'], ['banana', 'lemon', 'Apple']) == ['apple', 'banana', 'cherry', 'lemon'] >>> merge_and_sort(['Word', 'another', 'Example'], ['word', 'Another', 'example']) == ['another', 'example', 'word'] >>> merge_and_sort(['Hello', 'world'], ['hello', 'WORLD']) == ['hello', 'world'] >>> merge_and_sort([], ['Banana', 'apple']) == ['apple', 'banana'] >>> merge_and_sort(['Word', 'another'], []) == ['another', 'word'] >>> merge_and_sort([], []) == [] >>> merge_and_sort(['test', 'test'], ['TEST', 'TeSt']) == ['test'] >>> merge_and_sort(['b', 'a'], ['A', 'B']) == ['a', 'b']","solution":"def merge_and_sort(list1, list2): Merges two lists of strings and returns a sorted list of unique strings. The sorting is case-insensitive. # Combine the lists combined_list = list1 + list2 # Convert the combined list to a set to remove duplicates, case-insensitively unique_set = set(x.lower() for x in combined_list) # Convert the unique set back to a list and sort it alphabetically sorted_list = sorted(unique_set) return sorted_list"},{"question":"def calculate_scores(tasks): Calculate the productivity score for each employee based on completed tasks. The function takes a dictionary where the keys are employee names and the values are lists of tuples. Each tuple contains the task difficulty level (an integer from 1 to 5) and the number of tasks completed (an integer). Parameters: tasks (dict): A dictionary where keys are employee names and values are lists of tuples (task difficulty level (int), number of tasks completed (int)). Returns: dict: A dictionary where keys are employee names and values are their total productivity scores. Returns an empty dictionary if the input is empty or contains invalid data.","solution":"def calculate_scores(tasks): Calculate the productivity score for each employee based on completed tasks. Parameters: tasks (dict): A dictionary where keys are employee names (str) and values are lists of tuples (task difficulty level (int), number of tasks completed (int)). Returns: dict: A dictionary where keys are employee names and values are their total productivity scores. point_system = {1: 10, 2: 20, 3: 30, 4: 40, 5: 50} result = {} for employee, task_list in tasks.items(): total_score = 0 for difficulty, count in task_list: if not isinstance(difficulty, int) or not isinstance(count, int): return {} if difficulty not in point_system: return {} total_score += point_system[difficulty] * count result[employee] = total_score return result"},{"question":"import heapq from typing import Dict, List, Tuple def dijkstra(graph: Dict[str, List[Tuple[str, int]]], source: str) -> Dict[str, float]: Finds the shortest path from the source node to all other nodes in the network using Dijkstra's algorithm. Parameters: graph (dict): A dictionary representing the graph, where keys are node labels and values are lists of tuples (neighbor, cost). source (str): The starting node. Returns: dict: A dictionary where the keys are nodes and the values are their shortest travel cost from the source node. >>> graph = { ... 'A': [('B', 1), ('C', 4)], ... 'B': [('A', 1), ('C', 2), ('D', 5)], ... 'C': [('A', 4), ('B', 2), ('D', 1)], ... 'D': [('B', 5), ('C', 1)], ... } >>> source = 'A' >>> dijkstra(graph, source) {'A': 0, 'B': 1, 'C': 3, 'D': 4} >>> graph = { ... 'A': [('B', 1)], ... 'B': [('A', 1)], ... 'C': [('D', 1)], ... 'D': [('C', 1)], ... } >>> source = 'A' >>> dijkstra(graph, source) {'A': 0, 'B': 1, 'C': float('inf'), 'D': float('inf')}","solution":"import heapq def dijkstra(graph, source): Finds the shortest path from the source node to all other nodes in the network using Dijkstra's algorithm. Parameters: graph (dict): A dictionary representing the graph, where keys are node labels and values are lists of tuples (neighbor, cost). source (str): The starting node. Returns: dict: A dictionary where the keys are nodes and the values are their shortest travel cost from the source node. # Initialize distances with infinity distances = {node: float('inf') for node in graph} distances[source] = 0 # Priority queue to manage the node exploration priority_queue = [(0, source)] heapq.heapify(priority_queue) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the current distance is greater than the stored distance, continue if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, cost in graph.get(current_node, []): distance = current_distance + cost if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"import math def factorial_list(numbers, n): Given a list of non-negative integers and an integer n, return a list of the factorials of all integers in the list that are less than or equal to n. Args: numbers (list of int): List of non-negative integers. n (int): A non-negative integer limit. Returns: list of int: List of factorials of the integers less than or equal to n. Examples: >>> factorial_list([1, 3, 5, 7], 5) [1, 6, 120] >>> factorial_list([0, 2, 4, 8], 4) [1, 2, 24] >>> factorial_list([6, 7, 8, 9], 5) []","solution":"import math def factorial_list(numbers, n): Given a list of non-negative integers and an integer n, return a list of the factorials of all integers in the list that are less than or equal to n. Args: numbers (list of int): List of non-negative integers. n (int): A non-negative integer limit. Returns: list of int: List of factorials of the integers less than or equal to n. return [math.factorial(number) for number in numbers if number <= n]"},{"question":"def max_subarray_sum(arr): Function to find the maximum sum of any contiguous subarray. pass def solve(input_data): Function to solve the given task of finding the maximum possible sum of any contiguous subarray. >>> input_data = \\"2n5n1 -2 3 4 -5n4n-3 -1 -2 -5\\" >>> solve(input_data) \\"7n-1\\" >>> input_data = \\"2n1n5n1n-5\\" >>> solve(input_data) \\"5n-5\\" >>> input_data = \\"1n4n1 2 3 4\\" >>> solve(input_data) \\"10\\" >>> input_data = \\"1n4n-1 -2 -3 -4\\" >>> solve(input_data) \\"-1\\" >>> input_data = \\"1n10n2 -1 2 3 4 -5 -4 2 0 1\\" >>> solve(input_data) \\"10\\" >>> input_data = \\"1n10n-2 -3 -1 -4 -6 -5 -8 -4 -3 -2\\" >>> solve(input_data) \\"-1\\" pass","solution":"def max_subarray_sum(arr): Function to find the maximum sum of any contiguous subarray. max_so_far = arr[0] max_ending_here = arr[0] for i in range(1, len(arr)): max_ending_here = max(arr[i], max_ending_here + arr[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far def solve(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) results = [] index = 1 for _ in range(T): N = int(lines[index]) array = list(map(int, lines[index + 1].split())) results.append(max_subarray_sum(array)) index += 2 return \\"n\\".join(map(str, results))"},{"question":"def is_armstrong_number(num): Check if a number is an Armstrong number. >>> is_armstrong_number(1) True >>> is_armstrong_number(153) True >>> is_armstrong_number(10) False pass def find_armstrong_numbers(N): Find all Armstrong numbers between 1 and N inclusive. >>> find_armstrong_numbers(10) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> find_armstrong_numbers(100) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> find_armstrong_numbers(1000) [1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407] pass def armstrong_numbers(test_cases): Given a list of test cases, return the list of Armstrong numbers for each test case. >>> armstrong_numbers([10]) [[1, 2, 3, 4, 5, 6, 7, 8, 9]] >>> armstrong_numbers([100]) [[1, 2, 3, 4, 5, 6, 7, 8, 9]] >>> armstrong_numbers([1000]) [[1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407]] >>> armstrong_numbers([10, 100, 1000]) [[1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407]] pass","solution":"def is_armstrong_number(num): digits = list(map(int, str(num))) num_digits = len(digits) return num == sum(d ** num_digits for d in digits) def find_armstrong_numbers(N): return [i for i in range(1, N + 1) if is_armstrong_number(i)] def armstrong_numbers(test_cases): results = [] for N in test_cases: results.append(find_armstrong_numbers(N)) return results"},{"question":"def findMedian(nums: List[int]) -> Union[int, float]: Returns the median value of a list of integers. The list can have an odd or even number of elements. If the number of elements is even, the median is the average of the two middle numbers. >>> findMedian([1, 3, 3, 6, 7, 8, 9]) 6 >>> findMedian([1, 2, 3, 4, 5, 6, 8, 9]) 4.5","solution":"def findMedian(nums): Returns the median value of a list of integers. :param nums: List of integers :return: Median value as an integer or float nums_sorted = sorted(nums) n = len(nums_sorted) mid = n // 2 if n % 2 == 0: median = (nums_sorted[mid - 1] + nums_sorted[mid]) / 2 else: median = nums_sorted[mid] return median"},{"question":"def longest_consecutive(nums): Your task is to find the longest consecutive sequence of numbers in the given unsorted integer array, nums. The sequence should be formed by the numbers themselves, not by the indices, and you must do so in O(n) time complexity. >>> longest_consecutive([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive([0,3,7,2,5,8,4,6,0,1]) == 9 >>> longest_consecutive([9,1,4,7,3,-1,0,5,8,-1,6]) == 7 >>> longest_consecutive([1,2,0,1]) == 3 >>> longest_consecutive([]) == 0 >>> longest_consecutive([5]) == 1 >>> longest_consecutive([5, 5]) == 1 >>> longest_consecutive(list(range(1, 100001))) == 100000","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # only check for the start of sequences if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def count_flowerbeds(m: int, n: int, garden: List[str]) -> int: Counts the number of distinct flowerbeds in the garden. Parameters: m (int): Number of rows in the garden. n (int): Number of columns in the garden. garden (list of str): The garden represented as a list of strings. Returns: int: The number of distinct flowerbeds. >>> count_flowerbeds(4, 5, [\\"11000\\", \\"11000\\", \\"00100\\", \\"00011\\"]) 3 >>> count_flowerbeds(3, 3, [\\"111\\", \\"010\\", \\"111\\"]) 1","solution":"def count_flowerbeds(m, n, garden): Counts the number of distinct flowerbeds in the garden. Parameters: m (int): Number of rows in the garden. n (int): Number of columns in the garden. garden (list of str): The garden represented as a list of strings. Returns: int: The number of distinct flowerbeds. def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or garden[x][y] == '0': return garden[x][y] = '0' # Mark the cell as visited by setting it to '0' # Check all four directions dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) garden = [list(row) for row in garden] flowerbeds = 0 for i in range(m): for j in range(n): if garden[i][j] == '1': dfs(i, j) flowerbeds += 1 return flowerbeds"},{"question":"from typing import List def calculate_trapped_water(height_map: List[List[int]], m: int, n: int) -> int: Given a 2D grid of integers where each cell represents the height of that particular point on a terrain, compute the total water volume that would be trapped if the terrain is exposed to heavy rain. The rainwater can only be trapped where there are depressions between the heights, and the water cannot flow out of the grid. >>> calculate_trapped_water([[1, 4, 3], [3, 2, 3], [2, 3, 4]], 3, 3) 1 >>> calculate_trapped_water([[1, 1], [1, 1]], 2, 2) 0 >>> calculate_trapped_water([[200, 200], [200, 200]], 2, 2) 0 pass def process_input(input_data: str) -> List[str]: Process the input data, execute the test cases, and return the corresponding output. >>> process_input(\\"3 3n1 4 3n3 2 3n2 3 4n2 2n1 1n1 1n2 2n200 200n200 200n0 0n\\") [\\"Case #1: 1\\", \\"Case #2: 0\\", \\"Case #3: 0\\"] >>> process_input(\\"4 4n1 2 2 1n2 1 1 2n2 1 1 2n1 2 2 1n3 3n1 4 3n3 2 3n2 3 4n0 0n\\") [\\"Case #1: 4\\", \\"Case #2: 1\\"] pass def test_calculate_trapped_water(): height_map_1 = [ [1, 4, 3], [3, 2, 3], [2, 3, 4] ] assert calculate_trapped_water(height_map_1, 3, 3) == 1 height_map_2 = [ [1, 1], [1, 1] ] assert calculate_trapped_water(height_map_2, 2, 2) == 0 height_map_3 = [ [200, 200], [200, 200] ] assert calculate_trapped_water(height_map_3, 2, 2) == 0 def test_process_input(): input_data = \\"3 3n1 4 3n3 2 3n2 3 4n2 2n1 1n1 1n2 2n200 200n200 200n0 0n\\" expected_output = [ \\"Case #1: 1\\", \\"Case #2: 0\\", \\"Case #3: 0\\" ] assert process_input(input_data) == expected_output input_data = \\"4 4n1 2 2 1n2 1 1 2n2 1 1 2n1 2 2 1n3 3n1 4 3n3 2 3n2 3 4n0 0n\\" expected_output = [ \\"Case #1: 4\\", \\"Case #2: 1\\" ] assert process_input(input_data) == expected_output","solution":"import heapq def calculate_trapped_water(height_map, m, n): if not height_map or m < 3 or n < 3: return 0 heap = [] visited = [[False] * n for _ in range(m)] for i in range(m): heapq.heappush(heap, (height_map[i][0], i, 0)) heapq.heappush(heap, (height_map[i][n-1], i, n-1)) visited[i][0] = True visited[i][n-1] = True for j in range(n): heapq.heappush(heap, (height_map[0][j], 0, j)) heapq.heappush(heap, (height_map[m-1][j], m-1, j)) visited[0][j] = True visited[m-1][j] = True total_water = 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: water_trapped = max(0, height - height_map[nx][ny]) total_water += water_trapped heapq.heappush(heap, (max(height, height_map[nx][ny]), nx, ny)) visited[nx][ny] = True return total_water def process_input(input_data): lines = input_data.strip().split('n') index = 0 case_number = 1 results = [] while index < len(lines): m, n = map(int, lines[index].split()) if m == 0 and n == 0: break index += 1 height_map = [] for _ in range(m): height_map.append(list(map(int, lines[index].split()))) index += 1 water_trapped = calculate_trapped_water(height_map, m, n) results.append(f\\"Case #{case_number}: {water_trapped}\\") case_number += 1 return results"},{"question":"def findSecondLargest(nums): Find the second largest number in the list without using built-in functions for sorting. If the list has fewer than two unique numbers, return None. >>> findSecondLargest([1, 3, 4, 5, 0, 2]) 4 >>> findSecondLargest([1, 1, 1, 1]) None >>> findSecondLargest([5]) None","solution":"def findSecondLargest(nums): if len(nums) < 2: return None first = second = float('-inf') for num in nums: if num > first: second = first first = num elif num > second and num != first: second = num if second == float('-inf'): return None else: return second"},{"question":"def max_profit(prices: List[int]) -> int: Given a list of stock prices, determines the maximum profit that can be made by buying and selling the stock only once. Args: prices (List[int]): List of stock prices. Returns: int: The maximum profit possible. Returns 0 if no profit can be made. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5, 6]) 5 from solution import max_profit def test_example1(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 def test_example2(): assert max_profit([7, 6, 4, 3, 1]) == 0 def test_example3(): assert max_profit([1, 2, 3, 4, 5, 6]) == 5 def test_single_day(): assert max_profit([10]) == 0 # less than 2 elements def test_two_days_no_profit(): assert max_profit([10, 8]) == 0 # no profit def test_two_days_profit(): assert max_profit([8, 10]) == 2 # profit of 2 def test_multiple_days_varied_prices(): assert max_profit([3, 3, 5, 0, 0, 3, 1, 4]) == 4 # Buy at 0, sell at 4 def test_all_equal_prices(): assert max_profit([1, 1, 1, 1, 1]) == 0 # no profit possible def test_zeros_and_positives(): assert max_profit([0, 0, 0, 0, 5]) == 5 # Buy at 0, sell at 5","solution":"def max_profit(prices): Given a list of stock prices, determines the maximum profit that can be made by buying and selling the stock only once. Args: prices (List[int]): List of stock prices. Returns: int: The maximum profit possible. Returns 0 if no profit can be made. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: # Update the minimum price seen so far if price < min_price: min_price = price # Calculate the profit if we sold at the current price profit = price - min_price # Update the maximum profit seen so far if profit > max_profit: max_profit = profit return max_profit"},{"question":"def isReverse(a, b): Check if array b is the reverse of array a. Parameters: a (list): The original array. b (list): The array to check if it is the reverse of a. Returns: bool: True if b is the reverse of a, False otherwise. Examples: >>> isReverse([1, 2, 3], [3, 2, 1]) True >>> isReverse([1, 2, 3], [1, 2, 3]) False >>> isReverse(['a', 'b', 'c'], ['c', 'b', 'a']) True >>> isReverse(['a', 1, 'b'], ['b', 1, 'a']) True","solution":"def isReverse(a, b): Check if array b is the reverse of array a. Parameters: a (list): The original array. b (list): The array to check if it is the reverse of a. Returns: bool: True if b is the reverse of a, False otherwise. return a == b[::-1]"},{"question":"def check_pangram(s: str) -> str: Checks if the input string s contains all the letters of the English alphabet at least once. Returns \\"pangram\\" if true, otherwise returns \\"not pangram\\". >>> check_pangram(\\"The quick brown fox jumps over the lazy dog\\") \\"pangram\\" >>> check_pangram(\\"Hello world\\") \\"not pangram\\" >>> check_pangram(\\"We promptly judged antique ivory buckles for the Next Prize\\") \\"pangram\\" >>> check_pangram(\\"1234567890 The quick brown fox jumps over the lazy dog 0987654321\\") \\"pangram\\" >>> check_pangram(\\"\\") \\"not pangram\\" >>> check_pangram(\\"abcdefghijklmnopqrstuvwxyz\\" * 5) \\"pangram\\" >>> check_pangram(\\"thequickbrownfoxjumpsoverthelazydog\\") \\"pangram\\"","solution":"def check_pangram(s): Checks if the input string s contains all the letters of the English alphabet at least once. Prints \\"pangram\\" if true, otherwise prints \\"not pangram\\". # Create a set of all lowercase alphabet characters alphabet_set = set('abcdefghijklmnopqrstuvwxyz') # Create a set of all unique characters in the input string, converted to lowercase input_set = set(s.lower()) # Check if all alphabet characters are in the input set if alphabet_set.issubset(input_set): return \\"pangram\\" else: return \\"not pangram\\""},{"question":"from typing import List, Tuple def find_project_order(projects: List[str], dependencies: List[Tuple[str, str]]) -> List[str]: Find the order in which projects should be completed given their dependencies in a Directed Acyclic Graph (DAG). Args: projects (List[str]): A list of project names, each project represented as a string. dependencies (List[Tuple[str, str]]): A list of dependencies where each dependency is represented as a tuple (u, v) meaning that project u must be completed before project v. Returns: List[str]: A list of project names in a valid topological order. >>> find_project_order([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\"], [(\\"a\\", \\"d\\"), (\\"f\\", \\"b\\"), (\\"b\\", \\"d\\"), (\\"f\\", \\"a\\"), (\\"d\\", \\"c\\")]) ['f', 'e', 'a', 'b', 'd', 'c'] >>> find_project_order([\\"w\\", \\"x\\", \\"y\\", \\"z\\"], [(\\"w\\", \\"z\\"), (\\"x\\", \\"z\\"), (\\"z\\", \\"y\\")]) ['w', 'x', 'z', 'y'] pass def test_find_project_order_example_1(): projects = [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\"] dependencies = [(\\"a\\", \\"d\\"), (\\"f\\", \\"b\\"), (\\"b\\", \\"d\\"), (\\"f\\", \\"a\\"), (\\"d\\", \\"c\\")] result = find_project_order(projects, dependencies) assert set(result) == set(projects) for u, v in dependencies: assert result.index(u) < result.index(v) def test_find_project_order_example_2(): projects = [\\"w\\", \\"x\\", \\"y\\", \\"z\\"] dependencies = [(\\"w\\", \\"z\\"), (\\"x\\", \\"z\\"), (\\"z\\", \\"y\\")] result = find_project_order(projects, dependencies) assert set(result) == set(projects) for u, v in dependencies: assert result.index(u) < result.index(v) def test_find_project_order_no_dependencies(): projects = [\\"a\\", \\"b\\", \\"c\\"] dependencies = [] result = find_project_order(projects, dependencies) assert set(result) == set(projects) def test_find_project_order_single_project(): projects = [\\"a\\"] dependencies = [] result = find_project_order(projects, dependencies) assert result == [\\"a\\"] def test_find_project_order_cycle(): projects = [\\"a\\", \\"b\\", \\"c\\"] dependencies = [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"a\\")] result = find_project_order(projects, dependencies) assert result == []","solution":"from collections import defaultdict, deque def find_project_order(projects, dependencies): # Step 1: Create an adjacency list for the projects adj_list = defaultdict(list) indegree = defaultdict(int) for u, v in dependencies: adj_list[u].append(v) indegree[v] += 1 # Step 2: Find all projects with no incoming edges (indegree 0) zero_indegree_queue = deque([project for project in projects if indegree[project] == 0]) topological_order = [] while zero_indegree_queue: project = zero_indegree_queue.popleft() topological_order.append(project) # Reduce the indegree of the neighboring nodes by 1 for neighbor in adj_list[project]: indegree[neighbor] -= 1 # If indegree becomes 0, add it to the queue if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) # If topological_order does not contain all projects, there was a cycle if len(topological_order) != len(projects): return [] return topological_order"},{"question":"def calculate_variance(readings, mean): Calculate variance given a list of readings and their mean. pass def anomaly_detection(T, N, temperature_readings): Calculate the number of hours with temperature anomaly. :param T: Threshold value for anomaly detection. :param N: Total number of temperature readings. :param temperature_readings: List of temperature readings. :return: Number of hours with anomaly. pass def test_anomaly_detection(): T = 4 N = 120 temperature_readings = [ 72, 71, 69, 70, 73, 74, 68, 72, 75, 70, 69, 71, 72, 73, 73, 72, 70, 69, 71, 70, 70, 72, 71, 68, 74, 69, 73, 72, 71, 72, 70, 69, 73, 75, 74, 71, 72, 73, 72, 71, 71, 70, 69, 75, 72, 71, 72, 74, 69, 70, 73, 75, 70, 74, 73, 71, 70, 68, 73, 75, 77, 79, 80, 81, 83, 84, 82, 83, 86, 80, 77, 81, 83, 82, 81, 80, 79, 79, 82, 80, 81, 82, 83, 79, 84, 80, 83, 82, 81, 82, 80, 79, 83, 85, 84, 81, 82, 83, 82, 81, 81, 80, 79, 85, 82, 81, 82, 84, 79, 80, 83, 85, 80, 84, 83, 81, 80, 78, 83, 85 ] assert anomaly_detection(T, N, temperature_readings) == 1 def test_anomaly_detection_no_anomalies(): T = 10 N = 60 temperature_readings = [70] * 60 assert anomaly_detection(T, N, temperature_readings) == 0 def test_anomaly_detection_with_multiple_anomalies(): T = 4 N = 180 temperature_readings = [ 70, 71, 72, 69, 70, 68, 73, 68, 73, 72, 69, 71, 70, 73, 73, 72, 69, 70, 71, 70, 70, 69, 68, 74, 69, 73, 72, 71, 72, 70, 70, 68, 74, 73, 71, 72, 69, 68, 73, 72, 70, 69, 68, 74, 70, 71, 72, 74, 69, 70, 70, 73, 69, 71, 72, 73, 72, 70, 69, 73, 77, 88, 85, 80, 79, 90, 85, 84, 83, 88, 86, 80, 81, 89, 82, 78, 83, 89, 86, 84, 82, 81, 79, 85, 78, 90, 80, 82, 79, 86, 82, 83, 89, 88, 84, 87, 80, 79, 88, 86, 87, 83, 81, 82, 80, 79, 85, 88, 80, 82, 86, 90, 89, 88, 81, 78, 89, 88, 81, 85, 75, 75, 76, 74, 74, 76, 74, 74, 75, 74, 75, 75, 76, 75, 74, 75, 74, 75, 76, 75, 75, 75, 76, 74, 75, 75, 76, 75, 74, 75, 75, 76, 76, 75, 74, 75, 75, 76, 75, 74, 74, 75, 76, 74, 74, 75, 75, 76, 75, 75, 75, 76, 75, 74, 75, 74, 75, 74, 75, 75 ] assert anomaly_detection(T, N, temperature_readings) == 1 def test_anomaly_detection_all_anomalies(): T = 2 N = 120 temperature_readings = [ 72, 71, 69, 70, 73, 74, 68, 72, 75, 70, 69, 71, 72, 73, 73, 72, 70, 69, 71, 70, 70, 72, 71, 68, 74, 69, 73, 72, 71, 72, 70, 69, 73, 75, 74, 71, 72, 73, 72, 71, 71, 70, 69, 75, 72, 71, 72, 74, 69, 70, 73, 75, 70, 74, 73, 71, 70, 68, 73, 75, 77, 79, 80, 81, 83, 84, 82, 83, 86, 80, 77, 81, 83, 82, 81, 80, 79, 79, 82, 80, 81, 82, 83, 79, 84, 80, 83, 82, 81, 82, 80, 79, 83, 85, 84, 81, 82, 83, 82, 81, 81, 80, 79, 85, 82, 81, 82, 84, 79, 80, 83, 85, 80, 84, 83, 81, 80, 78, 83, 85 ] assert anomaly_detection(T, N, temperature_readings) == 2","solution":"import math def calculate_variance(readings, mean): Calculate variance given a list of readings and their mean. N = len(readings) variance = sum((xi - mean) ** 2 for xi in readings) / N return variance def anomaly_detection(T, N, temperature_readings): Calculate the number of hours with temperature anomaly. :param T: Threshold value for anomaly detection. :param N: Total number of temperature readings. :param temperature_readings: List of temperature readings. :return: Number of hours with anomaly. hours = N // 60 anomaly_count = 0 for i in range(hours): readings = temperature_readings[i * 60:(i + 1) * 60] mean = sum(readings) / 60 variance = calculate_variance(readings, mean) if variance > T: anomaly_count += 1 return anomaly_count"},{"question":"def rearrange_string(s: str) -> str: Rearranges the characters in a given string such that no two adjacent characters are the same. If such a rearrangement is not possible, return an empty string. >>> rearrange_string(\\"aaabbc\\") != \\"\\" >>> rearrange_string(\\"aaab\\") == \\"\\" >>> rearrange_string(\\"aabbcc\\") != \\"\\" >>> rearrange_string(\\"aa\\") == \\"\\" >>> rearrange_string(\\"a\\") == \\"a\\"","solution":"import heapq from collections import Counter def rearrange_string(s): Rearranges the characters in a given string such that no two adjacent characters are the same. If it's not possible, returns an empty string. # Frequency of each character freq_map = Counter(s) max_heap = [(-freq, char) for char, freq in freq_map.items()] heapq.heapify(max_heap) prev_char, prev_freq = None, 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 rearranged_str = \\"\\".join(result) if len(rearranged_str) != len(s): return \\"\\" # Not possible to rearrange return rearranged_str"},{"question":"def first_n_primes(n: int): Create a function that takes a number \`n\` and returns a list of the first \`n\` prime numbers. Prime numbers are those that have only two distinct positive divisors: 1 and themselves. If the input \`n\` is not a positive integer, return \\"Not valid\\". >>> first_n_primes(5) => [2, 3, 5, 7, 11] >>> first_n_primes(0) => \\"Not valid\\" >>> first_n_primes(\\"6\\") => \\"Not valid\\" >>> first_n_primes(10) => [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]","solution":"def first_n_primes(n): Returns a list of the first n prime numbers. If n is not a positive integer, returns \\"Not valid\\". if not isinstance(n, int) or n <= 0: return \\"Not valid\\" primes = [] num = 2 # Start checking for primes from 2 while len(primes) < n: if all(num % p != 0 for p in primes): primes.append(num) num += 1 return primes"},{"question":"from typing import List def max_even_ending_subarray_sum(arr: List[int]) -> int: Returns the maximum sum of a non-empty subarray that starts and ends with an even number. An empty input list should return 0. Subarrays consisting of a single even element are valid. Multiple subarrays can have the same even number at their start and/or end. >>> max_even_ending_subarray_sum([1, 2, 3, 4, 5]) 9 >>> max_even_ending_subarray_sum([8, 2, 3, 5, 6]) 24 >>> max_even_ending_subarray_sum([1, 3, 5]) 0","solution":"def max_even_ending_subarray_sum(arr): Returns the maximum sum of a non-empty subarray that starts and ends with an even number. max_sum = 0 n = len(arr) if n == 0: return max_sum for i in range(n): if arr[i] % 2 == 0: for j in range(i, n): if arr[j] % 2 == 0: subarray_sum = sum(arr[i:j + 1]) max_sum = max(max_sum, subarray_sum) return max_sum"},{"question":"from typing import List def longest_increasing_subsequence_lengths(nums: List[int]) -> List[int]: Given an integer array nums, return an array containing the length of the longest increasing subsequence that ends with each element of nums. Args: nums: List[int] - The input array of integers. Returns: List[int] - An array where each element represents the length of the longest increasing subsequence ending with the corresponding element in the input array. Examples: >>> longest_increasing_subsequence_lengths([1, 3, 5, 4, 7]) [1, 2, 3, 3, 4] >>> longest_increasing_subsequence_lengths([2, 2, 2, 2, 2]) [1, 1, 1, 1, 1] >>> longest_increasing_subsequence_lengths([0, 1, 0, 3, 2, 3]) [1, 2, 1, 3, 3, 4] pass def test_example_1(): assert longest_increasing_subsequence_lengths([1, 3, 5, 4, 7]) == [1, 2, 3, 3, 4] def test_example_2(): assert longest_increasing_subsequence_lengths([2, 2, 2, 2, 2]) == [1, 1, 1, 1, 1] def test_example_3(): assert longest_increasing_subsequence_lengths([0, 1, 0, 3, 2, 3]) == [1, 2, 1, 3, 3, 4] def test_single_element(): assert longest_increasing_subsequence_lengths([10]) == [1] def test_increasing_sequence(): assert longest_increasing_subsequence_lengths([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_decreasing_sequence(): assert longest_increasing_subsequence_lengths([5, 4, 3, 2, 1]) == [1, 1, 1, 1, 1] def test_mixed_sequence(): assert longest_increasing_subsequence_lengths([10, 20, 10, 30, 20, 50]) == [1, 2, 1, 3, 2, 4]","solution":"def longest_increasing_subsequence_lengths(nums): Given an integer array nums, return an array containing the length of the longest increasing subsequence that ends with each element of nums. if not nums: return [] n = len(nums) dp = [1] * n # dp[i] will store the length of the LIS ending at index i for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return dp"},{"question":"def generate_staircase(n: int) -> str: Generates a string representation of a right-aligned staircase with n steps. Parameters: n (int): Number of steps in the staircase. Returns: str: String representation of the staircase. >>> generate_staircase(5) \\" #n n #n n#n\\" >>> generate_staircase(3) \\" #n n#n\\" >>> generate_staircase(0) \\"n\\" >>> generate_staircase(1) \\"#n\\" >>> generate_staircase(2) \\" #nn\\"","solution":"def generate_staircase(n): Generates a string representation of a right-aligned staircase with n steps. Parameters: n (int): Number of steps in the staircase. Returns: str: String representation of the staircase. if n == 0: return \\"n\\" staircase = \\"\\" for i in range(1, n+1): staircase += \\" \\" * (n - i) + \\"#\\" * i + \\"n\\" return staircase"},{"question":"from typing import List, Tuple def max_importance_path_sum(T: int, inputs: List[int]) -> List[int]: Find the maximum sum of importance values from the root to any leaf in the hierarchy tree. :param T: Number of test cases :param inputs: List of input values for each test case :return: List of maximum sums for each test case >>> max_importance_path_sum(1, [5, 10, 5, 3, 6, 2, 1, 2, 1, 3, 2, 4, 2, 5]) [21] >>> max_importance_path_sum(1, [3, 4, 7, 3, 1, 2, 1, 3]) [11]","solution":"from collections import defaultdict, deque def find_max_path_sum(num_cases, cases): results = [] for case in cases: N, importance, edges = case # Handling a single-node case if N == 1: results.append(importance[0]) continue tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) def bfs(root): queue = deque([(root, importance[root - 1])]) visited = set() max_sum = 0 while queue: node, current_sum = queue.popleft() if node in visited: continue visited.add(node) is_leaf = True for neighbor in tree[node]: if neighbor not in visited: queue.append((neighbor, current_sum + importance[neighbor - 1])) is_leaf = False if is_leaf: max_sum = max(max_sum, current_sum) return max_sum results.append(bfs(1)) # Assuming 1 as the root node return results def max_importance_path_sum(T, inputs): cases = [] index = 0 for _ in range(T): N = inputs[index] index += 1 importance = inputs[index:index + N] index += N edges = [] for _ in range(N - 1): u, v = inputs[index], inputs[index + 1] edges.append((u, v)) index += 2 cases.append((N, importance, edges)) return find_max_path_sum(T, cases) # Example usage: T = 2 inputs = [ 5, 10, 5, 3, 6, 2, 1, 2, 1, 3, 2, 4, 2, 5, 3, 4, 7, 3, 1, 2, 1, 3 ] print(max_importance_path_sum(T, inputs)) # Expected: [21, 11]"},{"question":"from typing import List, Tuple def kth_most_frequent_character(s: str, queries: List[Tuple[int, int, int]]) -> List[str]: Determine the k-th most frequent character in the substring s[l, r] for each query. If there are ties, choose the lexicographically smaller character. Args: s (str): The input string of length n consisting of uppercase and lowercase English letters. queries (List[Tuple[int, int, int]]): A list of q queries where each query is a tuple of three integers l, r, and k. Returns: List[str]: A list of results for each query. Example: >>> kth_most_frequent_character(\\"aabbccdd\\", [(1, 4, 2), (1, 8, 4), (5, 7, 1)]) ['b', 'd', 'c'] >>> kth_most_frequent_character(\\"aaaaa\\", [(1, 5, 1), (1, 5, 2)]) ['a', 'No character'] def test_example_case(): s = \\"aabbccdd\\" queries = [(1, 4, 2), (1, 8, 4), (5, 7, 1)] expected = ['b', 'd', 'c'] result = kth_most_frequent_character(s, queries) assert result == expected def test_single_character(): s = \\"aaaaa\\" queries = [(1, 5, 1), (1, 5, 2)] expected = ['a', 'No character'] result = kth_most_frequent_character(s, queries) assert result == expected def test_tied_frequencies(): s = \\"aabbcc\\" queries = [(1, 6, 1), (1, 6, 2), (1, 6, 3), (1, 6, 4)] expected = ['a', 'b', 'c', 'No character'] result = kth_most_frequent_character(s, queries) assert result == expected def test_substring(): s = \\"abcabcabc\\" queries = [(1, 3, 1), (4, 6, 1), (7, 9, 1)] expected = ['a', 'a', 'a'] result = kth_most_frequent_character(s, queries) assert result == expected def test_query_on_different_substrings(): s = \\"abcdefghijkl\\" queries = [(1, 3, 1), (4, 6, 1), (7, 9, 1), (10, 12, 1)] expected = ['a', 'd', 'g', 'j'] result = kth_most_frequent_character(s, queries) assert result == expected","solution":"def kth_most_frequent_character(s, queries): def get_kth_frequent_character(substring, k): from collections import Counter freq_counter = Counter(substring) freq_list = sorted(sorted(freq_counter.items()), key=lambda x: (-x[1], x[0])) if len(freq_list) < k: return \\"No character\\" return freq_list[k-1][0] results = [] for (l, r, k) in queries: substring = s[l-1:r] result = get_kth_frequent_character(substring, k) results.append(result) return results"},{"question":"def largest_non_adjacent_sum(nums): Returns the largest sum of any non-adjacent numbers in the given array of positive integers. >>> largest_non_adjacent_sum([2, 4, 6, 2, 5]) 13 >>> largest_non_adjacent_sum([5, 1, 1, 5]) 10 >>> largest_non_adjacent_sum([3, 2, 5, 10, 7]) 15","solution":"def largest_non_adjacent_sum(nums): Returns the largest sum of non-adjacent numbers in the given array of positive integers. if not nums: return 0 elif len(nums) == 1: return nums[0] prev_one = 0 prev_two = 0 current = 0 for num in nums: current = max(prev_one, prev_two + num) prev_two = prev_one prev_one = current return current"},{"question":"def remove_special_characters(input_str: str) -> str: Removes all digits and special characters from the input string, leaving only alphabetic characters. Parameters: input_str (str): The string to be filtered. Returns: str: A string containing only alphabetic characters. >>> remove_special_characters(\\"123abc!@#\\") 'abc' >>> remove_special_characters(\\"a1b2c3\\") 'abc' >>> remove_special_characters(\\"Hello, World!\\") 'HelloWorld' >>> remove_special_characters(\\"Hacktober_2023!!\\") 'Hacktober'","solution":"def remove_special_characters(input_str): Removes all digits and special characters from the input string, leaving only alphabetic characters. Parameters: input_str (str): The string to be filtered. Returns: str: A string containing only alphabetic characters. return ''.join(char for char in input_str if char.isalpha())"},{"question":"def to_roman(num: int) -> str: Converts a given integer to its equivalent Roman Numeral. >>> to_roman(3) \\"III\\" >>> to_roman(58) \\"LVIII\\" >>> to_roman(1994) \\"MCMXCIV\\"","solution":"def to_roman(num: int) -> str: Converts an integer to its Roman numeral equivalent. Parameters: num (int): An integer in the range 1 to 3999. Returns: str: Roman numeral representation of the integer. value_map = [ (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I') ] roman_numeral = [] for value, symbol in value_map: while num >= value: roman_numeral.append(symbol) num -= value return ''.join(roman_numeral)"},{"question":"def is_subset_sum(arr, target): Determines if there exists a subset of the array that adds up to exactly the target number. >>> is_subset_sum([2, 3, 7, 8, 10], 11) True >>> is_subset_sum([1, 2, 5], 4) False","solution":"def is_subset_sum(arr, target): Determines if there exists a subset of the array that adds up to exactly the target number. :param arr: List of integers :param target: Target integer :return: True if such a subset exists, False otherwise n = len(arr) # Create a 2D array to store the results of subproblems dp = [[False for _ in range(target + 1)] for _ in range(n + 1)] # There is always a subset with sum 0, the empty set for i in range(n + 1): dp[i][0] = True # Fill the dp array for i in range(1, n + 1): for j in range(1, target + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] return dp[n][target]"},{"question":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Find the largest rectangular area in a histogram given by heights of bars. :param heights: List of non-negative integers representing the heights of the histogram bars. :return: The area of the largest rectangle that can be formed. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([0, 1]) 1 pass","solution":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Find the largest rectangular area in a histogram given by heights of bars. :param heights: List of non-negative integers representing the heights of the histogram bars. :return: The area of the largest rectangle that can be formed. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"class StringOperations: @staticmethod def is_rotation(s1, s2): Checks if s2 is a rotation of s1. >>> StringOperations.is_rotation(\\"waterbottle\\", \\"erbottlewat\\") \\"YES\\" >>> StringOperations.is_rotation(\\"hello\\", \\"world\\") \\"NO\\" >>> StringOperations.is_rotation(\\"abcde\\", \\"abcde\\") \\"YES\\" >>> StringOperations.is_rotation(\\"rotation\\", \\"tationro\\") \\"YES\\" >>> StringOperations.is_rotation(\\"abcdef\\", \\"ghijkl\\") \\"NO\\" >>> StringOperations.is_rotation(\\"a\\", \\"a\\") \\"YES\\" >>> StringOperations.is_rotation(\\"a\\", \\"b\\") \\"NO\\" >>> StringOperations.is_rotation(\\"aaab\\", \\"abaa\\") \\"YES\\" >>> StringOperations.is_rotation(\\"xyzxyz\\", \\"xyzxzy\\") \\"NO\\"","solution":"class StringOperations: @staticmethod def is_rotation(s1, s2): Checks if s2 is a rotation of s1. if len(s1) != len(s2): return \\"NO\\" # Concatenate s1 with itself and check if s2 is a substring combined = s1 + s1 if s2 in combined: return \\"YES\\" return \\"NO\\""},{"question":"def can_form_arithmetic_progression(n: int, numbers: List[int]) -> str: Determine if the given integers can form an arithmetic progression. >>> can_form_arithmetic_progression(4, [1, 3, 5, 7]) \\"YES\\" >>> can_form_arithmetic_progression(3, [2, 4, 8]) \\"NO\\" >>> can_form_arithmetic_progression(5, [10, 15, 20, 25, 30]) \\"YES\\" >>> can_form_arithmetic_progression(3, [1, 2, 4]) \\"NO\\" >>> can_form_arithmetic_progression(2, [7, 10]) \\"YES\\" >>> can_form_arithmetic_progression(6, [2, 4, 6, 8, 10, 12]) \\"YES\\" >>> can_form_arithmetic_progression(4, [5, 1, 7, 3]) \\"YES\\" def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: >>> process_test_cases(3, [(4, [1, 3, 5, 7]), (3, [2, 4, 8]), (5, [10, 15, 20, 25, 30])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(4, [(3, [1, 2, 4]), (2, [7, 10]), (6, [2, 4, 6, 8, 10, 12]), (4, [5, 1, 7, 3])]) [\\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_form_arithmetic_progression(n, numbers): numbers.sort() common_difference = numbers[1] - numbers[0] for i in range(2, n): if numbers[i] - numbers[i - 1] != common_difference: return \\"NO\\" return \\"YES\\" def process_test_cases(t, test_cases): results = [] for i in range(t): n, numbers = test_cases[i] result = can_form_arithmetic_progression(n, numbers) results.append(result) return results"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression and returns the result. This function supports addition (+), subtraction (-), multiplication (*), and division (/) of integers. The input string will always be a valid expression and will not contain any spaces. The solution handles operator precedence correctly. >>> evaluate_expression(\\"3+5\\") 8 >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"10-3*2\\") 4 >>> evaluate_expression(\\"8/2+3\\") 7 >>> evaluate_expression(\\"10+5-3*2\\") 9 >>> evaluate_expression(\\"1+2+3+4\\") 10 >>> evaluate_expression(\\"4+2*3-8/4\\") 8 >>> evaluate_expression(\\"123\\") 123 >>> evaluate_expression(\\"10+2*6/3-4\\") 10","solution":"def evaluate_expression(expression): Evaluates a mathematical expression and returns the result. Args: expression (str): A string representing a mathematical expression. Returns: int: The result of the evaluation. # Define an internal function to evaluate expressions def eval_internal(expr): operators, operands = [], [] i, n = 0, len(expr) def apply_operator(): operator = operators.pop() right = operands.pop() left = operands.pop() if operator == '+': operands.append(left + right) elif operator == '-': operands.append(left - right) elif operator == '*': operands.append(left * right) elif operator == '/': operands.append(int(left / right)) # Use integer division while i < n: char = expression[i] if char.isdigit(): num = 0 while i < n and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) continue elif char in '+-*/': while (operators and operators[-1] in '*/' and char in '+-') or (operators and operators[-1] in '*/' and char in '*/'): apply_operator() operators.append(char) i += 1 while operators: apply_operator() return operands[0] return eval_internal(expression)"},{"question":"def lexicographical_min_string(S: str) -> str: Given a string S, returns the lexicographically smallest string by replacing any \\"abc\\" with \\"cba\\" any number of times. >>> lexicographical_min_string(\\"abc\\") \\"abc\\" >>> lexicographical_min_string(\\"cba\\") \\"abc\\" >>> lexicographical_min_string(\\"abccba\\") \\"aabbcc\\" def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes multiple test cases and returns the results for each test case. >>> process_test_cases(3, [\\"abc\\", \\"cba\\", \\"abccba\\"]) [\\"abc\\", \\"abc\\", \\"aabbcc\\"]","solution":"def lexicographical_min_string(S): Given a string S, returns the lexicographically smallest string by replacing any \\"abc\\" with \\"cba\\" any number of times. # Since replacing \\"abc\\" with \\"cba\\" or \\"cba\\" with \\"abc\\" sorts the characters, # the smallest lexicographical string will be the sorted version of S. return ''.join(sorted(S)) def process_test_cases(T, test_cases): results = [] for i in range(T): result = lexicographical_min_string(test_cases[i]) results.append(result) return results"},{"question":"def sort_dict_by_values(d: dict) -> list: Takes a dictionary as input and returns a list of tuples sorted based on the dictionary values in descending order. If two values are the same, sort the corresponding keys in ascending order. Parameters: d (dict): Input dictionary where key is a string and value is an int Returns: list: List of tuples sorted as per the rules mentioned >>> sort_dict_by_values({\\"apple\\": 2, \\"banana\\": 1, \\"cherry\\": 2, \\"date\\": 3}) [(\\"date\\", 3), (\\"apple\\", 2), (\\"cherry\\", 2), (\\"banana\\", 1)] >>> sort_dict_by_values({\\"a\\": 3, \\"b\\": 2, \\"c\\": 3, \\"d\\": 1}) [(\\"a\\", 3), (\\"c\\", 3), (\\"b\\", 2), (\\"d\\", 1)] >>> sort_dict_by_values({\\"apple\\": 5, \\"banana\\": 3, \\"cherry\\": 1}) [(\\"apple\\", 5), (\\"banana\\", 3), (\\"cherry\\", 1)] >>> sort_dict_by_values({\\"a\\": 0, \\"b\\": 0, \\"c\\": 0}) [(\\"a\\", 0), (\\"b\\", 0), (\\"c\\", 0)] >>> sort_dict_by_values({\\"z\\": 2, \\"y\\": 2, \\"x\\": 3}) [(\\"x\\", 3), (\\"y\\", 2), (\\"z\\", 2)]","solution":"def sort_dict_by_values(d): Takes a dictionary as input and returns a list of tuples sorted based on the dictionary values in descending order. If two values are the same, sort the corresponding keys in ascending order. Parameters: d (dict): Input dictionary where key is a string and value is an int Returns: list: List of tuples sorted as per the rules mentioned return sorted(d.items(), key=lambda item: (-item[1], item[0]))"},{"question":"def min_substrings(s: str, words: List[str]) -> int: Given a string s and an array of strings words, find the minimum number of substrings of s required such that each substring is one of the words in the array. If it is not possible to form the string s using the words in the array, return -1. >>> min_substrings(\\"leetcode\\", [\\"leet\\", \\"code\\"]) 2 >>> min_substrings(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) 3 >>> min_substrings(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) -1 import pytest def test_min_substrings(): assert min_substrings(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == 2 assert min_substrings(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) == 3 assert min_substrings(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == -1 assert min_substrings(\\"apple\\", [\\"apple\\", \\"pen\\"]) == 1 assert min_substrings(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) == 0 assert min_substrings(\\"abcd\\", [\\"a\\", \\"b\\", \\"c\\"]) == -1 assert min_substrings(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\"]) == 3 assert min_substrings(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) == 3 assert min_substrings(\\"aaaaaaa\\", [\\"aa\\", \\"aaa\\"]) == 3 assert min_substrings(\\"alarmdoorbell\\", [\\"alarm\\", \\"door\\", \\"bell\\"]) == 3 assert min_substrings(\\"anystring\\", []) == -1 pytest.main()","solution":"def min_substrings(s, words): Given a string s and an array of strings words, find the minimum number of substrings of s required such that each substring is one of the words in the array. If it is not possible to form the string s using the words in the array, return -1. words_set = set(words) n = len(s) dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): for word in words_set: if i >= len(word) and s[i - len(word):i] == word: dp[i] = min(dp[i], dp[i - len(word)] + 1) return dp[n] if dp[n] != float('inf') else -1"},{"question":"import re from collections import defaultdict def wordFrequencyCounter(text: str) -> dict: Returns the frequency count of each word in the given text. Words are counted case-insensitively and punctuation is disregarded. Args: text (str): The input text string. Returns: dict: A dictionary with words as keys and their frequency counts as values. >>> wordFrequencyCounter(\\"Hello, hello world! This is a test. This is only a test.\\") {'a': 2, 'hello': 2, 'is': 2, 'only': 1, 'test': 2, 'this': 2, 'world': 1} >>> wordFrequencyCounter(\\"\\") {} >>> wordFrequencyCounter(\\"Hello\\") {'hello': 1} >>> wordFrequencyCounter(\\"Hello, hello world! This is a test. This is only a test.\\") == {'a': 2, 'hello': 2, 'is': 2, 'only': 1, 'test': 2, 'this': 2, 'world': 1} True >>> wordFrequencyCounter(\\"Hello hello Hello HELLO\\") {'hello': 4} >>> wordFrequencyCounter(\\"Python. Python, PYTHON! python?\\") {'python': 4} >>> wordFrequencyCounter(\\"Testing. This is a Test, testing the TEST cases!\\") {'a': 1, 'cases': 1, 'is': 1, 'test': 2, 'testing': 2, 'the': 1, 'this': 1}","solution":"import re from collections import defaultdict def wordFrequencyCounter(text): Returns the frequency count of each word in the given text. Words are counted case-insensitively and punctuation is disregarded. Args: text (str): The input text string. Returns: dict: A dictionary with words as keys and their frequency counts as values. # Remove punctuation using regular expressions and split the text into words words = re.findall(r'bw+b', text.lower()) frequency = defaultdict(int) for word in words: frequency[word] += 1 # Convert the defaultdict to a regular dictionary and sort it alphabetically return dict(sorted(frequency.items()))"},{"question":"def reorder_list(lst): Reorders a given list of integers such that all even numbers appear in ascending order at the beginning, followed by odd numbers in descending order. Parameters: lst (list): A list of integers. Returns: list: A reordered list as per the specifications. >>> reorder_list([1, 3, 2, 4, 7, 8, 5]) [2, 4, 8, 7, 5, 3, 1] >>> reorder_list([10, 21, 14, 13, 17, 6]) [6, 10, 14, 21, 17, 13]","solution":"def reorder_list(lst): Reorders a given list of integers such that all even numbers appear in ascending order at the beginning, followed by odd numbers in descending order. Parameters: lst (list): A list of integers. Returns: list: A reordered list as per the specifications. evens = sorted([x for x in lst if x % 2 == 0]) odds = sorted([x for x in lst if x % 2 != 0], reverse=True) return evens + odds"},{"question":"import re def isValidEmail(email: str) -> bool: Determine if a given email address is valid or not. >>> isValidEmail(\\"user.name@example.com\\") True >>> isValidEmail(\\"user@com\\") False >>> isValidEmail(\\"user@.com\\") False >>> isValidEmail(\\".user@domain.com\\") False","solution":"import re def isValidEmail(email): Returns true if the given email address is valid based on the rules specified. # Define the regular expression for matching the email based on the rules email_regex = r\\"^[A-Za-z0-9]+([._][A-Za-z0-9]+)*@[A-Za-z0-9]+(.[A-Za-z0-9]+)+\\" pattern = re.compile(email_regex) return pattern.match(email) is not None"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. >>> fibonacci(0) == 0 >>> fibonacci(1) == 1 >>> fibonacci(5) == 5 >>> fibonacci(10) == 55 >>> fibonacci(15) == 610 >>> fibonacci(30) == 832040","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"class VendingMachine: def __init__(self, products): Initialize the Vending Machine with a set of products and their prices. Products should be a dictionary with product names as keys and prices in cents as values. self.products = products self.balance = 0 def insert_money(self, amount): Insert money into the vending machine. Acceptable denominations are integers representing cents (e.g., 1, 5, 10, 25, etc.). def select_product(self, product_name): Select a product from the vending machine. Dispense the product if enough money has been inserted. Return the product and any change due. def get_change(self): Return the remaining balance in coins. Ensure that the change is returned in the fewest number of coins possible. def display_products(self): Display the available products and their prices. # Example Usage products = {\\"Soda\\": 150, \\"Chips\\": 75, \\"Candy\\": 60} vending_machine = VendingMachine(products) vending_machine.display_products() vending_machine.insert_money(100) vending_machine.insert_money(50) vending_machine.select_product(\\"Soda\\") vending_machine.insert_money(70) vending_machine.select_product(\\"Candy\\") vending_machine.insert_money(20) vending_machine.select_product(\\"Candy\\") # Unit Tests def test_vending_machine_initialization(): products = {\\"Soda\\": 150, \\"Chips\\": 75, \\"Candy\\": 60} vm = VendingMachine(products) assert vm.products == products assert vm.balance == 0 def test_insert_money(): vm = VendingMachine({\\"Soda\\": 150, \\"Chips\\": 75, \\"Candy\\": 60}) vm.insert_money(100) assert vm.balance == 100 vm.insert_money(50) assert vm.balance == 150 def test_select_product(): vm = VendingMachine({\\"Soda\\": 150, \\"Chips\\": 75, \\"Candy\\": 60}) vm.insert_money(200) result = vm.select_product(\\"Soda\\") assert result == \\"Dispensing Soda. Change: 50 cents.\\" assert vm.balance == 0 def test_select_product_insufficient_money(): vm = VendingMachine({\\"Soda\\": 150, \\"Chips\\": 75, \\"Candy\\": 60}) vm.insert_money(100) result = vm.select_product(\\"Soda\\") assert result == \\"Not enough money inserted. Please insert 50 more cents.\\" def test_select_product_nonexistent(): vm = VendingMachine({\\"Soda\\": 150, \\"Chips\\": 75, \\"Candy\\": 60}) vm.insert_money(100) result = vm.select_product(\\"Juice\\") assert result == \\"Product not available.\\" def test_get_change(): vm = VendingMachine({\\"Soda\\": 150, \\"Chips\\": 75, \\"Candy\\": 60}) vm.insert_money(100) change = vm.get_change() assert change == 100 assert vm.balance == 0 def test_display_products(capsys): vm = VendingMachine({\\"Soda\\": 150, \\"Chips\\": 75, \\"Candy\\": 60}) vm.display_products() captured = capsys.readouterr() assert captured.out == \\"1: Soda - 150 centsn2: Chips - 75 centsn3: Candy - 60 centsn\\"","solution":"class VendingMachine: def __init__(self, products): Initialize the Vending Machine with a set of products and their prices. Products should be a dictionary with product names as keys and prices in cents as values. self.products = products self.balance = 0 def insert_money(self, amount): Insert money into the vending machine. Acceptable denominations are integers representing cents (e.g., 1, 5, 10, 25, etc.). self.balance += amount def select_product(self, product_name): Select a product from the vending machine. Dispense the product if enough money has been inserted. Return the product and any change due. if product_name not in self.products: return \\"Product not available.\\" product_price = self.products[product_name] if self.balance >= product_price: self.balance -= product_price change = self.balance self.balance = 0 return f\\"Dispensing {product_name}. Change: {change} cents.\\" else: shortfall = product_price - self.balance return f\\"Not enough money inserted. Please insert {shortfall} more cents.\\" def get_change(self): Return the remaining balance in coins. Ensure that the change is returned in the fewest number of coins possible. change = self.balance self.balance = 0 return change def display_products(self): Display the available products and their prices. for idx, (product, price) in enumerate(self.products.items(), start=1): print(f\\"{idx}: {product} - {price} cents\\")"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Given a list of n integers, find the maximum possible sum of a contiguous subarray. The list can contain both positive and negative integers. Example: >>> max_subarray_sum([1, -3, 2, 1, -1]) 3 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 >>> max_subarray_sum([-1, -2, -3, -4]) -1 from solution import max_subarray_sum def test_single_element(): assert max_subarray_sum([1]) == 1 assert max_subarray_sum([-1]) == -1 def test_all_positive(): assert max_subarray_sum([1, 2, 3, 4]) == 10 def test_all_negative(): assert max_subarray_sum([-1, -2, -3, -4]) == -1 def test_mixed_positive_and_negative(): assert max_subarray_sum([1, -3, 2, 1, -1]) == 3 assert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 assert max_subarray_sum([5, 4, -1, 7, 8]) == 23 def test_edge_cases(): assert max_subarray_sum([0]) == 0 assert max_subarray_sum([0, -1, 0]) == 0 assert max_subarray_sum([1, -1, 1, -1, 1]) == 1 assert max_subarray_sum([-3, -4, -1, -7]) == -1 def test_varied_lengths(): assert max_subarray_sum([1, 1, -2, 3, -1, 2]) == 4 assert max_subarray_sum([-1, 2, 3, -9, 4, 5, -2, 1]) == 9 assert max_subarray_sum([8, -19, 5, -4, 20]) == 21 def test_large_input(): assert max_subarray_sum([10000] * 100) == 1000000 assert max_subarray_sum([-10000] * 100) == -10000 assert max_subarray_sum([i for i in range(-50, 50)]) == sum(range(1, 50))","solution":"def max_subarray_sum(nums): Returns the maximum sum of a contiguous subarray using the Kadane's algorithm. max_so_far = nums[0] max_ending_here = nums[0] for num in nums[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"from typing import List def trap_rain_water(heights: List[int]) -> int: Calculate the amount of water that can be trapped after raining. >>> trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap_rain_water([4,2,0,3,2,5]) == 9","solution":"from typing import List def trap_rain_water(heights: List[int]) -> int: if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate total water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"from typing import List def shortest_path(desert_map: List[str]) -> int: Determine the shortest path from the top-left corner to the bottom-right corner of the desert map. If no such path exists, return -1. >>> shortest_path([\\"SWS\\", \\"SWS\\", \\"SSS\\"]) == 4 >>> shortest_path([\\"WWW\\", \\"WWW\\", \\"WWW\\"]) == -1 >>> shortest_path([\\"SSS\\", \\"SSS\\", \\"SSS\\"]) == 4 >>> shortest_path([\\"SWW\\", \\"WSW\\", \\"WSS\\"]) == -1 >>> shortest_path([\\"S\\"]) == 0 >>> shortest_path([\\"SSSS\\", \\"SCSC\\", \\"SSSS\\", \\"SSSS\\"]) == 6 def process_input(input_data: str) -> List[int]: Process the input data and return the results for each test case. >>> process_input('''2 3 3 SWS SWS SSS 3 3 WWW WWW WWW''') == [4, -1] >>> process_input('''1 3 3 SSS SSS SSS''') == [4] >>> process_input('''1 3 3 SWW WSW WSS''') == [-1] >>> process_input('''1 1 1 S''') == [0] >>> process_input('''1 4 4 SSSS SCSC SSSS SSSS''') == [6]","solution":"from collections import deque def shortest_path(desert_map): rows = len(desert_map) cols = len(desert_map[0]) if desert_map[0][0] != 'S' or desert_map[rows-1][cols-1] != 'S': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == rows - 1 and c == cols - 1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and desert_map[nr][nc] == 'S': queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1 def process_input(input_data): results = [] data = input_data.strip().split('n') T = int(data[0]) index = 1 for _ in range(T): n, m = map(int, data[index].split()) index += 1 grid = [] for _ in range(n): grid.append(data[index]) index += 1 results.append(shortest_path(grid)) return results"},{"question":"from typing import Union def rearrange_string(s: str) -> Union[str, int]: Rearranges the string such that no two adjacent characters are the same. Returns the rearranged string if possible, otherwise returns -1. >>> rearrange_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] True >>> rearrange_string(\\"aaa\\") -1 >>> rearrange_string(\\"abcdefg\\") \\"abcdefg\\"","solution":"from collections import Counter import heapq def rearrange_string(s): Rearranges the string such that no two adjacent characters are the same. Returns the rearranged string if possible, otherwise returns -1. counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, \\"\\" result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char rearranged_string = \\"\\".join(result) if len(rearranged_string) != len(s): return -1 return rearranged_string"},{"question":"from typing import List def findKthLargest(nums: List[int], k: int) -> int: Given an integer array \`nums\` and an integer \`k\`, return the \`k\`-th largest element in the array. >>> findKthLargest([3, 2, 1, 5, 6, 4], 2) 5 >>> findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4","solution":"from typing import List import heapq def findKthLargest(nums: List[int], k: int) -> int: Returns the k-th largest element in the array \`nums\`. if not nums or k < 1 or k > len(nums): raise ValueError(\\"Invalid input\\") return heapq.nlargest(k, nums)[-1]"},{"question":"def matrix_rotation(matrix): Rotates the given NxN matrix 90 degrees clockwise in place. Args: matrix (List[List[int]]): A square matrix to be rotated. Returns: None Examples: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> matrix_rotation(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> matrix_rotation(matrix) >>> matrix [ [3, 1], [4, 2] ]","solution":"def matrix_rotation(matrix): Rotates the given NxN matrix 90 degrees clockwise in place. :param matrix: List[List[int]] :return: None n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def merge_sorted_arrays(A: List[int], B: List[int], k: int) -> List[int]: Merge two integer arrays A and B of the same length into a single sorted array by selecting one element from either A or B at each step. You are allowed to switch between picking from A or B at most k times. Return the lexicographically smallest merged array possible. >>> merge_sorted_arrays([1, 7, 8], [2, 3, 5, 9], 2) [1, 2, 3, 5, 7, 8, 9] >>> merge_sorted_arrays([1, 2, 3], [4, 5, 6], 0) [1, 2, 3, 4, 5, 6]","solution":"def merge_sorted_arrays(A, B, k): Merges two sorted arrays A and B while switching at most k times to produce the lexicographically smallest merged array. len_a, len_b = len(A), len(B) merged = [] i, j, switches = 0, 0, 0 while i < len_a and j < len_b: if switches == k: if i < len_a: merged += A[i:] if j < len_b: merged += B[j:] return merged if A[i] < B[j]: merged.append(A[i]) i += 1 elif A[i] > B[j]: merged.append(B[j]) j += 1 else: # A[i] == B[j] if i + 1 < len_a and j + 1 < len_b and A[i + 1] < B[j + 1]: merged.append(A[i]) i += 1 else: merged.append(B[j]) j += 1 # Once one of the arrays is exhausted, we add the remaining elements of the other array if i < len_a: merged += A[i:] if j < len_b: merged += B[j:] return merged"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, return a new list where each element is the product of all the numbers in the original list except the one at the same index. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([2, 3]) == [3, 2] >>> product_except_self([1, 1, 1, 1]) == [1, 1, 1, 1] >>> product_except_self([0, 1, 2, 3]) == [6, 0, 0, 0] >>> product_except_self([1000, 100, 10, 1]) == [1000, 10000, 100000, 1000000] >>> product_except_self([-1, 2, -3, 4]) == [-24, 12, -8, 6] >>> product_except_self([1, 2, 3, -4]) == [-24, -12, -8, 6] pass","solution":"def product_except_self(nums): Given a list of integers, return a new list where each element is the product of all the numbers in the original list except the one at the same index. length = len(nums) # Initialize prefix and suffix product lists prefix_products = [1] * length suffix_products = [1] * length result = [1] * length # Compute prefix products for i in range(1, length): prefix_products[i] = prefix_products[i-1] * nums[i-1] # Compute suffix products for i in range(length-2, -1, -1): suffix_products[i] = suffix_products[i+1] * nums[i+1] # Compute result by multiplying prefix and suffix products for i in range(length): result[i] = prefix_products[i] * suffix_products[i] return result"},{"question":"def find_pairs(nums: List[int], k: int) -> int: Finds the number of unique pairs (i, j) in an array such that nums[i] + nums[j] == k. >>> find_pairs([1, 2, 3, 4, 3], 6) 2 >>> find_pairs([1, 5, 1, 5], 6) 4","solution":"def find_pairs(nums, k): Finds the number of unique pairs (i, j) in an array such that nums[i] + nums[j] == k. count = 0 seen_pairs = set() for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == k and (i, j) not in seen_pairs: count += 1 seen_pairs.add((i, j)) return count"},{"question":"def find_missing_number(nums: List[int]) -> int: Given a list of unique integers ranging from 1 to n (inclusive) with one missing, returns the missing number. Args: nums: List[int] - the list of numbers with one number missing Returns: int - the missing number >>> find_missing_number([2, 3, 4, 5]) == 1 >>> find_missing_number([1, 2, 3, 4, 6]) == 5 >>> find_missing_number([1, 2, 3, 4, 5]) == 6 >>> find_missing_number([1, 2, 4, 5]) == 3 >>> find_missing_number([2]) == 1 >>> find_missing_number(list(range(1, 10001)) + [10002]) == 10001","solution":"def find_missing_number(nums): Given a list of unique integers ranging from 1 to n (inclusive) with one missing number, returns the missing number. Args: nums: List[int] - the list of numbers with one number missing Returns: int - the missing number n = len(nums) + 1 # since one number is missing, n should be len(nums) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"def max_area_of_island(grid: List[List[int]]) -> int: Find the maximum area of an island in the given 2D grid. >>> max_area_of_island([[0,0,1,0,0,0],[0,1,1,0,0,0],[0,0,0,0,0,0],[1,1,0,1,1,1],[0,0,1,0,1,0]]) == 4 >>> max_area_of_island([[1]]) == 1 >>> max_area_of_island([[0]]) == 0 >>> max_area_of_island([[0,0,0,0],[0,0,0,0]]) == 0 >>> max_area_of_island([[1, 1, 1, 1],[1, 1, 1, 1]]) == 8 >>> max_area_of_island([[1, 0],[0, 1]]) == 1","solution":"def max_area_of_island(grid): def dfs(i, j): if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1: grid[i][j] = 0 # Mark the cell as visited return 1 + dfs(i+1, j) + dfs(i-1, j) + dfs(i, j+1) + dfs(i, j-1) return 0 max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"def is_palindrome_permutation(s: str) -> bool: Checks if a given string is a permutation of a palindrome. >>> is_palindrome_permutation(\\"Tact Coa\\") True >>> is_palindrome_permutation(\\"Hello\\") False >>> is_palindrome_permutation(\\"A man a plan a canal Panama\\") True","solution":"def is_palindrome_permutation(s): Checks if a given string is a permutation of a palindrome. from collections import Counter # Normalize the string: lowercase and remove spaces s = s.replace(\\" \\", \\"\\").lower() # Count the frequency of each character char_count = Counter(s) # Check how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be a permutation of a palindrome if it has at most one character with an odd count return odd_count <= 1"},{"question":"def most_frequent_letter(s: str) -> str: Given a string of letters, returns the letter that appears the most frequently. If there are multiple letters with the same highest frequency, returns the one that comes first in the alphabet. >>> most_frequent_letter(\\"aabbbcc\\") 'b' >>> most_frequent_letter(\\"abacad\\") 'a' >>> most_frequent_letter(\\"xxyz\\") 'x' from collections import Counter counter = Counter(s) most_frequent = max(counter.items(), key=lambda item: (item[1], -ord(item[0]))) return most_frequent","solution":"def most_frequent_letter(s): Returns the letter that appears the most frequently in the string \`s\`. If there are multiple letters with the same highest frequency, the one that comes first in the alphabet is returned. from collections import Counter if not s: return \\"\\" counter = Counter(s) most_frequent = max(counter.items(), key=lambda item: (item[1], -ord(item[0]))) return most_frequent[0]"},{"question":"def optimal_meeting_point(houses: List[int]) -> int: Returns the meeting point position such that the sum of distances all friends have to travel is minimized. The optimal meeting point is the median of the house positions. >>> optimal_meeting_point([2, 4, 2]) 2 >>> optimal_meeting_point([1, 6, 2, 9, 3]) 3 >>> optimal_meeting_point([1, 1, 1, 1]) 1","solution":"from typing import List def optimal_meeting_point(houses: List[int]) -> int: Returns the meeting point position such that the sum of distances all friends have to travel is minimized. The optimal meeting point is the median of the house positions. houses.sort() n = len(houses) median = houses[n // 2] if n % 2 != 0 else houses[(n // 2) - 1] return median"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates the mathematical expression contained in the given string and returns the result as an integer. >>> evaluate_expression(\\"1 + 1\\") 2 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23 >>> evaluate_expression(\\" 2-1 + 2 \\") 3 >>> evaluate_expression(\\"42\\") 42 >>> evaluate_expression(\\"((1+(4+5+2)-3)+(6+8)+7)-(5+1)\\") 24 >>> evaluate_expression(\\"((2+2)-1)+(2-(1+(3-4)))\\") 5","solution":"def evaluate_expression(expression: str) -> int: Evaluates the mathematical expression contained in the given string and returns the result as an integer. :param expression: str - The mathematical expression to evaluate. :return: int - The result of the expression. def helper(s, idx): stack = [] num = 0 sign = 1 while idx < len(s): char = s[idx] if char.isdigit(): num = num * 10 + int(char) elif char == '+': stack.append(sign * num) num = 0 sign = 1 elif char == '-': stack.append(sign * num) num = 0 sign = -1 elif char == '(': num, idx = helper(s, idx + 1) stack.append(sign * num) num = 0 elif char == ')': stack.append(sign * num) return sum(stack), idx idx += 1 stack.append(sign * num) return sum(stack) return helper(expression, 0)"},{"question":"import heapq from collections import Counter from typing import List def reorganize_string(s: str) -> str: Rearranges the input string such that any two adjacent characters are not the same. Returns the rearranged string or an empty string if such an arrangement is not possible. >>> reorganize_string(\\"aab\\") in [\\"aba\\"] True >>> reorganize_string(\\"aaab\\") '' >>> reorganize_string(\\"aabbcc\\") in [\\"abcabc\\", \\"acbacb\\", \\"bacbac\\", \\"babcac\\"] True >>> reorganize_string(\\"a\\") 'a' >>> reorganize_string(\\"aa\\") '' >>> reorganize_string(\\"ab\\") in [\\"ab\\", \\"ba\\"] True >>> reorganize_string(\\"aaa\\") '' >>> reorganize_string(\\"aaabbc\\") in [\\"ababac\\", \\"abcaba\\", \\"abacab\\", \\"acabab\\", \\"abcaab\\", \\"acbaab\\"] True","solution":"import heapq from collections import Counter def reorganize_string(s): Rearranges the input string such that any two adjacent characters are not the same. Returns the rearranged string or an empty string if such an arrangement is not possible. # Count the frequency of each character frequency = Counter(s) max_heap = [(-count, char) for char, count in frequency.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) # Add the previous character back if it's still needed if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) result.append(char) prev_count, prev_char = count + 1, char result_str = ''.join(result) if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"def task_manager(n: int, existing_tasks: List[Tuple[int, int]], new_task: Tuple[int, int]) -> str: Check if a new task can be scheduled without conflicting with the existing tasks. Args: n (int): Number of existing tasks. existing_tasks (List[Tuple[int, int]]): List of tuples representing start and end times of existing tasks. new_task (Tuple[int, int]): A tuple representing start and end time of the new task. Returns: str: \\"Conflict\\" if the new task overlaps with any existing task, otherwise \\"No Conflict\\". Examples: >>> task_manager(3, [(1, 3), (4, 6), (7, 9)], (10, 12)) \\"No Conflict\\" >>> task_manager(3, [(1, 3), (4, 6), (7, 9)], (5, 8)) \\"Conflict\\"","solution":"def task_manager(n, existing_tasks, new_task): new_start, new_end = new_task for start, end in existing_tasks: if not (new_end <= start or new_start >= end): return \\"Conflict\\" return \\"No Conflict\\" # Example usage: # n = 3 # existing_tasks = [(1, 3), (4, 6), (7, 9)] # new_task = (5, 8) # print(task_manager(n, existing_tasks, new_task)) # Output: \\"Conflict\\""},{"question":"def max_sum_submatrix(matrix: List[List[int]], k: int) -> int: Find the maximum sum of a non-empty submatrix such that it does not exceed k. >>> max_sum_submatrix([[1, 0, 1], [0, -2, 3]], 2) 2 >>> max_sum_submatrix([[2, 2, -1]], 3) 3 >>> max_sum_submatrix([[5, 5, 5], [5, 5, 5]], 100) 30 >>> max_sum_submatrix([[-1, -2, -3], [-4, -5, -6]], -3) -3 >>> max_sum_submatrix([[5]], 5) 5 >>> max_sum_submatrix([[5]], 3) float('-inf') >>> max_sum_submatrix([[2, 2, 1], [3, 1, 0], [4, -1, 2]], 7) 7 >>> max_sum_submatrix([[-5, -3, -1], [-7, -4, -2], [-6, -8, -9]], -2) -2 >>> max_sum_submatrix([[-2, -1], [-3, -4]], -1) -1","solution":"def max_sum_submatrix(matrix, k): import bisect from itertools import accumulate def max_sum_no_larger_than_k(nums, k): max_sum = float('-inf') curr_sum = 0 prefix_sums = [0] for num in nums: curr_sum += num idx = bisect.bisect_left(prefix_sums, curr_sum - k) if idx < len(prefix_sums): max_sum = max(max_sum, curr_sum - prefix_sums[idx]) bisect.insort(prefix_sums, curr_sum) return max_sum max_sum = float('-inf') rows, cols = len(matrix), len(matrix[0]) for left in range(cols): row_sums = [0] * rows for right in range(left, cols): for r in range(rows): row_sums[r] += matrix[r][right] max_sum = max(max_sum, max_sum_no_larger_than_k(row_sums, k)) if max_sum == k: return max_sum return max_sum"},{"question":"def is_palindrome(s: str) -> bool: Determines if the given string is a palindrome, ignoring case and non-alphanumeric characters. Parameters: s (str): The input string containing only alphabets. Returns: bool: True if the input string is a palindrome, False otherwise. Examples: >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"No lemon, no melon\\") True","solution":"import re def is_palindrome(s: str) -> bool: Determines if the given string is a palindrome, ignoring case and non-alphanumeric characters. Parameters: s (str): The input string containing only alphabets. Returns: bool: True if the input string is a palindrome, False otherwise. # Remove non-alphanumeric characters and convert to lower case cleaned_str = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the cleaned string reads the same backward and forward return cleaned_str == cleaned_str[::-1]"},{"question":"def max_subarray_k_length(arr, k): Returns the largest sum of a contiguous subarray of length at most k and the smallest length of such subarray. >>> max_subarray_k_length([-1, -2, 3, 4, -1, 2, 1, -5], 4) (8, 4) >>> max_subarray_k_length([5], 1) (5, 1) >>> max_subarray_k_length([-1, -2, -3, -4], 2) (-1, 1) >>> max_subarray_k_length([2, 1, -3, 4, -1, 2, 1, -5, 4], 3) (5, 3) >>> max_subarray_k_length([1, 2, 3, 4], 4) (10, 4) pass","solution":"def max_subarray_k_length(arr, k): Returns the largest sum of a contiguous subarray of length at most k and the smallest length of such subarray. n = len(arr) max_sum = float('-inf') min_length = k for length in range(1, k + 1): # lengths from 1 to k current_sum = sum(arr[:length]) if current_sum > max_sum: max_sum = current_sum min_length = length for i in range(length, n): current_sum += arr[i] - arr[i - length] if current_sum > max_sum: max_sum = current_sum min_length = length return max_sum, min_length"},{"question":"def isValidTriangle(a: int, b: int, c: int) -> bool: Returns True if a, b, and c can form a valid triangle, otherwise False. A triangle is valid if the sum of the lengths of any two sides is greater than the length of the remaining side. >>> isValidTriangle(3, 4, 5) True >>> isValidTriangle(1, 1, 2) False >>> isValidTriangle(7, 10, 5) True >>> isValidTriangle(1, 2, 3) False >>> isValidTriangle(3, 3, 3) True >>> isValidTriangle(0, 1, 1) False >>> isValidTriangle(-1, 1, 1) False pass","solution":"def isValidTriangle(a, b, c): Returns True if a, b, and c can form a valid triangle, otherwise False. A triangle is valid if the sum of the lengths of any two sides is greater than the length of the remaining side. return a + b > c and a + c > b and b + c > a"},{"question":"def shortest_word_length(words: List[str]) -> int: Returns the length of the shortest word in the list. If the list is empty or contains non-string elements, returns 0. >>> shortest_word_length([\\"Hello\\", \\"world\\", \\"Python\\", \\"is\\", \\"awesome\\"]) # Returns: 2 >>> shortest_word_length([\\"coding\\", \\"assessment\\", \\"question\\"]) # Returns: 7 >>> shortest_word_length([]) # Returns: 0 >>> shortest_word_length([12345, \\"Pythagoras\\", \\"\\", \\"pi\\", \\"e\\"]) # Returns: 0","solution":"def shortest_word_length(words): Returns the length of the shortest word in the list. If the list is empty or contains non-string elements, returns 0. if not words or any(not isinstance(word, str) for word in words): return 0 shortest_length = min(len(word) for word in words if isinstance(word, str)) return shortest_length"},{"question":"def to_jaden_case(string: str) -> str: Capitalizes the first letter of each word in the input string. Parameters: string (str): The input string containing words separated by whitespace. Returns: str: A new string with the first letter of each word capitalized. >>> to_jaden_case('how can mirrors be real if our eyes aren't real') 'How Can Mirrors Be Real If Our Eyes Aren't Real' >>> to_jaden_case('') '' pass","solution":"def to_jaden_case(string): Capitalizes the first letter of each word in the input string. Parameters: string (str): The input string containing words separated by whitespace. Returns: str: A new string with the first letter of each word capitalized. return ' '.join(word.capitalize() for word in string.split())"},{"question":"def sieve_of_eratosthenes(max_n): Generate a list of prime numbers up to max_n using the Sieve of Eratosthenes. >>> primes, is_prime = sieve_of_eratosthenes(10) >>> primes [2, 3, 5, 7] >>> is_prime[4] False >>> is_prime[5] True def goldbach_conjecture(N): Find two prime numbers such that their sum equals to N. >>> goldbach_conjecture(4) (2, 2) >>> goldbach_conjecture(10) (3, 7) >>> goldbach_conjecture(26) (3, 23) >>> goldbach_conjecture(100) (3, 97) def solve_goldbach(T, test_cases): Process multiple test cases to solve the Goldbach Conjecture problem. >>> solve_goldbach(3, [4, 10, 26]) [\\"2 2\\", \\"3 7\\", \\"3 23\\"] >>> solve_goldbach(2, [100, 50]) [\\"3 97\\", \\"3 47\\"]","solution":"def sieve_of_eratosthenes(max_n): Generate a list of prime numbers up to max_n using the Sieve of Eratosthenes. is_prime = [True] * (max_n + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not prime numbers for start in range(2, int(max_n**0.5) + 1): if is_prime[start]: for i in range(start*start, max_n + 1, start): is_prime[i] = False primes = [num for num, prime in enumerate(is_prime) if prime] return primes, is_prime def goldbach_conjecture(N): Find two prime numbers such that their sum equals to N. primes, is_prime = sieve_of_eratosthenes(N) for p1 in primes: p2 = N - p1 if p2 >= p1 and is_prime[p2]: return p1, p2 return -1 def solve_goldbach(T, test_cases): Process multiple test cases to solve the Goldbach Conjecture problem. results = [] for N in test_cases: result = goldbach_conjecture(N) if isinstance(result, tuple): results.append(f\\"{result[0]} {result[1]}\\") else: results.append(f\\"{result}\\") return results"},{"question":"def is_valid_isbn(s: str) -> bool: Return True if the given string is a valid ISBN-10 number, False otherwise. >>> is_valid_isbn(\\"0306406152\\") True >>> is_valid_isbn(\\"0471958697\\") True >>> is_valid_isbn(\\"877195869X\\") True >>> is_valid_isbn(\\"0306406153\\") False >>> is_valid_isbn(\\"0471958696\\") False >>> is_valid_isbn(\\"8771958699\\") False >>> is_valid_isbn(\\"030640615\\") False >>> is_valid_isbn(\\"03064061521\\") False >>> is_valid_isbn(\\"03064061A2\\") False >>> is_valid_isbn(\\"04719#8697\\") False >>> is_valid_isbn(\\"87719586@X\\") False >>> is_valid_isbn(\\"8771958X69\\") False >>> is_valid_isbn(\\"X7719586X9\\") False >>> is_valid_isbn(\\"X771958690\\") False pass","solution":"def is_valid_isbn(s): Returns True if the given string is a valid ISBN-10 number, False otherwise. if len(s) != 10: return False total = 0 for i, char in enumerate(s): if i == 9 and char == 'X': value = 10 elif char.isdigit(): value = int(char) else: return False total += (i + 1) * value return total % 11 == 0"},{"question":"def check_permutation(s: str) -> int: Determine whether a string of numbers separated by commas forms a permutation of all integers in the range from the smallest integer to the largest integer (inclusive). Return: - 0 if the numbers form a valid permutation. - 1 if there are any non-numeric elements or if the list contains any duplicates. Examples: >>> check_permutation(\\"1,2,3,4,5\\") 0 >>> check_permutation(\\"3,5,4,1,2\\") 0 >>> check_permutation(\\"1,2,3,5,6\\") 1 >>> check_permutation(\\"1,2,a,4,5\\") 1 >>> check_permutation(\\"1,2,2,3,4\\") 1","solution":"def check_permutation(s): Returns 0 if the given string of numbers forms a valid permutation, and 1 if it contains any invalid input or duplicates. # Split the string by commas number_list = s.split(',') # Check for non-numeric elements try: number_list = [int(num) for num in number_list] except ValueError: return 1 # Check for duplicates if len(number_list) != len(set(number_list)): return 1 # Determine the range of numbers min_num = min(number_list) max_num = max(number_list) # Check if it forms a valid permutation if set(number_list) == set(range(min_num, max_num + 1)): return 0 else: return 1"},{"question":"def reverse_string(s: str) -> str: Returns the reversed string of the given input string s. >>> reverse_string(\\"hello\\") 'olleh' >>> reverse_string(\\"Python\\") 'nohtyP'","solution":"def reverse_string(s): Returns the reversed string of the given input string s. return s[::-1]"},{"question":"def sumOfOdds(nums: List[int]) -> int: Returns the sum of all odd numbers in the given list of integers. Parameters: nums (list): A list of integers Returns: int: Sum of odd numbers, or 0 if there are no odd numbers >>> sumOfOdds([1, 2, 3, 4, 5]) 9 >>> sumOfOdds([2, 4, 6, 8]) 0 >>> sumOfOdds([]) 0","solution":"def sumOfOdds(nums): Returns the sum of all odd numbers in the given list of integers. Parameters: nums (list): A list of integers Returns: int: Sum of odd numbers, or 0 if there are no odd numbers return sum(num for num in nums if num % 2 != 0)"},{"question":"from typing import List, Tuple def longest_increasing_subsequence(arr: List[int]) -> Tuple[int, List[int]]: Determine the length of the longest strictly increasing subsequence of gemstone values and return one example of such a subsequence. >>> longest_increasing_subsequence([5, 2, 8, 6, 3, 6]) (3, [2, 6, 8]) >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) (4, [2, 3, 7, 101]) # your code here def test_case_1(): arr = [5, 2, 8, 6, 3, 6] length, sequence = longest_increasing_subsequence(arr) assert length == 3 assert sequence in [[2, 6, 8], [2, 3, 6]] def test_case_2(): arr = [10, 9, 2, 5, 3, 7, 101, 18] length, sequence = longest_increasing_subsequence(arr) assert length == 4 assert sequence in [[2, 5, 7, 101], [2, 3, 7, 101]] def test_empty(): arr = [] length, sequence = longest_increasing_subsequence(arr) assert length == 0 assert sequence == [] def test_single_element(): arr = [1] length, sequence = longest_increasing_subsequence(arr) assert length == 1 assert sequence == [1] def test_all_decreasing(): arr = [4, 3, 2, 1] length, sequence = longest_increasing_subsequence(arr) assert length == 1 assert sequence in [[4], [3], [2], [1]] def test_all_increasing(): arr = [1, 2, 3, 4] length, sequence = longest_increasing_subsequence(arr) assert length == 4 assert sequence == [1, 2, 3, 4]","solution":"def longest_increasing_subsequence(arr): if not arr: return 0, [] n = len(arr) dp = [1] * n prev = [-1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 prev[i] = j max_len = max(dp) index = dp.index(max_len) lis = [] while index != -1: lis.append(arr[index]) index = prev[index] lis.reverse() return max_len, lis"},{"question":"def can_alice_win(piles: List[int]) -> bool: Determines if Alice will win the game assuming both play optimally. Alice starts first and in each turn, a player can pick any positive amount of gold from a single pile. However, the amount picked must be greater than half of the current total amount in that pile. :param piles: List[int] - List of non-negative integers representing gold piles. :return: bool - True if Alice wins, False otherwise. >>> can_alice_win([5, 7, 9]) True >>> can_alice_win([5, 7, 9, 3]) False >>> can_alice_win([]) False >>> can_alice_win([5]) True >>> can_alice_win([3, 4]) False >>> can_alice_win([1000] * 1001) True >>> can_alice_win([1000] * 1000) False","solution":"def can_alice_win(piles): Determines if Alice will win the game assuming both play optimally. Alice starts first and in each turn, a player can pick any positive amount of gold from a single pile. However, the amount picked must be greater than half of the current total amount in that pile. :param piles: List[int] - List of non-negative integers representing gold piles. # Alice wins if the total number of piles is odd return len(piles) % 2 == 1"},{"question":"def make_palindrome(s: str) -> str: Given a string of alphanumeric characters and spaces, converts each word into a palindrome. A word is a palindrome if it reads the same backward as forward. Words will be separated by single spaces and the string will not contain any punctuation other than spaces. >>> make_palindrome(\\"madam racecar hello world\\") \\"madam racecar helloolleh worlddlrow\\" >>> make_palindrome(\\"refer radar level noon\\") \\"refer radar level noon\\" from solution import make_palindrome def test_single_palindrome_word(): assert make_palindrome(\\"madam\\") == \\"madam\\" assert make_palindrome(\\"level\\") == \\"level\\" def test_single_non_palindrome_word(): assert make_palindrome(\\"hello\\") == \\"helloolleh\\" assert make_palindrome(\\"world\\") == \\"worlddlrow\\" def test_multiple_words(): assert make_palindrome(\\"madam racecar hello world\\") == \\"madam racecar helloolleh worlddlrow\\" assert make_palindrome(\\"refer radar level noon\\") == \\"refer radar level noon\\" assert make_palindrome(\\"test this function\\") == \\"testtset thissiht functionnoitcnuf\\" def test_empty_string(): assert make_palindrome(\\"\\") == \\"\\"","solution":"def make_palindrome(s): Given a string of alphanumeric characters and spaces, converts each word into a palindrome. A word is a palindrome if it reads the same backward as forward. Words will be separated by single spaces and the string will not contain any punctuation other than spaces. def make_word_palindrome(word): return word if word == word[::-1] else word + word[::-1] words = s.split() palindrome_words = [make_word_palindrome(word) for word in words] return ' '.join(palindrome_words)"},{"question":"def find_subsets(nums: List[int], target: int) -> int: Determine the number of subsets with a sum equal to a target value. >>> find_subsets([1, 2, 3, 4, 5], 5) 3 >>> find_subsets([1, 2, 3], 0) 1 >>> find_subsets([1, 2, 3], 10) 0 >>> find_subsets([1], 1) 1 >>> find_subsets([1], 2) 0 >>> find_subsets([1, 1, 1, 1], 2) 6 >>> find_subsets([1, 2, 3, 4, 5], 15) 1 >>> find_subsets([1, 2, 3, 4, 5], 0) 1","solution":"def find_subsets(nums, target): Return the number of subsets the sum of which is equal to the target. def count_subsets(nums, n, target): if target == 0: return 1 if n == 0: return 0 if nums[n-1] > target: return count_subsets(nums, n-1, target) return count_subsets(nums, n-1, target) + count_subsets(nums, n-1, target-nums[n-1]) return count_subsets(nums, len(nums), target)"},{"question":"class Node: def __init__(self, value, next_node=None): self.value = value self.next = next_node class LinkedList: A class that represents a singly linked list. >>> ll = LinkedList() >>> ll.head is None True >>> ll.append(1) >>> ll.append(2) >>> ll.head.value == 1 True >>> ll.head.next.value == 2 True >>> ll.prepend(0) >>> ll.head.value == 0 True >>> ll.delete(2) >>> ll.head.next is None True >>> ll.exists(1) True >>> ll.exists(3) False def __init__(self): self.head = None def append(self, value): pass def prepend(self, value): pass def delete(self, value): pass def exists(self, value): pass","solution":"class Node: def __init__(self, value, next_node=None): self.value = value self.next = next_node class LinkedList: def __init__(self): self.head = None def append(self, value): new_node = Node(value) if not self.head: self.head = new_node return current = self.head while current.next: current = current.next current.next = new_node def prepend(self, value): new_node = Node(value, self.head) self.head = new_node def delete(self, value): if not self.head: return if self.head.value == value: self.head = self.head.next return current = self.head while current.next and current.next.value != value: current = current.next if current.next: current.next = current.next.next def exists(self, value): current = self.head while current: if current.value == value: return True current = current.next return False"},{"question":"def solveShortPathAllCases(test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: For each test case, finds the shortest path from the top-left corner to the bottom-right corner of the grid, allowing at most one wall to be broken. >>> solveShortPathAllCases([(3, 3, [\\"..#\\", \\".#.\\", \\"...\\"])]) [5] >>> solveShortPathAllCases([(4, 4, [\\".#\\", \\"..#.\\", \\"#.\\", \\"....\\"])]) [7] >>> solveShortPathAllCases([(3, 3, [\\".\\", \\"#\\", \\".\\"])]) [-1] >>> solveShortPathAllCases([(1, 5, [\\".....\\"])]) [5] >>> solveShortPathAllCases([(5, 1, [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"])]) [5] >>> solveShortPathAllCases([(3, 3, [\\"...\\", \\"...\\", \\"...\\"])]) [5] >>> solveShortPathAllCases([(100, 100, [\\".\\"*100 for _ in range(100)])]) [199]","solution":"from collections import deque def shortestPathWithWallBreak(grid, N, M): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[[False, False] for _ in range(M)] for _ in range(N)] queue = deque([(0, 0, 0, 1)]) # (x, y, wall_broken, distance) visited[0][0][0] = True while queue: x, y, wall_broken, dist = queue.popleft() if x == N - 1 and y == M - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M: if grid[nx][ny] == '.' and not visited[nx][ny][wall_broken]: visited[nx][ny][wall_broken] = True queue.append((nx, ny, wall_broken, dist + 1)) if grid[nx][ny] == '#' and wall_broken == 0 and not visited[nx][ny][1]: visited[nx][ny][1] = True queue.append((nx, ny, 1, dist + 1)) return -1 def solveShortPathAllCases(test_cases): results = [] for case in test_cases: N, M, grid = case result = shortestPathWithWallBreak(grid, N, M) results.append(result) return results"},{"question":"def translate_messages(d, dictionary_entries, n, sequences): Translates sequences of alien symbols into Earth sentences. Args: d: Number of dictionary entries dictionary_entries: List of tuples with alien symbol and its corresponding Earth word n: Number of sequences sequences: List of lists with alien symbols sequences Returns: List of translated Earth sentences >>> translate_messages(3, [(1, 'hello'), (2, 'world'), (3, 'earth')], 2, [[1, 2, 3], [3, 1]]) ['hello world earth', 'earth hello'] >>> translate_messages(1, [(1, 'greetings')], 1, [[1]]) ['greetings'] >>> translate_messages(2, [(1, 'yes'), (2, 'no')], 2, [[1, 2, 1], [2, 2, 1]]) ['yes no yes', 'no no yes'] >>> translate_messages(1000, [(i, f'word{i}') for i in range(1, 1001)], 2, [list(range(1, 1001)), list(range(1000, 0, -1))]) [' '.join(f'word{i}' for i in range(1, 1001)), ' '.join(f'word{i}' for i in range(1000, 0, -1))]","solution":"def translate_messages(d, dictionary_entries, n, sequences): Translates sequences of alien symbols into Earth sentences. Args: d: Number of dictionary entries dictionary_entries: List of tuples with alien symbol and its corresponding Earth word n: Number of sequences sequences: List of lists with alien symbols sequences Returns: List of translated Earth sentences symbol_to_word = {entry[0]: entry[1] for entry in dictionary_entries} translated_sentences = [] for seq in sequences: translated_sentence = ' '.join(symbol_to_word[symbol] for symbol in seq) translated_sentences.append(translated_sentence) return translated_sentences"},{"question":"from typing import List def maxPossibleTreeHeight(array: List[int]) -> int: Returns the maximum possible height of a new tree that can be planted. The new tree's height must be less than or equal to the maximum height among the two neighboring trees. pass def test_max_possible_tree_height(): assert maxPossibleTreeHeight([3, 4, 5, 3, 7]) == 7 assert maxPossibleTreeHeight([1, 2, 6, 5, 4]) == 6 assert maxPossibleTreeHeight([2, 2, 2]) == 2 assert maxPossibleTreeHeight([10]) == 10 assert maxPossibleTreeHeight([1, 1, 1, 1, 1]) == 1 assert maxPossibleTreeHeight([10, 20, 30, 40, 50]) == 50 assert maxPossibleTreeHeight([5, 5, 5, 10]) == 10 assert maxPossibleTreeHeight([9, 7, 5, 3, 1]) == 9","solution":"from typing import List def maxPossibleTreeHeight(array: List[int]) -> int: Returns the maximum possible height of a new tree that can be planted. The new tree's height must be less than or equal to the maximum height among the two neighboring trees. # Edge case: if there's only one tree, return its height if len(array) == 1: return array[0] # Find the max height in the list max_height = max(array) # The height of the new tree must be less than or equal to the max height. return max_height"},{"question":"def is_palindrome(n: int) -> str: Returns 'YES' if the number n is a palindrome, 'NO' otherwise. >>> is_palindrome(121) 'YES' >>> is_palindrome(123) 'NO' >>> is_palindrome(55555) 'YES' >>> is_palindrome(1001) 'YES' >>> is_palindrome(10) 'NO' ... def solve_palindromes(T: int, numbers: List[int]) -> List[str]: Returns a list of 'YES' or 'NO' for each number in numbers based on whether it is a palindrome. >>> solve_palindromes(4, [121, 123, 55555, 1001]) ['YES', 'NO', 'YES', 'YES'] >>> solve_palindromes(3, [1, 22, 333]) ['YES', 'YES', 'YES'] >>> solve_palindromes(2, [10, 100]) ['NO', 'NO'] >>> solve_palindromes(5, [111, 12121, 1234554321, 12321, 1234321]) ['YES', 'YES', 'YES', 'YES', 'YES'] >>> solve_palindromes(1, [0]) ['YES'] ...","solution":"def is_palindrome(n): Returns 'YES' if the number n is a palindrome, 'NO' otherwise. str_n = str(n) if str_n == str_n[::-1]: return \\"YES\\" else: return \\"NO\\" def solve_palindromes(T, numbers): Returns a list of 'YES' or 'NO' for each number in numbers based on whether it is a palindrome. return [is_palindrome(num) for num in numbers]"},{"question":"def min_removals_to_make_palindrome(s: str) -> int: Determine the smallest number of characters to remove from the string to make it a palindrome. >>> min_removals_to_make_palindrome(\\"abca\\") 1 >>> min_removals_to_make_palindrome(\\"racecar\\") 0 >>> min_removals_to_make_palindrome(\\"google\\") 2","solution":"def min_removals_to_make_palindrome(s): Returns the minimum number of characters to remove from string s to make it a palindrome. def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] lps = longest_palindromic_subsequence(s) return len(s) - lps"},{"question":"from typing import List def subarray_sum_exists(array: List[int], target: int) -> str: Determines if a contiguous subarray whose sum equals the target exists. >>> subarray_sum_exists([1, 2, 3, 7, 5], 12) == 'Yes, the subarray exists.' >>> subarray_sum_exists([1, 2, 3, 4, 5], 9) == 'Yes, the subarray exists.' >>> subarray_sum_exists([10, 2, -2, -20, 10], 20) == 'No, such subarray does not exist.' >>> subarray_sum_exists([5], 5) == 'Yes, the subarray exists.' >>> subarray_sum_exists([5], 10) == 'No, such subarray does not exist.' >>> subarray_sum_exists([1, 2, 3, 4, 5], 20) == 'No, such subarray does not exist.' >>> subarray_sum_exists([1, -1, 2, 3, 4, -1], 8) == 'Yes, the subarray exists.' >>> subarray_sum_exists([1, -2, 3, 4, -5, 6], 10) == 'No, such subarray does not exist.'","solution":"def subarray_sum_exists(array, target): Determines if there's a contiguous subarray whose sum equals the target. Parameters: array (List[int]): List of integers. target (int): The target sum. Returns: str: 'Yes, the subarray exists.' if such subarray exists, otherwise 'No, such subarray does not exist.' current_sum = 0 start_index = 0 for end_index in range(len(array)): current_sum += array[end_index] while current_sum > target and start_index <= end_index: current_sum -= array[start_index] start_index += 1 if current_sum == target: return 'Yes, the subarray exists.' return 'No, such subarray does not exist.'"},{"question":"from typing import List def sort_strings_by_ascii_sum(strings: List[str]) -> List[str]: Sort a list of strings primarily by the sum of the ASCII values of the characters in each string in ascending order. If two strings have the same sum of ASCII values, they should be sorted by their natural lexicographical order. Args: strings (List[str]): List of strings with alphanumeric characters and spaces. Returns: List[str]: Sorted list of strings based on the criteria mentioned. Examples: >>> sort_strings_by_ascii_sum([\\"apple\\", \\"banana\\", \\"cherry\\"]) ['apple', 'banana', 'cherry'] >>> sort_strings_by_ascii_sum([\\"abc\\", \\"acd\\", \\"cab\\"]) ['abc', 'cab', 'acd'] >>> sort_strings_by_ascii_sum([\\"hello world\\", \\"hi!\\", \\"test\\"]) ['hi!', 'test', 'hello world'] def test_example_1(): assert sort_strings_by_ascii_sum([\\"apple\\", \\"banana\\", \\"cherry\\"]) == [\\"apple\\", \\"banana\\", \\"cherry\\"] def test_example_2(): assert sort_strings_by_ascii_sum([\\"abc\\", \\"acd\\", \\"cab\\"]) == [\\"abc\\", \\"cab\\", \\"acd\\"] def test_example_3(): assert sort_strings_by_ascii_sum([\\"hello world\\", \\"hi!\\", \\"test\\"]) == [\\"hi!\\", \\"test\\", \\"hello world\\"] def test_single_string(): assert sort_strings_by_ascii_sum([\\"single\\"]) == [\\"single\\"] def test_same_ascii_sum_different_lexicographical_order(): assert sort_strings_by_ascii_sum([\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\"]) == [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\"] def test_multiple_strings_with_spaces(): assert sort_strings_by_ascii_sum([\\"a b c\\", \\"abc\\", \\"a bc\\", \\"ab c\\"]) == [\\"abc\\", \\"a bc\\", \\"ab c\\", \\"a b c\\"] def test_mixed_case_strings(): assert sort_strings_by_ascii_sum([\\"Abc\\", \\"aBc\\", \\"AbC\\", \\"abc\\"]) == [\\"AbC\\", \\"Abc\\", \\"aBc\\", \\"abc\\"] def test_mixed_alphanumeric(): assert sort_strings_by_ascii_sum([\\"a1b\\", \\"b2c\\", \\"a2b\\", \\"b1c\\"]) == [\\"a1b\\", \\"a2b\\", \\"b1c\\", \\"b2c\\"] def test_string_with_non_alphanumeric_characters(): assert sort_strings_by_ascii_sum([\\"a#b\\", \\"a!b\\", \\"ab\\", \\"a%b\\"]) == [\\"a!b\\", \\"a#b\\", \\"ab\\", \\"a%b\\"] def test_empty_string_list(): assert sort_strings_by_ascii_sum([]) == []","solution":"from typing import List def sort_strings_by_ascii_sum(strings: List[str]) -> List[str]: def ascii_sum(s: str) -> int: return sum(ord(ch) for ch in s) return sorted(strings, key=lambda s: (ascii_sum(s), s)) # Example usage: # strings = [\\"apple\\", \\"banana\\", \\"cherry\\"] # print(sort_strings_by_ascii_sum(strings)) # Output: [\\"apple\\", \\"banana\\", \\"cherry\\"]"},{"question":"def portfolio_value(n: int, m: int, initial_values: List[int], changes: List[List[int]]) -> int: Compute the value of the portfolio after m days, modulo 10^9 + 7. Args: n (int): The number of assets. m (int): The number of days. initial_values (List[int]): The initial values of the assets. changes (List[List[int]]): The changes in value of the assets over m days. Returns: int: The total value of the portfolio modulo 10^9 + 7. Example: >>> n, m = 4, 2 >>> initial_values = [10, 20, 30, 40] >>> changes = [ ... [5, -10, 0, 10], ... [-10, 20, 5, -5] ... ] >>> portfolio_value(n, m, initial_values, changes) 115 >>> n, m = 3, 3 >>> initial_values = [100, 200, 300] >>> changes = [ ... [-50, 50, 0], ... [25, -100, 75], ... [10, 10, 10] ... ] >>> portfolio_value(n, m, initial_values, changes) 640 from solution import portfolio_value def test_example_1(): n = 4 m = 2 initial_values = [10, 20, 30, 40] changes = [ [5, -10, 0, 10], [-10, 20, 5, -5] ] assert portfolio_value(n, m, initial_values, changes) == 115 def test_example_2(): n = 3 m = 3 initial_values = [100, 200, 300] changes = [ [-50, 50, 0], [25, -100, 75], [10, 10, 10] ] assert portfolio_value(n, m, initial_values, changes) == 630 def test_large_values(): n = 2 m = 2 initial_values = [10**9, 10**9] changes = [ [1, -1], [3, -3] ] assert portfolio_value(n, m, initial_values, changes) == (10**9 + 1 + 10**9 - 1 + 3 - 3) % (10**9 + 7) def test_modulo_result(): n = 3 m = 1 initial_values = [10**8, 10**8, 10**8] changes = [ [10**8, 10**8, 10**8] ] assert portfolio_value(n, m, initial_values, changes) == ((10**8 + 10**8) * 3) % (10**9 + 7)","solution":"def portfolio_value(n, m, initial_values, changes): MODULO = 10**9 + 7 for day_changes in changes: initial_values = [(initial_values[i] + day_changes[i]) % MODULO for i in range(n)] total_value = sum(initial_values) % MODULO return total_value"},{"question":"def longest_subarray_sum_leq_k(nums: List[int], k: int) -> int: Find the length of the longest subarray whose sum is less than or equal to k. Parameters: nums (List[int]): List of integers. k (int): The upper limit for the subarray sum. Returns: int: Length of the longest subarray whose sum is less than or equal to k. >>> longest_subarray_sum_leq_k([1, 2, 3, 4, 5], 9) 3 >>> longest_subarray_sum_leq_k([10, 12, 15], 5) 0 >>> longest_subarray_sum_leq_k([5], 5) 1 >>> longest_subarray_sum_leq_k([1, 1, 1, 1, 1], 10) 5 >>> longest_subarray_sum_leq_k([0, 0, 0, 0, 0], 0) 5 >>> longest_subarray_sum_leq_k([-1, -2, 3, 4, -3, 2], 4) 6","solution":"def longest_subarray_sum_leq_k(nums, k): Function to find the length of the longest subarray such that the sum of its elements is less than or equal to k. Parameters: nums (List[int]): List of integers. k (int): The upper limit for the subarray sum. Returns: int: Length of the longest subarray whose sum is less than or equal to k. n = len(nums) max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum > k: current_sum -= nums[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def max_profit(prices: List[int]) -> int: Computes the maximum profit from a list of prices by buying on one day and selling on a later day. :param prices: List[int] - A List of integers representing prices of an item over a number of days. :return: int - The maximum profit that can be achieved, 0 if no profit is possible. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([]) 0 >>> max_profit([5]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1]) 0 >>> max_profit([3, 2, 6, 1, 4]) 4 >>> max_profit([3, 3, 5, 0, 0, 3, 1, 4]) 4","solution":"def max_profit(prices): Computes the maximum profit from a list of prices by buying on one day and selling on a later day. :param prices: List[int] - A List of integers representing prices of an item over a number of days. :return: int - The maximum profit that can be achieved, 0 if no profit is possible. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"import math from typing import List, Tuple def volume_of_cylinder(radius: int, height: int) -> float: Returns the volume of a cylinder given the radius and height. >>> volume_of_cylinder(3, 5) == 141.37 >>> volume_of_cylinder(7, 10) == 1539.38 >>> volume_of_cylinder(4, 12) == 603.19 >>> volume_of_cylinder(1, 1) == 3.14 >>> volume_of_cylinder(30, 30) == 84823.00 def calculate_volumes_for_cases(cases: List[Tuple[int, int]]) -> List[float]: Given a list of (radius, height) tuples, returns a list of corresponding cylinder volumes. >>> calculate_volumes_for_cases([(3, 5), (7, 10), (4, 12)]) == [141.37, 1539.38, 603.19] >>> calculate_volumes_for_cases([(1, 1), (30, 30)]) == [3.14, 84823.00]","solution":"import math def volume_of_cylinder(radius, height): Returns the volume of a cylinder given the radius and height. volume = math.pi * (radius ** 2) * height return round(volume, 2) def calculate_volumes_for_cases(cases): Given a list of (radius, height) tuples, returns a list of corresponding cylinder volumes. return [volume_of_cylinder(radius, height) for radius, height in cases]"},{"question":"def first_non_repeating_character(s: str) -> str: Given a string s consisting of lowercase English letters, find and return the first instance of a non-repeating character within the string. If all characters are repeating or the string is empty, return an empty string. >>> first_non_repeating_character(\\"leetcode\\") \\"l\\" >>> first_non_repeating_character(\\"loveleetcode\\") \\"v\\" >>> first_non_repeating_character(\\"aabbcc\\") \\"\\" >>> first_non_repeating_character(\\"abcd\\") \\"a\\" ...","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If all characters are repeating or the string is empty, returns an empty string. # Create a dictionary to count character occurrences char_count = {} # First pass to count all characters for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to identify the first non-repeating character for char in s: if char_count[char] == 1: return char return \\"\\""},{"question":"from typing import List, Union def flatten_and_sum(nested_list: List[Union[int, List]]) -> int: Returns the sum of all integers in the nested structure. >>> flatten_and_sum([1, 2, 3]) == 6 >>> flatten_and_sum([1, [2, [3, 4], 5], 6]) == 21 >>> flatten_and_sum([10, 20, 30, 40]) == 100 >>> flatten_and_sum([]) == 0 >>> flatten_and_sum([[], [], []]) == 0 >>> flatten_and_sum([10, [], [20, []], [], [30]]) == 60 >>> flatten_and_sum([1, [2, [3, [4, [5]]]]]) == 15 >>> flatten_and_sum([[1, [2, [3]]], [4], [5, [6]], 7]) == 28","solution":"def flatten_and_sum(nested_list): Returns the sum of all integers in the nested structure. total_sum = 0 for element in nested_list: if isinstance(element, int): total_sum += element elif isinstance(element, list): total_sum += flatten_and_sum(element) return total_sum"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string s, return the length of the longest substring without repeating characters. Examples: >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 Note that the answer must be a substring, \\"pwke\\" is a subsequence and not a substring. Constraints: - 0 <= s.length <= 5 * 10^4 - The string consists of English letters, digits, symbols, and spaces.","solution":"def length_of_longest_substring(s): Finds the length of the longest substring without repeating characters. char_map = {} left = 0 longest = 0 for right, char in enumerate(s): if char in char_map and char_map[char] >= left: left = char_map[char] + 1 char_map[char] = right longest = max(longest, right - left + 1) return longest"},{"question":"def is_valid_ipv4_address(ip_address: str) -> bool: Checks if the given string is a valid IPv4 address. An IPv4 address consists of four decimal numbers, each ranging from 0 to 255, separated by dots ('.'). >>> is_valid_ipv4_address(\\"192.168.1.1\\") == True >>> is_valid_ipv4_address(\\"255.255.255.255\\") == True >>> is_valid_ipv4_address(\\"0.0.0.0\\") == True >>> is_valid_ipv4_address(\\"10.0.0.1\\") == True >>> is_valid_ipv4_address(\\"256.256.256.256\\") == False >>> is_valid_ipv4_address(\\"192.168.1\\") == False >>> is_valid_ipv4_address(\\"192.168.1.1.1\\") == False >>> is_valid_ipv4_address(\\"192.168.01.1\\") == False >>> is_valid_ipv4_address(\\"192.168.1.-1\\") == False >>> is_valid_ipv4_address(\\"123.456.78.090\\") == False >>> is_valid_ipv4_address(\\"192.168.1.01\\") == False >>> is_valid_ipv4_address(\\"01.01.01.01\\") == False >>> is_valid_ipv4_address(\\"001.001.001.001\\") == False >>> is_valid_ipv4_address(\\"0.0.0.0\\") == True","solution":"def is_valid_ipv4_address(ip_address): Checks if the given string is a valid IPv4 address. An IPv4 address consists of four decimal numbers, each ranging from 0 to 255, separated by dots ('.'). Parameters: ip_address (str): The IP address to validate. Returns: bool: True if the given string is a valid IPv4 address, False otherwise. parts = ip_address.split(\\".\\") # There must be exactly 4 parts if len(parts) != 4: return False for part in parts: # Each part must be a number if not part.isdigit(): return False num = int(part) # Each number must be between 0 and 255 if num < 0 or num > 255: return False # No leading zeros allowed (except for the number \\"0\\" itself) if part != '0' and part[0] == '0': return False return True"},{"question":"def is_unique(string: str) -> bool: Determines if a string has all unique characters. >>> is_unique(\\"abcdefg\\") True >>> is_unique(\\"hello\\") False >>> is_unique(\\"1234567890\\") True >>> is_unique(\\"112233\\") False pass def test_is_unique_all_unique_chars(): assert is_unique(\\"abcdefg\\") == True def test_is_unique_with_duplicates(): assert is_unique(\\"hello\\") == False def test_is_unique_numeric_unique(): assert is_unique(\\"1234567890\\") == True def test_is_unique_numeric_non_unique(): assert is_unique(\\"112233\\") == False def test_is_unique_mixed_case_unique(): assert is_unique(\\"AbCdEfG\\") == True def test_is_unique_mixed_case_non_unique(): assert is_unique(\\"aAa\\") == False def test_is_unique_single_char(): assert is_unique(\\"a\\") == True def test_is_unique_empty_string(): assert is_unique(\\"\\") == True def test_is_unique_large_string_unique(): string = \\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\\" assert is_unique(string) == True def test_is_unique_large_string_non_unique(): string = \\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890\\" assert is_unique(string) == False","solution":"def is_unique(string): Determines if a string has all unique characters without using additional data structures. :param string: str - input string to be checked :return: bool - True if all characters in the string are unique, False otherwise # We will use a brute force method by comparing each character with every other character n = len(string) for i in range(n): for j in range(i + 1, n): if string[i] == string[j]: return False return True"},{"question":"from typing import List def find_kth_permutation(nums: List[int], k: int) -> List[int]: Returns the k-th permutation sequence (1-indexed) of the list nums. >>> find_kth_permutation([1, 2, 3], 3) [2, 1, 3] >>> find_kth_permutation([1], 1) [1] >>> find_kth_permutation([1, 2], 1) [1, 2] >>> find_kth_permutation([1, 2], 2) [2, 1] >>> find_kth_permutation([1, 2, 3, 4], 9) [2, 3, 1, 4] >>> find_kth_permutation([1, 2, 3, 4], 24) [4, 3, 2, 1] >>> find_kth_permutation([1, 2, 3], 6) [3, 2, 1] >>> find_kth_permutation([4, 5, 6], 1) [4, 5, 6] >>> find_kth_permutation([7, 8, 9], 2) [7, 9, 8] >>> find_kth_permutation([1, 2, 3, 4, 5], 120) [5, 4, 3, 2, 1]","solution":"import math def find_kth_permutation(nums, k): Returns the k-th permutation sequence (1-indexed) of the list nums. n = len(nums) k -= 1 # Change to 0-indexed factorial = math.factorial(n) permutation = [] for i in range(n, 0, -1): factorial //= i idx = k // factorial permutation.append(nums[idx]) nums.pop(idx) k %= factorial return permutation"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns a list of integers where each element at index i is the product of all the numbers in the original list except the one at i. Division operation is not used. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [3628800, 1814400, 1209600, 907200, 725760, 604800, 518400, 453600, 403200, 362880]","solution":"def product_except_self(nums): Returns a list of integers where each element at index i is the product of all the numbers in the original list except the one at i. Division operation is not used. n = len(nums) # Initialize the result array with 1s result = [1] * n # Calculate the prefix products and store in result prefix_product = 1 for i in range(n): result[i] = prefix_product prefix_product *= nums[i] # Calculate the suffix products and multiply with the corresponding # prefix product stored in result suffix_product = 1 for i in range(n-1, -1, -1): result[i] *= suffix_product suffix_product *= nums[i] return result"},{"question":"def evaluate_rpn(expression: str) -> float: Evaluates a given expression in Reverse Polish Notation (RPN) and returns the result as a float. >>> evaluate_rpn(\\"3 4 +\\") 7.0 >>> evaluate_rpn(\\"10 5 -\\") 5.0 >>> evaluate_rpn(\\"2 3 *\\") 6.0 >>> evaluate_rpn(\\"8 2 /\\") 4.0 >>> evaluate_rpn(\\"3 4 + 2 * 1 +\\") 15.0 >>> evaluate_rpn(\\"5 1 2 + 4 * + 3 -\\") 14.0 >>> evaluate_rpn(\\"4 2 / 3 +\\") 5.0 >>> evaluate_rpn(\\"3 -4 +\\") -1.0 >>> evaluate_rpn(\\"-2 -3 *\\") 6.0 >>> evaluate_rpn(\\"3.5 4.5 +\\") 8.0 >>> evaluate_rpn(\\"10.0 3.5 -\\") 6.5 >>> evaluate_rpn(\\"2.5 2 *\\") 5.0 >>> evaluate_rpn(\\"9.0 2.0 /\\") 4.5","solution":"def evaluate_rpn(expression: str) -> float: Evaluates a given expression in Reverse Polish Notation (RPN) and returns the result as a float. stack = [] tokens = expression.split() for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == '+': result = a + b elif token == '-': result = a - b elif token == '*': result = a * b elif token == '/': result = a / b stack.append(result) else: stack.append(float(token)) return stack[0]"},{"question":"def contains_tandem_repeats(n: int, sequence: str) -> str: Determines if there is a substring of length at least 2 which appears consecutively. Parameters: n (int): The length of the sequence. sequence (str): The biological sequence. Returns: str: 'YES' if there is a tandem repeat, 'NO' otherwise. >>> contains_tandem_repeats(7, \\"abababa\\") 'YES' >>> contains_tandem_repeats(6, \\"abcdef\\") 'NO'","solution":"def contains_tandem_repeats(n, sequence): Determines if there is a substring of length at least 2 which appears consecutively. Parameters: n (int): The length of the sequence. sequence (str): The biological sequence. Returns: str: 'YES' if there is a tandem repeat, 'NO' otherwise. for i in range(n - 1): if sequence[i] == sequence[i + 1]: return 'YES' for length in range(2, n // 2 + 1): for i in range(n - 2*length + 1): if sequence[i:i+length] == sequence[i+length:i+2*length]: return 'YES' return 'NO'"},{"question":"def decipher_message(message: str) -> str: Decipher the message by removing repeated letters followed by their intended count. >>> decipher_message(\\"a3b2\\") 'ab' >>> decipher_message(\\"cc3a1\\") 'ca' >>> decipher_message(\\"ttt3e2rrr2\\") 'ter' def decipher_messages(test_cases: List[str]) -> List[str]: Deciphers a list of messages. >>> decipher_messages([\\"a3b2\\", \\"cc3a1\\", \\"ttt3e2rrr2\\"]) ['ab', 'ca', 'ter'] return [decipher_message(message) for message in test_cases]","solution":"def decipher_message(message): Decipher the message by removing repeated letters followed by their intended count. i = 0 original_message = [] while i < len(message): current_char = message[i] j = i while j < len(message) and message[j].isdigit() == False: j += 1 count_string = [] while j < len(message) and message[j].isdigit(): count_string.append(message[j]) j += 1 count = int(''.join(count_string)) original_message.append(current_char) i = j return ''.join(original_message) def decipher_messages(test_cases): Deciphers a list of messages. return [decipher_message(message) for message in test_cases]"},{"question":"def isValid(s: str) -> bool: Identify if a given string s containing characters '(', ')', '{', '}', '[' and ']' is a valid expression. A valid expression is one where the brackets are correctly matched and nested. >>> isValid(\\"([]{})\\") True >>> isValid(\\"([{]})\\") False >>> isValid(\\"((()))\\") True >>> isValid(\\"[{()}]\\") True >>> isValid(\\"{[}]\\") False >>> isValid(\\"\\") True >>> isValid(\\"()[]{}\\") True >>> isValid(\\"([{}\\") False >>> isValid(\\"(\\") False >>> isValid(\\"}\\") False","solution":"def isValid(s: str) -> bool: stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def floyd_warshall(n, edges): Compute the shortest paths between all pairs of cities using the Floyd-Warshall algorithm. >>> floyd_warshall(4, [(0, 1, 3), (1, 2, 1), (2, 3, 7), (0, 3, 8)]) [[0, 3, 4, 8], ['INF', 0, 1, 8], ['INF', 'INF', 0, 7], ['INF', 'INF', 'INF', 0]] >>> floyd_warshall(3, []) [[0, 'INF', 'INF'], ['INF', 0, 'INF'], ['INF', 'INF', 0]] >>> floyd_warshall(2, [(0, 1, 5)]) [[0, 5], ['INF', 0]] >>> floyd_warshall(3, [(0, 1, 1), (0, 2, 4), (1, 2, 2)]) [[0, 1, 3], ['INF', 0, 2], ['INF', 'INF', 0]] >>> floyd_warshall(4, [(0, 1, 5), (2, 3, 2)]) [[0, 5, 'INF', 'INF'], ['INF', 0, 'INF', 'INF'], ['INF', 'INF', 0, 2], ['INF', 'INF', 'INF', 0]]","solution":"def floyd_warshall(n, edges): # Initialize distance matrix with \\"INF\\" except for 0s on the diagonal dist = [[float('inf')] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 # Add the direct distances to the matrix for u, v, d in edges: dist[u][v] = d # Floyd Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] # Formatting the output matrix result = [] for i in range(n): row = [] for j in range(n): if dist[i][j] == float('inf'): row.append('INF') else: row.append(dist[i][j]) result.append(row) return result"},{"question":"def max_games_played(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Calculate the maximal number of games that can be played simultaneously given the number of minions available and the number of minions required for each game. >>> max_games_played(2, [((10, 4), [2, 3, 4, 5]), ((8, 3), [5, 5, 5])]) [3, 1] >>> max_games_played(1, [((7, 5), [2, 2, 2, 3, 3])]) [3] >>> max_games_played(1, [((15, 4), [5, 6, 7, 8])]) [2] >>> max_games_played(1, [((5, 3), [4, 2, 2])]) [2] >>> max_games_played(1, [((20, 6), [1, 2, 3, 4, 5, 10])]) [5]","solution":"def max_games_played(T, test_cases): results = [] for i in range(T): B, M = test_cases[i][0] minions_required = sorted(test_cases[i][1]) max_games = 0 total_minions_used = 0 for game in minions_required: if total_minions_used + game <= B: total_minions_used += game max_games += 1 else: break results.append(max_games) return results"},{"question":"def invert_dictionary(d: dict) -> dict: Invert a dictionary such that the keys are the original dictionary's values, and the values are the original dictionary's keys. If the original dictionary has multiple keys with the same value, the value maps to a list containing all corresponding keys. >>> invert_dictionary({'a': 1, 'b': 2, 'c': 1}) {1: ['a', 'c'], 2: 'b'} >>> invert_dictionary({1: 'x', 2: 'y', 3: 'x'}) {'x': [1, 3], 'y': 2} >>> invert_dictionary({'name': 'John', 'age': 25, 'city': 'New York'}) {'John': 'name', 25: 'age', 'New York': 'city'} >>> invert_dictionary({}) {} >>> invert_dictionary({'a': (1, 2), 'b': (1, 2), 'c': 3}) {(1, 2): ['a', 'b'], 3: 'c'}","solution":"def invert_dictionary(d): Function to invert a dictionary such that the keys are the original dictionary's values, and the values are the original dictionary's keys. If the original dictionary has multiple keys with the same value, the value maps to a list containing all corresponding keys. inverted_dict = {} for key, value in d.items(): if value not in inverted_dict: inverted_dict[value] = key else: if not isinstance(inverted_dict[value], list): inverted_dict[value] = [inverted_dict[value]] inverted_dict[value].append(key) return inverted_dict"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the string s can be rearranged to form a palindrome. :param s: A single string consisting of lowercase alphabets :return: True if the string can be rearranged to form a palindrome, otherwise False >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"abc\\") False pass def process_test_cases(test_cases: List[str]) -> List[str]: Processes a list of test cases and returns the results for whether each string can be rearranged to form a palindrome. :param test_cases: A list of strings where each string is a test case :return: A list of strings, either \\"YES\\" or \\"NO\\", indicating if the string can be rearranged to form a palindrome >>> process_test_cases([\\"aabb\\", \\"abc\\"]) [\\"YES\\", \\"NO\\"] >>> process_test_cases([\\"aabbcc\\", \\"abcdefg\\"]) [\\"YES\\", \\"NO\\"] pass # Unit Tests def test_can_form_palindrome(): assert can_form_palindrome(\\"aabb\\") == True assert can_form_palindrome(\\"abc\\") == False assert can_form_palindrome(\\"aabbcc\\") == True assert can_form_palindrome(\\"a\\") == True assert can_form_palindrome(\\"aaabb\\") == True assert can_form_palindrome(\\"aaabbbcc\\") == False assert can_form_palindrome(\\"abccba\\") == True assert can_form_palindrome(\\"abcdefg\\") == False def test_process_test_cases(): assert process_test_cases([\\"aabb\\", \\"abc\\", \\"aabbcc\\", \\"abcdefg\\"]) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] assert process_test_cases([\\"abc\\", \\"aaabbbcc\\", \\"abccba\\"]) == [\\"NO\\", \\"NO\\", \\"YES\\"] assert process_test_cases([\\"a\\", \\"aaabb\\", \\"aabbcc\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_form_palindrome(s): Determines if the string s can be rearranged to form a palindrome. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1 def process_test_cases(test_cases): Processes a list of test cases and returns the results for whether each string can be rearranged to form a palindrome. results = [] for s in test_cases: if can_form_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def mostRepeatedChar(s: str) -> str: Returns the most repeated character in the string. If there are multiple characters with the same highest count, return the first one that appears. If the string is empty, returns an empty string. >>> mostRepeatedChar(\\"aabbcc\\") == \\"a\\" >>> mostRepeatedChar(\\"geeksforgeeks\\") == \\"e\\" >>> mostRepeatedChar(\\"abc abc abc\\") == \\"a\\" >>> mostRepeatedChar(\\" \\") == \\" \\" >>> mostRepeatedChar(\\"\\") == \\"\\" >>> mostRepeatedChar(\\"aaaaaa\\") == \\"a\\" >>> mostRepeatedChar(\\"bbbbbb\\") == \\"b\\" >>> mostRepeatedChar(\\"testing a function\\") == \\"t\\"","solution":"def mostRepeatedChar(s): Returns the most repeated character in the string. If there are multiple characters with the same highest count, return the first one that appears. If the string is empty, returns an empty string. if not s: return \\"\\" character_count = {} max_count = 0 max_char = \\"\\" for char in s: character_count[char] = character_count.get(char, 0) + 1 if character_count[char] > max_count: max_count = character_count[char] max_char = char return max_char"},{"question":"def analyze_stock_prices(prices: List[int]) -> int: Determines the maximum profit that can be made from buying and selling stock given a list of prices. >>> analyze_stock_prices([7, 1, 5, 3, 6, 4]) 5 >>> analyze_stock_prices([7, 6, 4, 3, 1]) 0 >>> analyze_stock_prices([1, 2, 3, 4, 5]) 4","solution":"def analyze_stock_prices(prices): Determines the maximum profit that can be made from buying and selling stock given a list of prices. :param prices: List[int] of stock prices where each element represents the price on a different day :return: int, maximum profit that can be made; 0 if no profitable opportunity exists # If prices list has less than 2 prices, profit is not possible if len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: # Update max profit if current price - min_price yields a better result max_profit = max(max_profit, price - min_price) # Update min price to the lowest price seen so far min_price = min(min_price, price) return max_profit"},{"question":"def can_form_palindrome(s: str) -> bool: Given a string, determine if any permutation of the string could form a palindrome. >>> can_form_palindrome(\\"Tact Coa\\") True >>> can_form_palindrome(\\"not a palindrome\\") False >>> can_form_palindrome(\\"A man a plan a canal Panama\\") True # Unit tests assert can_form_palindrome(\\"a\\") == True assert can_form_palindrome(\\"aa\\") == True assert can_form_palindrome(\\"ab\\") == False assert can_form_palindrome(\\"Tact Coa\\") == True assert can_form_palindrome(\\"not a palindrome\\") == False assert can_form_palindrome(\\"A man a plan a canal Panama\\") == True assert can_form_palindrome(\\"\\") == True assert can_form_palindrome(\\"abcdefghijk\\") == False assert can_form_palindrome(\\"carerac\\") == True assert can_form_palindrome(\\"aabbcc\\") == True","solution":"def can_form_palindrome(s: str) -> bool: from collections import Counter # Normalize the string: remove spaces and make it lower case s = ''.join(s.split()).lower() # Count the frequency of each character char_count = Counter(s) # Check the number of characters that have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For a string to be able to form a palindrome, there can be at most one character with an odd count return odd_count <= 1"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a given mathematical expression and returns the result as an integer. The expression can contain digits, '+', '-', '*', '/', and white spaces. Parameters: expression (str): The mathematical expression to evaluate. Returns: int: The result of the evaluation.","solution":"def evaluate_expression(expression): Evaluates a given mathematical expression and returns the result as an integer. The expression can contain digits, '+', '-', '*', '/', and white spaces. Parameters: expression (str): The mathematical expression to evaluate. Returns: int: The result of the evaluation. def apply_operator(operands, operator): b = operands.pop() a = operands.pop() if operator == '+': operands.append(a + b) elif operator == '-': operands.append(a - b) elif operator == '*': operands.append(a * b) elif operator == '/': operands.append(int(a / b)) # Use int() to ensure integer division def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 # Clean the expression by removing spaces expression = expression.replace(' ', '') operands = [] operators = [] i = 0 while i < len(expression): if expression[i].isdigit(): j = i while j < len(expression) and expression[j].isdigit(): j += 1 operands.append(int(expression[i:j])) i = j else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operands, operators.pop()) operators.append(expression[i]) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[0]"},{"question":"def min_operations_to_equal_heights(heights: List[int]) -> int: This function calculates the minimum number of operations required to make all tree heights the same. >>> min_operations_to_equal_heights([1, 2, 3]) 2 >>> min_operations_to_equal_heights([5, 5, 5]) 0 >>> min_operations_to_equal_heights([1, 1000]) 999 >>> min_operations_to_equal_heights([7, 3]) 4 >>> min_operations_to_equal_heights([10]) 0 >>> min_operations_to_equal_heights([]) 0 >>> min_operations_to_equal_heights([1, 2, 2, 3]) 2 >>> min_operations_to_equal_heights([-1, -2, -3]) 2 >>> min_operations_to_equal_heights([-1, 0, 1]) 2","solution":"def min_operations_to_equal_heights(heights): This function calculates the minimum number of operations required to make all tree heights the same. if not heights: return 0 median_height = sorted(heights)[len(heights) // 2] operations = sum(abs(height - median_height) for height in heights) return operations"},{"question":"def my_transpose(matrix): Returns a new array with the rows and columns transposed. If the matrix is not rectangular or empty, raises an ArgumentError. >>> my_transpose([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> my_transpose([ ... [1, 2, 3], ... [4, 5, 6] ... ]) [[1, 4], [2, 5], [3, 6]] >>> my_transpose([ ... [1, 2, 3] ... ]) [[1], [2], [3]] >>> my_transpose([ ... [1], ... [2], ... [3] ... ]) [[1, 2, 3]]","solution":"def my_transpose(matrix): Returns a new array with the rows and columns transposed. If the matrix is not rectangular or empty, raises an ArgumentError. if not matrix or not all(len(row) == len(matrix[0]) for row in matrix): raise ValueError(\\"Input must be a non-empty rectangular matrix.\\") return [list(row) for row in zip(*matrix)]"},{"question":"def is_valid_bracket_arrangement(s: str) -> bool: Returns True if the brackets in the string s are arranged in a valid way, otherwise returns False. >>> is_valid_bracket_arrangement(\\"()\\") True >>> is_valid_bracket_arrangement(\\"{}[]\\") True >>> is_valid_bracket_arrangement(\\"([{}])\\") True >>> is_valid_bracket_arrangement(\\"{[}]\\") False >>> is_valid_bracket_arrangement(\\"[(])\\") False","solution":"def is_valid_bracket_arrangement(s): Returns True if the brackets in the string s are arranged in a valid way, otherwise returns False. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False else: continue return stack == []"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeAndSortLists(l1: ListNode, l2: ListNode) -> ListNode: Merge two singly linked lists and return a sorted linked list. >>> l1 = list_to_linkedlist([1, 3, 5]) >>> l2 = list_to_linkedlist([2, 4, 6]) >>> linkedlist_to_list(mergeAndSortLists(l1, l2)) [1, 2, 3, 4, 5, 6] >>> l1 = list_to_linkedlist([]) >>> l2 = list_to_linkedlist([]) >>> linkedlist_to_list(mergeAndSortLists(l1, l2)) [] >>> l1 = list_to_linkedlist([]) >>> l2 = list_to_linkedlist([1, 2, 3]) >>> linkedlist_to_list(mergeAndSortLists(l1, l2)) [1, 2, 3] >>> l1 = list_to_linkedlist([1, 3, 5, 5]) >>> l2 = list_to_linkedlist([2, 3, 4, 6]) >>> linkedlist_to_list(mergeAndSortLists(l1, l2)) [1, 2, 3, 3, 4, 5, 5, 6] >>> l1 = list_to_linkedlist([1]) >>> l2 = list_to_linkedlist([2]) >>> linkedlist_to_list(mergeAndSortLists(l1, l2)) [1, 2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeAndSortLists(l1: ListNode, l2: ListNode) -> ListNode: def mergeTwoSortedLists(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode(-1) current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 if l1 else l2 return dummy.next return mergeTwoSortedLists(l1, l2)"},{"question":"def reverseLetters(s: str) -> str: Given a string containing alphabets and digits, return a string where the letters are reversed in order but the digits remain in their original positions and order. Examples: >>> reverseLetters(\\"a1b2c3\\") 'c1b2a3' >>> reverseLetters(\\"ab12cd34\\") 'dc12ba34'","solution":"def reverseLetters(s): Returns a string where the letters are reversed in order but the digits remain in their original positions and order. # Extract letters letters = [char for char in s if char.isalpha()] # Reverse the letters letters.reverse() # Initialize an iterator for the reversed letters letters_iter = iter(letters) # Construct the final string result = ''.join(next(letters_iter) if char.isalpha() else char for char in s) return result"},{"question":"def find_matching_words(words: List[str], pattern: str) -> List[str]: Returns a list of strings from the input list that match the given pattern. A string matches the pattern if replacing each unique character in the pattern with a unique letter consistently throughout the pattern yields the string. Parameters: words (list): List of strings. pattern (str): The pattern string. Returns: list: List of strings matching the pattern. >>> find_matching_words([\\"abb\\", \\"abc\\", \\"xyz\\", \\"xyy\\"], \\"mno\\") [\\"abc\\", \\"xyz\\"] >>> find_matching_words([\\"a\\", \\"b\\", \\"c\\"], \\"d\\") [\\"a\\", \\"b\\", \\"c\\"] >>> find_matching_words([\\"abb\\", \\"acc\\", \\"add\\"], \\"xyz\\") [] >>> find_matching_words([], \\"mno\\") [] >>> find_matching_words([\\"abc\\", \\"def\\"], \\"\\") [] >>> find_matching_words([\\"aba\\", \\"xyz\\", \\"xyx\\", \\"mnp\\"], \\"wuw\\") [\\"aba\\", \\"xyx\\"]","solution":"def find_matching_words(words, pattern): Returns a list of strings from the input list that match the given pattern. Parameters: words (list): List of strings. pattern (str): The pattern string. Returns: list: List of strings matching the pattern. def matches(word, pattern): if len(word) != len(pattern): return False char_map = {} mapped_chars = set() for w_char, p_char in zip(word, pattern): if p_char in char_map: if char_map[p_char] != w_char: return False else: if w_char in mapped_chars: return False char_map[p_char] = w_char mapped_chars.add(w_char) return True return [word for word in words if matches(word, pattern)]"},{"question":"from typing import List, Dict def sortByNameLength(arr: List[Dict[str, str]]) -> List[Dict[str, str]]: Sorts an array of objects in ascending order based on the length of the 'name' properties. >>> sortByNameLength([ ... {\\"name\\": \\"Harry\\"}, ... {\\"name\\": \\"Ron\\"}, ... {\\"name\\": \\"Hermione\\"} ... ]) [{\\"name\\": \\"Ron\\"}, {\\"name\\": \\"Harry\\"}, {\\"name\\": \\"Hermione\\"}] >>> sortByNameLength([ ... {\\"name\\": \\"Ed\\"}, ... {\\"name\\": \\"Jo\\"}, ... {\\"name\\": \\"Al\\"} ... ]) [{\\"name\\": \\"Ed\\"}, {\\"name\\": \\"Jo\\"}, {\\"name\\": \\"Al\\"}] >>> sortByNameLength([ ... {\\"name\\": \\"Dobby\\"}, ... ]) [{\\"name\\": \\"Dobby\\"}] >>> sortByNameLength([]) [] >>> sortByNameLength([ ... {\\"name\\": \\"Avery\\"}, ... {\\"name\\": \\"B\\"}, ... {\\"name\\": \\"Jon\\"}, ... {\\"name\\": \\"Alex\\"}, ... {\\"name\\": \\"Sue\\"} ... ]) [{\\"name\\": \\"B\\"}, {\\"name\\": \\"Jon\\"}, {\\"name\\": \\"Sue\\"}, {\\"name\\": \\"Alex\\"}, {\\"name\\": \\"Avery\\"}]","solution":"from typing import List, Dict def sortByNameLength(arr: List[Dict[str, str]]) -> List[Dict[str, str]]: Sorts an array of objects in ascending order based on the length of the 'name' properties. return sorted(arr, key=lambda x: len(x['name']))"},{"question":"def isAutomorphic(num: int) -> bool: Checks if the given number is an Automorphic number. An automorphic number is a number whose square ends in the same digits as the number itself. >>> isAutomorphic(1) True >>> isAutomorphic(5) True >>> isAutomorphic(6) True >>> isAutomorphic(25) True >>> isAutomorphic(76) True >>> isAutomorphic(376) True >>> isAutomorphic(2) False >>> isAutomorphic(3) False >>> isAutomorphic(10) False >>> isAutomorphic(100) False >>> isAutomorphic(0) True >>> isAutomorphic(9) False >>> isAutomorphic(9376) True","solution":"def isAutomorphic(num): Checks if the given number is an Automorphic number. Args: num: An integer. Returns: bool: True if num is an Automorphic number, False otherwise. squared = str(num ** 2) num_str = str(num) return squared.endswith(num_str)"},{"question":"import math from typing import List, Tuple def euclidean_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: Computes the Euclidean distance between two points p1 and p2. def farthest_distance(points: List[Tuple[int, int]]) -> float: Computes the farthest Euclidean distance between any two points in the set. >>> farthest_distance([(0, 0), (3, 4), (6, 8), (-3, -4)]) 15.0 >>> farthest_distance([(-1, -1), (1, 1), (2, 2)]) 4.242641 >>> farthest_distance([(0, 0), (1, 1)]) 1.414214 >>> farthest_distance([(0, 0), (10, 10), (10, 0), (0, 10)]) 14.142136","solution":"import math def euclidean_distance(p1, p2): Computes the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def farthest_distance(points): Computes the farthest Euclidean distance between any two points in the set. max_distance = 0 for i in range(len(points)): for j in range(i + 1, len(points)): distance = euclidean_distance(points[i], points[j]) if distance > max_distance: max_distance = distance return round(max_distance, 6) def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) points = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(N)] print(\\"{:.6f}\\".format(farthest_distance(points))) # Uncomment to run in the local environment # if __name__ == \\"__main__\\": # main()"},{"question":"from typing import List def max_apples(apples: List[int]) -> int: Returns the maximum number of apples that can be collected from any contiguous subsequence of trees. :param apples: List[int], a list of integers representing the number of apples on each tree. :return: int, the maximum number of apples that can be collected. >>> max_apples([1, 2, -3, 4, 5, 6, -2, 3]) 16 >>> max_apples([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_apples([5]) 5 >>> max_apples([1, 2, 3, 4, 5]) 15 >>> max_apples([-1, -2, -3, -4, -5]) -1","solution":"def max_apples(apples): Returns the maximum number of apples that can be collected from any contiguous subsequence of trees. :param apples: List[int], a list of integers representing the number of apples on each tree. :return: int, the maximum number of apples that can be collected. if not apples: return 0 max_current = max_global = apples[0] for num in apples[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def longestPalindrome(s: str) -> str: Function to find the longest palindromic substring in the given string. >>> longestPalindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longestPalindrome(\\"cbbd\\") == \\"bb\\" True >>> longestPalindrome(\\"a\\") == \\"a\\" True >>> longestPalindrome(\\"ac\\") in [\\"a\\", \\"c\\"] True","solution":"def longestPalindrome(s: str) -> str: Function to find the longest palindromic substring in the given string. if len(s) <= 1: return s def expand_around_center(left: int, right: int) -> str: while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest_palindrome = \\"\\" for i in range(len(s)): # Odd length palindromes temp = expand_around_center(i, i) if len(temp) > len(longest_palindrome): longest_palindrome = temp # Even length palindromes temp = expand_around_center(i, i + 1) if len(temp) > len(longest_palindrome): longest_palindrome = temp return longest_palindrome"},{"question":"def max_pairs(friends: int) -> int: Returns the maximum number of pairs that can be formed from the given number of friends. >>> max_pairs(5) 2 >>> max_pairs(10) 5 >>> max_pairs(15) 7 >>> max_pairs(0) 0 >>> max_pairs(1) 0","solution":"def max_pairs(friends): Returns the maximum number of pairs that can be formed from the given number of friends. return friends // 2"},{"question":"from typing import List def max_weight_support(heights: List[int]) -> int: Returns the maximum amount of weight that can be supported between any two poles. >>> max_weight_support([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_weight_support([1, 1]) 1 def test_max_weight_support_example1(): assert max_weight_support([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 def test_max_weight_support_example2(): assert max_weight_support([1, 1]) == 1 def test_max_weight_support_all_equal_heights(): assert max_weight_support([5, 5, 5, 5, 5]) == 20 # min height 5 * distance 4 (between indices 0 and 4) def test_max_weight_support_varying_heights(): assert max_weight_support([2, 3, 10, 5, 7, 8, 9]) == 36 # min height 6 * distance 6 (between indices 2 and 6) def test_max_weight_support_two_poles(): assert max_weight_support([3, 4]) == 3 # min height 3 * distance 1 (between indices 0 and 1) def test_max_weight_support_decreasing_heights(): assert max_weight_support([5, 4, 3, 2, 1]) == 6 # min height 2 * distance 3 (between indices 0 and 3) def test_max_weight_support_single_peak(): assert max_weight_support([1, 2, 4, 8, 4, 2, 1]) == 8 # min height 4 * distance 2 (between indices 2 and 4)","solution":"def max_weight_support(heights): Returns the maximum amount of weight that can be supported between any two poles. max_weight = 0 left, right = 0, len(heights) - 1 while left < right: min_height = min(heights[left], heights[right]) distance = right - left weight = min_height * distance max_weight = max(max_weight, weight) # Move the pointer pointing to the shorter pole if heights[left] < heights[right]: left += 1 else: right -= 1 return max_weight"},{"question":"def count_unique_elements_in_queries(n, array, queries): Returns the count of unique elements in the given subarrays specified by queries. Parameters: n (int): The number of elements in the array. array (list of ints): The integer elements of the array. queries (list of tuples): Queries specifying the subarrays, where each tuple contains two integers (L, R). Returns: list of ints: List containing the count of unique elements for each query. >>> count_unique_elements_in_queries(5, [1, 2, 1, 3, 2], [(1, 3), (2, 4), (1, 5)]) [2, 3, 3] >>> count_unique_elements_in_queries(5, [1, 2, 3, 4, 5], [(1, 5), (1, 1), (2, 3)]) [5, 1, 2] >>> count_unique_elements_in_queries(6, [2, 2, 2, 2, 2, 2], [(1, 6), (2, 4), (3, 5)]) [1, 1, 1]","solution":"def count_unique_elements_in_queries(n, array, queries): Returns the count of unique elements in the given subarrays specified by queries. Parameters: n (int): The number of elements in the array. array (list of ints): The integer elements of the array. queries (list of tuples): Queries specifying the subarrays, where each tuple contains two integers (L, R). Returns: list of ints: List containing the count of unique elements for each query. results = [] for L, R in queries: subarray = array[L-1:R] unique_elements_count = len(set(subarray)) results.append(unique_elements_count) return results"},{"question":"def all_pairs_shortest_path(T: int, cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[List[List[int]]]: Given a number of test cases, determine the shortest path from each computer to all the other computers in terms of the number of connections. The result should be a matrix where the element at row i and column j represents the shortest path from computer i to computer j. If there is no path from computer i to computer j, the corresponding element should be -1. >>> T = 2 >>> cases = [ >>> (3, 2, [(1, 2), (2, 3)]), >>> (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), >>> ] >>> all_pairs_shortest_path(T, cases) [ [ [0, 1, 2], [1, 0, 1], [2, 1, 0] ], [ [0, 1, 2, 1], [1, 0, 1, 2], [2, 1, 0, 1], [1, 2, 1, 0] ] ] >>> T = 1 >>> cases = [ >>> (2, 1, [(1, 2)]) >>> ] >>> all_pairs_shortest_path(T, cases) [ [ [0, 1], [1, 0] ] ] >>> T = 1 >>> cases = [ >>> (4, 2, [(1, 2), (3, 4)]) >>> ] >>> all_pairs_shortest_path(T, cases) [ [ [0, 1, -1, -1], [1, 0, -1, -1], [-1, -1, 0, 1], [-1, -1, 1, 0] ] ] >>> T = 1 >>> cases = [ >>> (3, 0, []) >>> ] >>> all_pairs_shortest_path(T, cases) [ [ [0, -1, -1], [-1, 0, -1], [-1, -1, 0] ] ]","solution":"def floyd_warshall(n, edges): Solves the all-pairs shortest path using Floyd-Warshall algorithm # Initialize the distance matrix with inf, and 0s on the diagonal dist = [[float('inf')] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 # Set initial distances based on the edge list for u, v in edges: dist[u-1][v-1] = 1 dist[v-1][u-1] = 1 # Apply Floyd-Warshall to find all shortest paths for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] # Convert inf back to -1 for no path result = [] for row in dist: result.append([d if d != float('inf') else -1 for d in row]) return result def all_pairs_shortest_path(T, cases): Process multiple test cases for the all-pairs shortest path problem outputs = [] for case in cases: n, m, edges = case result = floyd_warshall(n, edges) outputs.append(result) return outputs"},{"question":"class VendingMachine: def __init__(self, products): Initializes the VendingMachine with the given products. Arguments: products -- A dictionary of products with product code as key and a dictionary containing name, price, and quantity as value. self.products = products self.current_selection = None self.total_inserted = 0.0 self.total_money = 0.0 def display_products(self): Displays the available products along with their prices and quantities. def select_product(self, code): Allows a user to select a product by entering its product code. Arguments: code -- The product code of the selected product. def insert_money(self, amount): Handles the money insertion process. Arguments: amount -- The amount of money inserted by the user. def dispense_product(self): Dispenses the selected product if enough money has been inserted, adjusts the stock quantity, and returns any change. def refund(self): Handles the refund process and returns the inserted money to the user. # Example products products = { \\"A1\\": {\\"name\\": \\"Soda\\", \\"price\\": 1.25, \\"quantity\\": 10}, \\"A2\\": {\\"name\\": \\"Chips\\", \\"price\\": 0.75, \\"quantity\\": 5}, \\"A3\\": {\\"name\\": \\"Candy\\", \\"price\\": 0.65, \\"quantity\\": 8} } # Usage example: vm = VendingMachine(products) vm.display_products() vm.select_product(\\"A1\\") vm.insert_money(1.00) vm.insert_money(0.50) # Unit test example: from solution import VendingMachine, products def test_display_products(capfd): vm = VendingMachine(products) vm.display_products() captured = capfd.readouterr() assert \\"Products available:\\" in captured.out assert \\"Code: A1, Name: Soda, Price: 1.25, Quantity: 10\\" in captured.out assert \\"Code: A2, Name: Chips, Price: 0.75, Quantity: 5\\" in captured.out assert \\"Code: A3, Name: Candy, Price: 0.65, Quantity: 8\\" in captured.out def test_select_product(): vm = VendingMachine(products) vm.select_product(\\"A1\\") assert vm.current_selection == \\"A1\\" vm.select_product(\\"A4\\") assert vm.current_selection == \\"A1\\" # Previous selection should remain on invalid code def test_insert_money(capfd): vm = VendingMachine(products) vm.select_product(\\"A1\\") vm.insert_money(1.00) captured = capfd.readouterr() assert \\"Inserted 1.00. Total inserted: 1.00\\" in captured.out def test_dispense_product(capfd): vm = VendingMachine(products) vm.select_product(\\"A1\\") vm.insert_money(1.00) vm.insert_money(0.50) captured = capfd.readouterr() assert \\"Dispensing product: Soda. Returning change: 0.25\\" in captured.out assert vm.products[\\"A1\\"][\\"quantity\\"] == 9 assert vm.total_inserted == 0.0 def test_incomplete_payment(capfd): vm = VendingMachine(products) vm.select_product(\\"A1\\") vm.insert_money(1.00) captured = capfd.readouterr() assert \\"Inserted money is less than the product price. Insert more money.\\" in captured.out def test_out_of_stock_notification(capfd): vm = VendingMachine(products) vm.products[\\"A2\\"][\\"quantity\\"] = 0 vm.select_product(\\"A2\\") captured = capfd.readouterr() assert \\"Sorry, Chips is out of stock.\\" in captured.out def test_refund(capfd): vm = VendingMachine(products) vm.select_product(\\"A1\\") vm.insert_money(1.00) vm.refund() captured = capfd.readouterr() assert \\"Refunding 1.00\\" in captured.out assert vm.total_inserted == 0.0","solution":"class VendingMachine: def __init__(self, products): self.products = products self.current_selection = None self.total_inserted = 0.0 self.total_money = 0.0 def display_products(self): print(\\"Products available:\\") for code, details in self.products.items(): print(f\\"Code: {code}, Name: {details['name']}, Price: {details['price']:.2f}, Quantity: {details['quantity']}\\") def select_product(self, code): if code in self.products: self.current_selection = code product = self.products[code] if product['quantity'] > 0: print(f\\"Selected product: {product['name']}. Price: {product['price']:.2f}\\") else: print(f\\"Sorry, {product['name']} is out of stock.\\") self.current_selection = None else: print(\\"Invalid product code.\\") def insert_money(self, amount): if self.current_selection: self.total_inserted += amount print(f\\"Inserted {amount:.2f}. Total inserted: {self.total_inserted:.2f}\\") self.dispense_product() def dispense_product(self): if self.current_selection: product = self.products[self.current_selection] if self.total_inserted >= product['price']: change = self.total_inserted - product['price'] product['quantity'] -= 1 self.total_money += product['price'] print(f\\"Dispensing product: {product['name']}. Returning change: {change:.2f}\\") self.total_inserted = 0.0 self.current_selection = None else: print(f\\"Inserted money is less than the product price. Insert more money.\\") def refund(self): if self.total_inserted > 0: print(f\\"Refunding {self.total_inserted:.2f}\\") self.total_inserted = 0.0 # Example products products = { \\"A1\\": {\\"name\\": \\"Soda\\", \\"price\\": 1.25, \\"quantity\\": 10}, \\"A2\\": {\\"name\\": \\"Chips\\", \\"price\\": 0.75, \\"quantity\\": 5}, \\"A3\\": {\\"name\\": \\"Candy\\", \\"price\\": 0.65, \\"quantity\\": 8} }"},{"question":"def find_number_of_lis(nums: List[int]) -> int: Given an array of integers nums, return the number of unique longest increasing subsequences. >>> find_number_of_lis([1, 3, 5, 4, 7]) 2 >>> find_number_of_lis([2, 2, 2, 2, 2]) 5 >>> find_number_of_lis([5, 4, 3, 2, 1]) 5 >>> find_number_of_lis([1, 2, 4, 3, 5, 4, 7, 2]) 3 >>> find_number_of_lis([10]) 1 >>> find_number_of_lis([]) 0 >>> find_number_of_lis([0, 0, 0, 0, 0]) 5","solution":"def find_number_of_lis(nums): if not nums: return 0 n = len(nums) lengths = [1] * n # lengths[i] = length of longest ending in nums[i] counts = [1] * n # counts[i] = number of longest ending in nums[i] for i in range(n): for j in range(i): if nums[i] > nums[j]: if lengths[i] == lengths[j] + 1: counts[i] += counts[j] if lengths[i] < lengths[j] + 1: lengths[i] = lengths[j] + 1 counts[i] = counts[j] longest = max(lengths) return sum(c for l, c in zip(lengths, counts) if l == longest)"},{"question":"class ArrayProcessor: def __init__(self, N, A): Initialize the array processor with the specified array. self.N = N self.A = A def update(self, i, v): Update the element at index i to value v. # Implementation goes here def sum_range(self, l, r): Calculate and return the sum of elements from index l to r inclusive. # Implementation goes here def process_queries(N, Q, A, queries): Process the list of queries on array A. :param N: Integer, the size of the array :param Q: Integer, the number of queries :param A: List of integers, the initial array :param queries: List of queries to be processed :return: List of results from sum queries processor = ArrayProcessor(N, A) results = [] for query in queries: if query[0] == 1: # Update query _, i, v = query processor.update(i, v) elif query[0] == 2: # Sum query _, l, r = query results.append(processor.sum_range(l, r)) return results if __name__ == \\"__main__\\": # Example Usage N, Q = 5, 4 A = [1, 2, 3, 4, 5] queries = [ [2, 1, 3], [1, 2, 10], [2, 2, 5], [2, 1, 5], ] print(process_queries(N, Q, A, queries)) # Output: [6, 22, 23] # Unit Tests def test_example_case(): N, Q = 5, 4 A = [1, 2, 3, 4, 5] queries = [ [2, 1, 3], [1, 2, 10], [2, 2, 5], [2, 1, 5], ] assert process_queries(N, Q, A, queries) == [6, 22, 23] def test_single_update_single_sum(): N, Q = 3, 2 A = [4, 5, 6] queries = [ [1, 2, 10], [2, 1, 3] ] assert process_queries(N, Q, A, queries) == [20] def test_multiple_updates(): N, Q = 3, 4 A = [4, 5, 6] queries = [ [1, 1, 7], [1, 3, 8], [2, 1, 3], [2, 2, 3], ] assert process_queries(N, Q, A, queries) == [20, 13] def test_no_updates_only_sums(): N, Q = 3, 2 A = [1, 2, 3] queries = [ [2, 1, 2], [2, 2, 3], ] assert process_queries(N, Q, A, queries) == [3, 5] def test_no_sums_only_updates(): N, Q = 3, 2 A = [1, 2, 3] queries = [ [1, 1, 5], [1, 3, 7], ] assert process_queries(N, Q, A, queries) == [] def test_large_values(): N = 5 Q = 4 A = [1000000000, 1000000000, 1000000000, 1000000000, 1000000000] queries = [ [2, 1, 5], [1, 1, 999999999], [2, 1, 5], [1, 5, 1], ] assert process_queries(N, Q, A, queries) == [5000000000, 4999999999] test_example_case() test_single_update_single_sum() test_multiple_updates() test_no_updates_only_sums() test_no_sums_only_updates() test_large_values()","solution":"class ArrayProcessor: def __init__(self, N, A): self.N = N self.A = A def update(self, i, v): self.A[i-1] = v def sum_range(self, l, r): return sum(self.A[l-1:r]) def process_queries(N, Q, A, queries): processor = ArrayProcessor(N, A) results = [] for query in queries: if query[0] == 1: # Update query _, i, v = query processor.update(i, v) elif query[0] == 2: # Sum query _, l, r = query results.append(processor.sum_range(l, r)) return results"},{"question":"import random def simulate_roll(s: str, n: int) -> str: Simulates the rolling of a die with n faces and replaces each digit in s with the result of a roll. The digits in the string range from '1' to '9'. Only replace those digits that are ≤ n. Parameters: s (str): Input string containing digits and letters. n (int): Number of faces on the die. Returns: str: The string with digits replaced by the result of the roll. pass def test_simulate_roll(): random.seed(0) # Set seed for reproducibility result = simulate_roll(\\"hello1world2\\", 3) assert result.startswith(\\"hello\\") and result.endswith(\\"world2\\") # Check fixed part assert result[5].isdigit() and int(result[5]) in range(1, 4) # Check the replaced digit within 1-3 range result = simulate_roll(\\"number5here6\\", 5) assert result[6] in '12345' assert result[11] == '6' # Not to be changed as it's greater than n result = simulate_roll(\\"test9ing3\\", 4) assert result[4] == '9' # Not to be changed as it's greater than n assert result[4] == '9' # Not to be changed as it's greater than n def test_no_digits(): assert simulate_roll(\\"helloworld\\", 6) == \\"helloworld\\" def test_only_large_digits(): assert simulate_roll(\\"789\\", 3) == \\"789\\" def test_replacement_on_same_faced_die(): random.seed(5) # Set seed for reproducibility result = simulate_roll(\\"123\\", 3) # This should replace all digits assert all(ch in '123' for ch in result) def test_replacement_if_no_valid_digits(): assert simulate_roll(\\"abc4def\\", 3) == \\"abc4def\\" # No replacement since n = 3, digit '4' is not valid to replace","solution":"import random def simulate_roll(s: str, n: int) -> str: Simulates the rolling of a die with n faces and replaces each digit in s with the result of a roll. The digits in the string range from '1' to '9'. Only replace those digits that are ≤ n. Parameters: s (str): Input string containing digits and letters. n (int): Number of faces on the die. Returns: str: The string with digits replaced by the result of the roll. result = [] for char in s: if char.isdigit() and int(char) <= n: result.append(str(random.randint(1, n))) else: result.append(char) return ''.join(result)"},{"question":"def longest_unique_substring(s: str) -> str: Write a function that takes a string as input and returns the longest substring without repeating characters. If there are multiple longest substrings of the same length, return the one that appears first. Ensure the function runs efficiently with a time complexity of O(n), where n is the length of the input string. >>> longest_unique_substring(\\"abcabcbb\\") == \\"abc\\" >>> longest_unique_substring(\\"abcdef\\") == \\"abcdef\\" >>> longest_unique_substring(\\"bbbbb\\") == \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") == \\"wke\\" >>> longest_unique_substring(\\"a!@#aaaa\\") == \\"a!@#\\" >>> longest_unique_substring(\\"\\") == \\"\\" >>> longest_unique_substring(\\"a\\") == \\"a\\" >>> longest_unique_substring(\\"au\\") == \\"au\\" >>> longest_unique_substring(\\"aa\\") == \\"a\\"","solution":"def longest_unique_substring(s): Returns the longest substring without repeating characters. char_index_map = {} longest_start = 0 longest_length = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i current_length = i - start + 1 if current_length > longest_length: longest_length = current_length longest_start = start return s[longest_start:longest_start + longest_length]"},{"question":"def smallest_m_with_last_digit_1(n: int) -> int: Given a positive integer n, finds the smallest positive integer m such that the last digit of n^m is 1. If no such m exists, returns None. >>> smallest_m_with_last_digit_1(2) is None True >>> smallest_m_with_last_digit_1(9) == 2 True >>> smallest_m_with_last_digit_1(1) == 1 True >>> smallest_m_with_last_digit_1(3) == 4 True >>> smallest_m_with_last_digit_1(7) == 4 True >>> smallest_m_with_last_digit_1(10) is None True >>> smallest_m_with_last_digit_1(5) is None True","solution":"def smallest_m_with_last_digit_1(n): Given a positive integer n, finds the smallest positive integer m such that the last digit of n^m is 1. If no such m exists, returns None. # Function to get the last digit of a number def last_digit(num): return num % 10 target_last_digit = 1 for m in range(1, 11): # Check for the first 10 powers, there will be a cycle if it exists if last_digit(n ** m) == target_last_digit: return m return None"},{"question":"def palindromic_primes(n): Generates a list of the first n prime numbers that are also palindromes. >>> palindromic_primes(2) [2, 3] >>> palindromic_primes(5) [2, 3, 5, 7, 11] >>> palindromic_primes(7) [2, 3, 5, 7, 11, 101, 131] >>> palindromic_primes(10) [2, 3, 5, 7, 11, 101, 131, 151, 181, 191] >>> palindromic_primes(15) [2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727]","solution":"def palindromic_primes(n): Generates a list of first n prime numbers that are also palindromes. def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def is_palindrome(num): Helper function to check if a number is a palindrome. return str(num) == str(num)[::-1] primes = [] count = 0 while len(primes) < n: if is_prime(count) and is_palindrome(count): primes.append(count) count += 1 return primes"},{"question":"class Book: def __init__(self, title, author, year): self.title = title self.author = author self.year = year def __repr__(self): return f\\"Title: {self.title}, Author: {self.author}, Year: {self.year}\\" class Library: def __init__(self): self.books = {} def add_book(self, title, author, year): Adds a new book to the collection. pass def remove_book(self, title): Removes the book with the specified title from the collection. pass def search_book(self, title): Searches for a book with the specified title and returns its details. The details should be in the format \\"Title: [title], Author: [author], Year: [year]\\". If the book is not found, return \\"Book not found\\". pass def list_books(self): Lists all books in the collection sorted by title. If there are no books, return \\"No books in the collection\\". pass import pytest @pytest.fixture def setup_library(): library = Library() library.add_book(\\"The Alchemist\\", \\"Paulo Coelho\\", 1988) library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) return library def test_add_book(): library = Library() library.add_book(\\"The Alchemist\\", \\"Paulo Coelho\\", 1988) assert \\"The Alchemist\\" in library.books assert library.books[\\"The Alchemist\\"].title == \\"The Alchemist\\" assert library.books[\\"The Alchemist\\"].author == \\"Paulo Coelho\\" assert library.books[\\"The Alchemist\\"].year == 1988 def test_remove_book(): library = Library() library.add_book(\\"The Alchemist\\", \\"Paulo Coelho\\", 1988) library.remove_book(\\"The Alchemist\\") assert \\"The Alchemist\\" not in library.books def test_search_for_existing_book(): library = Library() library.add_book(\\"The Alchemist\\", \\"Paulo Coelho\\", 1988) assert library.search_book(\\"The Alchemist\\") == \\"Title: The Alchemist, Author: Paulo Coelho, Year: 1988\\" def test_search_for_non_existing_book(): library = Library() assert library.search_book(\\"Non Existing Book\\") == \\"Book not found\\" def test_list_books(): library = Library() library.add_book(\\"The Alchemist\\", \\"Paulo Coelho\\", 1988) library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) expected_output = \\"n\\".join([ \\"Title: The Alchemist, Author: Paulo Coelho, Year: 1988\\", \\"Title: To Kill a Mockingbird, Author: Harper Lee, Year: 1960\\", ]) assert library.list_books() == expected_output def test_list_books_empty(): library = Library() assert library.list_books() == \\"No books in the collection\\" def test_add_remove_search_list(setup_library): library = setup_library # Test SEARCH assert library.search_book(\\"The Alchemist\\") == \\"Title: The Alchemist, Author: Paulo Coelho, Year: 1988\\" # Test REMOVE library.remove_book(\\"To Kill a Mockingbird\\") assert library.search_book(\\"To Kill a Mockingbird\\") == \\"Book not found\\" # Test SEARCH after REMOVE assert library.search_book(\\"The Alchemist\\") == \\"Title: The Alchemist, Author: Paulo Coelho, Year: 1988\\" # Test LIST after REMOVE assert library.list_books() == \\"Title: The Alchemist, Author: Paulo Coelho, Year: 1988\\" # Remove the remaining book and check LIST library.remove_book(\\"The Alchemist\\") assert library.search_book(\\"The Alchemist\\") == \\"Book not found\\" assert library.list_books() == \\"No books in the collection\\"","solution":"class Book: def __init__(self, title, author, year): self.title = title self.author = author self.year = year def __repr__(self): return f\\"Title: {self.title}, Author: {self.author}, Year: {self.year}\\" class Library: def __init__(self): self.books = {} def add_book(self, title, author, year): book = Book(title, author, year) self.books[title] = book def remove_book(self, title): if title in self.books: del self.books[title] def search_book(self, title): if title in self.books: return str(self.books[title]) return \\"Book not found\\" def list_books(self): if not self.books: return \\"No books in the collection\\" sorted_books = sorted(self.books.values(), key=lambda book: book.title) return \\"n\\".join(str(book) for book in sorted_books)"},{"question":"def even_odd_difference(arr): Calculates and returns the absolute difference between the sum of the even numbers and the sum of the odd numbers in the array. Returns 0 if the array is empty. >>> even_odd_difference([]) == 0 >>> even_odd_difference([2, 4, 6, 8]) == 20 >>> even_odd_difference([1, 3, 5, 7]) == 16 >>> even_odd_difference([1, 2, 3, 4, 5, 6]) == 3 >>> even_odd_difference([10]) == 10 >>> even_odd_difference([7]) == 7 >>> even_odd_difference([0, 1, 2, 3, 4]) == 2 >>> even_odd_difference([-1, -2, -3, -4]) == 2","solution":"def even_odd_difference(arr): Returns the absolute difference between the sum of the even numbers and the sum of the odd numbers in the array. Returns 0 if the array is empty. if not arr: return 0 even_sum = sum(x for x in arr if x % 2 == 0) odd_sum = sum(x for x in arr if x % 2 != 0) return abs(even_sum - odd_sum)"},{"question":"def can_partition_k_subsets(nums: List[int], k: int) -> bool: You are given an array of integers \`nums\` and an integer \`k\`. You need to partition the array into exactly \`k\` non-empty subsets whose sums are all equal. Return true if and only if you can achieve this partition. Example 1: >>> can_partition_k_subsets([4, 3, 2, 3, 5, 2, 1], 4) True Example 2: >>> can_partition_k_subsets([1, 2, 3, 4], 3) False Constraints: 1 <= k <= len(nums) <= 16 0 < nums[i] <= 10000","solution":"def can_partition_k_subsets(nums, k): if k == 0 or sum(nums) % k != 0: return False target_sum = sum(nums) // k nums.sort(reverse=True) subset_sums = [0] * k def backtrack(index): if index == len(nums): return len(set(subset_sums)) == 1 for i in range(k): if subset_sums[i] + nums[index] <= target_sum: subset_sums[i] += nums[index] if backtrack(index + 1): return True subset_sums[i] -= nums[index] if subset_sums[i] == 0: break return False return backtrack(0)"},{"question":"def reverse_words(s: str) -> str: This function takes a string as input and returns a string with the words reversed, trimmed of any leading or trailing spaces, and with single spaces between words. >>> reverse_words(\\"the sky is blue\\") == \\"blue is sky the\\" >>> reverse_words(\\" hello world! \\") == \\"world! hello\\" >>> reverse_words(\\"a good example\\") == \\"example good a\\" >>> reverse_words(\\" Bob Loves Alice \\") == \\"Alice Loves Bob\\" >>> reverse_words(\\"Alice does not even like bob\\") == \\"bob like even not does Alice\\"","solution":"def reverse_words(s: str) -> str: This function takes a string as input and returns a string with the words reversed, trimmed of any leading or trailing spaces, and with single spaces between words. words = s.split() reversed_words = words[::-1] return ' '.join(reversed_words) # Example usage: # Input: \\" hello world! \\" # Output: \\"world! hello\\" # print(reverse_words(\\" hello world! \\")) # Output: \\"world! hello\\""},{"question":"import math from typing import List, Tuple def simplify_fraction(numerator: int, denominator: int) -> Tuple[int, int]: Simplify a fraction to its simplest form. >>> simplify_fraction(4, 8) (1, 2) >>> simplify_fraction(50, 100) (1, 2) def reduce_fractions(fractions: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Reduce a list of fractions to their simplest forms. >>> reduce_fractions([(4, 8), (50, 100), (7, 5)]) [(1, 2), (1, 2), (7, 5)] >>> reduce_fractions([(15, 25), (22, 11)]) [(3, 5), (2, 1)]","solution":"import math def simplify_fraction(numerator, denominator): gcd = math.gcd(numerator, denominator) return (numerator // gcd, denominator // gcd) def reduce_fractions(fractions): simplified_fractions = [] for numerator, denominator in fractions: simplified_fractions.append(simplify_fraction(numerator, denominator)) return simplified_fractions"},{"question":"def majority_element(nums: List[int]) -> int: Returns the majority element in an array of size N if it exists, otherwise returns -1. A majority element is an element that appears more than N/2 times. >>> majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> majority_element([3, 3, 4, 2, 4, 4, 2, 4]) -1 >>> majority_element([]) -1 >>> majority_element([1]) 1 >>> majority_element([2, 2]) 2 >>> majority_element([1, 2]) -1 >>> majority_element([9, 9, 9, 9, 9]) 9 >>> majority_element([1, 2, 1, 2, 1]) 1","solution":"def majority_element(nums): Returns the majority element if it exists, otherwise returns -1. count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) # Verify that the candidate is actually a majority element if nums.count(candidate) > len(nums) // 2: return candidate else: return -1"},{"question":"def transform_to_frequency_dict(s: str) -> dict: Transform a given string into a frequency dictionary where the keys are the characters and the values are the number of times each character appears in the string. Ignore non-alphabet characters and treat uppercase and lowercase letters as the same. Args: s (str): The input string. Returns: dict: A dictionary with characters as keys and their frequency as values. Examples: >>> transform_to_frequency_dict(\\"Hello, World!\\") {\\"h\\": 1, \\"e\\": 1, \\"l\\": 3, \\"o\\": 2, \\"w\\": 1, \\"r\\": 1, \\"d\\": 1} >>> transform_to_frequency_dict(\\"123 ABC abc!!!\\") {\\"a\\": 2, \\"b\\": 2, \\"c\\": 2} >>> transform_to_frequency_dict(\\"\\") {} >>> transform_to_frequency_dict(\\"AaAa\\") {\\"a\\": 4} pass def test_transform_to_frequency_dict_with_mixed_characters(): result = transform_to_frequency_dict(\\"Hello, World!\\") expected = {\\"h\\": 1, \\"e\\": 1, \\"l\\": 3, \\"o\\": 2, \\"w\\": 1, \\"r\\": 1, \\"d\\": 1} assert result == expected def test_transform_to_frequency_dict_with_digits_and_special_characters(): result = transform_to_frequency_dict(\\"123 ABC abc!!!\\") expected = {\\"a\\": 2, \\"b\\": 2, \\"c\\": 2} assert result == expected def test_transform_to_frequency_dict_empty_string(): result = transform_to_frequency_dict(\\"\\") expected = {} assert result == expected def test_transform_to_frequency_dict_all_same_case(): result = transform_to_frequency_dict(\\"AaAa\\") expected = {\\"a\\": 4} assert result == expected def test_transform_to_frequency_dict_uppercase_characters(): result = transform_to_frequency_dict(\\"XYZ XYZ\\") expected = {\\"x\\": 2, \\"y\\": 2, \\"z\\": 2} assert result == expected def test_transform_to_frequency_dict_mixed_case_characters(): result = transform_to_frequency_dict(\\"aAbBcCdD\\") expected = {\\"a\\": 2, \\"b\\": 2, \\"c\\": 2, \\"d\\": 2} assert result == expected def test_transform_to_frequency_dict_with_only_spaces(): result = transform_to_frequency_dict(\\" \\") expected = {} assert result == expected def test_transform_to_frequency_dict_mixed_characters_large_string(): result = transform_to_frequency_dict(\\"The quick brown fox jumps over the lazy dog\\") expected = { \\"t\\": 2, \\"h\\": 2, \\"e\\": 3, \\"q\\": 1, \\"u\\": 2, \\"i\\": 1, \\"c\\": 1, \\"k\\": 1, \\"b\\": 1, \\"r\\": 2, \\"o\\": 4, \\"w\\": 1, \\"n\\": 1, \\"f\\": 1, \\"x\\": 1, \\"j\\": 1, \\"m\\": 1, \\"p\\": 1, \\"s\\": 1, \\"v\\": 1, \\"l\\": 1, \\"a\\": 1, \\"z\\": 1, \\"y\\": 1, \\"d\\": 1, \\"g\\": 1 } assert result == expected","solution":"def transform_to_frequency_dict(s: str) -> dict: Returns a dictionary with characters as keys and their frequency as values. Only alphabet characters are considered, and it is case-insensitive. freq_dict = {} for char in s.lower(): if char.isalpha(): if char in freq_dict: freq_dict[char] += 1 else: freq_dict[char] = 1 return freq_dict"},{"question":"def findUniqueIntegers(nums: List[int]) -> List[int]: Create a function that takes a list of integers and returns a new list containing only the unique integers from the original list, in the order they first appeared. An integer is considered unique if it appears exactly once in the input list. Parameters: nums (list of int): The list of integers to process. Returns: list of int: A list of unique integers. >>> findUniqueIntegers([1, 2, 2, 3, 4, 4, 5]) == [1, 3, 5] >>> findUniqueIntegers([4, 5, 6, 7, 8, 8, 9, 9]) == [4, 5, 6, 7] >>> findUniqueIntegers([10, 10, 10, 11, 12]) == [11, 12] >>> findUniqueIntegers([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> findUniqueIntegers([]) == [] >>> findUniqueIntegers([1, 1, 2, 2, 3, 3]) == [] >>> findUniqueIntegers([1]) == [1] >>> findUniqueIntegers([1, 2, 3, 2, 1, 3, 4, 5, 6, 4, 7, 6, 8, 9, 8, 9]) == [5, 7]","solution":"def findUniqueIntegers(nums): Returns a list containing the unique integers from the input list \`nums\`, in the order they first appeared. An integer is considered unique if it appears exactly once in the input list. Parameters: nums (list of int): The list of integers to process. Returns: list of int: A list of unique integers. from collections import Counter count = Counter(nums) unique_integers = [num for num in nums if count[num] == 1] return unique_integers"},{"question":"def minimize_difference(books: List[int]) -> int: Given a list of integers representing the number of pages in each book in a collection, distribute these books into two piles such that the difference between the total number of pages in the two piles is minimized. >>> minimize_difference([10, 20, 15, 5, 25]) 5 >>> minimize_difference([10]) 10 >>> minimize_difference([10, 10]) 0 >>> minimize_difference([10, 20]) 10 >>> minimize_difference([]) 0 >>> minimize_difference([5, 5, 10, 10, 15, 20]) 5 >>> minimize_difference([5, 5, 5, 5]) 0","solution":"def minimize_difference(books): total_pages = sum(books) n = len(books) half_total = total_pages // 2 # Create a DP array to store results of subproblems dp = [[False] * (half_total + 1) for _ in range(n + 1)] dp[0][0] = True # Fill the DP table for i in range(1, n + 1): for j in range(half_total + 1): if j >= books[i-1]: dp[i][j] = dp[i-1][j] or dp[i-1][j-books[i-1]] else: dp[i][j] = dp[i-1][j] # Find the difference closest to half_total for j in range(half_total, -1, -1): if dp[n][j]: pile1 = j break pile2 = total_pages - pile1 return abs(pile1 - pile2)"},{"question":"def find_missing_number(nums: List[int]) -> int: Find the missing number in the list. >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0, 1]) 2 >>> find_missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) 8 pass","solution":"def find_missing_number(nums): Finds the missing number in the list. :param nums: List[int] - list of integers in the range from 0 to n with one integer missing :return: int - the missing integer n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"from typing import List, Tuple def count_words(input_string: str) -> List[Tuple[str, int]]: Counts the occurrence of unique words in a given string and returns a list of tuples where each tuple contains a word and its count. Words are considered case-insensitive. Numeric strings and special characters are ignored in counting. The list is sorted by words in ascending order. >>> count_words(\\"Hello, world! This is a test. This test is easy.\\") [('a', 1), ('easy', 1), ('hello', 1), ('is', 2), ('test', 2), ('this', 2), ('world', 1)] >>> count_words(\\"Chat GPT can write code, and write it well.\\") [('and', 1), ('can', 1), ('chat', 1), ('code', 1), ('gpt', 1), ('it', 1), ('well', 1), ('write', 2)] >>> count_words(\\"Numbers like 123, 456, and 789 should be ignored in the count.\\") [('and', 1), ('be', 1), ('count', 1), ('ignored', 1), ('in', 1), ('like', 1), ('numbers', 1), ('should', 1), ('the', 1)] >>> count_words(\\"\\") [] >>> count_words(\\"123 456 789 @#%^&*()\\") [] >>> count_words(\\"This is a Test. This is only a Test!\\") [('a', 2), ('is', 2), ('only', 1), ('test', 2), ('this', 2)]","solution":"import re from typing import List, Tuple def count_words(input_string: str) -> List[Tuple[str, int]]: Counts the occurrence of unique words in a given string and returns a list of tuples where each tuple contains a word and its count. Words are considered case-insensitive. Numeric strings and special characters are ignored in counting. The list is sorted by words in ascending order. # Convert the string to lowercase input_string = input_string.lower() # Remove all special characters except for alphanumerics and spaces words = re.findall(r'b[a-z]+b', input_string) # Count words word_count = {} for word in words: if word.isalpha(): word_count[word] = word_count.get(word, 0) + 1 # Convert the dictionary to a sorted list of tuples sorted_word_counts = sorted(word_count.items()) return sorted_word_counts"},{"question":"def vending_machine(item, money): Simulate a vending machine operation. - Takes the selected item and the amount of money inserted. - Outputs the change returned to the user and updates the item stock in the vending machine. The vending machine starts with the following initial stock and prices: - stock = {'A1': 5, 'A2': 3, 'B1': 2, 'B2': 0} - prices = {'A1': 1.25, 'A2': 0.75, 'B1': 1.50, 'B2': 2.00} - If the requested item is out of stock, returns a message and all inserted money. - If the user inserts insufficient money, returns a message and all inserted money. - If the user inserts more than the required amount, returns the exact change. - Updates the stock quantities after a successful transaction. stock = {'A1': 5, 'A2': 3, 'B1': 2, 'B2': 0} prices = {'A1': 1.25, 'A2': 0.75, 'B1': 1.50, 'B2': 2.00} # Your code here from solution import vending_machine def test_vending_machine_successful_purchase(): result, updated_stock = vending_machine('A1', 2.00) assert result == \\"Change: 0.75\\" assert updated_stock == {'A1': 4, 'A2': 3, 'B1': 2, 'B2': 0} def test_vending_machine_out_of_stock(): result, updated_stock = vending_machine('B2', 2.00) assert result == \\"Item B2 is out of stock. Returned money: 2.00\\" assert updated_stock == {'A1': 5, 'A2': 3, 'B1': 2, 'B2': 0} def test_vending_machine_insufficient_money(): result, updated_stock = vending_machine('B1', 1.00) assert result == \\"Insufficient money. Returned money: 1.00\\" assert updated_stock == {'A1': 5, 'A2': 3, 'B1': 2, 'B2': 0} def test_vending_machine_successful_exact_amount(): result, updated_stock = vending_machine('A2', 0.75) assert result == \\"Change: 0.00\\" assert updated_stock == {'A1': 5, 'A2': 2, 'B1': 2, 'B2': 0} def test_vending_machine_item_does_not_exist(): result, updated_stock = vending_machine('C1', 2.00) assert result == \\"Item C1 does not exist. Returned money: 2.00\\" assert updated_stock == {'A1': 5, 'A2': 3, 'B1': 2, 'B2': 0}","solution":"def vending_machine(item, money): stock = {'A1': 5, 'A2': 3, 'B1': 2, 'B2': 0} prices = {'A1': 1.25, 'A2': 0.75, 'B1': 1.50, 'B2': 2.00} if item not in stock: return f\\"Item {item} does not exist. Returned money: {money:.2f}\\", stock if stock[item] == 0: return f\\"Item {item} is out of stock. Returned money: {money:.2f}\\", stock price = prices[item] if money < price: return f\\"Insufficient money. Returned money: {money:.2f}\\", stock change = money - price stock[item] -= 1 return f\\"Change: {change:.2f}\\", stock"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Determines if it is possible to rearrange the characters of the string to form a palindrome. >>> can_form_palindrome(\\"aabb\\") == True >>> can_form_palindrome(\\"racecar\\") == True >>> can_form_palindrome(\\"abc\\") == False pass def solve_palindrome_problem(test_cases: List[str]) -> List[str]: Processes multiple test cases and determines if each string can be rearranged to form a palindrome. >>> solve_palindrome_problem([\\"aabb\\", \\"racecar\\", \\"abc\\"]) == [\\"Yes\\", \\"Yes\\", \\"No\\"] >>> solve_palindrome_problem([\\"a\\", \\"ab\\", \\"aa\\", \\"bb\\"]) == [\\"Yes\\", \\"No\\", \\"Yes\\", \\"Yes\\"] pass","solution":"def can_form_palindrome(s): Determines if it is possible to rearrange the characters of the string to form a palindrome. from collections import Counter freq = Counter(s) odd_count = sum(1 for count in freq.values() if count % 2 != 0) return odd_count <= 1 def solve_palindrome_problem(test_cases): Processes multiple test cases and determines if each string can be rearranged to form a palindrome. results = [] for s in test_cases: if can_form_palindrome(s): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def square_elements(lst: List[int]) -> List[int]: Returns a new list with each integer squared, preserving the original order. Parameters: lst (list): List of integers. Returns: list: A new list with each integer in lst squared. Example: >>> square_elements([1, 2, 3, -4]) [1, 4, 9, 16] >>> square_elements([-1, 2, -3, 4]) [1, 4, 9, 16]","solution":"def square_elements(lst): Returns a new list with each element squared. Parameters: lst (list): List of integers. Returns: list: A new list with each element in lst squared. return [x**2 for x in lst]"},{"question":"def squared_list(lst: List[int]) -> List[int]: Returns a new list with the squares of each value in the input list in non-decreasing order. >>> squared_list([1, 2, 3, 4, 5]) == [1, 4, 9, 16, 25] >>> squared_list([-5, -3, 0, 2, 4]) == [0, 4, 9, 16, 25] >>> squared_list([3, -1, 0, -2, 4]) == [0, 1, 4, 9, 16]","solution":"def squared_list(lst): Returns a new list with the squares of each value in the input list in non-decreasing order. squared = [x ** 2 for x in lst] return sorted(squared)"},{"question":"def max_calories(calories: List[int], k: int) -> int: Returns the maximum possible sum of calories over any contiguous subarray of length k. If k is greater than the length of the input list, returns 0. >>> max_calories([2, 1, 5, 1, 3, 2], 3) 9 >>> max_calories([2, 1, 5, 1, 3, 2], 7) 0 >>> max_calories([1, 2, 3, 4, 5], 2) 9","solution":"def max_calories(calories, k): Returns the maximum possible sum of calories over any contiguous subarray of length k. If k is greater than the length of the input list, returns 0. n = len(calories) if k > n: return 0 max_sum = sum(calories[:k]) current_sum = max_sum for i in range(k, n): current_sum = current_sum - calories[i - k] + calories[i] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def sort_students(students): Sort students by their grades in descending order. In case of tie, sort by names in ascending order. Args: students - list of tuples, where each tuple contains a student's name and grade Returns: sorted list of students >>> sort_students([(\\"James\\", 88), (\\"Alice\\", 72), (\\"David\\", 88), (\\"Bob\\", 85)]) [(\\"David\\", 88), (\\"James\\", 88), (\\"Bob\\", 85), (\\"Alice\\", 72)] >>> sort_students([(\\"James\\", 90), (\\"Alice\\", 90), (\\"David\\", 88), (\\"Bob\\", 85)]) [(\\"Alice\\", 90), (\\"James\\", 90), (\\"David\\", 88), (\\"Bob\\", 85)] >>> sort_students([(\\"James\\", 88)]) [(\\"James\\", 88)] >>> sort_students([(\\"James\\", 80), (\\"Alice\\", 80), (\\"David\\", 80), (\\"Bob\\", 80)]) [(\\"Alice\\", 80), (\\"Bob\\", 80), (\\"David\\", 80), (\\"James\\", 80)] >>> sort_students([(\\"James\\", 60), (\\"Alice\\", 85), (\\"David\\", 75), (\\"Bob\\", 90)]) [(\\"Bob\\", 90), (\\"Alice\\", 85), (\\"David\\", 75), (\\"James\\", 60)]","solution":"def sort_students(students): Sort students by their grades in descending order. In case of tie, sort by names in ascending order. Args: students - list of tuples, where each tuple contains a student's name and grade Returns: sorted list of students return sorted(students, key=lambda x: (-x[1], x[0]))"},{"question":"from typing import List, Union def filter_and_sort_leaves(n: int, widths: List[int], l1: int, l2: int) -> Union[List[int], str]: Filters and sorts leaf widths that fall within the inclusive range [l1, l2]. Parameters: n (int): The number of leaves. widths (list of int): The widths of the leaves. l1 (int): The lower bound of the width range. l2 (int): The upper bound of the width range. Returns: list of int or str: Sorted widths of the leaves within the range or \\"No leaves in range\\" if none are in the range. Examples: >>> filter_and_sort_leaves(5, [10, 23, 35, 12, 18], 10, 20) [10, 12, 18] >>> filter_and_sort_leaves(5, [21, 23, 35, 22, 28], 10, 20) \\"No leaves in range\\"","solution":"def filter_and_sort_leaves(n, widths, l1, l2): Filters and sorts leaf widths that fall within the inclusive range [l1, l2]. Parameters: n (int): The number of leaves. widths (list of int): The widths of the leaves. l1 (int): The lower bound of the width range. l2 (int): The upper bound of the width range. Returns: list of int or str: Sorted widths of the leaves within the range or \\"No leaves in range\\" if none are in the range. filtered_leaves = [width for width in widths if l1 <= width <= l2] if not filtered_leaves: return \\"No leaves in range\\" return sorted(filtered_leaves) # Example to test the function n = 5 widths = [10, 23, 35, 12, 18] l1 = 10 l2 = 20 print(filter_and_sort_leaves(n, widths, l1, l2)) # Output: [10, 12, 18]"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: You are given an array of integers and a target integer value. Your task is to find two distinct integers in the array that sum up to the target value and return their indices as a list. If no such integers exist, return an empty list. >>> two_sum([2, 7, 11, 15], 9) # returns [0, 1] >>> two_sum([3, 2, 4], 6) # returns [1, 2] >>> two_sum([3, 3], 6) # returns [0, 1] >>> two_sum([1, 2, 3], 7) # returns [] pass","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers that add up to the target. If no such pair exists, returns an empty list. num_to_index = {} for i, number in enumerate(nums): complement = target - number if complement in num_to_index: return [num_to_index[complement], i] num_to_index[number] = i return []"},{"question":"def is_valid_identifier(identifier: str) -> bool: Create a function that takes a string as input and checks if it is a valid identifier. A valid identifier meets the following criteria: 1. It must start with either a letter (a-z, A-Z) or an underscore (_). 2. The remaining characters can be letters, underscores, or digits (0-9). 3. The identifier length must be between 1 and 30 characters inclusive. Examples: >>> is_valid_identifier(\\"_variable1\\") True >>> is_valid_identifier(\\"var_123\\") True >>> is_valid_identifier(\\"a\\") True >>> is_valid_identifier(\\"myVariable\\") True >>> is_valid_identifier(\\"1variable\\") False >>> is_valid_identifier(\\"var!able\\") False >>> is_valid_identifier(\\"my variable\\") False >>> is_valid_identifier(\\"12345\\") False >>> is_valid_identifier(\\"\\") False >>> is_valid_identifier(\\"a\\" * 31) False","solution":"def is_valid_identifier(identifier): Checks if the input string is a valid identifier based on specific rules. if len(identifier) == 0 or len(identifier) > 30: return False if not (identifier[0].isalpha() or identifier[0] == '_'): return False if not all(char.isalnum() or char == '_' for char in identifier): return False return True"},{"question":"def first_missing_positive(nums: List[int]) -> int: Returns the smallest positive integer that is missing from the unsorted array. The function has a linear time complexity and uses constant extra space. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([7, 8, 9, 11, 12]) 1","solution":"def first_missing_positive(nums): Returns the smallest positive integer that is missing from the unsorted array. The function has a linear time complexity and uses constant extra space. n = len(nums) # Place each number in its right place. for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap nums[i] with nums[nums[i] - 1] nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Find the first missing positive number. for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def get_earliest_and_latest_dates(dates: List[str]) -> List[str]: Returns the earliest and latest dates from a list of dates in the format \\"YYYY-MM-DD\\". >>> get_earliest_and_latest_dates([\\"2023-12-01\\", \\"2022-05-06\\", \\"2024-07-11\\", \\"2021-09-23\\"]) [\\"2021-09-23\\", \\"2024-07-11\\"] >>> get_earliest_and_latest_dates([\\"2020-01-01\\", \\"2020-01-01\\"]) [\\"2020-01-01\\", \\"2020-01-01\\"]","solution":"def get_earliest_and_latest_dates(dates): Returns the earliest and latest dates from a list of dates in the format \\"YYYY-MM-DD\\". Arguments: dates -- list of dates in the format \\"YYYY-MM-DD\\" Returns: A list containing the earliest and latest dates in the format \\"YYYY-MM-DD\\". if not dates: return [] earliest_date = min(dates) latest_date = max(dates) return [earliest_date, latest_date]"},{"question":"def length_of_longest_unique_substring(s: str) -> int: Given a string s containing only lowercase letters, find the length of the longest substring with all unique characters. :param s: input string :return: length of the longest substring with all unique characters Examples: >>> length_of_longest_unique_substring(\\"ababcde\\") 5 >>> length_of_longest_unique_substring(\\"a\\") 1 >>> length_of_longest_unique_substring(\\"abcdef\\") 6 >>> length_of_longest_unique_substring(\\"aaaaaa\\") 1 >>> length_of_longest_unique_substring(\\"\\") 0 >>> length_of_longest_unique_substring(\\"aaaaaabcdef\\") 6 >>> length_of_longest_unique_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_unique_substring(s): Finds the length of the longest substring with all unique characters in a given string. :param s: input string :return: length of the longest substring with all unique characters char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"def fizz_buzz_custom(start: int, end: int, fizz_sub: str, buzz_sub: str, fizzbuzz_sub: str) -> None: Prints each number from start to end inclusive, replacing multiples of 3 with fizz_sub, multiples of 5 with buzz_sub, and multiples of both with fizzbuzz_sub. Args: - start: The starting number of the range. - end: The ending number of the range. - fizz_sub: The substitution string for multiples of 3. - buzz_sub: The substitution string for multiples of 5. - fizzbuzz_sub: The substitution string for multiples of both 3 and 5. >>> fizz_buzz_custom(1, 15, \\"Fizz\\", \\"Buzz\\", \\"FizzBuzz\\") 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz >>> fizz_buzz_custom(10, 20, \\"Foo\\", \\"Bar\\", \\"FooBar\\") Bar 11 Foo 13 14 FooBar 16 17 Foo 19 Bar >>> fizz_buzz_custom(5, 18, \\"Ping\\", \\"Pong\\", \\"PingPong\\") Pong Ping 7 8 Ping Pong 11 Ping 13 14 PingPong 16 17 Ping","solution":"def fizz_buzz_custom(start: int, end: int, fizz_sub: str, buzz_sub: str, fizzbuzz_sub: str) -> None: Prints each number from start to end inclusive, replacing multiples of 3 with fizz_sub, multiples of 5 with buzz_sub, and multiples of both with fizzbuzz_sub. Args: - start: The starting number of the range. - end: The ending number of the range. - fizz_sub: The substitution string for multiples of 3. - buzz_sub: The substitution string for multiples of 5. - fizzbuzz_sub: The substitution string for multiples of both 3 and 5. for i in range(start, end + 1): if i % 15 == 0: print(fizzbuzz_sub) elif i % 3 == 0: print(fizz_sub) elif i % 5 == 0: print(buzz_sub) else: print(i)"},{"question":"from typing import List, Dict def largest_area_in_gallery(test_cases: List[Dict[str, any]]) -> List[int]: Determine the maximum size of any empty rectangular area ('#' represents walls) in a 2D grid representing a museum floor plan. Args: test_cases (List[Dict[str, any]]): List of test case dictionaries, each containing: R (int): Number of rows in the grid. C (int): Number of columns in the grid. grid (List[str]): List of strings representing the grid, where each string is a row in the grid. Returns: List[int]: List of integers representing the area of the largest empty rectangular region for each test case. # Implementation here # Test cases for validation def test_given_examples(): test_cases = [ {'R': 4, 'C': 5, 'grid': [\\"#\\", \\"#...#\\", \\"#.#.#\\", \\"#\\"]}, {'R': 3, 'C': 4, 'grid': [\\".#..\\", \\"#..#\\", \\"....\\"]} ] assert largest_area_in_gallery(test_cases) == [3, 4] def test_single_row(): test_cases = [ {'R': 1, 'C': 5, 'grid': [\\".....\\"]} ] assert largest_area_in_gallery(test_cases) == [5] def test_single_column(): test_cases = [ {'R': 5, 'C': 1, 'grid': [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"]} ] assert largest_area_in_gallery(test_cases) == [5] def test_empty_grid(): test_cases = [ {'R': 0, 'C': 0, 'grid': []} ] assert largest_area_in_gallery(test_cases) == [0] def test_no_empty_cell(): test_cases = [ {'R': 4, 'C': 5, 'grid': [\\"#\\", \\"#\\", \\"#\\", \\"#\\"]} ] assert largest_area_in_gallery(test_cases) == [0] def test_large_grid(): test_cases = [ {'R': 6, 'C': 6, 'grid': [\\"......\\", \\"......\\", \\"......\\", \\"......\\", \\"......\\", \\"......\\"]} ] assert largest_area_in_gallery(test_cases) == [36]","solution":"def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 rows, cols = len(matrix), len(matrix[0]) heights = [0] * (cols + 1) for row in matrix: for i in range(cols): if row[i] == '.': heights[i] += 1 else: heights[i] = 0 stack = [-1] for i in range(cols + 1): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area def largest_area_in_gallery(test_cases): results = [] for t in test_cases: R, C, grid = t['R'], t['C'], t['grid'] max_area = maximalRectangle(grid) results.append(max_area) return results"},{"question":"def is_mountain_array(arr): Returns True if the given list of integers represents a mountain array, False otherwise. >>> is_mountain_array([2, 1]) == False >>> is_mountain_array([3, 5, 5]) == False >>> is_mountain_array([0, 3, 2, 1]) == True >>> is_mountain_array([0, 2, 3, 4, 5, 2, 1, 0]) == True >>> is_mountain_array([1, 2]) == False >>> is_mountain_array([1, 2, 3]) == False >>> is_mountain_array([3, 2, 1]) == False >>> is_mountain_array([1, 2, 0]) == True >>> is_mountain_array([2, 3, 4, 5, 4, 3, 2]) == True >>> is_mountain_array([9, 8, 7, 6, 5, 4, 3, 2, 1]) == False >>> is_mountain_array([0, 1, 2, 3, 0]) == True >>> is_mountain_array([0, 1, 0]) == True >>> is_mountain_array([0, 1, 2, 0, 2]) == False","solution":"def is_mountain_array(arr): Returns True if the given list of integers represents a mountain array, False otherwise. if len(arr) < 3: return False i = 1 # Walk up while i < len(arr) and arr[i] > arr[i - 1]: i += 1 # Peak can't be first or last if i == 1 or i == len(arr): return False # Walk down while i < len(arr) and arr[i] < arr[i - 1]: i += 1 return i == len(arr)"},{"question":"def calculate_points(results): Calculate the total points based on the match results. :param results: List of integers representing the match results (-1 for loss, 0 for draw, 1 for win) :return: Total points earned >>> calculate_points([1, 0, -1]) 4 >>> calculate_points([-1, -1, -1]) 0 pass def process_input(input_str): Process the input string and calculate points for each test case. :param input_str: A multiline string input as described in the problem statement :return: List of integers where each integer represents the total points for the respective test case >>> process_input(\\"3n3n1 0 -1n4n1 1 0 -1n2n-1 -1n\\") [4, 7, 0] >>> process_input(\\"1n5n1 1 1 1 1n\\") [15] >>> process_input(\\"1n1n-1n\\") [0] pass import pytest def test_calculate_points_all_draw(): assert calculate_points([0, 0, 0]) == 3 def test_calculate_points_mixed_results(): assert calculate_points([1, 0, -1]) == 4 def test_calculate_points_all_losses(): assert calculate_points([-1, -1, -1]) == 0 def test_process_input_example(): input_str = \\"3n3n1 0 -1n4n1 1 0 -1n2n-1 -1n\\" expected_output = [4, 7, 0] assert process_input(input_str) == expected_output def test_process_input_all_wins(): input_str = \\"1n5n1 1 1 1 1n\\" expected_output = [15] assert process_input(input_str) == expected_output def test_process_input_single_test_case(): input_str = \\"1n2n1 -1n\\" expected_output = [3] assert process_input(input_str) == expected_output def test_process_input_single_loss(): input_str = \\"1n1n-1n\\" expected_output = [0] assert process_input(input_str) == expected_output def test_process_input_all_draws(): input_str = \\"1n3n0 0 0n\\" expected_output = [3] assert process_input(input_str) == expected_output","solution":"def calculate_points(results): Calculate the total points based on the match results. :param results: List of integers representing the match results (-1 for loss, 0 for draw, 1 for win) :return: Total points earned points_map = {1: 3, 0: 1, -1: 0} total_points = sum(points_map[result] for result in results) return total_points def process_input(input_str): Process the input string and calculate points for each test case. :param input_str: A multiline string input as described in the problem statement :return: List of integers where each integer represents the total points for the respective test case lines = input_str.splitlines() T = int(lines[0]) results_per_case = [] line_idx = 1 for _ in range(T): N = int(lines[line_idx]) results = list(map(int, lines[line_idx + 1].split())) points = calculate_points(results) results_per_case.append(points) line_idx += 2 return results_per_case"},{"question":"def generate_tree_heights_pattern(n: int, heights: List[int]) -> List[int]: Generates a sequence of tree heights following the special pattern. Args: n (int): Number of trees. heights (List[int]): List of heights of trees. Returns: List[int]: Altered sequence of heights. >>> generate_tree_heights_pattern(5, [3, 1, 4, 1, 5]) [3, 3, 1, 4, 4, 8, 1, 9, 5, 14] >>> generate_tree_heights_pattern(3, [1, 2, 3]) [1, 1, 2, 3, 3, 6] >>> generate_tree_heights_pattern(4, [2, 2, 2, 2]) [2, 2, 2, 4, 2, 6, 2, 8] >>> generate_tree_heights_pattern(2, [5, 5]) [5, 5, 5, 10] >>> generate_tree_heights_pattern(1, [1]) [1, 1]","solution":"def generate_tree_heights_pattern(n, heights): Generates the sequence of tree heights following the special pattern. result = [] sum_heights = 0 for height in heights: sum_heights += height result.append(height) result.append(sum_heights) return result"},{"question":"from typing import List def find_largest_index(lst: List[int]) -> int: Returns the index of the largest number in the list. If there is a tie, returns the smallest index. If the list is empty, returns -1. >>> find_largest_index([1, 2, 3, 2, 1]) 2 >>> find_largest_index([5, 1, 5, 3, 5, 4]) 0 >>> find_largest_index([7, 7, 5, 7, 6]) 0 >>> find_largest_index([]) -1 >>> find_largest_index([5, 5, 5, 5, 5]) 0","solution":"def find_largest_index(lst): Returns the index of the largest number in the list. If there is a tie, returns the smallest index. If the list is empty, returns -1. if not lst: return -1 max_value = max(lst) return lst.index(max_value)"},{"question":"def verify_report(report: str, hash_sum: int) -> bool: Verifies the authenticity of a report by computing its hash sum and comparing it to the provided hash sum. :param report: A string representing the report text. :param hash_sum: An integer representing the expected hash sum of the report. :return: True if the computed hash sum matches the provided hash sum, otherwise False. >>> verify_report(\\"Hello, World!\\", 124) True >>> verify_report(\\"The quick brown fox jumps over the lazy dog.\\", 2204) False","solution":"def verify_report(report: str, hash_sum: int) -> bool: Verifies the authenticity of a report by computing its hash sum and comparing it to the provided hash sum. :param report: A string representing the report text. :param hash_sum: An integer representing the expected hash sum of the report. :return: True if the computed hash sum matches the provided hash sum, otherwise False. letters = 'abcdefghijklmnopqrstuvwxyz' report_sum = sum(letters.index(char.lower()) + 1 for char in report if char.lower() in letters) return report_sum == hash_sum"},{"question":"from typing import List, Tuple from math import factorial def unique_paths(width: int, height: int) -> int: Returns the number of unique paths from top-left to bottom-right in a grid with given width and height. >>> unique_paths(3, 2) 3 >>> unique_paths(2, 4) 4 >>> unique_paths(1, 1) 1 pass def find_paths(grids: List[Tuple[int, int]]) -> List[int]: Takes a list of tuples (width, height) representing grids and returns a list with the number of unique paths for each grid. >>> find_paths([(3, 2), (2, 4), (1, 1)]) [3, 4, 1] >>> find_paths([(10, 10), (7, 3), (3, 7)]) [48620, 28, 28] pass","solution":"from math import factorial def unique_paths(width, height): Returns the number of unique paths from top-left to bottom-right in a grid with given width and height. return factorial(width + height - 2) // (factorial(width - 1) * factorial(height - 1)) def find_paths(grids): Takes a list of tuples (width, height) representing grids and returns a list with the number of unique paths for each grid. results = [] for (width, height) in grids: results.append(unique_paths(width, height)) return results"},{"question":"def factorial(n: int) -> int: Returns the factorial of the non-negative integer n (where 0 <= n <= 12). >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(5) 120 >>> factorial(12) 479001600 >>> factorial(2) 2 >>> factorial(3) 6","solution":"def factorial(n): Returns the factorial of the non-negative integer n. if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"def reverse_words(s: str) -> str: Takes a string of words separated by spaces and returns a string where the words are in reverse order. Each word retains its original position, but its characters are reversed. Parameters: s (str): The input string. Returns: str: The string with each word's characters reversed. >>> reverse_words(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words(\\"The quick brown fox\\") \\"ehT kciuq nworb xof\\" def test_single_word(): assert reverse_words(\\"hello\\") == \\"olleh\\" def test_two_words(): assert reverse_words(\\"hello world\\") == \\"olleh dlrow\\" def test_multiple_words(): assert reverse_words(\\"The quick brown fox\\") == \\"ehT kciuq nworb xof\\" def test_blank_string(): assert reverse_words(\\"\\") == \\"\\" def test_string_with_spaces_only(): assert reverse_words(\\" \\") == \\" \\" def test_string_with_extra_spaces(): assert reverse_words(\\"hello world\\") == \\"olleh dlrow\\"","solution":"def reverse_words(s): Takes a string of words separated by spaces and returns a string where the words are in reverse order. Each word retains its original position, but its characters are reversed. Parameters: s (str): The input string. Returns: str: The string with each word's characters reversed. return ' '.join(word[::-1] for word in s.split(' '))"},{"question":"def titleToNumber(columnTitle: str) -> int: Converts a column title as appear in an Excel sheet to its corresponding column number. >>> titleToNumber(\\"A\\") 1 >>> titleToNumber(\\"AB\\") 28 >>> titleToNumber(\\"ZY\\") 701","solution":"def titleToNumber(columnTitle): Converts a column title as appear in an Excel sheet to its corresponding column number. :param columnTitle: str - A string representing the column title in Excel. :return: int - The corresponding column number. result = 0 for i, char in enumerate(columnTitle): result = result * 26 + (ord(char) - ord('A') + 1) return result"},{"question":"def longest_contiguous_ones(n: int, s: str) -> int: Determines the length of the longest contiguous subsequence of 1's that can be obtained by flipping the parity of exactly one bit in the given binary string. >>> longest_contiguous_ones(5, '11000') 3 >>> longest_contiguous_ones(3, '111') 3 >>> longest_contiguous_ones(5, '01000') 2 >>> longest_contiguous_ones(5, '00010') 2 >>> longest_contiguous_ones(8, '11011111') 8 >>> longest_contiguous_ones(1, '0') 1 >>> longest_contiguous_ones(1, '1') 1","solution":"def longest_contiguous_ones(n, s): Determines the length of the longest contiguous subsequence of 1's that can be obtained by flipping the parity of exactly one bit in the given binary string. if '0' not in s: # All are 1's case return n max_count = 0 current_count = 0 previous_count = 0 temp_max = 0 for i in range(n): if s[i] == '1': current_count += 1 else: previous_count = current_count current_count = 0 temp_max = max(temp_max, previous_count + current_count + 1) max_count = max(max_count, temp_max) return min(max_count, n)"},{"question":"def shortest_route(n: int, distances: List[List[int]]) -> int: Finds the minimum travel distance required to visit all destinations exactly once and return to the starting point. Parameters: n (int): The number of destinations. distances (List[List[int]]): The 2D list of distances between destinations. Returns: int: The minimum travel distance. from itertools import permutations def test_example_case(): n = 4 distances = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] assert shortest_route(n, distances) == 80 def test_two_cities(): n = 2 distances = [ [0, 10], [10, 0] ] assert shortest_route(n, distances) == 20 def test_three_cities(): n = 3 distances = [ [0, 10, 15], [10, 0, 20], [15, 20, 0] ] assert shortest_route(n, distances) == 45 def test_three_cities_another(): n = 3 distances = [ [0, 20, 30], [20, 0, 25], [30, 25, 0] ] assert shortest_route(n, distances) == 75 def test_edge_case_identical_distances(): n = 4 distances = [ [0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0] ] assert shortest_route(n, distances) == 4","solution":"import itertools def shortest_route(n, distances): Finds the minimum travel distance required to visit all destinations exactly once and return to the starting point. Parameters: n (int): The number of destinations. distances (List[List[int]]): The 2D list of distances between destinations. Returns: int: The minimum travel distance. min_distance = float('inf') # Generate all possible permutations of the destinations, excluding the start point 0 permutations = itertools.permutations(range(1, n)) for perm in permutations: current_distance = 0 current_point = 0 # start from point 0 # Calculate the distance for the current permutation for next_point in perm: current_distance += distances[current_point][next_point] current_point = next_point # Add the return distance to the start point current_distance += distances[current_point][0] # Update the minimum distance found if current_distance < min_distance: min_distance = current_distance return min_distance"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> bool: Determines if there are two distinct integers in the list that add up to the target value. :param nums: List of integers :param target: The target value to be achieved by summing two distinct integers from the list :return: True if such a pair exists, False otherwise >>> two_sum([2, 7, 11, 15], 9) True >>> two_sum([3, 2, 4], 6) True >>> two_sum([3, 3], 6) True >>> two_sum([1, 2, 3, 4, 5], 10) False","solution":"from typing import List def two_sum(nums: List[int], target: int) -> bool: Determines if there are two distinct integers in the list that add up to the target value. :param nums: List of integers :param target: The target value to be achieved by summing two distinct integers from the list :return: True if such a pair exists, False otherwise seen = set() for num in nums: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"def smallestDifference(arr: List[int]) -> int: Returns the smallest absolute difference between any two numbers in the list. >>> smallestDifference([5, 3, 8, 1, 4]) 1 >>> smallestDifference([1, 2, 3, 4, 5]) 1 >>> smallestDifference([5, 4, 3, 2, 1]) 1 >>> smallestDifference([5, 5, 5, 5]) 0 >>> smallestDifference([1000000, 500000, 0]) 500000 >>> smallestDifference([-10, -7, -3, -1]) 2 >>> smallestDifference([-1, 0, 1, 2]) 1","solution":"def smallestDifference(arr): Returns the smallest absolute difference between any two numbers in the list. # Sort the array first arr.sort() # Initialize the minimum difference to a large number min_diff = float('inf') # Compare adjacent pairs in the sorted array for i in range(len(arr) - 1): diff = abs(arr[i+1] - arr[i]) if diff < min_diff: min_diff = diff return min_diff"},{"question":"class Warehouse: You need to develop a warehouse management system. This system needs to efficiently handle operations related to storing, retrieving, and querying the status of items in a warehouse. >>> warehouse = Warehouse() >>> warehouse.store_item(\\"Apples\\", 100, \\"A1\\") >>> warehouse.store_item(\\"Oranges\\", 50, \\"B1\\") >>> warehouse.store_item(\\"Apples\\", 50, \\"A1\\") >>> warehouse.store_item(\\"Apples\\", 200, \\"C1\\") >>> warehouse.get_item_quantity(\\"Apples\\") 350 >>> warehouse.get_location_items(\\"A1\\") {\\"Apples\\": 150} >>> warehouse.retrieve_item(\\"Oranges\\", 30) 30 >>> warehouse.get_item_quantity(\\"Oranges\\") 20 >>> warehouse.retrieve_item(\\"Apples\\", 400) 350 def __init__(self): Initializes the warehouse. pass def store_item(self, item, quantity, location): Adds the specified quantity of the item to the given location. If the same item already exists in that location, it should update the quantity accordingly, adding to the existing quantity. pass def retrieve_item(self, item, quantity): Removes the specified quantity of the item from its stored location(s). If multiple locations store this item, consider the locations in the order they were added and retrieve from those with available quantities. If an insufficient quantity of the item exists, it should remove as much as possible and return the actual quantity retrieved. pass def get_item_quantity(self, item): Returns the total quantity of the specified item across all locations in the warehouse. pass def get_location_items(self, location): Returns a dictionary where keys are item names and values are the quantities of those items stored at the given location. pass","solution":"class Warehouse: def __init__(self): self.items = {} # Dictionary to store item information def store_item(self, item, quantity, location): if item not in self.items: self.items[item] = [] # Check if location already contains the item found = False for loc in self.items[item]: if loc['location'] == location: loc['quantity'] += quantity found = True break if not found: self.items[item].append({ 'location': location, 'quantity': quantity }) def retrieve_item(self, item, quantity): if item not in self.items: return 0 # Item not in warehouse total_retrieved = 0 locations_to_remove = [] for loc in sorted(self.items[item], key=lambda x: x['location']): # Retrieve in location order if loc['quantity'] >= quantity: loc['quantity'] -= quantity total_retrieved += quantity quantity = 0 # If location quantity is zero, mark it for removal if loc['quantity'] == 0: locations_to_remove.append(loc) break else: quantity -= loc['quantity'] total_retrieved += loc['quantity'] locations_to_remove.append(loc) for loc in locations_to_remove: self.items[item].remove(loc) return total_retrieved def get_item_quantity(self, item): if item not in self.items: return 0 # Item not in warehouse total_quantity = 0 for loc in self.items[item]: total_quantity += loc['quantity'] return total_quantity def get_location_items(self, location): items_in_location = {} for item in self.items: for loc in self.items[item]: if loc['location'] == location: items_in_location[item] = loc['quantity'] break return items_in_location"},{"question":"from typing import List def find_indices(arr: List[int], target: int) -> List[int]: Returns the indices of the two numbers that add up to the target sum. If no such pair exists, returns an empty array. >>> find_indices([2, 7, 11, 15], 9) [0, 1] >>> find_indices([3, 2, 4], 6) [1, 2] >>> find_indices([3, 3], 6) [0, 1] # your code here pass # Test cases def test_example_1(): assert find_indices([2, 7, 11, 15], 9) == [0, 1] def test_example_2(): assert find_indices([3, 2, 4], 6) == [1, 2] def test_example_3(): assert find_indices([3, 3], 6) == [0, 1] def test_no_solution(): assert find_indices([1, 2, 3], 7) == [] def test_large_numbers(): assert find_indices([1000000, 5000000, 5000000], 10000000) == [1, 2] def test_negative_numbers(): assert find_indices([-3, 4, 3, 90], 0) == [0, 2] def test_mixed_sign_numbers(): assert find_indices([4, -2, 3, 1], 1) == [1, 2]","solution":"def find_indices(arr, target): Returns the indices of the two numbers that add up to the target sum. If no such pair exists, returns an empty array. seen = {} for i, number in enumerate(arr): complement = target - number if complement in seen: return [seen[complement], i] seen[number] = i return []"},{"question":"def find_pair(nums: List[int], target: int) -> Tuple[int, int]: Determine if any two numbers in the list add up to the target number. If such a pair exists, return the indices of the two numbers in the form of a tuple. If no such pair exists, return (-1, -1). >>> find_pair([2, 7, 11, 15], 9) (0, 1) >>> find_pair([3, 2, 4], 6) (1, 2) >>> find_pair([3, 3], 6) (0, 1) >>> find_pair([1, 2, 3, 4], 8) (-1, -1) # Unit Tests def test_find_pair_example1(): assert find_pair([2, 7, 11, 15], 9) == (0, 1) def test_find_pair_example2(): assert find_pair([3, 2, 4], 6) == (1, 2) def test_find_pair_example3(): assert find_pair([3, 3], 6) == (0, 1) def test_find_pair_no_pair(): assert find_pair([1, 2, 3, 4], 8) == (-1, -1) def test_find_pair_large_numbers(): assert find_pair([10000000, 5000000, -15000000], -10000000) == (1, 2) def test_find_pair_with_negatives(): assert find_pair([1, -3, 2, 5], -1) == (1, 2) def test_find_pair_single_element(): assert find_pair([5], 5) == (-1, -1) def test_find_pair_empty_list(): assert find_pair([], 1) == (-1, -1)","solution":"def find_pair(nums, target): This function returns the indices of the two numbers such that they add up to the target. If no such pair exists, it returns (-1, -1). num_map = {} for i, num in enumerate(nums): complement = target - num if complement in num_map: return (num_map[complement], i) num_map[num] = i return (-1, -1)"},{"question":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest strictly increasing subsequence. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 pass def test_longest_increasing_subsequence_example1(): assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 def test_longest_increasing_subsequence_example2(): assert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4 def test_longest_increasing_subsequence_example3(): assert longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) == 1 def test_longest_increasing_subsequence_empty(): assert longest_increasing_subsequence([]) == 0 def test_longest_increasing_subsequence_single_element(): assert longest_increasing_subsequence([10]) == 1 def test_longest_increasing_subsequence_all_increasing(): assert longest_increasing_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9 def test_longest_increasing_subsequence_alternating(): assert longest_increasing_subsequence([1, 3, 2, 4, 3, 5]) == 4 def test_longest_increasing_subsequence_long(): assert longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6","solution":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest strictly increasing subsequence. if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"from collections import OrderedDict class LRUCache: Class that simulates a Least Recently Used (LRU) cache. Operations: - \`get(key)\`: Returns the value of the key if the key exists, otherwise returns -1. - \`put(key, value)\`: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, remove the least recently used key. Example usage: cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 cache.put(3, 3) assert cache.get(2) == -1 cache.put(4, 4) assert cache.get(1) == -1 assert cache.get(3) == 3 assert cache.get(4) == 4 def __init__(self, capacity: int): Initializes the LRU cache with positive size capacity. pass def get(self, key: int) -> int: Returns the value of the key if the key exists, otherwise returns -1. pass def put(self, key: int, value: int) -> None: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, remove the least recently used key. pass","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key in self.cache: self.cache.move_to_end(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"def num_islands(grid: List[str]) -> int: Given a 2D grid of size m x n representing a map where '1' represents land and '0' represents water, find the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. -----Input----- - A 2D list grid of '0's and '1's of size m x n (1 ≤ m, n ≤ 1000). -----Output----- - A single integer, the number of islands in the grid. >>> num_islands([ \\"11000\\", \\"11000\\", \\"00100\\", \\"00011\\" ]) 3 >>> num_islands([ \\"11100011\\", \\"11000001\\", \\"10000001\\", \\"00001110\\", \\"00001100\\", \\"00000000\\" ]) 3 >>> num_islands([ \\"1\\" ]) 1","solution":"def num_islands(grid): Function to count number of islands in a 2D grid. :param grid: 2D list (m x n) of '0's and '1's :return: int, number of islands if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False for _ in range(n)] for _ in range(m)] def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == '0' or visited[i][j]: return visited[i][j] = True dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) islands = 0 for i in range(m): for j in range(n): if grid[i][j] == '1' and not visited[i][j]: dfs(i, j) islands += 1 return islands"},{"question":"from typing import List from collections import Counter import heapq def reorganize_string(s: str) -> str: Rearranges the characters of string s so that no two adjacent characters are the same. If it is not possible, returns an empty string. >>> reorganize_string(\\"aab\\") 'aba' >>> reorganize_string(\\"aaab\\") '' pass # Unit Test def test_reorganize_string_example1(): assert reorganize_string(\\"aab\\") == \\"aba\\" def test_reorganize_string_example2(): assert reorganize_string(\\"aaab\\") == \\"\\" def test_reorganize_string_single_char(): assert reorganize_string(\\"a\\") == \\"a\\" def test_reorganize_string_no_reorganization_needed(): assert reorganize_string(\\"abcdef\\") == \\"abcdef\\" def test_reorganize_string_two_chars(): assert reorganize_string(\\"aa\\") == \\"\\" def test_reorganize_string_with_multiple(): result = reorganize_string(\\"aaabb\\") # Since there are multiple acceptable outputs, we test the validity assert result in [\\"ababa\\", \\"abbaa\\", \\"baaba\\", \\"babab\\", \\"baabb\\"] def test_reorganize_string_large_input(): input_str = \\"a\\" * 50 + \\"b\\" * 50 result = reorganize_string(input_str) for i in range(1, len(result)): assert result[i] != result[i-1]","solution":"from heapq import heappop, heappush from collections import Counter def reorganize_string(s: str) -> str: Rearranges the characters of string s so that no two adjacent characters are the same. If it is not possible, returns an empty string. # Count the frequencies of each character count = Counter(s) # Create a max heap based on character frequencies (negative for max heap in Python) max_heap = [] for char, freq in count.items(): heappush(max_heap, (-freq, char)) prev_freq, prev_char = 0, '' result = [] # Reorganize string while max_heap: freq, char = heappop(max_heap) result.append(char) # If there's a previous character to push back into the heap if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) # Update previous character and frequency prev_freq = freq + 1 # Decrease frequency by 1 (since it's negative) prev_char = char # If the length of the result is not the same as the input string, return empty string if len(result) != len(s): return \\"\\" return \\"\\".join(result)"},{"question":"def evaluate_paths(paths): Evaluates paths taken by players and calculates their total scores. Returns an array of player names ordered by their scores in descending order. >>> evaluate_paths([ ... {'name': 'Alice', 'steps': 300, 'traps': 2, 'bonuses': 1, 'teleports': 1, 'loops': 3}, ... {'name': 'Bob', 'steps': 500, 'traps': 1, 'bonuses': 0, 'teleports': 2, 'loops': 1}, ... {'name': 'Charlie', 'steps': 200, 'traps': 3, 'bonuses': 2, 'teleports': 0, 'loops': 2} ... ]) == ['Charlie', 'Alice', 'Bob'] >>> evaluate_paths([]) == [] >>> evaluate_paths([ ... {'name': 'Alice', 'steps': 300, 'traps': 2, 'bonuses': 1, 'teleports': 1, 'loops': 3}, ... {'name': 'Bob', 'steps': 300, 'traps': 2, 'bonuses': 1, 'teleports': 1, 'loops': 3} ... ]) == ['Alice', 'Bob'] >>> evaluate_paths([ ... {'name': 'Alice', 'steps': 10, 'traps': 10, 'bonuses': 0, 'teleports': 0, 'loops': 0}, ... {'name': 'Bob', 'steps': 20, 'traps': 19, 'bonuses': 0, 'teleports': 0, 'loops': 0} ... ]) == ['Alice', 'Bob'] >>> evaluate_paths([ ... {'name': 'Alice', 'steps': 300, 'traps': 4, 'bonuses': 2, 'teleports': 2, 'loops': 8}, ... {'name': 'Bob', 'steps': 600, 'traps': 10, 'bonuses': 1, 'teleports': 3, 'loops': 5}, ... {'name': 'Charlie', 'steps': 1000, 'traps': 1, 'bonuses': 5, 'teleports': 0, 'loops': 10} ... ]) == ['Charlie', 'Alice', 'Bob']","solution":"def evaluate_paths(paths): Evaluates paths taken by players and calculates their total scores. Returns an array of player names ordered by their scores in descending order. player_scores = [] for path in paths: name = path['name'] steps = path['steps'] traps = path['traps'] bonuses = path['bonuses'] teleports = path['teleports'] loops = path['loops'] # Calculate score based on the given rules total_score = ( steps * 1 - traps * 50 + bonuses * 200 + teleports * 100 - teleports * steps - loops * 75 ) player_scores.append((total_score, name)) # Sort the player scores by score in descending order player_scores.sort(key=lambda x: x[0], reverse=True) # Extract and return the player names in sorted order sorted_names = [name for score, name in player_scores] return sorted_names"},{"question":"def merge_events(events): Merges overlapping events, returning a list of merged events. Parameters: events (list of tuples): A list of events, where each event is a tuple (start_time, end_time, description). Returns: merged_events (list of tuples): A list of merged events in the same format (start_time, end_time, description). Example: >>> merge_events([(\\"09:00\\", \\"10:30\\", \\"Event 1\\"), (\\"10:00\\", \\"11:00\\", \\"Event 2\\"), (\\"11:30\\", \\"12:00\\", \\"Event 3\\"), (\\"12:00\\", \\"12:30\\", \\"Event 4\\")]) [(\\"09:00\\", \\"11:00\\", \\"Event 1, Event 2\\"), (\\"11:30\\", \\"12:00\\", \\"Event 3\\"), (\\"12:00\\", \\"12:30\\", \\"Event 4\\")]","solution":"def merge_events(events): Merges overlapping events, returning a list of merged events. Parameters: events (list of tuples): A list of events, where each event is a tuple (start_time, end_time, description). Returns: merged_events (list of tuples): A list of merged events in the same format (start_time, end_time, description). def time_to_minutes(t): Converts a time in \\"HH:MM\\" format into minutes since midnight. h, m = map(int, t.split(\\":\\")) return h * 60 + m def minutes_to_time(m): Converts minutes since midnight into \\"HH:MM\\" format. h = m // 60 m = m % 60 return f\\"{h:02}:{m:02}\\" # Sort events by start time events.sort(key=lambda event: time_to_minutes(event[0])) merged_events = [] for event in events: if not merged_events or time_to_minutes(event[0]) > time_to_minutes(merged_events[-1][1]): merged_events.append(event) else: merged_events[-1] = (merged_events[-1][0], max(merged_events[-1][1], event[1]), merged_events[-1][2] + \\", \\" + event[2]) return merged_events # Input: [(\\"09:00\\", \\"10:30\\", \\"Event 1\\"), (\\"10:00\\", \\"11:00\\", \\"Event 2\\"), (\\"11:30\\", \\"12:00\\", \\"Event 3\\"), (\\"12:00\\", \\"12:30\\", \\"Event 4\\")] # Expected Output: [(\\"09:00\\", \\"11:00\\", \\"Event 1, Event 2\\"), (\\"11:30\\", \\"12:00\\", \\"Event 3\\"), (\\"12:00\\", \\"12:30\\", \\"Event 4\\")] input_events = [(\\"09:00\\", \\"10:30\\", \\"Event 1\\"), (\\"10:00\\", \\"11:00\\", \\"Event 2\\"), (\\"11:30\\", \\"12:00\\", \\"Event 3\\"), (\\"12:00\\", \\"12:30\\", \\"Event 4\\")] print(merge_events(input_events))"},{"question":"def check_balance(arr): Determines if there is at least one pair of elements in the array that sum up to zero. If such a pair exists, returns 'Balance achieved'. Otherwise, returns 'Unbalanced array'. >>> check_balance([3, 1, -2, 5, -3]) == 'Balance achieved' >>> check_balance([0, 1, 2, -1]) == 'Balance achieved' >>> check_balance([-1, 1]) == 'Balance achieved' >>> check_balance([3, 1, 2, 5]) == 'Unbalanced array' >>> check_balance([1, 2, 3, 4, 5]) == 'Unbalanced array' >>> check_balance([10, 20, -5, -3]) == 'Unbalanced array' >>> check_balance([]) == 'Unbalanced array' >>> check_balance([0]) == 'Unbalanced array' >>> check_balance([1]) == 'Unbalanced array' >>> check_balance([-1]) == 'Unbalanced array' >>> check_balance([1, 2, 3, -1]) == 'Balance achieved'","solution":"def check_balance(arr): Determines if there is at least one pair of elements in the array that sum up to zero. If such a pair exists, returns 'Balance achieved'. Otherwise, returns 'Unbalanced array'. seen = set() for num in arr: if -num in seen: return 'Balance achieved' seen.add(num) return 'Unbalanced array'"},{"question":"def shortest_route(start: int, distances: List[List[int]]) -> int: Returns the minimum distance needed to complete the route starting from the given starting point and visiting each location exactly once. :param start: int, the starting location :param distances: 2D list of ints, the distances[i][j] represents the distance between location i and location j :return: int, the minimum distance to complete the route >>> distances = [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ] >>> start = 0 >>> shortest_route(start, distances) 80","solution":"import itertools def shortest_route(start, distances): Returns the minimum distance needed to complete the route starting from the given starting point and visiting each location exactly once. :param start: int, the starting location :param distances: 2D list of ints, the distances[i][j] represents the distance between location i and location j :return: int, the minimum distance to complete the route num_locations = len(distances) all_locations = set(range(num_locations)) # Generate all permutations of the locations excluding the start other_locations = all_locations - {start} min_distance = float('inf') for perm in itertools.permutations(other_locations): # Calculate the distance of this particular route current_distance = 0 prev_location = start for location in perm: current_distance += distances[prev_location][location] prev_location = location # Add the distance to return to the start current_distance += distances[prev_location][start] # Update the minimum distance min_distance = min(min_distance, current_distance) return min_distance"},{"question":"def reverse_words(sentence: str) -> str: Reverses the order of characters within each word in the sentence while maintaining the original order of words. >>> reverse_words(\\"hello world\\") # should return \\"olleh dlrow\\" >>> reverse_words(\\"The quick brown fox\\") # should return \\"ehT kciuq nworb xof\\"","solution":"def reverse_words(sentence): Reverses the order of characters within each word in the sentence while maintaining the original order of words. Parameters: sentence (str): A string containing the sentence to be reversed. Returns: str: A new sentence with the words reversed. words = sentence.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def find_unique_number(nums: List[int]) -> int: Identifies the unique number in a list where every number appears exactly twice except for one which appears only once. Args: nums (list): List of integers where one integer appears only once and the rest appear exactly twice. Returns: int: The unique integer that appears only once in the list. Examples: >>> find_unique_number([4, 1, 2, 1, 2]) 4 >>> find_unique_number([2, 2, 1]) 1 >>> find_unique_number([4, -1, 2, 1, 2, 1, -1]) 4","solution":"def find_unique_number(nums): Identifies the unique number in a list where every number appears exactly twice except for one which appears only once. Args: nums (list): List of integers where one integer appears only once and the rest appear exactly twice. Returns: int: The unique integer that appears only once in the list. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"def longest_subarray_sum(nums: List[int], target: int) -> int: Write a function that takes a list of integers and an integer target value. The function should return the lengths of the longest contiguous subarray that sums up to the target value. If no such subarray exists, the function should return 0. >>> longest_subarray_sum([1, -1, 5, -2, 3], 3) 4 >>> longest_subarray_sum([-2, -1, 2, 1], 1) 2 >>> longest_subarray_sum([1, 2, 3, 4, 5], 15) 5 >>> longest_subarray_sum([1, 2, 3, 4, 5], 11) 0","solution":"def longest_subarray_sum(nums, target): Returns the length of the longest contiguous subarray that sums up to the target value. If no such subarray exists, returns 0. sum_index = {} current_sum = 0 max_len = 0 for i, num in enumerate(nums): current_sum += num if current_sum == target: max_len = i + 1 if current_sum - target in sum_index: max_len = max(max_len, i - sum_index[current_sum - target]) if current_sum not in sum_index: sum_index[current_sum] = i return max_len"},{"question":"def contains_duplicates(nums: List[int]) -> bool: Returns True if there are any duplicates in the given list of integers, otherwise returns False. Time complexity should be O(n). Example: >>> contains_duplicates([1, 2, 3, 4]) False >>> contains_duplicates([1, 2, 3, 1]) True","solution":"def contains_duplicates(nums): Returns True if there are any duplicates in the given list of integers, otherwise returns False. Time complexity should be O(n). seen = set() for num in nums: if num in seen: return True seen.add(num) return False"},{"question":"def second_highest_score(scores: List[int]) -> int: Returns the second highest score from the list of scores, or -1 if it doesn't exist. >>> second_highest_score([50, 85, 85, 70]) 70 >>> second_highest_score([90, 90, 55, 55, 55]) 55 >>> second_highest_score([100, 100, 100]) -1 >>> second_highest_score([42]) -1","solution":"def second_highest_score(scores): Returns the second highest score from the list of scores, or -1 if it doesn't exist. if len(scores) < 2: return -1 unique_scores = list(set(scores)) if len(unique_scores) < 2: return -1 unique_scores.sort(reverse=True) return unique_scores[1]"},{"question":"def reverse_each_word(sentence: str) -> str: Reverses each word in the sentence while maintaining the order of the words and handling punctuation marks. Args: sentence (str): The input sentence containing words to be reversed. Returns: str: A sentence with each word reversed. >>> reverse_each_word(\\"Hello, world!\\") == \\",olleH !dlrow\\" >>> reverse_each_word(\\"This is an example.\\") == \\"sihT si na .elpmaxe\\" >>> reverse_each_word(\\"Python\\") == \\"nohtyP\\" >>> reverse_each_word(\\"\\") == \\"\\" >>> reverse_each_word(\\" \\") == \\" \\" >>> reverse_each_word(\\"Hello world\\") == \\"olleH dlrow\\" >>> reverse_each_word(\\"123 !!abc!!!\\") == \\"321 !!!cba!!\\"","solution":"def reverse_each_word(sentence): Reverses each word in the sentence while maintaining the order of the words. Args: sentence (str): The input sentence containing words to be reversed. Returns: str: A sentence with each word reversed. return ' '.join(word[::-1] for word in sentence.split(' '))"},{"question":"def sort_and_recombine(s: str) -> str: Extracts contiguous numeric digits and contiguous alphabetic characters, sorts each group individually, and recombines them into a single string. Parameters: s (str): The input string containing numeric digits and alphabetic characters. Returns: str: The string with each group sorted and recombined. >>> sort_and_recombine(\\"abc123xyz\\") \\"abc123xyz\\" >>> sort_and_recombine(\\"cba987abc123\\") \\"abc789abc123\\"","solution":"import re def sort_and_recombine(s: str) -> str: Extracts contiguous numeric digits and contiguous alphabetic characters, sorts each group individually, and recombines them into a single string. Parameters: s (str): The input string containing numeric digits and alphabetic characters. Returns: str: The string with each group sorted and recombined. # Find all groups of either digits or letters groups = re.findall(r'd+|D+', s) # Sort each group individually sorted_groups = [''.join(sorted(group)) for group in groups] # Recombine sorted groups into a single string return ''.join(sorted_groups)"},{"question":"def is_palindrome(n: int) -> bool: Determine if a given number is a numeric palindrome. Parameters: n (int): The input number to check. Returns: bool: True if the number is a palindrome, False otherwise. Examples: >>> is_palindrome(121) True >>> is_palindrome(123) False pass # Unit Test def test_is_palindrome_single_digit(): assert is_palindrome(0) == True assert is_palindrome(1) == True assert is_palindrome(5) == True assert is_palindrome(9) == True def test_is_palindrome_multiple_digits(): assert is_palindrome(121) == True assert is_palindrome(12321) == True assert is_palindrome(4554) == True def test_is_not_palindrome(): assert is_palindrome(123) == False assert is_palindrome(45234) == False assert is_palindrome(10) == False def test_large_numbers(): assert is_palindrome(9007199254740992) == False assert is_palindrome(9223372036854775808) == False assert is_palindrome(1000000000000000001) == True","solution":"def is_palindrome(n: int) -> bool: Determine if a given number is a numeric palindrome. Parameters: n (int): The input number to check. Returns: bool: True if the number is a palindrome, False otherwise. s = str(n) return s == s[::-1]"},{"question":"def find_peaks(arr): Returns a list of indices of all peak elements in the input array. A peak element is greater than its immediate neighbors. pass # Unit tests def test_no_peaks(): assert find_peaks([1, 2, 3]) == [] assert find_peaks([5, 5, 5, 5, 5]) == [] def test_one_peak(): assert find_peaks([1, 3, 2]) == [1] assert find_peaks([2, 1, 3, 1]) == [2] def test_multiple_peaks(): assert find_peaks([1, 3, 2, 4, 1, 6, 5]) == [1, 3, 5] assert find_peaks([10, 20, 10, 30, 20, 50, 40, 60, 50]) == [1, 3, 5, 7] def test_adjoining_elements(): assert find_peaks([1, 2, 1, 2, 1, 2, 1]) == [1, 3, 5] def test_all_descending(): assert find_peaks([5, 4, 3, 2, 1]) == [] def test_array_length_three(): assert find_peaks([1, 2, 1]) == [1]","solution":"def find_peaks(arr): Returns a list of indices of all peak elements in the input array. A peak element is greater than its immediate neighbors. peaks = [] for i in range(1, len(arr) - 1): if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: peaks.append(i) return peaks"},{"question":"def trap(height: List[int]) -> int: Computes the amount of water that can be trapped after raining given the heights of walls. :param height: List[int] -- a list of non-negative integers representing the height of walls. :return: int -- the total amount of water that can be trapped. >>> trap([]) == 0 >>> trap([1, 2]) == 0 >>> trap([4, 2, 0, 3, 2, 5]) == 9 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([2, 1, 2]) == 1 >>> trap([3, 3, 3, 3, 3]) == 0","solution":"def trap(height): Computes the amount of water that can be trapped. :param height: List[int] -- a list of non-negative integers representing the height of walls. :return: int -- the total amount of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"from typing import List, Dict def compute_office_hours(data: List[str]) -> Dict[int, int]: Compute the total minutes each employee spent inside the buildings based on swipe data. Parameters: data (List[str]): Swipe records in the format \\"employee_ID,timestamp,entry_type\\" Returns: Dict[int, int]: Dictionary with employee IDs as keys and total minutes spent as values Example: >>> data = [ ... \\"123,2021-09-01 08:00,entry\\", ... \\"123,2021-09-01 12:00,exit\\", ... \\"124,2021-09-01 09:00,entry\\", ... \\"124,2021-09-01 17:00,exit\\", ... \\"123,2021-09-02 08:30,entry\\", ... \\"123,2021-09-02 11:30,exit\\" ... ] >>> compute_office_hours(data) {123: 420, 124: 480} pass def test_basic_case(): data = [ \\"123,2021-09-01 08:00,entry\\", \\"123,2021-09-01 12:00,exit\\", \\"124,2021-09-01 09:00,entry\\", \\"124,2021-09-01 17:00,exit\\", \\"123,2021-09-02 08:30,entry\\", \\"123,2021-09-02 11:30,exit\\" ] result = compute_office_hours(data) expected = {123: 420, 124: 480} assert result == expected def test_unmatched_entry(): data = [ \\"123,2021-09-01 08:00,entry\\", \\"123,2021-09-01 12:00,exit\\", \\"124,2021-09-01 09:00,entry\\", \\"123,2021-09-02 08:30,entry\\", ] result = compute_office_hours(data) expected = {123: 240} assert result == expected def test_unmatched_exit(): data = [ \\"123,2021-09-01 08:00,entry\\", \\"123,2021-09-01 12:00,exit\\", \\"124,2021-09-01 09:00,entry\\", \\"124,2021-09-01 17:00,exit\\", \\"123,2021-09-02 08:30,entry\\", \\"123,2021-09-02 11:30,exit\\", \\"125,2021-09-03 09:00,exit\\" ] result = compute_office_hours(data) expected = {123: 420, 124: 480} assert result == expected def test_multiple_entries_before_exit(): data = [ \\"123,2021-09-01 08:00,entry\\", \\"123,2021-09-01 12:00,exit\\", \\"123,2021-09-01 13:00,entry\\", \\"123,2021-09-01 15:00,exit\\" ] result = compute_office_hours(data) expected = {123: 360} # 240 minutes (08:00 - 12:00) + 120 minutes (13:00 - 15:00) assert result == expected def test_spanning_days(): data = [ \\"123,2021-09-01 08:00,entry\\", \\"123,2021-09-02 08:00,exit\\", \\"124,2021-09-01 09:00,entry\\", \\"124,2021-09-01 17:00,exit\\" ] result = compute_office_hours(data) expected = {124: 480} # Employee 123 spans days, ignored. assert result == expected def test_empty_data(): data = [] result = compute_office_hours(data) expected = {} assert result == expected","solution":"from typing import List, Dict from datetime import datetime def compute_office_hours(data: List[str]) -> Dict[int, int]: employee_times = {} employee_enter_exit = {} for record in data: employee_id, timestamp, entry_type = record.split(',') employee_id = int(employee_id) timestamp = datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M\\") if employee_id not in employee_enter_exit: employee_enter_exit[employee_id] = [] if entry_type == \\"entry\\": employee_enter_exit[employee_id].append((timestamp, \\"entry\\")) elif entry_type == \\"exit\\": employee_enter_exit[employee_id].append((timestamp, \\"exit\\")) for employee_id, logs in employee_enter_exit.items(): total_time = 0 stack = [] for log in logs: if log[1] == \\"entry\\": stack.append(log[0]) elif log[1] == \\"exit\\" and stack: entry_time = stack.pop() exit_time = log[0] if entry_time.date() == exit_time.date(): total_time += int((exit_time - entry_time).total_seconds() // 60) if total_time > 0: employee_times[employee_id] = total_time return employee_times"},{"question":"def distribute_gifts(gifts: int, children: int): Distribute the specified number of gifts to the children attending the event. Parameters: gifts (int): The total number of gifts available. children (int): The total number of children attending the event. Returns: List[int] or str: A list representing how many gifts each child receives or a string message if there are no children. >>> distribute_gifts(10, 2) [5, 5] >>> distribute_gifts(5, 7) [1, 1, 1, 1, 1, 0, 0] >>> distribute_gifts(12, 5) [3, 3, 2, 2, 2] >>> distribute_gifts(0, 5) [0, 0, 0, 0, 0] >>> distribute_gifts(10, 0) \\"No children to give gifts to.\\" >>> distribute_gifts(0, 0) \\"No children to give gifts to.\\"","solution":"def distribute_gifts(gifts, children): Distribute the specified number of gifts to the children attending the event. Parameters: gifts (int): The total number of gifts available. children (int): The total number of children attending the event. Returns: List[int] or str: A list representing how many gifts each child receives or a string message if there are no children. if children == 0: return \\"No children to give gifts to.\\" # Each child gets at least one gift base_distributions = [1] * min(gifts, children) remaining_gifts = gifts - len(base_distributions) # If there are more gifts than children, distribute them for i in range(remaining_gifts): base_distributions[i % children] += 1 # If there are fewer gifts than children, append zeros while len(base_distributions) < children: base_distributions.append(0) return base_distributions"},{"question":"def find_unsorted_subarray(nums: List[int]) -> int: Returns the length of the shortest subarray that if sorted, would result in the entire array being sorted. >>> find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) == 5 >>> find_unsorted_subarray([1, 2, 3, 4]) == 0 >>> find_unsorted_subarray([1, 3, 2, 2, 2]) == 4","solution":"def find_unsorted_subarray(nums): Returns the length of the shortest subarray that if sorted, would result in the entire array being sorted. sorted_nums = sorted(nums) left, right = 0, len(nums) - 1 while left < len(nums) and nums[left] == sorted_nums[left]: left += 1 while right > left and nums[right] == sorted_nums[right]: right -= 1 return right - left + 1 if left < right else 0"},{"question":"def distribute_players(n: int, t: int) -> list: Distributes n players into t teams such that the difference in the number of players between any two teams is at most one. >>> distribute_players(10, 3) [3, 3, 4] >>> distribute_players(7, 5) [1, 1, 1, 2, 2] >>> distribute_players(8, 4) [2, 2, 2, 2]","solution":"def distribute_players(n, t): Distributes n players into t teams such that the difference in the number of players between any two teams is at most one. Args: n (int): The number of players. t (int): The number of teams. Returns: list: A list of integers representing the number of players in each team. base_players_per_team = n // t extra_players = n % t teams = [base_players_per_team] * t for i in range(extra_players): teams[i] += 1 return sorted(teams)"},{"question":"def count_palindromic_times() -> int: Count the number of palindromic times in a 24-hour period. >>> count_palindromic_times() 16 pass def process_cases(t: int) -> List[int]: Process multiple test cases and return the number of palindromic times for each case. >>> process_cases(1) [16] >>> process_cases(2) [16, 16] pass","solution":"def count_palindromic_times(): Count the number of palindromic times in a 24-hour period. palindromic_times = 0 for hour in range(24): for minute in range(60): # Format the time as hh:mm time_str = f\\"{hour:02d}:{minute:02d}\\" # Remove the colon and check if the resulting string is a palindrome if time_str == time_str[::-1]: palindromic_times += 1 return palindromic_times def process_cases(t): results = [] # Since the palindromic times don't change with the input, it's always the same result. count = count_palindromic_times() for _ in range(t): results.append(count) return results"},{"question":"def modify_string(s: str) -> str: Modifies the input string by adding 1 to each number and reversing the letters in each word. Args: s (str): Input string containing words and numbers. Returns: str: Modified string with each number incremented by 1 and each word reversed. Examples: >>> modify_string(\\"Hello 42 world\\") 'olleH 43 dlrow' >>> modify_string(\\"99 bottles\\") '100 selttob' >>> modify_string(\\" 99 bottles \\") ' 100 selttob ' >>> modify_string(\\" some text \\") ' emos txet ' >>> modify_string(\\"foo bar\\") 'oof rab' >>> modify_string(\\"123 456\\") '124 457' >>> modify_string(\\"0 99\\") '1 100' >>> modify_string(\\"Hi 1\\") 'iH 2' >>> modify_string(\\"good 5 times\\") 'doog 6 semit' pass","solution":"def modify_string(s): Modifies the input string by adding 1 to each number and reversing the letters in each word. Args: s (str): Input string containing words and numbers. Returns: str: Modified string with each number incremented by 1 and each word reversed. result = [] for element in s.split(' '): if element.isdigit(): result.append(str(int(element) + 1)) else: result.append(element[::-1]) return ' '.join(result)"},{"question":"from typing import List def min_deletions_to_make_anagrams(S: str, T: str) -> int: Returns the minimum number of deletions required to make the two strings S and T anagrams. >>> min_deletions_to_make_anagrams(\\"cde\\", \\"abc\\") 4 >>> min_deletions_to_make_anagrams(\\"a\\", \\"b\\") 2 >>> min_deletions_to_make_anagrams(\\"abc\\", \\"bca\\") 0 >>> min_deletions_to_make_anagrams(\\"abca\\", \\"bcab\\") 2 pass # Implementation goes here # Unit test cases def test_example_1(): assert min_deletions_to_make_anagrams(\\"cde\\", \\"abc\\") == 4 def test_example_2(): assert min_deletions_to_make_anagrams(\\"a\\", \\"b\\") == 2 def test_example_3(): assert min_deletions_to_make_anagrams(\\"abc\\", \\"bca\\") == 0 def test_example_4(): assert min_deletions_to_make_anagrams(\\"abca\\", \\"bcab\\") == 2 def test_empty_strings(): assert min_deletions_to_make_anagrams(\\"\\", \\"\\") == 0 def test_one_empty_string(): assert min_deletions_to_make_anagrams(\\"abc\\", \\"\\") == 3 assert min_deletions_to_make_anagrams(\\"\\", \\"def\\") == 3 def test_same_characters_different_counts(): assert min_deletions_to_make_anagrams(\\"aabbcc\\", \\"abc\\") == 3 assert min_deletions_to_make_anagrams(\\"abc\\", \\"aabbcc\\") == 3 def test_anagrams_with_different_orders(): assert min_deletions_to_make_anagrams(\\"listen\\", \\"silent\\") == 0 def test_one_character_string(): assert min_deletions_to_make_anagrams(\\"a\\", \\"a\\") == 0 assert min_deletions_to_make_anagrams(\\"a\\", \\"b\\") == 2","solution":"from collections import Counter def min_deletions_to_make_anagrams(S, T): Returns the minimum number of deletions required to make the two strings S and T anagrams. # Count characters in both strings countS = Counter(S) countT = Counter(T) # Calculate deletions needed for both strings deletions = 0 for char in set(countS.keys()).union(set(countT.keys())): deletions += abs(countS.get(char, 0) - countT.get(char, 0)) return deletions"},{"question":"def num_distinct_areas(k: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Determine the number of distinct tree areas in the park for multiple test cases. >>> num_distinct_areas(2, [(4, 5, [\\"TTGGT\\", \\"TGGTT\\", \\"GGTGG\\", \\"TTTGG\\"]), (3, 3, [\\"GGG\\", \\"GTG\\", \\"GGG\\"])]) [3, 1] >>> num_distinct_areas(1, [(3, 4, [\\"TGTG\\", \\"GTGT\\", \\"TGTG\\"])]) [6]","solution":"def num_distinct_areas(k, test_cases): def dfs(grid, visited, x, y, n, m): stack = [(x, y)] while stack: cx, cy = stack.pop() if 0 <= cx < n and 0 <= cy < m and not visited[cx][cy] and grid[cx][cy] == 'T': visited[cx][cy] = True stack.append((cx+1, cy)) stack.append((cx-1, cy)) stack.append((cx, cy+1)) stack.append((cx, cy-1)) results = [] for case in test_cases: n, m, grid = case visited = [[False for _ in range(m)] for _ in range(n)] distinct_areas = 0 for i in range(n): for j in range(m): if grid[i][j] == 'T' and not visited[i][j]: dfs(grid, visited, i, j, n, m) distinct_areas += 1 results.append(distinct_areas) return results"},{"question":"def max_candies(M: int, N: int, grid: List[List[int]]) -> int: Determine the maximum number of candies that can be collected on the way from the top-left cell to the bottom-right cell in a grid. Args: - M: int - number of rows in the grid - N: int - number of columns in the grid - grid: List[List[int]] - a 2D list representing the grid with candies Returns: - an integer representing the maximum number of candies that can be collected. pass import pytest def test_sample_input_1(): M, N = 3, 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_candies(M, N, grid) == 29 def test_single_cell(): M, N = 1, 1 grid = [[42]] assert max_candies(M, N, grid) == 42 def test_row_only(): M, N = 1, 4 grid = [[1, 2, 3, 4]] assert max_candies(M, N, grid) == 10 def test_column_only(): M, N = 4, 1 grid = [ [1], [2], [3], [4] ] assert max_candies(M, N, grid) == 10 def test_all_zeros(): M, N = 2, 2 grid = [ [0, 0], [0, 0] ] assert max_candies(M, N, grid) == 0 def test_mixed_values(): M, N = 3, 3 grid = [ [1, 10, 1], [1, 5, 1], [4, 2, 1] ] assert max_candies(M, N, grid) == 19","solution":"def max_candies(M, N, grid): # Create a 2D DP array to store the maximum candies collected till each cell dp = [[0] * N for _ in range(M)] # Initialize the first cell with the number of candies in the starting cell dp[0][0] = grid[0][0] # Fill the first row (moving only right) for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (moving only down) for i in range(1, M): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, M): for j in range(1, N): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The last cell will have the maximum candies collected return dp[M-1][N-1] def read_input(): import sys input = sys.stdin.read data = input().split() M = int(data[0]) N = int(data[1]) grid = [] idx = 2 for i in range(M): row = [int(data[idx + j]) for j in range(N)] grid.append(row) idx += N return M, N, grid if __name__ == \\"__main__\\": M, N, grid = read_input() result = max_candies(M, N, grid) print(result)"},{"question":"def categorize_files(file_tags, file_names): Categorize files based on their extensions. Args: file_tags (list of tuples): A list of (file extension, category) tuples. file_names (list): A list of file names to be categorized. Returns: list: A list of categories corresponding to each file name. >>> categorize_files([(\\"doc\\", \\"document\\"), (\\"jpg\\", \\"image\\"), (\\"xlsx\\", \\"spreadsheet\\"), (\\"py\\", \\"script\\")], [\\"report.doc\\", \\"holiday.jpg\\", \\"data.xlsx\\", \\"script.py\\", \\"notes.md\\"]) [\\"document\\", \\"image\\", \\"spreadsheet\\", \\"script\\", \\"uncategorized\\"] >>> categorize_files([(\\"doc\\", \\"document\\"), (\\"jpg\\", \\"image\\"), (\\"xlsx\\", \\"spreadsheet\\"), (\\"py\\", \\"script\\")], [\\"report\\", \\"holiday\\", \\"data\\", \\"script\\", \\"notes\\"]) [\\"uncategorized\\", \\"uncategorized\\", \\"uncategorized\\", \\"uncategorized\\", \\"uncategorized\\"] >>> categorize_files([(\\"doc\\", \\"document\\"), (\\"jpg\\", \\"image\\"), (\\"xlsx\\", \\"spreadsheet\\"), (\\"py\\", \\"script\\")], [\\"report.pdf\\", \\"holiday.png\\", \\"data.csv\\"]) [\\"uncategorized\\", \\"uncategorized\\", \\"uncategorized\\"] >>> categorize_files([], []) [] >>> categorize_files([(\\"Doc\\", \\"document\\"), (\\"Jpg\\", \\"image\\"), (\\"Xlsx\\", \\"spreadsheet\\"), (\\"Py\\", \\"script\\")], [\\"report.Doc\\", \\"holiday.Jpg\\", \\"data.Xlsx\\", \\"script.Py\\", \\"notes.md\\"]) [\\"document\\", \\"image\\", \\"spreadsheet\\", \\"script\\", \\"uncategorized\\"]","solution":"def categorize_files(file_tags, file_names): file_tag_dict = {ext: cat for ext, cat in file_tags} result = [] for file in file_names: if '.' in file: ext = file.split('.')[-1] if ext in file_tag_dict: result.append(file_tag_dict[ext]) else: result.append(\\"uncategorized\\") else: result.append(\\"uncategorized\\") return result"},{"question":"from collections import defaultdict, deque def minimum_time_to_complete_projects(projects, dependencies): Determines the minimum time required to complete all projects given the dependencies. Returns -1 if there is a circular dependency. >>> minimum_time_to_complete_projects([1], []) 1 >>> minimum_time_to_complete_projects([1, 2], [[2, 1]]) 2 >>> minimum_time_to_complete_projects([1, 2, 3, 4], [[2, 1], [3, 2], [4, 3]]) 4 >>> minimum_time_to_complete_projects([1, 2, 3, 4], [[2, 1], [3, 2], [4, 3], [1, 4]]) -1 >>> minimum_time_to_complete_projects([], []) 0 >>> minimum_time_to_complete_projects([1, 2, 3], []) 1 >>> minimum_time_to_complete_projects(list(range(1, 10001)), [(i+1, i) for i in range(1, 10000)]) 10000 # Implement the function here.","solution":"from collections import defaultdict, deque def minimum_time_to_complete_projects(projects, dependencies): Determines the minimum time required to complete all projects given the dependencies. Returns -1 if there is a circular dependency. # Build adjacency list and in-degree count adj = defaultdict(list) in_degree = {project: 0 for project in projects} for u, v in dependencies: adj[v].append(u) in_degree[u] += 1 # Queue for projects with no dependencies queue = deque([project for project in projects if in_degree[project] == 0]) completed_projects = 0 time_units = 0 while queue: current_level_size = len(queue) for _ in range(current_level_size): project = queue.popleft() completed_projects += 1 for neighbor in adj[project]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) time_units += 1 if completed_projects == len(projects): return time_units else: return -1"},{"question":"from typing import List def unique_paths_with_obstacles(grid: List[str]) -> int: Determine the number of unique paths from the top-left corner to the bottom-right corner of the grid, avoiding all obstacles. >>> unique_paths_with_obstacles([ ... \\"000\\", ... \\"010\\", ... \\"000\\" ... ]) 2 >>> unique_paths_with_obstacles([ ... \\"000\\", ... \\"111\\", ... \\"000\\" ... ]) 0 def solve_maze_solving_robot(test_cases: List[List[str]]) -> List[int]: For each test case, output the number of unique paths from the top-left corner to the bottom-right corner of the grid. >>> solve_maze_solving_robot([ ... [\\"000\\", ... \\"010\\", ... \\"000\\"], ... [\\"000\\", ... \\"111\\", ... \\"000\\"] ... ]) [2, 0] >>> solve_maze_solving_robot([ ... [\\"01\\", ... \\"10\\"], ... [\\"00\\", ... \\"00\\"] ... ]) [0, 2] from solution import unique_paths_with_obstacles, solve_maze_solving_robot def test_unique_paths_with_obstacles(): grid1 = [ \\"000\\", \\"010\\", \\"000\\" ] assert unique_paths_with_obstacles(grid1) == 2 grid2 = [ \\"000\\", \\"111\\", \\"000\\" ] assert unique_paths_with_obstacles(grid2) == 0 grid3 = [ \\"01\\", \\"10\\" ] assert unique_paths_with_obstacles(grid3) == 0 grid4 = [ \\"00\\", \\"00\\" ] assert unique_paths_with_obstacles(grid4) == 2 grid5 = [ \\"0\\" ] assert unique_paths_with_obstacles(grid5) == 1 def test_solve_maze_solving_robot(): test_cases = [ [ \\"000\\", \\"010\\", \\"000\\" ], [ \\"000\\", \\"111\\", \\"000\\" ] ] assert solve_maze_solving_robot(test_cases) == [2, 0] test_cases = [ [ \\"01\\", \\"10\\" ], [ \\"00\\", \\"00\\" ] ] assert solve_maze_solving_robot(test_cases) == [0, 2] test_cases = [ [ \\"0\\" ] ] assert solve_maze_solving_robot(test_cases) == [1] test_cases = [ [ \\"1\\" ] ] assert solve_maze_solving_robot(test_cases) == [0]","solution":"def unique_paths_with_obstacles(grid): X = len(grid) Y = len(grid[0]) if grid[0][0] == '1' or grid[X-1][Y-1] == '1': return 0 # Init DP table dp = [[0] * Y for _ in range(X)] dp[0][0] = 1 for i in range(X): for j in range(Y): if grid[i][j] == '0': if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[X-1][Y-1] def solve_maze_solving_robot(test_cases): results = [] for grid in test_cases: results.append(unique_paths_with_obstacles(grid)) return results"},{"question":"def isIsomorphic(s: str, t: str) -> bool: Check if two strings s and t are isomorphic. Examples: >>> isIsomorphic('egg', 'add') True >>> isIsomorphic('foo', 'bar') False >>> isIsomorphic('paper', 'title') True >>> isIsomorphic('ab', 'aa') False","solution":"def isIsomorphic(s, t): Check if two strings s and t are isomorphic. if len(s) != len(t): return False s_to_t_mapping = {} t_to_s_mapping = {} for char_s, char_t in zip(s, t): if char_s in s_to_t_mapping: if s_to_t_mapping[char_s] != char_t: return False else: s_to_t_mapping[char_s] = char_t if char_t in t_to_s_mapping: if t_to_s_mapping[char_t] != char_s: return False else: t_to_s_mapping[char_t] = char_s return True"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of the grid, avoiding the blocked cells. >>> unique_paths_with_obstacles([[0, 0, 1], [0, 0, 0], [0, 1, 0]]) == 2 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 6","solution":"def unique_paths_with_obstacles(grid): if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def calculate_total_cost(n, c, t, d, p): Calculate the total cost for the company for one day, given the number of vans, capacity, cycle time, daily operational time, and penalty. >>> calculate_total_cost(2, 100, 3, 24, 5) 1600 * 5 >>> calculate_total_cost(3, 150, 2, 30, 10) 6750 * 10 def process_input(input_data): Process the input data containing multiple test cases and returns a list of results for each test case. >>> process_input([\\"2 100 3 24 5\\", \\"3 150 2 30 10\\", \\"0 0 0 0 0\\"]) [8000, 67500]","solution":"def calculate_total_cost(n, c, t, d, p): if n == 0 and c == 0 and t == 0 and d == 0 and p == 0: return None total_capacity_per_van_per_day = (d // t) * c total_capacity_all_vans_per_day = total_capacity_per_van_per_day * n penalty_cost = total_capacity_all_vans_per_day * p return penalty_cost def process_input(input_data): results = [] for line in input_data: n, c, t, d, p = map(int, line.split()) if n == 0 and c == 0 and t == 0 and d == 0 and p == 0: break results.append(calculate_total_cost(n, c, t, d, p)) return results"},{"question":"def findFibonacci(n: int) -> list: Returns the first n terms of the Fibonacci sequence. >>> findFibonacci(1) [0] >>> findFibonacci(2) [0, 1] >>> findFibonacci(5) [0, 1, 1, 2, 3] >>> findFibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def findFibonacci(n): Returns the first n terms of the Fibonacci sequence. if n == 1: return [0] elif n == 2: return [0, 1] fib_sequence = [0, 1] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring of s that does not contain any repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring of s that does not contain any repeating characters. char_index_map = {} start = 0 max_length = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def wordTransformation(start: str, end: str, valid_words: List[str]) -> List[str]: Finds the shortest transformation sequence from start to end where each word in the sequence is in valid_words and only one letter differs from the previous word. Args: start (str): The starting word. end (str): The ending word. valid_words (List[str]): The list of valid words for transformation. Returns: List[str]: The shortest transformation sequence if exists, otherwise an empty list. Examples: >>> wordTransformation(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] >>> wordTransformation(\\"hit\\", \\"top\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) [] >>> wordTransformation(\\"hit\\", \\"hot\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) [\\"hit\\", \\"hot\\"] from typing import List def test_word_transformation_case_1(): valid_words = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] assert wordTransformation(\\"hit\\", \\"cog\\", valid_words) == [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] def test_word_transformation_case_2(): valid_words = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] assert wordTransformation(\\"hit\\", \\"top\\", valid_words) == [] def test_word_transformation_case_3(): valid_words = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] assert wordTransformation(\\"hit\\", \\"hot\\", valid_words) == [\\"hit\\", \\"hot\\"] def test_word_transformation_case_4(): valid_words = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] assert wordTransformation(\\"hit\\", \\"log\\", valid_words) == [\\"hit\\", \\"hot\\", \\"lot\\", \\"log\\"] def test_word_transformation_case_5(): valid_words = [\\"abc\\", \\"acc\\", \\"bcc\\", \\"ccc\\"] assert wordTransformation(\\"aaa\\", \\"ccc\\", valid_words) == [] def test_word_transformation_same_start_end(): valid_words = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] assert wordTransformation(\\"hit\\", \\"hit\\", valid_words) == [\\"hit\\"] def test_word_transformation_end_not_in_valid_words(): valid_words = [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] assert wordTransformation(\\"hit\\", \\"cog\\", valid_words) == []","solution":"from collections import deque def wordTransformation(start, end, valid_words): Finds the shortest transformation sequence from start to end where each word in the sequence is in valid_words and only one letter differs from the previous word. if start == end: return [start] valid_words = set(valid_words) if end not in valid_words: return [] queue = deque([(start, [start])]) visited = set() while queue: current_word, path = queue.popleft() visited.add(current_word) for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word == end: return path + [next_word] if next_word in valid_words and next_word not in visited: queue.append((next_word, path + [next_word])) visited.add(next_word) return []"},{"question":"def min_cost_path(matrix: List[List[int]]) -> int: Given a matrix of non-negative integers, returns the minimum cost path from the top-left corner to the bottom-right corner. >>> min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path([[5]]) 5 >>> min_cost_path([[1, 2], [1, 1]]) 3 >>> min_cost_path([[1, 2, 3], [4, 5, 6]]) 12 >>> min_cost_path([[1, 2], [4, 5], [7, 8]]) 16","solution":"def min_cost_path(matrix): Given a matrix of non-negative integers, returns the minimum cost path from the top-left corner to the bottom-right corner. Args: matrix (list of list of int): a 2D array where each element is an integer Returns: int: the minimum cost to reach the bottom-right corner n = len(matrix) m = len(matrix[0]) # Create a cost matrix to store the minimum path cost up to each cell cost = [[0] * m for _ in range(n)] # Initialize the top-left corner cost[0][0] = matrix[0][0] # Initialize the first row (can only move right) for j in range(1, m): cost[0][j] = cost[0][j-1] + matrix[0][j] # Initialize the first column (can only move down) for i in range(1, n): cost[i][0] = cost[i-1][0] + matrix[i][0] # Fill the cost matrix for i in range(1, n): for j in range(1, m): cost[i][j] = matrix[i][j] + min(cost[i-1][j], cost[i][j-1]) return cost[-1][-1]"},{"question":"def draw_diamond(n): Draw a diamond pattern using asterisks ('*') to impress your fellow wizards. Each row of the diamond is centered, and the middle row contains 2*n + 1 asterisks. The top half has increasing numbers of asterisks, and the bottom half mirrors the top half. Args: n (int): The number of rows in the top half of the diamond excluding the middle row. Returns: None: Prints the diamond pattern directly. -----Example----- >>> draw_diamond(3) * *** ***** ******* ***** *** *","solution":"def draw_diamond(n): Draws a diamond pattern with 2*n + 1 rows. Args: n (int): The number of rows in the top half of the diamond excluding the middle row. Returns: None: Prints the diamond pattern directly. rows = 2 * n + 1 max_width = 2 * n + 1 for i in range(n): num_asterisks = 2 * i + 1 spaces = (max_width - num_asterisks) // 2 print(' ' * spaces + '*' * num_asterisks) print('*' * max_width) for i in range(n - 1, -1, -1): num_asterisks = 2 * i + 1 spaces = (max_width - num_asterisks) // 2 print(' ' * spaces + '*' * num_asterisks)"},{"question":"def accum(s: str) -> str: Given a string s, return a new string in such a way that each character in s is multiplied by its 1-based index, with each repetition of the character alternating between uppercase and lowercase letters, starting with uppercase for the first occurrence, lowercase for the second, and so on. Each set of repeated characters for a given index should be joined with a hyphen (\`-\`). >>> accum(\\"abcd\\") 'A-Bb-Ccc-Dddd' >>> accum(\\"RqaEzty\\") 'R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy' >>> accum(\\"cwAt\\") 'C-Ww-Aaa-Tttt' >>> accum(\\"A\\") 'A' >>> accum(\\"z\\") 'Z' >>> accum(\\"\\") '' >>> accum(\\"aaa\\") 'A-Aa-Aaa' >>> accum(\\"zzz\\") 'Z-Zz-Zzz'","solution":"def accum(s): Given a string s, return a new string such that each character in the string is multiplied by its 1-based index, alternating between uppercase and lowercase starting with uppercase. result = [] for index, char in enumerate(s): result.append(char.upper() + (char.lower() * index)) return '-'.join(result)"},{"question":"def min_moves(x1, y1, x2, y2): Returns the minimum number of moves required to reach from (x1, y1) to (x2, y2). >>> min_moves(0, 0, 0, 0) == 0 >>> min_moves(5, 5, 5, 5) == 0 >>> min_moves(0, 0, 5, 0) == 5 >>> min_moves(0, 0, 0, 5) == 5 >>> min_moves(0, 0, 3, 4) == 7 >>> min_moves(1, 2, 4, 6) == 7 >>> min_moves(0, 0, 1000, 1000) == 2000","solution":"def min_moves(x1, y1, x2, y2): Returns the minimum number of moves required to reach from (x1, y1) to (x2, y2). return abs(x2 - x1) + abs(y2 - y1)"},{"question":"import re from collections import defaultdict from typing import Dict def word_frequency(sentence: str) -> Dict[str, int]: Write a function that takes a string containing a sentence and returns a dictionary with the word frequency count. The function should ignore punctuation and be case-insensitive. Examples: >>> word_frequency(\\"Hello, hello! How are you?\\") {'hello': 2, 'how': 1, 'are': 1, 'you': 1} >>> word_frequency(\\"\\") {} >>> word_frequency(\\"!!! ,,, ???\\") {}","solution":"import re from collections import defaultdict def word_frequency(sentence): Returns a dictionary with the word frequency count from the given sentence. The function ignores punctuation and is case-insensitive. if not sentence or not sentence.strip(): return {} # Convert to lowercase and remove punctuation words = re.findall(r'bw+b', sentence.lower()) freq_dict = defaultdict(int) for word in words: freq_dict[word] += 1 return dict(freq_dict)"},{"question":"class TextEditor: You have been tasked with implementing a basic text editor with undo functionality. The editor supports two operations: appending a string to the document and deleting the last \`k\` characters. Additionally, it supports an undo functionality, which reverts the document to its state before the last operation. Example usage: >>> editor = TextEditor() >>> editor.append(\\"hello\\") >>> editor.append(\\"world\\") >>> editor.get_document() == \\"helloworld\\" True >>> editor.delete(5) >>> editor.get_document() == \\"hello\\" True >>> editor.undo() >>> editor.get_document() == \\"helloworld\\" True >>> editor.undo() >>> editor.get_document() == \\"hello\\" True def __init__(self): # Initializes the text editor with an empty document. pass def append(self, string: str) -> None: # Appends the given string to the end of the current document. pass def delete(self, k: int) -> None: # Deletes the last k characters from the current document. pass def undo(self) -> None: # Reverts the document to its state before the last operation (append or delete). pass def get_document(self) -> str: # Returns the current state of the document. pass","solution":"class TextEditor: def __init__(self): self.document = \\"\\" self.history = [] def append(self, string: str) -> None: self.history.append(self.document) self.document += string def delete(self, k: int) -> None: self.history.append(self.document) self.document = self.document[:-k] def undo(self) -> None: if self.history: self.document = self.history.pop() def get_document(self) -> str: return self.document"},{"question":"from typing import List, Tuple def find_exit_route(grid: List[List[int]]) -> List[Tuple[int, int]]: Find a path from the top-left corner to the exit point in the grid. If there is no such path, return an empty list. Args: grid (List[List[int]]): 2D list representing the grid where 0 is an empty cell, 1 is an obstacle, and 2 is the exit point. Returns: List[Tuple[int, int]]: A list of tuples representing the path coordinates from start to exit. Examples: >>> grid = [ ... [0, 0, 1, 0], ... [1, 0, 1, 0], ... [1, 0, 0, 0], ... [0, 1, 1, 2] ... ] >>> find_exit_route(grid) [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2), (2, 3), (3, 3)] >>> grid = [ ... [0, 0, 1, 0], ... [1, 1, 1, 0], ... [1, 0, 0, 0], ... [0, 1, 1, 2] ... ] >>> find_exit_route(grid) []","solution":"from typing import List, Tuple from collections import deque def find_exit_route(grid: List[List[int]]) -> List[Tuple[int, int]]: Find a path from the top-left corner to the exit point in the grid. If there is no such path, return an empty list. if not grid or grid[0][0] == 1: return [] rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([((0, 0), [(0, 0)])]) visited = set() visited.add((0, 0)) while queue: (current_row, current_col), path = queue.popleft() if grid[current_row][current_col] == 2: return path for dr, dc in directions: new_row, new_col = current_row + dr, current_col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and grid[new_row][new_col] != 1: visited.add((new_row, new_col)) queue.append(((new_row, new_col), path + [(new_row, new_col)])) return []"},{"question":"import math def calculate_plant_height(plant_type: str, initial_height: float, duration: int) -> float: Calculate the height of a plant after a given duration based on its growth rate. Parameters: - plant_type: 'slow' or 'fast', indicating the growth rate type - initial_height: the initial height of the plant in centimeters - duration: the duration for the growth measurement in days (rounded to nearest whole number) Returns: - The height of the plant at the end of the given duration, rounded to the nearest tenth pass # Example test cases def test_slow_growth_plant_below_100(): assert calculate_plant_height('slow', 10, 30) == round(10 * math.exp(0.03 * 30), 1) def test_fast_growth_plant_below_100(): assert calculate_plant_height('fast', 10, 15) == round(10 * math.exp(0.07 * 15), 1) def test_slow_growth_plant_reaches_100(): assert calculate_plant_height('slow', 50, 30) == 100.0 def test_fast_growth_plant_reaches_100(): assert calculate_plant_height('fast', 30, 20) == 100.0 def test_initial_height_100(): assert calculate_plant_height('slow', 100, 10) == 100.0 assert calculate_plant_height('fast', 100, 10) == 100.0 def test_invalid_plant_type(): with pytest.raises(ValueError): calculate_plant_height('medium', 10, 10) def test_negative_initial_height(): with pytest.raises(ValueError): calculate_plant_height('slow', -10, 10) def test_negative_duration(): assert calculate_plant_height('slow', 10, -10) == round(10 * math.exp(0.03 * -10), 1) def test_non_integer_duration(): assert calculate_plant_height('slow', 10, 7.5) == round(10 * math.exp(0.03 * 8), 1) assert calculate_plant_height('fast', 10, 7.4) == round(10 * math.exp(0.07 * 7), 1) def test_large_duration(): assert calculate_plant_height('slow', 1, 500) == 100.0 assert calculate_plant_height('fast', 1, 100) == 100.0","solution":"import math def calculate_plant_height(plant_type: str, initial_height: float, duration: int) -> float: Calculate the height of a plant after a given duration based on its growth rate. Parameters: - plant_type: 'slow' or 'fast', indicating the growth rate type - initial_height: the initial height of the plant in centimeters - duration: the duration for the growth measurement in days (rounded to nearest whole number) Returns: - The height of the plant at the end of the given duration, rounded to the nearest tenth # Validate plant_type if plant_type not in ['slow', 'fast']: raise ValueError(\\"Invalid plant type. Must be 'slow' or 'fast'.\\") # Validate initial_height if initial_height < 0: raise ValueError(\\"Initial height cannot be negative.\\") # Validate duration and round to nearest whole number if not isinstance(duration, int): duration = round(duration) # Growth rate based on plant type growth_rate = 0.03 if plant_type == 'slow' else 0.07 # Calculate height using exponential growth model height = initial_height * math.exp(growth_rate * duration) # If height is >= 100 cm, cap it at 100 cm if height >= 100: height = 100.0 # Round height to the nearest tenth return round(height, 1)"},{"question":"from collections import Counter import heapq from typing import List, Tuple def rearrange_blocks(n: int, blocks: List[int]) -> Tuple[str, List[int]]: Rearrange blocks so that no two adjacent blocks have the same color. Parameters: n (int): Number of blocks blocks (list of int): List of colors of blocks Returns: tuple: (\\"YES\\", rearranged_blocks) or (\\"NO\\", ) >>> rearrange_blocks(5, [1, 1, 1, 2, 2]) ('YES', [1, 2, 1, 2, 1]) >>> rearrange_blocks(3, [3, 3, 3]) ('NO',) pass # Unit tests def test_simple_case(): n = 5 blocks = [1, 1, 1, 2, 2] result = rearrange_blocks(n, blocks) assert result[0] == \\"YES\\" assert result[1] == [1, 2, 1, 2, 1] or result[1] == [2, 1, 2, 1, 1] def test_impossible_case(): n = 3 blocks = [3, 3, 3] result = rearrange_blocks(n, blocks) assert result == (\\"NO\\",) def test_all_same_blocks(): n = 4 blocks = [1, 1, 1, 1] result = rearrange_blocks(n, blocks) assert result == (\\"NO\\",) def test_already_valid(): n = 4 blocks = [1, 2, 1, 2] result = rearrange_blocks(n, blocks) assert result[0] == \\"YES\\" assert result[1] == [1, 2, 1, 2] or result[1] == [2, 1, 2, 1] def test_complex_case(): n = 6 blocks = [1, 1, 1, 2, 2, 3] result = rearrange_blocks(n, blocks) assert result[0] == \\"YES\\" rearranged = result[1] for i in range(len(rearranged) - 1): assert rearranged[i] != rearranged[i + 1]","solution":"from collections import Counter import heapq def rearrange_blocks(n, blocks): Rearrange blocks so that no two adjacent blocks have the same color. Parameters: n (int): Number of blocks blocks (list of int): List of colors of blocks Returns: tuple: (\\"YES\\", rearranged_blocks) or (\\"NO\\", ) counter = Counter(blocks) max_occurrences = max(counter.values()) # Check if it's possible to rearrange blocks if max_occurrences > (n + 1) // 2: return (\\"NO\\", ) # Max heap to store blocks by their count max_heap = [(-cnt, color) for color, cnt in counter.items()] heapq.heapify(max_heap) prev_count, prev_color = 0, None rearranged = [] while max_heap: count, color = heapq.heappop(max_heap) rearranged.append(color) # If there's a previously used color to add back to heap if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_color)) # Prepare the current color to be used in the next round prev_count, prev_color = count + 1, color return (\\"YES\\", rearranged)"},{"question":"from typing import List def max_height_difference(heights: List[int]) -> int: Returns the maximum height difference between two trees such that the shorter tree is positioned before the taller tree. >>> max_height_difference([3, 1, 4, 2, 5]) 4 >>> max_height_difference([9, 7, 3, 1, 2, 6]) 5 >>> max_height_difference([1, 2, 3, 4, 5, 6]) 5 >>> max_height_difference([6, 5, 4, 3, 2, 1]) 0 >>> max_height_difference([1, 3, 2, 4, 2, 5]) 4 >>> max_height_difference([1, 5]) 4 >>> max_height_difference([5, 1]) 0 >>> max_height_difference([2, 8, 1, 10]) 9 >>> max_height_difference([4, 4, 4, 4]) 0","solution":"def max_height_difference(heights): Returns the maximum height difference between two trees such that the shorter tree is positioned before the taller tree. max_diff = 0 min_height = heights[0] for height in heights[1:]: if height > min_height: max_diff = max(max_diff, height - min_height) min_height = min(min_height, height) return max_diff"},{"question":"def next_alphabet(s: str) -> str: Write a function that takes a string as input and returns a new string where each character in the original string is replaced with the next character in the alphabet. The replacement should be case-sensitive, meaning 'a' should become 'b', 'z' should become 'a', 'A' should become 'B', and 'Z' should become 'A'. Spaces and non-alphabet characters should remain the same. >>> next_alphabet('Hello World!') == \\"Ifmmp Xpsme!\\" >>> next_alphabet('Zebra') == \\"Afcsb\\" >>> next_alphabet('Python-3.8') == \\"Qzuipo-3.8\\"","solution":"def next_alphabet(s: str) -> str: def shift_char(c): if 'a' <= c <= 'z': return 'a' if c == 'z' else chr(ord(c) + 1) elif 'A' <= c <= 'Z': return 'A' if c == 'Z' else chr(ord(c) + 1) return c return ''.join(shift_char(c) for c in s)"},{"question":"from typing import List def group_anagrams(strs: List[str]) -> List[List[str]]: Groups a list of strings into anagram groups and returns them as a list of lists. Example 1: >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] Example 2: >>> group_anagrams([\\"\\"]) [['']] Example 3: >>> group_anagrams([\\"a\\"]) [['a']]","solution":"from collections import defaultdict def group_anagrams(strs): Groups a list of strings into anagram groups and returns them as a list of lists. Args: strs (List[str]): A list of strings. Returns: List[List[str]]: A list of lists containing grouped anagrams. anagrams = defaultdict(list) for s in strs: # Sort the string to get the anagram key sorted_str = ''.join(sorted(s)) anagrams[sorted_str].append(s) return list(anagrams.values())"},{"question":"def max_unique_genres(test_cases): Find the maximum number of unique genres Hana can place on the special shelf. Args: test_cases: List of tuples, where each tuple contains: - N: Number of books (int) - Pmax: Maximum page limit (int) - books: List of tuples (pi, gi), where pi is the number of pages and gi is the genre of a book Returns: List of integers, where each integer is the maximum number of unique genres for a test case. Examples: >>> test_cases = [ ... (5, 15, [(3, 1), (5, 2), (6, 3), (4, 1), (8, 4)]), ... (3, 10, [(3, 1), (3, 2), (5, 1)]) ... ] >>> max_unique_genres(test_cases) [3, 2] # Define test function def test_max_unique_genres(): test_cases = [ (5, 15, [(3, 1), (5, 2), (6, 3), (4, 1), (8, 4)]), (3, 10, [(3, 1), (3, 2), (5, 1)]), (4, 7, [(2, 1), (3, 2), (4, 3), (1, 1)]), (5, 20, [(5, 1), (6, 2), (3, 3), (8, 4), (2, 2)]) ] results = max_unique_genres(test_cases) assert results == [3, 2, 2, 4] if __name__ == '__main__': test_max_unique_genres()","solution":"def max_unique_genres(test_cases): results = [] for test in test_cases: N, Pmax, books = test genre_pages = {} # Aggregate minimum pages for each genre for pages, genre in books: if genre in genre_pages: genre_pages[genre] = min(genre_pages[genre], pages) else: genre_pages[genre] = pages # Sort genres by their minimum pages, ascending sorted_genres = sorted(genre_pages.values()) total_pages = 0 unique_genres = 0 for pages in sorted_genres: if total_pages + pages <= Pmax: total_pages += pages unique_genres += 1 else: break results.append(unique_genres) return results"},{"question":"from typing import List def calculate_average(scores: List[int]) -> int: Calculate the average score of a group of students rounded down to the nearest integer. If the list is empty, return 0. >>> calculate_average([70, 80, 90]) == 80 >>> calculate_average([100, 99, 98, 97]) == 98 >>> calculate_average([]) == 0 >>> calculate_average([60, 70, 80, 90, 100]) == 80 >>> calculate_average([50]) == 50 >>> calculate_average([75, 75, 75, 75, 75]) == 75 >>> calculate_average([58, 72, 87, 91, 33, 67, 92]) == 71","solution":"from typing import List def calculate_average(scores: List[int]) -> int: Calculate the average score rounded down to the nearest integer. If the list is empty, return 0. if not scores: return 0 total_scores = sum(scores) count_scores = len(scores) average_score = total_scores // count_scores return average_score"},{"question":"import re from typing import List def isValidLicensePlate(licensePlate: str) -> bool: Returns True if the license plate is in the format 'AAA-1234', otherwise False. >>> isValidLicensePlate(\\"ABZ-1234\\") True >>> isValidLicensePlate(\\"ABC-123\\") False >>> isValidLicensePlate(\\"A2B-3445\\") False >>> isValidLicensePlate(\\"ABC1234\\") False >>> isValidLicensePlate(\\"AbC-1234\\") False >>> isValidLicensePlate(\\"ABCD-12345\\") False >>> isValidLicensePlate(\\"AB-1234\\") False >>> isValidLicensePlate(\\"\\") False >>> isValidLicensePlate(\\"A@C-1234\\") False","solution":"import re def isValidLicensePlate(licensePlate): Returns True if the license plate is in the format 'AAA-1234', otherwise False. pattern = r'^[A-Z]{3}-d{4}' return bool(re.match(pattern, licensePlate))"},{"question":"def reverse_words(string: str) -> List[str]: Write a function that takes a string of words separated by one or more whitespace characters and returns a list of words in the reverse order of their appearance. >>> reverse_words(\\"The quick brown fox jumps over the lazy dog\\") ['dog', 'lazy', 'the', 'over', 'jumps', 'fox', 'brown', 'quick', 'The'] >>> reverse_words(\\"hello world\\") ['world', 'hello'] >>> reverse_words(\\"one two three\\") ['three', 'two', 'one'] >>> reverse_words(\\"a b c\\") ['c', 'b', 'a'] >>> reverse_words(\\"singleword\\") ['singleword'] >>> reverse_words(\\"multiple spaces\\") ['spaces', 'multiple']","solution":"def reverse_words(string): Takes a string of words separated by one or more whitespace characters and returns a list of words in the reverse order of their appearance. words = string.split() return words[::-1]"},{"question":"def can_form_palindrome(s: str, k: int) -> bool: Determine if the string \`s\` can be rearranged into a palindrome by removing up to \`k\` characters. >>> can_form_palindrome(\\"civic\\", 0) True >>> can_form_palindrome(\\"ivicc\\", 0) True >>> can_form_palindrome(\\"hello\\", 1) False >>> can_form_palindrome(\\"racecar\\", 1) True from collections import Counter def test_can_form_palindrome_exact_palindrome(): assert can_form_palindrome(\\"civic\\", 0) == True def test_can_form_palindrome_near_palindrome(): assert can_form_palindrome(\\"ivicc\\", 0) == True def test_can_form_palindrome_not_possible(): assert can_form_palindrome(\\"hello\\", 1) == False def test_can_form_palindrome_with_removal(): assert can_form_palindrome(\\"racecar\\", 1) == True assert can_form_palindrome(\\"hello\\", 2) == True def test_can_form_palindrome_single_character(): assert can_form_palindrome(\\"a\\", 0) == True def test_can_form_palindrome_no_removal_needed(): assert can_form_palindrome(\\"aabbcc\\", 0) == True def test_can_form_palindrome_high_k(): assert can_form_palindrome(\\"abcdef\\", 5) == True def test_can_form_palindrome_exact_reduction(): assert can_form_palindrome(\\"aab\\", 1) == True def test_can_form_palindrome_one_off_odd_count(): assert can_form_palindrome(\\"aabbccc\\", 1) == True def test_can_form_palindrome_insufficient_removal(): assert can_form_palindrome(\\"abcd\\", 1) == False","solution":"def can_form_palindrome(s, k): Determine if the string \`s\` can be rearranged into a palindrome by removing up to \`k\` characters. from collections import Counter char_counts = Counter(s) odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # We can have at most one character with an odd count in a palindrome # Remove up to \`k\` characters to potentially reduce odd counts if odd_count - k <= 1: return True return False"},{"question":"def shortest_subarray_length(arr, x): Returns the length of the shortest subarray whose sum is strictly greater than x. If no such subarray exists, returns -1. >>> shortest_subarray_length([1, 4, 45, 6, 0, 19], 51) 3 >>> shortest_subarray_length([1, 10, 5, 2, 7], 9) 1 >>> shortest_subarray_length([1, 2, 3, 4], 100) -1","solution":"def shortest_subarray_length(arr, x): Returns the length of the shortest subarray whose sum is strictly greater than x. If no such subarray exists, returns -1. n = len(arr) min_len = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > x: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len != float('inf') else -1"},{"question":"def word_lengths(s: str) -> List[int]: Write a function that takes a string of words separated by spaces and returns a list of the lengths of those words. Handles multiple spaces between words, leading, and trailing spaces gracefully. >>> word_lengths(\\"hello world\\") [5, 5] >>> word_lengths(\\" fly me to the moon\\") [3, 2, 2, 3, 4] >>> word_lengths(\\"a \\") [1] >>> word_lengths(\\" code challenges \\") [4, 10] pass","solution":"def word_lengths(s): Returns a list of lengths of words in the input string s, where words are separated by spaces. Handles multiple spaces between words, and leading and trailing spaces. words = s.split() return [len(word) for word in words]"},{"question":"def average_age(ages: List[float]) -> float: Returns the average age of a list of ages, rounded to two decimal places. If the list is empty, returns 0. >>> average_age([20, 30, 40]) 30.00 >>> average_age([10, 20, 30, 40, 50]) 30.00 >>> average_age([]) 0 >>> average_age([25]) 25.00 >>> average_age([20.5, 30.5, 40.5]) 30.50 >>> average_age([20.123, 30.456, 40.789]) 30.46","solution":"def average_age(ages): Returns the average age of a list of ages, rounded to two decimal places. If the list is empty, returns 0. if not ages: return 0 return round(sum(ages) / len(ages), 2)"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns a new list where each element is the product of all other elements in the original list except for the one at that index. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([0, 1, 2, 3]) [6, 0, 0, 0] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([10]) [1] >>> product_except_self([]) [] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1]","solution":"def product_except_self(nums): Returns a new list where each element is the product of all other elements in the original list except for the one at that index. length = len(nums) if length == 0: return [] # Initialize the output array with ones output = [1] * length # Calculate products of elements before the current index left_product = 1 for i in range(length): output[i] = left_product left_product *= nums[i] # Calculate products of elements after the current index right_product = 1 for i in range(length - 1, -1, -1): output[i] *= right_product right_product *= nums[i] return output"},{"question":"def fixDateFormat(date_str: str) -> str: Takes a date string in the format MM-DD-YYYY and returns it in the format YYYY/MM/DD. If the input is invalid, returns an appropriate error message. >>> fixDateFormat(\\"01-05-2023\\") \\"2023/01/05\\" >>> fixDateFormat(\\"12-31-2020\\") \\"2020/12/31\\" >>> fixDateFormat(\\"06-15-1995\\") \\"1995/06/15\\" >>> fixDateFormat(\\"1-5-2023\\") \\"Invalid date format\\" >>> fixDateFormat(\\"01-5-2023\\") \\"Invalid date format\\" >>> fixDateFormat(\\"01/05/2023\\") \\"Invalid date format\\" >>> fixDateFormat(\\"01-05-23\\") \\"Invalid date format\\" >>> fixDateFormat(\\"January 5 2023\\") \\"Invalid date format\\" >>> fixDateFormat(\\"\\") \\"Invalid date format\\" >>> fixDateFormat(\\"2023-01-05\\") \\"Invalid date format\\" >>> fixDateFormat(\\"05-2023-01\\") \\"Invalid date format\\"","solution":"def fixDateFormat(date_str): Takes a date string in the format MM-DD-YYYY and returns it in the format YYYY/MM/DD. If the input is invalid, returns an appropriate error message. try: month, day, year = date_str.split('-') if len(month) == 2 and len(day) == 2 and len(year) == 4: return f\\"{year}/{month}/{day}\\" else: return \\"Invalid date format\\" except ValueError: return \\"Invalid date format\\""},{"question":"def convert_to_minutes(zogday, zoghour, zogminute): Convert time in zogdays, zoghours, and zogminutes to total zogminutes. return zogday * 24 * 60 + zoghour * 60 + zogminute def check_events_overlap(events): Determine if any two events in a list overlap. Each event is represented by a start time and duration. Parameters: events (list): List of events, each represented as ((zz, hh, mm), (dz, dh, dm)) Returns: str: \\"YES\\" if any events overlap, \\"NO\\" otherwise. Examples: >>> check_events_overlap([((1, 5, 30), (0, 5, 0)), ((1, 10, 0), (0, 10, 30)), ((2, 0, 0), (0, 2, 0))]) 'YES' # Implementation here def test_no_overlap(): events = [ ((1, 5, 30), (0, 5, 0)), ((1, 10, 30), (0, 10, 0)), ((2, 20, 0), (0, 2, 0)) ] assert check_events_overlap(events) == \\"NO\\" def test_overlap_same_start_time(): events = [ ((1, 5, 30), (0, 5, 0)), ((1, 5, 30), (0, 10, 0)) ] assert check_events_overlap(events) == \\"YES\\" def test_overlap_adjacent_times(): events = [ ((1, 5, 30), (0, 5, 0)), ((1, 10, 0), (0, 0, 30)), ((1, 9, 30), (0, 1, 30)) ] assert check_events_overlap(events) == \\"YES\\" def test_no_overlap_with_gap(): events = [ ((1, 5, 30), (0, 5, 0)), ((1, 11, 0), (0, 1, 0)), ((1, 12, 30), (1, 0, 0)) ] assert check_events_overlap(events) == \\"NO\\" def test_partial_overlap(): events = [ ((1, 5, 30), (0, 5, 0)), ((1, 10, 0), (0, 5, 0)), ((1, 9, 0), (0, 3, 0)) ] assert check_events_overlap(events) == \\"YES\\" # Running the tests if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def convert_to_minutes(zogday, zoghour, zogminute): Convert time in zogdays, zoghours, and zogminutes to total zogminutes. return zogday * 24 * 60 + zoghour * 60 + zogminute def check_events_overlap(events): Check if any two events overlap. event_times = [] for start_time, duration in events: zz, hh, mm = start_time dz, dh, dm = duration start_in_minutes = convert_to_minutes(zz, hh, mm) duration_in_minutes = convert_to_minutes(dz, dh, dm) end_in_minutes = start_in_minutes + duration_in_minutes event_times.append((start_in_minutes, end_in_minutes)) # Sort events by start time event_times.sort() for i in range(1, len(event_times)): if event_times[i][0] < event_times[i-1][1]: return \\"YES\\" return \\"NO\\" # Example usage events = [ ((1, 5, 30), (0, 5, 0)), ((1, 10, 0), (0, 10, 30)), ((2, 0, 0), (0, 2, 0)) ] print(check_events_overlap(events)) # Output: YES"},{"question":"from typing import List def is_valid_sudoku(grid: List[List[int]]) -> bool: Determine if a 9x9 Sudoku grid is valid. The grid is represented as a list of lists, where each sublist represents a row. Digits from 1 to 9 must satisfy the following rules: 1. Each row must contain the digits 1-9 without repetition. 2. Each column must contain the digits 1-9 without repetition. 3. Each of the 9 sub-grids, which are 3x3 in size, must contain the digits 1-9 without repetition. Empty cells are denoted by 0 and should be ignored in validation. Args: grid (List[List[int]]): A 9x9 Sudoku grid. Returns: bool: True if the grid is valid, False otherwise. Examples: >>> grid = [ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9] ... ] >>> is_valid_sudoku(grid) True >>> grid = [ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 7] ... ] >>> is_valid_sudoku(grid) False","solution":"from typing import List def is_valid_sudoku(grid: List[List[int]]) -> bool: # Helper function to check if a block (row, column, or sub-grid) is valid def is_valid_block(block: List[int]) -> bool: block = [num for num in block if num != 0] # Ignore the 0s return len(block) == len(set(block)) # Check rows for row in grid: if not is_valid_block(row): return False # Check columns for col in range(9): if not is_valid_block([grid[row][col] for row in range(9)]): return False # Check sub-grids for row in range(0, 9, 3): for col in range(0, 9, 3): block = [grid[r][c] for r in range(row, row + 3) for c in range(col, col + 3)] if not is_valid_block(block): return False return True"},{"question":"def is_target_achievable(n: int, m: int, ops: List[List[int]], x: int) -> bool: Determine if the target x can be achieved starting from 0 and performing each operation in ops exactly once. Args: n (int): Number of operations in ops. m (int): Not used, given but unnecessary in context. ops (List[List[int]]): List of operations, each operation is a pair [a, b]. x (int): Target integer to achieve. Returns: bool: True if target can be achieved, else False. Example: >>> is_target_achievable(4, 2, [[1, 2], [2, 1], [3, 3]], 2) True >>> is_target_achievable(3, 2, [[1, 2], [2, 1]], 4) False","solution":"def is_target_achievable(n, m, ops, x): Determine if the target x can be achieved starting from 0 and performing each operation in ops exactly once. Args: n (int): Number of operations in ops. m (int): Not used, given but unnecessary in context. ops (List[List[int]]): List of operations, each operation is a pair [a, b]. x (int): Target integer to achieve. Returns: bool: True if target can be achieved, else False. min_sum = 0 max_sum = 0 for op in ops: a, b = op min_sum += min(a, -b) max_sum += max(a, -b) return min_sum <= x <= max_sum"},{"question":"from typing import List def spiralOrder(matrix: List[List[int]]) -> List[int]: Given an m x n matrix, return all elements of the matrix in spiral order. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> spiralOrder(matrix) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> matrix = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ] >>> spiralOrder(matrix) [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] >>> matrix = [ ... [1, 2, 3, 4, 5] ... ] >>> spiralOrder(matrix) [1, 2, 3, 4, 5] >>> matrix = [ ... [1], ... [2], ... [3], ... [4] ... ] >>> spiralOrder(matrix) [1, 2, 3, 4] >>> matrix = [] >>> spiralOrder(matrix) [] >>> matrix = [ ... [42] ... ] >>> spiralOrder(matrix) [42] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> spiralOrder(matrix) [1, 2, 4, 3] >>> matrix = [ ... [100, 200, 300], ... [400, 500, 600], ... [700, 800, 900] ... ] >>> spiralOrder(matrix) [100, 200, 300, 600, 900, 800, 700, 400, 500]","solution":"from typing import List def spiralOrder(matrix: List[List[int]]) -> List[int]: Returns all elements of the matrix in spiral order. if not matrix: return [] result = [] while matrix: # Take the first row result += matrix.pop(0) # Take the last element of each remaining row if matrix and matrix[0]: for row in matrix: result.append(row.pop()) # Take the last row in reverse order if matrix: result += matrix.pop()[::-1] # Take the first element of each remaining row in reverse order if matrix and matrix[0]: for row in matrix[::-1]: result.append(row.pop(0)) return result"},{"question":"class MagicalGarden: def __init__(self, N): Initialize the magical garden with N types of flowers, all initially set to 0. self.flowers = [0] * (N + 1) def add_flowers(self, t: int, k: int): Add k flowers to the type t. Args: t: The type of flower. k: The number of flowers to add. self.flowers[t] += k def count_flowers(self, t1: int, t2: int) -> int: Count the total number of flowers from type t1 to type t2 (inclusive). Args: t1: The starting type of flower. t2: The ending type of flower. Returns: The sum of flowers between t1 and t2. return sum(self.flowers[t1:t2 + 1]) def process_queries(N: int, queries: List[str]) -> List[int]: Process a list of queries on the magical garden. Args: N: The number of flower types. queries: A list of queries in string format. Returns: A list of results for queries of type 2. >>> N = 3 >>> queries = [ ... \\"1 2 5\\", ... \\"1 1 10\\", ... \\"1 3 7\\", ... \\"2 1 2\\", ... \\"2 2 3\\", ... \\"2 1 3\\" ... ] >>> process_queries(N, queries) [15, 12, 22] >>> N = 3 >>> queries = [ ... \\"2 1 2\\", ... \\"2 2 3\\", ... \\"2 1 3\\" ... ] >>> process_queries(N, queries) [0, 0, 0] >>> N = 1000000 >>> queries = [ ... \\"1 500000 1000000\\", ... \\"2 499999 500001\\" ... ] >>> process_queries(N, queries) [1000000] >>> N = 1 >>> queries = [ ... \\"1 1 5\\", ... \\"2 1 1\\" ... ] >>> process_queries(N, queries) [5]","solution":"class MagicalGarden: def __init__(self, N): self.flowers = [0] * (N + 1) def add_flowers(self, t, k): self.flowers[t] += k def count_flowers(self, t1, t2): return sum(self.flowers[t1:t2+1]) def process_queries(N, queries): garden = MagicalGarden(N) result = [] for query in queries: parts = list(map(int, query.split())) if parts[0] == 1: _, t, k = parts garden.add_flowers(t, k) elif parts[0] == 2: _, t1, t2 = parts result.append(garden.count_flowers(t1, t2)) return result"},{"question":"def balanceParentheses(s: str) -> int: Returns the minimum number of insertions or deletions needed to make the parentheses balanced. >>> balanceParentheses(\\"()\\") == 0 >>> balanceParentheses(\\"(()\\") == 1 >>> balanceParentheses(\\"())\\") == 1 >>> balanceParentheses(\\")(\\") == 2 >>> balanceParentheses(\\"(\\") == 1 >>> balanceParentheses(\\")\\") == 1 >>> balanceParentheses(\\"((())\\") == 1 >>> balanceParentheses(\\"())(()\\") == 2 >>> balanceParentheses(\\"\\") == 0 >>> balanceParentheses(\\"(())()\\") == 0 >>> balanceParentheses(\\"((())(()\\") == 2","solution":"def balanceParentheses(s): Returns the minimum number of insertions or deletions needed to make the parentheses balanced. open_count = 0 # Count of open parentheses balance_actions = 0 # Count of actions (insertions or deletions) to balance the string for char in s: if char == '(': open_count += 1 else: # char == ')' if open_count > 0: open_count -= 1 else: balance_actions += 1 # We need an opening parenthesis # Any remaining open_count means we need closing parentheses balance_actions += open_count return balance_actions"},{"question":"def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into one sorted list in non-decreasing order. Parameters: list1 (list of int): The first sorted list to be merged. list2 (list of int): The second sorted list to be merged. Returns: list of int: A new sorted list containing all elements from list1 and list2.","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into one sorted list in non-decreasing order. Parameters: list1 (list of int): The first sorted list to be merged. list2 (list of int): The second sorted list to be merged. Returns: list of int: A new sorted list containing all elements from list1 and list2. merged_list = [] i, j = 0, 0 # Traverse both lists and append the smaller element to the merged_list while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If any elements remain in list1, add them to merged_list while i < len(list1): merged_list.append(list1[i]) i += 1 # If any elements remain in list2, add them to merged_list while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def rearrange_evens_first(input_list: List[int]) -> List[int]: Rearrange the list such that all even numbers appear before all the odd numbers while preserving the relative order of the even and odd numbers from the original list. Parameters: input_list (list): A list of integers Returns: list: A list with all even integers first, followed by all odd integers Examples: >>> rearrange_evens_first([3, 8, 5, 13, 6, 12, 7, 4]) [8, 6, 12, 4, 3, 5, 13, 7] >>> rearrange_evens_first([1, 3, 5, 7, 9]) [1, 3, 5, 7, 9] >>> rearrange_evens_first([2, 4, 6, 8]) [2, 4, 6, 8]","solution":"def rearrange_evens_first(input_list): Rearrange the list such that all even numbers appear before all the odd numbers while preserving the relative order of the even and odd numbers from the original list. Parameters: input_list (list): A list of integers Returns: list: A list with all even integers first, followed by all odd integers evens = [x for x in input_list if x % 2 == 0] odds = [x for x in input_list if x % 2 != 0] return evens + odds"},{"question":"def find_lus_length(s1: str, s2: str) -> int: Returns the length of the longest uncommon subsequence between s1 and s2. If the longest uncommon subsequence does not exist, returns -1. Examples: >>> find_lus_length(\\"abc\\", \\"cdc\\") 3 >>> find_lus_length(\\"aaa\\", \\"bbb\\") 3 >>> find_lus_length(\\"aaa\\", \\"aaa\\") -1","solution":"def find_lus_length(s1, s2): Returns the length of the longest uncommon subsequence between s1 and s2. If the longest uncommon subsequence does not exist, returns -1. if s1 == s2: return -1 return max(len(s1), len(s2))"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters for the input string s. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 pass def test_example_cases(): assert length_of_longest_substring(\\"abcabcbb\\") == 3 assert length_of_longest_substring(\\"bbbbb\\") == 1 assert length_of_longest_substring(\\"pwwkew\\") == 3 def test_empty_string(): assert length_of_longest_substring(\\"\\") == 0 def test_single_character_string(): assert length_of_longest_substring(\\"a\\") == 1 def test_case_sensitivity(): assert length_of_longest_substring(\\"aAbBcC\\") == 6 def test_end_case(): assert length_of_longest_substring(\\"END\\") == None def test_mixed_characters(): assert length_of_longest_substring(\\"dvdf\\") == 3 assert length_of_longest_substring(\\"anviaj\\") == 5 def test_longer_repeated_patterns(): assert length_of_longest_substring(\\"abcdeabcdea\\") == 5 def test_numbers_and_letters(): assert length_of_longest_substring(\\"123abc123\\") == 6","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters for the input string s. if s == \\"END\\": return None char_map = {} left_ptr = 0 max_length = 0 for right_ptr in range(len(s)): if s[right_ptr] in char_map: left_ptr = max(left_ptr, char_map[s[right_ptr]] + 1) char_map[s[right_ptr]] = right_ptr max_length = max(max_length, right_ptr - left_ptr + 1) return max_length"},{"question":"from typing import List, Tuple def min_meeting_rooms(meetings: List[Tuple[int, int]]) -> int: Returns the minimum number of meeting rooms required to accommodate all meetings without any conflicts. >>> min_meeting_rooms([(1, 5), (2, 6), (8, 9)]) 2 >>> min_meeting_rooms([(1, 3), (2, 4), (3, 5)]) 2 >>> min_meeting_rooms([(0, 30), (5, 10), (15, 20)]) 2 >>> min_meeting_rooms([(7, 10), (2, 4)]) 1 >>> min_meeting_rooms([(7, 10), (2, 4), (5, 7), (8, 11)]) 2 >>> min_meeting_rooms([(1,10)]) 1 >>> min_meeting_rooms([]) 0 >>> min_meeting_rooms([(1,2), (2,3), (3,4)]) 1 >>> min_meeting_rooms([(1, 5), (5, 10)]) 1 >>> min_meeting_rooms([(1, 2), (2, 3), (3, 4), (4, 5)]) 1 >>> min_meeting_rooms([(1, 4), (2, 5), (7, 8), (8, 9)]) 2","solution":"def min_meeting_rooms(meetings): Returns the minimum number of meeting rooms required to accommodate all meetings without any conflicts. if not meetings: return 0 # Separate start and end times start_times = sorted([meeting[0] for meeting in meetings]) end_times = sorted([meeting[1] for meeting in meetings]) start_pointer = 0 end_pointer = 0 used_rooms = 0 max_rooms = 0 while start_pointer < len(meetings): if start_times[start_pointer] < end_times[end_pointer]: used_rooms += 1 start_pointer += 1 else: used_rooms -= 1 end_pointer += 1 max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"def minimum_difference(N: int, nums: List[int]) -> int: Divide the list into two sublists such that the absolute difference between the sums of these two sublists is minimized. >>> minimum_difference(4, [1, 6, 11, 5]) 1 >>> minimum_difference(1, [10]) 10 >>> minimum_difference(4, [5, 5, 5, 5]) 0 >>> minimum_difference(2, [20, 30]) 10 >>> minimum_difference(100, [1000] * 100) 0 >>> minimum_difference(5, [3, 1, 4, 2, 2]) 0 >>> minimum_difference(3, [2, 1, 1]) 0 >>> minimum_difference(3, [1, 2, 3]) 0 >>> minimum_difference(3, [1, 1, 3]) 1","solution":"def minimum_difference(N, nums): total_sum = sum(nums) half_sum = total_sum // 2 dp = [[False] * (half_sum + 1) for _ in range(N + 1)] dp[0][0] = True for i in range(1, N + 1): for j in range(half_sum + 1): dp[i][j] = dp[i - 1][j] if j >= nums[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]] for j in range(half_sum, -1, -1): if dp[N][j]: sum1 = j break sum2 = total_sum - sum1 return abs(sum2 - sum1)"},{"question":"def find_pairs(arr: List[int], target: int) -> List[Tuple[int, int]]: Finds all unique pairs of integers in the array whose sum is equal to the target. :param arr: List of integers :param target: Target sum :return: List of tuples representing pairs >>> find_pairs([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> find_pairs([0, -1, 2, -3, 1], -2) [(-3, 1)] >>> find_pairs([1, -2, 3, 5, 7, -8, 4], 1) [(-2, 3)]","solution":"def find_pairs(arr, target): Finds all unique pairs of integers in the array whose sum is equal to the target. :param arr: List of integers :param target: Target sum :return: List of tuples representing pairs seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return sorted(pairs)"},{"question":"def count_balanced_substrings(s: str) -> int: Write a function that takes a string s consisting only of characters 'L' and 'R'. The function should return the number of balanced substrings. A balanced substring is one that contains an equal number of 'L' and 'R' characters, and all the balanced substrings in the input string should be disjoint (non-overlapping). Examples: >>> count_balanced_substrings(\\"RLRRLLRLRL\\") 4 >>> count_balanced_substrings(\\"RLLLLRRRLR\\") 3 >>> count_balanced_substrings(\\"LLLLRRRR\\") 1 >>> count_balanced_substrings(\\"RLRRRLLRLL\\") 2 >>> count_balanced_substrings(\\"LRLRLRLR\\") 4","solution":"def count_balanced_substrings(s: str) -> int: balance = 0 balanced_count = 0 for char in s: if char == 'L': balance += 1 elif char == 'R': balance -= 1 if balance == 0: balanced_count += 1 return balanced_count"},{"question":"def evaluate_expression(expression: str) -> str: Evaluates a mathematical expression containing numbers combined with the words \\"multiply\\" or \\"divide\\". The input string will always be a valid expression and produce an integer result. :param expression: str - The input expression string. :return: str - The result of the arithmetic operations as a string. >>> evaluate_expression(\\"10multiply2divide5\\") == \\"4\\" >>> evaluate_expression(\\"20divide2multiply3\\") == \\"30\\" >>> evaluate_expression(\\"5divide5multiply1\\") == \\"1\\" >>> evaluate_expression(\\"9multiply3divide3\\") == \\"9\\" >>> evaluate_expression(\\"8multiply2\\") == \\"16\\" >>> evaluate_expression(\\"8divide2\\") == \\"4\\" >>> evaluate_expression(\\"1000multiply1000divide1000000\\") == \\"1\\" >>> evaluate_expression(\\"999990multiply10divide99999\\") == \\"100\\" >>> evaluate_expression(\\"10multiply3divide2multiply4\\") == \\"60\\" >>> evaluate_expression(\\"90divide10multiply5divide3\\") == \\"15\\" >>> evaluate_expression(\\"1multiply1\\") == \\"1\\" >>> evaluate_expression(\\"1divide1\\") == \\"1\\" # Write your code here","solution":"def evaluate_expression(expression: str) -> str: Evaluates a mathematical expression containing numbers combined with the words \\"multiply\\" or \\"divide\\". The input string will always be a valid expression and produce an integer result. :param expression: str - The input expression string. :return: str - The result of the arithmetic operations as a string. # Replace words with symbols to simplify parsing expression = expression.replace(\\"multiply\\", \\"*\\") expression = expression.replace(\\"divide\\", \\"/\\") # Evaluate the modified expression result = eval(expression) return str(int(result)) # Convert the result to an integer and then to a string"},{"question":"def product_except_self(lst): Returns a list such that each element at index i is the product of all the numbers in the original list except the one at i. Division is not allowed. >>> product_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_except_self([3, 2, 1]) [2, 3, 6] >>> product_except_self([]) [] >>> product_except_self([10]) [1] >>> product_except_self([5, 10]) [10, 5] >>> product_except_self([1, 0, 3, 0]) [0, 0, 0, 0] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6]","solution":"def product_except_self(lst): Returns a list such that each element at index i is the product of all the numbers in the original list except the one at i. Division is not allowed. length = len(lst) if length == 0: return [] # Initialize lists for the prefix and suffix products prefix_products = [1] * length suffix_products = [1] * length # Calculate prefix products for i in range(1, length): prefix_products[i] = prefix_products[i - 1] * lst[i - 1] # Calculate suffix products for i in range(length - 2, -1, -1): suffix_products[i] = suffix_products[i + 1] * lst[i + 1] # Calculate the result by multiplying prefix and suffix products result = [prefix_products[i] * suffix_products[i] for i in range(length)] return result"},{"question":"from typing import List, Tuple def find_element(matrix: List[List[int]], element: int) -> Tuple[int, int]: Search for an element in a 2D matrix and return its position as a tuple (row, column). If the element is not found, return (-1, -1). >>> matrix = [ ... [10, 20, 30, 40], ... [15, 25, 35, 45], ... [27, 29, 37, 48], ... [32, 33, 39, 50] ...] >>> find_element(matrix, 29) (2, 1) >>> find_element(matrix, 50) (3, 3) >>> find_element(matrix, 100) (-1, -1) pass def test_find_element_found(): matrix = [ [10, 20, 30, 40], [15, 25, 35, 45], [27, 29, 37, 48], [32, 33, 39, 50] ] assert find_element(matrix, 29) == (2, 1) assert find_element(matrix, 50) == (3, 3) def test_find_element_not_found(): matrix = [ [10, 20, 30, 40], [15, 25, 35, 45], [27, 29, 37, 48], [32, 33, 39, 50] ] assert find_element(matrix, 100) == (-1, -1) def test_find_element_first_occurrence(): matrix = [ [10, 20, 30, 40], [15, 25, 29, 45], [27, 29, 37, 48], [32, 33, 39, 50] ] assert find_element(matrix, 29) == (1, 2) def test_find_element_single_row(): matrix = [ [10, 20, 30, 40] ] assert find_element(matrix, 30) == (0, 2) assert find_element(matrix, 50) == (-1, -1) def test_find_element_single_column(): matrix = [ [10], [20], [30], [40] ] assert find_element(matrix, 30) == (2, 0) assert find_element(matrix, 50) == (-1, -1)","solution":"from typing import List, Tuple def find_element(matrix: List[List[int]], element: int) -> Tuple[int, int]: Searches for the given element in the 2D matrix and returns a tuple (row, column) indicating its position. If the element is not found, returns (-1, -1). :param matrix: List[List[int]] - The 2D matrix where the element is searched. :param element: int - The element to find in the matrix. :return: Tuple[int, int] - The position of the found element in the matrix or (-1, -1) if not found. for row_index, row in enumerate(matrix): for col_index, value in enumerate(row): if value == element: return (row_index, col_index) return (-1, -1)"},{"question":"def min_possible_height(heights: List[int], k: int) -> int: Compute the minimum possible total height of trees remaining in the forest after exactly k cuts. Args: heights (list of int): List of integer heights of trees. k (int): Number of days you can cut trees. Returns: int: The minimum possible total height of trees remaining. Examples: >>> min_possible_height([10, 15, 17, 20], 2) 60 >>> min_possible_height([20, 17, 13], 3) 47 >>> min_possible_height([5, 5, 5, 5], 4) 16 pass","solution":"def min_possible_height(heights, k): Compute the minimum possible total height of trees remaining in the forest after exactly k cuts. Args: heights (list of int): List of integer heights of trees. k (int): Number of days you can cut trees. Returns: int: The minimum possible total height of trees remaining. heights.sort() n = len(heights) for i in range(k): heights[0] -= 1 heights.sort() return sum(heights)"},{"question":"def matrixTrace(matrix): Returns the trace of the matrix. If the matrix is not square, return None. Parameters: matrix (list of lists of int): The input two-dimensional list (matrix). Returns: int or None: The trace of the matrix if it is square; otherwise, None. Examples: >>> matrixTrace([[1, 2], [3, 4]]) == 5 # 1 + 4 >>> matrixTrace([[5, 9, 1], [2, 6, 3], [4, 7, 8]]) == 19 # 5 + 6 + 8 >>> matrixTrace([[5]]) == 5 # 5 >>> matrixTrace([[1, 2, 3], [4, 5, 6]]) == None # Not a square matrix >>> matrixTrace([[-1, 2], [3, -4]]) == -5 # -1 + (-4) >>> matrixTrace([[1, -2], [-3, 4]]) == 5 # 1 + 4","solution":"def matrixTrace(matrix): Returns the trace of the matrix. If the matrix is not square, return None. Parameters: matrix (list of lists of int): The input two-dimensional list (matrix). Returns: int or None: The trace of the matrix if it is square; otherwise, None. # Check if the matrix is square if len(matrix) != len(matrix[0]): return None # Calculate the trace of the matrix trace = sum(matrix[i][i] for i in range(len(matrix))) return trace"},{"question":"def min_swaps_to_make_identical(t: int, test_cases: List[Tuple[str, str]]) -> List[int]: Returns the minimum number of swaps required to make two strings identical or -1 if it is not possible. Args: t: int - the number of test cases test_cases: List[Tuple[str, str]] - list of tuples containing the test cases Returns: List[int] - a list containing the result for each test case >>> min_swaps_to_make_identical(3, [(\\"abcd\\",\\"bcda\\"), (\\"ab\\",\\"ab\\"),(\\"aaa\\",\\"aaa\\")]) [4, 0, 0] >>> min_swaps_to_make_identical(1, [(\\"abcd\\",\\"abcf\\")]) [-1]","solution":"def min_swaps_to_make_identical(t, test_cases): Returns the minimum number of swaps required to make two strings identical or -1 if it is not possible. results = [] for s1, s2 in test_cases: if sorted(s1) != sorted(s2): # It's not possible to make strings identical if they don't have the same set of characters results.append(-1) continue # Track the positions where s1 and s2 differ different_indices = [i for i in range(len(s1)) if s1[i] != s2[i]] # The number of swaps needed is half of the number of differences # Each swap reduces the number of differences by 2 results.append(len(different_indices)) return results"},{"question":"def trap(heights): Calculate the amount of water that can be trapped after raining. :param heights: List of non-negative integers representing elevations on a map. :return: Integer representing the maximum units of water trapped. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9","solution":"def trap(heights): Calculate the amount of water that can be trapped after raining. :param heights: List of non-negative integers representing elevations on a map. :return: Integer representing the maximum units of water trapped. if not heights: return 0 n = len(heights) left, right = 0, n - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water_trapped += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += right_max - heights[right] return water_trapped"},{"question":"def minPathSum(grid): Returns the minimum sum of the path from the top-left to bottom-right corner of the grid. :param grid: List[List[int]] - 2D list representing the grid :return: int - Minimum sum of the path Examples: >>> minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minPathSum([[1, 2, 5], [3, 2, 1]]) 6","solution":"def minPathSum(grid): Returns the minimum sum of the path from the top-left to bottom-right corner of the grid. :param grid: List[List[int]] - 2D list representing the grid :return: int - Minimum sum of the path if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) # Create a dp array to store the cumulative path sums dp = [[0] * m for _ in range(n)] # Initialize the top-left corner dp[0][0] = grid[0][0] # Fill in the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill in the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The value in the bottom-right corner is the answer return dp[n - 1][m - 1]"},{"question":"def longest_substring_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring with exactly k distinct characters. If no such substring exists, returns -1. Args: s: The input string consisting of lowercase English letters. k: The number of distinct characters. Examples: >>> longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> longest_substring_k_distinct(\\"aa\\", 1) 2 >>> longest_substring_k_distinct(\\"a\\", 2) -1","solution":"def longest_substring_k_distinct(s, k): Returns the length of the longest substring with exactly k distinct characters. If no such substring exists, returns -1. from collections import defaultdict if k == 0 or not s: return -1 left = 0 right = 0 char_count = defaultdict(int) max_length = -1 while right < len(s): char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if len(char_count) == k: max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def can_form_palindrome_by_removing_n_chars(s: str, n: int) -> bool: Determines if you can create a palindrome by removing exactly n characters from the original string. >>> can_form_palindrome_by_removing_n_chars(\\"abca\\", 1) True >>> can_form_palindrome_by_removing_n_chars(\\"abcdeba\\", 2) True >>> can_form_palindrome_by_removing_n_chars(\\"abcd\\", 1) False >>> can_form_palindrome_by_removing_n_chars(\\"abcba\\", 0) True >>> can_form_palindrome_by_removing_n_chars(\\"abcdefg\\", 2) False","solution":"def can_form_palindrome_by_removing_n_chars(s, n): Determines if a palindrome can be formed by removing exactly n characters from the original string. def is_palindrome(x): return x == x[::-1] def can_form_palindrome(s, n): if is_palindrome(s): return True if n == 0: return False for i in range(len(s)): if can_form_palindrome(s[:i] + s[i+1:], n - 1): return True return False return can_form_palindrome(s, n)"},{"question":"import re def is_valid_license_plate(plate: str) -> bool: Validates a license plate according to the given rules: - Three uppercase letters followed by four digits: 'ABC1234' - Two uppercase letters followed by five digits: 'AB12345' - Four digits followed by two uppercase letters: '1234AB' Args: plate (str): The license plate string to validate. Returns: bool: True if the license plate matches the valid patterns, False otherwise. >>> is_valid_license_plate(\\"ABC1234\\") True >>> is_valid_license_plate(\\"AB12345\\") True >>> is_valid_license_plate(\\"1234AB\\") True >>> is_valid_license_plate(\\"ABCD123\\") False >>> is_valid_license_plate(\\"AB12\\") False >>> is_valid_license_plate(\\"A-B1234\\") False >>> is_valid_license_plate(\\"1234#AB\\") False >>> is_valid_license_plate(\\"abc1234\\") False >>> is_valid_license_plate(\\"ab12345\\") False >>> is_valid_license_plate(\\"AbC1234\\") False","solution":"import re def is_valid_license_plate(plate): Validates a license plate according to the given rules. Args: plate (str): The license plate string to validate. Returns: bool: True if the license plate matches the valid patterns, False otherwise. pattern1 = re.compile(r\\"^[A-Z]{3}[0-9]{4}\\") pattern2 = re.compile(r\\"^[A-Z]{2}[0-9]{5}\\") pattern3 = re.compile(r\\"^[0-9]{4}[A-Z]{2}\\") if pattern1.match(plate) or pattern2.match(plate) or pattern3.match(plate): return True return False"},{"question":"def longest_subarray(arr: List[int], k: int) -> int: For a given list of integers, find the longest subarray where the difference between the maximum and minimum elements is less than or equal to a given integer \`k\`. >>> longest_subarray([4, 6, 5, 3, 3, 1], 2) 3 >>> longest_subarray([3, 3, 3, 3, 3], 0) 5 >>> longest_subarray([1, 5, 9], 2) 1 >>> longest_subarray([], 2) 0 >>> longest_subarray([1], 1) 1 >>> longest_subarray([4, 5, 6, 10, 12, 3, 4, 5, 2], 3) 4 >>> longest_subarray([4, 2, 1, 6, 5], 10) 5","solution":"from collections import deque def longest_subarray(arr, k): if not arr: return 0 max_deque, min_deque = deque(), deque() left, max_length = 0, 0 for right in range(len(arr)): while max_deque and arr[max_deque[-1]] <= arr[right]: max_deque.pop() while min_deque and arr[min_deque[-1]] >= arr[right]: min_deque.pop() max_deque.append(right) min_deque.append(right) while arr[max_deque[0]] - arr[min_deque[0]] > k: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"def generate_substrings(T: int, test_cases: List[Tuple[int, int]]) -> List[str]: Generate all substrings of length L from the string representation of the number N in base 10, sort these substrings lexicographically and return them. >>> generate_substrings(2, [(12345, 2), (67890, 3)]) [\\"12 23 34 45\\", \\"678 789 890\\"] >>> generate_substrings(2, [(12345, 0), (9, 0)]) [\\"1 2 3 4 5\\", \\"9\\"] >>> generate_substrings(2, [(1234, 5), (98765, 6)]) [\\"\\", \\"\\"] >>> generate_substrings(2, [(1, 1), (5, 1)]) [\\"1\\", \\"5\\"] >>> generate_substrings(4, [(12345, 2), (67890, 3), (1234567890, 4), (11111, 2)]) [\\"12 23 34 45\\", \\"678 789 890\\", \\"1234 2345 3456 4567 5678 6789 7890\\", \\"11 11 11 11\\"]","solution":"def generate_substrings(T, test_cases): results = [] for N, L in test_cases: str_N = str(N) L = max(L, 1) substrings = [str_N[i:i+L] for i in range(len(str_N) - L + 1)] substrings.sort() results.append(\\" \\".join(substrings)) return results"},{"question":"def calculate_bills(purchases: [(str, str, float, int)]) -> dict: Calculate the total bill for each customer based on their shopping cart. >>> calculate_bills([(\\"Alice\\", \\"Apple\\", 1.0, 3)]) {\\"Alice\\": 3.0} >>> calculate_bills([(\\"Alice\\", \\"Apple\\", 1.0, 3), (\\"Alice\\", \\"Banana\\", 0.5, 4)]) {\\"Alice\\": 5.0} >>> calculate_bills([(\\"Alice\\", \\"Apple\\", 1.0, 3), (\\"Bob\\", \\"Banana\\", 0.5, 4)]) {\\"Alice\\": 3.0, \\"Bob\\": 2.0} >>> calculate_bills([(\\"Alice\\", \\"Apple\\", 1.0, 3), (\\"Bob\\", \\"Banana\\", 0.5, 4), (\\"Alice\\", \\"Orange\\", 0.75, 2), (\\"Bob\\", \\"Milk\\", 1.5, 1)]) {\\"Alice\\": 4.5, \\"Bob\\": 3.5} >>> calculate_bills([]) {} >>> calculate_bills([(\\"Customer1\\", \\"Item1\\", 2.0, 5)] * 1000) {\\"Customer1\\": 10000.0}","solution":"def calculate_bills(purchases): Calculate the total bill for each customer based on their shopping cart. Parameters: purchases (list): A list of tuples where each tuple contains: (customer_name (str), item_name (str), price_per_unit (float), quantity (int)) Returns: dict: A dictionary with customer names as keys and their total bill as values. bills = {} for customer_name, item_name, price_per_unit, quantity in purchases: cost = price_per_unit * quantity if customer_name in bills: bills[customer_name] += cost else: bills[customer_name] = cost return bills"},{"question":"def minimum_time_to_capture_castles(castles, attacks_per_minute, regeneration): Given the defenses of castles and the attack and regeneration parameters, find the minimum time to capture each castle or return -1 if impossible. Parameters: castles (list): List of integers representing the defense level of each castle. attacks_per_minute (int): Number of attacks Zara's army can perform per minute. regeneration (int): Defense regeneration points per rest period. Returns: List[int]: List of minimum times in minutes to capture each castle or -1 if impossible. >>> minimum_time_to_capture_castles([15, 50, 23], 20, 5) [1, 3, 2] >>> minimum_time_to_capture_castles([15, 50, 23], 20, 25) [1, -1, -1] >>> minimum_time_to_capture_castles([15, 50, 23], 20, 0) [1, 3, 2] >>> minimum_time_to_capture_castles([10, 30, 60], 50, 15) [1, 1, 2] >>> minimum_time_to_capture_castles([10, 20, 30], 40, 10) [1, 1, 1] >>> minimum_time_to_capture_castles([10, 20, 30], 5, 10) [-1, -1, -1]","solution":"def minimum_time_to_capture_castles(castles, attacks_per_minute, regeneration): Given the defenses of castles and the attack and regeneration parameters, find the minimum time to capture each castle or return -1 if impossible. Parameters: castles (list): List of integers representing the defense level of each castle. attacks_per_minute (int): Number of attacks Zara's army can perform per minute. regeneration (int): Defense regeneration points per rest period. Returns: List[int]: List of minimum times in minutes to capture each castle or -1 if impossible. result = [] for defense in castles: if attacks_per_minute <= regeneration and defense > attacks_per_minute: result.append(-1) continue minutes = 0 while defense > 0: minutes += 1 attacks = min(defense, attacks_per_minute) defense -= attacks if defense > 0: defense += regeneration result.append(minutes) return result"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups the anagrams together from the given list of words. Args: words (list of str): A list of lowercase words. Returns: list of list of str: A list of lists, where each inner list contains words that are anagrams of each other. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([]) [] >>> group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) [['abc'], ['def'], ['ghi']] >>> group_anagrams([\\"abcd\\", \\"dcba\\", \\"bcad\\", \\"dbca\\"]) [['abcd', 'dcba', 'bcad', 'dbca']] >>> group_anagrams([\\"abc\\", \\"bca\\", \\"ABC\\"]) [['abc', 'bca'], ['ABC']] # Your implementation here","solution":"from collections import defaultdict def group_anagrams(words): Groups the anagrams together from the given list of words. Args: words (list of str): A list of lowercase words. Returns: list of list of str: A list of lists, where each inner list contains words that are anagrams of each other. anagrams = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"def sum_of_unique(nums: List[int]) -> int: Returns the sum of all numbers in the list that appear only once. >>> sum_of_unique([1, 2, 3, 2, 4]) # 8 >>> sum_of_unique([5, 5, 5, 5]) # 0 >>> sum_of_unique([1, 1, 2, 3, 3]) # 2 >>> sum_of_unique([]) # 0","solution":"def sum_of_unique(nums): from collections import Counter count = Counter(nums) return sum(num for num, cnt in count.items() if cnt == 1)"},{"question":"import numpy as np def reshape_matrix(initial_values: list, R: int, C: int) -> np.ndarray: This function first flattens a 2D matrix into a 1D array and then reshapes it into a matrix of dimensions RxC. Parameters: initial_values (list): List of integers in row-major order representing the initial matrix. R (int): Number of rows for the reshaped matrix. C (int): Number of columns for the reshaped matrix. Returns: numpy.ndarray: Reshaped matrix with dimensions R x C. pass def test_reshape_square_matrix(): initial_values = [1, 2, 3, 4, 5, 6, 7, 8, 9] R, C = 3, 3 expected_output = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) assert np.array_equal(reshape_matrix(initial_values, R, C), expected_output) def test_reshape_rectangle_matrix(): initial_values = [1, 2, 3, 4, 5, 6] R, C = 2, 3 expected_output = np.array([[1, 2, 3], [4, 5, 6]]) assert np.array_equal(reshape_matrix(initial_values, R, C), expected_output) def test_reshape_flat_to_2row_matrix(): initial_values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] R, C = 2, 5 expected_output = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]) assert np.array_equal(reshape_matrix(initial_values, R, C), expected_output) def test_reshape_flat_to_5row_matrix(): initial_values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] R, C = 5, 2 expected_output = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]) assert np.array_equal(reshape_matrix(initial_values, R, C), expected_output)","solution":"import numpy as np def reshape_matrix(initial_values, R, C): This function first flattens a 2D matrix into a 1D array and then reshapes it into a matrix of dimensions RxC. Parameters: initial_values (list): List of integers in row-major order representing the initial matrix. R (int): Number of rows for the reshaped matrix. C (int): Number of columns for the reshaped matrix. Returns: numpy.ndarray: Reshaped matrix with dimensions R x C. initial_array = np.array(initial_values) reshaped_matrix = np.reshape(initial_array, (R, C)) return reshaped_matrix"},{"question":"def can_jump(nums: List[int]) -> bool: Determine if you can reach the last index starting from the first index. Parameters: nums (List[int]): An array of positive integers representing the jumps you can make from each index. Returns: bool: True if you can reach the last index, otherwise False. Examples: >>> can_jump([2,3,1,1,4]) True >>> can_jump([3,2,1,0,4]) False","solution":"def can_jump(nums): Given an array of positive integers representing the jumps you can make from each index, determine if you can reach the last index starting from the first index. max_reachable = 0 for i, jump in enumerate(nums): if i > max_reachable: return False max_reachable = max(max_reachable, i + jump) return True"},{"question":"def stringCycler(s: str, n: int) -> str: Returns a new string that is constructed by cyclically shifting each character in the input string forward by the integer amount given, wrapping around if necessary. Parameters: s (str): The input string. n (int): The number of positions to shift forward. Returns: str: The cyclically shifted string. >>> stringCycler(\\"hello\\", 2) 'lohel' >>> stringCycler(\\"python\\", 3) 'honpyt' >>> stringCycler(\\"abcdef\\", 1) 'fabcde' >>> stringCycler(\\"abcdef\\", 6) 'abcdef' >>> stringCycler(\\"abcdef\\", 7) 'fabcde'","solution":"def stringCycler(s, n): Returns a new string that is constructed by cyclically shifting each character in the input string forward by the integer amount given, wrapping around if necessary. Parameters: s (str): The input string. n (int): The number of positions to shift forward. Returns: str: The cyclically shifted string. if not s: return \\"\\" # Ensure the shift amount is within the bounds of the string length n = n % len(s) # Return the cyclically shifted string return s[-n:] + s[:-n]"},{"question":"from typing import List, Tuple def shortest_path(N: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Find the shortest path distance from a given source node to target node in a directed graph. Args: N: Number of nodes in the graph. edges: List of edges where each edge is represented as a tuple (u, v, w) that indicates an edge from node u to node v with weight w. queries: List of queries where each query is represented as a tuple (s, t) that indicates we need to find the shortest path from node s to node t. Returns: A list of shortest path distances for each query. If there is no path from source to target, the distance is -1. Example usage: >>> shortest_path(4, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 3, 4)], [(1, 3), (2, 4), (1, 4)]) [3, 3, 4] >>> shortest_path(3, [(1, 2, 5), (2, 3, 10)], [(3, 1)]) [-1]","solution":"import heapq def shortest_path(N, edges, queries): # Create a graph using an adjacency list graph = [[] for _ in range(N + 1)] for u, v, w in edges: graph[u].append((v, w)) def dijkstra(start): distances = [float('inf')] * (N + 1) distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances results = [] for s, t in queries: distances = dijkstra(s) shortest_distance = distances[t] if shortest_distance == float('inf'): results.append(-1) else: results.append(shortest_distance) return results"},{"question":"def findAverage(numbers: List[float]) -> float: Returns the average of a list of numbers, rounded to 2 decimal places. If the list is empty, returns 0. >>> findAverage([1, 2, 3, 4, 5]) 3.00 >>> findAverage([10, 20, 30]) 20.00 >>> findAverage([]) 0 >>> findAverage([-1, -2, -3, -4, -5]) -3.00 >>> findAverage([20, -10, 40, -20]) 7.50","solution":"def findAverage(numbers): Returns the average of a list of numbers, rounded to 2 decimal places. If the list is empty, returns 0. if not numbers: return 0 return round(sum(numbers) / len(numbers), 2)"},{"question":"def can_rearrange_to_divisible_by_3(s: str) -> bool: Determines if the digits of string s can be rearranged to form a number that is divisible by 3. >>> can_rearrange_to_divisible_by_3(\\"123\\") True >>> can_rearrange_to_divisible_by_3(\\"1112\\") False >>> can_rearrange_to_divisible_by_3(\\"678\\") True >>> can_rearrange_to_divisible_by_3(\\"333\\") True >>> can_rearrange_to_divisible_by_3(\\"1111\\") False >>> can_rearrange_to_divisible_by_3(\\"9\\" * 100000) True >>> can_rearrange_to_divisible_by_3(\\"2\\" * 100000 + \\"1\\") True >>> can_rearrange_to_divisible_by_3(\\"3\\") True >>> can_rearrange_to_divisible_by_3(\\"4\\") False >>> can_rearrange_to_divisible_by_3(\\"396\\") True >>> can_rearrange_to_divisible_by_3(\\"987654\\") True >>> can_rearrange_to_divisible_by_3(\\"1234\\") False >>> can_rearrange_to_divisible_by_3(\\"56789\\") False","solution":"def can_rearrange_to_divisible_by_3(s): Determines if the digits of string s can be rearranged to form a number that is divisible by 3. Parameters: s (str): A string representing a positive integer. Returns: bool: True if it is possible to rearrange the digits to form a number divisible by 3, otherwise False. digit_sum = sum(int(char) for char in s) return digit_sum % 3 == 0"},{"question":"def isomorphic_strings(s: str, t: str) -> bool: Determine if two strings are isomorphic. Two strings are isomorphic if the characters in one string can be replaced to get the second string with all occurrences of a character being replaced with another character while preserving the order of characters. :param s: First string :param t: Second string :return: True if the strings are isomorphic, False otherwise >>> isomorphic_strings(\\"egg\\", \\"add\\") True >>> isomorphic_strings(\\"foo\\", \\"bar\\") False >>> isomorphic_strings(\\"paper\\", \\"title\\") True >>> isomorphic_strings(\\"abc\\", \\"ab\\") False >>> isomorphic_strings(\\"aaa\\", \\"bbb\\") True >>> isomorphic_strings(\\"abc\\", \\"def\\") True >>> isomorphic_strings(\\"abca\\", \\"zbxz\\") True >>> isomorphic_strings(\\"\\", \\"\\") True >>> isomorphic_strings(\\"a\\", \\"b\\") True >>> isomorphic_strings(\\"a\\", \\"a\\") True >>> isomorphic_strings(\\"ab\\", \\"aa\\") False","solution":"def isomorphic_strings(s, t): Determine if two strings are isomorphic. Two strings are isomorphic if the characters in one string can be replaced to get the second string with all occurrences of a character being replaced with another character while preserving the order of characters. :param s: First string :param t: Second string :return: True if the strings are isomorphic, False otherwise if len(s) != len(t): return False # To keep track of character mapping from s to t and t to s mapping_s_t = {} mapping_t_s = {} for char_s, char_t in zip(s, t): # If char_s is already mapped to another character, it should be the same as char_t if char_s in mapping_s_t and mapping_s_t[char_s] != char_t: return False # If char_t is already mapped to another character, it should be the same as char_s if char_t in mapping_t_s and mapping_t_s[char_t] != char_s: return False # Map the characters mapping_s_t[char_s] = char_t mapping_t_s[char_t] = char_s return True"},{"question":"def find_odd_occurrence(arr): Returns the element that appears an odd number of times in the array. Args: - arr (list): A list of integers where all integers appear an even number of times except one. Returns: - int: The integer that appears an odd number of times. >>> find_odd_occurrence([2, 3, 5, 4, 5, 2, 4, 3, 5]) 5 >>> find_odd_occurrence([10]) 10 >>> find_odd_occurrence([1, 1, 1, 1, 1]) 1 >>> find_odd_occurrence([7, 7, 8, 8, 9]) 9 >>> find_odd_occurrence([100000, 100000, 999999]) 999999 >>> find_odd_occurrence([1, -1, 2, -2, 1, -1, 2, 2, -2]) 2 >>> find_odd_occurrence([]) 0 >>> arr = [i for i in range(100000)] * 2 + [123456] >>> find_odd_occurrence(arr) 123456","solution":"def find_odd_occurrence(arr): Returns the element that appears an odd number of times in the array. Args: - arr (list): A list of integers where all integers appear an even number of times except one. Returns: - int: The integer that appears an odd number of times. result = 0 for num in arr: result ^= num return result"},{"question":"import re def is_valid_passphrase(passphrase: str) -> bool: Check if the given passphrase is valid based on the given rules. >>> is_valid_passphrase(\\"A1b!cdef\\") True >>> is_valid_passphrase(\\"ValidPass1!\\") True >>> is_valid_passphrase(\\"A1b!cde\\") False >>> is_valid_passphrase(\\"a1b!cdef\\") False >>> is_valid_passphrase(\\"A1B!CDEF\\") False >>> is_valid_passphrase(\\"A!bcdefg\\") False >>> is_valid_passphrase(\\"A1bcdefg\\") False >>> is_valid_passphrase(\\"abcdefg\\") False >>> is_valid_passphrase(\\"A1 b!cdef\\") True >>> is_valid_passphrase(\\"\\") False >>> is_valid_passphrase(\\"Aa1!2345\\") True >>> is_valid_passphrase(\\"Aa1@3456\\") True","solution":"import re def is_valid_passphrase(passphrase): Check if the given passphrase is valid based on the given rules. :param passphrase: str :return: bool if len(passphrase) < 8: return False has_upper = re.search(r'[A-Z]', passphrase) has_lower = re.search(r'[a-z]', passphrase) has_digit = re.search(r'd', passphrase) has_special = re.search(r'[!@#%^&*()-+]', passphrase) return bool(has_upper and has_lower and has_digit and has_special)"},{"question":"def find_contiguous_subarray(arr, n): Returns the contiguous subarray of length \`n\` with the maximum sum. If there are multiple subarrays with the same maximum sum, return the one that appears first. >>> find_contiguous_subarray([1, 2, 3, 4, 5, 6], 3) [4, 5, 6] >>> find_contiguous_subarray([5, 1, 3, -2, 4, 6, -1, 7], 2) [4, 6] >>> find_contiguous_subarray([-1, -2, -3], 2) [-1, -2] >>> find_contiguous_subarray([10, 2, 3, 1, 15], 4) [2, 3, 1, 15] >>> find_contiguous_subarray([1, 2, 3], 3) [1, 2, 3] >>> find_contiguous_subarray([1, 2, 3], 4) [] >>> find_contiguous_subarray([1, 2, 3], 0) []","solution":"def find_contiguous_subarray(arr, n): Returns the contiguous subarray of length \`n\` with the maximum sum. If there are multiple subarrays with the same maximum sum, return the one that appears first. if n > len(arr): return [] max_sum = float('-inf') max_subarray = [] for i in range(len(arr) - n + 1): current_subarray = arr[i:i+n] current_sum = sum(current_subarray) if current_sum > max_sum: max_sum = current_sum max_subarray = current_subarray return max_subarray"},{"question":"def sort_by_property(arr, prop): Sorts an array of objects by a specified integer property. Parameters: arr (list of dict): The list of objects to sort. prop (str): The property name to sort by. Returns: list of dict: A new sorted list of objects. # Unit tests def test_sort_by_quantity(): items = [ {'name': 'apple', 'quantity': 10, 'price': 50}, {'name': 'banana', 'quantity': 5, 'price': 20}, {'name': 'orange', 'quantity': 15, 'price': 30}, {'name': 'grape', 'quantity': 20, 'price': 40} ] sorted_by_quantity = sort_by_property(items, 'quantity') expected = [ {'name': 'banana', 'quantity': 5, 'price': 20}, {'name': 'apple', 'quantity': 10, 'price': 50}, {'name': 'orange', 'quantity': 15, 'price': 30}, {'name': 'grape', 'quantity': 20, 'price': 40} ] assert sorted_by_quantity == expected def test_sort_by_price(): items = [ {'name': 'apple', 'quantity': 10, 'price': 50}, {'name': 'banana', 'quantity': 5, 'price': 20}, {'name': 'orange', 'quantity': 15, 'price': 30}, {'name': 'grape', 'quantity': 20, 'price': 40} ] sorted_by_price = sort_by_property(items, 'price') expected = [ {'name': 'banana', 'quantity': 5, 'price': 20}, {'name': 'orange', 'quantity': 15, 'price': 30}, {'name': 'grape', 'quantity': 20, 'price': 40}, {'name': 'apple', 'quantity': 10, 'price': 50} ] assert sorted_by_price == expected def test_original_array_unmodified(): items = [ {'name': 'apple', 'quantity': 10, 'price': 50}, {'name': 'banana', 'quantity': 5, 'price': 20}, {'name': 'orange', 'quantity': 15, 'price': 30}, {'name': 'grape', 'quantity': 20, 'price': 40} ] items_copy = items[:] sort_by_property(items, 'price') assert items == items_copy def test_single_element_array(): items = [{'name': 'apple', 'quantity': 10, 'price': 50}] sorted_by_quantity = sort_by_property(items, 'quantity') expected = [{'name': 'apple', 'quantity': 10, 'price': 50}] assert sorted_by_quantity == expected def test_sort_by_nonexistent_property(): items = [ {'name': 'apple', 'quantity': 10, 'price': 50}, {'name': 'banana', 'quantity': 5, 'price': 20} ] try: sort_by_property(items, 'nonexistent') assert False, \\"Expected an exception for nonexistent property\\" except KeyError: pass","solution":"def sort_by_property(arr, prop): Sorts an array of objects by a specified integer property. Parameters: arr (list of dict): The list of objects to sort. prop (str): The property name to sort by. Returns: list of dict: A new sorted list of objects. def merge_sort(array): if len(array) > 1: mid = len(array) // 2 left_half = array[:mid] right_half = array[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i][prop] < right_half[j][prop]: array[k] = left_half[i] i += 1 else: array[k] = right_half[j] j += 1 k += 1 while i < len(left_half): array[k] = left_half[i] i += 1 k += 1 while j < len(right_half): array[k] = right_half[j] j += 1 k += 1 sorted_arr = arr[:] merge_sort(sorted_arr) return sorted_arr"},{"question":"class BankAccount: def __init__(self): Initializes the bank account with a balance of 0. self.__balance = 0 def deposit(self, amount): Deposits the given amount to the account balance. pass def withdraw(self, amount): Withdraws the given amount from the account balance if sufficient funds are available. pass def get_balance(self): Returns the current balance. pass import unittest class TestBankAccount(unittest.TestCase): def test_deposit_valid(self): account = BankAccount() account.deposit(100) self.assertEqual(account.get_balance(), 100) def test_deposit_negative(self): account = BankAccount() with self.assertRaises(ValueError) as e: account.deposit(-100) self.assertEqual(str(e.exception), \\"Deposit amount must be positive\\") def test_withdraw_valid(self): account = BankAccount() account.deposit(100) account.withdraw(50) self.assertEqual(account.get_balance(), 50) def test_withdraw_insufficient_funds(self): account = BankAccount() account.deposit(50) with self.assertRaises(ValueError) as e: account.withdraw(100) self.assertEqual(str(e.exception), \\"Insufficient funds\\") def test_withdraw_negative(self): account = BankAccount() account.deposit(50) with self.assertRaises(ValueError) as e: account.withdraw(-10) self.assertEqual(str(e.exception), \\"Withdraw amount must be positive\\") def test_get_balance_initial(self): account = BankAccount() self.assertEqual(account.get_balance(), 0) def test_deposit_multiple(self): account = BankAccount() account.deposit(50) account.deposit(30) self.assertEqual(account.get_balance(), 80) def test_withdraw_to_zero(self): account = BankAccount() account.deposit(100) account.withdraw(100) self.assertEqual(account.get_balance(), 0) if __name__ == '__main__': unittest.main()","solution":"class BankAccount: def __init__(self): self.__balance = 0 def deposit(self, amount): Deposits the given amount to the account balance. if amount < 0: raise ValueError(\\"Deposit amount must be positive\\") self.__balance += amount def withdraw(self, amount): Withdraws the given amount from the account balance if sufficient funds are available. if amount > self.__balance: raise ValueError(\\"Insufficient funds\\") if amount < 0: raise ValueError(\\"Withdraw amount must be positive\\") self.__balance -= amount def get_balance(self): Returns the current balance. return self.__balance"},{"question":"from typing import List def unique(lst: List[int]) -> List[int]: Returns a list containing only the unique elements from the original list, preserving their original order. >>> unique([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> unique([4, 5, 5, 5, 6, 6, 7]) [4, 5, 6, 7] >>> unique([1, 2, 3]) [1, 2, 3] pass def test_unique_with_duplicates(): assert unique([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] def test_unique_all_duplicates(): assert unique([4, 5, 5, 5, 6, 6, 7]) == [4, 5, 6, 7] def test_unique_no_duplicates(): assert unique([1, 2, 3]) == [1, 2, 3] def test_unique_single_element(): assert unique([5]) == [5] def test_unique_empty_list(): assert unique([]) == [] def test_unique_with_negative_numbers(): assert unique([-1, -1, 0, 1, -2, -2, 2]) == [-1, 0, 1, -2, 2] def test_unique_mixed_numbers(): assert unique([1, 2, 3, 2, 4, 3, 5, 5, 6]) == [1, 2, 3, 4, 5, 6]","solution":"def unique(lst): Returns a list containing only the unique elements from the original list, preserving their original order. seen = set() unique_list = [] for item in lst: if item not in seen: unique_list.append(item) seen.add(item) return unique_list"},{"question":"def flatten_dict(d: dict) -> dict: Flatten a nested dictionary. The keys in the flattened dictionary are represented in a dot-separated format indicating the path in the original nested dictionary. >>> flatten_dict({}) {} >>> flatten_dict({'a': 1, 'b': 2}) {'a': 1, 'b': 2} >>> flatten_dict({'a': 1, 'b': {'c': 2, 'd': {'e': 3}}}) {'a': 1, 'b.c': 2, 'b.d.e': 3} >>> flatten_dict({'a': {'b': {'c': {'d': {'e': 5}}}}}) {'a.b.c.d.e': 5} >>> flatten_dict({'a': 1, 'b': {'c': 2, 'd': {'e': 3, 'f': 4}}, 'g': {'h': 5, 'i': 6}}) {'a': 1, 'b.c': 2, 'b.d.e': 3, 'b.d.f': 4, 'g.h': 5, 'g.i': 6} >>> flatten_dict({'a': \\"hello\\", 'b': {'c': \\"world\\"}}) {'a': \\"hello\\", 'b.c': \\"world\\"}","solution":"def flatten_dict(d: dict) -> dict: def _flatten_dict(d, parent_key=''): items = [] for k, v in d.items(): new_key = f\\"{parent_key}.{k}\\" if parent_key else k if isinstance(v, dict): items.extend(_flatten_dict(v, new_key).items()) else: items.append((new_key, v)) return dict(items) return _flatten_dict(d)"},{"question":"def sum_adjacent_pairs(arr): Given an array of integers, return an array containing the sum of each pair of adjacent integers. If the input array has a length of 1 or less, return an empty array. :param arr: List[int] - the input array of integers :return: List[int] - the array containing the sum of each pair of adjacent integers >>> sum_adjacent_pairs([4, 2, 6, 3]) [6, 8, 9] >>> sum_adjacent_pairs([5]) [] >>> sum_adjacent_pairs([]) [] >>> sum_adjacent_pairs([1, 1]) [2] >>> sum_adjacent_pairs([-1, -2, -3]) [-3, -5] >>> sum_adjacent_pairs([2, -2, 2, -2]) [0, 0, 0]","solution":"def sum_adjacent_pairs(arr): Given an array of integers, return an array containing the sum of each pair of adjacent integers. If the input array has a length of 1 or less, return an empty array. :param arr: List[int] - the input array of integers :return: List[int] - the array containing the sum of each pair of adjacent integers if len(arr) <= 1: return [] return [arr[i] + arr[i + 1] for i in range(len(arr) - 1)]"},{"question":"def longest_substring_without_repeating_characters(s: str) -> int: Write a function that takes a string containing only lowercase alphabetical characters and returns the length of the longest substring without repeating characters. Examples: >>> longest_substring_without_repeating_characters(\\"abcabcbb\\") 3 >>> longest_substring_without_repeating_characters(\\"bbbbb\\") 1 >>> longest_substring_without_repeating_characters(\\"pwwkew\\") 3","solution":"def longest_substring_without_repeating_characters(s): Returns the length of the longest substring without repeating characters. start = 0 max_length = 0 used_chars = {} for i, char in enumerate(s): if char in used_chars and start <= used_chars[char]: start = used_chars[char] + 1 else: max_length = max(max_length, i - start + 1) used_chars[char] = i return max_length"},{"question":"from typing import List def contains_all_characters(test_cases: List[tuple]) -> List[str]: Check if each string S contains all characters of string P at least once. >>> contains_all_characters([(\\"abcdef\\", \\"bca\\"), (\\"hello\\", \\"world\\"), (\\"example\\", \\"ample\\")]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> contains_all_characters([(\\"abcdefghij\\", \\"jihgfedcba\\"), (\\"xyzzyx\\", \\"yxz\\")]) [\\"YES\\", \\"YES\\"] pass def process_input_output(input_lines: List[str]) -> List[str]: Process the input lines to extract test cases and determine results. >>> process_input_output([\\"3\\", \\"abcdef bca\\", \\"hello world\\", \\"example ample\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_input_output([\\"2\\", \\"a a\\", \\"b c\\"]) [\\"YES\\", \\"NO\\"] pass","solution":"def contains_all_characters(test_cases): results = [] for s, p in test_cases: from collections import Counter s_counter = Counter(s) p_counter = Counter(p) if all(s_counter[char] >= count for char, count in p_counter.items()): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # function to process the input and output def process_input_output(input_lines): T = int(input_lines[0]) test_cases = [line.split() for line in input_lines[1:T+1]] results = contains_all_characters(test_cases) return results"},{"question":"def is_hexadecimal(s: str) -> bool: Determines if the input string s is a valid hexadecimal number. A valid hexadecimal number can contain digits from 0 to 9 and letters from a to f (inclusive) only. Args: s (str): The input string to check. Returns: bool: True if the string is a valid hexadecimal number, False otherwise. Examples: >>> is_hexadecimal(\\"1a3f\\") True >>> is_hexadecimal(\\"123g\\") False >>> is_hexadecimal(\\"abcde\\") True >>> is_hexadecimal(\\"\\") False >>> is_hexadecimal(\\"123\\") True","solution":"def is_hexadecimal(s): Determines if the input string s is a valid hexadecimal number. A valid hexadecimal number can contain digits from 0 to 9 and letters from a to f (inclusive) only. Args: s (str): The input string to check. Returns: bool: True if the string is a valid hexadecimal number, False otherwise. if not s: return False valid_chars = set(\\"0123456789abcdef\\") for char in s: if char not in valid_chars: return False return True"},{"question":"def catalog_books(T: int, book_entries: List[Any], Q: int, queries: List[Tuple[int, int]]) -> List[Union[List[str], str]]: Catalog and retrieve books based on the publication year range. Args: T (int): Number of catalog entries. book_entries (List): List of catalog entries where each entry has a unique identifier, title, and year of publication. Q (int): Number of queries. queries (List): List of queries where each query has a start year and an end year (inclusive). Returns: List[Union[List[str], str]]: A list containing titles of books published within the specified year range or \\"No books found\\" if no books are found within the range. Example: >>> catalog_books(5, [ 1001, 'Moby Dick', 1851, 1002, 'Hamlet', 1600, 1003, 'To Kill a Mockingbird', 1960, 1004, 'Pride and Prejudice', 1813, 1005, '1984', 1949 ], 2, [(1800, 1900), (1950, 2000)]) [['Moby Dick', 'Pride and Prejudice'], ['To Kill a Mockingbird']] >>> catalog_books(2, [ 1001, 'Hamlet', 1600, 1002, '1984', 1949 ], 1, [(1800, 1900)]) ['No books found']","solution":"def catalog_books(T, book_entries, Q, queries): Catalog and retrieve books based on the publication year range. catalog = {} # Parse book entries for i in range(T): id = book_entries[i*3] title = book_entries[i*3 + 1] year = int(book_entries[i*3 + 2]) if year not in catalog: catalog[year] = [] catalog[year].append(title) # Handle queries results = [] for i in range(Q): A, B = queries[i] books_in_range = [] for year in range(A, B + 1): if year in catalog: books_in_range.extend(catalog[year]) if books_in_range: results.append(sorted(books_in_range)) else: results.append(\\"No books found\\") return results"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determine if two strings are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"apple\\", \\"pale\\") False >>> are_anagrams(\\"cinema\\", \\"iceman\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False pass","solution":"def are_anagrams(str1: str, str2: str) -> bool: Determine if two strings are anagrams of each other. if len(str1) != len(str2): return False # Create two dictionaries to count the frequency of each character count1 = {} count2 = {} for char in str1: if char in count1: count1[char] += 1 else: count1[char] = 1 for char in str2: if char in count2: count2[char] += 1 else: count2[char] = 1 # Compare both dictionaries return count1 == count2"},{"question":"def is_prime(n: int) -> bool: Checks if a number n is prime. >>> is_prime(2) True >>> is_prime(4) False pass def extract_primes(numbers: List[int]) -> List[int]: Takes a list of integers and returns a new list containing only the prime numbers from the original list. >>> extract_primes([12, 5, 7, 11, 45, 17]) [5, 7, 11, 17] >>> extract_primes([2, 3, 4, 9, 13, 16, 19]) [2, 3, 13, 19] >>> extract_primes([0, -1, -3, 4, 6, 8]) [] pass","solution":"def is_prime(n): Checks if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def extract_primes(numbers): Takes a list of integers and returns a new list containing only the prime numbers from the original list. return [num for num in numbers if is_prime(num)]"},{"question":"def garden_plots(L, W): Determines the side length of the largest possible square plot and the total number of such square plots that can fit in the rectangular plot with length L and width W. Args: L (float): The length of the rectangular plot. W (float): The width of the rectangular plot. Returns: tuple: A tuple containing the side length of the largest square plot (in meters) and the total number of such square plots. >>> garden_plots(10, 15) (5, 6) >>> garden_plots(7, 13) (1, 91) >>> garden_plots(0, 15) (0, 0) >>> garden_plots(10.5, 15.5) (5, 6) pass","solution":"from math import gcd, floor def garden_plots(L, W): Determines the side length of the largest possible square plot and the total number of such square plots that can fit in the rectangular plot with length L and width W. Args: L (float): The length of the rectangular plot. W (float): The width of the rectangular plot. Returns: tuple: A tuple containing the side length of the largest square plot (in meters) and the total number of such square plots. if L == 0 or W == 0: return (0, 0) L = floor(L) W = floor(W) side_length = gcd(L, W) num_plots = (L * W) // (side_length ** 2) return (side_length, num_plots)"},{"question":"from typing import List def count_special_pairs(arr: List[int], k: int) -> int: This function takes an array of integers and an integer k, and returns the total number of special pairs in the array where i < j and arr[i] + arr[j] equals k. >>> count_special_pairs([1, 5, 7, -1, 5], 6) 3 >>> count_special_pairs([0, 0, 0, 0], 0) 6 pass def test_example_case(): arr = [1, 5, 7, -1, 5] k = 6 assert count_special_pairs(arr, k) == 3 def test_zero_case(): arr = [0, 0, 0, 0] k = 0 assert count_special_pairs(arr, k) == 6 def test_no_pairs_case(): arr = [1, 2, 3, 4] k = 100 assert count_special_pairs(arr, k) == 0 def test_negative_numbers(): arr = [1, -1, 2, -2, 3, -3] k = 0 assert count_special_pairs(arr, k) == 3 def test_single_pair(): arr = [10, -10, 20, 10, 30, -20] k = 0 assert count_special_pairs(arr, k) == 3 def test_large_numbers(): arr = [100000, -100000, 99999, -99999, 1, -1] k = 0 assert count_special_pairs(arr, k) == 3 def test_with_duplicates(): arr = [5, 1, 5, 3, 2, 5, 1] k = 6 assert count_special_pairs(arr, k) == 6","solution":"from typing import List def count_special_pairs(arr: List[int], k: int) -> int: This function counts the number of special pairs (i, j) in the array such that i < j and arr[i] + arr[j] equals k. count = 0 seen = {} for i, num in enumerate(arr): if k - num in seen: count += seen[k - num] if num in seen: seen[num] += 1 else: seen[num] = 1 return count"},{"question":"def max_subarray_sum(nums): Finds the contiguous subarray which has the largest sum and returns its sum along with the start and end indices of that subarray. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) (6, 3, 6) >>> max_subarray_sum([1]) (1, 0, 0) >>> max_subarray_sum([-1, -2, -3]) (-1, 0, 0) >>> max_subarray_sum([4, -1, 2, 1]) (6, 0, 3) >>> max_subarray_sum([1, 2, 3, -2, 5]) (9, 0, 4) >>> max_subarray_sum([]) (0, -1, -1) >>> max_subarray_sum([0, 0, 0, 0, 0]) (0, 0, 0) >>> max_subarray_sum([5]) (5, 0, 0) >>> max_subarray_sum([-5]) (-5, 0, 0) >>> max_subarray_sum([-4, -3, -2, -1]) (-1, 3, 3) >>> max_subarray_sum([1, 2, 3, 4, 5]) (15, 0, 4) >>> max_subarray_sum([3, -2, 5, -1]) (6, 0, 2) >>> max_subarray_sum([-2, -1, -3, 2, -1, 2, 3]) (6, 3, 6)","solution":"def max_subarray_sum(nums): Finds the contiguous subarray which has the largest sum and returns its sum along with the start and end indices of that subarray. if not nums: return 0, -1, -1 max_sum = current_sum = nums[0] start = end = temp_start = 0 for i in range(1, len(nums)): if current_sum < 0: current_sum = nums[i] temp_start = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return max_sum, start, end"},{"question":"def min_operations_to_equal_elements(nums): Returns the minimum number of operations needed to make all elements in nums equal. Each operation chooses any two elements of the array and decreases them by 1. import pytest from solution import min_operations_to_equal_elements def test_min_operations_example1(): assert min_operations_to_equal_elements([3, 4, 6]) == 13 def test_min_operations_example2(): assert min_operations_to_equal_elements([1, 5, 9]) == 15 def test_min_operations_single_element(): assert min_operations_to_equal_elements([7]) == 7 def test_min_operations_two_elements(): assert min_operations_to_equal_elements([10, 15]) == 25 def test_min_operations_all_ones(): assert min_operations_to_equal_elements([1, 1, 1, 1, 1]) == 5 def test_min_operations_large_numbers(): assert min_operations_to_equal_elements([100000, 100000, 100000]) == 300000 def test_min_operations_mixed_numbers(): assert min_operations_to_equal_elements([5, 10, 15, 20, 25]) == 75","solution":"def min_operations_to_equal_elements(nums): Returns the minimum number of operations needed to make all elements in nums equal. Each operation chooses any two elements of the array and decreases them by 1. # The number of operations needed to make all elements equal to zero is simply the sum # of all elements in the array. return sum(nums)"},{"question":"def search_matrix(matrix, target): Returns True if target is present in the row and column sorted matrix. Returns False otherwise. >>> search_matrix( ... [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 5) == True >>> search_matrix( ... [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 20) == False","solution":"def search_matrix(matrix, target): Returns True if target is present in the row and column sorted matrix. Returns False otherwise. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) i, j = 0, cols - 1 # start from the top-right corner while i < rows and j >= 0: if matrix[i][j] == target: return True elif matrix[i][j] > target: j -= 1 else: i += 1 return False"},{"question":"def max_subarray_sum(N: int, A: List[int]) -> int: Determine the maximum sum of any non-empty subarray. >>> max_subarray_sum(8, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum(5, [-3, -1, -2, -4, -6]) -1 >>> max_subarray_sum(5, [1, 2, 3, 4, 5]) 15 >>> max_subarray_sum(5, [3, -2, 5, -1, 4]) 9 >>> max_subarray_sum(1, [-10]) -10 >>> max_subarray_sum(1, [10]) 10 >>> max_subarray_sum(7, [-2, 3, -4, 5, -6, 7, -8]) 7 >>> max_subarray_sum(7, [2, -3, 4, -5, 6, -7, 8]) 8","solution":"def max_subarray_sum(N, A): Determine the maximum sum of any non-empty subarray. Args: N : int : The length of the array A. A : list of int : List containing N integers. Returns: int : The maximum sum of any non-empty subarray. current_max = A[0] global_max = A[0] for i in range(1, N): current_max = max(A[i], current_max + A[i]) global_max = max(global_max, current_max) return global_max"},{"question":"def numTrees(n: int) -> int: Given a positive integer n, count all possible distinct binary search trees (BST) that can be made using values from 1 to n. Args: n : int : The number of nodes Returns: int : The number of distinct BSTs that can be constructed using the integers 1 to n. Example: >>> numTrees(3) 5","solution":"def numTrees(n): Returns the number of distinct binary search trees (BSTs) that can be constructed using values from 1 to n. G = [0] * (n + 1) G[0], G[1] = 1, 1 for i in range(2, n + 1): for j in range(1, i + 1): G[i] += G[j - 1] * G[i - j] return G[n]"},{"question":"class CumulativeSales: def __init__(self, n): Initialize the CumulativeSales system with n products. pass def record_sale(self, x, v): Record a sale transaction for product with ID x and number of units v. pass def range_sum_query(self, l, r): Return the total number of units sold for products with IDs from l to r inclusive. pass def process_queries(n, queries): Process a list of queries and return the results for each range sum query. >>> process_queries(5, [[1, 1, 100], [1, 2, 150], [2, 1, 3], [1, 3, 200], [1, 4, 50], [2, 1, 4]]) [250, 500] >>> process_queries(5, [[2, 1, 3], [2, 1, 4]]) [0, 0] >>> process_queries(1, [[1, 1, 300], [2, 1, 1]]) [300] >>> process_queries(3, [[1, 1, 200], [1, 2, 100], [1, 3, 50], [2, 1, 3], [1, 1, 50], [2, 1, 3]]) [350, 400] >>> process_queries(100000, [[1, i, 1] for i in range(1, 100001)] + [[2, 1, 100000]]) [100000]","solution":"class CumulativeSales: def __init__(self, n): self.sales = [0] * (n + 1) def record_sale(self, x, v): self.sales[x] += v def range_sum_query(self, l, r): return sum(self.sales[l:r+1]) def process_queries(n, queries): sales_system = CumulativeSales(n) results = [] for query in queries: if query[0] == 1: _, x, v = query sales_system.record_sale(x, v) elif query[0] == 2: _, l, r = query results.append(sales_system.range_sum_query(l, r)) return results"},{"question":"def can_reach_end(grid, start_row, start_col, end_row, end_col): Determine if there is a path from a given starting position (start_row, start_col) to an ending position (end_row, end_col) on the grid. The player can only move in four directions: up, down, left, and right. The grid contains cells that are either open (represented by 0) or blocked (represented by 1). Args: grid: List[List[int]] - 2D grid of integers where 0 represents open cell and 1 represents blocked cell. start_row: int - starting row index start_col: int - starting column index end_row: int - ending row index end_col: int - ending column index Returns: bool - True if a path exists, False otherwise >>> grid = [ ... [0, 0, 1, 0], ... [0, 1, 0, 0], ... [0, 0, 0, 1], ... [1, 0, 0, 0] ... ] >>> can_reach_end(grid, 0, 0, 3, 3) True >>> can_reach_end(grid, 0, 0, 3, 0) False pass","solution":"def can_reach_end(grid, start_row, start_col, end_row, end_col): def is_valid_move(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0 def dfs(x, y): # If we reached the end cell if (x, y) == (end_row, end_col): return True # Mark the cell as visited grid[x][y] = -1 # Explore the four possible directions for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_valid_move(nx, ny) and dfs(nx, ny): return True return False return dfs(start_row, start_col)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates an algebraic expression with +, -, and parentheses. Parameters: expression (str): The string containing the algebraic expression. Returns: int: The result of the evaluation. >>> evaluate_expression(\\"1 + 2\\") 3 >>> evaluate_expression(\\"2 - 3\\") -1 >>> evaluate_expression(\\"1 + 2 - (3 + 4)\\") -4 >>> evaluate_expression(\\"(1 + (4 + 5 + 2) - 3) + (6 + 8)\\") 23 >>> evaluate_expression(\\"(2 + (3 - (4 - 5)))\\") 6 >>> evaluate_expression(\\"(5 + 3) + (10 - 2)\\") 16 >>> evaluate_expression(\\" 5 + 3\\") 8 >>> evaluate_expression(\\"4 + (4 - 2)\\") 6","solution":"def evaluate_expression(expression): Evaluates an algebraic expression with +, -, and parentheses. Parameters: expression (str): The string containing the algebraic expression. Returns: int: The result of the evaluation. def helper(stack): num = 0 sign = 1 result = 0 while stack: char = stack.pop() if char.isdigit(): num = num * 10 + int(char) elif char == '+': result += sign * num num = 0 sign = 1 elif char == '-': result += sign * num num = 0 sign = -1 elif char == '(': result += sign * num num = 0 result += sign * helper(stack) elif char == ')': result += sign * num return result result += sign * num return result # Remove spaces and reverse the string to process the expression from left to right using a stack expression = expression.replace(' ', '')[::-1] # Convert expression to a stack of characters stack = list(expression) return helper(stack)"},{"question":"def count_smaller(nums: List[int]) -> List[int]: Given a list of integers \`nums\`, return a list of the same length where each element in the output list is the number of elements to the right of that element in the original list that are smaller than it. >>> count_smaller([3, 4, 9, 6, 1]) [1, 1, 2, 1, 0] >>> count_smaller([1, 2, 3, 4, 5]) [0, 0, 0, 0, 0] >>> count_smaller([5, 4, 3, 2, 1]) [4, 3, 2, 1, 0] >>> count_smaller([5, 2, 6, 1]) [2, 1, 1, 0] >>> count_smaller([2, 2, 2, 2, 2]) [0, 0, 0, 0, 0] >>> count_smaller([5]) [0] >>> count_smaller([5, 2]) [1, 0]","solution":"def count_smaller(nums): Returns a list where each element is the count of numbers to the right of the corresponding element in nums that are smaller than it. result = [] sorted_list = [] # Helper function to insert a number in sorted order def insert(num): left, right = 0, len(sorted_list) while left < right: mid = (left + right) // 2 if sorted_list[mid] < num: left = mid + 1 else: right = mid sorted_list.insert(left, num) return left for num in reversed(nums): index = insert(num) result.append(index) return result[::-1]"},{"question":"def first_missing_positive(nums): Given an array of integers, find the first missing positive integer. The function runs in O(n) time and uses constant extra space. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 from solution import first_missing_positive def test_missing_positive_simple(): assert first_missing_positive([3, 4, -1, 1]) == 2 assert first_missing_positive([1, 2, 0]) == 3 def test_missing_positive_consecutive(): assert first_missing_positive([1, 2, 3, 4, 5]) == 6 assert first_missing_positive([1, 2, 3]) == 4 def test_missing_positive_with_negatives(): assert first_missing_positive([-1, -2, -3]) == 1 def test_missing_positive_unsorted(): assert first_missing_positive([7, 8, 9, 11, 12]) == 1 assert first_missing_positive([3, 4, -1, 1, 0, 2, 5]) == 6 def test_missing_positive_with_duplicate(): assert first_missing_positive([1, 1, 1, 1]) == 2 def test_missing_positive_single_element(): assert first_missing_positive([1]) == 2 assert first_missing_positive([2]) == 1 def test_empty_list(): assert first_missing_positive([]) == 1","solution":"def first_missing_positive(nums): Given an array of integers, find the first missing positive integer. The function runs in O(n) time and uses constant extra space. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def find_first_missing_positive(nums: List[int]) -> int: Returns the smallest positive integer that is missing from the list. >>> find_first_missing_positive([3, 4, -1, 1]) == 2 >>> find_first_missing_positive([1, 2, 0]) == 3 >>> find_first_missing_positive([-1, -2, -3]) == 1 >>> find_first_missing_positive([1, 2, 3]) == 4 >>> find_first_missing_positive([10, 1, 3, -1, 6, 4, 2]) == 5 >>> find_first_missing_positive([]) == 1 >>> find_first_missing_positive([2]) == 1 >>> find_first_missing_positive([1]) == 2","solution":"def find_first_missing_positive(nums): Returns the smallest positive integer that is missing from the list. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap elements to their correct positions nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def matrix_diagonal_difference(matrix: List[List[int]]) -> int: Computes the absolute difference between the sum of the primary and secondary diagonals of a square matrix. Args: matrix (List[List[int]]): A square matrix of integers. Returns: int: The absolute difference between the sum of the primary and secondary diagonals. >>> matrix_diagonal_difference([ ... [11, 2, 4], ... [4, 5, 6], ... [10, 8, -12] ... ]) 15 >>> matrix_diagonal_difference([ ... [1, 2], ... [3, 4] ... ]) 0 >>> matrix_diagonal_difference([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> matrix_diagonal_difference([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) 0 >>> matrix_diagonal_difference([ ... [i + j for j in range(1000)] for i in range(1000) ... ]) 0","solution":"def matrix_diagonal_difference(matrix): Computes the absolute difference between the sum of the primary and secondary diagonals of a square matrix. Args: matrix (List[List[int]]): A square matrix of integers. Returns: int: The absolute difference between the sum of the primary and secondary diagonals. n = len(matrix) primary_diagonal_sum = sum(matrix[i][i] for i in range(n)) secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n)) return abs(primary_diagonal_sum - secondary_diagonal_sum)"},{"question":"from typing import List, Tuple def damage_grid(grid: List[List[int]], attacks: List[Tuple[int, int, int]]) -> List[List[int]]: Simulates the attacks on a 2D grid and returns the updated grid. Parameters: - grid: 2D list of integers where each value represents health of units. - attacks: List of tuples (x, y, damage) where (x, y) are coordinates and damage is the amount of damage to inflict. Returns: - Updated 2D list (grid) after applying all the attacks. Examples: >>> grid = [ ... [10, 0, 5], ... [0, 20, 0], ... [0, 0, 0] ... ] >>> attacks = [ ... (0, 2, 3), ... (1, 1, 5), ... (0, 0, 10) ... ] >>> damage_grid(grid, attacks) [[0, 0, 2], [0, 15, 0], [0, 0, 0]] >>> grid = [ ... [2, 4], ... [6, 8] ... ] >>> attacks = [ ... (0, 1, 4), ... (1, 1, 9) ... ] >>> damage_grid(grid, attacks) [[2, 0], [6, 0]]","solution":"def damage_grid(grid, attacks): Simulates the attacks on a 2D grid and returns the updated grid. Parameters: - grid: 2D list of integers where each value represents health of units. - attacks: List of tuples (x, y, damage) where (x, y) are coordinates and damage is the amount of damage to inflict. Returns: - Updated 2D list (grid) after applying all the attacks. for x, y, damage in attacks: if grid[x][y] > 0: # Check if there is a unit at the given coordinates grid[x][y] -= damage # Apply damage if grid[x][y] <= 0: # Check if unit's health has fallen to zero or below grid[x][y] = 0 # Remove the unit by setting the cell to zero return grid"},{"question":"from typing import List, Tuple, Dict def create_schedule(tasks: List[Tuple[str, int]]) -> Dict[str, int]: This function receives a list of tuples containing the schedule of different tasks. Each tuple consists of two elements: a string representing the day of the week, and the duration of the task in hours (an integer). The function returns a dictionary summarizing the total tasks time for each day of the week. >>> create_schedule([('Monday', 2), ('Tuesday', 3), ('Monday', 1), ('Wednesday', 4), ('Friday', 5)]) {'Monday': 3, 'Tuesday': 3, 'Wednesday': 4, 'Thursday': 0, 'Friday': 5, 'Saturday': 0, 'Sunday': 0} >>> create_schedule([]) {'Monday': 0, 'Tuesday': 0, 'Wednesday': 0, 'Thursday': 0, 'Friday': 0, 'Saturday': 0, 'Sunday': 0} >>> create_schedule([('Monday', 1), ('Wednesday', 3), ('Friday', 2)]) {'Monday': 1, 'Tuesday': 0, 'Wednesday': 3, 'Thursday': 0, 'Friday': 2, 'Saturday': 0, 'Sunday': 0} >>> create_schedule([('Monday', 1), ('Tuesday', 1), ('Wednesday', 2), ('Thursday', 3), ('Friday', 4), ('Saturday', 5), ('Sunday', 6)]) {'Monday': 1, 'Tuesday': 1, 'Wednesday': 2, 'Thursday': 3, 'Friday': 4, 'Saturday': 5, 'Sunday': 6} >>> create_schedule([('Monday', 1), ('Monday', 1), ('Tuesday', 2), ('Wednesday', 3), ('Wednesday', 1), ('Thursday', 1), ('Friday', 4), ('Sunday', 2), ('Sunday', 1), ('Sunday', 1)]) {'Monday': 2, 'Tuesday': 2, 'Wednesday': 4, 'Thursday': 1, 'Friday': 4, 'Saturday': 0, 'Sunday': 4}","solution":"def create_schedule(tasks): This function receives a list of tuples containing the schedule of different tasks. Each tuple consists of two elements: a string representing the day of the week, and the duration of the task in hours (an integer). The function returns a dictionary summarizing the total tasks time for each day of the week. # Initialize the schedule with all days of the week set to 0 hours schedule = { 'Monday': 0, 'Tuesday': 0, 'Wednesday': 0, 'Thursday': 0, 'Friday': 0, 'Saturday': 0, 'Sunday': 0 } # Iterate through the tasks and accumulate the hours for each day for day, duration in tasks: if day in schedule: schedule[day] += duration return schedule"},{"question":"def min_operations(X: str, Y: str) -> int: Calculates the minimum number of operations required to convert string X to string Y. Args: X : str : input string Y : str : target string Returns: int : minimum number of operations (insertions, deletions, substitutions) Example: >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 Unit Test: from solution import min_operations def test_min_operations_cases(): assert min_operations(\\"kitten\\", \\"sitting\\") == 3 assert min_operations(\\"flaw\\", \\"lawn\\") == 2 assert min_operations(\\"intention\\", \\"execution\\") == 5 assert min_operations(\\"apple\\", \\"apple\\") == 0 assert min_operations(\\"\\", \\"\\") == 0 assert min_operations(\\"abc\\", \\"\\") == 3 assert min_operations(\\"\\", \\"abc\\") == 3 def test_min_operations_edge_cases(): assert min_operations(\\"a\\", \\"a\\") == 0 assert min_operations(\\"a\\", \\"b\\") == 1 assert min_operations(\\"ab\\", \\"ba\\") == 2 assert min_operations(\\"abcdef\\", \\"abcdefg\\") == 1 assert min_operations(\\"example\\", \\"samples\\") == 3","solution":"def min_operations(X, Y): Calculates the minimum number of operations required to convert string X to string Y. Args: X : str : input string Y : str : target string Returns: int : minimum number of operations (insertions, deletions, substitutions) m = len(X) n = len(Y) # Create a DP table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(m + 1): for j in range(n + 1): # Base cases if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i # If last characters are the same elif X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last characters are different else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"import math def is_prime(n: int) -> bool: Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: return False return True def sumOfPrimes(numbers: List[int]) -> int: Returns the sum of the prime numbers in the list. >>> sumOfPrimes([1, 2, 3, 4, 5]) == 10 >>> sumOfPrimes([0, 1, 4, 6, 8]) == 0 >>> sumOfPrimes([7, 11, 13, 17]) == 48 >>> sumOfPrimes([10, 2, 3, 7, 5]) == 17","solution":"import math def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: return False return True def sumOfPrimes(numbers): Returns the sum of the prime numbers in the list. return sum(num for num in numbers if is_prime(num))"},{"question":"def find_max_average(nums, k): Finds the contiguous subarray of length k that has the maximum average value and returns the value. >>> find_max_average([1, 12, -5, -6, 50, 3], 4) 12.75 >>> find_max_average([5, 5, 5, 5, 5], 3) 5.0 >>> find_max_average([-1, -2, -3, -4, -5], 2) -1.5 >>> find_max_average([0, 4, 0, 3, 2], 1) 4.0 >>> find_max_average([7, 7, 7, 7, 7], 5) 7.0","solution":"def find_max_average(nums, k): Finds the contiguous subarray of length k that has the maximum average value and returns the value. n = len(nums) if n < k: raise ValueError(\\"The length of subarray k must be less than or equal to the length of nums.\\") # Initial sum of the first subarray of length k curr_sum = sum(nums[:k]) max_sum = curr_sum # Traverse from (k+1)th element to the last element for i in range(k, n): curr_sum = curr_sum - nums[i - k] + nums[i] if curr_sum > max_sum: max_sum = curr_sum # Maximum average is the maximum sum divided by k return max_sum / k"},{"question":"def min_path_cost(grid): Returns the minimum cost required to reach the bottom-right corner from the top-left corner of a grid. >>> min_path_cost([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_cost([[1, 2, 3, 4]]) 10 >>> min_path_cost([[1], [2], [3], [4]]) 10 >>> min_path_cost([[1, 2], [1, 1]]) 3 >>> min_path_cost([[1 for _ in range(200)] for _ in range(200)]) 399 >>> min_path_cost([[1, 1000], [1000, 1]]) 1002","solution":"import heapq def min_path_cost(grid): Returns the minimum cost required to reach the bottom-right corner from the top-left corner of a grid. n = len(grid) m = len(grid[0]) directions = [(0, 1), (1, 0)] # right, down min_heap = [(grid[0][0], 0, 0)] costs = [[float('inf')] * m for _ in range(n)] costs[0][0] = grid[0][0] while min_heap: cost, x, y = heapq.heappop(min_heap) if x == n - 1 and y == m - 1: return cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: new_cost = cost + grid[nx][ny] if new_cost < costs[nx][ny]: costs[nx][ny] = new_cost heapq.heappush(min_heap, (new_cost, nx, ny)) return costs[-1][-1]"},{"question":"def reverseString(s: str) -> str: Returns the string s in reverse order. >>> reverseString(\\"hello\\") \\"olleh\\" >>> reverseString(\\"world\\") \\"dlrow\\" >>> reverseString(\\"\\") \\"\\" >>> reverseString(\\"a\\") \\"a\\" >>> reverseString(\\"madam\\") \\"madam\\" >>> reverseString(\\"a b c\\") \\"c b a\\" >>> reverseString(\\"!@#%\\") \\"%#@!\\"","solution":"def reverseString(s): Returns the string s in reverse order. return s[::-1]"},{"question":"from typing import List def place_books(n: int, m: int, books: List[int]) -> List[List[int]]: Mimic the behavior of placing books on shelves in a local library. Args: n (int): number of rows of shelves (1 <= n <= 100) m (int): capacity (number of slots) of each row (1 <= m <= 100) books (List[int]): list of integers representing the books being returned (1 <= len(books) <= n*m) Returns: List[List[int]]: A list of lists representing the final state of the shelves. Examples: >>> place_books(3, 4, [101, 102, 103, 104, 105, 106, 107]) [[101, 102, 103, 104], [105, 106, 107], []] >>> place_books(2, 5, []) [[], []] >>> place_books(2, 3, [1, 2, 3, 4, 5, 6]) [[1, 2, 3], [4, 5, 6]] >>> place_books(4, 2, [10, 20, 30, 40, 50]) [[10, 20], [30, 40], [50], []] >>> place_books(1, 3, [7, 8, 9]) [[7, 8, 9]] >>> place_books(1, 5, [100]) [[100]] >>> place_books(3, 2, [1, 2, 3, 4, 5]) [[1, 2], [3, 4], [5]]","solution":"from typing import List def place_books(n: int, m: int, books: List[int]) -> List[List[int]]: shelves = [[] for _ in range(n)] current_row = 0 for book in books: if len(shelves[current_row]) == m: current_row += 1 shelves[current_row].append(book) return shelves"},{"question":"from typing import List, Tuple def can_rent_bike(availabilities: List[Tuple[int, int]], requests: List[Tuple[int, int]]) -> List[bool]: Determine if each rental request can be fulfilled based on bike availability. Args: availabilities (List[Tuple[int, int]]): List of tuples representing the availability periods of bikes. requests (List[Tuple[int, int]]): List of tuples representing the rental requests. Returns: List[bool]: List of booleans indicating whether each rental request can be fulfilled. Examples: >>> can_rent_bike([(9, 12), (13, 18), (19, 22)], [(10, 11), (9, 13), (14, 16), (20, 23)]) [True, False, True, False] >>> can_rent_bike([(9, 12), (13, 18), (19, 22)], [(8, 10), (12, 14), (18, 20), (22, 23)]) [False, False, False, False]","solution":"from typing import List, Tuple def can_rent_bike(availabilities: List[Tuple[int, int]], requests: List[Tuple[int, int]]) -> List[bool]: results = [] for req_start, req_end in requests: fulfilled = False for avail_start, avail_end in availabilities: if req_start >= avail_start and req_end <= avail_end: fulfilled = True break results.append(fulfilled) return results"},{"question":"def reduce_to_one(n: int) -> List[int]: Reduces the given integer n to 1 following the rule: - If n is even, divide n by 2. - If n is odd, subtract 1 from n. Returns a list of steps showing the reduction process. >>> reduce_to_one(10) [10, 5, 4, 2, 1] >>> reduce_to_one(7) [7, 6, 3, 2, 1] >>> reduce_to_one(1) [1] >>> reduce_to_one(16) [16, 8, 4, 2, 1] >>> reduce_to_one(21) [21, 20, 10, 5, 4, 2, 1]","solution":"def reduce_to_one(n): Reduces the given integer n to 1 following the rule: - If n is even, divide n by 2. - If n is odd, subtract 1 from n. Returns a list of steps showing the reduction process. steps = [n] while n > 1: if n % 2 == 0: n //= 2 else: n -= 1 steps.append(n) return steps"},{"question":"def can_form_teams(total_participants: int, team_size: int) -> bool: Determines if it's possible to divide the total number of participants into teams of a given size. Args: total_participants (int): The total number of participants. team_size (int): The size of each team. Returns: bool: True if it's possible to form the teams such that all teams have the same number of participants and no one is left without a team, otherwise False. >>> can_form_teams(50, 5) True >>> can_form_teams(50, 6) False","solution":"def can_form_teams(total_participants, team_size): Determines if it's possible to divide the total number of participants into teams of a given size. Args: total_participants (int): The total number of participants. team_size (int): The size of each team. Returns: bool: True if it's possible to form the teams such that all teams have the same number of participants and no one is left without a team, otherwise False. return total_participants % team_size == 0"},{"question":"class Scheduler: A class to simulate a task scheduler managing a set of tasks with their respective execution times. Methods: add_task(name, duration) -> int: Creates a new task with a given name and duration and initializes its state to \\"waiting\\". run_task(id, time): Executes a task identified by its unique id for a given time. get_state(id) -> str: Returns the current state of the task identified by the given id. get_remaining_duration(id) -> int: Returns the remaining duration for the task identified by the given id. Example usage: >>> scheduler = Scheduler() >>> task_id = scheduler.add_task(\\"Task1\\", 100) >>> scheduler.run_task(task_id, 50) >>> state = scheduler.get_state(task_id) 'running' >>> remaining = scheduler.get_remaining_duration(task_id) 50 >>> scheduler.run_task(task_id, 50) >>> state = scheduler.get_state(task_id) 'completed' >>> remaining = scheduler.get_remaining_duration(task_id) 0 def test_add_task(): scheduler = Scheduler() task_id = scheduler.add_task(\\"Task1\\", 100) assert task_id == 1 assert scheduler.get_state(task_id) == \\"waiting\\" assert scheduler.get_remaining_duration(task_id) == 100 def test_run_task(): scheduler = Scheduler() task_id = scheduler.add_task(\\"Task1\\", 100) scheduler.run_task(task_id, 50) assert scheduler.get_state(task_id) == \\"running\\" assert scheduler.get_remaining_duration(task_id) == 50 def test_run_task_completion(): scheduler = Scheduler() task_id = scheduler.add_task(\\"Task1\\", 100) scheduler.run_task(task_id, 100) assert scheduler.get_state(task_id) == \\"completed\\" assert scheduler.get_remaining_duration(task_id) == 0 def test_invalid_task_id_run_task(): scheduler = Scheduler() task_id = scheduler.add_task(\\"Task1\\", 100) invalid_task_id = task_id + 1 try: scheduler.run_task(invalid_task_id, 50) except Exception as e: assert str(e) == \\"Invalid task ID\\" def test_invalid_task_id_get_state(): scheduler = Scheduler() task_id = scheduler.add_task(\\"Task1\\", 100) invalid_task_id = task_id + 1 try: scheduler.get_state(invalid_task_id) except Exception as e: assert str(e) == \\"Invalid task ID\\" def test_invalid_task_id_get_remaining_duration(): scheduler = Scheduler() task_id = scheduler.add_task(\\"Task1\\", 100) invalid_task_id = task_id + 1 try: scheduler.get_remaining_duration(invalid_task_id) except Exception as e: assert str(e) == \\"Invalid task ID\\"","solution":"class Task: def __init__(self, name, duration): self.name = name self.duration = duration self.remaining_duration = duration self.state = \\"waiting\\" def run(self, time): if self.state == \\"waiting\\": self.state = \\"running\\" self.remaining_duration -= time if self.remaining_duration <= 0: self.remaining_duration = 0 self.state = \\"completed\\" class Scheduler: def __init__(self): self.tasks = {} self.next_id = 1 def add_task(self, name, duration): task_id = self.next_id self.next_id += 1 self.tasks[task_id] = Task(name, duration) return task_id def run_task(self, id, time): if id not in self.tasks: raise Exception(\\"Invalid task ID\\") task = self.tasks[id] task.run(time) def get_state(self, id): if id not in self.tasks: raise Exception(\\"Invalid task ID\\") return self.tasks[id].state def get_remaining_duration(self, id): if id not in self.tasks: raise Exception(\\"Invalid task ID\\") return self.tasks[id].remaining_duration"},{"question":"def can_be_divided(n: int) -> str: Determine if n can be evenly distributed into groups of 4 or 7. >>> can_be_divided(8) 'Feasible' >>> can_be_divided(14) 'Feasible' >>> can_be_divided(10) 'Not Feasible' >>> can_be_divided(0) 'Feasible' >>> can_be_divided(-8) 'Feasible' >>> can_be_divided(28) 'Feasible'","solution":"def can_be_divided(n): Determine if n can be evenly divided into groups of 4 or 7. Returns \\"Feasible\\" if n can be divided by 4 or 7, otherwise \\"Not Feasible\\". if n % 4 == 0 or n % 7 == 0: return \\"Feasible\\" return \\"Not Feasible\\""},{"question":"def max_flowers(flowerbed: List[int], n: int) -> bool: Determine if it's possible to plant \`n\` new flowers in the flowerbed without violating the no-adjacent-flowers rule. >>> max_flowers([1, 0, 0, 0, 1], 1) True >>> max_flowers([1, 0, 0, 0, 1], 2) False","solution":"def max_flowers(flowerbed, n): Determine if it's possible to plant \`n\` new flowers in the flowerbed without violating the no-adjacent-flowers rule. :param flowerbed: List[int] - The garden plots represented by 0s and 1s. :param n: int - The number of flowers to plant. :return: bool - True if it is possible to plant \`n\` flowers, otherwise False. count = 0 length = len(flowerbed) for i in range(length): if flowerbed[i] == 0: prev = (i == 0) or (flowerbed[i - 1] == 0) next = (i == length - 1) or (flowerbed[i + 1] == 0) if prev and next: flowerbed[i] = 1 count += 1 if count >= n: return True return count >= n"},{"question":"def max_water_trapped(heights: List[int]) -> int: Returns the maximum water that can be trapped between the buildings represented by heights. :param heights: List[int] :return: int >>> max_water_trapped([4, 2, 0, 3, 2, 5]) 9 >>> max_water_trapped([1, 1, 1, 1, 1]) 0 >>> max_water_trapped([3, 0, 2, 0, 4]) 7 pass","solution":"def max_water_trapped(heights): Returns the maximum water that can be trapped between the buildings represented by heights. :param heights: List[int] :return: int if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water_trapped += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += right_max - heights[right] return water_trapped"},{"question":"def find_palindrome(n: int) -> int: Determine the smallest integer greater than or equal to n that is a palindrome. >>> find_palindrome(123) 131 >>> find_palindrome(99) 99 >>> find_palindrome(100) 101 >>> find_palindrome(1234) 1331","solution":"def find_palindrome(n): while True: if str(n) == str(n)[::-1]: return n n += 1"},{"question":"def reverse_words_keep_spaces(s: str) -> str: Reverses the order of words in the input string, keeping the spaces intact. Args: s (str): Input string. Returns: str: Output string with the words reversed but spaces preserved. >>> reverse_words_keep_spaces('The quick brown fox') 'fox brown quick The' >>> reverse_words_keep_spaces(' Hello world ') ' world Hello ' >>> reverse_words_keep_spaces('Madam in Eden, I’m Adam') 'Adam I’m Eden, in Madam' >>> reverse_words_keep_spaces(' ') ' ' >>> reverse_words_keep_spaces(' Python programming ') ' programming Python '","solution":"def reverse_words_keep_spaces(s): Reverses the order of words in the input string, keeping the spaces intact. Args: s (str): Input string. Returns: str: Output string with the words reversed but spaces preserved. # Split the string into list of words and spaces words = s.split(' ') # Reverse the words list reversed_words = words[::-1] # Join the reversed words with a single space result = ' '.join(reversed_words) return result"},{"question":"def count_distinct_in_subarrays(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an array of integers and a list of queries, returns the number of distinct elements in each subarray defined by the queries. Parameters: n (int): The number of elements in the array. q (int): The number of queries. array (list of int): The array of elements. queries (list of tuples): The list of queries, where each tuple is (l, r). Returns: list of int: The answer to each query in sequence. from typing import List, Tuple def test_example_case(): n = 5 q = 3 array = [1, 2, 1, 3, 4] queries = [(1, 3), (2, 4), (1, 5)] expected = [2, 3, 4] assert count_distinct_in_subarrays(n, q, array, queries) == expected def test_single_element_subarray(): n = 5 q = 2 array = [1, 2, 1, 3, 4] queries = [(1, 1), (5, 5)] expected = [1, 1] assert count_distinct_in_subarrays(n, q, array, queries) == expected def test_entire_array(): n = 5 q = 1 array = [1, 2, 1, 3, 4] queries = [(1, 5)] expected = [4] assert count_distinct_in_subarrays(n, q, array, queries) == expected def test_all_elements_same(): n = 4 q = 2 array = [2, 2, 2, 2] queries = [(1, 4), (2, 3)] expected = [1, 1] assert count_distinct_in_subarrays(n, q, array, queries) == expected def test_varying_length_subarrays(): n = 6 q = 3 array = [1, 2, 3, 4, 5, 6] queries = [(1, 2), (1, 4), (1, 6)] expected = [2, 4, 6] assert count_distinct_in_subarrays(n, q, array, queries) == expected def test_subarray_at_the_end(): n = 6 q = 2 array = [1, 2, 3, 4, 5, 6] queries = [(5, 6), (3, 6)] expected = [2, 4] assert count_distinct_in_subarrays(n, q, array, queries) == expected","solution":"def count_distinct_in_subarrays(n, q, array, queries): Given an array of integers and a list of queries, returns the number of distinct elements in each subarray defined by the queries. Parameters: n (int): The number of elements in the array. q (int): The number of queries. array (list of int): The array of elements. queries (list of tuples): The list of queries, where each tuple is (l, r). Returns: list of int: The answer to each query in sequence. results = [] for l, r in queries: subarray = array[l-1:r] distinct_count = len(set(subarray)) results.append(distinct_count) return results"},{"question":"def find_pair_with_target(array: List[int], target: int) -> List[int]: Returns the first pair of numbers in the array that sum up to the target. Parameters: array (list of int): The input list of integers. target (int): The target sum. Returns: list: A list containing the first pair of numbers that sum up to the target, or an empty list if no such pair exists. >>> find_pair_with_target([2, 7, 11, 15], 9) [2, 7] >>> find_pair_with_target([3, 2, 4], 6) [2, 4] >>> find_pair_with_target([3, 3], 6) [3, 3] >>> find_pair_with_target([1, 2, 3, 4, 5], 10) []","solution":"def find_pair_with_target(array, target): Returns the first pair of numbers in the array that sum up to the target. Parameters: array (list of int): The input list of integers. target (int): The target sum. Returns: list: A list containing the first pair of numbers that sum up to the target, or an empty list if no such pair exists. seen = set() for num in array: complement = target - num if complement in seen: return [complement, num] seen.add(num) return []"},{"question":"from typing import List, Tuple def find_cheapest_dish(M: int, T: int, cafe_data: List[List[Tuple[int, int]]], queries: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Find the cheapest dish based on customer preferences and calorie limit. Args: M (int): Number of cafes. T (int): Number of queries. cafe_data (List[List[Tuple[int, int]]]): List of dishes in each cafe, where each dish is represented by a (price, calorie) tuple. queries (List[Tuple[Tuple[int, int], List[int]]]): List of queries, where each query is a tuple containing a (c, C) pair and a list of preferred cafes. Returns: List[int]: List of prices to be paid for each query. Returns -1 if no dish satisfies the criteria. Example: M = 3 T = 2 cafe_data = [ [(500, 600), (700, 800)], [(300, 500), (400, 600), (500, 900)], [(600, 700)] ] queries = [((2, 400), [1, 3]), ((1, 1400), [2, 3])] >>> find_cheapest_dish(M, T, cafe_data, queries) [-1, 300] pass def process_input(M: int, T: int, raw_data: List[int], raw_queries: List[Tuple[int, int, List[int]]]) -> Tuple[List[List[Tuple[int, int]]], List[Tuple[Tuple[int, int], List[int]]]]: Process the raw input data into formatted cafe_data and queries. Args: M (int): Number of cafes. T (int): Number of queries. raw_data (List[int]): Raw data containing dishes for each cafe. raw_queries (List[Tuple[int, int, List[int]]]): Raw queries containing customer preferences and calorie limits. Returns: Tuple[List[List[Tuple[int, int]]], List[Tuple[Tuple[int, int], List[int]]]]: Formatted cafe_data and queries. Example: M = 3 T = 2 raw_data = [2, 500, 600, 700, 800, 3, 300, 500, 400, 600, 500, 900, 1, 600, 700] raw_queries = [(2, 400), [1, 3], (1, 1400), [2, 3]] >>> process_input(M, T, raw_data, raw_queries) ([ [(500, 600), (700, 800)], [(300, 500), (400, 600), (500, 900)], [(600, 700)] ], [((2, 400), [1, 3]), ((1, 1400), [2, 3])]) pass # Test cases def test_find_cheapest_dish_example1(): M = 3 T = 2 raw_data = [2, 500, 600, 700, 800, 3, 300, 500, 400, 600, 500, 900, 1, 600, 700] raw_queries = [(2, 400), [1, 3], (1, 1400), [2, 3]] cafe_data, queries = process_input(M, T, raw_data, raw_queries) result = find_cheapest_dish(M, T, cafe_data, queries) assert result == [-1, 300] def test_find_cheapest_dish_case2(): M = 3 T = 1 raw_data = [2, 500, 600, 700, 800, 1, 300, 500, 2, 400, 600, 600, 700] raw_queries = [(3, 500), [1, 2, 3]] cafe_data, queries = process_input(M, T, raw_data, raw_queries) result = find_cheapest_dish(M, T, cafe_data, queries) assert result == [300] def test_find_cheapest_dish_no_valid_dishes(): M = 2 T = 1 raw_data = [1, 1000, 1500, 1, 1000, 2000] raw_queries = [(2, 1200), [1, 2]] cafe_data, queries = process_input(M, T, raw_data, raw_queries) result = find_cheapest_dish(M, T, cafe_data, queries) assert result == [-1] def test_find_cheapest_dish_multiple_options(): M = 2 T = 1 raw_data = [2, 200, 300, 500, 600, 2, 300, 400, 200, 450] raw_queries = [(2, 450), [1, 2]] cafe_data, queries = process_input(M, T, raw_data, raw_queries) result = find_cheapest_dish(M, T, cafe_data, queries) assert result == [200]","solution":"def find_cheapest_dish(M, T, cafe_data, queries): results = [] for query in queries: c, C = query[0] preferred_cafes = query[1] min_price = float('inf') for cafe_index in preferred_cafes: dishes = cafe_data[cafe_index - 1] for price, calorie in dishes: if calorie <= C and price < min_price: min_price = price if min_price == float('inf'): results.append(-1) else: results.append(min_price) return results # Helper function to process the input into the required format def process_input(M, T, raw_data, raw_queries): cafe_data = [] curr_index = 0 for _ in range(M): L = raw_data[curr_index] dishes = [] for i in range(L): price = raw_data[curr_index + 1 + 2 * i] calorie = raw_data[curr_index + 2 + 2 * i] dishes.append((price, calorie)) curr_index += 1 + 2 * L cafe_data.append(dishes) queries = [] for i in range(T): c_C = (raw_queries[2 * i][0], raw_queries[2 * i][1]) cafes = raw_queries[2 * i + 1] queries.append((c_C, cafes)) return cafe_data, queries"},{"question":"def generate_badges(names): Generates a list of badges with unique identifiers for each attendee. Given a list of full names, this function returns a list of badges formatted as \\"Full_Name - ID\\", where \\"ID\\" is a unique identifier starting from 1. Args: names (list): List of full names as strings (e.g., ['John Doe', 'Jane Smith']) Returns: list: List of formatted badge strings in the format \\"Full_Name - ID\\" >>> generate_badges(['John Doe']) ['John Doe - 1'] >>> generate_badges(['John Doe', 'Jane Smith']) ['John Doe - 1', 'Jane Smith - 2'] >>> generate_badges([]) [] >>> generate_badges(['Alice', 'Bob', 'Charlie', 'David', 'Eve']) ['Alice - 1', 'Bob - 2', 'Charlie - 3', 'David - 4', 'Eve - 5']","solution":"def generate_badges(names): Generates a list of badges with unique identifiers for each attendee. Parameters: names (list): List of full names Returns: list: List of formatted badge strings in the format \\"Full_Name - ID\\" return [f\\"{name} - {i+1}\\" for i, name in enumerate(names)]"},{"question":"from typing import List def max_length_subarray(nums: List[int], target: int) -> int: Returns the length of the longest contiguous subarray that sums to the given target. :param nums: List of integers :param target: Target sum for the subarray :return: Length of the longest contiguous subarray with the target sum Example: >>> max_length_subarray([1, -1, 5, -2, 3], 3) 4 >>> max_length_subarray([-2, -1, 2, 1], 1) 2 >>> max_length_subarray([3, 1, -1, -1, 2], 3) 3 pass","solution":"def max_length_subarray(nums, target): Returns the length of the longest contiguous subarray that sums to the given target. :param nums: List of integers :param target: Target sum for the subarray :return: Length of the longest contiguous subarray with the target sum cum_sum_map = {} cum_sum = 0 max_len = 0 for i, num in enumerate(nums): cum_sum += num if cum_sum == target: max_len = i + 1 if (cum_sum - target) in cum_sum_map: max_len = max(max_len, i - cum_sum_map[cum_sum - target]) if cum_sum not in cum_sum_map: cum_sum_map[cum_sum] = i return max_len"},{"question":"from typing import List def count_pattern_occurrences(identifiers: List[str], pattern: str) -> int: Returns the total count of occurrences of the pattern within the identifiers. >>> count_pattern_occurrences([\\"ab12cd34\\", \\"123ab\\", \\"a1b2c3\\"], \\"12\\") == 2 >>> count_pattern_occurrences([\\"abc\\", \\"def\\", \\"ghi\\"], \\"12\\") == 0 >>> count_pattern_occurrences([\\"ab12ab12ab\\", \\"12ab12\\", \\"121212\\"], \\"12\\") == 7 >>> count_pattern_occurrences([\\"abc12\\", \\"12abc\\", \\"abc12def\\", \\"def\\"], \\"12\\") == 3 >>> count_pattern_occurrences([\\"\\", \\"\\", \\"\\"], \\"12\\") == 0 >>> count_pattern_occurrences([\\"aA12Ba34\\", \\"aa12bb\\", \\"AA12BB\\"], \\"aa\\") == 1 >>> count_pattern_occurrences([\\"aA12Ba34\\", \\"aa12bb\\", \\"AA12BB\\"], \\"AA\\") == 1 >>> count_pattern_occurrences([\\"ab\\", \\"cd\\"], \\"abcd\\") == 0 >>> count_pattern_occurrences([\\"ab12cd34\\", \\"\\", \\"123ab\\"], \\"12\\") == 2 # Your code here","solution":"from typing import List def count_pattern_occurrences(identifiers: List[str], pattern: str) -> int: Returns the total count of occurrences of the pattern within the identifiers. count = 0 for identifier in identifiers: count += identifier.count(pattern) return count"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i. >>> product_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_except_self([10]) [1] >>> product_except_self([3, 5]) [5, 3] >>> product_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_except_self([2, 3, 4, 5, 6]) [360, 240, 180, 144, 120] >>> product_except_self([-1, 1, -1, 1]) [-1, 1, -1, 1] >>> product_except_self([100, 200, 300]) [60000, 30000, 20000]","solution":"def product_except_self(nums): Returns a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i. length = len(nums) answer = [0]*length # Create an array 'left_products' to contain the product of all elements to the left of each index left_products = [1]*length for i in range(1, length): left_products[i] = nums[i - 1] * left_products[i - 1] # Create an array 'right_products' to contain the product of all elements to the right of each index right_products = [1]*length for i in range(length - 2, -1, -1): right_products[i] = nums[i + 1] * right_products[i + 1] # Constructing the answer array for i in range(length): answer[i] = left_products[i] * right_products[i] return answer"},{"question":"def validateSudoku(board: str) -> bool: Create a function that takes a string representation of a Sudoku board and returns whether it's a valid board according to Sudoku rules. A valid Sudoku board must satisfy: - Each row contains the digits 1-9 without repetition (except for empty cells). - Each column contains the digits 1-9 without repetition (except for empty cells). - Each of the nine 3x3 sub-grids contains the digits 1-9 without repetition (except for empty cells). >>> validateSudoku(\\"53..7....6..195....98....6.8...6...34..8.3..17...2...6.6....28....419..5....8..79\\") True >>> validateSudoku(\\"53..7....6..195....98....6.8...6...34..8.3..17...2...6.6....28....419..5....8..71\\") False","solution":"def validateSudoku(board): def is_valid_block(block): block = [num for num in block if num != \\".\\"] return len(block) == len(set(block)) rows = [board[i * 9:(i + 1) * 9] for i in range(9)] columns = [board[i::9] for i in range(9)] subgrids = [ board[r * 9 + c:r * 9 + c + 3] + board[(r + 1) * 9 + c:(r + 1) * 9 + c + 3] + board[(r + 2) * 9 + c:(r + 2) * 9 + c + 3] for r in [0, 3, 6] for c in [0, 3, 6] ] for i in range(9): if not is_valid_block(rows[i]) or not is_valid_block(columns[i]) or not is_valid_block(subgrids[i]): return False return True"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns an array where each element at index 'i' is the product of all the numbers in the original array except the one at 'i'. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([10, 3, 5, 6, 2]) [180, 600, 360, 300, 900] >>> product_except_self([]) [] >>> product_except_self([10]) [1] >>> product_except_self([2, 3]) [3, 2]","solution":"def product_except_self(nums): Returns an array where each element at index 'i' is the product of all the numbers in the original array except the one at 'i'. n = len(nums) if n == 0: return [] # Initialize the left and right product arrays left_products = [1] * n right_products = [1] * n output = [1] * n # Fill left_products array for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill right_products array for j in range(n - 2, -1, -1): right_products[j] = right_products[j + 1] * nums[j + 1] # Fill the output array for k in range(n): output[k] = left_products[k] * right_products[k] return output"},{"question":"def can_partition_string(s: str, n: int) -> bool: Given a string s and an integer n, return true if it is possible to partition the string into exactly n substrings such that each substring contains unique characters, otherwise return false. >>> can_partition_string(\\"abac\\", 2) True >>> can_partition_string(\\"aaaa\\", 2) False >>> can_partition_string(\\"abcdef\\", 6) True","solution":"def can_partition_string(s, n): Returns true if it is possible to partition the string into n substrings such that each contains unique characters, otherwise returns false. # A set to store the characters seen so far in each possible partition seen = set() # Count the number of unique characters unique_count = 0 for char in s: if char not in seen: seen.add(char) unique_count += 1 return unique_count >= n"},{"question":"def shortest_delivery_time(t: int, test_cases: List[List[List[int]]]) -> List[int]: You have been hired to help a delivery company optimize its delivery routes. The company has a grid-like city with N x N intersections, and you need to find the shortest path from the top-left corner (0,0) to the bottom-right corner (N-1,N-1). Each intersection has a certain delivery time associated with it, which indicates how long it takes to traverse that intersection. You have the following information: - Each intersection can only be traversed once. - You can only move to the right or down from any intersection. Write an algorithm to help the company determine the shortest delivery time to go from the top-left corner to the bottom-right corner. Args: t (int): Number of test cases test_cases (List[List[List[int]]]): A list containing grids of integers representing delivery times for multiple test cases Returns: List[int]: A list containing the shortest delivery time for each test case. >>> shortest_delivery_time(1, [[[1, 3, 1], [1, 5, 1], [4, 2, 1]]]) [7] >>> shortest_delivery_time(1, [[[1, 3, 1, 2], [1, 5, 1, 3], [4, 2, 1, 1], [2, 1, 2, 1]]]) [9] >>> shortest_delivery_time(1, [[[1, 3, 1, 2, 8], [1, 5, 1, 3, 4], [4, 2, 1, 1, 9], [2, 1, 2, 1, 1], [2, 3, 4, 1, 1]]]) [11] >>> shortest_delivery_time(2, [[[1, 3, 1], [1, 5, 1], [4, 2, 1]], [[1, 3, 1, 2], [1, 5, 1, 3], [4, 2, 1, 1], [2, 1, 2, 1]]]) [7, 9] >>> shortest_delivery_time(1, [[[5, 9], [4, 2]]]) [11]","solution":"def shortest_delivery_time(t, test_cases): def min_path_sum(grid): N = len(grid) dp = [[0]*N for _ in range(N)] dp[0][0] = grid[0][0] # start point # Initialize first row for i in range(1, N): dp[0][i] = dp[0][i-1] + grid[0][i] # Initialize first column for j in range(1, N): dp[j][0] = dp[j-1][0] + grid[j][0] # Fill the rest of the dp table for i in range(1, N): for j in range(1, N): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[N-1][N-1] results = [] for test_case in test_cases: results.append(min_path_sum(test_case)) return results def format_and_solve(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) index += 1 grid = [] for i in range(N): row = list(map(int, input_lines[index].split())) index += 1 grid.append(row) test_cases.append(grid) return shortest_delivery_time(T, test_cases)"},{"question":"def solve(arr: List[int]) -> int: Given an array of integers, return the product of the maximum and minimum value in the array. If the array is empty, return \`0\`. >>> solve([1, 2, 3, 4, 5]) 5 >>> solve([-10, -20, 10, 20]) -400 >>> solve([]) 0 >>> solve([5, 5, 5, 5, 5]) 25 >>> solve([-3, 0, 2, 5, -7]) -35","solution":"def solve(arr): Returns the product of the maximum and minimum value in the array. If the array is empty, return 0. if not arr: return 0 max_value = max(arr) min_value = min(arr) return max_value * min_value"},{"question":"from typing import List def median_of_concatenated_arrays(arr1: List[int], arr2: List[int]) -> float: Find the median of two sorted arrays that are concatenated together. >>> median_of_concatenated_arrays([1, 3], [2]) 2.0 >>> median_of_concatenated_arrays([1, 2], [3, 4]) 2.5","solution":"def median_of_concatenated_arrays(arr1, arr2): Returns the median of two concatenated sorted arrays. merged_array = merge_arrays(arr1, arr2) length = len(merged_array) if length % 2 == 1: return float(merged_array[length // 2]) else: mid1, mid2 = merged_array[length // 2 - 1], merged_array[length // 2] return (mid1 + mid2) / 2.0 def merge_arrays(arr1, arr2): merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 while i < len(arr1): merged.append(arr1[i]) i += 1 while j < len(arr2): merged.append(arr2[j]) j += 1 return merged"},{"question":"def sum_of_digits(n: int) -> int: Calculate the sum of the digits of a given integer. If the integer is negative, treat it as its absolute value while calculating the sum. >>> sum_of_digits(1234) == 10 >>> sum_of_digits(-1234) == 10 >>> sum_of_digits(0) == 0 >>> sum_of_digits(7) == 7 >>> sum_of_digits(-9) == 9 >>> sum_of_digits(9999) == 36 >>> sum_of_digits(-9999) == 36","solution":"def sum_of_digits(n): Returns the sum of the digits of the given integer n. If the integer is negative, treats it as its absolute value. n = abs(n) return sum(int(digit) for digit in str(n))"},{"question":"def longestUniqueSubstring(s: str) -> int: Returns the length of the longest substring where all characters are unique. >>> longestUniqueSubstring(\\"abcabcbb\\") 3 >>> longestUniqueSubstring(\\"bbbbb\\") 1 >>> longestUniqueSubstring(\\"pwwkew\\") 3 >>> longestUniqueSubstring(\\"\\") 0 >>> longestUniqueSubstring(\\"a\\") 1 >>> longestUniqueSubstring(\\"abcdef\\") 6 >>> longestUniqueSubstring(\\"abcdeff\\") 6 >>> longestUniqueSubstring(\\"abcdabcabb\\") 4","solution":"def longestUniqueSubstring(s): Returns the length of the longest substring with all unique characters. Parameters: s (str): The input string Returns: int: The length of the longest substring where all characters are unique if not s: return 0 max_length = 0 start = 0 char_index_map = {} for end in range(len(s)): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def merge(nums1, m, nums2, n): Merge two sorted integer arrays nums1 and nums2 into a single array sorted in non-decreasing order. The merged array should be stored in nums1 starting from the first position. Args: nums1 (list): The first list of integers with at least m+n length. m (int): Number of elements initialized in nums1. nums2 (list): The second list of integers. n (int): Number of elements in nums2. Returns: None: The merging is done in-place in nums1. from solution import merge def test_example_case(): nums1 = [1,2,3,0,0,0] nums2 = [2,5,6] merge(nums1, 3, nums2, 3) assert nums1 == [1,2,2,3,5,6] def test_with_zeros_in_nums1_tail(): nums1 = [1,5,6,0,0,0] nums2 = [2,3,4] merge(nums1, 3, nums2, 3) assert nums1 == [1,2,3,4,5,6] def test_nums1_all_zeros_initially(): nums1 = [0,0,0,0,0] nums2 = [1,2,3,4,5] merge(nums1, 0, nums2, 5) assert nums1 == [1,2,3,4,5] def test_nums2_empty(): nums1 = [1,2,3] nums2 = [] merge(nums1, 3, nums2, 0) assert nums1 == [1,2,3] def test_both_empty(): nums1 = [] nums2 = [] merge(nums1, 0, nums2, 0) assert nums1 == []","solution":"def merge(nums1, m, nums2, n): Merges two sorted integer arrays nums1 and nums2 into a single array sorted in non-decreasing order. The merged array should be stored in nums1 starting from the first position. Args: nums1 (list): The first list of integers with at least m+n length. m (int): Number of elements initialized in nums1. nums2 (list): The second list of integers. n (int): Number of elements in nums2. Returns: None: The merging is done in-place in nums1. # Last index of nums1 last = m + n - 1 # Merge in reverse order while m > 0 and n > 0: if nums1[m - 1] > nums2[n - 1]: nums1[last] = nums1[m - 1] m -= 1 else: nums1[last] = nums2[n - 1] n -= 1 last -= 1 # Fill nums1 with remaining elements of nums2 if any while n > 0: nums1[last] = nums2[n - 1] n -= 1 last -= 1"},{"question":"from typing import List def find_next_ascending_permutation(nums: List[int]) -> List[int]: Finds the next lexicographically greater permutation of the given list of integers. If such a permutation does not exist, returns the smallest permutation (sorted in ascending order). >>> find_next_ascending_permutation([1, 2, 3]) [1, 3, 2] >>> find_next_ascending_permutation([3, 2, 1]) [1, 2, 3] >>> find_next_ascending_permutation([1, 1, 5]) [1, 5, 1] >>> find_next_ascending_permutation([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> find_next_ascending_permutation([1, 3, 2, 4, 3, 2]) [1, 3, 3, 2, 2, 4]","solution":"def find_next_ascending_permutation(nums): Finds the next lexicographically greater permutation of the given list of integers. If such a permutation does not exist, returns the smallest permutation (sorted in ascending order). n = len(nums) # Step 1: Find the largest index i such that nums[i] < nums[i + 1] i = n - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i == -1: # If no such index exists, the list is sorted in descending order nums.sort() return nums # Step 2: Find the largest index j such that nums[i] < nums[j] j = n - 1 while nums[j] <= nums[i]: j -= 1 # Step 3: Swap nums[i] and nums[j] nums[i], nums[j] = nums[j], nums[i] # Step 4: Reverse the sub-array nums[i + 1:] nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"def max_histogram_area(heights: List[int]) -> int: Function to calculate the maximum rectangular area in a histogram. Each height in 'heights' represents the height of a bar in a histogram. >>> max_histogram_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> max_histogram_area([2, 1, 5, 6, 2, 3]) 10 >>> max_histogram_area([1]) 1 >>> max_histogram_area([2, 4]) 4 >>> max_histogram_area([5, 5, 5, 5]) 20 >>> max_histogram_area([1, 2, 3, 4, 5]) 9 >>> max_histogram_area([5, 4, 3, 2, 1]) 9 pass from solution import max_histogram_area def test_max_histogram_area_1(): assert max_histogram_area([6, 2, 5, 4, 5, 1, 6]) == 12 def test_max_histogram_area_2(): assert max_histogram_area([2, 1, 5, 6, 2, 3]) == 10 def test_max_histogram_area_3(): assert max_histogram_area([1]) == 1 def test_max_histogram_area_4(): assert max_histogram_area([2, 4]) == 4 def test_max_histogram_area_5(): assert max_histogram_area([]) == 0 def test_max_histogram_area_all_equal(): assert max_histogram_area([5, 5, 5, 5]) == 20 def test_max_histogram_area_increasing(): assert max_histogram_area([1, 2, 3, 4, 5]) == 9 def test_max_histogram_area_decreasing(): assert max_histogram_area([5, 4, 3, 2, 1]) == 9","solution":"def max_histogram_area(heights): Function to calculate the maximum rectangular area in a histogram. Each height in 'heights' represents the height of a bar in a histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def wordBreak(s: str, wordDict: List[str]) -> int: Given a string s and a dictionary of words wordDict, return the number of ways you can break the string into a sequence of one or more dictionary words. >>> wordBreak(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) == 2 >>> wordBreak(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) == 3 >>> wordBreak(\\"catsandog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) == 0 >>> wordBreak(\\"a\\", [\\"a\\"]) == 1 >>> wordBreak(\\"appleapple\\", [\\"apple\\"]) == 1 >>> wordBreak(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == 1 >>> wordBreak(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) == 1","solution":"def wordBreak(s, wordDict): Returns the number of ways to break the string s into a sequence of one or more dictionary words. word_set = set(wordDict) n = len(s) dp = [0] * (n + 1) dp[0] = 1 # One way to interpret an empty string for i in range(1, n + 1): for j in range(i): if s[j:i] in word_set: dp[i] += dp[j] return dp[n]"},{"question":"def unscramble_messages(m: int, messages: List[List[str]]) -> List[List[str]]: Given the number of messages m and a list of messages where each message is a list containing the number of words followed by the list of words, return the lexicographically smallest sequence of words for each message. Args: - m: int, number of messages - messages: List[List[str]], list of words for each message Returns: - List[List[str]], list of words sorted lexicographically for each message >>> unscramble_messages(1, [[5, \\"scrambled\\", \\"ancient\\", \\"book\\", \\"secret\\", \\"pirates\\"]]) [['ancient', 'book', 'pirates', 'scrambled', 'secret']] >>> unscramble_messages(1, [[3, \\"help\\", \\"need\\", \\"you\\"]]) [['help', 'need', 'you']] >>> unscramble_messages(2, [ [5, \\"scrambled\\", \\"ancient\\", \\"book\\", \\"secret\\", \\"pirates\\"], [3, \\"help\\", \\"need\\", \\"you\\"] ]) [['ancient', 'book', 'pirates', 'scrambled', 'secret'], ['help', 'need', 'you']] >>> unscramble_messages(1, [[0]]) [[]] >>> unscramble_messages(1, [[1, \\"word\\"]]) [['word']]","solution":"def unscramble_messages(m, messages): Given the number of messages m and a list of messages where each message is a list containing the number of words followed by the list of words, return the lexicographically smallest sequence of words for each message. Args: - m: int, number of messages - messages: List[List[str]], list of words for each message Returns: - List[List[str]], list of words sorted lexicographically for each message sorted_messages = [] for message in messages: k = message[0] words = message[1:] words_sorted = sorted(words) sorted_messages.append(words_sorted) return sorted_messages # Example usage num_messages = 2 message_data = [ [5, \\"scrambled\\", \\"ancient\\", \\"book\\", \\"secret\\", \\"pirates\\"], [3, \\"help\\", \\"need\\", \\"you\\"] ] sorted_msgs = unscramble_messages(num_messages, message_data) for msg in sorted_msgs: print(\\" \\".join(msg))"},{"question":"def solve(nums: List[int]) -> int: Returns the number of unique triplets in the list that sum up to zero. >>> solve([-1, 0, 1, 2, -1, -4]) 2 >>> solve([1, 2, 3, 4, 5]) 0 >>> solve([0, 0, 0, 0, 0]) 1","solution":"def solve(nums): Returns the number of unique triplets in the list that sum up to zero. nums.sort() n = len(nums) unique_triplets = set() for i in range(n): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: s = nums[i] + nums[left] + nums[right] if s == 0: unique_triplets.add((nums[i], nums[left], nums[right])) left += 1 right -= 1 while left < right and nums[left] == nums[left - 1]: left += 1 while left < right and nums[right] == nums[right + 1]: right -= 1 elif s < 0: left += 1 else: right -= 1 return len(unique_triplets)"},{"question":"def max_trees_cut(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the maximum number of trees you can cut down such that no two consecutive trees are cut down. >>> max_trees_cut(2, [(5, [1, 2, 3, 4, 5]), (4, [5, 5, 5, 5])]) [3, 2] >>> max_trees_cut(1, [(1, [5])]) [1] Args: t (int): Number of test cases test_cases (List[Tuple[int, List[int]]]): Each test case is represented by a tuple of an integer and a list of integers Returns: List[int]: A list with the maximum number of trees that can be cut down for each test case","solution":"def max_trees_cut(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] heights = test_cases[i][1] # The maximum number of non-consecutive trees you can cut is (N + 1) // 2 max_cut = (n + 1) // 2 results.append(max_cut) return results"},{"question":"def longest_unique_subarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray with all unique elements. Parameters: arr (list): A list of integers Returns: int: The length of the longest contiguous subarray with unique elements >>> longest_unique_subarray([2, 1, 2, 3, 4, 2]) == 4 >>> longest_unique_subarray([1, 2, 3, 4, 5]) == 5 >>> longest_unique_subarray([5, 5, 5, 5, 5]) == 1 >>> longest_unique_subarray([]) == 0 >>> longest_unique_subarray([1, 3, 5, 3, 1, 3, 5, 7]) == 4 >>> longest_unique_subarray([1]) == 1 >>> longest_unique_subarray([1, 2, 1, 2, 1, 2]) == 2 >>> longest_unique_subarray([i % 100 for i in range(1000)]) >= 100","solution":"def longest_unique_subarray(arr): Returns the length of the longest contiguous subarray with all unique elements. Parameters: arr (list): A list of integers Returns: int: The length of the longest contiguous subarray with unique elements if not arr: return 0 max_length = 0 start = 0 seen = {} for end in range(len(arr)): if arr[end] in seen and seen[arr[end]] >= start: start = seen[arr[end]] + 1 seen[arr[end]] = end max_length = max(max_length, end - start + 1) return max_length # Test cases validations assert longest_unique_subarray([2, 1, 2, 3, 4, 2]) == 4 assert longest_unique_subarray([1, 2, 3, 4, 5]) == 5 assert longest_unique_subarray([5, 5, 5, 5, 5]) == 1 assert longest_unique_subarray([]) == 0 assert longest_unique_subarray([1, 3, 5, 3, 1, 3, 5, 7]) == 4"},{"question":"def largest_subarray_sum(nums: List[int]) -> int: Implement a function largest_subarray_sum that takes a list of integers as an argument and returns the sum of the contiguous subarray which has the largest sum. Example 1: >>> largest_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 Example 2: >>> largest_subarray_sum([1]) 1 Example 3: >>> largest_subarray_sum([-1, -2, -3, -4]) -1 pass def test_largest_subarray_sum_positive_and_negative(): assert largest_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 def test_largest_subarray_sum_single_element(): assert largest_subarray_sum([1]) == 1 assert largest_subarray_sum([-1]) == -1 def test_largest_subarray_sum_all_negative(): assert largest_subarray_sum([-1, -2, -3, -4]) == -1 def test_largest_subarray_sum_all_positive(): assert largest_subarray_sum([1, 2, 3, 4]) == 10 def test_largest_subarray_sum_mixed(): assert largest_subarray_sum([34, -50, 42, 14, -5, 86]) == 137 def test_largest_subarray_sum_zero_included(): assert largest_subarray_sum([0, -1, 2, -1, 2]) == 3","solution":"def largest_subarray_sum(nums): Returns the sum of the contiguous subarray which has the largest sum. max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def count_highest_score_rounds(T: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Determines the number of rounds in which a given player managed to achieve the highest points in that round compared to all other players. Parameters: T: int - number of test cases test_cases: list of tuples where each tuple contains: (N: int, R: int, scores: list of list of integers) Returns: list of integers: number of rounds each player achieves the highest score >>> count_highest_score_rounds(2, [(3, 4, [[10, 15, 20, 30], [20, 25, 18, 15], [15, 10, 20, 10]]), (4, 2, [[5, 10], [5, 10], [5, 10], [3, 8]])]) [4, 2] >>> count_highest_score_rounds(1, [(2, 3, [[10, 20, 30], [30, 20, 10]])]) [3] from typing import List, Tuple def test_case_1(): T = 2 test_cases = [ (3, 4, [[10, 15, 20, 30], [20, 25, 18, 15], [15, 10, 20, 10]]), (4, 2, [[5, 10], [5, 10], [5, 10], [3, 8]]) ] result = count_highest_score_rounds(T, test_cases) assert result == [4, 2] def test_case_2(): T = 1 test_cases = [ (2, 3, [[10, 20, 30], [30, 20, 10]]) ] result = count_highest_score_rounds(T, test_cases) assert result == [3] def test_case_3(): T = 1 test_cases = [ (1, 1, [[1000]]) ] result = count_highest_score_rounds(T, test_cases) assert result == [1] def test_case_4(): T = 1 test_cases = [ (2, 2, [[0, 0], [0, 0]]) ] result = count_highest_score_rounds(T, test_cases) assert result == [2]","solution":"def count_highest_score_rounds(T, test_cases): Determines the number of rounds in which a given player managed to achieve the highest points in that round compared to all other players. Parameters: - T: int - number of test cases - test_cases: list of tuples where each tuple contains: (N: int, R: int, scores: list of list of integers) Returns: - list of integers: number of rounds each player achieves the highest score results = [] for n, r, scores in test_cases: count = 0 for j in range(r): max_score = max(scores[i][j] for i in range(n)) for i in range(n): if scores[i][j] == max_score: count += 1 break results.append(count) return results"},{"question":"def sort_cards_descending(n: int, card_values: List[int]) -> List[int]: Returns the card values sorted in descending order. Parameters: n (int): Total number of cards. card_values (list of int): List of integers representing the card values. Returns: list of int: The card values sorted in descending order. Examples: >>> sort_cards_descending(5, [3, 10, 4, 6, 8]) [10, 8, 6, 4, 3] >>> sort_cards_descending(2, [1, 2]) [2, 1]","solution":"def sort_cards_descending(n, card_values): Returns the card values sorted in descending order. Parameters: n (int): Total number of cards. card_values (list of int): List of integers representing the card values. Returns: list of int: The card values sorted in descending order. return sorted(card_values, reverse=True)"},{"question":"from typing import List def generate_book_pattern(N: int) -> List[str]: Generate a pattern of book identifiers. Parameters: N (int): The number of book identifiers to generate in the pattern. Returns: list: A list of strings where each string represents a repeated digit pattern. pass def book_patterns(test_cases: List[int]) -> List[List[str]]: Generate book patterns for multiple test cases. Parameters: test_cases (list): A list of integers where each integer represents a test case. Returns: list: A list of lists containing the book patterns for each test case. pass def test_generate_book_pattern(): assert generate_book_pattern(2) == ['11', '22'] assert generate_book_pattern(3) == ['11', '22', '33'] assert generate_book_pattern(1) == ['11'] assert generate_book_pattern(5) == ['11', '22', '33', '44', '55'] def test_book_patterns(): assert book_patterns([2, 3]) == [['11', '22'], ['11', '22', '33']] assert book_patterns([1]) == [['11']] assert book_patterns([5, 1, 3]) == [['11', '22', '33', '44', '55'], ['11'], ['11', '22', '33']]","solution":"def generate_book_pattern(N): Generate a pattern of book identifiers. Parameters: N (int): The number of book identifiers to generate in the pattern. Returns: list: A list of strings where each string represents a repeated digit pattern. pattern = [] for i in range(1, N + 1): pattern.append(str(i) * 2) return pattern def book_patterns(test_cases): Generate book patterns for multiple test cases. Parameters: test_cases (list): A list of integers where each integer represents a test case. Returns: list: A list of lists containing the book patterns for each test case. results = [] for n in test_cases: results.append(generate_book_pattern(n)) return results"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns a list such that each element at index i of the output list is the product of all the numbers in the input list except nums[i]. Args: nums: List[int] - the input list of integers Returns: List[int] - the product list >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5, 9]) [9, 5] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([100, 200, 300]) [60000, 30000, 20000] >>> product_except_self([2, 2, 2, 2]) [8, 8, 8, 8]","solution":"def product_except_self(nums): Returns a list such that each element at index i of the output list is the product of all the numbers in the input list except nums[i]. Args: nums: List[int] - the input list of integers Returns: List[int] - the product list length = len(nums) # Initialize the result array with 1's result = [1] * length # Calculate prefix products prefix = 1 for i in range(length): result[i] = prefix prefix *= nums[i] # Calculate suffix products and multiply with prefix products suffix = 1 for i in range(length - 1, -1, -1): result[i] *= suffix suffix *= nums[i] return result"},{"question":"from typing import List def lexicographically_smallest_string(S: str) -> str: Given a string S, returns the lexicographically smallest string that can be obtained by choosing any two different characters in the string and swapping them any number of times. >>> lexicographically_smallest_string(\\"bca\\") 'abc' >>> lexicographically_smallest_string(\\"zyx\\") 'xyz' >>> lexicographically_smallest_string(\\"abba\\") 'aabb' pass def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Given the number of test cases T and a list of strings, returns a list of the lexicographically smallest strings for each test case. >>> process_test_cases(3, [\\"bca\\", \\"zyx\\", \\"abba\\"]) ['abc', 'xyz', 'aabb'] >>> process_test_cases(2, [\\"dcba\\", \\"aaaa\\"]) ['abcd', 'aaaa'] pass","solution":"def lexicographically_smallest_string(S): Given a string S, returns the lexicographically smallest string that can be obtained by choosing any two different characters in the string and swapping them any number of times. return ''.join(sorted(S)) def process_test_cases(T, test_cases): results = [] for i in range(T): S = test_cases[i] results.append(lexicographically_smallest_string(S)) return results"},{"question":"def count_k_distinct_substrings(N, K, S): Returns the number of contiguous substrings in string S of length N that contain exactly K distinct characters. >>> count_k_distinct_substrings(4, 2, 'abac') == 4 >>> count_k_distinct_substrings(5, 3, 'abcde') == 3 >>> count_k_distinct_substrings(4, 1, 'aaaa') == 10 >>> count_k_distinct_substrings(4, 1, 'abcd') == 4 >>> count_k_distinct_substrings(4, 5, 'abcd') == 0 >>> count_k_distinct_substrings(0, 0, '') == None def main(test_cases): results = [] for case in test_cases: N, K, S = case result = count_k_distinct_substrings(N, K, S) if result is not None: results.append(result) return results # Test cases def test_case_1(): assert count_k_distinct_substrings(4, 2, 'abac') == 4 def test_case_2(): assert count_k_distinct_substrings(5, 3, 'abcde') == 3 def test_case_3(): assert count_k_distinct_substrings(4, 1, 'aaaa') == 10 def test_case_4(): assert count_k_distinct_substrings(4, 1, 'abcd') == 4 def test_main_function(): test_cases = [(4, 2, 'abac'), (5, 3, 'abcde')] assert main(test_cases) == [4, 3] def test_no_substrings_possible(): assert count_k_distinct_substrings(4, 5, 'abcd') == 0 def test_empty_case(): assert count_k_distinct_substrings(0, 0, '') == None","solution":"def count_k_distinct_substrings(N, K, S): Returns the number of contiguous substrings in string S of length N that contain exactly K distinct characters. if N == 0 and K == 0: return None from collections import defaultdict def at_most_k_distinct(k): char_count = defaultdict(int) left = 0 count = 0 for right in range(N): char_count[S[right]] += 1 while len(char_count) > k: char_count[S[left]] -= 1 if char_count[S[left]] == 0: del char_count[S[left]] left += 1 count += right - left + 1 return count return at_most_k_distinct(K) - at_most_k_distinct(K-1) def main(test_cases): results = [] for case in test_cases: N, K, S = case result = count_k_distinct_substrings(N, K, S) if result is not None: results.append(result) return results"},{"question":"def generate_sequence(N: int) -> List[int]: Generates a sequence starting at 1 where the difference between consecutive terms increases by 2 with each step. >>> generate_sequence(1) [1] >>> generate_sequence(2) [1, 4] >>> generate_sequence(3) [1, 4, 9] >>> generate_sequence(4) [1, 4, 9, 16] def process_input(T: int, test_cases: List[int]) -> List[List[int]]: Given the number of test cases and a list of N values (one for each test case), generate and return the sequences for each test case. >>> process_input(3, [1, 2, 3]) [[1], [1, 4], [1, 4, 9]] >>> process_input(2, [1, 4]) [[1], [1, 4, 9, 16]]","solution":"def generate_sequence(N): Generates a sequence starting at 1 where the difference between consecutive terms increases by 2 with each step. sequence = [] current_value = 1 increment = 3 for _ in range(N): sequence.append(current_value) current_value += increment increment += 2 return sequence def process_input(T, test_cases): Given the number of test cases and a list of N values (one for each test case), generate and return the sequences for each test case. result = [] for N in test_cases: result.append(generate_sequence(N)) return result"},{"question":"def frequencySort(arr): Sort the array based on the frequency of the values. If two values have the same frequency, then the value which appeared first in the input array should appear first in the sorted array. pass # Test cases def test_frequency_sort_basic(): assert frequencySort([4, 5, 6, 5, 4, 3]) == [4, 4, 5, 5, 6, 3] assert frequencySort([3, 3, 2, 1, 2, 2, 1]) == [2, 2, 2, 3, 3, 1, 1] def test_frequency_sort_single_element(): assert frequencySort([1]) == [1] def test_frequency_sort_all_same(): assert frequencySort([7, 7, 7, 7]) == [7, 7, 7, 7] def test_frequency_sort_different_frequencies(): assert frequencySort([5, 5, 4, 4, 4, 3, 3, 3, 3]) == [3, 3, 3, 3, 4, 4, 4, 5, 5] def test_frequency_sort_same_frequency(): assert frequencySort([8, 8, 7, 7, 6, 6]) == [8, 8, 7, 7, 6, 6] def test_frequency_sort_large_array(): arr = [i % 10 for i in range(10000)] assert frequencySort(arr) == sorted(arr, key=lambda x: (-arr.count(x), arr.index(x))) def test_frequency_sort_with_negative_numbers(): assert frequencySort([4, -1, -1, 4, 5, 5, -1, 0]) == [-1, -1, -1, 4, 4, 5, 5, 0]","solution":"def frequencySort(arr): Sort the array based on the frequency of the values. If two values have the same frequency, then the value which appeared first in the input array should appear first in the sorted array. from collections import Counter # Count frequencies frequency = Counter(arr) # Custom sort function def custom_sort(x): return (-frequency[x], arr.index(x)) # Sort the array based on the frequency return sorted(arr, key=custom_sort)"},{"question":"def min_moves(piles: List[int]) -> int: Returns the minimum number of moves required to make all piles contain exactly one stone. Parameters: piles (list of int): A list where each element represents the number of stones in the i-th pile Returns: int: The minimum number of moves required >>> min_moves([3, 4, 5]) 9 >>> min_moves([1, 2, 3]) 3 >>> min_moves([1, 1, 1]) 0","solution":"def min_moves(piles): Returns the minimum number of moves required to make all piles contain exactly one stone. Parameters: piles (list of int): A list where each element represents the number of stones in the i-th pile Returns: int: The minimum number of moves required return sum(pile - 1 for pile in piles)"},{"question":"from typing import List def collect_items(item_list: List[str]) -> List[str]: Removes duplicate items from the list, treating names case-insensitively, while preserving the original order of their first appearance. >>> collect_items([\\"Sword\\", \\"shield\\", \\"Potion\\", \\"sword\\", \\"Shield\\", \\"SWORD\\", \\"potion\\"]) [\\"Sword\\", \\"shield\\", \\"Potion\\"] >>> collect_items([\\"Sword\\", \\"shield\\", \\"Potion\\"]) [\\"Sword\\", \\"shield\\", \\"Potion\\"] >>> collect_items([]) [] >>> collect_items([\\"sword\\"]) [\\"sword\\"] >>> collect_items([\\"ShIeLd\\"]) [\\"ShIeLd\\"] >>> collect_items([\\"Sword\\", \\"SWoRd\\", \\"sworD\\"]) [\\"Sword\\"] >>> collect_items([\\"shield\\", \\"Shield\\", \\"SHIELD\\", \\"SHieLd\\"]) [\\"shield\\"]","solution":"def collect_items(item_list): Removes duplicate items from the list, treating names case-insensitively, while preserving the original order of their first appearance. seen = set() result = [] for item in item_list: lowercase_item = item.lower() if lowercase_item not in seen: seen.add(lowercase_item) result.append(item) return result"},{"question":"class Warehouse: A class to manage warehouse inventory. Methods ------- add_item(SKU, name, category, quantity) Adds a new item to the inventory. update_quantity(SKU, quantity) Updates the quantity of the specified item. get_item(SKU) Returns details of an item by SKU. get_items_in_category(category) Returns a list of all items in a given category. get_total_quantity() Returns the total quantity of all items in the warehouse. Example ------- >>> warehouse = Warehouse() >>> warehouse.add_item('SKU123', 'ItemA', 'Category1', 10) >>> warehouse.add_item('SKU124', 'ItemB', 'Category1', 5) >>> warehouse.add_item('SKU125', 'ItemC', 'Category2', 15) >>> warehouse.update_quantity('SKU123', 20) >>> warehouse.get_item('SKU123') {'SKU': 'SKU123', 'name': 'ItemA', 'category': 'Category1', 'quantity': 20} >>> warehouse.get_items_in_category('Category1') [{'SKU': 'SKU123', 'name': 'ItemA', 'category': 'Category1', 'quantity': 20}, {'SKU': 'SKU124', 'name': 'ItemB', 'category': 'Category1', 'quantity': 5}] >>> warehouse.get_total_quantity() 40 def __init__(self): self.items = {} def add_item(self, SKU, name, category, quantity): # Add the item to the warehouse inventory. pass def update_quantity(self, SKU, quantity): # Update the quantity of the specified item. pass def get_item(self, SKU): # Retrieve item details by SKU. pass def get_items_in_category(self, category): # Retrieve list of items in the specified category. pass def get_total_quantity(self): # Calculate the total quantity of items in the warehouse. pass","solution":"class Warehouse: def __init__(self): self.items = {} def add_item(self, SKU, name, category, quantity): self.items[SKU] = { \\"SKU\\": SKU, \\"name\\": name, \\"category\\": category, \\"quantity\\": quantity } def update_quantity(self, SKU, quantity): if SKU in self.items: self.items[SKU]['quantity'] = quantity def get_item(self, SKU): return self.items.get(SKU, None) def get_items_in_category(self, category): return [item for item in self.items.values() if item[\\"category\\"] == category] def get_total_quantity(self): return sum(item[\\"quantity\\"] for item in self.items.values())"},{"question":"def find_first_unique(lst: list) -> int: Finds the first unique integer in the list. If no unique integer is found, returns -1. >>> find_first_unique([9, 2, 3, 2, 6, 6]) 9 >>> find_first_unique([4, 5, 4, 5, 7, 8, 8]) 7 >>> find_first_unique([1, 1, 2, 2, 3, 3]) -1 def test_find_first_unique_no_repeats(): assert find_first_unique([9, 2, 3, 2, 6, 6]) == 9 def test_find_first_unique_repeats_and_unique(): assert find_first_unique([4, 5, 4, 5, 7, 8, 8]) == 7 def test_find_first_unique_no_uniques(): assert find_first_unique([1, 1, 2, 2, 3, 3]) == -1 def test_find_first_unique_first_element_unique(): assert find_first_unique([10, 5, 5, 6, 6, 7, 7]) == 10 def test_find_first_unique_single_element(): assert find_first_unique([42]) == 42 def test_find_first_unique_all_uniques(): assert find_first_unique([1, 2, 3, 4, 5]) == 1 def test_find_first_unique_large_numbers(): assert find_first_unique([1000000000, 2000000000, 1000000000, 3000000000]) == 2000000000 def test_find_first_unique_negative_numbers(): assert find_first_unique([-1, -2, -3, -2, -1, -4]) == -3","solution":"def find_first_unique(lst: list) -> int: Finds the first unique integer in the list. If no unique integer is found, returns -1. frequency = {} # Calculate frequency of each element for num in lst: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 # Find the first unique element for num in lst: if frequency[num] == 1: return num return -1"},{"question":"from typing import List def count_unique_pairs(nums: List[int], target: int) -> int: Returns the number of unique pairs in an integer array that sum up to the target. >>> count_unique_pairs([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) == 4 >>> count_unique_pairs([1, 2, 3], 10) == 0 >>> count_unique_pairs([5, 5, 5, 5], 10) == 1 >>> count_unique_pairs([-1, -2, -3, -4, -5, -6, 11, 12, 13, 14, 15], 10) == 5 >>> count_unique_pairs([-1, 1, 2, -2, 3, -3, 4, -4, 5], 0) == 4","solution":"def count_unique_pairs(nums, target): Returns the number of unique pairs in nums that sum up to target. seen = set() unique_pairs = set() for num in nums: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) unique_pairs.add(pair) seen.add(num) return len(unique_pairs)"},{"question":"from typing import List def check_sorted(lst: List[float]) -> str: Checks if the given list of floating point numbers is sorted in non-decreasing order. Args: lst: List of floating point numbers. Returns: \\"List is sorted\\" if the list is sorted in non-decreasing order, otherwise \\"List is not sorted\\". pass def test_sorted_list(): assert check_sorted([1.1, 2.2, 3.3, 4.4]) == \\"List is sorted\\" assert check_sorted([0.0, 0.1, 0.2, 0.2, 1.0]) == \\"List is sorted\\" def test_unsorted_list(): assert check_sorted([1.1, 3.3, 2.2, 4.4]) == \\"List is not sorted\\" assert check_sorted([5.0, 4.0, 6.0]) == \\"List is not sorted\\" def test_single_element_list(): assert check_sorted([1.1]) == \\"List is sorted\\" def test_empty_list(): assert check_sorted([]) == \\"List is sorted\\" def test_duplicate_elements(): assert check_sorted([1.1, 1.1, 1.1]) == \\"List is sorted\\" assert check_sorted([1.1, 1.1, 1.0]) == \\"List is not sorted\\" def test_negative_numbers(): assert check_sorted([-3.5, -2.2, -0.1, 0.0, 2.5]) == \\"List is sorted\\" assert check_sorted([-1.1, -2.2, -3.3]) == \\"List is not sorted\\"","solution":"from typing import List def check_sorted(lst: List[float]) -> str: Checks if the given list of floating point numbers is sorted in non-decreasing order. Args: lst: List of floating point numbers. Returns: \\"List is sorted\\" if the list is sorted in non-decreasing order, otherwise \\"List is not sorted\\". if all(lst[i] <= lst[i+1] for i in range(len(lst)-1)): return \\"List is sorted\\" else: return \\"List is not sorted\\""},{"question":"def generate_pattern(N: int) -> str: Generates and returns the pattern of alphabets as a string for the given integer N. >>> generate_pattern(1) 'A' >>> generate_pattern(2) 'AnB C' >>> generate_pattern(3) 'AnB CnD E F' pass def organize_books(M: int, test_cases: List[int]) -> List[str]: For each test case in the given list of test cases, generates the pattern and returns a list of the patterns. >>> organize_books(3, [1, 2, 3]) ['A', 'AnB C', 'AnB CnD E F'] >>> organize_books(3, [3, 2, 1]) ['AnB CnD E F', 'AnB C', 'A'] >>> organize_books(3, [4, 4, 4]) ['AnB CnD E FnG H I J', 'AnB CnD E FnG H I J', 'AnB CnD E FnG H I J'] pass","solution":"def generate_pattern(N): Generates and returns the pattern of alphabets as a string for the given integer N. alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' index = 0 result = [] for i in range(1, N + 1): row = [] for j in range(i): row.append(alphabet[index % len(alphabet)]) index += 1 result.append(\\" \\".join(row)) return \\"n\\".join(result) def organize_books(M, test_cases): For each test case in the given list of test cases, generates the pattern and returns a list of the patterns. Input: M: int - Number of test cases. test_cases: list of int - Each integer represents the value N for which pattern should be generated. Output: list of str - The generated patterns for each test case. results = [] for case in test_cases: results.append(generate_pattern(case)) return results"},{"question":"def replace_question_marks(s: str) -> str: Replace each '?' character in the string with a lowercase letter such that no two adjacent characters are the same. >>> replace_question_marks(\\"a?c?e\\") in [\\"abcde\\", \\"axcde\\", \\"aycde\\"] >>> replace_question_marks(\\"???\\") in [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> replace_question_marks(\\"ab?\\") in [\\"abc\\", \\"abd\\", \\"abf\\", \\"abg\\"]","solution":"def replace_question_marks(s): s = list(s) for i in range(len(s)): if s[i] == '?': for c in 'abc': if (i == 0 or s[i - 1] != c) and (i == len(s) - 1 or s[i + 1] != c): s[i] = c break return ''.join(s)"},{"question":"def maximize_happiness(n: int, inc: int, H: List[int]) -> int: Find the maximum possible sum of happiness scores after applying the operation to the array. Parameters: n (int): Number of citizens. inc (int): The increase value that can be applied exactly once to a subarray. H (list): List of initial happiness scores. Returns: int: Maximum possible sum of happiness scores. >>> maximize_happiness(5, 10, [1, 2, 3, 4, 5]) 65 >>> maximize_happiness(1, 1, [1000000000]) 1000000001 >>> maximize_happiness(4, 3, [5, 5, 5, 5]) 32 >>> maximize_happiness(3, 1000000000, [1, 2, 3]) 3000000006 >>> maximize_happiness(1, 1, [1]) 2 >>> maximize_happiness(1000, 1000000000, [1000000000]*1000) 2000000000000","solution":"def maximize_happiness(n, inc, H): This function returns the maximum possible sum of happiness scores after performing the operation on array H. Parameters: n (int): Number of citizens. inc (int): The increase value that can be applied exactly once to a subarray. H (list): List of initial happiness scores. Returns: int: Maximum possible sum of happiness scores. # Calculate the initial sum of the happiness scores initial_sum = sum(H) # To maximize the sum, we apply the increment to all elements return initial_sum + n * inc"},{"question":"from typing import List, Dict, Union def apply_promotion(products: List[Dict[str, Union[str, int]]], category: str, discount: int) -> List[Dict[str, Union[str, float]]]: Applies a given discount to all products in the specified category. Parameters: products (list of dict): The list of products. category (str): The category of products to which the promotion should be applied. discount (int): The percentage discount to apply. Returns: list of dict: The updated list of products with discounted prices for the specified category. Examples: >>> products = [ ... {\\"name\\": \\"Laptop\\", \\"category\\": \\"Electronics\\", \\"price\\": 1000}, ... {\\"name\\": \\"Headphones\\", \\"category\\": \\"Electronics\\", \\"price\\": 200}, ... {\\"name\\": \\"Shoes\\", \\"category\\": \\"Clothing\\", \\"price\\": 100}, ... {\\"name\\": \\"Shirt\\", \\"category\\": \\"Clothing\\", \\"price\\": 50} ... ] >>> category = \\"Electronics\\" >>> discount = 10 >>> apply_promotion(products, category, discount) [{'name': 'Laptop', 'category': 'Electronics', 'price': 900.0}, {'name': 'Headphones', 'category': 'Electronics', 'price': 180.0}, {'name': 'Shoes', 'category': 'Clothing', 'price': 100}, {'name': 'Shirt', 'category': 'Clothing', 'price': 50}]","solution":"from typing import List, Dict, Union def apply_promotion(products: List[Dict[str, Union[str, int]]], category: str, discount: int) -> List[Dict[str, Union[str, float]]]: Applies a given discount to all products in the specified category. Parameters: products (list of dict): The list of products. category (str): The category of products to which the promotion should be applied. discount (int): The percentage discount to apply. Returns: list of dict: The updated list of products with discounted prices for the specified category. discounted_products = [] for product in products: if product['category'] == category: new_price = product['price'] * (1 - discount / 100) discounted_products.append({\\"name\\": product[\\"name\\"], \\"category\\": product[\\"category\\"], \\"price\\": round(new_price, 2)}) else: discounted_products.append(product) return discounted_products"},{"question":"def reverse_words(sentence: str) -> str: Reverses each word in a sentence while maintaining the order of the words. >>> reverse_words(\\"hello world\\") 'olleh dlrow' >>> reverse_words(\\"coding is fun\\") 'gnidoc si nuf'","solution":"def reverse_words(sentence): Reverses each word in a sentence while maintaining the order of the words. Parameters: sentence (str): The input sentence consisting of lowercase alphabetical characters and spaces. Returns: str: The new sentence with each word reversed but the word order preserved. words = sentence.split() # Split the sentence into individual words reversed_words = [word[::-1] for word in words] # Reverse each word return ' '.join(reversed_words) # Join the reversed words to form the final sentence"},{"question":"def can_produce_exactly_p_products(P: int) -> str: This function checks if it is possible to produce exactly P products using any non-negative combination of widgets (W) and gadgets (G) where W + G = P. Args: P (int): The total number of products needed for a particular day. Returns: str: \\"YES\\" if possible and \\"NO\\" otherwise. >>> can_produce_exactly_p_products(10) 'YES' >>> can_produce_exactly_p_products(15) 'YES' >>> can_produce_exactly_p_products(7) 'NO' >>> can_produce_exactly_p_products(0) 'YES' >>> can_produce_exactly_p_products(100000) 'YES' def solution(test_cases: List[int]) -> List[str]: This function checks for each test case if it is possible to produce exactly P products using any non-negative combination of widgets (W) and gadgets (G) where W + G = P. Args: test_cases (List[int]): The list of total number of products needed for each day. Returns: List[str]: A list of strings \\"YES\\" or \\"NO\\" for each test case. >>> solution([10, 15, 7]) ['YES', 'YES', 'NO'] >>> solution([0]) ['YES'] >>> solution([100000]) ['YES']","solution":"def can_produce_exactly_p_products(P): This function checks if it is possible to produce exactly P products using any non-negative combination of widgets (W) and gadgets (G) where W + G = P. The function returns \\"YES\\" if possible and \\"NO\\" otherwise. # Since W and G can be any non-negative integers, any non-negative integer P is possible return \\"YES\\" if P >= 0 else \\"NO\\" def solution(test_cases): results = [] for P in test_cases: results.append(can_produce_exactly_p_products(P)) return results"},{"question":"from datetime import datetime def high_spenders(transactions, min_amount, start_date, end_date): Identifies users who have spent more than the given amount within the specified date range. :param transactions: List of dictionaries representing user transactions. :param min_amount: Numeric value representing the minimum amount spent by a user. :param start_date: String representing the start date in 'YYYY-MM-DD' format. :param end_date: String representing the end date in 'YYYY-MM-DD' format. :return: List of user IDs who spent more than min_amount within the given date range. >>> transactions = [ ... {'user_id': 1, 'amount': 50, 'date': '2023-01-15'}, ... {'user_id': 2, 'amount': 75, 'date': '2023-01-18'}, ... {'user_id': 1, 'amount': 100, 'date': '2023-02-01'}, ... ] >>> high_spenders(transactions, 50, '2023-01-01', '2023-02-02') [1, 2] >>> high_spenders(transactions, 60, '2023-01-01', '2023-02-01') [1, 2] >>> high_spenders(transactions, 180, '2023-01-10', '2023-01-14') [] pass","solution":"from datetime import datetime def high_spenders(transactions, min_amount, start_date, end_date): Identifies users who have spent more than the given amount within the specified date range. :param transactions: List of dictionaries representing user transactions. :param min_amount: Numeric value representing the minimum amount spent by a user. :param start_date: String representing the start date in 'YYYY-MM-DD' format. :param end_date: String representing the end date in 'YYYY-MM-DD' format. :return: List of user IDs who spent more than min_amount within the given date range. if not isinstance(transactions, list) or not all(isinstance(t, dict) for t in transactions): raise ValueError(\\"Transactions must be a list of dictionaries.\\") required_keys = {'user_id', 'amount', 'date'} for t in transactions: if not required_keys.issubset(t.keys()): raise ValueError(\\"Each transaction must have 'user_id', 'amount', and 'date' keys.\\") start_date_obj = datetime.strptime(start_date, '%Y-%m-%d') end_date_obj = datetime.strptime(end_date, '%Y-%m-%d') user_spending = {} for transaction in transactions: user_id, amount, date = transaction['user_id'], transaction['amount'], transaction['date'] date_obj = datetime.strptime(date, '%Y-%m-%d') if start_date_obj <= date_obj <= end_date_obj: if user_id not in user_spending: user_spending[user_id] = 0 user_spending[user_id] += amount high_spenders = [user_id for user_id, total_amount in user_spending.items() if total_amount >= min_amount] return high_spenders"},{"question":"def product_except_self(nums): This function returns a new list where each element is the product of all the elements in the original list except for the element at the current position. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([0, 2, 3, 4]) [24, 0, 0, 0] >>> product_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([0, 0, 3, 4]) [0, 0, 0, 0] >>> product_except_self([10]) [1] >>> product_except_self([5, 9]) [9, 5]","solution":"def product_except_self(nums): Returns a list such that each element is the product of all the elements of nums except for the element at that position. length = len(nums) # Initialize the answer array res = [1] * length # Calculate products of elements to the left of each element prefix = 1 for i in range(length): res[i] = prefix prefix *= nums[i] # Calculate products of elements to the right of each element postfix = 1 for i in range(length - 1, -1, -1): res[i] *= postfix postfix *= nums[i] return res"},{"question":"def reverse_and_join(S: str, c: str) -> str: Splits the string S into words using the space character as a separator, reverses the order of words, and joins them back into a single string using the character c as the separator. Args: S (str): Input string. c (str): Separator character. Returns: str: The resulting string after reversing and joining. >>> reverse_and_join(\\"hello world how are you\\", \\"-\\") 'you-are-how-world-hello' >>> reverse_and_join(\\"python is awesome\\", \\",\\") 'awesome,is,python' >>> reverse_and_join(\\"hello\\", \\"-\\") 'hello' >>> reverse_and_join(\\"hello world\\", \\" \\") 'world hello' >>> reverse_and_join(\\"\\", \\"-\\") '' >>> reverse_and_join(\\"one two three\\", \\"|\\") 'three|two|one'","solution":"def reverse_and_join(S, c): Splits the string S into words using the space character as a separator, reverses the order of words, and joins them back into a single string using the character c as the separator. Args: S (str): Input string. c (str): Separator character. Returns: str: The resulting string after reversing and joining. words = S.split(\\" \\") words.reverse() return c.join(words)"},{"question":"def findLongestPalindrome(s: str) -> str: Returns the longest palindromic substring in s. >>> findLongestPalindrome(\\"a\\") \\"a\\" >>> findLongestPalindrome(\\"bb\\") \\"bb\\" >>> findLongestPalindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> findLongestPalindrome(\\"cbbd\\") \\"bb\\" >>> findLongestPalindrome(\\"abcde\\") \\"a\\" >>> findLongestPalindrome(\\"racecar\\") \\"racecar\\" >>> findLongestPalindrome(\\"\\") \\"\\" >>> findLongestPalindrome(\\"aabcdcb\\") \\"bcdcb\\"","solution":"def findLongestPalindrome(s): Returns the longest palindromic substring in s. if len(s) < 2: return s def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest_pal = '' for i in range(len(s)): # Odd length palindromes odd_pal = expand_around_center(i, i) if len(odd_pal) > len(longest_pal): longest_pal = odd_pal # Even length palindromes even_pal = expand_around_center(i, i + 1) if len(even_pal) > len(longest_pal): longest_pal = even_pal return longest_pal"},{"question":"def is_permutation_palindrome(s: str) -> bool: Determines if any permutation of the string can form a palindrome. A string can form a palindrome if at most one character has an odd count. Args: s (str): The input string Returns: bool: True if a permutation of the string can form a palindrome, False otherwise >>> is_permutation_palindrome(\\"civic\\") == True >>> is_permutation_palindrome(\\"ivicc\\") == True >>> is_permutation_palindrome(\\"hello\\") == False >>> is_permutation_palindrome(\\"aabb\\") == True >>> is_permutation_palindrome(\\"a\\") == True >>> is_permutation_palindrome(\\"aa\\") == True >>> is_permutation_palindrome(\\"abcabc\\") == True >>> is_permutation_palindrome(\\"abcdefg\\") == False >>> is_permutation_palindrome(\\"aabbccddeeffgg\\") == True >>> is_permutation_palindrome(\\"\\") == True # Edge case: empty string >>> is_permutation_palindrome(\\"aabbccddeeffg\\") == True >>> is_permutation_palindrome(\\"aabbccddeeffggz\\") == True","solution":"def is_permutation_palindrome(s): Determines if any permutation of the string can form a palindrome. A string can form a palindrome if at most one character has an odd count. Args: s (str): The input string Returns: bool: True if a permutation of the string can form a palindrome, False otherwise from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Check how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"def is_contiguous(arr: List[int]) -> bool: Determines if the given integer array represents a contiguous subarray containing all integers from 1 to n. Parameters: arr (list): List of integers. Returns: bool: True if the array is contiguous, False otherwise. >>> is_contiguous([4, 2, 1, 3]) True >>> is_contiguous([1, 3, 2, 4, 6]) False >>> is_contiguous([7, 5, 6, 8]) True from solution import is_contiguous def test_is_contiguous_true_case(): assert is_contiguous([4, 2, 1, 3]) == True def test_is_contiguous_false_case(): assert is_contiguous([1, 3, 2, 4, 6]) == False def test_is_contiguous_true_case_with_gap(): assert is_contiguous([7, 5, 6, 8]) == True def test_is_contiguous_single_element(): assert is_contiguous([1]) == True def test_is_contiguous_repeating_elements(): assert is_contiguous([1, 1, 2]) == False def test_is_contiguous_no_elements(): assert is_contiguous([]) == False def test_is_contiguous_large_range(): arr = list(range(10000, 20000)) assert is_contiguous(arr) == True def test_is_contiguous_negative_case(): assert is_contiguous([1, 2, 4, 5]) == False","solution":"def is_contiguous(arr): Determines if the given integer array represents a contiguous subarray containing all integers from 1 to n. Parameters: arr (list): List of integers. Returns: bool: True if the array is contiguous, False otherwise. if not arr: return False min_value = min(arr) max_value = max(arr) if max_value - min_value + 1 != len(arr): return False elements_set = set(arr) return len(elements_set) == len(arr)"},{"question":"def is_prime(n: int) -> bool: Check if a number n is a prime number. pass def count_prime_partitions(s: str) -> int: Return the number of ways to partition the string s into non-empty substrings such that each substring represents a prime number. >>> count_prime_partitions(\\"11373\\") 6 >>> count_prime_partitions(\\"3175\\") 3 pass # Example unit tests def test_example1(): assert count_prime_partitions(\\"11373\\") == 6 def test_example2(): assert count_prime_partitions(\\"3175\\") == 3 def test_single_digit_prime(): assert count_prime_partitions(\\"7\\") == 1 def test_single_digit_non_prime(): assert count_prime_partitions(\\"4\\") == 0 def test_multiple_zeros(): assert count_prime_partitions(\\"30307\\") == 1 def test_large_number(): assert count_prime_partitions(\\"2357\\") == 3","solution":"def is_prime(n): Check if a number n is a prime number. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True def count_prime_partitions(s): Return the number of ways to partition the string s into non-empty substrings such that each substring represents a prime number. length = len(s) dp = [0] * (length + 1) dp[0] = 1 # There's one way to partition an empty string. for i in range(1, length + 1): for j in range(i): if s[j] != '0' and is_prime(int(s[j:i])): dp[i] += dp[j] return dp[-1]"},{"question":"def max_obstacle_height(test_cases): Determines the maximum height of obstacles within specified segments of a marathon route. Args: test_cases: List[Dict] - A list of dictionaries where each dictionary represents a test case. Each dictionary contains: - N: int, the number of obstacles - Q: int, the number of queries - heights: List[int], the heights of the obstacles - queries: List[Tuple[int, int]], the queries consisting of start and end indices (1-based) Returns: List[int] - A list of maximum heights for each query across all test cases. Example: test_cases = [ { 'N': 5, 'Q': 2, 'heights': [1, 3, 2, 6, 4], 'queries': [ (1, 3), (2, 5) ] } ] max_obstacle_height(test_cases) -> [3, 6]","solution":"def max_obstacle_height(test_cases): results = [] for case in test_cases: N, Q = case['N'], case['Q'] heights = case['heights'] queries = case['queries'] for L, R in queries: # Subtract 1 from L and R to convert 1-based index to 0-based indexing used in Python lists segment = heights[L-1:R] results.append(max(segment)) return results"},{"question":"def quality_count(batch: str) -> dict: Chuck is planning a chocolate factory automation system. One part of the system needs to check the quality of chocolates coming off the production line. Given a string that represents a batch of chocolates, where each character denotes the quality of a chocolate (for example, 'A' for acceptable, 'B' for bad, 'C' for contaminated), return a dictionary with the count of each quality type in the batch. If a particular quality type is not present in the batch, it should be omitted from the dictionary. >>> quality_count(\\"AABCCBAA\\") {'A': 4, 'B': 2, 'C': 2} >>> quality_count(\\"BBBB\\") {'B': 4} >>> quality_count(\\"\\") {}","solution":"def quality_count(batch: str) -> dict: from collections import Counter return dict(Counter(batch))"},{"question":"from typing import List def update_board(board: List[List[str]], click: List[int]) -> List[List[str]]: Updates the Minesweeper board in-place according to the rules given. Parameters: board (List[List[str]]): The initial Minesweeper board. click (List[int]): The position to click on the board. Returns: List[List[str]]: The updated board. Examples: >>> update_board([ ['E', 'E', 'E', 'E', 'E'], ['E', 'E', 'M', 'E', 'E'], ['E', 'E', 'E', 'E', 'E'], ['E', 'E', 'E', 'E', 'E'] ], [3, 0]) [ ['B', '1', 'E', '1', 'B'], ['B', '1', 'M', '1', 'B'], ['B', '1', '1', '1', 'B'], ['B', 'B', 'B', 'B', 'B'] ] >>> update_board([ ['B', '1', 'E', '1', 'B'], ['B', '1', 'M', '1', 'B'], ['B', '1', '1', '1', 'B'], ['B', 'B', 'B', 'B', 'B'] ], [1, 2]) [ ['B', '1', 'E', '1', 'B'], ['B', '1', 'X', '1', 'B'], ['B', '1', '1', '1', 'B'], ['B', 'B', 'B', 'B', 'B'] ]","solution":"def update_board(board, click): Updates the Minesweeper board in-place according to the rules given. Parameters: board (List[List[str]]): The initial Minesweeper board. click (List[int]): The position to click on the board. Returns: List[List[str]]: The updated board. def count_mines_around(r, c): mines_count = 0 for dr in range(-1, 2): for dc in range(-1, 2): if dr == 0 and dc == 0: continue nr, nc = r + dr, c + dc if 0 <= nr < len(board) and 0 <= nc < len(board[0]) and board[nr][nc] == 'M': mines_count += 1 return mines_count def dfs(r, c): if board[r][c] != 'E': return mines_count = count_mines_around(r, c) if mines_count > 0: board[r][c] = str(mines_count) else: board[r][c] = 'B' for dr in range(-1, 2): for dc in range(-1, 2): if dr == 0 and dc == 0: continue nr, nc = r + dr, c + dc if 0 <= nr < len(board) and 0 <= nc < len(board[0]): dfs(nr, nc) click_r, click_c = click if board[click_r][click_c] == 'M': board[click_r][click_c] = 'X' else: dfs(click_r, click_c) return board"},{"question":"def can_form_palindrome(string: str) -> str: Returns 'YES' if the string can be converted to a palindrome by removing at most one character, otherwise 'NO'. >>> can_form_palindrome(\\"abca\\") 'YES' >>> can_form_palindrome(\\"racecar\\") 'YES' >>> can_form_palindrome(\\"abc\\") 'NO' def process_test_cases(test_cases: List[str]) -> List[str]: Process multiple test cases to determine if each string can be converted to a palindrome by removing at most one character. >>> process_test_cases([\\"abca\\", \\"racecar\\", \\"abc\\"]) ['YES', 'YES', 'NO'] >>> process_test_cases([\\"a\\"]) ['YES'] >>> process_test_cases([\\"ab\\"]) ['YES'] >>> process_test_cases([\\"abccba\\", \\"abcddcba\\"]) ['YES', 'YES'] >>> process_test_cases([\\"abcd\\"]) ['NO'] >>> process_test_cases([\\"a\\" * (10**5)]) ['YES'] >>> process_test_cases([\\"a\\" * (10**5-1) + \\"b\\"]) ['YES'] >>> process_test_cases([\\"a\\" * (10**4) + \\"b\\" + \\"a\\" * (10**4)]) ['YES']","solution":"def can_form_palindrome(string): Returns YES if the string can be converted to a palindrome by removing at most one character, otherwise NO. def is_palindrome_range(s, i, j): return all(s[k] == s[j-k+i] for k in range(i, j)) def can_be_palindrome(s): l, h = 0, len(s) - 1 while l < h: if s[l] != s[h]: return is_palindrome_range(s, l+1, h) or is_palindrome_range(s, l, h-1) l += 1 h -= 1 return True return can_be_palindrome(string) def process_test_cases(test_cases): results = [] for test_case in test_cases: results.append(\\"YES\\" if can_form_palindrome(test_case) else \\"NO\\") return results"},{"question":"def restore_ip_addresses(s: str) -> List[str]: Given a string containing digits from 0 to 9, return all possible valid IP addresses that can be obtained by inserting dots into the string. A valid IP address consists of four integers (each ranging from 0 to 255) separated by periods. Each integer is written without leading zeros, except for the number 0 itself which is always valid. You may not insert more than three periods into the string. >>> restore_ip_addresses(\\"25525511135\\") [\\"255.255.11.135\\", \\"255.255.111.35\\"] >>> restore_ip_addresses(\\"0000\\") [\\"0.0.0.0\\"] >>> restore_ip_addresses(\\"101023\\") [\\"1.0.10.23\\", \\"1.0.102.3\\", \\"10.1.0.23\\", \\"10.10.2.3\\", \\"101.0.2.3\\"] >>> restore_ip_addresses(\\"1111\\") [\\"1.1.1.1\\"] >>> restore_ip_addresses(\\"000\\") [] >>> restore_ip_addresses(\\"\\") [] >>> restore_ip_addresses(\\"1\\") [] >>> restore_ip_addresses(\\"010010\\") [\\"0.10.0.10\\", \\"0.100.1.0\\"]","solution":"def is_valid_segment(segment): Check if the given segment is a valid segment of an IP address. return 0 <= int(segment) <= 255 and str(int(segment)) == segment def restore_ip_addresses(s): Returns all possible valid IP addresses from the given string. def backtrack(start, path): if len(path) == 4 and start == len(s): result.append('.'.join(path)) return if len(path) == 4 or start == len(s): return for length in range(1, 4): if start + length <= len(s): segment = s[start:start + length] if is_valid_segment(segment): path.append(segment) backtrack(start + length, path) path.pop() result = [] backtrack(0, []) return result"},{"question":"def sort_by_vowels(words: List[str], target: str) -> List[str]: Sorts a list of strings by the number of vowels they contain in descending order. If two words have the same number of vowels, sorts them lexicographically in ascending order. >>> sort_by_vowels([\\"apple\\", \\"banana\\", \\"pear\\", \\"grape\\"], \\"target\\") [\\"banana\\", \\"apple\\", \\"grape\\", \\"pear\\"] >>> sort_by_vowels([\\"ape\\", \\"eel\\", \\"giraffe\\", \\"dog\\", \\"bat\\"], \\"target\\") [\\"giraffe\\", \\"ape\\", \\"eel\\", \\"bat\\", \\"dog\\"] >>> sort_by_vowels([], \\"target\\") [] >>> sort_by_vowels([\\"zebra\\"], \\"target\\") [\\"zebra\\"] >>> sort_by_vowels([\\"a\\", \\"e\\", \\"i\\", \\"o\\", \\"u\\"], \\"target\\") [\\"a\\", \\"e\\", \\"i\\", \\"o\\", \\"u\\"] >>> sort_by_vowels([\\"b\\", \\"c\\", \\"d\\"], \\"target\\") [\\"b\\", \\"c\\", \\"d\\"]","solution":"def sort_by_vowels(words, target): Sorts a list of strings by the number of vowels they contain in descending order. If two words have the same number of vowels, sorts them lexicographically in ascending order. def vowel_count(word): vowels = set('aeiou') return sum(1 for char in word if char in vowels) # Sort by two keys: # 1. Number of vowels in descending order (hence negative sign) # 2. Lexicographical order of the word itself return sorted(words, key=lambda word: (-vowel_count(word), word))"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate an arithmetic expression containing +, -, *, and / operators without parentheses. Args: expression (str): The arithmetic expression to evaluate. Returns: int: The result of the arithmetic evaluation. Example: >>> evaluate_expression(\\"3 + 2 * 2\\") 7 >>> evaluate_expression(\\"3/2\\") 1 >>> evaluate_expression(\\"3+5 / 2\\") 5 from solution import evaluate_expression def test_simple_addition(): assert evaluate_expression(\\"3+2\\") == 5 def test_simple_subtraction(): assert evaluate_expression(\\"3-2\\") == 1 def test_simple_multiplication(): assert evaluate_expression(\\"3*2\\") == 6 def test_simple_division(): assert evaluate_expression(\\"3/2\\") == 1 def test_combined_operations(): assert evaluate_expression(\\"3+2*2\\") == 7 assert evaluate_expression(\\"3-2/2\\") == 2 assert evaluate_expression(\\"3+5/2\\") == 5 assert evaluate_expression(\\"3*2+2\\") == 8 def test_whitespace_handling(): assert evaluate_expression(\\" 3 + 2 * 2 \\") == 7 assert evaluate_expression(\\" 3 / 2 \\") == 1 assert evaluate_expression(\\" 3 + 5 / 2 \\") == 5 def test_large_numbers(): assert evaluate_expression(\\"1000*1000\\") == 1000000 assert evaluate_expression(\\"100000/1000\\") == 100 assert evaluate_expression(\\"100000+100000\\") == 200000 def test_mixed_operations(): assert evaluate_expression(\\"2+3*4-5/2\\") == 11 assert evaluate_expression(\\"3*6/2-4+10\\") == 15 assert evaluate_expression(\\"10*10+10/10\\") == 101","solution":"def evaluate_expression(expression): Evaluate an arithmetic expression containing +, -, *, and / operators without parentheses. Args: expression (str): The arithmetic expression to evaluate. Returns: int: The result of the arithmetic evaluation. def operate(a, b, op): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': return a // b # integer division stack = [] current_number = 0 operation = '+' for i in range(len(expression)): char = expression[i] if char.isdigit(): current_number = current_number * 10 + int(char) if char in '+-*/' or i == len(expression) - 1: if operation == '+': stack.append(current_number) elif operation == '-': stack.append(-current_number) elif operation == '*': stack[-1] = stack[-1] * current_number elif operation == '/': stack[-1] = stack[-1] // current_number operation = char current_number = 0 return sum(stack)"},{"question":"def partition_list(nums: List[int]) -> Tuple[List[int], List[int]]: Partitions the list of unique integers into two subsets such that the difference between their sums is minimized. Returns a tuple of two lists representing these two subsets. >>> partition_list([1, 6, 11, 5]) ([1, 6, 5], [11]) >>> partition_list([3, 1, 4, 2, 2]) ([3, 2], [1, 4, 2]) >>> partition_list([10]) ([10], []) >>> partition_list([-10, 10, -20, 20]) ([-10, 10], [-20, 20]) >>> partition_list([-1, -2, -3, 1, 2, 3]) ([-1, -2, -3], [1, 2, 3])","solution":"from itertools import combinations def partition_list(nums): Partitions the list of unique integers into two subsets such that the difference between their sums is minimized. total_sum = sum(nums) n = len(nums) all_combinations = (combinations(nums, i) for i in range(n // 2 + 1)) min_diff = float('inf') best_subset = [] for comb_gen in all_combinations: for comb in comb_gen: subset_sum = sum(comb) other_subset_sum = total_sum - subset_sum diff = abs(subset_sum - other_subset_sum) if diff < min_diff: min_diff = diff best_subset = comb subset1 = list(best_subset) subset2 = nums.copy() for num in subset1: subset2.remove(num) return (subset1, subset2)"},{"question":"from typing import List, Tuple def max_difference_in_list(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of integers, find the maximum difference between any two elements in the list. >>> parse_input(\\"2n5n1 2 3 4 5n4n7 2 -3 5\\") [(5, [1, 2, 3, 4, 5]), (4, [7, 2, -3, 5])] >>> max_difference_in_list([(5, [1, 2, 3, 4, 5]), (4, [7, 2, -3, 5])]) [4, 10] >>> parse_input(\\"1n3n1 100 -100\\") [(3, [1, 100, -100])] >>> max_difference_in_list([(3, [1, 100, -100])]) [200]","solution":"def max_difference_in_list(test_cases): results = [] for case in test_cases: N, elements = case max_elem = max(elements) min_elem = min(elements) max_diff = abs(max_elem - min_elem) results.append(max_diff) return results def parse_input(input_data): input_lines = input_data.strip().split(\\"n\\") T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) elements = list(map(int, input_lines[index + 1].split())) test_cases.append((N, elements)) index += 2 return test_cases"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given an integer array \`nums\`, return an array \`answer\` such that \`answer[i]\` is equal to the product of all the elements of \`nums\` except \`nums[i]\`. The product of any prefix or suffix of \`nums\` is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and uses only constant extra space (excluding the output array). >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([1, 2, 0, 4]) == [0, 0, 8, 0] >>> product_except_self([1, 0, 3, 0]) == [0, 0, 0, 0] >>> product_except_self([1, 2, 3, 0]) == [0, 0, 0, 6] >>> product_except_self([-1, -2, -3, -4]) == [-24, -12, -8, -6] >>> product_except_self([-1, 2, -3, 4]) == [-24, 12, -8, 6] >>> product_except_self([1, 2]) == [2, 1] >>> product_except_self([0, 4]) == [4, 0] >>> product_except_self([5, -1]) == [-1, 5] pass","solution":"def product_except_self(nums): Given an array nums, returns an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. n = len(nums) output = [1] * n left_product = 1 for i in range(n): output[i] = left_product left_product *= nums[i] right_product = 1 for i in range(n-1, -1, -1): output[i] *= right_product right_product *= nums[i] return output"},{"question":"def sum_min_max(numbers: list) -> int: Finds the smallest and largest numbers in a list and returns their sum. >>> sum_min_max([3, 5, 1, 9, 7]) 10 >>> sum_min_max([5]) 10 >>> sum_min_max([-1, -5, -3, -9, -2]) -10 >>> sum_min_max([-3, 0, 2, 5, -7]) -2 >>> sum_min_max([10, 20, 30, 40, 50]) 60 >>> sum_min_max([]) 0","solution":"def sum_min_max(numbers): Finds the smallest and largest numbers in a list and returns their sum. :param numbers: list of numbers :return: sum of the smallest and largest numbers if not numbers: return 0 # Assuming we return 0 if the list is empty. min_num = min(numbers) max_num = max(numbers) return min_num + max_num"},{"question":"def single_number(nums): Finds the element that appears only once in the array. Args: nums: List[int] Returns: int The single element that appears only once. Examples: >>> single_number([2, 2, 1]) 1 >>> single_number([4, 1, 2, 1, 2]) 4","solution":"def single_number(nums): Finds the element that appears only once in the array. Args: nums: List[int] List of integers where every element appears twice except for one. Returns: int The single element that appears only once. result = 0 for num in nums: result ^= num return result"},{"question":"def evaluateExpression(expression: str) -> float: Parse and evaluate a mathematical expression. >>> evaluateExpression(\\"3 + 5\\") 8.0 >>> evaluateExpression(\\"10 + 2 * 6\\") 22.0 >>> evaluateExpression(\\"100 * 2 + 12\\") 212.0 >>> evaluateExpression(\\"100 * ( 2 + 12 )\\") 1400.0 >>> evaluateExpression(\\"100 * ( 2 + 12 ) / 14\\") 100.0 >>> evaluateExpression(\\"50 / 2 - 5\\") 20.0 >>> evaluateExpression(\\"(1 + 2) * (3 + 4) - 5 / (6 + 1)\\") 20.285714285714285","solution":"def evaluateExpression(expression: str) -> float: import re return eval(re.sub(r's+', '', expression)) # Using eval for simplicity"},{"question":"from typing import List, Tuple def lexicographically_smallest_string(T: int, test_cases: List[Tuple[int, str]]) -> List[str]: Returns the lexicographically smallest string possible for each test case. Parameters: T (int): Number of test cases test_cases (list of tuples): List containing tuples, each with an integer \`n\` and a string \`s\` Returns: list of str: List of lexicographically smallest strings for each test case pass def process_input(T: int, inputs: List[str]) -> List[Tuple[int, str]]: Processes the input from the format provided to a list of test cases. Parameters: T (int): Number of test cases inputs (list of str): List of strings, alternating between the length of the string \`n\` and the string \`s\` Returns: list of tuples: Each tuple contains an integer \`n\` and a string \`s\` pass # Unit Tests def test_lexicographically_smallest_string(): T = 3 inputs = [ (3, 'cba'), (5, 'edcba'), (4, 'bcda') ] expected_outputs = [ 'abc', 'abcde', 'abcd' ] assert lexicographically_smallest_string(T, inputs) == expected_outputs def test_process_input(): T = 3 inputs = [ '3', 'cba', '5', 'edcba', '4', 'bcda' ] expected_output = [ (3, 'cba'), (5, 'edcba'), (4, 'bcda') ] assert process_input(T, inputs) == expected_output def test_combined_function(): # This test combines input processing and result computation T = 3 raw_inputs = ['3', 'cba', '5', 'edcba', '4', 'bcda'] processed_inputs = process_input(T, raw_inputs) expected_outputs = ['abc', 'abcde', 'abcd'] assert lexicographically_smallest_string(T, processed_inputs) == expected_outputs def test_edge_cases(): T = 1 inputs = [(1, 'a')] expected_outputs = ['a'] assert lexicographically_smallest_string(T, inputs) == expected_outputs T = 1 inputs = [(2, 'ba')] expected_outputs = ['ab'] assert lexicographically_smallest_string(T, inputs) == expected_outputs T = 1 inputs = [(100, 'z' * 100)] expected_outputs = ['z' * 100] assert lexicographically_smallest_string(T, inputs) == expected_outputs","solution":"def lexicographically_smallest_string(T, test_cases): Returns the lexicographically smallest string possible for each test case. Parameters: T (int): Number of test cases test_cases (list of tuples): List containing tuples, each with an integer \`n\` and a string \`s\` Returns: list of str: List of lexicographically smallest strings for each test case result = [] for n, s in test_cases: result.append(''.join(sorted(s))) return result def process_input(T, inputs): test_cases = [] for i in range(T): n = int(inputs[2*i]) s = inputs[2*i + 1] test_cases.append((n, s)) return test_cases"},{"question":"def filter_primes(numbers: List[int]) -> List[int]: Write a Python function that takes a list of integers and returns a new list containing only the prime numbers from the original list. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Implement the function using list comprehension. >>> filter_primes([2, 3, 5, 7, 11, 13, 17]) [2, 3, 5, 7, 11, 13, 17] >>> filter_primes([2, 4, 5, 6, 7, 8, 10, 11]) [2, 5, 7, 11] >>> filter_primes([4, 6, 8, 9, 10, 12, 14]) [] >>> filter_primes([-10, -3, 0, 1]) [] >>> filter_primes([]) [] >>> filter_primes([3]) [3] >>> filter_primes([4]) []","solution":"def is_prime(n): Check if a number is a prime number. if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def filter_primes(numbers): Returns a list of prime numbers from the given list of integers. return [num for num in numbers if is_prime(num)]"},{"question":"def max_char_count(t: int, test_cases: List[Tuple[int, str]]) -> List[Tuple[str, int]]: Find the character which appears the maximum number of times in each string S for T test cases and its corresponding count. If there is a tie, return the character which is lexicographically smallest. >>> max_char_count(2, [(7, \\"abacaba\\"), (4, \\"bcbb\\")]) [('a', 4), ('b', 3)] >>> max_char_count(1, [(1, \\"a\\")]) [('a', 1)] >>> max_char_count(1, [(5, \\"ccccc\\")]) [('c', 5)] >>> max_char_count(1, [(6, \\"aabbcc\\")]) [('a', 2)] >>> max_char_count(3, [(7, \\"abacaba\\"), (4, \\"bcbb\\"), (5, \\"aaaaa\\")]) [('a', 4), ('b', 3), ('a', 5)]","solution":"def max_char_count(t, test_cases): results = [] for case in test_cases: n, s = case char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 max_count = max(char_count.values()) max_char = min([char for char in char_count if char_count[char] == max_count]) results.append((max_char, max_count)) return results"},{"question":"def is_path_possible(grid, N, M): Determines if there is a path from top-left to bottom-right in a given grid. >>> is_path_possible([\\"...\\", \\".*.\\", \\"...\\"], 3, 3) \\"YES\\" >>> is_path_possible([\\".*\\", \\"*.\\"], 2, 2) \\"NO\\" def solve(num_cases, cases): Determines the results for multiple test cases. >>> solve(4, [((3, 3), [\\"...\\", \\".*.\\", \\"...\\"]), ((2, 2), [\\".*\\", \\"*.\\",]), ((3, 3), [\\"..*\\", \\".*.\\", \\"*..\\"]), ((3, 3), [\\"...\\", \\"...\\", \\"...\\"])]) == [\\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\"]","solution":"def is_path_possible(grid, N, M): Determines if there is a path from top-left to bottom-right in a given grid. if grid[0][0] == '*' or grid[N-1][M-1] == '*': return \\"NO\\" from collections import deque directions = [(0, 1), (1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (N-1, M-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\" def solve(num_cases, cases): results = [] for i in range(num_cases): N, M = cases[i][0] grid = cases[i][1] results.append(is_path_possible(grid, N, M)) return results"},{"question":"def is_symmetric(grid: List[List[int]]) -> bool: Determines if a square grid is symmetric about its center. Parameters: grid (list of list of int): 2D list of integers representing the grid. Returns: bool: True if the grid is symmetric, False otherwise. Examples: >>> is_symmetric([ ... [2, 1, 1, 2], ... [1, 3, 3, 1], ... [1, 3, 3, 1], ... [2, 1, 1, 2] ... ]) True >>> is_symmetric([ ... [1, 2, 3], ... [4, 5, 4], ... [3, 2, 1] ... ]) False","solution":"def is_symmetric(grid): Determines if a square grid is symmetric about its center. Parameters: grid (list of list of int): 2D list of integers representing the grid. Returns: bool: True if the grid is symmetric, False otherwise. n = len(grid) for i in range(n): for j in range(n//2): if grid[i][j] != grid[i][n-j-1]: return False for i in range(n//2): if grid[i] != grid[n-i-1]: return False return True"},{"question":"def sum_of_squares(n: int) -> int: Returns the sum of the squares of integers from 1 to n. >>> sum_of_squares(1) 1 >>> sum_of_squares(2) 5 >>> sum_of_squares(3) 14 >>> sum_of_squares(10) 385","solution":"def sum_of_squares(n): Returns the sum of the squares of integers from 1 to n. return sum(i * i for i in range(1, n + 1))"},{"question":"from typing import List def intersect(nums1: List[int], nums2: List[int]) -> List[int]: Returns the intersection of two arrays including duplicate elements. >>> intersect([1,2,2,1], [2,2]) [2, 2] >>> intersect([4,9,5], [9,4,9,8,4]) [4, 9] def test_intersect_example1(): assert intersect([1,2,2,1], [2,2]) == [2,2] def test_intersect_example2(): result = intersect([4,9,5], [9,4,9,8,4]) assert sorted(result) == sorted([4, 9]) def test_intersect_no_intersection(): assert intersect([1, 2, 3], [4, 5, 6]) == [] def test_intersect_partial_intersection(): result = intersect([1, 2, 2, 1], [2, 2, 3]) assert sorted(result) == sorted([2, 2]) def test_intersect_identical_arrays(): result = intersect([1, 2, 3], [1, 2, 3]) assert sorted(result) == sorted([1, 2, 3]) def test_intersect_empty_intersection(): assert intersect([], [1, 2, 3]) == [] assert intersect([1, 2, 3], []) == []","solution":"def intersect(nums1, nums2): Returns the intersection of two arrays including duplicate elements. from collections import Counter # Use Counter to count frequencies of elements in both arrays counter1 = Counter(nums1) counter2 = Counter(nums2) # Find the intersection of the two counters intersection = [] for num in counter1: if num in counter2: intersection.extend([num] * min(counter1[num], counter2[num])) return intersection"},{"question":"def maxProfit(prices: List[int]) -> int: Given an array of integers representing the stock prices of a company in chronological order, determine the maximum profit you can achieve by buying and selling the stock such that you buy before you sell. You can complete at most one transaction (buy one and sell one share of the stock). >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0","solution":"def maxProfit(prices): Returns the maximum profit from a single buy-sell transaction if not prices: return 0 max_profit = 0 min_price = prices[0] for price in prices[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"from typing import List def count_special_subsequences(n: int, k: int, sequence: List[int]) -> int: Returns the number of special subsequences of length k in the given sequence of length n. Args: n (int): The number of elements in the sequence k (int): The length of the special subsequence to be found sequence (List[int]): The sequence of integers Returns: int: The number of special subsequences >>> count_special_subsequences(5, 3, [1, 2, 3, 4, 5]) 10 >>> count_special_subsequences(1, 1, [42]) 1 >>> count_special_subsequences(4, 4, [10, 20, 30, 40]) 1 >>> count_special_subsequences(5, 4, [1, 2, 3, 4, 5]) 5 >>> count_special_subsequences(6, 2, [9, 8, 7, 6, 5, 4]) 15 >>> count_special_subsequences(50, 2, list(range(1, 51))) 1225","solution":"from itertools import combinations def count_special_subsequences(n, k, sequence): Returns the number of special subsequences of length k in the given sequence of length n. return sum(1 for subseq in combinations(sequence, k)) # Example usage: # n, k = 5, 3 # sequence = [1, 2, 3, 4, 5] # print(count_special_subsequences(n, k, sequence)) # Output: 10"},{"question":"from typing import List def is_possible_to_form_palindrome(s: str) -> bool: Determine if it's possible to rearrange the string into a palindrome. >>> is_possible_to_form_palindrome(\\"aabb\\") True >>> is_possible_to_form_palindrome(\\"ab\\") False >>> is_possible_to_form_palindrome(\\"racecar\\") True def min_operations_to_form_palindrome(s: str) -> int: Determine the minimum number of operations required to rearrange the string into a palindrome. >>> min_operations_to_form_palindrome(\\"aabb\\") 0 >>> min_operations_to_form_palindrome(\\"ab\\") -1 >>> min_operations_to_form_palindrome(\\"racecar\\") 0 def min_operations_for_test_cases(test_cases: List[str]) -> List[int]: Determine the minimum number of operations required for each test case to rearrange the string into a palindrome. >>> min_operations_for_test_cases([\\"aabb\\", \\"ab\\", \\"racecar\\"]) [0, -1, 0] >>> min_operations_for_test_cases([\\"aa\\", \\"ab\\", \\"abcba\\"]) [0, -1, 0]","solution":"def is_possible_to_form_palindrome(s): # Count the frequency of each character freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 # Check the number of characters with odd frequency odd_count = 0 for count in freq.values(): if count % 2 != 0: odd_count += 1 # For a string to be rearranged into a palindrome, at most one character can have an odd frequency if odd_count > 1: return False return True def min_operations_to_form_palindrome(s): if not is_possible_to_form_palindrome(s): return -1 # If the string can be rearranged to form a palindrome, 0 operations are needed in our context (moving one char at a time) return 0 def min_operations_for_test_cases(test_cases): results = [] for s in test_cases: results.append(min_operations_to_form_palindrome(s)) return results"},{"question":"def alternate_strings(s1: str, s2: str) -> str: Combine two strings by alternating their characters. If one string is longer, append the remainder of the longer string to the result. Examples: >>> alternate_strings(\\"abc\\", \\"def\\") 'adbecf' >>> alternate_strings(\\"hello\\", \\"world\\") 'hweolrllod' >>> alternate_strings(\\"short\\", \\"longer\\") 'slhoonrgter'","solution":"def alternate_strings(s1, s2): Combine two strings by alternating their characters. If one string is longer, append the remainder of the longer string to the result. combined = [] len1, len2 = len(s1), len(s2) # Interleave characters from both strings for i in range(min(len1, len2)): combined.append(s1[i]) combined.append(s2[i]) # Append remaining characters from the longer string, if any if len1 > len2: combined.extend(s1[len2:]) elif len2 > len1: combined.extend(s2[len1:]) return ''.join(combined)"},{"question":"def can_partition(nums: List[int]) -> bool: Determines if the array can be partitioned into two subsets such that the sum of weights in both subsets is equal. :param nums: List[int] :return: bool >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False","solution":"def can_partition(nums): Determines if the array can be partitioned into two subsets such that the sum of weights in both subsets is equal. :param nums: List[int] :return: bool total_sum = sum(nums) # If the total sum is odd, it cannot be divided into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # DP array to store results of subproblems dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"from typing import List, Tuple def is_valid_fixture(n: int, m: int, matches: List[List[Tuple[int, int]]]) -> bool: Determines if the given fixture list is valid based on the specified constraints. n: int, number of teams m: int, number of days matches: list, list of matches for each day, format: [(k1, [(a1, b1), (a2, b2), ...]), (k2, [(a3, b3), ...]), ...] Returns a boolean indicating if the fixture list is valid. def check_fixtures(T: int, fixtures: List[Tuple[Tuple[int, int], List[List[Tuple[int, int]]]]]) -> List[str]: Checks the validity of multiple fixture lists. T: int, number of fixtures to verify fixtures: list of tuple containing the number of teams, number of days and a list of lists with matches per day Returns a list of results, \\"Valid\\" if each fixture list meets the constraints, or \\"Invalid\\" otherwise. def test_is_valid_fixture_valid_case(): n = 4 m = 2 matches = [ [(1, 2), (3, 4)], [(1, 3), (2, 4)] ] assert is_valid_fixture(n, m, matches) == True def test_is_valid_fixture_invalid_case_same_day(): n = 4 m = 2 matches = [ [(1, 2), (1, 3)], [(2, 4)] ] assert is_valid_fixture(n, m, matches) == False def test_is_valid_fixture_invalid_case_repeat_opponent(): n = 4 m = 2 matches = [ [(1, 2), (3, 4)], [(1, 2), (3, 4)] ] assert is_valid_fixture(n, m, matches) == False def test_check_fixtures(): T = 2 fixtures = [ ((4, 2), [[(1, 2), (3, 4)], [(1, 3), (2, 4)]]), ((3, 2), [[(1, 2), (2, 3)], [(1, 3), (2, 3)]]) ] assert check_fixtures(T, fixtures) == [\\"Valid\\", \\"Invalid\\"]","solution":"def is_valid_fixture(n, m, matches): Determines if the given fixture list is valid based on the specified constraints. n: int, number of teams m: int, number of days matches: list, list of matches for each day, format: [(k1, [(a1, b1), (a2, b2), ...]), (k2, [(a3, b3), ...]), ...] Returns a boolean indicating if the fixture list is valid. from collections import defaultdict played_opponents = defaultdict(set) for day in range(m): matches_per_day = matches[day] teams_playing_today = set() for match in matches_per_day: a, b = match if a in teams_playing_today or b in teams_playing_today: return False # A team is playing more than one match in a day. if b in played_opponents[a] or a in played_opponents[b]: return False # Teams are playing against the same opponent more than once. teams_playing_today.add(a) teams_playing_today.add(b) played_opponents[a].add(b) played_opponents[b].add(a) return True def check_fixtures(T, fixtures): results = [] for i in range(T): n, m = fixtures[i][0] matches = fixtures[i][1] result = is_valid_fixture(n, m, matches) results.append(\\"Valid\\" if result else \\"Invalid\\") return results"},{"question":"def reorder_packets(packets): Reorders the given packets based on their sequence numbers. :param packets: List of tuples, each containing (sequence number and data string) :return: List of data strings in the order of their sequence numbers pass from typing import List, Tuple def test_reorder_packets_basic(): packets = [(2, \\"world\\"), (3, \\"this\\"), (1, \\"Hello\\"), (4, \\"is\\"), (5, \\"test\\")] expected = [\\"Hello\\", \\"world\\", \\"this\\", \\"is\\", \\"test\\"] assert reorder_packets(packets) == expected def test_reorder_packets_single_packet(): packets = [(1, \\"only one packet\\")] expected = [\\"only one packet\\"] assert reorder_packets(packets) == expected def test_reorder_packets_consecutive_numbers(): packets = [(1, \\"packet1\\"), (3, \\"packet3\\"), (2, \\"packet2\\")] expected = [\\"packet1\\", \\"packet2\\", \\"packet3\\"] assert reorder_packets(packets) == expected def test_reorder_packets_different_orders(): packets = [(4, \\"packet4\\"), (1, \\"packet1\\"), (3, \\"packet3\\"), (2, \\"packet2\\")] expected = [\\"packet1\\", \\"packet2\\", \\"packet3\\", \\"packet4\\"] assert reorder_packets(packets) == expected def test_reorder_packets_random_order(): packets = [(10, \\"packet10\\"), (7, \\"packet7\\"), (9, \\"packet9\\"), (8, \\"packet8\\")] expected = [\\"packet7\\", \\"packet8\\", \\"packet9\\", \\"packet10\\"] assert reorder_packets(packets) == expected def test_reorder_packets_large_input(): packets = [(i, f\\"packet{i}\\") for i in range(1000, 0, -1)] expected = [f\\"packet{i}\\" for i in range(1, 1001)] assert reorder_packets(packets) == expected","solution":"def reorder_packets(packets): Reorders the given packets based on their sequence numbers. :param packets: List of tuples, each containing (sequence number, data string) :return: List of data strings in the order of their sequence numbers # Sort the packets based on their sequence numbers packets.sort() # Extract the data strings in sorted order ordered_data = [data for _, data in packets] return ordered_data"},{"question":"def longest_even_subsequence_length(N: int, A: list) -> int: Given an integer N and an array A of length N, return the length of the longest subsequence that contains only even numbers. >>> longest_even_subsequence_length(7, [1, 2, 4, 3, 6, 8, 5]) 4 >>> longest_even_subsequence_length(10, [1, 3, 5, 7, 9, 11, 13, 15, 17, 2]) 1","solution":"def longest_even_subsequence_length(N, A): Given an integer N and an array A of length N, return the length of the longest subsequence that contains only even numbers. even_count = 0 for num in A: if num % 2 == 0: even_count += 1 return even_count"},{"question":"def every_nth_character(s: str, n: int) -> str: Returns a new string consisting of every n-th character of the original string starting from the first character. If n is greater than the length of the string, return the original string. >>> every_nth_character(\\"abcdefg\\", 2) \\"aceg\\" >>> every_nth_character(\\"hello world\\", 3) \\"hlwl\\" >>> every_nth_character(\\"python\\", 6) \\"p\\" >>> every_nth_character(\\"programming\\", 12) \\"programming\\" >>> every_nth_character(\\"\\", 2) \\"\\" >>> every_nth_character(\\"a\\", 2) \\"a\\" >>> every_nth_character(\\"abc\\", 5) \\"abc\\" >>> every_nth_character(\\"abcdef\\", -1) \\"abcdef\\" >>> every_nth_character(\\"abcdefgh\\", 10) \\"abcdefgh\\" >>> every_nth_character(\\"xyz\\", 100) \\"xyz\\" >>> every_nth_character(\\"hello\\", 0) \\"hello\\" >>> every_nth_character(\\"world\\", -5) \\"world\\"","solution":"def every_nth_character(s, n): Returns a new string consisting of every n-th character of the original string starting from the first character. If n is greater than the length of the string, return the original string. if not s or n <= 0: return s if n > len(s): return s return s[::n]"},{"question":"from collections import deque class MovingAverage: Calculates a moving average of the last k values added. Attributes: size (int): The window size for the moving average. window (deque): The deque to store the last k values. sum (int): The sum of the elements in the current window. def __init__(self, size: int): Initializes the object with the size of the moving window. self.size = size self.window = deque() self.sum = 0 def next(self, val: int) -> float: Adds the integer val to the moving window and returns the current moving average of the last k values. Args: val (int): The value to be added to the moving window. Returns: float: The current moving average of the last k values. >>> m = MovingAverage(3) >>> m.next(1) 1.0 >>> m.next(10) 5.5 >>> m.next(3) 4.666666666666667 >>> m.next(5) 6.0 pass def test_moving_average_case_1(): movingAverage = MovingAverage(3) assert movingAverage.next(1) == 1.0 assert movingAverage.next(10) == 5.5 assert movingAverage.next(3) == 4.666666666666667 assert movingAverage.next(5) == 6.0 def test_moving_average_case_2(): movingAverage = MovingAverage(2) assert movingAverage.next(6) == 6.0 assert movingAverage.next(2) == 4.0 assert movingAverage.next(3) == 2.5 assert movingAverage.next(8) == 5.5 def test_moving_average_case_3(): movingAverage = MovingAverage(1) assert movingAverage.next(100) == 100.0 assert movingAverage.next(200) == 200.0 assert movingAverage.next(300) == 300.0 def test_moving_average_empty_initialization(): movingAverage = MovingAverage(4) assert movingAverage.next(0) == 0.0 assert movingAverage.next(0) == 0.0 def test_moving_average_split_case(): movingAverage = MovingAverage(5) movingAverage.next(1) movingAverage.next(2) movingAverage.next(3) movingAverage.next(4) assert movingAverage.next(5) == 3.0 assert movingAverage.next(6) == 4.0 assert movingAverage.next(7) == 5.0 assert movingAverage.next(8) == 6.0","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): self.size = size self.window = deque() self.sum = 0 def next(self, val: int) -> float: if len(self.window) == self.size: self.sum -= self.window.popleft() self.window.append(val) self.sum += val return self.sum / len(self.window)"},{"question":"def min_possible_max_weight(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given the number of test cases and the details of each test case, returns the minimum possible weight of the heaviest stone after performing any number of moves. >>> min_possible_max_weight(3, [(2, [10, 10]), (3, [5, 7, 5]), (4, [4, 8, 2, 6])]) [0, 1, 0] >>> min_possible_max_weight(1, [(1, [7])]) [1] from typing import List, Tuple def test_min_possible_max_weight_example(): input_data = (3, [ (2, [10, 10]), (3, [5, 7, 5]), (4, [4, 8, 2, 6]) ]) expected_output = [0, 1, 0] assert min_possible_max_weight(*input_data) == expected_output def test_min_possible_max_weight_single_stone(): input_data = (1, [ (1, [7]) ]) expected_output = [1] assert min_possible_max_weight(*input_data) == expected_output def test_min_possible_max_weight_all_zero(): input_data = (1, [ (3, [0, 0, 0]) ]) expected_output = [0] assert min_possible_max_weight(*input_data) == expected_output def test_min_possible_max_weight_even_sum(): input_data = (2, [ (2, [6, 6]), (4, [1, 1, 2, 2]) ]) expected_output = [0, 0] assert min_possible_max_weight(*input_data) == expected_output def test_min_possible_max_weight_odd_sum(): input_data = (2, [ (3, [5, 7, 5]), (4, [2, 3, 1, 7]) ]) expected_output = [1, 1] assert min_possible_max_weight(*input_data) == expected_output","solution":"def min_possible_max_weight(t, test_cases): Given the number of test cases and the details of each test case, returns the minimum possible weight of the heaviest stone after performing any number of moves. def calculate_min_max_weight(n, weights): total = sum(weights) return total % 2 results = [] for i in range(t): n = test_cases[i][0] weights = test_cases[i][1] results.append(calculate_min_max_weight(n, weights)) return results"},{"question":"def is_valid_parentheses(s: str) -> bool: Determines if the string of parentheses is valid. A string is considered valid if all parentheses are closed and properly nested. Args: s (str): A string consisting of parentheses characters '(', ')', '{', '}', '[' and ']'. Returns: bool: True if the string is valid, False otherwise. Examples: >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"()[]{}\\") True >>> is_valid_parentheses(\\"(]\\") False >>> is_valid_parentheses(\\"([)]\\") False >>> is_valid_parentheses(\\"{[]}\\") True","solution":"def is_valid_parentheses(s): Determines if the string of parentheses is valid. Args: s (str): A string consisting of parentheses characters '(', ')', '{', '}', '[' and ']'. Returns: bool: True if the string is valid, False otherwise. # Stack to keep track of opening parentheses. stack = [] # Dictionary to hold matching pairs of parentheses. matching_parentheses = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_parentheses.values(): # If the character is an opening bracket, push it onto the stack. stack.append(char) elif char in matching_parentheses.keys(): # If the character is a closing bracket, check if it matches the top of the stack. if stack == [] or matching_parentheses[char] != stack.pop(): return False # The stack should be empty if all opening brackets have been properly closed. return stack == []"},{"question":"def count_subarrays(n, d): Given a number 'n' and a target sum 'd', count the number of contiguous subarrays within the range [1, n] whose sum equals 'd'. >>> count_subarrays(5, 5) 2 >>> count_subarrays(4, 3) 2 >>> count_subarrays(6, 6) 2 >>> count_subarrays(1, 1) 1 >>> count_subarrays(5, 20) 0 >>> count_subarrays(10, 15) 3 >>> count_subarrays(3, 6) 1 >>> count_subarrays(0, 1) 0","solution":"def count_subarrays(n, d): Given a number 'n' and a target sum 'd', count the number of contiguous subarrays within the range [1, n] whose sum equals 'd'. array = list(range(1, n + 1)) count = 0 for i in range(n): current_sum = 0 for j in range(i, n): current_sum += array[j] if current_sum == d: count += 1 elif current_sum > d: break return count"},{"question":"def count_ways_to_sum(n: int, k: int) -> int: Count the number of ways to sum up to n using exactly k positive integers. >>> count_ways_to_sum(5, 2) 4 >>> count_ways_to_sum(5, 3) 6 >>> count_ways_to_sum(1, 1) 1 >>> count_ways_to_sum(10, 2) 9 >>> count_ways_to_sum(10, 3) 36","solution":"def count_ways_to_sum(n, k): Count the number of ways to sum up to n using exactly k positive integers. # Creating a memoization table to store the results of subproblems dp = [[0] * (k + 1) for _ in range(n + 1)] # Base case: There is one way to split zero into zero parts, that is do nothing dp[0][0] = 1 # Iterate over each number from 1 to n for i in range(1, n + 1): # Iterate over the possible number of parts from 1 to k for j in range(1, k + 1): # dp[i][j] = sum of all dp[i - l][j - 1] where l is 1 to i dp[i][j] = sum(dp[i - l][j - 1] for l in range(1, i + 1)) # Return the result of splitting n into k parts return dp[n][k]"},{"question":"def max_subarray_sum(arr): Given an array of positive integers, find the largest sum of a contiguous subarray. >>> max_subarray_sum([1, 2, 3, 4]) == 10 >>> max_subarray_sum([-1, 2, 3, -2, 5]) == 8 >>> max_subarray_sum([5, 4, -1, 7, 8]) == 23 pass def main(input_lists): Given a list of lists of integers, applies the max_subarray_sum function to each and returns the results. >>> input_lists = [ >>> [1, 2, 3, 4], >>> [-1, 2, 3, -2, 5], >>> [5, 4, -1, 7, 8] >>> ] >>> main(input_lists) == [10, 8, 23] pass","solution":"def max_subarray_sum(arr): Given an array of positive integers, find the largest sum of a contiguous subarray. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global def main(input_lists): Given a list of lists of integers, applies the max_subarray_sum function to each and returns the results. result = [] for lst in input_lists: result.append(max_subarray_sum(lst)) return result # Example usage: # input_lists = [ # [1, 2, 3, 4], # [-1, 2, 3, -2, 5], # [5, 4, -1, 7, 8] # ] # print(main(input_lists)) # Output: [10, 8, 23]"},{"question":"def calculate_unique_chars(input_string: str) -> dict: Returns a dictionary containing each unique character from the input string as keys and their respective counts as values. If the input string is empty, the function returns an empty dictionary. >>> calculate_unique_chars('') == {} >>> calculate_unique_chars('a') == {'a': 1} >>> calculate_unique_chars('aaa') == {'a': 3} >>> calculate_unique_chars('ab') == {'a': 1, 'b': 1} >>> calculate_unique_chars('aabbcc') == {'a': 2, 'b': 2, 'c': 2} >>> calculate_unique_chars('a b c') == {'a': 1, ' ': 2, 'b': 1, 'c': 1} >>> calculate_unique_chars('a!b@c#') == {'a': 1, '!': 1, 'b': 1, '@': 1, 'c': 1, '#': 1} >>> calculate_unique_chars('a1b2c3') == {'a': 1, '1': 1, 'b': 1, '2': 1, 'c': 1, '3': 1}","solution":"def calculate_unique_chars(input_string): Returns a dictionary with unique characters from the input string as keys and their respective counts as values. If the input string is empty, returns an empty dictionary. if not input_string: return {} char_count = {} for char in input_string: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"def reverse_words(s: str) -> str: Takes a string of words separated by single spaces and returns a new string where each word within the string is reversed. >>> reverse_words(\\"the sky is blue\\") \\"eht yks si eulb\\" >>> reverse_words(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words(\\"a bc def\\") \\"a cb fed\\" def test_single_word(): assert reverse_words(\\"hello\\") == \\"olleh\\" def test_two_words(): assert reverse_words(\\"hello world\\") == \\"olleh dlrow\\" def test_multiple_words(): assert reverse_words(\\"the sky is blue\\") == \\"eht yks si eulb\\" def test_words_of_varying_length(): assert reverse_words(\\"a bc def\\") == \\"a cb fed\\" def test_all_letters_reversed(): assert reverse_words(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"zyxwvutsrqponmlkjihgfedcba\\" def test_all_repeated_words(): assert reverse_words(\\"echo echo echo echo\\") == \\"ohce ohce ohce ohce\\"","solution":"def reverse_words(s): Takes a string of words separated by single spaces and returns a new string where each word within the string is reversed. :param s: str - Input string of words separated by single spaces :return: str - New string with each word reversed return ' '.join(word[::-1] for word in s.split())"},{"question":"from typing import List def count_colored_shapes(shapes: List[str], target_shape: str, target_color: str) -> int: Counts the number of times a target shape with a target color appears in the list of shapes. Parameters: - shapes: List[str] - list of strings where each string represents a shape and its color separated by a space. - target_shape: str - the target shape to count. - target_color: str - the target color to count. Returns: - int - the count of target shape with target color in the list. Examples: >>> shapes = [\\"red circle\\", \\"blue square\\", \\"red triangle\\", \\"red circle\\", \\"blue circle\\"] >>> count_colored_shapes(shapes, \\"circle\\", \\"red\\") 2 >>> shapes = [\\"green hexagon\\", \\"yellow triangle\\", \\"yellow hexagon\\", \\"green triangle\\", \\"green square\\"] >>> count_colored_shapes(shapes, \\"hexagon\\", \\"green\\") 1 >>> shapes = [\\"orange heart\\", \\"purple star\\", \\"orange star\\", \\"orange circle\\", \\"purple heart\\"] >>> count_colored_shapes(shapes, \\"star\\", \\"orange\\") 1 >>> shapes = [\\"blue oval\\", \\"blue rectangle\\", \\"blue oval\\", \\"blue square\\"] >>> count_colored_shapes(shapes, \\"circle\\", \\"blue\\") 0","solution":"from typing import List def count_colored_shapes(shapes: List[str], target_shape: str, target_color: str) -> int: Counts the number of times a target shape with a target color appears in the list of shapes. Parameters: - shapes: List[str] - list of strings where each string represents a shape and its color separated by a space. - target_shape: str - the target shape to count. - target_color: str - the target color to count. Returns: - int - the count of target shape with target color in the list. target = f\\"{target_color} {target_shape}\\" return shapes.count(target)"},{"question":"def filter_file_paths(file_paths: str, target_dir: str) -> List[str]: Given a string containing several file paths, filter out and return only the paths that point to a file in a given directory. >>> filter_file_paths( \\"/home/user/docs/file1.txtn/home/user/docs/file2.txtn/home/user/docs/subdir/file3.txtn/home/user/music/song.mp3\\", \\"/home/user/docs\\" ) ['/home/user/docs/file1.txt', '/home/user/docs/file2.txt'] >>> filter_file_paths( \\"/home/user/music/song.mp3n/home/user/pics/photo.jpg\\", \\"/home/user/docs\\" ) [] >>> filter_file_paths( \\"/home/user/docs/file1.txtn/home/user/music/song.mp3\\", \\"/home/user/docs\\" ) ['/home/user/docs/file1.txt'] >>> filter_file_paths(\\"\\", \\"/home/user/docs\\") [] >>> filter_file_paths( \\"/home/user/docs/file1.txtn/home/user/docs/subdir/file2.txtn/home/user/docs/file3.txt\\", \\"/home/user/docs\\" ) ['/home/user/docs/file1.txt', '/home/user/docs/file3.txt'] >>> filter_file_paths( \\"/home/user/docs/file1.txtn/home/user/docs123/file2.txtn/home/user/docs/subdir/file3.txtn/home/user/docs/file2.txt\\", \\"/home/user/docs\\" ) ['/home/user/docs/file1.txt', '/home/user/docs/file2.txt']","solution":"def filter_file_paths(file_paths, target_dir): Returns a list of file paths that are directly under the specified directory. :param file_paths: A string containing multiple file paths separated by newline characters. :param target_dir: A string representing the target directory path. :return: A list of file paths that are directly under the target directory. paths_list = file_paths.split('n') filtered_paths = [path for path in paths_list if path.startswith(target_dir + '/') and len(path[len(target_dir) + 1:].split('/')) == 1] return filtered_paths"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any contiguous subarray of the array. If the array is empty, return 0. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([-1]) == -1 >>> max_subarray_sum([-2, -3, -4, -1, -2, -1, -5, -4]) == -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 9 >>> max_subarray_sum([]) == 0","solution":"def max_subarray_sum(nums): Returns the maximum sum of any contiguous subarray of the array. If the array is empty, return 0. if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def has_consecutive_increasing_digits(s: str) -> bool: Write a function that takes a string consisting of digits and returns true if it contains exactly three consecutive digits in increasing order (e.g., '123', '456') somewhere in the string. Examples: >>> has_consecutive_increasing_digits(\\"12934567\\") True >>> has_consecutive_increasing_digits(\\"123456\\") True >>> has_consecutive_increasing_digits(\\"321456\\") True >>> has_consecutive_increasing_digits(\\"98765\\") False from solution import has_consecutive_increasing_digits def test_consecutive_increasing_digits_present(): assert has_consecutive_increasing_digits(\\"12934567\\") == True def test_multiple_consecutive_increasing_digits(): assert has_consecutive_increasing_digits(\\"123456\\") == True def test_consecutive_increasing_digits_in_middle(): assert has_consecutive_increasing_digits(\\"321456\\") == True def test_no_consecutive_increasing_digits(): assert has_consecutive_increasing_digits(\\"98765\\") == False def test_consecutive_increasing_digits_at_start(): assert has_consecutive_increasing_digits(\\"456789\\") == True def test_string_too_short(): assert has_consecutive_increasing_digits(\\"12\\") == False def test_no_digits(): assert has_consecutive_increasing_digits(\\"abcdef\\") == False def test_mixed_characters(): assert has_consecutive_increasing_digits(\\"a1b2c3d456f7\\") == True","solution":"def has_consecutive_increasing_digits(s): Returns True if the string contains exactly three consecutive digits in increasing order. for i in range(len(s) - 2): if s[i].isdigit() and s[i+1].isdigit() and s[i+2].isdigit(): if int(s[i]) + 1 == int(s[i+1]) and int(s[i+1]) + 1 == int(s[i+2]): return True return False"},{"question":"def longest_contiguous_substring(s: str) -> int: Returns the length of the longest contiguous substring consisting of the same character. >>> longest_contiguous_substring(\\"aaabbbcccccdd\\") 5 >>> longest_contiguous_substring(\\"aaaa\\") 4 >>> longest_contiguous_substring(\\"a\\") 1 >>> longest_contiguous_substring(\\"ab\\") 1 >>> longest_contiguous_substring(\\"\\") 0 >>> longest_contiguous_substring(\\"ababababab\\") 1 >>> longest_contiguous_substring(\\"abhhhhhhabbccc\\") 6 >>> longest_contiguous_substring(\\"zzzzyyyyyxxxxxxwwwwwwwxxx\\") 7 >>> longest_contiguous_substring(\\"zzzzzzzzz\\") 9","solution":"def longest_contiguous_substring(s): Returns the length of the longest contiguous substring consisting of the same character. if not s: return 0 max_len = 1 current_len = 1 for i in range(1, len(s)): if s[i] == s[i-1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 # Check one last time in case the longest substring is at the end max_len = max(max_len, current_len) return max_len"},{"question":"def first_non_repeated_char(s: str) -> str: Returns the first non-repeated character in the string s. If all characters are repeated or the string is empty, returns an empty string. >>> first_non_repeated_char(\\"swiss\\") \\"w\\" >>> first_non_repeated_char(\\"aabb\\") \\"\\" >>> first_non_repeated_char(\\"character\\") \\"h\\"","solution":"def first_non_repeated_char(s): Returns the first non-repeated character in the string s. If all characters are repeated or the string is empty, returns an empty string. char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character that appears only once for char in s: if char_count[char] == 1: return char return \\"\\""},{"question":"def time_differences(time_tuples: List[Tuple[int, int]]) -> List[int]: Calculate the difference in minutes between two points in time for each tuple. >>> time_differences([(1230, 1530)]) [180] >>> time_differences([(230, 600), (1230, 1330)]) [210, 60] >>> time_differences([(2359, 2359)]) [0] >>> time_differences([(2300, 2400), (1400, 1800)]) [60, 240] >>> time_differences([(1230, 1231)]) [1] >>> time_differences([(0, 1), (1234, 1235)]) [1, 1]","solution":"def time_differences(time_tuples): Calculate the difference in minutes between two points in time for each tuple. result = [] for t1, t2 in time_tuples: # Split HHMM into hours and minutes h1, m1 = divmod(t1, 100) h2, m2 = divmod(t2, 100) # Convert both times to minutes from midnight time1_in_minutes = h1 * 60 + m1 time2_in_minutes = h2 * 60 + m2 # Calculate the difference in minutes difference = time2_in_minutes - time1_in_minutes result.append(difference) return result"},{"question":"def maxTreasure(treasures): In a quiet village, there are N houses aligned in a straight row. Each house has a certain amount of treasure. Given the amount of treasure in each house, a thief can rob a house but cannot rob two consecutive houses due to the risk of getting caught. The thief wants to maximize the amount of treasure he can steal. However, there is one condition: if the first house is robbed, the last house cannot be robbed, and vice versa. Parameters: treasures (List[int]): List of integers representing the amount of treasure in each house. Returns: int: Maximum amount of treasure the thief can rob without robbing two consecutive houses and adhering to the condition mentioned above. >>> maxTreasure([2, 3, 2]) 3 >>> maxTreasure([5]) 5 >>> maxTreasure([5, 3]) 5 >>> maxTreasure([1, 2, 3]) 3 >>> maxTreasure([2, 7, 9, 3, 1]) 11 >>> maxTreasure([0, 0, 0, 0, 0]) 0 >>> maxTreasure([10, 1, 10, 1, 10, 1, 10]) 30","solution":"def maxTreasure(treasures): if not treasures: return 0 if len(treasures) == 1: return treasures[0] if len(treasures) == 2: return max(treasures) def rob_linear(houses): n = len(houses) dp = [0] * n if n >= 1: dp[0] = houses[0] if n >= 2: dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1] return max(rob_linear(treasures[:-1]), rob_linear(treasures[1:]))"},{"question":"def has_unique_chars(s: str) -> bool: Determines whether a string has all unique characters or not. >>> has_unique_chars(\\"abcdef\\") == True >>> has_unique_chars(\\"aabbcc\\") == False >>> has_unique_chars(\\"aA\\") == True >>> has_unique_chars(\\"\\") == True >>> has_unique_chars(\\"12345aA\\") == True >>> has_unique_chars(\\"112233\\") == False >>> has_unique_chars(\\"!@#%^&*()\\") == True >>> has_unique_chars(\\"!@#%!@#!\\") == False","solution":"def has_unique_chars(s): Returns True if all characters in the string s are unique, False otherwise. char_set = set() for char in s: if char in char_set: return False char_set.add(char) return True"},{"question":"from typing import List, Tuple def top_scorer(games: List[Tuple[str, int]]) -> str: Given an array of tuples representing points scored by players in a game, find the player with the highest average score over the games they played. In case of a tie, return the player that appears first in the list. >>> top_scorer([('alice', 10), ('bob', 15), ('alice', 20), ('bob', 25), ('charles', 10)]) 'bob' >>> top_scorer([('alice', 10)]) 'alice' >>> top_scorer([('alice', 10), ('alice', 20)]) 'alice' >>> top_scorer([('alice', 10), ('bob', 10), ('alice', 20), ('bob', 20)]) 'alice' >>> top_scorer([]) None pass","solution":"def top_scorer(games): from collections import defaultdict scores = defaultdict(list) for player, score in games: scores[player].append(score) max_avg = float('-inf') top_player = None for player, score_list in scores.items(): avg_score = sum(score_list) / len(score_list) if avg_score > max_avg: max_avg = avg_score top_player = player # In case of a tie, the player who appears first in the dictionary gets chosen (which aligns with first appearance in the list) return top_player"},{"question":"def countArmstrongNumbers(n: int) -> int: Write a function that takes an integer n as input and returns the count of all Armstrong numbers with 'n' digits. Armstrong numbers are numbers that are equal to the sum of their own digits each raised to the power of the number of digits. >>> countArmstrongNumbers(1) 9 >>> countArmstrongNumbers(2) 0 >>> countArmstrongNumbers(3) 4","solution":"def countArmstrongNumbers(n): Returns the count of Armstrong numbers with exactly n digits. def is_armstrong(num, n): Checks if a given number is an Armstrong number. return num == sum(int(digit) ** n for digit in str(num)) start = 10**(n-1) end = 10**n - 1 count = 0 for num in range(start, end + 1): if is_armstrong(num, n): count += 1 return count"},{"question":"def maximum_minimum_element(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given an array of N integers. You can perform the following operation on the array: Select any two adjacent elements and replace both of them with their sum. Your objective is to maximize the minimum element in the array after performing this operation exactly N-1 times. Args: t: int - Number of test cases. test_cases: List of tuples where each tuple contains (n, arr). Returns: List of integers - Each integer being the maximum possible minimum element for each test case. >>> maximum_minimum_element(2, [(3, [1, 2, 3]), (4, [1, 4, 1, 4])]) [6, 10] >>> maximum_minimum_element(1, [(2, [1, 1])]) [2] >>> maximum_minimum_element(1, [(5, [3, 3, 3, 3, 3])]) [15] >>> maximum_minimum_element(1, [(3, [1000000, 1000000, 1000000])]) [3000000] >>> maximum_minimum_element(2, [(5, [1, 2, 3, 4, 5]), (3, [6, 7, 8])]) [15, 21]","solution":"def maximum_minimum_element(t, test_cases): Args: t: int - Number of test cases test_cases: List of tuples where each tuple contains (n, arr) Returns: List of integers - Each integer being the maximum possible minimum element for each test case results = [] for n, arr in test_cases: # To maximize the minimum element, the optimal approach is to sum up all elements max_min_element = sum(arr) results.append(max_min_element) return results"},{"question":"def num_decodings(s: str) -> int: Given a string s containing only digits, return the number of ways to decode it. The mapping is given such that '1' maps to 'A', '2' maps to 'B', ..., '26' maps to 'Z'. >>> num_decodings(\\"12\\") 2 >>> num_decodings(\\"226\\") 3 >>> num_decodings(\\"06\\") 0 >>> num_decodings(\\"11106\\") 2","solution":"def num_decodings(s): Returns the number of ways to decode the string s. Args: s : str : a string containing only digits Returns: int : number of ways to decode the string if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): # Single digit decode if 0 < int(s[i-1:i]) <= 9: dp[i] += dp[i-1] # Two digits decode if 10 <= int(s[i-2:i]) <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"import random from typing import List, Dict, Tuple def generateMCQ(concepts: List[Tuple[str, str]], distractors: Dict[str, List[str]], num_questions: int) -> List[str]: Generates a specified number of multiple-choice questions (MCQs). Args: concepts (list of tuples): Each tuple contains a question (str) and its correct answer (str). distractors (dict): A dictionary mapping each question to a list of distractors (incorrect answers). num_questions (int): Number of MCQs to generate. Returns: list: A list of generated MCQs in string format. >>> concepts = [ ... ('What is the capital of France?', 'Paris'), ... ('What is 2+2?', '4') ... ] >>> distractors = { ... 'What is the capital of France?': ['London', 'Berlin', 'Madrid'], ... 'What is 2+2?': ['3', '5', '6'] ... } >>> generateMCQ(concepts, distractors, 2) [ \\"Q: What is the capital of France?na) Berlinnb) Parisnc) Madridnd) London\\", \\"Q: What is 2+2?na) 3nb) 4nc) 6nd) 5\\" ]","solution":"import random def generateMCQ(concepts, distractors, num_questions): Generates a specified number of multiple-choice questions (MCQs). Args: concepts (list of tuples): Each tuple contains a question (str) and its correct answer (str). distractors (dict): A dictionary mapping each question to a list of distractors (incorrect answers). num_questions (int): Number of MCQs to generate. Returns: list: A list of generated MCQs in string format. mcqs = [] for i in range(min(num_questions, len(concepts))): concept, correct_answer = concepts[i] wrong_answers = distractors.get(concept, []) # Shuffle the correct answer into the list of wrong answers all_answers = wrong_answers + [correct_answer] random.shuffle(all_answers) # Create the question string question_str = f\\"Q: {concept}n\\" options = ['a', 'b', 'c', 'd'] for j, answer in enumerate(all_answers): question_str += f\\"{options[j]}) {answer}n\\" mcqs.append(question_str.strip()) return mcqs"},{"question":"def convert_to_postfix(expression: str) -> str: Converts a given infix mathematical expression to postfix notation (Reverse Polish Notation). >>> convert_to_postfix(\\"3 + 4 * 2 / ( 1 - 5 )\\") == \\"3 4 2 * 1 5 - / +\\" >>> convert_to_postfix(\\"( 2 + 3 ) * 4\\") == \\"2 3 + 4 *\\" def test_basic_expression(): assert convert_to_postfix(\\"3 + 4\\") == \\"3 4 +\\" def test_expression_with_multiple_operators(): assert convert_to_postfix(\\"3 + 4 * 2 / ( 1 - 5 )\\") == \\"3 4 2 * 1 5 - / +\\" def test_expression_with_parentheses(): assert convert_to_postfix(\\"( 2 + 3 ) * 4\\") == \\"2 3 + 4 *\\" def test_nested_parentheses(): assert convert_to_postfix(\\"( ( 1 + 2 ) * ( 3 - 4 ) )\\") == \\"1 2 + 3 4 - *\\" def test_complex_expression(): assert convert_to_postfix(\\"4 + 18 / ( 9 - 3 )\\") == \\"4 18 9 3 - / +\\" def test_expression_with_same_precedence(): assert convert_to_postfix(\\"5 * 3 / 2 + 4 - 1\\") == \\"5 3 * 2 / 4 + 1 -\\" def test_expression_with_only_operands(): assert convert_to_postfix(\\"1 2 3\\") == \\"1 2 3\\"","solution":"def convert_to_postfix(expression): Converts an infix expression to postfix (Reverse Polish Notation). def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def infix_to_postfix(expression): stack = [] # stack to hold operators output = [] # list for output tokens = expression.split() for token in tokens: if token.isnumeric(): # if operand, add to output output.append(token) elif token == '(': stack.append(token) elif token == ')': while stack and stack[-1] != '(': output.append(stack.pop()) stack.pop() else: # operator encountered while stack and precedence(stack[-1]) >= precedence(token): output.append(stack.pop()) stack.append(token) while stack: output.append(stack.pop()) return ' '.join(output) return infix_to_postfix(expression)"},{"question":"def length_of_LIS(nums: List[int]) -> int: Returns the length of the longest increasing subsequence. Arguments: nums: List of unique integers. Returns: Length of the longest increasing subsequence. Example: >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_LIS([0, 1, 0, 3, 2, 3]) 4 >>> length_of_LIS([7, 7, 7, 7, 7, 7]) 1 >>> length_of_LIS([]) 0 >>> length_of_LIS([1]) 1 >>> length_of_LIS([1, 2, 3, 4, 5, 6, 7, 8, 9]) 9 >>> length_of_LIS([9, 8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> length_of_LIS([2, 6, 8, 3, 4, 5, 1, 7]) 5 pass","solution":"def length_of_LIS(nums): Returns the length of the longest increasing subsequence. The time complexity of this solution is O(n^2). Arguments: nums: List of unique integers. Returns: Length of the longest increasing subsequence. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def sort_tasks(tasks: list[dict]) -> list[dict]: Sorts the list of tasks first by priority (from highest to lowest), and then by due date (earliest first) if two tasks have the same priority. Args: tasks (list of dict): List of tasks where each task is a dictionary with keys 'name', 'priority', and 'due_date'. Returns: list of dict: Sorted list of tasks. >>> tasks = [ ... {\\"name\\": \\"Task1\\", \\"priority\\": 3, \\"due_date\\": \\"2023-11-01\\"}, ... {\\"name\\": \\"Task2\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-15\\"}, ... {\\"name\\": \\"Task3\\", \\"priority\\": 2, \\"due_date\\": \\"2023-10-10\\"}, ... {\\"name\\": \\"Task4\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-12\\"}, ... ] >>> sort_tasks(tasks) [ {\\"name\\": \\"Task4\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-12\\"}, {\\"name\\": \\"Task2\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-15\\"}, {\\"name\\": \\"Task3\\", \\"priority\\": 2, \\"due_date\\": \\"2023-10-10\\"}, {\\"name\\": \\"Task1\\", \\"priority\\": 3, \\"due_date\\": \\"2023-11-01\\"}, ] # Test Cases def test_sort_tasks_different_priorities(): tasks = [ {\\"name\\": \\"Task1\\", \\"priority\\": 3, \\"due_date\\": \\"2023-11-01\\"}, {\\"name\\": \\"Task2\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-15\\"}, {\\"name\\": \\"Task3\\", \\"priority\\": 2, \\"due_date\\": \\"2023-10-10\\"}, ] expected = [ {\\"name\\": \\"Task2\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-15\\"}, {\\"name\\": \\"Task3\\", \\"priority\\": 2, \\"due_date\\": \\"2023-10-10\\"}, {\\"name\\": \\"Task1\\", \\"priority\\": 3, \\"due_date\\": \\"2023-11-01\\"}, ] assert sort_tasks(tasks) == expected def test_sort_tasks_same_priority(): tasks = [ {\\"name\\": \\"Task1\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-15\\"}, {\\"name\\": \\"Task2\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-12\\"}, {\\"name\\": \\"Task3\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-10\\"}, ] expected = [ {\\"name\\": \\"Task3\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-10\\"}, {\\"name\\": \\"Task2\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-12\\"}, {\\"name\\": \\"Task1\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-15\\"}, ] assert sort_tasks(tasks) == expected def test_sort_tasks_mixed_priorities_and_dates(): tasks = [ {\\"name\\": \\"Task1\\", \\"priority\\": 3, \\"due_date\\": \\"2023-11-01\\"}, {\\"name\\": \\"Task2\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-15\\"}, {\\"name\\": \\"Task3\\", \\"priority\\": 2, \\"due_date\\": \\"2023-10-10\\"}, {\\"name\\": \\"Task4\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-12\\"}, ] expected = [ {\\"name\\": \\"Task4\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-12\\"}, {\\"name\\": \\"Task2\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-15\\"}, {\\"name\\": \\"Task3\\", \\"priority\\": 2, \\"due_date\\": \\"2023-10-10\\"}, {\\"name\\": \\"Task1\\", \\"priority\\": 3, \\"due_date\\": \\"2023-11-01\\"}, ] assert sort_tasks(tasks) == expected def test_sort_tasks_already_sorted(): tasks = [ {\\"name\\": \\"Task1\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-10\\"}, {\\"name\\": \\"Task2\\", \\"priority\\": 2, \\"due_date\\": \\"2023-10-15\\"}, {\\"name\\": \\"Task3\\", \\"priority\\": 3, \\"due_date\\": \\"2023-11-01\\"}, ] expected = [ {\\"name\\": \\"Task1\\", \\"priority\\": 1, \\"due_date\\": \\"2023-10-10\\"}, {\\"name\\": \\"Task2\\", \\"priority\\": 2, \\"due_date\\": \\"2023-10-15\\"}, {\\"name\\": \\"Task3\\", \\"priority\\": 3, \\"due_date\\": \\"2023-11-01\\"}, ] assert sort_tasks(tasks) == expected def test_sort_tasks_empty_list(): tasks = [] expected = [] assert sort_tasks(tasks) == expected","solution":"def sort_tasks(tasks): Sorts the list of tasks first by priority (from highest to lowest), and then by due date (earliest first) if two tasks have the same priority. Args: tasks (list of dict): List of tasks where each task is a dictionary with keys 'name', 'priority', and 'due_date'. Returns: list of dict: Sorted list of tasks. return sorted(tasks, key=lambda task: (task['priority'], task['due_date']))"},{"question":"from typing import List class Matrix: def __init__(self, data: List[List[int]]): Initialize the matrix with a 2D list of integers. self.data = data def __add__(self, other: 'Matrix') -> 'Matrix': Implement matrix addition. It should only be possible to add matrices of the same dimensions. If the dimensions do not match, raise a \`ValueError\`. >>> matrix1 = Matrix([[1, 2], [3, 4]]) >>> matrix2 = Matrix([[5, 6], [7, 8]]) >>> result = matrix1 + matrix2 >>> result.data [[6, 8], [10, 12]] pass def __mul__(self, scalar: int) -> 'Matrix': Implement scalar multiplication. >>> matrix = Matrix([[1, 2], [3, 4]]) >>> result = matrix * 3 >>> result.data [[3, 6], [9, 12]] pass def __str__(self) -> str: Represent the matrix as a string in a readable form. >>> matrix = Matrix([[1, 2], [3, 4]]) >>> print(matrix) 1 2 3 4 pass","solution":"from typing import List class Matrix: def __init__(self, data: List[List[int]]): self.data = data def __add__(self, other: 'Matrix') -> 'Matrix': if len(self.data) != len(other.data) or len(self.data[0]) != len(other.data[0]): raise ValueError(\\"Matrices must have the same dimensions for addition\\") result = [ [self.data[i][j] + other.data[i][j] for j in range(len(self.data[0]))] for i in range(len(self.data)) ] return Matrix(result) def __mul__(self, scalar: int) -> 'Matrix': result = [ [self.data[i][j] * scalar for j in range(len(self.data[0]))] for i in range(len(self.data)) ] return Matrix(result) def __str__(self) -> str: return 'n'.join([' '.join(map(str, row)) for row in self.data])"},{"question":"def max_non_adjacent_sum(arr: List[int]) -> int: Given an array of integers, return the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent in the original array. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([3, 2, 7, 10]) 13","solution":"def max_non_adjacent_sum(arr): if not arr: return 0 n = len(arr) if n == 1: return max(0, arr[0]) prev_prev = max(0, arr[0]) prev = max(prev_prev, arr[1]) for i in range(2, n): current = max(prev, prev_prev + arr[i]) prev_prev = prev prev = current return prev"},{"question":"def max_score_ways(Q: int) -> int: Determine the number of ways to obtain the maximum score in Alice's card game. Parameters: Q (int): The upper limit of card values. Returns: int: The number of ways to achieve the maximum score. Examples: >>> max_score_ways(5) 5 >>> max_score_ways(7) 7 >>> max_score_ways(2) 2","solution":"def max_score_ways(Q): return Q"},{"question":"def most_frequent_word(s: str) -> str: Returns the most frequent word in the given text \`s\`. If there is a tie, return the word that appears first. >>> most_frequent_word(\\"Hello world hello\\") \\"hello\\" >>> most_frequent_word(\\"It is what it is\\") \\"it\\" >>> most_frequent_word(\\"Coding coding CODING\\") \\"coding\\" def test_single_word(): assert most_frequent_word(\\"hello\\") == \\"hello\\" def test_two_different_words(): assert most_frequent_word(\\"hello world\\") == \\"hello\\" def test_multiple_same_words(): assert most_frequent_word(\\"hello hello world\\") == \\"hello\\" def test_tie_broken_by_first_occurrence(): assert most_frequent_word(\\"it is what it is\\") == \\"it\\" def test_case_insensitivity(): assert most_frequent_word(\\"Hello hello HELLO\\") == \\"hello\\" def test_normal_text(): assert most_frequent_word(\\"the quick brown fox jumps over the lazy dog\\") == \\"the\\" def test_multiple_word_ties(): assert most_frequent_word(\\"word test word test\\") == \\"word\\" def test_each_word_occurs_once(): assert most_frequent_word(\\"a b c d e f\\") == \\"a\\"","solution":"def most_frequent_word(s): Returns the most frequent word in the given text \`s\`. If there is a tie, return the word that appears first. # Normalize the text to lowercase s = s.lower() # Tokenize the text into words words = s.split() # Count frequency of each word from collections import Counter word_count = Counter(words) # Find the word with the highest frequency and if there is a tie, the first occurrence max_count = max(word_count.values()) for word in words: if word_count[word] == max_count: return word"},{"question":"import heapq from typing import List def findKthSmallest(matrix: List[List[int]], k: int) -> int: Finds the k-th smallest element in a row-wise and column-wise sorted matrix. >>> findKthSmallest([ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ], 8) 13 >>> findKthSmallest([ ... [1] ... ], 1) 1 >>> findKthSmallest([ ... [1, 2], ... [1, 3] ... ], 2) 1 >>> findKthSmallest([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], 5) 5 >>> findKthSmallest([ ... [-5, -4, -3], ... [-2, -1, 0], ... [1, 2, 3] ... ], 4) -2 >>> findKthSmallest([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ], 10) 10","solution":"import heapq from typing import List def findKthSmallest(matrix: List[List[int]], k: int) -> int: Finds the k-th smallest element in a row-wise and column-wise sorted matrix. n = len(matrix) # Initialize a min-heap with the first element of each row. min_heap = [(matrix[i][0], i, 0) for i in range(min(k, n))] heapq.heapify(min_heap) while k > 0: element, row, col = heapq.heappop(min_heap) if col + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[row][col+1], row, col+1)) k -= 1 return element"},{"question":"class Calculator: A basic calculator with logging capabilities supporting addition, subtraction, multiplication, and division. Every time a calculation is performed, it stores a log entry that records the operation type, input values, and the result. Methods: add(a, b): Returns the sum of \`a\` and \`b\`. subtract(a, b): Returns the difference between \`a\` and \`b\`. multiply(a, b): Returns the product of \`a\` and \`b\`. divide(a, b): Returns the quotient of \`a\` divided by \`b\`. get_logs(): Returns a list of all logged operations. def __init__(self): pass # Initialize logs def add(self, a, b): Takes two numbers \`a\` and \`b\`, returns their sum. pass def subtract(self, a, b): Takes two numbers \`a\` and \`b\`, returns their difference. pass def multiply(self, a, b): Takes two numbers \`a\` and \`b\`, returns their product. pass def divide(self, a, b): Takes two numbers \`a\` and \`b\`, returns their quotient. If \`b\` is zero, raises a \`ValueError\` with the message 'Cannot divide by zero'. pass def get_logs(self): Returns a list of all logged operations in the format 'Operation: a OP b = result', where \`OP\` is the operation performed (+, -, *, /). pass # Test cases def test_add(): calc = Calculator() assert calc.add(2, 3) == 5 assert calc.add(-1, 1) == 0 def test_subtract(): calc = Calculator() assert calc.subtract(5, 3) == 2 assert calc.subtract(-1, -1) == 0 def test_multiply(): calc = Calculator() assert calc.multiply(2, 3) == 6 assert calc.multiply(0, 5) == 0 def test_divide(): calc = Calculator() assert calc.divide(6, 3) == 2 with pytest.raises(ValueError): calc.divide(1, 0) def test_get_logs(): calc = Calculator() # Perform some operations calc.add(1, 2) calc.subtract(5, 3) calc.multiply(3, 4) calc.divide(8, 2) logs = calc.get_logs() assert logs == [ \\"Operation: 1 + 2 = 3\\", \\"Operation: 5 - 3 = 2\\", \\"Operation: 3 * 4 = 12\\", \\"Operation: 8 / 2 = 4.0\\" ] def test_combined_operations(): calc = Calculator() assert calc.add(3, 7) == 10 assert calc.subtract(10, 4) == 6 assert calc.multiply(2, 5) == 10 assert calc.divide(20, 4) == 5","solution":"class Calculator: def __init__(self): self.logs = [] def add(self, a, b): result = a + b self.logs.append(f\\"Operation: {a} + {b} = {result}\\") return result def subtract(self, a, b): result = a - b self.logs.append(f\\"Operation: {a} - {b} = {result}\\") return result def multiply(self, a, b): result = a * b self.logs.append(f\\"Operation: {a} * {b} = {result}\\") return result def divide(self, a, b): if b == 0: raise ValueError(\\"Cannot divide by zero\\") result = a / b self.logs.append(f\\"Operation: {a} / {b} = {result}\\") return result def get_logs(self): return self.logs"},{"question":"def is_tree(graph: dict) -> bool: Determine if the graph is a tree (connected and acyclic) >>> is_tree({ ... 0: [1, 2], ... 1: [0, 3, 4], ... 2: [0], ... 3: [1], ... 4: [1] ... }) is True >>> is_tree({ ... 0: [1, 2], ... 1: [0, 2], ... 2: [0, 1, 3], ... 3: [2] ... }) is False >>> is_tree({ ... 0: [1], ... 1: [0], ... 2: [3], ... 3: [2] ... }) is False >>> is_tree({ ... 0: [] ... }) is True >>> is_tree({}) is True >>> is_tree({ ... 0: [1], ... 1: [0], ... 2: [] ... }) is False >>> is_tree({ ... 0: [], ... 1: [], ... 2: [] ... }) is False","solution":"def is_tree(graph: dict) -> bool: def has_cycle(node, parent): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if has_cycle(neighbor, node): return True elif neighbor != parent: return True return False if not graph: return True visited = set() start_node = next(iter(graph)) if has_cycle(start_node, -1): return False # Check if all nodes are visited (graph is connected) return len(visited) == len(graph)"},{"question":"from typing import List def maximalSquare(matrix: List[List[int]]) -> int: You are given an integer matrix of size m x n where each cell contains either 0 or 1. Your task is to find the size of the largest square containing only 1s and return its area. If there's no such square, return 0. >>> maximalSquare([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) 4 >>> maximalSquare([ ... [0, 1, 0], ... [1, 1, 1], ... [0, 1, 0] ... ]) 1 pass def test_example_1(): matrix = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] assert maximalSquare(matrix) == 4 def test_example_2(): matrix = [ [0, 1, 0], [1, 1, 1], [0, 1, 0] ] assert maximalSquare(matrix) == 1 def test_no_square(): matrix = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert maximalSquare(matrix) == 0 def test_full_ones(): matrix = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert maximalSquare(matrix) == 9 def test_single_element_one(): matrix = [[1]] assert maximalSquare(matrix) == 1 def test_single_element_zero(): matrix = [[0]] assert maximalSquare(matrix) == 0 def test_empty_matrix(): matrix = [] assert maximalSquare(matrix) == 0","solution":"def maximalSquare(matrix): if not matrix: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"def baking_rounds(total_cookies: int, tray_capacity: int) -> int: Calculates the total number of baking rounds required to bake all the cookies. Parameters: total_cookies (int): Total number of cookies to bake. (0 <= total_cookies <= 10^6) tray_capacity (int): Maximum number of cookies a single tray can hold. (1 <= tray_capacity <= 1000) Returns: int: Total number of baking rounds required. Examples: >>> baking_rounds(23, 5) => 5 >>> baking_rounds(100, 25) => 4 >>> baking_rounds(7, 3) => 3","solution":"def baking_rounds(total_cookies: int, tray_capacity: int) -> int: Returns the total number of baking rounds required to bake all the cookies. Parameters: total_cookies (int): Total number of cookies to bake. (0 <= total_cookies <= 10^6) tray_capacity (int): Maximum number of cookies a single tray can hold. (1 <= tray_capacity <= 1000) Returns: int: Total number of baking rounds required. # Compute the number of full trays full_trays = total_cookies // tray_capacity # Check for any remaining cookies that need an additional round if total_cookies % tray_capacity > 0: full_trays += 1 return full_trays"},{"question":"def read_input_and_calculate_total_sales(input_data: str) -> float: Reads input data, calculates the total sales amount for the day, and returns the result. Input data format: - First line contains an integer N representing the number of transactions. - The next N lines each contain a product name and a product price. Example: >>> input_data = \\"1nApple 1.20\\" >>> read_input_and_calculate_total_sales(input_data) 1.20 >>> input_data = \\"4nApple 1.20nBanana 0.50nOrange 0.75nMango 2.00\\" >>> read_input_and_calculate_total_sales(input_data) 4.45","solution":"def calculate_total_sales(transactions): Calculates the total sales amount from a list of transactions. Each transaction is represented as a tuple of (product name, product price). total_sales = sum(price for name, price in transactions) return round(total_sales, 2) def read_input_and_calculate_total_sales(input_data): Reads input data, calculates the total sales, and returns the result. Input data format: - First line contains an integer N representing the number of transactions. - The next N lines each contain a product name and a product price. lines = input_data.strip().split('n') N = int(lines[0]) transactions = [] for i in range(1, N + 1): product_info = lines[i].rsplit(' ', 1) product_name = product_info[0] product_price = float(product_info[1]) transactions.append((product_name, product_price)) return calculate_total_sales(transactions)"},{"question":"def is_palindrome(num: int) -> bool: Returns whether the input non-negative integer is a palindrome. A palindrome is a number that reads the same forward and backward. Args: num: A non-negative integer. Returns: A boolean indicating whether the integer is a palindrome. Examples: >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(1001) True >>> is_palindrome(10) False","solution":"def is_palindrome(num): Returns whether the input non-negative integer is a palindrome. A palindrome is a number that reads the same forward and backward. # Convert the number to string to check if it reads the same forward and backward str_num = str(num) return str_num == str_num[::-1]"},{"question":"from typing import List def rob(nums: List[int]) -> int: Determine the maximum amount of money you can rob without alerting the police, given that adjacent houses cannot be robbed on the same night, and since the houses are in a circle, the first and last house are considered adjacent. >>> rob([2,3,2]) 3 >>> rob([1,2,3,1]) 4 >>> rob([0]) 0 def test_single_element(): assert rob([0]) == 0 assert rob([10]) == 10 def test_two_elements(): assert rob([1, 2]) == 2 assert rob([2, 1]) == 2 def test_three_elements(): assert rob([2, 3, 2]) == 3 assert rob([1, 2, 3]) == 3 def test_four_elements(): assert rob([1, 2, 3, 1]) == 4 def test_general_cases(): assert rob([6, 7, 1, 30, 8, 2, 4]) == 41 assert rob([5, 3, 4, 11, 2]) == 16 assert rob([1, 2, 3, 4, 5, 1]) == 9 def test_large_set(): assert rob([10] * 1000) == 5000 def test_alternating_large_and_small(): assert rob([1, 100, 1, 100, 1, 100, 1, 100, 1, 100]) == 500","solution":"def rob(nums): if len(nums) == 1: return nums[0] def rob_linear(houses): prev2, prev1 = 0, 0 for money in houses: curr = max(prev1, prev2 + money) prev2 = prev1 prev1 = curr return prev1 return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"def max_non_overlapping_trains(test_cases): Determine the maximum number of non-overlapping trains that can be accommodated at the station. Args: test_cases (List[List[Tuple[int, int]]]): List of test cases where each test case contains a list of tuples with train arrival and departure times. Returns: List[int]: List of integers representing the maximum number of non-overlapping trains for each test case. >>> test_cases = [[(1, 3), (2, 4), (3, 5)], [(1, 2), (3, 4), (0, 6), (5, 7)]] >>> max_non_overlapping_trains(test_cases) [2, 3] def parse_input(input_str): Parse the input string to extract test cases. Args: input_str (str): Input string containing multiple test cases and train arrival and departure times. Returns: List[List[Tuple[int, int]]]: List of test cases where each test case contains a list of tuples with train arrival and departure times. >>> input_str = \\"2n3n1 3n2 4n3 5n4n1 2n3 4n0 6n5 7n\\" >>> parse_input(input_str) [[(1, 3), (2, 4), (3, 5)], [(1, 2), (3, 4), (0, 6), (5, 7)]] def test_max_non_overlapping_trains(): input_str = \\"2n3n1 3n2 4n3 5n4n1 2n3 4n0 6n5 7n\\" test_cases = parse_input(input_str) result = max_non_overlapping_trains(test_cases) assert result == [2, 3] def test_no_overlapping_trains(): input_str = \\"1n5n1 10n11 20n21 30n31 40n41 50n\\" test_cases = parse_input(input_str) result = max_non_overlapping_trains(test_cases) assert result == [5] def test_all_overlapping_trains(): input_str = \\"1n3n1 5n2 6n4 8n\\" test_cases = parse_input(input_str) result = max_non_overlapping_trains(test_cases) assert result == [1] def test_mixed_overlap_trains(): input_str = \\"1n4n1 5n2 3n3 4n5 6n\\" test_cases = parse_input(input_str) result = max_non_overlapping_trains(test_cases) assert result == [3] def test_edge_case_single_train(): input_str = \\"1n1n1 2n\\" test_cases = parse_input(input_str) result = max_non_overlapping_trains(test_cases) assert result == [1]","solution":"def max_non_overlapping_trains(test_cases): results = [] for trains in test_cases: # Sort trains by their departure times trains.sort(key=lambda x: x[1]) max_trains = 0 last_end_time = -1 for train in trains: if train[0] >= last_end_time: max_trains += 1 last_end_time = train[1] results.append(max_trains) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) trains = [] for i in range(N): Si, Ei = map(int, lines[index + 1 + i].split()) trains.append((Si, Ei)) test_cases.append(trains) index += N + 1 return test_cases"},{"question":"def is_magic_square(matrix: List[List[int]]) -> bool: Determines if a given matrix is a magic square. Args: matrix (list of list of int): A square matrix represented as a list of lists. Returns: bool: True if the matrix is a magic square, False otherwise. >>> is_magic_square([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) True >>> is_magic_square([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) False >>> is_magic_square([[5]]) True >>> is_magic_square([[16, 2, 3, 13], [5, 11, 10, 8], [9, 7, 6, 12], [4, 14, 15, 1]]) True >>> is_magic_square([[5, 6, 7, 8], [6, 7, 8, 5], [7, 8, 5, 6], [8, 5, 6, 7]]) False >>> is_magic_square([[1, 2], [3, 0]]) False >>> is_magic_square([[2, 2, 2], [3, 3, 3], [4, 4, 4]]) False >>> is_magic_square([[1, -1, 0], [-1, 1, -1], [0, -1, 1]]) False >>> is_magic_square([[1, 2, 3], [4, 1, 2], [3, 4, 1]]) False","solution":"def is_magic_square(matrix): Determines if a given matrix is a magic square. Args: matrix (list of list of int): A square matrix represented as a list of lists. Returns: bool: True if the matrix is a magic square, False otherwise. n = len(matrix) # Calculate the sum of the first row as reference target_sum = sum(matrix[0]) # Check sum of each row for row in matrix: if sum(row) != target_sum: return False # Check sum of each column for col in range(n): if sum(matrix[row][col] for row in range(n)) != target_sum: return False # Check sum of main diagonal if sum(matrix[i][i] for i in range(n)) != target_sum: return False # Check sum of anti-diagonal if sum(matrix[i][n - 1 - i] for i in range(n)) != target_sum: return False return True"},{"question":"def sum_two_largest(numbers: List[int]) -> int: Write a function that takes a list of integers and returns the sum of the two largest integers in the list. >>> sum_two_largest([10, 3, 5, 6]) == 16 >>> sum_two_largest([1, 2, 3, 4]) == 7 pass","solution":"def sum_two_largest(numbers): Returns the sum of the two largest integers in the list. if len(numbers) < 2: raise ValueError(\\"The input list must contain at least two integers.\\") sorted_numbers = sorted(numbers, reverse=True) return sorted_numbers[0] + sorted_numbers[1]"},{"question":"from typing import List def find_pair_with_sum(nums: List[int], target: int) -> List[int]: Given an array of integers, find a pair of elements that sum up to a given target value. If multiple pairs exist, return any one of them. Args: nums (List[int]): List of integers. target (int): Target sum. Returns: List[int]: A list of two integers that sum up to the target, or an empty list if no such pair exists. Examples: >>> find_pair_with_sum([2, 7, 11, 15], 9) [2, 7] >>> find_pair_with_sum([1, 2, 3, 4, 6], 8) [2, 6] >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) [] >>> find_pair_with_sum([-1, -2, -3, -4, 3], 0) [-3, 3] >>> find_pair_with_sum([], 5) [] >>> find_pair_with_sum([5], 5) [] >>> find_pair_with_sum([1, 3, 2, 4, 3, 5], 6) in [[1, 5], [2, 4]] True >>> find_pair_with_sum([5, 3, 5], 10) [5, 5]","solution":"def find_pair_with_sum(nums, target): Given a list of integers, returns a pair of elements that sum up to the target value. If multiple pairs exist, returns any one of them. seen = {} for num in nums: complement = target - num if complement in seen: return [min(num, complement), max(num, complement)] seen[num] = True return []"},{"question":"def rotate_list(nums: List[int], k: int) -> List[int]: Returns a new list with the elements of nums rotated to the right by k positions. >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], 3) [3, 4, 5, 1, 2] >>> rotate_list([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_list([1, 2, 3, 4, 5], 6) [5, 1, 2, 3, 4] >>> rotate_list([], 2) [] >>> rotate_list([1], 0) [1] >>> rotate_list([1], 1) [1] >>> rotate_list([1], 2) [1] >>> rotate_list([1, 2, 3, 4, 5], 10) [1, 2, 3, 4, 5] >>> rotate_list([1, 2, 3, 4, 5], 11) [5, 1, 2, 3, 4] >>> rotate_list([1, 2, 3, 4, 5], -1) [2, 3, 4, 5, 1] >>> rotate_list([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2]","solution":"def rotate_list(nums, k): Returns a new list with the elements of nums rotated to the right by k positions. if not nums: return [] k = k % len(nums) return nums[-k:] + nums[:-k]"},{"question":"def single_number(nums: List[int]) -> int: Finds the number that appears exactly once in an array where every other number appears three times. >>> single_number([2, 2, 3, 2]) 3 >>> single_number([0, 1, 0, 1, 0, 1, 99]) 99","solution":"def single_number(nums): Finds the number that appears exactly once in an array where every other number appears three times. :param nums: List[int] :return: int ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"def find_top_employee(work_hours): Given a list of employee working hours, find the employee who worked the most hours in a given week and the total hours they worked. If there is a tie, return all employees who worked the most hours. Parameters: work_hours (list): A list of dictionaries, each containing an employee's name and a list of their daily working hours from Monday to Sunday. Returns: list: A list of dictionaries, each containing the employee's name and their total working hours. Examples: >>> find_top_employee([{\\"name\\": \\"Alice\\", \\"hours\\": [8, 9, 8, 8, 10, 0, 0]}, {\\"name\\": \\"Bob\\", \\"hours\\": [10, 10, 10, 8, 10, 0, 0]}, {\\"name\\": \\"Charlie\\", \\"hours\\": [5, 5, 5, 5, 5, 5, 5]}]) [{\\"name\\": \\"Bob\\", \\"total_hours\\": 48}] >>> find_top_employee([{\\"name\\": \\"Alice\\", \\"hours\\": [8, 9, 8, 8, 10, 0, 0]}, {\\"name\\": \\"Bob\\", \\"hours\\": [8, 9, 8, 8, 10, 0, 0]}, {\\"name\\": \\"Charlie\\", \\"hours\\": [5, 5, 5, 5, 5, 5, 5]}]) [{\\"name\\": \\"Alice\\", \\"total_hours\\": 43}, {\\"name\\": \\"Bob\\", \\"total_hours\\": 43}] >>> find_top_employee([{\\"name\\": \\"Alice\\", \\"hours\\": [0, 0, 0, 0, 0, 0, 0]}]) [{\\"name\\": \\"Alice\\", \\"total_hours\\": 0}]","solution":"def find_top_employee(work_hours): Finds the employee(s) who worked the most hours in a given week and their total hours. Parameters: work_hours (list): A list of dictionaries, each containing an employee's name and a list of their daily working hours from Monday to Sunday. Returns: list: A list of dictionaries, each containing the employee's name and their total working hours. max_hours = 0 result = [] for employee in work_hours: total_hours = sum(employee[\\"hours\\"]) if total_hours > max_hours: max_hours = total_hours result = [{\\"name\\": employee[\\"name\\"], \\"total_hours\\": total_hours}] elif total_hours == max_hours: result.append({\\"name\\": employee[\\"name\\"], \\"total_hours\\": total_hours}) return result"},{"question":"def reorder_strings(strings): Rearrange strings with digits at the end of the list in-place. Args: strings (list of str): A list of alphanumeric strings. Returns: list of str: The modified list with strings containing digits moved to the end. Examples: >>> reorder_strings([\\"abc\\", \\"a1b\\", \\"123\\", \\"def\\"]) ['abc', 'def', 'a1b', '123'] >>> reorder_strings([\\"cat\\", \\"2dogs\\", \\"bird\\", \\"3mice\\"]) ['cat', 'bird', '2dogs', '3mice'] >>> reorder_strings([\\"x1y\\", \\"a2\\", \\"b3\\", \\"xyz\\"]) ['xyz', 'x1y', 'a2', 'b3'] pass # Unit Tests def test_reorder_strings_example1(): assert reorder_strings([\\"abc\\", \\"a1b\\", \\"123\\", \\"def\\"]) == ['abc', 'def', 'a1b', '123'] def test_reorder_strings_example2(): assert reorder_strings([\\"cat\\", \\"2dogs\\", \\"bird\\", \\"3mice\\"]) == ['cat', 'bird', '2dogs', '3mice'] def test_reorder_strings_example3(): assert reorder_strings([\\"x1y\\", \\"a2\\", \\"b3\\", \\"xyz\\"]) == ['xyz', 'x1y', 'a2', 'b3'] def test_reorder_strings_empty(): assert reorder_strings([]) == [] def test_reorder_strings_no_digits(): assert reorder_strings([\\"apple\\", \\"banana\\", \\"cherry\\"]) == [\\"apple\\", \\"banana\\", \\"cherry\\"] def test_reorder_strings_all_digits(): assert reorder_strings([\\"1apple\\", \\"2banana\\", \\"3cherry\\"]) == [\\"1apple\\", \\"2banana\\", \\"3cherry\\"] def test_reorder_strings_mixed(): assert reorder_strings([\\"123\\", \\"abc\\", \\"ab2c\\", \\"1a2b\\", \\"def\\"]) == [\\"abc\\", \\"def\\", \\"123\\", \\"ab2c\\", \\"1a2b\\"]","solution":"def reorder_strings(strings): Rearrange strings with digits at the end of the list in-place. Args: strings (list of str): A list of alphanumeric strings. Returns: list of str: The modified list with strings containing digits moved to the end. has_digit = lambda s: any(char.isdigit() for char in s) without_digits = [s for s in strings if not has_digit(s)] with_digits = [s for s in strings if has_digit(s)] return without_digits + with_digits"},{"question":"def intersect_sorted_arrays(array1: List[int], array2: List[int]) -> List[int]: Finds the intersection of two sorted integer arrays and returns the result as a new sorted array without duplicates. >>> intersect_sorted_arrays([1, 2, 2, 3, 4, 5], [2, 2, 3, 5, 6]) [2, 3, 5] >>> intersect_sorted_arrays([1, 3, 5], [2, 4, 6]) [] >>> intersect_sorted_arrays([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> intersect_sorted_arrays([1, 1, 2, 2, 3, 3, 4, 5], [1, 2, 2, 3, 3, 5, 5, 6]) [1, 2, 3, 5] >>> intersect_sorted_arrays([], []) [] >>> intersect_sorted_arrays([], [1, 2, 3, 4, 5]) [] >>> intersect_sorted_arrays([1, 2, 3, 4, 5], []) []","solution":"def intersectSortedArrays(array1, array2): Returns a sorted array of intersection elements between array1 and array2, without duplicates. i, j = 0, 0 result = [] while i < len(array1) and j < len(array2): if array1[i] == array2[j]: if not result or result[-1] != array1[i]: result.append(array1[i]) i += 1 j += 1 elif array1[i] < array2[j]: i += 1 else: j += 1 return result"},{"question":"def days_in_month(month: int, year: int) -> int: Returns the number of days in the given month of the given year. Accounts for leap years in February. Returns None if the month is invalid. >>> days_in_month(0, 2023) is None >>> days_in_month(13, 2023) is None >>> days_in_month(1, 2023) == 31 >>> days_in_month(2, 2023) == 28 >>> days_in_month(2, 2024) == 29 >>> days_in_month(2, 2000) == 29 >>> days_in_month(2, 1900) == 28 >>> days_in_month(4, 2023) == 30 >>> days_in_month(8, 2023) == 31 >>> days_in_month(12, 2023) == 31","solution":"def days_in_month(month, year): Returns the number of days in the given month of the given year. Accounts for leap years in February. Returns None if the month is invalid. if month < 1 or month > 12: return None if month == 2: # Check for leap year if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return 29 else: return 28 # Months with 31 days if month in [1, 3, 5, 7, 8, 10, 12]: return 31 # Months with 30 days return 30"},{"question":"def isPathExists(grid: List[List[int]]) -> bool: Determines if there is a path from the top-left corner to the bottom-right corner in a 2D grid while avoiding any obstacles. :param grid: List of Lists where each element is either 0 (path) or 1 (obstacle) :return: Boolean, True if a path exists, False otherwise >>> isPathExists([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) True >>> isPathExists([[0, 1], [1, 0]]) False >>> isPathExists([[0, 0, 0], [1, 1, 0], [0, 0, 0]]) True >>> isPathExists([[1]]) False >>> isPathExists([[0, 0], [0, 0]]) True >>> isPathExists([[0, 1], [0, 1], [0, 0]]) True","solution":"def isPathExists(grid): Determines if there is a path from the top-left corner to the bottom-right corner in a 2D grid while avoiding any obstacles. :param grid: List of Lists where each element is either 0 (path) or 1 (obstacle) :return: Boolean, True if a path exists, False otherwise if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False m, n = len(grid), len(grid[0]) directions = [(1, 0), (0, 1)] # possible moves: down, right visited = [[False] * n for _ in range(m)] visited[0][0] = True stack = [(0, 0)] while stack: x, y = stack.pop() if x == m - 1 and y == n - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and not visited[nx][ny]: visited[nx][ny] = True stack.append((nx, ny)) return False"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit achievable by buying and selling the stock once. :param prices: List of integers representing daily stock prices. :return: Maximum profit or 0 if no profit can be achieved.","solution":"def max_profit(prices): Returns the maximum profit achievable by buying and selling the stock once. :param prices: List of integers representing daily stock prices. :return: Maximum profit or 0 if no profit can be achieved. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def validate_isbn10(isbn: str) -> bool: Validates an ISBN-10 string. >>> validate_isbn10(\\"0471958697\\") True >>> validate_isbn10(\\"123456789X\\") True >>> validate_isbn10(\\"1234567890\\") False >>> validate_isbn10(\\"12345\\") False","solution":"def validate_isbn10(isbn: str) -> bool: Validates an ISBN-10 string. Args: isbn (str): The ISBN-10 string to validate. Returns: bool: True if the ISBN-10 is valid, False otherwise. if len(isbn) != 10: return False total = 0 for i in range(9): if not isbn[i].isdigit(): return False total += int(isbn[i]) * (10 - i) if isbn[9] == 'X': total += 10 elif isbn[9].isdigit(): total += int(isbn[9]) else: return False return total % 11 == 0"},{"question":"def caesar_cipher(s: str, n: int) -> str: Shifts each alphabetic character in the string s forward by n positions in the alphabet. Non-alphabetic characters remain unchanged. >>> caesar_cipher(\\"hello world\\", 3) == \\"khoor zruog\\" >>> caesar_cipher(\\"xyz\\", 3) == \\"abc\\" >>> caesar_cipher(\\"XYZ\\", 3) == \\"ABC\\" >>> caesar_cipher(\\"a b c\\", 1) == \\"b c d\\" >>> caesar_cipher(\\"HELLO WORLD\\", 5) == \\"MJQQT BTWQI\\" >>> caesar_cipher(\\"Hello World\\", 5) == \\"Mjqqt Btwqi\\" >>> caesar_cipher(\\"No Shift\\", 0) == \\"No Shift\\" >>> caesar_cipher(\\"Full Shift\\", 26) == \\"Full Shift\\"","solution":"def caesar_cipher(s: str, n: int) -> str: Shifts each alphabetic character in the string s forward by n positions in the alphabet. Non-alphabetic characters remain unchanged. result = [] for char in s: if char.isalpha(): shift = ord('A') if char.isupper() else ord('a') result.append(chr(shift + (ord(char) - shift + n) % 26)) else: result.append(char) return \\"\\".join(result)"},{"question":"def can_form_palindrome(S: str) -> str: Alice is working on a new project to analyze substrings of a given string. She wants to find if there exists a substring that can be rearranged to form a palindrome. A palindrome is a word that reads the same backward as forward, such as \\"level\\" or \\"radar\\". Write a function to help Alice determine if there is a substring of the given string that can be rearranged to form a palindrome. -----Input----- - The input contains a single line with a string S made up of lowercase English letters. -----Output----- Print \\"YES\\" if there exists any substring that can be rearranged to form a palindrome, and \\"NO\\" otherwise. -----Constraints----- - 1 leq |S| leq 10^5 -----Examples----- -----Example 1----- Input: carrace Output: YES -----Example 2----- Input: abc Output: NO -----Example 3----- Input: a Output: YES >>> can_form_palindrome(\\"carrace\\") == \\"YES\\" >>> can_form_palindrome(\\"abc\\") == \\"NO\\" >>> can_form_palindrome(\\"a\\") == \\"YES\\" >>> can_form_palindrome(\\"aaaaa\\") == \\"YES\\" >>> can_form_palindrome(\\"aabbcc\\") == \\"YES\\" >>> can_form_palindrome(\\"aaabbcc\\") == \\"YES\\" >>> can_form_palindrome(\\"abcdef\\") == \\"NO\\" >>> can_form_palindrome(\\"aaa\\") == \\"YES\\" >>> can_form_palindrome(\\"a\\" * 100000) == \\"YES\\"","solution":"def can_form_palindrome(S): Returns \\"YES\\" if there exists any substring of S that can be rearranged to form a palindrome, and \\"NO\\" otherwise. from collections import Counter # Count frequency of each character char_count = Counter(S) # Palindrome can have at most one character with an odd frequency odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # If more than one character has an odd frequency, it cannot form a palindrome if odd_count > 1: return \\"NO\\" else: return \\"YES\\""},{"question":"planet_distances = { 'mercury': 0.39, 'venus': 0.72, 'earth': 1.00, 'mars': 1.52, 'jupiter': 5.20, 'saturn': 9.58, 'uranus': 19.22, 'neptune': 30.05, 'pluto': 39.48 } def distance_between_planets(planet_a, planet_b): Returns the distance between two planets in astronomical units (AU). Handles invalid inputs by returning an error message. Parameters: planet_a (str): The name of the first planet. planet_b (str): The name of the second planet. Returns: float or str: The distance in AU between the two planets or an error message. >>> distance_between_planets('earth', 'mars') 0.52 >>> distance_between_planets('jupiter', 'neptune') 24.85 >>> distance_between_planets('mars', 'pluto') 37.96 >>> distance_between_planets('earth', 'jupyter') \\"Error: One or both planet names are not in the database.\\" >>> distance_between_planets(123, 'venus') \\"Error: Both inputs must be strings representing planet names.\\"","solution":"planet_distances = { 'mercury': 0.39, 'venus': 0.72, 'earth': 1.00, 'mars': 1.52, 'jupiter': 5.20, 'saturn': 9.58, 'uranus': 19.22, 'neptune': 30.05, 'pluto': 39.48 } def distance_between_planets(planet_a, planet_b): Returns the distance between two planets in astronomical units (AU). Handles invalid inputs by returning an error message. Parameters: planet_a (str): The name of the first planet. planet_b (str): The name of the second planet. Returns: float or str: The distance in AU between the two planets or an error message. if not isinstance(planet_a, str) or not isinstance(planet_b, str): return \\"Error: Both inputs must be strings representing planet names.\\" planet_a = planet_a.lower() planet_b = planet_b.lower() if planet_a not in planet_distances or planet_b not in planet_distances: return \\"Error: One or both planet names are not in the database.\\" distance = abs(planet_distances[planet_a] - planet_distances[planet_b]) return distance"},{"question":"def max_sum_of_subarray(arr, k): Finds the maximum sum of k consecutive elements in the array. >>> max_sum_of_subarray([1, 3, -1, -3, 5, 3, 6, 7], 3) 16 >>> max_sum_of_subarray([2, 1, 5, 1, 3, 2], 2) 6 >>> max_sum_of_subarray([5], 1) 5 >>> max_sum_of_subarray([5, -3, 4], 1) 5 >>> max_sum_of_subarray([-1, -2, -3, -4, -5], 2) -3 >>> max_sum_of_subarray([-1, -2, -3, 4, 5], 3) 6 >>> max_sum_of_subarray([1, 2, 3, 4, 5], 5) 15 >>> max_sum_of_subarray([1, 2, 3, 4, 5], 0) 0 >>> max_sum_of_subarray([1, 2, 3, 4, 5], 6) 0 >>> max_sum_of_subarray([], 1) 0","solution":"def max_sum_of_subarray(arr, k): Finds the maximum sum of k consecutive elements in the array. if not arr or k <= 0 or k > len(arr): return 0 max_sum = current_sum = sum(arr[:k]) for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def longest_arith_seq_length(A: List[int]) -> int: Given a non-empty array of integers, return the length of the longest subsequence that forms an arithmetic progression. An arithmetic progression is a sequence of numbers in which the difference between any two consecutive numbers is the same. >>> longest_arith_seq_length([3, 6, 9, 12]) 4 >>> longest_arith_seq_length([9, 4, 7, 2, 10]) 3 >>> longest_arith_seq_length([20, 1, 15, 3, 10, 5, 8]) 4","solution":"def longest_arith_seq_length(A): if not A: return 0 n = len(A) if n == 1: return 1 # Create a dictionary to store the length of arithmetic sequences. # dp[i][d] means the length of arithmetic subsequence ending with A[i] and common difference d dp = [{} for _ in range(n)] max_length = 0 for i in range(n): for j in range(i): diff = A[i] - A[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"from typing import List def findLongestCompoundWord(words: List[str]) -> str: You are given an array of strings where no string is a prefix of another string. Your task is to write a function that finds the longest string in the array which can be composed of at least two other strings from the array. Examples: >>> findLongestCompoundWord([\\"cat\\", \\"cats\\", \\"catsdogcats\\", \\"dog\\", \\"dogcatsdog\\", \\"hippopotamuses\\", \\"rat\\", \\"ratcatdogcat\\"]) \\"ratcatdogcat\\" >>> findLongestCompoundWord([\\"hippo\\", \\"potamus\\", \\"hippopotamus\\"]) \\"hippopotamus\\" >>> findLongestCompoundWord([\\"this\\", \\"is\\", \\"an\\", \\"example\\"]) \\"\\" pass","solution":"from typing import List def findLongestCompoundWord(words: List[str]) -> str: words_set = set(words) def can_form(word, isOriginal): if word in words_set and not isOriginal: return True for i in range(1, len(word)): prefix = word[:i] suffix = word[i:] if prefix in words_set and can_form(suffix, False): return True return False longest_word = \\"\\" for word in words: if can_form(word, True) and len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"from typing import List def is_magic_square(matrix: List[List[int]]) -> bool: Check if a given matrix is a magic square. A magic square is a square matrix in which the sum of every row, column, and diagonal is the same. >>> matrix_1 = [ ... [2, 7, 6], ... [9, 5, 1], ... [4, 3, 8] ... ] >>> is_magic_square(matrix_1) True >>> matrix_2 = [ ... [3, 5, 7], ... [8, 1, 6], ... [4, 9, 2] ... ] >>> is_magic_square(matrix_2) False >>> matrix_3 = [[1]] >>> is_magic_square(matrix_3) True >>> matrix_4 = [ ... [16, 2, 3, 13], ... [ 5, 11, 10, 8], ... [ 9, 7, 6, 12], ... [ 4, 14, 15, 1] ... ] >>> is_magic_square(matrix_4) True >>> matrix_5 = [ ... [2, 7, 6], ... [9, 5, 2], ... [4, 3, 8] ... ] >>> is_magic_square(matrix_5) False >>> matrix_6 = [ ... [2, 7, 6], ... [9, 3, 1], ... [4, 5, 8] ... ] >>> is_magic_square(matrix_6) False >>> matrix_7 = [ ... [2, 7, 6], ... [9, 5, 1], ... [4, 9, 8] ... ] >>> is_magic_square(matrix_7) False","solution":"from typing import List def is_magic_square(matrix: List[List[int]]) -> bool: n = len(matrix) # Calculate the sum of the first row to use as the target sum target_sum = sum(matrix[0]) # Check sum of all rows for row in matrix: if sum(row) != target_sum: return False # Check sum of all columns for col in range(n): col_sum = sum(matrix[row][col] for row in range(n)) if col_sum != target_sum: return False # Check sum of the main diagonal main_diagonal_sum = sum(matrix[i][i] for i in range(n)) if main_diagonal_sum != target_sum: return False # Check sum of the secondary diagonal secondary_diagonal_sum = sum(matrix[i][n - i - 1] for i in range(n)) if secondary_diagonal_sum != target_sum: return False return True"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates a given NxN matrix 90 degrees clockwise in place. Args: matrix (List[List[int]]): A square matrix represented as a list of lists Example Usage: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] pass def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def test_rotate_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotate_matrix(matrix) assert matrix == [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] def test_rotate_1x1_matrix(): matrix = [ [1] ] rotate_matrix(matrix) assert matrix == [ [1] ] def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] rotate_matrix(matrix) assert matrix == [ [3, 1], [4, 2] ]","solution":"def rotate_matrix(matrix): Rotates the given NxN matrix 90 degrees clockwise in place. n = len(matrix) for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first top = matrix[first][i] # save top # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top"},{"question":"def longest_balanced_substring(s: str) -> int: Find the length of the longest balanced substring. A balanced substring contains equal number of 'a's and 'b's. Args: s (str): The input string containing only 'a's and 'b's. Returns: int: The length of the longest balanced substring. Examples: >>> longest_balanced_substring(\\"ababbb\\") 4 >>> longest_balanced_substring(\\"aaaa\\") 0 >>> longest_balanced_substring(\\"abababbaaab\\") 10 from solution import longest_balanced_substring def test_example_1(): assert longest_balanced_substring(\\"ababbb\\") == 4 def test_example_2(): assert longest_balanced_substring(\\"aaaa\\") == 0 def test_example_3(): assert longest_balanced_substring(\\"abababbaaab\\") == 10 def test_mixed_case_1(): assert longest_balanced_substring(\\"aabbab\\") == 6 def test_mixed_case_2(): assert longest_balanced_substring(\\"baba\\") == 4 def test_single_char_cases(): assert longest_balanced_substring(\\"a\\") == 0 assert longest_balanced_substring(\\"b\\") == 0 def test_large_balanced_substring_at_end(): assert longest_balanced_substring(\\"aaaaababab\\") == 6 def test_only_as_followed_by_bs(): assert longest_balanced_substring(\\"aaaabbbb\\") == 8 def test_disjoint_balanced_substrings(): assert longest_balanced_substring(\\"aabbaabb\\") == 8","solution":"def longest_balanced_substring(s): Returns the length of the longest balanced substring, where a balanced substring contains equal number of 'a's and 'b's. max_length = 0 counter = 0 index_map = {0: -1} # To handle the case when the whole substring from start is balanced for i, char in enumerate(s): if char == 'a': counter -= 1 else: counter += 1 if counter in index_map: max_length = max(max_length, i - index_map[counter]) else: index_map[counter] = i return max_length"},{"question":"def kth_smallest(nums: List[int], k: int) -> int: Given an integer array nums and an integer k, find the k-th smallest element in the array. >>> kth_smallest([7, 10, 4, 3, 20, 15], 3) 7 >>> kth_smallest([1, 2, 3, 4, 5], 1) 1 >>> kth_smallest([1, 2, 3, 4, 5], 5) 5 >>> kth_smallest([3, 1, 2, 5, 4], 2) 2 >>> kth_smallest([3, 2, 1, 5, 4], 4) 4 >>> kth_smallest([3, 1, 2, 2, 3], 3) 2 >>> kth_smallest([5, 3, 1, 1, 2, 2, 3], 4) 2 >>> kth_smallest([42], 1) 42","solution":"def kth_smallest(nums, k): Returns the k-th smallest element in the given array nums. nums.sort() return nums[k - 1]"},{"question":"def min_subscriptions(n, d, favourites): Calculate the minimum number of subscriptions required to ensure that within any period of d consecutive days, you can read all your favourite articles at least once. Args: n (int): The number of articles. d (int): The number of days within which you need to read all favourite articles. favourites (List[int]): List of favourite article IDs. Returns: int: Minimum number of subscriptions required. Example: >>> min_subscriptions(5, 2, [1, 2, 3, 2, 1]) 3 >>> min_subscriptions(6, 3, [3, 3, 2, 2, 1, 1]) 3 >>> min_subscriptions(4, 4, [2, 4, 4, 6]) 3 def solve(test_cases): Process a list of test cases calculating the required number of subscriptions for each case. Args: test_cases (List[Tuple[int, int, List[int]]]): List of test case tuples where each tuple contains (n, d, favourites). Returns: List[int]: List of results where each result corresponds to the minimum subscriptions required for each test case. results = [] for case in test_cases: n, d, favourites = case results.append(min_subscriptions(n, d, favourites)) return results def main(input_text): Main function to process input text, parse it, and produce the required output. Args: input_text (str): Multi-line string containing the input test cases. Returns: List[int]: The results to be printed. lines = input_text.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n, d = map(int, lines[index].split()) favourites = list(map(int, lines[index + 1].split())) test_cases.append((n, d, favourites)) index += 2 return solve(test_cases) def test_min_subscriptions(): # (number of articles, days, list of favourite articles) assert min_subscriptions(5, 2, [1, 2, 3, 2, 1]) == 3 assert min_subscriptions(6, 3, [3, 3, 2, 2, 1, 1]) == 3 assert min_subscriptions(4, 4, [2, 4, 4, 6]) == 3 assert min_subscriptions(8, 3, [1, 2, 1, 2, 1, 2, 1, 2]) == 2 def test_solve(): input_text = 3 5 2 1 2 3 2 1 6 3 3 3 2 2 1 1 4 4 2 4 4 6 expected_output = [3, 3, 3] assert main(input_text) == expected_output def test_main(): input_text = 3 5 2 1 2 3 2 1 6 3 3 3 2 2 1 1 4 4 2 4 4 6 output = main(input_text) expected_output = [3, 3, 3] assert output == expected_output","solution":"def min_subscriptions(n, d, favourites): from collections import Counter # Count frequency of each article ID freq = Counter(favourites) # Calculate the minimum number of subscriptions return len(freq) def solve(test_cases): results = [] for case in test_cases: n, d, favourites = case results.append(min_subscriptions(n, d, favourites)) return results # Test cases processing def main(input_text): lines = input_text.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n, d = map(int, lines[index].split()) favourites = list(map(int, lines[index + 1].split())) test_cases.append((n, d, favourites)) index += 2 return solve(test_cases)"},{"question":"def double_array(arr: List[int]) -> List[int]: Given an array of integers, returns a new array with each element doubled. >>> double_array([1, 2, 3, 4]) [2, 4, 6, 8] >>> double_array([-1, -2, -3, -4]) [-2, -4, -6, -8] >>> double_array([-1, 2, -3, 4]) [-2, 4, -6, 8] >>> double_array([0, 2, 0, 4]) [0, 4, 0, 8] >>> double_array([]) []","solution":"def double_array(arr): Given an array of integers, returns a new array with each element doubled. return [2 * x for x in arr]"},{"question":"def calculateMedian(nums: List[Union[int, float]]) -> Union[int, float, None]: Returns the median of the list of numbers. If the list is empty, returns None. >>> calculateMedian([1, 3, 2, 4]) 2.5 >>> calculateMedian([2, 5, 1, 3, 4]) 3 >>> calculateMedian([-3, -1, -4, -1]) -1.5 >>> calculateMedian([]) None","solution":"def calculateMedian(nums): Returns the median of the list of numbers. If the list is empty, returns None. if not nums: return None nums.sort() n = len(nums) mid = n // 2 if n % 2 == 0: return (nums[mid - 1] + nums[mid]) / 2 else: return nums[mid]"},{"question":"def reverse_digits(n: int) -> list: Write a function that takes a positive integer and returns a list of its digits in reverse order. The return value should be a list of integers. Example: >>> reverse_digits(12345) # should return [5, 4, 3, 2, 1] >>> reverse_digits(7) # should return [7] >>> reverse_digits(10203) # should return [3, 0, 2, 0, 1] >>> reverse_digits(9876543210) # should return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> reverse_digits(11111) # should return [1, 1, 1, 1, 1]","solution":"def reverse_digits(n): Returns the digits of the positive integer n in reverse order. reversed_digits = [int(digit) for digit in str(n)[::-1]] return reversed_digits"},{"question":"from typing import List def can_form_consecutive_sequence(arr: List[int]) -> bool: Determine if the elements of the array can be rearranged to form a sequence of consecutive numbers. >>> can_form_consecutive_sequence([5, 4, 2, 3, 1]) == True >>> can_form_consecutive_sequence([1, 3, 4, 5]) == False >>> can_form_consecutive_sequence([1]) == True >>> can_form_consecutive_sequence([5, 4, 3, 2, 1]) == True >>> can_form_consecutive_sequence([10, 12]) == False >>> can_form_consecutive_sequence([1, 2, 2, 3]) == False >>> can_form_consecutive_sequence([]) == False","solution":"def can_form_consecutive_sequence(arr): Determine if the elements of the array can be rearranged to form a sequence of consecutive numbers. :param arr: List of integers. :return: Boolean indicating if the elements can be rearranged to form a consecutive sequence. if not arr: return False min_val = min(arr) max_val = max(arr) # Check if the length of the range of values matches the length of the array return len(arr) == (max_val - min_val + 1)"},{"question":"def prime_factors_count(n: int, k: int) -> str: Determine if the number of unique prime factors of \`n\` is greater than or equal to \`k\`. >>> prime_factors_count(30, 3) == \\"Yes\\" >>> prime_factors_count(12, 2) == \\"Yes\\" >>> prime_factors_count(17, 1) == \\"Yes\\" >>> prime_factors_count(1000000, 4) == \\"No\\" >>> prime_factors_count(13, 2) == \\"No\\" def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[str]: Process multiple test cases. >>> test_cases = [ ... (30, 3), ... (12, 2), ... (17, 1), ... (1000000, 4), ... (13, 2) ... ] >>> expected_results = [\\"Yes\\", \\"Yes\\", \\"Yes\\", \\"No\\", \\"No\\"] >>> assert process_test_cases(test_cases) == expected_results","solution":"def prime_factors_count(n, k): Returns \\"Yes\\" if the number of unique prime factors of n is greater than or equal to k, otherwise \\"No\\". def prime_factors(number): Returns a set of unique prime factors of the given number. factors = set() # Check for number of twos in the factorization while number % 2 == 0: factors.add(2) number //= 2 # Check for odd factors for i in range(3, int(number**0.5) + 1, 2): while number % i == 0: factors.add(i) number //= i # If number is prime and greater than 2 if number > 2: factors.add(number) return factors # Calculate the number of unique prime factors unique_prime_factors = prime_factors(n) # Compare the number of unique prime factors with k if len(unique_prime_factors) >= k: return \\"Yes\\" else: return \\"No\\" def process_test_cases(test_cases): Process multiple test cases. results = [] for n, k in test_cases: results.append(prime_factors_count(n, k)) return results"},{"question":"def calculate(expression: str) -> int: Evaluate a mathematical expression and return the result as an integer. The expression may contain non-negative integers, '+', '-', '*', '/' operators, and spaces. The operators follow standard precedence rules, and division is integer division. Parameters: expression (str): The string representing the mathematical expression. Returns: int: The result of the evaluated expression. Examples: >>> calculate(\\"3+2*2\\") 7 >>> calculate(\\" 3/2 \\") 1 >>> calculate(\\"3+5/2\\") 5 >>> calculate(\\"14-3/2\\") 13 pass from solution import calculate def test_simple_addition(): assert calculate(\\"3+2\\") == 5 def test_simple_subtraction(): assert calculate(\\"3-2\\") == 1 def test_simple_multiplication(): assert calculate(\\"3*2\\") == 6 def test_simple_division(): assert calculate(\\"3/2\\") == 1 def test_combined_operations(): assert calculate(\\"3+2*2\\") == 7 assert calculate(\\"3-2*2\\") == -1 assert calculate(\\"3+5/2\\") == 5 assert calculate(\\"3+6/2\\") == 6 def test_with_spaces(): assert calculate(\\" 3/2 \\") == 1 assert calculate(\\" 3 + 5 / 2 \\") == 5 assert calculate(\\" 3 + 2 * 2 \\") == 7 def test_large_number(): assert calculate(\\"10+20*3/2-5\\") == 35 def test_all_operators(): assert calculate(\\"5+6*7-8/2\\") == 43 def test_order_of_operations(): assert calculate(\\"2*3+5\\") == 11 assert calculate(\\"5+3*2\\") == 11","solution":"def calculate(expression: str) -> int: def parse_expression(expression): tokens = [] number = 0 has_number = False for char in expression: if char.isdigit(): number = number * 10 + int(char) has_number = True else: if has_number: tokens.append(number) number = 0 has_number = False if char in \\"+-*/\\": tokens.append(char) if has_number: tokens.append(number) return tokens def evaluate_tokens(tokens): stack = [] current_operator = '+' i = 0 while i < len(tokens): token = tokens[i] if isinstance(token, int): if current_operator == '+': stack.append(token) elif current_operator == '-': stack.append(-token) elif current_operator == '*': stack[-1] = stack[-1] * token elif current_operator == '/': stack[-1] = int(stack[-1] / token) else: current_operator = token i += 1 return sum(stack) tokens = parse_expression(expression.replace(' ', '')) return evaluate_tokens(tokens)"},{"question":"def generate_permutations(s: str) -> list: Generate all unique permutations of the input string in lexicographic order. Parameters: s (str): The input string Returns: list: A list of unique permutations in lexicographic order >>> generate_permutations(\\"abc\\") [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> generate_permutations(\\"aab\\") [\\"aab\\", \\"aba\\", \\"baa\\"] # Your code here from itertools import permutations def test_generate_permutations_normal_case(): assert generate_permutations(\\"abc\\") == [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] def test_generate_permutations_with_duplicates(): assert generate_permutations(\\"aab\\") == [\\"aab\\", \\"aba\\", \\"baa\\"] def test_generate_permutations_single_character(): assert generate_permutations(\\"a\\") == [\\"a\\"] def test_generate_permutations_empty_string(): assert generate_permutations(\\"\\") == [\\"\\"] def test_generate_permutations_all_same_characters(): assert generate_permutations(\\"aaa\\") == [\\"aaa\\"]","solution":"from itertools import permutations def generate_permutations(s): Generate all unique permutations of the input string in lexicographic order. Parameters: s (str): The input string Returns: list: A list of unique permutations in lexicographic order # Generate all permutations using itertools.permutations perms = permutations(s) # Use a set to ensure uniqueness unique_perms = set(perms) # Convert tuples back to strings and sort them lexicographically sorted_perms = sorted([''.join(p) for p in unique_perms]) return sorted_perms"}]`),S={name:"App",components:{PoemCard:N},data(){return{searchQuery:"",visibleCount:4,poemsData:C,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},F={class:"card-container"},E={key:0,class:"empty-state"},z=["disabled"],P={key:0},I={key:1};function D(n,e,u,m,i,a){const f=p("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):l("",!0)]),t("div",F,[(s(!0),r(x,null,y(a.displayedPoems,(o,h)=>(s(),w(f,{key:h,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",E,' No results found for "'+d(i.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),r("span",I,"Loading...")):(s(),r("span",P,"See more"))],8,z)):l("",!0)])}const M=_(S,[["render",D],["__scopeId","data-v-3a38cb04"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/58.md","filePath":"grok/58.md"}'),Y={name:"grok/58.md"},W=Object.assign(Y,{setup(n){return(e,u)=>(s(),r("div",null,[v(M)]))}});export{O as __pageData,W as default};
