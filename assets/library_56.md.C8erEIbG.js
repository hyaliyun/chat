import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as y,U as _,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},N={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",N,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const E=c(k,[["render",A],["__scopeId","data-v-4442257a"]]),O=JSON.parse('[{"question":"# Context In a given text-based data pipeline, a common task is to ensure data consistency by checking if certain strings are valid palindromes. A palindrome is a sequence that reads the same backward as forward, ignoring spaces, punctuation, and case. Your task is to verify if a given string qualifies as a palindrome by implementing an algorithm to do so efficiently. # Task Write a function `validate_palindrome(s: str) -> bool` that verifies whether a given string `s` is a valid palindrome according to given rules. # Input - A string `s` (0 ≤ |s| ≤ 10^5), where |s| represents the length of the string. # Output - Return `True` if the string `s` is a palindrome, `False` otherwise. # Constraints - The function should handle all alphanumeric characters. - The function should be case-insensitive. - Non-alphanumeric characters should be ignored. # Requirements: - You should not use extra space proportional to the size of the input (consider in-place algorithms). # Example: ```python def validate_palindrome(s: str) -> bool: # Implement your function here # Example cases print(validate_palindrome(\\"A man, a plan, a canal: Panama\\")) # True print(validate_palindrome(\\"race a car\\")) # False print(validate_palindrome(\\"\\")) # True print(validate_palindrome(\\" \\")) # True print(validate_palindrome(\\"0P\\")) # False ``` # Notes: - An empty string or string with only non-alphanumeric characters should return `True` as per the definition of a palindrome.","solution":"def validate_palindrome(s: str) -> bool: This function checks if the given string is a valid palindrome ignoring cases, spaces, and non-alphanumeric characters. l, r = 0, len(s) - 1 while l < r: # Move l to the next alphanumeric character while l < r and not s[l].isalnum(): l += 1 # Move r to the previous alphanumeric character while l < r and not s[r].isalnum(): r -= 1 # Check if the characters are equal (case-insensitive) if s[l].lower() != s[r].lower(): return False l += 1 r -= 1 return True"},{"question":"You are tasked with creating a utility function that determines the number of digits in a given non-negative integer. Given how critical performance can be, your solution should ensure constant time complexity. **Function Signature** ```python def number_of_digits(n: int) -> int: ``` # Input * `n` - A non-negative integer (0 ≤ n ≤ 10^100) # Output * Return the number of digits in the integer n. # Constraints * You must ensure your function has a time complexity of O(1). * Handle edge cases where `n` is zero, and large numbers adequately. * Do not use standard library functions that automatically convert the number to string to count its length. # Example ```python assert number_of_digits(0) == 1 assert number_of_digits(5) == 1 assert number_of_digits(12345) == 5 ``` # Notes Your implementation should handle very large numbers efficiently using the constraints provided. Also ensure to properly manage any edge cases that could lead to errors or incorrect results.","solution":"def number_of_digits(n: int) -> int: Returns the number of digits in the integer n. if n == 0: return 1 return len(str(n))"},{"question":"# RandomizedSet Implementation In this task, you\'ll implement a data structure named `RandomizedSet` that supports insertion, deletion, and random element retrieval operations in average O(1) time complexity. The structure ensures that each element has an equal probability of being selected when retrieving a random element. Requirements 1. **Function Signature** - `def __init__(self):` Initializes the data structure. - `def insert(self, val: int) -> None:` Inserts an item `val` to the set if it is not already present. - `def remove(self, val: int) -> None:` Removes an item `val` from the set if it is present. - `def random_element(self) -> int:` Returns a random element from the current set of elements. 2. **Examples** ```python randomized_set = RandomizedSet() randomized_set.insert(1) # Inserts 1 randomized_set.remove(2) # Does nothing since 2 is not present randomized_set.insert(2) # Inserts 2 print(randomized_set.random_element()) # Should return either 1 or 2 randomly with equal probability randomized_set.remove(1) # Removes 1 print(randomized_set.random_element()) # Should return 2, as 2 is the only element present ``` 3. **Constraints** - The elements to be inserted or removed will be integers within the range `-10^6` to `10^6`. - It is guaranteed that `random_element` will only be called when there is at least one element in the set. Implement the `RandomizedSet` class as described.","solution":"import random class RandomizedSet: def __init__(self): Initialize your data structure here. self.dict = {} self.list = [] def insert(self, val: int) -> bool: Inserts a value to the set. Returns True if the set did not already contain the specified element. if val in self.dict: return False self.dict[val] = len(self.list) self.list.append(val) return True def remove(self, val: int) -> bool: Removes a value from the set. Returns True if the set contained the specified element. if val not in self.dict: return False # Move the last element to the place of the element to delete last_element = self.list[-1] idx = self.dict[val] self.list[idx] = last_element self.dict[last_element] = idx # Remove the last element self.list.pop() del self.dict[val] return True def random_element(self) -> int: Get a random element from the set. return random.choice(self.list)"},{"question":"Implement a Doubly Linked List with Specific Operations **Context**: You are required to design and implement a Doubly Linked List to support a small text editor\'s undo functionality. Your implementation needs to support the following operations efficiently: 1. Adding a character to the text. 2. Deleting the most recently added character. 3. Displaying the text. # Function Signature ```python class DoublyLinkedListNode: A node in a doubly linked list. def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): Initialize an empty doubly linked list. self.head = None self.tail = None def add_character(self, char: str) -> None: Add a character to the end of the text. Parameters: char (str): The character to be added. Returns: None pass def delete_character(self) -> bool: Delete the most recently added character from the text. Returns: bool: True if a character was successfully deleted, False if the text was already empty. pass def display_text(self) -> str: Display the current text. Returns: str: The current text as a single string. pass ``` # Input and Output Formats - **add_character(char: str)**: Takes a single character string as input and adds it to the end of the text. - **delete_character()**: Removes the most recently added character and returns `True`. If the text is empty, returns `False`. - **display_text()**: Returns the current state of the text as a single concatenated string. # Constraints - The function `add_character` will be called with exactly one character each time. # Example: ```python dll = DoublyLinkedList() dll.add_character(\'a\') dll.add_character(\'b\') dll.add_character(\'c\') print(dll.display_text()) # Output: \\"abc\\" dll.delete_character() print(dll.display_text()) # Output: \\"ab\\" ``` # Performance Requirements - Efficient handling of add and delete operations, i.e., should operate in constant time: O(1).","solution":"class DoublyLinkedListNode: A node in a doubly linked list. def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): Initialize an empty doubly linked list. self.head = None self.tail = None def add_character(self, char: str) -> None: Add a character to the end of the text. Parameters: char (str): The character to be added. Returns: None new_node = DoublyLinkedListNode(char) if self.tail is None: # Empty list self.head = new_node self.tail = new_node else: # Add to the end new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_character(self) -> bool: Delete the most recently added character from the text. Returns: bool: True if a character was successfully deleted, False if the text was already empty. if self.tail is None: return False if self.head == self.tail: # Only one element in the list self.head = None self.tail = None else: # Remove the last element self.tail = self.tail.prev self.tail.next = None return True def display_text(self) -> str: Display the current text. Returns: str: The current text as a single string. current = self.head result = [] while current is not None: result.append(current.value) current = current.next return \\"\\".join(result)"},{"question":"You are given a directed graph represented as an adjacency list, and two nodes `A` and `B`. Your task is to implement three functions: 1. `find_path(graph, start, end)`: - Find any path from the `start` node to the `end` node. - If such a path does not exist, return `None`. 2. `find_all_paths(graph, start, end)`: - Find all possible paths from the `start` node to the `end` node. - If no paths exist, return an empty list. 3. `find_shortest_path(graph, start, end)`: - Find the shortest path from the `start` node to the `end` node. - If such a path does not exist, return `None`. # Input Format: - `graph`: a dictionary representing an adjacency list of a directed graph. (`graph[node]` is a list of adjacent nodes). - `start`, `end`: strings representing the start and end nodes, respectively. # Output Format: - The output for `find_path` and `find_shortest_path` is a list of nodes representing the path from the start to the end. - The output for `find_all_paths` is a list of lists, where each list represents a valid path from the start to the end. # Constraints: - Assume all nodes are unique. - Consider the graph may have cycles. - Node values are case-sensitive strings. # Performance Requirements: - Aim for the smallest possible runtime complexity while considering possible optimizations. - Ensure the implementation can handle up to `10^3` nodes and `10^4` edges efficiently. # Examples: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [], \'E\': [\'F\'], \'F\': [] } print(find_path(graph, \'A\', \'F\')) # Example output: [\'A\', \'B\', \'E\', \'F\'] print(find_all_paths(graph, \'A\', \'F\')) # Example output: [[\'A\', \'B\', \'E\', \'F\'], [\'A\', \'C\', \'F\']] print(find_shortest_path(graph, \'A\', \'F\')) # Example output: [\'A\', \'C\', \'F\'] ``` # Note: - Ensure that your code handles edge cases such as: - No path exists between the `start` and `end`. - The `start` node equals the `end` node. - The `start` or `end` node does not exist in the graph. - Cyclic paths within the graph.","solution":"def find_path(graph, start, end, path=None): if path is None: path = [] path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: new_path = find_path(graph, node, end, path) if new_path: return new_path return None def find_all_paths(graph, start, end, path=None): if path is None: path = [] path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: new_paths = find_all_paths(graph, node, end, path) for new_path in new_paths: paths.append(new_path) return paths from collections import deque def find_shortest_path(graph, start, end): if start == end: return [start] visited = {start} queue = deque([(start, [start])]) while queue: (node, path) = queue.popleft() for adjacent in graph.get(node, []): if adjacent not in visited: if adjacent == end: return path + [adjacent] visited.add(adjacent) queue.append((adjacent, path + [adjacent])) return None"},{"question":"# Next Higher Number with Same Digits **Objective**: Implement a function to find the next higher number that can be formed using the exact same digits of a given number. If no such number exists, return -1. **Function Signature**: ```python def next_bigger(num: int) -> int: ``` # Description Given a number, find the next higher number that can be formed by rearranging its digits. If it\'s not possible to form any higher number with the same set of digits, return -1. # Input * A single integer `num` (1 ≤ `num` ≤ 10^9) # Output * Return an integer representing the next higher number or -1 if no such number exists. # Examples * `next_bigger(38276)` should return `38627` * `next_bigger(99999)` should return `-1` * `next_bigger(54321)` should return `-1` * `next_bigger(1528452)` should return `1528524` # Constraints * The number will be a positive integer. * The function should handle numbers up to 10^9 efficiently. # Requirements * The function must run in O(n) time complexity. * The function must be implemented efficiently without unnecessary memory usage. # Implementation Details Ensure to handle the edge cases: * If the digits are in descending order. * If all digits are the same. **Task**: Implement the `next_bigger` function to meet the above requirements and pass the provided tests.","solution":"def next_bigger(num: int) -> int: digits = list(str(num)) n = len(digits) # Step 1: Find the pivot, the point (from right) where the next digit is larger for i in range(n-2, -1, -1): if digits[i] < digits[i + 1]: break else: # No such pivot found, all digits are in non-increasing order return -1 # Step 2: Find the smallest digit on the right of the pivot which is larger than the pivot for j in range(n-1, i, -1): if digits[j] > digits[i]: break # Step 3: Swap the pivot and the smallest digit larger than the pivot digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits to the right of the pivot digits = digits[:i + 1] + digits[i + 1:][::-1] # Convert list of chars back to an integer next_bigger_num = int(\'\'.join(digits)) return next_bigger_num"},{"question":"# Binary Indexed Tree (Fenwick Tree) - Range Sum **Context**: You are given an array of integers. Your task is to support efficient range sum queries and point update operations—given that the array can change dynamically. Task Implement a class `BIT` (Binary Indexed Tree) that can efficiently: 1. Update a specified index in the array. 2. Compute the sum of the elements from index (0) to a specified index (i). Class Signature ```python class BIT: def __init__(self, initial_array: List[int]): Initializes the BIT with the given initial array, building the tree structure. :param initial_array: List[int] - the initial array to be constructed into BIT. pass def update(self, index: int, value: int) -> None: Updates the element at the specified index with the given value. :param index: int - Index of the element to update. :param value: int - New value to set. pass def query(self, index: int) -> int: Computes the sum of elements from the beginning of the array up to the specified index. :param index: int - End index of the range (inclusive) for the sum calculation. :return: int - Sum of elements from index 0 to the specified index. pass ``` Constraints * `1 <= length of initial_array <= 10^5` * `0 <= index < length of initial_array` * `-10^9 <= initial_array[i], value <= 10^9` Example Usage ```python # Sample initial array arr = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] # Initialize BIT with the array bit = BIT(arr) # Update operations bit.update(3, 5) # Query operations sum_up_to_5 = bit.query(5) print(sum_up_to_5) # Expected output would vary based on the update operations done. ``` Notes * The `update` method updates a single element at a given index with a new value. * The `query` method returns the sum of elements from index `0` to a given index `i`. Implement the above class, and ensure that both methods run in (O(log n)) time complexity.","solution":"class BIT: def __init__(self, initial_array): self.n = len(initial_array) self.bit = [0] * (self.n + 1) self.array = [0] * self.n for i, val in enumerate(initial_array): self.update(i, val) def update(self, index, value): delta = value - self.array[index] self.array[index] = value index += 1 while index <= self.n: self.bit[index] += delta index += index & -index def query(self, index): sum = 0 index += 1 while index > 0: sum += self.bit[index] index -= index & -index return sum"},{"question":"# Coding Challenge: Implement the Generalized Rabin-Karp Algorithm Context: The Rabin-Karp algorithm is often used for string matching, but it can be extended and generalized for any use case involving rolling hashes, such as detecting plagiarism in large bodies of text. In this task, you are required to implement a generalized version of the Rabin-Karp algorithm that works for some predefined conditions. Objective: You need to write a function `generalized_rabin_karp(pattern, text, base, modulus)` that takes: - `pattern` (str): the pattern string you are looking for. - `text` (str): the text string where you are looking for the pattern. - `base` (int): the base for the polynomial hash function. - `modulus` (int): the modulus used in the hash function to handle large numbers and reduce collisions. Function Signature: ```python def generalized_rabin_karp(pattern, text, base, modulus): # Your code here pass ``` Input Format: ```plaintext 1. pattern: a non-empty string (1 <= len(pattern) <= 100000). 2. text: a non-empty string (1 <= len(text) <= 100000). 3. base: an integer (1 <= base <= 1000). 4. modulus: an integer (1 <= modulus <= 1000000007). ``` Output Format: The function should return: - The starting index (0-based) of the first occurrence of the `pattern` string in the `text` string. - If the pattern is not found, return None. Constraints: 1. The function must handle empty strings by returning None. 2. The function should handle cases where the pattern length is greater than the text length by returning None. 3. The function should use the polynomial rolling hash method to compute hash values efficiently. 4. It must use modular arithmetic to avoid overflow and handle large character sets. Performance Requirements: - The function should run efficiently even for large inputs. Aim for average time complexity of O(n + m), where `n` is the length of the text and `m` is the length of the pattern. Example: ```python # Example 1 pattern = \\"abc\\" text = \\"abxabcabcaby\\" base = 256 modulus = 101 output = generalized_rabin_karp(pattern, text, base, modulus) # Output: 3 # Example 2 pattern = \\"a\\" text = \\"aaaaaaa\\" base = 31 modulus = 11 output = generalized_rabin_karp(pattern, text, base, modulus) # Output: 0 ```","solution":"def generalized_rabin_karp(pattern, text, base, modulus): if not pattern or not text or len(pattern) > len(text): return None pattern_len = len(pattern) text_len = len(text) pattern_hash = 0 current_hash = 0 h = 1 for i in range(pattern_len - 1): h = (h * base) % modulus for i in range(pattern_len): pattern_hash = (base * pattern_hash + ord(pattern[i])) % modulus current_hash = (base * current_hash + ord(text[i])) % modulus for i in range(text_len - pattern_len + 1): if pattern_hash == current_hash: if text[i:i + pattern_len] == pattern: return i if i < text_len - pattern_len: current_hash = (base * (current_hash - ord(text[i]) * h) + ord(text[i + pattern_len])) % modulus if current_hash < 0: current_hash += modulus return None"},{"question":"Find the Last Occurrence with Edge Cases Handling You are given a sorted (in increasing order) array of integers. Write a function to find the index of the last occurrence of a given integer in the array. If the integer is not found, return -1. Function Signature ```python def find_last_occurrence(array: List[int], query: int) -> int: pass ``` # Input * `array`: A list of sorted integers (non-decreasing order). * `query`: An integer, the target value to find in the array. # Output * Return the index of the last occurrence of the `query` in the array. * If the `query` does not exist in the array, return -1. # Constraints * The function should operate with a time complexity of O(log n). * The length of the array will not exceed 10^6. # Example ```python assert find_last_occurrence([1, 2, 2, 2, 3, 4, 5], 2) == 3 assert find_last_occurrence([1, 2, 2, 2, 3, 4, 5], 3) == 4 assert find_last_occurrence([], 3) == -1 assert find_last_occurrence([1, 1, 1, 1, 1], 1) == 4 assert find_last_occurrence([1, 2, 3, 4, 5], 6) == -1 ``` # Notes * The array can be empty. * The array contains integers and is sorted in non-decreasing order. * Consider edge cases like arrays of size one, where the element is either present or absent.","solution":"from typing import List def find_last_occurrence(array: List[int], query: int) -> int: Finds the index of the last occurrence of a given integer in a sorted array. If the integer is not found, returns -1. Parameters: array (List[int]): A list of sorted integers in non-decreasing order query (int): The target value to find in the array Returns: int: The index of the last occurrence of the query in the array, or -1 if not found left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid left = mid + 1 # Move to the right part to find the last occurrence elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"Find the Single Number You are given a non-empty array of integers `nums`, where every element appears **twice** except for one. Your task is to implement a function `single_number` that returns the single element that appears only once. Input - An integer array `nums` where `1 <= nums.length <= 10^5`. - All elements in `nums` will appear exactly twice except for one. Output - A single integer that appears only once in the array. Function Signature ```python def single_number(nums: List[int]) -> int: ``` Constraints - Your algorithm should run in O(n) time complexity. - You should not use extra memory and aim for O(1) space complexity. Example ```python assert single_number([2, 2, 1]) == 1 assert single_number([4, 1, 2, 1, 2]) == 4 assert single_number([1]) == 1 ``` Considerations - Handle edge cases such as a single-element array. - Ensure no invalid array configuration is provided (e.g., all elements appearing twice but no single number).","solution":"from typing import List def single_number(nums: List[int]) -> int: Returns the single number that appears only once in the list, while all other numbers appear exactly twice. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Priority Queue Implementation with Enhanced Features Summary You have been given a priority queue implementation using a linear array. The task involves enhancing and optimizing the priority queue to support the following operations more efficiently: 1. `change_priority(item, new_priority)`: Update the priority of an existing item in the queue. 2. `peek()`: Return the item with the highest priority without removing it. 3. `contains(item)`: Check if an item is present in the queue. Requirements Write a class `EnhancedPriorityQueue` that supports the following functions: 1. **Initialization**: - `__init__(self, items, priorities)`: Initialize the queue with the given items and their corresponding priorities. 2. **Insertion**: - `push(item, priority)`: Insert an item with the specified priority. 3. **Extract**: - `pop()`: Remove and return the item with the highest priority. - `peek()`: Return the item with the highest priority without removing it. 4. **Containment**: - `contains(item)`: Check whether the item is present in the queue. 5. **Priority Change**: - `change_priority(item, new_priority)`: Update the priority of an existing item in the queue. Your implementation should guarantee efficient execution for all operations. You can use any suitable data structure to achieve this. Example ```python pq = EnhancedPriorityQueue(items=[10, 20, 30], priorities=[3, 2, 1]) pq.push(40, 0) print(pq.pop()) # Output: 40 print(pq.peek()) # Output: 30 print(pq.contains(20)) # Output: True pq.change_priority(20, 4) print(pq.pop()) # Output: 20 ``` Constraints * Items and priorities are comparable and can be any objects supporting comparison operations. * All elements are unique; no duplicate elements in the queue. * Avoid using built-in libraries for the priority queue. Notes - Ensure to handle edge cases such as operations on an empty queue. - The `EnhancedPriorityQueue` class should maintain appropriate properties for all operations to be performed efficiently.","solution":"import heapq class EnhancedPriorityQueue: def __init__(self, items=None, priorities=None): self.heap = [] self.entry_finder = {} # mapping of items to their heap entry self.REMOVED = \'<removed-item>\' # placeholder for a removed item self.counter = 0 # unique sequence count if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) def push(self, item, priority): Add a new item or update the priority of an existing item. if item in self.entry_finder: self.remove_item(item) count = self.counter entry = [priority, count, item] self.entry_finder[item] = entry heapq.heappush(self.heap, entry) self.counter += 1 def remove_item(self, item): Mark an existing item as REMOVED. Raise KeyError if not found. entry = self.entry_finder.pop(item) entry[-1] = self.REMOVED def pop(self): Remove and return the lowest priority item. Raise KeyError if empty. while self.heap: priority, count, item = heapq.heappop(self.heap) if item is not self.REMOVED: del self.entry_finder[item] return item raise KeyError(\'pop from an empty priority queue\') def peek(self): Return the lowest priority item without removing it. Raise KeyError if empty. while self.heap: priority, count, item = self.heap[0] if item is self.REMOVED: heapq.heappop(self.heap) else: return item raise KeyError(\'peek from an empty priority queue\') def contains(self, item): Return True if the item is in the priority queue, False otherwise. return item in self.entry_finder def change_priority(self, item, new_priority): Change the priority of an existing item. Raise KeyError if not found. if item not in self.entry_finder: raise KeyError(f\\"{item} not found in the priority queue\\") self.remove_item(item) self.push(item, new_priority)"},{"question":"# Missing Number Ranges You are tasked with writing a function to find the missing number ranges between given bounds for an array of numbers. # Problem Statement Implement a function `find_missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]` that accepts a list of integers `arr` and two integers, `lo` and `hi`. The function should return a list of tuples, where each tuple represents a range of consecutive numbers missing from `arr` within the inclusive range `[lo, hi]`. - Each tuple `(a, b)` should satisfy `lo <= a <= b <= hi`. - If `lo` > `hi`, the function should return an empty list. - Assume that the input array `arr` is sorted in ascending order. # Input Format * A list of integers `arr` (sorted). * Two integers `lo` and `hi` representing the lower and upper bounds, respectively. # Output Format * A list of tuples, where each tuple consists of two integers, representing the starting and ending points of the missing ranges. # Constraints * `arr` contains only distinct elements. * `-10^9 <= lo, hi <= 10^9` * `0 <= len(arr) <= 10^6` # Performance Your implementation should be able to handle up to 1,000,000 elements efficiently. # Example 1. For `arr = [3, 5], lo = 1, hi = 10`, the output should be `[(1, 2), (4, 4), (6, 10)]`. 2. For `arr = [], lo = 1, hi = 10`, the output should be `[(1, 10)]`. 3. For `arr = [1, 2, 3, 4, 5], lo = 1, hi = 5`, the output should be `[]`. # Additional Notes - Ensure that your implementation handles edge cases, such as when the input list is empty or when the `lo` and `hi` bounds are inverted. - Consider performance and edge cases in your implementation.","solution":"from typing import List, Tuple def find_missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: if lo > hi: return [] result = [] prev = lo - 1 for num in arr: if num > prev + 1: result.append((prev + 1, num - 1)) prev = num if prev < hi: result.append((prev + 1, hi)) return result"},{"question":"# Question You are given a non-negative integer represented as an array of digits, where the most significant digit is at the head of the list. Write a function `increment_digit_array` that adds one to the integer. Function Signature ```python def increment_digit_array(digits: List[int]) -> List[int]: pass ``` Input - `digits` (List[int]): A list of integer digits, where each element is between `0` and `9` and the list is non-empty. Output - List[int]: A new list of integers representing the incremented number\'s digits. Constraints - The list length could be up to `10^4`. Examples - Example 1: ```python increment_digit_array([1, 2, 3]) -> [1, 2, 4] ``` - Example 2: ```python increment_digit_array([9, 9, 9]) -> [1, 0, 0, 0] ``` # Additional Notes The input list should not be altered; your function should return a new list with the incremented number. Focus on handling edge cases, especially when all digits are `9`.","solution":"from typing import List def increment_digit_array(digits: List[int]) -> List[int]: length = len(digits) for i in range(length - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 return [1] + digits"},{"question":"# Serialization and Deserialization of a Binary Tree Scenario You are working on a software that requires frequent saving and loading of large binary trees. To efficiently manage this, you decide to implement functions that can convert a binary tree into a format suitable for storage and reconvert it back to the binary tree structure. Task Implement two functions: 1. `serialize(root: TreeNode) -> str`: Converts a given binary tree to a string representation. 2. `deserialize(data: str) -> TreeNode`: Reconstructs binary tree from the string representation. Ensure your serialization approach allows for unique reconstruction and handles `None` nodes appropriately. Input and Output * **Input to `serialize` function**: A binary tree\'s root node (`TreeNode`). * **Output from `serialize` function**: A string representation of the binary tree. * **Input to `deserialize` function**: A string representation of a binary tree. * **Output from `deserialize` function**: The root node of the reconstructed binary tree. Constraints * The binary tree will have at most 10,000 nodes. * The values of the nodes will be integers. Performance Requirements * The solution should execute in O(n) time complexity for both serialization and deserialization, where n is the number of nodes in the tree. * Use O(n) space complexity considering output size and internal structure storage. ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: Converts a binary tree into a string representation :param root: the root node of the binary tree :return: a string representation of the binary tree # Write your code here def deserialize(data: str) -> TreeNode: Reconstructs a binary tree from its string representation :param data: the string representation of the binary tree :return: the root node of the binary tree # Write your code here ``` Example: ```python # Example usage: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) # Serialize the tree: serialized_str = serialize(root) print(serialized_str) # Example output: \\"1 2 # # 3 4 # # 5 # #\\" # Deserialize the string: reconstructed_tree = deserialize(serialized_str) print(reconstructed_tree.val) # Output: 1 ``` Note * You should handle edge cases such as an empty tree where `root` is `None`. * Ensure efficient handling and reconstruction to meet performance requirements.","solution":"class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: Converts a binary tree into a string representation. :param root: the root node of the binary tree :return: a string representation of the binary tree def helper(node): if node is None: tokens.append(\\"#\\") else: tokens.append(str(node.val)) helper(node.left) helper(node.right) tokens = [] helper(root) return \\" \\".join(tokens) def deserialize(data: str) -> TreeNode: Reconstructs a binary tree from its string representation. :param data: the string representation of the binary tree :return: the root node of the binary tree def helper(): if vals[0] == \\"#\\": vals.pop(0) return None root = TreeNode(int(vals.pop(0))) root.left = helper() root.right = helper() return root vals = data.split() return helper()"},{"question":"You are given a list of floating-point numbers within the range [0, 1). Your task is to implement the Bucket Sort algorithm to sort these numbers in ascending order. You must handle edge cases and ensure optimal performance for evenly distributed elements. # Function Signature ```python def bucket_sort(arr: List[float]) -> List[float]: ``` # Input - `arr`: A list of `n` floating-point numbers between [0, 1). # Output - A list of sorted floating-point numbers in ascending order. # Constraints - 1 <= len(arr) <= 10^6 - Each element 0 <= arr[i] < 1 # Requirements - Your function should sort the given list of floating-point numbers using the Bucket Sort algorithm. - Choose an optimal number of buckets to ensure efficient sorting. - Use insertion sort or any other efficient sorting algorithm for sorting elements within buckets. - The final implementation should handle edge cases and optimize performance. # Example ```python arr = [0.78, 0.17, 0.39, 0.26, 0.94, 0.21, 0.12, 0.23, 0.68] print(bucket_sort(arr)) Output: [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.78, 0.94] ```","solution":"from typing import List def bucket_sort(arr: List[float]) -> List[float]: Sorts a list of floating-point numbers in the range [0, 1) using the Bucket Sort algorithm. n = len(arr) if n <= 1: return arr # Create n empty buckets buckets = [[] for _ in range(n)] # Put array elements in different buckets for num in arr: index = int(num * n) buckets[index].append(num) # Sort individual buckets and concatenate sorted_array = [] for bucket in buckets: # Use insertion_sort to sort the bucket sorted_array.extend(sorted(bucket)) return sorted_array"},{"question":"You are given a list that may contain duplicate elements. Your task is to implement a function that removes the duplicates while preserving the order of their first occurrences and returns a new list of unique elements. # Function Signature ```python def remove_duplicates(array): # Implement this function ``` # Input - `array`: A list of elements which can include integers, strings, booleans, or a mix of these. The length of `array` can be up to 10^6. # Output - A new list containing only the unique elements from `array`, with the original order preserved. # Constraints - The function should efficiently handle large input sizes up to 10^6 elements. - The solution should aim for an improved time complexity better than O(n^2). # Example ```python # Example 1 input_array = [1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True] output_array = remove_duplicates(input_array) print(output_array) # Output: [1, 2, 3, 4, \'hey\', \'hello\'] # Example 2 input_array = [1, 2, 3, 2, 3, 4, 5] output_array = remove_duplicates(input_array) print(output_array) # Output: [1, 2, 3, 4, 5] ``` # Notes - Consider optimizing the function to handle large input sizes within a reasonable time. - Ensure the function does not break when encountering an array with diverse data types.","solution":"def remove_duplicates(array): Returns a new list containing only unique elements from the input list \'array\', preserving the order of their first occurrences. seen = set() unique_list = [] for element in array: if element not in seen: seen.add(element) unique_list.append(element) return unique_list"},{"question":"# Scenario Imagine you are running a bookstore and need an efficient data structure to handle your inventory system. You need to store information about books using their unique ISBN codes (as keys) and the quantity available in stock (as values). Additionally, the system should dynamically resize itself when the number of books grows to ensure quick retrieval and storage. # Task Implement a class `BookstoreInventory` using the `ResizableHashTable` that extends the provided `HashTable` implementation. Your `BookstoreInventory` should provide the following operations: 1. **add_book(isbn: int, quantity: int)**: Add the given quantity of the book to the inventory. If the book already exists, update the quantity. 2. **remove_book(isbn: int)**: Remove the book with the given ISBN from the inventory. 3. **get_quantity(isbn: int) -> int**: Return the quantity of the book with the given ISBN. If the book is not in the inventory, return 0. 4. **in_stock(isbn: int) -> bool**: Return `True` if the book with the given ISBN is in stock, `False` otherwise. # Constraints and Assumptions 1. ISBN codes are guaranteed to be unique integers. 2. Quantities are non-negative integers. 3. The data structure should handle up to 10,000 books efficiently. 4. You should utilize the underlying `ResizableHashTable` operations for hash handling. # Example ```python inventory = BookstoreInventory() inventory.add_book(1234567890, 3) inventory.add_book(1234567891, 5) print(inventory.get_quantity(1234567890)) # Output: 3 print(inventory.in_stock(1234567892)) # Output: False inventory.remove_book(1234567890) print(inventory.get_quantity(1234567890)) # Output: 0 ``` # Implementation ```python class BookstoreInventory: def __init__(self): self.inventory = ResizableHashTable() def add_book(self, isbn: int, quantity: int): current_quantity = self.inventory.get(isbn) or 0 self.inventory.put(isbn, current_quantity + quantity) def remove_book(self, isbn: int): self.inventory.del_(isbn) def get_quantity(self, isbn: int) -> int: return self.inventory.get(isbn) or 0 def in_stock(self, isbn: int) -> bool: return self.inventory.get(isbn) is not None ``` Implement this `BookstoreInventory` class and ensure it supports the functionalities as specified.","solution":"class ResizableHashTable: def __init__(self): self.size = 10 self.table = [[] for _ in range(self.size)] self.num_elements = 0 def _hash(self, key): return key % self.size def put(self, key, value): hashed_key = self._hash(key) bucket = self.table[hashed_key] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.num_elements += 1 if self.num_elements / self.size > 0.7: self._resize() def get(self, key): hashed_key = self._hash(key) bucket = self.table[hashed_key] for k, v in bucket: if k == key: return v return None def del_(self, key): hashed_key = self._hash(key) bucket = self.table[hashed_key] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.num_elements -= 1 return def _resize(self): old_table = self.table self.size *= 2 self.table = [[] for _ in range(self.size)] self.num_elements = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) class BookstoreInventory: def __init__(self): self.inventory = ResizableHashTable() def add_book(self, isbn: int, quantity: int): if quantity < 0: raise ValueError(\\"Quantity should be non-negative\\") current_quantity = self.inventory.get(isbn) or 0 self.inventory.put(isbn, current_quantity + quantity) def remove_book(self, isbn: int): self.inventory.del_(isbn) def get_quantity(self, isbn: int) -> int: return self.inventory.get(isbn) or 0 def in_stock(self, isbn: int) -> bool: return self.inventory.get(isbn) is not None"},{"question":"# Question Statement Consider the RSA algorithm implementation provided. Your task is to extend this system by implementing a secure communication protocol using RSA encryption. You will design a function that takes two sets of RSA keys as input (one for the sender and one for the receiver) and encrypts and decrypts a given message. Additionally, you must verify the encrypted communication by ensuring the decrypted message matches the original. # Input Format * Two sets of keys: `(n1, e1, d1)` and `(n2, e2, d2)`. - `n1`, `e1`, `d1` are the RSA keys for the sender. - `n2`, `e2`, `d2` are the RSA keys for the receiver. * A message `msg`, which is a string. # Output Format * The decrypted message after being sent through the encryption and decryption process. # Function Signature ```python def secure_communication(sender_keys: tuple, receiver_keys: tuple, msg: str) -> str: pass ``` # Constraints 1. The message contains only alphanumeric characters and has a maximum length of 256 characters. 2. The RSA keys provided are valid and correctly generated. 3. You may assume the standard ASCII encoding for the message. # Example ```python # Example RSA keys (for simplicity, here we use very small primes) sender_keys = (3233, 17, 413) receiver_keys = (3233, 17, 413) message = \\"HELLO123\\" output = secure_communication(sender_keys, receiver_keys, message) print(output) # Should print \\"HELLO123\\", the same as the input message after encryption and decryption ``` # Notes 1. You should ensure the message is encrypted using receiver\'s public key and decrypted using receiver\'s private key. 2. Focus on the security aspects like ensuring the message is correctly decrypted. 3. Utilize proper error handling to deal with incorrect decryption cases. 4. Test your function thoroughly to validate correctness.","solution":"def encrypt_message(n, e, msg): Encrypt the message using the receiver\'s public key (n, e). encrypted_message = [pow(ord(char), e, n) for char in msg] return encrypted_message def decrypt_message(n, d, encrypted_msg): Decrypt the message using the receiver\'s private key (n, d). decrypted_message = \'\'.join([chr(pow(char, d, n)) for char in encrypted_msg]) return decrypted_message def secure_communication(sender_keys: tuple, receiver_keys: tuple, msg: str) -> str: Secure communication using RSA encryption and decryption. The message is encrypted with the receiver\'s public key and decrypted with the receiver\'s private key. n2, e2, d2 = receiver_keys # Encrypt the message with receiver\'s public key encrypted_msg = encrypt_message(n2, e2, msg) # Decrypt the message with receiver\'s private key decrypted_msg = decrypt_message(n2, d2, encrypted_msg) return decrypted_msg"},{"question":"You have been given an array of integers that was originally sorted in increasing order and then rotated at some pivot. Your task is to find the minimum element in this rotated array using an efficient algorithm with a time complexity of O(log N). **Input**: * An integer array `arr` of size `N`, which is sorted in increasing order and then rotated. **Output**: * An integer representing the minimum element in the given array. **Constraints**: * The array contains no duplicate elements. * The algorithm must run in O(log N) time. * The array has at least one element and at most 10^5 elements. **Function Signature**: ```python def find_min_index(arr: List[int]) -> int: pass ``` # Example Example 1 *Input*: ```json { \\"arr\\": [4, 5, 6, 7, 0, 1, 2] } ``` *Output*: ```json 0 ``` Example 2 *Input*: ```json { \\"arr\\": [11, 13, 15, 17, 19, 3, 5, 7, 9] } ``` *Output*: ```json 3 ``` Example 3 *Input*: ```json { \\"arr\\": [2, 3, 4, 5, 6, 7] } ``` *Output*: ```json 2 ``` # Notes * You can implement this function using either iterative or recursive methods. * Pay special attention to edge cases, such as very small arrays or rotations at the boundaries of the array.","solution":"from typing import List def find_min_index(arr: List[int]) -> int: Finds the minimum element in a rotated sorted array. Uses a binary search approach for O(log N) time complexity. left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] > arr[right]: left = mid + 1 else: right = mid return arr[left]"},{"question":"# Scenario: You are developing an auto-complete feature for a search engine which presents suggestions based on the user\'s input. To do this, you need to find the longest common prefix from a list of user queries. # Task: Write a function `longest_common_prefix(strs)` to determine the longest common prefix string among an array of strings. Implement the function using a method that you believe is the most optimal in terms of both time and space complexity. You must also handle various edge cases, performance bottlenecks, and ensure error-free execution. # Constraints: - The input list of strings will not exceed 200 strings. - Each string will be of length no more than 100 characters. - The input strings will only contain lowercase English letters. # Input: - `strs`: A list of strings `[\\"string1\\", \\"string2\\", ..., \\"stringN\\"]`. # Output: - Return a string that represents the longest common prefix shared among all strings in the input list. If no common prefix exists, return an empty string `\\"\\"`. # Examples: 1. Input: `[\\"flower\\",\\"flow\\",\\"flight\\"]` Output: `\\"fl\\"` 2. Input: `[\\"dog\\",\\"racecar\\",\\"car\\"]` Output: `\\"\\"` 3. Input: `[\\"illumination\\", \\"illusion\\", \\"ill\\"]` Output: `\\"ill\\"` 4. Input: `[\\"\\", \\"b\\", \\"c\\"]` Output: `\\"\\"` # Additional Notes: - Consider different approaches like Horizontal Scanning, Vertical Scanning, and Divide and Conquer, and choose the most efficient one for implementation. - Optimize for clarity and efficiency while being mindful of edge cases and performance bottlenecks.","solution":"def longest_common_prefix(strs): Returns the longest common prefix among a list of strings. if not strs: return \\"\\" # The shortest string will limit the longest possible prefix shortest_str = min(strs, key=len) for i, char in enumerate(shortest_str): for other_str in strs: if other_str[i] != char: return shortest_str[:i] return shortest_str"},{"question":"Scenario You have been hired by a clothing retailer to help with their inventory management system. Their warehouse receives batches of t-shirts in different colors, and each t-shirt is tagged with an integer indicating its color: 0 (red), 1 (white), and 2 (blue). Your task is to sort these t-shirts by color efficiently to streamline the inventory process. Task Write a function `sort_colors` that takes a list of integers (`nums`), where each integer is 0, 1, or 2. The function should sort the list in-place so that all 0s come first, followed by all 1s, and all 2s last. Function Signature ```python def sort_colors(nums: List[int]) -> None: pass ``` Input - A list `nums` consisting of integers `0, 1, and 2` in any order. - Constraints: - The length of the list `nums` is in the range `[0, 10^5]`. Output - The function returns `None`. The input list `nums` should be modified in-place to reflect the sorted order. Examples ```python # Example 1 nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] # Example 2 nums = [2, 0, 1] sort_colors(nums) print(nums) # Output: [0, 1, 2] # Example 3 nums = [0] sort_colors(nums) print(nums) # Output: [0] # Example 4 nums = [] sort_colors(nums) print(nums) # Output: [] ``` Constraints and Performance Requirements - You are not allowed to use the built-in sort function. - Your solution should have O(n) time complexity and O(1) space complexity. - The list should be sorted in one pass. Notes - Make sure your solution handles empty lists gracefully. - The input list should be modified in-place so that no extra space is used.","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Sort the list nums in-place such that all 0s come first, followed by all 1s, and all 2s last. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Matrix Chain Multiplication You are given a sequence of matrices, and you need to find the most efficient way to multiply these matrices. The problem is not to perform the multiplications, but merely to determine the optimal parenthesization of the product. Given an array `array[]` which represents the dimensions of matrices such that the dimension of matrix `Ai` is `array[i-1] x array[i]`, you need to write a function that computes the minimum number of scalar multiplications needed to compute the matrix chain product. Function Signature ```python def min_matrix_mult(array: List[int]) -> Tuple[int, List[List[int]]]: Computes the minimum number of scalar multiplications needed to multiply the chain of matrices and returns the cost along with the solution matrix. Args: array (List[int]): Dimensions of the matrices. Returns: Tuple[int, List[List[int]]]: Minimum cost, and solution matrix. ``` Input * `array`: A list of integers where `array[i-1] x array[i]` are the dimensions of matrix `Ai`. # Constraints * All elements in the `array` are positive integers. * `2 <= len(array) <= 100` Output * Returns a tuple containing: * The minimum number of scalar multiplications needed. * A 2D list representing the solution matrix. Example ```python array = [30, 35, 15, 5, 10, 20, 25] print(min_matrix_mult(array)) # Output: (15125, solution_matrix) ``` Instructions * Implement the function `min_matrix_mult` that determines the minimum number of scalar multiplications and constructs a solution matrix. * Write helper functions if necessary. * Ensure optimized handling for larger inputs within the given constraints.","solution":"from typing import List, Tuple def min_matrix_mult(array: List[int]) -> Tuple[int, List[List[int]]]: Computes the minimum number of scalar multiplications needed to multiply the chain of matrices and returns the cost along with the solution matrix. Args: array (List[int]): Dimensions of the matrices. Returns: Tuple[int, List[List[int]]]: Minimum cost, and solution matrix. n = len(array) m = [[0 for x in range(n)] for y in range(n)] for length in range(2, n): for i in range(1, n-length+1): j = i+length-1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k+1][j] + array[i-1] * array[k] * array[j] if q < m[i][j]: m[i][j] = q return m[1][n-1], m"},{"question":"**Title**: Optimized Comb Sort Implementation **Objective**: Write a function `optimized_comb_sort` that extends the functionality of Comb Sort by addressing its common limitations for better performance. **Input**: - An array of integers `arr` (1 <= length of arr <= 10^5, -10^9 <= arr[i] <= 10^9). **Output**: - Return a sorted array of integers, in non-decreasing order. **Constraints**: 1. The function must handle large arrays efficiently. 2. Ensure in-place sorting (O(1) additional space). 3. Implement enhancements to Comb Sort, such as switching to insertion sort when the gap is sufficiently small. **Performance Requirements**: - Your optimized solution should aim to outperform the standard Comb Sort in practical scenarios, striving for close to O(n log n) behavior on average inputs. **Scenario/Context**: Comb Sort is decent but can be impractical for large datasets due to its O(n^2) limitations. By enhancing your Comb Sort with an adaptive strategy, you can achieve better performance and reliability for a broader range of use cases, ensuring its utility in real-world applications. Implement the function with the provided signatures: ```python def optimized_comb_sort(arr): Sort the input array using an optimized version of Comb Sort. Parameters: arr (List[int]): List of integers to be sorted. Returns: List[int]: The sorted list of integers. # YOUR CODE HERE pass ``` **Example**: ```python print(optimized_comb_sort([5, 3, 2, 8, 1, 4])) # Output: [1, 2, 3, 4, 5, 8] ``` Recommendations: 1. Optimize the gap shrink factor based on empirical evidence or theoretical improvements. 2. Integrate insertion sort for small gaps near the end of the procedure to streamline performance for nearly sorted sections.","solution":"def optimized_comb_sort(arr): Sort the input array using an optimized version of Comb Sort. Parameters: arr (List[int]): List of integers to be sorted. Returns: List[int]: The sorted list of integers. def insertion_sort(arr, start, end): for i in range(start + 1, end): key = arr[i] j = i - 1 while j >= start and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def get_next_gap(gap): gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True # For small gaps (close to 1), use insertion sort for better performance if gap == 1: insertion_sort(arr, 0, n) return arr"},{"question":"# Sorting with Stooge Sort You are hired to teach sorting algorithms, and part of the task is to introduce students to inefficient sorting algorithms to understand the need for efficient sorting. You need to implement a **Stooge Sort** function. Given an array of integers, rearrange them in non-decreasing order using the stooge sort algorithm. Function Signature: ```python def stoogesort(arr: list, l: int, h: int) -> None: Sorts the array recursively from index l to h using stooge sort algorithm. ``` Input: - `arr` (list of int): A list of integers that needs to be sorted. - `l` (int): The starting index of the segment of the array to be sorted. - `h` (int): The ending index of the segment of the array to be sorted. Output: - The function modifies the array `arr` in place to be sorted in non-decreasing order. Constraints: - 1 <= len(arr) <= 100 - -10^6 <= arr[i] <= 10^6 Example: ```python arr = [1, 3, 64, 5, 7, 8] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 3, 5, 7, 8, 64] ``` Notes: - Focus on implementing the stooge sort algorithm efficiently within the constraints. - Think about the edge cases such as an already sorted array or an array with very few elements (including an array of length one or two). Context: This task will help you explore an inefficient sorting algorithm to better understand the principles behind sorting and the importance of algorithm choice based on complexity.","solution":"def stoogesort(arr: list, l: int, h: int) -> None: Sorts the array recursively from index l to h using stooge sort algorithm. if l >= h: return # If the element at position l is greater than the element at position h, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the segment if h - l + 1 > 2: # Compute third length t = (h - l + 1) // 3 # Recursively sort the first 2/3 of the array stoogesort(arr, l, h - t) # Recursively sort the last 2/3 of the array stoogesort(arr, l + t, h) # Again sort the first 2/3 of the array to ensure it\'s fully sorted stoogesort(arr, l, h - t)"},{"question":"**Pattern Matching in Genomic Sequences** In bioinformatics, analyzing genomic sequences often involves searching for specific nucleotide patterns within larger DNA sequences. You are provided with a large DNA sequence `genome` and a specific nucleotide pattern `pattern` that you need to find within the genome. A DNA sequence is a string consisting only of the characters \'A\', \'C\', \'G\', and \'T\'. You will implement the Rabin-Karp algorithm to find the starting index of the first occurrence of the `pattern` in the `genome`. If the pattern is not found, return -1. **Function Signature**: ```python def find_pattern_in_genome(genome: str, pattern: str) -> int: ``` # Input * A string `genome` representing the DNA sequence. * `1 <= len(genome) <= 10^6` * The `genome` string contains only \'A\', \'C\', \'G\', \'T\' * A string `pattern` representing the nucleotide sequence to search for. * `1 <= len(pattern) <= 10^5` * The `pattern` string contains only \'A\', \'C\', \'G\', \'T\' # Output * An integer representing the starting index of the first occurrence of `pattern` in `genome`, or -1 if `pattern` is not found. # Example ```python genome = \\"AAGTCGGGACGTTACG\\" pattern = \\"GTT\\" find_pattern_in_genome(genome, pattern) # should return 10 genome = \\"AAGTCGGGACGTTACG\\" pattern = \\"TTT\\" find_pattern_in_genome(genome, pattern) # should return -1 ``` # Constraints 1. Ensure your solution can handle large inputs efficiently. 2. Use the rolling hash mechanism effectively to maintain O(n + m) average time complexity. 3. Consider the DNA sequence characteristics (`A`, `C`, `G`, `T`). # Notes * Case sensitivity should not be an issue as DNA sequences are strictly uppercase. * Assume no hash function collisions for this application. * Carefully handle the edge case where the pattern is longer than the genome.","solution":"def find_pattern_in_genome(genome: str, pattern: str) -> int: Uses the Rabin-Karp algorithm to find the first occurrence of pattern in genome. Returns the starting index of the first occurrence, or -1 if pattern is not found. len_genome = len(genome) len_pattern = len(pattern) if len_pattern > len_genome: return -1 # Base constants for Rabin-Karp base = 256 # Number of characters in the input alphabet prime = 101 # A prime number # Hash values for pattern and genome hash_pattern = 0 hash_genome = 0 h = 1 # The value of h would be \\"pow(d, M-1)%q\\" for i in range(len_pattern - 1): h = (h * base) % prime # Calculate the hash value of pattern and initial window of genome for i in range(len_pattern): hash_pattern = (base * hash_pattern + ord(pattern[i])) % prime hash_genome = (base * hash_genome + ord(genome[i])) % prime # Slide the pattern over genome one by one for i in range(len_genome - len_pattern + 1): # Check the hash values of current window of genome and pattern if hash_pattern == hash_genome: # If the hash values match, check for characters one by one for j in range(len_pattern): if genome[i + j] != pattern[j]: break else: # Pattern found at index i return i # Calculate hash value for next window of genome if i < len_genome - len_pattern: hash_genome = (base * (hash_genome - ord(genome[i]) * h) + ord(genome[i + len_pattern])) % prime # We might get negative value of hash_genome, convert it to positive if hash_genome < 0: hash_genome += prime return -1"},{"question":"Problem Statement You are tasked with implementing an extended version of the Markov Chain algorithm that allows additional features and robustness. Specifically, you need to implement a function `simulate_markov_chain` that simulates the Markov Chain for a given number of transitions from an initial state. # Function Signature ```python def simulate_markov_chain(chain: dict, initial_state: str, num_transitions: int) -> list: ``` # Input - `chain` (dict): A dictionary representing the Markov Chain. Each key is a state, and its value is another dictionary of states with transition probabilities (`dict[str, dict[str, float]]`). - `initial_state` (str): The state from which to start the simulation. - `num_transitions` (int): The number of transitions to simulate. # Output - A list of strings representing the sequence of states after simulating `num_transitions` transitions from the `initial_state`. # Constraints - The sum of the transition probabilities for any state must be `1`. - `num_transitions` is a non-negative integer. - The `initial_state` must be a valid state in the Markov Chain. # Example ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } initial_state = \'A\' num_transitions = 5 simulate_markov_chain(chain, initial_state, num_transitions) # Example Output: [\'E\', \'A\', \'A\', \'E\', \'A\', \'E\'] ``` # Instructions 1. Ensure your implementation correctly handles the probabilistic nature of the Markov Chain. 2. Account for edge cases like invalid states or transition probabilities sum not being 1. 3. Optimize for performance where applicable while maintaining code readability.","solution":"import random def simulate_markov_chain(chain, initial_state, num_transitions): Simulates a Markov Chain for a given number of transitions from an initial state. :param chain: dict, A dictionary representing the Markov Chain. Each key is a state, and its value is another dictionary of states with transition probabilities :param initial_state: str, The state from which to start the simulation :param num_transitions: int, The number of transitions to simulate :return: list of strings representing the sequence of states if initial_state not in chain: raise ValueError(\\"initial_state must be a valid state in the Markov Chain.\\") current_state = initial_state results = [current_state] for _ in range(num_transitions): transitions = chain[current_state] next_states, probabilities = zip(*transitions.items()) current_state = random.choices(next_states, probabilities)[0] results.append(current_state) return results"},{"question":"# Problem Context In the world of cryptography, a common problem involves transforming one string into another through a simple substitution cipher. Given two strings, your task is to determine if one string can be converted into the other by replacing characters consistently such that the new string is an isomorphic mapping of the original. # Problem Statement Write a function `is_isomorphic(s: str, t: str) -> bool` that determines if two given strings `s` and `t` are isomorphic. Two strings are isomorphic if each character in the first string can be uniquely replaced to get the second string, while preserving the order of characters. # Input * `s`: A string consisting of lowercase alphabets (1 <= len(s) <= 5 * 10^4). * `t`: A string consisting of lowercase alphabets (1 <= len(t) <= 5 * 10^4). # Output * Return `True` if the strings are isomorphic, otherwise `False`. # Constraints * You must solve the problem with a time complexity of O(n), where n is the length of the strings. * The space complexity should be optimized, considering the constraints provided. # Example Cases Example 1 Input: `s = \\"egg\\"`, `t = \\"add\\"` Output: `True` Explanation: Character \'e\' can be replaced with \'a\' and \'g\' with \'d\'. Example 2 Input: `s = \\"foo\\"`, `t = \\"bar\\"` Output: `False` Explanation: Character \'o\' cannot be mapped to two different characters \'a\' and \'r\'. Example 3 Input: `s = \\"paper\\"`, `t = \\"title\\"` Output: `True` Explanation: Character \'p\' can be replaced with \'t\', \'a\' with \'i\', \'e\' with \'l\', and \'r\' with \'e\'. # Task Implement the function `def is_isomorphic(s: str, t: str) -> bool:` that follows the problem description and constraints.","solution":"def is_isomorphic(s: str, t: str) -> bool: if len(s) != len(t): return False mapping_s_to_t = {} mapping_t_to_s = {} for char_s, char_t in zip(s, t): if char_s in mapping_s_to_t: if mapping_s_to_t[char_s] != char_t: return False else: mapping_s_to_t[char_s] = char_t if char_t in mapping_t_to_s: if mapping_t_to_s[char_t] != char_s: return False else: mapping_t_to_s[char_t] = char_s return True"},{"question":"You are tasked with implementing a variant of the Shell Sort algorithm with a custom gap sequence. The custom gap sequence is provided in the form of a list of integer gaps. This sequence defines the intervals between the elements to be compared and swapped during sorting. Function Signature ```python def custom_shell_sort(arr: list, gaps: list) -> list: pass ``` Input * `arr`: A list of integers that need to be sorted. * `gaps`: A list of integers representing the gap sequence (guaranteed to be in descending order). Output * A list of integers sorted in non-decreasing order. Constraints * The length of `arr` will be between 0 and 10^6. * All integers in `arr` will lie between -10^9 and 10^9. * The length of `gaps` will be appropriate such that the last gap is always 1, ensuring the entire array is sorted at the end. Scenario Imagine you are handling large datasets that may have already been partially sorted due to earlier operations. You want to utilize a sorting method that is efficient for such cases. Given a dataset that fits within the provided constraints and using a specific gap sequence for Shell Sort, implement the custom_shell_sort function that will return the sorted array efficiently. Example ```python arr = [5, 2, 9, 1, 5, 6] gaps = [4, 2, 1] print(custom_shell_sort(arr, gaps)) # Output: [1, 2, 5, 5, 6, 9] ``` # Requirements 1. The solution must correctly handle edge cases like empty arrays or arrays with a single element. 2. The function should maintain O(1) space complexity besides the input arguments. 3. Make use of the custom gap sequence provided and ensure to handle changing pointers efficiently.","solution":"def custom_shell_sort(arr: list, gaps: list) -> list: Perform Shell Sort using the provided custom gap sequence. Args: arr: A list of integers that need to be sorted. gaps: A list of integers representing the gap sequence (in descending order). Returns: A sorted list of integers in non-decreasing order. n = len(arr) # Perform the shell sort for gap in gaps: for i in range(gap, n): temp = arr[i] j = i # Shift elements of arr[0..i-gap] that are greater than temp to one position ahead while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"Two Sum Problem # Scenario You are tasked to find two distinct indices in an array of integers where the sum of the elements at those indices equals a given target value. This problem is frequently encountered in tasks such as pairing expenses to a budget or finding relationships between data points within a specific criterion. # Problem Statement Given an array of integers, return a tuple of two indices of the numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. # Input and Output Formats * **Input**: * `array`: List[int] - A list of integers (1 <= len(array) <= 10^5) * `target`: int - The target sum (|target| <= 10^6) * **Output**: * Tuple of two integers - Indices of the elements that add up to the target. # Constraints * Each input will have exactly one solution. * Elements cannot be used twice. * Optimize for time complexity with linear time. # Performance Requirements * Your solution should have a time complexity of O(n) and a space complexity of O(n). # Example ```python # Example nums = [2, 7, 11, 15] target = 9 # Because nums[0] + nums[1] = 2 + 7 = 9, # the expected output is (0, 1) ``` # Implementation You need to implement the function `two_sum(array, target)` which returns a tuple of two indices such that the numbers at those indices add up to the target value. ```python def two_sum(array, target): dic = {} for i, num in enumerate(array): if num in dic: return dic[num], i else: dic[target - num] = i return None ``` **Note**: The function should return a tuple `(index1, index2)` and not modify the input array.","solution":"def two_sum(array, target): Given an array of integers, return a tuple of two indices of the numbers such that they add up to a specific target. dic = {} for i, num in enumerate(array): if num in dic: return (dic[num], i) dic[target - num] = i return None"},{"question":"# Question: You are tasked with implementing a function to determine the smallest character in a sorted list of lowercase letters that is greater than a given target character. The input list `letters` is sorted in ascending order and contains only lowercase alphabetical characters. The list is circular, meaning if the target character is greater than or equal to the largest character in the list, the search should wrap around to the beginning of the list. Function Signature ```python def find_next_greater_letter(letters: List[str], target: str) -> str: pass ``` Constraints - The list `letters` will contain at least 2 elements. - All characters in `letters` will be lowercase English letters and appear in sorted order. - The target character `target` is a lowercase English letter. - The list may contain duplicates. Requirements - Implement the function efficiently with a preferred time complexity of O(log N). - Ensure the function handles the wrap-around scenario correctly. - Do not use pre-existing library `bisect` for binary searching; write the binary search logic manually. Input - A sorted list of characters `letters` (`List[str]`). - A target character `target` (`str`). Output - A single character (`str`) that is the smallest character in the list greater than the given target. Examples ```python letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"a\\" # Output: \\"c\\" letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"c\\" # Output: \\"f\\" letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"d\\" # Output: \\"f\\" letters = [\\"a\\", \\"c\\", \\"g\\"] target = \\"h\\" # Output: \\"a\\" letters = [\\"e\\", \\"e\\", \\"e\\", \\"e\\", \\"f\\", \\"f\\", \\"g\\", \\"g\\"] target = \\"e\\" # Output: \\"f\\" ``` Notes - If no such character exists in the list that is greater than the target, the result should be the first character in the list.","solution":"from typing import List def find_next_greater_letter(letters: List[str], target: str) -> str: Returns the smallest character in the sorted list letters that is greater than the target. The list is circular, so if no such character exists, it returns the first character in the list. left, right = 0, len(letters) - 1 # If the target is greater than or equal to the last character in the list, return the first character if target >= letters[right]: return letters[0] # Perform binary search while left < right: mid = (left + right) // 2 if letters[mid] > target: right = mid else: left = mid + 1 return letters[left]"},{"question":"# Question: You are tasked with developing a function that processes an array of integers to find the most frequent value(s). If multiple elements share the highest frequency, the function should list all of them. # Instructions: 1. **Input** - A list of integers, `arr` where (1 leq text{len}(arr) leq 10^6). 2. **Output** - A list of integers with the most frequent value(s) in ascending order. 3. **Constraints** - The array may contain negative numbers. - The elements may have multiple equal frequencies. 4. **Examples** - Example 1: ```python arr = [1,2,2,3,3,3,4,4,4,5] Output: [3, 4] ``` - Example 2: ```python arr = [7, 7, 7, 7] Output: [7] ``` - Example 3: ```python arr = [] Output: [] ``` 5. **Performance** - Your solution should have a time complexity of O(n) and a space complexity of O(n) to handle large inputs efficiently. 6. **Notes** - Your function should be named `most_frequent_values`. # Function Signature ```python def most_frequent_values(arr: list) -> list: pass ```","solution":"from collections import Counter def most_frequent_values(arr: list) -> list: if not arr: return [] frequency_counter = Counter(arr) max_frequency = max(frequency_counter.values()) most_frequent = [num for num, freq in frequency_counter.items() if freq == max_frequency] return sorted(most_frequent)"},{"question":"# Keyboard Row Typing Challenge Context You are building a word processor that can filter out words based on specific criteria. For this task, you will focus on the words that can be typed using the letters from only one row of an American QWERTY keyboard. The rows of the keyboard are defined as: 1. First row: \\"qwertyuiop\\" 2. Second row: \\"asdfghjkl\\" 3. Third row: \\"zxcvbnm\\" Using this information, write a function that determines which words can be typed using only letters from one of these rows. Task Write a function `find_keyboard_row_words` that takes a list of strings (words) and returns a list of words from the input that can be typed using letters from only one row of the keyboard. Input - List of words (1 ≤ len(words) ≤ 100) - Each word contains only English letters (1 ≤ len(word) ≤ 12) Output - A list of words that can be typed using letters from only one row of the American keyboard. - Words in the result should appear in the same order as they appear in the input. Constraints - The result should maintain the order of words as in the input. - The function should be case-insensitive (treat \\"Hello\\" the same as \\"hello\\"). Example ```python # Example input words = [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] # Example output output = [\\"Alaska\\", \\"Dad\\"] ``` Function Signature ```python def find_keyboard_row_words(words: list) -> list: # Your code here ``` Hints - Consider using sets to represent the rows of the keyboard for efficient lookup. - Convert each word to lowercase to ensure case-insensitivity. - Use set operations to check if all characters of a word belong to one keyboard row.","solution":"def find_keyboard_row_words(words): Returns the list of words that can be typed using letters from only one row of the keyboard. row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: lower_word = set(word.lower()) if lower_word.issubset(row1) or lower_word.issubset(row2) or lower_word.issubset(row3): result.append(word) return result"},{"question":"You are tasked with writing a function that computes the minimal number of bit flips required to convert one integer ( A ) to another integer ( B ). This function helps understand the degree of transformation needed at the binary level when comparing two integers. # Function Signature: ```python def count_flips_to_convert(a: int, b: int) -> int: ``` # Input * `a`: An integer ( A ). (constraints: ( 0 leq a leq 10^9 )) * `b`: An integer ( B ). (constraints: ( 0 leq b leq 10^9 )) # Output * Returns the minimal number of bit flips required to convert integer ( A ) to integer ( B ). # Examples 1. If the input is: ```python a = 29 b = 15 ``` The output should be: ```python 2 ``` 2. If the input is: ```python a = 1 b = 0 ``` The output should be: ```python 1 ``` # Explanation 1. The binary representation of 29 is `11101`, and for 15 it\'s `01111`. The different bits are: `11101` vs `01111`. By flipping the second and the fifth bit in 29, we transform it into 15, totaling 2 flips. 2. For the input 1 (`0001`) and 0 (`0000`), flipping the last bit will transform 1 into 0, totaling 1 flip. # Constraints * You should assume that both inputs are non-negative and within the given range. * Optimize the function for performance, aiming for the smallest time complexity possible.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Computes the minimal number of bit flips required to convert integer `a` to integer `b`. # XOR operation identifies the differing bits xor_result = a ^ b # Counting the number of 1s in the binary representation of the xor_result return bin(xor_result).count(\'1\')"},{"question":"# Counting Connected Components in an Undirected Graph Scenario: You are tasked with analyzing a social network to determine the number of distinct communities. Each community is defined as a group of users where each user is directly or indirectly connected to every other user in the group. To achieve this, you\'ll employ depth-first search (DFS) to count the number of connected components in the network graph. Problem Description: Write a function `count_connected_components` to count the number of connected components in an undirected graph. The graph is represented as an adjacency list. Function Signature: ```python def count_connected_components(adjacency_list: List[List[int]], node_count: int) -> int: pass ``` Input: - `adjacency_list`: A list of lists, where each index `i` contains a list of nodes that node `i` is directly connected to. - `node_count`: The total number of nodes in the graph. Output: - `int`: The number of connected components in the graph. Constraints: - 1 ≤ node_count ≤ 1000 - 0 ≤ len(adjacency_list[i]) ≤ node_count for all valid `i` - The graph is undirected and there are no self-loops or multiple edges between the same pair of nodes. Example: ```python adjacency_list = [ [], # Node 0 (not used, assuming 1-based index) [2], # Node 1 is connected to Node 2 [1, 4, 5], # Node 2 is connected to Nodes 1, 4, 5 [7], # Node 3 is connected to Node 7 [2], # Node 4 is connected to Node 2 [2, 6], # Node 5 is connected to Nodes 2, 6 [5], # Node 6 is connected to Node 5 [3] # Node 7 is connected to Node 3 ] node_count = 7 print(count_connected_components(adjacency_list, node_count)) # Output: 2 ``` Hints: 1. Consider implementing an auxiliary function to perform DFS. 2. Use a visited list to keep track of the visited nodes. Implement the function `count_connected_components` to find the number of connected components in the given undirected graph.","solution":"def count_connected_components(adjacency_list, node_count): def dfs(node, visited, adjacency_list): stack = [node] while stack: current = stack.pop() if not visited[current]: visited[current] = True for neighbor in adjacency_list[current]: if not visited[neighbor]: stack.append(neighbor) visited = [False] * (node_count + 1) component_count = 0 for node in range(1, node_count + 1): if not visited[node]: component_count += 1 dfs(node, visited, adjacency_list) return component_count"},{"question":"Scenario: You are tasked with implementing an efficient solution to find the starting and ending positions of a target integer within a large, sorted array. You must ensure that the solution performs optimally to handle very large datasets. Problem Statement: Write a function `search_range(nums, target)` that finds and returns the starting and ending positions of a given target value within a sorted array of integers `nums`. If the target is not present in the array, the function should return `[-1, -1]`. Function Signature: ```python def search_range(nums, target): :param nums: List[int] - A list of integers sorted in ascending order. :param target: int - The target integer to locate in the array. :returns: List[int] - Starting and ending indices of the target. pass ``` Examples: ```python # Example 1: nums = [5,7,7,8,8,8,10], target = 8 # Output: [3, 5] # Example 2: nums = [5,7,7,8,8,8,10], target = 11 # Output: [-1, -1] # Example 3: nums = [1,3,3,5,5,5,5,6,9], target = 5 # Output: [3, 6] # Example 4: nums = [], target = 4 # Output: [-1, -1] ``` Constraints: * The array `nums` is sorted in ascending order. * The array can contain integers and can be very large (up to 10^5 elements). * The target value is an integer. Performance Requirements: * Aim for an overall time complexity of `O(log n)` for optimal performance. Notes: - Make sure your solution handles edge cases such as an empty array and the target not being present in the array. - Consider the efficiency of your approach, particularly in maintaining logarithmic complexity.","solution":"def search_range(nums, target): Find the starting and ending positions of a target value within a sorted array. :param nums: List[int] - A list of integers sorted in ascending order. :param target: int - The target integer to locate in the array. :returns: List[int] - Starting and ending indices of the target. def find_left_index(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_right_index(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right left_index = find_left_index(nums, target) right_index = find_right_index(nums, target) if left_index <= right_index and 0 <= left_index < len(nums) and 0 <= right_index < len(nums) and nums[left_index] == target and nums[right_index] == target: return [left_index, right_index] else: return [-1, -1]"},{"question":"Optimized Binomial Coefficient Calculation Objective: Implement a more efficient version of the binomial coefficient calculation using an iterative approach to avoid deep recursion. Problem Statement: Write a Python function `iterative_binomial_coefficient(n, k)` that computes the binomial coefficient C(n, k) using an iterative method. The function should handle large values of n and k efficiently, avoiding the problem of recursion depth limitation. Requirements: 1. The function should accept two non-negative integers n and k (0 <= k <= n). 2. It should return the value of C(n, k), the number of ways to choose k elements from n elements. 3. Handle edge cases where k = 0 or k = n directly. 4. Should be optimized to use the smallest k value (utilize C(n, k) = C(n, n-k) for optimization). Example Usage: ```python def iterative_binomial_coefficient(n, k): # Your implementation here pass print(iterative_binomial_coefficient(5, 0)) # Output: 1 print(iterative_binomial_coefficient(8, 2)) # Output: 28 print(iterative_binomial_coefficient(500, 300)) # Expected Output: 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 ``` Constraints: 1. 0 <= k <= n <= 1000 2. The solution should avoid deep recursion issues by using an iterative approach. Performance: Your implementation should be able to handle the upper limits of the input constraints efficiently. Tips: * Consider implementing an iterative version that builds Pascal\'s triangle up to the required row. * Minimize the number of multiplications and divisions to prevent overflow.","solution":"def iterative_binomial_coefficient(n, k): Returns the binomial coefficient C(n, k) using an iterative method. # Since C(n, k) = C(n, n-k) if k > n - k: k = n - k result = 1 for i in range(k): result *= (n - i) result //= (i + 1) return result"},{"question":"Bogo Sort Analysis and Implementation Bogo Sort is a highly inefficient sorting algorithm based on generating permutations of the input list until the list is sorted. Your task is to write a Bogo Sort function and deeply comprehend its inefficiencies and limitations. Task: Implement a Bogo Sort function and demonstrate it on a list of integers. # Input: * A list of integers `arr` (length n, where 1 <= n <= 10). # Output: * Return the sorted list of integers in ascending order. # Performance Requirements: * Although Bogo Sort is known for its inefficiency, your function should break out of the loop if the permutation attempts exceed 1,000,000 to safeguard against non-termination. # Edge Cases to Consider: * An already sorted list. * Completely unsorted lists and duplicates. * Empty list (edge case, but for this problem, assume at least one element). # Example Scenarios: ```python # Example 1: Simple small array arr = [3, 1, 2] # Expected Output: [1, 2, 3] # Example 2: Array with duplicates arr = [1, 2, 2, 3] # Expected Output: [1, 2, 2, 3] # Example 3: Already sorted array arr = [1, 2, 3] # Expected Output: [1, 2, 3] ``` Write the function definition for `bogo_sort(arr: List[int]) -> List[int]` and ensure it meets the above requirements.","solution":"import random def is_sorted(arr): Helper function to check if the list is sorted in ascending order. return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def bogo_sort(arr): Sorts an array using the highly inefficient BogoSort method. attempts = 0 max_attempts = 1000000 while not is_sorted(arr): random.shuffle(arr) attempts += 1 if attempts > max_attempts: break return arr"},{"question":"Given an undirected graph represented as an adjacency list, write functions to traverse the graph using both Depth-First Search (DFS) and Breadth-First Search (BFS). Implement the traversals iteratively. You should also implement a function to check if the graph is connected. # Input 1. A dictionary `graph` representing the adjacency list of an undirected graph. The keys are node identifiers, and the values are lists of adjacent nodes. 2. A starting node `start` which is a key in the graph dictionary. # Output 1. For DFS and BFS traversals, return a list of nodes in the order they are visited. 2. For the connectedness check, return a boolean indicating whether all nodes in the graph are reachable from the starting node. # Function Signatures ```python def dfs_traverse(graph: dict, start: int) -> list: pass def bfs_traverse(graph: dict, start: int) -> list: pass def is_graph_connected(graph: dict, start: int) -> bool: pass ``` # Example ```python graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2] } start = 1 dfs_traverse(graph, start) # Output: [1, 3, 2, 4] or [1, 2, 4, 3] bfs_traverse(graph, start) # Output: [1, 2, 3, 4] is_graph_connected(graph, start) # Output: True ``` # Constraints * The graph will contain at least one node and will not be null. * The start node will always be a valid node within the graph.","solution":"def dfs_traverse(graph, start): visited = [] stack = [start] while stack: node = stack.pop() if node not in visited: visited.append(node) stack.extend(reversed(graph[node])) return visited def bfs_traverse(graph, start): visited = [] queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.append(node) queue.extend(graph[node]) return visited def is_graph_connected(graph, start): visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) queue.extend(graph[node]) return len(visited) == len(graph)"},{"question":"<|Analysis Begin|> # Algorithm/Data Structure Analysis * **Algorithm/Data Structure**: Sliding Window Algorithm using Deque * **Type**: Array manipulation * **Main Purpose**: To find the maximum element of each sub-array of size `k` within a given array. # Complexity * **Time Complexity**: O(N) where N is the length of the array. Each element is processed at most twice (once added, once removed). * **Space Complexity**: O(k) for the deque, which holds at most `k` elements. # Principles 1. Use a double-ended queue (deque) to keep track of the best candidates for the current maximum in the sliding window. 2. Make sure the deque remains sorted in decreasing order based on the values in the array. 3. Only keep the indexes of elements whose window still includes them. # Characteristics & Applications * **Properties**: Efficiently maintains a deque of potential maximum candidates. * **Common Use Cases**: Suited for scenarios requiring continuous window-based maximums such as stock price analysis, temperature monitoring, or any real-time data stream processing. * **Strengths**: The algorithm is efficient and processes elements in linear time. * **Limitations**: It may require additional data handling for different types of inputs (such as checking if `k` is valid). # Implementation Challenges * **Edge Cases**: - Array length smaller than k. - All elements in the array are the same. - k equals to 1 or the length of the array. * **Performance Bottlenecks**: Although efficient, maintaining the deque and ensuring sorting may introduce minor overhead. * **Error Scenarios**: - Handling arrays of length 0 or negative values of k. * **Optimization Points**: The algorithm is already optimized for average cases. However, improved data handling and validation checks can further enhance reliability. <|Analysis End|> <|Question Begin|> # Sliding Window Maximum **Problem Statement:** You are given an array of integers and an integer `k`. Your task is to implement a function `max_sliding_window(arr, k)` that returns the maximum elements of each of its sub-arrays of length `k`. **Function Signature:** ```python def max_sliding_window(arr: List[int], k: int) -> List[int]: pass ``` **Input:** - `arr (List[int])`: A list of integers `[a1, a2, ..., an]` where `1 <= len(arr) <= 10^5` and `-10^4 <= ai <= 10^4`. - `k (int)`: An integer `1 <= k <= len(arr)` representing the length of each sub-array. **Output:** - `List[int]`: A list of integers representing the maximum of each sub-array of length `k`. **Constraints:** - `1 <= k <= len(arr)` - The array can contain both negative and positive integers. **Example:** ```python assert max_sliding_window([1,3,-1,-3,5,3,6,7], 3) == [3,3,5,5,6,7] assert max_sliding_window([9, 11], 2) == [11] assert max_sliding_window([4, -2], 1) == [4, -2] ``` # Detailed Description: - Implement the sliding window maximum efficiently using a deque (double-ended queue) to keep indices of potential candidates for max values. - For each element in the array: 1. Remove elements from the back of the deque if they are smaller than the current element, as they are not potential candidates anymore. 2. Add the current element index to the deque. 3. Remove elements from the front if they are out of the current window range. 4. Append the maximum element (front of the deque) to the result once the first window of size k is complete. # Edge Cases to Consider: - The case where `k` equals 1 (the result should be the array itself). - The case where all elements in the array are the same. - Very large arrays and ensuring the function executes within time limits. Implement the function ensuring it handles invalid cases effectively and performs efficiently.","solution":"from typing import List from collections import deque def max_sliding_window(arr: List[int], k: int) -> List[int]: Returns a list of the maximum elements in each sub-array of length k. if not arr or k == 0: return [] result = [] deq = deque() for i in range(len(arr)): # Remove elements not in the current window if deq and deq[0] < i - k + 1: deq.popleft() # Remove elements from the back of the deque if they are smaller than the current element while deq and arr[deq[-1]] < arr[i]: deq.pop() # Add the current element to the deque deq.append(i) # Append the max value to the result once the first window is fully traversed if i >= k - 1: result.append(arr[deq[0]]) return result"},{"question":"# Longest Increasing Subsequence Challenge Given an unsorted array of integers, find the length of the longest increasing subsequence. Develop an efficient solution leveraging principles and data structures suitable for competitive coding environments. **Requirements**: * Implement a function `longest_increasing_subsequence(sequence: list[int]) -> int` that returns the length of the longest increasing subsequence. * Your implementation should aim for optimal time complexity; you may choose to use dynamic programming, segment trees, or other advanced data structures. **Input Constraints**: * The input list length will be between 1 and 10^5. * The elements in the array can vary between -10^9 and 10^9. **Output**: * A single integer representing the length of the longest increasing subsequence. **Examples**: 1. **Input**: `[10, 9, 2, 5, 3, 7, 101, 18]` **Output**: `4` **Explanation**: The longest increasing subsequence is `[2, 3, 7, 101]`. 2. **Input**: `[0, 1, 0, 3, 2, 3]` **Output**: `4` **Explanation**: The longest increasing subsequence is `[0, 1, 2, 3]`. 3. **Input**: `[7, 7, 7, 7, 7, 7, 7]` **Output**: `1` **Explanation**: The longest increasing subsequence is `[7]`. **Performance Requirements**: * Aim for a time complexity of O(n log n) for optimal performance. * The implementation should handle large input sizes efficiently and must not exceed memory limits. Deliver a well-documented solution explaining the choice of algorithms and data structures used.","solution":"import bisect def longest_increasing_subsequence(sequence): Function to find the length of the longest increasing subsequence. The function uses binary search and dynamic programming to achieve an O(n log n) time complexity. Parameters: sequence (list of int): The input list of integers Returns: int: The length of the longest increasing subsequence if not sequence: return 0 dp = [] for num in sequence: idx = bisect.bisect_left(dp, num) if idx == len(dp): dp.append(num) else: dp[idx] = num return len(dp)"},{"question":"**Scenario**: You are overseeing a logging system for a hierarchical fault-tolerant network. In the event of a node failure, you need to determine how quickly to route logs back up to a non-failing node. The tree represents nodes in the network hierarchy with various fault levels (depths). **Coding Task**: Implement a function to calculate the minimum depth of a binary tree (the shortest distance from the root node to a leaf). You have the following tree node structure: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` **Function Signature**: ```python def min_depth(root: TreeNode) -> int: Calculate the minimum depth from root to a leaf node. :param root: TreeNode, root of the binary tree :return: int, the minimum depth ``` **Examples**: 1. For the following tree: ``` 3 / 9 20 / 15 7 ``` `min_depth` should return 2 (The path is 3 -> 20 -> 7). 2. For an empty tree, `min_depth` should return 0. 3. For a single node tree: ``` 1 ``` `min_depth` should return 1. **Constraints**: - You may assume that the number of nodes in the tree is in the range [0, 10^5]. - Nodes\' values are unique integers. **Performance Requirement**: - Ensure your implementation can handle large trees efficiently.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def min_depth(root: TreeNode) -> int: Calculate the minimum depth from root to a leaf node. :param root: TreeNode, root of the binary tree :return: int, the minimum depth if root is None: return 0 children = [root.left, root.right] # if we\'re at a leaf node if not any(children): return 1 min_depth_val = float(\'inf\') for child in children: if child is not None: min_depth_val = min(min_depth_val, min_depth(child)) return min_depth_val + 1"},{"question":"Given a stream of integers and a window size `k`, implement a `MovingAverage` class that calculates the moving average of the last `k` integers in the stream. The solution should make each `next` method call as efficient as possible. # Class Definition The `MovingAverage` class should have: 1. **Constructor**: `__init__(self, size: int)` - Initialize a new instance of the class with a fixed window size `size`. 2. **Method**: `next(self, val: int) -> float` - Append the integer `val` to the stream and return the current moving average of the last `k` integers. # Input and Output - **Input**: - `size`: An integer representing the size of the moving window. - `val`: Continuous integers inserted into the stream one by one. - **Output**: - For each call to `next(val)`, return a float representing the current moving average. # Constraints - The window size `size` will be between 1 and 10000. - The integers in the stream `val` will be between -10,000 and 10,000. - At most 100,000 calls will be made to the `next` method. # Performance Requirements - Ensure that each call to the `next` method runs in O(1) time complexity after pre-processing. # Example ```python m = MovingAverage(3) print(m.next(1)) # Output: 1 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.67 print(m.next(5)) # Output: 6 ``` # Implementation Challenge Implement the class with an optimized approach considering the constraints and performance requirements discussed.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize your data structure here. self.size = size self.queue = deque() self.current_sum = 0 def next(self, val: int) -> float: if len(self.queue) == self.size: self.current_sum -= self.queue.popleft() self.queue.append(val) self.current_sum += val return self.current_sum / len(self.queue)"},{"question":"Context In data analysis and database management, it is often required to segregate distinct values in sequences for effective processing. One common operation is to move all zero-valued elements to the end of the list while preserving the order of non-zero elements. Problem Statement You are tasked with writing a function `move_zeros_in_place()` that rearranges the elements of an input array by moving all zeros to the end, while preserving the order of other elements. Your implementation should not use extra space proportional to the input array size, thereby modifying the array in place. Input and Output - **Input**: - `array`: a list of elements, which can include integers, booleans, and strings. - **Output**: - The same list with all the zeros moved to the end. Constraints 1. The input list can be of variable length. 2. You may assume the input list will contain at least one element. 3. You should not convert boolean `False` to zero. 4. The order of non-zero elements must be preserved. 5. Avoid using additional space proportional to input size. Example ```python # Example 1 array = [False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"] move_zeros_in_place(array) # Output: [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] # Example 2 array = [4, 0, 5, 0, 3, 0, 2, 0] move_zeros_in_place(array) # Output: [4, 5, 3, 2, 0, 0, 0, 0] ``` Performance Requirements The algorithm should have a time complexity of O(n) and space complexity of O(1) (excluding the input and any fixed amount of extra storage used). Implementation Notes - Handle edge cases where the list contains no zeros or is full of zeros. - Ensure the implementation works efficiently on large lists. - Verify the solution with a combination of mixed data type lists. **Function Signature** ```python def move_zeros_in_place(array: list) -> None: pass ``` **Note**: The function should modify the input list in place and return `None`.","solution":"def move_zeros_in_place(array): Modifies the input list in place by moving all zeros to the end, while preserving the order of non-zero elements. Boolean False should not be considered as zero. Parameters: array (list): List containing elements which may include integers, booleans and strings. Returns: None: The function modifies the list in place and doesn\'t return anything. non_zero_index = 0 for i in range(len(array)): if array[i] != 0 or array[i] is False: array[non_zero_index] = array[i] non_zero_index += 1 for i in range(non_zero_index, len(array)): array[i] = 0 # Example usage: # array = [False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"] # move_zeros_in_place(array) # print(array) # Output: [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0]"},{"question":"You are given an array of integers that is potentially unsorted. Your task is to implement the `optimized_cocktail_shaker_sort` function that sorts the array in ascending order using the optimized cocktail shaker sort algorithm. In addition to sorting the array, your implementation should ensure handling the following: * Optimize for arrays that are already sorted by exiting as early as possible. * Minimize unnecessary comparisons after a complete pass through the list to improve performance on partially sorted arrays. # Input * A list of integers `arr`, where 0 <= len(arr) <= 10^4. # Output * A list of integers sorted in ascending order. # Constraints * You should implement the algorithm in place, so the space complexity should be O(1). * Time complexity should strive for O(N) for nearly sorted arrays while maintaining O(N^2) in the worst case. # Example ```python arr = [6, 5, 3, 1, 8, 7, 2, 4] print(optimized_cocktail_shaker_sort(arr)) #Output: [1, 2, 3, 4, 5, 6, 7, 8] arr = [1, 2, 3, 4, 5, 6, 7, 8] print(optimized_cocktail_shaker_sort(arr)) #Output: [1, 2, 3, 4, 5, 6, 7, 8] ``` # Notes * Ensure to optimize the function by taking into account scenarios where the array may already be sorted or partially sorted. * Do not use any inbuilt sorting library functions.","solution":"def optimized_cocktail_shaker_sort(arr): Sorts the array in-place using the optimized cocktail shaker sort algorithm. n = len(arr) if n < 2: return arr start = 0 end = n - 1 swapped = True while swapped: swapped = False # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break # Since the last element is already in its correct position end -= 1 swapped = False # Backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True # Since the first element is already in its correct position start += 1 return arr"},{"question":"# Isomorphic Strings Detection Two strings are defined as **isomorphic** if the characters in one string can be replaced to get the second string while preserving the order of characters. No two characters may correspond to the same character, but a character can map to itself. Your Task Write a function `is_isomorphic(s, t)` that determines if the strings `s` and `t` are isomorphic. Function Signature ```python def is_isomorphic(s: str, t: str) -> bool: ``` Input * `s` (string): The first string, where 1 <= len(s) <= 100,000. * `t` (string): The second string, with len(t) equal to len(s). Output * Return `True` if `s` and `t` are isomorphic, otherwise return `False`. Examples ```text Example 1: Input: s = \\"egg\\", t = \\"add\\" Output: True Example 2: Input: s = \\"foo\\", t = \\"bar\\" Output: False Example 3: Input: s = \\"paper\\", t = \\"title\\" Output: True ``` # Constraints 1. `s` and `t` have the same length. 2. The input strings contain only printable ASCII characters. # Performance Requirements Your implementation should be efficient with respect to time and space complexity. The expected time complexity is O(n), where `n` is the length of the input strings. The space complexity is also expected to be O(n). Scenario for Clarity Imagine you are designing a system for checking the transformation rules in encoded messages. Two messages must be isomorphic for the transformation to be valid. Implement this function to automate the verification process. Begin your implementation now!","solution":"def is_isomorphic(s: str, t: str) -> bool: Determine if the strings s and t are isomorphic. :param s: first string :param t: second string :return: True if s and t are isomorphic, False otherwise if len(s) != len(t): return False # Dictionaries to map characters from s to t and from t to s map_s_t = {} map_t_s = {} for char_s, char_t in zip(s, t): if char_s in map_s_t and map_s_t[char_s] != char_t: return False if char_t in map_t_s and map_t_s[char_t] != char_s: return False map_s_t[char_s] = char_t map_t_s[char_t] = char_s return True"},{"question":"You are provided with a binary tree. Your task is to write a function `num_empty(root)` that returns the number of empty branches in the tree. A branch is considered empty if a node has no left or right child, or if the node itself is None. A leaf node has two empty branches as both its left and right children are None. Definition * Function name: `num_empty` * Input: `root` - a root node of a binary tree. * Output: An integer representing the number of empty branches in the given tree. * Constraints: None # Example Consider the following binary tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` In this tree, there are `10` empty branches as illustrated before in the example. # Function Signature ```python def num_empty(root: Node) -> int: # Your code here pass ``` # Additional Information * **Node Structure**: Assume the following structure for the Node class. ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key ``` # Testing To validate your function, you can use the following test suite implemented using the `unittest` framework. ```python import unittest class TestSuite(unittest.TestCase): def setUp(self): self.tree = Node(9) self.tree.left = Node(6) self.tree.right = Node(12) self.tree.left.left = Node(3) self.tree.left.right = Node(8) self.tree.left.right.left = Node(7) self.tree.right.left = Node(10) self.tree.right.right = Node(15) self.tree.right.right.right = Node(18) def test_num_empty(self): self.assertEqual(10, num_empty(self.tree)) if __name__ == \'__main__\': unittest.main() ``` Ensure your function passes the test cases provided in the test suite above. You are encouraged to write additional tests to verify the correctness and performance of your function, especially for edge cases.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def num_empty(root): if root is None: return 1 left_empty = num_empty(root.left) right_empty = num_empty(root.right) return left_empty + right_empty"},{"question":"# Matrix Transformation Question Problem Statement Given an NxN matrix, implement the following functions to manipulate the matrix: `rotate_clockwise`, `rotate_counterclockwise`, `top_left_invert`, and `bottom_left_invert`. 1. `rotate_clockwise(matrix)`: Rotate the matrix 90 degrees clockwise. 2. `rotate_counterclockwise(matrix)`: Rotate the matrix 90 degrees counterclockwise. 3. `top_left_invert(matrix)`: Transpose the matrix and then reverse each column. 4. `bottom_left_invert(matrix)`: Rotate the matrix by 180 degrees. Input Format - The input to each function is a 2D list of integers representing an NxN matrix (1 ≤ N ≤ 1000). Output Format - Each function returns a new 2D list of integers representing the transformed NxN matrix. Constraints - The matrix is always valid and non-empty. - The operations must handle edge cases such as the smallest (1x1) and largest (1000x1000) matrices within a reasonable runtime. Performance Requirements - The functions should be optimized to have time complexity of O(N^2) and space complexity of O(N^2). Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] # Expected Outputs rotate_clockwise(matrix) # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] rotate_counterclockwise(matrix) # Output: [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] top_left_invert(matrix) # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] bottom_left_invert(matrix) # Output: [ # [9, 8, 7], # [6, 5, 4], # [3, 2, 1] # ] ```","solution":"def rotate_clockwise(matrix): Rotate the matrix 90 degrees clockwise. N = len(matrix) return [[matrix[N - 1 - j][i] for j in range(N)] for i in range(N)] def rotate_counterclockwise(matrix): Rotate the matrix 90 degrees counterclockwise. N = len(matrix) return [[matrix[j][N - 1 - i] for j in range(N)] for i in range(N)] def top_left_invert(matrix): Transpose the matrix and then reverse each column. N = len(matrix) # Transpose the matrix transposed_matrix = [[matrix[j][i] for j in range(N)] for i in range(N)] # Reverse each column for i in range(N): transposed_matrix[i].reverse() return transposed_matrix def bottom_left_invert(matrix): Rotate the matrix by 180 degrees. N = len(matrix) return [[matrix[N - 1 - i][N - 1 - j] for j in range(N)] for i in range(N)]"},{"question":"Objective Write a function that determines if two strings are isomorphic. Two strings are considered isomorphic if the characters in the first string can be replaced to get the second string, with a one-to-one mapping of characters preserving their order. Input & Output Specifications * **Input**: Two strings `s` and `t`. * `s` and `t` have a length `n` (`0 <= n <= 10^4`). * Both strings only contain printable ASCII characters. * **Output**: A boolean value. * `True` if the strings `s` and `t` are isomorphic. * `False` otherwise. Constraints * Both strings must be checked for the same length. * No two characters may map to the same character in another string, but a character may map to itself. * Ensure the solution works efficiently for large inputs up to length `10^4`. Example 1: ```plaintext Input: s = \\"egg\\", t = \\"add\\" Output: True Explanation: characters \'e\' and \'g\' map to \'a\' and \'d\' respectively with no conflicting mapping. ``` Example 2: ```plaintext Input: s = \\"foo\\", t = \\"bar\\" Output: False Explanation: \'o\' maps to two characters \'a\' and \'r\', causing a conflict. ``` Example 3: ```plaintext Input: s = \\"paper\\", t = \\"title\\" Output: True Explanation: \'p\' maps to \'t\', \'a\' maps to \'i\', \'e\' maps to \'l\', and \'r\' maps to \'e\', with no conflicts. ``` Function Signature ```python def are_strings_isomorphic(s: str, t: str) -> bool: pass ```","solution":"def are_strings_isomorphic(s: str, t: str) -> bool: Determines if two strings \'s\' and \'t\' are isomorphic. Two strings are isomorphic if the characters in \'s\' can be replaced to get \'t\', with a one-to-one mapping of characters. Args: s (str): The first string. t (str): The second string. Returns: bool: True if the strings are isomorphic, False otherwise. if len(s) != len(t): return False mapping_s_to_t = {} mapping_t_to_s = {} for char_s, char_t in zip(s, t): if (char_s in mapping_s_to_t and mapping_s_to_t[char_s] != char_t) or (char_t in mapping_t_to_s and mapping_t_to_s[char_t] != char_s): return False mapping_s_to_t[char_s] = char_t mapping_t_to_s[char_t] = char_s return True"},{"question":"Optimizing Exchange Sort with Early Exit Scenario To enhance the performance of the basic Exchange Sort algorithm, we aim to introduce an optimization that can handle already sorted arrays or arrays that may become sorted before all comparisons are complete. This optimization involves adding an early exit mechanism when no swaps are made during a full pass through the array. Task Implement a function `optimized_exchange_sort` that sorts an array using the Exchange Sort algorithm with an added optimization for early exit. Input * An input list of integers `arr` where `1 ≤ len(arr) ≤ 10^3` and `-10^3 ≤ arr[i] ≤ 10^3`. Output * The sorted list in ascending order. Constraints * The function should optimize cases where the array is already close to sorted. Function Signature ```python def optimized_exchange_sort(arr: List[int]) -> List[int]: # Your code here ``` Examples # Example 1 * Input: `[64, 25, 12, 22, 11]` * Output: `[11, 12, 22, 25, 64]` # Example 2 * Input: `[1, 2, 3, 4, 5]` * Output: `[1, 2, 3, 4, 5]` # Example 3 * Input: `[5, 4, 3, 2, 1]` * Output: `[1, 2, 3, 4, 5]` Notes 1. Ensure that the function handles edge cases such as empty arrays or arrays with one element efficiently. 2. Aim to improve the algorithm\'s performance by reducing unnecessary passes where possible. 3. Write clean and readable code with appropriate comments.","solution":"from typing import List def optimized_exchange_sort(arr: List[int]) -> List[int]: Sorts the array using Exchange Sort algorithm with an early exit optimization. n = len(arr) for i in range(n - 1): swapped = False for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] swapped = True if not swapped: break # Exit early if no swaps were made in the previous pass return arr"},{"question":"**Insertion Point Finder** You are tasked with developing a utility function based on the binary search principle to locate the correct insertion position of a target value within a sorted list. This function is crucial for maintaining a sorted state in a dynamically updated list. # Your task Implement the function `search_insert(array, val)` that takes a sorted list `array` and a target value `val`. # Inputs - `array` (List[int]): A sorted list of integers. - `val` (int): The target value to find the insertion position for. # Outputs - (int): The index where the target value `val` should be inserted to maintain the sorted order of the list. # Example ```python assert search_insert([1, 3, 5, 6], 5) == 2 assert search_insert([1, 3, 5, 6], 2) == 1 assert search_insert([1, 3, 5, 6], 7) == 4 assert search_insert([1, 3, 5, 6], 0) == 0 ``` # Constraints - The length of the array (len(array)) will be in the range [0, 10^4]. - The elements of the array will be in the range [−10^4, 10^4]. - If the array is empty, the index should be 0. # Optimization Considerations * Ensure that your solution runs efficiently especially under large inputs, ideally O(log n) complexity due to the array size constraints. # Function Signature ```python def search_insert(array: List[int], val: int) -> int: # implement your solution here pass ``` # Performance Requirements - Submissions must handle edge cases efficiently. - Avoid unnecessary operations to ensure optimal run-time.","solution":"def search_insert(array, val): Find the index at which `val` should be inserted to maintain sorted order in `array`. left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] < val: left = mid + 1 else: right = mid return left"},{"question":"# Square Root Approximation Context You are tasked with implementing a function to approximate the square root of a given positive integer using Newton\'s Method. Given a number `N` and a precision factor `P`, your function should return an approximation of the square root such that the maximum error is less than `P`. Task Implement the function `approximate_sqrt(N: int, P: float) -> float`. Input * `N` (1 ≤ N ≤ 10^9): The number for which the square root needs to be found. * `P` (0 < P < 1): The precision factor for the approximation. Output * Return a floating-point number, the square root approximation of `N` with an error margin less than `P`. Constraints * You should handle edge cases like N = 0 or N = 1 directly. * Your solution should run efficiently for large values of `N` up to 10^9. * Handle invalid inputs by raising appropriate exceptions. Example ``` Input: N = 5, P = 0.001 Output: A number between 2.235 and 2.237. Input: N = 16, P = 0.0001 Output: A number between 3.9999 and 4.0001. ``` Note Ensure your function: * Uses iterative improvement based on Newton\'s Method. * Checks for and handles edge cases effectively. * Runs within reasonable time limits for the maximum input constraints.","solution":"def approximate_sqrt(N: int, P: float) -> float: Approximates the square root of N using Newton\'s Method with precision P. Parameters: N (int): The number to find the square root of, must be positive. P (float): The precision factor for the result, must be a positive floating-point number. Returns: float: The approximated square root of N with error less than P. if N < 0 or P <= 0: raise ValueError(\\"N must be non-negative and P must be positive.\\") if N == 0: return 0.0 if N == 1: return 1.0 x = N while True: next_x = 0.5 * (x + N / x) if abs(x - next_x) < P: return next_x x = next_x"},{"question":"You are given two strings, `word1` and `word2`, representing two sequences of characters. Your task is to determine the minimum number of operations required to convert `word1` into `word2`. In each operation, you can delete exactly one character from either of the strings. You must implement this function using a dynamic programming approach for improved efficiency. # Function Signature ```python def minDistance(word1: str, word2: str) -> int: pass ``` # Input * `word1` (A string consisting of lowercase letters, 0 ≤ len(word1) ≤ 500) * `word2` (A string consisting of lowercase letters, 0 ≤ len(word2) ≤ 500) # Output * An integer representing the minimum number of delete operations required. # Constraints * You may assume that the length of both `word1` and `word2` will not exceed 500 characters. * The function should be able to handle empty strings. # Example Example 1: * Input: `word1 = \\"sea\\"`, `word2 = \\"eat\\"` * Output: `2` * Explanation: You need one step to delete \'s\' from \\"sea\\" to get \\"ea\\" and another step to delete \'t\' from \\"eat\\" to get \\"ea\\". Example 2: * Input: `word1 = \\"leetcode\\"`, `word2 = \\"etco\\"` * Output: `4` * Explanation: You need to delete \'l\', \'d\', \'e\', and \'o\' from \\"leetcode\\" to get \\"etco\\". # Tips * Consider leveraging a 2D list for keeping track of the operations required for each substring combination. * Think about the base cases when either of the strings is empty, and build your solution incrementally based on this.","solution":"def minDistance(word1: str, word2: str) -> int: Determine the minimum number of operations required to convert word1 into word2 via deletion. :param word1: First string consisting of lowercase letters :param word2: Second string consisting of lowercase letters :return: Minimum number of delete operations required m, n = len(word1), len(word2) # Create a DP table with (m+1) x (n+1) dimensions dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize base cases: compare each string to an empty string for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill DP table for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1 return dp[m][n]"},{"question":"# Keyboard Row Typing Challenge You are given a list of words. Each word can be typed using letters of the alphabet on only one row of an American keyboard. Implement a function that returns the words that meet this criterion. Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: pass ``` Input * A list of strings `words` where each string represents a word. Output * A list of strings containing the words which can be typed using letters from any one of the keyboard rows only. Example ```python Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] Output: [\\"Alaska\\", \\"Dad\\"] ``` Constraints 1. Each word will only contain letters. 2. The length of each word will not exceed 100. 3. The number of words will not exceed 100. Performance Requirements * Aim for a solution that is efficient in terms of both time and space complexity. Scenario Consider you are developing a feature for a typewriting software where it suggests words that can be typed without shifting hands across different rows on a keyboard. Implement this feature taking into account the constraints and requirements provided.","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: Returns the words that can be typed using letters from any one of the keyboard rows only. row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") def can_type_with_one_row(word: str) -> bool: lower_word = word.lower() if set(lower_word).issubset(row1): return True elif set(lower_word).issubset(row2): return True elif set(lower_word).issubset(row3): return True return False return [word for word in words if can_type_with_one_row(word)]"},{"question":"# Hash Table with Item Removal and Load Factor Maintenance Scenario You are tasked with implementing a resizable hash table data structure with additional functionality for efficient item removal and load factor maintenance. The hash table must support key-value pair storage, and key lookup in an average O(1) time complexity. The table should dynamically resize when the number of elements exceeds a certain threshold to maintain its efficiency. Additionally, the table should handle the deletion of elements without disrupting the order of linear probing. Instructions 1. Implement a resizable hash table with the following methods: - `put(key, value)`: Insert a key-value pair into the hash table. If the key already exists, update the value. - `get(key)`: Retrieve the value associated with a given key. If the key does not exist, return `None`. - `del_(key)`: Remove the key-value pair associated with a given key. - `resize()`: Double the size of the hash table and rehash all elements when the load factor exceeds 2/3. - Additional special methods to provide dictionary-like behavior (`__getitem__`, `__setitem__`, `__delitem__`, `__len__`, etc.). 2. Ensure the hash table handles collisions using linear probing and properly manages item removal by marking slots with deleted sentinel values. 3. Consider the following constraints: - Keys will be non-negative integers. - Handle edge cases, such as inserting into a full table or deleting non-existing keys. 4. Be mindful of performance requirements, especially during the resizing operation where all existing keys may need to be rehashed. **Function Signatures**: ```python class ResizableHashTable: def __init__(self): pass def put(self, key, value): pass def get(self, key): pass def del_(self, key): pass def resize(self): pass def __getitem__(self, key): pass def __setitem__(self, key, value): pass def __delitem__(self, key): pass def __len__(self): pass ``` Example ```python hash_table = ResizableHashTable() hash_table.put(1, \'one\') print(hash_table.get(1)) # Output: \'one\' hash_table.put(1, \'uno\') print(hash_table.get(1)) # Output: \'uno\' hash_table.del_(1) print(hash_table.get(1)) # Output: None for i in range(8): hash_table.put(i, i) print(len(hash_table)) # Output: 8 # The hash table should resize automatically here hash_table.put(8, 8) print(len(hash_table)) # Output: 9 ```","solution":"class ResizableHashTable: def __init__(self, initial_capacity=8): self.capacity = initial_capacity self.size = 0 self.table = [None] * self.capacity self.deleted = object() # Sentinel for deleted elements def _hash(self, key): return key % self.capacity def put(self, key, value): if self.size >= (2/3) * self.capacity: self.resize() index = self._hash(key) while self.table[index] is not None and self.table[index] is not self.deleted: if self.table[index][0] == key: break index = (index + 1) % self.capacity if self.table[index] is None or self.table[index] is self.deleted: self.size += 1 self.table[index] = (key, value) def get(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index] is not self.deleted and self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.capacity return None def del_(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index] is not self.deleted and self.table[index][0] == key: self.table[index] = self.deleted self.size -= 1 return True index = (index + 1) % self.capacity return False def resize(self): old_table = self.table self.capacity *= 2 self.table = [None] * self.capacity self.size = 0 for item in old_table: if item is not None and item is not self.deleted: self.put(item[0], item[1]) def __getitem__(self, key): return self.get(key) def __setitem__(self, key, value): self.put(key, value) def __delitem__(self, key): self.del_(key) def __len__(self): return self.size"},{"question":"Context You are working as a software engineer analyzing streaming data from multiple sensors. Each sensor provides data in the form of an array of integers representing measurements taken over time. Your goal is to detect peaks within a defined window of time by identifying the maximum values within each sliding window of data points. Problem Statement Given an array of integers `nums`, representing sensor measurements over time, and an integer `k`, which specifies the size of the sliding window, implement a function `max_sliding_window` that returns an array of the maximum values for each sliding window of size `k` as it moves from the beginning to the end of the array. # Function Signature ```python def max_sliding_window(nums, k): :type nums: List[int] :type k: int :rtype: List[int] ``` # Input/Output Format * **Input**: * `nums` – a list of integers, where 1 <= len(nums) <= 10^5 and -10^4 <= nums[i] <= 10^4. * `k` – an integer, where 1 <= k <= len(nums). * **Output**: * A list of integers representing the maximum values in each sliding window of size `k`. # Example ```python # Example Input nums = [1, 3, -1, -3, 5, 3, 6, 7] k = 3 # Example Output [3, 3, 5, 5, 6, 7] ``` # Constraints * Ensure your implementation efficiently handles the input size within the given constraints. * The function must run with a time complexity of O(n). Additional Requirements * Consider edge cases such as: * Empty `nums` array. * `k` equal to 1 where each element is a maximum by itself. * Negative numbers within `nums`. * Avoid using built-in functions that directly compute results for each sliding window such as `max()` within the loop as it would invalidate the expected time complexity. *Hints*: - Use a double-ended queue (deque) to maintain indices of the elements in the current window ensuring the maximum element is always at the front of the queue. - Remove indices that are out of the bounds of the current window or that are less useful (i.e., smaller than the current element).","solution":"from collections import deque def max_sliding_window(nums, k): Returns an array of the maximum values in each sliding window of size k. :type nums: List[int] :type k: int :rtype: List[int] if not nums: return [] deq = deque() # holds indexes of the nums array elements result = [] for i in range(len(nums)): # Remove indexes that are out of the current window if deq and deq[0] < i - k + 1: deq.popleft() # Remove indexes whose corresponding values are less than nums[i] while deq and nums[deq[-1]] < nums[i]: deq.pop() # Add the current element index to the deq deq.append(i) # Append the current max to the result list if i >= k - 1: result.append(nums[deq[0]]) return result"},{"question":"**Hailstone Sequence and Longest Path Challenge** You are tasked with implementing a function to generate the hailstone sequence for a given starting number and to find the starting number below a given limit that produces the longest hailstone sequence. **Function Specifications** You must implement the following two functions: 1. **hailstone(n)** - **Input**: A positive integer `n`. - **Output**: A list of integers representing the hailstone sequence starting from `n`. 2. **longest_hailstone_sequence(limit)** - **Input**: A positive integer `limit`. - **Output**: The starting number below `limit` that produces the longest hailstone sequence and the length of that sequence. - **Constraints**: * `1 < limit <= 100,000` **Example** ```python sequence = hailstone(10) print(sequence) # Output: [10, 5, 16, 8, 4, 2, 1] result = longest_hailstone_sequence(10) print(result) # Output: (9, 20) ``` In the example, calling `hailstone(10)` generates the sequence `[10, 5, 16, 8, 4, 2, 1]`. When finding the longest sequence for numbers below 10, starting number 9 yields the longest sequence with length 20. **Performance Considerations** 1. Make sure your solution is efficient enough. 2. Avoid unnecessary computations and optimize where possible by reusing previous results. **Edge Cases** - Ensure to handle the smallest (n = 1) and the largest possible values for the limit effectively. - Consider potential performance issues with very large starting values. **Testing** Make sure to test your solution with a variety of inputs, including: - Small numbers (e.g. n = 1, 2, 3). - Larger limits to ensure performance holds (e.g., limit close to 100,000). - Random values to verify correctness and efficiency.","solution":"def hailstone(n): Generate the hailstone sequence for a given starting number n. sequence = [] while n != 1: sequence.append(n) if n % 2 == 0: n //= 2 else: n = 3 * n + 1 sequence.append(1) return sequence def longest_hailstone_sequence(limit): Find the starting number below a given limit that produces the longest hailstone sequence. max_length = 0 starting_number = 0 lengths = {} for i in range(1, limit): n = i count = 0 while n != 1 and n >= i: if n % 2 == 0: n //= 2 else: n = 3 * n + 1 count += 1 lengths[i] = count + (lengths[n] if n != 1 else 1) if lengths[i] > max_length: max_length = lengths[i] starting_number = i return (starting_number, max_length)"},{"question":"Given a list of unique integers `nums` representing numbers in the range `[0, n]` with exactly one number missing, write a function `find_missing(nums: List[int]) -> int` to return the missing number. If the sequence is already complete, return the next integer in the sequence. You need to implement the function to demonstrate your understanding of the algorithm: ```python def find_missing(nums: List[int]) -> int: pass ``` # Input Format - **nums**: A list of unique integers in an arbitrary order, representing numbers in the continuous range `[0, n]` (inclusive but with one missing number). # Output Format - Return the missing number from the list. If no number is missing, return the next number that would have completed the sequence. # Constraints - The input list will contain `n` unique integers where `0 <= n <= 10^6`. # Example Test Cases Example 1 Input: nums = [4, 1, 3, 0, 6, 5, 2] Output: 7 Example 2 Input: nums = [3, 0, 1] Output: 2 Example 3 Input: nums = [] Output: 1 Example 4 Input: nums = [1] Output: 0 # Additional Information - You may assume the list does not contain duplicate values. - Consider the performance requirement when handling large input sizes.","solution":"from typing import List def find_missing(nums: List[int]) -> int: Returns the missing number in the list nums which represents numbers in the range [0, n]. If no number is missing, returns the next integer in the sequence. n = len(nums) total_sum = n * (n + 1) // 2 actual_sum = sum(nums) missing_number = total_sum - actual_sum return missing_number"},{"question":"# Question: Implement the Merge Sort algorithm Your task is to implement the Merge Sort algorithm to sort an array of integers. Given an array of integers `arr`, you need to return a new sorted array using the merge sort technique. # Input * A list of integers `arr`. # Output * A sorted list of integers. # Constraints * The length of the array `arr` will be between 0 and 10^5. * The elements of `arr` will be integers between -10^6 and 10^6. # Requirements * Must use the merge sort algorithm. * Do not use Python\'s built-in sort functions. * Minimize the usage of extra space if possible. # Performance Requirements * The algorithm should work within O(n log(n)) time complexity. # Example ```python Input: [38, 27, 43, 3, 9, 82, 10] Output: [3, 9, 10, 27, 38, 43, 82] Input: [1, 1, 1, 1] Output: [1, 1, 1, 1] Input: [] Output: [] ``` # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: ``` # Notes * You should define a helper function `merge` to be used in your merge sort implementation. * Ensure your solution is efficient and handles large inputs effectively.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the merge sort algorithm. if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted lists into one sorted list. sorted_list = [] left_index, right_index = 0, 0 # Merge the two lists while comparing elements while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 # If there are any remaining elements in the left list, add them sorted_list.extend(left[left_index:]) # If there are any remaining elements in the right list, add them sorted_list.extend(right[right_index:]) return sorted_list # Divide the list into two halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the sorted halves return merge(left_half, right_half)"},{"question":"**Scenario**: As a developer at a digital library, you are tasked with building a feature to validate book titles. One of the checks involves verifying if a title is a pangram, meaning it includes every letter of the English alphabet at least once. This is a measure of completeness and diversity of letters in book titles. **Function Signature**: ```python def is_pangram(title: str) -> bool: ``` **Input**: - `title` (string): The book title to be checked. It consists of English alphabet letters and may contain punctuation, spaces, and other symbols. **Output**: - Returns a boolean: `True` if the title is a pangram and `False` otherwise. # Constraints - The title string can have a length between 0 and 1000. - The title includes uppercase and lowercase letters, digits, spaces, and other punctuation marks. # Performance Requirements - The solution should handle the maximum length efficiently. - Aim for a linear time complexity relative to the length of the input string. # Examples 1. `is_pangram(\\"The quick brown fox jumps over the lazy dog!\\")` should return `True`. 2. `is_pangram(\\"Hello World\\")` should return `False`. 3. `is_pangram(\\"\\")` should return `False`. 4. `is_pangram(\\"Pack my box with five dozen liquor jugs.\\")` should return `True`. # Note - Ensure the function properly handles an edge case where the input string length is zero. - Handle cases with mixed alphabets and noise (punctuation, spaces). **Implementation Guide**: Implement the function `is_pangram` which uses a set to store and check the presence of each alphabet letter efficiently. Ensure the function is case-insensitive and ignores non-alphabetic characters when performing the check.","solution":"def is_pangram(title: str) -> bool: Checks if the given title is a pangram (contains every letter of the English alphabet at least once). alphabet_set = set(\'abcdefghijklmnopqrstuvwxyz\') title_set = set(char.lower() for char in title if char.isalpha()) return alphabet_set.issubset(title_set)"},{"question":"# Decoding Ways for Encoded Messages You are given an encoded message that contains digits. Each digit or pair of digits corresponds to a letter using the following mapping: ``` \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 ``` Your task is to determine the total number of ways the given encoded message can be decoded. # Input - A single string `enc_mes` containing only numeric characters \'0\' to \'9\' (1 ≤ |enc_mes| ≤ 1000). # Output - An integer representing the total number of ways to decode the message. # Function Signature ```python def count_decodings(enc_mes: str) -> int: pass ``` # Example ``` Input: \\"12\\" Output: 2 Explanation: \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12). ``` ``` Input: \\"226\\" Output: 3 Explanation: \\"226\\" can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). ``` # Constraints - The encoded message does not contain leading zeros unless the string is \\"0\\", which should return 0. - Messages containing sequences like \'30\' are invalid and should return 0. - Only \'1\' to \'26\' are valid mappings to characters. # Complexity - The solution should run in linear time with respect to the length of the encoded message. # Additional Notes - Handle edge cases including an empty string, invalid encoded segments, and large inputs efficiently.","solution":"def count_decodings(enc_mes: str) -> int: Returns the number of ways to decode an encoded message using the given mapping. if not enc_mes: return 0 if enc_mes[0] == \'0\': return 0 n = len(enc_mes) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): single_digit = int(enc_mes[i-1]) two_digit = int(enc_mes[i-2:i]) if single_digit >= 1: dp[i] += dp[i-1] if 10 <= two_digit <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"# Anagram Checker Function Objective: Create a function `anagram_list_check(strings)` that takes a list of strings and checks if any two different strings in the list are anagrams of each other. Function Signature: ```python def anagram_list_check(strings: List[str]) -> bool: ``` Input: - `strings`: A list of `n` strings (1 <= n <= 1000). Each string consists of lowercase English letters and has a length between 1 and 100 inclusive. Output: - A boolean value indicating whether any two different strings in the input list are anagrams. Example: ```python Input: [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"goeogl\\"] Output: True Input: [\\"abcd\\", \\"dcba\\", \\"bcad\\", \\"efgh\\"] Output: True Input: [\\"abcd\\", \\"efgh\\"] Output: False ``` Constraints: - Focus on an efficient solution both in terms of time and space. - Consider edge cases like strings with different lengths and strings with repeated characters. - Ensure your code handles the scenario where the list contains very short or very long strings appropriately. Additional Context: This function can be useful in applications that involve detecting similarities or patterns in textual data, such as spell checkers, plagiarism detectors, or data validation for large datasets.","solution":"from typing import List def anagram_list_check(strings: List[str]) -> bool: Returns True if any two different strings in the list are anagrams of each other, otherwise False. # Use a dictionary to store sorted version of strings as keys seen = {} for s in strings: sorted_s = \'\'.join(sorted(s)) if sorted_s in seen: return True seen[sorted_s] = True return False"},{"question":"# Question: Implement Diffie-Hellman Key Exchange Algorithm Alice and Bob need to securely exchange keys over a network. You are to implement the Diffie-Hellman Key Exchange algorithm in Python. Task Write a function `diffie_hellman_key_exchange` which takes the following input: - `a`: an integer which is a primitive root modulo `p`. - `p`: a prime integer number. - `option`: an optional verbose flag to print intermediary key values. The function should determine whether the two parties, Alice and Bob, can successfully compute the same shared secret key. Input - `a` (int): A primitive root modulo ( p ). - `p` (int): A prime number. - `option` (bool): Optional flag, if set to true, the private and public keys of Alice and Bob are printed. Output - Return `True` if Alice and Bob compute the same shared secret key. - Return `False` with appropriate print messages if the input conditions are not met (e.g., `p` is not a prime, or `a` is not a primitive root modulo `p`). Constraints - ( 2 leq p leq 10^9 ) - ( 1 leq a < p ) Example ```python a = 5 p = 23 option = True print(diffie_hellman_key_exchange(a, p, option)) # Output: True ``` **Note**: Ensure the algorithm is optimized for performance and handles edge cases appropriately. Be sure to validate the inputs and handle any potential errors gracefully.","solution":"import random def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def power_mod(base, exponent, modulus): Compute (base ^ exponent) % modulus efficiently. result = 1 base = base % modulus while exponent > 0: if exponent % 2 == 1: result = (result * base) % modulus exponent = exponent >> 1 base = (base * base) % modulus return result def is_primitive_root(a, p): Check if a is a primitive root modulo p. if not is_prime(p): return False # All primes of p - 1 fact = [] phi = p - 1 n = phi i = 2 while i * i <= n: if n % i == 0: while n % i == 0: n //= i fact.append(i) i += 1 if n > 1: fact.append(n) for factor in fact: if power_mod(a, phi // factor, p) == 1: return False return True def diffie_hellman_key_exchange(a, p, option=False): Perform Diffie-Hellman Key Exchange algorithm. if not is_prime(p): if option: print(f\\"The number {p} is not prime.\\") return False if not is_primitive_root(a, p): if option: print(f\\"The number {a} is not a primitive root modulo {p}.\\") return False # Alice\'s secret key and public key alice_private_key = random.randint(1, p-2) alice_public_key = power_mod(a, alice_private_key, p) # Bob\'s secret key and public key bob_private_key = random.randint(1, p-2) bob_public_key = power_mod(a, bob_private_key, p) # Shared secret key alice_shared_secret = power_mod(bob_public_key, alice_private_key, p) bob_shared_secret = power_mod(alice_public_key, bob_private_key, p) if option: print(f\\"Alice\'s private key: {alice_private_key}\\") print(f\\"Alice\'s public key: {alice_public_key}\\") print(f\\"Bob\'s private key: {bob_private_key}\\") print(f\\"Bob\'s public key: {bob_public_key}\\") print(f\\"Alice\'s shared secret: {alice_shared_secret}\\") print(f\\"Bob\'s shared secret: {bob_shared_secret}\\") return alice_shared_secret == bob_shared_secret"},{"question":"**Scenario**: You are a software developer tasked with maintaining a high-performance search engine backend. Given that the backend needs to handle frequent insertions and deletions of query records, you have decided to use a Red-Black Tree for this purpose. **Assignment**: Extend the Red-Black Tree implementation provided to include the following functionalities: 1. **Range Queries**: Implement a method `range_query(self, low, high)` that returns all values (in sorted order) within the given range [low, high]. 2. **Successor**: Implement a method `successor(self, val)` which returns the smallest value greater than `val` in the tree. 3. **Predecessor**: Implement a method `predecessor(self, val)` which returns the largest value smaller than `val` in the tree. **Function Signatures**: ```python class RBTree: ... def range_query(self, low: int, high: int) -> List[int]: pass def successor(self, val: int) -> int: pass def predecessor(self, val: int) -> int: pass ``` **Constraints**: - The `RBTree` contains unique integer values. - `range_query` should run in O(k + log n) time complexity where `k` is the number of nodes in the range. - Assume None is returned if there is no valid successor or predecessor. - Performance requirement: The implemented methods should maintain an average time complexity of O(log n). **Example**: ```python rb = RBTree() nodes = [20, 15, 25, 10, 18, 23, 30] for node in nodes: rb.insert(RBNode(node, 1)) print(rb.range_query(15, 25)) # Output: [15, 18, 20, 23, 25] print(rb.successor(18)) # Output: 20 print(rb.predecessor(18)) # Output: 15 print(rb.successor(30)) # Output: None print(rb.predecessor(10)) # Output: None ``` **Notes**: - Use appropriate helper methods to traverse the tree and maintain Red-Black Tree properties. - Include necessary error checking for edge cases like empty tree, value not present, etc.","solution":"class RBNode: def __init__(self, val, color, left=None, right=None, parent=None): self.val = val self.color = color self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) # Our Null node self.TNULL.left = None self.TNULL.right = None self.root = self.TNULL def preorder_helper(self, node): if node != self.TNULL: print(node.val, node.color) self.preorder_helper(node.left) self.preorder_helper(node.right) def inorder_helper(self, node): if node != self.TNULL: self.inorder_helper(node.left) print(node.val, node.color) self.inorder_helper(node.right) def postorder_helper(self, node): if node != self.TNULL: self.postorder_helper(node.left) self.postorder_helper(node.right) print(node.val, node.color) def search_tree_helper(self, node, key): if node == self.TNULL or key == node.val: return node if key < node.val: return self.search_tree_helper(node.left, key) return self.search_tree_helper(node.right, key) def balance_insert(self, k): while k.parent.color == 1: if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = 0 def __init__(self): self.TNULL = RBNode(0, 0) # Our Null node self.TNULL.left = None self.TNULL.right = None self.root = self.TNULL def insert(self, key): node = RBNode(key, 1) node.left = self.TNULL node.right = self.TNULL node.parent = None y = None x = self.root while x != self.TNULL: y = x if node.val < x.val: x = x.left else: x = x.right node.parent = y if y == None: self.root = node elif node.val < y.val: y.left = node else: y.right = node if node.parent == None: node.color = 0 return if node.parent.parent == None: return self.balance_insert(node) def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def minimum(self, node): while node.left != self.TNULL: node = node.left return node def maximum(self, node): while node.right != self.TNULL: node = node.right return node def range_query(self, low, high): def inorder_range(node, low, high, result): if node != self.TNULL: if low < node.val: inorder_range(node.left, low, high, result) if low <= node.val <= high: result.append(node.val) if high > node.val: inorder_range(node.right, low, high, result) result = [] inorder_range(self.root, low, high, result) return result def successor(self, val): node = self.search_tree_helper(self.root, val) if node == self.TNULL: return None if node.right != self.TNULL: return self.minimum(node.right).val y = node.parent while y != None and node == y.right: node = y y = y.parent return y.val if y != None else None def predecessor(self, val): node = self.search_tree_helper(self.root, val) if node == self.TNULL: return None if node.left != self.TNULL: return self.maximum(node.left).val y = node.parent while y != None and node == y.left: node = y y = y.parent return y.val if y != None else None"},{"question":"Problem Description Given a singly linked list, design a function that determines if the list contains a cycle. A linked list contains a cycle if a node\'s next pointer points to an earlier node in the sequence. If the list contains a cycle, return the node at which the cycle begins. If the list does not contain a cycle, return `None`. Input * A class definition for `ListNode`: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` * The `head` node of the singly linked list (of type `ListNode`). Output * The node where the cycle begins (if there is a cycle), or `None` if there is no cycle. Constraints * **Memory Constraint**: O(1) extra space (i.e., constant space requirement excluding the input and output). * **Performance Requirement**: O(n) time complexity, where `n` is the number of nodes in the list. Example ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_cycle_start(head): # To be implemented by the student. pass # Helper function to create a linked list with a cycle for testing. def create_linked_list_with_cycle(values, pos): if not values: return None head = ListNode(values[0]) current = head cycle_node = None if pos == 0: cycle_node = head for i, value in enumerate(values[1:], 1): current.next = ListNode(value) current = current.next if i == pos: cycle_node = current current.next = cycle_node return head # Test test_head = create_linked_list_with_cycle([3, 2, 0, -4], 1) result = find_cycle_start(test_head) # Should return the node containing value 2 print(result.val if result else None) # Expected output: 2 ``` Explanation of Example The example linked list [3, 2, 0, -4] with `pos = 1` creates a cycle that starts at the node with the value 2. The function `find_cycle_start` should return the node where the cycle begins. Instructions 1. Implement the function `find_cycle_start(head: ListNode) -> ListNode` that follows the above requirements. 2. Your implementation should correctly handle all the specified edge cases, such as an empty list or a list with no cycle.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_cycle_start(head: ListNode) -> ListNode: Detects the start of the cycle in a linked list, if any. Uses Floyd\'s Tortoise and Hare algorithm. if not head or not head.next: return None slow = head fast = head # Detect cycle using slow and fast pointers (Floyd\'s Tortoise and Hare) while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If no cycle was detected if not fast or not fast.next: return None # Reset one pointer to the beginning of the list and keep the other at the meeting point slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Question: Implement Manhattan Distance Calculation Manhattan distance, also known as the L1 distance, measures the distance between two points in a grid-based path (like city blocks). Your task is to implement a function to calculate the Manhattan distance between two given vectors. For two vectors `vec1` and `vec2` of the same length, the Manhattan distance is the sum of the absolute differences of their corresponding elements. Function Signature ```python def manhattan_distance(vec1: List[float], vec2: List[float]) -> float: ``` Input - `vec1`: A list of floats representing the first vector. - `vec2`: A list of floats representing the second vector. Both lists will have the same length, i.e., `1 <= len(vec1) == len(vec2) <= 10^5`. Output - Returns a float representing the Manhattan distance between the two vectors. Constraints - `-10^6 <= vec1[i], vec2[i] <= 10^6` Example ```python manhattan_distance([1, 2, 3], [4, 0, -1]) # output: 9.0 ``` Notes - Ensure your code runs efficiently for large inputs. - Account for the given constraints, including both positive and negative values in the vectors.","solution":"from typing import List def manhattan_distance(vec1: List[float], vec2: List[float]) -> float: Returns the Manhattan distance between two vectors. The Manhattan distance is defined as the sum of the absolute differences of the corresponding elements of the two vectors. return sum(abs(v1 - v2) for v1, v2 in zip(vec1, vec2))"},{"question":"Context You are assigned to develop a function that identifies numbers with a unique property within a specified range. These numbers, when their respective digits are raised to consecutive ascending powers, sum to the original number itself. This problem has interesting mathematical properties and is great for practicing arithmetic operations and control flows in programming. Task Write a function `special_numbers(low, high)` that returns a list of numbers within a given inclusive range `[low, high]` that meets the specified property. Function Description - **Function Name**: `special_numbers` - **Parameters**: - `low` (int): The lower bound of the range (inclusive). - `high` (int): The upper bound of the range (inclusive). - **Returns**: - A list of integers that satisfy the property. Input/Output Constraints - `0 <= low <= high <= 10^4` - Each number in the return list should be within the given range. - The returned list should be sorted in ascending order. Example ```python # Example 1 print(special_numbers(1, 10)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] # Example 2 print(special_numbers(1, 100)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] # Example 3 print(special_numbers(10, 150)) # Output: [89, 135] ``` # Additional Information - Validate your input range and ensure that `low` is less than or equal to `high`. - Handle edge cases such as the smallest range `[0, 0]`. - Optimize for performance for larger ranges by identifying opportunities to reduce redundant calculations.","solution":"def special_numbers(low, high): Returns a list of integers in the range [low, high] that satisfy the property where the sum of the digits raised to consecutive, ascending powers equals the number itself. def is_special(number): num_str = str(number) return number == sum(int(digit) ** (index + 1) for index, digit in enumerate(num_str)) return [num for num in range(low, high + 1) if is_special(num)]"},{"question":"# Elias Coding Challenge Problem Statement Given the definitions and explanations of Elias γ (gamma) and Elias δ (delta) coding algorithms, you are required to implement both in Python. The provided functions handle the encoding process for these methods, and you should extend this functionality by implementing a decoder for both Elias γ and Elias δ codes. Core Requirements 1. **Function Signature**: - `def elias_gamma_decode(encoded: str) -> int:` - `def elias_delta_decode(encoded: str) -> int:` 2. **Input/Output Formats**: - **Input**: - **`encoded`**: A string representing the Elias γ or Elias δ encoded data. - **Output**: - **return**: An integer that the encoded string represents. 3. **Constraints**: - `encoded` will be a valid Elias γ or Elias δ encoded string. - The decoded integer will be within the range [1, 10^6]. 4. **Performance Requirements**: - Decoding should be efficient and handle up to the upper constraint smoothly. Scenario You are working as a software engineer at a data compression company. You are required to decode various integers encoded using the Elias γ and Elias δ coding method. This task involves implementing the decoders corresponding to the encoders provided to ensure the correct retrieval of your compressed data. Function Definitions ```python def elias_gamma_decode(encoded: str) -> int: Decode a string encoded using Elias gamma coding method to return the integer value. Args: encoded: str: The Elias gamma encoded string Returns: int: The decoded integer pass def elias_delta_decode(encoded: str) -> int: Decode a string encoded using Elias delta coding method to return the integer value. Args: encoded: str: The Elias delta encoded string Returns: int: The decoded integer pass ``` Example ```python print(elias_gamma_decode(\'0001000\')) # Should output 9 print(elias_delta_decode(\'000010000\')) # Should output 16 ``` Implement these functions to decode Elias γ and Elias δ encoded strings and effectively retrieve the original integers.","solution":"def elias_gamma_decode(encoded: str) -> int: Decode a string encoded using Elias gamma coding method to return the integer value. Args: encoded: str: The Elias gamma encoded string Returns: int: The decoded integer # Find the length of leading zeroes leading_zeros = 0 while encoded[leading_zeros] == \'0\': leading_zeros += 1 # The length of the binary part binary_len = leading_zeros + 1 binary_part = encoded[leading_zeros:leading_zeros + binary_len] # Convert binary part to integer return int(binary_part, 2) def elias_delta_decode(encoded: str) -> int: Decode a string encoded using Elias delta coding method to return the integer value. Args: encoded: str: The Elias delta encoded string Returns: int: The decoded integer # Step 1: Decode the leading Elias gamma encoded value leading_zeros = 0 while encoded[leading_zeros] == \'0\': leading_zeros += 1 # The length of the binary representation of N in delta code gamma_length = leading_zeros + 1 gamma_encoded = encoded[leading_zeros:leading_zeros + gamma_length] N = int(gamma_encoded, 2) # Step 2: Decode the remaining part as a normal binary number binary_part = encoded[leading_zeros + gamma_length:leading_zeros + gamma_length + (N - 1)] # The decoded number if binary_part: return (1 << (N - 1)) + int(binary_part, 2) else: return (1 << (N - 1))"},{"question":"Rotate An Array **Problem Statement:** You are given an array of integers and a non-negative integer (k). Write a function to rotate the array to the right by (k) steps. **Function Signature:** ```python def rotate_array(arr: List[int], k: int) -> None: pass ``` **Input:** - `arr`: A list of integers ([a_1, a_2, ldots, a_n]). - Constraints: 1 <= len(arr) <= 10^5, -10^9 <= arr[i] <= 10^9. - `k`: A non-negative integer, indicating the number of steps to rotate the array. - Constraints: 0 <= k <= 10^5. **Output:** - The function does not return anything. The array should be modified in-place, i.e., the original array should be rotated. **Example:** ```python rotate_array([1, 2, 3, 4, 5, 6, 7], 3) # Before: [1, 2, 3, 4, 5, 6, 7] # After: [5, 6, 7, 1, 2, 3, 4] ``` **Explanation:** 1. The last three elements ([5, 6, 7]) are moved to the front. 2. The first four elements ([1, 2, 3, 4]) follow the moved elements. **Additional Information:** - Consider edge cases like empty arrays, (k) being zero, and (k) being larger than the array length. - Aim to achieve an efficient solution in terms of time and space complexity. **Hint:** - Using cyclic replacements or array reversal could enhance efficiency.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> None: Rotates the array to the right by k steps in-place. :param arr: List of integers to rotate. :param k: Number of steps to rotate the array. n = len(arr) if n == 0 or k == 0 or k % n == 0: return k = k % n # handle cases where k is greater than the array length # Reverse the entire array arr.reverse() # Reverse the first k elements arr[:k] = reversed(arr[:k]) # Reverse the rest of the array arr[k:] = reversed(arr[k:])"},{"question":"# Reversing Strings in Multiple Ways Context: Given various methods to reverse a string in Python, implement a well-optimized version that leverages the strengths of the outlined techniques. Assess your comprehension of iterative, recursive, and Python-native string operations. Task: You need to implement a function `reverse_string(s: str) -> str` that reverses the input string using the most efficient method. Given the analysis, select an appropriate method and justify your choice in comments within the code. Input: - `s` (str): A non-empty string which can contain alphanumeric characters, whitespace, and special characters. Output: - Return the reversed string. Constraints: - The string length `1 <= len(s) <= 10^6`. Performance Requirement: - Time complexity should be O(n). - Space complexity should be O(n). Example: ```python reverse_string(\\"hello world\\") # Output: \\"dlrow olleh\\" reverse_string(\\"data structures&algorithms\\") # Output: \\"smhtirogla&serutcurts atad\\" ```","solution":"def reverse_string(s: str) -> str: Returns the reversed string using slicing. This method is chosen because it\'s simple, efficient, and leverages Python\'s powerful slicing capabilities. It runs in O(n) time complexity and uses O(n) space complexity to store the reversed string. return s[::-1]"},{"question":"You are working on a text-based game where players transform words step-by-step to reach a final goal word. The permitted transformations involve changing one letter in the word at a time, and the transformations must use only valid dictionary words. Your task is to implement a function to determine the length of the shortest transformation sequence from a starting word to a goal word using a given list of dictionary words. # Function Signature: ```python def shortest_transformation_sequence_length(begin_word: str, end_word: str, word_list: List[str]) -> int: pass ``` # Input: - `begin_word` (str): The starting word. - `end_word` (str): The target word. - `word_list` (List[str]): A list containing all valid intermediary words. # Output: - (int): The length of the shortest transformation sequence, return `-1` if no such sequence is possible. # Constraints: - All words are of the same length. - All words contain only lowercase English letters. - The word list will contain at least the begin and end words. # Requirements: - The function should utilize the bidirectional BFS approach for efficiency. - Ensure efficient handling to minimize memory usage. - Consider and handle edge cases effectively. # Example: ```python begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"] assert shortest_transformation_sequence_length(begin_word, end_word, word_list) == 5 ``` In this example, one possible transformation sequence is `hit` -> `hot` -> `dot` -> `dog` -> `cog`, which has a length of 5. You can use the provided code structure as a guideline but you need to implement this function yourself taking into consideration the required optimizations and edge cases.","solution":"from collections import deque from typing import List, Set def shortest_transformation_sequence_length(begin_word: str, end_word: str, word_list: List[str]) -> int: if end_word not in word_list: return -1 word_list = set(word_list) def get_neighbors(word): neighbors = [] for i in range(len(word)): for c in \\"abcdefghijklmnopqrstuvwxyz\\": if c != word[i]: new_word = word[:i] + c + word[i+1:] if new_word in word_list: neighbors.append(new_word) return neighbors begin_set = {begin_word} end_set = {end_word} visited = set() level = 1 while begin_set and end_set: if len(begin_set) > len(end_set): begin_set, end_set = end_set, begin_set next_level = set() for word in begin_set: visited.add(word) for neighbor in get_neighbors(word): if neighbor in end_set: return level + 1 if neighbor not in visited: next_level.add(neighbor) visited.add(neighbor) begin_set = next_level level += 1 return -1"},{"question":"# Zigzag Iterator for Multiple Lists You are given `k` input integer lists. Design and implement a class `ZigZagIteratorK` that outputs elements from these lists in a zigzag manner. That is, it outputs one element from each list in turn, looping through the lists, and skips empty lists until all elements are returned. # Requirements: - The class `ZigZagIteratorK` should contain the following methods: - `__init__(self, lists: List[List[int]])`: Initializes the iterator with `k` lists. - `next(self) -> int`: Returns the next element in zigzag order. - `has_next(self) -> bool`: Returns `True` if there are still elements to be returned, `False` otherwise. # Performance Constraints: - Initialization should run in (O(k)), where (k) is the number of input lists. - `next` and `has_next` methods should run in (O(1)). # Input - `lists` (List[List[int]]): A 2D list containing integer lists. # Output - Method `next`: Returns the next integer in the zigzag order. - Method `has_next`: Returns a boolean signifying if more elements are available. # Example ```python lists = [[1, 2, 3], [4, 5, 6, 7], [8, 9]] iterator = ZigZagIteratorK(lists) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) ``` **Expected Output:** ``` [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` # Edge Cases - All lists are empty. - Lists have varying lengths. - A single non-empty list.","solution":"from collections import deque from typing import List class ZigZagIteratorK: def __init__(self, lists: List[List[int]]): Initializes the iterator with k lists. self.queue = deque((lst_idx, 0) for lst_idx, lst in enumerate(lists) if lst) self.lists = lists def next(self) -> int: Returns the next element in zigzag order. Assumes `has_next` is called beforehand to ensure there is a next element. lst_idx, elem_idx = self.queue.popleft() if elem_idx + 1 < len(self.lists[lst_idx]): self.queue.append((lst_idx, elem_idx + 1)) return self.lists[lst_idx][elem_idx] def has_next(self) -> bool: Returns True if there are still elements to be returned, False otherwise. return len(self.queue) > 0"},{"question":"# Comb Sort Implementation and Optimization Context: You have learned about sorting algorithms and their various efficiencies. One prominent algorithm, Comb Sort, is an improvement over Bubble Sort but has its constraints and optimizations to consider. Task: Given an unsorted list of integers, implement the Comb Sort algorithm and optimize it. Write a function `optimized_comb_sort` that adheres to the principles of Comb Sort but tries to address its performance limitations. Specifically, your function should handle different edge cases effectively. **Requirements**: - Your implementation should handle already sorted arrays with minimal comparisons. - Optimize the use of gap reduction for better performance with typical data. - Provide additional comments in the code to explain any enhancements or optimizations used. Input: - A single list of integers `arr` (maximum length of 10^5). Output: - A sorted list of integers. Constraints: - The list can be empty or contain up to 10^5 integers. - The integers values range from -10^6 to 10^6. Example: ```python def optimized_comb_sort(arr): # Your implementation here # Example Usage print(optimized_comb_sort([64, 34, 25, 12, 22, 11, 90])) # Output: [11, 12, 22, 25, 34, 64, 90] ```","solution":"def optimized_comb_sort(arr): An optimized implementation of the Comb Sort algorithm. def get_next_gap(gap): # Shrink gap by the shrink factor (classic value 1.3) new_gap = int(gap // 1.3) return max(new_gap, 1) # Ensure the gap is at least 1 n = len(arr) if n <= 1: return arr gap = n sorted = False while gap > 1 or not sorted: gap = get_next_gap(gap) sorted = True # Assume array is sorted for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False # We had to swap, so not sorted return arr"},{"question":"# Problem Description You are given a non-empty binary search tree (BST) and a target value which is a floating point number. Your task is to write a function `closest_value` that finds the value in the BST that is closest to the target. # Function Signature ```python def closest_value(root, target): :type root: TreeNode :type target: float :rtype: int ``` # Input - `root`: A TreeNode representing the root of a non-empty BST. - `target`: A floating point number representing the target value. # Output - Return an integer which is the value in the BST that is closest to the target. # Constraints - The BST will have at least one node. - The closest value, in case of a tie, can be the smallest or the largest among the closest values. # Example Example 1: ``` Input: root = [4, 2, 5, 1, 3] # A BST represented as a list in level-order traversal target = 3.714286 Output: 4 ``` Example 2: ``` Input: root = [1] # Tree with a single node target = 4.428571 Output: 1 ``` # Explanation In Example 1, the target 3.714286 is closer to 4 than any other values in the tree. In Example 2, since there\'s only one node in the BST, it is the closest to the target. When writing your function, carefully handle floating-point precision and ensure you compare nodes correctly based on their proximity to the target. Consider the closest value guaranteed property of BST and devise an efficient and recursive solution.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def closest_value(root, target): Finds the value in the BST that is closest to the target. :type root: TreeNode :type target: float :rtype: int closest = root.val current = root while current: if abs(current.val - target) < abs(closest - target): closest = current.val if target < current.val: current = current.left elif target > current.val: current = current.right else: break return closest"},{"question":"# Problem Description: You are tasked to compute the number of ways to choose `r` items from `n` items, which is denoted as combinations or nCr. Your goal is to implement an optimized function that computes this using dynamic programming. # Function Signature: ```python def comb_dp(n: int, r: int) -> int: pass ``` # Input and Output: * **Input**: - `n` (int): Number of items (0 ≤ n ≤ 1000) - `r` (int): Number of items to choose (0 ≤ r ≤ n) * **Output**: - Return the integer that represents the number of ways to choose `r` items from `n` items. # Constraints and Performance Requirements: * You must use a dynamic programming approach optimized for both time and space complexity. * Expected time complexity should be O(n*r) due to the nested iteration. * Manage large inputs efficiently to avoid excessive memory usage and ensure quick computation. # Example: ```python # Example 1 n = 5 r = 2 # Expected Output: 10 # Example 2 n = 10 r = 5 # Expected Output: 252 # Example 3 n = 0 r = 0 # Expected Output: 1 # Example 4 n = 30 r = 15 # Expected Output: 155117520 ``` # Additional Requirements: - Your implementation should carefully handle edge cases such as `r = 0`, `r = n` or large values of `n` and `r`. - Write clean, readable, and well-documented code. # Notes: The dynamic programming approach should allow you to efficiently compute large values using a bottom-up iterative approach, leveraging a 2D table for combination values. Consider optimizing space usage by maintaining only the necessary state.","solution":"def comb_dp(n: int, r: int) -> int: Calculate the number of ways to choose r items from n items using dynamic programming. Args: n (int): number of items (0 ≤ n ≤ 1000) r (int): number of items to choose (0 ≤ r ≤ n) Returns: int: the number of ways to choose r items from n items if r > n: return 0 if r == 0 or r == n: return 1 dp = [[0 for _ in range(r+1)] for _ in range(n+1)] # Initialize base cases for i in range(n+1): dp[i][0] = 1 # nC0 is always 1 for j in range(r+1): dp[0][j] = 0 # 0Cr, for all r > 0, is always 0 dp[0][0] = 1 # 0C0 is 1 for i in range(1, n+1): for j in range(1, min(i, r)+1): dp[i][j] = dp[i-1][j-1] + dp[i-1][j] return dp[n][r]"},{"question":"# Coding Challenge: Distinct Pair with Target Sum Problem Statement: You are given an array of integers and a target integer. Your task is to implement a function `find_pair_with_sum` that finds two distinct numbers in the array such that their sum equals the target. The function should return the indices of these two numbers as a tuple `(i, j)` where `i < j`. If no such pair exists, return `None`. Input Format: - A list of integers `nums`, representing the array. - An integer `target`, the target sum. Output Format: - Return a tuple `(i, j)` where `nums[i] + nums[j] = target` and `i < j`. - If no such pair exists, return `None`. Constraints: - Each input will have exactly one solution. - `nums` will have at least two elements. - Elements in `nums` can be positive, negative, or zero. - You may not use the same element twice. Example: ```python # Example 1: nums = [2, 7, 11, 15] target = 9 # Explanation: Because nums[0] + nums[1] = 2 + 7 = 9, return (0, 1) find_pair_with_sum(nums, target) # Output: (0, 1) # Example 2: nums = [3, 2, 4] target = 6 # Explanation: Because nums[1] + nums[2] = 2 + 4 = 6, return (1, 2) find_pair_with_sum(nums, target) # Output: (1, 2) ``` Function Signature: ```python def find_pair_with_sum(nums, target): # Your code here ```","solution":"def find_pair_with_sum(nums, target): Finds two distinct numbers in the array such that their sum equals the target. Returns the indices of these two numbers as a tuple (i, j) where i < j. If no such pair exists, returns None. :param nums: List of integers :param target: Integer target sum :return: Tuple of indices (i, j) or None seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return (seen[complement], i) seen[num] = i return None"},{"question":"**Scenario** Your task is to implement a function that verifies if a given string can be formed by interleaving two other strings while preserving their respective character orders. Imagine you are developing a text parsing feature for a software tool that reconstructs texts from fragments. The user provides a merged text and its two source fragments; you need to ensure the merged text is valid. **Function Definition** Implement the function `is_merge_recursive(s, part1, part2)` using recursion and `is_merge_iterative(s, part1, part2)` using an iterative approach. **Input Format** * **s** (string): The target string to form. * **part1** (string): The first fragment of the string. * **part2** (string): The second fragment of the string. **Output Format** Return a boolean: * `True` if `s` can be formed from an interleaving of `part1` and `part2`. * `False` otherwise. **Performance Requirements** Your solution must handle strings of up to 1000 characters efficiently. **Constraints** * The length of `s` must be equal to the combined length of `part1` and `part2`. **Examples** 1. Input: `s = \\"codewars\\", part1 = \\"cdw\\", part2 = \\"oears\\"` Output: `True` 2. Input: `s = \\"abc\\", part1 = \\"ab\\", part2 = \\"c\\"` Output: `True` 3. Input: `s = \\"abc\\", part1 = \\"ab\\", part2 = \\"\\"` Output: `False` 4. Input: `s = \\"abc\\", part1 = \\"a\\", part2 = \\"c\\"` Output: `False` Implementations of both recursive and iterative solutions are required to enforce understanding and ability to optimize algorithms.","solution":"def is_merge_recursive(s, part1, part2): Returns True if s can be formed by interleaving part1 and part2, otherwise False. if len(s) != len(part1) + len(part2): return False def dfs(i, j, k): if k == len(s): return True if i < len(part1) and part1[i] == s[k] and dfs(i + 1, j, k + 1): return True if j < len(part2) and part2[j] == s[k] and dfs(i, j + 1, k + 1): return True return False return dfs(0, 0, 0) def is_merge_iterative(s, part1, part2): Returns True if s can be formed by interleaving part1 and part2, otherwise False. if len(s) != len(part1) + len(part2): return False dp = [[False] * (len(part2) + 1) for _ in range(len(part1) + 1)] dp[0][0] = True for i in range(len(part1) + 1): for j in range(len(part2) + 1): if i > 0 and s[i + j - 1] == part1[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] if j > 0 and s[i + j - 1] == part2[j - 1]: dp[i][j] = dp[i][j] or dp[i][j - 1] return dp[len(part1)][len(part2)]"},{"question":"# Question: Implement an Enhanced Merge Sort Merge Sort is a classic divide-and-conquer algorithm for sorting an array of numbers. We have provided a simplified version of the Merge Sort algorithm that sorts an array in ascending order. For this task, you are required to enhance and implement the Merge Sort algorithm with the following improvements: 1. **Iterative Merge Sort**: Convert the provided recursive Merge Sort to an iterative (bottom-up) version to reduce space overhead. 2. **Custom Comparison**: Modify the algorithm to support a custom comparator function that defines the sorting order. 3. **Space Optimization**: Minimize the auxiliary space used during merging. # Input - An array of integers, `arr`, with length `n` (1 <= n <= 10^5). - A comparator function, `compare`, that compares two integers and returns: - A negative value if the first argument is less than the second. - Zero if they are equal. - A positive value if the first argument is greater than the second. # Output - A sorted array based on the custom comparison function. # Function Signature ```python def enhanced_merge_sort(arr: List[int], compare: Callable[[int, int], int]) -> List[int]: pass ``` # Example ```python # Example custom comparator for descending order def comparator(a, b): return b - a arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] print(enhanced_merge_sort(arr, comparator)) # Output: [9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1] ``` # Constraints and Performance Requirements - The algorithm should perform in O(n log n) time. - The auxiliary space usage should not exceed O(n) during the merge process.","solution":"from typing import List, Callable def enhanced_merge_sort(arr: List[int], compare: Callable[[int, int], int]) -> List[int]: Iterative bottom-up merge sort that uses a custom comparator function. n = len(arr) width = 1 temp = arr[:] while width < n: for i in range(0, n, 2 * width): left = i right = min(i + width, n) end = min(i + 2 * width, n) merge(arr, temp, left, right, end, compare) width *= 2 return arr def merge(arr: List[int], temp: List[int], left: int, right: int, end: int, compare: Callable[[int, int], int]): i, j, k = left, right, left while i < right and j < end: if compare(arr[i], arr[j]) <= 0: temp[k] = arr[i] i += 1 else: temp[k] = arr[j] j += 1 k += 1 while i < right: temp[k] = arr[i] i += 1 k += 1 while j < end: temp[k] = arr[j] j += 1 k += 1 for i in range(left, end): arr[i] = temp[i]"},{"question":"Scenario You have been hired to create a system for generating unique arrangements of product displays in a retail store. Each product display can have multiple items, and some items can be identical. The task is to ensure all possible configurations are unique to provide diversified setups. Problem Statement Write a function `permute_unique` that takes a list of integers, which may contain duplicates, and returns all possible unique permutations of the list. Input * A list `nums` of integers, where 0 ≤ len(nums) ≤ 10. Output * A list of lists, where each inner list represents a unique permutation of `nums`. Constraints * The algorithm should handle duplicate entries gracefully by returning only unique permutations. * The solution should be able to handle the maximum input size within reasonable time limits. Function Signature ```python def permute_unique(nums: List[int]) -> List[List[int]]: pass ``` Requirements 1. Generate all unique permutations of the input list. 2. Avoid duplicate permutations in the output. Example ```python >>> permute_unique([1, 1, 2]) [[1, 1, 2], [1, 2, 1], [2, 1, 1]] >>> permute_unique([3, 3, 3, 1]) [[3, 3, 3, 1], [3, 3, 1, 3], [3, 1, 3, 3], [1, 3, 3, 3]] >>> permute_unique([]) [[]] >>> permute_unique([0]) [[0]] ```","solution":"from typing import List import itertools def permute_unique(nums: List[int]) -> List[List[int]]: Returns all unique permutations of the input list of integers. return list(map(list, set(itertools.permutations(nums))))"},{"question":"# Context You are a software developer tasked with handling a collection of data entries stored in arrays. One frequent task is searching for particular elements within these arrays. It is crucial to implement a reliable and efficient search functionality to maintain system performance. # Task Implement a function `linear_search_modified(array, query)` that extends the behavior of the standard linear search described above. This enhanced function should handle additional constraints and return more information: # Requirements: 1. Besides returning the index of the element if found, your function should return the number of comparisons made during the search. 2. If the element is not found, your function should still return the number of comparisons made. 3. Ensure your function handles edge cases effectively (e.g., empty arrays, elements not present). # Function Signature ```python def linear_search_modified(array: list, query: int) -> tuple: Find the index of the given element in the array and return the number of comparisons made. Parameters: array (list): The list of integers to search through. query (int): The target integer to find in the array. Returns: tuple: A tuple containing two values: - The index of the query element if found, otherwise -1 - The number of comparisons made during the search # Your code here ``` # Example ```python assert linear_search_modified([1, 5, 3, 7, 9, 2], 7) == (3, 4) assert linear_search_modified([1, 5, 3, 7, 9, 2], 4) == (-1, 6) assert linear_search_modified([], 4) == (-1, 0) assert linear_search_modified([2, 2, 2], 2) == (0, 1) ``` # Constraints: - The array elements are integers. - The length of the array is between 0 and 100,000. - The query element is an integer within the range of the array\'s elements. # Performance: - Aim for an O(n) time complexity for this problem.","solution":"def linear_search_modified(array, query): Find the index of the given element in the array and return the number of comparisons made. Parameters: array (list): The list of integers to search through. query (int): The target integer to find in the array. Returns: tuple: A tuple containing two values: - The index of the query element if found, otherwise -1 - The number of comparisons made during the search comparisons = 0 for index, element in enumerate(array): comparisons += 1 if element == query: return (index, comparisons) return (-1, comparisons)"},{"question":"Scenario: You are tasked with designing a module of a project management tool where users can define dependencies between tasks. Each task is represented as a node in a directed graph, and a directed edge from task A to task B means that task B depends on task A. To optimize the task scheduling system, you need to compute the transitive closure of this dependency graph, which will allow the system to detect all indirect dependencies between tasks. Your Task: You are required to implement the function `find_transitive_closure` that takes an integer representing the number of tasks (vertices) and a list of tuples representing directed dependencies between tasks (edges) as input. Your function should return the transitive closure matrix which is a 2D list where `closure[i][j] = 1` indicates that task j is reachable from task i, and `closure[i][j] = 0` otherwise. # Function Signature ```python def find_transitive_closure(vertices: int, edges: List[Tuple[int, int]]) -> List[List[int]]: pass ``` # Input * `vertices` (int): The number of tasks. * `edges` (List[Tuple[int, int]]): A list of directed edges where each tuple (a, b) indicates a directed edge from task `a` to task `b`. # Output * `closure` (List[List[int]]): A 2D list representing the transitive closure matrix. # Performance Requirements * Aim for a solution with the stated complexities: * **Time Complexity**: O(V * (V + E)) * **Space Complexity**: O(V^2) # Constraints * 1 ≤ vertices ≤ 1000 * 0 ≤ len(edges) ≤ 5000 * All vertex indices `0 ≤ vertex < vertices` * No duplicate edges in the input list # Example Input ```python vertices = 4 edges = [(0, 1), (1, 2), (2, 3)] ``` Output ```python [[1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1]] ``` Explanation * Task 0 can reach all other tasks (0, 1, 2, 3). * Task 1 can reach tasks 1, 2, 3. * Task 2 can reach tasks 2, 3. * Task 3 can only reach itself.","solution":"def find_transitive_closure(vertices, edges): Returns the transitive closure matrix for a directed graph. Parameters: vertices (int): The number of tasks (vertices). edges (List[Tuple[int, int]]): A list of directed edges where each tuple (a, b) indicates a directed edge from task a to task b. Returns: List[List[int]]: A 2D list representing the transitive closure matrix. # Initialize the closure matrix with 0s closure = [[0] * vertices for _ in range(vertices)] # Each task is reachable from itself for i in range(vertices): closure[i][i] = 1 # Add the given edges to the closure matrix for u, v in edges: closure[u][v] = 1 # Apply the Floyd-Warshall algorithm to find the transitive closure for k in range(vertices): for i in range(vertices): for j in range(vertices): closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j]) return closure"},{"question":"# Context: You are given a singly linked list, but can only access the node to be deleted, not the list head. Write a function that will delete the given node from the list. # Function Signature: ```python def delete_node(node: Node) -> None: :param node: Node - The node to be deleted (guaranteed not to be the last node) ``` # Input: * A `Node` object representing the node to be deleted. * The input node will not be the last node in the list. # Output: * The function does not return anything. It modifies the linked list in-place. # Constraints: * You must solve the problem with O(1) time complexity for the deletion operation. * If the node or the next node is `None`, raise a `ValueError`. # Example: Given the linked list `1 -> 2 -> 3 -> 4 -> 5` and deleting the node `node` with value `3`: * Original List: `1 -> 2 -> 3 -> 4 -> 5` * After `delete_node(node)` the list should be `1 -> 2 -> 4 -> 5`. # Additional Test Cases: * When the list is `10 -> 20 -> 30 -> 40` and deleting node `node` with value `20`, the list should become `10 -> 30 -> 40`. * If the input node is `None` or the next node is `None`, raise a `ValueError`. # Notes: The function should handle edge cases by raising appropriate exceptions and guarantee constant time complexity.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def delete_node(node: Node) -> None: Deletes the given node from the linked list in O(1) time complexity. :param node: Node - The node to be deleted (guaranteed not to be the last node) if not node or not node.next: raise ValueError(\\"Node or its next node cannot be None\\") node.value = node.next.value node.next = node.next.next"},{"question":"# Task: Implement Enhanced Selection Sort with Custom Comparator Objective: Enhance the standard selection sort algorithm to allow sorting an array based on a custom comparator function. Problem Description: You are given an array and a custom comparator function. Your task is to implement the enhanced selection sort algorithm that sorts the array according to the comparator function. Function Signature: ```python def custom_selection_sort(arr: list, comparator: callable) -> list: pass ``` Input: - **arr**: List of elements to be sorted (0 ≤ len(arr) ≤ 10^3). - **comparator**: A callable that takes two arguments, `a` and `b`. It returns: - Negative if `a` should appear before `b`. - Zero if `a` and `b` are considered equal. - Positive if `a` should appear after `b`. Output: - Returns a list with elements sorted according to the comparator function. Constraints: - The array may contain any type of elements, provided the comparator can handle comparisons between them. - The array length will not exceed 1000 elements. Example: ```python # Comparator function for ascending order def ascending(a, b): return a - b # Comparator function for descending order def descending(a, b): return b - a arr = [5, 2, 9, 1, 5, 6] print(custom_selection_sort(arr, ascending)) # Output: [1, 2, 5, 5, 6, 9] print(custom_selection_sort(arr, descending)) # Output: [9, 6, 5, 5, 2, 1] ``` Additional Information: Ensure your function handles edge cases such as an empty array, arrays with identical elements, and uses the comparator function correctly to determine the sorted order.","solution":"def custom_selection_sort(arr: list, comparator: callable) -> list: Enhanced selection sort function that sorts arr according to the comparator function. Parameters: arr (list): List of elements to be sorted. comparator (callable): Comparator function defining the sort order. Returns: list: Sorted list of elements. n = len(arr) for i in range(n): min_index = i for j in range(i+1, n): if comparator(arr[j], arr[min_index]) < 0: min_index = j arr[i], arr[min_index] = arr[min_index], arr[i] return arr"},{"question":"<|Analysis Begin|> # Algorithm/Data Structure: Binary Search Tree (BST) * **Type**: Tree Data Structure * **Main Purpose**: A binary search tree (BST) is a data structure that quickly allows us to maintain a sorted list of numbers. * **Complexity**: * **Time Complexity**: * Average Case: * Search, Insert, Delete: O(log N) * Traversal (Inorder, Preorder, Postorder): O(N) * Worst Case (Skewed Tree): * Search, Insert, Delete: O(N) * **Space Complexity**: O(N) for storing N nodes. # Principles 1. **Core Operational Steps**: * Insert: Place the new value in the correct hierarchical position. * Search: Compare against the root and traverse left or right based on comparison. * Size: Count the total nodes. * Traversal: Visit nodes in a specific order (preorder, inorder, postorder). # Characteristics & Applications * **Properties**: * Each node has at most two children. * The value of each node must be greater than or equal to any values in its left subtree and less than or equal to any values in its right subtree. * **Common Use Cases**: * Efficient lookup, insertion, and deletion. * Sorted data retrieval (using inorder traversal). * **Strengths/Limitations**: * **Strengths**: Provides ordered data, efficient search, insert and delete operations. * **Limitations**: Can degenerate to a linked list (poor performance) if not balanced. # Implementation Challenges * **Edge Cases**: * Empty trees. * Inserting duplicate values. * **Performance Bottlenecks**: * Imbalance leading to skewed tree and O(N) complexity. * **Error Scenarios**: * Inserting duplicate elements. * **Optimization Points**: * Implement a self-balancing BST (e.g., AVL Tree, Red-Black Tree). <|Analysis End|> <|Question Begin|> # Context In this assessment, you will implement modifications to a Binary Search Tree (BST) class. This class will be capable of performing standard operations such as insertion, searching, finding the size, and tree traversals (inorder, preorder, postorder). Following the initial requirements, you will add a method to remove a node from the BST ensuring the tree remains a valid BST after the removal. # Function Description remove(self, data) This method should remove a node with the given data from the BST. If the node does not exist, the method should do nothing. The removal operation must maintain the properties of the BST. # Input - An integer `data` denoting the value to be removed from the BST. # Output - None. This method should modify the tree structure internally. # Constraints - Assume no duplicate elements are inserted into the BST. - The tree will contain up to 10^4 nodes. # Requirements - Implement the `remove` method in the `BST` class in Python. - The BST property must be maintained after removal. - Test your implementation with standard unittest. # Example Given BST: ``` 10 / 6 15 / / 4 9 12 24 / / 7 20 30 / 18 ``` - If you call `remove(15)`, the tree should adjust as follows: ``` 10 / 6 18 / / 4 9 12 24 / / 7 20 30 ``` # Implementation ```python class BST: #... [existing methods] def remove(self, data): def find_min(node): current = node while current.left is not None: current = current.left return current def delete_rec(root, data): if root is None: return root if data < root.data: root.left = delete_rec(root.left, data) elif data > root.data: root.right = delete_rec(root.right, data) else: # Node with only one child or no child if root.left is None: return root.right elif root.right is None: return root.left # Node with two children: Get inorder successor (smallest in the right subtree) temp = find_min(root.right) root.data = temp.data root.right = delete_rec(root.right, temp.data) return root self.root = delete_rec(self.root, data) # Add unit tests for the remove method class TestSuite(unittest.TestCase): def setUp(self): #... [existing setup] def test_remove(self): self.tree.remove(24) self.assertFalse(self.tree.search(24)) self.tree.remove(15) self.assertFalse(self.tree.search(15)) self.tree.remove(4) self.assertFalse(self.tree.search(4)) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = Node(data) else: self._insert(self.root, data) def _insert(self, node, data): if data < node.data: if node.left is None: node.left = Node(data) else: self._insert(node.left, data) elif data > node.data: if node.right is None: node.right = Node(data) else: self._insert(node.right, data) def search(self, data): return self._search(self.root, data) def _search(self, node, data): if node is None: return False if data == node.data: return True elif data < node.data: return self._search(node.left, data) else: return self._search(node.right, data) def remove(self, data): def find_min(node): current = node while current.left is not None: current = current.left return current def delete_rec(node, data): if node is None: return node if data < node.data: node.left = delete_rec(node.left, data) elif data > node.data: node.right = delete_rec(node.right, data) else: if node.left is None: return node.right elif node.right is None: return node.left temp = find_min(node.right) node.data = temp.data node.right = delete_rec(node.right, temp.data) return node self.root = delete_rec(self.root, data)"},{"question":"# Coding Task: Cocktail Shaker Sort Implementation Problem Statement Implement the Cocktail Shaker Sort algorithm to sort a list of integers in non-decreasing order. The function should utilize the bi-directional traversal approach as detailed. Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: pass ``` Input * A list of integers `arr` where 1 <= len(arr) <= 10^4 and each integer is within the range -10^6 <= arr[i] <= 10^6. Output * Return the sorted list of integers in non-decreasing order. Constraints * The algorithm should perform in-place sorting. * The function needs to handle edge cases such as empty lists, lists with single elements, and already sorted lists. Example ```python arr = [3, 0, 2, 5, -1, 4, 1] assert cocktail_shaker_sort(arr) == [-1, 0, 1, 2, 3, 4, 5] arr = [5, 1, 4, 2, 8, 0, 2] assert cocktail_shaker_sort(arr) == [0, 1, 2, 2, 4, 5, 8] arr = [1, 2, 3, 4, 5] assert cocktail_shaker_sort(arr) == [1, 2, 3, 4, 5] ``` Requirements * The function should be optimized to handle the upper limits of input size efficiently within the given constraints. * Ensure that the algorithm can gracefully handle edge cases.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts a list of integers in non-decreasing order using the Cocktail Shaker Sort algorithm. if not arr: # handle empty list return [] n = len(arr) swapped = True while swapped: swapped = False # Traverse the array from left to right as in bubble sort for i in range(0, n - 1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If no elements were swapped, the list is sorted if not swapped: break swapped = False # Traverse the array from right to left for i in range(n - 2, -1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True return arr"},{"question":"You are given a tree-like dictionary structure where each key is associated with a list of strings and/or integers. Your task is to write a function `tree_print` that traverses this dictionary and prints its contents in a structured format. The structure of the dictionary is such that each key represents a node, and its associated list contains values that can be: * Nested strings/integers directly under the key. Your print format should strictly follow these rules: 1. Print each key followed by its associated values. 2. Ensure there is an arrow (`->`) between the key and its values. 3. Move to a new line after you print all values associated with each key. 4. If the value in the list is an integer, print it on a new line with an additional leading space indented. Constraints * The dictionary will have at most 100 key-value pairs. * Each list associated with a key will contain at most 10 elements. * Elements in the list are either strings or integers. # Example ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } Expected Output: a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Function Signature ```python def tree_print(tree: dict) -> None: pass ``` Implement the `tree_print` function to match the specification provided.","solution":"def tree_print(tree: dict) -> None: for key, values in tree.items(): line = f\\"{key} -> \\" for value in values: line += f\\"{value} -> \\" print(line.rstrip(\\" -> \\"))"},{"question":"# Assessment Question Context You have been given a linked list of integers that may or may not be sorted in non-decreasing order. Your task is to implement a function that checks if a linked list is sorted. Additionally, your task will focus on identifying core properties of data integrity in a linked list structure and ensuring robustness in edge case handling. Problem Statement Write a function `is_sorted(head: Optional[ListNode]) -> bool` that takes the head of a singly linked list and returns `True` if the list is sorted in non-decreasing order, otherwise returns `False`. # Expected Input and Output Formats * **Input**: - `head`: A reference to the head node of a singly linked list. * **Output**: - `True` if the list is sorted in non-decreasing order. - `False` otherwise. # Constraints 1. The linked list\'s node values are integers. 2. The list may be empty (i.e., `head` can be `None`). 3. No duplicate values are constrained. # Performance Requirements - The function should run in O(N) time complexity, where N is the number of nodes in the linked list. - The function should use O(1) extra space, aside from the input. Example ```python # Example 1: # Input: 1 -> 2 -> 3 -> 4 # Output: True # Example 2: # Input: 1 -> 3 -> 2 # Output: False # Example 3: # Input: None # Output: True ``` Edge Cases - An empty list should be considered sorted. - A list with one element should be considered sorted. Implement the `is_sorted` function: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head: Optional[ListNode]) -> bool: # Implement the function\'s logic here pass ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next from typing import Optional def is_sorted(head: Optional[ListNode]) -> bool: if not head or not head.next: return True current_node = head while current_node.next: if current_node.val > current_node.next.val: return False current_node = current_node.next return True"},{"question":"Given a collection of integers which might include duplicates, write a function `generate_unique_permutations(nums)` to return all possible unique permutations. Function Signature ```python def generate_unique_permutations(nums: List[int]) -> List[List[int]]: ``` Input * `nums` (List[int]): A collection of integers (with possible duplicates). Output * List[List[int]]: A list containing all unique permutations of the integers in `nums`. Constraints * All integers in `nums` will lie between `-10` and `10`. * The length of `nums` will be at most `10`. Performance Requirements * The solution should be efficient in terms of both time and space, ideally handling most cases within a reasonable amount of time. Example Input: ```python nums = [1, 1, 2] ``` Output: ```python [ [1, 1, 2], [1, 2, 1], [2, 1, 1] ] ``` # Edge Cases to Consider * The function should handle an empty list. * It should appropriately manage cases where all elements are identical. * Efficiently handle cases with a high number of duplicates among the integers. # Additional Context Imagine that you are working for a company that specializes in creating unique combinations for code security systems. Your task is to develop an algorithm that reliably generates all non-repetitive permutations of a given set of numeric codes. This problem simulates a real-world scenario where uniqueness and efficiency are crucial. Implement the function `generate_unique_permutations(nums)` according to the specifications above.","solution":"from typing import List from itertools import permutations def generate_unique_permutations(nums: List[int]) -> List[List[int]]: Generate all unique permutations of a list of integers, which may include duplicates. Args: nums (List[int]): A collection of integers which might include duplicates. Returns: List[List[int]]: A list of lists, where each list is a unique permutation of the input numbers. unique_permutations = set(permutations(nums)) return [list(p) for p in unique_permutations]"},{"question":"# Problem Description You have been assigned to implement a backtracking algorithm to generate all possible abbreviations of a given word. The algorithm should produce a list of all transformations where each letter in the word can either be retained as is or replaced by a count which represents consecutive abbreviated characters. The resulting abbreviations should cover all valid combinations. # Function Signature ```python def generate_abbreviations(word: str) -> List[str]: ``` # Input * `word` (str): A non-empty string consisting only of lowercase English letters with length (1 leq text{length of word} leq 20). # Output * Returns a list of strings representing all possible abbreviations of the input word. # Constraints * Your implementation should handle up to the maximum input size efficiently. * Ensure your function is optimized to perform within reasonable time limits for the given constraints. # Example ```python assert generate_abbreviations(\\"word\\") == [ \\"word\\", \\"wor1\\", \\"wo1d\\", \\"wo2\\", \\"w1rd\\", \\"w1r1\\", \\"w2d\\", \\"w3\\", \\"1ord\\", \\"1or1\\", \\"1o1d\\", \\"1o2\\", \\"2rd\\", \\"2r1\\", \\"3d\\", \\"4\\" ] ``` # Guidelines * Use a backtracking approach to explore all combinations. * Regularly add current abbreviations to the result list. * Include thorough handling of the abbreviation count. * Do not modify the input word directly in the recursive calls; use passed state parameters for this.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: def backtrack(pos: int, cur: str, count: int): # If we\'ve reached the end, append the current string along with count (if any) if pos == len(word): result.append(cur + (str(count) if count > 0 else \\"\\")) return # Option 1: Abbreviate the character at pos backtrack(pos + 1, cur, count + 1) # Option 2: Keep the character at pos, include the abbreviation count so far if any backtrack(pos + 1, cur + (str(count) if count > 0 else \\"\\") + word[pos], 0) result = [] backtrack(0, \\"\\", 0) return result"},{"question":"# Polynomial and Monomial Arithmetic Implementation Overview You are to implement arithmetic operations (add, subtract, multiply, and divide) for monomials and polynomials. This task assesses your understanding of object-oriented programming, arithmetic operations, and edge case handling. Requirements Complete the implementation of the `Monomial` and `Polynomial` classes. Monomial A monomial is represented by its coefficients and variables: - Implement the operations `__add__`, `__sub__`, `__mul__`, `__truediv__`, and helper methods like `clean`. Polynomial A polynomial is a collection of monomials: - Implement the operations `__add__`, `__sub__`, `__mul__`, `__truediv__`, and helper methods like `subs`. Example Given the following code snippets: ```python # Implementation of Monomial({2:2}, 3) represents 3(a_2)^2 monomial1 = Monomial({2:2}, 3) monomial2 = Monomial({2:2}, 5) # Addition: 3(a_2)^2 + 5(a_2)^2 = 8(a_2)^2 result = monomial1 + monomial2 print(result) # should output the monomial with the new coefficient 8 ``` ```python # Implementation of Polynomial that represents: 3(a_1)^2 + 4(a_2) - 1 polynomial1 = Polynomial([ Monomial({1:2}, 3), Monomial({2:1}, 4), Monomial({}, -1) ]) # Addition: (3(a_1)^2 + 4(a_2) - 1) + (2(a_1)^2 - a_2 + 3) polynomial2 = Polynomial([ Monomial({1:2}, 2), Monomial({2:1}, -1), Monomial({}, 3) ]) result = polynomial1 + polynomial2 print(result) # should combine like terms and simplify the polynomial ``` Edge Cases 1. Monomials with coefficients that are zero or have all variable powers zero should be handled properly. 2. Polynomials with zero monomials should reduce to zero. 3. Handle rational numbers carefully to avoid precision errors. Performance Considerations 1. Avoid redundant checks and operations that can be streamlined. 2. Properly manage memory usage especially when dealing with a large number of variables and monomials. Implement and test your solution thoroughly to ensure all edge cases and performance considerations are addressed.","solution":"from collections import defaultdict class Monomial: def __init__(self, variables, coefficient): self.variables = variables self.coefficient = coefficient self.clean() def __add__(self, other): if self.variables == other.variables: return Monomial(self.variables, self.coefficient + other.coefficient) raise ValueError(\\"Cannot add monomials with different variables.\\") def __sub__(self, other): if self.variables == other.variables: return Monomial(self.variables, self.coefficient - other.coefficient) raise ValueError(\\"Cannot subtract monomials with different variables.\\") def __mul__(self, other): variables = defaultdict(int, self.variables) for var, power in other.variables.items(): variables[var] += power return Monomial(variables, self.coefficient * other.coefficient) def __truediv__(self, other): variables = defaultdict(int, self.variables) for var, power in other.variables.items(): variables[var] -= power if variables[var] == 0: del variables[var] return Monomial(variables, self.coefficient / other.coefficient) def clean(self): # Clean up zero coefficient or zero exponents in variables if self.coefficient == 0: self.variables.clear() else: self.variables = {var: power for var, power in self.variables.items() if power != 0} def __repr__(self): return f\\"Monomial({dict(self.variables)}, {self.coefficient})\\" class Polynomial: def __init__(self, monomials=None): if monomials is None: monomials = [] self.monomials = monomials self.clean() def clean(self): # Combine like terms and remove zero coefficient terms terms = defaultdict(int) for mono in self.monomials: key = frozenset(mono.variables.items()) terms[key] += mono.coefficient self.monomials = [Monomial(dict(key), coeff) for key, coeff in terms.items() if coeff != 0] def __add__(self, other): return Polynomial(self.monomials + other.monomials) def __sub__(self, other): return Polynomial(self.monomials + [Monomial(mono.variables, -mono.coefficient) for mono in other.monomials]) def __mul__(self, other): products = [] for mono1 in self.monomials: for mono2 in other.monomials: products.append(mono1 * mono2) return Polynomial(products) def __repr__(self): return f\\"Polynomial({self.monomials})\\""},{"question":"# Scenario You are designing a system that frequently inserts new elements into an already sorted list. To maintain efficiency, you aim to use both binary search and insertion sort principles. # Problem Write a function `binary_insertion_sort(arr)` that takes a list of integers and sorts it using an optimized insertion sort leveraging binary search to find the proper insert position. # Requirements * Use the binary search approach to locate the correct insertion index for each element. * Perform the sorting in-place within the list. # Function Signature ```python def binary_insertion_sort(arr: List[int]) -> None: Sorts the list in-place using a binary search aided insertion sort. Args: arr: List[int] - A list of integers to be sorted. Returns: None: The list is sorted in place. ``` # Example ```python input_array = [12, 11, 13, 5, 6] binary_insertion_sort(input_array) print(input_array) # Output: [5, 6, 11, 12, 13] ``` # Constraints * `1 <= len(arr) <= 1000` * `-10^3 <= arr[i] <= 10^3` for all `i` in the list # Edge Cases * Test the function with an empty list. * Test with lists having duplicate elements. * Test with an already sorted array and a reversed array. # Performance Requirements The sorting algorithm should have a time complexity better than O(n^2) for finding the insertion position by utilizing binary search.","solution":"from typing import List def binary_insertion_sort(arr: List[int]) -> None: Sorts the list in-place using a binary search aided insertion sort. Args: arr: List[int] - A list of integers to be sorted. Returns: None: The list is sorted in place. def binary_search(sub_arr, val): Helper function to find the index to insert \'val\' using binary search. low, high = 0, len(sub_arr) - 1 while low <= high: mid = (low + high) // 2 if sub_arr[mid] < val: low = mid + 1 else: high = mid - 1 return low for i in range(1, len(arr)): key = arr[i] # Find the location where \'key\' should be inserted j = binary_search(arr[:i], key) # Move all elements after index \'j\' to one position to the right arr[j+1:i+1] = arr[j:i] # Insert \'key\' at the correct position arr[j] = key"},{"question":"# Binomial Coefficient Computation Context You are working on a combinatorial problem and need to calculate the number of ways to choose k elements from a set of n elements. An efficient way to compute this is by using the binomial coefficient C(n, k). Task Write a function `binomial_coefficient_iterative(n, k)` that computes the binomial coefficient C(n, k) using an iterative approach. Specifications * **Input Format**: Two integers n and k where ( 0 leq k leq n ). * **Output Format**: Return an integer representing C(n, k). * **Constraints**: * ( 0 leq k leq n leq 10^6 ) Example Input: ```python binomial_coefficient_iterative(8, 2) ``` Output: ```python 28 ``` Requirements * Your solution should be optimized for larger inputs. * Aim for an efficient time complexity and avoid using recursion due to possible stack overflow issues. Performance Constraints * Ensure that your function runs efficiently within the provided constraints. * Handle edge cases appropriately such as ( n = k ) or ( k = 0 ).","solution":"def binomial_coefficient_iterative(n, k): Compute the binomial coefficient C(n, k) using an iterative approach. if k > n - k: # Since C(n, k) == C(n, n-k) k = n - k c = 1 for i in range(k): c = c * (n - i) // (i + 1) return c"},{"question":"# Comb Sort Implementation and Analysis **Context**: Comb Sort is an improved version of Bubble Sort designed to eliminate turtles - small values near the end of the list that move to the beginning very slowly using Bubble Sort. Comb Sort achieves this by introducing a gap between the compared elements, which reduces by a shrink factor in each iteration until it eventually performs a bubble sort when the gap becomes 1. **Task**: Implement the Comb Sort algorithm and analyze its performance on different data sets. Your task involves the following steps: 1. Implement the `comb_sort` function as described. 2. In addition to sorting, you must also validate your implementation using provided test cases. 3. Ensure that the function can handle edge cases efficiently. 4. Provide a documentation file analyzing the performance with various input datasets, highlighting the impact of the shrink factor on performance. Discuss any limitations or improvements you observe. **Function Signature**: ```python def comb_sort(arr: List[int]) -> List[int]: pass ``` **Input**: * `arr`: A list of integers `[a1, a2, ..., an]` where (1 leq n leq 10^5). **Output**: * Return a sorted list of integers in ascending order. **Constraints**: * The list may contain duplicate elements. * Your implementation must be follow time and space complexity constraints as described in the algorithm analysis above. **Performance Requirements**: * Ensure your solution efficiently handles large datasets with up to (10^5) elements. * Analyze and optimize the shrink factor if needed. **Example Input/Output**: ```python # Example 1 input: [3, 5, 1, 9, 2, 0] output: [0, 1, 2, 3, 5, 9] # Example 2 input: [8, 4, 4, 7, 6, 2, 1] output: [1, 2, 4, 4, 6, 7, 8] ``` **Explanation**: * In the first example, the input list is `[3, 5, 1, 9, 2, 0]` and gets sorted to `[0, 1, 2, 3, 5, 9]`. * In the second example, the input list is `[8, 4, 4, 7, 6, 2, 1]` which sorts to `[1, 2, 4, 4, 6, 7, 8]`.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: def get_next_gap(gap): gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n-gap): if arr[i] > arr[i+gap]: arr[i], arr[i+gap] = arr[i+gap], arr[i] swapped = True return arr"},{"question":"You are given an array of distinct positive integers and a target integer. Your task is to write a function that counts the number of different ways to sum the integers in the array to the target integer. Each integer in the array can be used multiple times. The order of elements counts as different combinations. # Input: * A list of distinct positive integers `nums`. * A positive integer `target`. # Output: * An integer representing the number of different combinations that can sum to the target. # Constraints: 1. 1 <= nums.length <= 200 2. 1 <= nums[i] <= 20 3. All elements of `nums` are distinct. 4. 1 <= target <= 1000 # Examples: ```python nums = [1, 2, 3] target = 4 ``` Example Output: ```python 7 ``` Explanation: The possible combinations are: - (1, 1, 1, 1) - (1, 1, 2) - (1, 2, 1) - (1, 3) - (2, 1, 1) - (2, 2) - (3, 1) Therefore, the output is 7. # Follow-up: * What if negative numbers are allowed in the given array? * How does it change the problem? * What limitation do we need to add to the question to allow negative numbers? # Function Signature: ```python def combination_sum(nums: List[int], target: int) -> int: pass ``` Write the `combination_sum` function to solve this problem using either the top-down or bottom-up dynamic programming approach. Ensure that your solution is efficient and adheres to the provided constraints.","solution":"from typing import List def combination_sum(nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for total in range(1, target + 1): for num in nums: if total >= num: dp[total] += dp[total - num] return dp[target]"},{"question":"# Question: Implement Hailstone Sequence Length Calculator You are given the task to implement a function that calculates the length of the hailstone sequence (also known as the Collatz sequence) for a given starting number `n`. Function Signature ```python def hailstone_length(n: int) -> int: Calculate the length of the hailstone sequence starting at n. Parameters: n (int): The starting number of the hailstone sequence. Returns: int: The length of the sequence until it reaches 1, inclusive of the starting number. ``` Example ```python assert hailstone_length(1) == 1 # Only 1 in the sequence assert hailstone_length(3) == 8 # 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1 (8 steps) ``` Constraints - `n` is a positive integer (1 ≤ `n` ≤ 10^6). - Implement the function to handle the worst-case input within 1 second. Requirements - Do not store the entire sequence; calculate and count only the length. - Ensure the function runs efficiently for large values of `n`. Use this problem to demonstrate your understanding of iterative processes and numerical algorithms. Write clean, efficient, and well-documented code.","solution":"def hailstone_length(n: int) -> int: Calculate the length of the hailstone sequence starting at n. Parameters: n (int): The starting number of the hailstone sequence. Returns: int: The length of the sequence until it reaches 1, inclusive of the starting number. length = 1 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 length += 1 return length"},{"question":"# Question You are required to implement the classic \\"FizzBuzz\\" algorithm in a more memory-efficient way. Instead of returning a list of numbers and strings, write the output directly to the console. This will demonstrate your ability to optimize space complexity using generators in Python. Function Signature: ```python def fizzbuzz_optimized(n: int) -> None: ``` Input: * An integer `n` (n >= 1) Output: * No return value; print each item in the FizzBuzz sequence on a new line. Example: ```python >>> fizzbuzz_optimized(5) 1 2 Fizz 4 Buzz ``` Constraints: * The function should handle values of n up to at least 10,000 efficiently in terms of memory usage. * Make sure to raise a `ValueError` if `n` is less than 1. Performance Requirements: * The solution should run in O(n) time complexity. * Aim for O(1) additional space complexity excluding the input and output. Points of Evaluation: 1. Correctness of the FizzBuzz logic. 2. Efficient memory usage. 3. Handling of edge cases and input validation. 4. Proper documentation and code readability. Background Context: This problem tests your ability to implement a well-known algorithm while optimizing for memory usage. By printing results directly, you can handle larger ranges of input without running into memory limitations associated with list storage.","solution":"def fizzbuzz_optimized(n: int) -> None: Prints the FizzBuzz sequence from 1 to n (inclusive). For multiples of three, print \\"Fizz\\" instead of the number. For multiples of five, print \\"Buzz\\" instead of the number. For numbers which are multiples of both three and five, print \\"FizzBuzz\\". Args: n (int): The upper limit of the range to print. Must be >= 1. Raises: ValueError: If n is less than 1. if n < 1: raise ValueError(\\"n must be greater than or equal to 1\\") for i in range(1, n + 1): output = \\"\\" if i % 3 == 0: output += \\"Fizz\\" if i % 5 == 0: output += \\"Buzz\\" print(output if output else i)"},{"question":"**Title**: Efficient Element Lookup using Binary Search in a Sorted Array **Problem Statement**: You are given a sorted array of integers and a target value. Write an efficient search algorithm using Binary Search to find the target value in the array. If the target value exists in the array, return its index. Otherwise, return -1. **Function Signature**: ```python def find_target_index(array: List[int], target: int) -> int: ``` **Input**: * `array`: A list of integers sorted in ascending order. The length of the array will be `1 <= len(array) <= 10^5`. * `target`: An integer value that we want to find in the array. **Output**: * An integer representing the index of the target value. If the target value is not present in the array, return -1. **Constraints**: * The array is non-empty and sorted in ascending order. * The values in the array and the target are all integers. * Implement the solution using an **iterative approach**. **Examples**: 1. Input: `array = [1, 2, 3, 4, 5, 6, 7]`, `target = 5` Output: `4` 2. Input: `array = [10, 20, 30, 40, 50]`, `target = 35` Output: `-1` 3. Input: `array = [5, 5, 5, 5, 5]`, `target = 5` Output: `2` (any valid index meeting the condition can be accepted) **Note**: * You should handle edge cases such as the target not existing in the array or the array having duplicate values. * Aim for a time complexity of O(log(n)) with an iterative solution to avoid recursion depth issues.","solution":"from typing import List def find_target_index(array: List[int], target: int) -> int: Finds the index of the target value using binary search in a sorted array. If the target value does not exist, returns -1. left, right = 0, len(array) - 1 while left <= right: mid = left + (right - left) // 2 if array[mid] == target: return mid elif array[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Question You are required to implement a function for calculating the least common multiple (LCM) of two non-negative integers, taking into consideration proper error handling and integer output. Function Signature ```python def lcm(a: int, b: int) -> int: pass ``` Input - Two non-negative integers, `a` and `b`. Output - An integer representing the least common multiple of `a` and `b`. Constraints - The inputs `a` and `b` can be between 0 and (10^6). Example ```python >>> lcm(15, 20) 60 >>> lcm(0, 5) 0 >>> lcm(7, 0) 0 ``` Guidelines - You must handle cases where either or both inputs are zero correctly. - Return the result as an integer, not a floating-point number. - Ensure your function is efficient and correctly handles the defined input constraints. You can use the existing `gcd` function provided in the snippets for the GCD calculation as part of your LCM computation. Implement it correctly considering the integer handling and input validity.","solution":"def gcd(a, b): Calculate the Greatest Common Divisor of a and b. while b: a, b = b, a % b return a def lcm(a: int, b: int) -> int: Calculate the Least Common Multiple of two non-negative integers a and b. if a == 0 or b == 0: return 0 return abs(a * b) // gcd(a, b)"},{"question":"You are provided with a highly inefficient sorting algorithm, Bogo Sort, which randomly shuffles the given array until it gets sorted. Your task is to implement an improved version of Bogo Sort called **\\"Count-Sort Before Shuffling (CSBS)\\"**. The CSBS algorithm will count the number of times it attempts to shuffle before finding the sorted array. # Requirements: 1. **Input**: A list of integers `arr` that needs to be sorted. 2. **Output**: A tuple containing: - The sorted list of integers. - An integer representing the total number of shuffles required to sort the array. # Constraints: - Your solution should detect sorted arrays immediately without additional shuffles. - Small arrays (length up to 5) will be tested due to Bogo Sort\'s impracticality with larger inputs. - The given list may contain positive and negative integers as well as zero. # Performance Requirements: - Since Bogo sort is inherently inefficient, there are no stringent performance requirements, but your code should exhibit correct functionality. # Scenario/Context: Imagine you are running a simulation for a randomized algorithm and want to record how many attempts it takes for the Bogo Sort to succeed. This question is designed to assess your understanding of randomization, array handling, and the importance of algorithm efficiency. # Example: ```python def csbs_bogo_sort(arr): # Your implementation here pass # Example test case arr = [3, 1, 2] print(csbs_bogo_sort(arr)) # Possible output: ([1, 2, 3], 4) ``` The function `csbs_bogo_sort` should return a tuple with the sorted list `[1, 2, 3]` and the number of shuffles it took, which can vary.","solution":"import random def is_sorted(arr): Checks if the array is sorted in non-decreasing order. return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def csbs_bogo_sort(arr): Sorts the array using an improved Bogo Sort algorithm called Count-Sort Before Shuffling (CSBS). Counts the number of shuffles required to sort the array. Parameters: arr (list): A list of integers to sort. Returns: tuple: A tuple where the first element is the sorted list, and the second element is the number of shuffles required to sort the list. shuffles = 0 while not is_sorted(arr): random.shuffle(arr) shuffles += 1 return arr, shuffles"},{"question":"# Coin Change Problem - Number of Combinations Background In a hypothetical country, there is an unlimited supply of certain denominations of coins. The government needs a program that can determine the number of potential ways citizens can sum a specific monetary value using any combination of these coins. Given a value and an array of coin denominations, find out how many ways you can sum up to the value using any combination of the given denominations. Problem Statement Write a function `def count(coins: List[int], value: int) -> int:` that calculates the number of ways to make change for a given value using a set of coin denominations. Input - `coins`: A list of integers representing the denominations of available coins. (1 <= len(coins) <= 100) - `value`: An integer representing the target value we want to achieve using the coins. (0 <= value <= 10000) Output - Return an integer representing the number of ways to make up the `value` using the given coin denominations. Constraints - Assume that all coin values are positive. - The order of using coins does not matter, so different permutations of the same set of coins are considered the same. Example ```python # Example 1: print(count([1, 2, 3], 4)) # Output: 4 # Example 2: print(count([2, 5, 3, 6], 10)) # Output: 5 ``` Notes - Consider base cases and edge conditions such as when `value` is `0`. - The DP approach should efficiently handle the upper limits of the input range.","solution":"from typing import List def count(coins: List[int], value: int) -> int: Returns the number of ways to make change for the given value using the given denominations of coins. # Create a list to store the computed number of ways to make change for each amount up to `value` dp = [0] * (value + 1) # There is one way to make the value 0, which is to use no coins at all dp[0] = 1 # Iterate over each coin for coin in coins: # Update the dp array for each amount that can be achieved using the current coin for i in range(coin, value + 1): dp[i] += dp[i - coin] return dp[value]"},{"question":"Implement a function `first_occurrence(array, query)` to find the index of the first occurrence of a given element in a sorted array using binary search. The array will be sorted in non-decreasing order. If the element is not present in the array, it should return -1. Your solution should be optimized for large input sizes. # Function Signature ```python def first_occurrence(array: List[int], query: int) -> int: ``` # Input - `array`: A list of integers, sorted in non-decreasing order, with a length `n` (0 <= n <= 10^6). - `query`: An integer representing the element to search for. # Output - Return the index of the first occurrence of `query` in `array`. - If the element is not present in the array, return -1. # Examples ```python assert first_occurrence([1, 2, 2, 2, 3], 2) == 1 assert first_occurrence([1, 2, 3, 4, 5], 3) == 2 assert first_occurrence([1, 2, 3, 4, 5], 6) == -1 assert first_occurrence([], 1) == -1 assert first_occurrence([1,1,1,1,1], 1) == 0 assert first_occurrence([1,2,3,3,3,4,5], 3) == 2 ``` # Constraints - The array may contain duplicates, and your function should find the first occurrence of `query`. - Optimize for time complexity O(log n) and space complexity O(1).","solution":"from typing import List def first_occurrence(array: List[int], query: int) -> int: Finds the index of the first occurrence of query in array using binary search. Parameters: array (List[int]): A list of sorted integers. query (int): The target integer to find in the array. Returns: int: The index of the first occurrence of query in array, or -1 if not found. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid right = mid - 1 # Continue searching in the left half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"**Scenario**: You are developing a part of a cryptographic library that requires identifying primitive roots of a given number `n`. Understanding this requires knowledge of number theory, particularly Euler\'s Totient function and modular arithmetic. **Objective**: Implement a function that finds all primitive roots of a given integer `n`. # Function Signature ```python def find_primitive_roots(n: int) -> list: ``` # Input * An integer `n` (1 ≤ `n` ≤ 10^4) # Output * A list of integers representing all primitive roots of `n`. # Constraints * Handle edge cases like `n = 1`. * Ensure efficient computation within provided constraints. # Example ```python assert find_primitive_roots(1) == [0] assert find_primitive_roots(7) == [3, 5] assert find_primitive_roots(9) == [2, 5] ``` # Notes * If `n = 1`, the only primitive root is 0. * If no primitive roots exist for `n`, return an empty list. * Ensure to manage computational complexity effectively, especially for higher values of `n`. **Instructions**: 1. Implement the `find_primitive_roots` function based on provided analysis and code snippets. 2. Ensure to handle special cases and input constraints. 3. Optimize for performance where possible.","solution":"from math import gcd def euler_totient(n): Calculate Euler\'s Totient function φ(n). result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def is_primitive_root(n, g): Check if g is a primitive root of n. if gcd(g, n) != 1: return False phi = euler_totient(n) factors = set() k = 2 original_phi = phi while k * k <= original_phi: if phi % k == 0: factors.add(k) while phi % k == 0: phi = phi // k k += 1 if phi > 1: factors.add(phi) for factor in factors: if pow(g, original_phi // factor, n) == 1: return False return True def find_primitive_roots(n): Find all primitive roots of the given integer n. if n == 1: return [0] primitive_roots = [] for g in range(1, n): if is_primitive_root(n, g): primitive_roots.append(g) return primitive_roots"},{"question":"# Matrix Chain Multiplication You are given a sequence of matrices, and you have to find the most efficient way to multiply these matrices together. The task is to find the minimum number of multiplications needed to multiply the chain of matrices. Each matrix `Ai` has dimensions `p[i-1] x p[i]` for `i = 1` to `n`. Given an array `p` representing the dimensions of the matrices, your task is to write a function `matrix_chain_order(p)` that returns the minimum number of scalar multiplications needed to compute the matrix product, along with a function `print_optimal_solution(optimal_solution, i, j)` that prints the optimal order of matrix multiplication. Function Signatures ```python def matrix_chain_order(p: List[int]) -> Tuple[List[List[int]], List[List[int]]]: Finds the optimal order to multiply matrices. Input: p : List[int] - array representing the dimensions of the matrices. Output: matrix : List[List[int]] - 2D list storing the minimum multiplication cost. sol : List[List[int]] - 2D list storing the optimal split points. pass def print_optimal_solution(optimal_solution: List[List[int]], i: int, j: int) -> None: Prints the optimal solution of matrix multiplication. Input: optimal_solution : List[List[int]] - 2D list storing the optimal split points. i : int - starting index for printing the solution. j : int - ending index for printing the solution. pass ``` # Input * A list `p` of integers where `p[i]` represents the number of rows of the matrix `A[i]` and `p[i+1]` represents the number of columns of the matrix `A[i]`. # Output * The function `matrix_chain_order` should return two 2D lists: * `matrix` where `matrix[i][j]` stores the minimum number of multiplications needed to compute the product of matrices `A[i]` to `A[j]`. * `sol` where `sol[i][j]` stores the index of the matrix after which the optimal split occurs. * The function `print_optimal_solution` should print the optimal order of matrix multiplication. # Constraints * 1 <= len(p) <= 100 * 1 <= p[i] <= 1000 # Example ```python p = [30, 35, 15, 5, 10, 20, 25] matrix, optimal_solution = matrix_chain_order(p) print(\\"Minimum number of multiplications is\\", matrix[1][len(p)-1]) print(\\"Optimal order of matrix multiplication is:\\") print_optimal_solution(optimal_solution, 1, len(p) - 1) ``` # Expected Output The expected output in the example should be: ``` Minimum number of multiplications is 15125 Optimal order of matrix multiplication is: ((A1 (A2 A3)) ((A4 A5) A6)) ``` # Notes: * Ensure to handle edge cases such as single matrix multiplication. * Consider performance implications for larger input sizes due to the cubic time complexity.","solution":"from typing import List, Tuple def matrix_chain_order(p: List[int]) -> Tuple[List[List[int]], List[List[int]]]: n = len(p) - 1 # Number of matrices matrix = [[0 for _ in range(n)] for _ in range(n)] sol = [[0 for _ in range(n)] for _ in range(n)] for length in range(2, n + 1): # length is the chain length for i in range(n - length + 1): j = i + length - 1 matrix[i][j] = float(\'inf\') for k in range(i, j): q = matrix[i][k] + matrix[k + 1][j] + p[i] * p[k + 1] * p[j + 1] if q < matrix[i][j]: matrix[i][j] = q sol[i][j] = k return matrix, sol def print_optimal_solution(optimal_solution: List[List[int]], i: int, j: int) -> None: if i == j: print(f\\"A{i + 1}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(optimal_solution, i, optimal_solution[i][j]) print_optimal_solution(optimal_solution, optimal_solution[i][j] + 1, j) print(\\")\\", end=\\"\\") # Example usage p = [30, 35, 15, 5, 10, 20, 25] matrix, optimal_solution = matrix_chain_order(p) print(\\"Minimum number of multiplications is\\", matrix[0][len(p)-2]) print(\\"Optimal order of matrix multiplication is:\\") print_optimal_solution(optimal_solution, 0, len(p) - 2) print()"},{"question":"Remove Minimum Value from an Array with a Stack-like Approach Background You are given a stack-like data structure, implemented using a list in Python. Your goal is to develop a function that removes the smallest value from this stack while preserving the order of the remaining elements. Task Write a function `remove_min(arr)` that takes a list `arr` representing a stack, removes the smallest value, and returns the modified list. The operation must maintain the original order of elements except for the removed minimum value. Function Signature ```python def remove_min(arr: list) -> list: pass ``` Input and Output * **Input**: A list `arr` containing integers, which operates as a stack where the last element is the top of the stack. * **Output**: A list with the smallest value removed, maintaining the original order of other elements. Constraints * You should not use any built-in functions that directly solve the problem (e.g., `min`). * If the list is empty, return the empty list. * If the smallest value appears multiple times, only the first occurrence (from the bottom of the stack) should be removed. Examples ```python # Example 1 arr = [2, 8, 3, -6, 7, 3] result = remove_min(arr) # Expected output: [2, 8, 3, 7, 3] # Example 2 arr = [5, 1, 9, 1, 2] result = remove_min(arr) # Expected output: [5, 9, 1, 2] # Example 3 arr = [] result = remove_min(arr) # Expected output: [] ``` Notes * Ensure your solution is efficient by minimizing the number of times you traverse the input list. * Take care of edge cases such as an empty list and multiple instances of the minimum value.","solution":"def remove_min(arr): Removes the smallest value from the stack-like list \'arr\' while preserving the order of the remaining elements. if not arr: return arr min_value = arr[0] for num in arr: if num < min_value: min_value = num result = [] removed = False for num in arr: if num == min_value and not removed: removed = True else: result.append(num) return result"},{"question":"You are given a problem where you need to compute the nth power of a number `a`. In some cases, you may need to compute this under modulo `mod`. Your task is to implement two functions: 1. **iterative_power(a, n, mod=None)**: This function should compute `a^n` using an iterative binary exponentiation approach. If `mod` is specified, compute `(a^n) % mod`. 2. **recursive_power(a, n, mod=None)**: This function should compute `a^n` using a recursive binary exponentiation approach. If `mod` is specified, compute `(a^n) % mod`. Both functions should handle large values of `n` efficiently with a logarithmic time complexity. Function Signatures: ```python def iterative_power(a: int, n: int, mod: int = None) -> int: pass def recursive_power(a: int, n: int, mod: int = None) -> int: pass ``` Input: - `a` (integer): The base number (0 ≤ |a| ≤ 10^9) - `n` (integer): The exponent (0 ≤ n ≤ 10^9) - `mod` (integer, optional): The modulo value (1 ≤ mod ≤ 10^9) Output: - Return the result of the exponentiation (`a^n`) or (`a^n % mod` if `mod` is specified). Constraints: - You must implement both the iterative and recursive versions. - The solution must handle large integers efficiently and within the constraints of logarithmic complexity. Example: ```python assert iterative_power(2, 10) == 1024 assert iterative_power(2, 10, 1000) == 24 assert recursive_power(3, 5) == 243 assert recursive_power(3, 5, 100) == 43 assert recursive_power(5, 0) == 1 assert iterative_power(5, 0) == 1 ``` Notes: - Be cautious about edge cases like zero exponents or very large values of `n`. - Consider the differences in handling space for iterative and recursive methods.","solution":"def iterative_power(a: int, n: int, mod: int = None) -> int: result = 1 base = a if mod is None else a % mod while n > 0: if n % 2 == 1: # If n is odd, multiply the current result by the base result = (result * base) if mod is None else (result * base) % mod base = (base * base) if mod is None else (base * base) % mod n //= 2 # Divide n by 2 return result def recursive_power(a: int, n: int, mod: int = None) -> int: if n == 0: return 1 if n % 2 == 0: half_power = recursive_power(a, n // 2, mod) full_power = (half_power * half_power) if mod is None else (half_power * half_power) % mod else: partial_power = recursive_power(a, n - 1, mod) full_power = a * partial_power if mod is None else (a * partial_power) % mod return full_power"},{"question":"Scenario: As a programmer, you often need to preprocess strings to ensure they meet certain criteria. One common requirement is to remove any repeated characters from a string, leaving only the first occurrence of each character. This is useful in many contexts, such as cleaning user inputs or preparing strings for further processing where uniqueness is required. Task: You are tasked with implementing a function `delete_reoccurring_characters` that removes any duplicate characters from a given input string while maintaining the order of first occurrences. Function Signature: ```python def delete_reoccurring_characters(string: str) -> str: ``` Input: * A single string, `string` (0 ≤ len(string) ≤ 10^5), consisting of printable ASCII characters. Output: * A new string that contains only the first occurrence of each character from the input string. Constraints: * The function should aim for linear time complexity, O(n). * Auxiliary space should also be O(n) considering the use of sets and the resulting string. # Examples 1. Input: \\"hello\\" Output: \\"helo\\" 2. Input: \\"\\" Output: \\"\\" 3. Input: \\"mississippi\\" Output: \\"misp\\" 4. Input: \\"abcabcabc\\" Output: \\"abc\\" # Additional Notes: * Consider scenarios involving an empty string. * Ensure that the function is efficient for long strings up to length 100,000. # Implementation Notes: * Think carefully about the most efficient way to build the output string. * Remember to maintain the order of first appearances of characters.","solution":"def delete_reoccurring_characters(string: str) -> str: Removes duplicate characters from the input string, keeping only the first occurrence of each character while maintaining the order of their first appearance. Parameters: string (str): The input string from which to remove duplicate characters. Returns: str: A new string with only the first occurrence of each character. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Matrix Chain Multiplication Optimization Given a series of matrices, the goal is to determine the most efficient way to multiply these matrices together. The cost of multiplying two matrices is defined by the number of scalar multiplications needed. The task is to return the minimum number of scalar multiplications required to compute the product of the given matrix chain. Problem: You are given the dimensions of a chain of matrices such that the `i`-th matrix `A[i]` has dimensions `p[i-1] x p[i]`. Your task is to implement a function that determines the minimum number of scalar multiplications needed to compute the matrix chain product. Input: * `p`: A list of integers where the `i-th` matrix has dimensions `p[i-1] x p[i]`. Output: * Return an integer which is the minimum number of scalar multiplications needed. Example: ```python def matrix_chain_order(p: list) -> int: # Your code here # Example Usage: # For matrices with dimensions 1x2, 2x3, 3x4 the list p would be [1, 2, 3, 4] print(matrix_chain_order([1, 2, 3, 4])) # Expected output: 18 ``` Constraints: * `2 ≤ len(p) ≤ 100` * `1 ≤ p[i] ≤ 500` Explanation: To minimize the computational cost, dynamic programming (DP) should be used. The problem should be solved using a DP table where `dp[i][j]` will represent the minimum number of multiplications needed to multiply matrices from `i` to `j`. Use the matrix chain multiplication algorithm to derive the solution. Consider every possible place to split and minimize the cost recursively.","solution":"def matrix_chain_order(p: list) -> int: n = len(p) - 1 dp = [[0 for _ in range(n)] for _ in range(n)] for l in range(2, n + 1): for i in range(n - l + 1): j = i + l - 1 dp[i][j] = float(\'inf\') for k in range(i, j): q = dp[i][k] + dp[k + 1][j] + p[i] * p[k + 1] * p[j + 1] if q < dp[i][j]: dp[i][j] = q return dp[0][n - 1]"},{"question":"# Integer Decomposition Problem Given a positive integer, your task is to write a function that determines the number of ways it can be decomposed into sums of positive integers. Function Signature ```python def int_divide(n: int) -> int: ``` Input * An integer `n` (1 <= n <= 200), representing the positive integer to decompose. Output * An integer representing the number of different ways to decompose `n`. Specifications * The decomposition must be into sums of positive integers. * The order of summands does not matter (e.g., `4 = 3 + 1` is considered the same as `4 = 1 + 3`). Example * **Example 1**: * Input: `4` * Output: `5` * Explanation: ``` 4=4 4=3+1 4=2+2 4=2+1+1 4=1+1+1+1 ``` * **Example 2**: * Input: `7` * Output: `15` * Explanation: ``` 7=7 7=6+1 7=5+2 7=5+1+1 7=4+3 7=4+2+1 7=4+1+1+1 7=3+3+1 7=3+2+2 7=3+2+1+1 7=3+1+1+1+1 7=2+2+2+1 7=2+2+1+1+1 7=2+1+1+1+1+1 7=1+1+1+1+1+1+1 ``` Note * Ensure that your function handles edge cases efficiently. * Performance constraints: Aim for O(n^2) complexity for both time and space. Good luck!","solution":"def int_divide(n: int) -> int: dp = [0] * (n + 1) dp[0] = 1 # base case: one way to partition zero for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"# Longest Common Prefix (LCP) Challenge Given an array of strings, write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \\"\\". Functional Requirements * **Function Name**: longest_common_prefix * **Input**: A list of strings, e.g., `[\\"flower\\",\\"flow\\",\\"flight\\"]` * **Output**: A single string that represents the longest common prefix, e.g., `\\"fl\\"` Constraints * All inputs are in lowercase letters a-z. * The array size will be in the range [1, 200]. * The length of any single string will be in the range [0, 200]. Performance Requirements * The function should aim to have efficient time and space complexity, considering constraints. Example **Example 1:** * Input: `[\\"flower\\",\\"flow\\",\\"flight\\"]` * Output: `\\"fl\\"` **Example 2:** * Input: `[\\"dog\\",\\"racecar\\",\\"car\\"]` * Output: `\\"\\"` * Explanation: There is no common prefix among the input strings. **Example 3:** * Input: `[\\"interspecies\\",\\"interstellar\\",\\"interstate\\"]` * Output: `\\"inters\\"` # Evaluation Criteria * Correctness: The solution should produce the correct longest common prefix. * Efficiency: The solution should work well given the constraints. * Code Quality: The code should be clean, well-documented, and formatted.","solution":"def longest_common_prefix(strs): Returns the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string. if not strs: return \\"\\" # Start with the first word\'s entire length as the prefix prefix = strs[0] for string in strs[1:]: while not string.startswith(prefix): # Shorten the prefix by one character and check again prefix = prefix[:-1] if not prefix: return \\"\\" return prefix"},{"question":"# Coding Challenge: Binary Tree Postorder Traversal **Context**: You have been tasked with implementing a function to return the postorder traversal of a binary tree, a fundamental tree traversal technique useful in various applications like expression evaluation and tree deletion. **Specification**: * Implement two functions `postorder_iterative(root)` and `postorder_recursive(root)` that return the postorder traversal of a binary tree. **Function Definitions**: 1. `postorder_iterative(root: Node) -> List[int]` 2. `postorder_recursive(root: Node) -> List[int]` **Input**: * `root`: The root node of a binary tree. **Output**: * A list of integers representing the node values accessed in postorder traversal order. **Constraints**: * The number of nodes in the binary tree is between `0` and `10^4`. * Each node\'s value is a distinct integer. **Example**: ```python # Define the tree # 1 # / # 2 3 # / # 4 5 root = Node(1, Node(2, Node(4), Node(5)), Node(3)) assert postorder_iterative(root) == [4, 5, 2, 3, 1] assert postorder_recursive(root) == [4, 5, 2, 3, 1] ``` **Guidelines**: 1. In the iterative approach, leverage a stack to simulate the recursive process. 2. Ensure your recursive solution does not cause stack overflow for deep trees. 3. Handle edge cases such as an empty tree and single-node trees. **Performance Requirements**: Your solution should run efficiently within the provided constraints, achieving a time complexity of O(n) and a linear space complexity. Implement the required functions: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_iterative(root: Node) -> List[int]: # Your code here pass def postorder_recursive(root: Node) -> List[int]: # Your code here pass ```","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_iterative(root: Node): if root is None: return [] stack, result = [], [] stack.append(root) while stack: node = stack.pop() result.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return result[::-1] def postorder_recursive(root: Node): result = [] def helper(node): if node: helper(node.left) helper(node.right) result.append(node.val) helper(root) return result"},{"question":"You are provided with a non-empty string. Your task is to determine whether the string can be constructed by taking a substring and appending multiple copies of this substring together. Implement the function `repeat_substring` that accepts a single argument and returns a boolean indicating whether the string can be represented in this way. # Function Signature ```python def repeat_substring(s: str) -> bool: pass ``` # Input/Output - **Input**: A single string `s` (1 <= len(s) <= 10^4). - **Output**: A boolean value (`True` or `False`). # Example ```python assert repeat_substring(\\"abab\\") == True assert repeat_substring(\\"aba\\") == False assert repeat_substring(\\"abcabcabcabc\\") == True assert repeat_substring(\\"a\\") == True ``` # Constraints - The input string will only contain lowercase English letters. - The input string will not be empty. # Performance Requirements - The solution should aim for a linear time complexity, O(N), where N is the length of the string. # Context Imagine you are developing a feature for an application that needs to detect and compress repeated patterns in user-generated content such as posts or tweets. Efficiently determining if a string can be broken down into repeated substrings will help in the compression algorithm. # Note Do not use built-in functions that perform similar tasks directly. Implement the logic manually to demonstrate understanding.","solution":"def repeat_substring(s: str) -> bool: Determines whether the string can be constructed by taking a substring and appending multiple copies of this substring together. Parameters: s (str): The input string to check. Returns: bool: True if the string can be represented by a repeated substring, False otherwise. n = len(s) if n == 1: return True for i in range(1, n // 2 + 1): if n % i == 0: if s[:i] * (n // i) == s: return True return False"},{"question":"# Context: You are developing a low-level data compression algorithm where you need to manipulate individual bits of a data sequence efficiently. To do this, you will use bit manipulation functions. # Task: Implement the following function that utilizes bit manipulation to reverse the binary representation of a given integer. # Function Signature ```python def reverse_bits(num: int) -> int: pass ``` # Input: * `num` (int): A 32-bit unsigned integer. # Output: * (int): The unsigned integer resulting from reversing the binary representation of the input integer. # Constraints: * `0 <= num <= 2^32 - 1` # Example: ```python >>> reverse_bits(43261596) 964176192 ``` Explanation: - The binary representation of 43261596 is `00000010100101000001111010011100` - Reversing its bits gives `00111001011110000010100101000000`, which corresponds to 964176192 in decimal.","solution":"def reverse_bits(num: int) -> int: Reverses the bits of a 32-bit unsigned integer. Args: num (int): A 32-bit unsigned integer. Returns: int: The unsigned integer resulting from reversing the bits of the input integer. result = 0 for i in range(32): result = (result << 1) | (num & 1) num >>= 1 return result"},{"question":"You are given a graph in the form of an adjacency list and you need to determine if it contains a negative-weight cycle reachable from a specified source node. If the graph contains such a cycle, return `False`. Otherwise, return `True`. # Input: * A dictionary representing the graph. Each key is a node and the value is another dictionary representing the adjacent nodes and their respective edge weights. * A string representing the source node. # Output: * A boolean indicating whether the graph contains a negative-weight cycle reachable from the source (`False` if it does, `True` otherwise). # Constraints: * The graph can have up to 1000 nodes. * Edge weights are integers and can be negative. * The source node is guaranteed to be in the graph. # Function Signature: ```python def detect_negative_cycle(graph: Dict[str, Dict[str, int]], source: str) -> bool: ``` # Example: ```python graph = { \'a\': {\'b\': 6, \'e\': 7}, \'b\': {\'c\': 5, \'d\': -4, \'e\': 8}, \'c\': {\'b\': -2}, \'d\': {\'a\': 2, \'c\': 7}, \'e\': {\'b\': -3} } source = \'a\' assert detect_negative_cycle(graph, source) == True ``` Implement the `detect_negative_cycle` function that solves the problem using the analysis provided above.","solution":"def detect_negative_cycle(graph, source): Returns True if there is no reachable negative weight cycle from the source, False otherwise. Uses Bellman-Ford algorithm to detect negative weight cycles. # Step 1: Initialize distances from source to all other vertices as infinity # and source to itself as 0 distance = {node: float(\'inf\') for node in graph} distance[source] = 0 # Step 2: Relax all edges |V| - 1 times. for _ in range(len(graph) - 1): for u in graph: for v in graph[u]: if distance[u] + graph[u][v] < distance[v]: distance[v] = distance[u] + graph[u][v] # Step 3: Check for negative-weight cycles for u in graph: for v in graph[u]: if distance[u] + graph[u][v] < distance[v]: return False # A negative weight cycle detected! return True # No negative weight cycle detected"},{"question":"# Binary Min Heap Implementation Problem Statement You are required to implement a Binary Min Heap with the following functionalities: 1. **Insert Function**: Insert a new integer into the heap. 2. **Remove Minimum Function**: Remove and return the minimum integer from the heap. 3. **Get Minimum Function**: Return the minimum integer from the heap without removing it. The Binary Min Heap should be implemented as a class `BinaryMinHeap`. Input and Output Formats 1. **Insert Function (`insert`)**: - Input: An integer to be inserted into the heap. - Output: None. 2. **Remove Minimum Function (`remove_min`)**: - Input: None. - Output: The minimum integer from the heap. 3. **Get Minimum Function (`get_min`)**: - Input: None. - Output: The minimum integer from the heap. Constraints - Implement the operations such that the time complexity of insertion and removal of the minimum element is O(log N). - The heap should handle edge cases like inserting into an empty heap and removing from a heap with just one element efficiently. Implementation Requirements Implement the min heap using a dynamic array to store the heap elements. Example ```python heap = BinaryMinHeap() heap.insert(5) heap.insert(3) heap.insert(8) min_element = heap.get_min() # Should return 3 removed_element = heap.remove_min() # Should return and remove 3 new_min_element = heap.get_min() # Should return 5 ``` Notes - You must not use any existing library implementation of heap/priority queue. - Ensure that your code handles edge cases and performs efficiently with large input sizes. Signature ```python class BinaryMinHeap: def __init__(self): pass # Implement the initializer def insert(self, val): pass # Implement the insert method def remove_min(self): pass # Implement the remove_min method def get_min(self): pass # Implement the get_min method ``` Implement the class `BinaryMinHeap` above following the given method signatures and requirements.","solution":"class BinaryMinHeap: def __init__(self): self.heap = [] def insert(self, val): self.heap.append(val) self._heapify_up(len(self.heap) - 1) def remove_min(self): if len(self.heap) == 0: raise IndexError(\\"remove_min(): empty heap\\") min_val = self.heap[0] last_item = self.heap.pop() if len(self.heap) > 0: self.heap[0] = last_item self._heapify_down(0) return min_val def get_min(self): if len(self.heap) == 0: raise IndexError(\\"get_min(): empty heap\\") return self.heap[0] def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left] < self.heap[smallest]: smallest = left if right < len(self.heap) and self.heap[right] < self.heap[smallest]: smallest = right if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"Integer Base Conversion In a given numeral system, a number can be represented in different bases such as binary (base-2), decimal (base-10), or hexadecimal (base-16). You are required to write functions that convert numbers between these bases effectively. You need to implement the two following functions: 1. **int_to_base(num, base)**: Convert an integer (`num`) to its string representation in a specified `base`. - **Input**: - `num` (integer): The number to convert. It can be negative. - `base` (integer): The base for conversion (2 ≤ base ≤ 36). - **Output**: - Returns a string representation of the number in the specified base. - **Example**: - `int_to_base(5, 2)` → `\'101\'` - `int_to_base(-29, 16)` → `\'-1D\'` 2. **base_to_int(str_to_convert, base)**: Convert a string (`str_to_convert`) representing a number in a specified `base` back to its integer representation. - **Input**: - `str_to_convert` (string): The number in string format in the given base. It can represent negative numbers. - `base` (integer): The base of the given string number (2 ≤ base ≤ 36). - **Output**: - Returns the integer representing the given string in the specified base. - **Example**: - `base_to_int(\'101\', 2)` → `5` - `base_to_int(\'-1D\', 16)` → `-29` Constraints - The `num` integer in `int_to_base` is guaranteed to be within the range of a typical 32-bit signed integer. - The `base` parameter for both functions will only be between 2 and 36, inclusive. - The string provided to `base_to_int` will always be valid for the given `base`. Implement these functions correctly to assess your knowledge of number systems and algorithm efficiency.","solution":"def int_to_base(num, base): Converts an integer to its string representation in a specified base. Parameters: - num (int): The number to convert. It can be negative. - base (int): The base for conversion (2 ≤ base ≤ 36). Returns: - str: The string representation of the number in the given base. if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" neg = num < 0 num = abs(num) result = \\"\\" while num > 0: result = digits[num % base] + result num //= base if neg: result = \\"-\\" + result return result def base_to_int(str_to_convert, base): Converts a string number in a given base to its integer representation. Parameters: - str_to_convert (str): The number in string format in the given base. - base (int): The base of the given string number (2 ≤ base ≤ 36). Returns: - int: The integer representation of the given string in the specified base. digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" neg = str_to_convert[0] == \'-\' if neg: str_to_convert = str_to_convert[1:] result = 0 for char in str_to_convert: result = result * base + digits.index(char) if neg: result = -result return result"},{"question":"# Integer Partition Count Context: Given a positive integer `n`, an integer partition of `n` is a way of writing `n` as a sum of positive integers. Partitions that differ only in the order of their summands are considered the same. Task: Write a function `int_divide(decompose: int) -> int` that takes an integer `n` and returns the count of different integer partitions of `n`. Input: - A single integer `decompose` such that `1 <= decompose <= 100`. Output: - An integer count of the number of ways the integer can be partitioned. Example: ```python int_divide(4) # Output: 5 # Explanation: # 4 = 4 # 4 = 3 + 1 # 4 = 2 + 2 # 4 = 2 + 1 + 1 # 4 = 1 + 1 + 1 + 1 int_divide(7) # Output: 15 # Explanation: # 7 = 7 # 7 = 6 + 1 # 7 = 5 + 2 # 7 = 5 + 1 + 1 # 7 = 4 + 3 # 7 = 4 + 2 + 1 # 7 = 4 + 1 + 1 + 1 # 7 = 3 + 3 + 1 # 7 = 3 + 2 + 2 # 7 = 3 + 2 + 1 + 1 # 7 = 3 + 1 + 1 + 1 + 1 # 7 = 2 + 2 + 2 + 1 # 7 = 2 + 2 + 1 + 1 + 1 # 7 = 2 + 1 + 1 + 1 + 1 + 1 # 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` Constraints: - **Performance Requirements**: Ensure your solution can handle inputs up to the upper constraint efficiently. - **Note**: Do not consider the permutations of summands as different partitions. Implement the function `int_divide` to solve this problem.","solution":"def int_divide(decompose: int) -> int: Returns the number of different ways to partition the integer decompose. :param decompose: a positive integer (1 <= decompose <= 100) :return: an integer count of different partitions of the input. # Dynamic programming approach to solve the integer partition problem. # Initialize a list to hold the partition counts for numbers from 0 to decompose partition = [0] * (decompose + 1) # There\'s 1 way to partition 0 which is not to partition it at all. partition[0] = 1 # Iterate over all numbers from 1 to decompose for generating partitions for i in range(1, decompose + 1): for j in range(i, decompose + 1): partition[j] += partition[j - i] return partition[decompose]"},{"question":"Implement Enhanced Gnome Sort Gnome Sort is a simple sorting algorithm that works by repeatedly stepping through the list and swapping adjacent elements that are out of order. While straightforward, it can be inefficient for large datasets. Your task is to implement an enhanced version of gnome sort that remains true to the original algorithm but optimizes performance using a hybrid approach with insertion sort principles. Requirements: 1. Implement the enhanced gnome sort function. 2. It should retain the simplicity of gnome sort but attempt to reduce the number of steps needed for large arrays by re-positioning elements more efficiently. 3. The function should correctly handle edge cases such as an empty list or already sorted list. # Function Signature ```python def enhanced_gnome_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: A list of integers. - Constraints: - The list can contain up to (10^5) elements. - The integers are in the range (-10^9) to (10^9). # Output - A list of integers sorted in non-decreasing order. # Examples ```python assert enhanced_gnome_sort([]) == [] assert enhanced_gnome_sort([3, 2, 1, 4, 5]) == [1, 2, 3, 4, 5] assert enhanced_gnome_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert enhanced_gnome_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] ``` # Notes - Your implementation should aim to improve upon the performance while maintaining the correctness. - Consider common and edge cases during your implementation to ensure robustness. - Keep the code simple and readable.","solution":"from typing import List def enhanced_gnome_sort(arr: List[int]) -> List[int]: Enhanced version of gnome sort that optimizes performance by using insertion sort principles. Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: The sorted list of integers. n = len(arr) index = 0 while index < n: if index == 0 or arr[index - 1] <= arr[index]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 # Optimized approach: perform insertion sort step # to push elements further to the correct position while index > 0 and arr[index - 1] > arr[index]: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Scenario Alice and Bob are playing a game in which they each have a string. To win, they need to make their strings identical by removing characters. Given this task, you need to help them determine the minimum number of delete operations required to achieve their goal. # Task Write a function `min_steps_to_identical(word1, word2)` that returns the minimum number of steps required to make two given strings identical by only deleting characters. # Input * `word1`: a string consisting of lowercase English letters (1 <= len(word1) <= 1000) * `word2`: a string consisting of lowercase English letters (1 <= len(word2) <= 1000) # Output * An integer representing the minimum number of delete operations needed. # Constraints * Both strings are non-empty and contain only lowercase English letters. * The performance expectation is to have a time complexity of O(len(word1) * len(word2)) or better. # Example ```python # Example 1 word1 = \\"sea\\" word2 = \\"eat\\" # Explanation: You can delete \'s\' from \\"sea\\" to get \\"ea\\", then delete \'t\' from \\"eat\\" to get \\"ea\\". Hence, the minimum number of deletions is 2. print(min_steps_to_identical(word1, word2)) # Output: 2 # Example 2 word1 = \\"leetcode\\" word2 = \\"etco\\" # Explanation: You can delete \'l\', \'e\', \'e\', \'d\' from \\"leetcode\\" to get \\"tco\\", then no need to delete characters from \\"etco\\". Hence, the minimum number of deletions is 4. print(min_steps_to_identical(word1, word2)) # Output: 4 ``` # Implementation Hints 1. Utilize dynamic programming to find the length of the longest common subsequence (LCS) of the two strings. 2. Calculate the total characters to be deleted using the formula `len(word1) + len(word2) - 2 * len(LCS)`.","solution":"def min_steps_to_identical(word1, word2): Returns the minimum number of steps required to make two given strings identical by only deleting characters. m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_length = dp[m][n] return m + n - 2 * lcs_length"},{"question":"# Binary Search Tree Implementation & Practical Use You are to implement a Binary Search Tree (BST) with the following functionalities: 1. **Insert**: Adds an element to the tree. 2. **Search**: Searches for an element in the tree. 3. **Size**: Returns the number of elements in the tree. 4. **Traversal**: Implements and returns the traversal sequences (Preorder, Inorder, Postorder). Write a function named `BST` that performs the above operations. Additionally, implement a function to calculate the height of the tree and another function to determine if the tree is balanced. Constraints: - Duplicate values should not be inserted in the tree. - An empty tree should return appropriate values for all the functionalities. Expected Functions and Signatures: ```python class Node: def __init__(self, data): pass class BST: def __init__(self): pass def insert(self, data: int) -> bool: pass def search(self, data: int) -> bool: pass def size(self) -> int: pass def inorder(self) -> list: pass def preorder(self) -> list: pass def postorder(self) -> list: pass def height(self) -> int: pass def is_balanced(self) -> bool: pass ``` Input: - Operations (insert, search) on the tree. - Request for traversals (inorder, preorder, postorder). - Tree height and balance status checks. Output: - For insertions, returns True if the insertion was successful, False otherwise. - For searches, returns True if the element is present, False otherwise. - For size, returns the total number of elements. - For traversal functions, returns a list of elements in the respective order. - For height, returns the height of the tree. - For balance, returns True if the tree is balanced, False if unbalanced. Example: ```python bst = BST() bst.insert(10) bst.insert(15) bst.insert(6) bst.insert(4) bst.insert(9) print(bst.size()) # Output: 5 print(bst.search(15)) # Output: True print(bst.search(5)) # Output: False print(bst.inorder()) # Output: [4, 6, 9, 10, 15] print(bst.preorder()) # Output: [10, 6, 4, 9, 15] print(bst.postorder()) # Output: [4, 9, 6, 15, 10] print(bst.height()) # Output: 2 print(bst.is_balanced()) # Output: True ```","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, data: int) -> bool: if self.root is None: self.root = Node(data) return True else: return self._insert_recursive(self.root, data) def _insert_recursive(self, node, data): if data < node.data: if node.left is None: node.left = Node(data) return True else: return self._insert_recursive(node.left, data) elif data > node.data: if node.right is None: node.right = Node(data) return True else: return self._insert_recursive(node.right, data) else: return False # Duplicate values are not inserted def search(self, data: int) -> bool: return self._search_recursive(self.root, data) def _search_recursive(self, node, data): if node is None: return False if data < node.data: return self._search_recursive(node.left, data) elif data > node.data: return self._search_recursive(node.right, data) else: return True def size(self) -> int: return self._size_recursive(self.root) def _size_recursive(self, node): if node is None: return 0 return 1 + self._size_recursive(node.left) + self._size_recursive(node.right) def inorder(self) -> list: result = [] self._inorder_recursive(self.root, result) return result def _inorder_recursive(self, node, result): if node is not None: self._inorder_recursive(node.left, result) result.append(node.data) self._inorder_recursive(node.right, result) def preorder(self) -> list: result = [] self._preorder_recursive(self.root, result) return result def _preorder_recursive(self, node, result): if node is not None: result.append(node.data) self._preorder_recursive(node.left, result) self._preorder_recursive(node.right, result) def postorder(self) -> list: result = [] self._postorder_recursive(self.root, result) return result def _postorder_recursive(self, node, result): if node is not None: self._postorder_recursive(node.left, result) self._postorder_recursive(node.right, result) result.append(node.data) def height(self) -> int: return self._height_recursive(self.root) def _height_recursive(self, node): if node is None: return -1 left_height = self._height_recursive(node.left) right_height = self._height_recursive(node.right) return 1 + max(left_height, right_height) def is_balanced(self) -> bool: return self._is_balanced_recursive(self.root) def _is_balanced_recursive(self, node): if node is None: return True left_height = self._height_recursive(node.left) right_height = self._height_recursive(node.right) if abs(left_height - right_height) > 1: return False return self._is_balanced_recursive(node.left) and self._is_balanced_recursive(node.right)"},{"question":"# Jump Search Algorithm Implementation You are given an array of sorted integers and a target value. Implement the function `jump_search` to find the index of the target value. If the target is not found in the array, the function should return -1. Your implementation should make use of the jump search algorithm. Function Signature ```python def jump_search(arr: List[int], target: int) -> int: ``` Input * `arr`: A list of sorted integers. * `target`: An integer value to search for in the array. Output * The index of the target in the array if found, otherwise return -1. Constraints * The input array `arr` will have a maximum length of `10^6`. * The values in arr and target will fit within the range of 32-bit signed integers. Example ```plaintext Input: arr = [3, 5, 7, 9, 23, 34, 56, 78], target = 23 Output: 4 Input: arr = [1, 2, 4, 5, 6, 7, 8, 9], target = 10 Output: -1 ``` Performance Requirements * Time Complexity: O(√n) * Space Complexity: O(1) Implement the function `jump_search` to meet these requirements. Make sure to handle edge cases and optimize for performance.","solution":"import math from typing import List def jump_search(arr: List[int], target: int) -> int: Performs jump search on the sorted list arr to find the index of target. Returns the index of target if found, otherwise returns -1. n = len(arr) if n == 0: return -1 # Finding the block size to be jumped step = int(math.sqrt(n)) # Finding the block where target is present (if it is present) prev = 0 while arr[min(step, n)-1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Doing a linear search for target in the identified block for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"# Coding Assessment: Shortest Path in a Directed Graph Objective You are required to implement the shortest path algorithm for a directed graph. Given a representation of a graph and a starting node, your task is to determine the shortest path from the start node to all other nodes using Dijkstra\'s algorithm. Function Signature ```python def shortest_path(graph, start_node): :param graph: Instance of DirectedGraph containing nodes and edges. :param start_node: The node (Node instance) from which shortest paths are to be calculated. :return: A dictionary where keys are nodes and values are the shortest distance from start_node. ``` Input - `graph`: An instance of `DirectedGraph` which includes nodes and directed edges. - `start_node`: A `Node` object which is the starting point for the shortest path calculation. Output - A dictionary where keys are `Node` instances (excluding the start_node itself) and values are the shortest distances from the `start_node`. Constraints - The graph is directed and may contain cycles. - There are no negative weight edges in the graph. - The start node is guaranteed to be part of the graph. Performance Requirements - Your solution should have a time complexity of O((V + E) log V), where V is the number of nodes and E is the number of edges. Example ```python Given this graph represented as a dictionary: { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [] } And the start node \'A\', the output should be: { \'B\': 1, \'C\': 1, \'D\': 2 } # Example Usage graph_dict = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [] } graph = DirectedGraph(graph_dict) start_node = graph.add_node(\'A\') print(shortest_path(graph, start_node)) ``` **Note**: The edges between nodes are assumed to have a weight of 1 for simplicity.","solution":"from heapq import heappop, heappush import sys class Node: def __init__(self, name): self.name = name self.edges = [] def __lt__(self, other): return self.name < other.name def __repr__(self): return self.name class DirectedGraph: def __init__(self, graph_dict=None): self.nodes = {} if graph_dict: for src, dests in graph_dict.items(): if src not in self.nodes: self.add_node(src) for dest in dests: if dest not in self.nodes: self.add_node(dest) self.add_edge(src, dest) def add_node(self, name): node = Node(name) self.nodes[name] = node return node def add_edge(self, src, dest, weight=1): src_node = self.nodes[src] dest_node = self.nodes[dest] src_node.edges.append((dest_node, weight)) def shortest_path(graph, start_node): shortest_distances = {node: float(\'inf\') for node in graph.nodes.values()} shortest_distances[start_node] = 0 priority_queue = [(0, start_node)] while priority_queue: current_distance, current_node = heappop(priority_queue) if current_distance > shortest_distances[current_node]: continue for neighbor, weight in current_node.edges: distance = current_distance + weight if distance < shortest_distances[neighbor]: shortest_distances[neighbor] = distance heappush(priority_queue, (distance, neighbor)) # Exclude the starting node from the result shortest_distances.pop(start_node) return shortest_distances"},{"question":"You are required to implement a function that reverses the order of words in a given string while managing edge cases effectively. The function should not reverse the characters within the individual words themselves, only the order of words. Ensure to handle leading, trailing, and multiple consecutive spaces appropriately. # Function Signature ```python def reverse_sentence(sentence: str) -> str: pass ``` # Input * `sentence`: A string `s` of length `1 <= |s| <= 10^5`, containing words separated by spaces. # Output * A string where the words in the input sentence are reversed in order. # Constraints * Each word consists of English letters (uppercase and lowercase) only. * The sentence may have leading, trailing, and consecutive spaces between words. # Examples ```python # Example 1 sentence = \\"I am keon kim and I like pizza\\" # The expected output is: \\"pizza like I and kim keon am I\\" # Example 2 sentence = \\" Hello World \\" # The expected output is: \\"World Hello\\" # Example 3 sentence = \\" a \\" # The expected output is: \\"a\\" ``` # Implementation Details * You should use the helper function `reverse` that takes an array and two indices to reverse the elements in-place. * Implement the necessary code to process the input string, reverse the word order, and return the new string in the expected format.","solution":"def reverse_sentence(sentence: str) -> str: Reverses the order of words in the given sentence while handling leading, trailing, and multiple consecutive spaces appropriately. Parameters: sentence (str): The input sentence to be reversed. Returns: str: The sentence with the words\' order reversed. # Split the sentence into words words = sentence.split() # Reverse the order of words reversed_words = words[::-1] # Join the reversed words with a single space in between reversed_sentence = \' \'.join(reversed_words) return reversed_sentence"},{"question":"# Binary Search Tree Operations **Problem Statement**: You are to implement a Binary Search Tree (BST) with the following operations: 1. `insert(value)`: Insert a value into the BST. 2. `delete(value)`: Remove a value from the BST. 3. `search(value)`: Search for a value in the BST and return `True` if it exists, otherwise `False`. 4. `in_order_traversal()`: Return a list of all values in the BST, sorted in ascending order. **Input and Output**: * `insert(value: int) -> None`: Inserts `value` into the BST. * `delete(value: int) -> None`: Deletes `value` from the BST if it exists. * `search(value: int) -> bool`: Returns `True` if `value` exists in the BST, otherwise `False`. * `in_order_traversal() -> List[int]`: Returns a list of all values in the BST in sorted order. **Constraints**: * BST will only store integers. * Negative and positive integers are valid values. * Initial tree is empty. * You can assume unique values for simplicity in this case. **Performance Requirements**: * Your implementation should aim for average-case time complexity of O(log n) for insertion, deletion, and search. * Space complexity should be O(n) for storing n nodes. **Context**: A software engineering team is building a database management system. They need a fast data structure to manage dynamic, ordered sets of records. As a part of their team, you must implement the core BST operations to support efficient record management. **Function Signatures**: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: pass def delete(self, value: int) -> None: pass def search(self, value: int) -> bool: pass def in_order_traversal(self) -> list: pass ``` **Example**: ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) assert bst.search(3) == True assert bst.search(4) == False bst.delete(3) assert bst.search(3) == False assert bst.in_order_traversal() == [5, 7] ```","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: self.root = self._insert(self.root, value) def _insert(self, node, value): if node is None: return TreeNode(value) if value < node.val: node.left = self._insert(node.left, value) elif value > node.val: node.right = self._insert(node.right, value) return node def delete(self, value: int) -> None: self.root = self._delete(self.root, value) def _delete(self, node, value): if node is None: return node if value < node.val: node.left = self._delete(node.left, value) elif value > node.val: node.right = self._delete(node.right, value) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.val = temp.val node.right = self._delete(node.right, temp.val) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def search(self, value: int) -> bool: return self._search(self.root, value) def _search(self, node, value): if node is None: return False if value == node.val: return True elif value < node.val: return self._search(node.left, value) else: return self._search(node.right, value) def in_order_traversal(self) -> list: result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if node: self._in_order_traversal(node.left, result) result.append(node.val) self._in_order_traversal(node.right, result)"},{"question":"# Context Encryption algorithms frequently utilize modular arithmetic for secure communications. An essential operation in many cryptographic systems is calculating the modular inverse, which allows for decryption of data encoded with a modular encryption algorithm. Ensuring efficient computation of the modular inverse is critical in maintaining the overall performance of a cryptographic system. # Task Implement a function that calculates the modular inverse of a given integer `a` modulo `m`. Your solution should leverage the Extended Euclidean Algorithm to ensure correct and efficient computation of the inverse. # Function Signature ```python def find_modular_inverse(a: int, m: int) -> int: Calculate and return the modular inverse of a modulo m. Parameters: a (int): An integer whose modular inverse needs to be calculated. m (int): The modulus. Returns: int: The modular inverse of `a` modulo `m`. Raises: ValueError: If `a` and `m` are not coprime. ``` # Input - `a` and `m`: Two integers ( 1 leq a, m leq 10^9 ). # Output - An integer representing the modular inverse of `a` modulo `m`. # Constraints - `a` and `m` must be coprime. - The result must always satisfy ( a times x equiv 1 mod{m} ). # Example ```python assert find_modular_inverse(3, 11) == 4 assert find_modular_inverse(10, 17) == 12 ``` # Notes - The modular inverse exists only if `a` and `m` are coprime. - Ensure appropriate handling of large integers to avoid overflow issues. - The function should raise a `ValueError` if `a` and `m` are not coprime, indicating that no modular inverse exists.","solution":"def find_modular_inverse(a: int, m: int) -> int: def extended_gcd(aa, bb): last_remainder, remainder = abs(aa), abs(bb) x, last_x, y, last_y = 0, 1, 1, 0 while remainder: last_remainder, (quotient, remainder) = remainder, divmod(last_remainder, remainder) x, last_x = last_x - quotient * x, x y, last_y = last_y - quotient * y, y return last_remainder, last_x * (-1 if aa < 0 else 1), last_y * (-1 if bb < 0 else 1) g, x, y = extended_gcd(a, m) if g != 1: raise ValueError(f\\"No modular inverse for a={a} and m={m}, since they are not coprime.\\") return x % m"},{"question":"# Context: You are part of a software development team tasked with developing a memory-efficient in-memory cache system that can efficiently insert, delete, and fetch random elements. Your system must maintain a nearly constant time complexity for these operations to meet performance requirements. # Problem Statement: Design and implement a `RandomizedSet` class that supports the following operations in average O(1) time: 1. `insert(val: int) -> bool`: Inserts an item val if not already present. Returns `True` if the element was inserted successfully, otherwise returns `False`. 2. `remove(val: int) -> bool`: Removes an item val if present. Returns `True` if the element was removed successfully, otherwise returns `False`. 3. `get_random() -> int`: Returns a random element from the current set of elements. Each element must have the same probability of being returned. You are required to implement the following methods: ```python class RandomizedSet: def __init__(self): # Initialize your data structure here pass def insert(self, val: int) -> bool: # Insert method implementation pass def remove(self, val: int) -> bool: # Remove method implementation pass def get_random(self) -> int: # Get random method implementation pass ``` # Constraints: - All elements are integers in the range `-10^6` to `10^6`. - The number of operations will not exceed `10^5`. - Each call to `get_random` must have the same probability of returning any of the elements currently in the set. # Example: ```python # Example use case for the RandomizedSet class # Initializing an instance of RandomizedSet randomizedSet = RandomizedSet() print(randomizedSet.insert(1)) # Returns True, inserted successfully print(randomizedSet.insert(2)) # Returns True, inserted successfully print(randomizedSet.insert(2)) # Returns False, 2 already present print(randomizedSet.remove(1)) # Returns True, removed successfully print(randomizedSet.remove(3)) # Returns False, 3 not present in set print(randomizedSet.get_random()) # Returns either 2 (since 1 has been removed) ``` Your solution will be graded based on correctness, efficiency (time and space complexity), and code readability.","solution":"import random class RandomizedSet: def __init__(self): Initialize your data structure here. self.dict = {} self.list = [] def insert(self, val: int) -> bool: Inserts an item val if not already present. Returns True if the element was inserted successfully, otherwise returns False. if val in self.dict: return False self.dict[val] = len(self.list) self.list.append(val) return True def remove(self, val: int) -> bool: Removes an item val if present. Returns True if the element was removed successfully, otherwise returns False. if val not in self.dict: return False index = self.dict[val] last_element = self.list[-1] # Move the last element to the place of the element to delete self.list[index] = last_element self.dict[last_element] = index # Remove the last element self.list.pop() del self.dict[val] return True def get_random(self) -> int: Returns a random element from the current set of elements. Each element must have the same probability of being returned. return random.choice(self.list)"},{"question":"# Question: Lowest Common Ancestor in a Binary Search Tree **Context**: You have recently been hired by a software company that handles a large volume of hierarchical data stored as Binary Search Trees (BSTs). Your task is to efficiently find relational connections within such data. **Problem Statement**: Given a Binary Search Tree (BST) and two nodes within this tree, write a function `lowest_common_ancestor(root, p, q)` that finds and returns the lowest common ancestor (LCA) of those two nodes. By definition, the LCA of two nodes p and q in a BST is the deepest node that is an ancestor of both p and q. **Function Signature**: ```python def lowest_common_ancestor(root: \'Node\', p: \'Node\', q: \'Node\') -> \'Node\': pass ``` **Input**: - `root`: A reference to the root node of the BST. - `p` and `q`: References to the two nodes for which the LCA is to be found. **Output**: - Returns a reference to the LCA node. **Constraints**: - All nodes have unique values. - Both `p` and `q` are guaranteed to be in the BST. **Examples**: 1. ```python # Tree structure # 6 # / # 2 8 # / / # 0 4 7 9 # / # 3 5 # # p = 2, q = 8 => LCA = 6 lca = lowest_common_ancestor(root, p, q) # lca should return the node with value 6 ``` 2. ```python # Tree structure # 6 # / # 2 8 # / / # 0 4 7 9 # / # 3 5 # # p = 2, q = 4 => LCA = 2 lca = lowest_common_ancestor(root, p, q) # lca should return the node with value 2 ``` **Note**: - Consider edge cases such as when `p` is the ancestor of `q`. - Ensure your function runs efficiently, even for large trees. Please implement the function considering the above criteria and properties of BST.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowest_common_ancestor(root: \'Node\', p: \'Node\', q: \'Node\') -> \'Node\': if not root: return None # Start from the root node and traverse the tree current = root while current: # If both p and q are greater than parent if p.val > current.val and q.val > current.val: current = current.right # If both p and q are lesser than parent elif p.val < current.val and q.val < current.val: current = current.left else: # We have found the split point, i.e., the LCA node. return current"},{"question":"Context: You are working on a graph analysis tool for a social network that models relationships as directed connections. A graph is represented by a set of nodes (users) and directed edges (follows). Your task is to determine if the entire social network is strongly connected, meaning there is a path of follows between every pair of users in both directions. Task: Implement a function `is_strongly_connected` that takes the number of users and a list of directed connections, and returns `True` if the social network is strongly connected, otherwise returns `False`. Function Signature: ```python def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: ``` Input: * `vertex_count` (int): The number of users in the social network, representing vertices in the graph. * `edges` (List[Tuple[int, int]]): A list of tuples where each tuple represents a directed edge from the first user to the second user. Output: * Returns `True` if the graph is strongly connected, otherwise returns `False`. Constraints: * 1 <= `vertex_count` <= 10^5 * 0 <= len(`edges`) <= 10^5 * 0 <= `edges[i][j]` < `vertex_count` Example: ```python vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 0)] print(is_strongly_connected(vertex_count, edges)) # Output: True vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3)] print(is_strongly_connected(vertex_count, edges)) # Output: False ``` Notes: * Pay attention to edge cases like single-node graphs and disconnected graphs. * Ensure your solution is optimized for time and space complexity.","solution":"from typing import List, Tuple, Dict from collections import defaultdict, deque def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: if vertex_count == 1: return True def bfs(start: int, graph: Dict[int, List[int]]) -> List[bool]: visited = [False] * vertex_count queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return visited forward_graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: forward_graph[u].append(v) reverse_graph[v].append(u) # Check reachability from the first node in the original graph visited_from_first = bfs(0, forward_graph) if not all(visited_from_first): return False # Check reachability from the first node in the reversed graph visited_from_first_reversed = bfs(0, reverse_graph) if not all(visited_from_first_reversed): return False return True"},{"question":"You are given a sequence of digits that is constructed by concatenating all positive integers: \\"123456789101112131415...\\" and so on. You need to find the `nth` digit in this sequence. Write a function `find_nth_digit(n: int) -> int` that returns the `nth` digit in this sequence. # Input * `n`: A positive integer indicating the position of the digit in the sequence (1 ≤ n ≤ 10^9). # Output * Return a single integer, which is the `nth` digit of the sequence. # Examples ```python assert find_nth_digit(3) == 3 assert find_nth_digit(11) == 0 assert find_nth_digit(19) == 4 ``` # Constraints * Your algorithm should have an efficient time complexity, ideally O(log n). # Notes 1. Be mindful of numeric operations and conversions. 2. Ensure that your solution handles large values of `n` efficiently. 3. Consider edge cases such as very small or very large values of `n`. Good luck and write clean, efficient, and well-commented code!","solution":"def find_nth_digit(n): Finds the nth digit in the concatenated sequence of positive integers. length = 1 # the length of the numbers count = 9 # the count of numbers with \'length\' digits start = 1 # the first number of the \'length\' digit numbers # Find the range that contains the nth digit while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Determine the exact number that contains the nth digit start += (n - 1) // length # Find the exact digit in the number num_str = str(start) return int(num_str[(n - 1) % length])"},{"question":"# Insertion Sort Enhancement with Binary Search Insertion Sort is a simple and intuitive algorithm suitable for small data sets. To perform insertion efficiently, we can utilize Binary Search to find the proper insertion spot instead of a linear search. **Prompt:** Implement the `insertion_sort` function that takes a list of integers and returns the list sorted in ascending order. Use the provided `search_insert` function to determine the insertion points. **Function Signature:** ```python def insertion_sort(array: List[int]) -> List[int]: ``` **Input:** - `array`: A list of integers, where 0 <= len(array) <= 10^4 and -10^5 <= array[i] <= 10^5. **Output:** - Return the sorted list of integers. **Constraints:** - Use the binary search helper function `search_insert` for finding insertion points. - Aim for an overall time complexity close to O(n log n) for permissible large input sizes. **Example:** ```python assert insertion_sort([4, 3, 2, 10, 12, 1, 5, 6]) == [1, 2, 3, 4, 5, 6, 10, 12] assert insertion_sort([12, 11, 13, 5, 6]) == [5, 6, 11, 12, 13] ``` **Edge cases to consider:** - When `array` is empty, return an empty list. - When `array` contains a single element, return it as is. - Handle arrays with all elements being the same. _Function to aid:_ ```python def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low ```","solution":"from typing import List def search_insert(array: List[int], val: int) -> int: low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low def insertion_sort(array: List[int]) -> List[int]: for i in range(1, len(array)): current_value = array[i] insert_pos = search_insert(array[:i], current_value) array = array[:insert_pos] + [current_value] + array[insert_pos:i] + array[i+1:] return array"},{"question":"Context: To evaluate students\' understanding of advanced search algorithms, this task focuses on implementing an efficient search in sorted arrays. This search method, Interpolation Search, works best on uniformly distributed arrays and challenges students to handle edge cases and performance considerations carefully. Problem Statement: Write a function `optimized_interpolation_search` that adapts the standard interpolation search to handle edge cases more efficiently, ensuring it performs well on uniformly distributed arrays. The function should account for potential edge conditions and possibly optimize the search behavior under specific scenarios. Function Signature: ```python def optimized_interpolation_search(array: List[int], search_key: int) -> int: :param array: List[int] - The sorted array to be searched (assumed to be sorted in increasing order and uniformly distributed). :param search_key: int - The key to be searched within the array. :returns: int - Index of search_key in array if found, otherwise -1. ``` Examples: ```python >>> optimized_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) -1 >>> optimized_interpolation_search([10, 10, 10, 10, 10], 10) 2 >>> optimized_interpolation_search([], 10) -1 ``` Constraints: * The array will be non-decreasing and may contain duplicate elements. * The array will have at most (10^5) elements. * The ranges of integer and the search key will be (-10^6) to (10^6). Performance Requirements: * Ensure that the average-case time complexity remains (O(log log n)) for uniformly distributed arrays. * Consider scenarios where elements are repeated or identical and avoid potential infinite loops or inefficiencies. Additional Notes: - The function must handle edge cases and avoid divide-by-zero errors. - Emphasis should be placed on optimizing the performance for the best possible scenario whilst safely handling worst-case scenarios.","solution":"def optimized_interpolation_search(array, search_key): :param array: List[int] - The sorted array to be searched (assumed to be sorted in increasing order and uniformly distributed). :param search_key: int - The key to be searched within the array. :returns: int - Index of search_key in array if found, otherwise -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((high - low) // (array[high] - array[low] + 1)) * (search_key - array[low]) if pos < 0 or pos > high: return -1 if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Linked List Operations Objective: Implement a class `DoublyLinkedList` with the following functionalities for a doubly linked list: 1. **add_front(value)**: Insert a new node with the given value at the front of the list. 2. **add_end(value)**: Insert a new node with the given value at the end of the list. 3. **remove_front()**: Remove the node at the front of the list. 4. **remove_end()**: Remove the node at the end of the list. 5. **find(value)**: Find and return the first node with the given value. If the node is not found, return `None`. 6. **print_list()**: Print the elements of the list from front to end. Implementation: ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_front(self, value): # Implement this method pass def add_end(self, value): # Implement this method pass def remove_front(self): # Implement this method pass def remove_end(self): # Implement this method pass def find(self, value): # Implement this method pass def print_list(self): # Implement this method pass ``` Constraints: * **Input**: `value` will be an integer. * **Output**: Each method must perform the respective operation correctly. * Edge Case Handling: Consider empty list scenarios and single-node lists. Example: ```python dll = DoublyLinkedList() dll.add_front(10) dll.add_end(20) dll.add_front(5) dll.print_list() # Output: 5 -> 10 -> 20 dll.remove_front() dll.print_list() # Output: 10 -> 20 dll.remove_end() dll.print_list() # Output: 10 dll.add_end(15) node = dll.find(10) if node: print(f\\"Found: {node.value}\\") # Output: Found: 10 else: print(\\"Not Found\\") node = dll.find(100) if node: print(f\\"Found: {node.value}\\") else: print(\\"Not Found\\") # Output: Not Found dll.print_list() # Output: 10 -> 15 ```","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_front(self, value): new_node = DoublyLinkedListNode(value) if not self.head: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def add_end(self, value): new_node = DoublyLinkedListNode(value) if not self.tail: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def remove_front(self): if not self.head: return if self.head == self.tail: self.head = self.tail = None else: self.head = self.head.next self.head.prev = None def remove_end(self): if not self.tail: return if self.head == self.tail: self.head = self.tail = None else: self.tail = self.tail.prev self.tail.next = None def find(self, value): current = self.head while current: if current.value == value: return current current = current.next return None def print_list(self): current = self.head elements = [] while current: elements.append(str(current.value)) current = current.next print(\\" -> \\".join(elements))"},{"question":"# Quick Sort: Real-World Application Scenario Background: Quick Sort is a highly efficient sorting algorithm that is widely used in practice due to its performance on average cases. Although its worst-case performance is quadratic, with proper pivot selection, this rarely occurs. This question will assess your understanding of Quick Sort through a real-world application scenario. Scenario: You are developing a system for a library that manages a large collection of books. Each book has a unique `ID` number. Given an unsorted list of these `ID` numbers, your task is to sort them in ascending order using Quick Sort. Additionally, the library is interested in seeing the intermediate steps of the sorting process. Task: Implement the Quick Sort algorithm in Python. Your function should not only sort the list but also print the list after each partitioning step for debugging purposes. # Function Specification: ```python def library_quick_sort(book_ids: List[int]) -> List[int]: Sorts a given list of book IDs in ascending order using Quick Sort. Args: - book_ids: List[int] : a list of integer book IDs to be sorted. Returns: - List[int] : the sorted list of book IDs. ``` Input: - `book_ids`: A list of non-negative integer book IDs, where `1 <= len(book_ids) <= 10^5` and `0 <= book_ids[i] <= 10^9` Output: - Returns the sorted list of the book IDs. - Prints the list after each partitioning step to show intermediate sorting steps. Constraints: - Optimize for time and space complexity. - Handle edge cases, such as empty lists or lists with all identical elements. **Example**: ```python book_ids = [27, 3, 15, 10, 23, 4] sorted_books = library_quick_sort(book_ids) # Expected output in console (example with iteration steps): # [3, 4, 15, 10, 23, 27] # ... (subsequent iteration steps) # [3, 4, 10, 15, 23, 27] print(sorted_books) # Output: [3, 4, 10, 15, 23, 27] ``` # Guidelines 1. Implement the `partition` and `quick_sort_recur` helper functions inside `library_quick_sort`. 2. Ensure your code prints the list after each partitioning step and handles edge cases gracefully. 3. Maintain the original format and only use standard libraries for sorting logic.","solution":"from typing import List def library_quick_sort(book_ids: List[int]) -> List[int]: def quick_sort_recur(arr, low, high): if low < high: pi = partition(arr, low, high) # Print the list after each partitioning step print(arr) quick_sort_recur(arr, low, pi - 1) quick_sort_recur(arr, pi + 1, high) def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 quick_sort_recur(book_ids, 0, len(book_ids) - 1) return book_ids"},{"question":"# Scenario You are tasked with helping a logistics company optimize their databases by employing a sorting algorithm that minimizes the number of write operations to the database, which is highly I/O constrained. # Problem Statement Implement a function `cycle_sort` that takes a list of integers as input and returns the sorted list. The function should minimize the number of write operations, making it suitable for environments where writes are costly. # Input * A list of integers, `arr`, with the following constraints: * (0 leq text{len(arr)} leq 10^3) * All integers in the array are within the range of ([-10^3, 10^3]) # Output * Return the sorted list of integers. # Example ```python # Example Input arr = [3, 1, 5, 7, 2] # Example Output [1, 2, 3, 5, 7] # Example Input arr = [24, 5, 5, 12] # Example Output [5, 5, 12, 24] ``` # Functional Requirements 1. The function must be named `cycle_sort`. 2. The list must be sorted in-place, modifying the input list and returning it. 3. Edge cases should be handled correctly, including empty lists and lists with duplicate values. # Performance Requirements 1. The solution should handle up to (N = 1000) effectively. 2. The time complexity should be (O(N^2)) and the space complexity should be (O(1)).","solution":"def cycle_sort(arr): In-place cycle sort function that sorts a list with minimal write operations. writes = 0 # Traverse the array to find cycles to rearrange for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find the position where we put the element pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in correct position if pos == cycle_start: continue # Otherwise, put the item at its correct position while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"Context You have been hired by a sorting algorithm research company and your task is to optimize sorting algorithms for specific use cases. Despite knowing that Exchange Sort is inefficient for large datasets, you are tasked to examine and implement a variant of this sorting algorithm that addresses certain edge cases and ensures stability. Task Write a Python function `optimized_exchange_sort(arr)` that implements a stable version of the exchange sort algorithm. In addition to making it stable, ensure that it can handle edge cases efficiently. Specifications 1. **Input**: - A list of integers `arr` with a length constraint of 0 ≤ len(arr) ≤ 10^4. 2. **Output**: - The function should return a sorted list of integers. Constraints 1. **Handling Edge Cases**: - The function should correctly handle empty arrays and arrays with a single element. - The function should also be stable, maintaining the relative order of identical elements. 2. **Performance Requirements**: - Although the time complexity will remain O(n^2), ensure that the algorithm efficiently handles arrays where many elements are already sorted. Example ```python print(optimized_exchange_sort([4, 2, 3, 1])) # Expected Output: [1, 2, 3, 4] print(optimized_exchange_sort([3, 3, 2, 1])) # Expected Output: [1, 2, 3, 3] print(optimized_exchange_sort([])) # Expected Output: [] print(optimized_exchange_sort([10])) # Expected Output: [10] ``` Notes - Remember that \\"efficient handling\\" does not mean improving beyond O(n^2) for this specific algorithm. It means ensuring that the algorithm incurs minimal unnecessary checks. Good luck!","solution":"def optimized_exchange_sort(arr): A stable variant of the Exchange Sort (Bubble Sort) algorithm. if not arr: return [] n = len(arr) for i in range(n): swapped = False for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: # Swap if elements are out of order arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if not swapped: # If no two elements were swapped, break break return arr"},{"question":"# Context: Radix Sort is an efficient, stable sorting algorithm that can handle large sets of numbers by sorting based on individual digit places. It processes digits from either least significant to most significant place (LSD) or vice versa. # Problem: Write a function `optimized_radix_sort(arr)` that sorts an input list of non-negative integers using Radix Sort. The function should handle both small and very large lists with high efficiency. # Input: - `arr`: A list of non-negative integers (0 ≤ arr[i] < 10^9) - The list can be empty or have up to 10^6 elements. # Output: - Returns the list sorted in ascending order. # Constraints: - The implementation must not use any built-in sort functions but should utilize the radix sort principles. - Consider potential optimizations to manage memory usage effectively. - It should handle edge cases such as an empty list and lists with repetitive elements. # Example: ```python print(optimized_radix_sort([170, 45, 75, 90, 802, 24, 2, 66])) # Output: [2, 24, 45, 66, 75, 90, 170, 802] print(optimized_radix_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3])) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 6, 9] print(optimized_radix_sort([])) # Output: [] ``` # Constraints for the Student: 1. You must avoid using built-in sorting functions. 2. Write clean, readable, and efficient code. 3. Consider edge cases and optimize for performance in terms of both time and space complexity.","solution":"def optimized_radix_sort(arr): Returns the sorted version of the input list \'arr\' using Radix Sort. if not arr: return arr max_num = max(arr) exp = 1 while max_num // exp > 0: counting_sort_by_digit(arr, exp) exp *= 10 return arr def counting_sort_by_digit(arr, exp): A helper function that performs counting sort on the array based on the digit represented by \'exp\'. n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 for i in range(n): arr[i] = output[i]"},{"question":"# Segment Tree Implementation Challenge Problem Statement You are tasked with implementing a segment tree to handle efficient range queries and point updates on an array. Your segment tree should support any commutative function - one that returns the same type value and its result does not depend on the order of operations. Class Definition You have to implement the `SegmentTree` class with the following methods: * `__init__(self, arr, function)`: Constructor method to initialize the segment tree with an array and a commutative function. * `update(self, p, v)`: Method to update the element at index `p` of the array with value `v`. * `query(self, l, r)`: Method to return the result of the commutative function applied to the segment of the array from index `l` to `r` inclusive. Method Signatures ```python class SegmentTree: def __init__(self, arr, function): Initializes the segment tree with the given array and commutative function. :param arr: List[int] or List[Tuple[int, int]], the array to build the segment tree from. :param function: Callable[[Any, Any], Any], the commutative function to apply. pass def update(self, p, v): Updates the element at index p of the array with value v. :param p: int, the index of the element to update. :param v: int or tuple, the new value to update the element with. pass def query(self, l, r): Returns the result of the commutative function applied to the segment of the array from index l to r inclusive. :param l: int, the starting index of the segment to query. :param r: int, the ending index of the segment to query. :return: int or tuple, the result of the commutative function applied to the segment. pass ``` Constraints * The initial array length `N` will be in the range [1, 10^5]. * The value of each element in the array will be an integer or a tuple of integers. * The commutative function will not change during the segment tree\'s lifecycle. * Updates and queries will be interleaved (i.e., there will be a mix of updates and queries in any sequence). Example ```python # Example 1 mytree = SegmentTree([2, 4, 5, 3, 4], max) assert mytree.query(2, 4) == 5 mytree.update(3, 6) assert mytree.query(0, 3) == 6 # Example 2 mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) assert mytree.query(0, 6) == 64 mytree.update(2, -10) assert mytree.query(0, 6) == 52 # Example 3 mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) assert mytree.query(0, 2) == (9, 13) mytree.update(2, (-1, 2)) assert mytree.query(0, 2) == (4, 10) ``` **Note**: Ensure you handle edge cases such as single element arrays, query ranges that exactly match the boundaries, and updates at the boundaries.","solution":"class SegmentTree: def __init__(self, arr, function): Initializes the segment tree with the given array and commutative function. :param arr: List[int] or List[Tuple[int, int]], the array to build the segment tree from. :param function: Callable[[Any, Any], Any], the commutative function to apply. self.n = len(arr) self.func = function self.tree = [None] * (2 * self.n) # Build the tree self._build(arr) def _build(self, arr): # Initialize the leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Initialize the internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, p, v): Updates the element at index p of the array with value v. :param p: int, the index of the element to update. :param v: int or tuple, the new value to update the element with. # Update the leaf p += self.n self.tree[p] = v # Update the internal nodes i = p while i > 1: i //= 2 self.tree[i] = self.func(self.tree[2 * i], self.tree[2 * i + 1]) def query(self, l, r): Returns the result of the commutative function applied to the segment of the array from index l to r inclusive. :param l: int, the starting index of the segment to query. :param r: int, the ending index of the segment to query. :return: int or tuple, the result of the commutative function applied to the segment. # Indexes in the segment tree l += self.n r += self.n + 1 # Make r inclusive res = None while l < r: if l % 2 == 1: res = self.tree[l] if res is None else self.func(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 res = self.tree[r] if res is None else self.func(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"You are tasked with implementing a Ticket Booking system for a train that supports the following functionalities efficiently: 1. **Book a Ticket**: Adds a ticket to the end of the list. 2. **Cancel a Ticket**: Removes a ticket given the ticket details. 3. **Find Ticket**: Returns the position of a ticket given the ticket details. 4. **Display Bookings**: Displays all tickets in the booking list. You need to implement these functionalities using a **Doubly Linked List**. # Function Specifications ```python class TicketNode: def __init__(self, ticket_details): self.ticket_details = ticket_details self.next = None self.prev = None class TicketBookingSystem: def __init__(self): self.head = None self.tail = None def book_ticket(self, ticket_details): # Your code here def cancel_ticket(self, ticket_details): # Your code here def find_ticket(self, ticket_details): # Your code here def display_bookings(self): # Your code here ``` # Constraints - Each ticket (`ticket_details`) is a string with a maximum length of 100 characters. - The number of tickets will not exceed 10,000. # Input/Output 1. **book_ticket(ticket_details)**: - Input: A string `ticket_details`. - Output: None. 2. **cancel_ticket(ticket_details)**: - Input: A string `ticket_details`. - Output: None. 3. **find_ticket(ticket_details)**: - Input: A string `ticket_details`. - Output: The zero-based index of the ticket if found, otherwise -1. 4. **display_bookings()**: - Output: Print ticket details in the order they were booked. # Example ```python # Creating the booking system system = TicketBookingSystem() # Booking tickets system.book_ticket(\\"Ticket1\\") system.book_ticket(\\"Ticket2\\") system.book_ticket(\\"Ticket3\\") # Displaying bookings system.display_bookings() # Output: # Ticket1 # Ticket2 # Ticket3 # Finding a ticket print(system.find_ticket(\\"Ticket2\\")) # Output: 1 # Canceling a ticket system.cancel_ticket(\\"Ticket2\\") # Displaying bookings again system.display_bookings() # Output: # Ticket1 # Ticket3 ``` # Additional Notes Please ensure that your code handles edge cases such as canceling a ticket that does not exist, and displaying bookings when there are no tickets booked.","solution":"class TicketNode: def __init__(self, ticket_details): self.ticket_details = ticket_details self.next = None self.prev = None class TicketBookingSystem: def __init__(self): self.head = None self.tail = None def book_ticket(self, ticket_details): new_node = TicketNode(ticket_details) if self.tail is None: # if the list is empty self.head = new_node self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def cancel_ticket(self, ticket_details): current = self.head while current is not None: if current.ticket_details == ticket_details: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return # ticket found and removed current = current.next def find_ticket(self, ticket_details): current = self.head index = 0 while current is not None: if current.ticket_details == ticket_details: return index current = current.next index += 1 return -1 def display_bookings(self): current = self.head while current is not None: print(current.ticket_details) current = current.next"},{"question":"# Egg Dropping Optimization Problem Context You are given (K) eggs and have access to a building with (N) floors. Each egg is identical in function, and if an egg breaks, you cannot drop it again. There exists a floor (F) (where (0 leq F leq N)) such that any egg dropped from a floor higher than (F) will break, whereas any egg dropped from or below floor (F) will not break. You need to determine the exact value of (F) with the minimum number of egg drops in the worst-case scenario. Task Design a function `min_egg_drops(n: int, k: int) -> int`: * **Input**: * `n` (int): Represents the number of floors (1 ≤ n ≤ 10^2) * `k` (int): Represents the number of eggs (1 ≤ k ≤ 10^2) * **Output**: * Returns the minimum number of egg drops required to find the critical floor (F). * **Performance Requirements**: * Implement the function efficiently, ensuring it works within the constraints and optimizes for the worst-case scenario. Constraints 1. You can drop an egg from any floor from 1 to (N). 2. If an egg breaks, you cannot use it again. 3. You can reuse an unbroken egg. Example * **Input**: `n = 2`, `k = 1` * **Output**: `2` * **Explanation**: * Drop the egg from floor 1. If it breaks, (F = 0). * If it doesn\'t break, drop the egg from floor 2. * If it breaks, (F = 1). If it doesn\'t, (F = 2). * Therefore, a total of 2 moves are needed in this worst-case scenario to determine (F). You need to provide a solution that computes the optimal number of drops required in the worst-case scenario using dynamic programming techniques.","solution":"def min_egg_drops(n: int, k: int) -> int: Determine the minimum number of drops required to find the critical floor in the worst-case scenario using k eggs. Parameters: n (int): number of floors k (int): number of eggs Returns: int: minimum number of egg drops required # Create a table where dp[i][j] represents the minimum number of drops needed with i eggs and j floors dp = [[0 for _ in range(n + 1)] for _ in range(k + 1)] # We need 0 drops for 0 floors, and 1 drop for 1 floor regardless of the number of eggs for i in range(1, k + 1): dp[i][0] = 0 dp[i][1] = 1 # We need j drops for 1 egg and j floors for j in range(1, n + 1): dp[1][j] = j # Fill the rest of the dp table for i in range(2, k + 1): for j in range(2, n + 1): dp[i][j] = float(\'inf\') for x in range(1, j + 1): cost = 1 + max(dp[i-1][x-1], dp[i][j-x]) if cost < dp[i][j]: dp[i][j] = cost return dp[k][n]"},{"question":"# Context You\'re developing a spell-checking module that needs to correct potentially misspelled words. One approach to suggest the correct words is to compute the **edit distance** between the input word and a list of dictionary words. # Task Write a function, `edit_distance`, that computes the edit distance between two input words `word_a` and `word_b`. # Function Signature ```python def edit_distance(word_a: str, word_b: str) -> int: pass ``` # Input - `word_a`: A string consisting of lowercase alphabetic characters (1 ≤ len(word_a) ≤ 100). - `word_b`: A string consisting of lowercase alphabetic characters (1 ≤ len(word_b) ≤ 100). # Output - Returns an integer representing the minimum number of operations required to transform `word_a` into `word_b`. # Examples ```python assert edit_distance(\\"food\\", \\"money\\") == 4 assert edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert edit_distance(\\"abc\\", \\"abc\\") == 0 assert edit_distance(\\"\\", \\"abc\\") == 3 assert edit_distance(\\"abcdef\\", \\"\\") == 6 ``` # Constraints - The function must run in O(length_a * length_b) time. - The function must use O(length_a * length_b) space. # Requirements 1. Consider edge cases like one or both strings being empty. 2. Ensure handling of equal strings efficiently. 3. Avoid using high-level libraries for the core functionality.","solution":"def edit_distance(word_a: str, word_b: str) -> int: Returns the minimum number of operations required to transform word_a into word_b. Operations can be insertion, deletion, or substitution. len_a = len(word_a) len_b = len(word_b) # Create a DP table to memoize results of subproblems dp = [[0] * (len_b + 1) for _ in range(len_a + 1)] # Initialize the DP table for i in range(len_a + 1): for j in range(len_b + 1): if i == 0: dp[i][j] = j # If word_a is empty, insert all characters of word_b elif j == 0: dp[i][j] = i # If word_b is empty, delete all characters of word_a elif word_a[i - 1] == word_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no new operations else: dp[i][j] = 1 + min(dp[i - 1][j], # Insert dp[i][j - 1], # Remove dp[i - 1][j - 1]) # Replace return dp[len_a][len_b]"},{"question":"# Question: Optimal Strobogrammatic Number Generation and Counting Context A strobogrammatic number is one that looks the same when rotated 180 degrees. Your task is to implement two functions: one that generates all strobogrammatic numbers of a given length and another that counts how many such numbers fall within a specific numeric range. Function Definitions 1. **`generate_strobogrammatic(n: int) -> List[str]`**: * **Input**: Integer `n` representing the length of the numbers to generate. * **Output**: List of strings, each representing a strobogrammatic number of length `n`. 2. **`count_strobogrammatic_in_range(low: str, high: str) -> int`**: * **Input**: Strings `low` and `high` representing the lower and upper bounds of the numeric range. * **Output**: Integer count of strobogrammatic numbers within the inclusive range `[low, high]`. Constraints * For `generate_strobogrammatic`: * ( 1 leq n leq 10 ) * For `count_strobogrammatic_in_range`: * ( 1 leq text{len(low)} leq text{len(high)} leq 10 ) * `low` and `high` represent valid numeric strings without leading zeros, and `low leq high`. Requirements 1. Ensure efficient recursive or iterative solutions to handle up to the maximum constraints. 2. Handle edge cases such as the smallest and largest possible values and boundary overlaps correctly. Example Scenarios * `generate_strobogrammatic(2)` should return a list like `[\\"11\\", \\"69\\", \\"88\\", \\"96\\"]`. * `count_strobogrammatic_in_range(\\"50\\", \\"100\\")` should compute to 3 (accounting for \\"69\\", \\"88\\", \\"96\\"). Implement the functions according to the above requirements.","solution":"from typing import List def generate_strobogrammatic(n: int) -> List[str]: # pairs of strobogrammatic numbers pairs = {\'0\': \'0\', \'1\': \'1\', \'6\': \'9\', \'8\': \'8\', \'9\': \'6\'} def helper(n, length): if n == 0: return [\\"\\"] if n == 1: return [\\"0\\", \\"1\\", \\"8\\"] middles = helper(n-2, length) result = [] for middle in middles: for key, value in pairs.items(): if n != length or key != \'0\': # avoid numbers with leading zeros result.append(key + middle + value) return result return helper(n, n) def count_strobogrammatic_in_range(low: str, high: str) -> int: def compare_str_num(str1, str2): if len(str1) != len(str2): return len(str1) - len(str2) return (str1 > str2) - (str1 < str2) count = 0 for length in range(len(low), len(high) + 1): strobogrammatic_numbers = generate_strobogrammatic(length) for num in strobogrammatic_numbers: if (compare_str_num(low, num) <= 0) and (compare_str_num(num, high) <= 0): count += 1 return count"},{"question":"# Question: Implementing Advanced Duplicate Removal in Linked Lists You are given a singly linked list where each node contains a value. Your goal is to implement a function that removes all duplicate elements such that each unique value appears only once. Function Signature ```python def remove_duplicates(head: Node) -> Node: pass ``` Input - `head` (Node): The head of the singly linked list. Output - A modified linked list with duplicates removed, starting from the same head node. Constraints - The linked list will have at most 10^4 nodes. - The values in the list are strings and come from a finite alphabet. Example ```python # Linked list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g new_head = remove_duplicates(a1) # Expected linked list after duplicates removed: A -> B -> C -> D -> F -> G print_linked_list(new_head) # (Function to print the list for verification) ``` Requirements 1. Implement the function `remove_duplicates(head: Node) -> Node` to remove duplicates efficiently. 2. You may choose to implement either the space-efficient or time-efficient approach. 3. Ensure your solution handles edge cases, including an empty list and lists with all duplicate elements. Performance Requirements - Your implementation should be efficient enough to handle the upper constraint on list size. - Justify your choice of algorithm considering both time and space complexity. **Note**: You should not use any example code provided above directly. Implement the solution from scratch based on your understanding of the problem.","solution":"class Node: def __init__(self, value=None): self.value = value self.next = None def remove_duplicates(head: Node) -> Node: if not head: return None seen = set() current = head prev = None while current: if current.value in seen: prev.next = current.next else: seen.add(current.value) prev = current current = current.next return head"},{"question":"# Task You are given a singly linked list and a pivot value `x`. Write a function `partition_linked_list(head, x)` that rearranges the nodes in the linked list such that all nodes with values less than `x` come before all nodes with values greater than or equal to `x`. Function Signature ```python def partition_linked_list(head: Node, x: int) -> Node: ``` # Input - `head (Node)`: The head of the singly linked list. This list may contain zero or more nodes. - `x (int)`: The pivot value for partitioning the list. # Output - Returns the head of the modified linked list with nodes partitioned around `x`. # Constraints - The values of all linked list nodes are `int`. - `x` is an `int`. # Example Given the linked list: 3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1 And the partition value: `x = 5` The output should be a linked list where all nodes with values less than `5` come before any node with values greater than or equal to `5`. One correct partitioning could be: ``` 3 -> 2 -> 1 -> 5 -> 8 -> 5 -> 10 ``` # Note The relative order of nodes within the partitions should be preserved, and the partition element can appear anywhere in the right partition; it does not need to be between the left and right partitions. # Test Scenario Write your test function to validate that: 1. The linked list is partitioned correctly. 2. The relative order of nodes is preserved. 3. Edge cases like empty lists, all elements less than x, and all elements greater than x are handled correctly.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def partition_linked_list(head: Node, x: int) -> Node: # Create dummy nodes for partitions less than x and greater or equal to x. less_head = less_tail = Node(0) greater_equal_head = greater_equal_tail = Node(0) current = head while current: if current.val < x: # Append to the list of nodes less than x less_tail.next = current less_tail = less_tail.next else: # Append to the list of nodes greater or equal to x greater_equal_tail.next = current greater_equal_tail = greater_equal_tail.next current = current.next # Connect the last node of \\"less\\" partition to the first node of \\"greater or equal\\" partition less_tail.next = greater_equal_head.next # End the list greater_equal_tail.next = None # Return the head of the new combined list return less_head.next"},{"question":"**Scenario:** In a dark data vault, two binary trees hold identical keys to the vault lock, concealed in their structures and values. As a data guardian, you need to verify whether these keys (trees) are identical to ensure the integrity of the vault lock. **Task:** Write a function to assess if two binary trees are identical, substantiating that every corresponding node bears the same value and structural position. **Function Signature:** ```python def is_same_tree(tree_p, tree_q): ... ``` # Input: - `tree_p`: Reference to the root node of the first binary tree. - `tree_q`: Reference to the root node of the second binary tree. Both `tree_p` and `tree_q` are instances of a class `TreeNode` defined as: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Output: - Return `True` if both trees are identical. - Return `False` otherwise. # Constraints: - The number of nodes in both trees is between 0 and 100. - Node values are integers that fall within the range [-1000, 1000]. # Examples: 1. **Example 1:** - Input: ```python tree1 = TreeNode(1) tree1.left = TreeNode(2) tree1.right = TreeNode(3) tree2 = TreeNode(1) tree2.left = TreeNode(2) tree2.right = TreeNode(3) ``` - Output: `True` 2. **Example 2:** - Input: ```python tree1 = TreeNode(1) tree1.left = TreeNode(2) tree2 = TreeNode(1) tree2.right = TreeNode(2) ``` - Output: `False` 3. **Example 3:** - Input: ```python tree1 = TreeNode(1) tree2 = TreeNode(1) ``` - Output: `True` Using these examples, create a function that confirms if the two given binary trees `tree_p` and `tree_q` are exactly identical.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_same_tree(tree_p, tree_q): Determines if two binary trees are identical. :param tree_p: TreeNode, root of the first binary tree. :param tree_q: TreeNode, root of the second binary tree. :return: bool, True if both trees are identical, False otherwise. # Both trees are empty if not tree_p and not tree_q: return True # One of the trees is empty, the other is not if not tree_p or not tree_q: return False # Both trees are non-empty, compare current nodes and their subtrees return (tree_p.val == tree_q.val and is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right))"},{"question":"# Function to Find Consecutive Power Sum Numbers You are tasked with identifying numbers that exhibit the special property where the sum of their digits, raised to consecutive powers, equals the number itself within a given range. This problem tests your ability to manipulate and analyze digits within an integer and comparisons. # Problem Statement Write a function `sum_dig_pow` that takes two integers, `low` and `high`, and returns a list of all numbers in the inclusive range `[low, high]` such that the sum of their digits raised to consecutive powers starting from 1 equals the number itself. # Input and Output Format - **Input**: Two integers `low` and `high` such that `1 <= low <= high <= 10^6`. - **Output**: A list of integers within the range `[low, high]` that satisfy the condition mentioned above. # Constraints - The function must handle ranges up to `10^6` efficiently. - Avoid unnecessary computations and optimize where possible. # Examples ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(10, 150) == [89, 135] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert sum_dig_pow(90, 150) == [135] ``` # Additional Notes - Ensure your code is optimized and handles edge cases effectively. - Strive for readability and efficiency in your solution.","solution":"def sum_dig_pow(low, high): Returns a list of numbers within the range [low, high] such that the sum of their digits raised to consecutive powers starting from 1 equals the number itself. result = [] for num in range(low, high + 1): num_str = str(num) sum_of_powers = sum(int(digit) ** (i + 1) for i, digit in enumerate(num_str)) if sum_of_powers == num: result.append(num) return result"},{"question":"You are given a stack implemented as a list in Python. Write a function `is_consecutive_with_limits` that verifies whether the elements in the stack are consecutive integers from the bottom to the top. However, due to space constraints, you are only allowed to use O(1) extra space (excluding the input stack). The function signature should be: ```python def is_consecutive_with_limits(stack: list) -> bool: ``` Input * A list `stack` representing the stack, where the first element of the list is the bottom of the stack, and the last element is the top. Output * Returns `True` if the numbers in the stack are consecutive integers from bottom to top, otherwise returns `False`. Constraints * The function must use at most O(1) extra space, aside from the input stack. Example * For `stack = [3, 4, 5, 6, 7]`, the function should return `True`. * For `stack = [3, 4, 6, 7]`, the function should return `False`. * For `stack = [3, 2, 1]`, the function should return `False`. Performance Requirements * Ensure your solution adheres to the provided space constraints. * Aim for a time complexity of O(n), where n is the number of elements in the stack.","solution":"def is_consecutive_with_limits(stack: list) -> bool: Verifies whether the elements in the stack are consecutive integers from the bottom to the top. Args: stack (list): The stack to be checked. Returns: bool: True if the elements are consecutive integers, False otherwise. if not stack: return True for i in range(1, len(stack)): if stack[i] != stack[i - 1] + 1: return False return True"},{"question":"# Unique Permutations with Duplicate Handling Given a list of numbers that might contain duplicates, write a function `permute_unique(nums: List[int]) -> List[List[int]]` that returns all possible unique permutations. Input - `nums`: A list of integers `[n_1, n_2, ..., n_k]`, where `k` is the number of elements (1 ≤ k ≤ 9, each element |n_i| ≤ 20) Output - A list of lists, where each inner list is a unique permutation of the input list. Constraints - You must return the list of permutations sorted in lexicographical order. - There might be duplicate elements in the list, but each permutation must be unique. Example ```python # Example 1 input: [1, 1, 2] output: [ [1, 1, 2], [1, 2, 1], [2, 1, 1] ] # Example 2 input: [2, 2, 1, 1] output: [ [1, 1, 2, 2], [1, 2, 1, 2], [1, 2, 2, 1], [2, 1, 1, 2], [2, 1, 2, 1], [2, 2, 1, 1], ] ``` Performance Requirements - The function should efficiently handle input lists with up to 9 elements. - Aim to optimize both time and space complexity while ensuring correctness. **Note**: Consider edge cases such as: - Empty input list `[]`, which should return `[[]]`. - Input list with all identical elements `[4, 4, 4]`. You must ensure your solution avoids generating duplicate permutations and is capable of handling the given constraints effectively.","solution":"from typing import List from itertools import permutations def permute_unique(nums: List[int]) -> List[List[int]]: Returns all unique permutations of the given list of integers sorted in lexicographical order. unique_permutations = set(permutations(nums)) sorted_permutations = sorted(list(map(list, unique_permutations))) return sorted_permutations"},{"question":"# Question Begin You are given a dictionary representing a Markov chain. Each key-value pair corresponds to a state and its possible transitions, where the value is another dictionary mapping to the next state and its transition probability. **Task:** 1. Write a Python function `generate_sequence(chain: dict, initial_state: str, steps: int) -> list` that generates a sequence of states starting from the `initial_state` and taking `steps` number of transitions based on the given Markov chain. 2. Write a function `validate_chain(chain: dict) -> bool` to validate if the provided Markov chain dictionary is valid. A valid chain means: - The probabilities for each state sum up to 1. - Each state must map to one or more states with corresponding probabilities. **Function Signatures:** ```python def generate_sequence(chain: dict, initial_state: str, steps: int) -> list: pass def validate_chain(chain: dict) -> bool: pass ``` **Input Constraints:** - `chain` is a non-empty dictionary where keys and keys of nested dictionaries are string representing states. - Probabilities are floating-point numbers between 0 and 1 inclusive. - `steps` is a non-negative integer. - `initial_state` is a string and a valid state in the `chain`. **Expected Output:** - `generate_sequence` should return a list of states the Markov chain transitions through. - `validate_chain` should return `True` if the Markov chain is valid, otherwise `False`. **Examples:** ```python # Example Chain chain = { \'A\': {\'A\': 0.6, \'B\': 0.4}, \'B\': {\'A\': 0.3, \'B\': 0.7} } print(generate_sequence(chain, \'A\', 5)) # Possible Output: [\'A\', \'B\', \'B\', \'A\', \'A\', \'B\'] depending on randomness print(validate_chain(chain)) # Output: True ``` **Note:** The sequence generated in the first function is not unique and can vary due to the random nature of transitions. Ensure to account for and validate edge cases.","solution":"import random def generate_sequence(chain: dict, initial_state: str, steps: int) -> list: Generates a sequence of states starting from `initial_state` and performing `steps` transitions based on the Markov chain. current_state = initial_state sequence = [current_state] for _ in range(steps): next_state = random.choices( list(chain[current_state].keys()), list(chain[current_state].values()) )[0] sequence.append(next_state) current_state = next_state return sequence def validate_chain(chain: dict) -> bool: Validates if the provided Markov chain dictionary is valid. for state, transitions in chain.items(): total_prob = sum(transitions.values()) if not (0.999 <= total_prob <= 1.001): # Allow floating point margin errors return False if not transitions: # State must map to one or more transitions return False return True"},{"question":"# Problem: Robust Mean Calculation You are tasked with developing a function to compute the trimmed mean of an array of numbers. The trimmed mean is calculated after removing a specified percentage of the largest and smallest values from the array. This is particularly useful in fields like data analysis, where it\'s beneficial to disregard extreme outliers in order to get a more reliable mean of the central values. Function Signature ```python def trimmed_mean(arr: List[float], percentage: float) -> float: pass ``` Input: - `arr`: A list of float numbers representing the dataset `[a1, a2, ..., an]`. - `percentage`: A float number representing the total percentage of values to exclude from both ends of the array. Output: - A float number representing the trimmed mean of the remaining values. Constraints: - `0 <= len(arr) <= 10^5` - `0 <= percentage <= 100` Requirements: - **Efficiency**: Your solution should handle large inputs efficiently. - **Correctness**: Your solution should correctly calculate the trimmed mean as per the above rules, handling all edge cases. Examples: ```python assert trimmed_mean([1.0, 2.0, 3.0, 4.0, 5.0], 20.0) == 3.0 assert trimmed_mean([5.0, 1.0, 3.0, 4.0, 2.0], 20.0) == 3.0 assert trimmed_mean([5.0, 15.0, 25.0, 35.0, 45.0, 55.0], 40.0) == 30.0 assert trimmed_mean([10.0, 10.0, 10.0, 10.0, 10.0], 100.0) == 0.0 ``` Notes: - If the percentage is 0, the function should return the mean of the entire array. - If the percentage is 100, all elements should be removed and the function should return 0. - Ensure to handle edge cases efficiently, influencing minimum and maximum elements based on the percentage.","solution":"from typing import List def trimmed_mean(arr: List[float], percentage: float) -> float: Returns the trimmed mean of the array after removing a specified percentage of the largest and smallest values. if not arr: return 0.0 n = len(arr) k = int(n * percentage / 100 / 2) if percentage >= 100: return 0.0 sorted_arr = sorted(arr) trimmed_arr = sorted_arr[k:n-k] if not trimmed_arr: return 0.0 trimmed_mean_value = sum(trimmed_arr) / len(trimmed_arr) return trimmed_mean_value"},{"question":"You are tasked with sorting an array of integers using the merge sort algorithm. Your objective is to implement the `merge_sort` function and handle edge cases properly. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: ``` # Input * `arr` (List[int]): A list of integers. # Output * Returns a new list containing all the elements from `arr` in non-decreasing order. # Constraints * 0 <= len(arr) <= 10^5 * -10^6 <= arr[i] <= 10^6 # Example 1. `merge_sort([5, 2, 9, 1, 5, 6])` should return `[1, 2, 5, 5, 6, 9]`. 2. `merge_sort([])` should return `[]`. 3. `merge_sort([1])` should return `[1]`. 4. `merge_sort([2, 1])` should return `[1, 2]`. # Notes * Ensure that your function handles the empty array case correctly. * Your solution should maintain the stability of the sorting algorithm, meaning equal elements should retain their relative order. * Consider optimizing the memory usage where possible. # Hints - Consider writing a helper function to merge two sorted arrays. - Remember to handle base cases in your recursive function to prevent unnecessary computations.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the merge sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted arrays into one sorted array. sorted_array = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_array.append(left[left_index]) left_index += 1 else: sorted_array.append(right[right_index]) right_index += 1 # Append any remaining elements from left or right sorted_array.extend(left[left_index:]) sorted_array.extend(right[right_index:]) return sorted_array"},{"question":"# Coding Challenge: Minimizing Bit Flips Context In digital data transmissions, it\'s often crucial to know how many bits differ between two binary numbers. This is especially useful in areas like error detection and correction. Optimizing how we detect these differences can greatly improve system performance and reliability. Task Write a function `minimal_bits_to_flip(a: int, b: int) -> int` that determines the minimal number of bits you need to flip to convert integer `a` to integer `b`. Requirements - **Input**: - `a` (int): A non-negative integer. - `b` (int): A non-negative integer. - **Output**: - (int): The minimum number of bit flips required to transform `a` to `b`. Constraints - Both inputs are 32-bit non-negative integers. Example ```python >>> minimal_bits_to_flip(29, 15) 2 >>> minimal_bits_to_flip(4, 4) 0 >>> minimal_bits_to_flip(1, 7) 2 ``` Details - The XOR (exclusive OR) operation can be used to determine which bits differ between two numbers. - The task involves counting the number of set bits (1s) in the result of the XOR operation. - Utilize efficient bitwise operations to count these differences quickly. Provide a solution within the constraints and ensure the function operates optimally for all valid inputs.","solution":"def minimal_bits_to_flip(a: int, b: int) -> int: Determines the minimal number of bits you need to flip to convert integer a to integer b. Args: a: A non-negative integer. b: A non-negative integer. Returns: int: The minimum number of bit flips required to transform `a` to `b`. return bin(a ^ b).count(\'1\')"},{"question":"# Task: Implement a Custom Bit Manipulation Function You are required to implement a new function utilizing the given bit manipulation functions. The goal is to reverse the bits of an integer. Given an integer `num`, your task is to reverse its binary representation and return the new integer formed by the reversed bits. # Function Signature ```python def reverse_bits(num: int) -> int: pass ``` # Input - An integer `num` (0 <= num <= 10^9). # Output - An integer representing the value after reversing the bits of `num`. # Example - Input: `num = 5` (binary: `101`) - Output: `5` (binary after reversing: `101`) - Input: `num = 13` (binary: `1101`) - Output: `11` (binary after reversing: `1011`) # Constraints - You can assume the input integer `num` is non-negative. - You should handle up to 32-bit integers efficiently. # Performance Requirements - Your solution should have a time complexity of O(1) due to the fixed number of operations to reverse bits of a 32-bit integer. - Space complexity should also be O(1). # Guidelines 1. Ensure you handle edge cases, such as `num = 0`. 2. Leverage the provided bit manipulation functions (e.g., `get_bit`, `set_bit`, `clear_bit`, `update_bit`) where appropriate. 3. You may assume the integer\'s binary representation will fit within a 32-bit unsigned integer.","solution":"def reverse_bits(num: int) -> int: Reverses the bits of a 32-bit integer. :param num: An integer whose bits are to be reversed. :return: The integer representation of the reversed bits. result = 0 for i in range(32): result <<= 1 result |= (num >> i) & 1 return result"},{"question":"You are tasked with implementing an efficient algorithm to generate all prime numbers less than a given integer ( n ). The algorithm should make use of an optimized Sieve of Eratosthenes, which skips all even numbers apart from 2. # Requirements 1. Implement the function `get_primes(n: int) -> List[int]` which takes an integer `n` and returns a list of all prime numbers that are less than `n`. 2. Your implementation must adhere to the Sieve of Eratosthenes principles but should exclude even numbers in its internal processing to optimize both time and space complexity. 3. Consider and handle edge cases such as: - ( n ) being less than 2. - Non-positive integers ( n ). # Constraints - 0 <= ( n ) <= 10^6 # Input - `n`: An integer ( n ), representing the upper limit (exclusive). # Output - A list of integers where each integer is a prime number less than ( n ). # Performance - Your algorithm should have a time complexity of ( O(n log log n) ). - The space complexity should be ( O(n / 2) ) due to the optimized storage of only odd numbers. # Examples 1. **Example 1**: - Input: `n = 10` - Output: `[2, 3, 5, 7]` 2. **Example 2**: - Input: `n = 1` - Output: `[]` 3. **Example 3**: - Input: `n = 19` - Output: `[2, 3, 5, 7, 11, 13, 17]` # Implementation ```python def get_primes(n): Return list of all primes less than n, using Sieve of Eratosthenes. if n <= 0: raise ValueError(\\"\'n\' must be a positive integer.\\") sieve_size = (n // 2 - 1) if n % 2 == 0 else (n // 2) sieve = [True for _ in range(sieve_size)] # Sieve primes = [] # List of Primes if n >= 2: primes.append(2) # 2 is prime by default for i in range(sieve_size): if sieve[i]: value_at_i = i*2 + 3 primes.append(value_at_i) for j in range(i, sieve_size, value_at_i): sieve[j] = False return primes ``` Develop and test your function to ensure it meets the requirements and edge cases specified.","solution":"def get_primes(n): Return a list of all prime numbers less than n using an optimized Sieve of Eratosthenes. if n <= 2: return [] # Initialize sieve list for odd numbers only sieve = [True] * (n // 2) primes = [2] # Starting list with the first prime number for i in range(1, (n // 2)): if sieve[i]: prime = 2 * i + 1 primes.append(prime) for j in range(i + prime, n // 2, prime): sieve[j] = False return primes"},{"question":"# Coding Problem: Dynamic Word Dictionary Implementation As a part of building a new smart autocomplete search engine, you are required to design a data structure that supports adding words and searching for words efficiently, including handling wildcard characters (\'.\') which can represent any letter. Function Specifications Implement the `WordDictionary` class that should include the following methods: 1. **`add_word(word: str) -> None`**: Adds a word into the data structure. 2. **`search(word: str) -> bool`**: Returns `True` if there is any string in the data structure that matches the given word (including literals and possible wildcards `\'.\'`), otherwise returns `False`. Constraints - Words you intend to store and search have a length between 1 and 50. - Only lowercase English letters will be used. - At most, you will call `add_word` or `search` a total of 10^4 times. Input and Output - **Input**: Strings to be added or searched. - **Output**: Boolean values indicating the presence of words. Requirements 1. Design the data structure to be as efficient as possible. 2. Ensure correct handling of wildcard characters. Example Usage ```python word_dictionary = WordDictionary() word_dictionary.add_word(\\"bad\\") word_dictionary.add_word(\\"dad\\") word_dictionary.add_word(\\"mad\\") print(word_dictionary.search(\\"pad\\")) # Output: False print(word_dictionary.search(\\"bad\\")) # Output: True print(word_dictionary.search(\\".ad\\")) # Output: True print(word_dictionary.search(\\"b..\\")) # Output: True ``` **Note**: Your solution should focus on implementing the data structure with optimal performance to handle frequent adds and searches efficiently.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_word = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if search_in_node(word[i + 1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word return search_in_node(word, self.root)"},{"question":"# Red-Black Tree Insert and Get Rank You are given a partially implemented Red-Black Tree (self-balancing binary search tree) class `RBTree`. Your tasks are as follows: 1. **Implement the `rank_of` function that determines the rank of an element in the Red-Black Tree.** - The rank of an element is its position in the in-order traversal of the tree. - If the element is not present in the tree, return -1. 2. **Implement the `insert` function that inserts a new value in the tree and maintains the Red-Black properties if it\'s not already correctly implemented.** - Use the given function partially implemented. - Ensure that the tree remains balanced following the properties of a Red-Black tree after insertion. Here is the input/output structure and function signatures: ```python class RBTree: def __init__(self): self.root = None def insert(self, value: int): Insert a value into the Red-Black Tree and maintain the Red-Black properties. Ensure that the tree remains balanced. # Partially implemented, complete this function. pass def rank_of(self, value: int) -> int: Determine the rank of the value in the Red-Black Tree. The rank is defined as the position of the node in the in-order traversal. If the value is not found in the tree, return -1. # Implement this function. pass # Other methods are defined already. ``` # Example ```python if __name__ == \\"__main__\\": rb_tree = RBTree() values = [7, 3, 18, 10, 22, 8, 11, 26] for value in values: rb_tree.insert(value) print(rb_tree.rank_of(10)) # Output should be the rank of the value 10 in the tree. print(rb_tree.rank_of(26)) # Output should be the rank of the value 26 in the tree. print(rb_tree.rank_of(30)) # Output should be -1 as 30 is not in the tree. ``` # Constraints - Each element in `values` is unique and the range of input values is within 1 to (10^6). - You may assume that the provided `RBNode` class and other helper functions from the Red-Black Tree implementation are already included. Ensure your implementation adheres to the Red-Black Tree properties after insertion and efficiently computes the rank of any element.","solution":"class RBNode: def __init__(self, value, color=\'R\'): self.value = value self.color = color # \'R\' for Red, \'B\' for Black self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.TNULL = RBNode(0, \'B\') self.root = self.TNULL def insert(self, key): node = RBNode(key) node.left = self.TNULL node.right = self.TNULL node.parent = None parent = None current = self.root if self.root == self.TNULL: self.root = node self.root.color = \'B\' self.root.parent = None else: while current != self.TNULL: parent = current if node.value < current.value: current = current.left else: current = current.right node.parent = parent if node.value < parent.value: parent.left = node else: parent.right = node node.color = \'R\' self.fix_insertion(node) def fix_insertion(self, node): while node != self.root and node.parent.color == \'R\': if node.parent == node.parent.parent.right: uncle = node.parent.parent.left if uncle.color == \'R\': uncle.color = \'B\' node.parent.color = \'B\' node.parent.parent.color = \'R\' node = node.parent.parent else: if node == node.parent.left: node = node.parent self.right_rotate(node) node.parent.color = \'B\' node.parent.parent.color = \'R\' self.left_rotate(node.parent.parent) else: uncle = node.parent.parent.right if uncle.color == \'R\': uncle.color = \'B\' node.parent.color = \'B\' node.parent.parent.color = \'R\' node = node.parent.parent else: if node == node.parent.right: node = node.parent self.left_rotate(node) node.parent.color = \'B\' node.parent.parent.color = \'R\' self.right_rotate(node.parent.parent) self.root.color = \'B\' def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def inorder_traversal(self, node, result): if node != self.TNULL: self.inorder_traversal(node.left, result) result.append(node.value) self.inorder_traversal(node.right, result) def rank_of(self, value): result = [] self.inorder_traversal(self.root, result) try: return result.index(value) except ValueError: return -1"},{"question":"As a cryptography enthusiast, you are interested in efficiently determining how \'coprime\' a number is with respect to other integers up to that number. You’ve learned about Euler’s Totient Function, which does exactly that. Your task is to implement this function, ensuring it handles various edge cases and large inputs efficiently. # Function Specification Write a function named `efficient_phi` that computes Euler\'s Totient Function for an integer n. Input: - An integer `n` (1 <= n <= 10^6) Output: - An integer representing the count of integers from 1 to `n` that are coprime with `n`. Constraints: - The function should handle values up to 1 million efficiently. - Ensure that your implementation is optimized for time complexity, ideally using O(sqrt(n)) logic. Example: ```python assert efficient_phi(1) == 1 assert efficient_phi(10) == 4 assert efficient_phi(13) == 12 assert efficient_phi(1000000) == 400000 ``` # Notes: - Ensure your function handles edge cases such as when `n` is 1 or a prime number. - Consider potential optimization and time complexities while writing your solution.","solution":"def efficient_phi(n): Computes Euler\'s Totient Function for an integer n. Args: n (int): the integer to compute the totient function for. Returns: int: the count of integers from 1 to n that are coprime with n. if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: # If p is a factor, then reduce result by a factor of (1 - 1/p) while n % p == 0: n //= p result -= result // p p += 1 # If n > 1, it means n is prime and there is one prime factor greater than sqrt(n) if n > 1: result -= result // n return result"},{"question":"# Context Comb Sort is an improvement of the Bubble Sort algorithm. By using gap sequences, it significantly reduces the need for large numbers of swaps and comparisons typical in Bubble Sort. It uses a shrink factor to gradually decrease the gap used in comparisons until it reaches 1, thereby morphing into a bubble sort in the latter phase while finishing the sort. # Problem Statement Implement a function `optimized_comb_sort` that sorts an array of integers using Comb Sort. Your task is to optimize the provided comb sort implementation, enhancing its gap reduction mechanism and minimizing any performance lags. # Function Signature ```python def optimized_comb_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of integers. `1 <= len(arr) <= 10^5`, where the integers can be negative, zero and positive. # Output * The function should return the sorted list of integers in increasing order. # Constraints * You must optimize the provided Comb Sort: - Improve gap reduction mechanism if possible. - Ensure the function runs efficiently (average case O(n log n) behavior is expected) and handles large datasets within reasonable time-limits. * Maintain the in-place sorting of the array, do not use extra space. * Comments in your code marking major steps and decisions will fetch you additional credits. # Example ```python # This should sort the array in ascending order print(optimized_comb_sort([5, 3, 1, 2, 4])) # Output: [1, 2, 3, 4, 5] print(optimized_comb_sort([20, -10, 2, 2, 2, 2])) # Output: [-10, 2, 2, 2, 2, 20] ``` # Implementation Notes * Consider exploring different shrink factors or adaptive gap sequences to reduce time complexity. * Ensure the function handles all edge cases efficiently, including very small arrays and arrays with identical elements.","solution":"def optimized_comb_sort(arr): This function sorts an array of integers using an optimized Comb Sort algorithm. # Define the shrink factor shrink_factor = 1.3 # Initialize gap size gap = len(arr) # Initialize swapped to True to start the first pass swapped = False # Main loop to continue sorting until no swaps and gap is 1 while gap > 1 or swapped: if gap > 1: gap = int(gap / shrink_factor) swapped = False # Perform a comb-pass over the array for i in range(len(arr) - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Problem: Enhanced Interpolation Search You are given a sorted array of integers. Your task is to write an enhanced version of the Interpolation Search algorithm. The enhanced version should handle cases where the array elements may not be uniformly distributed and improve performance over the traditional interpolation search in such scenarios. # Input * A sorted array of integers `arr` (length (1 leq n leq 10^5)). * An integer `key` that represents the number we are searching for. # Output * Return the index of `key` in `arr` if it exists; otherwise, return `-1`. # Constraints * You may assume all elements in `arr` are unique. * The sorting order is non-decreasing. * Performance improvement for non-uniform distributions will be evaluated. * To handle extreme cases, use Binary Search if the distribution deviates significantly from uniformity. # Function Signature ```python def enhanced_interpolation_search(arr: List[int], key: int) -> int: ``` # Example ```python assert enhanced_interpolation_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7) == 6 assert enhanced_interpolation_search([10, 20, 30, 40, 50], 35) == -1 assert enhanced_interpolation_search([10, 20, 30, 40, 50], 50) == 4 ``` # Note You might consider switching to binary search after a certain number of unsuccessful interpolation steps or when certain conditions, discussed in the analysis, are detected.","solution":"from typing import List def enhanced_interpolation_search(arr: List[int], key: int) -> int: def binary_search(l, r): while l <= r: mid = l + (r - l) // 2 if arr[mid] == key: return mid elif arr[mid] < key: l = mid + 1 else: r = mid - 1 return -1 l, r = 0, len(arr) - 1 attempts = 0 max_attempts = 3 # Arbitrary number of attempts before switching to binary search while l <= r and arr[l] <= key <= arr[r]: if l == r: if arr[l] == key: return l return -1 pos = l + ((key - arr[l]) * (r - l) // (arr[r] - arr[l])) if pos < l or pos > r: break # Interpolation has failed badly, switch to binary search attempts += 1 if attempts > max_attempts: return binary_search(l, r) if arr[pos] == key: return pos elif arr[pos] < key: l = pos + 1 else: r = pos - 1 return binary_search(l, r)"},{"question":"# Question: Binary Tree to Doubly Linked List Conversion You are given a binary tree represented by its root node. Your task is to convert this binary tree to a doubly linked list in an in-order sequence. You need to implement the following function: ```python def convert_to_list(root): Convert the given binary tree to a doubly linked list. Parameters: root (TreeNode): Root node of the binary tree. Returns: TreeNode: Head of the doubly linked list. ``` # Input * The root of a binary tree where each node has the following structure: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Output * The head node of the resulting doubly linked list, where each node points to the next node (right pointer) and previous node (left pointer) accordingly. # Constraints * Node values are integers. * The binary tree can be empty. * A node can have 0, 1, or 2 children. # Example Given the following binary tree: ``` 10 / 12 15 / / 25 30 36 ``` The resulting doubly linked list should be: ``` 25 <-> 12 <-> 30 <-> 10 <-> 36 <-> 15 ``` # Notes * Ensure your solution handles edge cases like an empty tree or a single-node tree. * Consider the efficiency of your solution in terms of both time and space complexity. * You may assume the given `TreeNode` class is defined in your coding environment.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def convert_to_list(root): Convert the given binary tree to a doubly linked list. Parameters: root (TreeNode): Root node of the binary tree. Returns: TreeNode: Head of the doubly linked list. if not root: return None # Initialize previous and head nodes prev = None head = None def inorder(node): nonlocal prev, head if not node: return # Process the left subtree inorder(node.left) # Process the current node if prev: prev.right = node node.left = prev else: head = node prev = node # Process the right subtree inorder(node.right) inorder(root) return head"},{"question":"# Coding Challenge: Meeting Room Availability Checker Objective You are managing meeting room schedules and need to determine whether a person can attend all given meetings based on their time intervals. Problem Statement Given an array of meeting time intervals consisting of start and end times `[[s1, e1], [s2, e2], ...]` (si < ei), write a function `canAttendMeetings` that determines if a person can attend all meetings without any overlapping. Function Signature ```python def canAttendMeetings(intervals: List[List[int]]) -> bool: ``` Input - `intervals`: A list of lists, where each inner list contains two integers `[startTime, endTime]` representing the start and end times of a meeting interval. Output - Return `True` if a person can attend all meetings without any overlap. - Return `False` if there is any overlap among the meetings. Constraints - The length of `intervals` will not exceed 10^4. - The start and end times will be non-negative integers. Performance Requirements - Your solution should run in O(n log n) time complexity. - Auxillary space complexity should be O(n). Example 1. Example 1: ```python canAttendMeetings([[0, 30], [5, 10], [15, 20]]) ``` Output: ```python False ``` 2. Example 2: ```python canAttendMeetings([[7, 10], [2, 4]]) ``` Output: ```python True ``` Description Your function should determine if there are any overlapping intervals after sorting them by start times and inspecting each pair sequentially. **Hint**: You\'ll need to sort the intervals based on start times and check for any two adjacent intervals if the end time of the first interval is greater than the start time of the next interval.","solution":"from typing import List def canAttendMeetings(intervals: List[List[int]]) -> bool: # Sort the intervals by start time intervals.sort(key=lambda x: x[0]) # Check for any overlapping intervals for i in range(1, len(intervals)): if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"# Question: String Reversal Algorithm You are required to implement a string reversal function in Python. The function should take a single input string and return the string reversed. Given multiple approaches outlined in the analysis, your task is to implement the iterative approach for string reversal. Function Signature ```python def reverse_string(s: str) -> str: pass ``` # Input - A single string `s` (1 ≤ length of `s` ≤ 10^6). # Output - The reversed string of `s`. # Constraints - The input string will consist of printable ASCII characters only. # Requirements 1. The implementation must use an iterative approach (cannot use built-in Python reverse functions). 2. The function should handle edge cases efficiently, such as empty strings or single character strings. 3. Aim for a time complexity of (O(n)) and space complexity of (O(n)). # Example Input ```python s = \\"hello\\" ``` Output ```python \\"olleh\\" ``` **Scenario**: Suppose you are building a simple text processing application that needs to reverse user input for a particular feature. This function should be efficient enough to handle real-time inputs which could be very large. **Performance Requirements**: - Ensure that your implementation can handle inputs up to the maximum constraint efficiently and within acceptable time frames. Implement `reverse_string` function in Python using an iterative approach.","solution":"def reverse_string(s: str) -> str: Reverses the input string iteratively. Args: s (str): The input string. Returns: str: The reversed string. reversed_str = [] for char in s: reversed_str.insert(0, char) return \'\'.join(reversed_str)"},{"question":"# Question **Matrix Chain Multiplication Optimization** You are given a sequence of matrices, and you need to find the most efficient way to multiply these matrices together. The problem is not to actually perform the multiplications, but merely to decide the sequence of scalar multiplications that has the least number of multiplications. Given an array `p[]` which represents the chain of matrices such that the `i`-th matrix has dimensions `p[i-1] x p[i]`, formulate a function `matrix_chain_multiply(p: List[int]) -> Tuple[int, str]` that outputs the minimum number of scalar multiplications needed to multiply the chain and also the optimal parenthesization of the matrices. **Function Signature:** ```python def matrix_chain_multiply(p: List[int]) -> Tuple[int, str]: pass ``` # Input * `p` : List of integers where the length of the list is `n + 1` representing `n` matrices. * ( 2 leq len(p) leq 100 ) * ( 1 leq p[i] leq 500 ) # Output * Tuple containing: 1. Minimum number of scalar multiplications required. 2. String representation of the optimal parenthesization of matrices. # Example ```python p = [30, 35, 15, 5, 10, 20, 25] result = matrix_chain_multiply(p) print(result) # Output: (15125, \'((A1 (A2 A3)) ((A4 A5) A6))\') ``` # Constraints * Your solution should work within the strict time limits imposed by the input size. * Make sure to handle edge cases and optimize algorithm performance to fit in constraints.","solution":"def matrix_chain_multiply(p): n = len(p) - 1 # Number of matrices m = [[0] * n for _ in range(n)] # m[i][j] will hold the minimum number of scalar multiplications needed to compute the product of matrices A[i] to A[j] s = [[0] * n for _ in range(n)] # s[i][j] will be used to store the index of the matrix after which the product is split in an optimal solution # l is chain length for l in range(2, n + 1): for i in range(n - l + 1): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + p[i] * p[k + 1] * p[j + 1] if q < m[i][j]: m[i][j] = q s[i][j] = k def construct_solution(s, i, j): if i == j: return f\\"A{i+1}\\" else: return f\\"({construct_solution(s, i, s[i][j])} {construct_solution(s, s[i][j] + 1, j)})\\" optimal_order = construct_solution(s, 0, n - 1) return m[0][n - 1], optimal_order"},{"question":"# Scenario You are assigned to develop a program that can efficiently compute powers of matrices for a simulation project in computational physics. The simulation demands raising a transformation matrix to large powers to understand its long-term behavior. To achieve this quickly and accurately, you will implement matrix exponentiation using the repeated squaring method. # Task Implement the function `matrix_power(mat: list, n: int) -> list` that takes a square matrix `mat` of size `d x d` and an integer `n`, and returns the matrix raised to the power `n` using the repeated squaring method. # Function Signature ```python def matrix_power(mat: list, n: int) -> list: pass ``` # Input - `mat`: A square matrix represented as a list of lists of integers. - `n`: A non-negative integer representing the power to which the matrix is to be raised. # Output - A square matrix of the same size as `mat`, which is the result of raising `mat` to the power `n`. # Constraints - 1 ≤ d ≤ 200 (where `d` is the dimension of the matrix `mat`) - 0 ≤ n ≤ 10^9 - Matrix elements are integers in the range of [-10^9, 10^9] # Example ```python mat = [ [1, 2], [3, 4] ] n = 3 print(matrix_power(mat, n)) # Output: # [ # [37, 54], # [81, 118] # ] ``` # Notes - If `n` is 0, return the identity matrix of the same dimension as `mat`. - Ensure your solution has optimal performance for large values of `n`.","solution":"def matrix_power(mat, n): Computes the matrix power using repeated squaring method. :param mat: List of List of integers representing a square matrix. :param n: Integer, power to raise the matrix. :return: List of List of integers representing the resulting matrix. size = len(mat) def identity_matrix(size): return [[1 if i == j else 0 for j in range(size)] for i in range(size)] def matrix_multiply(A, B): return [[sum(A[i][k] * B[k][j] for k in range(size)) for j in range(size)] for i in range(size)] def matrix_pow(mat, n): result = identity_matrix(size) base = mat while n > 0: if n % 2 == 1: result = matrix_multiply(result, base) base = matrix_multiply(base, base) n //= 2 return result if n == 0: return identity_matrix(size) return matrix_pow(mat, n)"},{"question":"Context Heap Sort is an efficient comparison-based sorting algorithm that can either use a Max-Heap or Min-Heap. This task will help you understand the operational mechanics of both types and their implementations. Task Implement a function `dual_heap_sort` which sorts an array using both max-heap and min-heap approaches sequentially and returns the final sorted array. This function should execute `max_heap_sort` followed by `min_heap_sort` on the reversed result of the array from the max-heap sort, i.e., apply `min_heap_sort` on the descending sorted array to re-sort it in ascending order. Function Signature ```python def dual_heap_sort(arr: List[int]) -> List[int]: pass ``` Specifications * **Input Format**: - An array of integers. * **Output Format**: - An array of integers sorted in ascending order. * **Constraints**: - The array length can be up to 10^5. - The integers can range from -10^9 to 10^9. Example ```python Input: [3, 6, 1, 5, 2, 4] Output: [1, 2, 3, 4, 5, 6] ``` Requirements * **Performance**: The solution should be efficient, ideally running within O(n log n) time complexity and O(1) additional space. * **Implementation Note**: You should implement heap sort using both `max_heap_sort` and `min_heap_sort` functions as described. Good Luck!","solution":"import heapq from typing import List def max_heap_sort(arr: List[int]) -> List[int]: Perform a heap sort using a max heap. # heapify transforms list into a heap, in-place, in linear time. heap = [-x for x in arr] heapq.heapify(heap) sorted_list = [] while heap: max_element = -heapq.heappop(heap) sorted_list.append(max_element) return sorted_list def min_heap_sort(arr: List[int]) -> List[int]: Perform a heap sort using a min heap. heapq.heapify(arr) sorted_list = [] while arr: min_element = heapq.heappop(arr) sorted_list.append(min_element) return sorted_list def dual_heap_sort(arr: List[int]) -> List[int]: Sort the array using both max-heap and min-heap approaches sequentially. # Perform max-heap sort descending_sorted = max_heap_sort(arr) # Perform min-heap sort ascending_sorted = min_heap_sort(descending_sorted) return ascending_sorted"},{"question":"# Task You are tasked with implementing an enhanced priority queue using a binary heap to improve the efficiency of insertion operations. The current priority queue implementation uses a linear array which has a time complexity of O(n) for insertion. You need to implement a binary heap which offers an average insertion time complexity of O(log n). # Function Signature ```python class PriorityQueueNode: def __init__(self, data, priority): self.data = data self.priority = priority def __repr__(self): return \\"{}: {}\\".format(self.data, self.priority) class PriorityQueue: def __init__(self, items=None, priorities=None): Initialize a new priority queue using a binary heap. # Your code here def size(self): Return the size of the priority queue. # Your code here def push(self, item, priority=None): Push the item in the priority queue. if priority is not given, priority is set to the value of item. # Your code here def pop(self): Remove and return the item with the lowest priority. # Your code here ``` # Input and Output Formats - **Input**: - For `__init__`: Optional lists of items and priorities. - For `push`: An `item` to be inserted along with its `priority`. - For `pop`: No input parameters. - **Output**: - For `size`: The number of elements in the priority queue. - For `push`: No explicit output (just modify the internal structure). - For `pop`: The data of the item with the lowest priority. # Constraints * Assume item priorities are integers. * The priority queue should handle duplicate priorities correctly. * If an attempt to pop from an empty queue occurs, your implementation should handle it gracefully, perhaps by returning `None` or raising an appropriate exception. # Example ```python # Initialize priority queue with some items and priorities pq = PriorityQueue([\'apple\', \'banana\', \'cherry\'], [2, 1, 3]) print(pq.size()) # Output: 3 # Insert new item with priority pq.push(\'date\', 0) # Check size after insertion print(pq.size()) # Output: 4 # Pop item with the lowest priority print(pq.pop()) # Output: \'date\' # Check size after popping print(pq.size()) # Output: 3 ``` # Performance Requirement Your implementation should ensure that the insertion time complexity is O(log n) and the extraction time complexity is O(log n).","solution":"class PriorityQueueNode: def __init__(self, data, priority): self.data = data self.priority = priority def __repr__(self): return \\"{}: {}\\".format(self.data, self.priority) class PriorityQueue: def __init__(self, items=None, priorities=None): Initialize a new priority queue using a binary heap. self.heap = [] if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) def size(self): Return the size of the priority queue. return len(self.heap) def push(self, item, priority=None): Push the item in the priority queue. if priority is not given, priority is set to the value of item. if priority is None: priority = item new_node = PriorityQueueNode(item, priority) self.heap.append(new_node) self._heapify_up(len(self.heap) - 1) def pop(self): Remove and return the item with the lowest priority. if not self.heap: return None if len(self.heap) == 1: return self.heap.pop().data root = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return root.data def _heapify_up(self, index): parent = (index - 1) // 2 if parent >= 0 and self.heap[index].priority < self.heap[parent].priority: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] self._heapify_up(parent) def _heapify_down(self, index): smallest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left].priority < self.heap[smallest].priority: smallest = left if right < len(self.heap) and self.heap[right].priority < self.heap[smallest].priority: smallest = right if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"# Question: Implement a ZigZag Iterator for Multiple Lists Scenario You are developing a part of a larger system that processes data from multiple sources. You need to alternate between multiple sequences of data and retrieve elements in a zigzag manner until all sequences are exhausted. Task Implement a class `ZigZagIterator` that can take any number of lists of integers and iterate through them cyclically, returning one element from each list in turn until all elements have been returned. Requirements 1. **Initialization**: * `__init__(self, *args)` - Initialize the iterator with any number of lists. 2. **Methods**: * `next(self)` - Return the next element in the zigzag order. * `has_next(self)` - Return True if there are more elements to iterate over, False otherwise. Input * `*args`: A variable number of lists, each containing integers (e.g., `[1, 2, 3]`, `[4, 5, 6, 7]`). Output * `next()`: Integer - The next element in the zigzag order. * `has_next()`: Boolean - True if there are more elements, False otherwise. Constraints * Each list provided can have different lengths. * The function should handle empty lists gracefully. * Assume the lists contain only integers. Example ```python l1 = [1, 2, 3] l2 = [4, 5, 6, 7] l3 = [8, 9] it = ZigZagIterator(l1, l2, l3) result = [] while it.has_next(): result.append(it.next()) print(result) # Output should be: [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` Note * You may use collections.deque or any other data structure to ensure efficient popping from the front of the list. * Consider edge cases such as handling empty lists and lists of unequal lengths.","solution":"from collections import deque class ZigZagIterator: def __init__(self, *args): self.queue = deque() for index, lst in enumerate(args): if lst: self.queue.append((index, 0, lst)) def next(self): if self.has_next(): index, elem_index, lst = self.queue.popleft() next_elem = lst[elem_index] if elem_index + 1 < len(lst): self.queue.append((index, elem_index + 1, lst)) return next_elem def has_next(self): return len(self.queue) > 0"},{"question":"# Secure Messaging Using Diffie-Hellman Key Exchange Alice and Bob want to securely share a secret key over an insecure communication channel, using the Diffie-Hellman Key Exchange algorithm. Given a large prime number (p) and its primitive root (a), write Python functions to simulate this secure key exchange and confirm that both parties end up with the same shared secret key. Requirements: 1. Validate that (p) is a prime number. 2. Ensure that (a) is a primitive root of (p). 3. Function to generate private keys for Alice and Bob. 4. Function to generate public keys for Alice and Bob using their private keys. 5. Function to calculate the shared secret key using the public key of the other party and the private key of oneself. 6. Function to execute the sequence of steps required for the Diffie-Hellman key exchange and verify that Alice\'s and Bob\'s shared keys match. Function Signatures: * `def prime_check(num: int) -> bool:` * `def find_primitive_root(n: int) -> list:` * `def alice_private_key(p: int) -> int:` * `def alice_public_key(a_pr_k: int, a: int, p: int) -> int:` * `def bob_private_key(p: int) -> int:` * `def bob_public_key(b_pr_k: int, a: int, p: int) -> int:` * `def alice_shared_key(b_pu_k: int, a_pr_k: int, p: int) -> int:` * `def bob_shared_key(a_pu_k: int, b_pr_k: int, p: int) -> int:` * `def diffie_hellman_key_exchange(a: int, p: int) -> bool:` Input: * Two integers (a) and (p) where: * (p) is a large prime number. * (a) is a primitive root of (p). Output: * Returns `True` if the shared keys match for Alice and Bob, otherwise `False`. * Print debug statements showing Alice\'s and Bob\'s private keys, public keys, and the shared key. Example: ```python p = 23 # Large prime number a = 5 # Primitive root of 23 if diffie_hellman_key_exchange(a, p): print(\\"The shared keys match! Secure key exchange successful.\\") else: print(\\"Error in key exchange.\\") ``` Constraints: * (p) is a prime number > 2 * (2 leq a < p)","solution":"import random def prime_check(num: int) -> bool: if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_primitive_root(n: int) -> list: if not prime_check(n): return [] phi = n - 1 factors = [] i = 2 while i * i <= phi: if phi % i == 0: factors.append(i) while phi % i == 0: phi //= i i += 1 if phi > 1: factors.append(phi) primitive_roots = [] for r in range(2, n): flag = True for factor in factors: if pow(r, (n - 1) // factor, n) == 1: flag = False break if flag: primitive_roots.append(r) return primitive_roots def alice_private_key(p: int) -> int: return random.randint(2, p - 2) def alice_public_key(a_pr_k: int, a: int, p: int) -> int: return pow(a, a_pr_k, p) def bob_private_key(p: int) -> int: return random.randint(2, p - 2) def bob_public_key(b_pr_k: int, a: int, p: int) -> int: return pow(a, b_pr_k, p) def alice_shared_key(b_pu_k: int, a_pr_k: int, p: int) -> int: return pow(b_pu_k, a_pr_k, p) def bob_shared_key(a_pu_k: int, b_pr_k: int, p: int) -> int: return pow(a_pu_k, b_pr_k, p) def diffie_hellman_key_exchange(a: int, p: int) -> bool: a_pr_k = alice_private_key(p) b_pr_k = bob_private_key(p) a_pu_k = alice_public_key(a_pr_k, a, p) b_pu_k = bob_public_key(b_pr_k, a, p) alice_shared = alice_shared_key(b_pu_k, a_pr_k, p) bob_shared = bob_shared_key(a_pu_k, b_pr_k, p) print(f\\"Alice\'s private key: {a_pr_k}\\") print(f\\"Alice\'s public key: {a_pu_k}\\") print(f\\"Bob\'s private key: {b_pr_k}\\") print(f\\"Bob\'s public key: {b_pu_k}\\") print(f\\"Alice\'s shared key: {alice_shared}\\") print(f\\"Bob\'s shared key: {bob_shared}\\") return alice_shared == bob_shared"},{"question":"# Context: You are working on a search feature in a text-based interactive game. Words can be stored and retrieved such that the search queries may include wildcards represented by `.` which stands for any character. Implement a data structure that efficiently supports adding words and searching, including these wildcard characters. # Challenge: You need to implement an advanced word storage system that supports both adding and searching words with possible wildcard characters. The system should be efficient in terms of both time and space complexity. # Problem Statement: Implement the `WordDictionary` class with the following methods: 1. `add_word(word: str) -> None`: Adds a word to the data structure. 2. `search(word: str) -> bool`: Returns `true` if a word (of exact length) or wildcard representation matches any previously added word; otherwise returns `false`. # Constraints: - All words are in lowercase English letters. - `1 <= word.length <= 500`, length is the length of `word`. - There will be at most `10^5` calls to `add_word` and `search`. # Expected Function Signatures: ```python class WordDictionary: def __init__(self): pass def add_word(self, word: str) -> None: pass def search(self, word: str) -> bool: pass ``` # Example: ```python # Initialize your data structure word_dictionary = WordDictionary() # Add words word_dictionary.add_word(\\"bad\\") word_dictionary.add_word(\\"dad\\") word_dictionary.add_word(\\"mad\\") # Search for words and patterns assert word_dictionary.search(\\"pad\\") == False # not added assert word_dictionary.search(\\"bad\\") == True # exact match assert word_dictionary.search(\\".ad\\") == True # matching with \'bad\', \'dad\', \'mad\' assert word_dictionary.search(\\"b..\\") == True # matches with \'bad\' ``` # Note: - Consider performance implications when words with varying patterns and lengths are frequently added and searched. - Handle edge cases such as searching for an empty word or patterns with multiple wildcards efficiently.","solution":"class WordDictionary: def __init__(self): self.words = {} def add_word(self, word: str) -> None: length = len(word) if length not in self.words: self.words[length] = [] self.words[length].append(word) def search(self, word: str) -> bool: length = len(word) if length not in self.words: return False for candidate in self.words[length]: if self.match(candidate, word): return True return False def match(self, candidate: str, word: str) -> bool: for c, w in zip(candidate, word): if w != \'.\' and c != w: return False return True"},{"question":"Given a string made up of lowercase letters and a dictionary of lowercase words, your task is to write a function that returns the number of possible sentences that can be formed from the string such that each word in the sentences is contained in the dictionary. Function Signature ```python def count_sentences(string: str, dictionary: set) -> int: pass ``` # Input * `string` (str): A string made up of lowercase letters with length `1 <= len(string) <= 100` * `dictionary` (set): A set of lowercase words, each word with length `1 <= len(word) <= 10` # Output * (int): The number of possible sentences that can be formed. # Constraints - The same string should be decomposed into different possible sets of dictionary words, and all sets should be counted. - Function purity must be maintained; avoid using global variables. # Examples Example 1 Input: ```python string = \\"appletablet\\" dictionary = {\\"apple\\", \\"tablet\\", \\"applet\\", \\"able\\", \\"t\\"} ``` Output: ```python 3 ``` Explanation: The possible sentences are: - \\"apple tablet\\" - \\"apple t able t\\" - \\"applet\\" Example 2 Input: ```python string = \\"thing\\" dictionary = {\\"thing\\"} ``` Output: ```python 1 ``` Explanation: The only possible sentence is \\"thing\\". # Detailed Requirements To solve this problem: 1. Use a recursive approach to evaluate possible decompositions. 2. Implement memoization to optimize and avoid redundant computations. 3. Ensure no global variables are used within your implementation. 4. Return the total number of valid decomposed sentences.","solution":"def count_sentences(string: str, dictionary: set) -> int: def dfs(s, memo): if s in memo: return memo[s] if not s: return 1 count = 0 for i in range(1, len(s) + 1): if s[:i] in dictionary: count += dfs(s[i:], memo) memo[s] = count return count memo = {} return dfs(string, memo)"},{"question":"# Question: Implement an Enhanced Quick Sort Function **Context**: Quick Sort is a highly efficient sorting algorithm commonly used in many practical applications. However, its performance can degrade to O(n²) under certain conditions, such as when the pivot selection is suboptimal. One way to improve Quick Sort\'s performance is to enhance the pivot selection strategy. Objective You are tasked with implementing an enhanced version of the Quick Sort algorithm named `enhanced_quick_sort(arr, use_median_pivot=False)` that uses the median-of-three method for pivot selection to improve performance. Your function should sort the provided list in ascending order. Input and Output Formats * **Input** * `arr`: List of integers to be sorted. * `use_median_pivot`: Boolean (Optional) flag to use the median of the first, middle, and last elements as the pivot. Defaults to `False`. * **Output** * A new list containing the sorted integers. Implementation Requirements 1. **Enhanced Pivot Selection**: Use the median of the first, middle, and last elements as the pivot when `use_median_pivot` is `True`. 2. **Maintain Efficiency**: Ensure that the overall time complexity remains within O(n log(n)) on average. 3. **Account for Edge Cases and Limitations**: Handle edge cases, such as arrays with duplicate elements, very large arrays, and arrays with a small number of elements effectively. 4. **Avoid Recursion Depth Issues**: Optimize the recursion strategy to handle deep recursion appropriately. Constraints * The input list `arr` can have up to `10^6` elements. * Each element in `arr` is an integer within the range `-10^6` to `10^6`. Example Usage ```python # Example 1: arr = [3, 6, 8, 10, 1, 2, 1] print(enhanced_quick_sort(arr, use_median_pivot=True)) # Output: [1, 1, 2, 3, 6, 8, 10] # Example 2: arr = [1,0,-1,8,5,7] print(enhanced_quick_sort(arr, use_median_pivot=False)) # Output: [-1, 0, 1, 5, 7, 8] ``` Ensure your function is tested against various edge cases to validate its correctness and performance.","solution":"def enhanced_quick_sort(arr, use_median_pivot=False): Sorts the input list using an enhanced Quick Sort algorithm. Uses median-of-three for pivot selection if use_median_pivot is True. Parameters: arr (list): List of integers to be sorted. use_median_pivot (bool, optional): Flag to use median-of-three pivot selection. Default is False. Returns: list: A new list containing the sorted integers. if len(arr) <= 1: return arr def median_of_three(lst): first = lst[0] middle = lst[len(lst) // 2] last = lst[-1] return sorted([first, middle, last])[1] def quicksort_internal(lst): if len(lst) <= 1: return lst if use_median_pivot: pivot = median_of_three(lst) else: pivot = lst[len(lst) // 2] left = [x for x in lst if x < pivot] middle = [x for x in lst if x == pivot] right = [x for x in lst if x > pivot] return quicksort_internal(left) + middle + quicksort_internal(right) return quicksort_internal(arr)"},{"question":"You are implementing a predictive text input mechanism on a mobile device, which requires generating all possible letter combinations that a given digit string represents. This is based on the classic phone keypad layout where each digit maps to a set of letters as follows: - 2: \\"abc\\" - 3: \\"def\\" - 4: \\"ghi\\" - 5: \\"jkl\\" - 6: \\"mno\\" - 7: \\"pqrs\\" - 8: \\"tuv\\" - 9: \\"wxyz\\" Write a function `generate_combinations(digits: str) -> List[str]` that takes a string of digits (2-9) as input and returns all possible letter combinations represented by that digit string. # Input and Output - **Input**: A string `digits` made up of characters \'2\' through \'9\' (inclusive). - **Output**: A list of strings, where each string represents a possible combination of letters. # Example ```python # Example 1: digits = \\"23\\" # Output: [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] # Example 2: digits = \\"\\" # Output: [] ``` # Additional Constraints - The length of `digits` is between [0, 4], inclusive. - The output must contain letter combinations sorted in lexicographical order. # Note Consider edge cases such as an empty input string or invalid characters. Optimize for both time and space where possible, but prioritize readability and correctness.","solution":"from typing import List def generate_combinations(digits: str) -> List[str]: # Mapping of digits to corresponding letters digit_to_char = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } if not digits: return [] # Result list to store the combinations result = [] # Helper function for recursive backtracking def backtrack(index, current_combination): if index == len(digits): result.append(\'\'.join(current_combination)) return # Get the letters that the current digit maps to, and recurse current_digit = digits[index] for char in digit_to_char[current_digit]: current_combination.append(char) backtrack(index + 1, current_combination) current_combination.pop() # Start the backtracking with initial parameters backtrack(0, []) return result"},{"question":"Context and Scenario You have been hired by a company that works extensively in the field of genetic research. One of their tasks is to find palindromic sequences in DNA strings. As part of the assessment for new developers, the company wants them to implement a highly efficient algorithm to find the longest palindromic substring in a given DNA sequence. Task Write a function `longest_palindromic_substring` which takes a string `s` and returns the longest palindromic substring in `s`. Utilize Manacher\'s algorithm to achieve your result efficiently. Function Signature ```python def longest_palindromic_substring(s: str) -> str: ``` Input - `s`: a non-empty string containing the sequence of characters (1 <= len(s) <= 1000) Output - A string representing the longest palindromic substring in the input string `s`. Constraints - The solution must run in O(n) time complexity. - The solution must transform the string to handle even and odd length palindromes uniformly. Examples 1. Input: `\\"babad\\"` Output: `\\"bab\\"` (Note: `\\"aba\\"` is also a valid answer) 2. Input: `\\"cbbd\\"` Output: `\\"bb\\"` 3. Input: `\\"a\\"` Output: `\\"a\\"` 4. Input: `\\"ac\\"` Output: `\\"a\\"` or `\\"c\\"` Use the following template to start implementing the solution: ```python def longest_palindromic_substring(s: str) -> str: if len(s) < 2: return s n_str = \'#\' + \'#\'.join(s) + \'#\' p = [0] * len(n_str) mx, loc = 0, 0 index, maxlen = 0, 0 for i in range(len(n_str)): if i < mx and 2 * loc - i < len(n_str): p[i] = min(mx - i, p[2 * loc - i]) else: p[i] = 1 while p[i] + i < len(n_str) and i - p[i] >= 0 and n_str[i - p[i]] == n_str[i + p[i]]: p[i] += 1 if i + p[i] > mx: mx = i + p[i] loc = i if p[i] > maxlen: index = i maxlen = p[i] s = n_str[index - p[index] + 1:index + p[index]] return s.replace(\'#\', \'\') ```","solution":"def longest_palindromic_substring(s: str) -> str: if len(s) < 2: return s # Transform the string to handle even and odd length palindromes uniformly t = \'#\' + \'#\'.join(s) + \'#\' p = [0] * len(t) c = r = 0 # center and right edge of the current right-most palindrome max_len = center_index = 0 for i in range(len(t)): mirr = 2 * c - i # mirror of i with respect to the center c if i < r: p[i] = min(r - i, p[mirr]) # Expand around the center i while i + p[i] + 1 < len(t) and i - p[i] - 1 >= 0 and t[i + p[i] + 1] == t[i - p[i] - 1]: p[i] += 1 # If the expanded palindrome is past the right edge, update center and right edge if i + p[i] > r: c = i r = i + p[i] # Update the maximum length and center position if p[i] > max_len: max_len = p[i] center_index = i # Extract the longest palindromic substring start = (center_index - max_len) // 2 return s[start:start + max_len]"},{"question":"# Markov Chain Based Weather Prediction Context: Imagine you are tasked with building a basic weather prediction model using a Markov Chain. Each day can be one of three states: sunny, rainy, and cloudy. The weather transitions between these states based on certain probabilities which are given. Your goal is to implement a Markov Chain driven weather prediction function. The function should be able to predict the weather for a sequence of days given an initial condition. Task: Implement the function `predict_weather` which takes the following arguments: - `chain`: A dictionary representing the weather transition probabilities. - `initial_state`: A string representing the initial weather state (one of \\"sunny\\", \\"rainy\\", \\"cloudy\\"). - `days`: An integer representing the number of days to predict the weather for. The function should return a list of weather states (strings), starting with the `initial_state` and containing exactly `days` elements. Constraints: - All transition probabilities for each state will sum up to 1. - The Markov Chain is fully connected (i.e., there is a non-zero transition probability between any two states). Example: ```python chain = { \\"sunny\\": {\\"sunny\\": 0.8, \\"rainy\\": 0.1, \\"cloudy\\": 0.1}, \\"rainy\\": {\\"sunny\\": 0.2, \\"rainy\\": 0.6, \\"cloudy\\": 0.2}, \\"cloudy\\": {\\"sunny\\": 0.3, \\"rainy\\": 0.3, \\"cloudy\\": 0.4} } initial_state = \\"sunny\\" days = 5 result = predict_weather(chain, initial_state, days) # Possible output: [\'sunny\', \'sunny\', \'cloudy\', \'sunny\', \'rainy\'] ``` Requirements: 1. Use meaningful variable names and maintain good code structure. 2. Consider edge cases such as random selection when probabilities are low or handling edge during state transition. 3. Ensure the solution is efficient and handles larger state spaces if needed.","solution":"import random def predict_weather(chain, initial_state, days): Predict the weather for a sequence of days given an initial state and transition probabilities. :param dict chain: A dictionary representing the weather transition probabilities. :param str initial_state: The initial weather state (one of \\"sunny\\", \\"rainy\\", \\"cloudy\\"). :param int days: The number of days to predict the weather for. :return: A list of weather states (strings) starting with the initial_state. :rtype: list current_state = initial_state weather_forecast = [current_state] for _ in range(days - 1): next_state = random.choices( population=list(chain[current_state].keys()), weights=list(chain[current_state].values()), k=1 )[0] weather_forecast.append(next_state) current_state = next_state return weather_forecast"},{"question":"**Question: Implementing Optimized Jump Search** You are given a sorted array `arr` of `n` integers and an integer `target` to search for. Your task is to optimize and implement the `jump_search` function to find the position of `target` in the array. If `target` is not present in the array, return `-1`. # Input * A sorted array `arr` of `n` integers (`1 <= n <= 10^6`). * An integer `target`. # Output * An integer representing the index of `target` in the array if found, otherwise `-1`. # Constraints * Array `arr` will be sorted in non-decreasing order. * All elements in `arr` are distinct. * Optimize for the best performance considering time and space complexity. # Example Example 1: Input: ``` arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] target = 11 ``` Output: ``` 5 ``` Example 2: Input: ``` arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] target = 4 ``` Output: ``` -1 ``` # Requirements: 1. Implement the function `optimized_jump_search(arr: List[int], target: int) -> int`. 2. Ensure the solution handles edge cases such as small arrays, large arrays, arrays without the target value, and arrays with the target as the first or last element. 3. Ensure the function is optimized for time and memory efficiency. # Hints: 1. Utilize the concept of dividing the array into blocks and searching within blocks to minimize the number of comparisons. 2. Make sure to handle array boundaries and ensure no out-of-bounds access.","solution":"import math from typing import List def optimized_jump_search(arr: List[int], target: int) -> int: n = len(arr) step = int(math.sqrt(n)) prev = 0 while arr[min(step, n) - 1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"# Plus One to a Large Number Represented as an Array You are given a non-negative number represented as a list of digits. The most significant digit is at the head of the list. Your task is to increment this number by one and return the resulting array of digits. **Function Signature:** ```python def plus_one(digits: List[int]) -> List[int]: pass ``` # Input - A list `digits` representing a non-negative integer, where each element in the list is a digit from 0 to 9. - The list does not contain leading zeros, except in the case of the number \'0\' itself. # Output - The list of digits representing the number after adding one to it. # Constraints - The length of the list will be at least 1 and at most 10,000. - Each digit in the list will be between 0 and 9. # Example ```python assert plus_one([1, 2, 3]) == [1, 2, 4] # 123 + 1 = 124 assert plus_one([9, 9, 9]) == [1, 0, 0, 0] # 999 + 1 = 1000 ``` # Requirements - Implement an efficient algorithm. - Consider the given time and space complexities. # Notes - Think about edge cases, such as when the entire number consists of digit `9`.","solution":"from typing import List def plus_one(digits: List[int]) -> List[int]: Adds one to an array-represented large number. n = len(digits) for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 return [1] + [0] * n"},{"question":"# Ternary Search Coding Challenge In this challenge, you are tasked with implementing the ternary search algorithm to find a specific key in a sorted array of integers. Problem Statement Implement a function `ternary_search(arr: List[int], key: int) -> int` that searches for an integer `key` in a given sorted list of integers `arr`. The function should return the index of the key if found, otherwise it should return `-1`. You need to use the ternary search algorithm as explained below: 1. Divide the array into three parts using two midpoints. 2. Compare the key with the values at these midpoints to determine which segment to search in next. 3. Continue the process recursively or iteratively until the key is found or the search space is exhausted. Input * `arr`: A list of integers sorted in ascending order. * `key`: An integer value to search for. Output * An integer representing the index of `key` in `arr` if found, otherwise `-1`. Constraints * The length of `arr` is in the range of `[0, 10^5]`. * The values in `arr` are in the range of ([-10^9, 10^9]). * Perform the search with a time complexity of ( O(log_3(N)) ). Example ```python assert ternary_search([1, 2, 3, 4, 5, 6], 4) == 3 assert ternary_search([10, 20, 30, 40, 50], 25) == -1 assert ternary_search([], 1) == -1 assert ternary_search([1], 1) == 0 assert ternary_search([-10, -5, 0, 5, 10], -5) == 1 ``` Note * Make sure to handle edge cases such as an empty array and large values appropriately. * Avoiding off-by-one errors and efficient midpoint calculations are crucial to the correct functioning of the algorithm.","solution":"def ternary_search(arr, key): Performs a ternary search on a sorted array to find the key. Parameters: arr (list): A list of integers sorted in ascending order. key (int): An integer to search for in the list. Returns: int: The index of the key if found, otherwise -1. def search(l, r): if r >= l: # Calculate the two midpoints mid1 = l + (r - l) // 3 mid2 = r - (r - l) // 3 # Check if key is present at any midpoints if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 # Determine which segment the key is present in if key < arr[mid1]: # Key in the left segment return search(l, mid1 - 1) elif key > arr[mid2]: # Key in the right segment return search(mid2 + 1, r) else: # Key in the middle segment return search(mid1 + 1, mid2 - 1) return -1 return search(0, len(arr) - 1)"},{"question":"# Linked List Cycle Detection and Removal You are given a linked list that might contain a cycle. Your task is to first detect if there is a cycle in the provided linked list and if a cycle is detected, remove the cycle making the linked list linear (i.e., without any cycles). # Input - A single linked list `head` where each `Node` has an integer value `val` and a pointer `next` to the next node. # Output - Return the head of the corrected linked list (without any cycle). If there is no cycle, return the original head. # Constraints - The number of nodes in the linked list is in the range [0, 10^4]. - -10^5 <= Node.val <= 10^5 # Example ```python # Suppose we have a linked list: 1 -> 2 -> 3 -> 4 -> 5 -> 3 (cycle starts again at 3) node1 = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(4) node5 = Node(5) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 node5.next = node3 # cycle here # After removing the cycle # The modified linked list should be: 1 -> 2 -> 3 -> 4 -> 5 head = remove_cycle(node1) # Traversal of the updated linked list should print: # 1 2 3 4 5 ``` # Requirements - Implement the function `remove_cycle(head)` which: - Takes the head of the linked list as input. - Returns the head of the modified list with any cycle removed. # Testing You are encouraged to write unit tests to validate your solution under different scenarios including: - No cycle in the list. - Cycle at various positions within the list. - Single-node lists with and without cycles. - Empty list (head is None). # Code to Begin ```python class Node: def __init__(self, x): self.val = x self.next = None def remove_cycle(head): :type head: Node :rtype: Node # Your implementation here # You can start writing some tests as well to validate your function ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def remove_cycle(head): if not head or not head.next: return head slow = fast = head has_cycle = False # First step: detect cycle using Floyd\'s Cycle Detection Algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: has_cycle = True break if not has_cycle: return head # Second step: find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next # Third step: remove the cycle while fast.next != slow: fast = fast.next fast.next = None return head"},{"question":"You are required to implement a function that determines the number of digits in an integer. The function should operate in constant time and handle both positive and negative integers as well as zero. Please follow the method described below: # Function Signature ```python def num_digits(n: int) -> int: pass ``` # Input * An integer `n` where `-10^18 <= n <= 10^18`. # Output * Return an integer representing the number of digits in `n`. # Constraints 1. The input will always be a valid integer. 2. You cannot convert the number to a string or use any built-in functions that directly count the number of digits. # Examples ```python print(num_digits(12345)) # Output: 5 print(num_digits(-987654321)) # Output: 9 print(num_digits(0)) # Output: 1 print(num_digits(10**17)) # Output: 18 ``` # Explanation 1. For `12345`, the number of digits is `5`. 2. For `-987654321`, despite the negative sign, the digit count is `9`. 3. For `0`, by definition, the digit count is `1`. 4. For `10**17`, it contains `18` digits. Considering the efficient computation of logarithms, ensure the program executes in constant time.","solution":"import math def num_digits(n: int) -> int: Returns the number of digits in an integer n. Handles both positive and negative integers, as well as zero. if n == 0: return 1 return int(math.log10(abs(n))) + 1"},{"question":"# Question: Minimum Deletion Steps to Make Words the Same Context: You are working on a version control system that requires determining the minimum number of deletions to make two strings the same. This is important to help track changes and show differences between file versions efficiently. Task: Write a function `min_deletion_steps(word1, word2)` that takes two strings `word1` and `word2`, and calculates the minimum number of deletions required to make the two strings identical. In each step, you can delete one character from either string. Function Signature: ```python def min_deletion_steps(word1: str, word2: str) -> int: ``` Input: * `word1, word2`: Two non-empty strings consisting of lowercase alphabetical characters (1 ≤ len(word1), len(word2) ≤ 500). Output: * Return an integer representing the minimum number of deletions needed. Constraints: * The function must have a time complexity of O(m * n) and use no more than O(m * n) additional space. Example: ```python # Example 1 word1 = \\"sea\\" word2 = \\"eat\\" # The output should be 2: by deleting \'s\' from \\"sea\\" and \'t\' from \\"eat\\", both become \\"ea\\". print(min_deletion_steps(word1, word2)) # Output: 2 # Example 2 word1 = \\"abc\\" word2 = \\"def\\" # The output should be 6: delete all characters from both strings since there are no common subsequences. print(min_deletion_steps(word1, word2)) # Output: 6 ``` Hints: 1. Consider finding the longest common subsequence (LCS) first, as deletions required will be the sum of deletions needed to delete characters not in the LCS from both strings. 2. Use dynamic programming to build the solution iteratively, and remember to check boundary conditions (empty strings, equal strings). Constraints: * Optimize for both time and space where possible. * Handle empty and equivalent strings properly.","solution":"def min_deletion_steps(word1: str, word2: str) -> int: Calculate the minimum number of deletions needed to make two strings identical. m, n = len(word1), len(word2) # Create a DP table to store lengths of the Longest Common Subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the DP table for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The longest common subsequence length is dp[m][n] lcs_length = dp[m][n] # The result is the sum of deletions needed in both strings return (m - lcs_length) + (n - lcs_length)"},{"question":"You are given a directed graph as an initial adjacency list representation for constructing a `DirectedGraph`. Implement a method in the `DirectedGraph` class to check if there is a path between two given nodes using Depth-First Search (DFS). The method signature should be: ```python def is_path(self, start_node_name, end_node_name): pass ``` # Function Definition ```python def is_path(self, start_node_name, end_node_name): Determine if there\'s a path from start_node to end_node :param start_node_name: Name of the start node :param end_node_name: Name of the end node :return: True if there is a path, otherwise False ``` # Input * `start_node_name`: string representing the name of the starting node. * `end_node_name`: string representing the name of the end node. # Output * Returns a boolean value indicating whether a path exists between the two nodes. # Constraints * The graph uses existing nodes and edges within the given `DirectedGraph` object. * Node names are unique strings. # Example 1. Given an initial graph could be represented as: ```python load_dict = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [], \'D\': [\'E\'], \'E\': [] } graph = DirectedGraph(load_dict) print(graph.is_path(\'A\', \'E\')) # Output: True print(graph.is_path(\'C\', \'D\')) # Output: False print(graph.is_path(\'A\', \'F\')) # Output: False (node \'F\' not present) ```","solution":"class DirectedGraph: def __init__(self, adjacency_list): self.adjacency_list = adjacency_list def is_path(self, start_node_name, end_node_name): Determine if there\'s a path from start_node to end_node :param start_node_name: Name of the start node :param end_node_name: Name of the end node :return: True if there is a path, otherwise False if start_node_name not in self.adjacency_list or end_node_name not in self.adjacency_list: return False visited = set() def dfs(node): if node == end_node_name: return True visited.add(node) for neighbor in self.adjacency_list[node]: if neighbor not in visited: if dfs(neighbor): return True return False return dfs(start_node_name)"},{"question":"**Fourier Transform for Time Series Prediction** A company is working on a prototype for predicting future trends in weather data using signal processing techniques. They have collected hourly temperature data over several months and want to use the Fast Fourier Transform (FFT) to analyze the frequency components of the data. You are given an array of complex numbers where each element represents temperature data at an hour (encapsulated as a complex number with the real part being the actual temperature and the imaginary part being 0). **Function Specification:** ```python def forecast_fft(temperatures: List[complex]) -> List[complex]: pass ``` - **Input**: - `temperatures`: A list of complex numbers representing hourly temperature readings with length N (where N is a power of 2) - **Output**: - A list of complex numbers representing the transformed data using FFT. **Constraints**: - Length of the input list `N` is guaranteed to be a power of 2 and 1 <= N <= 1024. - The imaginary part of all input complex numbers is 0. - Use the provided FFT function as the basis for your implementation. **Example**: ```python # Sample Input forecast_fft([1.0+0j, 2.0+0j, 1.0+0j, 0.0+0j, 1.0+0j, 2.0+0j, 1.0+0j, 0.0+0j]) # Expected Output [(8+0j), (0+2.8284271247461903j), (0+0j), 0-2.8284271247461903j), (0+0j), (-0+0j), 0+-2.8284271247461903j), (-0+-0j)] ``` # Implementation Requirements: 1. Implement the `forecast_fft` function using the `fft` function provided in the code snippets. 2. Ensure the function handles the input correctly and returns the correct FFT transformed data. # Evaluation Criteria: - Correctness of the implemented function. - Efficiency in terms of time and space complexity, matching or improving the given O(N log N) requirement. - Proper handling of edge cases and constraints.","solution":"import numpy as np from typing import List def forecast_fft(temperatures: List[complex]) -> List[complex]: Applies the Fast Fourier Transform (FFT) to the list of temperatures. Parameters: temperatures (List[complex]): A list of complex numbers representing hourly temperature readings. Returns: List[complex]: The FFT transformed data as a list of complex numbers. # Use numpy\'s fft function to perform the Fast Fourier Transform transformed_data = np.fft.fft(temperatures) # Convert the numpy array to a list of complex numbers and return return list(transformed_data)"},{"question":"Given an encoded message containing digits, implement a function `num_decodings` that determines the total number of ways to decode it. Inputs and Outputs: * **Input**: A single string `enc_mes` containing digits (1-9). * **Output**: An integer representing the total number of decoding ways. Constraints: * The encoded message contains only digits and may not start with \'0\'. * Invalid sequences should return 0 (e.g., \\"0123\\", \\"10203\\"). * Assume the input string length does not exceed 1000 characters. Function Signature: ```python def num_decodings(enc_mes: str) -> int: pass ``` # Example: ```python assert num_decodings(\\"12\\") == 2 # \\"AB\\" (1 2) or \\"L\\" (12) assert num_decodings(\\"226\\") == 3 # \\"BZ\\" (2 26), \\"VF\\" (22 6), \\"BBF\\" (2 2 6) assert num_decodings(\\"0\\") == 0 # Invalid assert num_decodings(\\"06\\") == 0 # Invalid assert num_decodings(\\"27\\") == 1 # \\"BG\\" (2 7) ``` Explanation: 1. For the message `\\"12\\"`, it can be decoded as \\"AB\\" (1 2) or \\"L\\" (12). 2. For the message `\\"226\\"`, it can be decoded in three ways: \\"BZ\\" (2 26), \\"VF\\" (22 6), \\"BBF\\" (2 2 6). Your task is to write a Python function that implements this logic efficiently.","solution":"def num_decodings(enc_mes: str) -> int: if not enc_mes or enc_mes[0] == \'0\': return 0 n = len(enc_mes) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): single_digit = int(enc_mes[i-1:i]) double_digit = int(enc_mes[i-2:i]) if 1 <= single_digit <= 9: dp[i] += dp[i - 1] if 10 <= double_digit <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"# Pancake Sort Implementation and Optimization You are tasked with extending the given **Pancake Sort** algorithm. Your goal is to implement a function that not only sorts the array as given but also monitors the number of flips performed during the sorting process. Additionally, you should provide an updated version of Pancake Sort that uses optimized flipping to further enhance the performance where possible. # Specifications: * **Function Signature:** ```python def optimized_pancake_sort(arr: list) -> (list, int): ``` * **Inputs:** - `arr`: A list of integers that needs to be sorted. * **Outputs:** - **Sorted List**: The sorted version of `arr`. - **Flip Count**: The number of flips performed during the sorting process. * **Constraints:** - The array may be empty. - The elements will be integers. - The array can have up to 1000 elements. * **Performance Requirements:** - Aim to minimize the number of flips compared to the original Pancake Sort. # Example ```python assert optimized_pancake_sort([3, 2, 4, 1]) == ([1, 2, 3, 4], 4) assert optimized_pancake_sort([10, 23, 51, 18, 4, 31, 13, 5]) == ([4, 5, 10, 13, 18, 23, 31, 51], 10) assert optimized_pancake_sort([]) == ([], 0) ``` # Implementation Details: Main Steps: 1. **Find the maximum element** in the unsorted part of the array. 2. **Move the maximum element** to the start of the array if it\'s not already at the correct position. 3. **Flip the array** to move the maximum element to its correct position. 4. **Keep iterating** through the array until the entire array is sorted. 5. **Optimize** by combining consecutive flips when possible. 6. Keep **track of all flips** performed to return as part of the result.","solution":"def optimized_pancake_sort(arr: list) -> (list, int): Sorts the array using an optimized version of pancake sorting and counts the number of flips performed. Args: arr (list): A list of integers to be sorted. Returns: tuple: A tuple containing the sorted list and the number of flips. def flip(sub_arr, k): Helper function to reverse the first k elements of the array. return sub_arr[:k][::-1] + sub_arr[k:] def find_max_index(sub_arr, n): Helper function to find the index of the maximum element in sub_arr[:n]. return sub_arr.index(max(sub_arr[:n])) n = len(arr) flip_count = 0 for size in range(n, 1, -1): # Find the index of the maximum element in the unsorted part of the array max_index = find_max_index(arr, size) if max_index != size - 1: # Flip the maximum element to the front if it\'s not already at the front if max_index != 0: arr = flip(arr, max_index + 1) flip_count += 1 # Flip the maximum element to its correct position arr = flip(arr, size) flip_count += 1 return arr, flip_count"},{"question":"Given an array of integers, implement the `comb_sort` function to sort the array in ascending order using Comb Sort algorithm. # Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: ``` # Input * An array `arr` of integers, where (1 leq text{len}(arr) leq 10^4). # Output * The function should return a new list containing the sorted integers from the input array in ascending order. # Performance Requirements * The solution should aim to be efficient with respect to time and space limits given the size constraints. # Constraints * The integer values in the array can be positive, negative, and zero. * Your solution should handle large inputs efficiently. # Examples ```python *Example 1:* Input: [34, -50, 42, 0, 13, -5, 5, 15] Output: [-50, -5, 0, 5, 13, 15, 34, 42] *Example 2:* Input: [1, 2, 3, 4, 5] Output: [1, 2, 3, 4, 5] *Example 3:* Input: [5, 4, 3, 2, 1] Output: [1, 2, 3, 4, 5] *Example 4:* Input: [10, 1] Output: [1, 10] ``` **Note:** Ensure to handle edge cases such as arrays with duplicate values, already sorted arrays, and arrays with very large or small lengths efficiently.","solution":"def comb_sort(arr): Sorts the array using comb sort algorithm. Args: arr (List[int]): List of integers to be sorted. Returns: List[int]: Sorted list of integers. def get_next_gap(gap): # Shrink gap by shrink factor gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Doubly Linked List Implementation and Operations **Context**: The Doubly Linked List data structure is very useful for certain types of list manipulations. Given a class definition, your task is to implement basic operations for a doubly linked list and ensure the list maintains correct link order. Function Implementations 1. **Adding a new node at the beginning of the list**. 2. **Adding a new node at the end of the list**. 3. **Deleting a node by value**. 4. **Reversing the doubly linked list**. 5. **Traversing and returning the list as a Python list**. Expected Input and Output Formats * **Input/Output**: * For all insertion and deletion operations, functions will return a message indicating the operation\'s success or specify if the operation failed. * For traversal, the function will return a list of values. Constraints * Assume the list initially is empty and operations are performed in sequence. * Values in the list are unique integers. Function Signatures ```python class DoublyLinkedList: def __init__(self): self.head = None def add_at_beginning(self, value: int) -> str: pass def add_at_end(self, value: int) -> str: pass def delete_node(self, value: int) -> str: pass def reverse_list(self) -> str: pass def traverse_list(self) -> list: pass ``` Example ```python dll = DoublyLinkedList() print(dll.add_at_beginning(10)) # \\"Node added at beginning\\" print(dll.add_at_end(20)) # \\"Node added at end\\" print(dll.add_at_beginning(5)) # \\"Node added at beginning\\" print(dll.traverse_list()) # [5, 10, 20] print(dll.delete_node(10)) # \\"Node deleted\\" print(dll.traverse_list()) # [5, 20] print(dll.reverse_list()) # \\"List reversed\\" print(dll.traverse_list()) # [20, 5] ``` **Notes**: 1. Ensure base cases such as inserting into or deleting from an empty list are handled gracefully. 2. Ensure both the `prev` and `next` pointers are updated correctly during node manipulations.","solution":"class Node: def __init__(self, value): self.data = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None def add_at_beginning(self, value: int) -> str: new_node = Node(value) if self.head is not None: new_node.next = self.head self.head.prev = new_node self.head = new_node else: self.head = new_node return \\"Node added at beginning\\" def add_at_end(self, value: int) -> str: new_node = Node(value) if self.head is None: self.head = new_node else: tail = self.head while tail.next is not None: tail = tail.next tail.next = new_node new_node.prev = tail return \\"Node added at end\\" def delete_node(self, value: int) -> str: current = self.head while current is not None: if current.data == value: if current.prev is not None: current.prev.next = current.next if current.next is not None: current.next.prev = current.prev if current is self.head: self.head = current.next del current return \\"Node deleted\\" current = current.next return \\"Node not found\\" def reverse_list(self) -> str: current = self.head prev = None while current is not None: next_node = current.next current.next = prev current.prev = next_node prev = current current = next_node self.head = prev return \\"List reversed\\" def traverse_list(self) -> list: result = [] current = self.head while current is not None: result.append(current.data) current = current.next return result"},{"question":"# Question: Enhanced Counting Sort with Arbitrary Range Handling Suppose you have been given the task to sort an array of integers using the Counting Sort algorithm. You are required to handle the scenario where the array can contain both negative and positive integers. As part of the assessment, ensure your solution is efficient and maintains the properties of the original counting sort algorithm. **Function Signature**: ```python def custom_counting_sort(arr: List[int]) -> List[int]: ``` **Input**: - A list `arr` of integers, where the length is `n` (0 ≤ n ≤ 10^6). **Output**: - A sorted list of integers. **Constraints**: - The integer values can range from `-10^6` to `10^6`. **Performance Requirements**: - Time complexity should remain O(n + k) where `k` is the range from the smallest to the largest integer in the array. - Space complexity should primarily depend on the given range `k`. **Requirements**: 1. Convert negative values to positives temporarily to use counting sort effectively. 2. Restore the correct values after sorting. 3. Ensure that the sort remains stable. **Edge Cases** to Consider: - An empty array. - Array where all elements are identical. - Arrays containing maximum or minimum integer values within the constraints. # Example ```python assert custom_counting_sort([4, -1, 2, -3, 0]) == [-3, -1, 0, 2, 4] assert custom_counting_sort([]) == [] assert custom_counting_sort([5, 5, 5, 5]) == [5, 5, 5, 5] ```","solution":"from typing import List def custom_counting_sort(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 count = [0] * range_of_elements output = [0] * len(arr) for num in arr: count[num - min_val] += 1 for i in range(1, len(count)): count[i] += count[i - 1] for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"Implement a Doubly Linked List Scenario: You are part of a software development team working on a text editor. The text editor needs an efficient way to handle frequent insertions and deletions of characters, both from the front and back. Considering the need for efficient operations from both ends, you decide to implement a Doubly Linked List. Task: Write a class `DoublyLinkedList` with the following methods: - `append(value)`: Adds a node with the given value to the end of the list. - `prepend(value)`: Adds a node with the given value to the front of the list. - `delete(value)`: Removes the first occurrence of a node with the given value from the list. - `find(value)`: Returns the node with the given value, or `None` if the value is not in the list. - `display()`: Prints the values in the list from head to tail. Constraints: - The list should handle all types of elements (integers, strings, etc.). - Assume no duplicate elements in the list for simplicity. - Aim for O(1) insertion and deletion operations if the node references are known. Function Signature: ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): # Your implementation here def prepend(self, value): # Your implementation here def delete(self, value): # Your implementation here def find(self, value): # Your implementation here def display(self): # Your implementation here ``` **Example:** ```python dll = DoublyLinkedList() dll.append(10) dll.append(20) dll.prepend(5) dll.display() # Output: 5 10 20 dll.delete(10) dll.display() # Output: 5 20 node = dll.find(20) print(node.value) # Output: 20 ``` Ensure your implementation passes all provided examples and handles edge cases like empty list operations, single-node list operations, and non-existent value deletions gracefully.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): new_node = DoublyLinkedListNode(value) if self.tail is None: self.head = new_node self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def prepend(self, value): new_node = DoublyLinkedListNode(value) if self.head is None: self.head = new_node self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def delete(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return current = current.next def find(self, value): current = self.head while current: if current.value == value: return current current = current.next return None def display(self): values = [] current = self.head while current: values.append(current.value) current = current.next print(\\" \\".join(map(str, values)))"},{"question":"You are given a matrix `mat` of size `m x n`, sorted in non-decreasing order both row-wise and column-wise. Your task is to implement a function `search_in_sorted_matrix(mat, m, n, key)` that searches for a specific key in the matrix and returns the coordinates of the key if found, or `None` otherwise. # Function Signature ```python def search_in_sorted_matrix(mat: List[List[int]], m: int, n: int, key: int) -> Union[Tuple[int, int], None]: pass ``` # Input * `mat`: A list of lists representing the `m x n` matrix where rows and columns are sorted in non-decreasing order. * `m`: An integer representing the number of rows in the matrix. * `n`: An integer representing the number of columns in the matrix. * `key`: An integer to be searched in the matrix. # Output * Returns a tuple `(row, column)` of 0-based indices where the key is found. If the key is not present in the matrix, return `None`. # Constraints * `1 <= m, n <= 500` * -10^6 <= `mat[i][j]`, `key` <= 10^6 # Example ```python mat = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 assert search_in_sorted_matrix(mat, 4, 3, 13) == (1, 2) key = 3 assert search_in_sorted_matrix(mat, 4, 3, 3) == None ``` # Explanation In the first example, the key `13` is found at row `1`, column `2` (0-indexed). In the second example, the key `3` is not present in the matrix, thus returning `None`.","solution":"from typing import List, Tuple, Union def search_in_sorted_matrix(mat: List[List[int]], m: int, n: int, key: int) -> Union[Tuple[int, int], None]: Searches for the key in the sorted matrix and returns its position (row, column) if found. If the key is not found, returns None. row = 0 col = n - 1 while row < m and col >= 0: if mat[row][col] == key: return (row, col) elif mat[row][col] > key: col -= 1 else: row += 1 return None"},{"question":"# Question: Mode Finding Algorithm You are tasked with finding the mode(s) of an array, i.e., the element(s) that appear most frequently in the array. # Function Signature ```python def top_1(arr: List[int]) -> List[int]: ``` # Input - `arr` (List[int]): An array of integers which can contain both positive and negative numbers. # Output - Return a list of integers containing the most frequently occurring value(s) in the array. The list should contain all the elements that have the highest frequency, in any order. # Constraints - The input list can have a length between `0` to `10^6`. - The elements in the list will be within the range `-10^9` to `10^9`. # Performance Requirements - The time complexity of your solution should be O(n). - The space complexity of your solution should be O(n). # Example ```python Input: arr = [1, 1, 2, 2, 3, 4] Output: [1, 2] Input: arr = [5, 5, 5, -1, -1, 2, 2, 2, 3, 3, 4, 4] Output: [5, 2] Input: arr = [] Output: [] ``` # Description In this exercise, you need to implement the function `top_1` which takes an array of integers and returns a list of the mode(s). If there are multiple values with the same highest frequency, include all of them in the list. The function should be efficient in terms of both time and space complexity, handling up to one million integers. # Considerations - Handle edge cases like an empty array gracefully by returning an empty list. - Ensure the function can handle large inputs efficiently within the specified constraints.","solution":"from typing import List from collections import Counter def top_1(arr: List[int]) -> List[int]: Finds the mode(s) of an array i.e., the element(s) that appear most frequently. If there are multiple elements with the same highest frequency, all should be returned. if not arr: return [] frequency = Counter(arr) max_count = max(frequency.values()) return [num for num, count in frequency.items() if count == max_count]"},{"question":"You are tasked with writing a function that counts the number of islands in a 2D grid. An island is formed by connecting adjacent cells horizontally or vertically and is surrounded by water. # Function Signature ```python def count_islands(grid: List[List[int]]) -> int: ``` # Input * `grid`: A 2D list of integers where \'1\' represents land and \'0\' represents water. You can assume all four edges of the grid are surrounded by water. # Output * Return an integer representing the number of islands. # Constraints * The grid will have at least one cell and at most 1000x1000 cells (reasonable constraints to check performance). * The grid contains only \'1\'s and \'0\'s. * You are expected to handle grids of different shapes and sizes. Rectangular grids are permissible. # Example ```python grid1 = [ [1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0] ] print(count_islands(grid1)) # Output: 1 grid2 = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] print(count_islands(grid2)) # Output: 3 ``` You are encouraged to handle all edge cases and ensure the function operates efficiently given the constraints. # Context In this problem, you are asked to demonstrate your knowledge of breadth-first search (BFS) for graph traversal in a 2D grid context. Make sure to clearly manage the visited cells and ensure your solution scales appropriately for large inputs.","solution":"from typing import List def count_islands(grid: List[List[int]]) -> int: def bfs(r, c): queue = [(r, c)] while queue: row, col = queue.pop(0) for dr, dc in directions: nr, nc = row + dr, col + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc)) if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = set() directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] island_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1 and (r, c) not in visited: visited.add((r, c)) bfs(r, c) island_count += 1 return island_count"},{"question":"You are given a non-empty string `sentence` and a set of valid words `dictionary`. Your task is to determine the number of distinct ways the given string can be segmented into a sequence of one or more dictionary words. # Input: 1. `sentence`: A non-empty string consisting of lowercase alphabets. 2. `dictionary`: A set of valid words, where each word is a non-empty string of lowercase alphabets. # Output: Return an integer representing the number of distinct ways the input string `sentence` can be segmented using words from the `dictionary`. # Constraints: * The input string will have a length of at most 300. * Dictionary words will have a length of at most 300. # Performance Requirements: The solution should handle up to the largest constraints efficiently with techniques such as memoization or dynamic programming to avoid excessive recomputation. # Example: **Input:** ```python sentence = \\"appletablet\\" dictionary = {\\"apple\\", \\"tablet\\", \\"applet\\", \\"able\\", \\"t\\", \\"app\\", \\"let\\"} ``` **Output:** ```python 4 ``` **Explanation:** The string can be segmented into the following valid sentences: 1. \\"apple\\" \\"tablet\\" 2. \\"apple\\" \\"table\\"\\"t\\" 3. \\"applet\\" \\"able\\" \\"t\\" 4. \\"app\\" \\"let\\" \\"able\\" \\"t\\" # Function Signature: ```python def count_sentences(sentence: str, dictionary: Set[str]) -> int: pass ``` # Implementation Requirement: Write the `count_sentences` function to solve the problem while adhering to the above specifications. You can use any suitable optimization techniques discussed.","solution":"def count_sentences(sentence, dictionary): Returns the number of distinct ways the given string can be segmented into a sequence of one or more dictionary words. def helper(index): if index == len(sentence): return 1 if index in memo: return memo[index] count = 0 for end in range(index + 1, len(sentence) + 1): if sentence[index:end] in dictionary: count += helper(end) memo[index] = count return count memo = {} return helper(0)"},{"question":"You are given a singly linked list of nodes that may contain duplicates. Each node contains an integer value. Your task is to implement two functions to remove the duplicates from the linked list. 1. **`remove_dups_with_set(head: Node) -> None`**: * This function should remove duplicates using a set. * `head`: The head node of the singly linked list. * **Time Complexity**: O(N) * **Space Complexity**: O(N) 2. **`remove_dups_without_set(head: Node) -> None`**: * This function should remove duplicates without using any additional data structures for tracking. * `head`: The head node of the singly linked list. * **Time Complexity**: O(N^2) * **Space Complexity**: O(1) Additional Requirements * Implement the `Node` class as a data structure to represent each node in the linked list. * Also, implement a function to print the linked list for debugging purposes: * **`print_linked_list(head: Node) -> None`** * This function should print the values in the linked list from the head to the last node, separated by \\" -> \\". **Input and Output Specifications**: * Input: A single input — the head node of a singly linked list. * Output: No return value. The linked list should be modified in-place. **Examples**: 1 ```python # Example of create and linking nodes head = Node(1) head.next = Node(2) head.next.next = Node(2) head.next.next.next = Node(3) remove_dups_with_set(head) print_linked_list(head) # Outputs: 1 -> 2 -> 3 remove_dups_without_set(head) print_linked_list(head) # Outputs: 1 -> 2 -> 3 ``` **Edge Cases**: * Empty linked list or a linked list with a single node, e.g., `head = None` or `head = Node(1)`. * Very large linked list to test performance limits and memory usage. **Constraints**: * The values in the nodes are guaranteed to be integers. * You are guaranteed to have at least one node in the test cases.","solution":"class Node: def __init__(self, value): self.value = value self.next = None def remove_dups_with_set(head: Node) -> None: if not head: return seen = set() current = head prev = None while current: if current.value in seen: prev.next = current.next else: seen.add(current.value) prev = current current = current.next def remove_dups_without_set(head: Node) -> None: current = head while current: runner = current while runner.next: if runner.next.value == current.value: runner.next = runner.next.next else: runner = runner.next current = current.next def print_linked_list(head: Node) -> None: values = [] current = head while current: values.append(current.value) current = current.next print(\\" -> \\".join(map(str, values)))"},{"question":"You are tasked with implementing a segment tree to facilitate efficient range queries over an array. The segment tree uses a provided function to compute the result over a specified range. Your segment tree should support efficient querying. # Requirements Class Definition You need to define the class `SegmentTree` with the following functionalities: # Constructor ```python def __init__(self, arr: List[int], function: Callable[[int, int], int]): ``` * Initializes the segment tree for the input array `arr` and function `function`. * Parameters: * `arr` - List of integers to be managed by the segment tree. * `function` - A binary function to apply during construction and querying (e.g., sum, max). # Query Method ```python def query(self, L: int, R: int) -> int: ``` * Returns the result of the provided function over the array range [L, R]. * Parameters: * `L` - Starting index of the range. * `R` - Ending index of the range, inclusive. # Constraints * 1 <= len(arr) <= 10^5 * 0 <= arr[i] <= 10^9 * 0 <= L <= R < len(arr) # Example ```python # Example with sum function arr = [4, 5, 2, 3, 4, 43, 3] seg_tree = SegmentTree(arr, sum) print(seg_tree.query(1, 4)) # Output: 14 (5 + 2 + 3 + 4) # Example with max function arr = [2, 4, 5, 3, 4] seg_tree = SegmentTree(arr, max) print(seg_tree.query(2, 4)) # Output: 5 print(seg_tree.query(0, 3)) # Output: 5 ```","solution":"from typing import List, Callable class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]): self.n = len(arr) self.func = function self.tree = [None] * (2 * self.n) # Build the tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, L: int, R: int) -> int: L += self.n R += self.n result = None while L <= R: if L % 2 == 1: result = self.tree[L] if result is None else self.func(result, self.tree[L]) L += 1 if R % 2 == 0: result = self.tree[R] if result is None else self.func(result, self.tree[R]) R -= 1 L //= 2 R //= 2 return result"},{"question":"# Regex Matching Problem You are tasked with designing a function that determines whether a given string matches a pattern containing two special characters, \'.\' and \'*\'. The \'.\' character matches any single character, while \'*\' matches zero or more of the preceding element. The function should verify that the entire input string conforms to the pattern, from start to finish. **Function Signature**: ```python def is_match(s: str, p: str) -> bool: ... ``` Input - `s`: A string (1 ≤ len(s) ≤ 20). - `p`: A string containing the pattern (1 ≤ len(p) ≤ 30), which can include letters, \'.\' and \'*\'. Output - Returns a boolean value indicating whether the input string `s` matches the pattern `p`. Constraints - Patterns like `a**`, `.*` are valid. - Patterns like `*` (leading `*`) are invalid. - Assume that all input is valid and non-empty. Examples ```python print(is_match(\\"aa\\", \\"a\\")) # Output: False print(is_match(\\"aa\\", \\"aa\\")) # Output: True print(is_match(\\"aaa\\", \\"aa\\")) # Output: False print(is_match(\\"aa\\", \\"a*\\")) # Output: True print(is_match(\\"aa\\", \\".*\\")) # Output: True print(is_match(\\"ab\\", \\".*\\")) # Output: True print(is_match(\\"aab\\", \\"c*a*b\\")) # Output: True ``` Scenario Consider writing a function to evaluate a set of user inputs against predefined patterns for a validation system, such as confirming username formats, allowing any single character wildcards, and repeated sequences. This function will be integrated into a larger system dealing with user inputs in various forms, requiring reliability and efficiency. Develop a solution that comprehensively handles these constraints and implements the required matches.","solution":"def is_match(s: str, p: str) -> bool: Given an input string (s) and a pattern (p), implement regular expression matching with support for \'.\' and \'*\'. # This uses dynamic programming. We\'ll create a DP table to store results of subproblems. # dp[i][j] will be True if first i characters in string s match the first j characters of pattern p. m, n = len(s), len(p) dp = [[False] * (n + 1) for _ in range(m + 1)] # Base case: empty string matches empty pattern dp[0][0] = True # Deals with patterns that can match the empty string for j in range(1, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Build the table dp in bottom-up manner for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or dp[i - 1][j] and (p[j - 2] == s[i - 1] or p[j - 2] == \'.\') return dp[m][n]"},{"question":"# Cycle Detection in a Process Dependency Graph In an operating system, processes may hold locks on various resources, leading to dependency chains. Sometimes, these chains might form cycles, which indicates a deadlock. Your task is to determine if a given set of process dependencies contains a cycle. You are given a dictionary `graph` representing the dependency graph, where keys are process identifiers and values are lists of processes that the key process is waiting on. Implement a function `detect_cycle(graph: Dict[str, List[str]]) -> bool` that returns `True` if there is at least one cycle in the graph, and `False` otherwise. Input: - `graph`: A dictionary where each key is a process identifier (a string), and the corresponding value is a list of processes (strings) that it depends on. Output: - A boolean value indicating whether there is a cycle in the graph. Constraints: - Each process identifier is unique. - The graph may be simplified such that there are no duplicate dependencies for a process (A -> B will not appear twice). # Example: Example 1 ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(detect_cycle(graph)) # Output: True ``` Example 2 ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [], \'D\': [\'E\'], \'E\': [\'F\'], \'F\': [] } print(detect_cycle(graph)) # Output: False ``` Write your implementation of the `detect_cycle` function below: ```python def detect_cycle(graph): # Your code here pass ```","solution":"def detect_cycle(graph): Returns True if there is a cycle in the process dependency graph, False otherwise. def visit(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if visit(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph: if visit(node): return True return False"},{"question":"# Question Context: You are tasked with implementing a function to find the coefficients of Bézout\'s identity for two given integers (num1) and (num2). These coefficients (s) and (t) must satisfy the equation (num1 cdot s + num2 cdot t = GCD(num1, num2)). This is useful for solving linear Diophantine equations and for cryptographic algorithms where such relationships are essential. Problem Statement: Write a function `extended_gcd(num1, num2)` in Python that takes two integers (num1) and (num2) and returns three integers (s), (t), and (g), where (g) is the GCD of (num1) and (num2). The integers (s) and (t) must satisfy Bézout\'s identity (num1 cdot s + num2 cdot t = g). Input Format: - Two integers (num1) and (num2). Output Format: - Three integers (s), (t), and (g). Constraints: - (-10^9 leq num1, num2 leq 10^9) - (num1) and (num2) can be negative or zero but not both zero at the same time. Implementation: ```python def extended_gcd(num1, num2): Extended GCD algorithm. Return s, t, g such that num1 * s + num2 * t = GCD(num1, num2) and s and t are co-prime. Args: num1 (int): First integer num2 (int): Second integer Returns: int, int, int: Coefficients s, t and GCD of num1 and num2 # Implement the extended GCD algorithm here. old_s, s = 1, 0 old_t, t = 0, 1 old_r, r = num1, num2 while r != 0: quotient = old_r // r old_r, r = r, old_r - quotient * r old_s, s = s, old_s - quotient * s old_t, t = t, old_t - quotient * t return old_s, old_t, old_r # Example usage: # num1 = 120 # num2 = 23 # s, t, g = extended_gcd(num1, num2) # print(s, t, g) # Output should be: s, t, and the gcd ``` Example: - **Input**: `num1 = 120`, `num2 = 23` - **Output**: `s, t, 1` (example, actual outputs may vary) Ensure that the numbers provided are integers and handle cases where either (num1) or (num2) is zero appropriately within your code.","solution":"def extended_gcd(num1, num2): Extended GCD algorithm. Returns s, t, g such that num1 * s + num2 * t = GCD(num1, num2) where s and t are integers and g is the GCD. Args: num1 (int): First integer num2 (int): Second integer Returns: int, int, int: Coefficients s, t and GCD of num1 and num2 old_s, s = 1, 0 old_t, t = 0, 1 old_r, r = num1, num2 while r != 0: quotient = old_r // r old_r, r = r, old_r - quotient * r old_s, s = s, old_s - quotient * s old_t, t = t, old_t - quotient * t return old_s, old_t, old_r # Example usage: # num1 = 120 # num2 = 23 # s, t, g = extended_gcd(num1, num2) # print(s, t, g)"},{"question":"# Text Justification Challenge **Context**: You are developing a text editor feature that formats paragraphs into fully-justified text. Your task is to write a function that takes an array of words and a maximum line width, and returns the words formatted into fully-justified lines of text. **Function Signature**: ```python def text_justification(words: List[str], max_width: int) -> List[str]: pass ``` **Input**: - A list of words (`words`) where each word is a non-space character string. - An integer (`max_width`) which is the maximum width of each line. **Output**: - A list of strings where each string represents a fully-justified line with exactly `max_width` characters. **Constraints**: - `1 <= len(words) <= 1000` - `1 <= len(words[i]) <= max_width` - `max_width <= 100` **Performance Requirements**: - The solution should be efficient with a time complexity of `O(n)`, where `n` is the number of words. **Examples**: 1. Input: `words = [\\"What\\", \\"must\\", \\"be\\", \\"acknowledgment\\", \\"shall\\", \\"be\\"], max_width = 16` Output: ``` [ \\"What must be\\", \\"acknowledgment \\", \\"shall be \\" ] ``` 2. Input: `words = [\\"This\\", \\"is\\", \\"an\\", \\"example\\", \\"of\\", \\"text\\", \\"justification.\\"], max_width = 16` Output: ``` [ \\"This is an\\", \\"example of text\\", \\"justification. \\" ] ``` **Detailed Requirements**: 1. Each line should contain as many words as possible. 2. Use spaces `\' \'` to ensure each line has exactly `max_width` characters. 3. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly, the empty slots on the left will be assigned more spaces than the slots on the right. 4. The last line should be left-justified and no extra space is inserted between words. **Note**: - Ensure the function handles edge cases such as single long words and input with varying word lengths effectively. Implement the function `text_justification` as specified to complete the challenge.","solution":"from typing import List def text_justification(words: List[str], max_width: int) -> List[str]: result = [] line = [] curr_len = 0 for word in words: if curr_len + len(word) + len(line) > max_width: for i in range(max_width - curr_len): line[i % (len(line) - 1 or 1)] += \' \' result.append(\'\'.join(line)) line, curr_len = [word], len(word) else: line.append(word) curr_len += len(word) # Handle the last line result.append(\' \'.join(line).ljust(max_width)) return result"},{"question":"Implement a Graph Cycle Detection Algorithm Context You are given a directed graph implemented as a class `DirectedGraph`. Your task is to implement a function `has_cycle` to detect if the graph contains any cycles. A cycle in a directed graph is a path from at least one node back to itself, following the directed edges. Task 1. Implement a function `has_cycle` in the `DirectedGraph` class to determine whether there is a cycle in the graph. 2. The function should return `True` if a cycle exists, and `False` otherwise. Input and Output Formats - **Input**: The function `has_cycle` takes no parameters. The graph data is contained within the `DirectedGraph` instance. - **Output**: A boolean value `True` if the graph contains a cycle, `False` otherwise. Constraints - The graph can have up to 10,000 nodes and 100,000 edges. - Ensure that the function runs efficiently within these constraints. Performance Requirements - Aim for a time complexity of O(V + E), where V is the number of vertices (nodes) and E is the number of edges in the graph. - Ensure that memory consumption does not exceed necessary bounds for the given constraints. Implementation Tip Consider utilizing graph traversal techniques such as Depth-First Search (DFS) with recursion, and a mechanism to track the current path and overall visited nodes to detect cycles. # Example ```python # Example Graph Creation (No cycle) graph_data = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [] } graph = DirectedGraph(graph_data) print(graph.has_cycle()) # Output: False # Example Graph with Cycle graph_data_with_cycle = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] } graph_with_cycle = DirectedGraph(graph_data_with_cycle) print(graph_with_cycle.has_cycle()) # Output: True ```","solution":"class DirectedGraph: def __init__(self, graph_data): Initializes the DirectedGraph with the given adjacency list. graph_data: Dictionary where the keys are nodes and the values are lists of adjacent nodes. self.graph = graph_data def has_cycle(self): Detects if the graph contains any cycle. Returns: True if there is a cycle in the graph, False otherwise. visited = set() rec_stack = set() def dfs(node): if node in rec_stack: return True if node in visited: return False visited.add(node) rec_stack.add(node) for neighbor in self.graph.get(node, []): if dfs(neighbor): return True rec_stack.remove(node) return False for node in self.graph: if dfs(node): return True return False"},{"question":"# Coding Challenge: k-th to Last Element in a Linked List Scenario You are managing a dynamic dataset represented as a singly linked list. The nature of this dataset involves frequent insertions and deletions, making arrays an inefficient option. Your task is to implement a function that finds the k-th to last element in the linked list. This is particularly useful in cases such as retrieving the last few orders or logs in a system. Task Write a function to find the k-th to last element of a singly linked list. Implement the function using an optimal approach that balances both time and space complexities. Function Signature ```python def kth_to_last_optimal(head: Node, k: int) -> Node: pass ``` Inputs - A head node of a singly linked list. - An integer `k` representing the position from the last element (0-based index). Outputs - Returns the k-th to last node of the list. Ensure the function raises an appropriate error (e.g., IndexError) if k is out of bounds. Constraints - The list contains at least one node. - `k` is a non-negative integer. - Avoid using any unsafe or suboptimal methods (e.g., `eval`, using dictionaries for storage). Example Consider the linked list with elements: A -> A -> B -> C -> D -> C -> F -> G, when searching for the 4th to last element: - Input: `head (linked list), k = 4` - Output: Node with value `D` Edge Cases - Empty list or null head. - Invalid `k` values. **Note**: Follow optimal practices and ensure proper handling of edge cases and constraints.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def kth_to_last_optimal(head: Node, k: int) -> Node: Returns the k-th to last element of a singly linked list. Raises an IndexError if k is out of bounds. if head is None: raise IndexError(\\"List is empty\\") fast = slow = head for _ in range(k): if fast is None: raise IndexError(\\"k is out of bounds\\") fast = fast.next while fast and fast.next: fast = fast.next slow = slow.next if fast is None: raise IndexError(\\"k is out of bounds\\") return slow"},{"question":"# Transitive Closure with Optimization Context You are working on a project that involves analyzing network connectivity. Your task is to determine the reachability of nodes within a directed network and store this reachability information in a matrix form. The provided graph will be represented using an adjacency list. You need to calculate the transitive closure of this graph. Task Implement a function `find_transitive_closure` that calculates the transitive closure of a directed graph using Depth-First Search (DFS). Optimize your implementation by ensuring that you do not perform redundant DFS operations. Function Signature ```python def find_transitive_closure(vertex_count: int, edges: List[Tuple[int, int]]) -> List[List[int]]: ``` Input 1. `vertex_count`: An integer representing the number of vertices in the graph. 2. `edges`: A list of tuples where each tuple `(u, v)` represents a directed edge from vertex `u` to vertex `v`. Output * A matrix of size `vertex_count x vertex_count`, where the element at (i, j) is 1 if there is a path from vertex i to vertex j, and 0 otherwise. Constraints * 1 <= vertex_count <= 100 * 0 <= len(edges) <= 1000 Performance Requirements * Ensure that the solution is optimized to avoid redundant DFS traversals, keeping the overall computation efficient. Example ```python vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3)] print(find_transitive_closure(vertex_count, edges)) # Output: # [[1, 1, 1, 1], # [0, 1, 1, 1], # [0, 0, 1, 1], # [0, 0, 0, 1]] ``` In the above example: - Node 0 can reach all other nodes following the edges provided. - Node 1 can reach nodes 1, 2, and 3. - Node 2 can reach nodes 2 and 3. - Node 3 can only reach itself.","solution":"from typing import List, Tuple def find_transitive_closure(vertex_count: int, edges: List[Tuple[int, int]]) -> List[List[int]]: # Initialize the reachability matrix with 0s. closure = [[0] * vertex_count for _ in range(vertex_count)] # Create an adjacency list from the edges adj_list = [[] for _ in range(vertex_count)] for u, v in edges: adj_list[u].append(v) # Helper function to perform DFS and mark reachability def dfs(start, v): for neighbor in adj_list[v]: if closure[start][neighbor] == 0: closure[start][neighbor] = 1 dfs(start, neighbor) # Calculate transitive closure for i in range(vertex_count): closure[i][i] = 1 # Each vertex is reachable from itself dfs(i, i) return closure"},{"question":"# Radix Sort Implementation and Analysis You are tasked with implementing an advanced sorting algorithm, Radix Sort. This algorithm is particularly efficient for sorting lists of integers where the number of digits in the largest number is significantly smaller than the size of the list itself. Your implementation should handle arrays of non-negative integers. # Problem Statement Write a function `radix_sort(arr, simulation=False)` that sorts an array of non-negative integers using the Radix Sort algorithm. Optionally (when `simulation` parameter is True), the function should print out the array at each iteration of sorting at each significant digit. Input: * `arr`: List of non-negative integers to be sorted. The length of arr (n) satisfies (1 leq n leq 10^6). * `simulation` (optional): Boolean flag. If `True`, after every iteration of sorting digits, print the array. Default is `False`. Output: * Returns a sorted list of integers. * When `simulation=True`, print the list after each digit sorting step. Constraints: 1. You may assume all integers in the list are non-negative and fit in a standard 32-bit integer. 2. If `arr` contains zero or one element, return it as is. 3. The array must be sorted in ascending order. Function Signature: ```python def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Example: ```python arr = [170, 45, 75, 90, 802, 24, 2, 66] radix_sort(arr, simulation=True) ``` **Output:** ``` iteration 0 : 170 45 75 90 802 24 2 66 iteration 1 : 802 2 24 45 66 170 75 90 iteration 2 : 2 24 45 66 75 90 170 802 iteration 3 : 2 24 45 66 75 90 170 802 ```","solution":"from typing import List def counting_sort_for_radix(arr: List[int], exp: int) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(n): arr[i] = output[i] return arr def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if len(arr) <= 1: return arr max_val = max(arr) exp = 1 iteration = 0 while max_val // exp > 0: arr = counting_sort_for_radix(arr, exp) if simulation: print(f\\"iteration {iteration} : {\' \'.join(map(str, arr))}\\") exp *= 10 iteration += 1 return arr"},{"question":"# Advanced Stack Operations - Assessment Question Overview: You are working on developing an algorithm to manage inventory in a warehouse where items are stacked. Your task is to verify if the given stack of item IDs is sorted in non-decreasing order from the bottom to the top using stack operations. Problem Statement: Implement a function called `verify_sorted_stack` that takes a stack of integers as input and returns a boolean indicating whether the stack is sorted in ascending order from the bottom. You should not use any additional data structures apart from the stack provided and temporary variables. Function Signature: ```python def verify_sorted_stack(stack: List[int]) -> bool: ``` Input: * `stack`: A list of integers representing the stack, where the last element of the list represents the top of the stack. Output: * A boolean value: `True` if the stack is sorted in ascending order from bottom to top, otherwise `False`. Constraints: * The function must not use any auxiliary data structures (e.g., lists, arrays) except for temporary variables. * You are allowed only stack operations (i.e., pop, push). Example: ```python stack1 = [1, 2, 3, 4, 5, 6] print(verify_sorted_stack(stack1)) # Output: True stack2 = [6, 5, 4, 3, 2, 1] print(verify_sorted_stack(stack2)) # Output: False stack3 = [1, 3, 2, 4, 5] print(verify_sorted_stack(stack3)) # Output: False ``` Implementation Constraints: * Ensure the original order of the stack is preserved after the function execution. * Optimize the function to work in O(n) time complexity and O(1) additional space complexity. Performance Requirements: * The solution must run efficiently for stacks with up to 10^5 elements.","solution":"from typing import List def verify_sorted_stack(stack: List[int]) -> bool: Verify if the stack is sorted in non-decreasing order from bottom to top. Parameters ---------- stack : List[int] The stack of integers represented as a list where the last element is the top of the stack. Returns ------- bool True if the stack is sorted in ascending order from bottom to top, False otherwise. # If the stack is empty or has one element, it is considered sorted if len(stack) <= 1: return True # Initialize the last checked element to the bottom-most element last_checked = stack[0] # Iterate through the stack for i in range(1, len(stack)): current = stack[i] if current < last_checked: return False last_checked = current return True"},{"question":"# Coding Assessment You are given a linked list where each node holds a character value. Two different methods to remove duplicates from this list have been discussed in detail. Your task is to implement a function to merge two sorted linked lists into a single sorted linked list, ensuring that the merged list is free from duplicate values. # Requirements * Implement the function `merge_and_remove_dups(head1, head2)`: * **Input**: * `head1`: The head node of the first sorted linked list. * `head2`: The head node of the second sorted linked list. * **Output**: The head node of the merged linked list with all unique values, free of duplicates. * The given linked lists are sorted in ascending order and may contain duplicate values within each list or between the lists. * The merged list should be in ascending order and should contain no duplicate values. # Constraints * The value of the nodes are characters (\'A\'-\'Z\'). * You cannot use additional data structures like sets or hashmaps – optimize for space complexity. # Examples *Example 1:* ```plaintext Input: head1: A -> A -> B -> C head2: B -> D -> D -> E Output: A -> B -> C -> D -> E ``` *Example 2:* ```plaintext Input: head1: F -> G -> H head2: A -> B -> C Output: A -> B -> C -> F -> G -> H ``` # Notes - Use the provided `Node` class for creating list nodes. - Ensure to handle edge cases like empty input lists or lists with no duplicates. ```python class Node: def __init__(self, val=None): self.val = val self.next = None def merge_and_remove_dups(head1, head2): # Your implementation here pass ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def merge_and_remove_dups(head1, head2): # Create a dummy node to act as the head of the merged list dummy = Node() current = dummy prev_val = None while head1 is not None and head2 is not None: if head1.val < head2.val: if prev_val != head1.val: current.next = Node(head1.val) current = current.next prev_val = head1.val head1 = head1.next elif head1.val > head2.val: if prev_val != head2.val: current.next = Node(head2.val) current = current.next prev_val = head2.val head2 = head2.next else: if prev_val != head1.val: current.next = Node(head1.val) current = current.next prev_val = head1.val head1 = head1.next head2 = head2.next while head1 is not None: if prev_val != head1.val: current.next = Node(head1.val) current = current.next prev_val = head1.val head1 = head1.next while head2 is not None: if prev_val != head2.val: current.next = Node(head2.val) current = current.next prev_val = head2.val head2 = head2.next return dummy.next"},{"question":"# Question Scenario You are working on implementing a feature for a software system where you need to process hierarchical data stored as a binary tree. Specifically, you need to implement the preorder traversal of the binary tree. Preorder traversal is important as it processes the parent node before its child nodes, which helps in tasks like tree reconstruction. Task Write a function `preorder_traversal` that accepts the root node of a binary tree and returns a list containing the values of the nodes visited in preorder traversal order. Specifications 1. Implement both an iterative and recursive solution within the same function. 2. The binary tree node is defined as: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` 3. Function signature: ```python def preorder_traversal(root: Node) -> list: # Implement the function ``` 4. Input: - `root`: The root node of the binary tree (type `Node` or `None`). 5. Output: - A list of integers representing the node values in preorder traversal order. Constraints * The number of nodes in the tree will be in the range `[0, 10^4]`. * Node values are integers within `[-10^5, 10^5]`. Example ```python # Construct a binary tree # 1 # / # 2 3 # / # 4 5 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) print(preorder_traversal(root)) # Output: [1, 2, 4, 5, 3] ``` Implement both the recursive and iterative versions for a thorough understanding of tree traversal methods.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def preorder_traversal(root: Node) -> list: def recursive_preorder(node, result): if not node: return result.append(node.val) recursive_preorder(node.left, result) recursive_preorder(node.right, result) # Implementing recursive solution result_recursive = [] recursive_preorder(root, result_recursive) # Implementing iterative solution result_iterative = [] if root: stack = [root] while stack: node = stack.pop() result_iterative.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) # Returns the result for either solution. Here, we return the recursive one for simplicity. return result_recursive"},{"question":"# Set Cover Problem: Optimized Implementation **Objective**: You are tasked with implementing a function to solve the Set Cover problem using an optimized lazy greedy algorithm. Your implementation should provide an efficient approximation for large inputs. **Scenario**: A library needs to include a specific collection of books (universe) to meet regulatory requirements. To minimize costs, they will choose bundles of books (subsets) being sold in the market. Each bundle has an associated cost. You need to help the library determine which bundles to buy to minimize their expenses while still covering all required books. **Function Signature**: ```python def optimized_greedy_set_cover(universe: set, subsets: dict, costs: dict) -> list: Find a near-optimal minimum cost subcollection of subsets that covers all elements of the universe. Args: universe (set): Set of elements to be covered. subsets (dict): Dictionary of subsets where keys are identifiers and values are sets of elements. costs (dict): Dictionary where keys are subset identifiers and values are the cost of each subset. Returns: list: List of subset identifiers that minimally cover the universe. # Your code here ``` Input: - **universe**: `set` of integers representing the required books. - **subsets**: `dict` where each key is a subset ID and the value is a set of integers representing books in that subset. - **costs**: `dict` where each key is a subset ID and the value is an integer representing the cost of that subset. Output: - **list**: List of subset IDs that cover all elements in the universe at the minimum possible combined cost. # Example: **Input**: ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} ``` **Output**: ```python [\'S3\', \'S2\'] ``` **Explanation**: Subset `S3` covers {1, 4, 3, 2} and subset `S2` covers {2, 5}. Together, they cover all elements of the universe `{1, 2, 3, 4, 5}` with a combined cost of 13, which is the minimum possible. # Constraints: 1. The sets can only contain positive integers. 2. The cost of any subset is a positive integer. 3. The universe set can contain up to 1000 elements. 4. The number of subsets can be up to 100. **Performance Requirement**: The algorithm should perform efficiently with (O(m log n)) time complexity, (m) being the number of subsets and (n) the size of the universe, using lazy evaluation achieving near-optimal subsets selection. # Special Notes: 1. Ensure to handle incomplete cover scenarios by returning an empty list if the subsets do not cover the universe. 2. Validate inputs to ensure universe subsets can form a complete coverage.","solution":"def optimized_greedy_set_cover(universe, subsets, costs): Find a near-optimal minimum cost subcollection of subsets that covers all elements of the universe. Args: universe (set): Set of elements to be covered. subsets (dict): Dictionary of subsets where keys are identifiers and values are sets of elements. costs (dict): Dictionary where keys are subset identifiers and values are the cost of each subset. Returns: list: List of subset identifiers that minimally cover the universe. # Remaining elements to be covered remaining_elements = set(universe) # Selected subsets selected_subsets = [] while remaining_elements: # Select the subset with the best cost-effectiveness ratio best_subset = None best_cost_effectiveness = float(\'inf\') for subset_id, elements in subsets.items(): # Calculate the cost-effectiveness ratio covered_elements = remaining_elements & elements if covered_elements: cost_effectiveness = costs[subset_id] / len(covered_elements) if cost_effectiveness < best_cost_effectiveness: best_cost_effectiveness = cost_effectiveness best_subset = subset_id if best_subset is None: # No subset can cover any remaining elements return [] # Update the remaining elements and add the selected subset remaining_elements -= subsets[best_subset] selected_subsets.append(best_subset) return selected_subsets"},{"question":"# Scenario You are working as a software engineer in a company building a DNA sequence analysis tool. One of the components you need to implement is to determine how similar two DNA strands are by finding the minimum number of operations (insertions, deletions, and substitutions) required to transform one strand into another. # Task Write a function `edit_distance_dna` that computes the edit distance between two DNA sequences. The DNA sequences consist of characters \'A\', \'C\', \'G\', and \'T\'. # Function Signature ```python def edit_distance_dna(sequence_a: str, sequence_b: str) -> int: ``` # Input * `sequence_a` (str): First DNA sequence. * `sequence_b` (str): Second DNA sequence. # Output * `int`: The minimum number of operations required to transform `sequence_a` into `sequence_b`. # Example ```python assert edit_distance_dna(\\"GATTACA\\", \\"GCATGCU\\") == 4 assert edit_distance_dna(\\"\\", \\"GATTACA\\") == 7 ``` # Constraints * 0 <= len(sequence_a), len(sequence_b) <= 2000 # Notes * Your function should handle cases where one or both strings are empty efficiently. * Optimizing space complexity is encouraged, although the primary goal is correctness.","solution":"def edit_distance_dna(sequence_a: str, sequence_b: str) -> int: len_a = len(sequence_a) len_b = len(sequence_b) # Create a DP table to memoize the distances dp = [[0] * (len_b + 1) for _ in range(len_a + 1)] # Base cases: transformation of a substring to an empty string for i in range(len_a + 1): dp[i][0] = i # All deletions for j in range(len_b + 1): dp[0][j] = j # All insertions # Fill the DP table for i in range(1, len_a + 1): for j in range(1, len_b + 1): if sequence_a[i - 1] == sequence_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no operation needed else: dp[i][j] = min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1] # Substitution ) + 1 return dp[len_a][len_b]"},{"question":"# Some students are organizing a library, but they need to sort the books by their titles. Your task is to implement a Bubble Sort function to sort an array of book titles. # Implementation Requirements: - Write a function `sort_book_titles(titles: List[str]) -> List[str]` that sorts an array of book titles in alphabetical order using the Bubble Sort algorithm. - Ensure your implementation handles edge cases efficiently, such as arrays that are already sorted or contain just one title. - Optimize your function to stop early if no swaps occur during a pass. # Constraints: - Input array size can be up to 10,000 titles. - The length of a book title does not exceed 100 characters. # Input: - A list of strings, `titles`, where each string represents a book title. # Output: - A list of strings sorted in alphabetical order. # Example: ```python titles = [\\"The Great Gatsby\\", \\"To Kill a Mockingbird\\", \\"1984\\", \\"Pride and Prejudice\\", \\"The Catcher in the Rye\\"] print(sort_book_titles(titles)) # Output: [\'1984\', \'Pride and Prejudice\', \'The Catcher in the Rye\', \'The Great Gatsby\', \'To Kill a Mockingbird\'] ``` Make sure your implementation is efficient and can handle the largest inputs within a reasonable time frame.","solution":"from typing import List def sort_book_titles(titles: List[str]) -> List[str]: Sorts a list of book titles in alphabetical order using the Bubble Sort algorithm. n = len(titles) if n < 2: # No need to sort if the list has less than 2 items return titles for i in range(n): swapped = False # Flag to detect any swap for j in range(0, n - i - 1): if titles[j] > titles[j + 1]: # Compare adjacent items titles[j], titles[j + 1] = titles[j + 1], titles[j] swapped = True if not swapped: # No swaps means the list is already sorted break return titles"},{"question":"# Comb Sort Implementation and Edge Case Handling **Context**: Comb Sort is a refined version of Bubble Sort that improves sorting performance by initially comparing far apart elements and subsequently reducing the gap between elements compared. It helps eliminate small values near the end of the array (turtles) early, thus speeding up the sorting process. # Task You are provided with the comb_sort algorithm. Implement the function `enhanced_comb_sort` which sorts an array using Comb Sort and additionally ensures the handling of common edge cases effectively: 1. **Function Signature**: You need to implement `def enhanced_comb_sort(arr: List[int]) -> List[int]:`. 2. **Input**: A list of integers `arr`. 3. **Output**: A list of integers sorted in non-decreasing order. 4. **Constraints**: - The length of the array `n` will be in the range of 0 to 10^6. - The elements of the array will be in the range of -10^9 to 10^9. # Performance Requirements - Expected to handle arrays of varying lengths efficiently. - Minimize unnecessary swaps and checks wherever possible. # Example ```python def enhanced_comb_sort(arr): # Implement your comb sort variant handling edge cases here. pass # Test cases print(enhanced_comb_sort([])) # Output: [] print(enhanced_comb_sort([1])) # Output: [1] print(enhanced_comb_sort([4, 2, 3, 1])) # Output: [1, 2, 3, 4] print(enhanced_comb_sort([3, -1, -2, -5, 0, 10])) # Output: [-5, -2, -1, 0, 3, 10] ``` # Considerations 1. Ensure that the algorithm\'s performance and correctness are maintained for all given edge cases. 2. Make sure the code handles large datasets within acceptable time limits for sorting. 3. Review how the algorithm can be fine-tuned or adjusted based on the input dataset to optimize performance without changing the core mechanism of Comb Sort.","solution":"def enhanced_comb_sort(arr): if len(arr) < 2: return arr n = len(arr) gap = n shrink = 1.3 sorted = False while not sorted: gap = int(gap / shrink) if gap <= 1: gap = 1 sorted = True for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr"},{"question":"You are given a `m x n` 2D grid initialized with the following values: * `-1`: A wall or an obstacle. * `0`: A gate. * `INF`: Infinity, representing an empty room. Use the value 2<sup>31</sup> - 1 = 2147483647 for infinity. Write a function that fills each empty room with the distance to the nearest gate. If it is impossible to reach a gate, it should remain filled with `INF`. # Input Format: * A 2D grid, `rooms` of size `m x n`, where `m` and `n` are positive integers (`1 <= m, n <= 100`), containing values: `-1`, `0`, or `INF`. # Output: The modified 2D grid where each empty room is filled with the distance to its nearest gate. # Constraints: * Every element of rooms\' 2D grid must be `-1`, `0`, or `INF`. * There will be at least one gate. # Performance Requirements: The algorithm should run within O(m * n) time complexity and O(m * n) space complexity due to recursion stack or queue. # Example: Input: ``` [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] ``` Output: ``` [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] ``` # Solution Template: ```python def walls_and_gates(rooms): # Implement your solution here pass # Helper function if needed def dfs(rooms, i, j, depth): pass # Example usage: rooms = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] walls_and_gates(rooms) print(rooms) # Expected output is the modified grid ```","solution":"from collections import deque def walls_and_gates(rooms): if not rooms: return m, n = len(rooms), len(rooms[0]) queue = deque() # Initialize the queue with all gates positions for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Directions array to move in 4 possible directions (left, right, up, down) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: i, j = queue.popleft() for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and rooms[ni][nj] == 2147483647: rooms[ni][nj] = rooms[i][j] + 1 queue.append((ni, nj)) # Example usage: rooms = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] walls_and_gates(rooms) print(rooms) # Expected output is the modified grid"},{"question":"Scenario To ensure a consistent display format for product license keys, a company needs to reformat given license key strings. Each license key comprises alphanumeric characters and hyphens. Hyphens need to be removed, and the string should be reformatted to include new hyphens after every `k` characters from right to left. For instance, a key `\\"5F3Z-2e-9-w\\"` with `k = 4` should be reformatted to `\\"5F3Z-2E9W\\"`. Write a function `reformat_license_key` that performs this reformatting based on the following specifications: Function Signature ```python def reformat_license_key(key: str, k: int) -> str: pass ``` Input Format - `key` (str): The original license key string consisting of alphanumeric characters and hyphens. - `k` (int): An integer defining the interval at which hyphens should be inserted from right to left. Output Format - Returns a formatted string according to the described rules. Constraints - The input string `key` will have a length in the range [1, 100,000]. - `k` will be a positive integer less than or equal to the number of alphanumeric characters in `key`. Examples 1. Input: `key = \\"5F3Z-2e-9-w\\"`, `k = 4` Output: `\\"5F3Z-2E9W\\"` 2. Input: `key = \\"2-5g-3-J\\"`, `k = 2` Output: `\\"2-5G-3J\\"` 3. Input: `key = \\"a-bC-dEf-ghIj\\"`, `k = 3` Output: `\\"A-BCD-EFG-HIJ\\"` Additional Notes - Ensure the output string has all uppercase characters. - Consider edge cases such as very short or very long input strings, and strings with multiple hyphens.","solution":"def reformat_license_key(key: str, k: int) -> str: # Remove existing hyphens and convert to uppercase cleaned = key.replace(\'-\', \'\').upper() # The result list to hold the parts of the new key result = [] # Starting from the end of the cleaned string, take k characters at a time for i in range(len(cleaned), 0, -k): result.append(cleaned[max(0, i-k):i]) # Join the result with hyphens in between formatted_key = \'-\'.join(reversed(result)) return formatted_key"},{"question":"# Connecting Islands You are tasked with writing functions that utilize different graph traversal methods to determine if there is a path between two islands in an archipelago. The archipelago is represented by an undirected graph where each node corresponds to an island and each edge to a direct connection (boat route) between two islands. # Function Specifications 1. **dfs_path_exists(graph: Dict[int, List[int]], start: int, target: int) -> bool** 2. **bfs_path_exists(graph: Dict[int, List[int]], start: int, target: int) -> bool** # Inputs - `graph`: Dictionary of integers to list of integers representing an undirected graph. - `start`: Integer representing the starting island. - `target`: Integer representing the target island. # Outputs - `bool`: Return `True` if a path exists from `start` to `target`, otherwise `False`. # Constraints - The graph will have at most 10,000 nodes. - The graph can be disconnected. - Ensure that your solution is optimal in terms of both time and space complexities. # Examples ```python graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2], 5: [] } # Returns True, there is a path 1 -> 2 -> 4 print(dfs_path_exists(graph, 1, 4)) # Returns False, no path from 1 to 5 print(bfs_path_exists(graph, 1, 5)) ``` # Notes - Use depth-first search and breadth-first search to solve the problem. - Make sure to handle graphs with cycles and disconnected parts appropriately. - Provide error handling for cases where the start or target nodes are not present in the graph.","solution":"def dfs_path_exists(graph, start, target): Determine if there is a path from start to target using DFS. if start not in graph or target not in graph: return False visited = set() def dfs(node): if node in visited: return False visited.add(node) if node == target: return True for neighbor in graph[node]: if dfs(neighbor): return True return False return dfs(start) def bfs_path_exists(graph, start, target): Determine if there is a path from start to target using BFS. if start not in graph or target not in graph: return False visited = set() queue = [start] while queue: current = queue.pop(0) if current == target: return True if current not in visited: visited.add(current) queue.extend(neighbor for neighbor in graph[current] if neighbor not in visited) return False"},{"question":"# Segment Tree Assessment Question Context You are given an array, and you need to support two types of operations efficiently: range queries and updates using a commutative function. A segment tree provides a powerful way to perform these operations in logarithmic time. Task Implement a segment tree that supports the following operations: * `query(l, r)`: Returns the result of the commutative function applied over the range `[l, r]`. * `update(index, value)`: Updates the element at `index` to `value` and reflects this change efficiently in the segment tree. # Specifications 1. **Class Definition**: - Class Name: `SegmentTree` - Constructor: `__init__(self, arr, function)` - `arr`: List of initial elements. - `function`: A commutative function that defines how segment results are merged. - Methods: - `build_tree(self)`: Builds the segment tree from the initial array. - `update(self, p, v)`: Updates the element at index `p` to value `v`. - `query(self, l, r)`: Returns the result over the range `[l, r]`. 2. **Input Constraints**: - The array `arr` will contain between 1 and 100,000 elements. - Each element can be any integer within the range (-10^9) to (10^9). - Queries and updates will be performed within valid indexes. 3. **Performance**: - The operations `query` and `update` must have logarithmic time complexity, O(log N). - The initialization should be linear in time complexity, O(N). Example ```python # Example function usage: # Maximum function mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 # Sum function mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 # Tuple summation mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Output: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Output: (4, 10) ``` Submission Submit your implementation of the Segment Tree class with the specified methods and ensure it passes the provided examples.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.function = function self.tree = [None] * (2 * self.n) self.build_tree(arr) def build_tree(self, arr): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, v): # Set value at position p p += self.n self.tree[p] = v # Move up and update parents i = p while i > 1: i //= 2 self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, l, r): # Initialize result res = None # Convert indices to leaf representation l += self.n r += self.n while l <= r: if l % 2 == 1: res = self.tree[l] if res is None else self.function(res, self.tree[l]) l += 1 if r % 2 == 0: res = self.tree[r] if res is None else self.function(res, self.tree[r]) r -= 1 l //= 2 r //= 2 return res"},{"question":"# RSA Key Generation and Utilization You are tasked with implementing parts of the RSA encryption algorithm. The main focus will be on understanding and enhancing the key generation mechanism and then utilizing these keys for encryption and decryption. Steps: 1. Implement a function `generate_key(bits: int) -> (int, int, int)`: * This function should generate a modulus `n` of the requested size in bits, an encryption exponent `e`, and a decryption exponent `d`. * Ensure `n = p * q`, where `p` and `q` are prime numbers, and `e` is a prime distinct from `(p-1)*(q-1)`. 2. Implement an `encrypt(data: str, e: int, n: int) -> list[int]` function: * Convert the data string to a list of integers corresponding to their ASCII values and then encrypt each integer using the RSA encryption formula. 3. Implement a `decrypt(data: list[int], d: int, n: int) -> str` function: * Decrypt each integer in the list using the RSA decryption formula and convert back to the string format. Input/Output Formats: * `generate_key(bits: int) -> (int, int, int)`: Accepts an integer specifying the size of the modulus `n` and returns a tuple `(n, e, d)`. * `encrypt(data: str, e: int, n: int) -> list[int]`: Accepts a string and RSA public key `(e, n)` and returns a list of encrypted integers. * `decrypt(data: list[int], d: int, n: int) -> str`: Accepts a list of encrypted integers and RSA private key `(d, n)` and returns the decrypted string. # Constraints: * `bits` for `generate_key` should be at least 16 for simplicity in this task demonstration. * Ensure inputs to `encrypt` and `decrypt` functions are properly validated. # Example: ```python # Example usage: n, e, d = generate_key(16) print(f\\"Generated keys: Public (n={n}, e={e}), Private (d={d})\\") message = \\"Hello\\" # Encryption encrypted_message = encrypt(message, e, n) print(f\\"Encrypted: {encrypted_message}\\") # Decryption decrypted_message = decrypt(encrypted_message, d, n) print(f\\"Decrypted: {decrypted_message}\\") # Validate correctness assert decrypted_message == message ``` Implement these functions correctly to ensure secure data encryption and decryption using the RSA method.","solution":"import random from sympy import isprime, mod_inverse def generate_key(bits: int) -> (int, int, int): Generates an RSA key pair. Args: - bits (int): The size of the modulus in bits. Returns: - tuple: (n, e, d), the modulus, encryption exponent, and decryption exponent. def generate_prime(bits): while True: p = random.getrandbits(bits) if isprime(p): return p half_bits = bits // 2 p = generate_prime(half_bits) q = generate_prime(half_bits) n = p * q phi = (p - 1) * (q - 1) e = 65537 # A common choice for e d = mod_inverse(e, phi) return n, e, d def encrypt(data: str, e: int, n: int) -> list[int]: Encrypts the data using RSA encryption. Args: - data (str): The plaintext message. - e (int): The encryption exponent. - n (int): The modulus. Returns: - list[int]: The encrypted integers. return [pow(ord(char), e, n) for char in data] def decrypt(data: list[int], d: int, n: int) -> str: Decrypts the data using RSA decryption. Args: - data (list[int]): The encrypted integers. - d (int): The decryption exponent. - n (int): The modulus. Returns: - str: The decrypted message. return \'\'.join(chr(pow(char, d, n)) for char in data)"},{"question":"# Segment Tree Use Case: Maximum Temperature Query System You are tasked with creating a temperature monitoring system that records the maximum temperatures for different days over a month. Using a **Segment Tree**, you will implement an efficient system to handle the following operations: 1. **Update** the temperature of a specific day. 2. **Query** the maximum temperature in a given range of days. # Your Task: Implement a `TempSegmentTree` class with the following methods: 1. **Initialization**: ```python def __init__(self, temperatures: List[int]): # Initializes the segment tree with the provided list of temperatures. ``` 2. **Update**: ```python def update(self, day: int, temperature: int): # Updates the temperature of a specific day. ``` 3. **Query**: ```python def query(self, start_day: int, end_day: int) -> int: # Returns the maximum temperature recorded between start_day and end_day (inclusive). ``` # Input: - The initial list of temperatures. - Queries and updates in the format described below. # Output: - For each query, return the maximum temperature in the given range. # Example: ```python # Initial temperatures are provided temp_tree = TempSegmentTree([15, 20, 25, 30, 35, 40]) # Query the maximum temperature from day 1 to day 3 print(temp_tree.query(1, 3)) # Output: 30 # Update the temperature of day 2 to 22 temp_tree.update(2, 22) # Query the maximum temperature from day 1 to day 3 again print(temp_tree.query(1, 3)) # Output: 30 # Query the maximum temperature from day 0 to day 5 print(temp_tree.query(0, 5)) # Output: 40 ``` # Constraints: - Ensure your solution handles at least up to 10^5 days efficiently. - The range for queries and updates will always be valid and within [0, N-1] where N is the number of days. # Notes: - The temperature is represented as an integer. - Use `max` as the function for the segment tree to find the maximum temperature in a given range.","solution":"class TempSegmentTree: def __init__(self, temperatures): self.n = len(temperatures) self.tree = [0] * (2 * self.n) # Build the tree self.build(temperatures) def build(self, temperatures): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = temperatures[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, day, temperature): # Update leaf node pos = day + self.n self.tree[pos] = temperature # Update internal nodes while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, start_day, end_day): # Initialize our pointers l = start_day + self.n r = end_day + self.n + 1 max_temp = float(\'-inf\') # Traverse and find maximum in the range while l < r: if l % 2: max_temp = max(max_temp, self.tree[l]) l += 1 if r % 2: r -= 1 max_temp = max(max_temp, self.tree[r]) l //= 2 r //= 2 return max_temp"},{"question":"# Task You have been asked to implement a modified version of the `ArrayQueue` that inherently uses a circular buffer to avoid resizing delays. Your goal is to complete the given methods by optimizing the `enqueue`, `dequeue`, and `peek` methods to work with a circular buffer while maintaining constant time complexity for these operations. # Requirements: Function Signatures: ```python class CircularQueue: def __init__(self, capacity=10): Initialize queue with given capacity (default is 10). Initialize appropriate counters, front, and rear pointers. pass def enqueue(self, value): Add an element to the rear of the queue. Raises OverflowError if the queue is full. pass def dequeue(self): Remove and return an element from the front of the queue. Raises IndexError if the queue is empty. pass def peek(self): Return the front element of the queue without removing it. Raises IndexError if the queue is empty. pass def is_empty(self): Return True if the queue is empty, otherwise False. pass def is_full(self): Return True if the queue is full, otherwise False. pass def size(self): Return the number of elements in the queue. pass ``` Constraints: * The circular buffer\'s size is fixed at initialization and will not expand. * Your methods should run in O(1) time complexity. * Use Python lists to implement the circular buffer.","solution":"class CircularQueue: def __init__(self, capacity=10): Initialize queue with given capacity (default is 10). Initialize appropriate counters, front, and rear pointers. self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.count = 0 def enqueue(self, value): Add an element to the rear of the queue. Raises OverflowError if the queue is full. if self.is_full(): raise OverflowError(\\"Queue is full\\") self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.count += 1 def dequeue(self): Remove and return an element from the front of the queue. Raises IndexError if the queue is empty. if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.count -= 1 return value def peek(self): Return the front element of the queue without removing it. Raises IndexError if the queue is empty. if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self): Return True if the queue is empty, otherwise False. return self.count == 0 def is_full(self): Return True if the queue is full, otherwise False. return self.count == self.capacity def size(self): Return the number of elements in the queue. return self.count"},{"question":"# Coding Assessment: Interpolation Search Enhancement You are given a sorted array `array` of integer numbers and a search key `search_key`. Interpolation search works efficiently on uniformly distributed arrays. Your task is to enhance the `interpolation_search` function to handle arrays that may not be uniformly distributed, ensuring accuracy and efficiency. Functional Requirements 1. Implement an optimized version of the `interpolation_search` function: - It should return the index of the `search_key` if found within the array. - It should return `-1` if the `search_key` is not found. 2. Your implementation should prioritize efficient handling of non-uniform data while maintaining the benefits of the original interpolation search. 3. Improve the function\'s robustness by handling potential error scenarios such as division by zero. Input and Output Formats * **Input**: * `array (List[int])`: A sorted list of integers. * `search_key (int)`: An integer representing the value to search within the array. * **Output**: * `int`: The index of the `search_key` in the array if found, otherwise `-1`. Constraints * The array size will not exceed (10^6) elements. * The integer values in the array are in the range of ([-10^9, 10^9]). Example ```python assert enhanced_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) == -1 ``` Performance Requirements You should aim for a time complexity of (O(log(log n))) on average and handle performance gracefully for worst-case scenarios. Ensure that the space complexity remains (O(1)).","solution":"def enhanced_interpolation_search(array, search_key): Perform an enhanced interpolation search on an array that may not be uniformly distributed. :param array: List[int], a sorted array of integers :param search_key: int, the value to search within the array :return: int, the index of the search_key in the array if found, otherwise -1 low, high = 0, len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Calculate the probe position using the interpolation formula if array[high] == array[low]: mid = low else: mid = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) # Check if the calculated mid index is within the bounds of the array if mid < low or mid > high: return -1 if array[mid] == search_key: return mid elif array[mid] < search_key: low = mid + 1 else: high = mid - 1 return -1"},{"question":"# Scenario You are working on a project to develop a robust file indexing system. For this, you need an optimized data structure for managing large sets of keys efficiently with frequent insertions and deletions. A B-Tree is chosen for this purpose due to its balanced structure, which supports quick lookups, insertions, and deletions. # Task Implement a B-Tree with the following operations: 1. `insert_key(key)`: Insert a key into the tree. 2. `find(key)`: Check if the key is present in the tree. 3. `remove_key(key)`: Remove a key from the tree. 4. `traverse_tree()`: In-order traversal of the tree. # Implementation Instructions Implement the above B-Tree operations in Python, ensuring that the tree remains balanced after each insert and delete operation. # Input Format * `insert_key(key)`: Key is an integer. * `find(key)`: Key is an integer. * `remove_key(key)`: Key is an integer. # Output Format * `find(key)`: Return `True` if the key is found, `False` otherwise. * `traverse_tree()`: Print the in-order traversal of the tree\'s keys in a single line, separated by spaces. # Constraints * Use a minimum degree `t` of 2. # Example Input: ```python btree = BTree(t_val=2) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) print(btree.find(10)) # Expected Output: True print(btree.find(15)) # Expected Output: False btree.remove_key(10) btree.traverse_tree() # Expected Output: 5 20 ```","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, else False self.keys = [] # List to store keys self.children = [] # List to store child pointers class BTree: def __init__(self, t_val): self.t = t_val # Minimum degree self.root = BTreeNode(t_val, True) # Root node def traverse_tree(self): self._traverse_tree(self.root) print() def _traverse_tree(self, node): i = 0 # Traverse the keys and children for i in range(len(node.keys)): if not node.leaf: self._traverse_tree(node.children[i]) print(node.keys[i], end=\\" \\") # Last child if not node.leaf: self._traverse_tree(node.children[i + 1]) def find(self, key): return self._find(self.root, key) def _find(self, node, key): i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and node.keys[i] == key: return True if node.leaf: return False return self._find(node.children[i], key) def insert_key(self, key): root = self.root if len(root.keys) == 2 * self.t - 1: temp = BTreeNode(self.t, False) self.root = temp temp.children.append(root) self._split_child(temp, 0) self._insert_non_full(temp, key) else: self._insert_non_full(root, key) def _split_child(self, parent, i): t = self.t y = parent.children[i] z = BTreeNode(y.t, y.leaf) parent.children.insert(i + 1, z) parent.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t - 1)] y.keys = y.keys[0:(t - 1)] if not y.leaf: z.children = y.children[t:(2 * t)] y.children = y.children[0:t] def _insert_non_full(self, node, key): i = len(node.keys) - 1 if node.leaf: node.keys.append(0) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == 2 * self.t - 1: self._split_child(node, i) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def remove_key(self, key): self._remove_key(self.root, key) if len(self.root.keys) == 0: if not self.root.leaf: self.root = self.root.children[0] else: self.root = BTreeNode(self.t, True) def _remove_key(self, node, key): t = self.t i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and node.keys[i] == key: if node.leaf: node.keys.pop(i) else: self._remove_internal_node(node, key, i) elif not node.leaf: if len(node.children[i].keys) < t: self._fill(node, i) if i < len(node.keys) and key == node.keys[i]: return self._remove_key(node.children[i + 1], key) else: return self._remove_key(node.children[i], key) def _remove_internal_node(self, node, key, idx): t = self.t if len(node.children[idx].keys) >= t: pred_key = self._get_pred(node, idx) node.keys[idx] = pred_key self._remove_key(node.children[idx], pred_key) elif len(node.children[idx + 1].keys) >= t: succ_key = self._get_succ(node, idx) node.keys[idx] = succ_key self._remove_key(node.children[idx + 1], succ_key) else: self._merge(node, idx) self._remove_key(node.children[idx], key) def _get_pred(self, node, idx): cur = node.children[idx] while not cur.leaf: cur = cur.children[-1] return cur.keys[-1] def _get_succ(self, node, idx): cur = node.children[idx + 1] while not cur.leaf: cur = cur.children[0] return cur.keys[0] def _fill(self, node, idx): if idx != 0 and len(node.children[idx - 1].keys) >= self.t: self._borrow_from_prev(node, idx) elif idx != len(node.children) - 1 and len(node.children[idx + 1].keys) >= self.t: self._borrow_from_next(node, idx) else: if idx != len(node.children) - 1: self._merge(node, idx) else: self._merge(node, idx - 1) def _borrow_from_prev(self, node, idx): child = node.children[idx] sibling = node.children[idx - 1] child.keys.insert(0, node.keys[idx - 1]) if not child.leaf: child.children.insert(0, sibling.children.pop()) node.keys[idx - 1] = sibling.keys.pop() def _borrow_from_next(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) if not child.leaf: child.children.append(sibling.children.pop(0)) node.keys[idx] = sibling.keys.pop(0) def _merge(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) node.keys.pop(idx) node.children.pop(idx + 1)"},{"question":"# Primality Test Challenge Context: You are developing a cryptographic library that requires efficient and accurate primality testing. To ensure the robustness of your library, you will implement the Rabin-Miller Primality Test. This algorithm will help determine the primality of large numbers with high probability, essential for generating cryptographic keys. Task: Implement a function `is_prime(n, k)` that checks whether a number ( n ) is prime with a given confidence level, determined by ( k ) iterations. Function Signature: ```python def is_prime(n: int, k: int) -> bool: ``` Input: * ( n ) (int): The number to test for primality ( ( n geq 5 ) ). * ( k ) (int): The number of iterations for the Rabin-Miller test ( ( k geq 1 ) ). Output: * Returns `True` if ( n ) is probably prime. * Returns `False` if ( n ) is definitely not prime. Constraints: * Handle inputs with number size up to ( 10^{18} ). * Ensure ( n geq 5 ) and ( k geq 1 ). * Minimize the time complexity to perform well even for the upper limits of ( n ). Example: ```python assert is_prime(31, 5) == True assert is_prime(15, 5) == False assert is_prime(101, 1) == True assert is_prime(18, 4) == False ``` Notes: 1. Use efficient random number generation within the valid range. 2. Ensure correct handling of the modular exponentiation for large numbers. 3. Employ robust error handling to deal with any unexpected inputs or conditions.","solution":"import random def is_prime(n: int, k: int) -> bool: Returns True if n is probably prime with k iterations of the Rabin-Miller test. Returns False if n is definitely not prime. # Handle edge cases if n in (2, 3): return True if n % 2 == 0 or n < 2: return False # Write n as d * 2^r + 1 with d odd def decompose(n): r = 0 d = n - 1 while d % 2 == 0: d //= 2 r += 1 return r, d def is_composite(a, d, n, r): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True r, d = decompose(n) for _ in range(k): a = random.randint(2, n - 2) if is_composite(a, d, n, r): return False return True"},{"question":"You are given the task of implementing a dynamic data structure called `SegmentTree` which efficiently handles point updates and range queries on an array. You need to implement three methods: `__init__()`, `update()`, and `query()`. # Function Descriptions 1. **`__init__(self, arr, function)`**: * Initialize the segment tree using the provided array `arr` and a function `function`. * `function` should be a commutative function that takes two elements and returns a combined result of the same type. 2. **`update(self, p, v)`**: * Update the value at index `p` to `v` in the segment tree and adjust the tree accordingly. 3. **`query(self, l, r)`**: * Return the combined result using the function for the range `[l, r]` (both inclusive). # Input Format - `__init__(arr, function)`: - `arr`: a list of elements. - `function`: a function used to combine elements (e.g., `max`, `min`, `sum`). - `update(p, v)`: - `p`: index to update (0-based). - `v`: new value. - `query(l, r)`: - `l`: left boundary for the query (0-based). - `r`: right boundary for the query (0-based). # Output Format - `query(l, r)` should return a combined result from the function for the specified range. # Example ```python # Intuition: Segment Tree initialized to find maximum element in subarrays. arr = [2, 4, 5, 3, 4] mytree = SegmentTree(arr, max) assert mytree.query(2, 4) == 5 mytree.update(3, 6) assert mytree.query(0, 3) == 6 # Another example with sum function arr = [4, 5, 2, 3, 4, 43, 3] mytree = SegmentTree(arr, lambda a, b: a + b) assert mytree.query(0, 6) == 64 mytree.update(2, -10) assert mytree.query(0, 6) == 52 # Example with tuples arr = [(1, 2), (4, 6), (4, 5)] mytree = SegmentTree(arr, lambda a, b: (a[0] + b[0], a[1] + b[1])) assert mytree.query(0, 2) == (9, 13) mytree.update(2, (-1, 2)) assert mytree.query(0, 2) == (4, 10) ``` # Constraints * The array length `n` will be in the range `[1, 10000]`. * Function `function` will always be commutative. * Update operations will not exceed `10000`. * Query operations will not exceed `10000`. Implement the `SegmentTree` class based on the given specifications.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.tree = [None] * (2 * self.n) self.function = function # Build the tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, v): # Set value at position p p += self.n self.tree[p] = v while p > 1: p //= 2 self.tree[p] = self.function(self.tree[2 * p], self.tree[2 * p + 1]) def query(self, l, r): l += self.n r += self.n res = None while l <= r: if l % 2 == 1: res = self.tree[l] if res is None else self.function(res, self.tree[l]) l += 1 if r % 2 == 0: res = self.tree[r] if res is None else self.function(res, self.tree[r]) r -= 1 l //= 2 r //= 2 return res"},{"question":"# Question You are given an encoded message containing digits from \'0\' to \'9\'. Each digit or group of two digits can represent a letter according to the mapping \'A\' -> 1, \'B\' -> 2, ..., \'Z\' -> 26. Write a function `count_decoding_ways(enc_mes)` that determines the total number of ways to decode the given message. Function Signature ```python def count_decoding_ways(enc_mes: str) -> int: ``` Input * `enc_mes` (string): A string containing digits from \'0\' to \'9\'. The length of the string is between 1 and 50. Output * Return an integer representing the total number of ways to decode the message. Constraints * The input string can contain characters \'0\' to \'9\'. * The message is guaranteed to be of length from 1 to 50. Example ```python # Example 1 enc_mes = \\"12\\" assert count_decoding_ways(enc_mes) == 2 # Example 2 enc_mes = \\"226\\" assert count_decoding_ways(enc_mes) == 3 # Example 3 enc_mes = \\"0\\" assert count_decoding_ways(enc_mes) == 0 # Example 4 enc_mes = \\"06\\" assert count_decoding_ways(enc_mes) == 0 ``` Explanation 1. For `enc_mes = \\"12\\"`, it can be decoded as \\"AB\\" (1 2) or \\"L\\" (12). 2. For `enc_mes = \\"226\\"`, it can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). 3. For `enc_mes = \\"0\\"`, there are no valid decodings. 4. For `enc_mes = \\"06\\"`, there are no valid decodings because \\"06\\" is not a valid encoding combination. **Note**: Ensure that your function handles edge cases such as message strings starting with \'0\' and consecutive invalid two-digit combinations. Performance should be considered for the length constraint.","solution":"def count_decoding_ways(enc_mes: str) -> int: Determines the total number of ways to decode the given message encoded as digits. Args: enc_mes (str): Encoded message containing digits from \'0\' to \'9\'. Returns: int: The total number of ways to decode the message. if not enc_mes or enc_mes[0] == \'0\': return 0 n = len(enc_mes) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 # There is one way to decode a non-zero single digit for i in range(2, n + 1): one_digit = int(enc_mes[i-1:i]) two_digits = int(enc_mes[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"Longest Binary Gap Problem Statement: Given a positive integer N, write a function to find and return the longest distance between two consecutive 1\'s in the binary representation of N. If there are not two consecutive 1\'s, the function should return 0. Input: - A single integer N (1 <= N <= 10^9). Output: - Return an integer representing the maximum distance between two consecutive 1\'s in the binary representation of N. Examples: 1. Input: `22` - Output: `2` - Explanation: `22` in binary is `10110`. The gaps between consecutive 1\'s are 2 (between the first and second 1) and 1 (between the second and third 1). The maximum gap is therefore 2. 2. Input: `5` - Output: `2` - Explanation: `5` in binary is `101`. The maximum gap between the two 1\'s is 2. 3. Input: `6` - Output: `1` - Explanation: `6` in binary is `110`. The maximum gap between the two 1\'s is 1. 4. Input: `8` - Output: `0` - Explanation: `8` in binary is `1000`. There are no consecutive 1\'s in the binary representation. Edge Cases: - N is a power of 2 (like 8, 16), should return 0. - N is 1, should return 0 because it only has a single 1 bit. - Large N to test efficiency (like `10^9`). Constraints: - You are required to implement the algorithm with a time complexity of O(log N) and a space complexity of O(1). Function Signature: ```python def longest_binary_gap(N: int) -> int: # Your implementation here ```","solution":"def longest_binary_gap(N: int) -> int: Return the longest distance between two consecutive 1\'s in the binary representation of N. If there are not two consecutive 1\'s, return 0. binary_representation = bin(N)[2:] # Get binary representation of N and remove the \'0b\' prefix max_gap = 0 current_gap = 0 found_one = False for bit in binary_representation: if bit == \'1\': if found_one: max_gap = max(max_gap, current_gap) current_gap = 1 found_one = True elif bit == \'0\' and found_one: current_gap += 1 return max_gap"},{"question":"# Rotated String Check **Scenario**: You are working with a text processing system that involves circular data streams. A common task in this system is to determine if one segment of text is just a rotated version of another. This functionality is crucial for detecting cyclic patterns and ensuring correct data management. **Objective**: Implement a function that determines if one string is a rotated version of another. **Function Signature**: ```python def is_rotated(s1: str, s2: str) -> bool: pass ``` **Input**: - `s1` (str): A non-empty string consisting of lowercase English letters. - `s2` (str): Another string, potentially a rotated version of `s1`. **Output**: - Returns `True` if `s2` is a rotated version of `s1`, otherwise `False`. **Constraints**: - 1 <= len(s1), len(s2) <= 10^5 - Both `s1` and `s2` contain only lowercase English letters. **Example**: ```python assert is_rotated(\\"hello\\", \\"llohe\\") == True assert is_rotated(\\"hello\\", \\"helol\\") == False assert is_rotated(\\"aaa\\", \\"aaa\\") == True assert is_rotated(\\"waterbottle\\", \\"erbottlewat\\") == True assert is_rotated(\\"abcd\\", \\"dcba\\") == False ``` **Note**: - The solution should efficiently handle large strings within the given constraints. - Take into account edge cases such as empty strings and strings with repeating characters.","solution":"def is_rotated(s1: str, s2: str) -> bool: Determines if s2 is a rotated version of s1. if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"Problem You are given a sorted array of integers. You need to write a function `insert_in_sorted_array` that takes in a sorted array and a target value, and returns the array with the target value inserted at its appropriate position to maintain the sorted order. Function Signature ```python def insert_in_sorted_array(array: List[int], val: int) -> List[int]: pass ``` Input - `array`: A list of integers, sorted in non-decreasing order. - `val`: An integer value to be inserted. Output - A new list of integers with `val` inserted in its appropriate position. Constraints - The length of the array (n) will be in the range ([0, 10^5]). - The array elements and the target value (a_i) will be in the range ([-10^9, 10^9]). Example ```python # Example 1 array = [1, 3, 5, 6] val = 5 # Output: [1, 3, 5, 5, 6] # Example 2 array = [1, 3, 5, 6] val = 2 # Output: [1, 2, 3, 5, 6] # Example 3 array = [1, 3, 5, 6] val = 7 # Output: [1, 3, 5, 6, 7] # Example 4 array = [1, 3, 5, 6] val = 0 # Output: [0, 1, 3, 5, 6] # Example 5 array = [] val = 1 # Output: [1] ``` Notes - You are required to use a binary search technique to determine the correct insertion position for better efficiency. - Make sure to handle edge cases such as an empty array or insertion at the beginning/end of the array.","solution":"from typing import List def insert_in_sorted_array(array: List[int], val: int) -> List[int]: Inserts a value into a sorted array such that the array remains sorted. Uses binary search to find the appropriate insertion index. if not array: return [val] # Binary search to find the correct insertion point left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] < val: left = mid + 1 else: right = mid # Insert the value at the found position array.insert(left, val) return array"},{"question":"# Transitive Closure Using DFS Problem Statement You are provided with a directed graph and you need to compute its transitive closure using Depth-First Search (DFS) algorithm. The transitive closure of a graph is a reachability matrix where the entry at row `i` and column `j` is `1` if there is a path from vertex `i` to vertex `j`; otherwise, it is `0`. Task Implement a function `find_transitive_closure(graph: List[List[int]]) -> List[List[int]]` that computes the transitive closure of the given graph. Input Format * `graph`: A list of lists where each sublist contains two integers `[source, target]` representing a directed edge from `source` to `target`. * `vertices`: An integer representing the total number of vertices in the graph. Vertex indices are zero-based. Output Format * Return a 2D list (matrix) where `closure[i][j]` is `1` if there is a path from vertex `i` to vertex `j`; `0` otherwise. Constraints * `1 <= vertices <= 100` * `0 <= len(graph) <= vertices * (vertices - 1)` Example ```plaintext Input: vertices = 4 graph = [ [0, 1], [1, 2], [2, 3] ] Output: [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1] ] ``` Performance Requirements Your solution should have a time complexity not exceeding O(V*(V+E)) and space complexity of O(V^2), where V is the number of vertices and E is the number of edges.","solution":"def find_transitive_closure(vertices, graph): Compute the transitive closure of a directed graph using DFS. :param vertices: Total number of vertices in the graph. :param graph: A list of lists where each sublist contains two integers [source, target] representing a directed edge from source to target. :return: A 2D list (matrix) where closure[i][j] is 1 if there is a path from vertex i to vertex j; 0 otherwise. # Initialize the closure matrix with 0s closure = [[0 for _ in range(vertices)] for _ in range(vertices)] # Create adjacency list from the graph adj_list = [[] for _ in range(vertices)] for u, v in graph: adj_list[u].append(v) # Function to perform DFS and mark reachability def dfs(start, v): closure[start][v] = 1 for neighbor in adj_list[v]: if closure[start][neighbor] == 0: dfs(start, neighbor) # Perform DFS from each vertex for i in range(vertices): dfs(i, i) return closure"},{"question":"# Question You are tasked with creating an encoding and decoding system for a list of strings. This system should allow you to encode the list into a single string for efficient storage and transmission and decode it back into the original list of strings. Write two functions `encode` and `decode`: - `encode(strs: List[str]) -> str`: This method will take a list of strings, encode it into a single string, and return the encoded string. - `decode(s: str) -> List[str]`: This method will take an encoded string, decode it back into the list of strings, and return that list. Input - `encode` method: - `strs`: List of strings, 0 <= len(strs) <= 10^5, 0 <= len(strs[i]) <= 10^3 - `decode` method: - `s`: Encoded string Output - `encode` returns a single encoded string. - `decode` returns a list of strings. Constraints - Strings in `strs` can contain any characters, including \':\', but the encoding scheme must handle such cases correctly. - Ensure that your implementation is efficient both in terms of time and space complexities. Examples ```python # Example 1: strs = [\\"Hello\\", \\"World\\"] encoded_str = encode(strs) # encoded_str should be \\"5:Hello5:World\\" decoded_list = decode(encoded_str) # decoded_list should be [\\"Hello\\", \\"World\\"] # Example 2: strs = [\\"\\", \\"data\\", \\"structure\\"] encoded_str = encode(strs) # encoded_str should be \\"0:4:data9:structure\\" decoded_list = decode(encoded_str) # decoded_list should be [\\"\\", \\"data\\", \\"structure\\"] ``` # Additional Notes - Ensure your code handles edge cases, like empty strings or lists, properly. - Design your solution to be robust against strings containing numeric characters or delimiter characters.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. encoded_str = \'\' delimiter = \':\' for string in strs: encoded_str += str(len(string)) + delimiter + string return encoded_str def decode(s: str) -> List[str]: Decodes a single string back to a list of strings. decoded_list = [] i = 0 while i < len(s): delimiter_index = s.find(\':\', i) if delimiter_index == -1: break length = int(s[i:delimiter_index]) i = delimiter_index + 1 decoded_list.append(s[i:i + length]) i += length return decoded_list"},{"question":"# RSA Key Generation and Encryption You are required to implement RSA encryption and decryption using the principles outlined in the RSA algorithm. Your task is to write functions that: 1. **Generate the RSA keys**: Public key (e, n) and private key (d, n). 2. **Encrypt and Decrypt Data**: Using the generated keys, encrypt and decrypt given data. **Function Signature**: ```python def generate_key(k_bits: int) -> (int, int, int): pass def encrypt(data: int, e: int, n: int) -> int: pass def decrypt(encrypted_data: int, d: int, n: int) -> int: pass ``` # Constraints: - `1 <= k_bits <= 2048` (bit length for RSA key) - `0 <= data <= n-1` - Ensure (p) and (q) are distinct primes. # Example: ```python # Generate RSA keys n, e, d = generate_key(16) # Encrypt data data = 123 encrypted = encrypt(data, e, n) print(f\\"Encrypted: {encrypted}\\") # Decrypt data decrypted = decrypt(encrypted, d, n) print(f\\"Decrypted: {decrypted}\\") # Ensure decrypted data matches the original assert data == decrypted ``` # Notes: - **Testing Edge Cases**: - Confirm data boundaries: `0`, `n-1`, values around half of `n`. - Validate with random and specific `k_bits` values like 16, 256, 1024. - **Error Handling**: - Ensure functions robustly handle invalid inputs (negative data, invalid bit sizes). - Key generation should handle different primes and potential rejections for `gcd(e, phi(n))`. # Performance: - Your encryption and decryption functions should complete within acceptable time limits for key sizes up to 1024 bits.","solution":"import random from sympy import isprime, mod_inverse def generate_prime(bits): while True: num = random.getrandbits(bits) if isprime(num): return num def generate_key(k_bits: int) -> (int, int, int): Generate RSA public and private keys. Args: - k_bits (int): Number of bits for the primes p and q used to compute n. Returns: - Tuple (n, e, d): Public key (e, n) and private key (d, n) e = 65537 # Commonly used prime exponent for RSA. # Generate two distinct prime numbers p and q p = generate_prime(k_bits // 2) q = generate_prime(k_bits // 2) while p == q: q = generate_prime(k_bits // 2) n = p * q phi_n = (p - 1) * (q - 1) # Ensure e and phi_n are coprime while gcd(e, phi_n) != 1: e += 2 # Adjust e to ensure it is coprime with phi_n, normally this is not needed with 65537 d = mod_inverse(e, phi_n) return n, e, d def gcd(a, b): while b != 0: a, b = b, a % b return a def encrypt(data: int, e: int, n: int) -> int: Encrypt data using RSA encryption. Args: - data (int): The data to be encrypted, must be in the range [0, n-1]. - e (int): The public exponent. - n (int): The modulus. Returns: - int: The encrypted data. return pow(data, e, n) def decrypt(encrypted_data: int, d: int, n: int) -> int: Decrypt data using RSA encryption. Args: - encrypted_data (int): The encrypted data to be decrypted. - d (int): The private exponent. - n (int): The modulus. Returns: - int: The decrypted data. return pow(encrypted_data, d, n)"},{"question":"# Problem: Incrementing a Number Represented as an Array of Digits You are given an array of non-negative integers representing a non-negative number. The digits are ordered such that the most significant digit is at the head of the list. Write a function `increment_number_by_one` that increments the number by one and returns the resulting array of digits. Expected Input and Output Formats: - **Input**: A list of integers `digits` where each element of the list is a digit (0-9). - **Output**: A list of integers representing the incremented number. Constraints: - Do not use other built-in functions that directly handle large numbers (like converting the array to an integer and then back to a list). - The input list is non-empty. - The input list represents a valid non-negative number. Example: ```python def increment_number_by_one(digits: List[int]) -> List[int]: # your code here # Example 1: assert increment_number_by_one([1, 2, 3]) == [1, 2, 4] # Example 2: assert increment_number_by_one([9,9,9]) == [1, 0, 0, 0] # Example 3: assert increment_number_by_one([0]) == [1] ``` Performance Requirements: - The time complexity should be O(n), where n is the number of digits. - The space complexity should be O(1) for in-place modifications, or O(n) if additional space is required.","solution":"def increment_number_by_one(digits): Increment the number represented by the array of digits by one. Args: digits (list of int): List of non-negative integers representing the number. Returns: list of int: New list of integers representing the incremented number. n = len(digits) # Start from the last digit and move to the front for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits # If the digit is 9, set it to 0 digits[i] = 0 # If all digits are 9, we need to add a new digit return [1] + digits"},{"question":"# Combination Sum with Non-negative Integers Given a list of unique positive integers `nums` and a target integer `target`, write a function to compute the number of possible combinations that add up to the target. Each number in `nums` can be used multiple times. Implement both a top-down approach using memoization and a bottom-up dynamic programming approach. Function Signature ```python def combination_sum_topdown(nums: List[int], target: int) -> int: pass def combination_sum_bottom_up(nums: List[int], target: int) -> int: pass ``` Input * `nums`: A list of unique positive integers (1 <= len(nums) <= 200, 1 <= nums[i] <= 1000) * `target`: A positive integer (1 <= target <= 1000) Output * Returns an integer representing the number of possible combinations that add up to the target. Example ```python nums = [1, 2, 3] target = 4 # For combination_sum_topdown: combination_sum_topdown(nums, target) -> 7 # For combination_sum_bottom_up: combination_sum_bottom_up(nums, target) -> 7 ``` Note the difference in sequence order differs from counting unique sets. For example, (1, 2, 1) and (1, 1, 2) are counted separately. Constraints * Ensure that your solution handles potentially large values efficiently using dynamic programming methods. * Negative numbers are not allowed in this problem set.","solution":"from typing import List def combination_sum_topdown(nums: List[int], target: int) -> int: memo = {} def dp(t): if t in memo: return memo[t] if t == 0: return 1 if t < 0: return 0 count = 0 for num in nums: count += dp(t - num) memo[t] = count return count return dp(target) def combination_sum_bottom_up(nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for t in range(1, target + 1): for num in nums: if t - num >= 0: dp[t] += dp[t - num] return dp[target]"},{"question":"# Absolute Path Calculator You are tasked with creating a function `resolve_full_path(file_path)` which converts a given relative file path to its absolute path. Your function should handle user-specific shortcuts, such as `~` for home directories, and provide a normalized, absolute path output. Function Signature ```python def resolve_full_path(file_path: str) -> str: pass ``` Input * A single string representing a file path, `file_path`. Output * A single string representing the absolute path resolved from the input. Examples ```python assert resolve_full_path(\\"~/Documents/file.txt\\") == \\"/home/username/Documents/file.txt\\" assert resolve_full_path(\\"./file.txt\\") == \\"/home/username/current_directory/file.txt\\" assert resolve_full_path(\\"/etc/config\\") == \\"/etc/config\\" ``` Constraints 1. Your solution should work for typical file paths in Unix-like operating systems. 2. Assume an environment where `os.path.expanduser` and `os.path.abspath` functionalities are accurate and reliable.","solution":"import os def resolve_full_path(file_path: str) -> str: Resolves a given file path to its absolute path, handling user-specific shortcuts like `~`. return os.path.abspath(os.path.expanduser(file_path))"},{"question":"**Scenario**: You are tasked with implementing a modified insertion sort algorithm for a performance-critical application. The classic insertion sort algorithm works efficiently for small arrays or nearly sorted arrays, but it can be slow on larger datasets due to its O(n^2) time complexity. One way to improve insertion sort is by using binary search to find the correct insertion position, leveraging its O(log n) search time. Your task is to implement a binary insertion sort algorithm that uses the provided `search_insert` function to find the proper insertion index for each element. # Function Signature ```python def binary_insertion_sort(array): Sort the input list \'array\' using the binary insertion sort technique. Args: array (list): a list of integers that needs to be sorted. Returns: list: a new list with the elements sorted in non-decreasing order. ``` # Constraints * The input list can contain up to 10,000 integer elements. * The integers in the input list can be both positive and negative. # Input/Output Format * **Input**: An unsorted list of integers. * Example: `[4, 2, 0, -1, 3]` * **Output**: A new sorted list of integers. * Example: `[-1, 0, 2, 3, 4]` # Performance Requirements * The implementation should be efficient for the given constraints. * Utilize the `search_insert` function for determining the insertion index. # Example ```python # Example usage: input_array = [4, 2, 0, -1, 3] print(binary_insertion_sort(input_array)) # Output: [-1, 0, 2, 3, 4] ``` # Implementation Hints * Use the `search_insert` function provided to find the correct position for each element during the insertion process. * Consider how elements will be shifted to make room for the newly inserted element.","solution":"def search_insert(array, element, start, end): Perform a binary search to find the index at which \'element\' should be inserted into \'array\'. Args: array (list): The list where the search should be performed. element (int): The element for which to find the insertion index. start (int): The starting index of the sublist to be searched. end (int): The ending index of the sublist to be searched. Returns: int: The index at which \'element\' should be inserted. while start < end: mid = (start + end) // 2 if array[mid] < element: start = mid + 1 else: end = mid return start def binary_insertion_sort(array): Sort the input list \'array\' using the binary insertion sort technique. Args: array (list): a list of integers that needs to be sorted. Returns: list: a new list with the elements sorted in non-decreasing order. sorted_array = array[:] for i in range(1, len(sorted_array)): current_value = sorted_array[i] insertion_index = search_insert(sorted_array, current_value, 0, i) for j in range(i, insertion_index, -1): sorted_array[j] = sorted_array[j - 1] sorted_array[insertion_index] = current_value return sorted_array"},{"question":"**Context**: You are working with a system that processes multi-dimensional array data. Sometimes, the data arrays have arbitrarily deep nesting levels, and you need to simplify these structures to a one-dimensional array for further processing. **Objective**: Implement a function `flatten_array` that takes a nested array and returns a flattened array. Your implementation should consider edge cases such as empty nested arrays, and non-iterable elements. Additionally, implement an iterative version that efficiently handles memory by avoiding deep recursion. Function Signature: ```python def flatten_array(input_array: list) -> list: Flattens a multi-dimensional input array into a single-dimensional array. :param input_array: List of elements, potentially nested :return: Flattened list containing all elements of input in depth-first order pass ``` **Input Format**: - `input_array`: A list which may include nested lists, integers, floats, strings, or other types. **Output Format**: - A single-dimensional list with all elements of `input_array`. **Constraints**: - The elements of `input_array` are guaranteed to be iterables (including nested lists) and atomic elements (e.g., integers, strings). - You must handle nesting up to reasonable recursive or iterative limits as per typical constraints (`sys.getrecursionlimit`). **Example**: ```python assert flatten_array([1, [2, 3, [4, 5]], [6, 7]]) == [1, 2, 3, 4, 5, 6, 7] assert flatten_array([\\"a\\", [\\"b\\", [\\"c\\", \\"d\\"]], [\\"e\\", [\\"f\\", \\"g\\"]]]) == [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\"] assert flatten_array([[], [[], []]]) == [] ``` **Criteria**: - The solution should pass all provided test cases. - The implementation should be efficient and handle nested arrays up to typical practical limits. - Recursive and iterative methods should be implemented considering their advantages and drawbacks.","solution":"def flatten_array(input_array: list) -> list: Flattens a multi-dimensional input array into a single-dimensional array. :param input_array: List of elements, potentially nested :return: Flattened list containing all elements of input in depth-first order stack = [input_array] result = [] while stack: current = stack.pop() if isinstance(current, list): # We need to add elements in reverse to the stack, so we process # them in the correct order. stack.extend(current[::-1]) else: result.append(current) return result"},{"question":"# Scenario You work for a financial analytics firm and are tasked with predicting the best possible profit from historical stock prices. Your algorithm should identify the maximum profit by buying and selling a single stock, given the daily price list. # Problem Statement Your goal is to write an optimized function `max_profit(prices: List[int]) -> int` that returns the maximum profit you can achieve from these transactions. # Requirements - **Input**: - A list of integers `prices`, where `prices[i]` is the stock price on the `i-th` day. - **Output**: - An integer representing the maximum profit possible. - **Constraints**: - The length of `prices` will be in the range `[0, 10^5]`. - The prices will be in the range `[0, 10^4]`. - **Performance**: - You must achieve a time complexity of O(n) and a space complexity of O(1). # Example ```python assert max_profit([7, 1, 5, 3, 6, 4]) == 5 # Buy on day 2 (price=1) and sell on day 5 (price=6) for a 5 profit. assert max_profit([7, 6, 4, 3, 1]) == 0 # No transaction is possible resulting in a zero profit. assert max_profit([1, 2]) == 1 # Buy on day 1 and sell on day 2 for a 1 profit. assert max_profit([2, 4, 1]) == 2 # Buy on day 1 (price=2) and sell on day 2 (price=4) for a 2 profit. assert max_profit([]) == 0 # No prices available hence no profit. assert max_profit([5]) == 0 # Not enough prices for both buy and sell. ``` # Requirements for a Complete Solution - The function should return the maximum profit achievable or 0 if no profit is possible. - The solution should handle edge cases such as empty list and single-element lists gracefully.","solution":"from typing import List def max_profit(prices: List[int]) -> int: if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: profit = price - min_price if profit > max_profit: max_profit = profit return max_profit"},{"question":"# Disjoint Set Awareness in a Dynamic Grid Background You are tasked with designing an algorithm for dynamically adding land to a grid and counting the number of islands formed by land additions. Each \\"land\\" connects ortho-horizontally or -vertically to another land but is initially surrounded by water. Task Implement a function `dynamic_island_counter(grid_size, positions)` which performs the following: - Initializes a grid of the given size filled with water. - Adds land to specified positions sequentially. - After each addition, returns the number of islands present on the grid. Input - **grid_size**: A tuple `(m, n)` defining the grid dimensions (1 <= m, n <= 1000). - **positions**: A list of tuples where each tuple contains (row, column) coordinates representing land additions. Output - A list of integers where each integer is the count of islands after corresponding land addition. Constraints - Ensure the solution works efficiently within the size constraints. - Handle cases such as isolated land and fully connected grids. Example ```python positions = [(0, 0), (0, 1), (1, 2), (2, 1)] grid_size = (3, 3) # Expected output explanation # Initial grid: # 0 0 0 # 0 0 0 # 0 0 0 # Operation #1: addLand(0, 0) # 1 0 0 -> 1 island # 0 0 0 # 0 0 0 # Operation #2: addLand(0, 1) # 1 1 0 -> 1 island # 0 0 0 # 0 0 0 # Operation #3: addLand(1, 2) # 1 1 0 -> 2 islands # 0 0 1 # 0 0 0 # Operation #4: addLand(2, 1) # 1 1 0 -> 3 islands # 0 0 1 # 0 1 0 output = [1, 1, 2, 3] ``` Function Signature ```python def dynamic_island_counter(grid_size: Tuple[int, int], positions: List[Tuple[int, int]]) -> List[int]: pass ```","solution":"def dynamic_island_counter(grid_size, positions): class DSU: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size self.count = 0 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 if not grid_size or not positions: return [] m, n = grid_size total_positions = m * n dsu = DSU(total_positions) result = [] directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] addedLand = set() for position in positions: r, c = position if (r, c) in addedLand: result.append(dsu.count) continue addedLand.add((r, c)) index = r * n + c dsu.count += 1 for dr, dc in directions: nr, nc = r + dr, c + dc neighbor_index = nr * n + nc if 0 <= nr < m and 0 <= nc < n and (nr, nc) in addedLand: dsu.union(index, neighbor_index) result.append(dsu.count) return result"},{"question":"# SegmentTree Operations **Context**: A segment tree is a powerful data structure used for efficient range queries and updates. In this problem, you are tasked with implementing a segment tree and handling specific types of queries and updates efficiently. **Task**: Implement the `SegmentTree` class with the following methods: - **Constructor (`__init__`)**: * Parameters: Takes an array and a function. * Builds the segment tree for the given array using the provided function. - **`build_tree`**: * Constructs the segment tree from the initial array, aggregating values using the given function. - **`update`**: * Parameters: An index and a new value. * Updates the element at the given index with the new value and updates the segment tree accordingly. - **`query`**: * Parameters: Two indices representing the range (inclusive). * Returns the result of the provided function applied to the range of the array. **Method Specifications**: ```python class SegmentTree: def __init__(self, arr, function): # initialization and tree building def build_tree(self): # build the tree def update(self, p, v): # update element and tree accordingly def query(self, l, r): # performs range query ``` # Examples 1. **Example 1**: ```python arr = [2, 4, 5, 3, 4] mytree = SegmentTree(arr, max) print(mytree.query(2, 4)) # returns 5 mytree.update(3, 6) print(mytree.query(0, 3)) # returns 6 ``` 2. **Example 2**: ```python arr = [4, 5, 2, 3, 4, 43, 3] mytree = SegmentTree(arr, lambda a, b: a + b) print(mytree.query(0, 6)) # returns 64 mytree.update(2, -10) print(mytree.query(0, 6)) # returns 52 ``` 3. **Example 3**: ```python arr = [(1, 2), (4, 6), (4, 5)] mytree = SegmentTree(arr, lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # returns (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # returns (4, 10) ``` **Constraints**: - Array length: 1 <= N <= 100000. - Values: Suitable for the specified function. **Note**: - Ensure your solutions are efficient and avoid excessive memory usage. - Your code should handle edge cases gracefully, such as out-of-bounds queries.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.arr = arr self.func = function self.tree = [None] * (2 * self.n) self.build_tree() def build_tree(self): # Initialize the leaves of the segment tree for i in range(self.n): self.tree[self.n + i] = self.arr[i] # Build the rest of the tree by combining the children nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index, value): # Set the value at the leaf node pos = index + self.n self.tree[pos] = value # Traverse up and update the parents while pos > 1: pos //= 2 self.tree[pos] = self.func(self.tree[pos * 2], self.tree[pos * 2 + 1]) def query(self, left, right): # Transform to leaf positions left += self.n right += self.n + 1 res = None while left < right: if left % 2 == 1: res = self.tree[left] if res is None else self.func(res, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 res = self.tree[right] if res is None else self.func(res, self.tree[right]) left //= 2 right //= 2 return res"},{"question":"Validate Consecutive Sequence of Stack Using Auxiliary Structure **Objective**: To assess the student\'s understanding of stack operations and auxiliary storage mechanisms while verifying consecutive integer sequences. **Problem Statement**: Write a function `is_consecutive_with_aux` that determines whether the given stack contains a sequence of consecutive integers starting from the bottom of the stack. The function should use either an additional stack or queue as auxiliary storage and restore the original stack intact after checking. Function Signature: ```python def is_consecutive_with_aux(stack: list[int], use_queue: bool) -> bool: pass ``` Input: - `stack` (list of integers): A stack represented by a list of integers where the first element is the bottom and the last element is the top. - `use_queue` (bool): If True, use a queue as the auxiliary storage; otherwise, use an additional stack. Output: - Returns `True` if the stack contains consecutive integers starting from the bottom, otherwise `False`. Constraints: - Stack size will be at most 10^4. - Elements in the stack are integers. Performance Requirements: - The function should have a time complexity of O(n) and space complexity of O(n), where n is the number of elements in the stack. Example: ```python stack = [3, 4, 5, 6, 7] use_queue = False assert is_consecutive_with_aux(stack, use_queue) == True stack = [3, 4, 6, 7] use_queue = True assert is_consecutive_with_aux(stack, use_queue) == False stack = [3, 2, 1] use_queue = True assert is_consecutive_with_aux(stack, use_queue) == False ``` # Clarifications: - The initial ordering of elements matters, and they must be in ascending order consecutive from bottom to top. - The original stack should remain unchanged after function execution. - Consider both even and odd-sized stacks in the validation.","solution":"def is_consecutive_with_aux(stack: list[int], use_queue: bool) -> bool: # Making copies of the stack to keep the original stack intact original_stack = stack.copy() if not stack: return True # Empty stack is trivially consecutive # Auxiliary data structure (stack or queue) if use_queue: from collections import deque aux = deque() else: aux = [] previous = stack.pop(0) # Remove bottom element (first element of the list) aux.append(previous) while stack: current = stack.pop(0) # Remove the next element from the bottom if current != previous + 1: return False aux.append(current) previous = current # Restoring the original stack elements while aux: if use_queue: stack.insert(0, aux.popleft()) else: stack.insert(0, aux.pop()) return True"},{"question":"You are tasked to enhance the Bubble Sort algorithm to improve its efficiency and to add additional functionalities. The new implementation should have the following features: 1. **Early Termination Check**: If the array is already sorted, the function should terminate early without performing unnecessary passes. 2. **Sort Order Option**: Allow the function to sort in either ascending or descending order, based on a parameter. # Details Implement the function `enhanced_bubble_sort(arr: list, ascending: bool = True, simulation: bool = False) -> list` where: - `arr` (list): A list of integers to be sorted. - `ascending` (bool): A boolean value indicating the order of sorting. The default value is `True` (ascending order). If `False`, sort the array in descending order. - `simulation` (bool): A boolean flag indicating whether to print the simulation process. The default value is `False`. # Input - A list of integers `arr` which may be of varying lengths. - A boolean `ascending` controlling the sort order. - A boolean `simulation` for printing the sorting process for each significant step. # Output - The sorted list, based on the specified sorting order. # Constraints - The input list `arr` can have up to ( 10^5 ) elements. - Each element is an integer within the range [-10^6, 10^6]. # Example ```python print(enhanced_bubble_sort([5, 1, 4, 2, 8], ascending=True, simulation=False)) # Output: [1, 2, 4, 5, 8] print(enhanced_bubble_sort([5, 1, 4, 2, 8], ascending=False, simulation=False)) # Output: [8, 5, 4, 2, 1] ``` # Notes - You must optimize the function for early termination. - Ensure that your implementation handles edge cases such as empty lists and lists with a single element. - Your solution should be efficient and handle lists with up to ( 10^5 ) elements within a reasonable time frame.","solution":"def enhanced_bubble_sort(arr: list, ascending: bool = True, simulation: bool = False) -> list: Enhanced Bubble Sort with early termination and sort order option. Parameters: arr (list): List of integers to be sorted. ascending (bool): Sort order, True for ascending and False for descending. simulation (bool): Flag to print the sorting process. Returns: list: Sorted list of integers. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if (ascending and arr[j] > arr[j+1]) or (not ascending and arr[j] < arr[j+1]): arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if simulation: print(f\\"Swapped {arr[j]} and {arr[j+1]}: {arr}\\") if simulation: print(f\\"End of pass {i+1}: {arr}\\") if not swapped: if simulation: print(\\"No swaps occurred in this pass, array is sorted.\\") break return arr"},{"question":"Context: You have been given a stack where you need to switch successive pairs of numbers starting from the bottom. This kind of operation is useful when you need to rearrange certain portions of a data structure in a specific way, often for reorganization or preparatory steps in larger algorithms. Task: Create a function called `switch_pairs_custom` that accepts a stack and a mode of operation (\'stack\' or \'queue\'). Depending on the specified mode, it should use either a stack or a queue as auxiliary storage to perform the switching operation. Function Signature: ```python def switch_pairs_custom(stack: List[int], mode: str) -> List[int]: pass ``` Input: * `stack` (List[int]): A list of integers where the end of the list represents the top of the stack. * `mode` (str): A string that is either \'stack\' or \'queue\', indicating the type of auxiliary storage to use. Output: * The modified stack, where successive pairs of elements from the bottom are switched. Constraints: * All elements of the stack are integers. * The mode will be a string with only two possible values: \'stack\' or \'queue\'. * You may assume the given stack fits in memory. Examples: * Example 1: ```python stack = [3, 8, 17, 9, 1, 10] print(switch_pairs_custom(stack, \'stack\')) # Output: [8, 3, 9, 17, 10, 1] ``` * Example 2: ```python stack = [3, 8, 17, 9, 1] print(switch_pairs_custom(stack, \'queue\')) # Output: [8, 3, 9, 17, 1] ``` * Example 3: ```python stack = [] print(switch_pairs_custom(stack, \'stack\')) # Output: [] ``` * Example 4: ```python stack = [5] print(switch_pairs_custom(stack, \'queue\')) # Output: [5] ``` Notes: * Ensure that the function handles edge cases such as empty stacks and stacks with a single element. * The function should have a time complexity of O(n).","solution":"from typing import List from collections import deque def switch_pairs_custom(stack: List[int], mode: str) -> List[int]: if not stack: return stack if mode not in [\'stack\', \'queue\']: raise ValueError(\\"Invalid mode. Use \'stack\' or \'queue\'.\\") auxiliary_storage = deque() if mode == \'queue\' else [] size = len(stack) if mode == \'stack\': # Transfer all elements to auxiliary stack for _ in range(size): auxiliary_storage.append(stack.pop()) # Switch pairs while transferring back to the original stack while auxiliary_storage: first = auxiliary_storage.pop() if auxiliary_storage else None second = auxiliary_storage.pop() if auxiliary_storage else None if second is not None: stack.append(second) if first is not None: stack.append(first) elif mode == \'queue\': # Transfer all elements to auxiliary queue for _ in range(size): auxiliary_storage.appendleft(stack.pop()) # Switch pairs while transferring back to the original stack while auxiliary_storage: first = auxiliary_storage.popleft() if auxiliary_storage else None second = auxiliary_storage.popleft() if auxiliary_storage else None if second is not None: stack.append(second) if first is not None: stack.append(first) return stack"},{"question":"# In-order Traversal of a Binary Tree Scenario You are employed at a software company and are responsible for implementing a function that performs an in-order traversal of a binary tree. The binary tree is used in one of your company\'s core products\' modules, where sorted order traversal of the elements stored in the tree is critical for the module\'s functionality. Task Implement a function that performs an in-order traversal of a given binary tree. You must provide two versions of the function: one using an iterative approach and one using a recursive approach. Requirements * Implement the function `inorder_iterative(root)` for iterative in-order traversal. * Implement the function `inorder_recursive(root)` for recursive in-order traversal. Input and Output Format * **Input**: A `Node` object that represents the root of the binary tree. * **Output**: A list of node values in in-order sequence. Constraints & Assumptions * The binary tree can have up to `10^5` nodes. * Node values are unique and fall within the range of 32-bit signed integers. * The tree can be highly unbalanced. Node Class ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` # Example ```python # Example binary tree: # 100 # / # 50 150 # / / # 25 75 125 175 # Creating the tree root = Node(100) root.left = Node(50) root.right = Node(150) root.left.left = Node(25) root.left.right = Node(75) root.right.left = Node(125) root.right.right = Node(175) # Expected Output: [25, 50, 75, 100, 125, 150, 175] print(inorder_iterative(root)) print(inorder_recursive(root)) ```","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iterative(root): Performs iterative in-order traversal of a binary tree. :param root: Node, the root of the binary tree. :return: List of node values in in-order sequence. stack = [] result = [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root): Performs recursive in-order traversal of a binary tree. :param root: Node, the root of the binary tree. :return: List of node values in in-order sequence. result = [] def traverse(node): if node: traverse(node.left) result.append(node.val) traverse(node.right) traverse(root) return result"},{"question":"**Scenario** You\'re working on a web application where you frequently need to construct URLs by concatenating different path segments. For instance, you might have a base URL and need to append different endpoints to it. However, you want to ensure that the URLs are correctly formed without double slashes or missing slashes. # Problem Implement a function named `join_url_segments` that takes two strings: `base_url` and `path_segment`. The function should return a properly joined URL that ensures there are no duplicate or missing slashes between the segments. # Function Signature ```python def join_url_segments(base_url: str, path_segment: str) -> str: ``` # Input * `base_url` (str): The base URL (e.g., \\"http://algorithms.com/\\"). * `path_segment` (str): The URL path segment to append (e.g., \\"path/to/resource\\"). # Output * Returns a string representing the properly joined URL. # Constraints * Both `base_url` and `path_segment` are non-empty strings. * `base_url` may or may not end with a slash `/`. * `path_segment` may or may not start with a slash `/`, but should not end with any trailing spaces or newlines. * The function should handle large inputs efficiently. # Example ```python assert join_url_segments(\\"http://algorithms.com\\", \\"path/to/resource\\") == \\"http://algorithms.com/path/to/resource\\" assert join_url_segments(\\"http://algorithms.com/\\", \\"/path/to/resource\\") == \\"http://algorithms.com/path/to/resource\\" assert join_url_segments(\\"http://algorithms.com\\", \\"/path/to/resource\\") == \\"http://algorithms.com/path/to/resource\\" assert join_url_segments(\\"http://algorithms.com/base/\\", \\"path/to/resource\\") == \\"http://algorithms.com/base/path/to/resource\\" ``` # Edge Cases * Handle cases where `base_url` or `path_segment` are empty; (this will not happen due to the non-empty constraint). * Handle multiple slashes cases in between the segments.","solution":"def join_url_segments(base_url: str, path_segment: str) -> str: Joins base_url and path_segment ensuring no duplicate or missing slashes between them. if base_url.endswith(\'/\') and path_segment.startswith(\'/\'): return base_url + path_segment[1:] elif not base_url.endswith(\'/\') and not path_segment.startswith(\'/\'): return base_url + \'/\' + path_segment else: return base_url + path_segment"},{"question":"# Coding Assessment: Two Sum with Array Extension Context: You are given an extended problem of the Two Sum algorithm where the array might not be sorted, and duplicate elements are allowed. Your task is to find all unique pairs in the array that sum up to the given target. Each pair should be returned as an ordered tuple `(min_val, max_val)`. Task: Write a function `two_sum_pairs(numbers, target)` that takes an array of integers `numbers` and an integer `target`, and returns a list of tuples. Each tuple represents two values from the array whose sum equals the `target`. Ensure that each pair is unique and avoid using the same element twice. The returned list should be sorted lexicographically. Input: - `numbers`: List of integers, which can be unsorted and contain duplicates. - `target`: An integer representing the sum to find. Output: - A list of tuples, where each tuple contains two integers from the input list that add up to `target`. Each tuple should be in the form `(min_val, max_val)`. Constraints: - You may assume that there will be at most 1000 elements in the input list. - There can be multiple pairs or no pairs at all. Example: ```python numbers = [1, 3, 2, 2, 4, 3] target = 5 Output: [(1, 4), (2, 3)] ``` Performance Requirements: - Ensure the solution is efficient with a complexity close to O(n log n) or better. Function Signature: ```python def two_sum_pairs(numbers: List[int], target: int) -> List[Tuple[int, int]]: pass ```","solution":"def two_sum_pairs(numbers, target): Returns a list of unique pairs of numbers from the list `numbers` that add up to `target`. The returned pairs are sorted lexicographically, and each pair is in the form (min_val, max_val). seen = {} pairs = set() for number in numbers: complement = target - number if complement in seen: pair = tuple(sorted((number, complement))) pairs.add(pair) seen[number] = seen.get(number, 0) + 1 return sorted(list(pairs))"},{"question":"# Question: Swap Odd and Even Bits Given an integer, write a function `swap_odd_even_bits(num)` that swaps all odd bits with even bits. Odd bits are those in odd positions (1st, 3rd, 5th, etc.), and even bits are in even positions (2nd, 4th, 6th, etc.). Assume a 32-bit integer representation. Input - An integer `num` where `0 <= num <= 4294967295` (32-bit unsigned integer). Output - An integer where all odd bits have been swapped with their immediate even counterparts. Example ```python swap_odd_even_bits(22) # 010110 in binary -> 101001 in binary, which is 41 in decimal swap_odd_even_bits(10) # 1010 in binary -> 0101 in binary, which is 5 in decimal ``` Constraints - The function should run in constant time O(1). - You must use bitwise operations to achieve the result. # Scenario Consider a networking scenario where you need to transform data packets at the bit level for transmission. This function ensures efficient bit manipulation, a crucial component for performance optimization in such low-level operations. Performance Requirements - The function should efficiently handle the transformation using bitwise operations.","solution":"def swap_odd_even_bits(num): Swap odd bits with even bits in a given 32-bit unsigned integer. # 0xAAAAAAAA is a mask for all odd bits in a 32-bit number (101010... in binary) ODD_BITS_MASK = 0xAAAAAAAA # 0x55555555 is a mask for all even bits in a 32-bit number (010101... in binary) EVEN_BITS_MASK = 0x55555555 # Extract odd and even bits using bitwise AND odd_bits = num & ODD_BITS_MASK even_bits = num & EVEN_BITS_MASK # Right shift the odd bits to even positions, and left shift the even bits to odd positions odd_bits_shifted = odd_bits >> 1 even_bits_shifted = even_bits << 1 # Combine the shifted bits using bitwise OR to get the final swapped result swapped_num = odd_bits_shifted | even_bits_shifted return swapped_num"},{"question":"# Question You are tasked to expand the functionality of the provided `OrderedStack` class to handle additional operations efficiently. The goal is to enhance the ordered stack with a new operation that finds the median value of the stack. # Context: The `OrderedStack` maintains its elements in sorted order ensuring that the highest value is always at the top. In addition to the operations already provided (`push`, `pop`, `peek`, `is_empty`, and `size`), implement an efficient method to find the median of the elements currently in the stack. # Specification: Implement the following function within the `OrderedStack` class: ```python def find_median(self): Finds the median value of the elements in the stack. Returns: float: Median value of the stack\'s elements. If the stack is empty, raise an IndexError. ``` # Constraints: 1. The stack can contain any integer values. 2. You must not use any additional data structures such as lists, arrays, or external libraries like `heapq`. # Performance Requirements: - The median finding should be optimized to work under worst-case runtime of O(n). - The existing stack operations (`push`, `pop`, `peek`, `size`, `is_empty`) should retain their expected behavior and performance characteristics. # Example: Assume the stack has elements [1, 3, 5, 7, 9] with 9 on the top (stack is sorted such that the highest element is on top in the current implementation). Calling `find_median()` should return 5. # Edge Cases: - Finding median in an empty stack should raise an IndexError. - Finding median with an even number of elements should return the average of the two middle elements. # Hints: - Ensure to account for the properties of a stack (Last-In-First-Out) while implementing the median calculation. - Efficiently traverse the elements to find the median without violating the stack\'s LIFO property and sorting order.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, val): if not self.stack or val >= self.stack[-1]: self.stack.append(val) else: temp_stack = [] while self.stack and val < self.stack[-1]: temp_stack.append(self.stack.pop()) self.stack.append(val) while temp_stack: self.stack.append(temp_stack.pop()) def pop(self): if not self.stack: raise IndexError(\\"pop from an empty stack\\") return self.stack.pop() def peek(self): if not self.stack: raise IndexError(\\"peek from an empty stack\\") return self.stack[-1] def is_empty(self): return len(self.stack) == 0 def size(self): return len(self.stack) def find_median(self): size = len(self.stack) if size == 0: raise IndexError(\\"find_median from an empty stack\\") if size % 2 == 1: return float(self.stack[size // 2]) else: return (self.stack[size // 2 - 1] + self.stack[size // 2]) / 2"},{"question":"# Integer Base Conversion Problem Statement You are asked to implement a system that converts integers between different numerical bases. You need to write two functions: one that converts an integer to a base, and another that converts a base-represented string back to an integer. These functions should handle common edge cases and avoid performance pitfalls. Function Signature ```python def int_to_base(num: int, base: int) -> str: pass def base_to_int(str_to_convert: str, base: int) -> int: pass ``` Input * `int_to_base(num: int, base: int) -> str` - `num` is an integer value that can be positive, negative, or zero. - `base` is an integer representing the base for the conversion. Valid base values are between 2 and 36, inclusive. * `base_to_int(str_to_convert: str, base: int) -> int` - `str_to_convert` is a string representing the number in a given base. The string can contain digits and uppercase letters. - `base` is an integer representing the base of `str_to_convert`. Valid base values are between 2 and 36, inclusive. Output * `int_to_base` should return a string representing the base conversion of the integer. * `base_to_int` should return an integer result of the base converted string. Constraints * The input integer for `int_to_base` can range from -2^31 to 2^31-1. * The length of the string for `base_to_int` will not exceed 32 characters. Performance Requirements * Both functions should have a time complexity of O(log_b(n)) and O(m), respectively, as outlined in the algorithm analysis. Examples ```python assert int_to_base(10, 2) == \'1010\' assert int_to_base(-10, 16) == \'-A\' assert base_to_int(\'1010\', 2) == 10 assert base_to_int(\'-A\', 16) == -10 ``` Notes * Ensure that your implementation correctly handles negative numbers and zero. * For invalid base values (less than 2 or greater than 36), raise a `ValueError`. * Consider using efficient string operations to avoid performance overhead.","solution":"def int_to_base(num: int, base: int) -> str: Converts an integer to a given base and returns the string representation of the number in that base. The base can be between 2 and 36 inclusive. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" is_negative = num < 0 num = abs(num) result = \\"\\" while num > 0: result = digits[num % base] + result num //= base if is_negative: result = \\"-\\" + result return result def base_to_int(str_to_convert: str, base: int) -> int: Converts a string representation of a number in a given base back to an integer. The base can be between 2 and 36 inclusive. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" num_mapping = {digits[i]: i for i in range(base)} is_negative = str_to_convert[0] == \\"-\\" if is_negative: str_to_convert = str_to_convert[1:] num = 0 for char in str_to_convert: num = num * base + num_mapping[char] return -num if is_negative else num"},{"question":"# Problem Description You are given an unsorted array of integers and a target integer. Your goal is to implement a function `find_all_indices` that returns a list of all indices where the target integer is found in the array. If the target integer is not found, return an empty list. # Input - An unsorted array of integers, `arr` (0 ≤ len(arr) ≤ 10^5) - A target integer `target` # Output - A list of integers representing the indices of all occurrences of the target integer in the array, in ascending order. # Constraints - The function should handle empty arrays and return an empty list in such cases. - Avoid using extra space beyond the list for storing results (O(1) extra space). # Example Example 1 ```plaintext Input: arr = [4, 2, 2, 3, 4, 2], target = 2 Output: [1, 2, 5] ``` Example 2 ```plaintext Input: arr = [1, 2, 3, 4, 5], target = 6 Output: [] ``` # Function Signature ```python def find_all_indices(arr: List[int], target: int) -> List[int]: ```","solution":"from typing import List def find_all_indices(arr: List[int], target: int) -> List[int]: Returns a list of indices where the target is found in the array. indices = [] for i, num in enumerate(arr): if num == target: indices.append(i) return indices"},{"question":"# Question: Finding Primitive Roots of a Number You are required to implement functions related to finding primitive roots of a number. A primitive root of a positive integer `n` is any integer `a` such that all integers coprime with `n` are generated in a sequence modulo `n` by powers of `a`. Your implementation needs to accurately determine primitive roots and understand their properties and applications in number theory. Function 1: find_order ```python def find_order(a, n): Determine the smallest positive integer `k` such that pow(a, k) % n == 1. a: int - (must be coprime with n) n: int - positive integer Returns: k: int - the order of a modulo n, or -1 if no such k exists. pass ``` * **Input**: Two integers `a` and `n` (1 <= a, n <= 10^5). `a` must be coprime with `n`. * **Output**: An integer which is the smallest positive integer `k` such that `a^k ≡ 1 (mod n)`. Function 2: euler_totient ```python def euler_totient(n): Compute Euler\'s totient function of an integer n. n: int - positive integer Returns: phi: int - the number of integers less than n that are coprime with n. pass ``` * **Input**: An integer `n` (1 <= n <= 10^5). * **Output**: An integer which is the count of integers less than n that are coprime with n. Function 3: find_primitive_root ```python def find_primitive_root(n): Identify all primitive roots of a given positive integer n. n: int - positive integer Returns: p_root_list: List[int] - a list containing all primitive roots of n. pass ``` * **Input**: An integer `n` (1 <= n <= 10^5). * **Output**: A list of all integers that are primitive roots of `n`. # Constraints: - Inputs will always meet the specified constraints. - You must handle edge cases effectively, such as when `n` is 1. # Example: ```python assert find_order(3, 7) == 6 assert euler_totient(9) == 6 assert find_primitive_root(7) == [3, 5] ``` # Performance Requirements: - Your solution should efficiently handle large inputs within the constraints provided. - Aim for optimal time complexity, especially focusing on reducing the computational overhead of repeated calculations.","solution":"def find_order(a, n): Determine the smallest positive integer `k` such that pow(a, k) % n == 1. a: int - (must be coprime with n) n: int - positive integer Returns: k: int - the order of a modulo n, or -1 if no such k exists. k = 1 current = a % n while current != 1: current = (current * a) % n k += 1 if k > n: return -1 # should always exit before this if a and n are coprime return k def euler_totient(n): Compute Euler\'s totient function of an integer n. n: int - positive integer Returns: phi: int - the number of integers less than n that are coprime with n. result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_primitive_root(n): Identify all primitive roots of a given positive integer n. n: int - positive integer Returns: p_root_list: List[int] - a list containing all primitive roots of n. if n == 1: return [0] phi = euler_totient(n) coprime_set = set() for a in range(1, n): g = gcd(a, n) if g == 1: coprime_set.add(a) primitive_roots = [] for g in range(1, n): if gcd(g, n) == 1: order = find_order(g, n) if order == phi: primitive_roots.append(g) return primitive_roots from math import gcd"},{"question":"# Context: You are tasked with optimizing storage in an embedded system by manipulating binary representations of integers. One common operation involves removing specific bits from integer values for alignment and optimization. # Problem: Write a function that removes a bit at a specified position from the binary representation of an integer. # Function Signature: ```python def remove_bit(num: int, i: int) -> int: ``` # Parameters: - `num` (int): An integer from which a bit is to be removed. - `i` (int): The position (0-indexed from the right) at which the bit is to be removed. # Returns: - (int): The resulting integer after the specified bit is removed. # Constraints: 1. Both `num` and `i` will be non-negative integers. 2. The position `i` will be within the bit-length of `num`. # Example: ```python # Example 1 num = 21 # Binary: 10101 i = 2 assert remove_bit(num, i) == 9 # Binary: 1001 # Example 2 num = 21 # Binary: 10101 i = 4 assert remove_bit(num, i) == 5 # Binary: 101 # Example 3 num = 21 # Binary: 10101 i = 0 assert remove_bit(num, i) == 10 # Binary: 1010 ``` # Clarifications: - Removing a bit shifts all higher-order bits to the right by one position. - Ensure that your method handles all valid edge cases, such as removing the most significant bit (leftmost bit). # Implementation Details: Use bitwise operations to achieve this. Shifting bits right and left and using masks are essential to solving this problem efficiently.","solution":"def remove_bit(num: int, i: int) -> int: Removes a bit at the specified position from the binary representation of the integer. Parameters: num (int): the integer from which to remove the bit. i (int): the position of the bit to remove (0-indexed from the right). Returns: int: the new integer after removing the bit. # Split the number into two parts: above and below the bit to remove left_part = num >> (i + 1) right_part = num & ((1 << i) - 1) # Combine the parts without the position i result = (left_part << i) | right_part return result"},{"question":"You are required to implement a class `OrderedStack`, a variation of the stack data structure that maintains its elements in a sorted order such that the maximum element is always at the top of the stack. Implement the following methods: 1. **`__init__(self)`**: Initializes an empty stack. 2. **`is_empty(self)`**: Returns `True` if the stack is empty, else `False`. 3. **`push_t(self, item)`**: Standard push operation that inserts `item` at the top of the stack. 4. **`push(self, item)`**: Method to push `item` into the stack while maintaining the order such that the highest element is on the top. 5. **`pop(self)`**: Removes and returns the item at the top of the stack. Raises an `IndexError` if the stack is empty. 6. **`peek(self)`**: Returns the item at the top of the stack without removing it. Raises an `IndexError` if the stack is empty. 7. **`size(self)`**: Returns the number of elements in the stack. # Constraints: - All elements pushed into the stack implement comparison operations (i.e., they support `>`, `<`). # Example: ```python stack = OrderedStack() stack.push(3) stack.push(1) stack.push(4) stack.push(2) assert stack.peek() == 4 # 4 is the max, hence top assert stack.pop() == 4 assert stack.pop() == 3 assert stack.pop() == 2 assert stack.pop() == 1 assert stack.is_empty() == True ``` # Note: - Ensure your implementation handles edge cases such as pushing into an empty stack and popping from an empty stack correctly. - Your solution should properly manage space complexity and not retain unnecessary memory.","solution":"class OrderedStack: def __init__(self): self.stack = [] def is_empty(self): return len(self.stack) == 0 def push_t(self, item): self.stack.append(item) def push(self, item): temp_stack = [] while not self.is_empty() and self.peek() > item: temp_stack.append(self.pop()) self.push_t(item) while temp_stack: self.push_t(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\'pop from empty stack\') return self.stack.pop() def peek(self): if self.is_empty(): raise IndexError(\'peek from empty stack\') return self.stack[-1] def size(self): return len(self.stack)"},{"question":"You are tasked to implement a function that decodes an encoded string according to a specific rule. The rule is specified as `k[encoded_string]`, where `encoded_string` inside the square brackets is repeated exactly `k` times. You may assume that the input string is valid and well-formed, with no extra whitespace, and all brackets are properly closed. Digits only appear for repeat counts and not within the encoded strings. # Function Signature ```python def decode_string(s: str) -> str: pass ``` # Input - `s` (string): A non-empty, valid, encoded string. # Output - A decoded string as per the given encoding rules. # Constraints - The input string `s` will be well-formed with no unpaired brackets or invalid characters. - The input string will only contain lowercase English letters and digits for repeat counts. # Examples ```python assert decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" assert decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" ``` # Requirements Implement the function in such a way that it: - Efficiently processes the string with time complexity O(n) - Handles nested encodings correctly - Works within memory constraints, ideally using O(n) space. # Detailed Explanation 1. Traverse each character in the string `s`. 2. Use a stack to handle nested encodings by storing the current string and repeat times when encountering \'[\'. 3. Construct the current string by concatenating repeated substrings or adding individual characters. 4. Upon encountering \']\', pop the top of the stack to retrieve the previous string and the repeat count, then construct the new string by repeating and concatenating properly. Good luck!","solution":"def decode_string(s: str) -> str: stack = [] current_num = 0 current_string = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) # construct repeat number with multiple digits elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': prev_string, repeat_num = stack.pop() current_string = prev_string + current_string * repeat_num else: # char is an alphabet current_string += char return current_string"},{"question":"# Cloning an Undirected Graph Context You are working on a graph-based application and need to create an exact duplicate of an existing graph. The graph is undirected, meaning that for every edge between two nodes, both nodes consider each other as neighbors. Each node in the graph has a unique label and may have a list of neighbors (other nodes). Task Write a function `clone_undirected_graph(node)` that takes as input a reference to a node in an undirected graph and returns a deep copy (clone) of the entire graph. Requirements - Implement the cloning using an iterative approach of Depth First Search (DFS). - Consider using a stack for the DFS. - Make sure to handle graphs with cycles correctly and avoid infinite loops. - You should handle edge cases such as: * An empty graph (input node is `None`). * Graphs where nodes have self-cycles. * Graphs with disconnected components. Input and Output - **Input**: A single node (`node`) of type `UndirectedGraphNode`, that represents a node in the undirected graph. - **Output**: Return the cloned graph\'s corresponding starting node. Example Consider a graph represented as: ``` 1 / / 0 --- 2 / _/ ``` If the input node is `node` representing the node with label `0`, your function should return the clone of the entire graph. Constraints - Node labels are unique integers. - The number of nodes is at most `100`. - Your function should be efficient in terms of both time and space complexity. ```python import collections class UndirectedGraphNode: A node in an undirected graph. Contains a label and a list of neighbouring nodes (initially empty). def __init__(self, label): self.label = label self.neighbors = [] def clone_undirected_graph(node): Clones an undirected graph using iterative DFS. # Your code here ```","solution":"import collections class UndirectedGraphNode: A node in an undirected graph. Contains a label and a list of neighbouring nodes (initially empty). def __init__(self, label): self.label = label self.neighbors = [] def clone_undirected_graph(node): Clones an undirected graph using iterative DFS. if not node: return None # Dictionary to store the mapping from original node to the cloned node mapping = {} # Initialize a stack with the initial node stack = [node] # Clone the root node and put it in the mapping dictionary mapping[node] = UndirectedGraphNode(node.label) while stack: # Pop a node from the stack current = stack.pop() # Iterate through the neighbors of the current node for neighbor in current.neighbors: if neighbor not in mapping: # Clone the neighbor and put it in the mapping dictionary mapping[neighbor] = UndirectedGraphNode(neighbor.label) # Add the neighbor to the stack for further processing stack.append(neighbor) # Link the clone of the current node to the clone of the neighbor mapping[current].neighbors.append(mapping[neighbor]) # Return the clone of the initial node return mapping[node]"},{"question":"# Context: You are part of a software development team at an educational platform. Your task is to implement a sorting module that can efficiently handle moderately sized datasets and demonstrate the mechanics of less common sorting algorithms for instructional purposes. # Task: Implement a function `enhanced_cocktail_shaker_sort(arr: List[int]) -> List[int]` that sorts an array of integers using the Cocktail Shaker Sort algorithm with an enhancement to optimize its performance by early termination when no swaps occur during a complete traversal. # Input: - `arr` - A list of integers ( (1 leq text{len}(arr) leq 10^4) ). # Output: - Return the sorted list of integers. # Constraints: - The function must handle arrays of up to `10^4` integers within reasonable time limits. - You may assume all integers fit within the standard integer range. # Example: ```python assert enhanced_cocktail_shaker_sort([5, 3, 7, 2, 8, 6, 4, 1]) == [1, 2, 3, 4, 5, 6, 7, 8] assert enhanced_cocktail_shaker_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert enhanced_cocktail_shaker_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] ``` # Notes: - Ensure your implementation stops early when the array is already sorted during a particular direction of pass. - Pay attention to edge cases, such as an array that is already sorted, an array with a single element, or an empty array.","solution":"def enhanced_cocktail_shaker_sort(arr): Sorts an array of integers using an enhanced Cocktail Shaker Sort algorithm with early termination optimization. n = len(arr) if n <= 1: return arr # Early return for trivial lists start = 0 end = n - 1 swapped = True while swapped: swapped = False # Traverse from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 # Traverse from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"# Problem: Insert in Sorted Array You are given a sorted array of integers and a target value. Your task is to write a function `insert_in_sorted_array` which inserts the target value into the array while maintaining the sorted order, utilizing the efficient search provided by binary search. # Function Signature ```python def insert_in_sorted_array(array: list, target: int) -> list: pass ``` # Input * A sorted list of integers, `array`. * An integer, `target`. # Output * A new list of integers with the `target` value inserted in the correct position to maintain the sorted order. # Constraints * All integers in `array` are unique. * The function should run in O(n) time complexity, considering the insertion process after finding the correct position. * The function should handle arrays of up to 10^5 elements. # Example ```python assert insert_in_sorted_array([1, 3, 5, 6], 5) == [1, 3, 5, 6] # Target already in array assert insert_in_sorted_array([1, 3, 5, 6], 2) == [1, 2, 3, 5, 6] assert insert_in_sorted_array([1, 3, 5, 6], 7) == [1, 3, 5, 6, 7] assert insert_in_sorted_array([1, 3, 5, 6], 0) == [0, 1, 3, 5, 6] assert insert_in_sorted_array([], 1) == [1] # Empty array edge case ``` # Explanation Use a binary search to determine the correct insert position efficiently. Then insert the target at that position, ensuring the array remains sorted. The insertion operation can be relatively expensive in terms of shifting elements, but the binary search helps minimize the processing time to find the correct position.","solution":"def insert_in_sorted_array(array: list, target: int) -> list: Inserts the target value into the sorted array while maintaining the sorted order. if not array: return [target] left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == target: return array # Target already in array, no need to insert elif array[mid] < target: left = mid + 1 else: right = mid - 1 array.insert(left, target) return array"},{"question":"Scenario You are working on a project that involves extensive manipulation of linked lists. One common operation you need to implement is the removal of duplicate elements from a singly linked list. To assess your understanding of both linked list operations and algorithm optimization, you will implement this operation using two different approaches. Task 1. **Implement a function to remove duplicates from a singly linked list using a hash set**: ```python def remove_duplicates_with_set(head: Node) -> None: Removes duplicate nodes from the linked list. Args: head (Node): The head node of the singly linked list. Returns: None pass ``` 2. **Implement a function to remove duplicates from a singly linked list without using any extra space for data structures**: ```python def remove_duplicates_without_set(head: Node) -> None: Removes duplicate nodes from the linked list without using extra space. Args: head (Node): The head node of the singly linked list. Returns: None pass ``` Function Details: * **Expected Input Format**: - `head`: The head node of a singly linked list. Each `Node` object has: - `val`: The value of the node (assume it can be any hashable type like integers, strings). - `next`: The reference to the next node. * **Expected Output Format**: - Both functions should modify the linked list in-place and do not return any value (i.e., return `None`). - After calling either function, the linked list should not contain any duplicate elements. * **Constraints and Limitations**: - You can assume the linked list\'s length is at most `10^6`. * **Performance Requirements**: - The `remove_duplicates_with_set` function should operate in linear time, O(N), and use O(N) additional space. - The `remove_duplicates_without_set` function should operate in quadratic time, O(N^2), but use O(1) additional space. Examples: Consider a linked list represented as: `A -> A -> B -> C -> D -> C -> F -> G` Before: `A -> A -> B -> C -> D -> C -> F -> G` - After `remove_duplicates_with_set` OR `remove_duplicates_without_set`: `A -> B -> C -> D -> F -> G` **Note**: You can include additional helper functions/classes (like `Node`), as needed to implement and test your solution.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates_with_set(head: Node) -> None: Removes duplicate nodes from the linked list using a hash set. Args: head (Node): The head node of the singly linked list. Returns: None if not head: return seen = set() current = head seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_duplicates_without_set(head: Node) -> None: Removes duplicate nodes from the linked list without using extra space. Args: head (Node): The head node of the singly linked list. Returns: None current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Shell Sort Implementation Shell Sort is a highly efficient sorting algorithm based on insertion sort. It starts by sorting elements far apart and gradually reduces the gap between compared elements. This technique can significantly reduce the number of shifts when compared to a simple insertion sort. Problem Statement Implement the Shell Sort algorithm, which sorts a given list of integers in ascending order. Your implementation should ensure efficiency and correctness while handling various edge cases. Input - A list of integers `arr` of size `n` (1 ≤ n ≤ 10^6). Output - Return the sorted list of integers in ascending order. Constraints - The input list can be very large, so your solution must pay attention to time and space efficiency. - Consider both average cases and edge cases to ensure the robustness of your implementation. Example ```python # Input arr = [64, 34, 25, 12, 22, 11, 90] # Output sorted_arr = [11, 12, 22, 25, 34, 64, 90] ``` Requirements - Your solution should be optimized for performance. - Use a suitable gap sequence to achieve better practical performance. Evaluation Criteria - Correctness of the implementation. - Handling of edge cases. - Efficiency concerning both time and space. Write a function `shell_sort(arr)` to implement the sorting algorithm. ```python def shell_sort(arr): # Your implementation here pass # Example usage arr = [64, 34, 25, 12, 22, 11, 90] print(shell_sort(arr)) # Output: [11, 12, 22, 25, 34, 64, 90] ```","solution":"def shell_sort(arr): Sorts the list arr using the Shell Sort algorithm. n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"# Problem: Check if Tree is a Subtree Given two binary trees `s` and `t`, write a function `is_subtree(s, t)` that returns `True` if `t` is a subtree of `s`, and `False` otherwise. A subtree of a tree `t` is a tree consisting of a node in `t` and all of its descendants. # Input Format: - `s`, `t` - binary trees represented by their root nodes. # Output Format: - Returns a boolean value (`True` or `False`). # Constraints: 1. The number of nodes in `s` will be between 1 and 2000. 2. The number of nodes in `t` will be between 1 and 1000. 3. Node values will be unique. # Example: Example 1: **Input:** ``` s: 3 / 4 5 / 1 2 t: 4 / 1 2 ``` **Output:** `True` Example 2: **Input:** ``` s: 3 / 4 5 / 1 2 / 0 t: 4 / 1 2 ``` **Output:** `False` # Follow-up: What if one tree is significantly larger than the other? # Implementation function template: ```python import collections def is_subtree(s, t): queue = collections.deque([s]) while queue: node = queue.popleft() if node.val == t.val and compare_trees(node, t): return True if node.left: queue.append(node.left) if node.right: queue.append(node.right) return False def compare_trees(s, t): if not s and not t: return True if not s or not t or s.val != t.val: return False return compare_trees(s.left, t.left) and compare_trees(s.right, t.right) ``` You need to complete the implementation of `is_subtree(s, t)` and `compare_trees(s, t)` following the provided template consistent with the traversal and comparison logic discussed.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(s, t): Returns True if binary tree t is a subtree of binary tree s. if not s: return False if is_same_tree(s, t): return True return is_subtree(s.left, t) or is_subtree(s.right, t) def is_same_tree(s, t): Returns True if binary trees s and t are identical. if not s and not t: return True if not s or not t or s.val != t.val: return False return is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right)"},{"question":"Counting \'1\' Bits Scenario: You are working on optimizing a network management system that frequently needs to determine the number of active connections represented as \'1\' bits in a status integer. To make this system efficient, you need to implement an optimized function to count the number of \'1\' bits in an unsigned integer. Task: Implement the function `count_ones` that utilizes Brian Kernighan\'s algorithm to count the number of \'1\' bits in the binary representation of a given unsigned integer. Function Signature: ```python def count_ones(n: int) -> int: Counts the number of \'1\' bits in the binary representation of an unsigned integer. Parameters: n (int): An unsigned integer. Returns: int: The number of \'1\' bits in the binary representation of n. ``` Input: - A single unsigned integer `n`. Output: - Return a single integer representing the count of \'1\' bits in the binary representation of `n`. Example: ```python assert count_ones(11) == 3 # Binary: 1011 assert count_ones(128) == 1 # Binary: 10000000 assert count_ones(255) == 8 # Binary: 11111111 assert count_ones(0) == 0 # Binary: 0 ``` Constraints: - The function should handle any unsigned integer within the typical 32-bit range. - The implementation must use Brian Kernighan\'s algorithm, either recursively or iteratively, and avoid built-in functions that abstract away the bit manipulation work. Performance Requirements: - Ensure that the function runs efficiently with a time complexity of O(k), where k is the number of \'1\' bits. - Maintain a constant space complexity of O(1).","solution":"def count_ones(n: int) -> int: Counts the number of \'1\' bits in the binary representation of an unsigned integer. Parameters: n (int): An unsigned integer. Returns: int: The number of \'1\' bits in the binary representation of n. count = 0 while n: n &= n - 1 count += 1 return count"},{"question":"**Problem Statement:** You are given a list of integers and a value `k`. You need to implement the Misra-Gries algorithm to find all the integers in the list that appear at least `ceil(n/k)` times, where `n` is the length of the list. **Function Signature:** ```python def misras_gries(array: List[int], k: int = 2) -> Optional[Dict[int, int]]: ``` **Input:** - `array`: A list of integers. Example: `[1, 4, 4, 4, 5, 4, 4]` - `k`: An optional integer value representing the divisor. Default value is 2. **Output:** - A dictionary where keys are the integers that appear at least `ceil(n/k)` times and values are their frequencies. If no such element exists, return `None`. **Constraints:** - `1 <= len(array) <= 10^6` - `1 <= k <= len(array)` **Performance Requirements:** - The function must run in linear time, O(n). - The space complexity should be O(k). **Example:** ```python assert misras_gries([1, 4, 4, 4, 5, 4, 4]) == {\'4\': 5} assert misras_gries([0, 0, 0, 1, 1, 1, 1]) == {\'1\': 4} assert misras_gries([0, 0, 0, 0, 1, 1, 1, 2, 2], 3) == {\'0\': 4, \'1\': 3} assert misras_gries([0, 0, 0, 1, 1, 1]) == None ``` **Edge Cases:** - If the list is empty, return `None`. - If `k` is set too high relative to the list size, ensure the function handles it gracefully. **Implementation Constraints:** - Do not use any libraries other than standard Python libraries. - The function should be efficient in terms of both time and space complexity.","solution":"from math import ceil from typing import List, Optional, Dict def misras_gries(array: List[int], k: int = 2) -> Optional[Dict[int, int]]: if not array: return None n = len(array) threshold = ceil(n/k) candidates = {} # First pass: Find potential candidates for num in array: if num in candidates: candidates[num] += 1 elif len(candidates) < k - 1: candidates[num] = 1 else: candidates = {key: val - 1 for key, val in candidates.items() if val - 1 > 0} # Reset counts for candidates for key in list(candidates.keys()): candidates[key] = 0 # Second pass: Validate candidates for num in array: if num in candidates: candidates[num] += 1 # Filter results by threshold result = {key: val for key, val in candidates.items() if val >= threshold} return result if result else None"},{"question":"Implement Binary Search Variants **Background Context**: You have been hired as a developer to optimize the search module of an extensive product database. This module needs to rapidly fetch product details based on various search criteria. As part of this effort, you need to implement a reliable and efficient search algorithm. **Problem Statement**: Write two functions to perform a binary search on a sorted array of integers, once using an iterative approach and once using a recursive approach. Both implementations should return the index of the target value if it exists in the array and `-1` if it doesn\'t. # Function 1: Iterative Binary Search ```python def iterative_binary_search(array, target): Searches for the target value in a sorted array using iterative binary search. Parameters: array (list of int): A sorted list of integers where the target value is to be searched. target (int): The value to be searched for in the array. Returns: int: The index of the target if found, otherwise -1. pass ``` # Function 2: Recursive Binary Search ```python def recursive_binary_search(array, low, high, target): Searches for the target value in a sorted array using recursive binary search. Parameters: array (list of int): A sorted list of integers where the target value is to be searched. low (int): The starting index of the search range. high (int): The ending index of the search range. target (int): The value to be searched for in the array. Returns: int: The index of the target if found, otherwise -1. pass ``` # Input Format * **Array**: A non-empty list of integers sorted in ascending order. * **Target**: An integer representing the value to be searched. # Output Format Return the integer index of the target value in the array. If the target is not found, return `-1`. # Constraints 1. The array length will be between 1 and 10^5. 2. The array elements and the target will be integers between -10^9 and 10^9. # Example Scenarios Example 1: ```py array = [-1, 0, 3, 5, 9, 12] target = 9 ``` * **Expected Output**: `4` Example 2: ```py array = [-1, 0, 3, 5, 9, 12] target = 2 ``` * **Expected Output**: `-1` # Guidelines * Implement the iterative binary search in the `iterative_binary_search` function. * Implement the recursive binary search in the `recursive_binary_search` function. * For the recursive function, `low` should typically start at 0 and `high` should be the last index of the array (`len(array) - 1`). **Note**: You are required to handle edge cases and write efficient, correct code that adheres to the given constraints.","solution":"def iterative_binary_search(array, target): Searches for the target value in a sorted array using iterative binary search. Parameters: array (list of int): A sorted list of integers where the target value is to be searched. target (int): The value to be searched for in the array. Returns: int: The index of the target if found, otherwise -1. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def recursive_binary_search(array, low, high, target): Searches for the target value in a sorted array using recursive binary search. Parameters: array (list of int): A sorted list of integers where the target value is to be searched. low (int): The starting index of the search range. high (int): The ending index of the search range. target (int): The value to be searched for in the array. Returns: int: The index of the target if found, otherwise -1. if low > high: return -1 mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: return recursive_binary_search(array, mid + 1, high, target) else: return recursive_binary_search(array, low, mid - 1, target)"},{"question":"Context You are developing a command-line utility that manipulates and reads files provided by the user. It is crucial that you correctly determine the absolute path of any provided filepath to avoid unexpected behavior caused by relative paths. Task Implement a function `resolve_file_path` that determines the full absolute path of a given file. This function should handle all user shortcuts (e.g., tilde for user home directory) and convert any relative paths to absolute paths. Function Signature ```python def resolve_file_path(file: str) -> str: pass ``` Input * **file** (str): A string representing the file path which could be relative, contain user directory shortcuts or be an already absolute path. Output * (str): The absolute file path. Constraints * The input string can be empty or of variable length not exceeding 260 characters. * Ensure the function is platform-independent (usable in Unix, Linux, Windows, and macOS environments). Example ```python # Example 1 input: \'~/documents/myfile.txt\' output: \'/home/username/documents/myfile.txt\' # Assuming \'username\' is the current user\'s home directory # Example 2 input: \'somefile.txt\' output: \'/Users/username/somefile.txt\' # Assuming current directory is the user\'s home directory # Example 3 input: \'/abs/path/to/file.txt\' output: \'/abs/path/to/file.txt\' # Already absolute path should remain unchanged ``` Notes * Ensure the function handles empty input strings gracefully. * The home directory in Unix-like systems starts with `/home`, whereas in Windows it might start with `C:Users`.","solution":"import os def resolve_file_path(file: str) -> str: Returns the absolute path of the given file string. Handles user shortcuts and converts relative paths to absolute paths. if not file: return \'\' return os.path.abspath(os.path.expanduser(file))"},{"question":"# RSA Decryption Challenge You are given an implementation of RSA encryption, which includes generating keys, encrypting data, and decrypting data. Your task is to ensure that the decryption function works for various edge cases and to implement a robust encryption-decryption system that can handle: - Large prime numbers - Random keys generation with unique seeds - Data encryption and decoding validation Function Signatures 1. `generate_key(k: int, seed: Optional[int] = None) -> Tuple[int, int, int]` 2. `encrypt(data: int, e: int, n: int) -> int` 3. `decrypt(data: int, d: int, n: int) -> int` Constraints - `1 <= k <= 1024` (bit size of primes) - `0 <= data < 2^k` (integer to encrypt) - The functions should handle large prime number computations efficiently. # Task 1. **Extend `generate_key()`** to handle edge cases, including ensuring the generated prime numbers are large and `e` and `λ(n)` are coprime. 2. **Implement `encrypt()` and `decrypt()` functions**, ensuring they work efficiently for the given input size. # Input Format - `k`: an integer representing the bit length for the generated prime numbers. - `seed`: (optional) an integer seed for random number generation. - `data`: an integer representing the data to be encrypted. # Output Format - A tuple of three integers (n, e, d) from `generate_key()`. - An encrypted integer from `encrypt()`. - A decrypted integer from `decrypt()`. # Example ```python n, e, d = generate_key(16, seed=42) data = 1234 encrypted_data = encrypt(data, e, n) decrypted_data = decrypt(encrypted_data, d, n) assert decrypted_data == data # should be True ``` # Evaluation Criteria 1. Correctness: The decryption must accurately recover the original data. 2. Efficiency: Handle large `k` values within reasonable time limits. 3. Robustness: Handle edge cases such as very small or very large prime numbers, ensuring correctness.","solution":"import random from sympy import isprime, mod_inverse, nextprime def generate_key(k, seed=None): if seed is not None: random.seed(seed) def generate_large_prime(bits): while True: p = random.getrandbits(bits) p |= (1 << (bits - 1)) | 1 # Ensure p is of bit length k and is odd if isprime(p): return p p = generate_large_prime(k) q = generate_large_prime(k) n = p * q phi = (p - 1) * (q - 1) # Choose e such that 1 < e < phi and gcd(e, phi) = 1 e = 65537 # A common value for e while phi % e == 0: e = nextprime(e) d = mod_inverse(e, phi) return (n, e, d) def encrypt(data, e, n): return pow(data, e, n) def decrypt(data, d, n): return pow(data, d, n)"},{"question":"You have been provided with a set of fundamental bit manipulation functions that perform basic operations on individual bits of an integer. These four functions are: 1. `get_bit(num, i)` - Returns the value of the bit at index `i`. 2. `set_bit(num, i)` - Sets the bit at index `i` to 1. 3. `clear_bit(num, i)` - Clears (sets to 0) the bit at index `i`. 4. `update_bit(num, i, bit)` - Updates the bit at index `i` to the specified `bit` value. Now, given these basic building blocks, your task is to implement a new function, `modify_bits(num, operations)`, that applies a sequence of bit manipulation operations to a given number. Function Signature ```python def modify_bits(num: int, operations: List[Tuple[str, int, Optional[int]]]) -> int: Apply a sequence of bit manipulation operations on a given integer. :param num: Initial integer on which to perform the operations. :param operations: A list of tuples, each representing an operation. Each tuple contains: - A string (\'get\', \'set\', \'clear\', \'update\') indicating the type of operation. - An integer `i` representing the bit position. - An optional integer `bit` (needed only for \'update\' operations) representing the new bit value. :return: The modified integer after performing all operations. pass ``` Input * `num` (int): The integer on which to perform the bit manipulation operations. * `operations` (List[Tuple[str, int, Optional[int]]]): A list of operations to be applied in order. Each tuple specifies: - The operation type as a string: `\'get\'`, `\'set\'`, `\'clear\'`, `\'update\'`. - The bit index `i` as an integer. - Optionally, for `update` operations, the third element is the new bit value (0 or 1). Output * The modified integer after applying all operations in the given sequence. # Example ```python # Example Operations operations = [ (\'set\', 1), # Set bit at index 1 (\'clear\', 0), # Clear bit at index 0 (\'update\', 2, 1), # Update bit at index 2 to 1 (\'get\', 2) # Get value of the bit at index 2 (no-op in context of modifying the integer) ] # Initial number num = 0 # Expected result modified_num = modify_bits(num, operations) print(modified_num) # Output: 6 ``` **Explanation**: 1. Initially, `num = 0` (binary `0000`). 2. `\'set(1)\'` makes it `0010` (binary). 3. `\'clear(0)\'` makes no change as the 0th bit was already 0, so still `0010`. 4. `\'update(2, 1)\'` changes the binary to `0110`. 5. `\'get(2)\'` has no effect on num but would return the value of the 2nd bit. *Note*: Ensure that when processing `\'get\'` operations, the current bit value is printed directly. # Constraints * You may assume bit positions are valid (0 <= i < 32 for standard 32-bit integers). * The input integer will be non-negative.","solution":"def get_bit(num, i): Returns the value of the bit at index i. return (num >> i) & 1 def set_bit(num, i): Sets the bit at index i to 1. return num | (1 << i) def clear_bit(num, i): Clears (sets to 0) the bit at index i. return num & ~(1 << i) def update_bit(num, i, bit): Updates the bit at index i to the specified bit value. mask = ~(1 << i) return (num & mask) | (bit << i) def modify_bits(num, operations): Apply a sequence of bit manipulation operations on a given integer. :param num: Initial integer on which to perform the operations. :param operations: A list of tuples, each representing an operation. Each tuple contains: - A string (\'get\', \'set\', \'clear\', \'update\') indicating the type of operation. - An integer `i` representing the bit position. - An optional integer `bit` (needed only for \'update\' operations) representing the new bit value. :return: The modified integer after performing all operations. for operation in operations: op_type = operation[0] i = operation[1] if op_type == \'get\': print(get_bit(num, i)) # Print the value of the bit at index i elif op_type == \'set\': num = set_bit(num, i) elif op_type == \'clear\': num = clear_bit(num, i) elif op_type == \'update\': bit = operation[2] num = update_bit(num, i, bit) return num"},{"question":"# Run-Length Encoding and Decoding Given a string, implement functions that perform Run-Length Encoding (RLE) and Run-Length Decoding (RLD). Problem: 1. **rle_encode**: Compress the input string using Run-Length Encoding. 2. **rle_decode**: Decompress the encoded string back to its original form. Input: 1. **rle_encode**: A single-line string containing the data to be encoded (1 ≤ length ≤ 10^5). The string only consists of alphanumeric characters. 2. **rle_decode**: A single-line string containing the run-length encoded data (1 ≤ length ≤ 10^5). The encoded string is well-formed and follows the RLE encoding schema. Output: 1. **rle_encode**: A string representing the run-length encoded data. 2. **rle_decode**: A string representing the original data after decoding. Constraints: - Both functions should run efficiently even for the maximum input size. - Handle edge cases such as empty strings or strings with no repetitive characters. Examples: 1. Encoding: ```python input_str = \\"aaabbc\\" output_str = \\"3a2b1c\\" ``` 2. Decoding: ```python input_str = \\"3a2b1c\\" output_str = \\"aaabbc\\" ``` **Your task is to implement the following functions:** ```python def rle_encode(input_str): Compress the input string using Run-Length Encoding. :param input_str: str, the data to be encoded. :return: str, the encoded string. pass # Your code goes here def rle_decode(encoded_str): Decompress the encoded string using Run-Length Decoding. :param encoded_str: str, the RLE encoded data. :return: str, the original data. pass # Your code goes here ```","solution":"def rle_encode(input_str): Compress the input string using Run-Length Encoding. :param input_str: str, the data to be encoded. :return: str, the encoded string. if not input_str: return \\"\\" encoded_str = [] current_char = input_str[0] count = 1 for char in input_str[1:]: if char == current_char: count += 1 else: encoded_str.append(f\\"{count}{current_char}\\") current_char = char count = 1 encoded_str.append(f\\"{count}{current_char}\\") return \'\'.join(encoded_str) def rle_decode(encoded_str): Decompress the encoded string using Run-Length Decoding. :param encoded_str: str, the RLE encoded data. :return: str, the original data. if not encoded_str: return \\"\\" decoded_str = [] count = \\"\\" for char in encoded_str: if char.isdigit(): count += char else: decoded_str.append(char * int(count)) count = \\"\\" return \'\'.join(decoded_str)"},{"question":"# Question: Convert BST to DLL Given a Binary Search Tree (BST), the task is to convert it into a Doubly Linked List (DLL) in which nodes are ordered based on their in-order traversal. The left and right pointers in the original BST should be used as the previous and next pointers in the DLL, respectively. Function Signature ```python def bst_to_dll(root: TreeNode) -> TreeNode: pass ``` Input - `root` : The root node of the BST. The `TreeNode` class is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output - Return the head node of the resulting doubly linked list. Example ```python # Example Usage root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) head = bst_to_dll(root) current = head while current: print(current.val, end=\' \') current = current.right # Output: 1 2 3 4 5 ``` Constraints 1. The number of nodes in the tree is in the range [0, 1000]. 2. The value of each node is in the range [-10^4, 10^4]. Performance Requirements The solution should operate in O(n) time complexity, where n is the number of nodes in the tree. Hints 1. Consider the properties of in-order traversal. 2. Handle the base case of an empty tree. 3. Recursively link the nodes in in-order and manage pointers for DLL.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_to_dll(root: TreeNode) -> TreeNode: # Internal recursive function to perform in-order traversal and link nodes in a DLL def inorder(node): nonlocal head, prev if not node: return # Recurse on left subtree inorder(node.left) # Link current node if prev: prev.right = node node.left = prev else: head = node # Initialize head of the DLL prev = node # Move prev to current node # Recurse on right subtree inorder(node.right) if not root: return None head = None # Pointer to the head of the DLL prev = None # Pointer to the previous node in the DLL inorder(root) return head"},{"question":"You are tasked with creating an enhanced version of a doubly linked list to manage a dynamic playlist for a music application. The playlist should allow for efficient insertions and deletions, as well as the ability to jump to the next or previous song. Requirements: 1. Implement a class `DoublyLinkedList` with the following methods: * `insert_at_head(value)`: Inserts a new node with the given value at the head of the list. * `insert_at_tail(value)`: Inserts a new node with the given value at the tail of the list. * `delete_node(value)`: Deletes the first node with the specified value. * `find_node(value)`: Finds and returns the node with the specified value. Returns `None` if not found. * `play_next(current_node)`: Returns the next node from the current node. Returns `None` if at the end of the list. * `play_prev(current_node)`: Returns the previous node from the current node. Returns `None` if at the beginning of the list. 2. Handle all relevant edge cases, such as inserting or deleting in an empty list. 3. Assume that each song is represented by a unique name as the `value` in each node. Input and Output Formats: - **`insert_at_head(value)`**: * Input: String representing the song name. * Output: None - **`insert_at_tail(value)`**: * Input: String representing the song name. * Output: None - **`delete_node(value)`**: * Input: String representing the song name to be deleted. * Output: None - **`find_node(value)`**: * Input: String representing the song name. * Output: The `DoublyLinkedListNode` containing the song name, or `None` if not found. - **`play_next(current_node)`**: * Input: The `DoublyLinkedListNode` representing the current song. * Output: The `DoublyLinkedListNode` representing the next song, or `None` if at the end of the list. - **`play_prev(current_node)`**: * Input: The `DoublyLinkedListNode` representing the current song. * Output: The `DoublyLinkedListNode` representing the previous song, or `None` if at the beginning of the list. **Constraints**: 1. Ensure optimal performance where applicable. 2. The playlist should handle up to 10,000 songs. 3. No duplicate song names are allowed in the list. Submit your implementation of the `DoublyLinkedList` class along with the necessary methods.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = DoublyLinkedListNode(value) if not self.head: # If the list is empty self.head = new_node self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_tail(self, value): new_node = DoublyLinkedListNode(value) if not self.tail: # If the list is empty self.head = new_node self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_node(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return current = current.next def find_node(self, value): current = self.head while current: if current.value == value: return current current = current.next return None def play_next(self, current_node): return current_node.next def play_prev(self, current_node): return current_node.prev"},{"question":"Identifying Strongly Connected Components As a software engineer, you have been tasked with creating a component that identifies all strongly connected components (SCCs) in a directed graph. This is useful for analyzing dependencies within a system. You are to implement Tarjan\'s Algorithm that computes all SCCs of a directed graph efficiently. Function Signature: ```python class DirectedGraph: # Initialization and necessary methods are assumed to be implemented here # Example methods: # - __init__(self, dict_graph): Initializes the graph with the given adjacency list # - add_edge(self, from_vertex, to_vertex): Adds a directed edge from `from_vertex` to `to_vertex` def find_strongly_connected_components(graph: DirectedGraph) -> List[List[int]]: pass ``` Input: * **graph**: An instance of `DirectedGraph` which encapsulates the graph\'s structure using an adjacency list. Output: * **List[List[int]]**: A list containing SCCs. Each SCC is a list of node indices, sorted in ascending order. Constraints: * The graph may contain up to (10^4) nodes and (10^5) edges. * Node indices are non-negative integers. * Each SCC should be listed in the result, and the SCCs themselves should be sorted by their smallest node. Context: Imagine you are analyzing a set of web pages where each page has links to other pages. Identifying SCCs can help in understanding clusters of closely connected pages. Example: ```python # Example Graph: # Graph: # 0 --> 1 # 1 --> 2 # 2 --> 0 # 1 --> 3 # 3 --> 4 graph = DirectedGraph({ 0: [1], 1: [2, 3], 2: [0], 3: [4], 4: [] }) result = find_strongly_connected_components(graph) # Expected Output: [[0, 1, 2], [3], [4]] # Explanation: # - Nodes 0, 1, 2 form an SCC because they can reach each other. # - Node 3 forms its own SCC. # - Node 4 forms its own SCC. ``` Implement the `find_strongly_connected_components` function using Tarjan’s algorithm as described.","solution":"class DirectedGraph: def __init__(self, dict_graph): self.graph = dict_graph def find_strongly_connected_components(graph: DirectedGraph): index = 0 stack = [] indices = {} low_link = {} on_stack = set() sccs = [] def strongconnect(node): nonlocal index indices[node] = index low_link[node] = index index += 1 stack.append(node) on_stack.add(node) for neighbor in graph.graph.get(node, []): if neighbor not in indices: strongconnect(neighbor) low_link[node] = min(low_link[node], low_link[neighbor]) elif neighbor in on_stack: low_link[node] = min(low_link[node], indices[neighbor]) if low_link[node] == indices[node]: scc = [] while True: w = stack.pop() on_stack.remove(w) scc.append(w) if w == node: break sccs.append(sorted(scc)) for node in graph.graph: if node not in indices: strongconnect(node) sccs.sort(key=lambda x: min(x)) return sccs"},{"question":"Advanced Knapsack Problem You are a treasure hunter and you have found a magical bag that can hold up to a certain weight capacity. Given a set of items, each with a specific value and weight, your objective is to figure out the maximum value of items that you can carry in your magical bag. However, there is a twist: this time, some items can have zero weight but still have a positive value. To solve this problem, write a function `advanced_knapsack` that determines the maximum value that can fit into the knapsack without exceeding the weight capacity. Function Signature ```python def advanced_knapsack(items: List[Tuple[int, int]], capacity: int) -> int: pass ``` Input * `items`: A list of tuples where each tuple contains two integers (value, weight) representing the value and weight of an item. * `capacity`: An integer representing the maximum weight the knapsack can hold. Constraints: * (0 leq text{len(items)} leq 1000) * (0 leq text{capacity} leq 1000) * (0 leq text{value}, text{weight} leq 1000) Output * Return an integer representing the maximum value that can fit into the knapsack. Example ```python # Example 1 items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 assert advanced_knapsack(items, capacity) == 80 # Example 2 items = [(100, 0), (50, 3), (20, 2)] capacity = 2 assert advanced_knapsack(items, capacity) == 120 ``` **Note**: In the second example, the item valued 100 can be added to the knapsack even though the capacity is 2 because its weight is 0. Make sure your solution handles edge cases effectively, such as: * When all items have zero value. * When the capacity of the knapsack is zero. * When some items have zero weight but non-zero value.","solution":"from typing import List, Tuple def advanced_knapsack(items: List[Tuple[int, int]], capacity: int) -> int: n = len(items) dp = [0] * (capacity + 1) for value, weight in items: if weight == 0: for w in range(capacity + 1): dp[w] += value else: for w in range(capacity, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return max(dp)"},{"question":"Context Imagine you are responsible for implementing a sorting mechanism for a basic toy project where you need to sort a list of integer toy IDs. Task Write a function `custom_sort(arr: List[int]) -> List[int]` that sorts a given list of integers using the Gnome Sort algorithm. Your implementation must: * Return a new list where the items are sorted in non-decreasing order. * Handle the typical edge cases such as an empty list or a list with one element gracefully. **Input Format** * A single list of integers `arr` where `1 <= len(arr) <= 10^3` and the values within the list are between `-10^6` and `10^6`. **Output Format** * A list of integers sorted in non-decreasing order. **Constraints** * The function should run efficiently for the given input size. * You may assume that the input list will always be valid (i.e., contain integers). **Example** ```python custom_sort([34, 2, 10, -9]) # Output: [-9, 2, 10, 34] custom_sort([]) # Output: [] custom_sort([1]) # Output: [1] custom_sort([3, 3, 3, 3]) # Output: [3, 3, 3, 3] custom_sort([10, -1, 7, 5, 2]) # Output: [-1, 2, 5, 7, 10] ``` Additional Requirements Provide a brief justification of why Gnome Sort is suitable or unsuitable for very large datasets.","solution":"def custom_sort(arr): Sorts a given list of integers using the Gnome Sort algorithm and returns a new sorted list. if not arr: # Handling edge case for empty array return [] arr = arr[:] # Creating a copy of the array to avoid modifying the original list pos = 0 while pos < len(arr): if pos == 0 or arr[pos] >= arr[pos - 1]: pos += 1 else: arr[pos], arr[pos - 1] = arr[pos - 1], arr[pos] pos -= 1 return arr # Justification: # Gnome Sort is simple to implement and works quite similarly to insertion sort, but # its time complexity is worse when compared to more efficient algorithms like Merge Sort or Quick Sort. # It performs adequately on small datasets, but for large datasets, it becomes inefficient # due to its worst-case time complexity of O(n^2). This makes it unsuitable for very large datasets # that require better performance with regard to time complexity."},{"question":"# Multiply Large Numbers Represented as Strings You are asked to implement a function that multiplies two very large non-negative integers represented as strings. The task is to compute the product without using any built-in libraries for handling large integers and without converting the inputs directly to integers. Function Signature ```python def multiply_large_numbers(num1: str, num2: str) -> str: ``` # Input * `num1` (string): A non-negative integer represented as a string. The length of num1 is less than 110. * `num2` (string): A non-negative integer represented as a string. The length of num2 is less than 110. # Output * Returns a string representing the product of the two input numbers. # Constraints * Both `num1` and `num2` contain only digits `0-9`. * Both `num1` and `num2` do not contain any leading zeros. # Example ```python # Example 1 num1 = \\"123\\" num2 = \\"456\\" # The product is \\"56088\\" assert multiply_large_numbers(num1, num2) == \\"56088\\" # Example 2 num1 = \\"9\\" num2 = \\"9\\" # The product is \\"81\\" assert multiply_large_numbers(num1, num2) == \\"81\\" # Example 3 num1 = \\"123456789\\" num2 = \\"987654321\\" # The product is \\"121932631112635269\\" assert multiply_large_numbers(num1, num2) == \\"121932631112635269\\" ``` # Explanation You will need to implement the multiplication manually by simulating the process of elementary school multiplication. The intermediary results should be correctly summed considering their positional weights. Consider edge cases such as: * One or both numbers being zero (which should return zero). * The largest possible input sizes. * Handling all digits correctly without overflow of standard data types. # Additional Notes * Optimize your solution to run within the constraints.","solution":"def multiply_large_numbers(num1: str, num2: str) -> str: # Check for zero multiplication if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" # Initialize result as a list of zeroes for the maximum possible length result = [0] * (len(num1) + len(num2)) # Reverse the numbers to simplify position handling num1 = num1[::-1] num2 = num2[::-1] # Multiply each digit and add to the result for i in range(len(num1)): for j in range(len(num2)): result[i + j] += int(num1[i]) * int(num2[j]) result[i + j + 1] += result[i + j] // 10 # Carry over to next digit position result[i + j] %= 10 # Remove leading zeros while len(result) > 1 and result[-1] == 0: result.pop() # Join result and reverse it to form the final string result = result[::-1] return \'\'.join(map(str, result))"},{"question":"# Context Given an array of integers, you need to reorder it so that it creates a zigzag pattern: nums[0] < nums[1] > nums[2] < nums[3] > .... # Task Write a function `wiggle_sort` to reorder the given array so that it follows the zigzag pattern. # Function Signature ```python def wiggle_sort(nums: List[int]) -> None: # your code here ``` # Input * A list of integers `nums` where 1 ≤ len(nums) ≤ 10^5 and the elements of `nums` may include positive, negative integers, and duplicates. # Output * The function should modify the list in place with no return value. # Constraints * The algorithm should ideally work in O(n) time complexity. * Modify the array in place; do not use extra space. # Example ```python example = [3, 5, 2, 1, 6, 4] wiggle_sort(example) print(example) # Possible output: [3, 5, 1, 6, 2, 4] ``` # Edge Cases Consider arrays with: * Less than or equal to 2 elements. * All identical numbers. # Performance Requirements Your function should be efficient in both time (O(n)) and space (O(1)) complexities.","solution":"from typing import List def wiggle_sort(nums: List[int]) -> None: Modifies the list in place to satisfy the wiggle pattern: nums[0] < nums[1] > nums[2] < nums[3] > ... for i in range(len(nums) - 1): if i % 2 == 0: if nums[i] > nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i] else: if nums[i] < nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"# Krishnamurthy Number Checker Scenario: You are working on a number puzzle game where players need to identify special numbers with unique properties. A Krishnamurthy number is a special number where the sum of the factorials of its digits equals the number itself. You need to write a function to check this property. Task: Implement the function `krishnamurthy_number(n)` that verifies if a given number `n` is a Krishnamurthy number. Use the helper function `find_factorial(n)` to calculate the factorial of individual digits. Function Signature: ```python def krishnamurthy_number(n): # your code here def find_factorial(n): Calculates the factorial of a given number n # your code here ``` Input: * **n** (int): A non-negative integer which you need to check. Output: * **boolean**: `True` if `n` is a Krishnamurthy number, `False` otherwise. Constraints: * `0 <= n <= 10^7` Examples: 1. `krishnamurthy_number(145)` -> `True` (1! + 4! + 5! = 145) 2. `krishnamurthy_number(40785)` -> `True` (4! + 0! + 7! + 8! + 5! = 40585) 3. `krishnamurthy_number(357)` -> `False` (3! + 5! + 7! != 357) 4. `krishnamurthy_number(1)` -> `True` (1! = 1) Guidelines: 1. **Factorial Calculation**: Ensure that `find_factorial(n)` correctly computes the factorial. 2. **Efficient Summation**: Optimize for repeated computation of factorial values. 3. **Edge Cases**: Account for numbers with several digits and validate outcomes accordingly. Additional Notes: Precompute factorials of the digits 0-9 to avoid recalculating them repeatedly, which can speed up the computation.","solution":"def find_factorial(n): Calculates the factorial of a given number n. if n == 0 or n == 1: return 1 factorial = 1 for i in range(2, n + 1): factorial *= i return factorial def krishnamurthy_number(n): Checks if n is a Krishnamurthy number. def compute_digit_factorials(number): # Define a lookup table for factorial values of digits 0-9 factorial_lookup = {i: find_factorial(i) for i in range(10)} sum_factorials = 0 while number > 0: digit = number % 10 sum_factorials += factorial_lookup[digit] number //= 10 return sum_factorials return n == compute_digit_factorials(n)"},{"question":"# Custom Path/URL Joiner Function **Objective**: Write a function `join_with_slash` that combines a base path or URL with a suffix string while ensuring correct formatting by managing the presence of redundant slashes. **Function Signature**: ```python def join_with_slash(base: str, suffix: str) -> str: pass ``` **Parameters**: * `base` (str): A base string representing the initial part of the path or URL. * `suffix` (str): The suffix string representing the remaining part to be appended. **Returns**: * Returns a combined string representing the correctly formatted path or URL. **Constraints**: * Inputs will be non-null strings. * Inputs might contain leading or trailing white spaces. * The function should handle edge cases (described below). * Performance should be efficient even for long strings. **Edge Cases**: 1. If base is an empty string, the result should be the cleaned suffix. 2. If suffix is an empty string, the result should be the cleaned base. 3. If either or both inputs contain only slashes, they should be combined correctly without excessive slashes. 4. Should handle strings with leading, trailing, or internal white spaces appropriately. **Scenario**: You are designing a web application where you need to dynamically construct URLs for different API endpoints. Properly formatting these URLs by avoiding redundant slashes is critical for making successful API requests. Your task is to ensure that the composed URLs are always correctly formatted regardless of how the base URL and endpoint suffix are provided. **Example**: ```python assert join_with_slash(\\"http://algorithms.com\\", \\"part\\") == \\"http://algorithms.com/part\\" assert join_with_slash(\\"http://algorithms.com/\\", \\"part\\") == \\"http://algorithms.com/part\\" assert join_with_slash(\\"path/to/\\", \\"/dir\\") == \\"path/to/dir\\" assert join_with_slash(\\"\\", \\"file\\") == \\"file\\" assert join_with_slash(\\"path/to/base\\", \\"\\") == \\"path/to/base\\" ``` Write the complete function `join_with_slash` fulfilling the requirements outlined above.","solution":"def join_with_slash(base: str, suffix: str) -> str: Combine a base path or URL with a suffix string while ensuring correct formatting by managing the presence of redundant slashes. base = base.strip() suffix = suffix.strip() if not base: return suffix if not suffix: return base if base.endswith(\'/\') and suffix.startswith(\'/\'): return base.rstrip(\'/\') + \'/\' + suffix.lstrip(\'/\') elif base.endswith(\'/\') or suffix.startswith(\'/\'): return base + suffix else: return base + \'/\' + suffix"},{"question":"# Conversion between Integers and Byte Arrays (Endianness) **Context**: In systems programming and network protocols, data often needs to be converted between different byte order representations for proper communication and storage. Understanding how to efficiently convert data between integer and byte array representations in big-endian and little-endian formats is crucial. Task Implement two functions: 1. `convert_big_to_little_endian(bytestr: bytes) -> bytes`: Converts a byte array from big-endian to little-endian format. 2. `convert_little_to_big_endian(bytestr: bytes) -> bytes`: Converts a byte array from little-endian to big-endian format. Input/Output * **Input**: * `bytestr`: A byte array (`bytes` type in Python) representing an integer in either big-endian or little-endian format. * **Output**: * Return a new byte array (`bytes` type in Python) representing the integer in the target endianness. Constraints * Input byte array can contain between 1 and 32 bytes (inclusive). Performance Requirements * Ensure that your implementation runs efficiently with a linear time complexity relative to the number of bytes. * Minimize additional space usage. Example ```python # Big-endian to Little-endian input_bytes_big = bytes([0x12, 0x34, 0x56, 0x78]) output_bytes_little = convert_big_to_little_endian(input_bytes_big) print(list(output_bytes_little)) # Should print [0x78, 0x56, 0x34, 0x12] # Little-endian to Big-endian input_bytes_little = bytes([0x78, 0x56, 0x34, 0x12]) output_bytes_big = convert_little_to_big_endian(input_bytes_little) print(list(output_bytes_big)) # Should print [0x12, 0x34, 0x56, 0x78] ``` Implement the functions `convert_big_to_little_endian` and `convert_little_to_big_endian` as specified above.","solution":"def convert_big_to_little_endian(bytestr: bytes) -> bytes: Converts a byte array from big-endian to little-endian format. Parameters: - bytestr (bytes): The input byte array in big-endian format. Returns: - bytes: The byte array converted to little-endian format. return bytestr[::-1] def convert_little_to_big_endian(bytestr: bytes) -> bytes: Converts a byte array from little-endian to big-endian format. Parameters: - bytestr (bytes): The input byte array in little-endian format. Returns: - bytes: The byte array converted to big-endian format. return bytestr[::-1]"},{"question":"# **Problem Description** In this problem, you are required to implement a function to decode a given encoded string. The encoding rule follows a pattern `k[encoded_string]`, where the `encoded_string` inside the square brackets will be repeated exactly `k` times. Here, `k` is guaranteed to be a positive integer. Input: * A string `s` containing the encoded message, which consists of lower-case English letters, digits, and square brackets. * The input is always well-formed, meaning no extraneous whitespace and all brackets are balanced correctly. Output: * A decoded string after processing the encoded pattern in the input. Constraints: * The length of string ( s ) will be in the range `[1, 30]`. * The string does not contain any digits outside of the repetition counts. Examples: 1. `decode_string(\\"3[a]2[bc]\\")` should return `\\"aaabcbc\\"`. 2. `decode_string(\\"3[a2[c]]\\")` should return `\\"accaccacc\\"`. 3. `decode_string(\\"2[abc]3[cd]ef\\")` should return `\\"abcabccdcdcdef\\"`. Implement the function `decode_string(s)` as specified.","solution":"def decode_string(s: str) -> str: stack = [] current_string = \\"\\" current_num = 0 for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append(current_string) stack.append(current_num) current_string = \\"\\" current_num = 0 elif char == \']\': num = stack.pop() prev_string = stack.pop() current_string = prev_string + num * current_string else: current_string += char return current_string"},{"question":"Pathfinding in Graph **Context**: You are designing a navigation system for a city\'s public transport network represented as a graph. Each node represents a station, and each edge represents a direct route between two stations. **Task**: Implement a function using the given graph traversal methods to determine specific paths within the city\'s transport network. **Function Description**: You need to implement the following function: ```python def find_paths(graph, start, end): Finds and returns two types of paths in the transport network: 1. Any valid path from start to end, if it exists. 2. The shortest path from start to end, if it exists. Args: graph (dict): A dictionary representing the graph where keys are station names, and values are lists of directly connected stations. start (str): The starting station. end (str): The destination station. Returns: tuple: A tuple containing two elements: 1. A list representing any valid path from start to end. 2. A list representing the shortest path from start to end. If no path exists for either case, return None for that path. pass ``` # Constraints: - The graph is a dictionary where the keys are station names (strings), and values are lists of station names directly connected to the key station. - Each station name is unique. - `start` and `end` will always be valid station names within the graph. # Examples: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } result = find_paths(graph, \'A\', \'F\') print(result) # Output: ([\'A\', \'C\', \'F\'], [\'A\', \'C\', \'F\']) ``` # Performance requirements: - Your solution should handle graphs with up to 1000 nodes efficiently. # Additional Notes: * Ensure that your implementation considers edge cases such as disconnected nodes and cycles within the graph.","solution":"from collections import deque def find_paths(graph, start, end): Finds and returns two types of paths in the transport network: 1. Any valid path from start to end, if it exists. 2. The shortest path from start to end, if it exists. Args: graph (dict): A dictionary representing the graph where keys are station names, and values are lists of directly connected stations. start (str): The starting station. end (str): The destination station. Returns: tuple: A tuple containing two elements: 1. A list representing any valid path from start to end. 2. A list representing the shortest path from start to end. If no path exists for either case, return None for that path. def bfs_find_any_path(graph, start, end): visited = set() queue = deque([[start]]) while queue: path = queue.popleft() node = path[-1] if node == end: return path if node not in visited: visited.add(node) for neighbor in graph.get(node, []): new_path = list(path) new_path.append(neighbor) queue.append(new_path) return None def bfs_find_shortest_path(graph, start, end): visited = set() queue = deque([[start]]) while queue: path = queue.popleft() node = path[-1] if node == end: return path if node not in visited: visited.add(node) for neighbor in graph.get(node, []): new_path = list(path) new_path.append(neighbor) queue.append(new_path) return None any_path = bfs_find_any_path(graph, start, end) shortest_path = bfs_find_shortest_path(graph, start, end) return (any_path, shortest_path)"},{"question":"# Anagram Detection with Extended Character Set In this task, you are to implement a function that checks if two strings are anagrams of each other. An anagram is a word formed by rearranging the characters of another, such as \\"listen\\" and \\"silent.\\" The strings may contain not only lowercase English letters but also uppercase letters and special characters. # Requirements: - Your function should be case-insensitive (i.e., \'A\' and \'a\' should be treated as the same character). - Characters other than English alphabets should be ignored. # Function Signature: ```python def extended_anagram(s1: str, s2: str) -> bool: ``` # Input: - `s1`: A string - `s2`: A string # Output: - Return `True` if `s1` and `s2` are anagrams after normalizing case and ignoring non-alphabetic characters, `False` otherwise. # Examples: ```python print(extended_anagram(\\"Astronomer\\", \\"Moon starer\\")) # True print(extended_anagram(\\"Hello, World!\\", \\"Dolor wheLl\\")) # True print(extended_anagram(\\"apple\\", \\"papel\\")) # True print(extended_anagram(\\"apple\\", \\"appeal\\")) # False ``` # Constraints: - Consider the length of the strings within reasonable limits for manual testing. - Do not assume a fixed length for the input strings. # Implementation Notes: - Normalize the strings by converting them to lowercase and removing non-alphabetic characters. - Compare the character frequencies for the normalized strings.","solution":"def extended_anagram(s1: str, s2: str) -> bool: Returns True if s1 and s2 are anagrams of each other, ignoring case and non-alphabet characters. from collections import Counter import re # Function to normalize strings def normalize_string(s): return re.sub(r\'[^a-z]\', \'\', s.lower()) # Normalize both strings normalized_s1 = normalize_string(s1) normalized_s2 = normalize_string(s2) # Compare character counts return Counter(normalized_s1) == Counter(normalized_s2)"},{"question":"Strongly Connected Graph Detection You are provided with a `Graph` class which can be used to create a directed graph with a given number of vertices and edges. Your task is to implement a functionality to determine if the graph is strongly connected, i.e., from any vertex `u`, you can reach any other vertex `v` and vice versa. Function Signature ```python class Graph: def __init__(self, vertex_count): # Initialize the graph with the given vertex count pass def add_edge(self, source, target): # Add an edge from source to target pass def is_strongly_connected(self): # Implement the function to check if the graph is strongly connected pass ``` Constraints * The number of vertices `V` will be in the range [1, 1000]. * The number of edges `E` will be in the range [0, 5000]. * Vertices are numbered from `0` to `V-1`. Input You do not have to handle input as this is already encapsulated within the graph class methods. All input interactions will be through method calls. Output * Return `True` if the graph is strongly connected, otherwise return `False`. Example ```python g = Graph(5) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(1, 3) g.add_edge(3, 4) g.add_edge(4, 1) # The graph is strongly connected, so it should return True print(g.is_strongly_connected()) # Output: True g2 = Graph(4) g2.add_edge(0, 1) g2.add_edge(1, 2) g2.add_edge(2, 3) # The graph is not strongly connected, so it should return False print(g2.is_strongly_connected()) # Output: False ``` Your task is to complete the implementation of the `Graph` class, ensuring that the `is_strongly_connected` function accurately determines whether the graph is strongly connected.","solution":"class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.adj_list = [[] for _ in range(vertex_count)] def add_edge(self, source, target): self.adj_list[source].append(target) def _dfs(self, v, visited): visited[v] = True for u in self.adj_list[v]: if not visited[u]: self._dfs(u, visited) def _get_transpose(self): g_t = Graph(self.vertex_count) for v in range(self.vertex_count): for u in self.adj_list[v]: g_t.add_edge(u, v) return g_t def is_strongly_connected(self): # Step 1: Perform DFS from any vertex visited = [False] * self.vertex_count self._dfs(0, visited) # Check if all vertices are visited if not all(visited): return False # Step 2: Compute the transpose of the graph g_t = self._get_transpose() # Step 3: Perform DFS on the transposed graph starting from the same vertex visited = [False] * self.vertex_count g_t._dfs(0, visited) # Check if all vertices are visited in the transposed graph return all(visited)"},{"question":"# Coding Challenge: Enhanced Bubble Sort Context Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. Although it is not suitable for large datasets due to its O(n^2) complexity, it allows us to demonstrate fundamental concepts of sorting algorithms. You are required to implement an enhanced version of Bubble Sort that can handle not only numeric arrays but also arrays of string values by sorting them lexicographically. Furthermore, you need to add functionality to handle descending order sorting. Task Write a function `enhanced_bubble_sort(arr, order=\'asc\', data_type=\'numeric\')` that sorts an array in ascending or descending order. It should handle both numeric and string data types. Input * `arr` - A list of integers, floats, or strings. * `order` - A string that specifies the sorting order; either \'asc\' for ascending or \'desc\' for descending. Default is \'asc\'. * `data_type` - A string that specifies the type of data in the list; either \'numeric\' for numbers or \'string\' for string values. Default is \'numeric\'. Output * The sorted array in the specified order. Constraints * The array `arr` can be empty, or contain up to (10^3) elements. * If `data_type` is \'numeric\', array elements can be integers or floats. * If `data_type` is \'string\', array elements can be any strings. Examples ```python assert enhanced_bubble_sort([4, 2, 3, 1], order=\'asc\', data_type=\'numeric\') == [1, 2, 3, 4] assert enhanced_bubble_sort([\\"banana\\", \\"apple\\", \\"cherry\\"], order=\'asc\', data_type=\'string\') == [\\"apple\\", \\"banana\\", \\"cherry\\"] assert enhanced_bubble_sort([4, 2, 3, 1], order=\'desc\', data_type=\'numeric\') == [4, 3, 2, 1] assert enhanced_bubble_sort([\\"banana\\", \\"apple\\", \\"cherry\\"], order=\'desc\', data_type=\'string\') == [\\"cherry\\", \\"banana\\", \\"apple\\"] assert enhanced_bubble_sort([], order=\'asc\', data_type=\'numeric\') == [] ``` Notes * Provide clear and efficient code. * Handle all edge cases. * Ensure proper documentation and comments in your code. Good luck!","solution":"def enhanced_bubble_sort(arr, order=\'asc\', data_type=\'numeric\'): Sorts an array in ascending or descending order. It handles both numeric and string data types. Parameters: arr (list): The list of elements to be sorted. Can be numeric or string. order (str): The sorting order, either \'asc\' for ascending or \'desc\' for descending. Default is \'asc\'. data_type (str): The type of data in the list, either \'numeric\' for numbers or \'string\' for strings. Default is \'numeric\'. Returns: list: The sorted array in the specified order. n = len(arr) for i in range(n): for j in range(0, n-i-1): if order == \'asc\': if data_type == \'numeric\' and arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] elif data_type == \'string\' and arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] elif order == \'desc\': if data_type == \'numeric\' and arr[j] < arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] elif data_type == \'string\' and arr[j] < arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr"},{"question":"# FizzBuzz Custom Extension **Scenario**: You are given the task of designing a variant of the FizzBuzz problem. Instead of specified multiples, you have to allow customizable multiples and corresponding words. Implement a function that, given a range from 1 to N, and a list of tuples where each tuple contains a divisor and a corresponding word, returns a list in which: - Numbers divisible by any of the provided divisors are replaced by their associated words. - If a number is divisible by more than one of the provided divisors, concatenate the corresponding words in the given tuple order. - If a number is not divisible by any provided divisor, include the number itself. **Function Signature**: ```python def custom_fizzbuzz(n: int, rules: List[Tuple[int, str]]) -> List[Union[int, str]]: ``` **Input**: - An integer `n` (1 <= n <= 10^6), the end range. - A list of tuples `rules`, where each tuple consists of an integer divisor and a corresponding string. Each divisor is a positive integer. **Output**: - A list of length `n` where each list element follows the above rules. **Constraints**: - `n` will always be at least 1. - The `rules` list will contain at least one rule and each rule will have valid values. **Example**: ```python # Example 1 n = 15 rules = [(3, \\"Fizz\\"), (5, \\"Buzz\\")] print(custom_fizzbuzz(n, rules)) # Output: [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] # Example 2 n = 10 rules = [(2, \\"Foo\\"), (3, \\"Bar\\")] print(custom_fizzbuzz(n, rules)) # Output: [1, \\"Foo\\", \\"Bar\\", \\"Foo\\", 5, \\"FooBar\\", 7, \\"Foo\\", \\"Bar\\", \\"Foo\\"] ```","solution":"def custom_fizzbuzz(n, rules): result = [] for i in range(1, n + 1): output = \\"\\" for divisor, word in rules: if i % divisor == 0: output += word if not output: output = i result.append(output) return result"},{"question":"You are tasked with implementing a function to filter out recurring characters from a given string. The function must preserve the order of the first occurrence of each character and return a new string with these characters only. Function Signature ```python def delete_reoccurring_characters(string: str) -> str: ``` # Input * `string`: A string, `1 <= len(string) <= 10^5`, consisting of ASCII characters. # Output * Return a new string consisting of characters from the input string such that each character appears only once, preserving their first occurrence in the input. # Examples ```python delete_reoccurring_characters(\\"ababcabcd\\") -> \\"abcd\\" delete_reoccurring_characters(\\"hello\\") -> \\"helo\\" delete_reoccurring_characters(\\"swiss\\") -> \\"swi\\" delete_reoccurring_characters(\\"\\") -> \\"\\" ``` # Constraints * The function must run in O(n) time complexity. * The function must use O(n) additional space in the worst case. # Edge Cases * An empty string should return an empty string. * Strings where all characters are unique should return the original string. * Strings where all characters are the same should return a string with a single character.","solution":"def delete_reoccurring_characters(string: str) -> str: Returns a new string with recurring characters removed, preserving the order of their first occurrence. Parameters: string (str): The input string consisting of ASCII characters. Returns: str: A new string with only the first non-reoccurring characters. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Unique Element Detection Using Bitwise Operations You are given an array of integers where each element appears exactly three times except for one element, which appears exactly once. Implement a function `find_unique_element(nums)` that identifies the element which appears only once. Input - `nums`: A list of integers where each integer appears exactly three times except for one, which appears only once. The length of `nums` is guaranteed to be greater than 1. Output - Return a single integer representing the unique element that appears once in the array. Constraints - Your algorithm should have a linear runtime complexity, i.e., O(n). - You should not use any extra memory beyond a couple of integer variables. Example ```python assert find_unique_element([2, 2, 3, 2]) == 3 assert find_unique_element([0, 1, 0, 1, 0, 1, 99]) == 99 ``` Write a well-optimized and thorough function `find_unique_element(nums)` that adheres to the described criteria. Make sure to handle edge cases and explain the logic behind your implementation.","solution":"def find_unique_element(nums): This function finds the unique element in the list where every other element appears exactly three times. Args: nums (list): A list of integers where each integer appears exactly three times except for one. Returns: int: The integer that appears only once. ones, twos = 0, 0 for num in nums: # First toggle `ones` with current number and then AND it with inverted `twos` ones = (ones ^ num) & ~twos # First toggle `twos` with current number and then AND it with inverted `ones` twos = (twos ^ num) & ~ones return ones"},{"question":"Context: You are tasked with enhancing the security comment filtering system for a social media application. Specifically, you need to create a function that reverses only the vowels in user comments, while leaving consonants and other characters in their original positions. This will help in anonymizing sensitive comments based on predefined patterns. Problem Statement: Write a function `reverse_vowels(s: str) -> str` that takes a string `s` as input and returns a new string where only the vowels (a, e, i, o, u both uppercase and lowercase) are reversed. Requirements: 1. **Input**: A single string `s` (0 <= len(s) <= 1000). 2. **Output**: A new string with the vowels reversed in order while other characters remain unchanged. 3. **Constraints**: - The function should handle both empty strings and strings without any vowels gracefully. - The performance should be optimized for long strings with infrequent vowels. Examples: ```python reverse_vowels(\\"hello\\") # Returns \\"holle\\" reverse_vowels(\\"leetcode\\") # Returns \\"leotcede\\" reverse_vowels(\\"aA\\") # Returns \\"Aa\\" reverse_vowels(\\"\\") # Returns \\"\\" reverse_vowels(\\"bcdfg\\") # Returns \\"bcdfg\\" (no change as there are no vowels) ``` Notes: 1. `reverse_vowels(\\"hello\\")` explanation: \'e\' and \'o\' are the vowels in \\"hello\\". When reversed, \\"hello\\" becomes \\"holle\\". 2. Consider using the two-pointer technique for an efficient solution. 3. Pay attention to edge cases and ensure that your function handles strings of different lengths and contents correctly.","solution":"def reverse_vowels(s: str) -> str: vowels = set(\\"aeiouAEIOU\\") s_list = list(s) left, right = 0, len(s) - 1 while left < right: if s_list[left] in vowels and s_list[right] in vowels: s_list[left], s_list[right] = s_list[right], s_list[left] left += 1 right -= 1 if s_list[left] not in vowels: left += 1 if s_list[right] not in vowels: right -= 1 return \'\'.join(s_list)"},{"question":"Problem Context You are working on a text processing application and need to implement a function to search for a substring within a larger string. Your task is to find the first occurrence of the substring (needle) in the larger string (haystack). Task Implement the function `strStr(haystack, needle)` that returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. Function Signature ```python def strStr(haystack: str, needle: str) -> int: ``` Input * `haystack` (string): The string in which to search for the needle. (0 ≤ len(haystack) ≤ 5 * 10^4) * `needle` (string): The substring to search for in haystack. (0 ≤ len(needle) ≤ 5 * 10^4) Output * An integer representing the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. Constraints * `needle` and `haystack` consist of only lowercase English characters. * If `needle` is an empty string, return 0. Examples 1. **Example 1**: * Input: `haystack = \\"hello\\"`, `needle = \\"ll\\"` * Output: `2` * Explanation: \\"ll\\" is found at index 2 in \\"hello\\". 2. **Example 2**: * Input: `haystack = \\"aaaaa\\"`, `needle = \\"bba\\"` * Output: `-1` * Explanation: \\"bba\\" is not found in \\"aaaaa\\". 3. **Example 3**: * Input: `haystack = \\"\\"`, `needle = \\"\\"` * Output: `0` * Explanation: An empty needle is considered to match at the beginning of the haystack. Requirements * Your solution should handle edge cases efficiently. * Considering performance, try to avoid unnecessary comparisons. * The implementation should not use built-in functions like `str.index()` or `str.find()` to solve the problem directly.","solution":"def strStr(haystack: str, needle: str) -> int: Returns the first occurrence of needle in haystack, or -1 if needle is not part of haystack. # Edge case: if needle is an empty string, return 0 if not needle: return 0 # Length of haystack and needle haystack_len = len(haystack) needle_len = len(needle) # If needle is longer than haystack, needle can\'t be in haystack if needle_len > haystack_len: return -1 # Check each position in haystack to see if needle starts there for i in range(haystack_len - needle_len + 1): if haystack[i:i+needle_len] == needle: return i return -1"},{"question":"You are given a list of numeric scores representing performance scores of athletes and a percentage value that indicates how many extreme values (high and low) should be excluded from the mean calculation. Your task is to implement a function that calculates the trimmed mean, a robust measure of central tendency. # Function Signature: ```python def calculate_trimmed_mean(scores: List[int], percentage: float) -> float: pass ``` # Input: - **scores** (List[int]): A list of integers representing the performance scores of athletes. It is guaranteed that the list has at least 3 elements. - **percentage** (float): A float value between 0 and 100 inclusive, representing the percentage of extreme values to exclude from both ends. # Output: - A float representing the trimmed mean of the scores. # Constraints: - The input list will always have at least 3 elements. - The percentage value will be between 0 and 100 inclusive. # Example: ```python assert abs(calculate_trimmed_mean([10, 20, 30, 40, 50], 20) - 30.0) < 1e-5 assert abs(calculate_trimmed_mean([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 10) - 55.0) < 1e-5 ``` # Explanation: 1. In the first example, the sorted array is [10, 20, 30, 40, 50]. With a 20% exclusion, we exclude 10% from each end. Thus, exclude 1 (10%) element from the beginning and end, resulting in [20, 30, 40]. The mean of this is 30. 2. In the second example, the sorted array is [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]. With a 10% exclusion, we exclude 10% from each end. Thus, exclude 1 (10%) element from the beginning and end, resulting in [20, 30, 40, 50, 60, 70, 80, 90]. The mean of this is 55. **Note**: Ensure your solution maintains high performance even with large datasets. Consider edge cases where the percentage is 0 or 100 and the given list includes many identical values.","solution":"from typing import List def calculate_trimmed_mean(scores: List[int], percentage: float) -> float: Calculate the trimmed mean of the given performance scores excluding a given percentage of extreme values from both ends. if percentage == 0: return sum(scores) / len(scores) scores.sort() n = len(scores) k = int(n * percentage / 100) # Trim the extreme values trimmed_scores = scores[k:n-k] if not trimmed_scores: return 0 return sum(trimmed_scores) / len(trimmed_scores)"},{"question":"**Shortest Path for Delivery Network** You are working for a delivery company. Your task is to optimize the delivery routes to minimize the travel time between warehouses located in different cities. You want to calculate the shortest travel time between every pair of warehouses. To solve this problem, you have the map of all cities as an adjacency matrix, where each element (i, j) represents the travel time from warehouse i to warehouse j. If there is no direct route between warehouse i and j, the value is set to a large number (e.g., infinity). Implement the Floyd-Warshall algorithm to find the shortest travel time between every pair of warehouses. # Function Signature ```python def calculate_shortest_delivery_routes(adjacency_matrix: List[List[float]]) -> List[List[float]]: pass ``` # Input * `adjacency_matrix`: a 2D list of floats representing the travel time between any pair of vertices. If `adjacency_matrix[i][j]` is a large number (e.g., float(\'inf\')), it means there is no direct route from warehouse i to warehouse j. # Output * Returns a 2D list (matrix) where the element at index (i, j) represents the shortest travel time from warehouse i to j considering all intermediate nodes. # Constraints * The adjacency matrix will always be square (i.e., `n x n`). * `1 <= n <= 200` * `0 <= adjacency_matrix[i][j] <= 1000` or `adjacency_matrix[i][j] = float(\'inf\')` * The diagonal elements of the adjacency matrix are zero (i.e., `adjacency_matrix[i][i] = 0` for all `i`). # Example ```python adjacency_matrix = [ [0, 1, float(\'inf\'), 1], [1, 0, 1, float(\'inf\')], [float(\'inf\'), 1, 0, 1], [1, float(\'inf\'), 1, 0] ] result = calculate_shortest_delivery_routes(adjacency_matrix) # Expected output: # [ # [0, 1, 2, 1], # [1, 0, 1, 2], # [2, 1, 0, 1], # [1, 2, 1, 0] # ] ``` Use the Floyd-Warshall algorithm to implement the function: ```python def calculate_shortest_delivery_routes(adjacency_matrix): import copy dist = copy.deepcopy(adjacency_matrix) n = len(dist) for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist ```","solution":"def calculate_shortest_delivery_routes(adjacency_matrix): import copy dist = copy.deepcopy(adjacency_matrix) n = len(dist) for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist"},{"question":"# Two Sum Problem in Programming Context: You are a part of a development team working on a financial application. One of your tasks is to implement a robust algorithm to identify transactions that collectively sum up to a specific target value. Task: Given an array of integers sorted in ascending order, write a function `two_sum` which returns the 1-based indices of the two numbers such that they add up to a specific target. Ensure the solution is valid for scenarios where input size can vary considerably. Requirements: 1. Implement three versions of the function using different algorithms: * **Binary Search Method**: ```python def two_sum_binary_search(numbers, target): pass # Implement using binary search ``` * **Hash Table Method**: ```python def two_sum_hash_table(numbers, target): pass # Implement using hash table ``` * **Two Pointers Method**: ```python def two_sum_two_pointers(numbers, target): pass # Implement using two pointers ``` 2. Ensure to handle performance, edge cases, and potential error scenarios. Input: ```python numbers: List[int] # Sorted list of integers. target: int # Target sum. ``` Output: ```python List[int] # 1-based indices of the two elements that sum up to the target. ``` Constraints: 1. Each input array will have exactly one solution. 2. Indices returned should be 1-based. 3. The same element cannot be used twice. Example: ```python Input: numbers = [2, 7, 11, 15], target = 9 Output: [index1 = 1, index2 = 2] ``` Utilize suitable algorithms and justify their use based on complexity and use-case effectiveness.","solution":"def two_sum_binary_search(numbers, target): Use binary search to find the two numbers which add up to \'target\'. def binary_search(numbers, start, end, target): low, high = start, end while low <= high: mid = (low + high) // 2 if numbers[mid] == target: return mid elif numbers[mid] < target: low = mid + 1 else: high = mid - 1 return -1 for i in range(len(numbers)): complement = target - numbers[i] j = binary_search(numbers, i + 1, len(numbers) - 1, complement) if j != -1: return [i + 1, j + 1] return [] def two_sum_hash_table(numbers, target): Use hash table to find the two numbers which add up to \'target\'. lookup = {} for i, num in enumerate(numbers): complement = target - num if complement in lookup: return [lookup[complement] + 1, i + 1] lookup[num] = i return [] def two_sum_two_pointers(numbers, target): Use two pointers to find the two numbers which add up to \'target\'. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"# Objective Design a function that implements a string matching algorithm, demonstrating your understanding of the Knuth-Morris-Pratt (KMP) algorithm. # Problem Statement Given two sequences, `text` and `pattern`, write a function `find_pattern_occurrences(text: Sequence[str], pattern: Sequence[str]) -> List[int]` that returns the starting indices of all occurrences of the `pattern` within the `text`. # Expected Implementation - The function should return a list of start indices. - Use the KMP algorithm to achieve linear time complexity. - Construct the partial match table (pi table) efficiently. # Example ```python >>> find_pattern_occurrences(\\"hello there hero!\\", \\"he\\") [0, 7, 12] >>> find_pattern_occurrences(\\"ababcabcabababd\\", \\"ababd\\") [10] ``` # Input and Output Formats - **Input**: - `text`: A sequence of characters (1 <= len(text) <= 10^6). - `pattern`: A sequence of characters (1 <= len(pattern) <= 10^4). - **Output**: - A list of integers representing the starting indices of `pattern` in `text`. # Constraints - The function must operate with `O(N + M)` time complexity. - Handle edge cases where the `text` or `pattern` might be empty. # Guidance - Construct the pi table for the pattern. - Use the pi table to efficiently find all occurrences of the pattern in the text.","solution":"from typing import List, Sequence def kmp_partial_match_table(pattern: Sequence[str]) -> List[int]: Generates the partial match table (pi table) using the pattern. m = len(pattern) pi = [0] * m k = 0 for q in range(1, m): while k > 0 and pattern[k] != pattern[q]: k = pi[k - 1] if pattern[k] == pattern[q]: k += 1 pi[q] = k return pi def find_pattern_occurrences(text: Sequence[str], pattern: Sequence[str]) -> List[int]: Returns the starting indices of all occurrences of `pattern` within `text` using the Knuth-Morris-Pratt algorithm. n = len(text) m = len(pattern) if m == 0 or n == 0: return [] pi = kmp_partial_match_table(pattern) q = 0 # Number of characters matched occurrences = [] for i in range(n): while q > 0 and pattern[q] != text[i]: q = pi[q - 1] if pattern[q] == text[i]: q += 1 if q == m: occurrences.append(i - m + 1) q = pi[q - 1] return occurrences"},{"question":"# Question: Cycle Detection in a Linked List Given a singly linked list, write a function to detect if there is a cycle in the list. If a cycle is detected, return the first node where the cycle begins. Otherwise, return `None`. # Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def detectCycle(head: Node) -> Node: pass ``` # Input - `head`: The head node of a singly linked list. You can assume that each node contains: - An integer value `val`. - A pointer `next`, which points to the next node in the list or `None`. # Output - Returns the first node where the cycle begins if a cycle exists. - Returns `None` if there is no cycle. # Constraints - You must solve the problem using O(1) additional space. # Example ```python # Example 1 # Input: 3 -> 2 -> 0 -> -4 -> (back to 2) # Output: Node with val 2 # Example 2 # Input: 1 -> 2 -> (back to 1) # Output: Node with val 1 # Example 3 # Input: 1 -> None # Output: None ``` # Testing You may use the following code to test your implementation: ```python import unittest class TestSuite(unittest.TestCase): def test_cases(self): # Test case 1 head = Node(3) second = Node(2) third = Node(0) fourth = Node(-4) head.next = second second.next = third third.next = fourth fourth.next = second self.assertEqual(detectCycle(head).val, 2) # Test case 2 head = Node(1) second = Node(2) head.next = second second.next = head self.assertEqual(detectCycle(head).val, 1) # Test case 3 head = Node(1) self.assertEqual(detectCycle(head), None) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def detectCycle(head: Node) -> Node: slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return None slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Counting Unique Binary Search Trees Given an integer n, write a function `num_trees(n)` to calculate the number of structurally unique Binary Search Trees (BSTs) that store values 1...n. Function Signature ```python def num_trees(n: int) -> int: ``` Input * `n` (1 <= n <= 19): An integer representing the range of values to form BSTs. Output * Returns an integer representing the number of structurally unique BSTs that can be formed using values from 1 to n. # Example ```python assert num_trees(1) == 1 assert num_trees(2) == 2 assert num_trees(3) == 5 ``` # Constraints & Notes * The calculation should consider the constraint that larger values of n (close to 20) should be handled efficiently. * Utilize the concepts of dynamic programming to avoid redundant calculations. * Remember to handle base cases explicitly where n = 0 or n = 1. * The expected time complexity is O(n^2) and space complexity is O(n). # Scenario Imagine you are designing a database schema that needs efficient indexing structures for different ranges of keys. Understanding the number of distinct indexing structures (BSTs) you can form with your range of keys helps you plan resource allocation and query performance strategies better. Implement the `num_trees(n)` function to assist in this analysis.","solution":"def num_trees(n): Calculate the number of structurally unique Binary Search Trees (BSTs) that store values 1...n. Args: n (int): The range of values to form BSTs. Returns: int: The number of structurally unique BSTs. # Base case if n == 0 or n == 1: return 1 # dp[i] will store the number of unique BSTs that can be made with i nodes dp = [0] * (n + 1) dp[0] = dp[1] = 1 # Fill the dp array for nodes in range(2, n + 1): for root in range(1, nodes + 1): left = root - 1 # Number of nodes in the left subtree right = nodes - root # Number of nodes in the right subtree dp[nodes] += dp[left] * dp[right] return dp[n]"},{"question":"You are tasked with implementing an optimized Binary Heap data structure, which supports efficient insertion and removal of elements while maintaining the heap property. Specifically, you will implement a min-heap version where the smallest element is always at the root. The heap is represented as a complete binary tree. # Function Signature ```python class BinaryHeap: def __init__(self): # Initialize the heap array with a placeholder for the 0th index pass def insert(self, val: int) -> None: # Inserts a value into the heap pass def remove_min(self) -> int: # Removes and returns the minimum value in the heap pass ``` # Functional Requirements * **insert(val: int) -> None**: * Inserts `val` into the heap and ensures the heap property is maintained. * **Input Constraint**: The value `val` will be a non-negative integer. * **remove_min() -> int**: * Removes and returns the minimum value from the heap and maintains the heap property. * **Output Constraint**: It should raise an `IndexError` if the heap is empty when `remove_min` is called. # Performance Requirements * Ensure both `insert` and `remove_min` methods operate in (O(log N)) time where (N) is the number of elements in the heap. # Example ```python # Example usage heap = BinaryHeap() heap.insert(4) heap.insert(50) heap.insert(7) heap.insert(55) heap.insert(90) heap.insert(87) print(heap.remove_min()) # Should return 4 heap.insert(2) print(heap.remove_min()) # Should return 2 ``` # Notes * The heap is represented as an array, with the 0th index unused. * You should ensure that all internal operations, like `perc_up`, `perc_down`, and `min_child`, maintain the heap property correctly. * Handle edge cases diligently, including operations on an empty heap. Write a clear, efficient, and well-tested implementation based on the given structure.","solution":"class BinaryHeap: def __init__(self): self.heap = [0] # Initialize the heap array with a placeholder for the 0th index self.size = 0 def insert(self, val: int) -> None: self.heap.append(val) self.size += 1 self._perc_up(self.size) def remove_min(self) -> int: if self.size == 0: raise IndexError(\\"remove_min from an empty heap\\") root_val = self.heap[1] self.heap[1] = self.heap[self.size] self.size -= 1 self.heap.pop() if self.size > 0: self._perc_down(1) return root_val def _perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i //= 2 def _perc_down(self, i): while (i * 2) <= self.size: mc = self._min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def _min_child(self, i): if (i * 2 + 1) > self.size: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1"},{"question":"# Context: A database management system (DBMS) uses an index for fast data retrieval. One of the prevalent index structures is the Red-Black tree. To comprehend the underlying mechanics, you have to implement a Red-Black tree and ensure it adheres to its properties after each insertion and deletion. # Problem Statement: Implement a Red-Black Tree that supports node insertion, deletion, and in-order traversal. Ensure that: 1. The tree remains balanced after each insertion and deletion. 2. In-order traversal should return a sorted sequence of the node values. # Function Signature: ```python class RBNode: def __init__(self, val, is_red=True): pass class RBTree: def __init__(self): pass def insert(self, value: int) -> None: pass def delete(self, value: int) -> None: pass def inorder(self) -> list: pass ``` # Requirements: 1. **Node Insertion**: - `insert(value: int) -> None`: Insert a node with the given value into the Red-Black tree. 2. **Node Deletion**: - `delete(value: int) -> None`: Delete the node containing the given value from the Red-Black tree. 3. **In-order Traversal**: - `inorder() -> list`: Return a list of dictionaries each representing a node with keys for \'val\' and \'color\' (0 for black, 1 for red) in the in-order sequence. # Constraints: 1. All values are distinct integers. 2. Ensure the Red-Black tree properties are maintained. # Example Usage: ```python rb = RBTree() rb.insert(10) rb.insert(20) rb.insert(30) print(rb.inorder()) # [{\'val\': 10, \'color\': 1}, {\'val\': 20, \'color\': 0}, {\'val\': 30, \'color\': 1}] rb.delete(20) print(rb.inorder()) # [{\'val\': 10, \'color\': 1}, {\'val\': 30, \'color\': 0}] ``` # Notes: 1. Focus on balancing the tree and maintaining Red-Black properties during each modification. 2. Testing will involve multiple insertions and deletions.","solution":"class RBNode: def __init__(self, val, is_red=True): self.val = val self.color = 1 if is_red else 0 # 1 is red, 0 is black self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.NIL = RBNode(0, False) # NIL nodes are always black self.root = self.NIL def insert(self, value): new_node = RBNode(value) new_node.left = self.NIL new_node.right = self.NIL parent = None current = self.root while current != self.NIL: parent = current if new_node.val < current.val: current = current.left else: current = current.right new_node.parent = parent if parent is None: self.root = new_node elif new_node.val < parent.val: parent.left = new_node else: parent.right = new_node if new_node.parent is None: new_node.color = 0 return if new_node.parent.parent is None: return self._fix_insert(new_node) def delete(self, value): self._delete_node_helper(self.root, value) def inorder(self): res = [] def inorder_helper(node): if node != self.NIL: inorder_helper(node.left) res.append({\'val\': node.val, \'color\': node.color}) inorder_helper(node.right) inorder_helper(self.root) return res def _left_rotate(self, x): y = x.right x.right = y.left if y.left != self.NIL: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def _right_rotate(self, x): y = x.left x.left = y.right if y.right != self.NIL: y.right.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def _fix_insert(self, k): while k.parent.color == 1: if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.left: k = k.parent self._right_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self._left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.right: k = k.parent self._left_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self._right_rotate(k.parent.parent) if k == self.root: break self.root.color = 0 def _transplant(self, u, v): if u.parent is None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def _delete_node_helper(self, node, key): z = self.NIL while node != self.NIL: if node.val == key: z = node if node.val <= key: node = node.right else: node = node.left if z == self.NIL: print(\\"Cannot find key in the tree\\") return y = z y_original_color = y.color if z.left == self.NIL: x = z.right self._transplant(z, z.right) elif z.right == self.NIL: x = z.left self._transplant(z, z.left) else: y = self._minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self._transplant(y, y.right) y.right = z.right y.right.parent = y self._transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == 0: self._fix_delete(x) def _fix_delete(self, x): while x != self.root and x.color == 0: if x == x.parent.left: s = x.parent.right if s.color == 1: s.color = 0 x.parent.color = 1 self._left_rotate(x.parent) s = x.parent.right if s.left.color == 0 and s.right.color == 0: s.color = 1 x = x.parent else: if s.right.color == 0: s.left.color = 0 s.color = 1 self._right_rotate(s) s = x.parent.right s.color = x.parent.color x.parent.color = 0 s.right.color = 0 self._left_rotate(x.parent) x = self.root else: s = x.parent.left if s.color == 1: s.color = 0 x.parent.color = 1 self._right_rotate(x.parent) s = x.parent.left if s.left.color == 0 and s.right.color == 0: s.color = 1 x = x.parent else: if s.left.color == 0: s.right.color = 0 s.color = 1 self._left_rotate(s) s = x.parent.left s.color = x.parent.color x.parent.color = 0 s.left.color = 0 self._right_rotate(x.parent) x = self.root x.color = 0 def _minimum(self, node): while node.left != self.NIL: node = node.left return node"},{"question":"# Gnome Sort Implementation and Optimization Objective: You are tasked with implementing the gnome sort algorithm as provided and enhancing it to switch to a more efficient sorting algorithm when the list is longer than a certain threshold. Problem Statement: Write a function `enhanced_gnome_sort` that sorts a list of integers. The function should use the gnome sort algorithm for lists with ( text{length} leq 10 ). For lists longer than 10 elements, it should switch to an efficient sorting algorithm of your choice (e.g., quicksort or mergesort). Input: * `arr`: A list of integers with 0 (leq text{len(arr)} leq 1000). Output: * A sorted list of integers. Constraints: * The list can contain duplicate numbers. * Optimize for both small and large lists. * Ensure stability in sorting. Performance Requirements: * Best: ( O(n log n) ). # Function Signature ```python def enhanced_gnome_sort(arr): # Your implementation here pass ``` # Examples: ```python assert enhanced_gnome_sort([34, 2, 78, 12, 5]) == [2, 5, 12, 34, 78] assert enhanced_gnome_sort([5, 8, 1, 3, 7, 9, 2]) == [1, 2, 3, 5, 7, 8, 9] assert enhanced_gnome_sort([]) == [] assert enhanced_gnome_sort([4]) == [4] assert enhanced_gnome_sort([3, 1, 2, 2, 1, 3]) == [1, 1, 2, 2, 3, 3] assert enhanced_gnome_sort([100] * 50) == [100] * 50 ``` Implementation Hints: 1. Implement the gnome sort for small lists as shown in the provided code. 2. For larger lists, switch to a more efficient sorting algorithm, such as quicksort. 3. Ensure that your solution handles edge cases appropriately. 4. Include checks for the list length within your function to decide which sorting technique to apply.","solution":"def gnome_sort(arr): index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr def enhanced_gnome_sort(arr): if len(arr) <= 10: return gnome_sort(arr) else: return sorted(arr)"},{"question":"Relative Path Resolver with Normalization **Problem Statement**: You are working on a file management utility that needs to handle various user-provided file paths. Sometimes, these paths include user home directories (`~`), relative paths like `..`, and may contain redundant separators (e.g., `///`). Your task is to implement a function that not only converts a relative path into its absolute path but also normalizes the path by resolving any redundant components. **Function Signature**: ```python def resolve_full_path(relative_path: str) -> str: pass ``` **Input**: - `relative_path` (str): A string representing the relative path which might include symbols like `~`, `..`, `.` and redundant separators. **Output**: - (str): The fully resolved and normalized absolute path. **Constraints**: - Do not use any external libraries beyond the `os` and `os.path` modules. - Assume the input will always be a valid path string. - Paths should be resolved assuming the current working directory of your script. **Performance Requirements**: - Your solution should handle paths with a length up to 4096 characters efficiently. - Aim for optimal path resolution especially for paths with many redundant or special components. **Example Scenario**: Imagine an application that takes logs paths from user input and normalizes it for storage consistency, ensuring no redundant elements remain. **Example Usage**: ```python assert resolve_full_path(\\"~/../Documents/Project/../file.txt\\") == \\"/home/user/Documents/file.txt\\" assert resolve_full_path(\\"////home//user////Documents/./../file.log\\") == \\"/home/user/file.log\\" assert resolve_full_path(\\"my_project/../../report.pdf\\") == \\"/home/user/report.pdf\\" # assuming the current directory is /home/user/scripts/ ``` **Implementation Notes**: To achieve the normalization, utilize functions like `os.path.normpath` in conjunction with the existing path resolution techniques.","solution":"import os def resolve_full_path(relative_path: str) -> str: Converts a relative path into its absolute path and normalizes it. Parameters: - relative_path: str : The relative path to resolve and normalize Returns: - str: The fully resolved and normalized absolute path # Expand the user home directory if present expanded_path = os.path.expanduser(relative_path) # Resolve the absolute path absolute_path = os.path.abspath(expanded_path) # Normalize the resolved absolute path normalized_path = os.path.normpath(absolute_path) return normalized_path"},{"question":"# Question **Nth Digit Finder** You are given a massive sequence formed by concatenating all integers starting from 1: \\"123456789101112131415...\\". Your task is to implement a function that finds the nth digit in this infinite sequence. Function Signature ```python def find_nth_digit(n: int) -> int: pass ``` Input * An integer n (1 <= n <= 2 * 10^9) Output * An integer representing the nth digit in the infinite sequence. Example ```python assert find_nth_digit(3) == 3 # Sequence: \\"123456789...\\", 3rd digit is 3 assert find_nth_digit(11) == 0 # Sequence: \\"12345678910...\\", 11th digit is 0 assert find_nth_digit(250) == 1 # Sequence ...279280281282..., 250th digit falls within \\"280\\", 1 is the digit # Larger example assert find_nth_digit(1000000000) == 1 # Resulting output of the 1 billion position ``` Constraints * Ensure that your solution handles very large values of n efficiently, and adheres to the given time complexity constraints. * Be cautious of potential precision issues due to floating-point arithmetic. Use integer arithmetic as much as possible. Notes * Avoid generating the entire sequence to find the digit, as n can be extremely large. * Focus on identifying the number within the sequence and the specific digit of that number.","solution":"def find_nth_digit(n: int) -> int: length = 1 # initial length of digits we are looking at (1 digit numbers) count = 9 # 9 single-digit numbers (1 to 9) start = 1 # the starting number with the current digit length # Step 1: Identify the range in which the nth digit falls while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Step 2: Identify the exact number that contains the nth digit start += (n - 1) // length # (n-1 to adjust for Python\'s 0-indexing) # Step 3: Identify the exact digit within this number number_str = str(start) digit_index = (n - 1) % length # (n-1 to adjust for Python\'s 0-indexing) return int(number_str[digit_index])"},{"question":"# Flatten Nested Arrays Context In data analysis and processing, you often encounter arrays or lists that contain nested arrays. To perform operations on them, you need a flattened version of these arrays. Let\'s design a function to achieve this. Task Write a Python function: ```python def custom_flatten(nested_list): Flattens a nested list or array into a single list. Args: nested_list (list): A list that can contain other nested lists/arrays. Returns: list: A single-dimensional flattened list. ``` Requirements - The function should handle multiple levels of nesting. - It must preserve the order of elements. - Strings should be treated as single elements and should not be further flattened. - The function should work efficiently for larger structures. Constraints - You cannot use predefined functions or libraries that directly perform flattening. - The input may include integers, strings, and nested lists. Input Format A single parameter: - `nested_list` (list): A potentially nested list to be flattened. Output Format - A single list containing all elements in a flattened form. Examples ```python assert custom_flatten([1, [2, [3, 4]], 5]) == [1, 2, 3, 4, 5] assert custom_flatten([[\'a\', [\'b\']], \'c\', [[], \'d\']]) == [\'a\', \'b\', \'c\', \'d\'] assert custom_flatten([]) == [] assert custom_flatten([[1], 2, [[3]], [[[4]]]]) == [1, 2, 3, 4] ``` Implement the `custom_flatten` function based on the given requirements.","solution":"def custom_flatten(nested_list): Flattens a nested list or array into a single list. Args: nested_list (list): A list that can contain other nested lists/arrays. Returns: list: A single-dimensional flattened list. def flatten(lst): for item in lst: if isinstance(item, list): yield from flatten(item) else: yield item return list(flatten(nested_list))"},{"question":"# Word Search Data Structure Implementation You are asked to implement the `WordDictionary` and `WordDictionary2` classes to efficiently add and search for words, allowing for searches that may include the \'.\' character to represent any letter. # Function Specifications: WordDictionary 1. **add_word(word: str) -> None** * Add the word to the data structure. * **Input**: `word` (string). A non-empty sequence of lowercase alphabets. * **Output**: None. 2. **search(word: str) -> bool** * Search for the word in the data structure. A \'`.`\' character in the word can represent any letter. * **Input**: `word` (string). A non-empty sequence of lowercase alphabets and/or \'.\'. * **Output**: `True` if the word is found, `False` otherwise. WordDictionary2 1. **add_word(word: str) -> None** * Add the word to the data structure. * **Input**: `word` (string). A non-empty sequence of lowercase alphabets. * **Output**: None. 2. **search(word: str) -> bool** * Search for the word in the data structure. A \'`.`\' character in the word can represent any letter. * **Input**: `word` (string). A non-empty sequence of lowercase alphabets and/or \'.\'. * **Output**: `True` if the word is found, `False` otherwise. # Constraints: * All words consist of lowercase English letters. * All add and search operations will involve strings with a length between 1 and 100 characters. # Example Usage: ```python # Test Case 1 wd1 = WordDictionary() wd1.add_word(\\"bad\\") wd1.add_word(\\"dad\\") wd1.add_word(\\"mad\\") assert wd1.search(\\"pad\\") == False assert wd1.search(\\"bad\\") == True assert wd1.search(\\".ad\\") == True assert wd1.search(\\"b..\\") == True # Test Case 2 wd2 = WordDictionary2() wd2.add_word(\\"bad\\") wd2.add_word(\\"dad\\") wd2.add_word(\\"mad\\") assert wd2.search(\\"pad\\") == False assert wd2.search(\\"bad\\") == True assert wd2.search(\\".ad\\") == True assert wd2.search(\\"b..\\") == True ```","solution":"class WordDictionary: def __init__(self): self.words = [] def add_word(self, word: str) -> None: self.words.append(word) def search(self, word: str) -> bool: import re pattern = \\"^\\" + word.replace(\'.\', \'[a-z]\') + \\"\\" for w in self.words: if re.match(pattern, w): return True return False class WordDictionary2: def __init__(self): self.trie = {} def add_word(self, word: str) -> None: node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node[\'#\'] = True def search(self, word: str) -> bool: return self._search_in_node(word, self.trie) def _search_in_node(self, word: str, node: dict) -> bool: for i, char in enumerate(word): if char == \'.\': for x in node: if x != \'#\' and self._search_in_node(word[i + 1:], node[x]): return True return False elif char not in node: return False node = node[char] return \'#\' in node"},{"question":"# Balanced Parentheses Validator Scenario In a programming class, students are taught about stacks and their applications in parsing expressions. To assess their understanding, you need to create a function to validate balanced parentheses in a string. Problem Statement Write a Python function `validate_parentheses(s: str) -> bool` that takes in a string containing just the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'`. The function should determine if the input string is valid. A string is considered valid if: 1. The brackets must close in the correct order, meaning, every opening bracket of a type has a corresponding closing bracket of the same type. 2. Every closing bracket has a corresponding opening bracket of the same type. 3. An empty string is considered as valid. Input * A single string `s` containing up to 10^5 characters comprising `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'`. Output * Return `True` if the string is valid, otherwise return `False`. Constraints * The input string may be empty. * The input string contains only the mentioned parentheses characters without any other types of characters. Performance Requirements * The solution should run in linear time, O(n), where n is the length of the string. Example ```python assert validate_parentheses(\\"()\\") == True assert validate_parentheses(\\"()[]{}\\") == True assert validate_parentheses(\\"(]\\") == False assert validate_parentheses(\\"([)]\\") == False assert validate_parentheses(\\"{[]}\\") == True assert validate_parentheses(\\"\\") == True # Edge case: empty string ``` # Additional Challenge If your initial implementation passes all test cases and meets the performance requirements, try optimizing space usage or consider other types of characters and brackets.","solution":"def validate_parentheses(s: str) -> bool: This function checks if the given string of parentheses is balanced. stack = [] mapping = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in mapping: top_element = stack.pop() if stack else \'#\' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"# Sorting Algorithm Challenge: Implement and Analyze a Sorting Algorithm Context You are a software developer tasked with sorting a list of library books by their unique ID numbers. You have come across an inefficiency in one of your team’s sorting algorithms and have been asked to replace it with a more optimal and efficient algorithm. Problem Statement You need to implement the **Quick Sort** algorithm, known for its efficiency and using the \'divide and conquer\' method. This algorithm efficiently organizes a list by selecting a \'pivot\' element and partitioning the other elements into those less than and greater than the pivot. Function Signature Implement a Python function with the following signature: ```python def quick_sort(arr): Sorts an array using the Quick Sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: The sorted list of integers. pass ``` Constraints * The input list `arr` will contain no more than 10^6 elements. * Each element in `arr` will be an integer in the range [-10^9, 10^9]. * You should aim for an average case time complexity of O(n log n) and the space complexity should be O(log n) due to recursive calls. Requirements 1. The function `quick_sort` should return a list of integers sorted in ascending order. 2. Consider edge cases such as an empty list, a list with one element, and a list with duplicate elements. 3. Avoid excessive memory usage and minimize time complexity as far as possible. 4. Document steps taken to avoid common pitfalls, especially handling pivot selection and partitioning. Example ```python >>> quick_sort([3, 6, 8, 10, 1, 2, 1]) [1, 1, 2, 3, 6, 8, 10] >>> quick_sort([10, 7, 8, 9, 1, 5]) [1, 5, 7, 8, 9, 10] >>> quick_sort([]) [] >>> quick_sort([1]) [1] ``` Complete the function and ensure it handles all the outlined cases and constraints effectively.","solution":"def quick_sort(arr): Sorts an array using the Quick Sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: The sorted list of integers. # If the array is empty or has one element, it\'s already sorted if len(arr) <= 1: return arr # Choose the pivot (using the middle element for better performance on already sorted lists) pivot = arr[len(arr) // 2] # Partition the array into three parts: less than pivot, equal to pivot, and greater than pivot. low = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] high = [x for x in arr if x > pivot] # Recursively apply quick_sort to the low and high partitions return quick_sort(low) + middle + quick_sort(high)"},{"question":"# Two Sum Extended **Context**: You are working on a financial tracking application and need to implement a feature that lets users know which two distinct transactions perfectly match a specific total amount from a list of transaction amounts. Problem Statement Write a function `two_sum(array, target)` that: - Takes in a list of integers `array` representing transaction amounts and an integer `target` representing the target total sum. - Returns a tuple of indices of the two numbers that add up to the target. **Function Signature**: ```python def two_sum(array: List[int], target: int) -> Tuple[int, int]: ``` Input Format - `array`: List of integers (1 <= len(array) <= 10^4). Each integer can range from -10^3 to 10^3. - `target`: An integer that represents the target sum (-10^3 <= target <= 10^3). Output Format - A tuple of two integers representing the indices of the two numbers within the `array` that sum up to `target`. Constraints - Each input will have exactly one solution. - You may not use the same element twice. **Example**: ```python two_sum([2, 7, 11, 15], 9) # should return (0, 1) two_sum([3, 2, 4], 6) # should return (1, 2) two_sum([-1, -2, -3, -4, -5], -8) # should return (2, 4) ``` Notes - Ensure that you consider edge cases such as negative numbers and zeros in the input list. - Optimize for time and space efficiency where possible.","solution":"from typing import List, Tuple def two_sum(array: List[int], target: int) -> Tuple[int, int]: Returns indices of the two numbers such that they add up to the target. index_map = {} for i, num in enumerate(array): diff = target - num if diff in index_map: return (index_map[diff], i) index_map[num] = i"},{"question":"# Question: Optimal Matrix Chain Multiplication Scenario: Matrix Chain Multiplication is an optimization problem that aims to find the most efficient way to multiply a given chain of matrices. Multiplying matrices is associative, meaning the order in which we multiply does not affect the final result. However, different multiplication orders can result in different computational costs. In this task, you will implement an efficient algorithm to find the minimum number of scalar multiplications needed to multiply a chain of matrices. Additionally, you will print the optimal order of multiplication. Task: * Implement a function `matrix_chain_order` that takes an array of dimensions and returns two tables: * `matrix`: Contains the minimum number of scalar multiplications needed to multiply matrices from `i` to `j`. * `sol`: Contains the optimal split point `k` for matrices from `i` to `j`. * Implement a function `print_optimal_solution` to print the optimal order of matrix multiplication based on the `sol` table. Function Signatures: ```python def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: pass def print_optimal_solution(optimal_solution: List[List[int]], i: int, j: int) -> None: pass ``` Input: * `array`: A list of integers, where each integer represents the dimensions of matrices in the chain. * For instance, an input array `[30, 35, 15, 5, 10, 20, 25]` represents the dimensions of matrices: 30x35, 35x15, 15x5, 5x10, 10x20, 20x25. Output: * The function `matrix_chain_order` returns two matrices, `matrix` and `sol`. * The function `print_optimal_solution` prints the optimal multiplication order. Example: ```python array = [30, 35, 15, 5, 10, 20, 25] matrix, optimal_solution = matrix_chain_order(array) print(\\"Minimum number of multiplications is:\\", matrix[1][len(array) - 1]) print(\\"Optimal multiplication order is:\\") print_optimal_solution(optimal_solution, 1, len(array) - 1) ``` Constraints: * 2 ≤ len(array) ≤ 100 * 1 ≤ dimension ≤ 500 Note: * Handle edge cases where the input array has fewer dimensions or extremely large dimensions appropriately. * Ensure efficiency within the provided constraints.","solution":"from typing import List, Tuple def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: n = len(array) - 1 # m[i][j] stores the minimum number of scalar multiplications needed to compute the product of matrices A[i]...A[j] m = [[0 for _ in range(n + 1)] for _ in range(n + 1)] # s[i][j] stores the index of the matrix after which the optimal split occurs in the product of matrices A[i]...A[j] s = [[0 for _ in range(n + 1)] for _ in range(n + 1)] # l is the chain length for l in range(2, n + 1): for i in range(1, n - l + 2): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + array[i - 1] * array[k] * array[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m, s def print_optimal_solution(s: List[List[int]], i: int, j: int) -> None: if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(s, i, s[i][j]) print_optimal_solution(s, s[i][j] + 1, j) print(\\")\\", end=\\"\\")"},{"question":"# Question: Implement and Analyze a Stoodge Sort Variant Context: To better understand the inefficiencies of Stooge Sort, let\'s modify and implement a variant of the algorithm—Reactive Stooge Sort. This variant will include an additional check to reduce unnecessary recursive calls. If the number of elements in the subarray is less than 3, the algorithm will confirm if the section is already sorted before making further recursive calls. Task: Write a function `reactive_stooge_sort(arr, l, h)` that sorts an array `arr` in ascending order using the Reactive Stooge Sort method. Function Signature: ```python def reactive_stooge_sort(arr: List[int], l: int, h: int) -> None: # Implementation goes here ``` Input: - `arr`: List of integers to be sorted. - `l`: Starting index (0-based). - `h`: Ending index (0-based). Output: - In-place sorting of the input list `arr`. Constraints: - The length of `arr` will be between 1 and 10^3. - Each element in `arr` will be an integer within the range [-10^6, 10^6]. Performance Requirements: - The main goal is to improve the efficiency of Stooge Sort by reducing redundant checks. Example: ```python arr = [5, 3, 2, 8, 1, 4] reactive_stooge_sort(arr, 0, len(arr) - 1) print(arr) # Output should be [1, 2, 3, 4, 5, 8] ``` Implementation Details: 1. Swap elements if the element at `l` is greater than the element at `h`. 2. Check if there are at least three elements in the current range. 3. If less than three elements, ensure they are in sorted order. 4. Recursively sort the first two-thirds and last two-thirds. 5. Re-sort the first two-thirds to confirm the order.","solution":"def reactive_stooge_sort(arr, l, h): Sorts an array arr[l:h+1] using Reactive Stooge Sort. if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 reactive_stooge_sort(arr, l, h - t) reactive_stooge_sort(arr, l + t, h) reactive_stooge_sort(arr, l, h - t)"},{"question":"Climbing Stairs You are designing an elevator system that can stop at different levels of a building. The user can either move up one or two levels each time they press a button. Given the total number of levels, implement a function that calculates the number of distinct ways a user can reach the top level. Function Signature ```python def num_ways_to_top(levels: int) -> int: :param levels: int - the total number of levels in the building (positive integer). :return: int - the number of distinct ways to reach the top level. ``` Input - `levels` (1 <= levels <= 10^6): An integer representing the total levels in the building. Output - Return an integer representing the number of distinct ways to reach the top level. Constraints - You must implement the function with an optimized approach using O(1) space complexity. - The function should efficiently handle large input values up to 10^6 levels. Example ```python assert num_ways_to_top(2) == 2 # There are 2 ways to reach level 2: (1 + 1) or (2). assert num_ways_to_top(3) == 3 # There are 3 ways to reach level 3: (1 + 1 + 1), (1 + 2), or (2 + 1). assert num_ways_to_top(4) == 5 # There are 5 ways to reach level 4: (1 + 1 + 1 + 1), (1 + 1 + 2), (1 + 2 + 1), (2 + 1 + 1), or (2 + 2). ```","solution":"def num_ways_to_top(levels: int) -> int: Calculate the number of distinct ways to reach the top level using either 1-step or 2-steps moves. :param levels: int - the total number of levels in the building (positive integer). :return: int - the number of distinct ways to reach the top level. # Edge cases for levels 0 and 1 if levels == 0: return 1 elif levels == 1: return 1 # Using variables to store the number of ways to reach the previous two levels prev1, prev2 = 1, 1 for _ in range(2, levels + 1): current = prev1 + prev2 prev2 = prev1 prev1 = current return prev1"},{"question":"# Run-Length Encoding and Decoding **Objective**: Implement functions for encoding and decoding strings using Run-Length Encoding (RLE) algorithm. **Function Descriptions**: 1. `encode_rle(input: str) -> str`: * Takes a string `input` containing the data to be encoded. * Returns a string representing the run-length encoded version of the input. 2. `decode_rle(input: str) -> str`: * Takes a string `input` that is the run-length encoded data. * Returns the original string before encoding. **Constraints**: * All characters in the input string for both functions are printable ASCII characters. * The encoded string will follow the format produced by `encode_rle`. **Requirements**: * Both functions should handle edge cases (e.g., empty strings, single-character strings). * Consider performance: aim for O(n) time complexity. * Do not use any standard library functions built for encoding/decoding or compressing data. **Examples**: ```python # Example for encode_rle encode_rle(\\"aaaabbbcccc\\") # Should return \\"4a3b4c\\" # Example for decode_rle decode_rle(\\"4a3b4c\\") # Should return \\"aaaabbbcccc\\" ``` # Task Write the two functions `encode_rle` and `decode_rle` based on the descriptions provided. Ensure they handle edge cases correctly and perform efficiently.","solution":"def encode_rle(input: str) -> str: Encode a string using Run-Length Encoding (RLE). Parameters: input (str): The string to encode. Returns: str: The run-length encoded string. if not input: return \\"\\" encoded = [] count = 1 previous_char = input[0] for char in input[1:]: if char == previous_char: count += 1 else: encoded.append(f\\"{count}{previous_char}\\") previous_char = char count = 1 encoded.append(f\\"{count}{previous_char}\\") # add the last run return \\"\\".join(encoded) def decode_rle(input: str) -> str: Decode a run-length encoded string. Parameters: input (str): The encoded string to decode. Returns: str: The original string before encoding. if not input: return \\"\\" decoded = [] count = \'\' for char in input: if char.isdigit(): count += char else: decoded.append(char * int(count)) count = \'\' return \\"\\".join(decoded)"},{"question":"You are given multiple implementations of a function to reverse a string. Your task is to implement a function that combines the efficiency of the iterative method with the simplicity of Pythonic slicing, but without using built-in slicing or reversed functions directly. # Function Signature ```python def efficient_reverse(s: str) -> str: pass ``` # Input and Output Formats * Input: A string `s` with length n (1 ≤ n ≤ 10^5). * Output: A string that is the reverse of the input string `s`. # Constraints * You must not use Python\'s built-in reversed() or slicing (s[::-1]) functions. * The solution must have linear time complexity (O(n)) and operate in place or with O(n) extra space at most. # Example 1. Input: `\\"hello\\"` Output: `\\"olleh\\"` 2. Input: `\\"algorithm\\"` Output: `\\"mhtirogla\\"` # Additional Notes Please consider common edge cases such as: - An empty string. - A single character string. While implementing, pay attention to: - Efficiency both in terms of time and space complexity. - Clear and maintainable code.","solution":"def efficient_reverse(s: str) -> str: Returns the reverse of the input string s. # Convert the string to a list of characters chars = list(s) # Initialize two pointers, one at the beginning and one at the end left, right = 0, len(chars) - 1 # Swap characters from the start and end moving towards the center while left < right: chars[left], chars[right] = chars[right], chars[left] left += 1 right -= 1 # Join the characters back into a single string and return return \'\'.join(chars)"},{"question":"# RSA Key Generation and Encryption/Decryption Implementation As a skilled software engineer at a tech startup, you are tasked with implementing a secure message transfer system that uses RSA for encryption and decryption. Your first goal is to correctly generate RSA keys and ensure the encryption and decryption processes work seamlessly. Objectives: 1. **Key Generation**: Write a Python function `generate_key(k)` that takes an integer `k` (the key size in bits) and returns a tuple (n, e, d), where: - **n**: The product of two distinct k/2-bit prime numbers (the modulus). - **e**: A k-bit prime number (encryption exponent). - **d**: The modular multiplicative inverse of e modulo φ(n) (decryption exponent). 2. **Encryption**: Write a Python function `encrypt(data, e, n)` that takes an integer `data` and public key (e, n), and returns the encrypted data. 3. **Decryption**: Write a Python function `decrypt(data, d, n)` that takes the encrypted integer `data` and private key (d, n), and returns the decrypted original data. # Constraints: - `k` will be a positive even number. - All numbers (e, d, n) will fit within standard Python integer ranges. - You can assume `data` to be a non-negative integer less than `n`. # Performance Requirements: - Key generation must handle typical `k` of up to 2048 bits efficiently. - Encryption and decryption operations should be performed using optimal mathematical methods to ensure efficiency. # Sample Usage: ```python k = 16 n, e, d = generate_key(k) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` # Submit: - Implement the `generate_key(k)`, `encrypt(data, e, n)`, and `decrypt(data, d, n)` functions. - Ensure correctness and efficiency in your implementations.","solution":"import random from sympy import isprime, mod_inverse def generate_prime(bits): Function to generate a prime number of given bits. p = random.getrandbits(bits) while not isprime(p): p = random.getrandbits(bits) return p def generate_key(k): Generates RSA key pair. Parameters: k (int): Key size in bits. Returns: tuple: (n, e, d) where n is the modulus for public and private keys, e is the public exponent, d is the private exponent. assert k % 2 == 0, \\"Key size must be an even number\\" p = generate_prime(k // 2) q = generate_prime(k // 2) while q == p: q = generate_prime(k // 2) n = p * q phi = (p - 1) * (q - 1) e = generate_prime(k // 4) while gcd(e, phi) != 1: e = generate_prime(k // 4) d = mod_inverse(e, phi) return n, e, d def encrypt(data, e, n): Encrypts the data using the public key. Parameters: data (int): The data to be encrypted. e (int): The public exponent. n (int): The modulus. Returns: int: The encrypted data. return pow(data, e, n) def decrypt(data, d, n): Decrypts the data using the private key. Parameters: data (int): The encrypted data. d (int): The private exponent. n (int): The modulus. Returns: int: The decrypted original data. return pow(data, d, n) def gcd(a, b): Return the greatest common divisor using Euclid\'s Algorithm. while b: a, b = b, a % b return a"},{"question":"You are given an array of integers `nums` in which exactly two elements appear only once and all the other elements appear exactly twice. Your task is to write a function that finds the two elements that appear only once, with the condition that your solution must have a time complexity of (O(N)) and a space complexity of (O(1)). # Function Signature ```python def single_number3(nums: List[int]) -> List[int]: pass ``` # Input - `nums`: List of integers with length `N` (1 ≤ `N` ≤ (10^6)) # Output - Return a list containing the two unique elements. # Constraints - The given input array `nums` contains exactly two elements that appear only once, and all the other elements appear exactly twice. - The result can have the unique elements in any order. # Examples 1. **Example 1:** ``` Input: nums = [1, 2, 1, 3, 2, 5] Output: [3, 5] or [5, 3] ``` 2. **Example 2:** ``` Input: nums = [4, 1, 2, 1, 2, 3] Output: [3, 4] or [4, 3] ``` # Approach 1. Calculate the XOR of all elements in the array to find (A oplus B) where (A) and (B) are the unique elements. 2. Identify the rightmost set bit in the resultant XOR value. 3. Use this bit to partition the array into two groups: one group in which all numbers have the bit set and another group in which all numbers do not have the bit set. 4. XOR the numbers in each group separately. This will cancel out all pairs, leaving the unique number in each group. 5. Return the unique numbers as the result. Good luck!","solution":"from typing import List def single_number3(nums: List[int]) -> List[int]: # 1. Find the XOR of all numbers in the array. xor_all = 0 for num in nums: xor_all ^= num # 2. Find the rightmost set bit in xor_all. rightmost_set_bit = xor_all & -xor_all # 3. Divide the numbers into two groups and find the unique number in each group. unique_num1 = 0 unique_num2 = 0 for num in nums: if num & rightmost_set_bit: unique_num1 ^= num else: unique_num2 ^= num return [unique_num1, unique_num2]"},{"question":"**Context**: You are implementing a sorting functionality for a small e-commerce site that often processes relatively small and nearly sorted datasets. Given the nature of the data, an optimized insertion sort using a helper function to find the insertion position would be an ideal choice. **Task**: Write a function `insertion_sort_with_helper()` that sorts an array of integers in non-decreasing order using an optimized insertion sort algorithm. Use the provided `search_insert()` helper function to efficiently find the insertion position for each element. **Function Signature**: ```python def insertion_sort_with_helper(arr: List[int]) -> List[int]: ``` **Input**: * `arr`: A list of integers ( (0 leq text{len(arr)} leq 10^3) ). The integers can be positive or negative. **Output**: * Return a list of integers sorted in non-decreasing order. **Example**: ```python insertion_sort_with_helper([4, 2, 6, 1, 5]) # Output: [1, 2, 4, 5, 6] insertion_sort_with_helper([1, 3, 2, 4]) # Output: [1, 2, 3, 4] ``` **Constraints**: * All elements in the input list are integers. * The length of the list does not exceed 1000. **Notes**: * Optimize the insertion sort using the provided `search_insert()` function. * Ensure the algorithm handles edge cases properly, such as an empty array or arrays with duplicate values.","solution":"from typing import List def search_insert(arr: List[int], start: int, end: int, target: int) -> int: Helper function to find the position to insert target into arr[start:end]. while start < end: mid = (start + end) // 2 if arr[mid] < target: start = mid + 1 else: end = mid return start def insertion_sort_with_helper(arr: List[int]) -> List[int]: Sorts an array of integers using optimized insertion sort algorithm with a binary search helper function. if len(arr) <= 1: return arr for i in range(1, len(arr)): current_value = arr[i] pos = search_insert(arr, 0, i, current_value) # Shift elements to the right to make room for current_value for j in range(i, pos, -1): arr[j] = arr[j - 1] # Place current_value at its correct position arr[pos] = current_value return arr"},{"question":"# Advanced Coding Assessment: Cooley-Tukey FFT Algorithm Context: The Fast Fourier Transform (FFT) is an efficient algorithm to compute the Discrete Fourier Transform (DFT) and its inverse. The Cooley-Tukey algorithm is the most common FFT algorithm, recursively breaking down a DFT of any composite size ( N ) into many smaller DFTs. Task: Implement the Cooley-Tukey FFT algorithm as a function that takes an array of complex numbers as input and returns its DFT, also as an array of complex numbers. Your implementation should follow the given recursive structure. Input: * A list `x` of complex numbers with a length ( N ) where ( N ) is a power of 2. Output: * A list of complex numbers representing the DFT of the input list. Constraints: * The length of the input list ( N ) will be a power of 2 (( 2^k ) for some integer ( k geq 1 )). * Aim for a time complexity of ( O(N log N) ). Example: ```python Input: [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] Output: [(8+8j), (2j), (2-2j), (-2+0j)] ``` Implementation: You must implement the function `fft(x: List[complex]) -> List[complex]` following the structure outlined in the provided pseudo-code. # Constraints and Requirements: * Ensure the function handles the given constraints without errors. * Write the code to be efficient and clean, leveraging Python\'s `cmath` library for complex number operations. * Avoid using iterative transformations—focus on a recursive implementation. Additional Notes: You are free to precompute any constants or make use of any helper functions as needed to make your main `fft` function efficient and readable. Your code should handle floating-point operations robustly to maintain accuracy.","solution":"import cmath def fft(x): N = len(x) if N <= 1: return x even = fft(x[0::2]) odd = fft(x[1::2]) T = [cmath.exp(-2j * cmath.pi * k / N) * odd[k] for k in range(N // 2)] return [even[k] + T[k] for k in range(N // 2)] + [even[k] - T[k] for k in range(N // 2)]"},{"question":"Question: Dynamic Island Tracker # Scenario You are managing a coastal region represented by a 2D grid of water (0s) and land (1s). Initially, the grid is filled with water. Any land formation operation connects adjacent lands horizontally or vertically to form islands. Your task is to determine the number of islands after each land formation operation. # Task Implement a function `dynamic_island_tracker` that tracks the number of islands after each land formation operation. You are given a 2D grid and a list of positions where land formations occur. # Function Signature ```python def dynamic_island_tracker(rows: int, cols: int, positions: List[List[int]]) -> List[int]: pass ``` # Input * `rows`: An integer representing the number of rows in the grid (1 ≤ rows ≤ 1000). * `cols`: An integer representing the number of columns in the grid (1 ≤ cols ≤ 1000). * `positions`: A list of lists, where each inner list contains two integers `[r, c]` denoting the row and column of a land formation in the grid. # Output * Returns a list of integers, where each integer represents the number of islands after each land formation operation in the given order. # Constraints * Operations are performed sequentially based on the provided position list. * Land formations may occur multiple times at the same position, and such redundant operations should not affect the island count. * The solution should be efficient with respect to both time and space complexities. # Examples ```python # Example 1 rows = 3 cols = 3 positions = [[0, 0], [0, 1], [1, 2], [2, 1]] print(dynamic_island_tracker(rows, cols, positions)) # Output: [1, 1, 2, 3] # Example 2 rows = 3 cols = 3 positions = [[0,0], [1,1], [2,2]] print(dynamic_island_tracker(rows, cols, positions)) # Output: [1, 2, 3] ``` # Notes * Make sure to handle edge cases where the same position is given multiple times. * Optimize the find and union operations using path compression and union by size.","solution":"from typing import List def find(parent, i): if parent[i] != i: parent[i] = find(parent, parent[i]) # path compression return parent[i] def union(parent, rank, x, y): rootx = find(parent, x) rooty = find(parent, y) if rootx != rooty: if rank[rootx] > rank[rooty]: parent[rooty] = rootx elif rank[rootx] < rank[rooty]: parent[rootx] = rooty else: parent[rooty] = rootx rank[rootx] += 1 return True return False def dynamic_island_tracker(rows: int, cols: int, positions: List[List[int]]) -> List[int]: if not positions: return [] parent = {} rank = {} result = [] island_count = 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for r, c in positions: current = (r, c) if current in parent: result.append(island_count) continue parent[current] = current rank[current] = 0 island_count += 1 for dr, dc in directions: nr, nc = r + dr, c + dc neighbor = (nr, nc) if neighbor in parent: if union(parent, rank, current, neighbor): island_count -= 1 result.append(island_count) return result"},{"question":"You are given a graph represented as an adjacency list. Your task is to implement a function that counts the number of connected components in the graph using both DFS and BFS traversal methods. A connected component is a set of vertices in a graph that are linked to each other by paths and which is not connected to any additional vertices. # Function Signature ```python def count_connected_components_dfs(graph: Dict[int, List[int]]) -> int: pass def count_connected_components_bfs(graph: Dict[int, List[int]]) -> int: pass ``` # Input - **graph**: A dictionary where the keys are the vertex indices and the values are lists of integers representing the adjacent vertices. # Output - An integer indicating the number of connected components in the graph. # Constraints - The graph can have up to 1000 vertices. - Each vertex index is a non-negative integer <= 1000. - Self-loops and parallel edges may exist. # Example ```python graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1], 3: [4], 4: [3], 5: [] } assert count_connected_components_dfs(graph) == 3 assert count_connected_components_bfs(graph) == 3 ``` # Explanation In the given example graph: - The first connected component is {0, 1, 2}. - The second connected component is {3, 4}. - The third connected component is {5}. Therefore, the total number of connected components in the graph is 3.","solution":"def count_connected_components_dfs(graph): def dfs(node, visited): stack = [node] while stack: n = stack.pop() if n not in visited: visited.add(n) for neighbor in graph[n]: if neighbor not in visited: stack.append(neighbor) visited = set() count = 0 for node in graph: if node not in visited: dfs(node, visited) count += 1 return count def count_connected_components_bfs(graph): from collections import deque def bfs(start, visited): queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) visited = set() count = 0 for node in graph: if node not in visited: bfs(node, visited) count += 1 return count"},{"question":"Problem Statement Given the implementation of a function `remove_min(stack)` which removes the smallest value from an input stack, your task is to write a new function `retain_min(stack)` which should **retain only the smallest value in the stack** and remove all other elements. # Function Signature ```python def retain_min(stack: List[int]) -> List[int]: pass ``` # Input - `stack`: A list of integers representing the stack with the top of the stack being the end of the list. # Output - The function should return a list representing the stack after retaining only the smallest value. # Constraints - The input stack can have at most 10^4 elements. - The integer values can range from -10^5 to 10^5. - The stack is not guaranteed to be sorted. # Example ```python stack = [2, 8, 3, -6, 7, 3] retain_min(stack) # Output should be: # [-6] ``` # Performance Requirements - Your solution must be efficient in both time and space given the constraints. # Notes - You may use auxiliary data structures if necessary. - Ensure to handle edge cases such as an empty stack. # Scenario Imagine managing a priority queue for urgent tasks, where only the most critical task (with the lowest priority number) needs to be processed, and all other tasks can be discarded after the critical task is identified.","solution":"def retain_min(stack): Retains only the smallest value in the stack and removes all other elements. The function takes the stack as a list with the top of the stack being the end of the list. Parameters: stack (List[int]): The stack of integers. Returns: List[int]: The stack after retaining only the smallest value. if not stack: return stack # Find the minimum value min_val = min(stack) # Create a new stack with only the minimum value result_stack = [val for val in stack if val == min_val] return result_stack"},{"question":"Scenario You are developing a command-line tool that needs to operate correctly regardless of how users input their file paths. This tool will repeatedly require the full, absolute path of files, whether they are given as relative paths, paths with user home directory tildes (`~`), or already absolute paths. To ensure consistency and correctness in path handling, you need to write a function that standardizes these paths. Task Write a Python function named `resolve_path` that takes a single argument: `file_path` (a string representing the path to a file). The function should return the full, absolute path of the file, appropriately handling any user home directory expansions. Function Signature ```python def resolve_path(file_path: str) -> str: pass ``` Input - `file_path`: A string that could be a relative path, absolute path, or a path containing the `~` symbol representing the user\'s home directory. Output - Return a string representing the full, absolute path for `file_path`. Constraints - Ensure compatibility across different operating systems. - You can assume that the input path will not be empty. Examples ```python resolve_path(\\"~/docs/file.txt\\") # Should return the equivalent absolute path, e.g., \\"/home/user/docs/file.txt\\" resolve_path(\\"./scripts/run.sh\\") # Should return the absolute path, e.g., \\"/Users/user_name/dev/scripts/run.sh\\" resolve_path(\\"/etc/passwd\\") # Should return the same absolute path \\"/etc/passwd\\" ```","solution":"import os def resolve_path(file_path: str) -> str: Returns the absolute path of the given file path, resolving any user home (~) shorthand and converting relative paths to absolute paths. :param file_path: The input file path (relative, absolute or with home dir shorthand) :return: An absolute path string. return os.path.abspath(os.path.expanduser(file_path))"},{"question":"# Full Path Resolution Function Scenario A file management system needs to handle various user-supplied file paths. These paths may include relative paths, paths with user directory indicators (`~`), and redundant directories. Before performing any operations on these files, it is essential to convert these paths to an absolute form to ensure consistency and accuracy. Task Write a function that takes a file path as input and returns its absolute path. The function should handle user directory expansions and normalize relative paths. Function Signature ```python def resolve_full_path(path: str) -> str: pass ``` Input * `path` (string): A string representing the file path, which could include relative paths, home directories, etc. Output * Returns the absolute path representation of the given file path as a string. Constraints * The input string will always be in a format recognizable by the current operating system. * Path strings can be very long but within a reasonable length for current OS path limits. Examples ```python assert resolve_full_path(\\"~/documents/file.txt\\") == \\"/home/username/documents/file.txt\\" assert resolve_full_path(\\"../file.txt\\") == \\"/current/directory/of/calling/program/file.txt\\" assert resolve_full_path(\\"/absolute/path/file.txt\\") == \\"/absolute/path/file.txt\\" ``` **Note**: It’s assumed that `/home/username` is the user’s home directory and `/current/directory/of/calling/program/` is the OS\'s current working directory.","solution":"import os def resolve_full_path(path: str) -> str: Takes a file path as input and returns its absolute path. Handles user directory expansions and normalizes relative paths. # Expand the user directory if present path = os.path.expanduser(path) # Return the absolute path return os.path.abspath(path)"},{"question":"Given a singly linked list, your task is to implement a function that returns the k-th to last element of the list. You should create an implementation that is efficient in terms of both time and space complexity. # Input - A singly linked list. - An integer `k` which represents the position from the end (0-based index). # Output - The node that is k steps from the end of the list. # Constraints - Assume the linked list contains at least one node. - 0 ≤ k < n where n is the length of the linked list. # Scenario Consider a linked list where each node contains a unique integer value. This list grows dynamically in response to incoming data streams, and you need to frequently access elements close to the end, such as finding the 2nd-to-last, 4th-to-last, etc. # Implementation Requirements Implement the function: ```python def kth_to_last(head, k): # Your code here ``` You may also create additional helper functions as needed. Example ```python class Node: def __init__(self, val=None): self.val = val self.next = None def print_linked_list(head): string = \\"\\" while head.next: string += head.val + \\" -> \\" head = head.next string += head.val print(string) # Example use case: a1 = Node(1) a2 = Node(2) a3 = Node(3) a4 = Node(4) a5 = Node(5) a1.next = a2 a2.next = a3 a3.next = a4 a4.next = a5 print_linked_list(a1) # \\"1 -> 2 -> 3 -> 4 -> 5\\" # Get 2nd to last element (0,1,2... k=2) result_node = kth_to_last(a1, 2) if result_node: print(result_node.val) # Output: 3 ``` # Notes - Consider edge cases like the smallest list with a single node or the largest expected list. - Ensure robustness against incorrect k values by raising appropriate exceptions.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head, k): Returns the k-th to last element of the singly linked list. if head is None: raise ValueError(\\"The linked list is empty.\\") if k < 0: raise ValueError(\\"k should be a non-negative integer.\\") # Two pointer approach p1 = head p2 = head # Move p1 forward by k nodes for _ in range(k): if p1.next is None: raise ValueError(\\"k is larger than the length of the linked list.\\") p1 = p1.next # Move both pointers at the same pace while p1.next: p1 = p1.next p2 = p2.next return p2"},{"question":"# Symmetry Validation of Binary Trees Problem Statement You are given a binary tree. Write a function to check whether the tree is symmetric around its center. A binary tree is symmetric if and only if its left and right subtrees are mirror images of each other. For example, given the binary tree [1,2,2,3,4,4,3], the tree is symmetric: ``` 1 / 2 2 / / 3 4 4 3 ``` But the binary tree [1,2,2,null,3,null,3] is not symmetric: ``` 1 / 2 2 3 3 ``` Constraints * The number of nodes in the tree is in the range `[0, 1000]`. * The node values are of type `int` and in the range `[0, 1000]`. Function Specifications Write the following function: **Recursive Solution** ```python def is_symmetric_recursive(root: TreeNode) -> bool: pass ``` **Iterative Solution** ```python def is_symmetric_iterative(root: TreeNode) -> bool: pass ``` Input - `root`: a reference to the root node of a binary tree. Output - Returns `True` if the tree is symmetric, `False` otherwise. Example ```python # Example 1: # Input: root = [1,2,2,3,4,4,3] # Output: True # Example 2: # Input: root = [1,2,2,null,3,null,3] # Output: False ``` # Performance Requirements - Aim to implement the solution with a time complexity of O(n) and a space complexity of O(h) for the recursive approach, where h is the height of the tree. - For the iterative approach, ensure time complexity is O(n) and space complexity can be up to O(n) in the worst case. **Note**: You may assume the existence of a `TreeNode` class as defined below: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Write both recursive and iterative solutions to solve this problem.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric_recursive(root: TreeNode) -> bool: def is_mirror(t1: TreeNode, t2: TreeNode) -> bool: if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right) if not root: return True return is_mirror(root.left, root.right) def is_symmetric_iterative(root: TreeNode) -> bool: if not root: return True queue = [(root.left, root.right)] while queue: t1, t2 = queue.pop(0) if not t1 and not t2: continue if not t1 or not t2: return False if t1.val != t2.val: return False queue.append((t1.left, t2.right)) queue.append((t1.right, t2.left)) return True"},{"question":"Absolute Path Resolver You are designing a utility function for a file management system to ensure that all file paths used by the system are absolute paths. Given a file path, your function should convert it to an absolute path, expanding any user-specific directory symbols (`~`). # Function Specification Implement a function `resolve_absolute_path(path: str) -> str` that takes a single argument: - `path` (str): A string representing a file path. It may be relative or contain user directory symbols. The function should return: - A string representing the absolute path for the given input `path`. # Constraints - The input path is a non-empty string. - The input may contain user directory symbols (`~`). # Example ```python import os def resolve_absolute_path(path: str) -> str: # Your implementation here # Examples print(resolve_absolute_path(\\"~/file.txt\\")) # Expected Output: \\"/home/username/file.txt\\" (with username being the current user’s directory) print(resolve_absolute_path(\\"docs/report.pdf\\")) # Expected Output: \\"/absolute/path/to/docs/report.pdf\\" (resolved absolute path based on the current directory) ``` # Requirements 1. The solution must handle paths starting with `~` properly. 2. It should correctly resolve relative paths to absolute paths. 3. Pay attention to edge cases such as empty or malformed paths. 4. Ensure that it runs efficiently with an O(n) complexity where n is the length of the path string. # Notes: - You should not assume or use any external libraries other than `os`. - You can assume that the environment will provide valid paths.","solution":"import os def resolve_absolute_path(path: str) -> str: Resolves a given file path to an absolute path, expanding any user-specific directory symbols (~). return os.path.abspath(os.path.expanduser(path))"},{"question":"# Question: Merging Two Sorted Linked Lists You are given two sorted linked lists. Your goal is to merge these two lists into a single sorted linked list. You will implement this functionality in a function. Function Signature ```python def merge_two_sorted_lists(l1: Node, l2: Node) -> Node: pass ``` # Input * Two sorted linked lists, `l1` and `l2`, which are represented by their head nodes (instances of the `Node` class). # Output * Return the head node of the merged sorted linked list. # Constraints * The number of nodes in the linked lists is at most 10,000. * Each linked list is already sorted in ascending order. * The `Node` class is defined as follows: ```python class Node: def __init__(self, x: int): self.val = x self.next = None ``` # Example ```python # Provided linked list representations: # l1: 1 -> 2 -> 4 # l2: 1 -> 3 -> 4 # Expected output linked list representation: # 1 -> 1 -> 2 -> 3 -> 4 -> 4 ``` # Additional Information * You may assume that the given linked lists will not be circular, i.e., there will be no cycles. * Evaluate both the iterative and recursive approaches; justify your choice based on the constraints and efficiency considerations.","solution":"class Node: def __init__(self, x: int): self.val = x self.next = None def merge_two_sorted_lists(l1: Node, l2: Node) -> Node: Merges two sorted linked lists into one sorted linked list and returns its head node. dummy = Node(0) current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 else: current.next = l2 return dummy.next"},{"question":"# Next Lexicographical Permutation **Objective**: Write a function `next_bigger(num: int) -> int` that takes a non-negative integer as input and returns the next higher number that can be formed using the exact same set of digits. If no such number exists (i.e., the given number is already the highest possible permutation with those digits), the function should return -1. **Function Signature**: ```python def next_bigger(num: int) -> int: pass ``` **Input**: * `num` - A positive integer. **Output**: * An integer representing the next higher number with the same set of digits, or -1 if no such number exists. **Constraints**: * The input number will be in the range of 0 to (10^{18}). **Examples**: ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(1528452) == 1528524 assert next_bigger(138654) == 143568 assert next_bigger(54321) == -1 assert next_bigger(999) == -1 assert next_bigger(5) == -1 ``` **Explanation**: * In the case of `38276`, the next permutation is obtained by swapping the positions of the digits to form `38627`. * For `54321`, the digits are already in descending order, so there is no larger number which can be formed using the same digits, hence the output is `-1`. Thoroughly test your implementation to confirm correctness, and consider edge cases such as very small numbers or numbers with all identical digits.","solution":"def next_bigger(num: int) -> int: digits = list(str(num)) n = len(digits) # Step 1: Identify the largest index k such that digits[k] < digits[k + 1] k = -1 for i in range(n - 1): if digits[i] < digits[i + 1]: k = i # If no such index exists, the number is in descending order if k == -1: return -1 # Step 2: Identify the largest index l greater than k such that digits[k] < digits[l] l = -1 for i in range(k + 1, n): if digits[k] < digits[i]: l = i # Step 3: Swap the values of digits[k] and digits[l] digits[k], digits[l] = digits[l], digits[k] # Step 4: Reverse the sequence from digits[k + 1] to the end next_digits = digits[:k + 1] + digits[k + 1:][::-1] # Convert list of digits back to integer next_number = int(\'\'.join(next_digits)) return next_number"},{"question":"# Question: Implement Secure Key Exchange using Extended GCD Context In modern cryptographic systems, especially those using RSA, it\'s critical to compute the modular inverse of large numbers for secure key exchange. To test your understanding of number theory and the Euclidean algorithm, you need to implement a function that leverages the extended Euclidean algorithm to find the modular inverse, and another function to simulate a secure key exchange. Task 1. **Implement the Extended Euclidean Algorithm**: Using the provided description, write a function `extended_euclid(a: int, b: int) -> Tuple[int, int, int]` to compute the GCD and the coefficients. 2. **Compute the Modular Inverse**: Using the extended Euclidean algorithm, write a function `mod_inverse(a: int, m: int) -> int` to compute the modular inverse. 3. **Simulate Secure Key Exchange**: - Write a function `secure_key_exchange(p: int, q: int) -> Tuple[int, int]` that accepts two large prime numbers `p` and `q`. - Generate a public key ( n = p times q ). - Provide an encryption exponent ( e ) and compute its modular inverse modulo ( phi(n) ). - Return the public key ((e, n)) and private key ((d, n)), where ( d ) is the modular inverse of ( e ) mod ( phi(n) ). # Specifications - **Input**: - For `extended_euclid`: Two non-negative integers `a` and `b`. - For `mod_inverse`: Two positive coprime integers `a` and `m`. - For `secure_key_exchange`: Two large prime numbers `p` and `q`. - **Output**: - For `extended_euclid`: A tuple of three integers (s, t, g). - For `mod_inverse`: An integer x such that ( a cdot x equiv 1 mod m ). - For `secure_key_exchange`: A tuple containing the public key (e, n) and the private key (d, n). Constraints - Ensure that `a` and `m` are coprime for `mod_inverse` function. - Use large prime numbers for `secure_key_exchange` function (Hint: ( 10^5 < p, q < 10^6 )). Performance Requirements - The extended Euclidean algorithm should run in ( O(log(min(a, b))) ) time complexity. - The modular inverse function should validate coprimality and handle non-coprime errors appropriately. Testing your implementation will help establish your grasp of these fundamental number theory concepts critical in cryptographic practices.","solution":"from typing import Tuple def extended_euclid(a: int, b: int) -> Tuple[int, int, int]: if b == 0: return (1, 0, a) else: x1, y1, gcd = extended_euclid(b, a % b) x = y1 y = x1 - (a // b) * y1 return (x, y, gcd) def mod_inverse(a: int, m: int) -> int: x, y, gcd = extended_euclid(a, m) if gcd != 1: raise ValueError(\\"The modulus and number must be coprime.\\") else: return x % m def secure_key_exchange(p: int, q: int) -> Tuple[Tuple[int, int], Tuple[int, int]]: n = p * q phi_n = (p - 1) * (q - 1) e = 65537 # Commonly used public exponent in RSA d = mod_inverse(e, phi_n) public_key = (e, n) private_key = (d, n) return public_key, private_key"},{"question":"You are given an array of integers that may include both positive and negative numbers. Implement a function `improved_counting_sort(arr)` that uses the Counting Sort algorithm to sort the array in non-decreasing order. # Input - `arr`: A list of integers (e.g., `arr = [4, -1, -3, 2, 1, 2, 0, -2]`). # Output - Return a new list containing the sorted integers in non-decreasing order. # Constraints - The input array can be empty. - The values in the array lie within the range ([-10^6, 10^6]). # Function Signature ```python def improved_counting_sort(arr: List[int]) -> List[int]: pass ``` # Example Input: ```python arr = [4, -1, -3, 2, 1, 2, 0, -2] ``` Output: ```python [-3, -2, -1, 0, 1, 2, 2, 4] ``` # Performance Requirements - Your implementation should be efficient in terms of both time and space. - Aim for a solution with a time complexity of (O(n + k)), where (n) is the number of elements in the array and (k) is the range of the numbers. # Hints - Consider adjusting all numbers to be non-negative by shifting the values in the input array. - Use a counting array based on the shifted values and then reconstruct the sorted output.","solution":"def improved_counting_sort(arr): if not arr: return [] min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 count = [0] * range_of_elements for num in arr: count[num - min_val] += 1 sorted_arr = [] for i, cnt in enumerate(count): sorted_arr.extend([i + min_val] * cnt) return sorted_arr"},{"question":"# Question: Implementing and Analyzing the Atbash Cipher The Atbash cipher is a simple substitution cipher used historically to encode text by mapping each letter of the alphabet to its reverse (e.g., \'a\' <-> \'z\', \'b\' <-> \'y\'). You are required to implement the Atbash cipher and analyze the impacts of this cipher on different input scenarios. **Task**: Write a function `atbash_cipher(s: str) -> str` that takes a single argument `s` (a string) and returns its Atbash cipher equivalent. **Function Signature**: ```python def atbash_cipher(s: str) -> str: ``` **Input**: * `s`: A string consisting of alphabetic characters, spaces, and punctuation. **Output**: * A string that is the Atbash cipher equivalent of the input string. **Constraints**: * The input string can have a length in the range from 0 to 10^6. * The input can include both uppercase and lowercase letters. Uppercase letters should be mapped according to uppercase rules (\'A\' <-> \'Z\') and lowercase letters should follow lowercase rules (\'a\' <-> \'z\'). **Example**: ```python assert atbash_cipher(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash_cipher(\\"Hello, World!\\") == \\"Svool, Dliow!\\" assert atbash_cipher(\\"The quick brown fox\\") == \\"Gsv jfrxp yildm ulc\\" assert atbash_cipher(\\"\\") == \\"\\" ``` **Requirements**: 1. Ensure your solution maintains linear time complexity, O(n). 2. Ensure non-alphabetic characters remain unchanged. 3. Handle both uppercase and lowercase transformations correctly. **Follow-Up**: (not part of the code but for your understanding) - Discuss the security implications of using the Atbash cipher in modern cryptographic practices. - Identify challenges one might face if the input string is of maximum length (10^6 characters).","solution":"def atbash_cipher(s: str) -> str: Converts the input string to its Atbash cipher equivalent. - Uppercase letters are mapped \'A\' <-> \'Z\', \'B\' <-> \'Y\', etc. - Lowercase letters are mapped \'a\' <-> \'z\', \'b\' <-> \'y\', etc. - Non-alphabetic characters remain unchanged. result = [] for char in s: if \'a\' <= char <= \'z\': new_char = chr(219 - ord(char)) # \'a\' (97) + \'z\' (122) = 219 elif \'A\' <= char <= \'Z\': new_char = chr(155 - ord(char)) # \'A\' (65) + \'Z\' (90) = 155 else: new_char = char result.append(new_char) return \'\'.join(result)"},{"question":"# Scenario: You are implementing a basic recommender system using the Nearest Neighbor algorithm. Your task involves working with high-dimensional user preference vectors and a known set of content vectors to recommend the closest content to a user. Given a user vector and a set of content vectors, the goal is to identify and return the most similar content. # Task: * Implement the function `nearest_neighbor` which identifies and returns the content vector most similar to the user vector. * Utilize the provided distance function to determine Euclidean distance. # Function Signature: ```python def nearest_neighbor(user_vector: tuple, content_set: dict) -> tuple: pass ``` # Input: * `user_vector`: A tuple of integers representing the user\'s preference vector. * `content_set`: A dictionary where keys are tuples representing content vectors, and values are the identifiers or names of the content. # Output: * Return the identifier or name of the content that is closest to the `user_vector` based on Euclidean distance. # Constraints: * Each vector will have at least one dimension and contain non-negative integers. * The length of each vector in the content set will be the same as the length of the `user_vector`. * The content set will have at least one content vector. # Example: ```python user_vector = (3, 5, 1) content_set = { (1, 4, 2): \'Video A\', (3, 5, 6): \'Video B\', (4, 5, 1): \'Video C\' } assert nearest_neighbor(user_vector, content_set) == \'Video C\' ``` # Performance Considerations: * Efficiently implement the function to handle a modest number of vectors (~1000) and up to 100 dimensions. * Handle edge cases gracefully including empty sets or vectors of incorrect lengths with proper error messages.","solution":"import math def euclidean_distance(vector1, vector2): Compute the Euclidean distance between two vectors. return math.sqrt(sum((a - b) ** 2 for a, b in zip(vector1, vector2))) def nearest_neighbor(user_vector: tuple, content_set: dict) -> str: Finds and returns the content identifier/name most similar to the user_vector based on Euclidean distance. closest_content = None closest_distance = float(\'inf\') for content_vector, content_name in content_set.items(): distance = euclidean_distance(user_vector, content_vector) if distance < closest_distance: closest_distance = distance closest_content = content_name return closest_content"},{"question":"**Context:** You have been hired by a text analysis company and your task is to create a function that verifies if two given texts are anagrams of each other. Given limited processing time in a data-heavy environment, it\'s crucial that your solution is both efficient and thorough, correctly handling edge conditions. **Problem Statement:** Write a function `check_anagram(s1, s2)` that takes two strings `s1` and `s2` and returns `True` if `s2` is an anagram of `s1`, and `False` otherwise. Function Signature: ```python def check_anagram(s1: str, s2: str) -> bool: ``` Input: * `s1`: A string with lowercase alphabet letters, length `n` (0 ≤ n ≤ 10^6). * `s2`: A string with lowercase alphabet letters, length `m` (0 ≤ m ≤ 10^6). Output: * Return `True` if `s2` is an anagram of `s1`, otherwise return `False`. Constraints: * Both strings will consist of lowercase English letters only. * Consider edge cases like empty strings. Performance Requirements: * Time complexity: O(n + m) * Space complexity: O(1) (considering a limited alphabet size) Example: ```python assert check_anagram(\\"anagram\\", \\"nagaram\\") == True assert check_anagram(\\"rat\\", \\"car\\") == False assert check_anagram(\\"\\", \\"\\") == True assert check_anagram(\\"a\\", \\"a\\") == True assert check_anagram(\\"ab\\", \\"a\\") == False assert check_anagram(\\"abc\\", \\"cba\\") == True ``` **Requirements and Hints:** 1. The solution should not depend on the length of the input strings beyond linear scaling. 2. Note the problem requires handling all potential edge cases gracefully, including but not limited to different lengths and empty strings. 3. Ensure that the solution leverages the limited alphabet size effectively, avoiding unnecessary space utilization. 4. Consider optimizing dictionary operations or employing an alternative counting mechanism if possible to improve efficiency.","solution":"def check_anagram(s1: str, s2: str) -> bool: Returns True if s2 is an anagram of s1, False otherwise. if len(s1) != len(s2): return False # Create a count dictionary for characters in s1 count = [0] * 26 for char in s1: count[ord(char) - ord(\'a\')] += 1 for char in s2: count[ord(char) - ord(\'a\')] -= 1 for cnt in count: if cnt != 0: return False return True"},{"question":"# Comb Sort Algorithm Implementation You are provided with a partially implemented Comb Sort algorithm in the form of a Python function. Your task is to complete the function such that it correctly sorts an input list of integers in ascending order. # Scenario Imagine you are handling a large dataset with random elements with redundant nearby entries. Given this scenario, the Comb Sort algorithm can be a suitable sorting method. # Task Write a function named `comb_sort` to sort a list of integers using the Comb Sort algorithm. The function should adhere to the properties and principles of Comb Sort as described in the analysis. # Input * `arr`: A list of integers to sort. # Output * Return the sorted list of integers. # Constraints * The input list `arr` will contain at most `10^5` integers. * Each integer in the list `arr` will be within the range `[-10^9, 10^9]`. # Example ```python def comb_sort(arr): # your code here # Example usage print(comb_sort([64, 34, 25, 12, 22, 11, 90])) # Output: [11, 12, 22, 25, 34, 64, 90] print(comb_sort([5, 1, 4, 2, 8])) # Output: [1, 2, 4, 5, 8] ``` # Note * Ensure to handle edge cases like an empty list, a list with one element, or a fully sorted list. * Optimize wherever possible to maintain an efficient sorting process.","solution":"def comb_sort(arr): Sorts a list of integers using the Comb Sort algorithm. def get_next_gap(gap): To find the new gap # Shrink factor 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True # Keep running while gap is more than 1 and last iteration caused a swap while gap != 1 or swapped: # Find the next gap gap = get_next_gap(gap) swapped = False # Compare all elements with current gap for i in range(0, n - gap): if arr[i] > arr[i + gap]: # Swap arr[i] and arr[i + gap] arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"Context You are tasked with enhancing the functionality of the Pythagorean theorem function to ensure robust handling of different input scenarios, including edge cases and error conditions. The function must remain efficient and handle both typical and atypical inputs gracefully. Problem Statement Implement a Python function `enhanced_pythagoras`, which computes the unknown side of a right-angled triangle given the lengths of the other two sides, indicated by the placeholder \\"?\\" for the unknown side. The function must also incorporate thorough input validation and error handling. # Requirements: 1. Your function should handle the following inputs and constraints: * `enhanced_pythagoras(opposite, adjacent, hypotenuse)` * Parameters can be positive numeric values for known sides or string \\"?\\" for the unknown side. * Only one side can be unknown, clearly indicated by \\"?\\". 2. The function should: * Return a tuple with a string indicating which side was calculated (\\"Opposite\\", \\"Adjacent\\", or \\"Hypotenuse\\") and the calculated length. * Raise a `ValueError` with a descriptive message for invalid inputs. # Constraints: * Inputs may not be negative or zero (raised as `ValueError`). * Only one side should be unknown (raise `ValueError` if more or none are unknown). * The function should remain efficient (constant time complexity is expected). # Input Formats: ```python def enhanced_pythagoras(opposite: Union[int, str], adjacent: Union[int, str], hypotenuse: Union[int, str]) -> Tuple[str, float]: pass ``` # Output Formats: * Returns a tuple `(str, float)` indicating the calculated side and length. * Raises `ValueError` with descriptive error message for invalid inputs. Examples: ```python assert enhanced_pythagoras(\\"?\\", 4, 5) == (\\"Opposite\\", 3.0) assert enhanced_pythagoras(3, \\"?\\", 5) == (\\"Adjacent\\", 4.0) assert enhanced_pythagoras(3, 4, \\"?\\") == (\\"Hypotenuse\\", 5.0) assert enhanced_pythagoras(3, 4, 5) raised ValueError(\\"Exactly one side must be unknown\\") assert enhanced_pythagoras(\\"?\\", \\"?\\", 5) raised ValueError(\\"Exactly one side must be unknown\\") assert enhanced_pythagoras(-3, 4, \\"?\\") raised ValueError(\\"Side lengths must be positive\\") assert enhanced_pythagoras(0, 4, \\"?\\") raised ValueError(\\"Side lengths must be positive\\") ```","solution":"import math from typing import Union, Tuple def enhanced_pythagoras(opposite: Union[int, str], adjacent: Union[int, str], hypotenuse: Union[int, str]) -> Tuple[str, float]: Calculates the unknown side of a right triangle given two known sides. Parameters: - opposite (Union[int, str]): Length of the opposite side or \'?\' if unknown - adjacent (Union[int, str]): Length of the adjacent side or \'?\' if unknown - hypotenuse (Union[int, str]): Length of the hypotenuse or \'?\' if unknown Returns: - Tuple[str, float]: A tuple containing the calculated side name and length. Raises: - ValueError: If inputs are invalid or don\'t meet the constraint requirements. # Ensure there is exactly one unknown side. sides = [opposite, adjacent, hypotenuse] unknown_count = sides.count(\\"?\\") if unknown_count != 1: raise ValueError(\\"Exactly one side must be unknown\\") # Validate known sides are positive numbers. for side in sides: if side != \\"?\\" and (not isinstance(side, (int, float)) or side <= 0): raise ValueError(\\"Side lengths must be positive numbers\\") if opposite == \\"?\\": # Calculate opposite side calculated_side = math.sqrt(hypotenuse ** 2 - adjacent ** 2) return (\\"Opposite\\", round(calculated_side, 1)) elif adjacent == \\"?\\": # Calculate adjacent side calculated_side = math.sqrt(hypotenuse ** 2 - opposite ** 2) return (\\"Adjacent\\", round(calculated_side, 1)) elif hypotenuse == \\"?\\": # Calculate hypotenuse side calculated_side = math.sqrt(opposite ** 2 + adjacent ** 2) return (\\"Hypotenuse\\", round(calculated_side, 1))"},{"question":"# Objective Design and implement a `RandomizedSet` data structure that supports inserting, removing, and retrieving random elements in average O(1) time. # Context Imagine you are building a game system where each player can pick random items from an inventory. Your task is to implement the backend for this system using a `RandomizedSet` that supports fast insertions, deletions, and random retrievals. # Requirements - **insert(val)**: Inserts an item val to the set if not already present. Returns true if the item was inserted, otherwise false. - **remove(val)**: Removes an item val from the set if present. Returns true if the item was removed, otherwise false. - **random_element()**: Returns a random element from the current set of elements. Each element must have the same probability of being returned. Returns None if the set is empty. # Function Signature ```python class RandomizedSet: def insert(self, val: int) -> bool: pass def remove(self, val: int) -> bool: pass def random_element(self) -> int: pass ``` # Example ```python # Initialize the data structure rset = RandomizedSet() # Insert elements print(rset.insert(1)) # returns True print(rset.insert(2)) # returns True print(rset.insert(2)) # returns False since 2 is already in the set # Remove elements print(rset.remove(1)) # returns True print(rset.remove(3)) # returns False since 3 is not in the set # Retrieve a random element print(rset.random_element()) # returns either 2 or None if the set is empty # More operations print(rset.insert(3)) # returns True print(rset.remove(2)) # returns True print(rset.random_element()) # returns 3 or None if the set is empty ``` # Constraints - Val is an integer and can be a negative or positive value. - All operations should be performed in average O(1) time. - Handle common edge cases such as inserting or removing elements when the set is empty or handling duplicate insertions. # Performance Requirements Ensure your implementation meets the average O(1) time complexity for insert and remove operations and O(1) for retrieving a random element.","solution":"import random class RandomizedSet: def __init__(self): self.values = [] self.index_map = {} def insert(self, val: int) -> bool: if val in self.index_map: return False self.index_map[val] = len(self.values) self.values.append(val) return True def remove(self, val: int) -> bool: if val not in self.index_map: return False # Swap the element with the last element last_val = self.values[-1] index_to_replace = self.index_map[val] self.values[index_to_replace] = last_val self.index_map[last_val] = index_to_replace # Remove the val self.values.pop() del self.index_map[val] return True def random_element(self) -> int: if not self.values: return None return random.choice(self.values)"},{"question":"# Maximum Depth of a Binary Tree Problem Description You are given a binary tree. Your task is to write a function `max_height(root)` to find its maximum depth. The maximum depth of a binary tree is the number of nodes along the longest path from the root node down to the farthest leaf node. Input The function will receive the root node of the binary tree: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Output The function should return an integer which represents the maximum depth of the binary tree. Constraints * The number of nodes in the tree is in the range [0, 10^4]. * The depth of the tree can be between 0 and 10^4. Example Here is the binary tree representation: ``` 10 / 12 15 / 25 30 36 100 ``` The maximum depth of this tree is 4. Requirements 1. Your function should account for the scenario of an empty tree (`None` as the `root`). 2. You should implement an optimized solution with a clear balance between performance and memory usage. Performance Requirements * Time Complexity: O(N), where N is the number of nodes in the tree. * Space Complexity: O(N), considering the maximum depth of the recursion stack or the largest level stored in the queue. Instructions Implement the two variations of the `max_height` function using: 1. Depth-First Search (DFS) Recursive approach. 2. Breadth-First Search (BFS) Iterative approach. Note that these implementations should handle all common edge cases as described in the analysis. ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_height_dfs(root: TreeNode) -> int: # Implement your DFS approach here pass def max_height_bfs(root: TreeNode) -> int: # Implement your BFS approach here pass ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_height_dfs(root: TreeNode) -> int: Returns the maximum depth of a binary tree using DFS (recursive). if root is None: return 0 left_depth = max_height_dfs(root.left) right_depth = max_height_dfs(root.right) return max(left_depth, right_depth) + 1 def max_height_bfs(root: TreeNode) -> int: Returns the maximum depth of a binary tree using BFS (iterative). if root is None: return 0 from collections import deque queue = deque([(root, 1)]) max_depth = 0 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return max_depth"},{"question":"Implement Enhanced RandomizedSet Context: You are required to implement a data structure `EnhancedRandomizedSet` that supports the following operations with average O(1) time complexity: 1. `insert(val)`: Inserts a new item `val` to the set if not already present. 2. `remove(val)`: Removes an item `val` from the set if present. 3. `get_random_element()`: Returns a random element from the current set of elements. Each element must have the same probability of being returned. 4. `get_k_random_elements(k)`: Returns `k` random elements from the current set. Each selection must have the same probability. Your task is to implement this data structure and ensure that the new method `get_k_random_elements(k)` returns `k` unique elements if the set has at least `k` elements. If the set has fewer than `k` elements, it should return all elements. Function Signatures: ```python class EnhancedRandomizedSet: def __init__(self): pass def insert(self, val: int) -> bool: pass def remove(self, val: int) -> bool: pass def get_random_element(self) -> int: pass def get_k_random_elements(self, k: int) -> List[int]: pass ``` Input and Output Format: - `insert(val: int) -> bool`: Inserts `val` into the set. Returns `True` if `val` was not present, `False` otherwise. - `remove(val: int) -> bool`: Removes `val` from the set. Returns `True` if `val` was present, `False` otherwise. - `get_random_element() -> int`: Returns a random element from the set. - `get_k_random_elements(k: int) -> List[int]`: Returns a list of `k` unique random elements. Constraints: - The set contains only unique integers. - Operations should be expected to run in average O(1) time. - You can assume that `0 <= k <= n`, where `n` is the number of elements in the set. Example: ```python ers = EnhancedRandomizedSet() print(ers.insert(1)) # True print(ers.insert(2)) # True print(ers.insert(3)) # True print(ers.get_k_random_elements(2)) # [1, 2] or any other combination of size 2 print(ers.remove(2)) # True print(ers.get_random_element()) # 1 or 3 ``` Implement the above class definition and ensure it meets the provided constraints and functionality.","solution":"import random class EnhancedRandomizedSet: def __init__(self): self.vals = [] self.val_to_index = {} def insert(self, val: int) -> bool: if val in self.val_to_index: return False self.val_to_index[val] = len(self.vals) self.vals.append(val) return True def remove(self, val: int) -> bool: if val not in self.val_to_index: return False last_val = self.vals[-1] idx_to_remove = self.val_to_index[val] self.vals[idx_to_remove] = last_val self.val_to_index[last_val] = idx_to_remove self.vals.pop() del self.val_to_index[val] return True def get_random_element(self) -> int: return random.choice(self.vals) def get_k_random_elements(self, k: int) -> list: return random.sample(self.vals, min(k, len(self.vals)))"},{"question":"Question: Byte Order Conversion Utility You are tasked with creating a utility for converting integers to byte arrays and vice versa in both big-endian and little-endian formats. This utility should help in understanding the data representation in different systems and formats. # Function Signature ```python def int_to_bytes_big_endian(num: int) -> bytes: # Your code here def int_to_bytes_little_endian(num: int) -> bytes: # Your code here def bytes_big_endian_to_int(bytestr: bytes) -> int: # Your code here def bytes_little_endian_to_int(bytestr: bytes) -> int: # Your code here ``` # Task 1. Implement the `int_to_bytes_big_endian` function, which converts a given non-negative integer to a byte string in big-endian format. 2. Implement the `int_to_bytes_little_endian` function, which converts a given non-negative integer to a byte string in little-endian format. 3. Implement the `bytes_big_endian_to_int` function, which converts a byte string in big-endian format to the corresponding integer. 4. Implement the `bytes_little_endian_to_int` function, which converts a byte string in little-endian format to the corresponding integer. # Constraints - Assume `num` is a non-negative integer (0 <= num < 2**64). - `bytestr` is a byte array that represents non-negative integers. - Optimize for efficiency where possible. # Example ```python # Example of big-endian conversion assert int_to_bytes_big_endian(305419896) == b\'x12x34x56x78\' assert bytes_big_endian_to_int(b\'x12x34x56x78\') == 305419896 # Example of little-endian conversion assert int_to_bytes_little_endian(305419896) == b\'x78x56x34x12\' assert bytes_little_endian_to_int(b\'x78x56x34x12\') == 305419896 ``` # Notes 1. Use Python\'s `deque` for the `appendleft` operation or manage with list reversal for more efficiency. 2. Check edge cases, like converting the integer `0` and very large numbers close to `2**64`. # Evaluation Your implementation will be evaluated based on: - Correctness of conversion functions. - Efficiency of algorithm implementation. - Handling of edge cases.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: Converts a non-negative integer to a big-endian byte array. return num.to_bytes((num.bit_length() + 7) // 8 or 1, byteorder=\'big\') def int_to_bytes_little_endian(num: int) -> bytes: Converts a non-negative integer to a little-endian byte array. return num.to_bytes((num.bit_length() + 7) // 8 or 1, byteorder=\'little\') def bytes_big_endian_to_int(bytestr: bytes) -> int: Converts a big-endian byte array to a non-negative integer. return int.from_bytes(bytestr, byteorder=\'big\') def bytes_little_endian_to_int(bytestr: bytes) -> int: Converts a little-endian byte array to a non-negative integer. return int.from_bytes(bytestr, byteorder=\'little\')"},{"question":"# Sudoku Solver You are given a 9x9 Sudoku board. Your task is to implement a solver using a depth-first search (DFS) and backtracking technique. The objective of the solver is to fill in the missing numbers (marked as \'.\') so that every row, column, and 3x3 block contains the digits 1 to 9 exactly once. Input - A 9x9 list of lists representing the Sudoku board, `board`. - Each element in the list is either a digit \'1\'-\'9\' or \'.\' representing an empty cell. Output - The completed 9x9 Sudoku board, filled in-place. Constraints - The input board will always have a valid solution. - The Sudoku board is a 9x9 grid. Function Signature ```python def solve_sudoku(board: List[List[str]]) -> None: Solves the Sudoku puzzle by modifying the \'board\' in-place. Args: board (List[List[str]]): 9x9 Sudoku board with some cells filled and some as \'.\'. Returns: None ``` # Example Input ``` board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] ``` Output ``` [ [\\"5\\",\\"3\\",\\"4\\",\\"6\\",\\"7\\",\\"8\\",\\"9\\",\\"1\\",\\"2\\"], [\\"6\\",\\"7\\",\\"2\\",\\"1\\",\\"9\\",\\"5\\",\\"3\\",\\"4\\",\\"8\\"], [\\"1\\",\\"9\\",\\"8\\",\\"3\\",\\"4\\",\\"2\\",\\"5\\",\\"6\\",\\"7\\"], [\\"8\\",\\"5\\",\\"9\\",\\"7\\",\\"6\\",\\"1\\",\\"4\\",\\"2\\",\\"3\\"], [\\"4\\",\\"2\\",\\"6\\",\\"8\\",\\"5\\",\\"3\\",\\"7\\",\\"9\\",\\"1\\"], [\\"7\\",\\"1\\",\\"3\\",\\"9\\",\\"2\\",\\"4\\",\\"8\\",\\"5\\",\\"6\\"], [\\"9\\",\\"6\\",\\"1\\",\\"5\\",\\"3\\",\\"7\\",\\"2\\",\\"8\\",\\"4\\"], [\\"2\\",\\"8\\",\\"7\\",\\"4\\",\\"1\\",\\"9\\",\\"6\\",\\"3\\",\\"5\\"], [\\"3\\",\\"4\\",\\"5\\",\\"2\\",\\"8\\",\\"6\\",\\"1\\",\\"7\\",\\"9\\"] ] ``` # Additional Notes - The function `solve_sudoku` modifies the original board and does not return any value. - The solution should be implemented using DFS and backtracking as detailed in the algorithm analysis.","solution":"def solve_sudoku(board): def is_valid(board, row, col, num): # Check if the number is already in the current row for i in range(9): if board[row][i] == num: return False # Check if the number is already in the current column for i in range(9): if board[i][col] == num: return False # Check if the number is already in the 3x3 block start_row = row // 3 * 3 start_col = col // 3 * 3 for i in range(3): for j in range(3): if board[start_row + i][start_col + j] == num: return False return True def solve(): for row in range(9): for col in range(9): if board[row][col] == \'.\': for num in \'123456789\': if is_valid(board, row, col, num): board[row][col] = num if solve(): return True board[row][col] = \'.\' return False return True solve()"},{"question":"# Matrix Chain Multiplication (Dynamic Programming) **Objective**: Given a sequence of matrices, your task is to determine the most efficient way to multiply these matrices together. The goal is to minimize the number of scalar multiplications needed to compute the result. **Function Signature**: ```python def matrix_chain_multiplication(arr: List[int]) -> Tuple[int, List[List[int]]]: pass ``` # Input * `arr`: a list of integers where the `i-th` integer represents the number of rows of the `i-th` matrix, and `i+1-th` integer represents the number of columns of the `i-th` matrix. # Output * Returns a tuple containing: * An integer representing the minimum number of scalar multiplications needed. * A 2D list representing the optimal ordering of matrices. # Constraints * `1 <= len(arr) <= 100` (the number of matrices will be `len(arr)-1`) * The dimensions will be positive integers. # Example ```python array = [30, 35, 15, 5, 10, 20, 25] # Here there are 6 matrices with dimensions: # 30x35, 35x15, 15x5, 5x10, 10x20, 20x25 # The optimal solution should minimize the total scalar multiplications. output = matrix_chain_multiplication(array) print(output) # Expected output: # (15125, [[0, 0, 0, 0, 0, 0, 0], [0, 0, 15750, 7875, 9375, 11875, 15125], [0, 0, 0, 2625, 4375, 7125, 10500], [0, 0, 0, 0, 750, 2500, 5375], [0, 0, 0, 0, 0, 1000, 3500], [0, 0, 0, 0, 0, 0, 5000], [0, 0, 0, 0, 0, 0, 0]]) ``` # Note - Ensure to consider edge cases where the length of the array is minimal. - Make sure to validate the constraints before use. - You are expected to implement a dynamic programming approach to solve this problem efficiently within the given constraints.","solution":"from typing import List, Tuple def matrix_chain_multiplication(arr: List[int]) -> Tuple[int, List[List[int]]]: n = len(arr) dp = [[0 for _ in range(n)] for _ in range(n)] # l is the chain length for l in range(2, n): for i in range(1, n - l + 1): j = i + l - 1 dp[i][j] = float(\'inf\') for k in range(i, j): q = dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j] if q < dp[i][j]: dp[i][j] = q return dp[1][n - 1], dp"},{"question":"# Missing Number Finder Context: You are given a sequence of unique integers ranging from 0 to n, where exactly one integer is missing. The sequence is supposed to cover every integer in the given range. Your task is to find the missing integer. Task: Write a function `find_missing_number(nums)` that takes a list of unique integers `nums` containing `n` elements. The function should return the missing integer in the range from 0 to n. Input: - A list of unique integers `nums` of length `n` where `0 <= nums[i] <= n`. Output: - An integer representing the missing number in the range. Constraints: - Time complexity must be O(n). - Space complexity must be O(1). Examples: - Input: `nums = [4, 1, 3, 0, 6, 5, 2]` - Output: `7` - Input: `nums = [0, 1, 2, 4]` - Output: `3` - Input: `nums = [1]` - Output: `0` Performance Requirements: - Ensure that your implementation handles large input sizes efficiently. - Consider edge cases, such as an empty list or a list with minimum and maximum possible lengths.","solution":"def find_missing_number(nums): Returns the missing integer in the range from 0 to n given a list containing unique integers in that range with one integer missing. n = len(nums) expected_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(expected_sum - actual_sum)"},{"question":"# Task: Determining the Number of Connected Components Consider a system where you need to determine the number of connected components after each connection is added. A connection connects two initially isolated components into a single component. This operation, repeated over time, reduces the number of disjoint components. # Problem Statement You are given a series of connections, where each connection is a pair of integers representing a connection between two components. Your task is to determine the number of connected components after each connection is added. **Input**: - An integer `n` representing the number of initially isolated components (labeled from 0 to n-1). - A list of tuples `connections`, where each tuple `(i, j)` represents a connection between components `i` and `j`. **Output**: - Return a list of integers, where each integer corresponds to the number of connected components after each connection. **Constraints**: - 1 ≤ n ≤ 10^5 - 1 ≤ len(connections) ≤ 2 * 10^5 - 0 ≤ i, j < n **Function Signature**: ```python def countComponents(n: int, connections: List[Tuple[int, int]]) -> List[int]: ``` # Example ```python # Example 1: n = 5 connections = [(0, 1), (1, 2), (3, 4), (2, 3)] # Outputs after each connection: # [4, 3, 2, 1] # Example 2: n = 3 connections = [(0, 1), (1, 2), (0, 2)] # Outputs after each connection: # [2, 1, 1] ``` # Explanation Initially, each component is isolated, forming `n` disjoint sets. As connections are added, the number of disjoint components decreases. Use the Union-Find data structure to efficiently track and merge connected components. Implement both path compression in the `find` method and union by size in the `union` method to ensure optimal performance.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size: int): self.parent = list(range(size)) self.rank = [0] * size def find(self, node: int) -> int: if self.parent[node] != node: self.parent[node] = self.find(self.parent[node]) return self.parent[node] def union(self, node1: int, node2: int) -> bool: root1 = self.find(node1) root2 = self.find(node2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 return True return False def countComponents(n: int, connections: List[Tuple[int, int]]) -> List[int]: uf = UnionFind(n) result = [] component_count = n for u, v in connections: if uf.union(u, v): component_count -= 1 result.append(component_count) return result"},{"question":"Context You are provided with a method to store and manipulate large sparse vectors efficiently. The core task involves transforming vectors into indexed-value lists and computing the dot product of two such lists. Task Write a Python function `optimized_dot_product(vector1: List[float], vector2: List[float]) -> float` that performs the following: 1. Converts the input vectors into indexed-value lists. 2. Computes and returns the dot product of the two vectors using their indexed-value lists. Expected Input and Output Formats * **Input**: * `vector1` and `vector2`: List of floats representing the vectors. * **Output**: * A single float value representing the dot product of the two vectors. Constraints * The vectors can be very large (up to (10^6) elements) and sparse, meaning most of their elements are zeros. * You must avoid unnecessary computations involving zero elements. * Optimize for both time and space complexity. Example ```python vector1 = [1.0, 0.0, 3.0, 0.0, 0.0, 0.0, 0.0, 5.0] vector2 = [0.0, 2.0, 0.0, 0.0, 3.0, 0.0, 4.0, 5.0] result = optimized_dot_product(vector1, vector2) print(result) # Output should be 25.0 ``` Performance Requirements * Your solution should efficiently handle vectors with sizes up to (10^6) elements with a significant portion being zeros. * The solution should make use of sparse vector representation for efficiency.","solution":"from typing import List def optimized_dot_product(vector1: List[float], vector2: List[float]) -> float: Computes the dot product of two sparse vectors represented as lists. # Create indexed-value lists for non-zero elements indexed_vector1 = [(i, value) for i, value in enumerate(vector1) if value != 0.0] indexed_vector2 = [(i, value) for i, value in enumerate(vector2) if value != 0.0] # Dictionaries for quick lookup dict_vector1 = dict(indexed_vector1) dict_vector2 = dict(indexed_vector2) # Compute dot product dot_product = 0.0 for index, value in dict_vector1.items(): if index in dict_vector2: dot_product += value * dict_vector2[index] return dot_product"},{"question":"Background You are working on a low-level library that requires efficient bit manipulation operations. Two important functions are designed to insert one or multiple bits at a specific position within an integer. Understanding how to manipulate bits efficiently is crucial for the performance of this library. Problem Statement Implement the two functions `insert_one_bit` and `insert_mult_bits` that allow inserting one or multiple bits at a specified position in an integer. 1. **Function 1: `insert_one_bit`** - **Input**: * `num`: An integer where the bit will be inserted. * `bit`: The bit (0 or 1) to insert. * `i`: The position at which to insert the bit (0-indexed, 0 being the least significant bit). - **Output**: The resulting integer after insertion. ```python def insert_one_bit(num, bit, i): pass ``` **Example**: ```python insert_one_bit(21, 1, 2) # Output: 45 insert_one_bit(21, 0, 2) # Output: 41 insert_one_bit(21, 1, 5) # Output: 53 insert_one_bit(21, 1, 0) # Output: 43 ``` 2. **Function 2: `insert_mult_bits`** - **Input**: * `num`: An integer where the bits will be inserted. * `bits`: An integer representing the bits to be inserted. * `len`: The number of bits to insert. * `i`: The position at which to start inserting the bits (0-indexed, 0 being the least significant bit). - **Output**: The resulting integer after insertion. ```python def insert_mult_bits(num, bits, length, i): pass ``` **Example**: ```python insert_mult_bits(5, 7, 3, 1) # Output: 47 insert_mult_bits(5, 7, 3, 0) # Output: 47 insert_mult_bits(5, 7, 3, 3) # Output: 61 ``` Constraints * You may assume that `num` is a non-negative integer. * The position `i` and the length of bits `len` will always be within valid ranges for the given integer. * The bits to be inserted will also be valid and within bounds.","solution":"def insert_one_bit(num, bit, i): Inserts a bit (0 or 1) at position i in the given integer num. Args: num (int): The integer where the bit will be inserted. bit (int): The bit (0 or 1) to insert. i (int): The position (0-indexed) at which to insert the bit. Returns: int: The resulting integer after insertion. # Create mask for all bits that are below the insertion point lower_mask = (1 << i) - 1 lower_bits = num & lower_mask # Left shift higher bits (>= i) to make space for the new bit higher_bits = num >> i higher_bits = (higher_bits << 1) | bit # Combine them together to get the new number return (higher_bits << i) | lower_bits def insert_mult_bits(num, bits, length, i): Inserts multiple bits at position i in the given integer num. Args: num (int): The integer where the bits will be inserted. bits (int): The bits to insert. length (int): The number of bits to insert. i (int): The position (0-indexed) at which to start inserting the bits. Returns: int: The resulting integer after insertion. # Create mask for all bits that are below the insertion point lower_mask = (1 << i) - 1 lower_bits = num & lower_mask # Left shift higher bits (>= i) to make space for the new bits higher_bits = num >> i higher_bits = (higher_bits << length) | bits # Combine them together to get the new number return (higher_bits << i) | lower_bits"},{"question":"# Question You are tasked with implementing a function that removes duplicate elements from a given list. Your solution should be optimized for performance. Consider an initial implementation of the function provided below. Analyze and improve this function to handle larger datasets efficiently, while maintaining the original order of elements. Function Signature ```python def remove_duplicates(array: list) -> list: pass ``` Input * A list `array` of elements, which can contain integers, strings, and boolean values. Output * A list with duplicates removed, maintaining the original order of first occurrence of each element. Example ```python remove_duplicates([1, 1 ,1 ,2 ,2 ,3 ,4 ,4 ,\\"hey\\", \\"hey\\", \\"hello\\", True, True]) # Output: [1, 2, 3, 4, \'hey\', \'hello\', True] ``` Constraints * The length of the input list `array` is at most 10^6. * Elements in the list can be integers, strings, and boolean values. * The solution must be optimized to handle large datasets efficiently. Performance Requirements * Your implementation should aim for O(n) time complexity. * Space complexity should be O(n) in the worst case scenario (when all elements are unique).","solution":"def remove_duplicates(array: list) -> list: Removes duplicate elements from the input list while maintaining the original order. :param array: List of elements which may include integers, strings, and boolean values. :return: List of elements with duplicates removed. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"Objective Implement both iterative and recursive in-order traversal functions for a binary tree. Additionally, write a function to generate a BST from a given sorted list. Problem Statement You are given a binary tree node class as defined below: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` Implement the following functions: 1. `inorder(root: Node) -> List[int]`: Iteratively performs in-order traversal of a binary tree and returns a list of visited node values. 2. `inorder_rec(root: Node) -> List[int]`: Recursively performs in-order traversal of a binary tree and returns a list of visited node values. 3. `sorted_list_to_bst(nums: List[int]) -> Node`: Given a sorted list of integers, constructs a balanced binary search tree and returns its root node. You can assume the input tree and list will contain only integers. Function Definitions ```python def inorder(root: Node) -> List[int]: # Your implementation here pass def inorder_rec(root: Node, res=None) -> List[int]: # Your implementation here pass def sorted_list_to_bst(nums: List[int]) -> Node: # Your implementation here pass ``` Constraints - The binary tree can have up to (10^4) nodes. - The sorted list can have up to (10^4) elements. - All integers in the tree and list are in the range [-10^4, 10^4]. Example: ```python # Input Tree Creation n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert inorder(n1) == [25, 50, 75, 100, 125, 150, 175] assert inorder_rec(n1) == [25, 50, 75, 100, 125, 150, 175] # Example for sorted_list_to_bst sorted_nums = [-10, -3, 0, 5, 9] root = sorted_list_to_bst(sorted_nums) assert inorder(root) == sorted_nums # The inorder traversal of the BST should match the sorted list. ``` Performance Requirement - Time complexity should be (O(n)) where (n) is the number of nodes or length of the list. - Space complexity should be (O(h)) where (h) is the height of the tree.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right # Iterative Inorder Traversal def inorder(root: Node) -> list: res = [] stack = [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() res.append(current.val) current = current.right return res # Recursive Inorder Traversal def inorder_rec(root: Node, res=None) -> list: if res is None: res = [] if root: inorder_rec(root.left, res) res.append(root.val) inorder_rec(root.right, res) return res # Convert sorted list to BST def sorted_list_to_bst(nums: list) -> Node: if not nums: return None mid_index = len(nums) // 2 root = Node(nums[mid_index]) root.left = sorted_list_to_bst(nums[:mid_index]) root.right = sorted_list_to_bst(nums[mid_index + 1:]) return root"},{"question":"# Tree Structure Printing Scenario: You are working on a project to visualize hierarchical data in the form of organizational or directory structures. You have been provided with a nested dictionary, where keys represent node names and their values are lists of strings or sub-elements (children of the nodes). Your task is to complete the function `tree_print` that prints each node and its corresponding children in a structured format. The input to the function is a dictionary representing the tree structure. Function Signature: ```python def tree_print(tree: dict) -> None: ``` Input: * `tree` (dict): A dictionary representing the tree structure. Each key-value pair in the dictionary represents a node and its children. Output: * The function should print each node and its corresponding children in the format specified in the scenario. Nodes and their children are printed in a line, and different levels of hierarchy should be easily distinguishable. Performance Requirements: * The function should efficiently handle a moderate-sized tree with up to 100 nodes. Constraints: * Each node name and its children are either strings or lists containing strings or integers. Lists within lists should be flattened and printed correctly. Example: Given the dictionary: ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', [\'Computer\', 5, \'TV\', 6], \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } ``` The output should be: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 b -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 d -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` Write code to complete the function `tree_print`.","solution":"def flatten_list(lst): flattened = [] for item in lst: if isinstance(item, list): flattened.extend(flatten_list(item)) else: flattened.append(item) return flattened def tree_print(tree): for key, values in tree.items(): flattened_values = flatten_list(values) print(f\\"{key} -> \\" + \\" -> \\".join(map(str, flattened_values)))"},{"question":"# Merge Sort with Detailed Merging Process Question Scenario You are tasked with sorting a list of integers in ascending order using a well-known sorting algorithm, Merge Sort. However, the implementation requires modifying the merge function to work in-place, minimizing extra space usage. Task Description 1. Implement the `merge_sort_inplace` function that performs the merge sort algorithm, modifying the merge function to work in-place. 2. The `merge_sort_inplace` function should follow the merge sort principles and must sort the input list in ascending order. Core Function Definition ```python def merge_sort_inplace(arr): Perform an in-place merge sort on the provided list. :param arr: List of integers to be sorted. :return: None, sort the list in-place. pass ``` Input/Output Format 1. **Input**: A list of integers. (e.g., `[4, 1, 5, 2, 3]`) 2. **Output**: The function does not return anything. The input list should be sorted in-place. 3. **Constraints**: - The input list size will not exceed 10^5 elements. - The values in the input list will range within the integer limits. Performance Requirements - The sorting algorithm must have a time complexity of O(n log n). - The in-place merge should minimize extra space usage as much as possible, ideally maintaining O(1) additional space complexity. Example ```python example_list = [3, 1, 2, 4, 6, 5] merge_sort_inplace(example_list) print(example_list) # Output should be [1, 2, 3, 4, 5, 6] ``` Additional Notes 1. Remember to handle edge cases like an empty list or a list with only one element. 2. Focus on writing clean, efficient, and bug-free code. 3. Avoid using additional lists or excessive recursion depth which can lead to stack overflow issues on large inputs.","solution":"def merge_sort_inplace(arr): Perform an in-place merge sort on the provided list. :param arr: List of integers to be sorted. :return: None, sort the list in-place. def merge(arr, start, mid, end): # In-place merge start2 = mid + 1 # If the direct merge is already sorted if arr[mid] <= arr[start2]: return # Two pointers to maintain start of both arrays to merge while start <= mid and start2 <= end: # If element 1 is in right place if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 # Shift all the elements between element 1 and element 2 to the right by 1 while index != start: arr[index] = arr[index - 1] index -= 1 arr[start] = value # Update all pointers start += 1 mid += 1 start2 += 1 def mergeSort(arr, l, r): if l < r: m = l + (r - l) // 2 mergeSort(arr, l, m) mergeSort(arr, m + 1, r) merge(arr, l, m, r) mergeSort(arr, 0, len(arr) - 1)"},{"question":"# Context You are given a coding task related to maps and spatial connectivity. You need to use the Union-Find data structure to efficiently manage and query clusters of land on a 2D grid. # Problem Statement Given a 2D grid initially filled entirely with water (represented by 0s), with operations to add land (represented by 1s), implement a function to track the number of connected land clusters (islands) after each add operation. An island is formed by connecting adjacent lands horizontally or vertically. # Requirements Write a function `num_islands(positions: List[List[int]]) -> List[int]` that takes a list of operations where each operation is a pair `[i, j]` representing converting cell (i,j) from water to land. **Function Signature**: `def num_islands(positions: List[List[int]]) -> List[int]:` # Input - `positions`: A list containing pairs of integers `[i, j]`, each representing a cell being turned from water (0) to land (1). # Output - A list of integers where the `i-th` element represents the number of islands after the `i-th` operation. # Constraints - `1 <= len(positions) <= 10^4` - Each add operation is guaranteed to be within the bounds of the grid. - No two operations will convert the same cell from water to land. # Example ```python positions = [[0,0], [0,1], [1,2], [2,1]] result = num_islands(positions) print(result) # Output: [1, 1, 2, 3] ``` # Explanation For the above example: 1. Initially, the grid is all water. 2. `[[0,0]]` means turning the cell at [0,0] to land, resulting in 1 island. 3. `[[0,0],[0,1]]` means turning the cell at [0,1] to land, still resulting in 1 island as [0,0] and [0,1] are connected. 4. `[[0,0],[0,1],[1,2]]` means turning the cell at [1,2] to land, now there are 2 separate islands. 5. `[[0,0],[0,1],[1,2],[2,1]]` means turning the cell at [2,1] to land, now there are 3 separate islands. # Notes **Performance**: Ensure your implementation handles up to 10,000 add operations efficiently. **Hint**: Use the Union-Find (Disjoint Set) data structure to manage and merge islands.","solution":"from typing import List class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size self.count = 0 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def add(self, x): self.parent[x] = x self.count += 1 def num_islands(positions: List[List[int]]) -> List[int]: if not positions: return [] max_x = max(x for x, y in positions) max_y = max(y for x, y in positions) # Create Union-Find for a large enough grid uf = UnionFind((max_x + 1) * (max_y + 1)) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] seen = set() result = [] for i, j in positions: idx = i * (max_y + 1) + j if idx not in seen: uf.add(idx) seen.add(idx) for direction in directions: ni, nj = i + direction[0], j + direction[1] neighbor_idx = ni * (max_y + 1) + nj if 0 <= ni <= max_x and 0 <= nj <= max_y and neighbor_idx in seen: uf.union(idx, neighbor_idx) result.append(uf.count) return result"},{"question":"# Coding Task: Post-Order Traversal of a Binary Tree Context: You are given a binary tree and need to perform a post-order traversal of this tree. The traversal extracts values starting from the left subtree, followed by the right subtree, and finally the root node. This type of traversal is widely used for tasks like tree deletion algorithms and expression tree evaluations. Task: Implement a function `postorder_traversal` that takes the root of a binary tree and returns a list of values representing the post-order traversal of the tree. Function Signature: ```python def postorder_traversal(root: Node) -> List[int]: # Your implementation here pass ``` Input and Output: * **Input**: - `root` (Node): The root of the binary tree. It can be `None` which signifies an empty tree. * **Output**: - List[Int]: List of node values in post-order traversal. Constraints: * The number of nodes in the tree is in the range [0, 1000]. * Tree node values are integers in the range `[-1000, 1000]`. Example: 1. Given the tree: ```plaintext 1 / 2 3 / 4 5 ``` Output: `[4, 5, 2, 3, 1]` 2. Given the tree: ```plaintext 10 20 / 15 25 ``` Output: `[15, 25, 20, 10]` Additional Notes: * You may choose either an iterative or a recursive approach to solve the problem. * Make sure to handle edge cases such as an empty tree or a tree with a single node. Good luck!","solution":"from typing import List, Optional class Node: def __init__(self, val: int = 0, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def postorder_traversal(root: Optional[Node]) -> List[int]: result = [] def traverse(node: Optional[Node]): if node is not None: traverse(node.left) traverse(node.right) result.append(node.val) traverse(root) return result"},{"question":"You are given a sequence of matrices where the (i)-th matrix has dimensions (p[i-1] times p[i]). Your task is to write a function that computes the most efficient way to multiply these matrices together. The function should return the minimum number of scalar multiplications required to compute the product and the optimal order of multiplications. # Input * An integer array (p) of length (n + 1) where (n) is the number of matrices. # Output * Return an integer representing the minimum number of scalar multiplications needed. * Print the optimal order of multiplications as well using a helper function. # Constraints * (2 leq n leq 100) * (1 leq p[i] leq 500) for all (i) # Example ```python def matrix_chain_order(array): # Your implementation here def print_optimal_solution(optimal_solution, i, j): # Your implementation here array = [30, 35, 15, 5, 10, 20, 25] matrix, optimal_solution = matrix_chain_order(array) print(\\"Minimum number of multiplications is:\\", matrix[1][len(array) - 1]) print(\\"Optimal Parenthesization is:\\") print_optimal_solution(optimal_solution, 1, len(array) - 1) # Expected Output # Minimum number of multiplications is: 15125 # Optimal Parenthesization is: ((A1(A2A3))((A4A5)A6)) ``` Make sure to handle the appropriate indexing (1-based for matrices) and implement the helper function to print the solution.","solution":"def matrix_chain_order(p): Computes the minimum number of scalar multiplications needed to multiply a chain of matrices and returns the optimal order. Parameters: p (list[int]): The dimensions of the matrices such that the i-th matrix has dimensions p[i-1] x p[i]. Returns: tuple: Minimum number of multiplications and the optimal solution matrix. n = len(p) - 1 # m[i][j] will store the minimum number of multiplications needed m = [[0 for i in range(n + 1)] for j in range(n + 1)] s = [[0 for i in range(n + 1)] for j in range(n + 1)] for l in range(2, n + 1): # l is the chain length for i in range(1, n - l + 2): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m, s def print_optimal_solution(s, i, j): Prints the optimal parenthesization of matrices. Parameters: s (list[list[int]]): The matrix storing the optimal split points. i (int): Start matrix index. j (int): End matrix index. if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(s, i, s[i][j]) print_optimal_solution(s, s[i][j] + 1, j) print(\\")\\", end=\\"\\")"},{"question":"# Question **Polynomial Class Implementation** In this assessment, you will implement additional functionality for a polynomial class that can manage polynomials and perform algebraic operations on them. # Scenario You are working on a symbolic algebra system that needs to support various polynomial operations. The current implementation handles basic functionalities but needs extension to support polynomial differentiation and integration. You need to implement methods for computing the derivative and the indefinite integral of a polynomial. # Task Implement the following methods in the given `Polynomial` and `Monomial` classes: 1. `Monomial::differentiate()` - Differentiates the monomial with respect to a specified variable. 2. `Polynomial::differentiate(variable)` - Differentiates the polynomial with respect to a specified variable. 3. `Monomial::integrate(variable)` - Integrates the monomial with respect to a specified variable. 4. `Polynomial::integrate(variable)` - Integrates the polynomial with respect to a specified variable. # Detailed Requirements Method: `Monomial::differentiate()` - **Input**: Integer representing the variable with respect to which the differentiation is to be performed. - **Output**: A new `Monomial` representing the differentiated result. - **Note**: Differentiate term-by-term using `d(ax^n)/dx = anx^(n-1)`. Method: `Polynomial::differentiate()` - **Input**: Integer representing the variable with respect to which the differentiation is to be performed. - **Output**: A new `Polynomial` representing the differentiated result. - **Note**: Differentiate each monomial in the polynomial. Method: `Monomial::integrate()` - **Input**: Integer representing the variable with respect to which the integration is to be performed. - **Output**: A new `Monomial` representing the indefinite integral. - **Note**: Integrate term-by-term using `∫ax^n dx = a/(n+1)x^(n+1)`, adding constant of integration as needed. Method: `Polynomial::integrate()` - **Input**: Integer representing the variable with respect to which the integration is to be performed. - **Output**: A new `Polynomial` representing the indefinite integral. - **Note**: Integrate each monomial in the polynomial. # Constraint - Do not simplify terms with common variables in the resulting polynomial after differentiation or integration. # Example ```python m1 = Monomial({1: 3}, 2) # Represents 2x^3 m_diff = m1.differentiate(1) # m_diff should be Monomial({1: 2}, 6) representing 6x^2 m_int = m1.integrate(1) # m_int should be Monomial({1: 4}, 0.5) representing 0.5x^4 p1 = Polynomial([Monomial({1: 3}, 2), Monomial({2: 1}, 4)]) p_diff = p1.differentiate(1) # p_diff should be Polynomial([Monomial({1: 2}, 6)]) p_int = p1.integrate(2) # p_int should be Polynomial([Monomial({1: 3}, 2), Monomial({2: 2}, 2)]) ``` # Function Signatures ```python class Monomial: def differentiate(self, variable: int) -> Monomial: pass def integrate(self, variable: int) -> Monomial: pass class Polynomial: def differentiate(self, variable: int) -> Polynomial: pass def integrate(self, variable: int) -> Polynomial: pass ``` # Notes - Ensure the differentiation and integration logic respects polynomial algebra rules. - Handle edge cases, such as differentiating a constant term (resulting in zero), and integrating a zero coefficient (resulting in a constant of integration).","solution":"class Monomial: def __init__(self, vars_degree, coefficient): self.vars_degree = vars_degree # Dictionary {variable: degree} self.coefficient = coefficient def differentiate(self, variable: int): if variable not in self.vars_degree: return Monomial({}, 0) # The differentiation of a constant is zero degree = self.vars_degree[variable] if degree == 0: return Monomial({}, 0) # The differentiation of a constant w.r.t. itself is zero new_coeff = self.coefficient * degree new_degree = degree - 1 new_vars_degree = self.vars_degree.copy() new_vars_degree[variable] = new_degree if new_degree == 0: del new_vars_degree[variable] return Monomial(new_vars_degree, new_coeff) def integrate(self, variable: int): degree = self.vars_degree.get(variable, 0) new_coeff = self.coefficient / (degree + 1) new_degree = degree + 1 new_vars_degree = self.vars_degree.copy() new_vars_degree[variable] = new_degree return Monomial(new_vars_degree, new_coeff) class Polynomial: def __init__(self, monomials): self.monomials = monomials # List of Monomial instances def differentiate(self, variable: int): differentiated_monomials = [monomial.differentiate(variable) for monomial in self.monomials] # Remove zero monomials differentiated_monomials = [m for m in differentiated_monomials if m.coefficient != 0] return Polynomial(differentiated_monomials) def integrate(self, variable: int): integrated_monomials = [monomial.integrate(variable) for monomial in self.monomials] return Polynomial(integrated_monomials)"},{"question":"# Polynomial and Monomial Manipulations In this coding assessment, you are asked to implement certain functionalities of a `Polynomial` class that allows algebraic manipulation of polynomials. The provided code snippet includes the class definitions `Monomial` and `Polynomial` with various methods for arithmetic operations, variable management, and substitution. Your task is to enhance these classes by implementing additional functionality for polynomial simplification. Task Implement the following method in the `Polynomial` class: # Simplify Polynomial The `simplify` method should: - Combine like terms in the polynomial. - Return a new simplified polynomial instance. - Simplify should ensure minimal possible variable exponents representation. Your implementation should focus on: 1. Combining like terms, i.e., terms with the same set of variables and their respective exponents irrespective of the coefficient. # Constraints 1. Polynomial terms should be represented accurately with correct coefficients. 2. The polynomial should not contain any monomials with a zero coefficient. 3. Each variable should be simplified as much as possible. Input - A polynomial represented as an instance of the `Polynomial` class. Output - A new simplified instance of the `Polynomial` class. Example ```python p1 = Polynomial([ Monomial({1: 1}, 2), Monomial({2: 3, 1: -1}, -1), Monomial({1: 1}, 3), Monomial({2: 3, 1: -1}, 1), Monomial({}, 5) ]) simplified_p1 = p1.simplify() print(simplified_p1) # Expected output: 5 + 5(a_1) + 0 (a_2)^3(a_1)^(-1) ``` The combined like terms result in a simplified version of the polynomial.","solution":"from collections import defaultdict class Monomial: def __init__(self, exponents, coefficient): Initialize a monomial. :param exponents: a dictionary where keys are variable indices and values are their exponents. :param coefficient: the coefficient of the monomial. self.exponents = exponents self.coefficient = coefficient def __eq__(self, other): return self.exponents == other.exponents and self.coefficient == other.coefficient def __hash__(self): return hash((frozenset(self.exponents.items()), self.coefficient)) def __repr__(self): term = \'*\'.join(f\'a_{k}^{v}\' if v != 1 else f\'a_{k}\' for k, v in sorted(self.exponents.items())) return f\'{self.coefficient}{(\\"*\\" + term) if term else \\"\\"}\' class Polynomial: def __init__(self, monomials): Initialize a polynomial with a list of monomials. :param monomials: a list of Monomial instances. self.monomials = monomials def simplify(self): Simplify the polynomial by combining like terms. :return: a new simplified Polynomial instance. simplified_dict = defaultdict(int) for monomial in self.monomials: frozen_exponents = frozenset(monomial.exponents.items()) simplified_dict[frozen_exponents] += monomial.coefficient simplified_monomials = [ Monomial(dict(exponents), coefficient) for exponents, coefficient in simplified_dict.items() if coefficient != 0 ] return Polynomial(simplified_monomials) def __repr__(self): return \' + \'.join(str(monomial) for monomial in self.monomials) if self.monomials else \'0\' # Example usage: p1 = Polynomial([ Monomial({1: 1}, 2), Monomial({2: 3, 1: -1}, -1), Monomial({1: 1}, 3), Monomial({2: 3, 1: -1}, 1), Monomial({}, 5) ]) simplified_p1 = p1.simplify() print(simplified_p1) # Expected output: 5 + 5*a_1"},{"question":"**Scenario**: You are tasked with developing a feature for a software application that determines the health of an organizational structure represented as a binary tree. Specifically, you need to implement functionality to compute the maximum depth of this binary tree, which could represent any multi-level hierarchy within the organization. **Task**: Write a Python function `max_depth(root)` to find the maximum depth of a binary tree. You need to implement this function using an iterative approach. Additionally, provide a secondary implementation using recursion for comparison. **Function Signature**: ```python def max_depth(root: TreeNode) -> int: pass def max_depth_recursive(root: TreeNode) -> int: pass ``` **Input**: - `root`: The root node of a binary tree. The node structure is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Output**: - Returns an integer representing the maximum depth of the tree. **Constraints**: - The number of nodes in the tree is between 0 and 10^4. - The tree\'s depth will not exceed 10^4. **Example**: Given the following binary tree: ``` 3 / 9 20 / 15 7 ``` Call `max_depth(root)` should return 3, as the maximum depth is along the path 3 -> 20 -> 15 (or 3 -> 20 -> 7). **Notes**: - Ensure optimized performance and handle edge cases effectively. - Compare your iterative solution against the provided recursive method.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right from collections import deque def max_depth(root: TreeNode) -> int: if not root: return 0 queue = deque([root]) depth = 0 while queue: depth += 1 level_length = len(queue) for _ in range(level_length): node = queue.popleft() if node.left: queue.append(node.left) if node.right: queue.append(node.right) return depth def max_depth_recursive(root: TreeNode) -> int: if not root: return 0 left_depth = max_depth_recursive(root.left) right_depth = max_depth_recursive(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Context Binary search is a fundamental algorithm for searching in a sorted array. It is effective due to its logarithmic time complexity compared to linear search. In this problem, you will demonstrate your understanding of binary search by implementing a modified version for a slightly more complex scenario. # Problem Statement Given a sorted array of integers in ascending order, you need to implement a function `find_bounds(array, value)` that returns the start and end indices of the given value in the array. If the value is not present, return [-1, -1]. # Input Format: - `array`: A list of integers in ascending order `[a1, a2, a3, ..., an]` where (1 leq n leq 10^5). - `value`: An integer to search in the array. # Output Format: - A list of two integers `[start_index, end_index]` representing the start and end indices of the value in the array. If the value doesn\'t exist in the array, return `[-1, -1]`. # Constraints: - The input array will always be sorted in ascending order. - The elements in the array and the value will be within the range of -(10^9) to (10^9). # Examples ```python assert find_bounds([1, 2, 2, 2, 3, 4, 5], 2) == [1, 3] assert find_bounds([1, 2, 3, 4, 5, 6], 4) == [3, 3] assert find_bounds([1, 2, 2, 2, 3, 4, 5], 6) == [-1, -1] assert find_bounds([], 5) == [-1, -1] ``` # Scenario Consider a dataset of login timestamps for a month, sorted in ascending order, where you need to quickly find the time range (start and end positions) when a particular user was active, represented by repeated timestamps of that user. This problem involves searching for all appearances of a specific timestamp efficiently, which makes binary search suited for it. # Task Implement the function: ```python def find_bounds(array, value): # Your Code Here ``` # Notes - Your solution should have optimal time complexity, ideally (O(log n)). - Avoid unnecessary traversals and ensure your implementation handles edge cases effectively.","solution":"def find_bounds(array, value): Returns the start and end indices of the given value in a sorted array. If the value is not present, returns [-1, -1]. def find_first(array, value): left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] >= value: right = mid - 1 else: left = mid + 1 return left if left < len(array) and array[left] == value else -1 def find_last(array, value): left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] <= value: left = mid + 1 else: right = mid - 1 return right if right >= 0 and array[right] == value else -1 start = find_first(array, value) if start == -1: return [-1, -1] end = find_last(array, value) return [start, end]"},{"question":"Problem Statement You are tasked with implementing a sorting function based on a variation of bubble sort, known as \\"Cocktail Shaker Sort\\". This algorithm sorts a list by repeatedly passing through the list in alternating directions, ensuring that the list is checked more thoroughly for any unsorted elements. Requirements * Write a function `cocktail_shaker_sort` that: - Takes a list of integers `arr` as input. - Returns the sorted list in non-decreasing order. ```python def cocktail_shaker_sort(arr): # Implement the sorting logic ``` # Input - A list of integers `arr` where `0 <= len(arr) <= 10^6`. - The list elements will lie in the range `-10^9` to `10^9`. # Output - A sorted list of integers in non-decreasing order. Constraints 1. Your solution must operate with a time complexity of O(N^2) in the worst case. 2. Ensure the sort is stable, meaning it preserves the relative order of equal elements. Example Input: ```python arr = [3, 0, 2, 5, -1, 4, 1] ``` Output: ```python [-1, 0, 1, 2, 3, 4, 5] ``` Input: ```python arr = [5, 3, 1, 2, 4] ``` Output: ```python [1, 2, 3, 4, 5] ``` Edge Cases 1. An empty list should return an empty list. 2. A list with a single element should return that element. 3. A list with all identical elements should return the list unaltered. Additional Requirement - Ensure your function performs optimally within the provided constraints for both time and space.","solution":"def cocktail_shaker_sort(arr): Sorts a list of integers using the Cocktail Shaker Sort algorithm. Args: arr (list): A list of integers to be sorted. Returns: list: The sorted list in non-decreasing order. n = len(arr) if n < 2: return arr start = 0 end = n - 1 swapped = True while swapped: swapped = False # Pass from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 # Pass from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"# Instructions You are tasked with implementing a function to decrypt a message that was encrypted using a Caesar Cipher. The encryption shifts each alphabetic character by a fixed number of positions. The decryption process involves shifting characters in the opposite direction. Write a function named `decrypt_caesar_cipher` that takes the encrypted string `s` and an integer `k` (shift value) as inputs. Return the decrypted string. # Function Signature ```python def decrypt_caesar_cipher(s: str, k: int) -> str: # Your code goes here ``` # Input - `s` (string): The encrypted message consisting of alphabetic characters and possibly other characters. - `k` (integer): The number of positions each character was shifted during the encryption. # Output - Return the decrypted string by shifting each alphabetic character in the encrypted message by `k` positions back. # Constraints - `0 <= len(s) <= 10^5` (100,000 characters) - -10^6 <= k <= 10^6 # Example Example 1 ```py s = \\"def\\" k = 3 decrypt_caesar_cipher(s, k) # Output: \\"abc\\" ``` Example 2 ```py s = \\"xyz\\" k = 2 decrypt_caesar_cipher(s, k) # Output: \\"vwx\\" ``` # Additional Notes - Ensure the function handles both uppercase and lowercase letters. - Non-alphabetic characters should remain unchanged. - Be aware of large positive and negative values of `k`. - Optimize your implementation to handle the upper limits of the input constraints efficiently. **Scenarios** - You need to recover an original document that was encrypted using the Caesar Cipher for historical analysis. - A user accidentally encrypted their files with a Caesar Cipher and does not remember the shift value used but knows it\'s the same for all files.","solution":"def decrypt_caesar_cipher(s: str, k: int) -> str: def decrypt_char(c, k): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') - k) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') - k) % 26 + ord(\'A\')) else: return c k = k % 26 # Normalize k to be within the range 0-25 return \'\'.join(decrypt_char(c, k) for c in s)"},{"question":"# Graph Traversal and Node Count You are provided an unweighted, undirected graph represented as an adjacency list where the nodes are identified by strings. Your task is to implement both Depth First Search (DFS) and Breadth First Search (BFS) traversals and calculate the number of connected components in the graph. Input - An adjacency list representation of the graph (`graph: Dict[str, List[str]]`). - A string representing the starting node (`start: str`). Output - A tuple with two sets; the first set containing all the nodes visited by DFS starting from `start`, and the second set containing all the nodes visited by BFS starting from `start`. - An integer representing the total number of connected components in the graph. Constraints - The graph is unweighted and undirected. - The number of nodes `N` is in the range 1 ≤ N ≤ 10^4. - All node identifiers are unique strings. Example ```python graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", \\"D\\", \\"E\\"], \\"C\\": [\\"A\\", \\"F\\"], \\"D\\": [\\"B\\"], \\"E\\": [\\"B\\", \\"F\\"], \\"F\\": [\\"C\\", \\"E\\"], \\"G\\": [\\"H\\"], \\"H\\": [\\"G\\"] } start = \\"A\\" # Expected output: ({\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\", \\"F\\"}, {\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\", \\"F\\"}, 2) ``` Function Signature ```python from typing import Dict, List, Tuple, Set def traverse_and_count_components(graph: Dict[str, List[str]], start: str) -> Tuple[Set[str], Set[str], int]: # Your code here ``` Task Implement the function `traverse_and_count_components` that returns the correct output for the provided input graph.","solution":"from typing import Dict, List, Tuple, Set def dfs(graph: Dict[str, List[str]], start: str, visited: Set[str]): stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: stack.append(neighbor) return visited def bfs(graph: Dict[str, List[str]], start: str, visited: Set[str]): queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited def count_connected_components(graph: Dict[str, List[str]]) -> int: visited = set() count = 0 for node in graph: if node not in visited: dfs(graph, node, visited) count += 1 return count def traverse_and_count_components(graph: Dict[str, List[str]], start: str) -> Tuple[Set[str], Set[str], int]: # Perform DFS dfs_visited = dfs(graph, start, set()) # Perform BFS bfs_visited = bfs(graph, start, set()) # Count components components_count = count_connected_components(graph) return dfs_visited, bfs_visited, components_count"},{"question":"Cycle Detection in a Linked List Given a linked list, your task is to write a function to determine if it contains a cycle. A cycle occurs when a node\'s next pointer points back to a previous node, creating a loop. Implement the function `detect_cycle(head)` using Floyd\'s Tortoise and Hare algorithm. Function Signature ```python def detect_cycle(head: Node) -> bool: ``` Input - `head` (Node): The head of a singly linked list where each node contains an integer value (`val`) and a pointer to the next node (`next`). Output - `bool`: Return `True` if there is a cycle in the linked list, otherwise return `False`. Constraints - You must solve it without using any extra space, meaning the space complexity should be O(1). - A potential maximum number of nodes is 10^4. - Node values can be any integer in the range of [-10^6, 10^6]. Example ```python class Node: def __init__(self, x): self.val = x self.next = None # Example 1 head = Node(3) node2 = Node(2) node3 = Node(0) node4 = Node(-4) head.next = node2 node2.next = node3 node3.next = node4 node4.next = node2 # cycle here print(detect_cycle(head)) # Output: True # Example 2 head2 = Node(1) node2 = Node(2) head2.next = node2 node2.next = head2 # cycle here print(detect_cycle(head2)) # Output: True # Example 3 head3 = Node(1) print(detect_cycle(head3)) # Output: False ``` Your task is to implement the function `detect_cycle` accurately and efficiently to pass all the test cases adhering to the constraints provided.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def detect_cycle(head: Node) -> bool: Determines if a cycle exists in a linked list using Floyd\'s Tortoise and Hare algorithm. :param head: Node - the head of the linked list :return: bool - True if there is a cycle, False otherwise if not head or not head.next: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Matrix Transformation Question You are given a `n x n` matrix (2D list) of integers. Write a set of functions to perform the following transformations on this matrix: 1. **Rotate Clockwise**: Rotates the matrix 90 degrees clockwise. 2. **Rotate Counterclockwise**: Rotates the matrix 90 degrees counterclockwise. 3. **Top-Left to Bottom-Right Inversion**: Inverts the matrix along the top-left to bottom-right diagonal. 4. **Bottom-Left to Top-Right Inversion**: Inverts the matrix along the bottom-left to top-right diagonal. # Input Format: - A 2D list `matrix` representing the matrix to be transformed. # Output Format: - A new 2D list representing the transformed matrix. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Example of Rotate Clockwise # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 3, 0] # ] # Example of Rotate Counterclockwise # Output: [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] # Example of Top-Left to Bottom-Right Inversion # Output: [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] # Example of Bottom-Left to Top-Right Inversion # Output: [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ``` # Functions to Implement: 1. `rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]` 2. `rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]` 3. `top_left_invert(matrix: List[List[int]]) -> List[List[int]]` 4. `bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]` # Constraints: - 1 ≤ matrix size (n) ≤ 100 # Note: - The matrix will always be a square matrix for this task. - You must avoid using any libraries for matrix multiplication or inversion, implement the transformations using basic list operations.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix 90 degrees clockwise. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix 90 degrees counterclockwise. n = len(matrix) return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: Inverts the given n x n matrix along the top-left to bottom-right diagonal. n = len(matrix) return [[matrix[j][i] for j in range(n)] for i in range(n)] def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: Inverts the given n x n matrix along the bottom-left to top-right diagonal. n = len(matrix) return [[matrix[n - j - 1][n - i - 1] for j in range(n)] for i in range(n)]"},{"question":"Minimum Repetitions for Substring Placement Context You are working as a software developer and encountered a problem where you need to determine how many times to repeat a pattern to establish another pattern within it. Problem Statement Given two strings ( A ) and ( B ), determine the minimum number of times ( A ) has to be repeated such that ( B ) is a substring of the repeated ( A ). If no such solution exists, return -1. Function Signature ```python def repeat_string(A: str, B: str) -> int: ``` Input: - You are given two strings ( A ) and ( B ) where both strings have lengths between 1 and 10000. Output: - Return an integer representing the minimum number of repetitions of ( A ) required such that ( B ) is a substring of it. - If no number of repetitions can make ( B ) a substring, return -1. Constraints: - The search process should be optimal. - Your solution should handle edge cases efficiently. Examples: ```python print(repeat_string(\\"abcd\\", \\"cdabcdab\\")) # Output: 3 print(repeat_string(\\"a\\", \\"aa\\")) # Output: 2 print(repeat_string(\\"abc\\", \\"wxyz\\")) # Output: -1 print(repeat_string(\\"abcd\\", \\"abcdabcdabcd\\")) # Output: 3 print(repeat_string(\\"abc\\", \\"cabcabca\\")) # Output: 4 ``` Hints: 1. Think about the lengths of the concatenated string to optimize the search. 2. Consider the edge cases of ( B ) having repetitive patterns. 3. Explore efficient ways of checking if a string is a substring of another. In your implementation, ensure the code handles various edge cases suitably and remains optimal in terms of both time and space complexity.","solution":"def repeat_string(A: str, B: str) -> int: Determine the minimum number of times A has to be repeated such that B is a substring of the repeated A. If no such solution exists, return -1. # Calculate the minimum and maximum number of times we might need to repeat A min_repeats = len(B) // len(A) # We might need one additional repeat because B could span between repeats for i in range(min_repeats, min_repeats + 3): if B in A * i: return i return -1"},{"question":"You are given a positive integer `n` and another integer `a` such that (text{gcd}(a, n) = 1). The order of `a` modulo `n` is the smallest positive integer `k` such that (a^k equiv 1 pmod{n}). Write a function that computes this order or returns -1 if it does not exist. # Function Signature ```python def find_order(a: int, n: int) -> int: ``` # Input - `a`: an integer where (text{gcd}(a, n) = 1) - `n`: a positive integer # Output - Return integer `k` which is the smallest positive integer satisfying (a^k equiv 1 pmod{n}), or return -1 if no such `k` exists. # Constraints - (1 leq a, n leq 10^6) # Requirements - Optimize the algorithm to be as efficient as possible within the constraint limits. - Handle all edge cases appropriately (e.g., `gcd(a, n) != 1`). # Example ```python print(find_order(2, 5)) # Output: 4 print(find_order(3, 7)) # Output: 6 print(find_order(2, 4)) # Output: -1 (since gcd(2, 4) != 1) ``` # Notes - Ensure to handle the cases where `a` and `n` are not coprime by returning -1. - Consider implementing further optimizations to handle maximum constraint values efficiently.","solution":"import math def gcd(a, b): while b: a, b = b, a % b return a def find_order(a: int, n: int) -> int: Finds the smallest positive integer k such that a^k ≡ 1 (mod n). If no such k exists, returns -1. # If gcd(a, n) != 1, then no such k exists. if gcd(a, n) != 1: return -1 # Euler\'s Totient function value of n phi_n = n phi_values = [i for i in range(1, n) if gcd(i, n) == 1] phi_n = len(phi_values) # Check for the smallest k such that a^k ≡ 1 (mod n) k = 1 current = a % n while k <= phi_n: if current == 1: return k current = (current * a) % n k += 1 return -1"},{"question":"# Question: You are given an array of integers and an integer k, and you need to implement the Misra-Gries algorithm. Your task is to identify all elements that appear at least n/k times in the array, where n is the length of the array. Implementation Details: * Implement the function `misras_gries(array, k=2)` which takes an array of integers and an optional integer k (default value is 2). * Return a dictionary where keys are the elements that appear at least n/k times and values are their respective frequencies in the array. * If no such elements exist, return `None`. Input: * `array` (List[int]): A list of integers that can have repeated elements. * `k` (int): An integer greater than or equal to 2, determining the frequency threshold. Output: * Return a dictionary with elements and their corresponding frequencies if they appear at least n/k times. If no such element exists, return `None`. Constraints: * The array size can be up to 10^5. * Each element in the array is a 32-bit signed integer. * k is at least 2 and at most 10^4. Example: ```python print(misras_gries([1,4,4,4,5,4,4])) # Output: {\'4\': 5} print(misras_gries([0,0,0,1,1,1,1])) # Output: {\'1\': 4} print(misras_gries([0,0,0,0,1,1,1,2,2], 3)) # Output: {\'0\': 4, \'1\': 3} print(misras_gries([0,0,0,1,1,1])) # Output: None ``` # Notes: * The implemented function should be efficient and handle large inputs within the constraints effectively.","solution":"def misras_gries(array, k=2): Identifies elements that appear at least n/k times in the array using the Misra-Gries algorithm. Params: - array: List[int] : list of integers with possible repetition - k: int: An integer determining the frequency threshold (default 2) Returns: - dict: dictionary with elements as keys and their frequencies as values if they appear at least n/k times - None: if no elements qualify the condition n = len(array) if k < 2 or n == 0: return None # Step 1: Initialize a counter dictionary with size k-1 counter = {} # Step 2: Use the Misra-Gries algorithm to find potential candidates for num in array: if num in counter: counter[num] += 1 elif len(counter) < k - 1: counter[num] = 1 else: for key in list(counter.keys()): counter[key] -= 1 if counter[key] == 0: del counter[key] # Step 3: Verify these candidates for key in counter.keys(): counter[key] = 0 # Reset counts for num in array: if num in counter: counter[num] += 1 # Step 4: Collect and return qualified candidates result = {key: count for key, count in counter.items() if count >= n / k} return result if result else None"},{"question":"Context Your company is developing a new software tool to analyze and store large sets of data. One of the key components of this tool is efficiently managing temporary data in a LIFO (Last-In, First-Out) order. To address this need, you must implement a stack ADT (Abstract Data Type) using an array-based approach. However, to increase the efficiency of the software, you will also implement a function to optimize the memory usage by performing dynamic expansion and shrinkage of the stack\'s underlying array. Task Implement the `DynamicArrayStack` class, an enhanced version of the `ArrayStack` class, which automatically expands the underlying array when the stack reaches full capacity and shrinks the array when the stack size decreases significantly. Requirements - Ensure the class inherits from `AbstractStack`. - Implement the following methods: - `push(value)`: Adds a new item to the top of the stack. - `pop()`: Removes the top item from the stack. - `peek()`: Returns the top item from the stack but does not remove it. - `is_empty()`: Returns `True` if the stack is empty, otherwise `False`. - Additionally, implement a `_shrink` method to reduce the size of the underlying array when the stack size is less than a quarter of the array capacity, ensuring it does not shrink below a predefined minimum size. Specifications - You may assume the initial size of the array is 10. - The array should double in size when expanded. - The array should halve in size when shrunk but should not be smaller than 10. - Throw an `IndexError` if a `pop` or `peek` operation is attempted on an empty stack. Input and Output - No specific input/output is required as the focus is on the class implementation. - Ensure the class and its methods work correctly by writing multiple use cases and edge cases in a test function. ```python class DynamicArrayStack(AbstractStack): def __init__(self, size=10): super().__init__() self._array = [None] * size self._min_size = size def __iter__(self): probe = self._top while True: if probe == -1: return yield self._array[probe] probe -= 1 def push(self, value): self._top += 1 if self._top == len(self._array): self._expand() self._array[self._top] = value def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") value = self._array[self._top] self._top -= 1 if self._top < len(self._array) // 4 and len(self._array) > self._min_size: self._shrink() return value def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self._array[self._top] def _expand(self): self._array += [None] * len(self._array) # double the size of the array def _shrink(self): new_size = max(len(self._array) // 2, self._min_size) self._array = self._array[:new_size] ``` Constraints - Aim to ensure time complexity of O(1) for `push` and `pop` operations. - Allocations and deallocations should be efficient, mimicking the behavior of an automatic memory management system. Testing Write comprehensive test cases to verify your implementation, including: - Basic operations (`push`, `pop`, `peek`, `is_empty`). - Boundary cases (expansion when full, shrinkage when under-occupied). - Error cases (operations on an empty stack).","solution":"class DynamicArrayStack: def __init__(self, initial_capacity=10): self._array = [None] * initial_capacity self._top = -1 self._min_size = initial_capacity def push(self, value): self._top += 1 if self._top == len(self._array): self._expand() self._array[self._top] = value def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") value = self._array[self._top] self._top -= 1 if self._top < len(self._array) // 4 and len(self._array) > self._min_size: self._shrink() return value def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self._array[self._top] def is_empty(self): return self._top == -1 def _expand(self): new_capacity = len(self._array) * 2 new_array = [None] * new_capacity for i in range(len(self._array)): new_array[i] = self._array[i] self._array = new_array def _shrink(self): new_size = max(len(self._array) // 2, self._min_size) new_array = self._array[:new_size] self._array = new_array"},{"question":"You are provided with a list of floating point numbers. Your task is to write a function called `bucket_sort` that sorts these numbers using the bucket sort algorithm. Additionally, make improvements to handle poor distributions efficiently. Ensure that the bucket sort is not only competitive in best-case scenarios but also capable of handling edge cases and poor distributions effectively. # Function Signature ```python def bucket_sort(arr: List[float]) -> List[float]: pass ``` # Input: * `arr`: A list of floating point numbers. (0 ≤ len(arr) ≤ 10^5) # Output: * A list of floating point numbers sorted in ascending order. # Constraints: * The values in the list `arr` will be within the range [0, 1). * You cannot use Python\'s in-built sort functions. * Optimize the function to perform efficiently even with non-uniform distributions. # Example: ```python assert bucket_sort([0.45, 0.12, 0.89, 0.39, 0.71]) == [0.12, 0.39, 0.45, 0.71, 0.89] assert bucket_sort([0.23, 0.56, 0.22, 0.78, 0.35]) == [0.22, 0.23, 0.35, 0.56, 0.78] assert bucket_sort([]) == [] ``` # Notes: * Provide comprehensive handling of all edge cases. * Ensure your function remains efficient and utilizes memory judiciously. * Justify your choice of sorting method for individual buckets.","solution":"from typing import List import math def insertion_sort(bucket): Helper function to sort an individual bucket using insertion sort, which is efficient for small datasets. for i in range(1, len(bucket)): key = bucket[i] j = i - 1 while j >= 0 and bucket[j] > key: bucket[j + 1] = bucket[j] j -= 1 bucket[j + 1] = key return bucket def bucket_sort(arr: List[float]) -> List[float]: Sorts a list of floating point numbers in the range [0, 1) using the bucket sort algorithm. This function handles non-uniform distributions efficiently by using a dynamic number of buckets. if len(arr) == 0: return arr # Determine the number of buckets to use num_buckets = len(arr) buckets = [[] for _ in range(num_buckets)] # Distribute the elements into buckets for value in arr: bucket_index = math.floor(num_buckets * value) buckets[bucket_index].append(value) # Sort individual buckets and concatenate results sorted_array = [] for bucket in buckets: if bucket: sorted_array.extend(insertion_sort(bucket)) return sorted_array"},{"question":"# Question Context You are implementing a text-based editor that needs to frequently search and replace words in large documents and keep track of count or other aggregate information. To efficiently handle the editing and query operations, you decide to use a segment tree. Task Implement a `SegmentTree` class that supports efficient updates and range queries by adhering to the following specification: 1. **Constructor**: ```python def __init__(self, arr, function): Initializes the segment tree with the provided array and function. Args: arr (list): The initial array to build the segment tree from. function (callable): A commutative function used for combining the values. pass ``` 2. **build_tree**: Builds the segment tree from an array. ```python def build_tree(self): Builds the segment tree from the specified array. pass ``` 3. **update**: Updates the value at an index and reflects the change in the tree. ```python def update(self, p, v): Updates the value at index p with a new value v. Args: p (int): Index to be updated. v: New value. pass ``` 4. **query**: Queries the range and returns the result based on the function. ```python def query(self, l, r): Queries the range [l, r] and returns the aggregated result using the function. Args: l (int): Left index of the query range. r (int): Right index of the query range. Returns: The query result. pass ``` Example ```python # Example 1: Using the max function on an initial array mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 # Example 2: Using a sum function (lambda a, b: a + b) mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 # Example 3: Working with tuples for multivalue aggregation mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Output: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Output: (4, 10) ``` Constraints 1. Array length can be up to (10^5). 2. The function should be commutative and able to handle input types effectively (integers, floats, tuples, etc.). 3. Queries and updates should run in logarithmic time. Requirements 1. Implement the `SegmentTree` class with required functions. 2. Ensure that the solution is efficient, handling edge cases appropriately. 3. Follow proper coding standards and include necessary comments.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.arr = arr self.function = function self.tree = [None] * (2 * self.n) self.build_tree() def build_tree(self): # Initialize leaves in the tree for i in range(self.n): self.tree[self.n + i] = self.arr[i] # Initialize internal nodes in the tree for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, idx, value): # Update value in the array idx += self.n self.tree[idx] = value # Update the segment tree nodes while idx > 1: idx //= 2 self.tree[idx] = self.function(self.tree[2 * idx], self.tree[2 * idx + 1]) def query(self, left, right): result = None left += self.n right += self.n + 1 while left < right: if left % 2: if result is None: result = self.tree[left] else: result = self.function(result, self.tree[left]) left += 1 if right % 2: right -= 1 if result is None: result = self.tree[right] else: result = self.function(result, self.tree[right]) left //= 2 right //= 2 return result"},{"question":"You are given an (n times n) 2D matrix `mat` representing an image. You are required to write a function `rotate(mat)` that rotates the image by 90 degrees (clockwise) in place. Function Signature ```python def rotate(mat: List[List[int]]) -> None: ``` Input - `mat`: a list of `n` lists, each containing `n` integers, representing the matrix/image to be rotated. Output The function should modify the input matrix `mat` to represent the image rotated by 90 degrees clockwise. It should do this in place and not return anything. Constraints - (1 leq n leq 1000) - You must perform this operation in-place. Example ```python # Input mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Output # After rotation, mat should be: [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Follow-up Could you implement the solution in a recursive manner or by partitioning the matrix?","solution":"from typing import List def rotate(mat: List[List[int]]) -> None: Rotate the n x n matrix mat by 90 degrees (clockwise) in place. n = len(mat) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j] # Step 2: Reverse each row for i in range(n): mat[i].reverse()"},{"question":"# Overview You are tasked with implementing a function to find coordinates in an m x n matrix where water can flow to both the Pacific and Atlantic Oceans, using Depth-First Search (DFS). # Function Specification Implement a function `pacific_atlantic(matrix: List[List[int]]) -> List[List[int]]`: **Input**: - `matrix`: a list of lists of integers representing an m x n matrix where each element is the height of the cell. **Output**: - Return a list of lists of integers as coordinates where water can flow to both Pacific and Atlantic Oceans. # Constraints - The dimensions of the matrix `matrix` will always be less than 150. - Elements of the matrix are non-negative integers. # Example ```python matrix = [ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4] ] print(pacific_atlantic(matrix)) ``` Expected Output: ``` [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] ``` # Details - The Pacific ocean touches the left and top edges of the matrix. - The Atlantic ocean touches the right and bottom edges. - Water can flow from one cell to another only if the adjacent cell\'s height is equal or lower. Write an efficient function considering both time and space complexity.","solution":"from typing import List def pacific_atlantic(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) pacific_reach = [[False] * n for _ in range(m)] atlantic_reach = [[False] * n for _ in range(m)] def dfs(x, y, reach): reach[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not reach[nx][ny] and matrix[nx][ny] >= matrix[x][y]: dfs(nx, ny, reach) for i in range(m): dfs(i, 0, pacific_reach) dfs(i, n - 1, atlantic_reach) for j in range(n): dfs(0, j, pacific_reach) dfs(m - 1, j, atlantic_reach) result = [] for i in range(m): for j in range(n): if pacific_reach[i][j] and atlantic_reach[i][j]: result.append([i, j]) return result"},{"question":"# Question: Implement an iterative version of the binomial coefficient calculation. Your task is to write a function that calculates and returns the binomial coefficient C(n, k) using an iterative approach to avoid the issues caused by deep recursion. Requirements: - **Function signature**: `def iterative_binomial_coefficient(n, k):` - **Input**: - `n` (integer): The total number of items. - `k` (integer): The number of items to choose. - **Output**: - Returns the binomial coefficient C(n, k). - **Constraints**: - 0 <= k <= n # Example: ```python print(iterative_binomial_coefficient(5, 0)) # Output: 1 print(iterative_binomial_coefficient(8, 2)) # Output: 28 print(iterative_binomial_coefficient(500, 300)) # Massive number output ``` Performance: - Ensure the implementation handles large values of n and k efficiently. Tips: - Use the property C(n, k) = C(n, n-k) to minimize calculations where applicable.","solution":"def iterative_binomial_coefficient(n, k): Calculate binomial coefficient C(n, k) using iterative approach. Parameters: n (int): Total number of items. k (int): Number of items to choose. Returns: int: Binomial coefficient C(n, k). # Use the property C(n, k) = C(n, n - k) if k > n - k: k = n - k result = 1 for i in range(k): result = result * (n - i) // (i + 1) return result"},{"question":"Context Given a list `lst` and an integer `N`, we want to transform this list such that no element appears more than `N` times, while maintaining the original order of elements. This question is designed to test your understanding of managing element frequencies and optimizing list operations. Task Implement a function `limit_element_frequency(lst: List[int], N: int) -> List[int]` that takes a list of integers `lst` and a positive integer `N`, and returns a new list with each element appearing at most `N` times, preserving the order of first occurrences. Input * `lst` (List[int]): The input list of integers, where `0 <= len(lst) <= 10^5`. * `N` (int): The maximum number of times any element can appear in the output list, where `0 <= N <= 10^5`. Output * Returns a list with the constrained frequency of elements. Constraints - You must maintain the original order of elements. - The solution should have a time complexity close to (O(n)) for efficient processing of large lists. Examples ```python >>> limit_element_frequency([1,2,3,1,2,1,2,3], 2) [1,2,3,1,2,3] >>> limit_element_frequency([20,37,20,21], 1) [20, 37, 21] >>> limit_element_frequency([], 2) [] >>> limit_element_frequency([1, 1, 1], 0) [] ``` Notes - If `N` is zero, the output list should be empty regardless of the input list. - You can assume that the list elements are non-negative integers.","solution":"from typing import List def limit_element_frequency(lst: List[int], N: int) -> List[int]: Returns a list with each element appearing at most N times, preserving the original order. if N == 0: return [] freq = {} result = [] for num in lst: if num in freq: if freq[num] < N: result.append(num) freq[num] += 1 else: result.append(num) freq[num] = 1 return result"},{"question":"# Rabin-Miller Primality Test Function Implementation As a programming student, your task is to implement the Rabin-Miller primality test that determines if a given number ( n ) is a prime. The test is probabilistic with a tunable parameter ( k ) determining the number of iterations to increase confidence in the result. Function Signature ```python def is_prime(n: int, k: int) -> bool: ``` Input - `n` (int): A positive integer ( n geq 2 ) to be tested for primality. - `k` (int): Number of iterations to perform the test, which influences the confidence level. Output - Returns a boolean result: * `True` if ( n ) is probably prime. * `False` if ( n ) is definitely not prime (composite). Constraints - For small values of ( n < 5 ), handle the scenarios distinctly. - Ensure optimal performance for very large values of ( n ). Example Usage ```python print(is_prime(17, 5)) # Output: True (Probably prime) print(is_prime(18, 5)) # Output: False (Composite) print(is_prime(19, 5)) # Output: True (Probably prime) print(is_prime(20, 5)) # Output: False (Composite) ``` Detailed Instructions 1. Implement the helper function `pow2_factor(num: int) -> (int, int)` to factor the number into a power of 2 times an odd number. 2. Implement the helper function `valid_witness(a: int, n: int, r: int, d: int) -> bool` to check if the chosen witness invalidates the primality of ( n ). 3. Use these helper functions within `is_prime(n: int, k: int) -> bool` to make the primality check robust and efficient. Performance Note - Ensure to implement modular exponentiation efficiently for large numbers using Python\'s in-built `pow` function which supports three arguments, i.e., `pow(base, exp, mod)`. Good luck, and ensure to test thoroughly with different values of ( n ) and ( k ) for covering edge cases and performance.","solution":"import random def pow2_factor(num): Factoring out the power of 2 from the number r = 0 d = num while d % 2 == 0: d //= 2 r += 1 return r, d def valid_witness(a, n, r, d): Check if a is a witness to the compositeness of n x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True def is_prime(n, k): Perform the Rabin-Miller primality test to determine if n is a prime number. :param n: The number to be tested for primality. :param k: Number of iterations to increase confidence level. :return: True if n is probably prime, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write (n - 1) as 2^r * d such that d is odd r, d = pow2_factor(n - 1) for _ in range(k): a = random.randint(2, n - 2) if valid_witness(a, n, r, d): return False return True"},{"question":"You\'ve been given a sequence of unique integers in the range `[0..n]`, but one number from the sequence is missing. Your task is to implement a function that finds the missing number. Function Signature ```python def find_missing_number(nums: List[int]) -> int: ``` # Input - A list of unique integers, `nums`, of length `n`, where each integer is in the range `[0..n]`. # Output - The single missing integer from the list. # Constraints 1. The list contains `n` unique integers from the range `[0..n]`. 2. No two integers in the list are the same. 3. Integers within the list are within the specified range. # Example Example 1: ```plaintext Input: nums = [4, 1, 3, 0, 2] Output: 5 ``` Example 2: ```plaintext Input: nums = [0, 1, 2, 3] Output: 4 ``` # Performance Requirements Your solution should have an overall time complexity of O(n) and a space complexity of O(1). # Additional Information - Verify your implementation against edge cases such as an empty list or a list with the smallest and largest possible values. Implement the `find_missing_number` function that adheres to the given requirements and constraints.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Returns the single missing integer from the list nums. nums: A list of unique integers in the range [0, n] with one number missing. # Length of the list n = len(nums) # Sum of the first n+1 natural numbers total_sum = (n * (n + 1)) / 2 # Sum of the numbers in the list actual_sum = sum(nums) # The missing number is the difference between expected sum and actual sum missing_number = total_sum - actual_sum return int(missing_number)"},{"question":"# Coding Challenge: Implementing Minimum Range Query with Segment Tree Context You are given an array of integers, and you need to frequently query the minimum value in various subranges of this array. To efficiently handle these range minimum queries, you decide to use a Segment Tree. Task Implement a Segment Tree that can handle minimum range queries. Specifically, you need to write two methods: 1. `__init__`: Constructor to initialize and build the segment tree. 2. `query`: Method to handle range minimum queries. Instructions 1. **Initialization**: - Constructor takes an array of integers and builds the segment tree structured to handle minimum queries. 2. **Range Query**: - `query(L, R)`: Returns the minimum value in the subarray from index `L` to `R` (inclusive). Constraints - The length of the array, `n`, is between 1 and 10^5. - Array values are between -10^9 and 10^9. - Queries will be frequent (up to 10^5). Example ```python # Example usage arr = [2, 4, 5, 3, 4] min_tree = SegmentTree(arr) print(min_tree.query(1, 3)) # Output: 3 print(min_tree.query(0, 4)) # Output: 2 ``` Implementation Notes - Ensure the segment tree is implemented to cater to minimum queries. - Optimize for both time and space complexity. **Your implementation should handle constructing the segment tree and performing efficient minimum range queries.**","solution":"class SegmentTree: def __init__(self, arr): Initialize the segment tree with the given array. self.n = len(arr) self.tree = [0] * (2 * self.n) # Build the segment tree self.build(arr) def build(self, arr): # Initialize leaves at the end of the tree array for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the rest of the tree by calculating minimum values for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, L, R): Query the minimum value in the range [L, R] (inclusive). L += self.n R += self.n minimum = float(\'inf\') while L <= R: if L % 2 == 1: minimum = min(minimum, self.tree[L]) L += 1 if R % 2 == 0: minimum = min(minimum, self.tree[R]) R -= 1 L //= 2 R //= 2 return minimum"},{"question":"You are required to implement a function to solve a classic coding problem often referred to as \\"FizzBuzz\\". Your task is to write a function that takes a single integer, `n`, and returns an array of integers from 1 to `n` inclusive with the following modifications: - Replace numbers divisible by 3 with the string \\"Fizz\\". - Replace numbers divisible by 5 with the string \\"Buzz\\". - Replace numbers divisible by both 3 and 5 with the string \\"FizzBuzz\\". # Function Signature ```python def fizzbuzz(n: int) -> list: # Your implementation here pass ``` # Input - An integer, `n` (1 ≤ n ≤ 10^4). # Output - A list of length n. # Constraints: - The input will always be a valid integer. - For simplicity, your code does not need to handle `n < 1` or non-integer inputs. # Example ```python fizzbuzz(15) # Output: [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] ``` # Context This exercise is commonly used in programming interviews to test basic implementation skills, conditional logic handling, and familiarity with loops and list operations.","solution":"def fizzbuzz(n: int) -> list: Returns a list from 1 to n inclusive with modifications: - Replace numbers divisible by 3 with \\"Fizz\\" - Replace numbers divisible by 5 with \\"Buzz\\" - Replace numbers divisible by both 3 and 5 with \\"FizzBuzz\\" result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"Problem Description You are tasked with writing a function to determine if two strings are case-sensitive anagrams of each other. An anagram of a string is another string that contains the same characters, only the order of characters can be different. The function should consider case sensitivity, meaning \'A\' and \'a\' are different characters. Function Signature ```python def is_case_sensitive_anagram(s: str, t: str) -> bool: Determine if t is a case-sensitive anagram of s. Parameters: s (str): The first string. t (str): The second string. Returns: bool: True if t is a case-sensitive anagram of s, False otherwise. pass ``` Input * Two strings `s` and `t` each containing at most 100,000 characters. * The strings can have uppercase and lowercase English letters. Output * Return `True` if `t` is a case-sensitive anagram of `s`, otherwise return `False`. Constraints * Strings `s` and `t` can contain any printable ASCII characters. * The comparison should be case-sensitive. Examples ```python assert is_case_sensitive_anagram(\\"Listen\\", \\"Silent\\") == False assert is_case_sensitive_anagram(\\"Triangle\\", \\"Integral\\") == False assert is_case_sensitive_anagram(\\"Apple\\", \\"ppale\\") == False assert is_case_sensitive_anagram(\\"Apple\\", \\"apple\\") == False assert is_case_sensitive_anagram(\\"dormitory\\", \\"dirtyroom\\") == True assert is_case_sensitive_anagram(\\"A gentleman\\", \\"Elegant man\\") == False ``` Performance Requirements * Aim for a solution with O(n) time complexity and O(1) space complexity if possible, where n is the length of the inputs.","solution":"def is_case_sensitive_anagram(s: str, t: str) -> bool: Determine if t is a case-sensitive anagram of s. Parameters: s (str): The first string. t (str): The second string. Returns: bool: True if t is a case-sensitive anagram of s, False otherwise. if len(s) != len(t): return False from collections import Counter return Counter(s) == Counter(t)"},{"question":"# Write a Min Binary Heap Class Objective Implement a Min Binary Heap class that supports efficient insertion and removal of the smallest element. Instructions 1. Implement the `BinaryHeap` class in Python using the following method signatures: - `__init__(self)`: Initializes an empty heap. - `insert(self, val)`: Inserts a new value into the heap while maintaining the heap property. - `remove_min(self)`: Removes and returns the smallest element from the heap while maintaining the heap property. - `perc_up(self, i)`: Moves the element at index `i` up until the heap property is restored. - `perc_down(self, i)`: Moves the element at index `i` down until the heap property is restored. - `min_child(self, i)`: Returns the index of the smaller child of the element at index `i`. 2. Your task: - Implement a class `BinaryHeap` based on the above method signatures. - Ensure all operations have the correct time complexities: - Insertion: O(log N) - Removal of the minimum element: O(log N) 3. **Constraints**: - The heap will only store integer values to simplify comparisons. Example ```python heap = BinaryHeap() heap.insert(4) heap.insert(50) heap.insert(7) heap.insert(55) heap.insert(90) heap.insert(87) print(heap.heap) # Output should display the heap structure in array form print(heap.remove_min()) # Output should be 4, the smallest element print(heap.heap) # Heap after removing the minimum element ``` Expected Output ```python # Inserting values and checking internal state [0, 4, 50, 7, 55, 90, 87] 4 [0, 7, 50, 87, 55, 90] ``` Follow-Up Question How would you modify the class to efficiently handle situations where frequent bulk insertions are expected? Please explain your approach in the comments or in a separate method implementation.","solution":"class BinaryHeap: def __init__(self): self.heap = [0] self.current_size = 0 def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def perc_down(self, i): while (i * 2) <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def min_child(self, i): if i * 2 + 1 > self.current_size: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def remove_min(self): min_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return min_val"},{"question":"Matrix Exponentiation Challenge # Problem Statement You are given a square matrix `mat` of size `d x d` and a positive integer `power`. Write a function `fast_matrix_exponentiation` to compute the matrix raised to the given power using repeated squaring method. # Function Signature ```python def fast_matrix_exponentiation(mat: list, power: int) -> list: pass ``` # Input * `mat`: A list of lists where each inner list represents a row of the matrix. `mat[i][j]` represents the element at the ith row and jth column. * `power`: A non-negative integer representing the power to which the matrix must be raised (0 ≤ power ≤ 10000). # Output * Return the resulting matrix after it has been raised to the specified power. # Constraints * The matrix `mat` will be a square matrix with dimensions 1 ≤ d ≤ 20. * Elements in `mat` are integers between `-100` and `100`. # Examples ```python # Example 1 mat = [[1, 2], [3, 4]] power = 2 print(fast_matrix_exponentiation(mat, power)) # Output: [[7, 10], [15, 22]] # Example 2 mat = [[2]] power = 3 print(fast_matrix_exponentiation(mat, power)) # Output: [[8]] # Example 3 mat = [[5, 0, 0], [0, 5, 0], [0, 0, 5]] power = 5 print(fast_matrix_exponentiation(mat, power)) # Output: [[3125, 0, 0], [0, 3125, 0], [0, 0, 3125]] # Example 4 mat = [[1, 2], [2, 4]] power = 0 print(fast_matrix_exponentiation(mat, power)) # Output: [[1, 0], [0, 1]] ``` # Notes * Ensure your implementation is optimized to handle the upper constraints efficiently. * Carefully handle edge cases, especially when `power` is 0.","solution":"def matrix_mult(A, B): Multiplies two matrices A and B. Assumes that A and B are square matrices of same dimensions. n = len(A) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): result[i][j] += A[i][k] * B[k][j] return result def matrix_identity(size): Creates an identity matrix of the given size. identity = [[1 if i == j else 0 for j in range(size)] for i in range(size)] return identity def fast_matrix_exponentiation(mat, power): Computes the matrix `mat` raised to the power `power` using repeated squaring. n = len(mat) result = matrix_identity(n) # Initialize result as the identity matrix base = mat # Base starts as the given matrix while power > 0: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result"},{"question":"# Diffie-Hellman Key Exchange Simulation Implement a simplified version of the Diffie-Hellman key exchange as follows: Function Signatures: ```python def diffie_hellman_key_exchange(a: int, p: int, print_keys: bool = False) -> bool: Perform Diffie-Hellman key exchange. :param a: An integer, the primitive root modulo p. :param p: A large prime integer. :param print_keys: Optional; if set to True, print out the keys. :return: True if the shared keys computed by both parties match, False otherwise. pass ``` Implementation Details: 1. **Prime Check**: - Verify if `p` is a prime number. Use the provided `prime_check` function. 2. **Primitive Root Check**: - Ensure `a` is a primitive root modulo `p`. Use the provided `find_primitive_root` function. 3. **Private and Public Key Generation**: - Generate private keys using `alice_private_key` and `bob_private_key`. - Generate public keys using `alice_public_key` and `bob_public_key`. 4. **Shared Secret Calculation**: - Compute the shared secret keys using `alice_shared_key` and `bob_shared_key`. 5. **Key Comparison**: - Compare the shared secret keys computed by both parties. Return `True` if they match, otherwise return `False`. Input Constraints: - `a` and `p` are positive integers, where `p` is a prime number. - `a` should be a valid primitive root of `p`. Example: ```python # Example usage: a = 2 # primitive root modulo p p = 23 # a prime number result = diffie_hellman_key_exchange(a, p, print_keys=True) # Should print keys and return True print(result) # p should be a prime number, otherwise the function should return False invalid_p = 20 # not a prime number result = diffie_hellman_key_exchange(a, invalid_p, print_keys=True) print(result) # Should return False ``` Notes: - Ensure proper validation and handling of input parameters. - Optionally, included a flag `print_keys` to print out the private and public keys, and verify intermediate results.","solution":"import sympy def prime_check(p): return sympy.isprime(p) def find_primitive_root(p): if not prime_check(p): return -1 for a in range(2, p): powers = set(pow(a, i, p) for i in range(1, p)) if len(powers) == p - 1: return a return -1 def diffie_hellman_key_exchange(a: int, p: int, print_keys: bool = False) -> bool: Perform Diffie-Hellman key exchange. :param a: An integer, the primitive root modulo p. :param p: A large prime integer. :param print_keys: Optional; if set to True, print out the keys. :return: True if the shared keys computed by both parties match, False otherwise. if not prime_check(p): return False if find_primitive_root(p) != a: return False # Private keys (these would normally be randomly chosen and secret) alice_private_key = 6 bob_private_key = 15 # Public keys alice_public_key = pow(a, alice_private_key, p) bob_public_key = pow(a, bob_private_key, p) if print_keys: print(\\"Alice\'s private key:\\", alice_private_key) print(\\"Alice\'s public key:\\", alice_public_key) print(\\"Bob\'s private key:\\", bob_private_key) print(\\"Bob\'s public key:\\", bob_public_key) # Shared secret computation alice_shared_key = pow(bob_public_key, alice_private_key, p) bob_shared_key = pow(alice_public_key, bob_private_key, p) if print_keys: print(\\"Alice\'s shared key:\\", alice_shared_key) print(\\"Bob\'s shared key:\\", bob_shared_key) return alice_shared_key == bob_shared_key"},{"question":"# Objective You are tasked with implementing a function to check for cycles in a directed graph using the Depth-First Search (DFS) algorithm. Your solution should efficiently determine if there is any cycle in the given directed graph. # Function Signature ```python def contains_cycle(graph: Dict[str, List[str]]) -> bool: ``` # Input * `graph`: A dictionary where each key is a vertex, and the corresponding value is a list of vertices it has directed edges to. - For example: `{\'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': []}` # Output * Returns a boolean value: - `True` if the graph contains at least one cycle. - `False` if there are no cycles in the graph. # Constraints * The graph can have up to 1,000 vertices and 10,000 edges. * Vertices are represented by unique strings. * Graph does not necessarily contain any edges (it can be an empty set). # Requirements 1. Implement the function using Depth-First Search (DFS) with appropriate state management. 2. Ensure the function handles edge cases such as: * Single vertex with no edges. * Fully connected components. * Disconnected or isolated nodes. 3. Optimize for both execution time and space utilization. 4. Consider potential recursion limits and provide an iterative alternative if necessary. # Example Example 1 # Input: ```python { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } ``` # Output: `True` Example 2 # Input: ```python { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [] } ``` # Output: `False` Implement the function `contains_cycle` that accepts the described input and produces the correct output.","solution":"def contains_cycle(graph): This function checks for cycles in a directed graph using Depth-First Search (DFS). Parameters: graph (dict): A dictionary where each key is a vertex, and the corresponding value is a list of vertices it has directed edges to. Returns: bool: True if the graph contains at least one cycle, False otherwise. def dfs(vertex): # Mark the vertex as currently being visited visited[vertex] = True recursion_stack[vertex] = True # Explore all the adjacent vertices for neighbor in graph.get(vertex, []): if not visited[neighbor]: # If the neighbor has not been visited yet, recurse on it if dfs(neighbor): return True elif recursion_stack[neighbor]: # If the neighbor is in the recursion stack, we have found a cycle return True # Remove the vertex from recursion stack recursion_stack[vertex] = False return False visited = {vertex: False for vertex in graph} recursion_stack = {vertex: False for vertex in graph} # Perform DFS from each vertex that has not been visited yet for node in graph: if not visited[node]: if dfs(node): return True return False"},{"question":"You are tasked with implementing a custom image compression algorithm using Run-Length Encoding (RLE). Your program should have the ability to compress and decompress a string representing pixel data. **Function to Implement**: 1. `compress_image(data: str) -> str`: This function takes a string of image data and returns its compressed form using RLE. 2. `decompress_image(data: str) -> str`: This function takes a compressed string of image data and returns the original image data. # Inputs and Outputs: compress_image - **Input**: A string `data` representing the image pixel data. - Example: `\\"AAABBBCDDD\\"` - **Output**: A string `compressed_data` representing the compressed image data. - Example: `\\"3A3B1C3D\\"` decompress_image - **Input**: A string `compressed_data` representing the compressed image pixel data. - Example: `\\"3A3B1C3D\\"` - **Output**: A string `data` representing the original image data. - Example: `\\"AAABBBCDDD\\"` # Constraints: - The input strings will only contain upper-case alphabetic characters (\'A\'-\'Z\'). - The decompressed string will have a length `≤ 10^6`. # Performance Requirements: - Your solution should handle compressing and decompressing strings up to length `10^6` efficiently (within reasonable time limits). # Example: ```python # Example use case print(compress_image(\\"AAABBBCDDD\\")) # Output should be \\"3A3B1C3D\\" print(decompress_image(\\"3A3B1C3D\\")) # Output should be \\"AAABBBCDDD\\" ``` Your task is to complete the implementation of both functions to ensure they work correctly for the described scenario and constraints.","solution":"def compress_image(data: str) -> str: Compresses the image data using Run-Length Encoding (RLE). :param data: str - The original image data. :return: str - The compressed image data. if not data: return \\"\\" compressed = [] count = 1 prev_char = data[0] for char in data[1:]: if char == prev_char: count += 1 else: compressed.append(f\\"{count}{prev_char}\\") count = 1 prev_char = char compressed.append(f\\"{count}{prev_char}\\") return \\"\\".join(compressed) def decompress_image(data: str) -> str: Decompresses the image data compressed using Run-Length Encoding (RLE). :param data: str - The compressed image data. :return: str - The decompressed image data. if not data: return \\"\\" decompressed = [] count = \\"\\" for char in data: if char.isdigit(): count += char else: decompressed.append(char * int(count)) count = \\"\\" return \\"\\".join(decompressed)"},{"question":"# Decoding Count Challenge You are given a message encoded with numbers where each number maps to a letter between \'A\' and \'Z\' (i.e., \'1\' -> \'A\', \'2\' -> \'B\', ..., \'26\' -> \'Z\'). Your task is to write a function to determine the total number of ways to decode the given encoded message. # Task Implement the function `count_decodings(encoded_message: str) -> int` that calculates the total number of possible decodings of the input `encoded_message`. # Input * `encoded_message` - A string composed of digits representing the encoded message (`1` <= length of encoded_message <= `100`). # Output * An integer representing the total number of ways to decode the given `encoded_message`. # Constraints * The input `encoded_message` will not be empty and will not contain any characters other than digits. * \'0\' cannot be decoded alone but can form valid pairs like \'10\' or \'20\'. * The decoding is case-sensitive by definition, and numeric strings should be within the 1-26 inclusive range for valid decodings. # Examples ```python assert count_decodings(\\"12\\") == 2 # (\\"AB\\" or \\"L\\") assert count_decodings(\\"226\\") == 3 # (\\"BBF\\", \\"BZ\\", \\"VF\\") assert count_decodings(\\"0\\") == 0 # Invalid assert count_decodings(\\"10\\") == 1 # (\\"J\\") assert count_decodings(\\"100\\") == 0 # Invalid sequence ``` # Notes * Consider edge cases like numbers containing \'0\' and ensure proper handling. * Focus on efficient implementation both in terms of time and space to cater to the constraints given.","solution":"def count_decodings(encoded_message: str) -> int: if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) # dp[i] represents the number of ways to decode the message up to the i-th character dp = [0] * (n + 1) dp[0] = 1 # An empty string can be decoded in one way (doing nothing) dp[1] = 1 # A single character (not \'0\') can be decoded in one way for i in range(2, n + 1): one_digit = int(encoded_message[i - 1:i]) two_digits = int(encoded_message[i - 2:i]) if 1 <= one_digit <= 9: # Single valid character dp[i] += dp[i - 1] if 10 <= two_digits <= 26: # Valid character formed by two digits dp[i] += dp[i - 2] return dp[n]"},{"question":"You are given an undirected graph represented as an adjacency list. Implement two functions: `dfs_traverse_complete(graph)` and `bfs_traverse_complete(graph)` that traverse the entire graph using Depth-First Search (DFS) and Breadth-First Search (BFS) respectively. The traversal should handle disconnected graphs, ensuring all nodes are visited. # Function Signatures ```python def dfs_traverse_complete(graph: dict) -> set: pass def bfs_traverse_complete(graph: dict) -> set: pass ``` # Inputs * `graph` (dict): A dictionary where keys are node identifiers and values are lists of adjacent nodes. # Outputs * Return a set of all visited nodes. Both functions should return the same set, containing all nodes in the graph. # Constraints * The graph has at most (1000) nodes. * The graph can be disconnected. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } assert dfs_traverse_complete(graph) == {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'} assert bfs_traverse_complete(graph) == {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'} ``` # Requirements * Your solution should handle graphs with disconnected components. * Consider graphs with cycles. * Ensure your implementation does not get stuck in infinite loops. * Avoid using global variables. # Execution Time * Function should execute efficiently within a reasonable time frame considering the constraints.","solution":"def dfs_traverse_complete(graph: dict) -> set: def dfs(node, visited): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) for neighbor in graph.get(current, []): if neighbor not in visited: stack.append(neighbor) visited = set() for node in graph: if node not in visited: dfs(node, visited) return visited def bfs_traverse_complete(graph: dict) -> set: from collections import deque def bfs(start, visited): queue = deque([start]) while queue: current = queue.popleft() if current not in visited: visited.add(current) for neighbor in graph.get(current, []): if neighbor not in visited: queue.append(neighbor) visited = set() for node in graph: if node not in visited: bfs(node, visited) return visited"},{"question":"As a software engineer, you are tasked with creating an efficient function to find the starting index of the first occurrence of a given substring (needle) within a main string (haystack), similar to the built-in `strstr()` function found in many programming languages. However, in this task, you need to implement an optimized solution that improves performance for large inputs. Write a function `optimized_strStr(haystack, needle)` that takes two strings, `haystack` and `needle`, and returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. Your implementation must improve upon the provided basic approach by applying a more advanced algorithm like the Knuth-Morris-Pratt (KMP) algorithm. # Input - `haystack` (string): The main string in which to search the `needle`. Length is in the range [0, 10^5]. - `needle` (string): The substring to search in the `haystack`. Length is in the range [0, 10^4]. # Output - (int): The starting index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Constraints - The search should be case-sensitive. - An empty `needle` should return 0. - If `needle` is longer than `haystack`, return -1. # Performance Requirements - Aim for an algorithm with linear time complexity, ideally O(m + n), where *m* is the length of `needle` and *n* is the length of `haystack`. # Example ```python # Example 1: haystack = \\"hello\\" needle = \\"ll\\" # Output: 2 # Example 2: haystack = \\"aaaaa\\" needle = \\"bba\\" # Output: -1 ```","solution":"def optimized_strStr(haystack, needle): Returns the index of the first occurrence of the needle in the haystack using the KMP search algorithm. if not needle: return 0 if len(needle) > len(haystack): return -1 # Preprocess the needle to get the lps array (Longest Prefix Suffix) def computeLPSArray(needle): lps = [0] * len(needle) length = 0 # Length of the previous longest prefix suffix i = 1 while i < len(needle): if needle[i] == needle[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = computeLPSArray(needle) i = 0 # Index for haystack j = 0 # Index for needle while i < len(haystack): if needle[j] == haystack[i]: i += 1 j += 1 if j == len(needle): return i - j elif i < len(haystack) and needle[j] != haystack[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"You are tasked with enhancing the provided priority queue implementation. Specifically, you need to design and implement a more efficient priority queue using a binary heap, which will optimize the insertion time complexity. **Objective**: Implement a `HeapPriorityQueue` class with methods for insertion and extraction of the highest-priority item. # Specifications **Class Definition**: ```python class HeapPriorityQueue: def __init__(self): # Initialize an empty heap-based priority queue pass def push(self, item, priority=None): # Inserts an item with the specified priority into the priority queue. pass def pop(self): # Removes and returns the item with the highest priority from the priority queue. pass def size(self): # Returns the number of elements in the priority queue. pass ``` **Input/Output**: - `push(item, priority)`: Inserts an `item` with the specified `priority`. If `priority` is not provided, it defaults to the value of the item. - **Input**: item (any type), priority (numeric, optional). - **Output**: None. - `pop()`: Removes and returns the item with the highest priority. - **Input**: None. - **Output**: The item with the highest priority. - `size()`: Returns the number of elements in the priority queue. - **Input**: None. - **Output**: Integer, the size of the queue. **Constraints**: - All priorities are unique numeric values. - Item can be of any hashable type. - The priority queue should support operations maintaining a complexity of O(log n) for both insertion and extraction. **Example**: ```python pq = HeapPriorityQueue() pq.push(\'task1\', priority=3) pq.push(\'task2\', priority=1) pq.push(\'task3\', priority=2) assert pq.pop() == \'task2\' assert pq.size() == 2 pq.push(\'task4\', priority=0) assert pq.pop() == \'task4\' ``` # Notes - Use a binary heap (min-heap) to ensure that both insertion and extraction operations are efficient. - Handle edge cases, especially when the priority queue is empty during extraction. - Ensure that your implementation passes the given example and additional test cases.","solution":"import heapq class HeapPriorityQueue: def __init__(self): # Initialize an empty heap-based priority queue self.heap = [] def push(self, item, priority=None): # Inserts an item with the specified priority into the priority queue if priority is None: priority = item heapq.heappush(self.heap, (priority, item)) def pop(self): # Removes and returns the item with the highest priority from the priority queue if not self.heap: raise IndexError(\\"pop from an empty priority queue\\") return heapq.heappop(self.heap)[1] def size(self): # Returns the number of elements in the priority queue return len(self.heap)"},{"question":"You are required to implement a **doubly linked list** from scratch with the following functionalities: inserting at the head, inserting at the tail, deleting a node by value, and reversing the list. Function Signatures ```python class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): pass def insert_at_tail(self, value): pass def delete_by_value(self, value): pass def reverse(self): pass def to_list(self): Helper method to convert list to a python list for testing. pass ``` # Requirements * **insert_at_head(value)**: Insert a new node with the given value at the head of the list. This operation should have a time complexity of O(1). * **insert_at_tail(value)**: Insert a new node with the given value at the tail of the list. This operation should have a time complexity of O(1). * **delete_by_value(value)**: Delete the first node that contains the given value. If the value is not found, do nothing. This operation should have a time complexity of O(n). * **reverse()**: Reverse the list, such that the head becomes the tail and the tail becomes the head. This operation should have a time complexity of O(n). * **to_list()**: Convert the linked list to a standard Python list for result verification. # Constraints - The maximum number of elements (`n`) in the list can be up to 10^5. # Example ```python dll = DoublyLinkedList() dll.insert_at_head(1) dll.insert_at_head(2) dll.insert_at_tail(3) dll.insert_at_tail(4) dll.delete_by_value(3) print(dll.to_list()) # Expected: [2, 1, 4] dll.reverse() print(dll.to_list()) # Expected: [4, 1, 2] ``` Explanation In this example: 1. `insert_at_head(1)` results in list: [1] 2. `insert_at_head(2)` results in list: [2, 1] 3. `insert_at_tail(3)` results in list: [2, 1, 3] 4. `insert_at_tail(4)` results in list: [2, 1, 3, 4] 5. `delete_by_value(3)` results in list: [2, 1, 4] 6. `reverse()` results in list: [4, 1, 2] Ensure that your implementation takes into account the edge cases where the list might be empty or the operations involve the head or tail of the list.","solution":"class Node: def __init__(self, value, prev=None, next=None): self.value = value self.prev = prev self.next = next class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = Node(value) if self.head is None: self.head = new_node self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_tail(self, value): new_node = Node(value) if self.tail is None: self.head = new_node self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_by_value(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return current = current.next def reverse(self): current = self.head prev_node = None self.tail = self.head while current: next_node = current.next current.next = prev_node current.prev = next_node prev_node = current current = next_node self.head = prev_node def to_list(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result"},{"question":"# Subset Generation with Bitwise Operations **Context:** In many real-world applications, such as combinatorial optimization, power set generation, and decision-making problems, generating all possible subsets of a given set of elements is a crucial task. This problem leverages the elegance of bitwise operations to generate all possible subsets efficiently. **Problem Statement:** Given a set of distinct integers, implement a function `generate_subsets(nums)` to return all possible subsets of the given set. The solution must ensure all subsets generated are unique and correspond correctly to the input set. **Function Signature:** ```python def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: ``` **Input:** - `nums`: A list of distinct integers. Constraints: (0 leq |nums| leq 20) **Output:** - A set of tuples, where each tuple is a unique subset of the given list `nums`. **Example:** ```python # Example 1: nums = [1, 2, 3] # Expected Output: {(1, 2), (1, 3), (1,), (2,), (3,), (1, 2, 3), (), (2, 3)} # Example 2: nums = [] # Expected Output: {()} ``` **Constraints:** - The function must not produce duplicate subsets. - The function should efficiently handle edge cases, such as empty lists. **Performance Requirements:** - The function should have a time complexity of O(n * 2^n), where n is the length of `nums`. - Space complexity should be O(2^n) to store all subsets. **Implementation Tips:** - Utilize bitwise operations to enumerate and generate subsets. - Iteratively generate each subset by considering the binary representation of indices. Your task is to implement the `generate_subsets(nums)` function that meets the above criteria.","solution":"from typing import List, Set, Tuple def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: Generates all possible subsets of the given list of distinct integers. Args: nums: List of distinct integers. Returns: Set of tuples, each representing a unique subset of the list. n = len(nums) subsets = set() for i in range(1 << n): # 1 << n is 2^n subset = tuple(nums[j] for j in range(n) if i & (1 << j)) subsets.add(subset) return subsets"},{"question":"# Question: Compute the Maximum Depth of a Binary Tree Given the structure of a binary tree, your task is to write a Python function that determines its maximum depth. The maximum depth is defined as the number of nodes along the longest path from the root node down to the farthest leaf node. You are to implement this using an iterative approach (using BFS). Function Signature ```python def max_depth(root: \'TreeNode\') -> int: ``` Input * `root`: The root node of a binary tree. Each node contains an integer value and pointers to its left and right children. Output * Return an integer representing the maximum depth of the binary tree. Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * The `TreeNode` class is predefined as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Example Consider the following binary tree: ``` 3 / 9 20 / 15 7 ``` If root is the node with value 3, the call to `max_depth(root)` should return `3` since the longest path from the root to the farthest leaf involves three nodes: 3 -> 20 -> 15 or 3 -> 20 -> 7. Note * Handle edge cases such as an empty tree or a tree with only one node. Scenario You are a software engineer tasked with implementing functionality for a large database where hierarchical data structures are commonly used. Efficiently calculating the maximum depth of these trees will help optimize the storage and queries in the database.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_depth(root: TreeNode) -> int: if not root: return 0 queue = deque([(root, 1)]) max_depth = 0 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return max_depth"},{"question":"# Coding Challenge Given an unsorted array of integers, your task is to implement the Cycle Sort algorithm to sort the array in place. The goal is to sort the array with the minimum number of write operations. Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: ``` Input - An array of integers `arr` where `1 <= len(arr) <= 10^4` and elements are within the range from `-10^6` to `10^6`. Output - A sorted array of integers. Performance Requirements - Use the Cycle Sort algorithm to perform the sorting. - Time complexity: (O(n^2)) in average and worst cases. - Space complexity: (O(1)) (in-place sorting). Constraints - The algorithm should be implemented in such a way that it minimizes the number of write operations. Example ```python # Example 1 input: [3, 4, 1, 2, 5] output: [1, 2, 3, 4, 5] # Example 2 input: [5, 3, 1, 2, 2] output: [1, 2, 2, 3, 5] ``` Notes - Your implementation should also account for duplicate elements in the array and handle them correctly. - Consider edge cases such as empty arrays or arrays with a single element. - Do not use any built-in sort functions.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: Sorts the array using Cycle Sort algorithm. n = len(arr) # Traverse the array and place elements at their correct position for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find the correct position for item pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If item is already in correct position if pos == cycle_start: continue # Skip duplicates while item == arr[pos]: pos += 1 # Swap the item with item in its correct position if pos != cycle_start: arr[pos], item = item, arr[pos] # Rotate the rest to put items in correct positions while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 if item != arr[pos]: arr[pos], item = item, arr[pos] return arr"},{"question":"# Priority Queue Optimization A logistics company uses a priority queue to organize delivery packages based on their priority, where high priority packages need to be delivered first. The current priority queue implementation uses a linear array, leading to inefficiencies in insertion operations. You are tasked with optimizing this priority queue by implementing a binary heap, which should improve the time complexity for inserting elements. The updated priority queue must support insertion and extraction operations efficiently. Function Signature You need to implement the following class: ```python class OptimizedPriorityQueue: def __init__(self, items=None, priorities=None): pass def size(self): pass def push(self, item, priority=None): pass def pop(self): pass ``` # Requirements * **Complexity**: - The `push` operation should run in O(log n) time. - The `pop` operation should run in O(log n) time. * **Input/Output**: - `__init__(self, items=None, priorities=None)`: Initialize the priority queue. If `items` and `priorities` are provided, initialize the queue with these elements. - `size(self)`: Return the number of elements in the priority queue. - `push(self, item, priority=None)`: Insert a new item with an optional priority. If the priority is not provided, use the item\'s value as its priority. - `pop(self)`: Remove and return the item with the highest priority. # Constraints 1. If `priorities` are not given during initialization, each item\'s priority is assumed to be the item\'s value. 2. If attempting to `pop` from an empty queue, raise an `IndexError`. # Example ```python # Example usage: pq = OptimizedPriorityQueue(items=[5, 3, 8], priorities=[10, 15, 5]) print(pq.size()) # Output: 3 pq.push(2, priority=20) print(pq.size()) # Output: 4 print(pq.pop()) # Output: 2 (highest priority) ``` # Performance Requirements Your solution should be efficient enough to handle up to 100,000 operations within a reasonable time frame.","solution":"import heapq class OptimizedPriorityQueue: def __init__(self, items=None, priorities=None): self.heap = [] if items is not None: if priorities is not None: for item, priority in zip(items, priorities): heapq.heappush(self.heap, (-priority, item)) else: for item in items: heapq.heappush(self.heap, (-item, item)) def size(self): return len(self.heap) def push(self, item, priority=None): if priority is None: priority = item heapq.heappush(self.heap, (-priority, item)) def pop(self): if not self.heap: raise IndexError(\\"pop from empty priority queue\\") return heapq.heappop(self.heap)[1]"},{"question":"# Filtering Array Elements by Bounds You are given an array of integers `arr` and optional integer parameters `min_lim` and `max_lim`. Your task is to implement a function `limit(arr, min_lim=None, max_lim=None)` that filters and returns the elements of the array that lie within the range `[min_lim, max_lim]` inclusive. If `min_lim` is not provided, all values less than or equal to `max(arr)` should be considered. If `max_lim` is not provided, all values greater than or equal to `min(arr)` should be included. Return the filtered array in the same order as they appeared in the input array. # Function Signature ```python def limit(arr: list[int], min_lim: int = None, max_lim: int = None) -> list[int]: ``` # Input - `arr`: A list of integers (0 <= len(arr) <= 10^6) - `min_lim` (optional): An integer representing the minimum value (inclusive). Default is None. - `max_lim` (optional): An integer representing the maximum value (inclusive). Default is None. # Output - A list of integers which fall within the given bounds `[min_lim, max_lim]`. # Constraints - If `arr` is empty, return an empty list. - If `min_lim` is None, consider the minimum value to be negative infinity. - If `max_lim` is None, consider the maximum value to be positive infinity. # Examples ```python assert limit([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert limit([10, 15, 20, 25, 30], 15, 25) == [15, 20, 25] assert limit([5, 10, 15, 20], 10) == [10, 15, 20] assert limit([1, 2, 3, 4, 5], 6, 10) == [] ``` # Explanation - For the first example, elements less than or equal to 3 are included. - For the second example, elements between 15 and 25 inclusive, are included. - For the third example, as `max_lim` is not provided, all elements greater than or equal to 10 are included. - For the fourth example, no elements fall within the range 6 to 10. # Edge Cases - Handle empty arrays by returning an empty array. - Handle cases where no elements fit within the given bounds by returning an empty array. Implement the function `limit` considering optimal time and space complexity constraints.","solution":"def limit(arr, min_lim=None, max_lim=None): Filters and returns elements of the array within the bounds [min_lim, max_lim] inclusive. if min_lim is None and max_lim is None: return arr filtered_arr = [] if min_lim is None: min_lim = float(\'-inf\') if max_lim is None: max_lim = float(\'inf\') for num in arr: if min_lim <= num <= max_lim: filtered_arr.append(num) return filtered_arr"},{"question":"# Question: Count Set Bits Using Brian Kernighan\'s Algorithm Given an unsigned integer, write a function to return the number of \'1\' bits (Hamming weight) in its binary representation. Use Brian Kernighan\'s algorithm for the implementation. You need to provide both recursive and iterative solutions. Your task is to implement the following two functions: 1. `count_ones_recur(n: int) -> int` 2. `count_ones_iter(n: int) -> int` Input: * An unsigned integer `n`. Output: * An integer representing the number of \'1\' bits in the binary representation of `n`. Constraints: * 0 <= n <= 2^32 - 1 Performance Requirements: * Both functions should run in O(k) time complexity, where k is the number of \'1\' bits. * The iterative function should have a constant space complexity. Examples: 1. Input: `n = 11` Output: `3` Explanation: The binary representation of 11 is `00000000000000000000000000001011`, which has three \'1\' bits. 2. Input: `n = 128` Output: `1` Explanation: The binary representation of 128 is `00000000000000000000000010000000`, which has one \'1\' bit. 3. Input: `n = 255` Output: `8` Explanation: The binary representation of 255 is `00000000000000000000000011111111`, which has eight \'1\' bits. Implement the functions to ensure they handle edge cases and perform efficiently.","solution":"def count_ones_recur(n: int) -> int: Count the number of \'1\' bits using recursive Brian Kernighan\'s Algorithm. if n == 0: return 0 return 1 + count_ones_recur(n & (n - 1)) def count_ones_iter(n: int) -> int: Count the number of \'1\' bits using iterative Brian Kernighan\'s Algorithm. count = 0 while n: n &= n - 1 # Drop the lowest set bit count += 1 return count"},{"question":"# Word Dictionary with Wildcard Search You are tasked with implementing a word dictionary with two primary operations: adding words and searching words using wildcard characters. The placeholder character for wildcard searches is \'.\' which matches any single letter. Implement the class `WordDictionary` with the following methods: Methods: - **`add_word(word: str) -> None`** - Adds a word into the word dictionary. - **Parameters**: - `word` (str): the word to add into the dictionary. - **`search(word: str) -> bool`** - Returns if the word is in the dictionary. A word could contain the wildcard character \'.\' to represent any one letter. - **Parameters**: - `word` (str): the word to search for in the dictionary. It could contain the wildcard character \'.\'. - **Returns**: - `bool`: `True` if the word is found in the dictionary, `False` otherwise. Example: ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") assert wd.search(\\"pad\\") == False, \\"Failed Test Case\\" assert wd.search(\\"bad\\") == True, \\"Failed Test Case\\" assert wd.search(\\".ad\\") == True, \\"Failed Test Case\\" assert wd.search(\\"b..\\") == True, \\"Failed Test Case\\" ``` Constraints: - The words added to the dictionary will consist only of lowercase English letters. - The search string might contain the \'.\' character which matches any single letter. - The length of the word to add or search will be at most 100. Note: Your solution should be efficient with respect to both time and space complexity. Consider edge cases such as searching for an empty string or adding words of various lengths. Implement the `WordDictionary` class with the required methods `add_word` and `search`.","solution":"class WordDictionary: def __init__(self): self.words = {} def add_word(self, word: str) -> None: length = len(word) if length not in self.words: self.words[length] = [] self.words[length].append(word) def search(self, word: str) -> bool: length = len(word) if length not in self.words: return False for w in self.words[length]: if self._matches(w, word): return True return False def _matches(self, word: str, pattern: str) -> bool: for i in range(len(word)): if pattern[i] != \'.\' and pattern[i] != word[i]: return False return True"},{"question":"Context The number 89 is the first integer with more than one digit whose digits when raised up to consecutive powers give the same number. For example, 89 = 8**1 + 9**2 gives the number 89. The next number after 89 with this property is 135 = 1**1 + 3**2 + 5**3 = 135. You are to write a function that returns a list of such numbers within a specified range. Task Implement a function: ```python def find_digit_power_sums(low: int, high: int) -> List[int]: pass ``` Requirements - The function should accept two integers, `low` and `high`, which define the inclusive range `[low, high]`. - The function should return a list of integers within the range `[low, high]` for which the sum of their digits raised to consecutive powers equals the number itself. - The solution should handle the scenario where no numbers in the given range satisfy the condition. Example ```python # Input print(find_digit_power_sums(1, 100)) # Output # [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] print(find_digit_power_sums(90, 150)) # Output # [135] ``` Constraints - All numbers `low` and `high` will be in the range `1 <= low <= high <= 10^4`. - The function should handle edge cases, including ranges with no such numbers. Performance - Aim to optimize the solution to run efficiently within the given input constraints.","solution":"from typing import List def find_digit_power_sums(low: int, high: int) -> List[int]: Returns a list of integers within the range [low, high] for which the sum of their digits raised to consecutive powers equals the number itself. def is_digit_power_sum(n: int) -> bool: digits = [int(d) for d in str(n)] return sum(d ** (i + 1) for i, d in enumerate(digits)) == n return [n for n in range(low, high + 1) if is_digit_power_sum(n)]"},{"question":"Context You are developing a software module for sorting inventory counts of different items in a warehouse. The item counts are non-negative integers and typically range between 0 and 1000. Given the nature of the data, you decide to implement the Pigeonhole Sort due to its efficiency when handling numbers with a limited range. Task Implement the `pigeonhole_sort` function that sorts an array of non-negative integers using the Pigeonhole Sort algorithm. Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input - `arr`: A list of non-negative integers (0 ≤ arr[i] ≤ 1000). Output - A sorted list of integers. Constraints - The list size will not exceed 10,000 elements. - The value of integers in the list ranges from 0 to 1000. - Optimize for both time and space efficiency based on the given constraints. Performance Requirements - Time Complexity: O(n + R), where n is the number of elements in the list, and R is the range of possible values in the array. - Space Complexity: O(R). Example ```python assert pigeonhole_sort([8, 3, 2, 7, 4, 6, 8]) == [2, 3, 4, 6, 7, 8, 8] assert pigeonhole_sort([0, 1, 0, 1, 0]) == [0, 0, 0, 1, 1] assert pigeonhole_sort([5, 3, 6, 1, 3, 5, 7, 9, 2]) == [1, 2, 3, 3, 5, 5, 6, 7, 9] ``` Notes - Consider edge cases such as all equal elements, empty list, and very small lists with a large range. - Ensure your solution properly handles the boundaries given in the constraints.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return arr min_value = min(arr) max_value = max(arr) range_size = max_value - min_value + 1 holes = [0] * range_size for num in arr: holes[num - min_value] += 1 sorted_arr = [] for index, count in enumerate(holes): sorted_arr.extend([index + min_value] * count) return sorted_arr"},{"question":"# String Reversal Challenge **Objective**: Implement a function to reverse a given string using an iterative approach. Your function should handle potential edge cases effectively and return the correctly reversed string. Input * A non-empty string `s`. Output * A new string which is the reverse of `s`. Constraints * The input string `s` will have a maximum length of `10^5`. * The string contains printable ASCII characters. Requirements * Your solution must use an iterative approach. * Your implementation must be efficient in both time and space complexity. Example ```python Input: \\"hello\\" Output: \\"olleh\\" Input: \\"A man, a plan, a canal, Panama\\" Output: \\"amanaP ,lanac a ,nalp a ,nam A\\" ``` # Function Signature ```python def reverse_iterative(s: str) -> str: # Your code here ```","solution":"def reverse_iterative(s: str) -> str: Reverses a given string `s` using an iterative approach. Parameters: s (str): Input string to be reversed. Returns: str: Reversed string. reversed_string = [] for char in s: reversed_string.insert(0, char) return \'\'.join(reversed_string)"},{"question":"# Question You are required to implement a system that can efficiently manage prefix sum queries and updates on an array using a Fenwick Tree (also known as a Binary Indexed Tree). # Task 1. **Function 1**: `construct(arr)`: - Constructs and returns a Binary Indexed Tree (BIT) from a given integer array `arr`. - Returns a BIT (list of integers) that allows for efficient sum queries and updates. 2. **Function 2**: `get_sum(bit_tree, index)`: - Returns the sum of elements from the start of the array to the given `index` using the provided Binary Indexed Tree `bit_tree`. 3. **Function 3**: `update_bit(bit_tree, index, value)`: - Updates the BIT `bit_tree` such that the element at `index` in the original array is incremented by `value`. # Input - `construct` function: * `arr`: a list of integers (0 <= len(arr) <= 10000), the array you need to construct the Binary Indexed Tree from. - `get_sum` function: * `bit_tree`: a Binary Indexed Tree returned from the `construct` function. * `index`: an integer (0 <= index < len(arr)), denoting the index up to which sum is required. - `update_bit` function: * `bit_tree`: a Binary Indexed Tree returned from the `construct` function. * `index`: an integer (0 <= index < len(arr)), denoting the index of the element to be updated. * `value`: an integer, representing the value to be added to the element at `index`. # Output - `construct`: Returns the constructed Binary Indexed Tree. - `get_sum`: Returns an integer, the sum of elements from the start of the array to the given `index`. - `update_bit`: Updates the Binary Indexed Tree. # Example ```python arr = [1, 2, 3, 4, 5] bit_tree = construct(arr) # Testing get_sum sum_to_index_2 = get_sum(bit_tree, 2) print(sum_to_index_2) # Output: 6 # Testing update_bit update_bit(bit_tree, 2, 1) # Increment element at index 2 by 1 updated_sum_to_index_2 = get_sum(bit_tree, 2) print(updated_sum_to_index_2) # Output: 7 ``` # Constraints 1. You should aim for O(log n) complexity for both `get_sum` and `update_bit` functions. 2. The given array can be empty, and both indices and values will be non-negative integers. 3. Handle large input sizes efficiently without causing stack overflow due to recursion depth limits.","solution":"def construct(arr): Constructs and returns a Binary Indexed Tree (BIT) from a given integer array `arr`. n = len(arr) bit_tree = [0] * (n + 1) for i in range(n): update_bit(bit_tree, i, arr[i]) return bit_tree def get_sum(bit_tree, index): Returns the sum of elements from the start of the array to the given `index` using the provided Binary Indexed Tree `bit_tree`. index += 1 sum = 0 while index > 0: sum += bit_tree[index] index -= index & -index return sum def update_bit(bit_tree, index, value): Updates the BIT `bit_tree` such that the element at `index` in the original array is incremented by `value`. index += 1 while index < len(bit_tree): bit_tree[index] += value index += index & -index # Example usage: arr = [1, 2, 3, 4, 5] bit_tree = construct(arr) # Testing get_sum sum_to_index_2 = get_sum(bit_tree, 2) print(sum_to_index_2) # Output: 6 # Testing update_bit update_bit(bit_tree, 2, 1) # Increment element at index 2 by 1 updated_sum_to_index_2 = get_sum(bit_tree, 2) print(updated_sum_to_index_2) # Output: 7"},{"question":"# Context: Imagine you are designing a social network application where users can become friends. We need to manage and dynamically query groups of connected users (i.e., friends of friends). # Problem Statement: Implement a Union-Find data structure to manage groups of connected users. Each user starts as their own group. Users can form friendships, which merges their groups. Additionally, implement a function to query whether two users are in the same group of friends. # Operations: 1. `add_user(user_id)`: Add a new user with `user_id` to the network. 2. `add_friendship(user1, user2)`: Create a friendship between `user1` and `user2`. 3. `are_friends(user1, user2)`: Return `True` if `user1` and `user2` are in the same friendship group, `False` otherwise. Implement the following class: ```python class SocialNetwork: def __init__(self): pass def add_user(self, user_id): pass def add_friendship(self, user1, user2): pass def are_friends(self, user1, user2): pass ``` # Constraints: - The user IDs are unique integers, with a maximum of 10^5 users. - The network can support up to 10^5 friendship operations. - The network can support up to 10^5 friendship queries. # Example: ```python network = SocialNetwork() network.add_user(1) network.add_user(2) network.add_user(3) network.add_friendship(1, 2) print(network.are_friends(1, 2)) # Outputs: True print(network.are_friends(1, 3)) # Outputs: False network.add_friendship(2, 3) print(network.are_friends(1, 3)) # Outputs: True ``` # Notes: - Ensure your solution efficiently handles the given constraints. - Both `add_friendship` and `are_friends` operations should be optimized using the principles of Union-Find. - Your solution must exhibit a firm understanding of Union-Find operations including path compression and union by size/rank.","solution":"class UnionFind: def __init__(self): self.parent = {} self.rank = {} def add(self, x): if x not in self.parent: self.parent[x] = x self.rank[x] = 0 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # Path compression return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 class SocialNetwork: def __init__(self): self.uf = UnionFind() def add_user(self, user_id): self.uf.add(user_id) def add_friendship(self, user1, user2): self.uf.union(user1, user2) def are_friends(self, user1, user2): if user1 not in self.uf.parent or user2 not in self.uf.parent: return False return self.uf.find(user1) == self.uf.find(user2)"},{"question":"Given a string `s` and a dictionary of words `dict`, write a function `count_sentences(s: str, dict: Set[str]) -> int` that returns the number of different ways to form sentences from the words in `dict` such that all the words in each sentence are from the dictionary. # Input * `s` (1 <= len(s) <= 100): a string consisting of lowercase alphabetic characters. * `dict` (1 <= len(dict) <= 100): a set of words consisting of lowercase alphabetic characters. # Output * An integer representing the number of possible sentences. # Constraints * All dictionary words are unique. * You may assume each word in the dictionary will be of reasonable length to fit in memory constraints. # Example ```python assert count_sentences(\\"appletablet\\", {\\"apple\\", \\"tablet\\", \\"table\\", \\"app\\", \\"let\\", \\"able\\", \\"t\\"}) == 4 assert count_sentences(\\"applet\\", {\\"app\\", \\"let\\", \\"apple\\", \\"t\\", \\"applet\\"}) == 3 assert count_sentences(\\"thing\\", {\\"thing\\"}) == 1 ``` # Performance Requirements * The solution should handle strings of length up to 100 efficiently. * Aim to optimize time complexity with memoization or iterative dynamic programming. # Additional Scenarios * Consider the scenario where `s` has overlapping words, requiring careful handling of recursive splits. * Plan for potential performance bottlenecks by identifying and memoizing redundant calculations.","solution":"def count_sentences(s: str, dict: set) -> int: Returns the number of different ways to form sentences from the string s using the provided dictionary of words. def backtrack(start): # Base case: if we reach the end of the string if start == len(s): return 1 if start in memo: return memo[start] count = 0 for end in range(start + 1, len(s) + 1): if s[start:end] in dict: count += backtrack(end) memo[start] = count return count memo = {} return backtrack(0)"},{"question":"# Scenario You are tasked with merging two sorted singly linked lists into one sorted linked list for a data processing system. This will help streamline data aggregation processes. # Task Write a function `merge_two_sorted_lists` that takes two singly linked lists as input and returns a new linked list that contains all the elements from both lists, sorted. # Function Signature ```python class ListNode: def __init__(self, x): self.val = x self.next = None def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: # Implement your solution here ``` # Input - `l1` and `l2`: Heads of two singly linked lists, where each list is already sorted in ascending order. # Output - Return the head of a new linked list that contains all the elements of `l1` and `l2` in sorted order. # Constraints - The number of nodes in both lists should be in the range `[0, 1000]`. - Both list nodes contain integer values `[-10^4, 10^4]`. # Example ```python # Example usage: # List 1: 1 -> 2 -> 4 # List 2: 1 -> 3 -> 4 # Merged list: 1 -> 1 -> 2 -> 3 -> 4 -> 4 l1 = ListNode(1) l1.next = ListNode(2) l1.next.next = ListNode(4) l2 = ListNode(1) l2.next = ListNode(3) l2.next.next = ListNode(4) merged_head = merge_two_sorted_lists(l1, l2) # Print merged list while merged_head: print(merged_head.val, end=\\" -> \\") merged_head = merged_head.next # Expected Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> ``` # Note - Ensure your implementation handles edge cases such as empty lists or lists of different lengths.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: # Create a dummy head to simplify the merging process dummy = ListNode(0) tail = dummy # Traverse both lists and append the smallest value to the merged list while l1 and l2: if l1.val < l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next # If there are remaining elements in l1 or l2, append them directly if l1: tail.next = l1 elif l2: tail.next = l2 # The merged list starts from the next node of the dummy return dummy.next"},{"question":"# Merge Sort Implementation You are tasked with implementing the `merge_sort` function designed to sort an array of integers using the merge sort algorithm. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` # Expected Input and Output * **Input**: A list of integers `arr` with the following constraints: * The length of `arr` is between 0 and 10^5. * Each integer `x` in `arr` satisfies `-10^9 <= x <= 10^9`. * **Output**: A new list which is the sorted version of `arr` in ascending order. # Constraints and Limitations * You must implement the merge sort algorithm. * The solution should have a time complexity of O(n log n) and space complexity of O(n). # Performance Requirements The function should handle large inputs efficiently within the above constraints, sorting arrays up to the upper bounds effectively. # Example ```python # Example 1 arr = [38, 27, 43, 3, 9, 82, 10] assert merge_sort(arr) == [3, 9, 10, 27, 38, 43, 82] # Example 2 arr = [1, 3, 2, 4, 2] assert merge_sort(arr) == [1, 2, 2, 3, 4] # Example 3 arr = [] assert merge_sort(arr) == [] # Example 4 arr = [5] assert merge_sort(arr) == [5] ``` # Detailed Explanation 1. **Recursive Division**: - The array is split into halves until each half contains a single element. 2. **Merge Phase**: - The halves are merged back together, ensuring that the resulting array is in sorted order. 3. **Edge Handling**: - Handle empty arrays and arrays with a single element gracefully. **Note:** Please avoid using any built-in sort functions and stick to the principles of merge sort provided in the prompt.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the merge sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted lists into one sorted list. merged = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 # Append any remaining elements in the left or right list while left_index < len(left): merged.append(left[left_index]) left_index += 1 while right_index < len(right): merged.append(right[right_index]) right_index += 1 return merged"},{"question":"# Question: Advanced Flattening of Nested Arrays Alex is working on a data transformation project involving large datasets. A significant challenge is to convert these datasets, which are deeply nested arrays, into a single-level array. Given the potential size and depth of these nested arrays, it\'s crucial to implement an efficient solution. Write a function `advanced_flatten` that flattens any arbitrarily nested array into a single-level list. Additionally, avoid deep recursion to handle very deeply nested structures. The function should also be capable of handling various types of non-iterable elements like strings correctly. # Function Specification ```python def advanced_flatten(input_arr): pass ``` # Input * `input_arr` (list): A list that may contain deeply nested lists, including other data types (integers, strings, etc.). # Output * Returns a single list with all elements from the nested structures, preserving the order. # Constraints 1. The input list may contain any combination of nested lists and other data types. 2. The function should handle deeply nested lists without resulting in a recursion limit error. 3. The solution should be optimized for performance and memory usage. # Example ```python assert advanced_flatten([1, [2, [3, 4]], 5, [[6], 7], 8]) == [1, 2, 3, 4, 5, 6, 7, 8] assert advanced_flatten([\'alpha\', [\'beta\', [\'gamma\', \'delta\']], \'epsilon\']) == [\'alpha\', \'beta\', \'gamma\', \'delta\', \'epsilon\'] assert advanced_flatten([]) == [] assert advanced_flatten([[], [[], [[[]]]]]) == [] ``` # Explanation - The function should maintain the order of elements and handle any level of nesting. - Strings should be considered as atomic elements, not iterable sequences. - The function should efficiently handle large input sizes and deep nestings without causing stack overflow or significant memory overhead.","solution":"from collections.abc import Iterable def advanced_flatten(input_arr): Flattens any arbitrarily nested list into a single-level list. result = [] stack = [iter(input_arr)] while stack: for element in stack[-1]: if isinstance(element, list): stack.append(iter(element)) break else: result.append(element) else: stack.pop() return result"},{"question":"# Dot Product of Sparse Vectors Problem Statement You are provided with a function to convert a list representing a vector into a compressed format (index-value pairs). The main task is to implement a new function that calculates the dot product of two such compressed vectors efficiently. This will include utilizing the given conversion function and managing the sparse representation for optimal performance. Function Signature ```python def optimized_dot_product(vector1: List[float], vector2: List[float]) -> float: pass ``` Input - Two lists of floating-point numbers, `vector1` and `vector2`, which may contain many zeros. - Both vectors will have the same length `n` where (1 leq n leq 10^6). Output - A single floating-point number representing the dot product of the two vectors. Constraints - Vectors can contain any floating-point values, including positive, negative, and zero. - Ensure the function operates efficiently even for large inputs. Example ```python vector1 = [1.0, 0.0, 3.0, 0.0, 4.0] vector2 = [0.0, 2.0, 1.0, 0.0, 5.0] print(optimized_dot_product(vector1, vector2)) # Output: 23.0 vector1 = [0.0, 0.0, 0.0] vector2 = [0.0, 0.0, 0.0] print(optimized_dot_product(vector1, vector2)) # Output: 0.0 ```","solution":"from typing import List, Tuple def compress_vector(vector: List[float]) -> List[Tuple[int, float]]: Compresses a vector into a list of index-value pairs, excluding zeros. compressed = [] for i, value in enumerate(vector): if value != 0.0: compressed.append((i, value)) return compressed def optimized_dot_product(vector1: List[float], vector2: List[float]) -> float: Computes the dot product of two sparse vectors represented as lists using their compressed forms. compressed_vector1 = compress_vector(vector1) compressed_vector2 = compress_vector(vector2) i, j = 0, 0 dot_product = 0.0 while i < len(compressed_vector1) and j < len(compressed_vector2): index1, value1 = compressed_vector1[i] index2, value2 = compressed_vector2[j] if index1 == index2: dot_product += value1 * value2 i += 1 j += 1 elif index1 < index2: i += 1 else: j += 1 return dot_product"},{"question":"Advanced Search Implementation You are part of a team building a high-performance search tool for large, sorted databases where the distribution of elements can vary. The current search functionality is built using binary search, but your team needs to optimize this for cases where the data is uniformly distributed. You have decided to implement an enhanced search function using the Interpolation Search algorithm. Task Implement a function `adaptive_search` that switches between the Interpolation Search algorithm and Binary Search algorithm based on the distribution characteristics of the given sorted array. If the initial positional estimate in the Interpolation Search deviates substantially, the function should revert to using Binary Search for performance consistency. Function Signature ```python from typing import List def adaptive_search(array: List[int], search_key: int) -> int: :param array: the sorted array to be searched. :param search_key: the key to be searched in the array. :return: Index of search_key in array if found, else -1. ``` Input - An array of integers `array` sorted in non-decreasing order, i.e., `array = [a_1, a_2, ..., a_n]` where `a_i ≤ a_j` for `i < j`. - An integer `search_key` representing the value to be searched. Output - The function returns the index of the `search_key` in the array if found. - If `search_key` is not present in the array, return `-1`. Constraints - The size of the input array `n` will be in the range `0 ≤ n ≤ 10^6`. - The values in `array` and `search_key` will be in the range `-10^6 ≤ value ≤ 10^6`. Examples ```python >>> adaptive_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> adaptive_search([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> adaptive_search([5, 10, 12, 14, 17, 20, 21], -5) -1 ``` Notes - If the positional estimate in Interpolation Search shows high deviation (e.g., more than 10 positions away), consider switching to Binary Search. - Ensure your implementation handles edge cases such as empty arrays and arrays with duplicated values effectively. - Aim for a solution that balances performance well for various data distributions by intelligently switching search algorithms.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: lo, hi = 0, len(array) - 1 while lo <= hi and search_key >= array[lo] and search_key <= array[hi]: if lo == hi: if array[lo] == search_key: return lo return -1 pos = lo + ((search_key - array[lo]) * (hi - lo) // (array[hi] - array[lo])) if array[pos] == search_key: return pos if array[pos] < search_key: lo = pos + 1 else: hi = pos - 1 return -1 def binary_search(array: List[int], search_key: int) -> int: lo, hi = 0, len(array) - 1 while lo <= hi: mid = lo + (hi - lo) // 2 if array[mid] == search_key: return mid elif array[mid] < search_key: lo = mid + 1 else: hi = mid - 1 return -1 def adaptive_search(array: List[int], search_key: int) -> int: if not array: return -1 if (array[-1] - array[0]) == 0: if array[0] == search_key: return 0 return -1 lo, hi = 0, len(array) - 1 pos = lo + ((search_key - array[lo]) * (hi - lo) // (array[hi] - array[lo])) if abs(pos - (lo + hi) // 2) > 10: return binary_search(array, search_key) else: return interpolation_search(array, search_key)"},{"question":"# Problem Context You are working on a system that needs to store and manipulate a large number of binary trees efficiently. The serialization and deserialization functions provided are crucial but need enhancements to handle larger datasets and ensure robustness. # Task Implement a function `find_deepest_node` that finds the deepest node in a binary tree. The deepest node is defined as the one with the greatest depth from the root (i.e., the longest path from the root). # Function Signature ```python def find_deepest_node(root: TreeNode) -> int: # Your implementation here ``` # Input - `root`: The root of the binary tree (a `TreeNode` object). # Output - Returns the value of the deepest node. If there are multiple nodes at the same maximum depth, return the leftmost one. # Constraints - The binary tree can contain up to 10^4 nodes. - Node values are integers. # Example ```python # Build the tree: # 1 # / # 2 3 # / # 4 5 # / # 7 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.left.right.left = TreeNode(7) assert find_deepest_node(root) == 7 # Build another tree: # 1 # / # 2 3 # / # 4 5 # / # 6 7 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.left.right.left = TreeNode(6) root.left.right.right = TreeNode(7) assert find_deepest_node(root) == 6 ``` # Notes - Be sure to handle edge cases such as an empty tree. - Aim for an efficient solution that traverses the tree in O(n) time complexity.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_deepest_node(root: TreeNode) -> int: if not root: return None queue = [(root, 0)] # (node, depth) deepest_node = root max_depth = 0 while queue: node, depth = queue.pop(0) if depth > max_depth: max_depth = depth deepest_node = node if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return deepest_node.val"},{"question":"# Task: Improved Binary Search You are given a sorted array of integers and a target value. Your task is to write an optimized version of the binary search algorithm that handles potential integer overflow issues while calculating the mid index. Additionally, it should return the first occurrence of the target value if duplicates are present in the array. # Function Signature ```python def improved_binary_search(array: List[int], target: int) -> int: # Your code here ``` # Input - `array`: A sorted list of integers (1 ≤ len(array) ≤ 10^6) - `target`: The integer value to search for in the array. # Output - Return the index of the first occurrence of the target value within the array if it exists. - If the target is not present in the list, return -1. # Constraints 1. Your solution should handle arrays containing duplicate values, ensuring the index of the first occurrence of the target is returned if there are multiple occurrences. 2. Handle potential integer overflow correctly while calculating the mid index. # Example Example 1: ```python array = [1, 2, 4, 4, 5, 6, 8, 9] target = 4 improved_binary_search(array, target) ``` **Output**: 2 Example 2: ```python array = [10, 20, 30, 40, 50] target = 25 improved_binary_search(array, target) ``` **Output**: -1 # Explanation In Example 1, the target 4 appears twice in the array, the function returns the index of its first occurrence which is 2. In Example 2, the target 25 does not appear in the array, so the function returns -1. # Note - Ensure the implementation does not suffer from integer overflow when calculating the mid index. - Aim for optimal time complexity using the binary search approach.","solution":"from typing import List def improved_binary_search(array: List[int], target: int) -> int: Returns the index of the first occurrence of the target in the sorted array. If the target is not present, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == target: result = mid right = mid - 1 # Continue searching to the left elif array[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"Scenario You are working on a project involving binary trees where you need to frequently traverse and process nodes in the preorder sequence. You have been given an implementation of both iterative and recursive preorder tree traversal. Your task is to implement a new function that finds the sum of all node values using preorder traversal. Task Write a function `sum_preorder(root: Node) -> int` that calculates the sum of all values in a binary tree using preorder traversal. You can use either recursive or iterative methods as provided in the initial code snippets for the traversal technique. Function Signature ```python def sum_preorder(root: Node) -> int: pass ``` Input * `root`: The root node of a binary tree (object of class `Node`). Output * Returns an integer, the sum of all node values in the tree. Constraints * The node values are integers. * The tree can have up to 10^5 nodes. Example ```python # Define the tree structure root = Node(1, Node(2), Node(3, Node(4), Node(5))) # Example run print(sum_preorder(root)) # Output should be 15 ``` Note You are expected to use the given preorder traversal techniques to perform the sum calculation efficiently.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_preorder(root: Node) -> int: Returns the sum of all node values in the tree using preorder traversal. if root is None: return 0 stack = [root] total_sum = 0 while stack: node = stack.pop() total_sum += node.value if node.right: stack.append(node.right) if node.left: stack.append(node.left) return total_sum"},{"question":"# Coding Challenge: Robust Trimmed Mean Calculation You are working on a data analysis project, and you need to calculate a reliable mean for a data set that contains several outliers. In this task, you are required to write a function that computes the trimmed mean of an array of numbers given the percentage of extreme values to exclude from both ends. The trimmed mean of an array is calculated by sorting the array first, removing a certain percentage of the smallest and largest elements, and then computing the mean of the remaining elements. # Function Signature ```python def trimmed_mean(data: List[float], percentage: float) -> float: ``` # Input * `data` (List[float]): A list of floating-point numbers representing the data set. * `percentage` (float): A floating-point number representing the percentage of values to be trimmed from both ends. # Output * The function should return a floating-point number representing the trimmed mean of the data. # Constraints * 1 <= len(data) <= 10^6 * 0 <= percentage < 100 * The elements in `data` are in the range of [-10^9, 10^9]. # Performance Requirements * The function should run efficiently for large data sets with up to 1,000,000 elements. # Example ```python # Example 1 data = [1, 2, 3, 4, 5] percentage = 20 print(trimmed_mean(data, percentage)) # Output: 3 # Example 2 data = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] percentage = 10 print(trimmed_mean(data, percentage)) # Output: 55 ``` # Description 1. The function `trimmed_mean` should first sort the input list of data. 2. Then, it should calculate the number of elements to exclude from both ends using the given percentage. 3. After trimming, the function should compute and return the mean of the remaining elements. # Edge Cases * If `percentage` is 0, return the mean of the entire data set. * If the trimmed elements leave no data points, consider handling exceptions or special conditions to avoid division by zero. # Notes * Ensure your implementation is efficient and can handle edge cases gracefully.","solution":"from typing import List def trimmed_mean(data: List[float], percentage: float) -> float: Calculate the trimmed mean of the given data. Args: data (List[float]): A list of floating-point numbers percentage (float): The percentage of values to be trimmed from both ends Returns: float: The trimmed mean of the data if not data: return 0.0 n = len(data) trim_count = int((percentage / 100) * n) # Sort the data sorted_data = sorted(data) # Determine the subarray after trimming trimmed_data = sorted_data[trim_count:n-trim_count] # Calculate the mean of the trimmed data if not trimmed_data: return 0.0 return sum(trimmed_data) / len(trimmed_data)"},{"question":"Binary Tree Inorder Traversal Problem Statement: You are given a binary tree, and your task is to implement two functions to perform inorder traversal on the tree. You are required to provide both iterative and recursive solutions. Detailed Requirements: * Implement the function `inorder_iterative(root: Node) -> List[int]` to perform an inorder traversal iteratively. * Implement the function `inorder_recursive(root: Node) -> List[int]` to perform an inorder traversal recursively. Function Signatures: ```python def inorder_iterative(root: Node) -> List[int]: pass def inorder_recursive(root: Node) -> List[int]: pass ``` Input: * `root`: The root node of the binary tree. A node is defined by the class `Node`: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` * The node values are integers and can be positive or negative. Output: * Returns a list of integers representing the inorder traversal of the binary tree. Constraints: * 0 <= Number of nodes in the tree <= 10^4 * The value of each node is an integer within the range of [-10^5, 10^5]. Performance Requirements: * The functions should have a time complexity of O(n). * The space complexity should be O(n) for the recursive approach due to stack memory and approximately O(h) for the iterative approach. Example: Given the binary tree: ``` 100 / 50 150 / / 25 75 125 175 ``` * `inorder_iterative(root)` should return `[25, 50, 75, 100, 125, 150, 175]`. * `inorder_recursive(root)` should return `[25, 50, 75, 100, 125, 150, 175]`.","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def inorder_recursive(root: Optional[Node]) -> List[int]: def helper(node: Optional[Node], result: List[int]): if node: helper(node.left, result) result.append(node.val) helper(node.right, result) result = [] helper(root, result) return result def inorder_iterative(root: Optional[Node]) -> List[int]: result = [] stack = [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result"},{"question":"# Question: Implement and Analyze a Histogram Function You have been provided with the conceptual approach and some initial code for a function `get_histogram` that calculates the frequency distribution of elements in a list. Your task is to complete the implementation of this function, ensuring it handles various edge cases effectively. **Function Specification:** - **Function Name**: `get_histogram` - **Input**: - `input_list`: A list of integers, where each integer may or may not be unique, e.g., `[2, 3, 5, 5, 5, 6, 4, 3, 7]`. - **Output**: - A dictionary representing the histogram (i.e., frequency) of the input list elements. For the previous example, the output should be `{2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1}`. **Constraints**: - The input list can be empty. - The elements in the list are non-negative integers. - Your solution should have a time complexity of O(n). **Requirements**: - Ensure your implementation handles edge cases properly. - You should provide some example test cases including edge cases. **Example**: ```python assert get_histogram([2, 3, 2, 4, 4, 4]) == {2: 2, 3: 1, 4: 3} assert get_histogram([]) == {} assert get_histogram([7, 7, 7, 7, 7]) == {7: 5} ``` # Scoring Criteria: - **Correctness**: Your function should correctly compute the histogram for given test cases. - **Performance**: The function should efficiently handle large lists. - **Edge Cases**: Proper handling of edge cases like empty lists or uniform distributions.","solution":"def get_histogram(input_list): Returns a dictionary representing the frequency histogram of the elements in the input list. Args: input_list: A list of integers. Returns: A dictionary where keys are the unique elements from the input list and values are their frequency. histogram = {} for num in input_list: if num in histogram: histogram[num] += 1 else: histogram[num] = 1 return histogram"},{"question":"You are tasked with implementing a function to determine the number of valid sentences that can be formed from a given string using words from a provided dictionary. A sentence is considered valid if it can be segmented into one or more dictionary words. Additionally, you should optimize your solution to reduce redundant computations by using memoization. **Function Signature:** ```python def count_sentences(s: str, word_dict: set) -> int: ``` # Input * `s` (string): - This is the string to be segmented. - 1 ≤ len(s) ≤ 1000. * `word_dict` (set of strings): - This is the dictionary containing valid words. - 1 ≤ size of word_dict ≤ 10000. - Each word has a length between 1 and 100 characters. # Output * An integer representing the number of valid sentences that can be formed. # Constraints - All characters in the string and dictionary are lowercase English letters. - You should implement an optimized solution with memoization to handle larger inputs efficiently. # Example ```python s = \\"appletablet\\" word_dict = {\\"apple\\", \\"tablet\\", \\"applet\\", \\"able\\", \\"t\\"} print(count_sentences(s, word_dict)) # Output: 3 s = \\"thing\\" word_dict = {\\"thing\\"} print(count_sentences(s, word_dict)) # Output: 1 ``` # Optimization Hint - Utilize a memoization dictionary where the keys are substrings of `s`, and values are the number of ways the substring can be segmented into dictionary words. # Scenario You are developing a text segmentation feature for a new language processing tool. Given a continuous string of characters, you need to determine the number of unique ways to segment the string into valid words found in the dictionary. This will help in offering suggestions for potential word breaks in the input text.","solution":"def count_sentences(s: str, word_dict: set) -> int: # Define a memoization dictionary. memo = {} def dfs(index): # If we have reached the end of the string, that\'s a valid way to segment it. if index == len(s): return 1 # If this computation has already been done, return the stored result. if index in memo: return memo[index] # Explore further segmentations count = 0 for end in range(index + 1, len(s) + 1): if s[index:end] in word_dict: count += dfs(end) # Store the result in memoization dictionary before returning it. memo[index] = count return count # Start the DFS from the beginning of the string. return dfs(0)"},{"question":"# Problem: Inorder Traversal of Binary Tree You are given a root of a binary tree. Your task is to implement two methods for inorder traversal of the tree and return the sequence of node values: 1. An iterative approach (`inorder`) 2. A recursive approach (`inorder_rec`) Both methods should return a list of values representing the inorder traversal of the binary tree. # Constraints - The maximum number of nodes in the tree is 10^4. - Node values are integers and may be negative. # Input - A binary tree represented by its root node. Use the provided `Node` class for implementation. # Output - A list of integers representing the inorder traversal of the tree. # Example Consider the binary tree structured as follows: ``` 100 / 50 150 / / 25 75 125 175 ``` Input - Root node of the tree. Output - `[25, 50, 75, 100, 125, 150, 175]` # Requirements 1. Define a `Node` class as provided in the code snippet. 2. Implement two methods: `inorder` and `inorder_rec`. # Function Signatures ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder(root: Node) -> [int]: pass def inorder_rec(root: Node) -> [int]: pass ``` # Additional Notes - You can assume that the root node and the tree structure have been built before being passed to your functions. - Your solutions should be efficient in both time and space.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder(root): Iterative inorder traversal. stack, result = [], [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_rec(root): Recursive inorder traversal. def traverse(node, result): if not node: return traverse(node.left, result) result.append(node.val) traverse(node.right, result) result = [] traverse(root, result) return result"},{"question":"**Objective**: Implement a function to serialize and deserialize a Binary Search Tree (BST). # Context When working with complex data structures that need to be stored or transmitted, serialization (converting the data structure into a linear format) becomes essential. Deserialization is the reverse process of constructing the data structure back from the serialized format. You are provided with a class `BST` that supports insertion, search, and traversal operations. Extend this BST class by implementing a `serialize` method that converts the BST into a list of tuples (preorder format) and a `deserialize` method that reconstructs the BST from such a list. # Tasks 1. Implement the `serialize(self) -> list` method in the `BST` class. 2. Implement the `deserialize(self, data: list)` method in the `BST` class. # Function Signature ```python def serialize(self) -> list: Converts the BST to a list of tuples (node value, left size, right size) in preorder format. def deserialize(self, data: list): Converts the list of tuples (node value, left size, right size) in preorder format back into a BST. ``` # Input Format - For `serialize`: No input required, it\'s a method of the BST class. - For `deserialize`: A list of tuples, where each tuple consists of three elements: - `value` (int): The value of the node. - `left_size` (int): The size of the left subtree. - `right_size` (int): The size of the right subtree. # Output Format - For `serialize`: A list of tuples representing the serialized BST. - For `deserialize`: No output required, the BST is built within the class. # Examples ```python # Example use bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) # Serialize the BST data = bst.serialize() print(data) # Example output: [(10, 1, 1), (5, 0, 0), (15, 0, 0)] # Deserialize the BST new_bst = BST() new_bst.deserialize(data) print(new_bst.size()) # Should match the size of the original BST ``` # Constraints - The input BST will not contain duplicate values. - The list provided for deserialization will always represent a valid BST. Ensure your solution maintains the properties of the BST and can handle large trees efficiently.","solution":"class BST: class Node: def __init__(self, value): self.value = value self.left = None self.right = None def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = self.Node(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = self.Node(value) else: self._insert(node.left, value) else: if node.right is None: node.right = self.Node(value) else: self._insert(node.right, value) def serialize(self) -> list: result = [] self._serialize(self.root, result) return result def _serialize(self, node, result): if node is None: return left_size = self._get_size(node.left) right_size = self._get_size(node.right) result.append((node.value, left_size, right_size)) self._serialize(node.left, result) self._serialize(node.right, result) def _get_size(self, node): if node is None: return 0 return 1 + self._get_size(node.left) + self._get_size(node.right) def deserialize(self, data: list): if not data: return self.root, _ = self._deserialize(data, 0, len(data)) def _deserialize(self, data, start, end): if start >= end: return None, start node = self.Node(data[start][0]) left_size = data[start][1] right_size = data[start][2] node.left, next_index = self._deserialize(data, start + 1, start + 1 + left_size) node.right, next_index = self._deserialize(data, next_index, next_index + right_size) return node, next_index def size(self): return self._get_size(self.root) def search(self, value): return self._search(self.root, value) def _search(self, node, value): if node is None: return False if node.value == value: return True elif value < node.value: return self._search(node.left, value) else: return self._search(node.right, value)"},{"question":"# Question: Minimize Bit Flips to Convert One Integer to Another You are given two integers, `A` and `B`. Your task is to write a function `count_flips_to_convert(A, B)` that determines the minimal number of bits you would need to flip to convert integer `A` to integer `B`. Function Signature: ```python def count_flips_to_convert(a: int, b: int) -> int: ``` Input: - `a`: An integer `A` (0 ≤ A ≤ 10^9). - `b`: An integer `B` (0 ≤ B ≤ 10^9). Output: - Returns the minimal number of bits that must be flipped to convert integer `A` to integer `B`. # Explanation: 1. Compute the XOR of `A` and `B`, which will give a number where each bit set to 1 signifies a difference between the corresponding bits of `A` and `B`. 2. Count the number of set bits (1s) in the result from step 1, as each represents a bit that needs to be flipped. # Example: ```python print(count_flips_to_convert(29, 15)) # Output: 2 ``` This means converting 29 (binary: `11101`) to 15 (binary: `01111`) requires flipping two bits. # Constraints: - The function should have a time complexity of O(k) and space complexity of O(1), where k is the number of bits in the XOR result. Complete the implementation of the `count_flips_to_convert` function to solve this problem.","solution":"def count_flips_to_convert(a: int, b: int) -> int: This function returns the minimal number of bits you would need to flip to convert integer `a` to integer `b`. # XOR a and b to find differing bits xor_result = a ^ b # Count the number of 1s in the binary representation of the xor_result count = 0 while xor_result > 0: count += xor_result & 1 xor_result >>= 1 return count"},{"question":"# Post-order Traversal Challenge You are given a binary tree, represented by the `Node` class below: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` Task Write a function `postorder_traversal` that performs a post-order traversal of the binary tree and returns a list of values visited in that order. You should implement both an iterative and a recursive solution within separate methods under the same function name. Function Signature ```python def postorder_traversal(root: Node) -> dict: # Your code goes here pass ``` Input * `root`: The root node of the binary tree (an instance of `Node`). It can be `None` if the tree is empty. Output * A dictionary with two keys: - `\\"iterative\\"`: List of node values in post-order obtained iteratively. - `\\"recursive\\"`: List of node values in post-order obtained recursively. Constraints * 0 <= Number of nodes in the tree <= 10^5 Performance Requirements Write efficient solutions ensuring O(n) time complexity where n is the number of nodes in the tree. Example ```python # Binary Tree Representation # 1 # / # 2 3 # / # 4 5 node4 = Node(4) node5 = Node(5) node2 = Node(2, node4, node5) node3 = Node(3) root = Node(1, node2, node3) result = postorder_traversal(root) print(result) # Output: {\\"iterative\\": [4, 5, 2, 3, 1], \\"recursive\\": [4, 5, 2, 3, 1]} ``` Note Make sure to handle an empty tree scenario. Both implementations (iterative and recursive) should produce the same output for a given tree.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def recursive_postorder(root, result): if root is not None: recursive_postorder(root.left, result) recursive_postorder(root.right, result) result.append(root.val) def iterative_postorder(root): if root is None: return [] result = [] stack = [root] while stack: node = stack.pop() result.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) result.reverse() return result def postorder_traversal(root): result_recursive = [] recursive_postorder(root, result_recursive) result_iterative = iterative_postorder(root) return {\\"iterative\\": result_iterative, \\"recursive\\": result_recursive}"},{"question":"**Context**: You are tasked with organizing a library\'s cataloging system by developing an efficient way to sort book records. Each book\'s record consists of various details, but for sorting purposes, we\'ll only focus on the publication year. **Problem Statement**: Implement a function `sort_books_by_year` that uses the insertion sort algorithm to sort a list of dictionaries, where each dictionary represents a book with a \'year\' key denoting the year of publication. **Function Signature**: ```python def sort_books_by_year(books: List[Dict[str, Any]]) -> List[Dict[str, Any]]: pass ``` **Input**: * `books`: A list of dictionaries, where each dictionary contains book details. Each dictionary has a \'year\' key of type integer, representing the year of publication. **Output**: * The function returns a list of dictionaries sorted in ascending order based on the \'year\' key. **Constraints**: * The function should perform an in-place sort, modifying the input list directly. * The year values are integers and can be negative (representing B.C.), zero, or positive. * The list can contain up to 1000 book records. **Example**: ```python books = [ {\\"title\\": \\"Book A\\", \\"year\\": 2020}, {\\"title\\": \\"Book B\\", \\"year\\": 1997}, {\\"title\\": \\"Book C\\", \\"year\\": 2010}, {\\"title\\": \\"Book D\\", \\"year\\": 2001} ] sorted_books = sort_books_by_year(books) # Expected Output: # [ # {\\"title\\": \\"Book B\\", \\"year\\": 1997}, # {\\"title\\": \\"Book D\\", \\"year\\": 2001}, # {\\"title\\": \\"Book C\\", \\"year\\": 2010}, # {\\"title\\": \\"Book A\\", \\"year\\": 2020} # ] books = [] sorted_books = sort_books_by_year(books) # Expected Output: [] books = [{\\"title\\": \\"Ancient Book\\", \\"year\\": -500}] sorted_books = sort_books_by_year(books) # Expected Output: [{\\"title\\": \\"Ancient Book\\", \\"year\\": -500}] ``` **Performance Requirements**: Ensure that the insertion sort implementation adheres to the time complexity of O(n^2) as expected and handles edge cases gracefully. **Additional Notes**: Handle special cases like an empty input list, a single-element list, and lists with books from the same year effectively.","solution":"def sort_books_by_year(books): Sort books in-place by their publication year using the insertion sort algorithm. Parameters: - books (List[Dict[str, Any]]): List of dictionaries, each with a \'year\' key. Returns: - List[Dict[str, Any]]: The same list of dictionaries, sorted by the \'year\' key. n = len(books) for i in range(1, n): keyBook = books[i] j = i - 1 # Move elements of books[0..i-1], that are greater than keyBook, to one position ahead of their current position while j >= 0 and books[j][\'year\'] > keyBook[\'year\']: books[j + 1] = books[j] j -= 1 books[j + 1] = keyBook return books"},{"question":"# Huffman Coding Implementation You are tasked with implementing the Huffman coding algorithm to compress and decompress text data. Your implementation should include functions for building the frequency table, constructing the Huffman tree, generating codes for symbols, encoding a given text, and decoding a given encoded binary string. Requirements: 1. **build_frequency_table(text)**: - Input: A string `text`. - Output: A dictionary with symbols as keys and their frequencies as values. 2. **build_huffman_tree(freq_table)**: - Input: A dictionary `freq_table` with symbols and their frequencies. - Output: The root of the Huffman tree. 3. **generate_huffman_codes(root)**: - Input: The root of the Huffman tree. - Output: A dictionary with symbols as keys and their Huffman codes as values. 4. **huffman_encode(text, codes)**: - Input: A string `text` and a dictionary `codes`. - Output: A binary string representing the encoded text. 5. **huffman_decode(encoded_text, root)**: - Input: A binary string `encoded_text` and the root of the Huffman tree. - Output: The original decoded string. # Constraints: - The input text will contain only ASCII characters. - The length of the text will be at most 1000 characters. # Expected Code Structure: ```python class Node: def __init__(self, frequency=0, sign=None, left=None, right=None): self.frequency = frequency self.sign = sign self.left = left self.right = right def __lt__(self, other): return self.frequency < other.frequency def build_frequency_table(text): # Your implementation here pass def build_huffman_tree(freq_table): # Your implementation here pass def generate_huffman_codes(root): # Your implementation here pass def huffman_encode(text, codes): # Your implementation here pass def huffman_decode(encoded_text, root): # Your implementation here pass ``` # Sample Input/Output Example 1: ```python text = \\"this is an example for huffman encoding\\" freq_table = build_frequency_table(text) root = build_huffman_tree(freq_table) codes = generate_huffman_codes(root) encoded_text = huffman_encode(text, codes) decoded_text = huffman_decode(encoded_text, root) assert decoded_text == text # The decoded text should match the original text ```","solution":"import heapq from collections import defaultdict, Counter class Node: def __init__(self, frequency=0, sign=None, left=None, right=None): self.frequency = frequency self.sign = sign self.left = left self.right = right def __lt__(self, other): return self.frequency < other.frequency def build_frequency_table(text): return Counter(text) def build_huffman_tree(freq_table): heap = [Node(frequency=freq, sign=char) for char, freq in freq_table.items()] heapq.heapify(heap) while len(heap) > 1: left = heapq.heappop(heap) right = heapq.heappop(heap) merged = Node(frequency=left.frequency + right.frequency, left=left, right=right) heapq.heappush(heap, merged) return heap[0] def generate_huffman_codes(root): codes = {} def _generate_huffman_codes_helper(node, current_code): if node is not None: if node.sign is not None: codes[node.sign] = current_code _generate_huffman_codes_helper(node.left, current_code + \'0\') _generate_huffman_codes_helper(node.right, current_code + \'1\') _generate_huffman_codes_helper(root, \\"\\") return codes def huffman_encode(text, codes): return \'\'.join(codes[char] for char in text) def huffman_decode(encoded_text, root): decoded_text = [] current_node = root for bit in encoded_text: if bit == \'0\': current_node = current_node.left else: current_node = current_node.right if current_node.left is None and current_node.right is None: decoded_text.append(current_node.sign) current_node = root return \'\'.join(decoded_text)"},{"question":"Scenario: You have been hired by a logistics company to help sort the incoming packages by their weight efficiently. The company wants to start with a simple algorithm to ease the implementation process and then gradually move to more complex algorithms as required. They decide to use the Selection Sort algorithm for its simplicity. Problem Statement: Write a function `logistics_selection_sort` that sorts an array of package weights in ascending order using the Selection Sort algorithm. Additionally, implement a simulation mode that prints the list after each outer loop iteration to help visualize the sorting process. Function Signature: ```python def logistics_selection_sort(weights: List[int], simulation: bool=False) -> List[int]: pass ``` Input: - `weights`: A list of integers representing the weights of the packages. - `simulation`: A boolean flag. If True, the function should print the state of the list after each outer loop iteration. Output: - A list of integers representing the sorted weights in ascending order. Constraints: - The list can contain up to 10,000 integers. - Each integer in the list is in the range from -10,000 to 10,000. - The function should operate within a reasonable time for large lists despite Selection Sort’s inherent inefficiency. Example: ```python # Example 1: weights = [60, 30, 20, 40, 90, 10] print(logistics_selection_sort(weights, simulation=True)) ``` Output: ``` iteration 0 : 10 30 20 40 90 60 iteration 1 : 10 20 30 40 90 60 iteration 2 : 10 20 30 40 90 60 iteration 3 : 10 20 30 40 90 60 iteration 4 : 10 20 30 40 60 90 iteration 5 : 10 20 30 40 60 90 [10, 20, 30, 40, 60, 90] ``` ```python # Example 2: weights = [2, 0, 5, 1, -1] print(logistics_selection_sort(weights)) ``` Output: ``` [-1, 0, 1, 2, 5] ``` Provide a clear, efficient implementation of the sorting algorithm with a focus on correctness and clarity.","solution":"from typing import List def logistics_selection_sort(weights: List[int], simulation: bool=False) -> List[int]: n = len(weights) for i in range(n): min_index = i for j in range(i+1, n): if weights[j] < weights[min_index]: min_index = j weights[i], weights[min_index] = weights[min_index], weights[i] if simulation: print(f\\"iteration {i} :\\", \' \'.join(map(str, weights))) return weights"},{"question":"# Linked List Manipulation Functions You are asked to implement a few functions for both singly and doubly linked lists. Your implementations should be efficient and handle various edge cases effectively. Below are the details and requirements for each type of linked list. Part 1: Singly Linked List Manipulation 1. **Insert At End**: Implement a function to insert a new node with a given value at the end of the singly linked list. ```python def insert_at_end_singly_ll(head, value): Inserts a new node with the given value at the end of the singly linked list. Args: head (SinglyLinkedListNode): Head node of the singly linked list value: Value to be inserted at the end of the list Returns: SinglyLinkedListNode: Head node of the modified linked list pass ``` 2. **Delete With Value**: Implement a function to delete the first node with a given value in the singly linked list. ```python def delete_with_value_singly_ll(head, value): Deletes the first node with the given value in the singly linked list. Args: head (SinglyLinkedListNode): Head node of the singly linked list value: Value to be deleted from the list Returns: SinglyLinkedListNode: Head node of the modified linked list pass ``` Part 2: Doubly Linked List Manipulation 1. **Insert At Position**: Implement a function to insert a new node with a given value at a specified position in the doubly linked list. ```python def insert_at_position_doubly_ll(head, value, position): Inserts a new node with the given value at the specified position in the doubly linked list. Args: head (DoublyLinkedListNode): Head node of the doubly linked list value: Value to be inserted into the list position (int): Position at which to insert the new node (0-based index) Returns: DoublyLinkedListNode: Head node of the modified linked list pass ``` 2. **Reverse List**: Implement a function to reverse a doubly linked list. ```python def reverse_doubly_ll(head): Reverses the doubly linked list. Args: head (DoublyLinkedListNode): Head node of the doubly linked list Returns: DoublyLinkedListNode: Head node of the reversed linked list pass ``` * **Constraints**: - Assume there are no cycles in the linked lists. - The head node can be `None`, indicating an empty list. - Positions in linked lists are 0-indexed.","solution":"class SinglyLinkedListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def insert_at_end_singly_ll(head, value): new_node = SinglyLinkedListNode(value) if head is None: return new_node current = head while current.next: current = current.next current.next = new_node return head def delete_with_value_singly_ll(head, value): if head is None: return None if head.value == value: return head.next current = head while current.next and current.next.value != value: current = current.next if current.next: current.next = current.next.next return head class DoublyLinkedListNode: def __init__(self, value=0, prev=None, next=None): self.value = value self.prev = prev self.next = next def insert_at_position_doubly_ll(head, value, position): new_node = DoublyLinkedListNode(value) if position == 0: new_node.next = head if head: head.prev = new_node return new_node current = head for _ in range(position - 1): if current: current = current.next else: raise IndexError(\\"Position out of bounds\\") new_node.next = current.next new_node.prev = current if current.next: current.next.prev = new_node current.next = new_node return head def reverse_doubly_ll(head): current = head prev_node = None while current is not None: next_node = current.next current.next = prev_node current.prev = next_node prev_node = current current = next_node return prev_node"},{"question":"**Problem Description**: **Scenario**: You are a software engineer at a company that offers natural language processing services. One of the features you need to enhance is the ability to segment a given string into space-separated words based on a given dictionary. This function will be highly useful in preprocessing text data for various NLP tasks. **Task**: You need to implement the function `can_segment_into_dictionary_words` that determines if the given input string can be segmented into one or more words from the provided dictionary. **Function Signature**: ```python def can_segment_into_dictionary_words(word: str, word_dict: Set[str]) -> bool: Determine if the word can be segmented into a space-separated sequence of one or more dictionary words. :param word: str - the input string to be segmented. :param word_dict: Set[str] - a set containing dictionary words. :return: bool - True if the word can be segmented, otherwise False. pass ``` **Input**: * `word` (string): A non-empty string containing lowercase English letters. * `word_dict` (set of strings): A non-empty set containing unique dictionary words where each word consists of lowercase English letters. **Output**: * Returns a boolean value `True` if the word can be segmented into a sequence of one or more dictionary words, otherwise `False`. **Constraints**: * The length of the input string is at most 300. * All words in the dictionary and the input string consist of lowercase English letters. **Example**: ```python word = \\"leetcode\\" word_dict = {\\"leet\\", \\"code\\"} print(can_segment_into_dictionary_words(word, word_dict)) # Output: True word = \\"applepenapple\\" word_dict = {\\"apple\\", \\"pen\\"} print(can_segment_into_dictionary_words(word, word_dict)) # Output: True word = \\"catsandog\\" word_dict = {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"} print(can_segment_into_dictionary_words(word, word_dict)) # Output: False ``` **Notes**: * Consider edge cases such as when the string is made of a single word in the dictionary or has no valid segmentations. * Optimize for both time and space complexity while ensuring correctness. Implement the function by leveraging dynamic programming to solve this classic problem efficiently.","solution":"def can_segment_into_dictionary_words(word: str, word_dict: set) -> bool: Determine if the word can be segmented into a space-separated sequence of one or more dictionary words. :param word: str - the input string to be segmented. :param word_dict: Set[str] - a set containing dictionary words. :return: bool - True if the word can be segmented, otherwise False. n = len(word) dp = [False] * (n + 1) dp[0] = True # Base case: an empty string can be segmented. for i in range(1, n + 1): for j in range(i): if dp[j] and word[j:i] in word_dict: dp[i] = True break return dp[n]"},{"question":"Given the implementations of functions to convert integers to byte arrays and back in both big-endian and little-endian formats, write a new function that takes a list of integers and returns a tuple: 1. A byte array representation of their concatenation (all integers joined together) in big-endian format. 2. The total integer value interpreted from the concatenated byte array in big-endian format. # Function Signature ```python def concat_and_convert_to_int(int_list): pass ``` # Input * `int_list` : List[int] - A list of non-negative integers. * Each integer in the list can be arbitrarily large. # Output * Tuple[bytes, int] - A tuple containing two elements: * The first element is a byte array that represents the concatenation of all integers in the list in big-endian format. * The second element is the integer value obtained by interpreting the concatenated byte array in big-endian format. # Constraints * All integers in the list are non-negative. * The provided list is non-empty. # Example ```python # Example input int_list = [1, 256, 65536] # Example output (bytearray(b\'x00x01x00x01x00x00x01x00\'), 4294967296 + 256 + 1) ``` # Requirements * Your solution should correctly handle edge cases such as an integer value of 0. * Aim to optimize for both readability and performance. # Notes Keep in mind the provided functions for individual integer and byte array conversions in both big-endian and little-endian formats. Feel free to use helper functions if needed.","solution":"def int_to_bytes_be(integer): Converts an integer to a byte array in big-endian format. if integer == 0: return bytes([0]) byte_length = (integer.bit_length() + 7) // 8 return integer.to_bytes(byte_length, byteorder=\'big\') def bytes_to_int_be(byte_array): Converts a big-endian byte array to an integer. return int.from_bytes(byte_array, byteorder=\'big\') def concat_and_convert_to_int(int_list): Concatenates a list of integers into a byte array in big-endian format and returns the byte array and the integer it represents. # Convert each integer to its byte array in big-endian format byte_arrays = [int_to_bytes_be(num) for num in int_list] # Concatenate all byte arrays concatenated_byte_array = b\'\'.join(byte_arrays) # Convert the concatenated byte array back to an integer in big-endian format total_integer_value = bytes_to_int_be(concatenated_byte_array) return concatenated_byte_array, total_integer_value"},{"question":"Scenario You are a software engineer working on a project that involves processing and analyzing hierarchical data structures. One task requires determining if a specific configuration (represented as a smaller binary tree) is present within a larger dataset structure (represented as a larger binary tree). Task Write a Python function `is_subtree(big, small)` that determines if the smaller binary tree `small` is a subtree of the larger binary tree `big`. Requirements - Implement the function `is_subtree(big, small)`. - Binary tree nodes have attributes `val`, `left`, and `right`. # Input - `big`: The root node of the larger binary tree. - `small`: The root node of the smaller binary tree. # Output - Return `True` if `small` is a subtree of `big`, otherwise `False`. # Constraints - At most 10^4 nodes in the larger tree. - Each node\'s value is an integer. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example usage: # Creating nodes for the larger tree n1 = TreeNode(3) n2 = TreeNode(4) n3 = TreeNode(5) n4 = TreeNode(1) n5 = TreeNode(2) n1.left = n2 n1.right = n3 n2.left = n4 n2.right = n5 # Creating nodes for the smaller tree m1 = TreeNode(4) m2 = TreeNode(1) m3 = TreeNode(2) m1.left = m2 m1.right = m3 # Function call print(is_subtree(n1, m1)) # Expected output: True ``` # Follow-up Discuss how you would handle situations where the larger tree is significantly larger than the smaller tree. Suggest improvements or different strategies to address performance and space efficiency.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(tree1, tree2): if not tree1 and not tree2: return True if not tree1 or not tree2: return False return (tree1.val == tree2.val and is_same_tree(tree1.left, tree2.left) and is_same_tree(tree1.right, tree2.right)) def is_subtree(big, small): if not small: return True if not big: return False if is_same_tree(big, small): return True return is_subtree(big.left, small) or is_subtree(big.right, small)"},{"question":"You are given an n x n 2D `matrix` that represents an image. Write a function `rotate_image(matrix)` that rotates the image by 90 degrees clockwise in-place. # Input: * `matrix`: A list of lists where each inner list has `n` integers, representing an n x n grid of image pixel values. # Output: * The function should modify the input matrix in-place and does not need to return anything. # Constraints: * The input will always be a valid n x n matrix where 1 ≤ n ≤ 20. * An empty matrix should not be processed. # Example: ```python def test_rotate_image(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_image(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] print(\\"Test passed!\\") matrix = [ [1] ] rotate_image(matrix) assert matrix == [ [1] ] print(\\"Test passed!\\") matrix = [] rotate_image(matrix) assert matrix == [] print(\\"Test passed!\\") test_rotate_image() ``` # Function Signature: ```python def rotate_image(matrix: List[List[int]]) -> None: ``` # Requirements: 1. You must perform the rotation in-place. 2. Consider common edge cases like an empty matrix or a single-element matrix. 3. Provide a clear and correct `rotate_image` function that will be tested using the examples given. 4. Ensure the function modifies the input matrix as expected.","solution":"def rotate_image(matrix): Rotates the given n x n matrix by 90 degrees clockwise in-place. # First, transpose the matrix n = len(matrix) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"You are tasked to implement a class `WordDictionary` that supports the following operations: 1. **addWord(word)**: Adds a word into the data structure. 2. **search(word)**: Searches for a literal word or a regular expression-like pattern where `.` can be any single letter. # Class Definition Implement the class `WordDictionary`: ```python class WordDictionary: def __init__(self): Initialize data structure here. pass def add_word(self, word: str) -> None: Adds a word into the word dictionary. pass def search(self, word: str) -> bool: Searches for a word or regular expression pattern. Returns True if the word or pattern matches any word in the dictionary. pass ``` # Input and Output Format - `add_word(word: str) -> None`: Method takes a string `word` and adds it to the data structure. - `search(word: str) -> bool`: Method takes a string `word` which can include the wildcard character `.` and returns a boolean indicating whether any word in the data structure matches the given word. # Constraints - All words are lower-case alphabets. - `word` can be empty. - `word` length will be at most 100. - Total number of calls to `add_word` and `search` methods combined will be at most `10^4`. # Example ```python wordDictionary = WordDictionary() wordDictionary.add_word(\\"bad\\") wordDictionary.add_word(\\"dad\\") wordDictionary.add_word(\\"mad\\") assert wordDictionary.search(\\"pad\\") == False assert wordDictionary.search(\\"bad\\") == True assert wordDictionary.search(\\".ad\\") == True assert wordDictionary.search(\\"b..\\") == True ``` # Notes - Focus on efficient implementation to handle multiple wildcards and large collections of words efficiently. - Consider edge cases like empty strings and words consisting entirely of wildcard characters. - Ensure that the data structure is optimized for both space and time complexities.","solution":"class WordDictionary: def __init__(self): Initialize data structure here. self.words = [] def add_word(self, word: str) -> None: Adds a word into the word dictionary. self.words.append(word) def search(self, word: str) -> bool: Searches for a word or regular expression pattern. Returns True if the word or pattern matches any word in the dictionary. import re pattern = re.compile(f\\"^{word}\\") return any(pattern.match(w) for w in self.words)"},{"question":"# Connected Components in Graph **Context**: You are working on a networking tool to analyze network structures. To begin with, you need to identify isolated networks within a larger network composed of interconnected devices. Each isolated network is termed a \\"connected component.\\" You are required to create a function that calculates the number of connected components in a given undirected graph. # Function Implementation Write a Python function `count_components` that accepts an adjacency list of an undirected graph and the number of nodes, and returns the number of connected components. **Function Signature**: ```python def count_components(adjacency_list: List[List[int]], size: int) -> int: ``` **Input**: - `adjacency_list` (List[List[int]]): A list of lists where `adjacency_list[i]` contains the nodes connected to node `i`. - `size` (int): Total number of nodes in the graph. **Output**: - `int`: Number of connected components. **Constraints**: - 1 <= size <= 10^5 (There may be up to 100,000 nodes) - 0 <= len(adjacency_list[i]) <= size-1 for all 1 <= i <= size-1 - Graph could be fully disconnected or fully connected **Example**: ```python adjacency_list = [ [], [2], # Node 1 is connected to Node 2 [1, 4, 5], # Node 2 is connected to Node 1, 4, and 5 [7], # Node 3 is connected to Node 7 [2], # Node 4 is connected to Node 2 [2, 6], # Node 5 is connected to Node 2 and 6 [5], # Node 6 is connected to Node 5 [3] # Node 7 is connected to Node 3 ] size = 7 assert count_components(adjacency_list,size) == 2 ``` # Notes: - This function should handle large graphs efficiently, with consideration for time and space complexity. - Consider edge cases such as completely disconnected graphs or graphs with no nodes.","solution":"from typing import List def count_components(adjacency_list: List[List[int]], size: int) -> int: Count the number of connected components in an undirected graph. :param adjacency_list: List of lists where adjacency_list[i] contains the nodes connected to node i :param size: Total number of nodes in the graph :return: Number of connected components def dfs(node: int): stack = [node] while stack: current = stack.pop() for neighbor in adjacency_list[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) visited = set() count = 0 for node in range(size): if node not in visited: dfs(node) count += 1 return count"},{"question":"Context You are given an array of integers where every element appears twice except for two elements which appear exactly once. Your task is to identify these two unique elements. Problem Statement Write a function `find_unique_elements(nums)` that takes a list of integers `nums`, where exactly two elements appear only once and all other elements appear twice. The function should return a list containing the two unique elements. The order of the unique elements in the output list is not important. # Input and Output Format # Input: - A list of integers `nums` of length `N` (1 ≤ N ≤ 10^6). - All integers in `nums` appear twice except for exactly two unique elements. - Example: `nums = [1, 2, 1, 3, 2, 5]` # Output: - A list containing the two unique integers. - Example: `[3, 5]` or `[5, 3]` # Constraints: - Time Complexity: O(N) - Space Complexity: O(1) # Performance Requirements The solution must achieve the specified time and space complexity constraints. Example Cases: # Example 1: Input: `nums = [1, 2, 1, 3, 2, 5]` Output: `[3, 5]` or `[5, 3]` # Example 2: Input: `nums = [4, 6, 2, 4, 6, 7]` Output: `[2, 7]` or `[7, 2]` Implementation Notes: 1. Use XOR operations to isolate the two unique numbers. 2. Partition the array based on the rightmost differing bit between the two unique numbers. 3. Perform XOR separately on each partition to find the unique numbers. Function Signature: ```python def find_unique_elements(nums): # Your implementation here ```","solution":"def find_unique_elements(nums): Returns a list containing the two unique integers from the input list. # XOR-ing all elements will give us a XOR result of the two unique elements xor_result = 0 for num in nums: xor_result ^= num # Find the rightmost set bit in xor_result rightmost_set_bit = xor_result & -xor_result # Divide elements into two groups based on the rightmost set bit num1, num2 = 0, 0 for num in nums: if num & rightmost_set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"# Question: Counting Unique BSTs Problem Statement A binary search tree (BST) is a tree data structure in which each node has at most two children, referred to as the left child and the right child. For each node, values in the left subtree are less, and values in the right subtree are greater. Given an integer n, calculate the number of structurally unique BSTs (binary search trees) that contain values from 1 to n inclusive. You need to implement the function `num_trees`, which uses dynamic programming to determine this count. Function Signature ```python def num_trees(n: int) -> int: pass ``` Input - An integer n (0 <= n <= 19). Output - An integer, the number of structurally unique BSTs that store values from 1 to n. Constraints and Performance Requirements - You should ensure that your solution runs in O(n^2) time complexity and uses O(n) space complexity. - You are expected to handle larger values of n (close to the upper bound of the constraint) efficiently. Example - Input: n = 3 - Output: 5 Explanation: For n = 3, there are 5 unique BSTs as shown in the prompt: ``` 1 3 3 2 1 / / / 3 2 1 1 3 2 / / 2 1 2 3 ``` Additional Notes - The problem follows the recursion formula for Catalan numbers: [ F(n) = sum_{i=1}^{n} F(i-1) times F(n-i) ] You should convert this recursive formulation into an iterative dynamic programming solution.","solution":"def num_trees(n: int) -> int: Calculate the number of unique BSTs that can be created using values from 1 to n. if n == 0 or n == 1: return 1 # Create a list to store the computed number of unique BSTs dp = [0] * (n + 1) # There is one unique BST with 0 or 1 nodes dp[0] = 1 dp[1] = 1 # Fill the dp list using the formula for Catalan numbers for nodes in range(2, n + 1): for root in range(1, nodes + 1): left_subtrees = dp[root - 1] right_subtrees = dp[nodes - root] dp[nodes] += left_subtrees * right_subtrees return dp[n]"},{"question":"\\"Narcissistic Number Range Finder\\" Scenario You have been tasked with finding all numbers within a given range [low, high] that are equal to the sum of their digits raised to consecutive powers starting from 1. This task requires a good understanding of number manipulation and power calculations. Function Specification Write a function `find_narcissistic_numbers(low: int, high: int) -> List[int]` that returns a list of numbers in the range [low, high] inclusive, which satisfy the property where the number equals the sum of its digits raised to consecutive powers. Input * An integer `low`: the lower bound of the range (1 ≤ low ≤ 10^4). * An integer `high`: the upper bound of the range (low ≤ high ≤ 10^4). Output * A list of integers that satisfy the described property. Example ```python def find_narcissistic_numbers(low: int, high: int) -> List[int]: # Your implementation here # Example usage: print(find_narcissistic_numbers(1, 100)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] print(find_narcissistic_numbers(50, 150)) # Output: [89, 135] ``` Constraints * The function should be efficient enough to handle the upper limit of the input constraints. * Consider edge cases like no numbers in the range satisfying the property. Performance Requirements Strive to minimize time and space complexity while ensuring the solution is correct.","solution":"from typing import List def find_narcissistic_numbers(low: int, high: int) -> List[int]: def is_narcissistic(num: int) -> bool: digits = list(map(int, str(num))) return num == sum(dig ** (i+1) for i, dig in enumerate(digits)) return [num for num in range(low, high + 1) if is_narcissistic(num)] # Example usage: # print(find_narcissistic_numbers(1, 100)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] # print(find_narcissistic_numbers(50, 150)) # Output: [89, 135]"},{"question":"**Task**: You are given a list of integers `nums` where every element appears twice except for one. Your task is to find the single one. **Function Signature**: ```python def single_number(nums: List[int]) -> int: This function finds and returns the single unique number in a list where all other elements appear twice. :param nums: List of integers (1 <= len(nums) <= 3 * 10^4) :return: The single unique integer from the list ``` # Constraints: * The function should have a linear runtime complexity, O(n). * No extra memory should be used, O(1) space complexity. * The input list is non-empty and contains at least one unique number. # Input/Output Format: * **Input**: A list of integers `nums` such that `1 <= len(nums) <= 3 * 10^4`. * **Output**: An integer representing the single number that appears only once in the list. # Example: ```python assert single_number([4, 1, 2, 1, 2]) == 4 assert single_number([2, 2, 1]) == 1 assert single_number([1]) == 1 ``` # Scenario: Imagine you have a list of integers where each integer appears exactly twice except for one integer that appears only once. Your task is to find this single integer using bitwise XOR operations to achieve an optimal solution.","solution":"from typing import List def single_number(nums: List[int]) -> int: This function finds and returns the single unique number in a list where all other elements appear twice using bitwise XOR. :param nums: List of integers (1 <= len(nums) <= 3 * 10^4) :return: The single unique integer from the list # Initialize a variable to hold the result of XOR operations. single = 0 # Perform XOR operation on each element in the list. for num in nums: single ^= num return single"},{"question":"Decode String with Nested Patterns Given an encoded string, return its decoded string following specific encoding rules. The encoding rule is defined as: `k[encoded_string]`, wherein the `encoded_string` inside the square brackets is repeated exactly `k` times. Function Signature: ```python def decode_string(s: str) -> str: Decode a given encoded string, `s`. Parameters: s (str): Encoded string to be decoded. Returns: str: Decoded string. ``` Input: * `s`: A non-empty string containing digits, letters, and square brackets. The digits represent the number of times the enclosed string should be repeated. Output: * Return the decoded string. Constraints: * The input string is valid; containing no extra spaces, square brackets are well-formed, etc. * The original data does not contain any digits; digits in the input are only used for repeat numbers, `k`. Example: ```python # Example 1: input = \\"3[a]2[bc]\\" output = \\"aaabcbc\\" # Example 2: input = \\"3[a2[c]]\\" output = \\"accaccacc\\" # Example 3: input = \\"2[abc]3[cd]ef\\" output = \\"abcabccdcdcdef\\" ``` Explanation: * In the first example, \\"3[a]2[bc]\\" is decoded as \\"aaa\\" followed by \\"bcbc\\", resulting in \\"aaabcbc\\". * In the second example, \\"3[a2[c]]\\" interprets the inner \\"2[c]\\" first (as \\"cc\\"), and then repeats it \\"3\\" times resulting in \\"accaccacc\\". * In the third example, \\"2[abc]3[cd]ef\\" forms \\"abcabc\\" and \\"cdcdcde\\" with \\"ef\\" appended to the end. Objective: Write a function `decode_string` that interprets and decodes the provided encoded string as described.","solution":"import re def decode_string(s: str) -> str: Decode a given encoded string, `s`. Parameters: s (str): Encoded string to be decoded. Returns: str: Decoded string. stack = [] current_num = 0 current_str = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_str, current_num)) current_str, current_num = \\"\\", 0 elif char == \']\': last_str, num = stack.pop() current_str = last_str + current_str * num else: current_str += char return current_str"},{"question":"# Context You are working on a real-time data analytics system that processes continuous data streams. One of the requirements is to compute the moving average of the last `N` values in the stream. To achieve this, you decide to implement a class `EfficientMovingAverage` that maintains the average efficiently even as new data arrives. # Task Implement the class `EfficientMovingAverage` with methods for initialization and updating the current moving average as new integer values are added. Ensure the average is updated efficiently without recalculating the sum of the entire window each time a new value is added. # Requirements 1. **Class Name**: EfficientMovingAverage 2. **Methods**: * **__init__(self, size: int)**: Initializes the object with a specified size of the moving window. * **next(self, val: int) -> float**: Takes a new integer `val` and returns the updated moving average of the last `size` values. # Constraints * All integer values will be between -10^4 and 10^4. * The number of calls to the `next` method will not exceed 10^5. # Example ```python m = EfficientMovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: (1 + 10) / 2 = 5.5 print(m.next(3)) # Output: (1 + 10 + 3) / 3 = 4.666666666666667 print(m.next(5)) # Output: (10 + 3 + 5) / 3 = 6.0 ``` # Note Ensure that your solution handles the sliding window efficiently. Aim to reduce the complexity of updating the sum when new elements are added and old elements are removed.","solution":"from collections import deque class EfficientMovingAverage: def __init__(self, size: int): Initialize the moving average object with a specified size of the moving window. self.size = size self.queue = deque() self.current_sum = 0 def next(self, val: int) -> float: Takes a new integer \'val\' and returns the updated moving average of the last \'size\' values. if len(self.queue) == self.size: removed_val = self.queue.popleft() self.current_sum -= removed_val self.queue.append(val) self.current_sum += val return self.current_sum / len(self.queue)"},{"question":"Coding Assessment Question # Scenario You are developing a data filtering tool for a statistical software package. The tool needs to allow users to filter a list of numerical data based on a user-specified range. # Task Write a function `filter_range(arr, min_val=None, max_val=None)` that takes an array of numbers `arr`, and optional parameters `min_val` and `max_val`. The function should return a new array containing only the elements of `arr` that are between `min_val` and `max_val`, inclusive. If `min_val` is not provided, it should include all elements greater than `-Infinity`. If `max_val` is not provided, it should include all elements less than `Infinity`. # Input and Output * **Input**: * `arr`: A list of integers (`List[int]`), length `0 <= len(arr) <= 10^6`. * `min_val`: An optional integer that specifies the minimum value in the range. * `max_val`: An optional integer that specifies the maximum value in the range. * **Output**: * A list of integers filtered to the specified range. # Examples ```python # Example 1 input_array = [1, 2, 3, 4, 5] min_val = 2 max_val = 4 # Expected output: [2, 3, 4] # Example 2 input_array = [10, 20, 30, 40, 50] min_val = None max_val = 30 # Expected output: [10, 20, 30] # Example 3 input_array = [100, 200, 300, 400, 500] min_val = 250 max_val = None # Expected output: [300, 400, 500] # Example 4 input_array = [] min_val = 1 max_val = 10 # Expected output: [] # Example 5 input_array = [5, 5, 5, 5, 5] min_val = 5 max_val = 5 # Expected output: [5, 5, 5, 5, 5] ``` # Constraints * The implementation should process arrays with up to `10^6` elements efficiently. * Edge cases such as empty arrays and `None` values for the range limits should be handled gracefully. # Function Signature ```python def filter_range(arr: List[int], min_val: int = None, max_val: int = None) -> List[int]: pass ``` Implement the `filter_range` function using the above guidelines.","solution":"from typing import List def filter_range(arr: List[int], min_val: int = None, max_val: int = None) -> List[int]: Filters the array such that only elements between min_val and max_val (inclusive) are included. Parameters: arr (List[int]): The input array of integers. min_val (int, optional): The minimum value for the range filter. max_val (int, optional): The maximum value for the range filter. Returns: List[int]: A list of integers filtered to the specified range. if min_val is None: min_val = float(\'-inf\') if max_val is None: max_val = float(\'inf\') return [x for x in arr if min_val <= x <= max_val]"},{"question":"# Combination Calculation with Large Inputs Given two non-negative integers `n` and `r`, the task is to compute the number of ways to choose `r` items from a set of `n` items (nCr). You must provide an efficient implementation using dynamic programming concepts. Ensure your solution handles large values of `n` and `r` within sensible time and space limits. # Requirements * Write a function `combination(n: int, r: int) -> int` that: * Returns the number of combinations. * Handles large inputs efficiently. * Adheres to the combinatorial principles and edge cases. * Expected time complexity: O(n * r) * Expected space complexity: O(r), using an iterative dynamic programming approach. # Input * Two integers `n` and `r` where `0 <= r <= n`. # Output * An integer representing the number of combinations. # Example ```python assert combination(5, 2) == 10 assert combination(10, 5) == 252 assert combination(0, 0) == 1 assert combination(100, 50) == 100891344545564193334812497256 ``` # Constraints * `0 <= n <= 10^5` * `0 <= r <= n` # Implementation Details You are required to optimize the recursive solution using dynamic programming concepts. Specifically, implement an iterative approach to efficiently calculate the combinations while minimizing space usage. ```python def combination(n: int, r: int) -> int: if r > n: return 0 if r == 0 or r == n: return 1 # Use a 1-D array to store intermediate combination values dp = [0] * (r + 1) dp[0] = 1 # C(n, 0) = 1 for i in range(1, n + 1): # Start from min(i, r) to 1 to update the dp array for j in range(min(i, r), 0, -1): dp[j] = dp[j] + dp[j - 1] return dp[r] ``` Note 1. Please ensure your implementation handles edge cases such as `n == r` and `r == 0`.","solution":"def combination(n: int, r: int) -> int: if r > n: return 0 if r == 0 or r == n: return 1 # Use a 1-D array to store intermediate combination values dp = [0] * (r + 1) dp[0] = 1 # C(n, 0) = 1 for i in range(1, n + 1): # Start from min(i, r) to 1 to update the dp array for j in range(min(i, r), 0, -1): dp[j] = dp[j] + dp[j - 1] return dp[r]"},{"question":"# Polynomial and Monomial Data Structures Objective Implement a customizable polynomial class to demonstrate understanding of fundamental and advanced data structure manipulation. This class should support core algebraic operations and evaluation via substitution. Task Using the provided `Monomial` and `Polynomial` classes, update and extend the implementation to include the following functionalities: 1. **Monomial Division**: - Implement the ability to divide two monomials and handle edge cases such as division by zero. 2. **Polynomial Division**: - Enable division between two polynomials. This involves polynomial long division, ensuring proper handling of remainders. 3. **Differentiation**: - Implement a method for both `Monomial` and `Polynomial` classes to compute the derivative with respect to a given variable. 4. **Integration**: - Implement an integration method for both classes with respect to a given variable, assuming constants of integration are ignored. Implementation Requirements - Ensure all operations return instances of `Monomial` or `Polynomial` with appropriate simplifications. - Follow proper exception handling for illegal operations. - Maintain thorough docstrings and comments for clarity. Input and Output Formats - Implement the following methods with exact input and output: ```python class Monomial: def __truediv__(self, other: Monomial) -> Monomial: # Compute the division of monomials class Polynomial: def __truediv__(self, other: Polynomial) -> Polynomial: # Compute the division of polynomials def differentiate(self, variable: int) -> Polynomial: # Compute the derivative with respect to the given variable def integrate(self, variable: int) -> Polynomial: # Compute the indefinite integral with respect to the given variable ``` Constraints - Coefficients can be integers, floats, or fractions. - Variables must be represented by dictionary keys (integers). Performance Requirements - Polynomial division should operate with a complexity of O(n^2) or better for polynomials of degree n. - Differentiation and integration should operate linearly with respect to the number of terms. Example ```python p1 = Polynomial([ Monomial({1: 2}, 3), # 3x^2 Monomial({1: 1, 2: 1}, 4), # 4xy ]) p2 = Polynomial([ Monomial({1: 1}, 1), # x ]) # Polynomial Division result = p1 / p2 # Expected: Polynomial([Monomial({1: 1}, 3), Monomial({2: 1}, 4)]) # Differentiation derivative = p1.differentiate(1) # Expected: Polynomial([Monomial({1: 1}, 6), Monomial({2: 1}, 4)]) # Integration integral = p1.integrate(1) # Expected: Polynomial([Monomial({1: 3}, 1), Monomial({1: 2, 2: 1}, 2)]) ``` Implement these methods and ensure they pass various test cases, particularly edge cases like division by zero and differentiation of constants.","solution":"from fractions import Fraction from typing import Dict, List class Monomial: def __init__(self, powers: Dict[int, int], coefficient: float): self.powers = powers self.coefficient = coefficient def __truediv__(self, other: \'Monomial\') -> \'Monomial\': if other.coefficient == 0: raise ZeroDivisionError(\\"Division by zero monomial\\") result_coefficient = self.coefficient / other.coefficient result_powers = self.powers.copy() for variable, power in other.powers.items(): if variable in result_powers: result_powers[variable] -= power if result_powers[variable] == 0: del result_powers[variable] else: result_powers[variable] = -power return Monomial(result_powers, result_coefficient) def differentiate(self, variable: int) -> \'Monomial\': if variable not in self.powers: return Monomial({}, 0) new_coefficient = self.coefficient * self.powers[variable] new_powers = self.powers.copy() if new_powers[variable] == 1: del new_powers[variable] else: new_powers[variable] -= 1 return Monomial(new_powers, new_coefficient) def integrate(self, variable: int) -> \'Monomial\': new_powers = self.powers.copy() if variable in new_powers: new_powers[variable] += 1 else: new_powers[variable] = 1 new_coefficient = self.coefficient / new_powers[variable] return Monomial(new_powers, new_coefficient) def __repr__(self): terms = [f\\"{self.coefficient}\\"] for var, exp in self.powers.items(): terms.append(f\\"x{var}^{exp}\\") return \\" * \\".join(terms) class Polynomial: def __init__(self, monomials: List[Monomial]): self.monomials = monomials def __truediv__(self, other: \'Polynomial\') -> \'Polynomial\': if len(other.monomials) != 1 or other.monomials[0].coefficient == 0: raise ZeroDivisionError(\\"Polynomial division requires a non-zero single-term divisor\\") divisor = other.monomials[0] quotient_monomials = [] for monomial in self.monomials: quotient_monomials.append(monomial / divisor) return Polynomial(quotient_monomials) def differentiate(self, variable: int) -> \'Polynomial\': differentiated_monomials = [m.differentiate(variable) for m in self.monomials] return Polynomial(differentiated_monomials) def integrate(self, variable: int) -> \'Polynomial\': integrated_monomials = [m.integrate(variable) for m in self.monomials] return Polynomial(integrated_monomials) def __repr__(self): return \\" + \\".join(map(str, self.monomials))"},{"question":"# Scenario: You have been hired by a logistics company to optimize their parcel sorting system, which currently sorts parcels based on their unique tracking codes. Each tracking code is a positive integer, and the company guarantees that the range of tracking codes falls within a known small range for their sorting departments. You must implement an efficient sorting algorithm that leverages this fact. # Task: Write a function `optimized_pigeonhole_sort` that sorts a list of integer tracking codes using the pigeonhole sorting algorithm. # Function Signature: ```python def optimized_pigeonhole_sort(parcels: List[int]) -> List[int]: ``` # Input: - `parcels` (List[int]): A list of integers representing the tracking codes of parcels. (1 <= len(parcels) <= 10^5, 0 <= tracking codes <= 10^5) # Output: - Returns the sorted list of tracking codes as a list of integers. # Example: ```python # Example 1 parcels = [10, 3, 19, 5, 18, 9] assert optimized_pigeonhole_sort(parcels) == [3, 5, 9, 10, 18, 19] # Example 2 parcels = [2, 1, 0] assert optimized_pigeonhole_sort(parcels) == [0, 1, 2] # Example 3 parcels = [] assert optimized_pigeonhole_sort(parcels) == [] # Example 4 parcels = [7, 7, 7, 7] assert optimized_pigeonhole_sort(parcels) == [7, 7, 7, 7] ``` # Constraints: - Ensure the sorting is done in O(n + Range) time complexity. - Consider edge cases such as empty list, list with identical elements, and lists with minimum and maximum tracking codes.","solution":"def optimized_pigeonhole_sort(parcels): if not parcels: return [] min_val = min(parcels) max_val = max(parcels) range_size = max_val - min_val + 1 holes = [0] * range_size for tracking_code in parcels: holes[tracking_code - min_val] += 1 sorted_parcels = [] for index, count in enumerate(holes): sorted_parcels.extend([index + min_val] * count) return sorted_parcels"},{"question":"# Sparse Matrix Multiplication Problem Statement You are provided with two sparse matrices A and B comprised mostly of zero elements. Your task is to compute the product of matrices A and B (denoted as AB). You can assume that A\'s column number is equal to B\'s row number, making the multiplication valid. Input Format - A: a list of lists where each sublist represents a row of matrix A. - B: a list of lists where each sublist represents a row of matrix B. Output Format - Return a list of lists representing the product matrix AB. # Constraints - Both A and B will have no more than 300 x 300 elements. - Elements in A and B are integers. Performance Requirements - Utilize sparsity for optimization to handle matrices efficiently. - Aim for minimizing time and space complexity leveraging matrix properties. Examples Example 1: ```plaintext Input: A = [ [ 1, 0, 0], [-1, 0, 3] ] B = [ [ 7, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 1 ] ] Output: [ [7, 0, 0], [-7, 0, 3] ] ``` # Task Implement the function `sparse_matrix_multiply(A, B)` following the above specifications and considering the provided constraints and edge cases.","solution":"def sparse_matrix_multiply(A, B): Multiplies two sparse matrices A and B to give the product matrix AB. Parameters: - A: List of lists, where each sublist represents a row of matrix A - B: List of lists, where each sublist represents a row of matrix B Returns: - List of lists representing the product matrix AB # Number of rows and columns in A rows_A = len(A) cols_A = len(A[0]) # Number of rows and columns in B rows_B = len(B) cols_B = len(B[0]) # Resultant matrix with all elements initialized to 0 result = [[0] * cols_B for _ in range(rows_A)] # Sparse matrix multiplication for i in range(rows_A): for k in range(cols_A): if A[i][k] != 0: for j in range(cols_B): if B[k][j] != 0: result[i][j] += A[i][k] * B[k][j] return result"},{"question":"**Problem Statement**: You are given a binary tree. Implement a function `is_balanced(root)` to determine if the tree is height-balanced. A binary tree is height-balanced if for every node in the tree, the difference in height between its left and right subtrees is at most one. **Function Signature**: ```python def is_balanced(root: Optional[TreeNode]) -> bool: ``` **Input**: - `root`: The root node of a binary tree (of type `TreeNode`). **Output**: - Return `True` if the tree is height-balanced, otherwise return `False`. **Constraints**: - The number of nodes in the tree is in the range [0, 10^4]. - The values of the nodes are not relevant for this problem. **Example**: ```python # Example 1: # Input: root = [3,9,20,null,null,15,7] # Output: True # Example 2: # Input: root = [1,2,2,3,3,null,null,4,4] # Output: False # Example 3: # Input: root = [] # Output: True ``` **Context**: In scenarios like workload distribution, search efficiency, or data organization where a balanced binary tree structure facilitates optimal performance, it is critical to ensure the balance of the binary tree. The given problem tests your ability to correctly implement an efficient algorithm to determine the balance of binary trees, leveraging depth-first search traversal and recursive techniques. **Note**: - You must not use any additional data structures; implement the function in an in-place manner. - Aim for an optimal O(N) time complexity solution.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: Optional[TreeNode]) -> bool: def height(node): if not node: return 0 left_height = height(node.left) right_height = height(node.right) if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1: return -1 return 1 + max(left_height, right_height) return height(root) != -1"},{"question":"# Problem Description You are provided with a non-empty string `s`. Your task is to determine if the string can be constructed by repeating a substring of it multiple times. If true, return the length of the smallest such substring; otherwise, return -1. # Input and Output * **Input**: * A non-empty string `s` (1 ≤ |s| ≤ 10^4). * **Output**: * If the string can be constructed by repeating a substring, return the length of the smallest such substring. * Otherwise, return -1. # Constraints * The input string contains only lowercase English characters. * You should aim for a solution with a time complexity of O(n). # Example Example 1 * **Input**: \\"abab\\" * **Output**: 2 * **Explanation**: The string is constructed by repeating the substring \\"ab\\". Example 2 * **Input**: \\"aba\\" * **Output**: -1 * **Explanation**: The string cannot be constructed by repeating any substring. Example 3 * **Input**: \\"abcabcabcabc\\" * **Output**: 3 * **Explanation**: The string is constructed by repeating the substring \\"abc\\". # Scenario/Context Imagine you are working on a text processing system that needs to identify repeating patterns efficiently to compress text data. # Function Signature ```python def smallest_repeating_substring_length(s: str) -> int: This function determines the length of the smallest repeating substring. :param s: Input string. :type s: str :return: Length of smallest repeating substring or -1 if no such substring exists. :rtype: int pass ```","solution":"def smallest_repeating_substring_length(s: str) -> int: n = len(s) # Iterate over possible lengths of the repeating substring for i in range(1, n // 2 + 1): if n % i == 0: # Check if length of s is divisible by i # Check if repeating substring of length \'i\' forms the whole string if s[:i] * (n // i) == s: return i return -1"},{"question":"Implement a function `rabin_karp_multiple_substrings` which takes a list of patterns and a single text. The function should utilize the Rabin-Karp algorithm to find all occurrences of each pattern in the text and return a dictionary where each key is a pattern and each value is a list of starting indices where that pattern is found. Your implementation should efficiently handle the case where multiple patterns need to be searched within the same text. Function Signature ```python def rabin_karp_multiple_substrings(patterns: List[str], text: str) -> Dict[str, List[int]]: pass ``` Input * `patterns` : A list containing multiple patterns as strings to be searched in the text. * `text` : A string representing the text in which these patterns need to be searched. Output * A dictionary where each key is a pattern from the input list and each value is a list of starting indices in the text where the pattern is found. Constraints * Patterns are non-empty strings and will always contain only lowercase alphabet characters (\'a\'-\'z\'). * Text is a non-empty string containing only lowercase alphabet characters (\'a\'-\'z\'). * Length of text and each pattern will not exceed (10^5). Example ```python patterns = [\\"ab\\", \\"bc\\", \\"abc\\"] text = \\"abcabcabc\\" output = {\'ab\': [0, 3, 6], \'bc\': [1, 4, 7], \'abc\': [0, 3, 6]} ``` # Requirements 1. Handle collisions effectively. 2. Utilize the rolling hash technique for computing the hashes. 3. Ensure that the function runs efficiently within the provided constraints. Good luck!","solution":"from typing import List, Dict def rabin_karp_multiple_substrings(patterns: List[str], text: str) -> Dict[str, List[int]]: def hash_function(s, base, mod): hash_value = 0 for char in s: hash_value = (hash_value * base + ord(char)) % mod return hash_value def rolling_hash(old_hash, old_char, new_char, base, mod, power): new_hash = (old_hash - ord(old_char) * power) * base + ord(new_char) return new_hash % mod base = 256 mod = 2**61 - 1 n = len(text) result = {pattern: [] for pattern in patterns} for pattern in patterns: m = len(pattern) pattern_hash = hash_function(pattern, base, mod) text_hash = hash_function(text[:m], base, mod) power = pow(base, m - 1, mod) if pattern_hash == text_hash and text[:m] == pattern: result[pattern].append(0) for i in range(m, n): text_hash = rolling_hash(text_hash, text[i - m], text[i], base, mod, power) if pattern_hash == text_hash and text[i - m + 1:i + 1] == pattern: result[pattern].append(i - m + 1) return result"},{"question":"You are developing a feature for a phone-based auto-complete system. Given a digit string where each digit maps to specific letters as on a traditional telephone keypad, your task is to generate all possible letter combinations the number could represent. The function should be efficient and able to handle typical edge cases. Input * A string `digits` consisting of digits `2-9`. * `1` and `0` do not map to any letters and should be excluded. * An empty string input should return an empty list. Output * A list of strings, where each string represents a unique letter combination corresponding to the input digits. Constraints * Output list should be in lexicographical order if possible. * The length of `digits` will not exceed 10. Examples Example 1: ``` Input: \\"23\\" Output: [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] ``` Example 2: ``` Input: \\"\\" Output: [] ``` Example 3: ``` Input: \\"7\\" Output: [\\"p\\", \\"q\\", \\"r\\", \\"s\\"] ``` # Task Implement the function: ```python def phone_combinations(digits: str) -> List[str]: # Your implementation here ``` Notes * Your implementation should handle and return results within a reasonable time frame for typical inputs.","solution":"from typing import List def phone_combinations(digits: str) -> List[str]: if not digits: return [] phone_map = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index: int, path: str): if index == len(digits): combinations.append(path) return possible_letters = phone_map[digits[index]] for letter in possible_letters: backtrack(index + 1, path + letter) combinations = [] backtrack(0, \\"\\") return sorted(combinations)"},{"question":"**Context**: A digital circuit engineer is developing a system where data is stored in an efficient, compressed binary form. To ensure data integrity during transmission between different modules of the system, the engineer needs to calculate how different the data is (in terms of bit differences) before and after transmission. Your task is to implement a function that computes the minimum number of bit changes required to convert one integer to another, which will help the engineer validate the integrity of the data. **Task**: Write a function `count_flips_to_convert(a: int, b: int) -> int` that receives two non-negative integers `a` and `b`, calculates and returns the minimal number of bit flips needed to convert `a` to `b`. **Constraints**: * `a` and `b` are non-negative integers (0 <= a, b <= 10^9). **Input**: * Two integers `a` and `b`. **Output**: * An integer representing the minimal number of bits that need to be flipped to convert `a` to `b`. **Example**: ```python # Example 1 a = 29 b = 15 # Explanation: # 29 in binary is 11101, 15 in binary is 01111. # Comparing both, positions: 0, 1, 2 have the same bit values, while positions: 3 and 4 are different. Hence, the output should be 2. assert count_flips_to_convert(a, b) == 2 # Example 2 a = 1 b = 4 # Explanation: # 1 in binary is 00001, 4 in binary is 00100. # These values differ in their 1st and 3rd bit positions. Hence, the output should be 2. assert count_flips_to_convert(a, b) == 2 ``` **Function Signature**: ```python def count_flips_to_convert(a: int, b: int) -> int: pass ``` Your task is to implement the function `count_flips_to_convert` based on the described requirements above.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Computes the minimum number of bits that need to be flipped to convert integer a to integer b. # XOR operation between a and b will give a number where # all differing bits between a and b are set to 1. xor_result = a ^ b # Count the number of 1s in the binary representation of xor_result # which represents the number of differing bits. return bin(xor_result).count(\'1\')"},{"question":"You are given a stack of integers, and your task is to write a function `stutter` which modifies the stack such that each element appears twice consecutively, preserving the original order. Given two distinct approaches using auxiliary data structures, you are to implement your solution twice: 1. Using an auxiliary stack. 2. Using an auxiliary queue. Your goal is to understand the core mechanism of using auxiliary data structures and handle potential edge cases efficiently. # Requirements 1. `stutter_using_stack(stack: list) -> list` - The stack must be modified using an auxiliary stack as described. 2. `stutter_using_queue(stack: list) -> list` - The stack must be modified using an auxiliary queue (using the collections.deque module). # Input Format * A stack of integers represented as a list where the end of the list represents the top of the stack. * Example: `[3, 7, 1, 14, 9]` representing bottom [3, 7, 1, 14, 9] top. # Output Format * The modified stack with every element duplicated. * Example: Input: `[3, 7, 1, 14, 9]` should output `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]`. # Constraints * The stack should contain a maximum of `1000` integers. * Integer values can be in the range of `-10^6` to `10^6`. # Example ```python # Example usage: stack = [3, 7, 1, 14, 9] # Using auxiliary stack print(stutter_using_stack(stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] # Using auxiliary queue print(stutter_using_queue(stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Notes * Both `stutter_using_stack` and `stutter_using_queue` should modify the stack in-place and return the modified stack. * Pay close attention to edge cases such as empty stacks and single-element stacks.","solution":"def stutter_using_stack(stack): Modifies the stack such that each element appears twice consecutively using an auxiliary stack. Args: stack (list): The input stack. Returns: list: The modified stack. aux_stack = [] # Transfer elements from original stack to auxiliary stack while stack: aux_stack.append(stack.pop()) # Transfer elements back to original stack with duplication while aux_stack: element = aux_stack.pop() stack.append(element) stack.append(element) return stack from collections import deque def stutter_using_queue(stack): Modifies the stack such that each element appears twice consecutively using an auxiliary queue. Args: stack (list): The input stack. Returns: list: The modified stack. # Use deque as an auxiliary queue queue = deque() # Transfer elements from stack to queue while stack: queue.append(stack.pop()) # Transfer elements back to stack with duplication while queue: element = queue.popleft() stack.append(element) stack.append(element) # Reverse the stack to restore original order with duplications stack.reverse() return stack"},{"question":"Given a stack, write a function `reverse_stack` that reverses the elements of the stack in place without using any extra space apart from the function call stack. The reversed stack should have the elements in reverse order from the original. For example: ``` Original Stack (bottom -> top): [3, 2, 1] Reversed Stack (bottom -> top): [1, 2, 3] ``` # Requirements * You are not allowed to use any additional data structures like lists, queues, or dictionaries to store elements temporarily. * Your function should modify the input stack directly. * The solution should be efficient in terms of time complexity. # Input and Output * **Input Format**: The stack is provided as a list where the end of the list represents the top of the stack. * **Output Format**: Modify the input list in place to reflect the reversed stack. # Constraints * The stack will have a maximum of (10^4) elements. * Elements of the stack are integers within the range ([-10^9, 10^9]). # Performance Requirements * The solution should have a time complexity of O(n), where n is the number of elements in the stack. # Function Signature ```python def reverse_stack(stack): pass ``` # Examples Example 1: * **Input**: `[1, 2, 3]` * **Output**: The input list should be modified to `[3, 2, 1]`. Example 2: * **Input**: `[10, 7, 4, 3]` * **Output**: The input list should be modified to `[3, 4, 7, 10]`. Example 3: * **Input**: `[]` * **Output**: The input list should remain as `[]`. # Hints * Consider using recursion to help temporarily hold values while reversing the stack. # Notes * You can utilize the stack nature (LIFO) within the function\'s call stack to achieve the solution.","solution":"def reverse_stack(stack): Reverses the elements of the stack in place. # Helper function to insert an element at the bottom of the stack def insert_at_bottom(stack, item): if not stack: stack.append(item) else: temp = stack.pop() insert_at_bottom(stack, item) stack.append(temp) # Main function to reverse the stack using recursion def reverse(stack): if stack: temp = stack.pop() reverse(stack) insert_at_bottom(stack, temp) reverse(stack)"},{"question":"# Knapsack Problem with Constraints **Challenge:** Given a list of items where each item has a value and weight, and a knapsack with a maximum weight capacity, implement a function to calculate the maximum value of items that the knapsack can carry without exceeding the weight capacity. The function should only be provided with the weights and values of the items. Use dynamic programming to solve this problem. # Function Signature ```python def knapsack_max_value(values: List[int], weights: List[int], capacity: int) -> int: pass ``` # Input - `values` (List[int]): A list of integers representing the values of the items. - `weights` (List[int]): A list of integers representing the weights of the items. The length of `weights` is the same as that of `values`. - `capacity` (int): An integer representing the maximum weight capacity of the knapsack. # Output - Returns an integer representing the maximum value of items that can be carried in the knapsack without exceeding its capacity. # Constraints - `1 <= len(values) == len(weights) <= 1000` - `1 <= weights[i] <= 1000` - `0 <= values[i] <= 1000` - `0 <= capacity <= 1000` # Example ```python assert knapsack_max_value([60, 50, 70, 30], [5, 3, 4, 2], 5) == 80 # Items with values 50 and 30 assert knapsack_max_value([1, 2, 3], [4, 5, 1], 4) == 3 # Items with values 3 assert knapsack_max_value([100], [1000], 0) == 0 # No items can be taken as capacity is 0 assert knapsack_max_value([100, 200], [1, 2], 1) == 100 # Only item with value 100 can be taken ``` # Notes - Think about edge cases, such as when the capacity is 0 or no items are provided. - Consider performance, as the inputs can reach up to 1000 items and capacity can also be as large as 1000.","solution":"from typing import List def knapsack_max_value(values: List[int], weights: List[int], capacity: int) -> int: n = len(values) dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"# Binary Search Tree Implementation and Statistics A Binary Search Tree (BST) is a fundamental data structure providing support for dynamically ordered data, allowing efficient searches, insertions, and deletions. The tree\'s property ensures that, for any node, all elements in its left subtree are less than it, and all elements in its right subtree are greater than it. You are required to extend the `BST` class with additional functionality to gather and compute various statistics about the tree structure. Your implementation should include: 1. **Height of the Tree**: Write a method `height` that computes the height (or depth) of the tree. The height of a tree is the length of the longest path from the root to a leaf. 2. **Count of Leaf Nodes**: Write a method `count_leaves` to count the number of leaf nodes in the tree. A leaf is a node with no children. 3. **Count of Internal Nodes**: Write a method `count_internal_nodes` to count the number of internal nodes in the tree. An internal node has at least one child. 4. **Balanced Check**: Write a method `is_balanced` that checks whether the tree is height-balanced. A binary tree is balanced if, for every node, the heights of the left and right subtrees differ by at most 1. # Function Specifications - `height(self) -> int` - `count_leaves(self) -> int` - `count_internal_nodes(self) -> int` - `is_balanced(self) -> bool` # Constraints - Each method should recursively traverse the tree. - The `height` and `is_balanced` methods can be designed to work with additional helper functions as needed. - Assume integer values are inserted into the tree, and it contains no duplicate values. # Examples Given the following binary search tree: ``` 10 / 6 15 / / 4 9 12 24 / / 7 20 30 / 18 ``` For this tree: - `height` should return 4. - `count_leaves` should return 5. - `count_internal_nodes` should return 6. - `is_balanced` should return False.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert_recursive(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert_recursive(root.right, key) def height(self): return self._height_recursive(self.root) def _height_recursive(self, node): if node is None: return -1 else: left_height = self._height_recursive(node.left) right_height = self._height_recursive(node.right) return max(left_height, right_height) + 1 def count_leaves(self): return self._count_leaves_recursive(self.root) def _count_leaves_recursive(self, node): if node is None: return 0 if node.left is None and node.right is None: return 1 else: return self._count_leaves_recursive(node.left) + self._count_leaves_recursive(node.right) def count_internal_nodes(self): return self._count_internal_nodes_recursive(self.root) def _count_internal_nodes_recursive(self, node): if node is None or (node.left is None and node.right is None): return 0 return 1 + self._count_internal_nodes_recursive(node.left) + self._count_internal_nodes_recursive(node.right) def is_balanced(self): return self._is_balanced_recursive(self.root) def _is_balanced_recursive(self, node): if node is None: return True left_height = self._height_recursive(node.left) right_height = self._height_recursive(node.right) if abs(left_height - right_height) > 1: return False return self._is_balanced_recursive(node.left) and self._is_balanced_recursive(node.right)"},{"question":"# Problem: Implement In-Place Merge Sort The provided `merge_sort` function sorts an array using the Merge Sort algorithm. However, it uses additional memory which increases space complexity. Your task is to implement an in-place merge sort to reduce the space complexity. **Function Signature:** ```python def in_place_merge_sort(arr: list) -> list: ``` # Input * A list of integers `arr` with length `n` (0 <= n <= 10^6). # Output * A sorted list of integers in non-decreasing order. # Constraints * You must implement an in-place version of the merge sort. That is, your code should not use any additional or temporary arrays apart from the input array for sorting. * You need to ensure that the algorithm maintains a time complexity of O(n log n). # Example ```python # Example 1 input_arr = [38, 27, 43, 3, 9, 82, 10] output_arr = in_place_merge_sort(input_arr) print(output_arr) # Output: [3, 9, 10, 27, 38, 43, 82] # Example 2 input_arr = [] output_arr = in_place_merge_sort(input_arr) print(output_arr) # Output: [] # Example 3 input_arr = [1] output_arr = in_place_merge_sort(input_arr) print(output_arr) # Output: [1] ``` # Notes * You need to handle edge cases such as empty arrays and arrays with one element. * Ensure your implementation is efficient in terms of both time and space to handle the upper limits of input size.","solution":"def in_place_merge(arr, start, mid, end): if arr[mid] <= arr[mid + 1]: # If the halves are already sorted return l, r = start, mid + 1 while l <= mid and r <= end: if arr[l] <= arr[r]: l += 1 # l is already in correct place else: temp = arr[r] arr[l+1:r+1] = arr[l:r] # Shift elements to the right arr[l] = temp # Update pointers mid += 1 l += 1 r += 1 def in_place_merge_sort(arr): def _merge_sort(arr, start, end): if start >= end: return mid = (start + end) // 2 _merge_sort(arr, start, mid) _merge_sort(arr, mid + 1, end) in_place_merge(arr, start, mid, end) _merge_sort(arr, 0, len(arr) - 1) return arr"},{"question":"Context You are a maze architect responsible for designing and managing complex mazes for puzzles and games. Recently, you encountered a scenario where parts of a maze represent various rooms separated by walls, and you need to determine the shortest path from gates to each room. Problem Statement You are given an `m x n` 2D grid initialized with the following possible values: - `-1`: A wall or an obstacle. - `0`: A gate. - `INF`: Infinity, an empty room. Use the value 2^31 - 1 = 2147483647 to represent `INF`. Write a function `walls_and_gates(grid)` that fills each empty room with the distance to its nearest gate. If it is impossible to reach a gate, the room should remain as `INF`. # Function Signature: ```python def walls_and_gates(grid: List[List[int]]) -> None: # write your code here ``` # Input: - A 2D list `grid` with dimensions `m x n`. # Output: - The function should **modify the grid in place**. It does not return anything. # Constraints: - `1 <= m, n <= 100` - Grid values are integer and can be `-1`, `0`, or `INF`. # Example: Input: ``` [ [INF, -1, 0, INF], [INF, INF, INF, -1], [INF, -1, INF, -1], [0, -1, INF, INF] ] ``` Output: ``` [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] ``` Requirements: 1. Handle edge cases like grids with no gates or completely filled with walls. 2. Ensure efficiency in terms of time and space complexity, avoiding excessive recursion depth. 3. Consider using alternative approaches or optimization strategies, like BFS instead of DFS if necessary. Notes: - You may use the `collections.deque` for implementing BFS. - Plan your code to prevent revisiting cells unnecessarily and handle edge cases properly. Good luck and happy coding!","solution":"from collections import deque from typing import List def walls_and_gates(grid: List[List[int]]) -> None: if not grid or not grid[0]: return m, n = len(grid), len(grid[0]) INF = 2147483647 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque() # Initialize queue with all gates for i in range(m): for j in range(n): if grid[i][j] == 0: queue.append((i, j)) # Perform BFS from all gates while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == INF: grid[nx][ny] = grid[x][y] + 1 queue.append((nx, ny))"},{"question":"# Scenario You are given an array containing arbitrary order of colors represented by integers: red (0), white (1), and blue (2). You need to sort the array such that all instances of the same color are adjacent and the colors are in the order red, white and blue. Use an in-place sorting algorithm without using any predefined sorting functions. # Problem Statement Write a function named `sort_colors` that takes a list of integers representing colors and sorts them in-place. Function Signature ```python def sort_colors(nums: List[int]) -> None: :param nums: List[int] - A list where each element is either 0, 1, or 2 :return: None - The list should be sorted in-place ``` # Input * An unsorted list of integers `nums` where each element is from the set {0, 1, 2}. * The length of the list is between 0 and 10^5. # Output * The function does not return any value, but the input list `nums` should be sorted in-place. # Examples ```python nums = [0, 1, 1, 1, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 2, 2] sort_colors(nums) print(nums) # Output: [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2] nums = [2, 0, 1] sort_colors(nums) print(nums) # Output: [0, 1, 2] nums = [1, 2, 0] sort_colors(nums) print(nums) # Output: [0, 1, 2] ``` # Constraints * Do not use any built-in sort function like `sort()` or `sorted()`. * The algorithm should work efficiently for large lists, aiming for O(n) time complexity and O(1) space complexity.","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Sorts a list in-place such that all instances of the same color are adjacent, with the colors in the order red (0), white (1), and blue (2). left, current, right = 0, 0, len(nums) - 1 while current <= right: if nums[current] == 0: nums[left], nums[current] = nums[current], nums[left] left += 1 current += 1 elif nums[current] == 1: current += 1 else: nums[right], nums[current] = nums[current], nums[right] right -= 1"},{"question":"Context: You are working on a software project that processes and analyzes large volumes of data stored in sorted arrays. One of the critical functionalities required is to determine the position of the last occurrence of a specific value in these arrays efficiently. Problem Statement: Write a Python function, `find_last_occurrence`, which takes in two parameters: 1. A list of integers `array`, sorted in increasing order. 2. An integer `query` representing the value whose last occurrence needs to be found. The function should return the index of the last occurrence of `query` in `array`. If `query` is not found in `array`, return `-1`. Input Format: - `array`: A list of integers sorted in increasing order. - `query`: An integer value to find in the array. Output Format: - An integer representing the index of the last occurrence of `query` in `array`. Return `-1` if `query` is not in `array`. Constraints: - The length of `array` will be in the range [1, 10^6]. - The elements of `array` will be integers in the range [-10^9, 10^9]. - The `query` value will be an integer in the range [-10^9, 10^9]. Example: ```python array = [1, 2, 2, 2, 3, 4, 5] query = 2 print(find_last_occurrence(array, query)) # Output: 3 array = [1, 2, 3, 4, 5] query = 6 print(find_last_occurrence(array, query)) # Output: -1 array = [1, 2, 2, 3, 3, 3, 4] query = 3 print(find_last_occurrence(array, query)) # Output: 5 ``` Performance Requirements: The solution should have a time complexity of O(log n) and a space complexity of O(1). Function Signature: ```python def find_last_occurrence(array: List[int], query: int) -> int: pass ``` # Additional Notes: - Make sure to handle edge cases such as empty arrays, arrays with one element, and arrays where the `query` does not exist. - Think about the potential off-by-one errors that may occur with index computations.","solution":"from typing import List def find_last_occurrence(array: List[int], query: int) -> int: Finds the index of the last occurrence of a given query in a sorted list. Parameters: array (List[int]): A list of integers sorted in increasing order. query (int): The integer value to find in the array. Returns: int: The index of the last occurrence of query in array, or -1 if query is not found. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: result = mid left = mid + 1 # Continue searching to the right elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"**Title**: Implement Optimal Array Rotation **Problem Statement**: You are given an array `nums` with `n` elements and an integer `k`. Write a function `optimal_rotate(nums: List[int], k: int) -> List[int]` to rotate the array to the right by `k` steps. Constraints: * Do not allocate extra space for another array; you must modify the input array in-place with O(1) extra memory. * Aim for O(n) time complexity. # Example: ```python # Example 1: Input: nums = [1, 2, 3, 4, 5, 6, 7], k = 3 Output: [5, 6, 7, 1, 2, 3, 4] # Example 2: Input: nums = [-1, -100, 3, 99], k = 2 Output: [3, 99, -1, -100] ``` # Function Signature: ```python def optimal_rotate(nums: List[int], k: int) -> List[int]: # Your code here ``` # Guidance: 1. Use the most efficient in-place algorithms covered in class to achieve the desired rotation. 2. Think about how you can leverage reversing or other one-pass techniques to accomplish the task within the given constraints. 3. Consider edge cases and make sure your code handles them correctly: * Arrays with length 0 or 1 * `k` values of 0 or multiples of the array length 4. Validate your implementation with provided examples and additional test cases.","solution":"from typing import List def optimal_rotate(nums: List[int], k: int) -> List[int]: Rotates the array to the right by k steps, where k is non-negative. Modifies the input list in-place. n = len(nums) if n == 0 or k % n == 0: return nums k = k % n # Helper function to reverse a portion of the list def reverse(start: int, end: int): while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 # Reverse the entire array reverse(0, n-1) # Reverse the first k elements reverse(0, k-1) # Reverse the rest n-k elements reverse(k, n-1) return nums"},{"question":"# Segment Tree Range Queries You are given an array `arr` of integers. Implement a Segment Tree class to efficiently perform range queries using a provided binary function. Your task is to modify the provided `SegmentTree` class by adding a method to update the value at a specific index. The update function should change the value at a given index and ensure the segment tree reflects this change for subsequent queries. # Class Signature ```python class SegmentTree: def __init__(self, arr, function): pass def query(self, L, R): pass def update(self, idx, value): pass ``` # Method Descriptions 1. **`__init__(self, arr, function)`**: - **Parameters**: - `arr`: List of integers. - `function`: A binary function (e.g., `max`, `sum`) to combine segment results. - **Description**: Initializes the segment tree with the given array and function. 2. **`query(self, L, R)`**: - **Parameters**: - `L`: Starting index of the query range (inclusive). - `R`: Ending index of the query range (inclusive). - **Returns**: Result of the range query in the array, based on the provided function. 3. **`update(self, idx, value)`**: - **Parameters**: - `idx`: Index in the array to update. - `value`: New value to set at the specified index. - **Description**: Updates the value at index `idx` and updates the segment tree accordingly. # Example ```python # Using the Segment Tree to find the maximum value in a range arr = [2, 4, 5, 3, 4] mytree = SegmentTree(arr, max) assert mytree.query(2, 4) == 5 assert mytree.query(0, 3) == 5 # Update the value at index 3 to 6 mytree.update(3, 6) assert mytree.query(2, 4) == 6 assert mytree.query(0, 3) == 6 # Using the Segment Tree to find the sum in a range arr2 = [4, 5, 2, 3, 4, 43, 3] sumtree = SegmentTree(arr2, sum) assert sumtree.query(1, 3) == 10 assert sumtree.query(1, 5) == 57 # Update the value at index 2 to 10 sumtree.update(2, 10) assert sumtree.query(1, 3) == 18 ``` # Constraints - The length of the array `arr` will be between 1 and 10^5. - Elements of `arr` will be integers between -10^4 and 10^4. - Queries and updates are many (up to 10^4). Implement the Segment Tree with the capability to handle the above constraints efficiently.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.func = function self.tree = [0] * (2 * self.n) # Build the segment tree self.build(arr) def build(self, arr): # Initializing leaves of the tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Building the tree in a bottom up manner for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, L, R): # Range query from L to R (inclusive) L += self.n R += self.n + 1 # To make range inclusive res = None while L < R: if L % 2: if res is None: res = self.tree[L] else: res = self.func(res, self.tree[L]) L += 1 if R % 2: R -= 1 if res is None: res = self.tree[R] else: res = self.func(res, self.tree[R]) L //= 2 R //= 2 return res def update(self, idx, value): # Update value at index idx idx += self.n self.tree[idx] = value # Move upwards and update parents while idx > 1: idx //= 2 self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])"},{"question":"You are given a task to calculate the number of ways in which you can choose r items from a set of n distinct items (denoted as nCr or C(n, r)). Your task is to implement two functions: `combination` and `combination_memo` based on the provided descriptions below. # Function Requirements 1. **Function Name**: `combination` - **Input**: - `n` (integer): number of items. - `r` (integer): number of items to choose. - **Output**: - Return an integer representing the binomial coefficient (nCr). 2. **Function Name**: `combination_memo` - **Input**: - `n` (integer): number of items. - `r` (integer): number of items to choose. - **Output**: - Return an integer representing the binomial coefficient (nCr). # Constraints - ( 0 leq r leq n leq 30 ) - The functions must correctly handle edge cases such as ( n = r ) and ( r = 0 ). # Performance Requirement - The `combination_memo` function must utilize memoization to improve performance and avoid redundant calculations. # Example ```python print(combination(5, 2)) # Output: 10 print(combination_memo(5, 2)) # Output: 10 print(combination(6, 3)) # Output: 20 print(combination_memo(6, 3)) # Output: 20 ``` # Note - Ensure that your `combination` function implements a direct recursive solution. - Your `combination_memo` function should implement memoization to optimize performance.","solution":"def combination(n, r): Calculate the combination C(n, r) using a recursive approach. if r == 0 or r == n: return 1 return combination(n - 1, r - 1) + combination(n - 1, r) def combination_memo(n, r, memo=None): Calculate the combination C(n, r) using a memoized recursive approach. if memo is None: memo = {} if r == 0 or r == n: return 1 if (n, r) in memo: return memo[(n, r)] memo[(n, r)] = combination_memo(n - 1, r - 1, memo) + combination_memo(n - 1, r, memo) return memo[(n, r)]"},{"question":"You are provided with a `DirectedGraph` class that models a directed graph using an adjacency list. Your task is to implement a function that detects if there is a cycle in the directed graph. # Function Signature ```python def has_cycle(graph: DirectedGraph) -> bool: Determine if the directed graph contains any cycles. Args: graph (DirectedGraph): The directed graph instance to check for cycles. Returns: bool: True if there is at least one cycle in the graph, False otherwise. ``` # Expected Behavior 1. **Input**: A `DirectedGraph` instance with loaded nodes and edges. 2. **Output**: Boolean value. `True` if there is a cycle in the directed graph, `False` otherwise. # Constraints - Graph may contain up to 1000 nodes. - Graph may contain up to 10000 edges. - Graph nodes are uniquely named with non-empty strings. # Example ```python # Creating a graph with cycle graph_data = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"], # Cycle: A -> B -> C -> A } graph = DirectedGraph(graph_data) print(has_cycle(graph)) # Output: True # Creating a graph without cycle graph_data_no_cycle = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [], } graph_no_cycle = DirectedGraph(graph_data_no_cycle) print(has_cycle(graph_no_cycle)) # Output: False ``` # Considerations 1. You need to use Depth-First Search (DFS) algorithm to detect cycles. 2. Handle the case of disconnected components in the graph. 3. Ensure the algorithm efficiently handles the provided constraints of nodes and edges. # Note The `DirectedGraph` class and associated classes `Node` and `DirectedEdge` are defined and provided as part of the environment. You don\'t need to implement these classes, only utilize them within your solution to `has_cycle`.","solution":"def has_cycle(graph): Determine if the directed graph contains any cycles. Args: graph (DirectedGraph): The directed graph instance to check for cycles. Returns: bool: True if there is at least one cycle in the graph, False otherwise. visited = set() rec_stack = set() def dfs(vertex): if vertex not in visited: visited.add(vertex) rec_stack.add(vertex) for neighbor in graph.adjacency_list[vertex]: if neighbor not in visited: if dfs(neighbor): return True elif neighbor in rec_stack: return True rec_stack.remove(vertex) return False for node in graph.adjacency_list: if dfs(node): return True return False"},{"question":"# Context You are tasked with ensuring that two given strings are anagrams of each other for a word game. An anagram is a word or phrase that can be rearranged to form another word or phrase using all the original letters exactly once. Given the constraints of the game, the strings are guaranteed to be in lowercase and consist only of alphabetic characters from \'a\' to \'z\'. # Objective Write a function: ```python def check_anagram(s1: str, s2: str) -> bool: ``` # Input - `s1`: A string (1 ≤ |s1| ≤ 1000) consisting of lowercase alphabetic characters. - `s2`: A string (1 ≤ |s2| ≤ 1000) consisting of lowercase alphabetic characters. # Output - Return `True` if `s1` and `s2` are anagrams of each other, otherwise return `False`. # Example ```python assert check_anagram(\\"listen\\", \\"silent\\") == True assert check_anagram(\\"triangle\\", \\"integral\\") == True assert check_anagram(\\"apple\\", \\"pale\\") == False assert check_anagram(\\"actors\\", \\"costar\\") == True ``` # Constraints - The function should handle edge cases where lengths of `s1` and `s2` are not equal. - Ensure the solution performs efficiently within the given input size constraints.","solution":"def check_anagram(s1: str, s2: str) -> bool: Check if two strings are anagrams of each other. :param s1: The first string :param s2: The second string :return: True if s1 and s2 are anagrams, False otherwise # Anagrams must be of the same length if len(s1) != len(s2): return False # Count frequency of each character in both strings from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"# Question: Efficient Exponentiation for Large Numbers **Background**: You are working on a cryptography project that requires efficient computation of large powers, often with a modular operation to keep the numbers from growing too large. **Task**: Implement a function that computes the power of a given base raised to an exponent using binary exponentiation. Your solution should handle large numbers efficiently and support an optional modulo operation. **Function Signature**: ```python def efficient_power(base: int, exponent: int, mod: int = None) -> int: pass ``` **Input**: - `base` (integer): The base number which will be raised. - `exponent` (integer): The exponent to which the base number will be raised. - `mod` (integer, optional): An optional modulus. If provided, the result should be returned modulo this value. Defaults to `None`. **Output**: - Returns an integer which is the result of ( text{base}^text{exponent} ). If `mod` is provided, returns the result modulo `mod`. **Constraints**: - `0 <= base <= 10^9`. - `0 <= exponent <= 10^9`. - If `mod` is provided, `1 <= mod <= 10^9`. **Examples**: 1. `efficient_power(2, 10)` should return `1024`. 2. `efficient_power(2, 10, 1000)` should return `24`. 3. `efficient_power(3, 5, 27)` should return `0`. **Notes**: - Consider edge cases such as when `exponent` is 0 or 1. - Ensure the function efficiently handles very large inputs. - Think about whether the iterative or recursive approach would be more suitable for different scenarios.","solution":"def efficient_power(base: int, exponent: int, mod: int = None) -> int: Computes base raised to the power of exponent using binary exponentiation. If mod is provided, returns (base^exponent) % mod. if exponent == 0: return 1 if mod is None else 1 % mod result = 1 base = base if mod is None else base % mod while exponent > 0: if exponent % 2 == 1: result = result * base if mod is None else (result * base) % mod base = base * base if mod is None else (base * base) % mod exponent //= 2 return result"},{"question":"# Problem Description You are tasked with implementing a system to track the cumulative frequency of elements in a dynamic array. Specifically, you need to create a data structure allowing efficient prefix sum queries (i.e., sum of elements from the start up to a given index) and point updates (i.e., updating the value at a specific index). # Requirements 1. **Initialization**: Initialize the data structure with a given list of integers. 2. **Update**: Implement a method to update the value at a specific index. 3. **Query**: Implement a method to get the sum of elements from the start up to a given index. # Constraints * The input list will have a maximum length of (10^5). * Each element in the input list will be an integer between ([-10^4, 10^4]). * The number of update and query operations combined will not exceed (10^5). * Updates are only for single points, and queries are for prefix sums. # Input and Output * **Input**: * Initially, a list of integers. * Several updates and queries formatted as follows: * Updates: `(\\"update\\", index, value)` where `index` is the position to update and `value` is the new value. * Queries: `(\\"query\\", index)` where `index` is the position up to which the sum is needed. * **Output**: * For each query, return the sum of the elements from the start to the given index. # Example ```python # Sample Input freq = [1, 2, 3, 4, 5] instructions = [ (\\"update\\", 1, 3), (\\"query\\", 3), (\\"update\\", 4, 10), (\\"query\\", 4) ] # Sample Output # After first update: freq = [1, 3, 3, 4, 5] # After the first query: return 11 (1+3+3+4) # After second update: freq = [1, 3, 3, 4, 10] # After the second query: return 21 (1+3+3+4+10) ``` # Implementation You need to implement the `FenwickTree` class with the following methods: 1. `__init__(self, freq: List[int])` - Initialize the tree with the given list. 2. `update(self, index: int, value: int)` - Update the element at the specified index to the new value. 3. `query(self, index: int) -> int` - Return the prefix sum up to the specified index. Implement the solution keeping performance concerns in mind to handle large inputs efficiently.","solution":"class FenwickTree: def __init__(self, freq): Initialize the Fenwick Tree with the given list of frequencies. self.n = len(freq) self.tree = [0] * (self.n + 1) self.freq = freq[:] for i in range(self.n): self._add(i, self.freq[i]) def _add(self, index, value): Helper function to add value to the Fenwick Tree at the given index. index += 1 while index <= self.n: self.tree[index] += value index += index & -index def update(self, index, value): Update the element at index to the new value. delta = value - self.freq[index] self.freq[index] = value self._add(index, delta) def query(self, index): Return the prefix sum up to the given index. sum = 0 index += 1 while index > 0: sum += self.tree[index] index -= index & -index return sum"},{"question":"You are required to implement an encoding and decoding algorithm for a list of strings such that the encoded format can reliably be decoded back to its original format. This data encoding technique involves representing each string with its length followed by the actual string, separated by a colon. Functions to Implement 1. **encode(strs: List[str]) -> str**: - **Input**: A list of strings `strs`. - **Output**: A single encoded string. 2. **decode(encoded_str: str) -> List[str]**: - **Input**: The encoded string that represents the list of strings. - **Output**: The original list of strings decoded from the encoded string. # Constraints * The strings can contain any characters, including spaces and colons. * The lengths of strings do not exceed 1000. * The total number of strings will not exceed 1000. # Example ```python strs = [\\"hello\\", \\"world\\"] encoded_str = encode(strs) # encoded_str should be \\"5:hello5:world\\" decoded_strs = decode(encoded_str) # decoded_strs should be [\\"hello\\", \\"world\\"] ``` # Requirements - Your solution should handle edge cases such as empty strings or the presence of special characters. - Aim to achieve efficiency in both time and space complexity. - Ensure the correctness and reliability of your encode and decode functions.","solution":"def encode(strs): Encodes a list of strings to a single string. Args: strs (List[str]): List of strings to encode. Returns: str: Encoded single string. encoded_str = \\"\\" for s in strs: encoded_str += str(len(s)) + \\":\\" + s return encoded_str def decode(encoded_str): Decodes a single string to a list of strings. Args: encoded_str (str): Encoded single string. Returns: List[str]: Decoded list of strings. i = 0 decoded_strs = [] while i < len(encoded_str): # Find the separator \':\' to extract length of the next string j = i while encoded_str[j] != \':\': j += 1 length = int(encoded_str[i:j]) # Extract the string using the extracted length decoded_strs.append(encoded_str[j+1:j+1+length]) # Move the index to the next segment i = j + 1 + length return decoded_strs"},{"question":"Single Non-duplicate Number Context: You are given an array of integers, where every element appears exactly twice, except for one element which appears only once. Your task is to identify and return the element that appears only once. You should implement an efficient solution with a linear runtime complexity and constant space complexity. Problem Statement: Write a function `find_unique_number` that takes a list of integers and returns the integer that appears only once. Function Signature: ```python def find_unique_number(nums: List[int]) -> int: ``` Inputs: * `nums`: A list of integers (`List[int]`). Constraints: * The list will have a minimum length of 1. * Each element in the list can be an integer within the 32-bit signed integer range. * All integers appear exactly twice except for one integer, which appears only once. Output: * The function should return the single integer that appears once. Examples: 1. Input: `[2, 2, 1]` Output: `1` 2. Input: `[4, 1, 2, 1, 2]` Output: `4` 3. Input: `[1]` Output: `1` Additional Notes: * The solution should run in O(n) time. * The solution should use O(1) additional space. Example Explanation: In the first example, the integer `2` appears twice and `1` appears only once, so the output is `1`. Similarly, in the second example, `4` appears only once while the other numbers appear twice, so the output is `4`.","solution":"from typing import List def find_unique_number(nums: List[int]) -> int: Returns the integer that appears only once in the list. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Question: Implement the BTree `find_minimum` and `find_maximum` Operations A B-tree is a balanced tree data structure where each node can contain multiple keys and has more than two children. This structure is especially useful in scenarios where maintaining a balanced search tree ensures efficient insertion, deletion, and search operations. In this coding assignment, you are required to implement two additional utility functions for the `BTree` class: `find_minimum()` and `find_maximum()`. These functions should find and return the minimum and maximum keys stored in the B-tree, respectively. # Detailed Requirements 1. **Function Names**: Implement the functions `find_minimum()` and `find_maximum()`. 2. **Class Context**: These functions should be part of the `BTree` class. 3. **Expected Behavior**: - **find_minimum()**: - Should return the smallest key in the B-tree. - Traverse to the leftmost child to find the smallest key. - **find_maximum()**: - Should return the largest key in the B-tree. - Traverse to the rightmost child to find the largest key. # Input - No external input. # Output - For `find_minimum()`, output should be the smallest key. - For `find_maximum()`, output should be the largest key. # Example For a B-tree constructed with keys [10, 20, 5, 6, 12, 30, 7, 17]: - `find_minimum()` should return `5`. - `find_maximum()` should return `30`. # Constraints - Assume the B-tree is non-empty when these functions are called. - Ensure your functions have O(log n) time complexity where n is the number of elements in the tree. # Code Context ```python class BTree: # Existing BTree implementation ... def find_minimum(self): # Your implementation here def find_maximum(self): # Your implementation here ```","solution":"class BTreeNode: def __init__(self, leaf=False): self.keys = [] # list of keys in the node self.children = [] # list of children nodes self.leaf = leaf # True if node is a leaf, False otherwise class BTree: def __init__(self, t): self.root = BTreeNode(True) self.t = t # Minimum degree (defines the range for the number of keys) def find_minimum(self): current_node = self.root # Keep traversing the leftmost child until leaf node is reached while not current_node.leaf: current_node = current_node.children[0] # Minimum key will be the first key in the leaf node return current_node.keys[0] def find_maximum(self): current_node = self.root # Keep traversing the rightmost child until leaf node is reached while not current_node.leaf: current_node = current_node.children[-1] # Maximum key will be the last key in the leaf node return current_node.keys[-1]"},{"question":"# Maximum Flow Problem: Augmenting Paths Analysis Given a directed graph in the form of a capacity matrix, your task is to implement an algorithm to compute the maximum flow from a source vertex to a sink vertex using the Ford-Fulkerson method with Depth-First Search (DFS). Input - `capacity`: A 2D list where `capacity[i][j]` represents the capacity of the edge from vertex `i` to vertex `j`. If there is no edge between `i` and `j`, `capacity[i][j]` is zero. - `source`: An integer representing the source vertex. - `sink`: An integer representing the sink vertex. Output - An integer representing the maximum flow value from the source to the sink. Constraints - The capacity matrix will be of size `V x V`, where `V` is the number of vertices and `1 <= V <= 500`. - `0 <= capacity[i][j] <= 1000` - `0 <= source, sink < V` - There will be at least one path from `source` to `sink`. Example ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 print(max_flow(capacity, source, sink)) # Output: 23 ``` Function Signature ```python def max_flow(capacity: List[List[int]], source: int, sink: int) -> int: pass ``` Constraints and Requirements - You are required to use DFS as the basis for finding augmenting paths. - Clearly explain the visit marking process and flow updating mechanism. - Ensure your solution handles typical edge cases effectively.","solution":"def max_flow(capacity, source, sink): Returns the maximum flow from source to sink in the given graph using Ford-Fulkerson method with DFS. V = len(capacity) flow = [[0] * V for _ in range(V)] parent = [-1] * V def dfs(source, sink, visited): stack = [source] parent[source] = -1 visited[source] = True while stack: u = stack.pop() for v in range(V): if not visited[v] and capacity[u][v] - flow[u][v] > 0: stack.append(v) visited[v] = True parent[v] = u if v == sink: return True return False max_flow = 0 while True: visited = [False] * V if not dfs(source, sink, visited): break path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s] - flow[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] flow[u][v] += path_flow flow[v][u] -= path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"KMP-based Pattern Search with Modifications You are given two sequences: a text and a pattern. Your task is to implement a modified version of the Knuth-Morris-Pratt (KMP) algorithm to find both the start and end indices of each occurrence of the pattern in the text. Instead of returning just the start indices, you will return a list of tuples where each tuple contains the start and end indices of the pattern within the text. # Function Signature ```python def kmp_search_with_end_indices(text: Sequence[str], pattern: Sequence[str]) -> List[tuple]: Given two sequences text and pattern, return the list of tuples with start and end indices in the text that match the pattern using a modified KMP algorithm. Args: text: Text to search pattern: Pattern to search in the text Returns: List of tuples (start_index, end_index) of patterns found Example: >>> kmp_search_with_end_indices(\'hello there hero!\', \'he\') [(0, 1), (7, 8), (12, 13)] If (start, end) is in the list, text[start : end + 1] matches with the pattern. Time complexity of the algorithm should be O(N+M), with N and M the length of text and pattern, respectively. pass ``` # Input and Output - **Input**: - `text`: A sequence of characters representing the text in which the pattern is to be searched. - `pattern`: A sequence of characters representing the pattern to be searched within the text. - **Output**: - A list of tuples, where each tuple `(start_index, end_index)` indicates the start and end indices of the pattern in the text. # Constraints 1. The length of the text will be between 0 and 10^6 characters. 2. The length of the pattern will be between 0 and 10^4 characters. 3. The text and pattern will consist of ASCII characters only. # Performance Requirements - The solution must run in O(N + M) time, where N is the length of the text and M is the length of the pattern. - The solution must use O(M) additional space for the pi table. # Edge Cases - Both text and pattern are empty. - The text is non-empty, but the pattern is empty. - The text is empty, but the pattern is non-empty. - Repeated patterns in the text. You need to ensure that your code handles these edge cases efficiently and correctly.","solution":"from typing import Sequence, List, Tuple def kmp_search_with_end_indices(text: Sequence[str], pattern: Sequence[str]) -> List[Tuple[int, int]]: Given two sequences text and pattern, return the list of tuples with start and end indices in the text that match the pattern using a modified KMP algorithm. Args: text: Text to search pattern: Pattern to search in the text Returns: List of tuples (start_index, end_index) of patterns found Example: >>> kmp_search_with_end_indices(\'hello there hero!\', \'he\') [(0, 1), (7, 8), (12, 13)] If (start, end) is in the list, text[start : end + 1] matches with the pattern. Time complexity of the algorithm should be O(N+M), with N and M the length of text and pattern, respectively. if not pattern: return [] def compute_lps(pattern: Sequence[str]) -> List[int]: lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append((i - j, i - 1)) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"You are given a list of sorted characters `letters` containing only lowercase letters, and you need to find the smallest element in the list that is larger than a given `target` character. The list of characters is cyclic, meaning if the `target` character is greater than or equal to the largest character in the list, it should wrap around and return the smallest character. Function Signature `def find_next_greatest_letter(letters: List[str], target: str) -> str:` Input - `letters`: A list of sorted characters containing only lowercase letters. `1 <= len(letters) <= 10^4` - `target`: A single lowercase letter. Output - A single character which is the smallest letter in `letters` that is larger than `target`. Constraints - The input list `letters` is non-empty and sorted in ascending order. - The characters in `letters` may wrap around cyclically. Examples ``` find_next_greatest_letter([\\"c\\", \\"f\\", \\"j\\"], \\"a\\") -> \\"c\\" find_next_greatest_letter([\\"c\\", \\"f\\", \\"j\\"], \\"c\\") -> \\"f\\" find_next_greatest_letter([\\"c\\", \\"f\\", \\"j\\"], \\"d\\") -> \\"f\\" find_next_greatest_letter([\\"a\\", \\"b\\"], \\"z\\") -> \\"a\\" ``` # Requirements - Implement the function using binary search technique with optimal time complexity. - Ensure proper handling of edge cases and cyclic nature of the list. Additional Notes - Avoid using the `bisect` library for this implementation. - Emphasize understanding and implementing the binary search logic manually. - Aim for a clear, efficient, and well-documented solution.","solution":"from typing import List def find_next_greatest_letter(letters: List[str], target: str) -> str: Finds the smallest character in the sorted list `letters` that is larger than the given `target`. The list is considered cyclic. Parameters: letters (List[str]): A list of sorted lowercase characters target (str): A single lowercase character Returns: str: The smallest character in `letters` that is larger than `target` left, right = 0, len(letters) - 1 while left <= right: mid = left + (right - left) // 2 if letters[mid] <= target: left = mid + 1 else: right = mid - 1 return letters[left % len(letters)]"},{"question":"# Problem: Reverse a Sublist in a Singly Linked List Context Reversing a linked list is a common problem. To further your understanding, we will modify the problem slightly: reverse only a specific sublist of the linked list. For example, given positions `m` and `n`, reverse the nodes from position `m` to `n`. Task Write a function `reverse_between(head, m, n)` that takes the head of a singly linked list and two integers, `m` and `n`. The function should reverse the nodes of the list from position `m` to `n`. Input and Output - **Input**: - `head`: The head node of a singly linked list. - `m`: An integer representing the start position (1-based). - `n`: An integer representing the end position (1-based). - **Output**: - Returns the head of the modified list after reversing the nodes from `m` to `n`. Constraints - 1 ≤ m ≤ n ≤ length of list. - Performance requirement: Aim for O(n) time complexity. Example ```python # Given the list: 1 -> 2 -> 3 -> 4 -> 5 # m = 2, n = 4 # After reverse: 1 -> 4 -> 3 -> 2 -> 5 head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) head.next.next.next.next = ListNode(5) result_head = reverse_between(head, 2, 4) # result_head should represent the modified list: 1 -> 4 -> 3 -> 2 -> 5 ``` # Notes - You may assume that the input list contains at least one node. - You are not allowed to change the node values; only nodes should be modified.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_between(head, m, n): if not head or m == n: return head dummy = ListNode(0) dummy.next = head prev = dummy # Advance prev to the node just before the reversal starts for _ in range(m - 1): prev = prev.next # Reversal process reverse_prev = prev curr = prev.next prev = None for _ in range(n - m + 1): next_node = curr.next curr.next = prev prev = curr curr = next_node # Connect reversed part with remaining list reverse_prev.next.next = curr reverse_prev.next = prev return dummy.next"},{"question":"Context You are tasked with writing a function to determine the number of structurally unique Binary Search Trees (BSTs) that can be formed using a given number of distinct integers. A Binary Search Tree (BST) is a binary tree where for each node, the value of all the nodes in the left subtree is less, and the value of all the nodes in the right subtree is more. Problem Statement Write a function `num_trees(n)` that accepts an integer `n` and returns the number of structurally unique BSTs that store values from 1 to `n`. Use the dynamic programming approach as analyzed. Input * An integer `n` where `0 <= n <= 100`. Output * An integer representing the number of structurally unique BSTs. Example * **Example 1:** * Input: `n = 3` * Output: `5` * Explanation: There are 5 structurally unique BSTs that can be formed with `n = 3`: ``` 1 3 3 2 1 / / / 3 2 1 1 3 2 / / 2 1 2 3 ``` * **Example 2:** * Input: `n = 1` * Output: `1` * Explanation: There is 1 structurally unique BST that can be formed with `n = 1`: `1`. Constraints * Ensure your solution is efficient and can handle the upper limits of the input size.","solution":"def num_trees(n): Calculate the number of unique BSTs that can be formed with n nodes. Args: n (int): The number of nodes. Returns: int: The number of unique BSTs. # Base case if n == 0 or n == 1: return 1 # Create a list to store the number of unique BSTs for each count of nodes dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 # Initialize base cases # Fill the dp array using the dynamic programming approach for i in range(2, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"Scenario You are developing a program that sorts employee performance scores stored in an array. To ensure the results are consistent, you have chosen to use Heap Sort since it guarantees O(n log(n)) time complexity and sorts in place. Problem You need to implement a function that sorts an array in ascending order using Heap Sort. You need to write the heapify and sorting functions from scratch, following the principles of Max Heap. Function Signature ```python def heap_sort(arr: list) -> list: Sorts the given list of integers in ascending order using Heap Sort. :param arr: List of integers to be sorted. :return: List of sorted integers. ``` Input Format * An unsorted list of integers called `arr`. Output Format * A list of integers sorted in ascending order. Constraints * The input list will not exceed 10^5 elements. * The elements of the list are within the range of -10^6 to 10^6. * Ensure the solution runs within reasonable time limits for large inputs. Requirements 1. Implement a function `heapify` that arranges the list elements to satisfy the heap property. 2. Implement the main `heap_sort` function that makes use of `heapify` to sort the array. Example ```python >>> heap_sort([4, 10, 3, 5, 1]) [1, 3, 4, 5, 10] >>> heap_sort([0, -5, 3, 7, 2]) [-5, 0, 2, 3, 7] ``` Notes * Handle edge cases effectively. * Ensure your program handles a range of input efficiently. * The function should maintain O(n log(n)) performance.","solution":"def heapify(arr, n, i): To heapify a subtree rooted with node i which is an index in arr[]. n is size of heap. largest = i # Initialize largest as root l = 2 * i + 1 # left = 2*i + 1 r = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if l < n and arr[i] < arr[l]: largest = l # See if right child of root exists and is greater than the root (or largest so far) if r < n and arr[largest] < arr[r]: largest = r # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root. heapify(arr, n, largest) def heap_sort(arr): Sorts the given list of integers in ascending order using Heap Sort. :param arr: List of integers to be sorted. :return: List of sorted integers. n = len(arr) # Build a maxheap. for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) # One by one extract elements for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0) return arr"},{"question":"# Question You are tasked with implementing a function that takes in the head of a singly linked list and returns a deep copy of the list while removing all duplicates. A deep copy means that you should create entirely new nodes that do not share references with the original nodes. # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def deep_copy_and_remove_duplicates(head: ListNode) -> ListNode: pass ``` # Input - `head`: ListNode - A reference to the head node of a singly linked list. Each node has an integer value and a reference to the next node. # Output - `ListNode`: The head of the new linked list that is a deep copy of the input list but with all duplicate values removed. # Constraints - The values in the ListNode are integers. - The linked list may contain zero or more nodes with integer values. - Do not use extra data structures like sets or lists for storing nodes or intermediate values. # Performance Requirements - The solution should run in O(n) time complexity where n is the number of nodes in the list. - Space complexity should be O(1) in terms of extra memory used, excluding the memory used for the new list. # Examples 1. **Example 1**: - Input: `head = [1, 1, 2, 3, 3, 4]` - Output: New list`[1, 2, 3, 4]` Explanation: All duplicate values have been removed. The order of unique values from the original list is preserved. 2. **Example 2**: - Input: `head = [1, 2, 3, 4, 5]` - Output: New list `[1, 2, 3, 4, 5]` Explanation: No duplicates were present, so the new list is the same as the original list. 3. **Example 3**: - Input: `head = [1]` - Output: New list `[1]` Explanation: Only a single node is present, hence no duplicates. 4. **Example 4**: - Input: `head = []` - Output: New list `[]` Explanation: The input list is empty, hence the resulting list is also empty. # Notes - Ensure deep copy implies creating a completely new structure without any shared parts with the original list. - Pay attention to handling edge cases such as an empty list, a list with one node, and contiguous duplicate values.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def deep_copy_and_remove_duplicates(head: ListNode) -> ListNode: if not head: return None unique_vals = set() dummy = ListNode(0) current_new = dummy current_old = head while current_old: if current_old.val not in unique_vals: unique_vals.add(current_old.val) current_new.next = ListNode(current_old.val) current_new = current_new.next current_old = current_old.next return dummy.next"},{"question":"**Context**: You are given two integer arrays `v1` and `v2`. You are required to implement an iterator that yields elements from the two arrays in an alternating or zigzag order. The iterator should return elements from `v1` and `v2` one at a time, switching between the arrays and continuing until all elements from both arrays have been returned. If one array is exhausted before the other, the iterator should continue to return the remaining elements from the non-exhausted array. **Problem**: Implement the `ZigZagIterator` class which contains the following methods: - `__init__(self, v1: List[int], v2: List[int])`: Initializes the iterator with two lists `v1` and `v2`. - `next(self) -> int`: Returns the next element in the zigzag order. - `has_next(self) -> bool`: Returns `True` if there are more elements to return, otherwise `False`. **Constraints**: - The length of each list can be different. - The elements in the lists can be any valid integers. - The function should not use extra space that\'s proportional to the total number of elements in the lists; storage for iterating should be minimal. **Input/Output**: Suppose there are inputs: ```python v1 = [1, 2, 3] v2 = [4, 5, 6, 7, 8] ``` The `ZigZagIterator` should output elements in the following order: `1, 4, 2, 5, 3, 6, 7, 8`. # Example ```python v1 = [1, 2] v2 = [3, 4, 5, 6] it = ZigZagIterator(v1, v2) output = [] while it.has_next(): output.append(it.next()) print(output) # [1, 3, 2, 4, 5, 6] ``` # Code Template ```python from typing import List class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): Initialize your data structure here. self.queue = [_ for _ in (v1, v2) if _] def next(self) -> int: Returns the next element in zigzag order. v = self.queue.pop(0) ret = v.pop(0) if v: self.queue.append(v) return ret def has_next(self) -> bool: Returns true if there are more elements to fetch. return bool(self.queue) # Example use case v1 = [1, 2] v2 = [3, 4, 5, 6] it = ZigZagIterator(v1, v2) output = [] while it.has_next(): output.append(it.next()) print(output) # Expected: [1, 3, 2, 4, 5, 6] ```","solution":"from typing import List class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): Initialize your data structure here. self.index1, self.index2 = 0, 0 self.len1, self.len2 = len(v1), len(v2) self.turn = 0 self.v1, self.v2 = v1, v2 def next(self) -> int: Returns the next element in zigzag order. if (self.turn % 2 == 0 and self.index1 < self.len1) or self.index2 >= self.len2: result = self.v1[self.index1] self.index1 += 1 else: result = self.v2[self.index2] self.index2 += 1 self.turn += 1 return result def has_next(self) -> bool: Returns true if there are more elements to fetch. return self.index1 < self.len1 or self.index2 < self.len2"},{"question":"# Scenario You are working on a data processing pipeline that involves filtering numerical data based on user-defined thresholds. The data is stored in arrays and you need to ensure that only values within a specified range are passed to the next stage of processing. To achieve this, you must implement a function that filters the values of the array according to given minimum and maximum constraints. # Function Specification - **Function Name**: `limit` - **Input**: - `arr`: A list of integers. - `min_lim`: An integer or `None`. - `max_lim`: An integer or `None`. - **Output**: A new list of integers containing only the values from `arr` that are within the range `[min_lim, max_lim]` (inclusive). # Constraints - If `min_lim` is `None`, treat it as the smallest element in `arr`. - If `max_lim` is `None`, treat it as the largest element in `arr`. - Ensure your solution has a time complexity of O(n). # Example ```python # Example 1 arr = [1, 2, 3, 4, 5] min_lim = None max_lim = 3 print(limit(arr, min_lim, max_lim)) # Output: [1, 2, 3] # Example 2 arr = [10, 15, 3, 7, 8, 22] min_lim = 5 max_lim = 20 print(limit(arr, min_lim, max_lim)) # Output: [10, 15, 7, 8] # Example 3 arr = [] min_lim = 1 max_lim = 10 print(limit(arr, min_lim, max_lim)) # Output: [] # Example 4 arr = [5, 8, 12, 20] min_lim = None max_lim = None print(limit(arr, min_lim, max_lim)) # Output: [5, 8, 12, 20] ``` **Notes**: - Think about how you can handle cases where the `min_lim` or `max_lim` values are not provided. - Focus on making the solution efficient with a linear time complexity.","solution":"def limit(arr, min_lim, max_lim): if min_lim is None: min_lim = min(arr) if arr else float(\'-inf\') if max_lim is None: max_lim = max(arr) if arr else float(\'inf\') return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Question: Base Conversion Functions You are tasked with writing two functions that perform integer base conversions. Your functions should demonstrate understanding of numeric systems and efficient handling of edge cases. **Function 1: Integer to Base** Write a function `int_to_base(num, base)` that converts an integer `num` to its string representation in the specified `base`. * **Input**: * `num` - an integer (can be negative; at least 0). * `base` - an integer (2 <= base <= 36). * **Output**: * A string representing `num` in the given `base`. * **Examples**: * `int_to_base(5, 2)` should return `\'101\'`. * `int_to_base(-10, 16)` should return `\'-A\'`. **Function 2: Base to Integer** Write a function `base_to_int(str_to_convert, base)` that converts a string `str_to_convert` representing a number in the specified `base` to an integer. * **Input**: * `str_to_convert` - a string consisting of digits or uppercase letters (\'0\' to \'9\', \'A\' to \'Z\'). * `base` - an integer (2 <= base <= 36). * **Output**: * An integer which is the base-10 equivalent of `str_to_convert`. * **Examples**: * `base_to_int(\'101\', 2)` should return `5`. * `base_to_int(\'F\', 16)` should return `15`. **Constraints**: * Assume valid input for now; invalid bases or strings are not required to be handled explicitly. * Optimize for performance for reasonably sized inputs (values in the range of -2^31 to 2^31-1 for `int_to_base` and strings up to length 32 for `base_to_int`). Implement both functions efficiently, keeping the principles of base conversion in mind.","solution":"def int_to_base(num, base): Converts an integer `num` to its string representation in the specified `base`. if base < 2 or base > 36: raise ValueError(\\"base must be between 2 and 36\\") if num == 0: return \\"0\\" negative = num < 0 num = abs(num) digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = [] while num > 0: result.append(digits[num % base]) num //= base if negative: result.append(\'-\') return \'\'.join(reversed(result)) def base_to_int(str_to_convert, base): Converts a string `str_to_convert` representing a number in the specified `base` to an integer. if base < 2 or base > 36: raise ValueError(\\"base must be between 2 and 36\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" value_map = {char: i for i, char in enumerate(digits)} result = 0 negative = str_to_convert[0] == \'-\' start_index = 1 if negative else 0 for char in str_to_convert[start_index:]: result = result * base + value_map[char.upper()] return -result if negative else result"},{"question":"Given a stream of integers and a fixed window size, implement a function to calculate the moving average of all integers in the sliding window. # Function Signature ```python def moving_average(size: int, stream: List[int]) -> List[float]: Parameters: - size: The size of the sliding window (1 ≤ size ≤ 10^5) - stream: A list of integers representing the incoming data stream (0 ≤ len(stream) ≤ 10^6, -10^4 ≤ stream[i] ≤ 10^4) Returns: - A list of floats representing the moving averages for the sliding window. ``` # Constraints * `size` is always a positive integer. * The length of `stream` can vary from 0 to a large number (up to 1,000,000). # Example Given the list `stream = [1, 10, 3, 5]` and `size = 3`, the function should return `[1.0, 5.5, 4.666666666666667, 6.0]`. # Explanation: 1. The first element is `1`, so the average is `1.0`. 2. The first two elements are `[1, 10]`, so the average is `(1 + 10) / 2 = 5.5`. 3. The first three elements are `[1, 10, 3]`, so the average is `(1 + 10 + 3) / 3 = 4.666666666666667`. 4. The last three elements are `[10, 3, 5]`, so the average is `(10 + 3 + 5) / 3 = 6.0`. # Requirements * Your solution should handle cases where the length of `stream` is less than `size`. * Optimize for lower space utilization and ensure that the function runs efficiently even for large inputs. # Note 1. You are expected to use the `deque` data structure to maintain the sliding window efficiently. 2. Avoid recalculating the sum from scratch for every moving average.","solution":"from collections import deque from typing import List def moving_average(size: int, stream: List[int]) -> List[float]: if size <= 0: raise ValueError(\\"Size of the window must be a positive integer.\\") result = [] window = deque() current_sum = 0 for i, value in enumerate(stream): window.append(value) current_sum += value if len(window) > size: current_sum -= window.popleft() result.append(current_sum / len(window)) return result"},{"question":"You are given a 2D grid map where \'1\' represents land and \'0\' represents water. An island is defined as a group of adjacent \'1\'s (horizontally or vertically) surrounded by water. You need to count the number of distinct islands in the grid. Write a function `count_islands(grid)` that takes the following input: - **grid** (List[List[int]]): A 2D list of integers representing the map. The function should output: - **num_islands** (int): The total number of distinct islands found in the grid. # Example ```python def count_islands(grid): row = len(grid) col = len(grid[0]) num_islands = 0 visited = [[0] * col for i in range(row)] directions = [[-1, 0], [1, 0], [0, -1], [0, 1]] queue = [] for i in range(row): for j, num in enumerate(grid[i]): if num == 1 and visited[i][j] != 1: visited[i][j] = 1 queue.append((i, j)) while queue: x, y = queue.pop(0) for k in range(len(directions)): nx_x = x + directions[k][0] nx_y = y + directions[k][1] if nx_x >= 0 and nx_y >= 0 and nx_x < row and nx_y < col: if visited[nx_x][nx_y] != 1 and grid[nx_x][nx_y] == 1: queue.append((nx_x, nx_y)) visited[nx_x][nx_y] = 1 num_islands += 1 return num_islands # Test the function with the following examples: print(count_islands([ [1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0] ])) # Output: 1 print(count_islands([ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ])) # Output: 3 ``` # Constraints 1. The grid dimensions (rows and columns) will be at most 300x300. 2. You may assume all four edges of the grid are all surrounded by water. 3. The grid elements are either `0` (water) or `1` (land).","solution":"def count_islands(grid): Function to count the number of distinct islands in the given 2D grid map. :param grid: List[List[int]], a 2D list of integers where 1 represents land and 0 represents water :return: int, the total number of distinct islands found in the grid if not grid: return 0 def bfs(grid, row, col): queue = [(row, col)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: x, y = queue.pop(0) for d in directions: nx, ny = x + d[0], y + d[1] if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1: grid[nx][ny] = 0 # mark as visited queue.append((nx, ny)) num_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: bfs(grid, i, j) num_islands += 1 return num_islands"},{"question":"# Sparse Matrix Multiplication Introduction In various applications, from scientific computing to big data analysis, matrices often appear in a sparse form. Sparse matrices have the majority of their elements as zeros, making it inefficient to use traditional matrix multiplication methods which involve unnecessary computations. By leveraging the sparse property, we can optimize matrix multiplication significantly. Problem Statement Write a function that multiplies two given sparse matrices and returns the resultant matrix. Each matrix is represented as a list of lists (2D list) where the internal lists may contain integers, typically zeros, and non-zero elements. Function Signature Implement the function `sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]`. Parameters - **A** (`List[List[int]]`): First input sparse matrix of dimensions `m x n`. - **B** (`List[List[int]]`): Second input sparse matrix of dimensions `n x p`. Return - The resultant sparse matrix as a `List[List[int]]` of dimensions `m x p` after multiplying `A` with `B`. Constraints 1. The number of columns in A must be equal to the number of rows in B. 2. Matrices A and B could be sparse with a significant number of zero elements. Example ```python A = [ [1, 0, 0], [-1, 0, 3] ] B = [ [7, 0, 0], [0, 0, 0], [0, 0, 1] ] Expected Output: [ [7, 0, 0], [-7, 0, 3] ] ``` Constraints - Both matrices A and B have dimensions between 1x1 and 1000x1000. - Elements of the matrices are integers and could be negative. Requirements 1. Handle edge cases such as entirely zero rows or columns. 2. Ensure the function is efficient given the sparsity of the matrices. 3. Avoid unnecessary multiplications involving zero elements where possible.","solution":"from typing import List def sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: if not A or not B or not A[0] or not B[0]: return [] m, n = len(A), len(A[0]) nB, p = len(B), len(B[0]) assert n == nB, \\"Number of columns in A must be equal to the number of rows in B\\" result = [[0] * p for _ in range(m)] # Iterate over the matrix A. for i in range(m): for k in range(n): if A[i][k] != 0: for j in range(p): if B[k][j] != 0: result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# **Coding Assessment Question** # Context You have been asked to develop an intelligent text message predictive system. The system should take numeric inputs from a phone keypad and return all possible combinations of text that can be generated from those numerical inputs, based on typical keypad character mappings. Using the existing mappings for digits 2-9 (like on a telephone keypad), write a function that efficiently generates all possible letter combinations for a given digit string. # Task Write a Python function `generate_combinations(digits: str) -> List[str]` that takes a digit string and returns all possible letter combinations that the number could represent. # Input * A string `digits` consisting of digits from \'2\' to \'9\'. (1 <= len(digits) <= 4) # Output * A list of strings containing all possible letter combinations that the number could represent. # Constraints 1. An empty input string should return an empty list. 2. Every digit maps to a non-empty string of characters. # Performance Requirements * The solution should handle the maximum input size efficiently within the given constraints. * Aim for a solution that balances readability and performance. # Example ```python # Example 1 Input: \\"23\\" Output: [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] # Example 2 Input: \\"\\" Output: [] # Example 3 Input: \\"2\\" Output: [\\"a\\", \\"b\\", \\"c\\"] ``` # Requirements 1. Implement a function following the format: ```python from typing import List def generate_combinations(digits: str) -> List[str]: # Your code here ``` 2. Ensure your solution passes the given examples and any additional edge cases.","solution":"from typing import List def generate_combinations(digits: str) -> List[str]: if not digits: return [] # Mapping of digit to possible characters. digit_to_char = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index, path): # If the path is the same length as digits, we have a complete combination. if index == len(digits): combinations.append(\\"\\".join(path)) return # Get the letters that the current digit maps to, and loop through them. current_digit = digits[index] for letter in digit_to_char[current_digit]: path.append(letter) backtrack(index + 1, path) path.pop() # Backtrack to explore another letter option. combinations = [] backtrack(0, []) return combinations"},{"question":"# Question You are tasked with creating a tool that can convert integers between different numeral systems efficiently. Implement the following functions: 1. `int_to_base(num, base)` 2. `base_to_int(str_to_convert, base)` `int_to_base(num, base)` * **Input**: * `num`: An integer, which can be negative. (−10^9 ≤ num ≤ 10^9) * `base`: An integer, representing the base to convert to. (2 ≤ base ≤ 36) * **Output**: * A string representing the number in the specified base. * **Constraints**: - The conversion must support bases between 2 and 36. - It should handle both positive and negative integers. `base_to_int(str_to_convert, base)` * **Input**: * `str_to_convert`: A string representation of the number in the specified base. (0-9, A-Z) * `base`: An integer, representing the base of the string representation. (2 ≤ base ≤ 36) * **Output**: * An integer that the string represents in base 10. * **Constraints**: - The input string will contain valid characters for the specified base. - The base will be in the range 2 to 36. # Examples ```python # Example 1 print(int_to_base(5, 2)) # Output: \'101\' # Example 2 print(base_to_int(\'F\', 16)) # Output: 15 # Example 3 print(int_to_base(-31, 16)) # Output: \'-1F\' # Example 4 print(base_to_int(\'-1F\', 16)) # Output: -31 ```","solution":"def int_to_base(num, base): Converts an integer to a string representation in the specified base. if num == 0: return \'0\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if negative: result.append(\'-\') return \'\'.join(result[::-1]) def base_to_int(str_to_convert, base): Converts a string representation of a number in a specified base to an integer. str_to_convert = str_to_convert.upper() digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = str_to_convert[0] == \'-\' if negative: str_to_convert = str_to_convert[1:] result = 0 for char in str_to_convert: result = result * base + digits.index(char) if negative: result = -result return result"},{"question":"# Question: Counting Sort with Custom Range **Context**: As a software engineer working for a logistics company, you need to design a robust system to sort a set of delivery times, which can include negative values indicating deliveries ahead of schedule. **Problem Statement**: Implement a function `custom_counting_sort(arr: List[int]) -> List[int]` that performs counting sort on an array of integers, which may include negative values. The function should handle the range of the elements effectively and convert the array back to accommodate the original sign of the integers. **Function Signature**: ```python def custom_counting_sort(arr: List[int]) -> List[int]: ``` **Input**: - `arr` (List[int]): A list of integers which can contain negative values, either sorted, unsorted, or containing duplicate values. The size of the list can go up to `1000` elements, with values ranging between `-10^6` and `10^6`. **Output**: - A list of integers sorted in non-decreasing order, maintaining their original sign (positive or negative). **Constraints**: 1. The number of elements in `arr` ranges from `0` to `1000`. 2. Element values range from `-10^6` to `10^6`. 3. The algorithm must run in O(n + k) time complexity where `n` is the number of elements and `k` is the range of the input. **Example**: ```python assert custom_counting_sort([3, -2, -1, 4, -3]) == [-3, -2, -1, 3, 4] assert custom_counting_sort([0, 2, 1, -1, -4]) == [-4, -1, 0, 1, 2] assert custom_counting_sort([]) == [] ``` # Performance Requirements: - Your function should efficiently handle arrays with the maximum input size and value ranges within the specified constraints. - The solution must address both positive and negative numbers within the given range. # Hints: - Adjust the array so that all numbers are non-negative, sort using counting sort, and then readjust the array to convert back to its original sign. - Consider edge cases such as empty arrays or arrays with uniform values.","solution":"from typing import List def custom_counting_sort(arr: List[int]) -> List[int]: if not arr: return [] # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Shift the values so all are non-negative shift = -min_val shifted_max_val = max_val + shift # Create a count array to store the frequency of each value count = [0] * (shifted_max_val + 1) # Count the occurrences of each element in the shifted array for num in arr: count[num + shift] += 1 # Construct the sorted array sorted_arr = [] for i in range(len(count)): sorted_arr.extend([i - shift] * count[i]) return sorted_arr"},{"question":"# Segment Tree Implementation and Usage You are given a segment tree implementation designed to efficiently handle range queries and point updates on an array. A segment tree supports both range queries (e.g., finding the sum, maximum, minimum of elements over a subrange) and single-element updates (e.g., modifying an element) in logarithmic time. The segment tree uses a commutative function for the aggregation, meaning the order of operations doesn’t affect the result. Task 1. Implement additional functionality in the segment tree to handle a specific use case: - Compute the sum of non-zero elements within a specified range. - Update and set an element to zero within the array. Input and Output 1. **Query Non-zero Sum**: - Input: Two integers (l) and (r) representing the inclusive left and right bounds of the query range. - Output: An integer representing the sum of all non-zero elements between the indices (l) and (r). 2. **Update Element to Zero**: - Input: An integer (p) representing the index to be updated. - Output: None (modify the segment tree in place). Requirements 1. The solution should be efficient, utilizing the segment tree for range queries and updates. 2. Ensure that the current tree structure is updated correctly after setting an element to zero. Function Signature ```python class SegmentTree: ... def query_nonzero_sum(self, l: int, r: int) -> int: Queries the sum of non-zero elements between index l and r inclusive. :param l: The starting index of the range. :param r: The ending index of the range. :return: Sum of non-zero elements within the given range. pass def set_to_zero(self, p: int) -> None: Updates the element at index p to zero in the segment tree and array. :param p: The index to update to zero. pass ``` Example ```python arr = [4, 5, 2, 3, 0, 43, 3] seg_tree = SegmentTree(arr, lambda a, b: a + b) print(seg_tree.query_nonzero_sum(0, 6)) # Output should be 60 seg_tree.set_to_zero(1) print(seg_tree.query_nonzero_sum(0, 6)) # Output should be 55 seg_tree.set_to_zero(3) print(seg_tree.query_nonzero_sum(0, 6)) # Output should be 52 ```","solution":"class SegmentTree: def __init__(self, data, func): self.n = len(data) self.func = func self.data = data[:] self.tree = [0] * (2 * self.n) self.build() def build(self): # Build the tree by initializing tree values for i in range(self.n): self.tree[self.n + i] = self.data[i] if self.data[i] != 0 else 0 for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index, value): # Update the value at index and rebuild the tree accordingly pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.func(self.tree[pos * 2], self.tree[pos * 2 + 1]) def query(self, l, r): # Query the sum of values in the range [l, r) l += self.n r += self.n + 1 res = 0 while l < r: if l % 2 == 1: res = self.func(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 res = self.func(res, self.tree[r]) l //= 2 r //= 2 return res def query_nonzero_sum(self, l, r): Queries the sum of non-zero elements between index l and r inclusive. return self.query(l, r) def set_to_zero(self, p): Updates the element at index p to zero in the segment tree and array. self.data[p] = 0 self.update(p, 0)"},{"question":"Scenario You\'re part of a team that develops combinatorial analysis tools. One common task is generating all possible combinations (subsets) of a given set of distinct integers. Implement two variants of a solution to this problem: one using backtracking and another using an iterative approach. Task You need to implement a function that, given a set of distinct integers, generates all possible subsets. Function Signature ```python def subsets(nums: List[int]) -> List[List[int]]: pass def subsets_iterative(nums: List[int]) -> List[List[int]]: pass ``` Input - `nums`: A list of distinct integers `List[int]` where 0 <= len(nums) <= 10 and -10 <= nums[i] <= 10. Output - A list of lists `List[List[int]]` representing all possible subsets including the empty set. Example ```python Input: nums = [1, 2, 3] Output: [ [], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3] ] ``` Constraints - The subsets within the list do not need to be ordered. - Ensure there are no duplicate subsets. Requirements 1. Implement the `subsets` function using a backtracking approach. 2. Implement the `subsets_iterative` function using an iterative approach. Performance - Aim for a solution that runs with a time complexity of O(2^n). - Ensure your solution is efficient within the given constraints.","solution":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: def backtrack(start: int, path: List[int]): # Append the current subset (path) to the result result.append(path[:]) for i in range(start, len(nums)): # Include nums[i] into the current subset path.append(nums[i]) # Move on to the next element backtrack(i + 1, path) # Backtrack, removing nums[i] from the current subset path.pop() result = [] backtrack(0, []) return result def subsets_iterative(nums: List[int]) -> List[List[int]]: result = [[]] # Start with the empty subset for num in nums: # For each number, add it to all existing subsets in the result result += [curr + [num] for curr in result] return result"},{"question":"# Ternary Search Implementation **Scenario**: You are tasked with implementing a search feature for a large database of sorted integers. Given the database is sorted and may contain millions of records, an efficient searching algorithm is necessary. You decide to implement a ternary search, which divides the search interval into three parts to potentially reduce comparisons. **Task**: Write a Python function `ternary_search` that takes the following parameters: * `left` (int): The starting index of the array segment to search. * `right` (int): The ending index of the array segment to search. * `key` (int): The target value to search for. * `arr` (List[int]): The sorted list of integers in which to perform the search. The function should return the index of the `key` in the array if it is present. If the `key` is not found, return -1. **Function Signature**: ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: ``` **Example**: ```python # Example call arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] result = ternary_search(0, len(arr) - 1, 5, arr) print(result) # Output should be 4 since arr[4] = 5 ``` **Constraints**: * The input array is guaranteed to be sorted in ascending order. * The array may contain up to 10^6 elements. * The value of each element in the array ranges from -10^9 to 10^9. * The value of the key ranges from -10^9 to 10^9. Make sure to handle edge cases such as empty arrays and cases where the key is not present in the array correctly.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Searches for the key in arr between the indices left and right using ternary search. Returns the index of the key if found, otherwise returns -1. while right >= left: # Find the mid points mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 # Check if the key is at any mid point if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 # Determine which segment to search in if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 # Key was not found return -1"},{"question":"You are required to implement the `cycle_sort` function that sorts an array of integers in ascending order using the Cycle Sort algorithm. The provided implementation must perform the sorting in-place with minimal number of write operations. # Input * An array `arr` of integers of size (N) where (1 leq N leq 10^4). # Output * The function should return the sorted array `arr` after applying the Cycle Sort algorithm. # Constraints 1. You should handle arrays with duplicate values correctly. 2. The function should minimize the number of write operations. # Example Input ```python arr = [3, 5, 2, 1, 4] ``` Output ```python [1, 2, 3, 4, 5] ``` # Edge Cases to Consider 1. Arrays with all elements identical, e.g., `[1, 1, 1, 1]`. 2. Arrays that are already sorted, e.g., `[1, 2, 3, 4, 5]`. 3. Arrays with a large number of duplicates, e.g., `[2, 3, 2, 3, 2, 3]`. # Additional Information * You are not allowed to use any built-in sorting functions. * You must strictly follow the Cycle Sort algorithm to ensure minimal write operations.","solution":"def cycle_sort(arr): Sorts an array in place using Cycle Sort algorithm and returns it. n = len(arr) # Loop through the array to find cycles to rotate for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find the location where to put the item pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Skip duplicates while item == arr[pos]: pos += 1 # Put the item to the correct position if pos != cycle_start: arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 if item != arr[pos]: arr[pos], item = item, arr[pos] return arr"},{"question":"Context: Shell Sort is a generalization of insertion sort that allows the exchange of items far apart. The core idea is to arrange the elements so that, starting anywhere, taking every `k-th` element produces a sorted list. Then the gap `k` is reduced gradually to 1. This algorithm is particularly effective for medium-sized arrays and performs much better than insertion sort for larger gaps. Task: Write a function `shell_sort_optimized(arr: list, gaps: list) -> list` that sorts an array using the Shell Sort algorithm with a specified sequence of gaps. The function should accept an array of numbers and a list of integers representing the gap sequence. Function Signature: ```python def shell_sort_optimized(arr: list, gaps: list) -> list: pass ``` Input: * `arr` - A list of integers to be sorted. * `gaps` - A list of integers representing the gap sequence. Output: * The function should return the sorted list of integers. Example: ```python assert shell_sort_optimized([12, 34, 54, 2, 3], [4, 1]) == [2, 3, 12, 34, 54] assert shell_sort_optimized([23, 12, 1, 8, 34, 54, 2], [5, 3, 1]) == [1, 2, 8, 12, 23, 34, 54] ``` Constraints: * The length of the input array will be at most 10^5. * Each element in the input array is an integer within the range [-10^5, 10^5]. * The gap sequence will be a list of integers in non-increasing order and will always include a final gap of 1. Additional Notes: * Handle edge cases (e.g., empty array, single element array). * Focus on handling arrays that may contain duplicate elements correctly. * Ensure the solution is optimized for large arrays by considering the given gap sequence.","solution":"def shell_sort_optimized(arr: list, gaps: list) -> list: Sorts a list using the Shell Sort algorithm with a specified sequence of gaps. Parameters: arr (list): A list of integers to be sorted. gaps (list): A list of integers representing the gap sequence. Returns: list: The sorted list of integers. n = len(arr) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Prime Sum Aggregator **Objective**: Write a function that finds the sum of all prime numbers less than a given integer `N`. **Function Signature**: ```python def sum_of_primes(N: int) -> int: ``` **Input**: - **N** (integer): The upper limit (exclusive) for considering prime numbers. ( 1 leq N leq 10^6 ). **Output**: - An integer representing the sum of all prime numbers less than `N`. **Constraints**: - The function should be efficient and able to handle large values up to ( 10^6 ). - Consider edge cases like `N = 1`, where there are no primes less than 1. **Examples**: ```python assert sum_of_primes(10) == 17 # Primes are 2, 3, 5, 7 assert sum_of_primes(20) == 77 # Primes are 2, 3, 5, 7, 11, 13, 17, 19 assert sum_of_primes(1) == 0 # No primes less than 1 ``` **Instructions**: 1. Utilize the provided `prime_check` function logic or optimize it to create a solution that aggregates prime sums effectively. 2. Consider the performance implications and optimize where needed, possibly using the Sieve of Eratosthenes for an optimal approach. 3. Ensure your function passes given edge cases and general tests efficiently.","solution":"def sum_of_primes(N): Returns the sum of all prime numbers less than N. if N <= 1: return 0 sieve = [True] * N sieve[0] = sieve[1] = False # 0 and 1 are not primes p = 2 while (p * p < N): if sieve[p]: for i in range(p * p, N, p): sieve[i] = False p += 1 return sum(i for i in range(N) if sieve[i])"},{"question":"# Stooge Sort Algorithm Verification and Optimization Scenario You are given an array of integers and need to verify the efficiency and correctness of the Stooge Sort algorithm. Despite its educational value, your goal is to: 1. Implement a function that verifies if the array is sorted correctly using Stooge Sort. 2. Optimize the algorithm by replacing it with a more efficient sorting algorithm while ensuring the same results. Task 1. Implement the stooge_sort function. 2. Verify correctness by ensuring the array is indeed sorted. 3. Optimize the sorting algorithm to improve performance. Input: - arr: List[int] - An array of integers that need to be sorted. Output: - List[int] - The sorted array of integers. Example: ```python Input: [5, 4, 3, 2, 1] Output: [1, 2, 3, 4, 5] ``` Constraints: - The length of the array can be up to 1000. - The elements of the array are integers and can include negative numbers. Notes: 1. Ensure you handle edge cases such as already sorted arrays, arrays with duplicates, and arrays with only one element. 2. Aim to replace the Stooge Sort with a more efficient sorting algorithm like Merge Sort or Quick Sort to handle larger arrays effectively.","solution":"def stooge_sort(arr, l=0, h=None): if h is None: h = len(arr) - 1 if l >= h: return # If the first element is greater than the last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 stooge_sort(arr, l, h - t) stooge_sort(arr, l + t, h) stooge_sort(arr, l, h - t) def optimized_sort(arr): Uses Python\'s built-in Timsort algorithm (via sorted()) to sort the array. Timsort is a hybrid sorting algorithm derived from merge sort and insertion sort. return sorted(arr)"},{"question":"# Problem Description You have recently been hired as a junior developer at a tech company, and your first task is to enhance a substring search functionality in one of their text processing toolkits. You are given a function that finds the first occurrence of a substring (`needle`) in another string (`haystack`). Your task is to improve the performance of the search and ensure it handles edge cases properly. # Implementation Task Implement the function `find_substring(haystack, needle)` that performs the substring search. You are required to: * Input: * `haystack` - a string in which to search. * `needle` - a string to search for. * Output: * Return the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not a part of `haystack`. # Constraints * The length of both `haystack` and `needle` will be between (0) and (10^5). * Strings will only contain lowercase English characters (`a-z`). # Example * **Example 1:** ```plaintext Input: haystack = \\"hello\\", needle = \\"ll\\" Output: 2 ``` * **Example 2:** ```plaintext Input: haystack = \\"aaaaa\\", needle = \\"bba\\" Output: -1 ``` * **Example 3:** ```plaintext Input: haystack = \\"abc\\", needle = \\"\\" Output: 0 ``` # Performance Requirements * Your solution should have better time complexity compared to the naive approach, ideally (O(m + n)) in the average case using optimized algorithms such as KMP. # Task Overview * Carefully handle the edge cases mentioned. * Focus on writing clean and efficient code, keeping space usage minimal. Please implement your solution below: ```python def find_substring(haystack, needle): # Your code here ```","solution":"def find_substring(haystack, needle): Returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not a part of `haystack`. Uses the Knuth-Morris-Pratt (KMP) algorithm for efficient string matching. if not needle: return 0 if not haystack: return -1 # Helper function to generate the partial match table (LPS array) def compute_lps(needle): lps = [0] * len(needle) length = 0 i = 1 while i < len(needle): if needle[i] == needle[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(needle) i = 0 # index for haystack j = 0 # index for needle while i < len(haystack): if needle[j] == haystack[i]: i += 1 j += 1 if j == len(needle): return i - j elif i < len(haystack) and needle[j] != haystack[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"# Problem Description Given an array of integers, implement the `selection_sort` function to sort the array in ascending order using the selection sort algorithm. Your implementation should handle the following constraints and requirements: 1. **Function Signature**: `def selection_sort(arr: List[int], simulation: bool = False) -> List[int]:` 2. **Input**: - `arr`: A list of integers containing up to `10^3` elements. - `simulation`: A boolean flag that, when set to `True`, prints the status of the list after each iteration of sorting. 3. **Output**: A list of integers sorted in ascending order. 4. **Constraints**: - You may assume all integers in the input list are within the range of `-10^6` to `10^6`. # Example ```python # Empty list selection_sort([]) # returns [] # Single element list selection_sort([1]) # returns [1] # Multiple elements selection_sort([64, 25, 12, 22, 11]) # returns [11, 12, 22, 25, 64] # Simulation of sorting selection_sort([64, 25, 12, 22, 11], simulation=True) # should print: # iteration 0 : 64 25 12 22 11 # iteration 1 : 11 25 12 22 64 # iteration 2 : 11 12 25 22 64 # iteration 3 : 11 12 22 25 64 # iteration 4 : 11 12 22 25 64 ``` # Additional Context - Ensure you handle edge cases effectively. - Optimize unnecessary computations within loops. - Thoroughly test your implementation with diverse datasets to confirm its stability and correctness. - Ensure your print statements exactly match the format shown in the simulation example when `simulation` is `True`.","solution":"from typing import List def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) for i in range(n): min_idx = i for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"**Context**: You are given two singly linked lists. Each list might have nodes that eventually converge at a common node. This common node and subsequent nodes are all shared between the two lists and are unique identifiers (i.e., not just by value but by reference). **Objective**: Write a function `find_intersection(head1: Node, head2: Node) -> Node` that takes the heads of the two singly linked lists as arguments and returns the first intersecting node. If the lists do not intersect, return `None`. # Input * `head1`: The head node of the first singly linked list. * `head2`: The head node of the second singly linked list. Each node is defined by the class: ```python class Node: def __init__(self, val: int): self.val = val self.next = None ``` # Output * Return the intersecting node or `None` if no intersection is found. # Constraints - The nodes in the list have unique memory addresses. - Expected time complexity is O(N + M), and space complexity is O(1). **Function Signature**: ```python def find_intersection(head1: Node, head2: Node) -> Node: ``` # Example For the lists: 1 -> 3 -> 5 7 -> 9 -> 11 / 2 -> 4 -> 6 * Given input such that: ```python # Create nodes a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) # Link nodes a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f # Call function intersection = find_intersection(a1, a2) ``` * The function should return the node `d` with value `7`. # Notes: - Handle edge cases such as one or both lists being empty or having unequal lengths. - Ensure your implementation efficiently handles worst-case inputs by maintaining linear time complexity.","solution":"class Node: def __init__(self, val: int): self.val = val self.next = None def find_intersection(head1: Node, head2: Node) -> Node: Finds the intersection node of two singly linked lists. If no intersection is found, returns None. Parameters: head1 (Node): The head of the first linked list. head2 (Node): The head of the second linked list. Returns: Node: The intersecting node or None. def get_length(head: Node) -> int: length = 0 while head: length += 1 head = head.next return length # Calculate lengths of both lists len1 = get_length(head1) len2 = get_length(head2) # Advance the pointer of the longer list by the difference in lengths if len1 > len2: for _ in range(len1 - len2): head1 = head1.next else: for _ in range(len2 - len1): head2 = head2.next # Traverse both lists together until we find the intersection while head1 and head2: if head1 == head2: # Intersection found return head1 head1 = head1.next head2 = head2.next return None"},{"question":"Find the Unique Number in an Array Description You are given an array of integers where every number appears twice except for one. Your task is to find the single number that appears only once. You are required to achieve this in O(n) time complexity and without using extra memory. Function Signature ```python def find_single_number(nums: List[int]) -> int: ``` Input - `nums`: A list of integers. (1 <= len(nums) <= 100000) Output - Return the single integer that appears only once in the list. If all numbers appear exactly twice or the list is empty, return 0. Constraints - Your algorithm should run in linear runtime complexity O(n). - Do not use extra memory; the space complexity should be O(1). Examples ```python # Example 1: Input: [2, 2, 1] Output: 1 # Example 2: Input: [4, 1, 2, 1, 2] Output: 4 # Example 3: Input: [1] Output: 1 # Example 4: Input: [] Output: 0 ``` Notes - You should handle edge cases appropriately, such as when the list is empty. - Assume that the input list conforms to the constraints.","solution":"from typing import List def find_single_number(nums: List[int]) -> int: Finds the single number which appears only once in the array. Every other number appears exactly twice. if not nums: return 0 single_number = 0 for num in nums: single_number ^= num return single_number"},{"question":"# Shortest Task Description Given a list of sorted lowercase letters and a target letter, your task is to implement a function that finds the smallest letter in the list which is larger than the target. Wrap-around is considered. You should implement three versions: using the bisect library, a manual binary search, and a brute force approach. Evaluate their performance. # Detailed Description Function Signature: ```python def smallest_greater_letter_bisect(letters: List[str], target: str) -> str: def smallest_greater_letter_binary_search(letters: List[str], target: str) -> str: def smallest_greater_letter_brute_force(letters: List[str], target: str) -> str: ``` Input - `letters`: A list of sorted lowercase characters. Example: `[\'c\', \'f\', \'j\']` - `target`: A single lowercase character. Output - The function should return a single character, which is the smallest character in the list that is greater than the target character. Constraints - All characters in `letters` are sorted in non-decreasing order. - The list `letters` will wrap around if the target is greater than or equal to the last element. For example, if the target is \'z\', the search should wrap around to the beginning of the list. - Time and Space Complexity considerations as described in the analysis. Examples ```python assert smallest_greater_letter_bisect([\'c\', \'f\', \'j\'], \'a\') == \'c\' assert smallest_greater_letter_binary_search([\'c\', \'f\', \'j\'], \'c\') == \'f\' assert smallest_greater_letter_brute_force([\'c\', \'f\', \'j\'], \'d\') == \'f\' assert smallest_greater_letter_bisect([\'c\', \'f\', \'j\'], \'k\') == \'c\' assert smallest_greater_letter_binary_search([\'c\', \'f\', \'j\'], \'j\') == \'c\' assert smallest_greater_letter_brute_force([\'c\', \'f\', \'k\', \'x\', \'y\'], \'w\') == \'x\' ``` Notes - Ensure your solution passes edge cases and uses efficient algorithms where applicable. - You may assume the input list will always contain at least one character.","solution":"from bisect import bisect_right from typing import List def smallest_greater_letter_bisect(letters: List[str], target: str) -> str: Finds the smallest letter in the list which is greater than the target using bisect. idx = bisect_right(letters, target) if idx == len(letters): return letters[0] return letters[idx] def smallest_greater_letter_binary_search(letters: List[str], target: str) -> str: Finds the smallest letter in the list which is greater than the target using manual binary search. low, high = 0, len(letters) - 1 while low <= high: mid = (low + high) // 2 if letters[mid] <= target: low = mid + 1 else: high = mid - 1 return letters[low % len(letters)] def smallest_greater_letter_brute_force(letters: List[str], target: str) -> str: Finds the smallest letter in the list which is greater than the target using brute force approach. for letter in letters: if letter > target: return letter return letters[0]"},{"question":"You have been given a hierarchical tree structure that represents various categories and subcategories of items. Write a function called `print_hierarchical_tree(tree)` that prints the entire tree structure in a human-readable hierarchical format. Each level of the hierarchy should be indented to indicate its depth, and elements at each level should be printed on a new line prefixed by arrows (`->`). # Input - `tree`: A dictionary representing the hierarchical tree structure. The keys are strings representing category names, and the values are lists which may contain further dictionaries or strings representing item names. # Output - Print the tree structure to the console in a hierarchical format. # Constraints 1. The tree may have varying depths. 2. Elements at each level must be properly indented to indicate their depth. 3. Handle both string leaves and nested dictionary nodes correctly. # Performance Requirements - Minimize the number of dictionary lookups to optimize performance. # Example: Given the following tree structure: ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [ \'Bill\', {\'Computer\': 5}, {\'TV\': 6}, \'Jill\', {\'Sports\': 1} ], \'c\': [\'Bill\', {\'Sports\': 3}], \'d\': [ \'Adam\', {\'Computer\': 3}, \'Quin\', {\'Computer\': 3} ], \'e\': [ \'Quin\', {\'Book\': 5}, {\'TV\': 2} ], \'f\': [\'Adam\', {\'Computer\': 7}] } ``` Expected Output: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Function Signature ```python def print_hierarchical_tree(tree: dict) -> None: pass ``` # Notes - Ensure the output is neatly formatted to clearly convey the hierarchical structure. - Handle edge cases such as empty trees and deeply nested structures.","solution":"def print_hierarchical_tree(tree, indent=0): for key, value in tree.items(): print(\' \' * indent + \'-> \' + str(key)) if isinstance(value, dict): print_hierarchical_tree(value, indent + 1) elif isinstance(value, list): for item in value: if isinstance(item, dict): print_hierarchical_tree(item, indent + 1) else: print(\' \' * (indent + 1) + \'-> \' + str(item)) else: print(\' \' * (indent + 1) + \'-> \' + str(value))"},{"question":"Context A logistics company needs to keep track of shipment IDs that pass through various checkpoints along a route. To ensure no shipments have been missed, they need a program that can identify gaps in the sequence of IDs. Given a sorted list of shipment IDs and the complete range of expected IDs, you must find the ranges of missing shipment IDs. Problem Statement You need to write a function `find_missing_ranges(arr, lo, hi)` that takes in three parameters: 1. `arr` (list of integers): A sorted list of unique integers representing the shipment IDs. 2. `lo` (integer): The lowest expected shipment ID. 3. `hi` (integer): The highest expected shipment ID. Your function should return a list of tuples, where each tuple represents a range (inclusive) of IDs that are missing from the input list. Input - `arr`: Sorted list of unique integers. - `lo`: Integer (1 <= lo <= hi). - `hi`: Integer (lo <= hi <= 10^6). Output - List of tuples, where each tuple (a, b) represents a range of missing integers in `[lo, hi]`. Example ```python # Example 1 arr = [3, 5] lo = 1 hi = 10 find_missing_ranges(arr, lo, hi) # Output: [(1, 2), (4, 4), (6, 10)] # Example 2 arr = [1, 2, 3, 4, 5] lo = 1 hi = 5 find_missing_ranges(arr, lo, hi) # Output: [] # Example 3 arr = [] lo = 5 hi = 10 find_missing_ranges(arr, lo, hi) # Output: [(5, 10)] ``` Constraints 1. The input array `arr` will already be sorted in ascending order. 2. All elements in the array `arr` will be unique and within the range [1, 10^6]. 3. The bounds `lo` and `hi` will be within the range [1, 10^6], and `lo <= hi`. Performance Requirements The function should perform efficiently with a time complexity of (O(n)) where (n) is the length of the input array, and a space complexity of (O(1)) for auxiliary space (excluding the space used for the result list). Implement the function `find_missing_ranges(arr, lo, hi)`: ```python def find_missing_ranges(arr, lo, hi): # Your code here ```","solution":"def find_missing_ranges(arr, lo, hi): Finds the missing ranges of integers in the given sorted list. Parameters: arr (list of integers): A sorted list of unique integers. lo (integer): The lowest expected number. hi (integer): The highest expected number. Returns: List of tuples: Each tuple represents a range (inclusive) of missing numbers. missing_ranges = [] prev = lo - 1 # Start from before the lowest expected number # Append hi + 1 to arr to handle the upper bound case arr.append(hi + 1) for num in arr: if num - prev > 1: missing_ranges.append((prev + 1, num - 1)) prev = num return missing_ranges"},{"question":"# Problem Description You are tasked with optimizing a network by identifying groups of mutually connected individuals. The goal is to find all maximal cliques within an undirected graph representing the network. A clique is a subset of vertices where every two vertices are connected by an edge. # Function Signature ```python def find_maximal_cliques(edges: Dict[int, Set[int]]) -> List[List[int]]: pass ``` # Input * `edges`: A dictionary where each key is a vertex (an integer) and the value is a set of integers representing the vertices connected to the key. # Output * A list of lists, each representing a maximal clique of vertex identifiers. # Constraints 1. Vertices are identified by integer labels. 2. The graph is undirected and does not contain self-loops or duplicate edges. 3. The input graph can be sparse or dense with up to 100 vertices. # Example Input: ```python edges = { 0: {1, 2}, 1: {0, 2}, 2: {0, 1, 3}, 3: {2, 4}, 4: {3} } ``` Output: ```python [[0, 1, 2], [2, 3], [3, 4]] ``` # Instructions 1. Implement the function `find_maximal_cliques` to find all cliques in the given graph. 2. Consider edge cases such as disconnected graphs and highly connected graphs. 3. Optimize your solution to handle the upper constraint efficiently.","solution":"from typing import Dict, Set, List def find_maximal_cliques(edges: Dict[int, Set[int]]) -> List[List[int]]: def bron_kerbosch(R, P, X): if not P and not X: cliques.append(list(R)) while P: v = P.pop() bron_kerbosch(R | {v}, P & edges[v], X & edges[v]) X.add(v) cliques = [] bron_kerbosch(set(), set(edges.keys()), set()) return cliques"},{"question":"# Task You are to implement an optimized version of the function `first_unique_char` that improves upon the given code snippet\'s performance using hash tables. # Description Given a string, find the first non-repeating character in it and return its index. If it doesn\'t exist, return -1. You are required to improve the algorithm\'s performance. # Function Signature ```python def first_unique_char(s: str) -> int: :type s: str :rtype: int ``` Input * `s`: A single string of length n, where (0 ≤ n ≤ 10^5). Output * An integer representing the index of the first non-repeating character, or -1 if no such character exists. Constraints * The string contains only lowercase English letters (\'a\' - \'z\'). # Requirements 1. Your solution should have a time complexity of O(n). 2. Utilize appropriate data structures to optimize performance. # Example ```python # Example 1 s = \\"leetcode\\" print(first_unique_char(s)) # Output: 0 # Example 2 s = \\"loveleetcode\\" print(first_unique_char(s)) # Output: 2 ```","solution":"def first_unique_char(s: str) -> int: Returns the index of the first non-repeating character in the string s. If there is no such character, returns -1. char_count = {} char_index = {} for index, char in enumerate(s): if char in char_count: char_count[char] += 1 else: char_count[char] = 1 char_index[char] = index for char, count in char_count.items(): if count == 1: return char_index[char] return -1"},{"question":"# Scenario You have been hired by a statistical analysis company that frequently needs to calculate binomial combinations for large datasets. To improve efficiency, you are tasked with implementing an optimized function to compute these combinations using memoization. # Task Write a function `calculate_combination(n, r)` that, given two integers `n` and `r`, returns the number of ways to choose `r` items from `n` items without ordering them. Your function must handle large inputs efficiently by leveraging memoization. Input: - An integer `n` (0 <= n <= 1000) - An integer `r` (0 <= r <= n) Output: - An integer representing the binomial coefficient `nCr`. # Constraints: - You must use memoization to ensure your solution is efficient. - Your function should handle cases where `r` is larger than `n` by returning 0. # Performance Requirements: - Your function should run in O(n * r) time complexity. - Your function should use O(n * r) space complexity due to memoization. Example: ```python print(calculate_combination(5, 2)) # Should output 10 print(calculate_combination(6, 3)) # Should output 20 print(calculate_combination(1000, 500)) # Should execute efficiently ``` Implement the function using the following signature: ```python def calculate_combination(n: int, r: int) -> int: # Your code here ```","solution":"def calculate_combination(n: int, r: int) -> int: if r > n: return 0 # Memoization table memo = [[0 for _ in range(r+1)] for _ in range(n+1)] # Bottom up dp approach to fill this table for i in range(n+1): for k in range(min(i, r)+1): if k == 0 or k == i: memo[i][k] = 1 else: memo[i][k] = memo[i-1][k-1] + memo[i-1][k] return memo[n][r]"},{"question":"# Linked List Operations Context: You are tasked with enhancing a linked list implementation to support some basic operations. Specifically, you\'ll need to create a class for a singly linked list and implement several functions to manipulate the list. Objectives: 1. Implement a singly linked list class with basic operations. 2. Test the functions with various edge cases to ensure the robustness of your implementation. Requirements: - Create a class `SinglyLinkedList` with the following methods: * `append(value)`: Adds a new node with the specified value to the end of the list. * `prepend(value)`: Adds a new node with the specified value to the front of the list. * `delete(value)`: Deletes the first node with the specified value from the list. * `find(value)`: Returns the node with the specified value if it exists; otherwise, returns `None`. * `display()`: Prints the values of the nodes in the list in sequence. Input and Output Format: - **append(value)**: Appends a new node with value `value` to the end of the list. - **prepend(value)**: Prepends a new node with value `value` to the front of the list. - **delete(value)**: Deletes the first occurrence of a node with `value` from the list. - **find(value)**: Returns the node if found, else `None`. - **display()**: Prints the list elements in order. Constraints: - The list can contain any number of elements (0 <= elements <= 10^4). - Duplicate values are allowed in the list. Example: ```python # Initialize list and perform operations sll = SinglyLinkedList() sll.append(1) sll.append(2) sll.append(3) sll.prepend(0) sll.display() # Output: 0 -> 1 -> 2 -> 3 sll.delete(2) sll.display() # Output: 0 -> 1 -> 3 print(sll.find(3)) # Output: Node with value 3 print(sll.find(4)) # Output: None ``` Solution: You are required to write the `SinglyLinkedList` class and its methods.","solution":"class Node: def __init__(self, value=None): self.value = value self.next = None class SinglyLinkedList: def __init__(self): self.head = None def append(self, value): new_node = Node(value) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def prepend(self, value): new_node = Node(value) new_node.next = self.head self.head = new_node def delete(self, value): current = self.head # If the node to be deleted is the head if current and current.value == value: self.head = current.next current = None return prev = None while current and current.value != value: prev = current current = current.next # If value was not present in the list if not current: return prev.next = current.next current = None def find(self, value): current = self.head while current: if current.value == value: return current current = current.next return None def display(self): current = self.head values = [] while current: values.append(str(current.value)) current = current.next print(\\" -> \\".join(values))"},{"question":"# Question Scenario: You are given an unsorted singly linked list. The list may contain duplicate values. Your task is to remove duplicates from the list ensuring that each value appears only once. You should implement two methods: one that uses additional data structures (hash sets) and one that does not use any additional data structures for extra storage. Requirements: 1. Implement the function `remove_duplicates_with_set(head)`, which removes duplicates using a hash set. 2. Implement the function `remove_duplicates_without_set(head)`, which removes duplicates without using any extra storage. 3. Ensure that the list remains in the same order as the original for both functions. 4. Implement `print_linked_list(head)` function which prints the linked list in a readable format. Function signatures: ```python class Node: def __init__(self, val = None): self.val = val self.next = None def remove_duplicates_with_set(head: Node) -> None: pass def remove_duplicates_without_set(head: Node) -> None: pass def print_linked_list(head: Node) -> None: pass ``` Input: - `head`: a Node object, the head of the linked list Output: - The functions do not return anything. They modify the list in place. Constraints: - The linked list can contain up to 10,000 elements. - The values in the list will be strings of lowercase alphabets. Example: ```python # Construct linked list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Using hash set remove_duplicates_with_set(a1) print_linked_list(a1) # Expected output: A -> B -> C -> D -> F -> G # Reset linked list for second example a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Without using hash set remove_duplicates_without_set(a1) print_linked_list(a1) # Expected output: A -> B -> C -> D -> F -> G ``` Performance: - `remove_duplicates_with_set(head)` should run in O(N) time with O(N) space. - `remove_duplicates_without_set(head)` should run in O(N^2) time with O(1) space.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates_with_set(head: Node) -> None: Removes duplicates from the linked list using additional data structure (hash set). if not head: return current = head seen = set() seen.add(current.val) while current and current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_duplicates_without_set(head: Node) -> None: Removes duplicates from the linked list without using additional data structures. current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next def print_linked_list(head: Node) -> None: Prints the linked list in a readable format. current = head while current: print(current.val, end=\\" -> \\" if current.next else \\"\\") current = current.next print()"},{"question":"You are given a social network represented as a directed graph where each node represents a person and a directed edge from node A to node B implies that person A follows person B. Your task is to implement a function `find_top_influencer` that determines the node (person) with the highest number of incoming edges (followers), if there is a tie, return any one of the nodes with the highest number of incoming edges. # Function Signature ```python def find_top_influencer(graph: DirectedGraph) -> Node: ``` # Input * `graph`: A `DirectedGraph` object representing the social network. # Output * A `Node` object that represents the person with the highest number of followers. # Constraints * The graph is guaranteed to be non-empty. * There can be multiple people with the same highest number of followers. * The graph could be large, pay attention to the time and space complexity. # Example ```python # Example graph sample_graph = DirectedGraph({ \'Alice\': [\'Bob\', \'Charlie\'], \'Bob\': [\'Charlie\', \'David\'], \'Charlie\': [], \'David\': [\'Alice\'], }) # Function call top_influencer = find_top_influencer(sample_graph) # Output should be `Charlie` in this example since Charlie has two followers: Alice and Bob. assert top_influencer == Node(\'Charlie\') ``` # Implementation Your implementation should efficiently compute the node with the highest number of incoming edges from the adjacency list representation of the graph.","solution":"class DirectedGraph: def __init__(self, adjacency_list): self.adjacency_list = adjacency_list class Node: def __init__(self, name): self.name = name def find_top_influencer(graph: DirectedGraph) -> Node: Finds the node (person) with the highest number of incoming edges (followers). from collections import defaultdict followers_count = defaultdict(int) for followers in graph.adjacency_list.values(): for person in followers: followers_count[person] += 1 if not followers_count: return None top_influencer = max(followers_count, key=followers_count.get) return Node(top_influencer)"},{"question":"# Binary Tree Mirroring You are given a binary tree represented by its root node. Write a function to \\"mirror\\" this binary tree, meaning each node\'s left and right children are swapped. # Function Signature ```python def mirror_tree(root: TreeNode) -> None: pass ``` # Input - `root`: The root node of a binary tree. (`root` can be `None` for an empty tree.) # Output - The function should transform the binary tree in place and return `None`. The tree should be mirrored after this function is called. # Constraints - Each node of the binary tree contains an integer value. - The number of nodes in the tree will not exceed 10^5. # Example Example 1 ```plaintext Input: 1 / 2 3 Output: 1 / 3 2 ``` Example 2 ```plaintext Input: 4 / 2 7 / / 1 3 6 9 Output: 4 / 7 2 / / 9 6 3 1 ``` # Notes - You are required to handle the forced recursive calls carefully as the depth of the tree can be significant. Consider alternative iterative methods if necessary. - Ensure the function works efficiently for large trees and complete the transformation within acceptable time limits.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mirror_tree(root: TreeNode) -> None: Mirrors the binary tree in place. if root is None: return # Swap the left and right children root.left, root.right = root.right, root.left # Recursively call the function on the children mirror_tree(root.left) mirror_tree(root.right)"},{"question":"Scenario You are developing a fundamental bitwise arithmetic library for an embedded system where traditional arithmetic operations (`+`, `-`, `*`, `/`) are restricted. Your task is to implement several arithmetic operations using only bitwise operations. Task Write a Python function `add_numbers` that adds two non-negative integers using bitwise operations only. Function Signature ```python def add_numbers(x: int, y: int) -> int: ``` Input - `x` (int): A non-negative integer ( (0 leq x leq 10^9) ) - `y` (int): A non-negative integer ( (0 leq y leq 10^9) ) Output - An integer which is the sum of `x` and `y`. Constraints - You must not use the \'+\' operator. - Your solution should work efficiently for large inputs up to ( 10^9 ). Example ```python assert add_numbers(2, 3) == 5 assert add_numbers(15, 20) == 35 assert add_numbers(0, 7) == 7 assert add_numbers(1000000000, 1000000000) == 2000000000 ```","solution":"def add_numbers(x: int, y: int) -> int: Returns the sum of x and y using bitwise operations only. while y != 0: carry = x & y # Calculate carry x = x ^ y # Calculate sum without carry y = carry << 1 # Shift carry to the correct position return x"},{"question":"# Next Higher Permutation Coding Challenge **Context**: Imagine you are working on a software module that generates the next lexicographical permutation of an integer\'s digits. This is useful in various combinatorial applications and ordering problems. **Task**: Write a function `next_bigger(num: int) -> int` that takes a positive integer `num` and returns the next higher number using the same digits. If no such permutation exists, return `-1`. **Requirements**: - The function should handle numbers in the range from `1` to `10^9`. - The solution should be efficient, aiming for an O(n) time complexity. - Ensure that your code handles edge cases properly. **Input Format**: - A single integer `num` where `1 <= num <= 10^9`. **Output Format**: - A single integer representing the next higher permutation of digits. If no such permutation exists, return `-1`. **Examples**: ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(54321) == -1 assert next_bigger(99999) == -1 assert next_bigger(1528452) == 1528524 assert next_bigger(138654) == 143568 ``` **Constraints**: - You are not allowed to use any external libraries or built-in functions (except for basic data structures like lists) for this task. - Consider the edge cases like single-digit numbers and numbers that are already in their highest permutation form.","solution":"def next_bigger(num): Returns the next lexicographical permutation of the digits of \'num\'. If no such permutation exists, returns -1. # Convert number to list of digits digits = list(str(num)) n = len(digits) # Step 1: Find the largest index k such that digits[k] < digits[k + 1]. If no such index exists, return -1. k = -1 for i in range(n - 1): if digits[i] < digits[i + 1]: k = i if k == -1: return -1 # Step 2: Find the largest index l such that digits[k] < digits[l]. l = -1 for i in range(k + 1, n): if digits[k] < digits[i]: l = i # Step 3: Swap the values of digits[k] and digits[l]. digits[k], digits[l] = digits[l], digits[k] # Step 4: Reverse the sequence from digits[k + 1] up to and including the final element digits[n-1]. digits = digits[:k+1] + digits[k+1:][::-1] return int(\\"\\".join(digits))"},{"question":"# Factorial Calculation with Optimization You are required to implement two functions to calculate the factorial of a non-negative integer `n`, but with optimizations and handling for large inputs where overflow might occur. You should use the module operation to ensure values do not overflow the integer limits. **Function 1**: `optimized_factorial_iter(n, mod=None)` * **Input**: A non-negative integer `n`, and an optional integer `mod`. * **Output**: The factorial of `n` modulo `mod` if mod is provided; otherwise, return the factorial of `n`. * **Constraints**: - `0 <= n <= 10^6` - `1 <= mod <= 10^9` [only if mod is provided] - Performance requirement: The function should handle large `n` efficiently with time complexity O(n). **Function 2**: `optimized_factorial_recur(n, mod=None)` * **Input**: A non-negative integer `n`, and an optional integer `mod`. * **Output**: The factorial of `n` modulo `mod` if mod is provided; otherwise, return the factorial of `n`. * **Constraints**: - `0 <= n <= 10^6` - `1 <= mod <= 10^9` [only if mod is provided] - Performance requirement: The function should handle large `n` efficiently with time complexity O(n) and optimize recursion to handle large inputs without stack overflow. # Example ```python # Example cases: print(optimized_factorial_iter(5)) # Expected Output: 120 print(optimized_factorial_iter(5, 100)) # Expected Output: 20 print(optimized_factorial_recur(5)) # Expected Output: 120 print(optimized_factorial_recur(5, 100)) # Expected Output: 20 ``` Your task is to implement the `optimized_factorial_iter` and `optimized_factorial_recur` functions in Python.","solution":"def optimized_factorial_iter(n, mod=None): Calculate the factorial of a non-negative integer n iteratively. If mod is provided, return the factorial % mod. result = 1 for i in range(2, n + 1): result *= i if mod: result %= mod return result def optimized_factorial_recur(n, mod=None): Calculate the factorial of a non-negative integer n recursively. If mod is provided, return the factorial % mod. def factorial_helper(x, mod): if x == 0 or x == 1: return 1 partial_result = factorial_helper(x - 1, mod) result = x * partial_result if mod: result %= mod return result return factorial_helper(n, mod)"},{"question":"# RSA-Based Unique Identifier Creation You are developing a secure application that generates unique identifiers for users. Each identifier must be encrypted using the RSA algorithm. Requirements: 1. **Key Generation**: - A function that generates RSA keys. - Bit size for keys must be adjustable but should be at least 16 bits. - Public exponent ( e ) must be chosen suitably. By convention, use ( e = 65537 ). 2. **Identifier Encryption**: - A function to encrypt a user ID using the generated RSA public key. 3. **Identifier Decryption**: - A function to decrypt the encrypted identifier using the RSA private key. Expected Inputs and Outputs: 1. **generate_keys(bit_length: int) -> Tuple[int, int, int]** - **Input**: bit_length - an integer (minimum 16) representing the bit size of the RSA key. - **Output**: A tuple (n, e, d) where `n` is the modulus, `e` is the public exponent, and `d` is the private exponent. 2. **encrypt_identifier(user_id: int, e: int, n: int) -> int** - **Input**: user_id - the integer user ID to be encrypted, `e` - public exponent, `n` - modulus. - **Output**: An integer representing the encrypted identifier. 3. **decrypt_identifier(encrypted_id: int, d: int, n: int) -> int** - **Input**: encrypted_id - the encrypted integer identifier, `d` - private exponent, `n` - modulus. - **Output**: The original user ID. Constraints: - Ensure `generate_keys` handles edge cases, and the key size is a minimum of 16 bits. - Encrypt using the public key and decrypt using the private key accurately. - Handle any potential errors gracefully. Example: ```python n, e, d = generate_keys(16) user_id = 12345 encrypted_id = encrypt_identifier(user_id, e, n) decrypted_id = decrypt_identifier(encrypted_id, d, n) assert decrypted_id == user_id ``` Make sure to consider edge cases like small key sizes and ensure prime numbers chosen for keys are valid.","solution":"import random from sympy import isprime, randprime from math import gcd def generate_keys(bit_length: int): if bit_length < 16: raise ValueError(\\"Bit length must be at least 16\\") e = 65537 half_bit_length = bit_length // 2 p = randprime(2 ** (half_bit_length - 1), 2 ** half_bit_length) q = randprime(2 ** (half_bit_length - 1), 2 ** half_bit_length) while p == q: q = randprime(2 ** (half_bit_length - 1), 2 ** half_bit_length) n = p * q phi = (p - 1) * (q - 1) if gcd(e, phi) != 1: raise ValueError(\\"Public exponent e must be coprime with phi\\") d = pow(e, -1, phi) return n, e, d def encrypt_identifier(user_id: int, e: int, n: int) -> int: return pow(user_id, e, n) def decrypt_identifier(encrypted_id: int, d: int, n: int) -> int: return pow(encrypted_id, d, n)"},{"question":"You are required to implement a function `filter_range(arr, min_lim=None, max_lim=None)` that filters elements in an array based on specified minimum and maximum limits. # Input Details: - `arr` (list of integers): The array of integers to be filtered. - `min_lim` (integer or `None`): The lower limit for filtering. If `None`, there is no lower limit. - `max_lim` (integer or `None`): The upper limit for filtering. If `None`, there is no upper limit. # Output Details: - Returns a list of integers containing only the elements in `arr` that are greater than or equal to `min_lim` and less than or equal to `max_lim`. # Constraints: - The function should have a time complexity of O(n). - The space complexity should be O(m), where m is the length of the filtered array. - The input list may be empty, and in such cases, the function should return an empty list. # Performance Requirements: - The function should efficiently handle arrays with lengths up to 10^6. # Examples: ```python # Example 1: arr = [1, 2, 3, 4, 5] min_lim = None max_lim = 3 # Output: [1, 2, 3] # Example 2: arr = [10, 20, 30, 40, 50] min_lim = 15 max_lim = 45 # Output: [20, 30, 40] # Example 3: arr = [5, 3, 8, 1, 2] min_lim = 4 max_lim = None # Output: [5, 8] # Example 4: arr = [] min_lim = 4 max_lim = 10 # Output: [] ``` # Function Signature: ```python def filter_range(arr, min_lim=None, max_lim=None) -> list: pass ``` # Additional Notes: - Make sure to handle cases where the input array is empty or where no elements meet the criteria, returning an empty list in such scenarios.","solution":"def filter_range(arr, min_lim=None, max_lim=None): Filters elements of the input list `arr` such that the elements are >= min_lim and <= max_lim. Parameters: arr (list of int): The list to be filtered. min_lim (int or None): The lower bound for the filtering. max_lim (int or None): The upper bound for the filtering. Returns: list of int: The filtered list of elements. if min_lim is None and max_lim is None: return arr result = [] for num in arr: if min_lim is not None and num < min_lim: continue if max_lim is not None and num > max_lim: continue result.append(num) return result"},{"question":"# Minimum Perfect Squares Objective Write a function `min_perfect_squares(number: int) -> int` that computes the minimum number of perfect squares that sum up to the given integer `number`. Input - An integer `number` (1 ≤ number ≤ 10,000). Output - An integer representing the minimum number (between 1 to 4) of perfect squares that sum to `number`. Scenario You are working on optimizing a mathematical model that needs to decompose values into sums of perfect squares. Implementing this algorithm will help identify the minimum number of perfect squares required, ensuring that the process adheres to the constraints and optimizations from both Lagrange\'s and Legendre’s theorems. This will improve the efficiency of your model. Constraints - 1 ≤ number ≤ 10,000 Examples ```python assert min_perfect_squares(9) == 1 assert min_perfect_squares(10) == 2 assert min_perfect_squares(12) == 3 assert min_perfect_squares(31) == 4 ``` Implement the function in Python: ```python import math def min_perfect_squares(number): Returns the smallest number of perfect squares that sum to the specified number. :return: int between 1 - 4 # If the number is a perfect square then we only need 1 number. if int(math.sqrt(number))**2 == number: return 1 # We check if Legendre\'s three-square theorem holds and divide accordingly. while number > 0 and number % 4 == 0: number /= 4 # If the number is of the form 4^a(8b + 7), it can\'t be expressed as a sum of three (or less) perfect squares. if number % 8 == 7: return 4 # Try to express the number as a sum of 2 perfect squares. for i in range(1, int(math.sqrt(number)) + 1): if int(math.sqrt(number - i**2))**2 == number - i**2: return 2 return 3 ```","solution":"import math def min_perfect_squares(number): Returns the smallest number of perfect squares that sum to the specified number. :return: int between 1 - 4 # If the number is a perfect square then we only need 1 number. if int(math.sqrt(number))**2 == number: return 1 # We check if Legendre\'s three-square theorem holds and divide accordingly. while number % 4 == 0: number //= 4 # If the number is of the form 4^a(8b + 7), it can\'t be expressed as a sum of three (or less) perfect squares. if number % 8 == 7: return 4 # Try to express the number as a sum of 2 perfect squares. for i in range(1, int(math.sqrt(number)) + 1): if int(math.sqrt(number - i**2))**2 == number - i**2: return 2 return 3"},{"question":"**Context**: You are given a list of numbers that requires sorting in ascending order for an upcoming event\'s scheduling task. You need to use the Shell Sort algorithm to sort this list efficiently. **Task**: Implement the Shell Sort algorithm in Python to sort an array of integers in ascending order. **Function Signature**: `def shell_sort(arr: List[int]) -> List[int]:` **Input**: - `arr` : A list of integers where 0 <= len(arr) <= 1000. **Output**: - A list of integers sorted in ascending order. **Constraints**: - The elements in the list can be positive, negative, or zero. - Time complexity should strive to be less than (O(n^2)) on average with an optimized gap sequence. **Performance Requirements**: - Implement an optimized version of Shell Sort with an efficient gap sequence to ensure better performance for larger lists. **Examples**: - `shell_sort([64, 34, 25, 12, 22, 11, 90])` should return `[11, 12, 22, 25, 34, 64, 90]` - `shell_sort([7, -1, 0, 4, 2, 2, 10])` should return `[-1, 0, 2, 2, 4, 7, 10]` - `shell_sort([1])` should return `[1]` - `shell_sort([])` should return `[]`","solution":"from typing import List def shell_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the Shell Sort algorithm. n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"# Problem Description You are tasked with creating a memory game where you have to ensure the function correctly determines if a sequence of operations on a stack results in the stack returning to an empty state. This involves performing a mixture of `push`, `pop`, and `peek` operations on the stack. You will need to implement a function that interacts with the stack and returns a boolean indicating whether the stack ends up empty. # Function Signature ```python def does_stack_end_empty(operations: List[Tuple[str, int]]) -> bool: Determines if a sequence of operations results in the stack being empty. :param operations: A list of tuples, where each tuple contains an operation (\'push\', \'pop\', \'peek\') and an optional integer value (in case of \'push\'). :type operations: List[Tuple[str, int]] :return: True if the stack ends up empty, False otherwise. :rtype: bool ``` # Input * `operations`: List of pairs, where the first element is a string representing the operation (`\'push\'`, `\'pop\'`, or `\'peek\'`), and the second element (if applicable) is an integer to be used with the `\'push\'` operation. # Output * Boolean: Return `True` if the stack is empty after performing all operations, `False` otherwise. # Constraints * You can assume that all operations are valid. * Avoid using Python\'s built-in list methods for stack operations (e.g., append, pop). # Examples ```python assert does_stack_end_empty([(\'push\', 1), (\'push\', 2), (\'pop\', None), (\'pop\', None)]) == True assert does_stack_end_empty([(\'push\', 1), (\'push\', 2), (\'pop\', None), (\'peek\', None)]) == False assert does_stack_end_empty([(\'push\', 1), (\'pop\', None), (\'push\', 2), (\'pop\', None), (\'push\', 3), (\'pop\', None)]) == True ``` # Notes * Implement the stack using either the array-based or linked list-based structure provided above. * Ensure to handle edge cases like popping or peeking from an empty stack. * All operations, including peek, should not leave extraneous elements in the stack.","solution":"def does_stack_end_empty(operations): Determines if a sequence of operations results in the stack being empty. :param operations: A list of tuples, where each tuple contains an operation (\'push\', \'pop\', \'peek\') and an optional integer value (in case of \'push\'). :return: True if the stack ends up empty, False otherwise. stack = [] for operation in operations: op, value = operation if op == \'push\': stack.append(value) elif op == \'pop\': # Pop from the stack if there\'s something in it if stack: stack.pop() elif op == \'peek\': # Peek doesn\'t change the stack size; just ignore if stack: stack[-1] return len(stack) == 0"},{"question":"# Palindrome Check Algorithm A palindrome is a string that reads the same forward and backward, considering only alphanumeric characters and ignoring case differences. You are provided with several variants to check if a string is a palindrome. Your task is to implement one of these variants efficiently. # Objective Write a function `is_palindrome_variant` that determines if a given string is a palindrome using the two-pointer technique. This function should preprocess the input string to remove any non-alphanumeric characters and convert all letters to lowercase. # Function Signature ```python def is_palindrome_variant(s: str) -> bool: ``` # Input * `s` (string): The input string containing printable ASCII characters. # Output * Return `True` if `s` is a palindrome; otherwise, return `False`. # Constraints * The string length will be at most `10^5`. # Example ```python assert is_palindrome_variant(\\"A man, a plan, a canal: Panama\\") == True assert is_palindrome_variant(\\"race a car\\") == False assert is_palindrome_variant(\\"\\") == True assert is_palindrome_variant(\\" \\") == True ``` # Implementation Details 1. **Preprocessing**: Ignore non-alphanumeric characters and convert all letters to lowercase. 2. **Two-pointer Technique**: Use two pointers to compare characters from the start and end of the sanitized string: - If characters at pointers do not match, return `False`. - Increment the left pointer and decrement the right pointer. 3. **Return**: If all characters match, return `True`.","solution":"def is_palindrome_variant(s: str) -> bool: Determines if a given string is a valid palindrome by ignoring non-alphanumeric characters and case differences. Uses the two-pointer technique for the check. # Filter out non-alphanumeric characters and convert to lowercase filtered_s = \'\'.join(char.lower() for char in s if char.isalnum()) # Initialize two pointers left, right = 0, len(filtered_s) - 1 # Use two-pointer technique to check for palindrome while left < right: if filtered_s[left] != filtered_s[right]: return False left += 1 right -= 1 return True"},{"question":"Context You are tasked with implementing a sorting algorithm that efficiently handles small datasets or datasets that are nearly sorted. Given your knowledge of various sorting algorithms, you decide to use Insertion Sort for this task due to its competitive performance in such scenarios. Task Implement the function `custom_insertion_sort` that sorts an array of integers in non-decreasing order using the insertion sort algorithm. Additionally, implement a feature that allows the function to print the state of the array after each insertion operation (for simulation purposes). Requirements 1. **Function Signature**: ```python def custom_insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` 2. **Input**: - `arr`: A list of integers `arr` where (1 ≤ len(arr) ≤ 1000). - `simulation`: A boolean flag. If true, the function should print the state of the array after each iteration of the outer loop. Otherwise, it should not print anything. 3. **Output**: - Returns the sorted list of integers `arr` in non-decreasing order. 4. **Constraints**: - The function should perform the sorting in-place and must not use Python\'s built-in sort functions. - The simulation output should display the current state of the array at each major step. Example ```python arr = [4, 3, 2, 10, 12, 1, 5, 6] custom_insertion_sort(arr, simulation=True) # Expected Output: # iteration 0: 4 3 2 10 12 1 5 6 # iteration 1: 3 4 2 10 12 1 5 6 # iteration 2: 2 3 4 10 12 1 5 6 # iteration 3: 2 3 4 10 12 1 5 6 # iteration 4: 2 3 4 10 12 1 5 6 # iteration 5: 1 2 3 4 10 12 5 6 # iteration 6: 1 2 3 4 5 10 12 6 # iteration 7: 1 2 3 4 5 6 10 12 ``` Your task is to write the `custom_insertion_sort` function according to the specifications to correctly sort the array and optionally simulate the sorting process.","solution":"from typing import List def custom_insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts an array of integers in non-decreasing order using the insertion sort algorithm. If simulation is True, prints the state of the array after each insertion operation. Arguments: arr -- A list of integers to be sorted. simulation -- A boolean flag to print the state of the array after each iteration. Returns: A sorted list of integers in non-decreasing order. for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\\"iteration {i}: {\' \'.join(map(str, arr))}\\") return arr"},{"question":"**Problem Statement**: You are given the task to implement a transitive closure calculation for a directed graph. A transitive closure of a directed graph is a reachability matrix where if there is a path from vertex `i` to vertex `j`, the cell `(i, j)` in the matrix should be `1`, otherwise `0`. You need to complete the implementation of the `Graph` class by writing the `transitive_closure` method which uses Depth First Search (DFS) to create the reachability matrix. The class and its methods are already outlined to give you the structure needed. **Function Format**: ```python def transitive_closure(self) -> List[List[int]]: \'\'\' self: instance of Graph class containing vertices count, adjacency list, and initial closure matrix. return: 2D list of integers with 1 or 0 marking reachability. \'\'\' # Implement logic here ``` **Input**: - The class `Graph` has the following parameters and methods: - `__init__(self, vertices: int)`: Initializes a graph with the number of vertices. - `add_edge(self, source: int, target: int)`: Adds a directed edge from `source` to `target`. - `dfs_util(self, source: int, target: int)`: Helper function to perform recursive DFS and update the closure matrix. **Output**: - `transitive_closure()`: This method should return a 2D list representing the transitive closure matrix. **Constraints**: - 1 <= vertices <= 1000 - 0 <= source, target < vertices - The graph may have self loops and multiple edges. **Example**: ```python # Creating a graph instance graph = Graph(4) graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(2, 3) # Finding transitive closure closure = graph.transitive_closure() print(closure) # Output should reflect the reachability matrix ``` The expected reachability matrix will be: ``` [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1] ] ``` Consider edge cases such as graphs with no connections, self loops, or multiple edges while implementing your solution.","solution":"class Graph: def __init__(self, vertices: int): self.vertices = vertices self.adjacency_list = [[] for _ in range(vertices)] self.closure = [[0]*vertices for _ in range(vertices)] def add_edge(self, source: int, target: int): self.adjacency_list[source].append(target) def dfs_util(self, source: int, target: int): # Perform DFS from source to update closure[source][...] self.closure[source][target] = 1 for neighbour in self.adjacency_list[target]: if self.closure[source][neighbour] == 0: self.dfs_util(source, neighbour) def transitive_closure(self): # Initialize closure[i][i] = 1 for all i for i in range(self.vertices): self.closure[i][i] = 1 self.dfs_util(i, i) # For each vertex use dfs_util to fill reachability matrix. for i in range(self.vertices): self.dfs_util(i, i) return self.closure"},{"question":"Design a function `binomial_coefficient` to calculate the binomial coefficient ( C(n, k) ) (also known as \\"n choose k\\") in an iterative manner that avoids pitfalls associated with recursion stack overflow. The function should adhere to the following specification: Function Signature ```python def binomial_coefficient(n: int, k: int) -> int: ``` Input * `n` (int): Number of items to choose from. * `k` (int): Number of items to choose. * Both inputs are non-negative integers where ( 0 leq k leq n ). Output * Returns the binomial coefficient ( C(n, k) ) as an integer. Constraints * ( 0 leq k leq n leq 10^6 ) * Optimize for time efficiency. * Avoid recursion to handle large values of `n` and `k`. Examples ```python assert binomial_coefficient(5, 0) == 1 assert binomial_coefficient(8, 2) == 28 assert binomial_coefficient(10, 5) == 252 assert binomial_coefficient(500, 300) > 0 # Value is extremely large but should be computed efficiently ``` # Scenario Suppose you are working on a project that involves a large dataset where you need to calculate combinatorial probabilities efficiently. The recursive method might lead to stack overflow and is not feasible. You need to implement an iterative method to compute these values quickly without running into performance or memory issues. Write a function that can handle this task efficiently.","solution":"def binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient C(n, k) iteratively. if k > n - k: # Take advantage of symmetry, C(n, k) == C(n, n-k) k = n - k if k == 0: return 1 c = 1 for i in range(k): c = c * (n - i) // (i + 1) return c"},{"question":"You\'re given an array of integers and need to create a data structure that allows efficient updates and prefix sum queries on the array. Implement a Fenwick Tree (Binary Indexed Tree) to support the following operations: 1. `update(index, value)`: Update the element at the specified index by adding the given value. This should be done in O(log n) time. 2. `get_sum(index)`: Retrieve the sum of elements from the start of the array up to the specified index. This should be done in O(log n) time. # Constraints * The maximum size of the array (n) can be up to 10^5. * Each element in the array can be an integer between -10^9 and 10^9. * There will be at most 10^5 operations. # Input Format 1. An integer n denoting the size of the array. 2. An array of n integers representing the initial element values. 3. A series of operations, each can be in one of the following forms: * `update index value` - Update the element at `index` by adding `value`. * `get_sum index` - Retrieve the sum of elements from the start of the array up to `index`. # Output Format For each `get_sum` operation, output the result on a new line. # Example Input: ``` 5 1 2 3 4 5 update 1 3 get_sum 3 update 3 -2 get_sum 3 ``` Expected Output: ``` 13 11 ``` In the example above: - After the first update operation, the array becomes `[1, 5, 3, 4, 5]`. - The first `get_sum` operation sums up the first four elements: `1 + 5 + 3 + 4 = 13`. - After the second update operation, the array becomes `[1, 5, 3, 2, 5]`. - The second `get_sum` operation sums up the first four elements: `1 + 5 + 3 + 2 = 11`. **Note**: Remember to handle 1-based index adjustments internally in the Fenwick Tree implementation.","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, value): while index <= self.size: self.tree[index] += value index += index & -index def get_sum(self, index): result = 0 while index > 0: result += self.tree[index] index -= index & -index return result def initialize_fenwick_tree(arr): n = len(arr) fenwick_tree = FenwickTree(n) for i in range(n): fenwick_tree.update(i + 1, arr[i]) return fenwick_tree"},{"question":"Distinct Ways to Reach a Destination Scenario: You are a product manager responsible for ensuring smooth user experience in a stairs navigation application. Users can climb either 1 or 2 steps at a time. Your task is to determine the number of distinct ways to reach the top of a stair case with a given number of steps. Instructions: Write a function `distinct_ways_to_top(steps)` that takes an integer `steps` and returns the number of distinct ways to reach the exact step `steps`. Function Signature: ```python def distinct_ways_to_top(steps: int) -> int: pass ``` Input: * `steps` (1 <= steps <= 1000): An integer representing the number of steps in the staircase. Output: * Return an integer representing the number of distinct ways to reach the top. Constraints: * You can only climb 1 or 2 steps at a time. * Optimize for both time and space complexity. Example: 1. Input: `steps = 2` - Output: `2` - Explanation: There are two ways to climb to the top: (1 + 1) or (2). 2. Input: `steps = 3` - Output: `3` - Explanation: There are three ways to climb to the top: (1 + 1 + 1), (1 + 2), and (2 + 1). 3. Input: `steps = 4` - Output: `5` Notes: * Consider edge cases where `steps = 1` and `steps = 2` to ensure your function handles them correctly. * Your implementation should be efficient and make use of space optimization strategies where possible.","solution":"def distinct_ways_to_top(steps: int) -> int: Returns the number of distinct ways to reach the exact step `steps`. if steps == 1: return 1 if steps == 2: return 2 first = 1 second = 2 for _ in range(3, steps + 1): current = first + second first = second second = current return second"},{"question":"You are tasked with implementing a part of a navigation system for a map application. This navigation system frequently needs to handle inserting, deleting, and accessing locations as users interact with their routes. To efficiently manage such operations, you decide to use a doubly linked list. # Task: Implement a `DoublyLinkedList` class with the following functionalities: 1. **Insert a new node at the beginning**: `insert_at_beginning(value)` 2. **Insert a new node at the end**: `insert_at_end(value)` 3. **Delete a node by value**: `delete_value(value)` 4. **Search for a value**: `search(value)` should return the index (0-based) of the first occurrence of the value, or -1 if the value is not found. 5. **Display the list**: `display()` should print all the values in the list from the head to the tail. # Input and Output: * The methods `insert_at_beginning` and `insert_at_end` take an integer value to add to the list and do not return anything. * The method `delete_value` takes an integer value to remove from the list. If the value is found and deleted, it should return `True`; otherwise, if the value is not found, it should return `False`. * The method `search` takes an integer value and returns the 0-based index of its first occurrence or -1 if the value is not found. * The `display` method prints the current list in a space-separated string format. # Constraints: * All values in the list will be integers. * Assume the list size can grow dynamically as needed. * You can assume proper usage of the list by a calling environment (i.e., an attempt to delete element from an empty list should just return `False`). # Example: ```python dll = DoublyLinkedList() dll.insert_at_end(5) dll.insert_at_beginning(3) dll.insert_at_beginning(1) dll.insert_at_end(7) dll.display() # Output: \\"1 3 5 7\\" print(dll.search(5)) # Output: 2 print(dll.delete_value(3)) # Output: True dll.display() # Output: \\"1 5 7\\" print(dll.delete_value(42)) # Output: False ```","solution":"class Node: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_beginning(self, value): new_node = Node(value) if self.head is None: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_end(self, value): new_node = Node(value) if self.tail is None: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_value(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return True current = current.next return False def search(self, value): current = self.head index = 0 while current: if current.value == value: return index current = current.next index += 1 return -1 def display(self): output = [] current = self.head while current: output.append(str(current.value)) current = current.next print(\\" \\".join(output))"},{"question":"You are required to extend the `DirectedGraph` class to include a method called `detect_cycle` that will check if the graph contains any cycles. A cycle in a directed graph is a path that starts and ends at the same node, traversing through other nodes at least once in between. # Function Signature: ```python class DirectedGraph: ... def detect_cycle(self) -> bool: Returns True if there is a cycle in the graph, otherwise returns False. ``` # Input/Output Formats: * **Input**: The method `detect_cycle` takes no parameters. * **Output**: The method should return a boolean value (`True` or `False`). # Constraints: * Consider graphs with up to 10,000 nodes and 50,000 edges. * Node names are represented as strings (unique identifiers). * No need to consider disconnected graphs. # Performance Requirements: - The implementation should be efficient with time complexity of O(V + E), where V is the number of vertices (nodes) and E is the number of edges. - Space complexity should be kept at O(V). # Example: ```python load_dict = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"] } graph = DirectedGraph(load_dict) print(graph.detect_cycle()) # Output: True load_dict = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"D\\"], \\"D\\": [] } graph = DirectedGraph(load_dict) print(graph.detect_cycle()) # Output: False ``` # Notes: 1. Use Depth First Search (DFS) to traverse the graph and detect cycles. 2. Ensure that all nodes are visited to account for separate components in the graph. 3. Utilize an auxiliary stack or recursion stack to track nodes in the current path during DFS.","solution":"class DirectedGraph: def __init__(self, graph_dict=None): if graph_dict is None: graph_dict = {} self.graph_dict = graph_dict def detect_cycle(self) -> bool: visited = set() rec_stack = set() def dfs(node): if node not in visited: visited.add(node) rec_stack.add(node) for neighbour in self.graph_dict.get(node, []): if neighbour not in visited and dfs(neighbour): return True elif neighbour in rec_stack: return True rec_stack.remove(node) return False for node in self.graph_dict: if dfs(node): return True return False"},{"question":"# Prime Check Algorithm: Advanced Implementation and Use Case You are an intern at a cryptography company and have been tasked with implementing a robust and efficient function to check if a number is prime. This function will be used in various encryption algorithms, where the efficiency and correctness of primality testing are crucial. Problem Statement Write a function `is_prime(n)` that determines if the given integer `n` is a prime number. To achieve this, your implementation must: 1. Handle the basic checks for numbers less than or equal to 3. 2. Efficiently handle larger numbers by checking potential factors up to the square root of `n`. However, in addition to the standard implementation, your function should also consider additional algorithmic improvements: * Implement a safeguard for very large inputs to avoid performance pitfalls. * Ensure the function maintains O(√n) complexity and O(1) space complexity. Input and Output Format * **Input**: `n` (an integer within the range 1 ≤ `n` ≤ 10^12). * **Output**: Return `True` if `n` is prime, otherwise `False`. Constraints * The function must complete within a reasonable time for the upper constraint of `n` = 10^12. Function Signature ```python def is_prime(n: int) -> bool: pass ``` Example ```python print(is_prime(1)) # Output: False print(is_prime(2)) # Output: True print(is_prime(4)) # Output: False print(is_prime(29)) # Output: True print(is_prime(10**12)) # Output: False ``` Performance Requirements While correctness is paramount, the function must also operate efficiently for very large values close to the upper limit of the input range. Optimizations that help handle such cases, while not strictly necessary for correctness, will be highly valued. Edge Cases to Consider * `n` <= 1 should return `False`. * Small primes (2 and 3) should be identified correctly. * Large non-primes and primes must be handled within the constraint limits efficiently. Implement the `is_prime(n)` function in Python as described above.","solution":"def is_prime(n: int) -> bool: Determine if the given integer n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Question You are given an undirected graph represented as an adjacency matrix. Your task is to determine if this graph is bipartite. As a reminder, a bipartite graph is one where you can divide the set of vertices into two disjoint sets such that no two graph vertices within the same set are adjacent. # Input - An integer `n`: the number of vertices. - An `n x n` matrix `adj_matrix` where `adj_matrix[i][j] = 1` indicates an edge between vertex `i` and vertex `j`, and `adj_matrix[i][j] = 0` otherwise. # Output - A boolean value `True` if the graph is bipartite. - A boolean value `False` if the graph is not bipartite. # Constraints - 1 <= n <= 1000 - The graph does not contain parallel edges. # Example ```python Input: 3 [[0, 1, 0], [1, 0, 1], [0, 1, 0]] Output: True Input: 3 [[0, 1, 1], [1, 0, 1], [1, 1, 0]] Output: False ``` # Requirements - Your solution should attempt to solve the problem using BFS. - The function should be efficient, considering the time and space constraints.","solution":"from collections import deque def is_bipartite(n, adj_matrix): Determines if the given graph is bipartite. :param n: The number of vertices :param adj_matrix: The adjacency matrix of the graph :return: True if the graph is bipartite, False otherwise # Color array to store colors assigned to all vertices. # -1 indicates that the vertex has not been colored yet color = [-1] * n def bfs_check(start): queue = deque([start]) color[start] = 0 # Start coloring with 0 while queue: v = queue.popleft() for u in range(n): if adj_matrix[v][u] == 1: # There\'s an edge if color[u] == -1: # If the vertex is not colored color[u] = 1 - color[v] # Assign alternate color to this adjacent queue.append(u) elif color[u] == color[v]: # If adjacent vertex has the same color return False return True # Check all components of the graph for i in range(n): if color[i] == -1: # If the vertex is not colored, process it if not bfs_check(i): return False return True"},{"question":"# Scenario Your team is developing a script that needs to handle multiple file paths, requiring all to be in absolute format for further use. To achieve this, you need an efficient utility function that converts any type of relative path, including ones with user home shortcuts, to their corresponding absolute paths. In the process, you\'re expected to account for user inputs that might include home directory shortcuts, relative paths, and edge cases like non-existent directories. # Task Implement a function `convert_to_absolute_path(path: str) -> str` that takes a given path as input and returns its corresponding absolute path. # Input - `path` (str): A string representing the file path, which could be a relative path or include home directory shortcuts like `~`. # Output - Returns a string representing the absolute path. # Constraints - Avoid using any third-party libraries; you should use only Python\'s standard library. - Assume input paths are given in a valid format (string). # Performance Requirements - The function should be efficient and handle typical paths encountered in file systems gracefully. # Example ```python def convert_to_absolute_path(path: str) -> str: # Your implementation here # Example Usage print(convert_to_absolute_path(\\"~/documents/project\\")) # Output: \\"/home/user/documents/project\\" assuming \\"/home/user\\" is the home directory. ```","solution":"import os def convert_to_absolute_path(path: str) -> str: Converts the given path to an absolute path. return os.path.abspath(os.path.expanduser(path))"},{"question":"**Problem Statement:** Design and implement a Python class named `RandomizedSetExtended` which extends the capabilities of the `RandomizedSet` by adding the following functionalities while maintaining an average O(1) time complexity for each operation: 1. **insert(val)**: Inserts an item `val` to the set if not already present. Returns `True` if the item was not present and `False` otherwise. 2. **remove(val)**: Removes an item `val` from the set if present. Returns `True` if the item was present and successfully removed, `False` otherwise. 3. **get_random()**: Returns a random element from the current set of elements. Each element must have the same probability of being returned. 4. **get_all_elements()**: Returns all the current elements in the set as a list in O(n). 5. **size()**: Returns the number of elements in the set in O(1). # Function Signature: ```python class RandomizedSetExtended: def __init__(self): ... def insert(self, val: int) -> bool: ... def remove(self, val: int) -> bool: ... def get_random(self) -> int: ... def get_all_elements(self) -> list: ... def size(self) -> int: ... ``` # Example Usage: ```python rs = RandomizedSetExtended() print(rs.insert(1)) # Returns True print(rs.insert(2)) # Returns True print(rs.insert(3)) # Returns True print(rs.insert(2)) # Returns False, already present print(rs.get_all_elements()) # Returns [1, 2, 3] print(rs.size()) # Returns 3 print(rs.remove(3)) # Returns True print(rs.get_all_elements()) # Returns [1, 2] print(rs.remove(3)) # Returns False, already removed print(rs.size()) # Returns 2 print(rs.get_random()) # Returns 1 or 2 randomly ``` # Constraints: * The values will be in the range of -10^6 to 10^6. * At most 10^5 operations will be performed. Ensure that your implementation handles all edge cases effectively, including operations on an empty set and appropriate ordering of updates for maintaining O(1) complexity.","solution":"import random class RandomizedSetExtended: def __init__(self): self.elem_index_map = {} self.elements = [] def insert(self, val: int) -> bool: if val in self.elem_index_map: return False self.elem_index_map[val] = len(self.elements) self.elements.append(val) return True def remove(self, val: int) -> bool: if val not in self.elem_index_map: return False last_element = self.elements[-1] idx_to_remove = self.elem_index_map[val] self.elements[idx_to_remove] = last_element self.elem_index_map[last_element] = idx_to_remove self.elements.pop() del self.elem_index_map[val] return True def get_random(self) -> int: return random.choice(self.elements) def get_all_elements(self) -> list: return self.elements[:] def size(self) -> int: return len(self.elements)"},{"question":"# Question: Implement Enhanced Radix Sort **Objective**: Write a function to perform radix sort on a list of non-negative integers. Your implementation should include error handling for common edge cases and be optimized for performance. **Function Signature**: ```python def enhanced_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` **Input**: * `arr` (List[int]): A list of non-negative integers. * `simulation` (bool, default=False): If set to True, the function should print the internal state of the array after each digit position sorting pass. **Output**: * (List[int]): The list sorted in ascending order. **Constraints**: * Each integer in the list is non-negative. * The list can be empty. * The function should handle lists with duplicated numbers. **Scenario**: * Assume we have the following list of integers: `[170, 45, 75, 90, 802, 24, 2, 66]` * Sorting these integers using `enhanced_radix_sort` should return `[2, 24, 45, 66, 75, 90, 170, 802]`. * When the `simulation` parameter is set to `True`, the function prints intermediate sorting steps, providing insight into the process. **Edge Cases**: * Empty list should return an empty list. * A list with a single element should return the same single-element list. * A list where all elements are the same should return the same list. **Performance Considerations**: * Your implementation should minimize additional memory usage and aim for efficient runtime performance. **Example**: ```python assert enhanced_radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert enhanced_radix_sort([170, 45, 75, 90, 802, 24, 2, 66], simulation=True) == [2, 24, 45, 66, 75, 90, 170, 802] ``` Implement the function `enhanced_radix_sort` and ensure it passes the given test cases.","solution":"from typing import List def enhanced_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if not arr: return [] def counting_sort(exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(n): arr[i] = output[i] if simulation: print(f\\"After sorting on exp {exp}: {arr}\\") max1 = max(arr) exp = 1 while max1 // exp > 0: counting_sort(exp) exp *= 10 return arr"},{"question":"Context: A local shop wants to analyze the sales of their items. They maintain a list of sold products each day, and each product is represented by its unique ID. To get insights into the demand for each product, they want a frequency distribution of the sold items using a histogram. Task: Write a Python function `get_sales_histogram(sales_list: list) -> dict` that takes in a list of product IDs sold during the day and returns a histogram, which is a dictionary where the keys are product IDs and the values are their respective counts in the list. Input: * `sales_list` (list): A list of integers representing sold product IDs. The list can be empty. Output: * A dictionary where keys are product IDs and values denote the number of times each product was sold. Constraints: * Each item in the list is a non-negative integer. * You should handle the list efficiently, even if it contains repeated items. The maximum size of the list can be up to 10^6. Example: ```python sales_list_1 = [101, 101, 102, 103] # Expected output: {101: 2, 102: 1, 103: 1} sales_list_2 = [105, 106, 106, 107, 108, 106, 109] # Expected output: {105: 1, 106: 3, 107: 1, 108: 1, 109: 1} ``` Performance Requirements: * Your implementation should run in O(n) time complexity and utilize O(k) space complexity, where n is the number of sales records and k is the number of unique product IDs. # Function Signature: ```python def get_sales_histogram(sales_list: list) -> dict: pass ```","solution":"def get_sales_histogram(sales_list: list) -> dict: Generates a histogram from the sales list. Args: sales_list (list): A list of integers representing sold product IDs. Returns: dict: A dictionary where keys are product IDs and values denote the number of times each product was sold. histogram = {} for item in sales_list: if item in histogram: histogram[item] += 1 else: histogram[item] = 1 return histogram"},{"question":"# Context You are tasked with developing a utility for data preprocessing. A critical requirement is to limit the frequency of elements in a list while preserving their order. # Problem Statement Write a function `delete_nth(array: List[int], n: int) -> List[int]` that takes a list of integers `array` and an integer `n`. Your function should return a new list that retains each number no more than `n` times, maintaining the original order. If (n leq 0), the function should return an empty list. # Function Signature ```python def delete_nth(array: List[int], n: int) -> List[int]: ``` # Input - `array`: A list of integers. Example: `[1, 2, 3, 1, 2, 1, 2, 3]` - `n`: An integer specifying the maximum number of occurrences allowed for each element. Example: `2` # Output - A list of integers from the input list, trimmed according to the specified number of occurrences. Example: `[1, 2, 3, 1, 2, 3]` # Constraints - The elements in `array` can be negative, zero, or positive integers. - The length of `array` will be in the range (0 leq text{len(array)} leq 10^6). - (n) is a non-negative integer. # Examples ```python assert delete_nth([1, 2, 3, 1, 2, 1, 2, 3], 2) == [1, 2, 3, 1, 2, 3] assert delete_nth([20, 37, 20, 21], 1) == [20, 37, 21] assert delete_nth([], 2) == [] assert delete_nth([1, 1, 1, 1], 0) == [] ``` # Notes - Ensure that your implementation is efficient in terms of time complexity. - Pay attention to edge cases such as an empty list and large `n`.","solution":"from typing import List from collections import defaultdict def delete_nth(array: List[int], n: int) -> List[int]: Limits the frequency of elements in the array to no more than n times, preserving order. If n <= 0, returns an empty list. :param array: List of integers from which to limit the occurrences. :param n: Maximum number of occurrences allowed for each integer. :return: A new list with limited occurrences of elements. if n <= 0: return [] result = [] counts = defaultdict(int) for element in array: if counts[element] < n: result.append(element) counts[element] += 1 return result"},{"question":"# Diffie-Hellman Key Exchange Implementation You are to implement a secure key exchange using the Diffie-Hellman protocol. Given a large prime number ( p ) and its primitive root ( a ), write a function that simulates the key exchange process between two parties, Alice and Bob. Your implementation should adhere to the following constraints and requirements: Function Signature ```python def diffie_hellman_key_exchange(a: int, p: int, verbose: bool=False) -> bool: Perform Diffie-Hellman key exchange between Alice and Bob. Parameters: a (int): Primitive root of p. p (int): A large prime number. verbose (bool): Optional; if set to True, print key exchange process details. Returns: bool: True if the key exchange is successful and shared keys match, False otherwise. ``` Requirements: 1. **Having a large prime number ( p ) and its primitive root ( a )**: - Validate ( p ) using a prime check. - Ensure ( a ) is a primitive root of ( p ). 2. **Key Generation**: - Alice and Bob each generate their private keys. - Compute their public keys from their respective private keys. 3. **Key Exchange**: - Compute the shared keys using the exchanged public keys. 4. **Output**: - Return `True` if the shared keys match, otherwise `False`. 5. **Constraints**: - ( 3 leq a, p leq 10^9 ), ensure efficient algorithms to handle large ( p ). 6. **Verbose Mode** (Optional): - When `verbose` is `True`, print the following details: - Alice\'s private key. - Alice\'s public key. - Bob\'s private key. - Bob\'s public key. - Shared key computed by Alice. - Shared key computed by Bob. Use the provided template as a starting point for your function implementation: ```python import math from random import randint def prime_check(num): if num <= 1: return False if num == 2 or num == 3: return True if num % 2 == 0 or num % 3 == 0: return False j = 5 while j * j <= num: if num % j == 0 or num % (j + 2) == 0: return False j += 6 return True def euler_totient(n): result = n for i in range(2, int(n ** 0.5) + 1): if n % i == 0: while n % i == 0: n //= i result -= result // i if n > 1: result -= result // n return result def find_order(a, n): if math.gcd(a, n) != 1: return -1 for i in range(1, n): if pow(a, i) % n == 1: return i return -1 def find_primitive_root(n): if n == 1: return [0] phi = euler_totient(n) p_root_list = [] for i in range (1, n): if math.gcd(i, n) != 1: continue order = find_order(i, n) if order == phi: p_root_list.append(i) return p_root_list def diffie_hellman_key_exchange(a, p, verbose=False): if prime_check(p) is False: return False try: find_primitive_root(p).index(a) except ValueError: return False a_pr_k = randint(1, p-1) a_pu_k = pow(a, a_pr_k, p) b_pr_k = randint(1, p-1) b_pu_k = pow(a, b_pr_k, p) if verbose: print(f\\"Alice\'s private key: {a_pr_k}\\") print(f\\"Alice\'s public key: {a_pu_k}\\") print(f\\"Bob\'s private key: {b_pr_k}\\") print(f\\"Bob\'s public key: {b_pu_k}\\") a_sh_k = pow(b_pu_k, a_pr_k, p) b_sh_k = pow(a_pu_k, b_pr_k, p) return a_sh_k == b_sh_k ``` **Sample Input** ```python a = 5 p = 23 verbose = True ``` **Sample Output** ``` Alice\'s private key: 6 Alice\'s public key: 8 Bob\'s private key: 15 Bob\'s public key: 19 Shared key calculated by Alice = 2 Shared key calculated by Bob = 2 True ```","solution":"import math from random import randint def prime_check(num): if num <= 1: return False if num == 2 or num == 3: return True if num % 2 == 0 or num % 3 == 0: return False j = 5 while j * j <= num: if num % j == 0 or num % (j + 2) == 0: return False j += 6 return True def euler_totient(n): result = n for i in range(2, int(n ** 0.5) + 1): if n % i == 0: while n % i == 0: n //= i result -= result // i if n > 1: result -= result // n return result def find_order(a, n): if math.gcd(a, n) != 1: return -1 for i in range(1, n): if pow(a, i) % n == 1: return i return -1 def find_primitive_root(n): if n == 1: return [0] phi = euler_totient(n) p_root_list = [] for i in range (1, n): if math.gcd(i, n) != 1: continue order = find_order(i, n) if order == phi: p_root_list.append(i) return p_root_list def diffie_hellman_key_exchange(a, p, verbose=False): if prime_check(p) is False: return False try: find_primitive_root(p).index(a) except ValueError: return False a_pr_k = randint(1, p-1) a_pu_k = pow(a, a_pr_k, p) b_pr_k = randint(1, p-1) b_pu_k = pow(a, b_pr_k, p) if verbose: print(f\\"Alice\'s private key: {a_pr_k}\\") print(f\\"Alice\'s public key: {a_pu_k}\\") print(f\\"Bob\'s private key: {b_pr_k}\\") print(f\\"Bob\'s public key: {b_pu_k}\\") a_sh_k = pow(b_pu_k, a_pr_k, p) b_sh_k = pow(a_pu_k, b_pr_k, p) return a_sh_k == b_sh_k"},{"question":"# Problem: Implement Rabin-Karp Substring Search with Custom Base and Modulus Given the **Rabin-Karp Algorithm** implementation, enhance it by adding the ability to specify a **base** and **modulus** values for the hash function. This adjustment is often necessary to handle larger alphabets and to better manage hash collisions. You are required to: 1. Implement a modified **RollingHash** class to accept a `base` and `modulus` values. 2. Adapt the `rabin_karp` function to use the new `RollingHash` class. Function Signature: ```python class RollingHash: def __init__(self, text: str, size_word: int, base: int, modulus: int): # your implementation def move_window(self): # your implementation def window_text(self) -> str: # your implementation def rabin_karp(word: str, text: str, base: int, modulus: int) -> int: # your implementation ``` Input: - `word`: A string representing the pattern to search for. - `text`: A string representing the text to search within. - `base`: An integer representing the base for the hash function. - `modulus`: An integer representing the modulus for the hash function. Output: - Return the starting index of the first occurrence of the pattern in the text, or `None` if the pattern is not found. Example: ```python text = \\"abacabadabacaba\\" word = \\"abac\\" base = 256 modulus = 101 result = rabin_karp(word, text, base, modulus) # Expected output: 0 ``` Constraints: - The text and pattern consist of lowercase English letters only. - The base and modulus values are positive integers.","solution":"class RollingHash: def __init__(self, text: str, size_word: int, base: int, modulus: int): self.text = text self.size_word = size_word self.base = base self.modulus = modulus self.hash = 0 self.window_start = 0 for i in range(size_word): self.hash = (self.hash * base + ord(text[i])) % modulus self.base_l = pow(base, size_word - 1, modulus) def move_window(self): start_char = self.text[self.window_start] new_char = self.text[self.window_start + self.size_word] self.hash = (self.hash - ord(start_char) * self.base_l) % self.modulus self.hash = (self.hash * self.base + ord(new_char)) % self.modulus self.window_start += 1 def window_text(self) -> str: return self.text[self.window_start:self.window_start + self.size_word] def rabin_karp(word: str, text: str, base: int, modulus: int) -> int: if len(word) > len(text): return None rolling_hash = RollingHash(text, len(word), base, modulus) word_hash = 0 for char in word: word_hash = (word_hash * base + ord(char)) % modulus for i in range(len(text) - len(word) + 1): if rolling_hash.hash == word_hash: if rolling_hash.window_text() == word: return i if i < len(text) - len(word): rolling_hash.move_window() return None"},{"question":"# Problem: Longest Substring Without Repeating Characters Given a string `s`, find the length and the value of the longest substring without repeating characters. Implement a function with the following signature: ```python def longest_substring(s: str) -> tuple: This function takes a string input and returns a tuple containing: - The length of the longest substring without repeating characters - The longest substring without repeating characters Example: longest_substring(\\"abcabcbb\\") returns (3, \\"abc\\") longest_substring(\\"bbbbb\\") returns (1, \\"b\\") longest_substring(\\"pwwkew\\") returns (3, \\"wke\\") Constraints: - Input string length should be between 0 and 100,000. - Only English letters, digits, symbols, and spaces are considered. - The output should maintain the first encountered maximum length substring in case of ties. Performance requirements: - Implement the function with a time complexity of O(n). - Use additional data structures within space complexity of O(n). Edge Cases: - Empty string. - String with all identical characters. - String with all unique characters. pass ``` # Context You are working on a text editor\'s autocomplete feature and need to ensure it suggests words or phrases without duplicating the same character in its current selection. The longest substring found, without repeating characters, will help in determining such suggestions efficiently. # Constraints & Requirements 1. **Input Format**: A single string `s`. 2. **Output Format**: A tuple with two elements: - An integer which is the length of the longest substring without repeating characters. - A string which is the longest substring without repeating characters. 3. **Constraints**: - The length of the string is between 0 and 100,000. - The string contains only printable English letters, digits, symbols, and spaces. # Evaluation Your solution will be evaluated based on: - Correctness: Ensure it correctly identifies the longest substring without repeat characters. - Efficiency: Maintain linear time complexity, O(n). - Handle edge cases gracefully (e.g., empty string, all characters identical). # Example Test Cases 1. `longest_substring(\\"abcabcbb\\")` should return `(3, \\"abc\\")`. 2. `longest_substring(\\"bbbbb\\")` should return `(1, \\"b\\")`. 3. `longest_substring(\\"pwwkew\\")` should return `(3, \\"wke\\")`. 4. `longest_substring(\\"\\")` should return `(0, \\"\\")`. 5. `longest_substring(\\"a\\")` should return `(1, \\"a\\")`.","solution":"def longest_substring(s: str) -> tuple: n = len(s) if n == 0: return 0, \\"\\" char_map = {} left = 0 max_length = 0 start = 0 for right in range(n): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right if right - left + 1 > max_length: max_length = right - left + 1 start = left return max_length, s[start:start + max_length]"},{"question":"# Question: Optimized Insertion Sort for Specific Conditions You are given an integer array that is nearly sorted: every element is at most `k` positions away from its target position. Your task is to write a function `optimized_insertion_sort(arr, k)` that sorts this array efficiently using a variation of the insertion sort algorithm. Function Signature ```python def optimized_insertion_sort(arr: list, k: int) -> list: ``` Input * **arr**: A list of integers that is nearly sorted. * **k**: An integer representing the maximum distance within which each element is misplaced from its sorted position. Output * The function should return a new list containing the sorted elements of `arr`. Constraints * All elements in `arr` are distinct. * `1 <= len(arr) <= 10^5` * `0 <= k < len(arr)` Example ```python optimized_insertion_sort([3, 2, 1, 5, 4, 7, 6, 9, 8], 2) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` Performance Requirements * The algorithm should run in O(n log k) time complexity in order to effectively handle large inputs within the constraints. # Explanation In this question, you are provided with an integer array `arr` that is nearly sorted, with each element at most `k` positions away from its target position in the sorted order. You need to implement an optimized version of the insertion sort algorithm, leveraging the fact that elements are almost sorted, to ensure a more efficient sorting process compared to the standard O(n^2) time complexity of traditional insertion sort.","solution":"import heapq def optimized_insertion_sort(arr, k): Sorts a nearly sorted array where each element is at most `k` positions away from its target position. # Create a min-heap min_heap = [] result = [] # Build the initial heap with the first k+1 elements for i in range(min(k + 1, len(arr))): heapq.heappush(min_heap, arr[i]) # Process the remaining elements, one by one for i in range(k + 1, len(arr)): # Extract the smallest element from the heap and add it to the result result.append(heapq.heappop(min_heap)) # Push the next element from the array to the heap heapq.heappush(min_heap, arr[i]) # Extract the remaining elements from the heap and add them to the result while min_heap: result.append(heapq.heappop(min_heap)) return result"},{"question":"# Question: Implement Shortest Path Finder in a Directed Graph Problem Statement: You are given a directed graph implemented using the `DirectedGraph` class defined in the code snippet above. Your task is to write a function to find the shortest path between two nodes using the Breadth-First Search (BFS) algorithm. Function Signature: ```python def find_shortest_path(graph: DirectedGraph, start: str, end: str) -> list: Find the shortest path from node `start` to node `end`. Parameters: 1. graph (DirectedGraph): The directed graph in which to find the shortest path. 2. start (str): The starting node name. 3. end (str): The ending node name. Returns: list: A list of node names representing the shortest path from `start` to `end`, inclusive. If no path exists, return an empty list. ``` Input: 1. `graph`: An instance of the `DirectedGraph` class, representing the graph. 2. `start`: A `string` indicating the name of the starting node. 3. `end`: A `string` indicating the name of the ending node. Output: - A `list` of node names that represent the shortest path from the starting node to the ending node. If there is no path, return an empty list. Constraints: - The graph contains at most 10,000 nodes and 50,000 edges. - Node names are alphanumeric strings with a maximum length of 10. - You may assume all node names in the graph are unique. - Both start and end nodes will exist in the graph. Performance Requirements: - Implement the algorithm with a time complexity of (O(V + E)) using the BFS approach. Example: ```python graph_dict = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'D\'], \'D\': [\'E\'], \'E\': [] } graph = DirectedGraph(graph_dict) start = \'A\' end = \'E\' assert find_shortest_path(graph, start, end) == [\'A\', \'B\', \'D\', \'E\'] assert find_shortest_path(graph, \'C\', \'E\') == [\'C\', \'D\', \'E\'] assert find_shortest_path(graph, \'A\', \'Z\') == [] # \'Z\' does not exist ``` Hints: - Use a queue to facilitate BFS. - Keep track of visited nodes to avoid cycles. - Maintain a mapping from nodes to their parents to reconstruct the path once the target is reached.","solution":"from collections import deque class DirectedGraph: def __init__(self, graph_dict=None): Initializes the graph with a dictionary where keys are node names and values are lists of adjacent nodes. self.graph_dict = graph_dict if graph_dict is not None else {} def add_edge(self, start, end): Adds an edge to the graph from start to end. if start in self.graph_dict: self.graph_dict[start].append(end) else: self.graph_dict[start] = [end] def get_adjacent_nodes(self, node): Returns the list of adjacent nodes for a given node. return self.graph_dict.get(node, []) def find_shortest_path(graph, start, end): Find the shortest path from node `start` to node `end` using Breadth-First Search (BFS). Parameters: 1. graph (DirectedGraph): The directed graph in which to find the shortest path. 2. start (str): The starting node name. 3. end (str): The ending node name. Returns: list: A list of node names representing the shortest path from `start` to `end`, inclusive. If no path exists, return an empty list. if start == end: return [start] queue = deque([start]) visited = {start} parent = {start: None} while queue: current_node = queue.popleft() for neighbor in graph.get_adjacent_nodes(current_node): if neighbor not in visited: parent[neighbor] = current_node visited.add(neighbor) queue.append(neighbor) if neighbor == end: # Reconstruct path from end to start using the parent mapping path = [] while neighbor is not None: path.append(neighbor) neighbor = parent[neighbor] return path[::-1] # Reverse the path to get it from start to end return [] # No path found from start to end"},{"question":"# Task: Implement a Min Binary Heap with an Additional Method Context You are tasked with implementing a priority queue using a min binary heap. A min binary heap maintains the smallest element at the root, and inserting or removing elements from the heap ensures that this property is preserved. Specification Complete the implementation of a `MinBinaryHeap` class which satisfies the following requirements: 1. **insert(val)**: Inserts an integer `val` into the heap. 2. **remove_min()**: Removes and returns the smallest element from the heap. 3. **extract_top_k_elements(k)**: Returns the `k` smallest elements from the heap without modifying the original heap. Input and Output Formats - **insert(val)**: Adds `val` to the heap. - **remove_min()**: Returns the smallest element if the heap is not empty, otherwise returns `None`. - **extract_top_k_elements(k)**: Returns a list of the `k` smallest elements from the heap. If `k` is larger than the size of the heap, return all elements sorted in ascending order. Constraints - You may assume that `insert` and `remove_min` operations will be called frequently. - Do not use any additional data structures (like another heap or an array) to hold the result for `extract_top_k_elements`. Implementation Implement the missing class and methods below: ```python class MinBinaryHeap: def __init__(self): self.current_size = 0 self.heap = [(0)] def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if 2 * i + 1 > self.current_size: return 2 * i if self.heap[2 * i] > self.heap[2 * i + 1]: return 2 * i + 1 return 2 * i def perc_down(self, i): while 2 * i <= self.current_size: min_child = self.min_child(i) if self.heap[min_child] < self.heap[i]: self.heap[min_child], self.heap[i] = self.heap[i], self.heap[min_child] i = min_child def remove_min(self): if self.current_size == 0: return None ret_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return ret_val def extract_top_k_elements(self, k): # Your implementation here pass # Example usage: # heap = MinBinaryHeap() # heap.insert(5) # heap.insert(9) # heap.insert(3) # heap.insert(7) # print(heap.extract_top_k_elements(2)) # Output: [3, 5] ``` Complete the `extract_top_k_elements(k)` method to return a list of the `k` smallest elements from the heap.","solution":"class MinBinaryHeap: def __init__(self): self.current_size = 0 self.heap = [(0)] def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if 2*i + 1 > self.current_size: return 2 * i if self.heap[2 * i] > self.heap[2 * i + 1]: return 2 * i + 1 return 2 * i def perc_down(self, i): while 2 * i <= self.current_size: min_child = self.min_child(i) if self.heap[min_child] < self.heap[i]: self.heap[min_child], self.heap[i] = self.heap[i], self.heap[min_child] i = min_child def remove_min(self): if self.current_size == 0: return None ret_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return ret_val def extract_top_k_elements(self, k): temp_heap = MinBinaryHeap() temp_heap.heap = self.heap[:] temp_heap.current_size = self.current_size top_k_elements = [] for _ in range(min(k, self.current_size)): top_k_elements.append(temp_heap.remove_min()) return top_k_elements"},{"question":"You are given a partially implemented doubly linked list class. Your task is to complete the class by implementing two essential functionalities: inserting a new node at a specific position and deleting a node from a specific position. Function Signature ```python class DoublyLinkedList: def __init__(self): # Initialize the head of the list self.head = None def insert(self, position: int, value: int) -> None: Insert a new node with the given value at the specified position in the list. If the position is greater than the length of the list, append the node at the end. position : index (0-based) where the new node should be inserted. value : value to be stored in the new node. pass def delete(self, position: int) -> None: Delete the node at the specified position from the list. If the position does not exist, do nothing. position : index (0-based) of the node to be deleted. pass ``` Constraints: 1. The index positions start from 0. 2. The linked list can be empty initially. 3. The position for insertion could be greater than the current length of the list, in which case, node should be appended at the end. 4. The position for deletion might not exist if greater than the current length of the list, in which case nothing should be done. Input Format: - No direct input; the methods will be invoked directly via provided function signatures. Output Format: - No direct output expected from methods. This is purely implementation-based. Example: ```python # Example usage: dll = DoublyLinkedList() dll.insert(0, 10) # Insert 10 at position 0 dll.insert(1, 20) # Insert 20 at position 1 dll.insert(1, 15) # Insert 15 at position 1, 20 moves to position 2 dll.delete(1) # Delete node at position 1 having value 15 # The resulting list would have 10->20 ``` You must ensure efficient and correct handling of edge cases such as inserting at the head, deleting from an empty list, and inserting/deleting at the boundaries.","solution":"class Node: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None def insert(self, position: int, value: int) -> None: new_node = Node(value) if not self.head: self.head = new_node return if position == 0: new_node.next = self.head self.head.prev = new_node self.head = new_node return current = self.head current_position = 0 while current.next and current_position < position - 1: current = current.next current_position += 1 if current_position == position - 1: new_node.next = current.next if current.next: current.next.prev = new_node current.next = new_node new_node.prev = current else: current.next = new_node new_node.prev = current def delete(self, position: int) -> None: if not self.head: return if position == 0: self.head = self.head.next if self.head: self.head.prev = None return current = self.head current_position = 0 while current and current_position < position: current = current.next current_position += 1 if current: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev def to_list(self) -> list: result = [] current = self.head while current: result.append(current.value) current = current.next return result"},{"question":"# Question: Enhanced Counting Sort Implementation Your task is to implement an enhanced version of the Counting Sort algorithm that can handle an array that may contain both negative and positive integers. The provided implementation handles this but in a very brute manner. Your implementation should instead use a more elegant approach. Requirements: - Your function should be named `enhanced_counting_sort`. - The function should take in a list `arr` of integers which may include both negative and positive elements. - Return the sorted version of the list. Input: - A list `arr` of integers, where -10^6 <= arr[i] <= 10^6 and 0 <= len(arr) <= 10^6. Output: - A list of integers sorted in non-decreasing order. Constraints: - The implementation must handle both positive and negative numbers efficiently. - The function should avoid unnecessary modifications to the input list. ```python def enhanced_counting_sort(arr): # [Implement the enhanced counting sort algorithm here] pass # Example Usage print(enhanced_counting_sort([4, -1, 3, 4, 3, 0, -5])) # Expected output: [-5, -1, 0, 3, 3, 4, 4] print(enhanced_counting_sort([])) # Expected output: [] ``` Performance Requirements: - The algorithm should retain linear time complexity on average and also manage space efficiently.","solution":"def enhanced_counting_sort(arr): if not arr: return [] min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 count = [0] * range_of_elements output = [0] * len(arr) for num in arr: count[num - min_val] += 1 for i in range(1, len(count)): count[i] += count[i - 1] for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"# Question: Scenario: You are given two strings `s` and `t` where `t` is generated by randomly shuffling string `s` and adding one additional letter at a random position. You need to determine the additional letter in `t`. Task: Write a function `find_additional_character(s: str, t: str) -> str` that finds and returns the additional character in `t`. Input: - `s` (str): A string consisting of only lowercase letters with a length between 0 and 1000. - `t` (str): A string consisting of only lowercase letters, formed by shuffling `s` and adding exactly one additional character. Output: - Returns (str): A single lowercase letter, which is the additional character that was added to `s` to form `t`. Function Signature: ```python def find_additional_character(s: str, t: str) -> str: pass ``` Constraints: - The input strings only consist of lowercase alphabetical letters. - The length of string `t` is exactly one more than the length of the string `s`. Example: ```python assert find_additional_character(\\"abcd\\", \\"abecd\\") == \'e\' ``` Explanation: The string `t` is \\"abecd\\", which is \\"abcd\\" shuffled with an extra character \'e\'. Therefore, \'e\' is the character that has been added. # Notes: - You are required to use XOR as the primary mechanism to solve this problem to demonstrate understanding of bitwise operations.","solution":"def find_additional_character(s: str, t: str) -> str: from functools import reduce from operator import xor # XOR all characters together from both strings # the result will be the additional character return chr(reduce(xor, map(ord, s + t)))"},{"question":"# Scenario In a genomic research lab, you are working with DNA sequences to find similar patterns. One common task involves finding the longest subsequence between two DNA strands to understand evolutionary connections between them. # Question Implement a function `longest_common_subsequence(s1: str, s2: str) -> int` that computes the length of the longest common subsequence (LCS) of two input strings `s1` and `s2`. The function should be optimized for performance, aiming for a time complexity better than the naive O(m*n) solution if possible. # Input - Two strings `s1` and `s2` where: - 1 <= len(s1), len(s2) <= 1000 # Output - Return an integer representing the length of the longest common subsequence of the two strings. # Constraints - No direct usage of dynamic programming matrix methods allowed. # Examples ```python assert longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") == 4 # \\"GTAB\\" assert longest_common_subsequence(\\"ABCDF\\", \\"AECBDF\\") == 4 # \\"ABDF\\" assert longest_common_subsequence(\\"ABC\\", \\"DEF\\") == 0 # No common subsequence ``` # Notes - Aim for an efficient solution and explain your approach briefly. - Consider edge cases like empty strings, strings with no common characters, and strings of different lengths. Good luck!","solution":"def longest_common_subsequence(s1: str, s2: str) -> int: Computes the length of the longest common subsequence (LCS) of two input strings s1 and s2. if not s1 or not s2: return 0 m, n = len(s1), len(s2) # Using a single array to save space current = [0] * (n + 1) for i in range(1, m + 1): previous = current.copy() for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: current[j] = previous[j - 1] + 1 else: current[j] = max(previous[j], current[j - 1]) return current[-1]"},{"question":"Enhanced FizzBuzz with Custom Rules You are tasked with extending the traditional FizzBuzz problem by introducing custom rules. The function should take an additional parameter `rules` which will define new multiples and their corresponding string replacements. # Objective Write a function `custom_fizzbuzz(n, rules)` where: - `n`: An integer greater than or equal to 1. - `rules`: A list of tuples where each tuple consists of an integer and a string (e.g., [(3, \\"Fizz\\"), (5, \\"Buzz\\"), (7, \\"Whizz\\")]). # Requirements 1. The function should return a list of length `n`, where: - The ith element (starting from 1) should be replaced by the corresponding string from the rules if the index is a multiple of the integer in any of the tuples. - If an index is a multiple of more than one integer in the rules, concatenate the strings in the order they appear in the rules list. - If not a multiple of any specified integers, retain the number itself in the list. 2. Implement input validation to ensure: - `n` is an integer greater than or equal to 1. - `rules` is a list of tuples with each tuple containing an integer and a string. # Input - An integer `n` (1 <= n <= 10^6). - A list of tuples `rules` where each tuple contains an integer and a string (maximum length of rules is 10, integers in rules are positive and strings are non-empty). # Output - A list of integers and strings based on the specified rules. # Example ```python custom_fizzbuzz(15, [(3, \\"Fizz\\"), (5, \\"Buzz\\")]) # Output: [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] custom_fizzbuzz(10, [(2, \\"Foo\\"), (3, \\"Bar\\")]) # Output: [1, \'Foo\', \'Bar\', \'Foo\', 5, \'FooBar\', 7, \'Foo\', \'Bar\', \'Foo\'] custom_fizzbuzz(5, [(7, \\"Zazz\\")]) # Output: [1, 2, 3, 4, 5] ``` # Constraints - Ensure that edge cases and invalid inputs are properly handled and produce informative errors. - Aim for an efficient solution given the constraints.","solution":"def custom_fizzbuzz(n, rules): Custom FizzBuzz implementation that takes into account additional rules for replacements. :param n: An integer greater than or equal to 1. :param rules: A list of tuples where each tuple consists of an integer and a string. :return: A list of length n with the replacements according to the rules. # Input validation if not isinstance(n, int) or n < 1: raise ValueError(\\"n must be an integer greater than or equal to 1\\") if not isinstance(rules, list) or not all(isinstance(rule, tuple) and len(rule) == 2 and isinstance(rule[0], int) and rule[0] > 0 and isinstance(rule[1], str) and rule[1] for rule in rules): raise ValueError(\\"rules must be a list of tuples (integer, non-empty string)\\") # Prepare the resulting list result = [] for i in range(1, n + 1): replacement = \\"\\" for divisor, word in rules: if i % divisor == 0: replacement += word if replacement == \\"\\": result.append(i) else: result.append(replacement) return result"},{"question":"# Objective: Implement a function to determine if a given string matches a pattern including \'.\' and \'*\' as described. # Function Signature: ```python def is_match(s: str, p: str) -> bool: ``` # Input: - `s`: A string representing the input text (0 ≤ len(s) ≤ 1000). - `p`: A string representing the pattern which includes characters along with \'.\' and \'*\' (0 ≤ len(p) ≤ 1000). # Output: - Return `True` if the entire input string matches the pattern, otherwise return `False`. # Constraints: - The special character \'.\' matches any single character. - The special character \'*\' matches zero or more of the preceding element. - The matching must cover the entire input string, not just a subset. # Example: ```python is_match(\\"aa\\", \\"a\\") # False is_match(\\"aa\\", \\"aa\\") # True is_match(\\"aaa\\", \\"aa\\") # False is_match(\\"aa\\", \\"a*\\") # True is_match(\\"aa\\", \\".*\\") # True is_match(\\"ab\\", \\".*\\") # True is_match(\\"aab\\", \\"c*a*b\\") # True ``` # Requirements: - Ensure your solution has a time complexity of O(m * n) and a space complexity of O(m * n). - Consider edge cases like empty strings or patterns, repetitive characters, and patterns designed to match multiple sequences. # Hints: 1. Use dynamic programming to build a 2D table where each entry `matches[i][j]` denotes if `s[:i]` matches `p[:j]`. 2. Initialize the table with base cases and fill it by evaluating each character pair in `s` and `p`, considering the special cases for \'.\' and \'*\'. 3. To match an empty string with patterns involving \'*\', ensure correct updating of the table as per the matching rules.","solution":"def is_match(s: str, p: str) -> bool: # Create a 2D dp table with default False values dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Base case: empty string and empty pattern match dp[0][0] = True # Fill the table for patterns with \'*\' that can match an empty string for j in range(2, len(dp[0])): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] for i in range(1, len(dp)): for j in range(1, len(dp[0])): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] if p[j - 2] == \'.\' or p[j - 2] == s[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] return dp[len(s)][len(p)]"},{"question":"You have been provided with an inventory list of items and a maximum number `N`. You need to return a new list that contains each item from the inventory list at most `N` times without reordering. Implement the function `limited_inventory` which efficiently performs this task. # Input: - `items (List[str])`: A list of strings representing the inventory items. - `N (int)`: A non-negative integer representing the maximum allowed occurrences of any item in the output list. # Output: - `List[str]`: A list with each item from the input list appearing at most `N` times, order preserved. # Constraints: - The length of the input list `items` will be in the range [0, 10^6]. - `N` will be a non-negative integer within the range [0, 10^6]. # Example: Given the list of items `items = [\'apple\', \'banana\', \'orange\', \'apple\', \'banana\', \'apple\', \'banana\', \'orange\']` and `N = 2`: - The output list should be `[\'apple\', \'banana\', \'orange\', \'apple\', \'banana\', \'orange\']`. # Function Signature ```python from typing import List def limited_inventory(items: List[str], N: int) -> List[str]: pass ``` # Explanation 1. The function should iterate through the list while keeping track of the count of each item encountered. 2. Using a hash table to store counts ensures O(1) average time complexity on counting operations. 3. If an item’s count is less than `N`, append it to the result list and update its count. 4. This ensures that no item appears more than `N` times in the final list while maintaining the order.","solution":"from typing import List from collections import defaultdict def limited_inventory(items: List[str], N: int) -> List[str]: Returns a list with each item from the input list appearing at most `N` times, order preserved. if N == 0: return [] item_count = defaultdict(int) result = [] for item in items: if item_count[item] < N: result.append(item) item_count[item] += 1 return result"},{"question":"**Problem Statement**: You are given an array of positive integers, and a target sum. Your task is to write a program that counts the number of unique combinations of numbers from the array that add up to the target sum. The order of numbers matters in the combinations. **Function Signature**: ```python def count_combinations(nums: List[int], target: int) -> int: ``` **Input**: 1. `nums`: List of positive integers (e.g., `[1, 2, 3]`). The list will not contain duplicates. 2. `target`: Positive integer representing the target sum. **Output**: - Return an integer representing the number of unique combinations that add up to the target sum. **Example**: ```python nums = [1, 2, 3] target = 4 count_combinations(nums, target) ``` Output: ``` 7 ``` The combinations that add up to 4 are: - (1, 1, 1, 1) - (1, 1, 2) - (1, 2, 1) - (1, 3) - (2, 1, 1) - (2, 2) - (3, 1) **Follow-Up**: 1. Extend your solution to handle cases where negative numbers are allowed in the input array. Modify your approach to prevent infinite loops and ensure the solution is valid. 2. Discuss constraints that could be added to handle negative numbers effectively. **Constraints**: 1. All numbers in the input array are unique. 2. Elements in `nums` are positive integers. 3. The target is a positive integer. **Performance Requirements**: - Your function should be efficiently implemented and avoid redundant calculations.","solution":"from typing import List def count_combinations(nums: List[int], target: int) -> int: # Create a memoization dictionary to store results of subproblems memo = {0: 1} # There is one way to get the target sum 0 (by picking nothing) def helper(t: int) -> int: # Check if the result is already in the memo dictionary if t in memo: return memo[t] # Initialize the count of combinations for the current target count = 0 # Iterate through each number in nums and compute the number of combinations for num in nums: if t >= num: count += helper(t - num) # Store the computed result in the memo dictionary memo[t] = count return count # Call the helper function with the initial target return helper(target)"},{"question":"# Question Objective Write a function that converts a given Roman numeral string into its integer value. Function Signature ```python def roman_to_int(s: str) -> int: ``` Input * `s`: A string representing a Roman numeral. Input is guaranteed to be within the range from 1 to 3999, but only valid Roman numeral characters should process further. Output * An integer representing the numerical value of the given Roman numeral. Constraints * Input Roman numeral strings are guaranteed to be within the range from 1 to 3999. * Input Roman numeral characters should adhere to traditional rules, such as no more than three consecutive identical numerals and ordered correctly according to Roman numeral protocols. Instructions 1. Traverse the Roman numeral string `s`. 2. For each character, determine if it adds to or subtracts from the running total based on the next character. 3. Return the computed integer value. Example ```python assert roman_to_int(\\"III\\") == 3 assert roman_to_int(\\"IV\\") == 4 assert roman_to_int(\\"IX\\") == 9 assert roman_to_int(\\"LVIII\\") == 58 assert roman_to_int(\\"MCMXCIV\\") == 1994 ``` Notes * Pay attention to traditional Roman numeral rules to determine the correct integer output.","solution":"def roman_to_int(s: str) -> int: Converts a given Roman numeral string into its integer value. roman_to_value = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_to_value[char] if value >= prev_value: total += value else: total -= value prev_value = value return total"},{"question":"# Scenario You have been hired by an educational platform to develop an application that verifies the completeness of sentences. Specifically, you need to ensure that the given sentences contain every letter from the English alphabet at least once. Your first task is to write a function that checks if a given sentence is a pangram. # Task Given an input string, implement the function: ```python def is_pangram(input_string: str) -> bool: pass ``` **Input**: * `input_string` (str): A string that may contain lowercase and uppercase English alphabets, digits, symbols, and whitespace characters. The length of `input_string` will be between 0 and 10^6. **Output**: * Returns a boolean value: * `True` if `input_string` contains every letter of the English alphabet at least once. * `False` otherwise. # Constraints: * The input string will be made of printable ASCII characters. * The function should handle large strings efficiently. # Performance Requirements: * Optimize your function to have an average time complexity of O(n) where n is the length of the input string. * The space complexity should be O(1). # Example ```python # Example 1: assert is_pangram(\\"The quick brown fox jumps over the lazy dog\\") == True # Example 2: assert is_pangram(\\"A quick movement of the enemy will jeopardize five gunboats\\") == False ``` # Note: * The first example is a classic pangram containing all the letters of the English alphabet. * The second example is missing some characters such as \'x\'. Ensure to consider edge cases such as empty strings and strings containing special characters. Your implementation should focus on efficiency and correctness.","solution":"def is_pangram(input_string: str) -> bool: Checks if the input string is a pangram. A pangram is a sentence that contains every letter of the alphabet at least once. Args: input_string (str): The string to check. Returns: bool: True if the string is a pangram, otherwise False. alphabet_set = set(\'abcdefghijklmnopqrstuvwxyz\') input_set = set(input_string.lower()) return alphabet_set <= input_set"},{"question":"# Question Given an array `arr` and optional limits `min_lim` and `max_lim`, write a function `limit(arr, min_lim, max_lim)` that filters the elements of the array such that only elements greater than or equal to `min_lim` and less than or equal to `max_lim` are retained. If either of the limits is not provided (None), it should default to the smallest or largest possible value within the array, respectively. # Input * `arr` (List[int]): A list of integers. * `min_lim` (int or None): The minimum limit of the range. If None, it defaults to the minimum value in `arr`. * `max_lim` (int or None): The maximum limit of the range. If None, it defaults to the maximum value in `arr`. # Output * A list of integers containing only elements from `arr` that fall within the specified range, inclusive of the limits. # Constraints * The array can be of any size, including empty. * The elements of the array are integers and comparable. * `min_lim` <= `max_lim` if both are provided. * The function should handle cases where `min_lim` and/or `max_lim` are None appropriately. # Example ```python assert limit([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert limit([1, 2, 3, 4, 5], 2, None) == [2, 3, 4, 5] assert limit([1, 2, 3, 4, 5], 2, 4) == [2, 3, 4] assert limit([], None, None) == [] assert limit([1, 3, 5, 7], 2, 6) == [3, 5] ```","solution":"def limit(arr, min_lim, max_lim): Filters the elements in the array to be within the specified limits. If min_lim or max_lim are None, default to the minimum or maximum value in the array respectively. Parameters: arr (List[int]) : List of integers. min_lim (int or None) : Minimum limit, defaults to min value in arr if None. max_lim (int or None) : Maximum limit, defaults to max value in arr if None. Returns: List[int]: Filtered list. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Question You are given an array of integers `nums` where every integer appears exactly three times except one integer which appears exactly once. Your task is to find the single integer that appears once. You should implement the function `find_unique_element(nums: List[int]) -> int`. Your solution should have a linear runtime complexity and must use only constant extra space. Input Format: * The array `nums` consists of integers and its length will be in the range `[4, 3 * 10^4]`. * Each integer in `nums` will be in the range `[-2^31, 2^31 - 1]`. Output Format: * Return the single integer that appears only once in the array. Constraints: * Your algorithm must have a linear runtime complexity and must use only constant extra space. # Example: Example 1: ```plaintext Input: [2, 2, 3, 2] Output: 3 ``` Example 2: ```plaintext Input: [0,1,0,1,0,1,99] Output: 99 ``` # Note: * Ensure your solution correctly addresses edge cases such as handling of negative numbers. Function Signature: ```python def find_unique_element(nums: List[int]) -> int: pass ```","solution":"from typing import List def find_unique_element(nums: List[int]) -> int: Finds the single integer that appears only once in the array where every other integer appears exactly three times. # Initialize counters ones, twos = 0, 0 for num in nums: # `ones` should hold the XOR of all numbers appearing one time, but not two times. ones = (ones ^ num) & ~twos # `twos` should hold the XOR of all numbers appearing two times, but not three times. twos = (twos ^ num) & ~ones return ones"},{"question":"# Histogram Calculation You are given a list of integers and you need to compute the histogram for this list. A histogram is a representation of the frequency distribution of numerical data. Your task is to write a function that takes the list as input and returns a dictionary where each key is an element from the input list and the corresponding value is the count of occurrences of that element in the list. Function Signature ```python def compute_histogram(data: List[int]) -> Dict[int, int]: ``` Input * `data`: A list containing `n` integers, where `0 <= n <= 10^6`. Output * Returns a dictionary where the keys are elements from the input list and the values are the number of times those elements appear in the input list. Constraints * The elements of the list can be both positive and negative integers. * The input list can contain duplicate elements. * You should aim to achieve a linear time complexity for your solution. Examples ```python # Example 1 input_list = [3, 3, 2, 1] output = {1: 1, 2: 1, 3: 2} # Example 2 input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] output = {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} # Example 3 input_list = [] output = {} # Example 4 input_list = [1] output = {1: 1} # Example 5 input_list = [0, -1, -1, 0, 1, -2, 1] output = {0: 2, -1: 2, 1: 2, -2: 1} ``` Notes Make sure your implementation handles edge cases effectively such as empty lists and lists with repeated elements.","solution":"from typing import List, Dict def compute_histogram(data: List[int]) -> Dict[int, int]: histogram = {} for num in data: if num in histogram: histogram[num] += 1 else: histogram[num] = 1 return histogram"},{"question":"Finding the First Occurrence Context: You are developing a feature for a system that needs to look up values quickly in large datasets. A common requirement is to find the first occurrence of a given number in a sorted array. Using a more efficient approach is necessary for this scenario to ensure performance remains optimal. Task: Write a function `find_first_occurrence` that finds the first occurrence of a specified number in a sorted array using an efficient algorithm. If the number is not found, the function should return `-1`. **Function Signature**: ```python def find_first_occurrence(array, query) -> int: pass ``` Input: - `array`: A list of integers in increasing order. - `query`: An integer to find in the array. Output: - Return the zero-based index of the first occurrence of the `query` in the given `array`. - If the `query` is not found, return `-1`. Constraints: - The length of the array will be between `0` and `10^6`. - `. The integers in the array will be in the range `-10^9` to `10^9`. Example: ```python # Example 1: array = [1, 2, 2, 2, 3] query = 2 # Output: 1 # Explanation: The first occurrence of 2 is at index 1. # Example 2: array = [1, 2, 3, 4, 5] query = 6 # Output: -1 # Explanation: There is no occurrence of 6 in the array. ``` Notes: - Ensure your solution is efficient with a time complexity of O(log n), utilizing binary search. - Consider edge cases, such as when the array is empty or the target number is not present in the array.","solution":"def find_first_occurrence(array, query) -> int: Finds the first occurrence of the specified number in a sorted array. Uses binary search for efficient lookup. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 # Check if the mid element is equal to the query if array[mid] == query: result = mid right = mid - 1 # Continue searching in the left half to find the first occurrence elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"Next Lexicographical Permutation Problem Statement You are given a number as input. Your task is to write a function `next_bigger(num)` that returns the next higher number with the same set of digits. If no such number exists, return `-1`. Function Signature ```python def next_bigger(num: int) -> int: pass ``` Input - **num**: An integer `1 ≤ num ≤ 10^18`. Output - **Returns**: The next greater number formed by the same set of digits, or `-1` if no such number exists. Constraints - The input number will be a positive integer. - The input number can be represented with up to 18 digits. Examples ```python next_bigger(38276) # Output: 38627 next_bigger(12345) # Output: 12354 next_bigger(54321) # Output: -1 next_bigger(5) # Output: -1 next_bigger(99999) # Output: -1 ``` Explanation 1. For the input `38276`, the next higher number with the same digits is `38627`. 2. For `12345`, the next permutation is `12354`. 3. For `54321`, it is already the largest permutation, so the function returns `-1`. 4. A single-digit number or numbers with all identical digits don\'t have a higher permutation, hence return `-1`. Additional Test Cases ```python assert next_bigger(1528452) == 1528524 assert next_bigger(138654) == 143568 ``` Implement the function, ensuring that it efficiently handles edge cases and large inputs within the constraints.","solution":"def next_bigger(num: int) -> int: Returns the next higher number with the same set of digits. If no such number exists, returns -1. digits = list(str(num)) len_digits = len(digits) # Find the pivot point where the number stops increasing for i in range(len_digits - 2, -1, -1): if digits[i] < digits[i + 1]: break else: return -1 # Find the next larger digit to replace with for j in range(len_digits - 1, i, -1): if digits[j] > digits[i]: break # Swap and sort the rest digits[i], digits[j] = digits[j], digits[i] digits = digits[:i + 1] + sorted(digits[i + 1:]) return int(\'\'.join(digits))"},{"question":"Shortest Path in a Weighted Grid Objective Write a function that computes the shortest path in a grid where each cell has a weight. Movement is allowed only to adjacent cells (up, down, left, and right). Problem Statement You are given a 2D grid where each cell represents the weight of entering that cell. You can only move in four directions: up, down, left, and right. The function should return the minimum cost required to travel from the top-left corner to the bottom-right corner of the grid. If no path exists, return -1. Function Signature: ```python def shortest_path_with_weights(grid: List[List[int]]) -> int: pass ``` # Input - A 2D list `grid` of size `n x m` where `n` is the number of rows and `m` is the number of columns. - Each cell `(grid[i][j])` can have a non-negative integer representing the cost to enter the cell. # Output - An integer representing the minimum cost to travel from the top-left to the bottom-right corner. Return -1 if no path exists. # Constraints - `1 <= n, m <= 100` - `0 <= grid[i][j] <= 10^4` Example Input ```python grid = [ [1, 2, 5], [3, 2, 1], [4, 3, 1] ] ``` Output ```python 8 ``` Explanation: The optimal path is `(0,0) -> (0,1) -> (1,1) -> (1,2) -> (2,2)` with the total cost of `1 + 2 + 2 + 1 + 1 = 7`. Note - You need to consider edge cases like non-connectivity and minimal grid sizes. - Implement your solution efficiently to meet the constraints provided. - You can use any data structure or algorithm that suits the problem, but a modified version of BFS with a priority queue (Dijkstra’s algorithm) might be a suitable choice for this problem.","solution":"from heapq import heappop, heappush from typing import List def shortest_path_with_weights(grid: List[List[int]]) -> int: if not grid or not grid[0]: return -1 n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] pq = [(grid[0][0], 0, 0)] min_cost = [[float(\'inf\')] * m for _ in range(n)] min_cost[0][0] = grid[0][0] while pq: cost, x, y = heappop(pq) if (x, y) == (n-1, m-1): return cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: new_cost = cost + grid[nx][ny] if new_cost < min_cost[nx][ny]: min_cost[nx][ny] = new_cost heappush(pq, (new_cost, nx, ny)) return -1 if min_cost[n-1][m-1] == float(\'inf\') else min_cost[n-1][m-1]"},{"question":"# Segment Tree Coding Challenge You are given an array of integers and a commutative function. Implement a segment tree that supports efficient range queries and updates. Your Task: Write a class `SegmentTree` with the following methods: 1. **Constructor**: - `__init__(self, arr: list, function: callable)`: Initializes the segment tree. `arr` is the initial array, and `function` is a commutative function (e.g., sum, max). 2. **Update**: - `update(self, index: int, value: int)`: Update the element at position `index` of the array to `value`. 3. **Query**: - `query(self, left: int, right: int) -> int`: Return the result of applying the commutative function to the segment of the array from `left` to `right` (inclusive). Input and Output Formats: - **Initialization**: - An array `arr` of length `N`. - A function `function`. - **Update**: - An integer `index` representing the position in the array. - An integer `value` representing the new value to be placed at `index`. - **Query**: - Two integers `left` and `right` representing the bounds of the range query. - Returns the result of the commutative function applied over the array segment from `left` to `right`. Constraints: - The array will have at most `10^5` elements. - Each element will be an integer in the range `[-10^9, 10^9]`. - `left` and `right` will always be within array bounds and `left <= right`. Example: ```python mytree = SegmentTree([1, 3, 5, 7, 9, 11], lambda a, b: a + b) print(mytree.query(1, 3)) # Output: 15 (3 + 5 + 7) mytree.update(1, 10) print(mytree.query(1, 3)) # Output: 22 (10 + 5 + 7) ```","solution":"class SegmentTree: def __init__(self, arr: list, function: callable): self.n = len(arr) self.func = function self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr): # Build the tree by filling in the leaves first for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index: int, value: int): pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.func(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, left: int, right: int) -> int: result = None left += self.n right += self.n + 1 while left < right: if left % 2: result = self.tree[left] if result is None else self.func(result, self.tree[left]) left += 1 if right % 2: right -= 1 result = self.tree[right] if result is None else self.func(result, self.tree[right]) left //= 2 right //= 2 return result"},{"question":"# Binary Tree Height Calculation You have been given the task of determining the height of a binary tree. The height is defined as the number of levels in the tree. An empty tree has a height of 0. A tree with one node (the root) has a height of 1. Your task is to implement the function `height(root)` which calculates the height of a binary tree. Function Signature ```python def height(root): pass ``` Input * `root`: A `TreeNode` object which is the root of the binary tree. Each `TreeNode` has the following properties: * `val`: The value of the node (integer) * `left`: A reference to the left child (another `TreeNode` object, or `None` if there is no child) * `right`: A reference to the right child (another `TreeNode` object, or `None` if there is no child) Output * An integer representing the height of the tree. Constraints * The tree will have at most 10^4 nodes. * Node values are unique integers. # Example Given a tree: ``` 9 / 6 12 / / 3 8 10 15 7 18 ``` Sample Usage ```python root = TreeNode(9) root.left = TreeNode(6) root.right = TreeNode(12) root.left.left = TreeNode(3) root.left.right = TreeNode(8) root.right.left = TreeNode(10) root.right.right = TreeNode(15) root.left.right.left = TreeNode(7) root.right.right.right = TreeNode(18) # The height of this tree is 4. print(height(root)) # Output: 4 ``` # Notes * You should ensure that your implementation efficiently handles large trees. * Consider edge cases such as an empty tree (`root` is `None`) or a completely skewed tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def height(root): This function returns the height of a binary tree. :param root: TreeNode, the root of the binary tree. :return: int, the height of the tree. if root is None: return 0 else: left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"# Scenario You are tasked to develop a critical component for a job scheduling system that processes tasks based on their arrival order. To implement this, a queue data structure is necessary to ensure the tasks are handled in a FIFO manner. # Task Implement a circular array-based queue class in Python by extending the provided abstract queue class. This circular queue should avoid the limitations of the fixed-sized `ArrayQueue` by allowing wrapping around of indexes, hence eliminating the need for frequent resizing. # Requirements 1. **Class Name**: `CircularArrayQueue` 2. **Methods**: - **enqueue(self, value)**: Add an element to the rear of the queue. - **dequeue(self)**: Remove and return the front element from the queue. - **peek(self)**: Return the front element without removing it. - **is_empty(self)**: Return `True` if the queue is empty, `False` otherwise. - **__len__(self)**: Return the number of elements in the queue. - **__iter__(self)**: Iterate through elements in the queue from front to rear. # Constraints - Initial capacity of the queue should be 10. - Implement wrap-around logic to efficiently use the array space. - Raising appropriate exceptions for invalid operations, such as dequeue or peek on an empty queue. # Example ```python cq = CircularArrayQueue() cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) print(cq.dequeue()) # Output: 1 print(cq.peek()) # Output: 2 print(len(cq)) # Output: 2 ``` # Hints - Think about how the rear and front pointers should move in a circular fashion. - Ensuring that the wrapping around condition is handled correctly can help avoid out-of-bound errors.","solution":"class CircularArrayQueue: def __init__(self): self._capacity = 10 self._array = [None] * self._capacity self._front = 0 self._rear = 0 self._size = 0 def _resize(self): new_capacity = self._capacity * 2 new_array = [None] * new_capacity for i in range(self._size): new_array[i] = self._array[(self._front + i) % self._capacity] self._array = new_array self._front = 0 self._rear = self._size self._capacity = new_capacity def enqueue(self, value): if self._size == self._capacity: self._resize() self._array[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") value = self._array[self._front] self._array[self._front] = None # Help garbage collection self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty queue\\") return self._array[self._front] def is_empty(self): return self._size == 0 def __len__(self): return self._size def __iter__(self): for i in range(self._size): yield self._array[(self._front + i) % self._capacity]"},{"question":"Coding Challenge: Misra-Gries Algorithm Extension # Scenario Your company handles enormous amounts of real-time data and needs a memory-efficient way to identify frequent items in incoming data streams. You are tasked to extend the Misra-Gries algorithm to handle a customizable threshold for frequent items and return the results accordingly. # Problem Statement Write a function `find_frequent_elements(array, threshold)` that uses the Misra-Gries algorithm to identify elements that appear at least `threshold` times in the input `array`. The function should handle potential edge cases and provide accurate counts of these elements. # Input * `array` (List[int]): A list of integers representing the data stream. * `threshold` (int): An integer specifying the minimum occurrence threshold for an element to be considered frequent. # Output * A dictionary where the keys are the elements from the array that appear at least `threshold` times, and the values are their respective frequencies. * If no elements meet the threshold, return an empty dictionary. # Constraints * 1 <= len(array) <= 10^6 * 1 <= threshold <= len(array) # Function Signature ```python def find_frequent_elements(array: List[int], threshold: int) -> Dict[int, int]: pass ``` # Examples ```python print(find_frequent_elements([1, 4, 4, 4, 5, 4, 4], 5)) # Output: {4: 5} print(find_frequent_elements([0, 0, 0, 1, 1, 1, 1], 4)) # Output: {1: 4} print(find_frequent_elements([0, 0, 0, 0, 1, 1, 1, 2, 2], 3)) # Output: {0: 4, 1: 3} print(find_frequent_elements([0, 0, 0, 1, 1, 1], 3)) # Output: {} ``` # Notes * Elements and their thresholds are based on absolute counts, not fractions of the array length as in the original algorithm. * The solution must factor in edge cases such as when the array is smaller than the threshold or contains fewer unique elements than the threshold.","solution":"from typing import List, Dict from collections import defaultdict def find_frequent_elements(array: List[int], threshold: int) -> Dict[int, int]: Uses the Misra-Gries algorithm to find elements in the array which appear at least `threshold` number of times. if len(array) < threshold: return {} # Step 1: Apply the Misra-Gries algorithm to narrow candidates k = threshold counter = defaultdict(int) for num in array: if num in counter: counter[num] += 1 elif len(counter) < k - 1: counter[num] = 1 else: keys_to_delete = [] for key in counter: counter[key] -= 1 if counter[key] == 0: keys_to_delete.append(key) for key in keys_to_delete: del counter[key] # Step 2: Verify the candidates to get true frequent element counts result = defaultdict(int) for num in array: if num in counter: result[num] += 1 # Step 3: Filter out candidates that do not meet the threshold frequent_elements = {num: count for num, count in result.items() if count >= threshold} return frequent_elements"},{"question":"# Pancake Sort Implementation You are provided with a partially implemented sorting algorithm called **Pancake Sort**. Your task is to complete this implementation ensuring it sorts the array correctly by repeatedly reversing sections of the array. Problem Description Implement the function `pancake_sort(arr)` which takes a list of integers `arr` and returns a new list with the integers sorted in non-decreasing order using the Pancake Sort algorithm. Input - `arr`: A list of integers (0 ≤ len(arr) ≤ 100), where 0 ≤ `arr[i]` ≤ 10^9. Output - A list of integers sorted in non-decreasing order. Constraints - The length of the array, N, where (0 ≤ N ≤ 100). - All integers are non-negative and within the given range. Function Signature ```python def pancake_sort(arr: List[int]) -> List[int]: ``` Example ```python # Example 1 input_arr = [3, 2, 4, 1] output_arr = pancake_sort(input_arr) print(output_arr) # Output: [1, 2, 3, 4] # Example 2 input_arr = [1, 2, 3] output_arr = pancake_sort(input_arr) print(output_arr) # Output: [1, 2, 3] # Example 3 input_arr = [9, 3, 5, 1, 7] output_arr = pancake_sort(input_arr) print(output_arr) # Output: [1, 3, 5, 7, 9] ``` Notes - You must ensure the function handles the edge cases efficiently, such as empty input list or already sorted list. - Remember to reverse parts of the list as needed to achieve the final sorted list.","solution":"from typing import List def flip(arr: List[int], k: int) -> None: Reverses the order of the first k elements in the array. arr[:k] = arr[:k][::-1] def find_max(arr: List[int], n: int) -> int: Returns the index of the maximum value in the first n elements of the array. max_index = 0 for i in range(1, n): if arr[i] > arr[max_index]: max_index = i return max_index def pancake_sort(arr: List[int]) -> List[int]: Sorts the array using the Pancake Sort algorithm. curr_size = len(arr) while curr_size > 1: # Find the index of the maximum element in arr[0..curr_size-1] max_index = find_max(arr, curr_size) # Move the maximum element to end of current array if it\'s not already at the end if max_index != curr_size - 1: # Move maximum number to first position by flipping the maximum number index flip(arr, max_index + 1) # Move maximum number to its correct position by flipping the current size flip(arr, curr_size) # Reduce current size curr_size -= 1 return arr"},{"question":"Context Given a set of distinct integers, you need to generate all possible subsets of these integers without any duplications. This problem explores your understanding of combinatorial algorithms and efficient traversal with bit manipulation. Task Write a function `generate_subsets(nums)` that takes a list of distinct integers `nums` and returns a set of tuples where each tuple represents a unique subset of the input list. Input * A list of distinct integers `nums` where `0 <= len(nums) <= 16` and `-100 <= nums[i] <= 100`. Output * A set of tuples, with each tuple representing a unique subset of the input list. Constraints * The solution should avoid duplicate subsets and maintain each subset as a tuple in the returned set. * Be mindful of the algorithm\'s efficiency given the input constraints. Example ```python # Example 1 nums = [1, 2, 3] # Expected output: # { # (), # (1,), # (2,), # (3,), # (1, 2), # (1, 3), # (2, 3), # (1, 2, 3) # } # Example 2 nums = [] # Expected output: # { () } # Example 3 nums = [4, -1] # Expected output: # { (), (4,), (-1,), (4, -1) } ``` Function Signature ```python def generate_subsets(nums): # Your implementation here pass ``` Evaluation Criteria * **Correctness**: Ensure the function produces accurate subsets for given input lists. * **Efficiency**: The function should run efficiently within provided constraints. * **Code Quality**: Clarity, readability, and proper handling of edge cases.","solution":"from itertools import chain, combinations def generate_subsets(nums): Returns a set of tuples where each tuple represents a unique subset of the input list `nums`. # Generate all combinations of the input list for all possible lengths subsets = set(chain(*[combinations(nums, r) for r in range(len(nums) + 1)])) return subsets"},{"question":"Implementing a Modified Shell Sort **Context**: You are tasked with improving a sorting function for a medium-sized dataset. The current algorithm is standard Shell Sort, but it needs enhancements to handle larger unsorted sections more efficiently. **Task**: Implement a modified version of Shell Sort that utilizes a more efficient gap sequence and includes optimizations to reduce the total number of comparisons and swaps. **Function Signature**: ```python def optimized_shell_sort(arr: List[int]) -> List[int]: pass ``` **Input**: - `arr`: A list of integers, where 1 <= len(arr) <= 10^4. **Output**: - Returns the sorted list of integers. **Constraints**: - Do not use built-in sort functions. - The algorithm should have an average-case time complexity better than O(n^2). - Minimize the number of comparisons and swaps for partially sorted data. **Additional Requirements**: - Provide explanations for your chosen gap sequence. - Include test cases covering various edge cases to demonstrate the robustness of your solution. **Example**: ```python print(optimized_shell_sort([10, 7, 8, 9, 1, 5])) # Output: [1, 5, 7, 8, 9, 10] print(optimized_shell_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] (Already sorted case) ``` **Note**: Consider using gaps derived from research, such as the sequence proposed by Sedgewick or others, to enhance the sorting performance.","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: n = len(arr) # Using the Sedgewick gap sequence: 1, 5, 19, 41, 109, ... gaps = [] k = 0 while True: gap = 4**k + 3 * 2**(k-1) + 1 if k > 0 else 1 if gap > n: break gaps.insert(0, gap) # We insert at the beginning to reverse the list at the end k += 1 # Shell Sort using Sedgewick gap sequence for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Question: Remove Duplicates from a Linked List You are provided with a singly linked list where each node contains an integer value. Your task is to implement two functions to remove duplicates from this linked list. Function 1: remove_dups(head) This function should remove duplicates using an auxiliary data structure to optimize for time complexity. **Input**: - A reference to the head node of the linked list. **Output**: - The linked list with duplicates removed. **Constraints**: - Time Complexity should be O(N). - Space Complexity should be O(N) because of the auxiliary data structure. Function 2: remove_dups_without_set(head) This function should remove duplicates without using any auxiliary data structure. It should achieve this through iterative comparisons. **Input**: - A reference to the head node of the linked list. **Output**: - The linked list with duplicates removed. **Constraints**: - Time Complexity should be O(N^2) - Space Complexity should be O(1). You are also provided with a helper function: ```python def print_linked_list(head): string = \\"\\" while head.next: string += str(head.val) + \\" -> \\" head = head.next string += str(head.val) print(string) ``` This function can be used to verify the correctness of your implementations. # Example Given the linked list: 1 -> 2 -> 3 -> 2 -> 4 -> 1 # Calling `remove_dups(head)`: The list after removing duplicates is: 1 -> 2 -> 3 -> 4 # Calling `remove_dups_without_set(head)` on the same initial list: The list after removing duplicates is: 1 -> 2 -> 3 -> 4 **Note**: After each operation, the list should be reset to its initial state for accurate testing of both functions.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_dups(head): Removes duplicates from the linked list using a set. Time Complexity: O(N) Space Complexity: O(N) if not head: return head current = head seen = set([current.val]) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head def remove_dups_without_set(head): Removes duplicates from the linked list without using any auxiliary data structure. Time Complexity: O(N^2) Space Complexity: O(1) if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head # Helper function to create a linked list from a list def create_linked_list(elements): if not elements: return None head = ListNode(elements[0]) current = head for element in elements[1:]: current.next = ListNode(element) current = current.next return head # Helper function to get list from a linked list def get_list_from_linked_list(head): result = [] current = head while current: result.append(current.val) current = current.next return result"},{"question":"# Question You are responsible for optimizing the daily schedule of a delivery robot in a warehouse. The robot has a list of delivery tasks, each represented by an integer (the lower the integer, the higher the priority). You need to implement a sorting function to organize these tasks from the highest priority to the lowest using the Selection Sort algorithm. However, your implementation should also have an option to print each step of the sorting process for debugging and monitoring purposes. Function Signature ```python def selection_sort(tasks: List[int], simulation: bool = False) -> List[int]: Sort the list of tasks in ascending order (highest priority first). Parameters: tasks : List[int] - A list of task priorities. simulation : bool - If True, print the array at each step of iteration. Returns: List[int] - The sorted list of tasks in ascending order. ``` # Input * `tasks` - A list of task priorities (1 ≤ len(tasks) ≤ 1000, -10^6 ≤ tasks[i] ≤ 10^6). * `simulation` - Boolean flag indicating whether to print the array at each step. # Output * Return the list of tasks sorted in ascending order. # Example * **Input**: `tasks = [4, 5, 3, 1, 2], simulation = True` * **Output**: `Sorted tasks: [1, 2, 3, 4, 5]` * **Output (with simulation)**: ``` iteration 0 : 4 5 3 1 2 iteration 1 : 1 5 3 4 2 iteration 2 : 1 2 3 4 5 iteration 3 : 1 2 3 4 5 iteration 4 : 1 2 3 4 5 Sorted tasks: [1, 2, 3, 4, 5] ``` # Constraints and Considerations * Assume the list may contain negative values and duplicate values. * Think about edge cases such as an empty list or a list with a single element. * Make sure to print each step of the sorting process if `simulation` is `True`. * Handle the swapping and selection mechanism carefully to avoid common pitfalls (e.g., going out of index bounds).","solution":"from typing import List def selection_sort(tasks: List[int], simulation: bool = False) -> List[int]: Sort the list of tasks in ascending order (highest priority first). Parameters: tasks : List[int] - A list of task priorities. simulation : bool - If True, print the array at each step of iteration. Returns: List[int] - The sorted list of tasks in ascending order. n = len(tasks) for i in range(n): min_idx = i for j in range(i+1, n): if tasks[j] < tasks[min_idx]: min_idx = j tasks[i], tasks[min_idx] = tasks[min_idx], tasks[i] if simulation: print(f\'iteration {i} : {\\" \\".join(map(str, tasks))}\') return tasks"},{"question":"# Matrix Multiplication Assessment Question You are tasked with implementing an optimized matrix multiplication function. Given two matrices, you should return their product while ensuring the time complexity is reduced as efficiently as possible. Function Signature ```python def optimized_multiply(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]: pass ``` # Input * `multiplicand`: A list of lists, where each sublist represents a row of the matrix. * `multiplier`: A list of lists, where each sublist represents a row of the matrix. # Output * Returns the resulting matrix product as a list of lists. # Constraints 1. The number of columns in `multiplicand` will always equal the number of rows in `multiplier`. 2. The dimensions of the matrices will not exceed 200x200. # Performance Requirement - Aim for an improved time complexity over the naive O(n^3). # Example Scenario Consider the following case: ```python multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] ``` Your function should return: ```python [ [58, 64], [139, 154] ] ``` # Notes - Ensure to handle edge cases such as mismatched dimensions with appropriate error handling. - Optimize your code for efficiency, leveraging any advanced algorithms or parallel computations if possible.","solution":"from typing import List def optimized_multiply(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]: Multiplies two matrices using a more efficient algorithm than the naive approach. Args: multiplicand (List[List[int]]): First matrix. multiplier (List[List[int]]): Second matrix. Returns: List[List[int]]: The product of the two matrices. n, m, p = len(multiplicand), len(multiplier[0]), len(multiplier) # Initialize result matrix with zeros result = [[0] * m for _ in range(n)] # Perform the matrix multiplication for i in range(n): for k in range(p): # iterating over the common dimension for j in range(m): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"**Scenario**: You are given a set of items, each with a value and a weight, and a knapsack with a fixed maximum capacity. Your task is to determine the most valuable combination of items that can be fit into the knapsack without exceeding its capacity. **Function Signature**: ```python def max_knapsack_value(capacity: int, items: List[Tuple[int, int]]) -> int: pass ``` **Description**: - **Input**: - `capacity` (int): The maximum weight capacity of the knapsack. - `items` (List[Tuple[int, int]]): A list of items, each represented as a tuple with the format (value, weight). - **Output**: - Returns an integer representing the maximum value that can be achieved within the given capacity. **Constraints**: - 0 <= capacity <= 10^4 - 0 <= len(items) <= 10^3 - 1 <= value, weight <= 10^4 **Example Input**: ```python capacity = 5 items = [(60, 5), (50, 3), (70, 4), (30, 2)] ``` **Example Output**: ```python 80 ``` **Additional Notes**: - You need to consider cases where no items can be inserted due to capacity constraints. - Focus on dynamic programming principles to achieve efficient computation. - Properly handle cases with multiple items having the same weight and value combinations. **Edge Cases to Handle**: - Empty items list. - Capacity of zero. - Items with non-sufficient weight to be added to the knapsack. Implement the `max_knapsack_value` function to solve the problem.","solution":"from typing import List, Tuple def max_knapsack_value(capacity: int, items: List[Tuple[int, int]]) -> int: Determine the maximum value of items that can be fit into the knapsack without exceeding its capacity. :param capacity: The maximum weight capacity of the knapsack. :param items: A list of items, each represented as a tuple (value, weight). :return: An integer representing the maximum value that can be achieved within the given capacity. # Initialize a list to store the maximum value at each capacity from 0 to capacity dp = [0] * (capacity + 1) # Iterate over all the items for value, weight in items: # Traverse the dp array from the back to front to avoid using the same item multiple times for cap in range(capacity, weight - 1, -1): dp[cap] = max(dp[cap], dp[cap - weight] + value) return dp[capacity]"},{"question":"# Question: Generate All Possible Subsets Problem Statement You are given a set of distinct integers `nums`, your task is to write a function `generate_subsets(nums)` that returns all possible subsets (the power set) of the given set. Input and Output Format - **Input**: A list of integers `nums` where (0 leq text{len}(nums) leq 16). - **Output**: A list of lists, where each inner list is a subset of the given set of integers. The solution set must not contain duplicate subsets and the order of subsets does not matter. Constraints - The integers in `nums` are all distinct. - The integers in `nums` are such that (-10^6 leq text{nums}[i] leq 10^6). Example *Example 1:* Input: `nums = [1, 2, 3]` Output: `[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]` *Example 2:* Input: `nums = []` Output: `[[]]` Function Signature ```python def generate_subsets(nums): pass ``` Performance Requirements - Your solution should strive to efficiently handle the worst-case input size within reasonable computational limits, considering the given constraints.","solution":"def generate_subsets(nums): Generates all possible subsets of a given set of integers. Args: nums (list): A list of distinct integers. Returns: List[List[int]]: A list of lists, where each list is a subset of the input integers. subsets = [[]] for num in nums: new_subsets = [] for subset in subsets: new_subsets.append(subset + [num]) subsets.extend(new_subsets) return subsets"},{"question":"Task Write a function, `is_same_inorder(tree1: Node, tree2: Node) -> bool`, that takes two binary trees and checks if they have the same in-order traversal. Description Given two binary trees, determine if the sequence of values in their in-order traversal is identical. The function should be efficient in terms of time and space complexity. Input * Two trees represented by the root node of their respective trees. Output * Return `True` if the in-order traversal of both trees matches, otherwise return `False`. Example ```python # Tree 1 # 100 # / # 50 150 # / / # 25 75 125 175 n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 # Tree 2 # 100 # / # 50 150 # / / # 25 75 125 175 m1 = Node(100) m2 = Node(50) m3 = Node(150) m4 = Node(25) m5 = Node(75) m6 = Node(125) m7 = Node(175) m1.left, m1.right = m2, m3 m2.left, m2.right = m4, m5 m3.left, m3.right = m6, m7 assert is_same_inorder(n1, m1) == True # both trees are identical in in-order traversal # Tree 3 # 100 # / # 50 150 # / # 25 o1 = Node(100) o2 = Node(50) o3 = Node(150) o4 = Node(25) o1.left, o1.right = o2, o3 o2.left = o4 assert is_same_inorder(n1, o1) == False # tree structures differ ``` Constraints * Both binary trees do not contain duplicate values. * The size of each tree can range from 0 (null node) to 10^5 nodes. Write your function below: ```python def is_same_inorder(tree1: Node, tree2: Node) -> bool: # Implement your solution here ```","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def inorder_traversal(root): if root is None: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) def is_same_inorder(tree1: Node, tree2: Node) -> bool: return inorder_traversal(tree1) == inorder_traversal(tree2)"},{"question":"# Counting the Number of Digits in a Number Given a non-negative integer, write a function called `count_digits` that returns the number of digits in the number. Your solution should be efficient with a time complexity of O(1) and a space complexity of O(1). # Input and Output Format * **Input**: A single non-negative integer `n` (0 ≤ n ≤ 10^18). * **Output**: An integer representing the number of digits in `n`. # Constraints 1. The input integer `n` will be within the range [0, 10^18]. # Example ```python def count_digits(n): import math n=abs(n) if n==0: return 1 return int(math.log10(n))+1 # Example Usage print(count_digits(12345)) # Output: 5 print(count_digits(0)) # Output: 1 print(count_digits(9876543210)) # Output: 10 print(count_digits(1000000000000000000)) # Output: 19 ``` # Explanation 1. `count_digits(12345)`: The number 12345 has 5 digits. 2. `count_digits(0)`: The number 0 is considered to have a single digit. 3. `count_digits(9876543210)`: The number 9876543210 has 10 digits. 4. `count_digits(1000000000000000000)`: The number 1000000000000000000 (10^18) has 19 digits. Ensure that your function handles the edge case of zero correctly and performs efficiently for all valid input ranges.","solution":"def count_digits(n): Returns the number of digits in a non-negative integer n. if n == 0: return 1 import math return int(math.log10(n)) + 1"},{"question":"You are given a list of integers that you need to sort using the Exchange Sort algorithm. Your task is to implement the function `sorted_exchange(arr: List[int]) -> List[int]` which takes an array of integers as input and returns a new array with the elements sorted in ascending order. # Expected Function Signature ```python from typing import List def sorted_exchange(arr: List[int]) -> List[int]: ``` # Input - `arr` : A list of integers of length `n`, where `0 <= n <= 10^3`. # Output - Returns a sorted list of integers in ascending order. # Example Example 1 **Input**: ```python arr = [4, 3, 2, 1] ``` **Output**: ```python [1, 2, 3, 4] ``` Example 2 **Input**: ```python arr = [] ``` **Output**: ```python [] ``` Example 3 **Input**: ```python arr = [1, 2, 3, 4] ``` **Output**: ```python [1, 2, 3, 4] ``` # Constraints - The algorithm must be implemented using the Exchange Sort method. - Time complexity should be O(n^2). - Space complexity should be O(1). # Notes - Consider edge cases such as empty arrays or arrays with a single element. - Implement in-place sorting to avoid additional memory usage.","solution":"from typing import List def sorted_exchange(arr: List[int]) -> List[int]: Sorts the array using the Exchange Sort algorithm. n = len(arr) for i in range(n): for j in range(i+1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"Context You are working on data cleaning for a large dataset and need to ensure that only the relevant range of values are considered for further analysis. For this purpose, you need an efficient way to filter out unwanted values from an array. Problem Statement Implement a function `filtered_array` that takes an array of integers and two optional limit values `min_lim` and `max_lim`. The function should return a new array containing only the elements from the original array that are greater than or equal to `min_lim` and less than or equal to `max_lim`. Specifications - **Function Signature**: `def filtered_array(arr: list[int], min_lim: int = None, max_lim: int = None) -> list[int]:` - **Input**: - `arr` (list of int): Array of integers which needs to be filtered. - `min_lim` (int, optional): Minimum limit of values to keep in the array. If `None`, consider the minimum value in the array as `min_lim`. - `max_lim` (int, optional): Maximum limit of values to keep in the array. If `None`, consider the maximum value in the array as `max_lim`. - **Output**: List of integers containing only values within the specified range. Constraints - The array can be empty or contain up to (10^6) integers. - The integers in the array can range from (-10^9) to (10^9). - If both `min_lim` and `max_lim` are given, ensure `min_lim` is less than or equal to `max_lim`. Performance Requirements - Time complexity should be O(n). - Space complexity should be O(n). Example ```python assert filtered_array([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert filtered_array([1, 2, 3, 4, 5], 2, 4) == [2, 3, 4] assert filtered_array([1, 2, 3, 4, 5], 6, 10) == [] ``` Edge Cases - `filtered_array([])`: Should return `[]`. - `filtered_array([1, 2, 3], 5, 6)`: Should return `[]`. - `filtered_array([1, 2, 3], None, None)`: Should return `[1, 2, 3]`. Implement the `filtered_array` function complying with the specifications and passing the example test cases.","solution":"def filtered_array(arr: list[int], min_lim: int = None, max_lim: int = None) -> list[int]: Returns a new array containing only the elements from the original array that are greater than or equal to min_lim and less than or equal to max_lim. If min_lim or max_lim is None, they are set to the minimum or maximum value in the array respectively. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"You are given a square, invertible matrix represented as a list of lists in Python. Write a function `invert_matrix` that computes and returns the inverse of the matrix using the matrix inversion algorithm outlined below. # Algorithm Steps 1. Compute the **matrix of minors**: For each element in the matrix, calculate the determinant of the smaller matrix that remains if you exclude the element\'s row and column. 2. Form the **matrix of cofactors**: Apply a checkerboard pattern of signs to the matrix of minors. 3. **Adjugate the matrix**: Transpose the matrix of cofactors. 4. **Calculate the inverse**: Divide each element of the adjugate matrix by the determinant of the original matrix. # Input - A list of lists `matrix` representing a square matrix of size n x n (2 ≤ n ≤ 10). # Output - A list of lists representing the inverse of the matrix if it exists. - Return specific error codes for the following edge cases: * Return `[[-1]]` if the input is not a matrix. * Return `[[-2]]` if the matrix is not square. * Return `[[-3]]` if the matrix size is less than 2x2. * Return `[[-4]]` if the matrix is singular (determinant is 0). # Constraints - The matrix will contain integers. - Proper handling of floating-point precision is required where applicable. # Example ```python matrix = [ [4, 7], [2, 6] ] print(invert_matrix(matrix)) # Expected Output: [[0.6, -0.7], [-0.2, 0.4]] ``` # Notes - Ensure to validate the input matrix. - Pay attention to floating-point arithmetic for accurate results. # Your Task Implement the `invert_matrix` function following the guidelines described above.","solution":"def determinant(matrix): if len(matrix) == 1: return matrix[0][0] if len(matrix) == 2: return matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0] det = 0 for c in range(len(matrix)): det += ((-1)**c) * matrix[0][c] * determinant(minor(matrix, 0, c)) return det def minor(matrix, i, j): return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def matrix_of_minors(matrix): minors = [] for i in range(len(matrix)): minors_row = [] for j in range(len(matrix)): minors_row.append(determinant(minor(matrix, i, j))) minors.append(minors_row) return minors def matrix_of_cofactors(matrix): cofactors = [] for i in range(len(matrix)): cofactors_row = [] for j in range(len(matrix)): cofactors_row.append(((-1)**(i+j)) * matrix[i][j]) cofactors.append(cofactors_row) return cofactors def transpose(matrix): return list(map(list, zip(*matrix))) def invert_matrix(matrix): if not isinstance(matrix, list) or any(not isinstance(row, list) for row in matrix): return [[-1]] if len(matrix) != len(matrix[0]): return [[-2]] n = len(matrix) if n < 2: return [[-3]] det = determinant(matrix) if det == 0: return [[-4]] minors = matrix_of_minors(matrix) cofactors = matrix_of_cofactors(minors) adjugate = transpose(cofactors) inverse = [[adjugate[i][j] / det for j in range(n)] for i in range(n)] return inverse"},{"question":"# Counting Sort Extension Problem Statement You need to implement an optimized version of the Counting Sort algorithm that can handle both negative and positive integers without transforming the array. The goal is to maintain a linear time complexity for sorting while being mindful of space complexity. Function Signature ```python def extended_counting_sort(arr: List[int]) -> List[int]: pass ``` Input A list of integers `arr` where: - (1 leq len(arr) leq 10^6) - (-10^6 leq arr[i] leq 10^6) Output A sorted list of integers. Constraints - The solution should work efficiently for the provided constraints, ideally within linear time (O(n + k)) where (k) is the range of numbers. Example ```python # Example 1: input_list = [4, -2, -3, 1, 0] output_list = extended_counting_sort(input_list) print(output_list) # Should print [-3, -2, 0, 1, 4] # Example 2: input_list = [1, 3, 2, 3, 1] output_list = extended_counting_sort(input_list) print(output_list) # Should print [1, 1, 2, 3, 3] # Example 3: input_list = [] output_list = extended_counting_sort(input_list) print(output_list) # Should print [] ``` Notes - Handle empty arrays effectively. - You should not modify the input array in terms of adding any offsets. - Any changes in internal representations should be kept within the function and not reflect in the given input array.","solution":"def extended_counting_sort(arr): if not arr: return [] # Find the maximum and minimum values in the array max_val = max(arr) min_val = min(arr) # Calculate the range of elements range_of_elements = max_val - min_val + 1 # Create a count array to store count of individual elements count = [0] * range_of_elements # Store the count of each element in the count array for num in arr: count[num - min_val] += 1 # Modify the count array to store the cumulative count for i in range(1, len(count)): count[i] += count[i - 1] # Output array to be sorted output = [0] * len(arr) # Build the output array using the count and input arrays for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"# Pathfinding in Graphs Background A graph is a collection of nodes connected by edges. Finding paths in a graph between two nodes is a common problem in computer science. Different algorithms can be employed to find various kinds of paths, such as any single path, all possible paths, or the shortest path. These algorithms often use Depth First Search (DFS) due to its simplicity and effectiveness. Task Implement the following functions that operate on a graph represented as a dictionary where keys are node identifiers and values are lists of nodes directly reachable from the key node: 1. **find_path(graph, start, end)** - **Input**: * `graph`: Dictionary representing the graph. * `start`: Starting node. * `end`: Ending node. - **Output**: A list representing a path from `start` to `end` if one exists, otherwise `None`. 2. **find_all_paths(graph, start, end)** - **Input**: * `graph`: Dictionary representing the graph. * `start`: Starting node. * `end`: Ending node. - **Output**: A list of lists, where each inner list is a unique path from `start` to `end`. 3. **find_shortest_path(graph, start, end)** - **Input**: * `graph`: Dictionary representing the graph. * `start`: Starting node. * `end`: Ending node. - **Output**: A list representing the shortest path from `start` to `end`, otherwise `None`. Constraints * Assume all nodes in the graph are unique identifiers (integers or strings). * The graph can be disconnected, directed, or have cycles. * Handle graphs with up to 50 nodes efficiently. * Optimize for both time and space where possible. Performance Requirements * Ensure that the solution can handle graphs with up to 50 nodes and varying edge densities within a time complexity of at most O(V + E) for any single pathfinding query. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [\'C\'], \'E\': [\'F\'], \'F\': [\'C\'] } print(find_path(graph, \'A\', \'D\')) # [\'A\', \'B\', \'D\'] print(find_all_paths(graph, \'A\', \'D\')) # [[\'A\', \'B\', \'D\'], [\'A\', \'B\', \'C\', \'D\'], [\'A\', \'C\', \'D\']] print(find_shortest_path(graph, \'A\', \'D\')) # [\'A\', \'B\', \'D\'] ```","solution":"def find_path(graph, start, end, path=None): Finds any path from start to end in the graph. if path is None: path = [] path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: newpath = find_path(graph, node, end, path) if newpath: return newpath return None def find_all_paths(graph, start, end, path=None): Finds all paths from start to end in the graph. if path is None: path = [] path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: newpaths = find_all_paths(graph, node, end, path) for newpath in newpaths: paths.append(newpath) return paths def find_shortest_path(graph, start, end): Finds the shortest path from start to end in the graph. from collections import deque queue = deque([(start, [start])]) visited = set() while queue: (node, path) = queue.popleft() if node in visited: continue for next_node in graph.get(node, []): if next_node in visited: continue if next_node == end: return path + [end] queue.append((next_node, path + [next_node])) visited.add(node) return None"},{"question":"# Problem Description Given a directed graph represented as an adjacency list, write a function `detect_cycle_in_directed_graph` to determine if the graph contains a cycle. You are to implement this function without using recursion. Instead, use an explicit stack for lifecycle tracking of nodes to simulate the depth-first search algorithm. # Function Signature ```python def detect_cycle_in_directed_graph(graph: dict) -> bool: Determines if the given directed graph contains a cycle. Parameters: graph (dict): A dictionary where the key is a node and the value is a list of its adjacent nodes. Returns: bool: True if the graph contains a cycle, False otherwise. pass ``` # Input Format - `graph` : A dictionary where the key is a node and the value is a list of its adjacent nodes. # Output Format - Return `True` if the graph contains a cycle, otherwise `False`. # Constraints - The graph can have up to 10^4 nodes. - Each node can have up to 10^4 edges. # Example Example 1: ```python graph = {\'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': []} print(detect_cycle_in_directed_graph(graph)) # Output: True ``` Example 2: ```python graph = {\'A\': [\'B\'], \'B\': [\'C\'], \'C\': []} print(detect_cycle_in_directed_graph(graph)) # Output: False ``` # Notes - Consider edge cases such as a graph with no edges, self-loops, or multiple disjoint graph components. - Ensure to use an explicit stack to avoid deep recursion issues.","solution":"def detect_cycle_in_directed_graph(graph: dict) -> bool: Determines if the given directed graph contains a cycle. Parameters: graph (dict): A dictionary where the key is a node and the value is a list of its adjacent nodes. Returns: bool: True if the graph contains a cycle, False otherwise. WHITE, GRAY, BLACK = 0, 1, 2 def dfs(node): stack = [node] while stack: node = stack.pop() if color[node] == WHITE: color[node] = GRAY stack.append(node) for neighbor in graph.get(node, []): if color[neighbor] == WHITE: stack.append(neighbor) elif color[neighbor] == GRAY: return True elif color[node] == GRAY: color[node] = BLACK return False color = {node: WHITE for node in graph} for node in graph: if color[node] == WHITE: if dfs(node): return True return False"},{"question":"**Context**: You have learned about AVL trees, a type of self-balancing binary search tree (BST). They automatically balance themselves during insertions and deletions to ensure that the depth of the tree remains logarithmic relative to the number of elements inside. This results in efficient searches, insertions, and deletions. # Task: Implement an AVL Tree with insertion, deletion, and in-order traversal functionalities. Write a Python class `AVLTree` from scratch that supports these operations. # Requirements: 1. **Class Structure**: - Create a class called `AVLTree` with these methods: - `insert(key: int) -> None`: Inserts a key into the AVL tree. - `delete(key: int) -> None`: Deletes a key from the AVL tree (if it exists). - `in_order_traverse() -> List[int]`: Returns the keys of the AVL tree in in-order traversal order. 2. **Input/Output**: - `insert(key: int)`: No return value. - `delete(key: int)`: No return value. - `in_order_traverse() -> List[int]`: Returns the elements of the tree in sorted order. 3. **Constraints**: - Keys will be unique integers. - The methods should handle edge cases appropriately, such as inserting into an empty tree or deleting non-existent keys. 4. **Balancing**: Ensure the AVL tree maintains its balance factor after each insertion and deletion via rotations. # Your Implementation: Use the following skeleton to structure your AVL tree: ```python class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, key: int) -> None: Insert key into the AVL tree and balance the tree. # Your code here def delete(self, key: int) -> None: Delete a key from the AVL tree and balance the tree. # Your code here def in_order_traverse(self) -> List[int]: Perform in-order traversal of the tree and return the keys. # Your code here # Additional helper functions for balancing, rotations, etc. ``` # Evaluation Criteria: 1. **Correctness**: The AVL tree operations should correctly insert, delete and maintain the balance of the tree. 2. **Efficiency**: The implementation should efficiently handle insertion, deletion, and traversal in logarithmic time. 3. **Code Quality**: Clear, readable code with appropriate comments and error handling.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, key: int) -> None: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left if balance > 1 and key < node.left.key: return self._right_rotate(node) # Right Right if balance < -1 and key > node.right.key: return self._left_rotate(node) # Left Right if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Left if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def delete(self, key: int) -> None: self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp_node = self._get_min_value_node(node.right) node.key = temp_node.key node.right = self._delete(node.right, temp_node.key) if not node: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) # Left Right if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Right if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) # Right Left if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left) def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def in_order_traverse(self) -> list: result = [] self._in_order_traverse(self.root, result) return result def _in_order_traverse(self, node, result): if not node: return self._in_order_traverse(node.left, result) result.append(node.key) self._in_order_traverse(node.right, result)"},{"question":"You are tasked with implementing an algorithm to reverse a given string, but with a twist. You will write a function that utilizes a specific inventive method to reverse the string, similar to the analyzed algorithms. This method will focus on utilizing iterative steps with two-pointers but with an added constraint: You may not use additional arrays or slicing functionalities provided by Python. # Task Implement the function `custom_reverse(s)` that takes a string `s` and returns the reversed string. # Input - `s` (1 <= len(s) <= 10^5): A non-empty string consisting of printable ASCII characters. # Output - A string that represents the input string reversed. # Constraints - You cannot use additional arrays or list slicing techniques. - You should aim for an O(n) time complexity and O(1) additional space complexity (except for the input string storage). # Example ```python def custom_reverse(s): # Your code here # Example usage: print(custom_reverse(\\"hello\\")) # Output: \\"olleh\\" print(custom_reverse(\\"abc\\")) # Output: \\"cba\\" print(custom_reverse(\\"a\\")) # Output: \\"a\\" ``` # Note - Ensure your function correctly handles edge cases such as strings with a single character. - Consider the implications of swapping characters in-place.","solution":"def custom_reverse(s): Reverses the given string `s` using a two-pointer approach without additional arrays or slicing. Parameters: s (str): The input string to reverse. Returns: str: The reversed string. # Convert the string to a list of characters to allow modification (strings are immutable in Python) s_list = list(s) left, right = 0, len(s_list) - 1 while left < right: # Swap characters at left and right pointers s_list[left], s_list[right] = s_list[right], s_list[left] left += 1 right -= 1 # Convert the list back to a string return \'\'.join(s_list)"},{"question":"# Question: Context: You are tasked with implementing a `SeparateChainingHashTable`, which maps keys to values using a hash function. This hash table uses separate chaining for collision resolution, where each bucket is a linked list of nodes. Your objective is to complete the implementation of two fundamental methods (`resize` and `clear`) that enhance the functionality of your hash table. Requirements: 1. **Method `resize(self, new_size)`**: - This method should resize the hash table to `new_size`. - It should rehash all existing keys and distribute them into the new table size. - Update the internal attributes accordingly. - Time complexity should ideally remain close to O(n). 2. **Method `clear(self)`**: - This method should remove all entries from the hash table. - After clearing, the size should be reset to the initial default size (11). - The number of elements should be zero. - Time complexity should be O(1). Function Signatures: ```python def resize(self, new_size: int) -> None: pass def clear(self) -> None: pass ``` Input/Output Formats: 1. **resize(new_size)**: - **Input**: An integer `new_size` (1 < `new_size` <= 100000) - **Output**: None (the hash table should be resized internally) 2. **clear()**: - **Input**: None - **Output**: None (the hash table should be cleared) Constraints: - Ensure the keys are distributed uniformly using the hash function after resizing. - Assume the `put`, `get`, and other methods work as intended. - Do not alter the given class structure except for adding the required methods. - Assume integer keys and valid value types for simplicity. Example Usage: ```python table = SeparateChainingHashTable() table.put(\'key1\', \'value1\') table.put(\'key2\', \'value2\') table.resize(20) assert table.get(\'key1\') == \'value1\' assert len(table) == 2 table.clear() assert len(table) == 0 assert table.get(\'key1\') is None assert table.size == 11 ``` # Provided Code: ```python class SeparateChainingHashTable(object): _empty = None def __init__(self, size=11): self.size = size self._len = 0 self._table = [self._empty] * size def put(self, key, value): hash_ = self.hash(key) node_ = self._table[hash_] if node_ is self._empty: self._table[hash_] = Node(key, value) else: while node_.next is not None: if node_.key == key: node_.value = value return node_ = node_.next node_.next = Node(key, value) self._len += 1 def get(self, key): hash_ = self.hash(key) node_ = self._table[hash_] while node_ is not self._empty: if node_.key == key: return node_.value node_ = node_.next return None def del_(self, key): hash_ = self.hash(key) node_ = self._table[hash_] pre_node = None while node_ is not None: if node_.key == key: if pre_node is None: self._table[hash_] = node_.next else: pre_node.next = node_.next self._len -= 1 pre_node = node_ node_ = node_.next def hash(self, key): return hash(key) % self.size def __len__(self): return self._len def __getitem__(self, key): return self.get(key) def __delitem__(self, key): return self.del_(key) def __setitem__(self, key, value): self.put(key, value) # Implement these methods def resize(self, new_size: int) -> None: pass def clear(self) -> None: pass ```","solution":"class SeparateChainingHashTable(object): _empty = None def __init__(self, size=11): self.default_size = size self.size = size self._len = 0 self._table = [self._empty] * size def put(self, key, value): hash_ = self.hash(key) node_ = self._table[hash_] if node_ is self._empty: self._table[hash_] = Node(key, value) else: while node_.next is not None: if node_.key == key: node_.value = value return node_ = node_.next node_.next = Node(key, value) self._len += 1 def get(self, key): hash_ = self.hash(key) node_ = self._table[hash_] while node_ is not self._empty: if node_.key == key: return node_.value node_ = node_.next return None def del_(self, key): hash_ = self.hash(key) node_ = self._table[hash_] pre_node = None while node_ is not None: if node_.key == key: if pre_node is None: self._table[hash_] = node_.next else: pre_node.next = node_.next self._len -= 1 pre_node = node_ node_ = node_.next def hash(self, key): return hash(key) % self.size def __len__(self): return self._len def __getitem__(self, key): return self.get(key) def __delitem__(self, key): return self.del_(key) def __setitem__(self, key, value): self.put(key, value) def resize(self, new_size: int) -> None: old_table = self._table old_size = self.size self.size = new_size self._table = [self._empty] * new_size self._len = 0 for i in range(old_size): node = old_table[i] while node is not self._empty: self.put(node.key, node.value) node = node.next def clear(self) -> None: self.size = self.default_size self._table = [self._empty] * self.default_size self._len = 0 class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None"},{"question":"# Selection Sort Algorithm Implementation **Context**: You work as a software engineer and are asked to implement a basic sorting function to sort small-sized datasets quickly. The company prefers simple, easy-to-understand algorithms for their educational purposes. **Task**: Implement the Selection Sort algorithm to sort an array in ascending order. **Function Signature**: ```python def selection_sort(arr: List[int]) -> List[int]: ``` **Input**: * `arr` (List[int]): An array of integers to be sorted. **Output**: * (List[int]): The sorted array in ascending order. **Constraints**: * The input list will contain a maximum of `1000` elements. * Each element in the input list will be an integer within the range `[-10^6, 10^6]`. **Example**: ```python assert selection_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64] assert selection_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert selection_sort([]) == [] assert selection_sort([1]) == [1] ``` **Performance Requirement**: The function should complete within `2` seconds for all inputs handed. **Additional Notes**: Implement the function without using any library sort functions.","solution":"from typing import List def selection_sort(arr: List[int]) -> List[int]: Implements the Selection Sort algorithm to sort an array in ascending order. Parameters: arr (List[int]): An array of integers to be sorted. Returns: List[int]: The sorted array in ascending order. n = len(arr) for i in range(n): # Find the minimum element in the remaining unsorted array min_index = i for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j # Swap the found minimum element with the first element of the unsorted part arr[i], arr[min_index] = arr[min_index], arr[i] return arr"},{"question":"# Question Implement a function that sorts an array of integers using the Selection Sort algorithm. Additionally, implement a secondary function that determines whether the array is sorted after the sorting operation and returns a corresponding boolean value. Function Signature ```python def selection_sort_and_validate(arr: list) -> tuple: Sorts the array using Selection Sort and returns the sorted array along with a boolean indicating whether the array is sorted correctly. ``` Input - A list of integers `arr` (0 <= len(arr) <= 1000, -10^3 <= arr[i] <= 10^3). Output - A tuple (sorted_array, is_sorted_correctly). Example ```python selection_sort_and_validate([64, 25, 12, 22, 11]) # Output: ([11, 12, 22, 25, 64], True) selection_sort_and_validate([5, 4, 3, 2, 1]) # Output: ([1, 2, 3, 4, 5], True) selection_sort_and_validate([1, 2, 3, 3, 2]) # Output: ([1, 2, 2, 3, 3], True) selection_sort_and_validate([1]) # Output: ([1], True) selection_sort_and_validate([]) # Output: ([], True) ``` Constraints - Your solution should handle edge cases like empty arrays, arrays with one element, and arrays with repeated values. - Ensure your function\'s correctness by verifying the result within the same function. Performance Requirements - Ensure the function runs efficiently for the given constraints. - Aim to minimize the number of swaps or unnecessary operations.","solution":"def selection_sort_and_validate(arr): Sorts the array using Selection Sort and returns the sorted array along with a boolean indicating whether the array is sorted correctly. n = len(arr) for i in range(n): min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] is_sorted_correctly = all(arr[k] <= arr[k + 1] for k in range(n - 1)) return arr, is_sorted_correctly"},{"question":"# 1-Sparse Stream Recovery Algorithm Objective: You are to implement the `one_sparse` function to determine whether a given stream of tuples (each containing a number and a sign) results in a single unique number when processed. Function Signature: ```python def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: ``` Input: - `array`: A list of tuples, where each tuple contains an integer (`val`) and a sign (`\'+\'` or `\'-\'`). - The list size will be at most `10^6`. - The integer values in the stream are non-negative and no larger than `10^9`. Output: - Return the unique integer if the stream is 1-sparse, i.e., results in a single unique number after all cancellations. - Return `None` if the stream is not 1-sparse. Constraints: - The stream only contains integers and their associated signs. - The processing should be efficient and must handle up to `10^6` tuples. Example: 1. ```python input = [(4, \'+\'), (2, \'+\'), (2, \'-\'), (4, \'+\'), (3, \'+\'), (3, \'-\')] output = 4 ``` 2. ```python input = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\')] output = 2 ``` 3. ```python input = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (1, \'+\')] output = None ``` Notes: - This algorithm assumes the stream strictly contains non-negative integers. - Consider edge cases such as all positive entries, mixed entries leading to zero balance, and unique numbers. Implement the `one_sparse` function to successfully determine if the provided stream is 1-sparse or not.","solution":"from typing import List, Tuple, Optional from collections import Counter def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: Determines whether a given stream of tuples (each containing a number and a sign) results in a single unique number when processed. :param array: List[Tuple[int, str]], list of tuples each containing an integer and a sign (\'+\' or \'-\') :return: int if the stream is 1-sparse, None otherwise counter = Counter() for val, sign in array: if sign == \'+\': counter[val] += 1 elif sign == \'-\': counter[val] -= 1 non_zero_values = [k for k, v in counter.items() if v != 0] if len(non_zero_values) == 1: return non_zero_values[0] return None"},{"question":"# Question: Prime Sum Sequence Given a number `N`, find the maximum number of consecutive prime numbers that sum up to `N`. Input: - An integer `N` (2 <= N <= 10^6). Output: - The maximum number of consecutive prime numbers that sum to `N`. Examples: 1. For `N = 41`, the consecutive prime numbers are `[2, 3, 5, 7, 11, 13]` (sum = 41). The output is `6` as there are 6 prime numbers. 2. For `N = 20`, the prime numbers are `[2, 3, 5, 7]` (sum = 17) or `[3, 5, 7]` (sum = 15). No consecutive primes sum up to 20, so the output is `0`. Guidelines: - Use the provided `prime_check(n)` function or implement your own version. - Ensure optimization to handle the upper constraints effectively. ```python def prime_check(n): Return True if n is a prime number Else return False. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False j = 5 while j * j <= n: if n % j == 0 or n % (j + 2) == 0: return False j += 6 return True def find_max_consecutive_prime_sum(N): # Implement your solution here pass # Example Usage: # print(find_max_consecutive_prime_sum(41)) # Output: 6 # print(find_max_consecutive_prime_sum(20)) # Output: 0 ```","solution":"def prime_check(n): Return True if n is a prime number Else return False. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False j = 5 while j * j <= n: if n % j == 0 or n % (j + 2) == 0: return False j += 6 return True def find_max_consecutive_prime_sum(N): def sieve(n): Generate a list of primes up to n inclusive. is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return [p for p in range(2, n + 1) if is_prime[p]] primes = sieve(N) max_len = 0 for i in range(len(primes)): total_sum = 0 for j in range(i, len(primes)): total_sum += primes[j] if total_sum > N: break if total_sum == N: max_len = max(max_len, j - i + 1) return max_len # Example Usage: # print(find_max_consecutive_prime_sum(41)) # Output: 6 # print(find_max_consecutive_prime_sum(20)) # Output: 0"},{"question":"Height of a Binary Tree Background A binary tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child. The height of a binary tree is defined as the number of levels in the tree. An empty tree has a height of 0, a tree with one node has a height of 1, and the height increases by one for each additional level of nodes. Task Write a function `height` in Python that accepts the root of a binary tree and returns the height of the tree. You are required to use a recursive approach to implement the function. Function Signature ```python def height(root) -> int: pass ``` Input - The input `root` is the root node of a binary tree. Output - The function should return an integer, representing the height of the binary tree. Constraints - The number of nodes in the tree is between 0 and 1000. - Node values are integers. Example Consider the following binary tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` For this tree, the function call `height(root)` should return `4`. Implementation Constraints - Your solution should use a recursive approach to compute the height of the tree. - Ensure that your solution handles edge cases like an empty tree (should return 0) and a tree with only one node. # Testing You are provided with a unit test `TestSuite` to validate your implementation. Ensure the following tree is constructed in the `setUp` method of the test suite: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` The test `test_height` should verify that the `height` function returns `4` for this tree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def height(root): Returns the height of the binary tree with the given root. if root is None: return 0 else: left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"Heap Sort for Unique Identifiers **Scenario**: A company wants to sort a list of unique identifiers using a Heap Sort algorithm. The unique identifiers should be sorted in ascending order. Each identifier is an integer, and the list can be very large. To ensure the approach is efficient and maintains low memory usage, the company has decided to use Heap Sort. **Task**: Implement an `identifier_heap_sort` function that uses Heap Sort to sort an array of unique identifiers in ascending order. **Function Signature**: ```python def identifier_heap_sort(arr: List[int], max_heap: bool = True) -> List[int]: ``` # Input: * `arr` - A list of integers representing unique identifiers. * `max_heap` - A boolean (default to True); if True, use Max-Heap sort, otherwise use Min-Heap sort. # Output: * The sorted list of integers in ascending order. # Constraints: * You must use an in-place sorting algorithm. * Time complexity should not exceed O(n log(n)). * You are not allowed to use any built-in sorting functions. # Example: ```python # Example 1: input = [3, 1, 9, 7, 2, 8] output = identifier_heap_sort(input) # Expected Output: [1, 2, 3, 7, 8, 9] # Example 2: input = [29, 25, 3, 49, 9, 37, 21] output = identifier_heap_sort(input, max_heap=False) # Expected Output: [3, 9, 21, 25, 29, 37, 49] ``` # Notes: - Handle edge cases such as an empty array or an array with one element. - Ensure your solution is well optimized and handles large input sizes efficiently.","solution":"from typing import List def identifier_heap_sort(arr: List[int], max_heap: bool = True) -> List[int]: def heapify(arr, n, i, max_heap): largest = i # Initialize largest as root for max heap smallest = i # Initialize smallest as root for min heap left = 2 * i + 1 right = 2 * i + 2 if max_heap: if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest, max_heap) else: if left < n and arr[left] < arr[smallest]: smallest = left if right < n and arr[right] < arr[smallest]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] heapify(arr, n, smallest, max_heap) n = len(arr) # Build a max/min heap for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, max_heap) for i in range(n-1, 0, -1): # Swap arr[i], arr[0] = arr[0], arr[i] # Heapify root element heapify(arr, i, 0, max_heap) if not max_heap: arr.reverse() return arr"},{"question":"# Question You are tasked with implementing a solution for encoding and decoding a list of strings to facilitate transmission over a network. Design and implement the functions `encode` and `decode`, which handle these operations reliably even under edge cases. Requirements * **Function 1**: `encode(strs)` - Input: `strs` - A list of strings. - Output: A single encoded string. * **Function 2**: `decode(s)` - Input: `s` - An encoded string. - Output: A list of strings. Input and Output Formats * `encode` * Input: List of strings `strs` such as `[\\"hello\\", \\"world\\"]`. * Output: Encoded string `s` such as `\\"5:hello5:world\\"`. * `decode` * Input: Encoded string `s` such as `\\"5:hello5:world\\"`. * Output: List of strings `strs` such as `[\\"hello\\", \\"world\\"]`. Constraints * You may assume that all strings in the input list are non-empty and contain only printable ASCII characters. * Strings should avoid using the character `\':\'` as data to avoid conflicts with the delimiter. # Example ```python encoded = encode([\\"hello\\", \\"world\\"]) print(encoded) # Output: \\"5:hello5:world\\" decoded = decode(\\"5:hello5:world\\") print(decoded) # Output: [\\"hello\\", \\"world\\"] ``` # Performance * The solution should be efficient in terms of both time and space complexities. * Consider optimizations for handling large volumes of data. Implement the functions as specified to achieve the desired encoding and decoding functionalities.","solution":"def encode(strs): Encodes a list of strings to a single string. :param strs: List of strings to encode :return: Encoded single string encoded_str = \'\' for s in strs: encoded_str += f\'{len(s)}:{s}\' return encoded_str def decode(s): Decodes a single string to a list of strings. :param s: Encoded string to decode :return: List of decoded strings decoded_list = [] i = 0 while i < len(s): # Find the separator \':\' j = i while s[j] != \':\': j += 1 # Find the length of the next string length = int(s[i:j]) # Extract the string decoded_str = s[j + 1:j + 1 + length] decoded_list.append(decoded_str) # Move to the next part of the encoded string i = j + 1 + length return decoded_list"},{"question":"# Switch Successive Pairs in Stack You are provided with a stack of integers and two functions, `first_switch_pairs` and `second_switch_pairs`, designed to switch successive pairs of elements within the stack. Write a new function `optimized_switch_pairs` that accomplishes the same goal but optimizes the space complexity to O(1) without using any auxiliary storage. Your function should adhere to the stack (LIFO) principle, retain the order, and handle the same edge cases appropriately. # Input * `stack`: A list of integers representing the stack, where the last element of the list is the top of the stack. # Output * The stack after switching successive pairs. # Constraints * The stack will have at most 10^5 elements. * Elements in the stack can range between -10^9 to 10^9. # Example Input ``` python stack = [3, 8, 17, 9, 1, 10] ``` Output ``` python [8, 3, 9, 17, 10, 1] ``` Input ``` python stack = [3, 8, 17, 9, 1] ``` Output ``` python [8, 3, 9, 17, 1] ``` # Note 1. If the stack has an odd number of elements, the last element remains in place. 2. You must not use any additional data structures like stacks, queues, or lists. # Function Signature ``` python def optimized_switch_pairs(stack: List[int]) -> List[int]: pass ``` Implement the `optimized_switch_pairs` function to complete this task.","solution":"def optimized_switch_pairs(stack): Optimizes space complexity to O(1) while switching successive pairs in the stack. # Iterate over the stack in steps of 2 to switch successive pairs for i in range(0, len(stack) - 1, 2): # Swap elements at positions i and i+1 stack[i], stack[i+1] = stack[i+1], stack[i] return stack"},{"question":"# Question: Implement Hierarchical Tree Traversal and Printing Given a hierarchical tree structure represented using nested dictionaries and lists, implement a function that effectively prints the entire structure with proper indentation, ensuring clarity and readability. Input * A dictionary `tree` where: * Keys are strings representing parent nodes. * Values are lists that contain a mix of strings (representing child nodes and leaf data) and integers. Output * Print each top-level item and its sub-items on separate lines, where each level of hierarchy is represented by an additional level of indentation of two spaces. Constraints * Tree `tree` can be empty, or nodes can vary in depth. * All node names are unique strings. * Numerical values indicate leaf nodes, and they should appear inline with their parent nodes. # Implementation Requirements 1. Optimize the function to avoid redundant lookups. 2. Ensure proper handling of varying data types. # Example ```python tree = { \\"a\\": [\\"Adam\\", \\"Book\\", 4], \\"b\\": [\\"Bill\\", \\"Computer\\", 5, \\"TV\\", 6, \\"Jill\\", \\"Sports\\", 1], \\"c\\": [\\"Bill\\", \\"Sports\\", 3], \\"d\\": [\\"Adam\\", \\"Computer\\", 3, \\"Quin\\", \\"Computer\\", 3], \\"e\\": [\\"Quin\\", \\"Book\\", 5, \\"TV\\", 2], \\"f\\": [\\"Adam\\", \\"Computer\\", 7] } tree_print(tree) ``` Expected Output ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Additional Notes 1. Pay attention to formatting details to ensure the output maintains a clear hierarchical perspective of tree elements. 2. Consider edge cases, such as empty tree structures and varied depths. 3. Optimize for readability and maintainability.","solution":"def tree_print(tree, indent=0): Prints a hierarchical tree structure with proper indentation. Parameters: tree (dict): A dictionary representing the hierarchical tree. indent (int): The current indentation level (used for recursive calls). for key, values in tree.items(): print(\\" \\" * indent + str(key)) for value in values: if isinstance(value, dict): tree_print(value, indent + 2) else: print(\\" \\" * (indent + 2) + str(value))"},{"question":"# RSA Encryption Design & Implementation As a new encryption expert, you\'ve been tasked with developing a secure communication channel for a company\'s internal systems, using RSA encryption. **Objective**: Implement an RSA encryption-decryption system tailored for small data messages. You need to: 1. Write a function to generate RSA keys. 2. Write functions to encrypt and decrypt messages using the generated keys. Function Specifications 1. **generate_rsa_keys(bits, seed=None)** - **Input**: - `bits` (int): Number of bits for the modulus (recommended: at least 16 bits for educational purposes). - `seed` (optional int): Seed for random number generator (useful for testing). - **Output**: Tuple `(n, e, d)` where: - `n` (int): Modulus. - `e` (int): Public exponent for encryption. - `d` (int): Private exponent for decryption. 2. **rsa_encrypt(data, e, n)** - **Input**: - `data` (int): The number to be encrypted. - `e` (int): Public exponent. - `n` (int): Modulus. - **Output**: - (int): Encrypted data. 3. **rsa_decrypt(data, d, n)** - **Input**: - `data` (int): The encrypted data. - `d` (int): Private exponent. - `n` (int): Modulus. - **Output**: - (int): Decrypted original data. Constraints - Ensure `data` for encryption fits within the size of `n`. - `bits` must be an integer greater than 1. - Efficient generation and handling of large prime numbers are critical. - Handle errors gracefully, especially in key generation. Example Usage ```python n, e, d = generate_rsa_keys(16, seed=42) data = 123 encrypted_data = rsa_encrypt(data, e, n) decrypted_data = rsa_decrypt(encrypted_data, d, n) assert decrypted_data == data ``` **Note**: Use the provided helper functions and ensure no hard-coded values.","solution":"import random from sympy import isprime, mod_inverse def generate_prime(bits, seed=None): if seed is not None: random.seed(seed) while True: num = random.getrandbits(bits) if isprime(num): return num def generate_rsa_keys(bits, seed=None): if bits <= 1: raise ValueError(\\"Number of bits must be greater than 1\\") p = generate_prime(bits, seed) q = generate_prime(bits, seed + 1 if seed is not None else None) n = p * q phi = (p - 1) * (q - 1) e = 65537 if e > phi or mod_inverse(e, phi) is None: e = 3 d = mod_inverse(e, phi) return n, e, d def rsa_encrypt(data, e, n): if data >= n: raise ValueError(\\"Data too large for the modulus\\") return pow(data, e, n) def rsa_decrypt(data, d, n): return pow(data, d, n)"},{"question":"**Question**: Implement the Binary Search Tree (BST) from scratch as defined in the provided skeleton code. Your task is to complete the methods for inserting, searching, calculating the size, and performing preorder, inorder, and postorder traversals. # Function Definitions 1. `insert(data: int) -> bool`: Insert the given data into the BST, maintaining the BST properties. Return `True` if the insertion was successful, `False` if the data already exists in the tree. 2. `search(data: int) -> bool`: Search for the given data in the BST. Return `True` if the data is found, `False` otherwise. 3. `size() -> int`: Return the total number of elements present in the BST. 4. `preorder(root: Node)`: Perform a preorder traversal of the BST and print the elements. 5. `inorder(root: Node)`: Perform an inorder traversal of the BST and print the elements. 6. `postorder(root: Node)`: Perform a postorder traversal of the BST and print the elements. # Input/Output Constraints * **Insert**: A non-none integer value. * **Search**: A non-none integer value. * **Traversal Methods**: Print each element\'s value in the respective traversal order, followed by a space (no trailing space at the end). # Task You must ensure your BST can handle various edge cases, such as: * Inserting duplicate values should not be allowed. * Searching for values that are not present in the tree should return `False`. # Example Usage ```python # Create BST instance bst = BST() # Insert elements into BST bst.insert(10) bst.insert(15) bst.insert(6) # Search elements in BST print(bst.search(15)) # True print(bst.search(20)) # False # Size of BST print(bst.size()) # 3 # Traversal output (assuming bst.root is the root node) bst.inorder(bst.get_root()) # Expected output: 6 10 15 ``` # Note: * Make sure to handle edge cases where the tree may be empty. * Use recursion for insertions and searches. * Optimize your solution to handle large datasets efficiently.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None self.node_count = 0 def get_root(self): return self.root def insert(self, data): if self.root is None: self.root = Node(data) self.node_count += 1 return True return self._insert(self.root, data) def _insert(self, node, data): if data < node.data: if node.left is None: node.left = Node(data) self.node_count += 1 return True else: return self._insert(node.left, data) elif data > node.data: if node.right is None: node.right = Node(data) self.node_count += 1 return True else: return self._insert(node.right, data) else: # data is already in the tree return False def search(self, data): return self._search(self.root, data) def _search(self, node, data): if node is None: return False if data < node.data: return self._search(node.left, data) elif data > node.data: return self._search(node.right, data) else: return True def size(self): return self.node_count def preorder(self, root): if root: print(root.data, end=\\" \\") self.preorder(root.left) self.preorder(root.right) def inorder(self, root): if root: self.inorder(root.left) print(root.data, end=\\" \\") self.inorder(root.right) def postorder(self, root): if root: self.postorder(root.left) self.postorder(root.right) print(root.data, end=\\" \\")"},{"question":"You are given a linked list and your task is to implement a function `find_unsorted_node` that identifies the first node in the list where the order property (non-decreasing) is violated. If the list is sorted or empty, the function should return `None`. Below are key points for your implementation: 1. Define the function `find_unsorted_node(head)`. 2. The function should take the `head` of a singly linked list as input and return the first node where the sorting breaks or `None` if the list is sorted. 3. The linked list node is defined as: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Input: - `head`: The head of a singly linked list (`ListNode` or `None`). Output: - Return the first node (`ListNode`) where the order (non-decreasing) is violated, or `None` if the list is sorted or empty. Constraints: - The values of nodes are integers. - Nodes are instances of the `ListNode` class. # Example: 1. **Input**: `head` pointing to the list `[1, 2, 4, 3, 5]` - **Output**: Node with value `4`. 2. **Input**: `head` pointing to the list `[1, 2, 3, 4, 5]` - **Output**: `None`. 3. **Input**: `head` is `None`. - **Output**: `None`. # Constraints: - You must avoid using extra space proportional to the number of elements in the list (constant additional space). - The time complexity should be O(n), where n is the number of nodes in the list. # Function Signature: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_unsorted_node(head): # Your code here ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_unsorted_node(head): if not head or not head.next: return None current = head while current and current.next: if current.val > current.next.val: return current current = current.next return None"},{"question":"# Set Cover Problem with Cost Context You are given a set of elements and a collection of subsets, each with an associated cost. Your task is to implement a function that selects a subcollection of the subsets such that all elements of the universal set are covered, and the total cost is minimized. This is known as the Set Cover Problem with costs. You\'ll implement both an optimal algorithm for exact solutions and a greedy algorithm for large inputs. Function Specifications 1. **Optimal Algorithm Function**: `optimal_set_cover(universe, subsets, costs)` 2. **Greedy Algorithm Function**: `greedy_set_cover(universe, subsets, costs)` Input - `universe`: A set of unique integers representing the universal set of elements. - `subsets`: A dictionary where keys are strings representing subset names and values are sets of integers representing the subsets. - `costs`: A dictionary where keys are subset names and values are integers representing the associated cost of each subset. Output - Returns a list of subset names that minimize the cost while covering the entire universal set of elements. Constraints - All subsets combined must be able to cover the entire universal set. - Subset names are unique strings. - If there are multiple solutions with the same minimum cost, return any one of them. - `1 <= len(universe) <= 20` for the optimal solution. - `1 <= len(universe) <= 1000` for the greedy solution. Performance - The optimal algorithm should prioritize correctness and minimal cost, suitable for small input sizes. - The greedy algorithm should perform well on larger inputs, prioritizing speed. Example ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} # Expected output for optimal algorithm optimal_cover = optimal_set_cover(universe, subsets, costs) print(optimal_cover) # Returns subsets with minimal cost: e.g., [\'S2\', \'S3\'] with cost 13 # Expected output for greedy algorithm greedy_cover = greedy_set_cover(universe, subsets, costs) print(greedy_cover) # Returns subsets with minimal cost: e.g., [\'S3\', \'S2\'] with cost 13 ``` Notes - Consider edge cases such as when one subset alone covers the entire universe or there are subsets with no elements. - Avoid computational inefficiencies by using set operations for union and difference wherever applicable.","solution":"import itertools def optimal_set_cover(universe, subsets, costs): Finds the optimal set cover with minimal cost. best_cover = None min_cost = float(\'inf\') subset_names = list(subsets.keys()) for r in range(1, len(subset_names) + 1): for combination in itertools.combinations(subset_names, r): cover = set() cost = 0 for subset in combination: cover.update(subsets[subset]) cost += costs[subset] if cover == universe and cost < min_cost: min_cost = cost best_cover = combination return list(best_cover) if best_cover else [] def greedy_set_cover(universe, subsets, costs): Uses a greedy algorithm to find an approximate set cover with minimal cost. selected_subsets = [] elements_covered = set() while elements_covered != universe: best_subset = None best_cost_efficiency = float(\'inf\') best_subset_elements = set() for subset_name, subset_elements in subsets.items(): additional_elements = subset_elements - elements_covered if additional_elements: cost_efficiency = costs[subset_name] / len(additional_elements) if cost_efficiency < best_cost_efficiency: best_cost_efficiency = cost_efficiency best_subset = subset_name best_subset_elements = additional_elements if best_subset: selected_subsets.append(best_subset) elements_covered.update(best_subset_elements) return selected_subsets"},{"question":"# Decoding Ways using Dynamic Programming A message containing letters from A-Z is being encoded to numbers using the following mapping: * \'A\' -> 1 * \'B\' -> 2 ... * \'Z\' -> 26 Given an encoded message containing digits, determine the total number of ways to decode it. For example, given the encoded message `\\"12\\"`, it could be decoded as `\\"AB\\"` (1 2) or `\\"L\\"` (12). Thus, the number of ways to decode `\\"12\\"` is 2. **Function Signature**: ```python def num_decodings(enc_mes: str) -> int: pass ``` # Input: - A string `enc_mes` containing the encoded message (1 <= length of string <= 100). # Output: - An integer representing the total number of ways the input message can be decoded. # Constraints: - The encoded message will contain only digits and must not start with \'0\'. # Performance Requirements: - Time complexity should be O(n), where `n` is the length of the input string. - Space complexity should be O(1) or O(n) depending on the chosen implementation approach. # Example: ```python assert num_decodings(\\"12\\") == 2 # \\"AB\\", \\"L\\" assert num_decodings(\\"226\\") == 3 # \\"BZ\\", \\"VF\\", \\"BBF\\" assert num_decodings(\\"0\\") == 0 # No valid decodings assert num_decodings(\\"10\\") == 1 # \\"J\\" ``` # Tips: * Handle cases where digits `0` appear carefully, they can only be part of valid two-digit numbers (i.e., 10, 20). * Single valid digits form valid decoding options by themselves. * Utilize dynamic programming to keep track of the number of ways to decode the message up to each point.","solution":"def num_decodings(enc_mes: str) -> int: Returns the total number of ways to decode an encoded message. Parameters: enc_mes (str): Encoded message containing digits. Returns: int: Total number of ways to decode the message. if not enc_mes or enc_mes[0] == \'0\': return 0 # dp[i] will store the number of ways to decode the substring of length i n = len(enc_mes) dp = [0] * (n + 1) dp[0] = 1 # Base case: there\'s 1 way to decode an empty string # Single character decode dp[1] = 1 if enc_mes[0] != \'0\' else 0 for i in range(2, n + 1): # One step jump if enc_mes[i - 1] != \'0\': dp[i] += dp[i - 1] # Two step jump two_digit = int(enc_mes[i - 2:i]) if 10 <= two_digit <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"You are given a pattern and a string. Your task is to determine if the string follows the same pattern. Follow means a full match where each character in the pattern maps to a unique, non-empty substring in the string, and vice versa. Write a function `string_follows_pattern(pattern: str, string: str) -> bool` that returns `True` if the string follows the pattern, and `False` otherwise. # Example ```python assert string_follows_pattern(\\"abab\\", \\"redblueredblue\\") == True assert string_follows_pattern(\\"aaaa\\", \\"asdasdasdasd\\") == True assert string_follows_pattern(\\"aabb\\", \\"xyzabcxyzabc\\") == False ``` # Functional Requirements * **Input**: Two strings `pattern` (1 ≤ len(pattern) ≤ 18) and `string` (1 ≤ len(string) ≤ 1000). * **Output**: A boolean indicating whether the pattern is matched by the string. * **Constraints**: * Both `pattern` and `string` must only contain lowercase alphabetic characters. # Note * Assume both `pattern` and `string` contain only lowercase letters. * You are required to implement a solution that is efficient and handles edge cases appropriately. # Tips Take advantage of backtracking but strive to enhance performance by reducing unnecessary recalculations. Focus on early rejection of impossible match situations to save time and space.","solution":"def string_follows_pattern(pattern: str, string: str) -> bool: def is_match(pattern_idx, string_idx, p_to_s, s_to_p): if pattern_idx == len(pattern) and string_idx == len(string): return True if pattern_idx == len(pattern) or string_idx == len(string): return False pattern_char = pattern[pattern_idx] for end in range(string_idx + 1, len(string) + 1): substring = string[string_idx:end] if pattern_char not in p_to_s and substring not in s_to_p: p_to_s[pattern_char] = substring s_to_p[substring] = pattern_char if is_match(pattern_idx + 1, string_idx + len(substring), p_to_s, s_to_p): return True del p_to_s[pattern_char] del s_to_p[substring] elif pattern_char in p_to_s and p_to_s[pattern_char] == substring: if is_match(pattern_idx + 1, string_idx + len(substring), p_to_s, s_to_p): return True return False return is_match(0, 0, {}, {})"},{"question":"You have been tasked with implementing a Fenwick Tree to handle dynamic cumulative frequencies. Your Fenwick Tree should support both updates and prefix sum queries efficiently. # Function Signature ```python class FenwickTree: def __init__(self, frequency: List[int]): Initialize your data structure here. :param frequency: List[int] - The initial frequencies list. pass def update(self, index: int, value: int) -> None: Add \'value\' to element at \'index\'. :param index: int - The index at which update is to be applied (0-based). :param value: int - The value to add to the element at specified index. :return: None pass def query(self, index: int) -> int: Compute the prefix sum from the start of the array up to the given index. :param index: int - The index upto which the prefix sum needs to be computed (0-based). :return: int - The prefix sum. pass ``` # Input and Output Formats * **Input Format**: - The constructor receives a list of integers representing the initial frequencies. - `update` receives an integer `index` and an integer `value` to update at the specified index. - `query` receives an integer `index` to compute the prefix sum up to this index. * **Output Format**: - `query` returns the prefix sum as an integer. - `update` doesn\'t return any value. # Constraints 1. 0 <= index < n where n is the length of the initial frequencies list. 2. The value and elements in the frequency list are integers. # Example ```python # Example usage: frequencies = [1, 7, 3, 0, 7, 8, 3, 2, 6, 2] fenwick_tree = FenwickTree(frequencies) # Query the prefix sum up to index 5 print(fenwick_tree.query(5)) # Output should be the sum 1 + 7 + 3 + 0 + 7 + 8 = 26 # Update index 3 with the value 3 (i.e., frequencies[3] += 3) fenwick_tree.update(3, 3) # Query the prefix sum again up to index 5 print(fenwick_tree.query(5)) # Now the output should be 1 + 7 + 3 + 3 + 7 + 8 = 29 ``` # Notes * Be mindful of handling indexes properly to optimize the performance to O(log n). * You can assume the length of the input list will be up to 100,000 elements.","solution":"class FenwickTree: def __init__(self, frequency): Initialize your data structure here. :param frequency: List[int] - The initial frequencies list. self.n = len(frequency) self.tree = [0] * (self.n + 1) for i in range(self.n): self.update(i, frequency[i]) def update(self, index, value): Add \'value\' to element at \'index\'. :param index: int - The index at which update is to be applied (0-based). :param value: int - The value to add to the element at specified index. :return: None i = index + 1 while i <= self.n: self.tree[i] += value i += i & -i def query(self, index): Compute the prefix sum from the start of the array up to the given index. :param index: int - The index upto which the prefix sum needs to be computed (0-based). :return: int - The prefix sum. sum_ = 0 i = index + 1 while i > 0: sum_ += self.tree[i] i -= i & -i return sum_"},{"question":"You are given a list of integers representing a dataset and a percentage value. Your task is to implement a function that calculates the trimmed mean of the dataset. The trimmed mean is computed after excluding a certain percentage of the highest and lowest values. # Function Signature ```python def calculate_trimmed_mean(data: List[int], percentage: float) -> float: ``` # Input - `data`: A list of integers (0 <= len(data) <= 10^6). - `percentage`: A float between 0 and 100 representing the percentage of data to be excluded from both ends. # Output - A float representing the trimmed mean of the dataset. # Constraints - If the percentage results in excluding all elements, return 0. - If the dataset length is 0, return 0. - You must write code with an average runtime complexity of O(n log n). # Example ```python assert calculate_trimmed_mean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20) == 5.5 assert calculate_trimmed_mean([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 10) == 55.0 assert calculate_trimmed_mean([4, 1, 7, 8, 3, 5, 9, 2, 6], 30) == 5.0 ``` # Explanation 1. For the first example, with `percentage=20`, we exclude the lowest 10% and highest 10%, i.e., we leave out 1 and 10. The remaining dataset is [2, 3, 4, 5, 6, 7, 8, 9], and their mean is 5.5. 2. For the second example, with `percentage=10`, the lowest 10% is 10%, and the highest 10% trimmed are [10, 100]. The trimmed dataset is [20, 30, 40, 50, 60, 70, 80, 90] with a mean of 55. 3. For the third example, with `percentage=30`, we exclude the lowest 30% and highest 30%, i.e., we leave out 1, 2, 7, 8, and 9. The remaining dataset is [3, 4, 5, 6], and their mean is 4.5. **Note**: Be careful with edge cases where trimming might lead to empty datasets or when given percentages are extreme.","solution":"from typing import List def calculate_trimmed_mean(data: List[int], percentage: float) -> float: if not data or percentage >= 100: return 0.0 n = len(data) if n == 0: return 0.0 trim_count = int((percentage / 100) * n) trimmed_data = sorted(data)[trim_count:n-trim_count] if not trimmed_data: return 0.0 return sum(trimmed_data) / len(trimmed_data)"},{"question":"# Context You are given the task of implementing and testing an alternative binary tree traversal method. # Problem Implement the Pre-Order Traversal and Post-Order Traversal for a given binary tree. Pre-Order traversal visits nodes in the order: Node, Left, Right, while Post-Order traversal visits nodes in the order: Left, Right, Node. # Instructions 1. **Function Definitions**: * `preorder(root: Node) -> List[int]`: Implement iterative pre-order traversal. * `preorder_rec(root: Node, res: List[int] = None) -> List[int]`: Implement recursive pre-order traversal. * `postorder(root: Node) -> List[int]`: Implement iterative post-order traversal. * `postorder_rec(root: Node, res: List[int] = None) -> List[int]`: Implement recursive post-order traversal. 2. **Input/Output**: * Each function receives root of type `Node` (defined as above). * Each function returns a list of integers representing the traversal order of the nodes. 3. **Constraints**: * Nodes values: `0 <= val <= 10^4` * Number of nodes in the tree: `0 <= n <= 10^4` * The tree is a binary tree and may have duplicate values. 4. **Performance Requirements**: * Ensure the implementation handles large trees efficiently. * Avoid stack overflow for deep trees when using recursion. # Examples ```python if __name__ == \'__main__\': n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert preorder(n1) == [100, 50, 25, 75, 150, 125, 175] assert preorder_rec(n1) == [100, 50, 25, 75, 150, 125, 175] assert postorder(n1) == [25, 75, 50, 125, 175, 150, 100] assert postorder_rec(n1) == [25, 75, 50, 125, 175, 150, 100] ```","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def preorder(root: Node) -> [int]: if not root: return [] stack = [root] res = [] while stack: node = stack.pop() res.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return res def preorder_rec(root: Node, res: [int] = None) -> [int]: if res is None: res = [] if not root: return res res.append(root.val) preorder_rec(root.left, res) preorder_rec(root.right, res) return res def postorder(root: Node) -> [int]: if not root: return [] stack1 = [root] stack2 = [] res = [] while stack1: node = stack1.pop() stack2.append(node) if node.left: stack1.append(node.left) if node.right: stack1.append(node.right) while stack2: node = stack2.pop() res.append(node.val) return res def postorder_rec(root: Node, res: [int] = None) -> [int]: if res is None: res = [] if not root: return res postorder_rec(root.left, res) postorder_rec(root.right, res) res.append(root.val) return res"},{"question":"# Graph Pathfinding Context You are tasked with implementing a pathfinding algorithm for a navigation system. Given a representation of a road map as a graph where intersections are nodes and roads are edges, you need to find the shortest path for a delivery route. Task: Implement a function `find_shortest_path` that uses Breadth-First Search (BFS) to find the shortest path between two intersections in an unweighted graph. Requirements: - The function should take three arguments: - `graph`: A dictionary where keys are node identifiers and values are lists of adjacent nodes. - `start`: The starting node identifier. - `end`: The target node identifier. - The function should return a list of nodes representing the shortest path from `start` to `end`. If no path exists, return an empty list. Constraints: - All nodes are unique. - Nodes are represented by integers or strings. - The graph can be disconnected. - Performance bounds: The solution must handle graphs with up to 10000 nodes and 50000 edges efficiently. Example: ```python # Example graph graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\', \'G\'], \'G\': [\'F\'] } find_shortest_path(graph, \'A\', \'G\') # Expected output: [\'A\', \'C\', \'F\', \'G\'] ```","solution":"from collections import deque def find_shortest_path(graph, start, end): Finds the shortest path between start and end using BFS. :param graph: dict, adjacency list of the graph :param start: start node identifier :param end: end node identifier :return: list of nodes representing the shortest path from start to end if start == end: return [start] queue = deque([[start]]) visited = set() while queue: path = queue.popleft() node = path[-1] if node == end: return path if node not in visited: visited.add(node) for neighbor in graph.get(node, []): new_path = list(path) new_path.append(neighbor) queue.append(new_path) return []"},{"question":"Scenario You work as a software engineer for a company that handles massive data processing tasks. One of your colleagues handed you a linked list and asked you to check whether this list is in sorted order. The implementation should be efficient and handle edge cases appropriately. Question Write a function called `is_sorted` that takes the head of a singly linked list and returns `True` if the list is sorted in non-decreasing order, and `False` otherwise. An empty list should be considered sorted. The singly linked list is defined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Function Signature ```python def is_sorted(head: ListNode) -> bool: ``` Input - `head`: ListNode - The first node in a singly linked list (or None if the list is empty). Output - Returns a boolean indicating whether the list is sorted: - `True` if the list is sorted in non-decreasing order. - `False` otherwise. Constraints - The list can have any integer values, including negative and positive numbers. - The function should be optimized in terms of time and space complexity. Examples - `is_sorted(None)` should return `True` (an empty list is considered sorted). - `is_sorted(ListNode(1, ListNode(2, ListNode(3, ListNode(4)))))` should return `True` (1 -> 2 -> 3 -> 4 is sorted). - `is_sorted(ListNode(1, ListNode(2, ListNode(-1, ListNode(3)))))` should return `False` (1 -> 2 -> -1 -> 3 is not sorted).","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head: ListNode) -> bool: if not head: return True current = head while current and current.next: if current.val > current.next.val: return False current = current.next return True"}]'),S={name:"App",components:{PoemCard:E},data(){return{searchQuery:"",visibleCount:4,poemsData:O,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},F={class:"card-container"},z={key:0,class:"empty-state"},L=["disabled"],R={key:0},Y={key:1};function j(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),y(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[_,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",z,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,L)):u("",!0)])}const B=c(S,[["render",j],["__scopeId","data-v-f9374154"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/56.md","filePath":"library/56.md"}'),P={name:"library/56.md"},G=Object.assign(P,{setup(r){return(e,l)=>(n(),i("div",null,[x(B)]))}});export{M as __pageData,G as default};
