import{_,o as r,c as n,a as t,m,t as d,C as g,M as p,U as b,f as u,F as x,p as y,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},L={class:"review-title"},R={class:"review-content"};function N(i,e,l,c,s,a){return r(),n("div",q,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(d(l.poem.solution),1)])])])}const j=_(k,[["render",N],["__scopeId","data-v-2d1bdb01"]]),A=JSON.parse(`[{"question":"def maxCompleteRecipes(ingredients, stock): Given the ingredient requirements and available stock, return the maximum number of complete recipes that can be prepared. :param ingredients: List of integers representing the amount of each ingredient required for one recipe. :param stock: List of integers representing the available amount of each ingredient. :return: Maximum number of complete recipes possible. pass # Test cases def test_basic_case(): ingredients = [2, 3, 5] stock = [10, 15, 25] assert maxCompleteRecipes(ingredients, stock) == 5 def test_zero_stock(): ingredients = [1, 1, 1] stock = [0, 0, 0] assert maxCompleteRecipes(ingredients, stock) == 0 def test_zero_ingredients(): ingredients = [0, 0, 0] stock = [10, 15, 25] assert maxCompleteRecipes(ingredients, stock) == 0 def test_mixed_case(): ingredients = [1, 2, 3] stock = [3, 6, 9] assert maxCompleteRecipes(ingredients, stock) == 3 def test_insufficient_stock(): ingredients = [2, 4, 6] stock = [10, 7, 6] assert maxCompleteRecipes(ingredients, stock) == 1 def test_large_numbers(): ingredients = [1000000, 2000000, 3000000] stock = [1000000000, 2000000000, 3000000000] assert maxCompleteRecipes(ingredients, stock) == 1000 def test_different_lengths(): ingredients = [1, 2, 3] stock = [3, 6] # Different length test assert maxCompleteRecipes(ingredients, stock) == 0","solution":"def maxCompleteRecipes(ingredients, stock): Given the ingredient requirements and available stock, return the maximum number of complete recipes that can be prepared. :param ingredients: List of integers representing the amount of each ingredient required for one recipe. :param stock: List of integers representing the available amount of each ingredient. :return: Maximum number of complete recipes possible. if not ingredients or not stock or len(ingredients) != len(stock): return 0 # Find the maximum number of times we can use each ingredient max_recipes = float('inf') for i in range(len(ingredients)): if ingredients[i] == 0: continue # If no ingredient is required, skip it max_possible = stock[i] // ingredients[i] max_recipes = min(max_recipes, max_possible) return max_recipes if max_recipes != float('inf') else 0"},{"question":"def findMaxLength(nums: List[int]) -> int: Returns the length of the longest contiguous subarray with an equal number of 1s and 0s. >>> findMaxLength([0, 1]) 2 >>> findMaxLength([0, 1, 0]) 2 >>> findMaxLength([0, 1, 0, 1, 0, 1]) 6 >>> findMaxLength([0, 0, 0, 1, 1]) 4 >>> findMaxLength([1, 1, 1]) 0 >>> findMaxLength([1]) 0 >>> findMaxLength([0]) 0 >>> findMaxLength([]) 0","solution":"def findMaxLength(nums): Returns the length of the longest contiguous subarray with an equal number of 1s and 0s. count = 0 max_len = 0 count_map = {0: -1} for i in range(len(nums)): count += 1 if nums[i] == 1 else -1 if count in count_map: max_len = max(max_len, i - count_map[count]) else: count_map[count] = i return max_len"},{"question":"def minCoins(coins, amount): Returns the minimum number of coins needed to make the total value of 'amount'. If it is not possible to make the amount with the given coins, returns -1. :param coins: List of positive integers representing the coin values. :param amount: Integer representing the target amount. :return: Minimum number of coins needed, or -1 if the amount cannot be formed. >>> minCoins([1, 2, 5], 11) 3 >>> minCoins([2], 3) -1 >>> minCoins([1, 2, 3], 6) 2 >>> minCoins([1], 0) 0 >>> minCoins([2], 1) -1 >>> minCoins([2, 4], 7) -1 >>> minCoins([], 0) 0 >>> minCoins([1], 1) 1 >>> minCoins([1], 5) 5 >>> minCoins([1, 2, 5], 100) 20 >>> minCoins([3], 9) 3 >>> minCoins([10], 30) 3 >>> minCoins([1, 5, 10, 25], 63) 6","solution":"def minCoins(coins, amount): Returns the minimum number of coins needed to make the total value of 'amount'. If it is not possible to make the amount with the given coins, returns -1. :param coins: List of positive integers representing the coin values. :param amount: Integer representing the target amount. :return: Minimum number of coins needed, or -1 if the amount cannot be formed. # DP array to store the minimum coins needed for each amount from 0 to amount dp = [float('inf')] * (amount + 1) dp[0] = 0 # Base case: 0 coins to make the amount 0 # Update dp array for each coin for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def count_paths_with_target_sum(matrix, target): Returns the number of distinct paths from the top-left to the bottom-right cell of the matrix such that the sum of the integers along the path equals the target. You can only move right or down from a cell. Args: matrix (List[List[int]]): The m x n matrix filled with integers. target (int): The target sum. Returns: int: The number of distinct paths where the sum of the integers along the path equals the target. >>> count_paths_with_target_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 21) == 1 >>> count_paths_with_target_sum([[1, 2, 3], [4, 2, 2], [1, 1, 1]], 9) == 2 >>> count_paths_with_target_sum([[1, 2], [1, 2]], 10) == 0 >>> count_paths_with_target_sum([[5]], 5) == 1 >>> count_paths_with_target_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 100) == 0 pass","solution":"def count_paths_with_target_sum(matrix, target): Returns the number of distinct paths from the top-left to the bottom-right cell of the matrix such that the sum of the integers along the path equals the target. You can only move right or down from a cell. m, n = len(matrix), len(matrix[0]) # Memoization dictionary memo = {} def dfs(r, c, path_sum): if r == m-1 and c == n-1: return 1 if path_sum + matrix[r][c] == target else 0 if (r, c, path_sum) in memo: return memo[(r, c, path_sum)] total_paths = 0 if r < m - 1: total_paths += dfs(r + 1, c, path_sum + matrix[r][c]) if c < n - 1: total_paths += dfs(r, c + 1, path_sum + matrix[r][c]) memo[(r, c, path_sum)] = total_paths return total_paths return dfs(0, 0, 0)"},{"question":"from typing import List def two_sum(arr: List[int], target: int) -> List[int]: Finds two distinct indices in the array such that their corresponding values add up to the given target. Parameters: arr (List[int]): List of integers. target (int): The target sum. Returns: List[int]: The list containing the indices of the two numbers that add up to target. If no such pair exists, returns an empty list. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([1, 2, 3, 4], 10) [] >>> two_sum([-1, -2, -3, -4], -5) [1, 2] >>> two_sum([-1, 2, 3, -4, 1, 7], 6) [0, 5] >>> two_sum([1, 3, 7, 9, 2], 11) [3, 4]","solution":"def two_sum(arr, target): Finds two distinct indices in the array such that their corresponding values add up to the given target. Parameters: arr (List[int]): List of integers. target (int): The target sum. Returns: List[int]: The list containing the indices of the two numbers that add up to target. If no such pair exists, returns an empty list. # Dictionary to store the index of the complementary number complement_dict = {} for index, number in enumerate(arr): complement = target - number if complement in complement_dict: return [complement_dict[complement], index] complement_dict[number] = index return []"},{"question":"def first_unique_char(s: str) -> str: Returns the first unique character in the string s. A unique character is one that appears only once in the string. If there is no such character, return an empty string. >>> first_unique_char(\\"swiss\\") \\"w\\" >>> first_unique_char(\\"aabbcc\\") \\"\\" >>> first_unique_char(\\"leetcode\\") \\"l\\" >>> first_unique_char(\\"loveleetcode\\") \\"v\\" >>> first_unique_char(\\"abcdef\\") \\"a\\" >>> first_unique_char(\\"\\") \\"\\" >>> first_unique_char(\\"a\\") \\"a\\" >>> first_unique_char(\\"aabb\\") \\"\\"","solution":"def first_unique_char(s: str) -> str: Returns the first unique character in the string s. # Frequency dictionary to count occurrences of each character char_frequency = {} # Loop through the string to fill the frequency dictionary for char in s: if char in char_frequency: char_frequency[char] += 1 else: char_frequency[char] = 1 # Loop through the string again to find the first unique character for char in s: if char_frequency[char] == 1: return char # If no unique character found, return an empty string return \\"\\""},{"question":"def count_coastal_cells(arr: List[int]) -> int: Counts the number of coastal land cells in the array. >>> count_coastal_cells([1, 1, 1, 1, 1]) == 2 >>> count_coastal_cells([0, 0, 0, 0, 0]) == 0 >>> count_coastal_cells([1]) == 1 >>> count_coastal_cells([1, 0, 1, 0, 1]) == 3 >>> count_coastal_cells([1, 0, 1, 1, 0, 1]) == 4 >>> count_coastal_cells([0, 1, 1, 1, 0]) == 2 >>> count_coastal_cells([0, 1, 0, 1, 0, 1, 0, 1, 0]) == 4","solution":"def count_coastal_cells(arr): Counts the number of coastal land cells in the array. Parameters: arr (list): A list of integers where each element is either 1 (land) or 0 (water). Returns: int: The count of coastal land cells. coastal_count = 0 n = len(arr) for i in range(n): if arr[i] == 1: if i == 0 or i == n - 1 or arr[i-1] == 0 or arr[i+1] == 0: coastal_count += 1 return coastal_count"},{"question":"from typing import List def largest_island(grid: List[List[int]]) -> int: Returns the size of the largest island of '1's in the grid. >>> largest_island([]) == 0 >>> largest_island([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> largest_island([[1]]) == 1 >>> largest_island([[1, 1, 0, 1]]) == 2 >>> largest_island([[1], [1], [0], [1]]) == 2 >>> largest_island([[1, 1, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 1, 1], [0, 1, 0, 0, 0], [1, 1, 1, 0, 0]]) == 4","solution":"def largest_island(grid): Returns the size of the largest island of '1's in the grid. if not grid: return 0 def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark as visited size = 1 # Count current cell # Explore all 4 directions size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def rightSideView(root: Optional[TreeNode]) -> List[int]: Return the rightmost node value at each level of the binary tree. >>> rightSideView(TreeNode(1)) == [1] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(4) >>> rightSideView(root) == [1, 3, 4] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> rightSideView(root) == [1, 2, 3] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> rightSideView(root) == [1, 2, 3]","solution":"from typing import List, Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def rightSideView(root: Optional[TreeNode]) -> List[int]: if not root: return [] queue = [root] right_view = [] while queue: # Number of nodes at current level level_length = len(queue) for i in range(level_length): node = queue.pop(0) # If it's the last node in current level, add to right view if i == level_length - 1: right_view.append(node.val) # Add child nodes in the queue for the next level if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"from typing import List def maxProfit(prices: List[int], fee: int) -> int: Calculate the maximum profit achievable given stock prices and transaction fee. >>> maxProfit([1, 3, 2, 8, 4, 9], 2) 8 >>> maxProfit([1, 3, 7, 5, 10, 3], 3) 6 >>> maxProfit([], 2) 0 >>> maxProfit([1, 2, 3, 4, 5], 1) 3 >>> maxProfit([5, 4, 3, 2, 1], 1) 0 >>> maxProfit([5], 2) 0 >>> maxProfit([1, 2, 3, 4, 5], 0) 4","solution":"from typing import List def maxProfit(prices: List[int], fee: int) -> int: Calculate the maximum profit achievable given stock prices and transaction fee. if not prices: return 0 n = len(prices) cash, hold = 0, -prices[0] for i in range(1, n): # Calculate the maximum cash if we don't hold the stock cash = max(cash, hold + prices[i] - fee) # Calculate the maximum hold value if we hold the stock hold = max(hold, cash - prices[i]) return cash"},{"question":"from typing import List, Tuple def can_reach_all_nodes(n: int, edges: List[Tuple[int, int]], start: int) -> bool: Determines if all nodes are reachable from the start node in a directed graph. :param n: Number of nodes in the graph :param edges: List of directed edges in the graph :param start: Starting node :return: True if all nodes are reachable from the start node, False otherwise >>> can_reach_all_nodes(4, [(0, 1), (0, 2), (1, 2), (2, 3)], 0) True >>> can_reach_all_nodes(4, [(0, 1), (1, 2)], 0) False >>> can_reach_all_nodes(1, [], 0) True >>> can_reach_all_nodes(3, [], 0) False >>> can_reach_all_nodes(6, [(0, 1), (2, 3), (4, 5)], 0) False >>> can_reach_all_nodes(3, [(0, 0), (0, 1), (1, 2)], 0) True","solution":"def can_reach_all_nodes(n, edges, start): Determines if all nodes are reachable from the start node. :param n: Number of nodes in the graph :param edges: List of directed edges in the graph :param start: Starting node :return: True if all nodes are reachable from the start node, False otherwise from collections import defaultdict, deque # Create an adjacency list adj_list = defaultdict(list) for src, dst in edges: adj_list[src].append(dst) # Perform BFS or DFS to see which nodes are reachable from start visited = [False] * n queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Check if all nodes were visited return all(visited)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_unival_subtrees(root): Counts the number of unival (universal value) subtrees in a binary tree. >>> root = TreeNode(1) >>> count_unival_subtrees(root) 1 >>> root = TreeNode(1, TreeNode(1), TreeNode(1)) >>> count_unival_subtrees(root) 3 >>> root = TreeNode(1, TreeNode(1), TreeNode(2)) >>> count_unival_subtrees(root) 2 >>> root = TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1)) >>> count_unival_subtrees(root) 5 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> count_unival_subtrees(root) 2 >>> root = TreeNode(1, ... TreeNode(1, TreeNode(1), TreeNode(2)), ... TreeNode(1, TreeNode(1), TreeNode(1)) ... ) >>> count_unival_subtrees(root) 5","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_unival_subtrees(root): Counts the number of unival (universal value) subtrees in a binary tree. def is_unival_tree(node, parent_value): nonlocal count if node is None: return True # Check left and right subtrees left_unival = is_unival_tree(node.left, node.value) right_unival = is_unival_tree(node.right, node.value) # If either left or right subtree is not unival, this subtree can't be unival if not left_unival or not right_unival: return False # If both left and right subtrees are unival, and the current node matches the parent value count += 1 # Current node forms a unival subtree return node.value == parent_value count = 0 is_unival_tree(root, None) return count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode: Add two numbers represented by linked lists where each node contains a single digit. The digits are stored in reverse order and the sum should also be returned as a linked list in reverse order. >>> linked_to_list(Solution().addTwoNumbers(list_to_linked([2, 4, 3]), list_to_linked([5, 6, 4]))) [7, 0, 8] >>> linked_to_list(Solution().addTwoNumbers(list_to_linked([0]), list_to_linked([0]))) [0] >>> linked_to_list(Solution().addTwoNumbers(list_to_linked([9, 9, 9, 9, 9, 9, 9]), list_to_linked([9, 9, 9, 9]))) [8, 9, 9, 9, 0, 0, 0, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode() current, carry = dummy, 0 while l1 or l2 or carry: val1 = (l1.val if l1 else 0) val2 = (l2.val if l2 else 0) carry, out = divmod(val1 + val2 + carry, 10) current.next = ListNode(out) current = current.next l1 = (l1.next if l1 else None) l2 =( l2.next if l2 else None) return dummy.next"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the characters of the string s can be rearranged to form a palindrome. >>> can_form_palindrome(\\"aabb\\") == True >>> can_form_palindrome(\\"aabbc\\") == True >>> can_form_palindrome(\\"abc\\") == False >>> can_form_palindrome(\\"a\\") == True >>> can_form_palindrome(\\"aaaa\\") == True >>> can_form_palindrome(\\"\\") == True >>> can_form_palindrome(\\"aaabbc\\") == False","solution":"def can_form_palindrome(s): Determines if the characters of the string s can be rearranged to form a palindrome. # Count the frequency of each character in the string char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Check the number of characters with odd frequency counts odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # A string can form a palindrome if there is at most one character with an odd count return odd_count <= 1"},{"question":"def longest_subarray(data, k): Finds the length of the longest contiguous subarray such that the difference between the maximum and minimum values in this subarray is less than or equal to k. Parameters: data (list): List of non-negative integers. k (int): The maximum allowed difference between the highest and lowest value in the subarray. Returns: int: Length of the longest contiguous subarray. Examples: >>> longest_subarray([10, 1, 2, 4, 7, 2], 5) 4 >>> longest_subarray([4, 8, 5, 1, 7, 9], 6) 3 >>> longest_subarray([1, 1, 1, 1, 1], 0) 5 >>> longest_subarray([], 5) 0 >>> longest_subarray([4], 0) 1 >>> longest_subarray([10, 20, 30, 40, 50], 100) 5 >>> longest_subarray([10, 10, 10, 10], 0) 4 >>> longest_subarray([10, 20, 30, 40], 0) 1","solution":"def longest_subarray(data, k): Finds the length of the longest contiguous subarray such that the difference between the maximum and minimum values in this subarray is less than or equal to k. Parameters: data (list): List of non-negative integers. k (int): The maximum allowed difference between the highest and lowest value in the subarray. Returns: int: Length of the longest contiguous subarray. from collections import deque if not data: # edge case if the data list is empty return 0 min_deque = deque() # to store indices of the smallest elements in a window max_deque = deque() # to store indices of the largest elements in a window left = 0 max_length = 0 for right in range(len(data)): while min_deque and data[min_deque[-1]] >= data[right]: min_deque.pop() min_deque.append(right) while max_deque and data[max_deque[-1]] <= data[right]: max_deque.pop() max_deque.append(right) while data[max_deque[0]] - data[min_deque[0]] > k: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"def uniquePaths(maze: List[List[int]]) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of a maze represented by 2D grid (m x n) where each cell can be either empty (0) or blocked (1). Example: >>> uniquePaths([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 6 >>> uniquePaths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 2","solution":"def uniquePaths(maze): Returns the number of unique paths from the top-left corner to the bottom-right corner of a maze represented by 2D grid (m x n) where each cell can be either empty (0) or blocked (1). m = len(maze) n = len(maze[0]) if maze[0][0] == 1 or maze[m-1][n-1] == 1: return 0 dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if maze[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]], start: int, end: int) -> int: Calculate the shortest path from start to end in a directed graph using Dijkstra's algorithm. Parameters: n (int): Number of nodes. m (int): Number of edges. edges (list of tuples): List of (u, v, w) where u is the start node, v is the end node, and w is the weight. start (int): The starting node. end (int): The ending node. Returns: int: Length of the shortest path or -1 if no path exists. >>> shortest_path(5, 6, [(0, 1, 1), (1, 2, 2), (0, 2, 4), (2, 3, 1), (3, 4, 3), (2, 4, 5)], 0, 4) 7 >>> shortest_path(5, 3, [(0, 1, 1), (1, 2, 2), (3, 4, 1)], 0, 4) -1 >>> shortest_path(3, 3, [(0, 1, 1), (1, 2, 1), (0, 2, 2)], 0, 2) 2 >>> shortest_path(1, 0, [], 0, 0) 0 >>> shortest_path(4, 2, [(0, 1, 1), (2, 3, 1)], 0, 3) -1","solution":"import heapq def shortest_path(n, m, edges, start, end): Calculate the shortest path from start to end in a directed graph using Dijkstra's algorithm. Parameters: n (int): Number of nodes. m (int): Number of edges. edges (list of tuples): List of (u, v, w) where u is the start node, v is the end node, and w is the weight. start (int): The starting node. end (int): The ending node. Returns: int: Length of the shortest path or -1 if no path exists. # Create adjacency list graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) # Dijkstra's algorithm pq = [(0, start)] # (distance, node) distances = {i: float('inf') for i in range(n)} distances[start] = 0 visited = set() while pq: current_distance, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances[end] if distances[end] != float('inf') else -1"},{"question":"def get_employee_importance(employee_data, target_id): Calculate the total importance value for the given employee and their subordinates. :param employee_data: List of dictionaries, each representing an employee with 'id', 'importance', and 'subordinates' keys. :param target_id: Integer, the ID of the target employee whose total importance value is to be computed. :return: Integer, the total importance value for the target employee including their subordinates. pass # Test Cases def test_single_employee(): employee_data = [ {'id': 1, 'importance': 5, 'subordinates': []} ] assert get_employee_importance(employee_data, 1) == 5 def test_employee_with_subordinates(): employee_data = [ {'id': 1, 'importance': 5, 'subordinates': [2, 3]}, {'id': 2, 'importance': 3, 'subordinates': []}, {'id': 3, 'importance': 4, 'subordinates': []} ] assert get_employee_importance(employee_data, 1) == 12 def test_employee_with_nested_subordinates(): employee_data = [ {'id': 1, 'importance': 5, 'subordinates': [2]}, {'id': 2, 'importance': 3, 'subordinates': [3]}, {'id': 3, 'importance': 4, 'subordinates': []} ] assert get_employee_importance(employee_data, 1) == 12 def test_employee_with_more_nested_subordinates(): employee_data = [ {'id': 1, 'importance': 5, 'subordinates': [2]}, {'id': 2, 'importance': 3, 'subordinates': [3]}, {'id': 3, 'importance': 4, 'subordinates': [4]}, {'id': 4, 'importance': 1, 'subordinates': []} ] assert get_employee_importance(employee_data, 1) == 13 def test_non_targeted_employee(): employee_data = [ {'id': 1, 'importance': 5, 'subordinates': [2]}, {'id': 2, 'importance': 3, 'subordinates': [3]}, {'id': 3, 'importance': 4, 'subordinates': []} ] assert get_employee_importance(employee_data, 2) == 7","solution":"def get_employee_importance(employee_data, target_id): Calculate the total importance value for the given employee and their subordinates. :param employee_data: List of dictionaries, each representing an employee with 'id', 'importance', and 'subordinates' keys. :param target_id: Integer, the ID of the target employee whose total importance value is to be computed. :return: Integer, the total importance value for the target employee including their subordinates. # Convert the employee data into a dictionary for quick access by ID employee_dict = {emp['id']: emp for emp in employee_data} def dfs(emp_id): # Access the employee's data using their ID employee = employee_dict[emp_id] # Start with the employee's own importance total_importance = employee['importance'] # Accumulate the importance of all subordinates recursively for sub_id in employee['subordinates']: total_importance += dfs(sub_id) return total_importance # Start DFS from the target employee ID return dfs(target_id)"},{"question":"def max_dist_to_closest(s: str) -> int: Given a binary string representing a row of seats where '1' is occupied and '0' is empty, returns the index of the empty seat that has the maximum distance to the nearest occupied seat. If there are multiple seats with the same maximum distance, returns the index of the leftmost one. If the string contains no empty seats, returns -1. >>> max_dist_to_closest(\\"111\\") -1 >>> max_dist_to_closest(\\"101\\") 1 >>> max_dist_to_closest(\\"110\\") 2 >>> max_dist_to_closest(\\"011\\") 0 >>> max_dist_to_closest(\\"1001\\") 1 >>> max_dist_to_closest(\\"10001\\") 2 >>> max_dist_to_closest(\\"100001\\") 2 >>> max_dist_to_closest(\\"0010\\") 0 >>> max_dist_to_closest(\\"010\\") 0 >>> max_dist_to_closest(\\"001\\") 0 >>> max_dist_to_closest(\\"0000\\") 0 >>> max_dist_to_closest(\\"0\\") 0 >>> max_dist_to_closest(\\"1\\") -1","solution":"def max_dist_to_closest(s: str) -> int: Given a binary string representing a row of seats where '1' is occupied and '0' is empty, returns the index of the empty seat that has the maximum distance to the nearest occupied seat. n = len(s) if '0' not in s: return -1 left = [-1] * n right = [-1] * n # Fill left distance array distance = float('inf') for i in range(n): if s[i] == '1': distance = 0 else: if distance != float('inf'): distance += 1 left[i] = distance # Fill right distance array distance = float('inf') for i in range(n-1, -1, -1): if s[i] == '1': distance = 0 else: if distance != float('inf'): distance += 1 right[i] = distance # Find the maximum distance max_distance = -1 index_with_max_distance = -1 for i in range(n): if s[i] == '0': min_distance = min(left[i], right[i]) if min_distance > max_distance: max_distance = min_distance index_with_max_distance = i return index_with_max_distance"},{"question":"def max_distance_between_ones(mat): Calculates the maximum distance between any two '1's in the matrix. The distance between two cells (x1, y1) and (x2, y2) is given by max(|x2 - x1|, |y2 - y1|). If there are less than two '1's in the matrix, returns -1. :param mat: 2D list of integers :return: integer >>> mat = [ >>> [0, 0], >>> [0, 0] >>> ] >>> max_distance_between_ones(mat) == -1 >>> mat = [ >>> [0, 0], >>> [0, 1] >>> ] >>> max_distance_between_ones(mat) == -1 >>> mat = [ >>> [1, 0], >>> [0, 1] >>> ] >>> max_distance_between_ones(mat) == 1 >>> mat = [ >>> [1, 1, 0], >>> [0, 0, 1], >>> [1, 0, 1] >>> ] >>> max_distance_between_ones(mat) == 2 >>> mat = [ >>> [1, 0, 0, 0], >>> [0, 0, 0, 1], >>> [0, 1, 0, 0], >>> [0, 0, 0, 0], >>> [1, 0, 0, 1] >>> ] >>> max_distance_between_ones(mat) == 4","solution":"def max_distance_between_ones(mat): Calculates the maximum distance between any two '1's in the matrix. The distance between two cells (x1, y1) and (x2, y2) is given by max(|x2 - x1|, |y2 - y1|). If there are less than two '1's in the matrix, returns -1. :param mat: 2D list of integers :return: integer # List to store positions of '1's ones = [(i, j) for i in range(len(mat)) for j in range(len(mat[0])) if mat[i][j] == 1] if len(ones) < 2: return -1 # Less than two '1's in the matrix max_distance = 0 for i in range(len(ones)): for j in range(i + 1, len(ones)): x1, y1 = ones[i] x2, y2 = ones[j] distance = max(abs(x2 - x1), abs(y2 - y1)) max_distance = max(max_distance, distance) return max_distance"},{"question":"class CustomHashMap: def __init__(self, size=1000): Initialize your data structure here with a default size. pass def _hash(self, key): Generate a hash for the given key. pass def put(self, key, value): Insert a (key, value) pair into the hash map. If the key already exists, update the value. pass def get(self, key): Retrieve the value associated with the given key, or -1 if the key is not found. pass def remove(self, key): Remove the (key, value) pair associated with the given key, if it exists. pass import pytest def test_put_and_get(): hash_map = CustomHashMap() hash_map.put(1, 1) assert hash_map.get(1) == 1 hash_map.put(2, 2) assert hash_map.get(2) == 2 hash_map.put(1, 10) assert hash_map.get(1) == 10 def test_get_non_existent_key(): hash_map = CustomHashMap() assert hash_map.get(3) == -1 def test_remove(): hash_map = CustomHashMap() hash_map.put(1, 1) assert hash_map.get(1) == 1 hash_map.remove(1) assert hash_map.get(1) == -1 def test_collision_handling(): hash_map = CustomHashMap(2) # Small size to ensure collisions hash_map.put(1, 1) hash_map.put(3, 3) # This will collide with key = 1 assert hash_map.get(1) == 1 assert hash_map.get(3) == 3 hash_map.put(1, 10) assert hash_map.get(1) == 10 # Should update key = 1 def test_large_number_of_elements(): hash_map = CustomHashMap() for i in range(1000): hash_map.put(i, i*2) for i in range(1000): assert hash_map.get(i) == i*2 for i in range(500): hash_map.remove(i) for i in range(500): assert hash_map.get(i) == -1 for i in range(500, 1000): assert hash_map.get(i) == i*2","solution":"class CustomHashMap: def __init__(self, size=1000): Initialize your data structure here with a default size. self.size = size self.buckets = [[] for _ in range(size)] def _hash(self, key): Generate a hash for the given key. return key % self.size def put(self, key, value): Insert a (key, value) pair into the hash map. If the key already exists, update the value. hash_key = self._hash(key) bucket = self.buckets[hash_key] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) def get(self, key): Retrieve the value associated with the given key, or -1 if the key is not found. hash_key = self._hash(key) bucket = self.buckets[hash_key] for k, v in bucket: if k == key: return v return -1 def remove(self, key): Remove the (key, value) pair associated with the given key, if it exists. hash_key = self._hash(key) bucket = self.buckets[hash_key] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] return"},{"question":"def longest_subarray_with_sum(arr: List[int], target: int) -> int: Returns the length of the longest subarray of arr whose elements sum to the target value. >>> longest_subarray_with_sum([1, -1, 5, -2, 3], 3) 4 >>> longest_subarray_with_sum([-2, -1, 2, 1], 1) 2 >>> longest_subarray_with_sum([1, 2, 3], 3) 2 >>> longest_subarray_with_sum([1, 2, 3, 4, 5], 15) 5 >>> longest_subarray_with_sum([1, 2, 3], 7) 0 >>> longest_subarray_with_sum([1, -1, 1], 5) 0 >>> longest_subarray_with_sum([5], 5) 1 >>> longest_subarray_with_sum([5], 7) 0 >>> longest_subarray_with_sum([1, 2, 1, 2, 1, 2], 3) 2 >>> longest_subarray_with_sum([1, 1, 1, 1, 1], 2) 2 >>> longest_subarray_with_sum([1] * 10000, 5000) 5000 <|INSERT YOUR SOLUTION HERE|>","solution":"def longest_subarray_with_sum(arr, target): Returns the length of the longest subarray of arr whose elements sum to the target value. prefix_sum_map = {} prefix_sum = 0 max_length = 0 for i, num in enumerate(arr): prefix_sum += num if prefix_sum == target: max_length = i + 1 if (prefix_sum - target) in prefix_sum_map: max_length = max(max_length, i - prefix_sum_map[prefix_sum - target]) if prefix_sum not in prefix_sum_map: prefix_sum_map[prefix_sum] = i return max_length"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Given a binary tree, return the values of the nodes you can see ordered from top to bottom if you stand on the right side of the tree. The function should return an array of these values. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> rightSideView(root) [1, 3] >>> empty_root = None >>> rightSideView(empty_root) []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Returns the values of the nodes you can see ordered from top to bottom if you stand on the right side of the tree. if not root: return [] result = [] current_level = [root] while current_level: # add the last element of current level to the result result.append(current_level[-1].val) next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level return result"},{"question":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_order(root): Returns a list of lists containing the values of nodes at each level of the binary tree. >>> level_order(None) [] >>> level_order(TreeNode(1)) [[1]] >>> level_order(TreeNode(1, TreeNode(2), TreeNode(3))) [[1], [2, 3]] >>> level_order(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))) [[1], [2, 3], [4, 5]] >>> level_order(TreeNode(1, None, TreeNode(2, TreeNode(3), None))) [[1], [2], [3]]","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_order(root): Returns a list of lists containing the values of nodes at each level of the binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"def min_substrings_with_k_distinct_chars(s: str, k: int) -> int: Decomposes the string s into the minimum number of substrings such that each substring contains at most k distinct characters. Returns the number of such substrings. :param s: Input string :param k: Maximum number of distinct characters allowed in each substring :return: Number of substrings >>> min_substrings_with_k_distinct_chars(\\"abcba\\", 2) == 3 >>> min_substrings_with_k_distinct_chars(\\"abac\\", 2) == 2 >>> min_substrings_with_k_distinct_chars(\\"aaaaa\\", 1) == 1 >>> min_substrings_with_k_distinct_chars(\\"abcba\\", 0) == 5 >>> min_substrings_with_k_distinct_chars(\\"abac\\", 10) == 1 >>> min_substrings_with_k_distinct_chars(\\"abcdef\\", 3) == 2 >>> min_substrings_with_k_distinct_chars(\\"\\", 3) == 0","solution":"def min_substrings_with_k_distinct_chars(s, k): Decomposes the string s into the minimum number of substrings such that each substring contains at most k distinct characters. Returns the number of such substrings. :param s: Input string :param k: Maximum number of distinct characters allowed in each substring :return: Number of substrings if k == 0: return len(s) substr_count = 0 left = 0 while left < len(s): right = left unique_chars = set() while right < len(s) and (len(unique_chars) < k or (len(unique_chars) == k and s[right] in unique_chars)): unique_chars.add(s[right]) right += 1 substr_count += 1 left = right return substr_count"},{"question":"def numDistinctIslands(grid: List[List[int]]) -> int: Determine the number of distinct islands in the given grid. >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> numDistinctIslands(grid) 1 >>> grid = [ ... [1, 1, 0, 0, 1], ... [1, 1, 0, 0, 1], ... [0, 0, 0, 0, 0], ... [1, 1, 0, 1, 1], ... [1, 1, 0, 1, 1] ... ] >>> numDistinctIslands(grid) 2 >>> grid = [ ... [1, 1, 0, 0, 0], ... [1, 0, 0, 1, 1], ... [0, 0, 1, 1, 1], ... [0, 0, 0, 0, 0], ... [1, 1, 0, 1, 0] ... ] >>> numDistinctIslands(grid) 4 >>> grid = [ ... [1, 1, 0, 0, 1], ... [1, 0, 0, 0, 1], ... [0, 0, 1, 1, 1], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 1, 1] ... ] >>> numDistinctIslands(grid) 3","solution":"def numDistinctIslands(grid): def dfs(x, y, origin): if not (0 <= x < len(grid) and 0 <= y < len(grid[0])) or grid[x][y] == 0: return grid[x][y] = 0 # mark as visited path_signature.append((x - origin[0], y - origin[1])) # record relative position for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy, origin) unique_island_shapes = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: path_signature = [] dfs(i, j, (i, j)) unique_island_shapes.add(tuple(path_signature)) return len(unique_island_shapes)"},{"question":"from typing import List def can_equalize_balances(accounts: List[int]) -> bool: Returns true if it is possible to transfer money between accounts to make all balances equal. :param accounts: List of integer account balances :return: Boolean indicating whether equalization is possible >>> can_equalize_balances([]) True >>> can_equalize_balances([100]) True >>> can_equalize_balances([50, 50, 50]) True >>> can_equalize_balances([30, 70, 50]) True >>> can_equalize_balances([30, 70, 51]) False","solution":"def can_equalize_balances(accounts): Returns true if it is possible to transfer money between accounts to make all balances equal. :param accounts: List of integer account balances :return: Boolean indicating whether equalization is possible if not accounts: return True total_balance = sum(accounts) num_accounts = len(accounts) # It is possible to equalize balances if total balance is divisible by number of accounts return total_balance % num_accounts == 0"},{"question":"def longest_subsequence(nums: List[int], k: int) -> int: Determine the length of the longest subsequence such that the difference between the maximum and minimum values in the subsequence is at most k. >>> longest_subsequence([1, 5, 9, 4, 2, 8], 3) == 3 >>> longest_subsequence([], 3) == 0 >>> longest_subsequence([1, 2, 3, 4, 5], 4) == 5 >>> longest_subsequence([1, 10, 20, 30], 2) == 1 >>> longest_subsequence([100], 0) == 1 >>> longest_subsequence([1, 3, 6, 10, 15], 5) == 3","solution":"def longest_subsequence(nums, k): if not nums: return 0 nums.sort() max_length = 1 left = 0 for right in range(1, len(nums)): while nums[right] - nums[left] > k: left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def minStepsToTop(steps: List[int]) -> int: Returns the minimum number of steps required to reach the top of the list. Args: steps (list of int): A list of integers where each element represents the number of steps required to move from that step. Returns: int: The minimum number of steps required to reach the top. >>> minStepsToTop([1, 2, 0, 1]) 2 >>> minStepsToTop([1]) 0 >>> minStepsToTop([1, 1, 1, 1, 1]) 2 >>> minStepsToTop([0, 2, 3, 0, 1, 2, 0, 1]) 4 >>> minStepsToTop([1, 0]) 1 >>> minStepsToTop([1, 1, 1, 1, 1, 1, 1, 1, 1]) 4 >>> minStepsToTop([0, 0, 0, 0, 0]) 2","solution":"def minStepsToTop(steps): Returns the minimum number of steps required to reach the top of the list. Args: steps (list of int): A list of integers where each element represents the number of steps required to move from that step. Returns: int: The minimum number of steps required to reach the top. n = len(steps) if n == 1: return 0 # Initialize a table to store the minimum number of steps to reach each position dp = [float('inf')] * n dp[0] = 0 for i in range(1, n): dp[i] = min(dp[i], dp[i - 1] + 1) if i > 1: dp[i] = min(dp[i], dp[i - 2] + 1) return dp[-1] # Testing the function print(minStepsToTop([1, 2, 0, 1])) # Output: 2 print(minStepsToTop([1])) # Output: 0 print(minStepsToTop([1, 1, 1, 1, 1])) # Output: 2"},{"question":"from typing import List def min_removals_to_decreasing(nums: List[int]) -> int: You are given a 0-indexed integer array \`nums\`. You are allowed to modify the array by removing any of its elements. Your task is to find the minimum number of elements to remove such that the remaining array is sorted in strictly decreasing order. >>> min_removals_to_decreasing([5, 3, 4, 2, 1]) 1 >>> min_removals_to_decreasing([4, 3, 2, 1]) 0 >>> min_removals_to_decreasing([3, 1, 2, 2, 1]) 2 >>> min_removals_to_decreasing([9, 2, 8, 5]) 1 >>> min_removals_to_decreasing([]) 0 >>> min_removals_to_decreasing([1]) 0 >>> min_removals_to_decreasing([7, 7, 7, 7, 7]) 4","solution":"def min_removals_to_decreasing(nums): n = len(nums) # If the array is empty or has one element, it is already sorted in strictly decreasing order if n <= 1: return 0 # Longest Decreasing Subsequence (LDS) array lds = [1] * n # Compute LDS values in reverse order for i in range(n - 2, -1, -1): for j in range(n - 1, i, -1): if nums[i] > nums[j]: lds[i] = max(lds[i], 1 + lds[j]) # The reason we subtract the length of the longest decreasing subsequence from total elements longest_decreasing_subsequence_length = max(lds) return n - longest_decreasing_subsequence_length"},{"question":"def sum_unique_divisibles(arr, x, y): Returns the sum of all unique elements in the array \`arr\` that are divisible by either \`x\` or \`y\`. Elements are considered unique based on their first occurrence in the array and any repeated instances are ignored for the sum calculation. >>> sum_unique_divisibles([2, 3, 6, 2, 5], 2, 3) 11 >>> sum_unique_divisibles([7, 13, 17], 2, 3) 0 >>> sum_unique_divisibles([4, 9, 12], 3, 4) 25 >>> sum_unique_divisibles([2, 3, 6, 6, 3], 2, 3) 11 >>> sum_unique_divisibles([], 2, 3) 0 >>> sum_unique_divisibles([2], 2, 3) 2 >>> sum_unique_divisibles([3], 2, 3) 3 >>> sum_unique_divisibles([4], 2, 3) 4 >>> sum_unique_divisibles([5], 2, 3) 0","solution":"def sum_unique_divisibles(arr, x, y): Returns the sum of all unique elements in the array \`arr\` that are divisible by either \`x\` or \`y\`. Elements are considered unique based on their first occurrence in the array and any repeated instances are ignored for the sum calculation. unique_elements = set() for num in arr: if num not in unique_elements and (num % x == 0 or num % y == 0): unique_elements.add(num) return sum(unique_elements)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def increasingBST(root): Rearranges the given binary search tree (BST) so that the leftmost node becomes the root and every node has no left child and only one right child. Returns the new root of the rearranged tree. >>> root = TreeNode(1) >>> new_root = increasingBST(root) >>> new_root.val 1 >>> new_root.left None >>> new_root.right None >>> root = TreeNode(2, TreeNode(1), None) >>> new_root = increasingBST(root) >>> new_root.val 1 >>> new_root.left None >>> new_root.right.val 2 >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(6) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.left.left.left = TreeNode(1) >>> new_root = increasingBST(root) >>> new_root.val 1 >>> new_root.right.val 2 >>> new_root.right.right.val 3 >>> new_root.right.right.right.val 4 >>> new_root.right.right.right.right.val 5 >>> new_root.right.right.right.right.right.val 6 >>> new_root.right.right.right.right.right.right None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def increasingBST(root): Rearranges the given binary search tree (BST) so that the leftmost node becomes the root and every node has no left child and only one right child. def inorder(node): if not node: return inorder(node.left) nodes.append(node) inorder(node.right) nodes = [] inorder(root) for i in range(len(nodes) - 1): nodes[i].left = None nodes[i].right = nodes[i + 1] # The last node should have no left or right child nodes[-1].left = None nodes[-1].right = None return nodes[0]"},{"question":"def evaluate_rpn(expression: List[str]) -> int: Evaluates a mathematical expression in Reverse Polish Notation (RPN). >>> evaluate_rpn([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) == 9 >>> evaluate_rpn([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) == 6 >>> evaluate_rpn([\\"10\\", \\"3\\", \\"/\\"]) == 3","solution":"def evaluate_rpn(expression): Evaluates a mathematical expression in Reverse Polish Notation (RPN). Parameters: expression (list of str): The RPN expression to evaluate. Returns: int: The result of the RPN expression. stack = [] operators = {'+', '-', '*', '/'} for token in expression: if token not in operators: stack.append(int(token)) else: b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(int(a / b)) # truncate toward zero return stack[0]"},{"question":"def min_cost_to_merge_piles(nums: List[int]) -> int: Return the minimum cost to merge all piles into one. You are given an array of integers \`nums\` representing piles of stones, each pile indexed from \`0\` to \`n-1\`. You can merge two adjacent piles into one pile by paying a cost equal to the total number of stones in the two piles. The resultant pile's index will be the smaller one. For example, merging piles \`nums[i]\` and \`nums[i+1]\` will cost \`nums[i] + nums[i+1]\` and the new pile at index \`i\` will have \`nums[i] + nums[i+1]\` stones. The process is repeated until only one pile remains. Return the minimum cost to merge all piles into one. >>> min_cost_to_merge_piles([5]) == 0 >>> min_cost_to_merge_piles([1, 2]) == 3 >>> min_cost_to_merge_piles([4, 3, 3, 4]) == 28 >>> min_cost_to_merge_piles([1, 2, 3, 4]) == 19 >>> min_cost_to_merge_piles([1, 1, 1, 1]) == 8 >>> min_cost_to_merge_piles([]) == 0 >>> min_cost_to_merge_piles([10, 20, 30, 40]) == 190 >>> min_cost_to_merge_piles([100, 200, 300]) == 900","solution":"def min_cost_to_merge_piles(nums): if len(nums) == 1: return 0 import heapq heapq.heapify(nums) total_cost = 0 while len(nums) > 1: first_pile = heapq.heappop(nums) second_pile = heapq.heappop(nums) merge_cost = first_pile + second_pile total_cost += merge_cost heapq.heappush(nums, merge_cost) return total_cost"},{"question":"from typing import List def most_frequent_char(s: str) -> str: Write a function that takes a string \`s\` and returns the character that appears the most frequently in \`s\`. If there are multiple characters with the same highest frequency, return the character that appears first in the string. >>> most_frequent_char(\\"a\\") 'a' >>> most_frequent_char(\\"ababab\\") 'a' >>> most_frequent_char(\\"example\\") 'e' >>> most_frequent_char(\\"aabbbccdde\\") 'b' >>> most_frequent_char(\\"abcdefg\\") 'a' >>> most_frequent_char(\\"112233\\") '1' >>> most_frequent_char(\\"!@#%^&*()\\") '!' >>> most_frequent_char(\\"aa1122bb\\") 'a' >>> most_frequent_char(\\"AaBBcc\\") 'B' >>> most_frequent_char(\\"aaabbc\\") 'a'","solution":"def most_frequent_char(s): Returns the character that appears the most frequently in \`s\`. If there are multiple characters with the same highest frequency, returns the character that appears first in the string. from collections import Counter char_count = Counter(s) max_freq = max(char_count.values()) for char in s: if char_count[char] == max_freq: return char"},{"question":"from typing import List class TaskScheduler: def __init__(self, tasks: List[int], k: int): Initializes the TaskScheduler with the list of tasks and number of workers. Args: tasks: List[int]: An array representing the time required to complete each task. k: int: The number of workers available. self.tasks = tasks self.k = k def minimizeMaxTime(self) -> int: Returns the minimized maximum time any worker spends on tasks. Returns: int: The minimum possible value of the maximum time taken by any worker to complete their tasks. Examples: >>> TaskScheduler([3, 2, 3], 3).minimizeMaxTime() 3 >>> TaskScheduler([1, 2, 3, 4, 5], 2).minimizeMaxTime() 9 >>> TaskScheduler([7, 2, 5, 10, 8], 3).minimizeMaxTime() 14 >>> TaskScheduler([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5).minimizeMaxTime() 15 >>> TaskScheduler([10, 10, 10], 3).minimizeMaxTime() 10","solution":"from typing import List import heapq class TaskScheduler: def __init__(self, tasks: List[int], k: int): self.tasks = tasks self.k = k def minimizeMaxTime(self) -> int: # If the number of workers is greater than or equal to the number of tasks, # the maximum time any worker spends will be equal to the time of the largest task. if self.k >= len(self.tasks): return max(self.tasks) # Minimize the maximum working time using a binary search approach low, high = max(self.tasks), sum(self.tasks) # Function to check if a given \`mid\` can be achieved def canDistribute(mid): workers = 1 current_time = 0 for task in self.tasks: if current_time + task > mid: workers += 1 current_time = task if workers > self.k: return False else: current_time += task return True # Binary search to find the minimum possible maximum time while low < high: mid = (low + high) // 2 if canDistribute(mid): high = mid else: low = mid + 1 return low"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of specified operations required to make the string \`s\` a palindrome. If it is not possible, return -1. >>> min_operations_to_palindrome(\\"racecar\\") == 0 >>> min_operations_to_palindrome(\\"abcbxa\\") == -1 >>> min_operations_to_palindrome(\\"abcba\\") == 0 >>> min_operations_to_palindrome(\\"abcdedcba\\") == 0 >>> min_operations_to_palindrome(\\"abcd\\") == -1 >>> min_operations_to_palindrome(\\"abc\\") == -1 >>> min_operations_to_palindrome(\\"aabbc\\") == -1 >>> min_operations_to_palindrome(\\"a\\") == 0 >>> min_operations_to_palindrome(\\"\\") == 0","solution":"def min_operations_to_palindrome(s): Returns the minimum number of specified operations required to make the string \`s\` a palindrome. If it is not possible, return -1. if s == s[::-1]: return 0 original = s operations = 0 while len(s) > 1: if s[0] == s[-1]: s = s[1:-1] else: s = original break if s == s[::-1]: return operations + 1 operations += 1 return -1"},{"question":"def can_find_increasing_subsequence_of_length_3(sequence: List[int]) -> bool: Given an integer array \`sequence\`, determine if it is possible to obtain a strictly increasing subsequence of length 3 by removing at most one element from the array. Return \`true\` if it is possible, otherwise return \`false\`. >>> can_find_increasing_subsequence_of_length_3([1, 2]) False >>> can_find_increasing_subsequence_of_length_3([1, 2, 3]) True >>> can_find_increasing_subsequence_of_length_3([1, 2, 2, 3]) True >>> can_find_increasing_subsequence_of_length_3([5, 4, 3, 2, 1]) False >>> can_find_increasing_subsequence_of_length_3([]) False >>> can_find_increasing_subsequence_of_length_3([1, 1, 2, 2, 3, 4, 5, 3, 6, 7]) True pass","solution":"def can_find_increasing_subsequence_of_length_3(sequence): n = len(sequence) if n < 3: return False left_min = [float('inf')] * n right_max = [float('-inf')] * n left_min[0] = sequence[0] for i in range(1, n): left_min[i] = min(left_min[i-1], sequence[i]) right_max[n-1] = sequence[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], sequence[i]) for i in range(1, n-1): if left_min[i-1] < sequence[i] < right_max[i+1]: return True return False"},{"question":"def min_operations_to_uniform_coins(coins: List[int]) -> int: Returns the minimum number of operations required to make all the coins show the same side. Either all heads (even numbers) or all tails (odd numbers). >>> min_operations_to_uniform_coins([1, 2, 3, 5, 6]) == 2 >>> min_operations_to_uniform_coins([2, 4, 6, 8]) == 0 >>> min_operations_to_uniform_coins([1, 3, 5, 7]) == 0 >>> min_operations_to_uniform_coins([1, 2, 3, 4, 5]) == 2 >>> min_operations_to_uniform_coins([2, 3, 4, 5, 6]) == 2 >>> min_operations_to_uniform_coins([1, 1, 1, 1]) == 0 >>> min_operations_to_uniform_coins([2, 2, 2, 2]) == 0 >>> min_operations_to_uniform_coins([1]) == 0 >>> min_operations_to_uniform_coins([2]) == 0","solution":"def min_operations_to_uniform_coins(coins): Returns the minimum number of operations required to make all the coins show the same side. Either all heads (even numbers) or all tails (odd numbers). even_count = sum(1 for coin in coins if coin % 2 == 0) odd_count = len(coins) - even_count # Total coins minus even coins gives odd coin count return min(even_count, odd_count) # Test cases to verify the solution print(min_operations_to_uniform_coins([1, 2, 3, 5, 6])) # Expected output: 2 print(min_operations_to_uniform_coins([2, 4, 6, 8])) # Expected output: 0 print(min_operations_to_uniform_coins([1, 3, 5, 7])) # Expected output: 0 print(min_operations_to_uniform_coins([1, 2, 3, 4, 5])) # Expected output: 2 print(min_operations_to_uniform_coins([2, 3, 4, 5, 6])) # Expected output: 2"},{"question":"class LibraryReservationSystem: A class representing a library reservation system for different types of rooms. >>> system = LibraryReservationSystem(3, 2, 1) >>> system.bookRoom(1) # should return True, successfully booked a study room True >>> system.bookRoom(2) # should return True, successfully booked a meeting room True >>> system.bookRoom(3) # should return True, successfully booked a conference hall True >>> system.bookRoom(1) # booking another study room, should return True True >>> system.bookRoom(1) # booking last available study room, should return True True >>> system.bookRoom(1) # no more study rooms available, should return False False >>> system.bookRoom(4) # invalid room type, should return False False def __init__(self, study, meeting, conference): Initializes the LibraryReservationSystem object with the number of rooms for each type. :param study: Number of study rooms available. :param meeting: Number of meeting rooms available. :param conference: Number of conference halls available. pass def bookRoom(self, roomType) -> bool: Books a room of the given type if available. :param roomType: Type of the room to be booked (1 for study, 2 for meeting, 3 for conference) :return: True if a room is booked, False otherwise. pass","solution":"class LibraryReservationSystem: def __init__(self, study, meeting, conference): Initializes the LibraryReservationSystem object with the number of rooms for each type. :param study: Number of study rooms available. :param meeting: Number of meeting rooms available. :param conference: Number of conference halls available. self.room_count = { 1: study, 2: meeting, 3: conference } def bookRoom(self, roomType): Books a room of the given type if available. :param roomType: Type of the room to be booked (1 for study, 2 for meeting, 3 for conference) :return: True if a room is booked, False otherwise. if self.room_count.get(roomType, 0) > 0: self.room_count[roomType] -= 1 return True else: return False"},{"question":"def smallest_string_after_k_swaps(s: str, k: int) -> str: Returns the lexicographically smallest string after exactly k adjacent swaps. >>> smallest_string_after_k_swaps(\\"cba\\", 1) 'bca' >>> smallest_string_after_k_swaps(\\"abc\\", 1) 'abc' >>> smallest_string_after_k_swaps(\\"dcba\\", 3) 'bcda' >>> smallest_string_after_k_swaps(\\"abcd\\", 2) 'abcd' >>> smallest_string_after_k_swaps(\\"zxy\\", 0) 'zxy' >>> smallest_string_after_k_swaps(\\"a\\", 10) 'a' >>> smallest_string_after_k_swaps(\\"bac\\", 5) 'abc'","solution":"def smallest_string_after_k_swaps(s, k): Returns the lexicographically smallest string after exactly k adjacent swaps. Args: s: str - input string consisting of lowercase alphabets. k: int - number of swap operations. Returns: str - lexicographically smallest string after exactly k swaps. # Base case: if k is 0, the string cannot be changed if k == 0: return s n = len(s) char_list = list(s) for i in range(k): for j in range(n - 1): if char_list[j] > char_list[j + 1]: # Swap adjacent characters if they are out of order char_list[j], char_list[j + 1] = char_list[j + 1], char_list[j] break # Only one swap per iteration of the outer loop return \\"\\".join(char_list)"},{"question":"from typing import List def minSubArrayLen(target: int, arr: List[int]) -> int: Given an array of integers \`arr\`, and an integer \`target\`, return the minimum length of a contiguous subarray of which the sum is greater than or equal to \`target\`. If there is no such subarray, return \`0\`. >>> minSubArrayLen(7, [2, 3, 1, 2, 4, 3]) 2 >>> minSubArrayLen(100, [1, 2, 3, 4, 5]) 0 >>> minSubArrayLen(15, [1, 2, 3, 4, 5]) 5 >>> minSubArrayLen(4, [1, 4, 4]) 1 >>> minSubArrayLen(6, [2, 3, 1, 1, 1, 2, 1]) 3 >>> minSubArrayLen(100, [50, 1, 50, 1, 50]) 3","solution":"from typing import List def minSubArrayLen(target: int, arr: List[int]) -> int: n = len(arr) left = 0 min_length = float('inf') current_sum = 0 for right in range(n): current_sum += arr[right] while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 return min_length if min_length != float('inf') else 0"},{"question":"def max_items_within_budget(prices: List[int], budget: int) -> int: Finds the maximum number of items that can be bought without exceeding the provided budget. Parameters: prices (list of int): List of item prices. budget (int): The total amount of money that can be spent. Returns: int: The maximum number of items that can be bought within the budget. pass def test_max_items_within_budget(): # Basic test case assert max_items_within_budget([1, 2, 3, 4, 5], 10) == 4 # Test case where budget allows to buy all items assert max_items_within_budget([1, 1, 1, 1], 5) == 4 # Test case with budget not sufficient for even the cheapest item assert max_items_within_budget([4, 5, 6], 3) == 0 # Test case with some affordable and some unaffordable items assert max_items_within_budget([2, 3, 5, 7], 10) == 3 # Test case where all items have the same price assert max_items_within_budget([3, 3, 3, 3, 3], 9) == 3 # Test case where the budget exactly matches the sum of some items assert max_items_within_budget([2, 2, 2, 2], 6) == 3 # Test case with zero budget assert max_items_within_budget([1, 2, 3], 0) == 0 # Test case with an empty price list assert max_items_within_budget([], 10) == 0","solution":"def max_items_within_budget(prices, budget): Finds the maximum number of items that can be bought without exceeding the provided budget. Parameters: prices (list of int): List of item prices. budget (int): The total amount of money that can be spent. Returns: int: The maximum number of items that can be bought within the budget. # Sort prices to try buying the cheapest items first prices.sort() total_spent = 0 items_bought = 0 for price in prices: if total_spent + price <= budget: total_spent += price items_bought += 1 else: break return items_bought"},{"question":"def max_profit(prices: List[int]) -> int: Given a list of stock prices where prices[i] is the price of a given stock on day i, return the maximum profit you can achieve from completing at most one transaction (i.e., buy one and sell one share of the stock). If no profit can be achieved, return 0. >>> max_profit([]) == 0 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([5]) == 0 >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([1, 2, 3, 4, 5]) == 4 >>> max_profit([5, 7, 2, 8]) == 6 >>> max_profit([7, 3, 5, 1, 8]) == 7 >>> max_profit([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 9 >>> max_profit([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 0","solution":"def max_profit(prices): Given a list of stock prices where prices[i] is the price of a given stock on day i, return the maximum profit you can achieve from completing at most one transaction (i.e., buy one and sell one share of the stock). If no profit can be achieved, return 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def rob_houses(money: List[int]) -> int: Returns the maximum amount of money that can be robbed without alerting the security systems. :param money: List[int] representing the amount of money in each house. :return: int, the maximum amount of money that can be robbed. >>> rob_houses([]) == 0 >>> rob_houses([5]) == 5 >>> rob_houses([2, 3]) == 3 >>> rob_houses([1, 2, 3, 1]) == 4 >>> rob_houses([2, 7, 9, 3, 1]) == 12 >>> rob_houses([2, 1, 1, 2]) == 4 >>> rob_houses([10, 1, 10, 1, 10]) == 30 >>> rob_houses([0, 0, 0, 0, 0]) == 0","solution":"def rob_houses(money): Returns the maximum amount of money that can be robbed without alerting the security systems. :param money: List[int] representing the amount of money in each house. :return: int, the maximum amount of money that can be robbed. if not money: return 0 if len(money) == 1: return money[0] n = len(money) dp = [0] * n dp[0] = money[0] dp[1] = max(money[0], money[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + money[i]) return dp[-1]"},{"question":"from typing import List def shortestBridge(grid: List[List[int]]) -> int: Find the shortest bridge (number of 0s) needed to connect two islands in the grid. >>> shortestBridge([[0,1],[1,0]]) == 1 >>> shortestBridge([[0,1,0],[0,0,0],[0,0,1]]) == 2 def test_shortestBridge(): grid1 = [[0,1],[1,0]] assert shortestBridge(grid1) == 1 grid2 = [[0,1,0],[0,0,0],[0,0,1]] assert shortestBridge(grid2) == 2 grid3 = [ [1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1] ] assert shortestBridge(grid3) == 1 grid4 = [ [0, 1, 0, 1], [0, 0, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0] ] assert shortestBridge(grid4) == 1 grid5 = [ [1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0] ] assert shortestBridge(grid5) == 6","solution":"from collections import deque def shortestBridge(grid): Find the shortest bridge (number of 0s) needed to connect two islands in the grid. def in_bounds(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) def get_neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: if in_bounds(x + dx, y + dy): yield x + dx, y + dy def bfs_find_island(): for r in range(len(grid)): for c in range(len(grid[r])): if grid[r][c] == 1: queue = deque([(r, c)]) component = set() while queue: x, y = queue.popleft() if (x, y) not in component: component.add((x, y)) for nx, ny in get_neighbors(x, y): if grid[nx][ny] == 1: queue.append((nx, ny)) return component def bfs_shortest_bridge(source): queue = deque([(x, y, 0) for x, y in source]) visited = set(source) while queue: x, y, d = queue.popleft() for nx, ny in get_neighbors(x, y): if (nx, ny) not in visited: if grid[nx][ny] == 1: return d queue.append((nx, ny, d + 1)) visited.add((nx, ny)) island1 = bfs_find_island() for x, y in island1: grid[x][y] = 2 # Marking island1 cells to avoid revisiting return bfs_shortest_bridge(island1)"},{"question":"def max_array_sum_after_k_operations(nums: List[int], k: int) -> int: Return the maximum possible sum of the array elements after performing the operation at most k times. In one operation, any element in the array can be replaced with any other integer. >>> max_array_sum_after_k_operations([1, 2, 3], 0) 6 >>> max_array_sum_after_k_operations([1, 2, 3], 1) float('inf') >>> max_array_sum_after_k_operations([1, 2, 3], 5) float('inf') >>> max_array_sum_after_k_operations([1, -2, 3], 2) float('inf') >>> max_array_sum_after_k_operations([-1, -2, -3], 3) float('inf') >>> max_array_sum_after_k_operations([-1, -2, 5, 6], 2) float('inf')","solution":"def max_array_sum_after_k_operations(nums, k): Returns the maximum possible sum of the array elements after performing the operation at most k times. In one operation, any element in nums can be replaced with any other integer. # If k is zero, no operations can be performed if k == 0: return sum(nums) # Sort the array to prioritize replacing the smallest elements sorted_nums = sorted(nums) # Initialize variables to keep track of the sum and operations performed total_sum = sum(nums) operations_performed = 0 index = 0 while operations_performed < k and index < len(sorted_nums): # Remove the smallest element and replace it total_sum -= sorted_nums[index] # Replace with a maximum possible value total_sum += float('inf') operations_performed += 1 index += 1 return total_sum"},{"question":"def numDistinctIslands(grid: List[List[int]]) -> int: Returns the number of distinct islands in the given 2D binary grid. An island is a group of '1's (land) connected 4-directionally (horizontal or vertical). An island is considered distinct if and only if one is not equal to another by shape, even if they are rotated or flipped. Parameters: grid (List[List[int]]): 2D binary grid where 0 represents water and 1 represents land. Returns: int: Number of distinct islands based on their shapes. Example: >>> numDistinctIslands([ ... [1, 1, 0], ... [0, 1, 0], ... [0, 0, 0], ... [0, 0, 1], ... [0, 1, 1] ... ]) 2","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in the given 2D binary grid. Parameters: grid (List[List[int]]): 2D binary grid where 0 represents water and 1 represents land. Returns: int: Number of distinct islands based on their shapes. def dfs(x, y, direction): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 shape.append(direction) # Explore all four directions dfs(x + 1, y, 'd') # move down dfs(x - 1, y, 'u') # move up dfs(x, y + 1, 'r') # move right dfs(x, y - 1, 'l') # move left shape.append('b') # backtrack distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: shape = [] dfs(i, j, 'o') # mark the starting point distinct_islands.add(tuple(shape)) return len(distinct_islands)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_sum_subtree(root): Returns the maximum sum of any subtree in the given binary search tree. from solution import TreeNode, max_sum_subtree def test_empty_tree(): assert max_sum_subtree(None) == float('-inf') def test_single_node_tree(): root = TreeNode(10) assert max_sum_subtree(root) == 10 def test_simple_tree(): root = TreeNode(1, TreeNode(2), TreeNode(3)) assert max_sum_subtree(root) == 6 def test_balanced_tree(): root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) assert max_sum_subtree(root) == 15 def test_unbalanced_tree(): root = TreeNode(1, TreeNode(-2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(-6))) assert max_sum_subtree(root) == 7 def test_tree_with_negative_values(): root = TreeNode(-1, TreeNode(-2, None, TreeNode(3)), TreeNode(-3)) assert max_sum_subtree(root) == 3","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_sum_subtree(root): Returns the maximum sum of any subtree in the given binary search tree. def dfs(node): if not node: return 0, float('-inf') left_sum, left_max_sum = dfs(node.left) right_sum, right_max_sum = dfs(node.right) current_sum = node.val + left_sum + right_sum max_sum = max(current_sum, left_max_sum, right_max_sum) return current_sum, max_sum return dfs(root)[1]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def replace_with_greatest(head: ListNode) -> ListNode: Replace each node's value with the greatest value among the values of all the nodes that follow that node. Args: head: ListNode - The head of the linked list. Returns: ListNode - The modified linked list. pass from solution import ListNode, replace_with_greatest def create_linked_list(values): if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head def listnode_to_list(head): result = [] current = head while current: result.append(current.val) current = current.next return result def test_empty_list(): assert replace_with_greatest(None) == None def test_single_element(): head = create_linked_list([5]) new_head = replace_with_greatest(head) assert listnode_to_list(new_head) == [float('-inf')] def test_two_elements(): head = create_linked_list([2, 1]) new_head = replace_with_greatest(head) assert listnode_to_list(new_head) == [1, float('-inf')] def test_ascending_order(): head = create_linked_list([1, 2, 3, 4]) new_head = replace_with_greatest(head) assert listnode_to_list(new_head) == [4, 4, 4, float('-inf')] def test_descending_order(): head = create_linked_list([4, 3, 2, 1]) new_head = replace_with_greatest(head) assert listnode_to_list(new_head) == [3, 2, 1, float('-inf')] def test_random_order(): head = create_linked_list([3, 2, 5, 1, 4]) new_head = replace_with_greatest(head) assert listnode_to_list(new_head) == [5, 5, 4, 4, float('-inf')]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def replace_with_greatest(head: ListNode) -> ListNode: Replace each node's value with the greatest value among the values of all the nodes that follow that node. Args: head: ListNode - The head of the linked list. Returns: ListNode - The modified linked list. if not head: return None # Start from the end of the list and keep track of the maximum value found prev = None current = head max_val = float('-inf') while current: next_node = current.next current.next = prev prev = current current = next_node head = prev current = head while current: original_val = current.val current.val = max_val max_val = max(max_val, original_val) current = current.next prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node head = prev return head"},{"question":"from typing import List from collections import deque def shortest_path_in_grid(grid: List[List[int]]) -> int: You are given a 2D grid \`grid\` of size \`m x n\` representing a field. Each cell in the grid contains either an obstacle represented by a \`1\` or empty space represented by a \`0\`. You start at the top-left corner of the grid (position \`(0, 0)\`) and your goal is to reach the bottom-right corner (position \`(m-1, n-1)\`). You can only move in four possible directions: up, down, left, or right and you cannot move into cells with obstacles. Returns the length of the shortest path from the top-left corner to the bottom-right corner of the grid. If no such path exists, returns -1. >>> shortest_path_in_grid([]) -1 >>> shortest_path_in_grid([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0]]) -1 >>> shortest_path_in_grid([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 1]]) -1 >>> shortest_path_in_grid([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0]]) 5 >>> shortest_path_in_grid([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0]]) 5 >>> shortest_path_in_grid([ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0]]) -1 >>> shortest_path_in_grid([ ... [0, 0, 1, 0, 0], ... [1, 0, 1, 0, 1], ... [0, 0, 0, 1, 0], ... [1, 0, 1, 0, 0], ... [0, 0, 0, 0, 0]]) 9","solution":"from collections import deque def shortest_path_in_grid(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner of the grid. If no such path exists, returns -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 1)]) # (row, col, path_length) visited = set((0, 0)) while queue: row, col, length = queue.popleft() if row == m - 1 and col == n - 1: return length for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < m and 0 <= new_col < n and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: queue.append((new_row, new_col, length + 1)) visited.add((new_row, new_col)) return -1"},{"question":"from typing import List def least_interval(tasks: List[int], n: int) -> int: Returns the minimum time required to finish all tasks with the given cooldown period. :param tasks: List[int] - a list of integers representing the time each task takes. :param n: int - the cooldown period between the same tasks. :return: int - the minimum time required to finish all tasks. >>> least_interval([], 2) 0 >>> least_interval([1], 2) 1 >>> least_interval([1, 2, 1, 2], 0) 4 >>> least_interval([1, 2, 3, 4], 2) 4 >>> least_interval([1, 1, 2, 2], 2) 5 >>> least_interval([1, 1, 1, 2, 2, 3], 2) 7","solution":"from collections import Counter def least_interval(tasks, n): Returns the minimum time required to finish all tasks with the given cooldown period. :param tasks: List[int] - a list of integers representing the time each task takes. :param n: int - the cooldown period between the same tasks. :return: int - the minimum time required to finish all tasks. if not tasks: return 0 task_counts = Counter(tasks) max_task_frequency = max(task_counts.values()) count_max_frequency = sum(1 for count in task_counts.values() if count == max_task_frequency) intervals = (max_task_frequency - 1) * (n + 1) + count_max_frequency return max(intervals, len(tasks))"},{"question":"from typing import List def max_non_overlapping_intervals(intervals: List[List[int]]) -> int: Returns the maximum number of non-overlapping intervals that can be completed. >>> max_non_overlapping_intervals([]) 0 >>> max_non_overlapping_intervals([[1, 2], [3, 4], [5, 6]]) 3 >>> max_non_overlapping_intervals([[1, 3], [2, 4], [3, 5]]) 2 >>> max_non_overlapping_intervals([[1, 2], [2, 3], [3, 4]]) 3 >>> max_non_overlapping_intervals([[1, 4], [2, 5], [3, 6]]) 1 >>> max_non_overlapping_intervals([[1, 2], [1, 3], [2, 4], [3, 5]]) 2 pass","solution":"def max_non_overlapping_intervals(intervals): Returns the maximum number of non-overlapping intervals that can be completed. if not intervals: return 0 # Sort the intervals based on their end times intervals.sort(key=lambda x: x[1]) # Keep track of the end time of the last added interval end_time = float('-inf') count = 0 for interval in intervals: if interval[0] >= end_time: # If the start time of the current interval is after or exactly at the end time # of the last added interval, we can add this interval end_time = interval[1] count += 1 return count"},{"question":"from typing import Dict def count_of_atoms(formula: str) -> Dict[str, int]: Parse a chemical formula and return a dictionary with the count of each element. >>> count_of_atoms(\\"H2O\\") {\\"H\\": 2, \\"O\\": 1} >>> count_of_atoms(\\"Mg(OH)2\\") {\\"Mg\\": 1, \\"O\\": 2, \\"H\\": 2} >>> count_of_atoms(\\"K4(ON(SO3)2)2\\") {\\"K\\": 4, \\"O\\": 14, \\"N\\": 2, \\"S\\": 4} >>> count_of_atoms(\\"Ca(OH)\\") {\\"Ca\\": 1, \\"O\\": 1, \\"H\\": 1}","solution":"from collections import defaultdict def count_of_atoms(formula): def parse(): stack = [defaultdict(int)] i, n = 0, len(formula) while i < n: if formula[i] == '(': stack.append(defaultdict(int)) i += 1 elif formula[i] == ')': i += 1 i_start = i while i < n and formula[i].isdigit(): i += 1 multiplier = int(formula[i_start:i] or 1) top = stack.pop() for el, count in top.items(): stack[-1][el] += count * multiplier else: i_start = i i += 1 while i < n and formula[i].islower(): i += 1 element = formula[i_start:i] i_start = i while i < n and formula[i].isdigit(): i += 1 count = int(formula[i_start:i] or 1) stack[-1][element] += count return stack.pop() return dict(parse())"},{"question":"def find_smallest_rectangle(park): Find the smallest rectangle that encloses all the trees in the park. Parameters: park (list of list of int): 2D grid representing the park Returns: list: coordinates of the rectangle in the format [r1, c1, r2, c2] >>> find_smallest_rectangle([[0, 0], [0, 0]]) [] >>> find_smallest_rectangle([]) [] >>> find_smallest_rectangle([[0]]) [] >>> find_smallest_rectangle([[1]]) [0, 0, 0, 0] >>> find_smallest_rectangle([[0, 1], [0, 0]]) [0, 1, 0, 1] >>> find_smallest_rectangle([ [0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0] ]) [1, 1, 2, 2] >>> find_smallest_rectangle([ [0, 0, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0] ]) [1, 0, 3, 3] >>> find_smallest_rectangle([ [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0], [0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0] ]) [1, 1, 3, 5]","solution":"def find_smallest_rectangle(park): Find the smallest rectangle that encloses all the trees in the park. Parameters: park (list of list of int): 2D grid representing the park Returns: list: coordinates of the rectangle in the format [r1, c1, r2, c2] if not park or not any(any(row) for row in park): return [] num_rows = len(park) num_cols = len(park[0]) min_row, max_row = float('inf'), float('-inf') min_col, max_col = float('inf'), float('-inf') for r in range(num_rows): for c in range(num_cols): if park[r][c] == 1: if r < min_row: min_row = r if r > max_row: max_row = r if c < min_col: min_col = c if c > max_col: max_col = c return [min_row, min_col, max_row, max_col]"},{"question":"def max_length_of_good_substring(s: str) -> int: Return the maximum length of a good substring in the given string s. A good substring is a substring with all unique characters. >>> max_length_of_good_substring(\\"abcabcbb\\") 3 >>> max_length_of_good_substring(\\"abcdefg\\") 7 >>> max_length_of_good_substring(\\"bbbbb\\") 1 >>> max_length_of_good_substring(\\"\\") 0 >>> max_length_of_good_substring(\\"pwwkew\\") 3 >>> max_length_of_good_substring(\\"abababab\\") 2 >>> max_length_of_good_substring(\\"dvdf\\") 3","solution":"def max_length_of_good_substring(s): Returns the maximum length of a good substring in the given string s. A good substring is a substring with all unique characters. max_len = 0 start = 0 char_index = {} for end in range(len(s)): if s[end] in char_index and char_index[s[end]] >= start: start = char_index[s[end]] + 1 char_index[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def min_deletions_to_palindrome(s: str) -> int: Determine the minimum number of deletions required to make a given string a palindrome. >>> min_deletions_to_palindrome('a') == 0 >>> min_deletions_to_palindrome('aa') == 0 >>> min_deletions_to_palindrome('ab') == 1 >>> min_deletions_to_palindrome('abca') == 1 >>> min_deletions_to_palindrome('aebcbda') == 2 >>> min_deletions_to_palindrome('racecar') == 0 >>> min_deletions_to_palindrome('geeksforgeeks') == 8","solution":"def min_deletions_to_palindrome(s): def longest_palindromic_subseq(s): n = len(s) # Create a 2D array to store the lengths of palindromic subsequences dp = [[0] * n for _ in range(n)] # All substrings with length 1 are palindromic for i in range(n): dp[i][i] = 1 # Build the table for length in range(2, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1] longest_palindromic_length = longest_palindromic_subseq(s) return len(s) - longest_palindromic_length"},{"question":"def gameOfLife(board: List[List[int]]) -> None: Simulates one iteration of the Game of Life. Args: board (list[list[int]]): 2D grid representing the board Returns: None >>> test_gameOfLife_all_dead() >>> test_gameOfLife_all_live() >>> test_gameOfLife_blinker() >>> test_gameOfLife_block() >>> test_gameOfLife_beacon()","solution":"def gameOfLife(board): Simulates one iteration of the Game of Life. Args: board (list[list[int]]): 2D grid representing the board Returns: None directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] rows, cols = len(board), len(board[0]) next_board = [[0] * cols for _ in range(rows)] for r in range(rows): for c in range(cols): live_neighbors = 0 for dr, dc in directions: if 0 <= r + dr < rows and 0 <= c + dc < cols: if board[r + dr][c + dc] == 1: live_neighbors += 1 if board[r][c] == 1 and (live_neighbors == 2 or live_neighbors == 3): next_board[r][c] = 1 elif board[r][c] == 0 and live_neighbors == 3: next_board[r][c] = 1 for r in range(rows): for c in range(cols): board[r][c] = next_board[r][c]"},{"question":"from typing import List def solve(board: List[List[str]]) -> None: Captures all regions surrounded by 'X' in-place. >>> board1 = [ ... ['X', 'X', 'X', 'X'], ... ['X', 'O', 'O', 'X'], ... ['X', 'X', 'O', 'X'], ... ['X', 'O', 'X', 'X'] ... ] >>> solve(board1) >>> assert board1 == [ ... ['X', 'X', 'X', 'X'], ... ['X', 'X', 'X', 'X'], ... ['X', 'X', 'X', 'X'], ... ['X', 'O', 'X', 'X'] ... ] >>> board2 = [['X']] >>> solve(board2) >>> assert board2 == [['X']] >>> board3 = [ ... ['O', 'O'], ... ['O', 'O'] ... ] >>> solve(board3) >>> assert board3 == [ ... ['O', 'O'], ... ['O', 'O'] ... ] >>> board4 = [] >>> solve(board4) >>> assert board4 == [] >>> board5 = [ ... ['X', 'X'], ... ['X', 'X'] ... ] >>> solve(board5) >>> assert board5 == [ ... ['X', 'X'], ... ['X', 'X'] ... ] >>> board6 = [ ... ['O', 'O'], ... ['O', 'O'] ... ] >>> solve(board6) >>> assert board6 == [ ... ['O', 'O'], ... ['O', 'O'] ... ] pass","solution":"def solve(board): Captures all regions surrounded by 'X' in-place. if not board or not board[0]: return rows, cols = len(board), len(board[0]) def dfs(x, y): if x < 0 or x >= rows or y < 0 or y >= cols or board[x][y] != 'O': return board[x][y] = 'B' dfs(x - 1, y) dfs(x + 1, y) dfs(x, y - 1) dfs(x, y + 1) for i in range(rows): dfs(i, 0) dfs(i, cols - 1) for j in range(cols): dfs(0, j) dfs(rows - 1, j) for i in range(rows): for j in range(cols): if board[i][j] == 'O': board[i][j] = 'X' elif board[i][j] == 'B': board[i][j] = 'O'"},{"question":"def find_anagrams(s: str, p: str) -> List[int]: Given a string \`s\` containing only lowercase alphabet characters, return a list containing the starting indices of all anagrams of a given string \`p\` within \`s\`. An anagram is a permutation of a word, meaning all the characters of the word are present in the same frequency. Note that the output order does not matter. >>> find_anagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> find_anagrams(\\"abab\\", \\"ab\\") [0, 1, 2] >>> find_anagrams(\\"af\\", \\"be\\") [] >>> find_anagrams(\\"baa\\", \\"aa\\") [1] >>> find_anagrams(\\"abcd\\", \\"bc\\") [1] >>> find_anagrams(\\"\\", \\"abc\\") [] >>> find_anagrams(\\"abcdefg\\", \\"hij\\") [] >>> find_anagrams(\\"a\\", \\"a\\") [0] >>> find_anagrams(\\"a\\", \\"b\\") []","solution":"from collections import Counter def find_anagrams(s, p): Returns a list containing the starting indices of all anagrams of the string \`p\` within the string \`s\`. p_count = Counter(p) s_count = Counter() result = [] p_len = len(p) for i in range(len(s)): s_count[s[i]] += 1 if i >= p_len: if s_count[s[i - p_len]] == 1: del s_count[s[i - p_len]] else: s_count[s[i - p_len]] -= 1 if s_count == p_count: result.append(i - p_len + 1) return result"},{"question":"def format_with_commas(s: str) -> str: Takes a string of digits and returns it formatted with commas as thousand separators. >>> format_with_commas(\\"1234\\") '1,234' >>> format_with_commas(\\"1234567890\\") '1,234,567,890' >>> format_with_commas(\\"0\\") '0' >>> format_with_commas(\\"1000000\\") '1,000,000' >>> format_with_commas(\\"12a34\\") Traceback (most recent call last): ValueError: Input must be a string of digits","solution":"def format_with_commas(s): Takes a string of digits and returns it formatted with commas as thousand separators. if not s.isdigit(): raise ValueError(\\"Input must be a string of digits\\") return '{:,}'.format(int(s))"},{"question":"def evaluate_expression(s: str) -> int: Evaluate a given arithmetic expression containing integers, '+', '-', and parentheses, and return the result as an integer. The given expression is always valid and follows the standard rules for arithmetic operations. >>> evaluate_expression(\\"3\\") 3 >>> evaluate_expression(\\"2+3\\") 5 >>> evaluate_expression(\\"3+2-1\\") 4 >>> evaluate_expression(\\"(3+(2-1))\\") 4 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23 >>> evaluate_expression(\\"1+(2-(3+(4-5)))\\") 1 >>> evaluate_expression(\\"2-1+(2-(3+(4-5)))\\") 1 >>> evaluate_expression(\\" 3 + 5 - 2 \\") 6 >>> evaluate_expression(\\" ( 2 - 1 ) \\") 1","solution":"def evaluate_expression(s): def evaluate(tokens): stack = [] num = 0 sign = 1 result = 0 for token in tokens: if token.isdigit(): num = num * 10 + int(token) elif token == '+': result += sign * num num = 0 sign = 1 elif token == '-': result += sign * num num = 0 sign = -1 elif token == '(': stack.append(result) stack.append(sign) result = 0 sign = 1 elif token == ')': result += sign * num num = 0 result *= stack.pop() # sign before the parenthesis result += stack.pop() # result calculated before the parenthesis return result + sign * num return evaluate(list(s.replace(' ', '')))"},{"question":"from typing import List def canPartitionKSubsets(arr: List[int], k: int) -> bool: Determines if the array can be partitioned into k non-empty subsets with equal sums. >>> canPartitionKSubsets([4, 3, 2, 3, 5, 2, 1], 4) == True >>> canPartitionKSubsets([1, 2, 3, 4], 2) == True >>> canPartitionKSubsets([1, 2, 3, 5], 2) == False >>> canPartitionKSubsets([1], 1) == True pass def test_canPartitionKSubsets_true_cases(): assert canPartitionKSubsets([4, 3, 2, 3, 5, 2, 1], 4) == True assert canPartitionKSubsets([1, 2, 3, 4], 2) == True assert canPartitionKSubsets([1, 1, 1, 1], 4) == True assert canPartitionKSubsets([2, 2, 3, 3, 4, 4, 5, 5], 4) == True def test_canPartitionKSubsets_false_cases(): assert canPartitionKSubsets([1, 2, 3, 5], 2) == False assert canPartitionKSubsets([1, 3], 2) == False assert canPartitionKSubsets([1, 1, 1, 2], 2) == False assert canPartitionKSubsets([1, 2, 2, 4], 3) == False def test_canPartitionKSubsets_edge_cases(): assert canPartitionKSubsets([1], 1) == True assert canPartitionKSubsets([0, 0, 0, 0], 4) == True assert canPartitionKSubsets([2], 2) == False","solution":"def canPartitionKSubsets(arr, k): Determines if the array can be partitioned into k non-empty subsets with equal sums. total_sum = sum(arr) if total_sum % k != 0: return False target_sum = total_sum // k arr.sort(reverse=True) used = [False] * len(arr) def backtrack(start, k, current_sum): if k == 0: return True if current_sum == target_sum: return backtrack(0, k-1, 0) for i in range(start, len(arr)): if not used[i] and current_sum + arr[i] <= target_sum: used[i] = True if backtrack(i+1, k, current_sum + arr[i]): return True used[i] = False return False return backtrack(0, k, 0)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter_of_binary_tree(root): Compute the diameter of a binary tree. The diameter is defined as the length of the longest path between any two nodes. >>> diameter_of_binary_tree(None) 0 >>> node = TreeNode(1) >>> diameter_of_binary_tree(node) 0 >>> node.left = TreeNode(2) >>> node.left.left = TreeNode(3) >>> diameter_of_binary_tree(node) 2 >>> node = TreeNode(1) >>> node.right = TreeNode(2) >>> node.right.right = TreeNode(3) >>> diameter_of_binary_tree(node) 2 >>> node = TreeNode(1) >>> node.left = TreeNode(2) >>> node.right = TreeNode(3) >>> diameter_of_binary_tree(node) 2 >>> node.left.left = TreeNode(4) >>> node.left.right = TreeNode(5) >>> diameter_of_binary_tree(node) 3 >>> node.left.right.left = TreeNode(6) >>> diameter_of_binary_tree(node) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter_of_binary_tree(root): Compute the diameter of a binary tree. The diameter is defined as the length of the longest path between any two nodes. def height_and_diameter(node): if not node: return 0, 0 # height, diameter left_height, left_diameter = height_and_diameter(node.left) right_height, right_diameter = height_and_diameter(node.right) current_height = max(left_height, right_height) + 1 # The diameter that passes through this node current_diameter = left_height + right_height # The largest diameter is either from the left subtree, right subtree or passing through this node max_diameter = max(current_diameter, left_diameter, right_diameter) return current_height, max_diameter _, diameter = height_and_diameter(root) return diameter"},{"question":"def get_top_employee(ratings: List[Tuple[int, int]]) -> int: Returns the ID of the employee with the highest rating. In the case of a tie, returns the smallest employee ID. >>> get_top_employee([(1, 100)]) 1 >>> get_top_employee([(1, 90), (2, 95), (3, 92)]) 2 >>> get_top_employee([(1, 90), (2, 95), (3, 95)]) 2 >>> get_top_employee([(1, 100), (2, 100), (3, 100), (4, 100)]) 1 >>> get_top_employee([]) Traceback (most recent call last): ... ValueError: Ratings list cannot be empty >>> get_top_employee([(i, 100) for i in range(1000)]) 0 >>> get_top_employee([(1, 50), (2, 100), (3, 75), (4, 100)]) 2 # Your code here","solution":"from typing import List, Tuple def get_top_employee(ratings: List[Tuple[int, int]]) -> int: Returns the ID of the employee with the highest rating. In the case of a tie, returns the smallest employee ID. if not ratings: raise ValueError(\\"Ratings list cannot be empty\\") # Find the maximum rating max_rating = max(ratings, key=lambda x: x[1])[1] # Filter employees with the maximum rating top_employees = [employee[0] for employee in ratings if employee[1] == max_rating] # Return the employee with the smallest ID among the top employees return min(top_employees)"},{"question":"def max_area_of_island(grid) -> int: Returns the area of the largest island in the grid. >>> max_area_of_island([ ... [0, 1, 0, 0], ... [1, 1, 0, 0], ... [0, 1, 0, 0] ... ]) == 4 >>> max_area_of_island([ ... [0, 1, 0, 1], ... [1, 1, 0, 0], ... [0, 0, 1, 1] ... ]) == 3 >>> max_area_of_island([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) == 0 >>> max_area_of_island([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 9 >>> max_area_of_island([]) == 0 >>> max_area_of_island([[]]) == 0 >>> max_area_of_island([ ... [1] ... ]) == 1 >>> max_area_of_island([ ... [0] ... ]) == 0","solution":"def max_area_of_island(grid): Returns the area of the largest island in the grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0: return 0 grid[r][c] = 0 return 1 + dfs(r-1, c) + dfs(r+1, c) + dfs(r, c-1) + dfs(r, c+1) max_area = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: max_area = max(max_area, dfs(r, c)) return max_area"},{"question":"def min_books(ratings: List[int]) -> int: Distribute books to students such that each student receives at least one book, and students with higher ratings get more books than their adjacent peers with lower ratings. Args: ratings (List[int]): A list of integers representing the ratings of each student. Returns: int: The minimum number of books needed. >>> min_books([1, 0, 2]) 5 >>> min_books([1, 2, 2]) 4 # Unit tests def test_example_1(): assert min_books([1, 0, 2]) == 5 def test_example_2(): assert min_books([1, 2, 2]) == 4 def test_single_student(): assert min_books([5]) == 1 def test_all_same_ratings(): assert min_books([3, 3, 3, 3]) == 4 def test_increasing_ratings(): assert min_books([1, 2, 3, 4, 5]) == 15 def test_decreasing_ratings(): assert min_books([5, 4, 3, 2, 1]) == 15 def test_alternating_ratings(): assert min_books([1, 2, 1, 2, 1]) == 7 def test_random_ratings(): assert min_books([4, 6, 4, 5, 6, 2]) == 10","solution":"def min_books(ratings): n = len(ratings) books = [1] * n # Left to right for i in range(1, n): if ratings[i] > ratings[i-1]: books[i] = books[i-1] + 1 # Right to left for i in range(n-2, -1, -1): if ratings[i] > ratings[i+1]: books[i] = max(books[i], books[i+1] + 1) return sum(books)"},{"question":"def max_possible_result(s: str) -> int: Given a string consisting of digits, returns the maximum possible result by inserting '+' or '-' between any two consecutive digits. >>> max_possible_result(\\"1111\\") 4 >>> max_possible_result(\\"12345\\") 15 >>> max_possible_result(\\"54321\\") 15 >>> max_possible_result(\\"8\\") 8 >>> max_possible_result(\\"15243\\") 15 >>> max_possible_result(\\"9876543210\\") 45","solution":"def max_possible_result(s): Given a string consisting of digits, returns the maximum possible result by inserting '+' or '-' between any two consecutive digits. # Initialize the result to the first digit as an integer result = int(s[0]) # Traverse through the string from the second character onwards for i in range(1, len(s)): # Always maximize the result by adding the digit result += int(s[i]) return result"},{"question":"from typing import List def max_sliding_window(nums: List[int], k: int) -> List[int]: Returns an array of the maximum values of each subarray of length k in nums. >>> max_sliding_window([], 3) == [] >>> max_sliding_window([1, 2, 3], 4) == [] >>> max_sliding_window([1], 1) == [1] >>> max_sliding_window([4, 4, 4, 4], 2) == [4, 4, 4] >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) == [3, 3, 5, 5, 6, 7] >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 2) == [3, 3, -1, 5, 5, 6, 7] >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 1) == [1, 3, -1, -3, 5, 3, 6, 7] >>> max_sliding_window([5, 4, 3, 2, 1], 3) == [5, 4, 3] >>> max_sliding_window([1, 2, 3, 4, 5], 3) == [3, 4, 5]","solution":"from collections import deque def max_sliding_window(nums, k): Returns an array of the maximum values of each subarray of length k in nums. if not nums or k == 0 or k > len(nums): return [] result = [] dq = deque() for i in range(len(nums)): if dq and dq[0] == i - k: dq.popleft() while dq and nums[dq[-1]] < nums[i]: dq.pop() dq.append(i) if i >= k - 1: result.append(nums[dq[0]]) return result"},{"question":"def has_cycle(graph: List[List[int]]) -> bool: Determine if the directed graph contains a cycle. Parameters: - graph: List[List[int]], an adjacency matrix representation of the directed graph Returns: - bool: True if the graph contains a cycle, False otherwise >>> has_cycle([ ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 1], ... [1, 0, 0, 0] ... ]) == True >>> has_cycle([ ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 1], ... [0, 0, 0, 0] ... ]) == False >>> has_cycle([]) == False >>> has_cycle([[0]]) == False >>> has_cycle([[1]]) == True >>> has_cycle([ ... [0, 1, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == False >>> has_cycle([ ... [0, 1], ... [1, 0] ... ]) == True","solution":"def has_cycle(graph): Determine if the directed graph contains a cycle. Parameters: - graph: List[List[int]], an adjacency matrix representation of the directed graph Returns: - bool: True if the graph contains a cycle, False otherwise def dfs(node, visited, recStack): visited[node] = True recStack[node] = True for neighbor, is_edge in enumerate(graph[node]): if is_edge: if not visited[neighbor] and dfs(neighbor, visited, recStack): return True elif recStack[neighbor]: return True recStack[node] = False return False n = len(graph) visited = [False] * n recStack = [False] * n for node in range(n): if not visited[node]: if dfs(node, visited, recStack): return True return False"},{"question":"def can_transform_to_bst(tree: List[int]) -> bool: Determines if it is possible to transform the binary tree into a binary search tree by rearranging the values of the nodes while keeping the structure of the tree unchanged. Args: tree: List[int] - Input list representation of a binary tree where \`-1\` represents missing nodes. Returns: bool - True if transformation is possible, False otherwise. >>> can_transform_to_bst([3, 2, 5, 1, -1, 4, 6]) True >>> can_transform_to_bst([10, 4, 6, 3, -1, -1, 8]) True >>> can_transform_to_bst([4, 4, 4, -1, -1, 4, -1]) False >>> can_transform_to_bst([1]) True >>> can_transform_to_bst([-1]) True >>> can_transform_to_bst([-1, -1, -1, -1]) True >>> can_transform_to_bst([10, 5, 15, 2, 7, 12, 17]) True","solution":"def can_transform_to_bst(tree): Determines if it is possible to transform the binary tree into a binary search tree by rearranging the values of the nodes while keeping the structure of the tree unchanged. :param tree: List[int], input list representation of a binary tree where \`-1\` represents missing nodes. :return: bool, True if transformation is possible, False otherwise. def in_order_traversal(tree, index, result): if index >= len(tree) or tree[index] == -1: return in_order_traversal(tree, 2 * index + 1, result) # left child result.append(tree[index]) in_order_traversal(tree, 2 * index + 2, result) # right child # Perform in-order traversal and collect only the valid nodes (discarding -1) elements_in_order = [] in_order_traversal(tree, 0, elements_in_order) # Remove -1 from elements_in_order elements_in_order = [x for x in elements_in_order if x != -1] # Check if it is possible to rearrange \`elements_in_order\` in such a way that it forms a strictly increasing sequence. n = len(elements_in_order) sorted_elements = sorted(elements_in_order) return n == len(set(sorted_elements))"},{"question":"import heapq def shortest_path_dag(graph, start, end): Finds the shortest path in a weighted directed acyclic graph from start to end. :param graph: List[List[(int, int)]], where graph[i] is a list of (node, weight) pairs. :param start: int, the starting node. :param end: int, the end node. :return: int, the length of the shortest path from start to end. If no path exists, returns -1. from solution import shortest_path_dag def test_shortest_path_simple(): graph = [ [(1, 1)], # 0 -> 1 (weight 1) [(2, 1)], # 1 -> 2 (weight 1) [(3, 1)], # 2 -> 3 (weight 1) [] # 3 has no outgoing edges ] assert shortest_path_dag(graph, 0, 3) == 3 def test_no_path_exists(): graph = [ [(1, 1)], # 0 -> 1 (weight 1) [(2, 1)], # 1 -> 2 (weight 1) [], # 2 has no outgoing edges [] # 3 has no outgoing edges ] assert shortest_path_dag(graph, 0, 3) == -1 def test_single_node(): graph = [[]] assert shortest_path_dag(graph, 0, 0) == 0 def test_disconnected_graph(): graph = [ [(1, 2)], # 0 -> 1 (weight 2) [(2, 2)], # 1 -> 2 (weight 2) [], # 2 has no outgoing edges [(4, 2)], # 3 -> 4 (weight 2) [] # 4 has no outgoing edges ] assert shortest_path_dag(graph, 0, 4) == -1 def test_multiple_paths(): graph = [ [(1, 1), (2, 4)], # 0 -> 1 (weight 1), 0 -> 2 (weight 4) [(2, 2), (3, 6)], # 1 -> 2 (weight 2), 1 -> 3 (weight 6) [(3, 3)], # 2 -> 3 (weight 3) [] # 3 has no outgoing edges ] assert shortest_path_dag(graph, 0, 3) == 6 def test_multiple_edges(): graph = [ [(1, 1), (2, 3)], # 0 -> 1 (weight 1), 0 -> 2 (weight 3) [(2, 1)], # 1 -> 2 (weight 1) [(3, 1)], # 2 -> 3 (weight 1) [] # 3 has no outgoing edges ] assert shortest_path_dag(graph, 0, 3) == 3","solution":"import heapq def shortest_path_dag(graph, start, end): Finds the shortest path in a weighted directed acyclic graph from start to end. :param graph: List[List[(int, int)]], where graph[i] is a list of (node, weight) pairs. :param start: int, the starting node. :param end: int, the end node. :return: int, the length of the shortest path from start to end. If no path exists, returns -1. n = len(graph) dist = [float('inf')] * n dist[start] = 0 min_heap = [(0, start)] while min_heap: current_dist, u = heapq.heappop(min_heap) if u == end: return current_dist if current_dist > dist[u]: continue for v, weight in graph[u]: new_dist = current_dist + weight if new_dist < dist[v]: dist[v] = new_dist heapq.heappush(min_heap, (new_dist, v)) return -1 if dist[end] == float('inf') else dist[end]"},{"question":"def alice_can_win(candies: List[int]) -> bool: Determines whether Alice can guarantee a win in the given game. Args: candies (list): A list where each element represents the number of candies in a pile. Returns: bool: True if Alice can guarantee a win, False otherwise. >>> alice_can_win([1]) == True >>> alice_can_win([1, 1]) == False >>> alice_can_win([1, 1, 1]) == True >>> alice_can_win([2, 2]) == False >>> alice_can_win([1, 2, 3]) == False >>> alice_can_win([4, 5, 7]) == True >>> alice_can_win([0, 0, 0]) == False","solution":"def alice_can_win(candies): Determines whether Alice can guarantee a win in the given game. Args: candies (list): A list where each element represents the number of candies in a pile. Returns: bool: True if Alice can guarantee a win, False otherwise. # XOR of all candy piles xor_sum = 0 for pile in candies: xor_sum ^= pile # Alice wins if the XOR of all elements is not 0 return xor_sum != 0"},{"question":"def min_subarray_len(arr: List[int], target: int) -> int: Find the length of the shortest subarray whose sum is greater than or equal to target. Examples: >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 7], 7) 1 >>> min_subarray_len([1, 2, 3, 4, 5], 20) 0 >>> min_subarray_len([1, 2, 3, 4, 5], 15) 5 >>> min_subarray_len([1, 2, 3, 4, 5, 6], 8) 2 >>> min_subarray_len([10, 2, 3, 1, 2], 5) 1","solution":"def min_subarray_len(arr, target): n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else 0"},{"question":"class KthLargestElement: def __init__(self, nums): Initializes the object with the given integer array \`nums\`. self.nums = nums def findKthLargest(self, k): Returns the k-th largest element in the array. >>> kle = KthLargestElement([3, 2, 1, 5, 6, 4]) >>> kle.findKthLargest(2) 5 >>> kle = KthLargestElement([1]) >>> kle.findKthLargest(1) 1 >>> kle = KthLargestElement([2, 2, 2, 2]) >>> kle.findKthLargest(3) 2 >>> kle = KthLargestElement([-1, -2, -3, -4, -5]) >>> kle.findKthLargest(1) -1 >>> kle = KthLargestElement([3, -2, 1, 5, -6, 4]) >>> kle.findKthLargest(3) 3 >>> kle = KthLargestElement([3, 2, 3, 1, 2, 4, 5, 5, 6]) >>> kle.findKthLargest(4) 4","solution":"class KthLargestElement: def __init__(self, nums): self.nums = nums def findKthLargest(self, k): Returns the k-th largest element in the array. return sorted(self.nums, reverse=True)[k-1]"},{"question":"def numIslands(grid): Returns the number of islands in the given 2D binary grid. >>> numIslands([ ... ['1', '1', '1', '1', '0'], ... ['1', '1', '0', '1', '0'], ... ['1', '1', '0', '0', '0'], ... ['0', '0', '0', '0', '0'] ... ]) == 1 >>> numIslands([ ... ['1', '1', '0', '0', '0'], ... ['1', '1', '0', '0', '0'], ... ['0', '0', '1', '0', '0'], ... ['0', '0', '0', '1', '1'] ... ]) == 3 >>> >>> numIslands([ ... ['0', '0', '0', '0', '0'], ... ['0', '0', '0', '0', '0'], ... ['0', '0', '0', '0', '0'], ... ['0', '0', '0', '0', '0'] ... ]) == 0 >>> >>> numIslands([]) == 0 >>> >>> numIslands([ ... ['1', '1', '0', '0', '1'], ... ['1', '0', '0', '1', '0'], ... ['0', '0', '1', '0', '0'], ... ['1', '1', '0', '1', '1'] ... ]) == 6","solution":"def numIslands(grid): Returns the number of islands in the given 2D binary grid. if not grid: return 0 def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != '1': return grid[x][y] = '0' # mark as visited # recursively visit all neighboring cells dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) num_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': dfs(i, j) num_islands += 1 return num_islands"},{"question":"from typing import List def is_pattern_in_all_words(words: List[str], pattern: str) -> List[bool]: Determine if the pattern appears as a subsequence in all of the strings within the list. >>> is_pattern_in_all_words([\\"abcde\\", \\"ace\\", \\"aec\\", \\"bdf\\"], \\"ace\\") [True, True, False, False] >>> is_pattern_in_all_words([\\"abcde\\", \\"ace\\", \\"aec\\", \\"bdf\\"], \\"\\") [True, True, True, True] >>> is_pattern_in_all_words([], \\"ace\\") [] >>> is_pattern_in_all_words([\\"abc\\", \\"def\\", \\"ghi\\"], \\"xyz\\") [False, False, False] >>> is_pattern_in_all_words([\\"abcdef\\", \\"zacef\\", \\"xyzace\\"], \\"ace\\") [True, True, True]","solution":"def is_subsequence(pattern, word): Determine if the pattern is a subsequence of the word. it = iter(word) return all(char in it for char in pattern) def is_pattern_in_all_words(words, pattern): Determine if the pattern is a subsequence in each word in the words list. return [is_subsequence(pattern, word) for word in words]"},{"question":"def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 0) [1, 2, 3, 4, 5, 6, 7] >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 7) [1, 2, 3, 4, 5, 6, 7] >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 10) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([1], 3) [1] >>> rotate_array([1, 2], 1) [2, 1] >>> rotate_array([1, 2], 2) [1, 2] >>> rotate_array([1, 2], 3) [2, 1]","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. Parameters: arr (list): List of integers to be rotated. k (int): Number of steps to rotate the array to the right. Returns: list: Rotated array. n = len(arr) k = k % n # In case k is greater than the length of the array return arr[-k:] + arr[:-k]"},{"question":"def min_steps_to_reach_rightmost(buildings): Returns the minimum number of steps required to move from the leftmost building to the rightmost building. Parameters: buildings (list): The list of heights of the buildings. Returns: int: The minimum number of steps required. >>> min_steps_to_reach_rightmost([1, 2, 3, 4, 5]) == 4 >>> min_steps_to_reach_rightmost([5, 1, 5, 1, 5]) == 2 >>> min_steps_to_reach_rightmost([2, 2, 2, 2, 2]) == 4 >>> min_steps_to_reach_rightmost([5]) == 0 >>> min_steps_to_reach_rightmost([3, 4]) == 1 >>> min_steps_to_reach_rightmost([5, 4, 3, 2, 1]) == 4 >>> min_steps_to_reach_rightmost([1, 3, 2, 4, 3, 5]) == 3","solution":"def min_steps_to_reach_rightmost(buildings): Returns the minimum number of steps required to move from the leftmost building to the rightmost building. Parameters: buildings (list): The list of heights of the buildings. Returns: int: The minimum number of steps required. n = len(buildings) if n <= 1: return 0 steps = 0 i = 0 while i < n - 1: if buildings[i] <= buildings[i + 1]: i += 1 elif i + 2 < n and buildings[i + 2] >= buildings[i]: i += 2 else: i += 1 steps += 1 return steps"},{"question":"def max_items_distribution(weights, capacities): Returns the maximum number of items that can be distributed into the bags without exceeding their capacity. :param weights: List[int], list of weights of the items :param capacities: List[int], list of capacities of the bags :return: int, maximum number of items that can be distributed >>> max_items_distribution([1, 2, 3], [3, 3, 3]) == 3 >>> max_items_distribution([5, 4, 3], [3, 3, 5]) == 2 >>> max_items_distribution([1, 2, 3, 4], [3, 3]) == 2 >>> max_items_distribution([1, 2], [1, 2, 3, 4]) == 2 >>> max_items_distribution([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == 5 >>> max_items_distribution([], [1, 2, 3]) == 0 >>> max_items_distribution([1, 2, 3], []) == 0","solution":"def max_items_distribution(weights, capacities): Returns the maximum number of items that can distributed into the bags without exceeding their capacity. :param weights: List[int], list of weights of the items :param capacities: List[int], list of capacities of the bags :return: int, maximum number of items that can be distributed # Sort weights of items and capacities of bags to facilitate the greedy approach weights.sort() capacities.sort() item_index = 0 bag_index = 0 items_distributed = 0 while item_index < len(weights) and bag_index < len(capacities): if weights[item_index] <= capacities[bag_index]: # if the item can fit into the current bag, distribute it items_distributed += 1 item_index += 1 bag_index += 1 else: # move to the next bag since the current one cannot fit the item bag_index += 1 return items_distributed"},{"question":"from typing import List def process_transactions(balances: List[int], transactions: List[List[str]]) -> List[int]: Simulate a basic banking system by processing a list of transactions and returning the final account balances. Each operation is given as a list in one of the following formats: - \`[\\"Deposit\\", account, amount]\`: Deposit the specified \`amount\` of money into the \`account\`. - \`[\\"Withdraw\\", account, amount]\`: Withdraw the specified \`amount\` of money from the \`account\`, if possible. - \`[\\"Transfer\\", fromAccount, toAccount, amount]\`: Transfer the specified \`amount\` of money from \`fromAccount\` to \`toAccount\`, if possible. Args: balances (List[int]): Initial balances for the accounts. transactions (List[List[str]]): List of operations to be performed on the accounts. Returns: List[int]: Final state of the account balances. Example: >>> process_transactions([100, 200], [[\\"Deposit\\", 1, 50]]) [150, 200] >>> process_transactions([100, 200], [[\\"Withdraw\\", 2, 250]]) [100, 200] >>> transactions = [[\\"Deposit\\", 1, 50], [\\"Withdraw\\", 2, 100], [\\"Transfer\\", 1, 2, 30]] >>> process_transactions([100, 200], transactions) [120, 130] >>> process_transactions([], []) [] pass def test_deposit(): assert process_transactions([100, 200], [[\\"Deposit\\", 1, 50]]) == [150, 200] assert process_transactions([100, 200], [[\\"Deposit\\", 2, 100]]) == [100, 300] def test_withdraw(): assert process_transactions([100, 200], [[\\"Withdraw\\", 1, 50]]) == [50, 200] assert process_transactions([100, 200], [[\\"Withdraw\\", 2, 250]]) == [100, 200] def test_transfer(): assert process_transactions([100, 200], [[\\"Transfer\\", 1, 2, 50]]) == [50, 250] assert process_transactions([100, 200], [[\\"Transfer\\", 1, 2, 150]]) == [100, 200] def test_multiple_operations(): transactions = [ [\\"Deposit\\", 1, 50], [\\"Withdraw\\", 2, 100], [\\"Transfer\\", 1, 2, 30] ] assert process_transactions([100, 200], transactions) == [120, 130] def test_edge_cases(): transactions = [ [\\"Withdraw\\", 1, 150], # Insufficient funds, ignore [\\"Transfer\\", 1, 2, 100], # Transfer all funds from account 1 [\\"Deposit\\", 2, 50] ] assert process_transactions([100, 200], transactions) == [0, 350] def test_empty_balances_and_transactions(): assert process_transactions([],[]) == [] def test_no_transactions(): assert process_transactions([100, 200, 300], []) == [100, 200, 300]","solution":"from typing import List def process_transactions(balances: List[int], transactions: List[List[str]]) -> List[int]: for transaction in transactions: if transaction[0] == \\"Deposit\\": account, amount = transaction[1] - 1, transaction[2] balances[account] += amount elif transaction[0] == \\"Withdraw\\": account, amount = transaction[1] - 1, transaction[2] if balances[account] >= amount: balances[account] -= amount elif transaction[0] == \\"Transfer\\": from_account, to_account, amount = transaction[1] - 1, transaction[2] - 1, transaction[3] if balances[from_account] >= amount: balances[from_account] -= amount balances[to_account] += amount return balances"},{"question":"from typing import List def three_sum_unique_triplets(nums: List[int], target: int) -> int: Given an integer array nums and a target value, return the number of unique triplets (nums[i], nums[j], nums[k]) such that i, j, k are all distinct and nums[i] + nums[j] + nums[k] == target. >>> three_sum_unique_triplets([1, 2, -1, -2, 3, 1], 2) == 2 >>> three_sum_unique_triplets([1, 1, 1], 5) == 0 >>> three_sum_unique_triplets([1, 2, 3, 4, 5], 6) == 1 >>> three_sum_unique_triplets([1, 2, 3, 0, -1, -2], 1) == 3 >>> three_sum_unique_triplets([0, 0, 0, 0], 0) == 1 >>> three_sum_unique_triplets([-5, -4, -3, -2, -1], -10) == 2","solution":"def three_sum_unique_triplets(nums, target): Given an integer array nums and a target value, return the number of unique triplets (nums[i], nums[j], nums[k]) such that i, j, k are all distinct and nums[i] + nums[j] + nums[k] == target. nums.sort() triplets_set = set() n = len(nums) for i in range(n - 2): l, r = i + 1, n - 1 while l < r: triplet_sum = nums[i] + nums[l] + nums[r] if triplet_sum == target: triplets_set.add((nums[i], nums[l], nums[r])) l += 1 r -= 1 elif triplet_sum < target: l += 1 else: r -= 1 return len(triplets_set)"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Restores a string based on the given indices mapping. Parameters: s (str): The original string. indices (list[int]): A list of integers indicating the new positions of each character. Returns: str: The restored string. Example: >>> restore_string(\\"codeleet\\", [4,5,6,7,0,2,1,3]) 'leetcode' >>> restore_string(\\"a\\", [0]) 'a' >>> restore_string(\\"abcd\\", [3,2,1,0]) 'dcba' >>> restore_string(\\"art\\", [1,0,2]) 'rat' >>> restore_string(\\"hello\\", [0, 1, 2, 3, 4]) 'hello'","solution":"def restore_string(s, indices): Restores a string based on the given indices mapping. Parameters: s (str): The original string. indices (list[int]): A list of integers indicating the new positions of each character. Returns: str: The restored string. restored = [''] * len(s) for i, idx in enumerate(indices): restored[idx] = s[i] return ''.join(restored)"},{"question":"def singleNumber(nums): Returns the single integer that appears exactly once in a list where every other integer appears exactly three times. Parameters: nums (list): List of integers Returns: int: The single integer that appears exactly once pass # Unit tests def test_single_number_with_mixed_values(): assert singleNumber([2, 2, 3, 2]) == 3 def test_single_number_at_start(): assert singleNumber([4, 3, 3, 3]) == 4 def test_single_number_at_end(): assert singleNumber([2, 2, 2, 1]) == 1 def test_single_number_middle(): assert singleNumber([0, 1, 0, 1, 0, 1, 99]) == 99 def test_single_number_negative_values(): assert singleNumber([-2, -2, 1, -2]) == 1 def test_single_number_all_negative(): assert singleNumber([-3, -3, -3, -7]) == -7","solution":"def singleNumber(nums): Returns the single integer that appears exactly once in a list where every other integer appears exactly three times. Parameters: nums (list): List of integers Returns: int: The single integer that appears exactly once ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: TreeNode) -> List[int]: Returns the values of the nodes visible from the right side of the binary tree. >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> right_side_view(root) [1, 2, 3] >>> root = TreeNode(1, TreeNode(2, TreeNode(3), None), None) >>> right_side_view(root) [1, 2, 3] pass def test_single_node(): root = TreeNode(1) assert right_side_view(root) == [1] def test_right_skewed_tree(): root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) assert right_side_view(root) == [1, 2, 3] def test_left_skewed_tree(): root = TreeNode(1, TreeNode(2, TreeNode(3), None), None) assert right_side_view(root) == [1, 2, 3] def test_perfect_binary_tree(): root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) assert right_side_view(root) == [1, 3, 7] def test_mixed_binary_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) root.right.right = TreeNode(4) assert right_side_view(root) == [1, 3, 4] def test_empty_tree(): root = None assert right_side_view(root) == []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the values of the nodes visible from the right side of the binary tree. if not root: return [] result = [] queue = [(root, 0)] while queue: node, depth = queue.pop(0) if len(result) == depth: result.append(node.val) if node.right: queue.append((node.right, depth + 1)) if node.left: queue.append((node.left, depth + 1)) return result"},{"question":"MOD = 10**9 + 7 def num_distinct_subsequences(s: str) -> int: Returns the number of distinct subsequences that can be formed by replacing each '*' with any lowercase letter. The result is given modulo 10^9 + 7. :param s: Input string consisting of lowercase letters and '*' :return: Number of distinct subsequences modulo 10^9 + 7 >>> num_distinct_subsequences(\\"abc\\") 1 >>> num_distinct_subsequences(\\"a*b\\") 26 >>> num_distinct_subsequences(\\"a*b*\\") 676 >>> num_distinct_subsequences(\\"ab*c*d*\\") 17576 >>> num_distinct_subsequences(\\"****\\") 456976 >>> num_distinct_subsequences(\\"\\") 1 >>> num_distinct_subsequences(\\"**********\\") 141167095653376","solution":"MOD = 10**9 + 7 def num_distinct_subsequences(s): Returns the number of distinct subsequences that can be formed by replacing each '*' with any lowercase letter :param s: Input string :return: Number of distinct subsequences modulo 10^9 + 7 count_star = s.count('*') return pow(26, count_star, MOD)"},{"question":"from typing import List def interleave_strings(s1: str, s2: str) -> str: Returns a new string formed by interleaving the characters of s1 and s2 alternately. If one string is longer than the other, append the additional characters to the end of the interleaved string. >>> interleave_strings(\\"abc\\", \\"pqr\\") 'apbqcr' >>> interleave_strings(\\"ab\\", \\"pqrs\\") 'apbqrs' >>> interleave_strings(\\"\\", \\"pqrs\\") 'pqrs' >>> interleave_strings(\\"abc\\", \\"\\") 'abc' >>> interleave_strings(\\"\\", \\"\\") ''","solution":"def interleave_strings(s1, s2): Returns a new string formed by interleaving the characters of s1 and s2 alternately. If one string is longer than the other, append the additional characters to the end of the interleaved string. interleaved = [] len_s1, len_s2 = len(s1), len(s2) max_len = max(len_s1, len_s2) for i in range(max_len): if i < len_s1: interleaved.append(s1[i]) if i < len_s2: interleaved.append(s2[i]) return ''.join(interleaved)"},{"question":"def count_unique_paths(n: int, edges: List[List[int]]) -> int: You are given a directed acyclic graph represented by an integer \`n\` (the number of nodes) and an array \`edges\` where \`edges[i] = [ui, vi]\` indicates that there is a directed edge from node \`ui\` to node \`vi\`. Your task is to find the number of unique paths from node \`0\` to node \`n-1\`. Since the number of paths can be very large, return the number of unique paths modulo \`10^9 + 7\`. If there is no path from \`0\` to \`n-1\`, return \`0\`. >>> count_unique_paths(2, []) == 0 >>> count_unique_paths(3, [[0, 1], [1, 2]]) == 1 >>> count_unique_paths(4, [[0, 1], [0, 2], [1, 3], [2, 3]]) == 2 >>> count_unique_paths(5, [[0, 1], [0, 2], [1, 3], [2, 3], [3, 4]]) == 2 >>> count_unique_paths(3, [[0, 1], [1, 2], [2, 0]]) == 0","solution":"def count_unique_paths(n, edges): MOD = 10**9 + 7 from collections import defaultdict, deque # Create graph and count in-degrees graph = defaultdict(list) in_degrees = [0] * n for u, v in edges: graph[u].append(v) in_degrees[v] += 1 # Topological order using Kahn's algorithm (BFS) queue = deque([i for i in range(n) if in_degrees[i] == 0]) top_order = [] while queue: node = queue.popleft() top_order.append(node) for neighbor in graph[node]: in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: queue.append(neighbor) if len(top_order) != n: return 0 # Graph is not a DAG # Initialize path count for each node path_count = [0] * n path_count[0] = 1 # Start from node 0 # Calculate number of paths using topological order for node in top_order: for neighbor in graph[node]: path_count[neighbor] = (path_count[neighbor] + path_count[node]) % MOD return path_count[n - 1]"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of any non-empty subarray of arr. >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-3]) -3 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([10, 20, 30, 40]) 100 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([-8, -3, -6, -2, -5, -4]) -2 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([4, -1, 2, 1]) 6 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([0, 0, 0, 0]) 0","solution":"def max_subarray_sum(arr): Returns the maximum sum of any non-empty subarray of arr. if not arr: return 0 max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def remove_k_digits(num: str, k: int) -> str: Returns the smallest number possible after removing exactly k digits from the string num. >>> remove_k_digits(\\"1432219\\", 3) \\"1219\\" >>> remove_k_digits(\\"10200\\", 1) \\"200\\" >>> remove_k_digits(\\"10\\", 2) \\"0\\" >>> remove_k_digits(\\"1234567890\\", 9) \\"0\\" >>> remove_k_digits(\\"100002\\", 1) \\"2\\" >>> remove_k_digits(\\"9\\", 1) \\"0\\"","solution":"def remove_k_digits(num, k): Returns the smallest number possible after removing exactly k digits from the string num. if k == len(num): return \\"0\\" stack = [] for digit in num: while stack and k > 0 and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If k is still greater than 0 after the loop ends stack = stack[:-k] if k else stack # Removing leading zeros result = ''.join(stack).lstrip('0') return result if result else \\"0\\""},{"question":"class StockTrader: def __init__(self, prices): self.prices = prices def getMaxProfit(self): Returns the maximum profit that can be achieved. If no profit is possible, returns 0.","solution":"class StockTrader: def __init__(self, prices): self.prices = prices def getMaxProfit(self): Returns the maximum profit that can be achieved. If no profit is possible, returns 0. if not self.prices or len(self.prices) < 2: return 0 min_price = self.prices[0] max_profit = 0 for price in self.prices[1:]: profit = price - min_price max_profit = max(max_profit, profit) min_price = min(min_price, price) return max_profit"},{"question":"def first_missing_positive(arr: List[int]) -> int: This function finds the smallest positive integer that is missing from the array. >>> first_missing_positive([1, 2, 3, 4, 5]) 6 >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([-1, -2, -3, -4, -5]) 1 >>> first_missing_positive([]) 1 >>> first_missing_positive([10, 9, 8, 7, 6, 5, 4, 3, 2, -1, 1]) 11 >>> first_missing_positive([3, 4, -1, 1, 1, 2]) 5 >>> first_missing_positive([1]) 2 >>> first_missing_positive([-1]) 1 >>> first_missing_positive([2, 1, 3, 5]) 4","solution":"def first_missing_positive(arr): This function finds the smallest positive integer that is missing from the array. The function operates in O(n) time and O(1) extra space. :param arr: List[int] - A list of integers. :return: int - The smallest positive integer that is missing from the array. n = len(arr) for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"def find_pivot_index(lst: List[int]) -> int: Returns the index of the pivot element in the original list. The pivot is defined as the middle element after sorting the list. If there are multiple pivots, returns the smallest index. If the list is empty, returns -1. >>> find_pivot_index([3, 1, 2]) == 2 >>> find_pivot_index([4, 1, 2, 3]) == 3 >>> find_pivot_index([1, 2, 2, 3]) == 1 >>> find_pivot_index([6, 3, 1, 4, 5, 2]) == 3 >>> find_pivot_index([10]) == 0 >>> find_pivot_index([]) == -1 >>> find_pivot_index([-10, -3, -5, -8, -1]) == 2 >>> find_pivot_index([7, 5, 5, 7, 3]) == 1","solution":"def find_pivot_index(lst): Returns the index of the pivot element in the original list. The pivot is defined as the middle element after sorting the list. If there are multiple pivots, returns the smallest index. If the list is empty, returns -1. if not lst: return -1 sorted_lst = sorted(lst) pivot = sorted_lst[len(sorted_lst) // 2] for i, num in enumerate(lst): if num == pivot: return i return -1"},{"question":"def canReach(arr: List[int], start: int) -> bool: Determines if it's possible to reach any index with value 0 in the array. :param arr: List of integers :param start: Starting index :return: Boolean indicating if it's possible to reach an index with value 0 >>> canReach([4, 2, 3, 0, 3, 1, 2], 5) == True >>> canReach([4, 2, 3, 0, 3, 1, 2], 0) == True >>> canReach([3, 0, 2, 1, 2], 2) == False >>> canReach([1, 2, 3], 1) == False >>> canReach([1, 1, 1, 1], 2) == False >>> canReach([0], 0) == True >>> canReach([1, 0, 1, 1, 1], 4) == True >>> canReach([2, 3, 0, 1, 4], 2) == True","solution":"def canReach(arr, start): Determines if it's possible to reach any index with value 0 in the array. :param arr: List of integers :param start: Starting index :return: Boolean indicating if it's possible to reach an index with value 0 n = len(arr) visited = [False] * n stack = [start] while stack: index = stack.pop() if arr[index] == 0: return True if visited[index]: continue visited[index] = True # Calculate new positions pos_forward = index + arr[index] pos_backward = index - arr[index] # If within bounds and not visited, add to stack if 0 <= pos_forward < n and not visited[pos_forward]: stack.append(pos_forward) if 0 <= pos_backward < n and not visited[pos_backward]: stack.append(pos_backward) return False"},{"question":"def profit_spans(sales: List[int]) -> List[int]: Returns an array where the i-th element is the profit span for day \`i\`. >>> profit_spans([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> profit_spans([5, 4, 3, 2, 1]) [1, 1, 1, 1, 1] >>> profit_spans([3, 1, 4, 3, 5, 6]) [1, 1, 2, 1, 2, 3] >>> profit_spans([7]) [1] >>> profit_spans([1, 2]) [1, 2] >>> profit_spans([2, 1]) [1, 1] >>> profit_spans([1, 3, 2, 4, 2, 5]) [1, 2, 1, 2, 1, 2]","solution":"def profit_spans(sales): Returns an array where the i-th element is the profit span for day \`i\`. n = len(sales) spans = [1] * n # Initialize all spans to 1 for i in range(1, n): if sales[i] >= sales[i - 1]: spans[i] = spans[i - 1] + 1 else: spans[i] = 1 return spans"},{"question":"from typing import List def min_flights(flights: List[List[int]], k: int) -> int: Returns the minimum number of flights required to travel from city 0 to city k, or -1 if it is not possible within the given limit. pass # Unit Tests def test_min_flights_direct_flight(): assert min_flights([[0, 1], [1, 2], [0, 2]], 2) == 1 def test_min_flights_multiple_flights(): assert min_flights([[0, 1], [1, 2], [2, 3], [3, 4]], 4) == 4 def test_min_flights_no_possible_route(): assert min_flights([[0, 1], [1, 2]], 3) == -1 def test_min_flights_same_city(): assert min_flights([[0, 0], [1, 1]], 0) == 0 def test_min_flights_large_number(): assert min_flights([[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10]], 10) == 10","solution":"from collections import deque, defaultdict def min_flights(flights, k): Returns the minimum number of flights required to travel from city 0 to city k, or -1 if it is not possible within the given limit. # Create a graph from the flights information graph = defaultdict(list) for departure, arrival in flights: graph[departure].append(arrival) # Use BFS to find the shortest path queue = deque([(0, 0)]) # (current city, number of flights taken) visited = set((0, 0)) while queue: current_city, num_flights = queue.popleft() # If we have reached the destination city if current_city == k: return num_flights # Add the neighbors to the queue for neighbor in graph[current_city]: if (neighbor, num_flights + 1) not in visited: queue.append((neighbor, num_flights + 1)) visited.add((neighbor, num_flights + 1)) # If there is no way to reach city k return -1"},{"question":"def min_remove_to_make_valid(s: str) -> str: Removes the minimal number of brackets to make the string valid. Returns the longest possible valid string. >>> min_remove_to_make_valid(\\"(abc)de(f)\\") == \\"(abc)de(f)\\" >>> min_remove_to_make_valid(\\"a)b(c)d\\") == \\"ab(c)d\\" >>> min_remove_to_make_valid(\\"))((\\") == \\"\\" >>> min_remove_to_make_valid(\\"lee(t(c)o)de)\\") == \\"lee(t(c)o)de\\" >>> min_remove_to_make_valid(\\"\\") == \\"\\" >>> min_remove_to_make_valid(\\"abcdef\\") == \\"abcdef\\" >>> min_remove_to_make_valid(\\"(((\\") == \\"\\" >>> min_remove_to_make_valid(\\")))\\") == \\"\\" pass","solution":"def min_remove_to_make_valid(s: str) -> str: Removes the minimal number of brackets to make the string valid. Returns the longest possible valid string. stack = [] s = list(s) for i, char in enumerate(s): if char == '(': stack.append(i) elif char == ')': if stack: stack.pop() else: s[i] = '' while stack: s[stack.pop()] = '' return ''.join(s)"},{"question":"from typing import List def max_events_attend(events: List[List[int]], k: int) -> int: Determine the maximum number of non-overlapping events you can attend given a constraint. >>> max_events_attend([[1, 2], [2, 3], [3, 4]], 2) 2 >>> max_events_attend([[1, 2], [3, 4], [5, 6]], 3) 3 >>> max_events_attend([[1, 2], [3, 4], [5, 6]], 5) 3 >>> max_events_attend([[1, 2], [2, 3], [2, 3], [3, 4]], 2) 2 >>> max_events_attend([[1, 2]], 1) 1 >>> max_events_attend([], 3) 0 >>> max_events_attend([[1, 3], [2, 5], [4, 6]], 2) 2 def test_max_events_attend_example(): events = [[1, 2], [2, 3], [3, 4]] k = 2 assert max_events_attend(events, k) == 2 def test_max_events_attend_all_non_overlapping(): events = [[1, 2], [3, 4], [5, 6]] k = 3 assert max_events_attend(events, k) == 3 def test_max_events_attend_k_more_than_events(): events = [[1, 2], [3, 4], [5, 6]] k = 5 assert max_events_attend(events, k) == 3 def test_max_events_attend_some_overlapping(): events = [[1, 2], [2, 3], [2, 3], [3, 4]] k = 2 assert max_events_attend(events, k) == 2 def test_max_events_attend_single_event(): events = [[1, 2]] k = 1 assert max_events_attend(events, k) == 1 def test_max_events_attend_no_events(): events = [] k = 3 assert max_events_attend(events, k) == 0 def test_max_events_attend_overlapping_events(): events = [[1, 3], [2, 5], [4, 6]] k = 2 assert max_events_attend(events, k) == 2","solution":"from typing import List def max_events_attend(events: List[List[int]], k: int) -> int: # Step 1: Sort events by their end times events.sort(key=lambda x: x[1]) # Step 2: Initialize variables attended_events = 0 last_end_time = -1 # Step 3: Iterate over sorted events for start, end in events: if start > last_end_time: attended_events += 1 last_end_time = end if attended_events == k: break return attended_events"},{"question":"from typing import List def maxWaterTrapped(height: List[int]) -> int: Calculates the maximum amount of water that can be trapped between buildings. Parameters: height (List[int]): List of integers representing the heights of the buildings. Returns: int: The maximum amount of water that can be trapped. Example: >>> maxWaterTrapped([4,2,0,3,2,5]) 9 >>> maxWaterTrapped([1,1,1,1]) 0 >>> maxWaterTrapped([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> maxWaterTrapped([2,1,0,1,3]) 4 >>> maxWaterTrapped([]) 0 >>> maxWaterTrapped([5]) 0 >>> maxWaterTrapped([5, 4]) 0 def test_maxWaterTrapped_case1(): assert maxWaterTrapped([4,2,0,3,2,5]) == 9 def test_maxWaterTrapped_case2(): assert maxWaterTrapped([1,1,1,1]) == 0 def test_maxWaterTrapped_case3(): assert maxWaterTrapped([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 def test_maxWaterTrapped_case4(): assert maxWaterTrapped([2,1,0,1,3]) == 4 def test_maxWaterTrapped_empty(): assert maxWaterTrapped([]) == 0 def test_maxWaterTrapped_single_building(): assert maxWaterTrapped([5]) == 0 def test_maxWaterTrapped_two_buildings(): assert maxWaterTrapped([5, 4]) == 0","solution":"from typing import List def maxWaterTrapped(height: List[int]) -> int: Calculates the maximum amount of water that can be trapped between buildings. Parameters: height (List[int]): List of integers representing the heights of the buildings. Returns: int: The maximum amount of water that can be trapped. if not height: return 0 left, right = 0, len(height) - 1 max_water = 0 left_max, right_max = height[left], height[right] while left < right: if height[left] <= height[right]: left += 1 left_max = max(left_max, height[left]) max_water += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) max_water += right_max - height[right] return max_water"},{"question":"from typing import List def trapRainWater(heightMap: List[List[int]]) -> int: Given a 2D grid of integers representing an elevation map, return the total amount of water that can be trapped after raining. Water can only be trapped in the valleys of the grid. >>> trapRainWater([]) 0 >>> trapRainWater([ ... [1, 1, 1, 1], ... [1, 2, 2, 1], ... [1, 2, 2, 1], ... [1, 1, 1, 1] ... ]) 0 >>> trapRainWater([ ... [1, 4, 3, 1, 3, 2], ... [3, 2, 1, 3, 2, 4], ... [2, 3, 3, 2, 3, 1] ... ]) 4 >>> trapRainWater([ ... [12, 13, 1, 12], ... [13, 4, 13, 12], ... [13, 8, 10, 12], ... [12, 13, 12, 12], ... [13, 13, 13, 13] ... ]) 14 >>> trapRainWater([ ... [1, 1, 1, 1], ... [1, 0, 0, 1], ... [1, 0, 0, 1], ... [1, 1, 1, 1] ... ]) 4 pass","solution":"from heapq import heappush, heappop from typing import List def trapRainWater(heightMap: List[List[int]]) -> int: if not heightMap or not heightMap[0]: return 0 n, m = len(heightMap), len(heightMap[0]) if n <= 2 or m <= 2: return 0 visited = [[False] * m for _ in range(n)] heap = [] # Push all border cells into heap and mark them as visited for i in range(n): heappush(heap, (heightMap[i][0], i, 0)) heappush(heap, (heightMap[i][m-1], i, m-1)) visited[i][0] = True visited[i][m-1] = True for j in range(m): heappush(heap, (heightMap[0][j], 0, j)) heappush(heap, (heightMap[n-1][j], n-1, j)) visited[0][j] = True visited[n-1][j] = True water_trapped = 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while heap: height, x, y = heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - heightMap[nx][ny]) heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) return water_trapped"},{"question":"def swap_heights(heights: List[int], indices: List[List[int]]) -> List[int]: Swaps the heights of students at the given positions in the indices array. :param heights: List[int] - List of students' heights. :param indices: List[List[int]] - List of pairs of indices to swap. :return: List[int] - List of students' heights after swaps. >>> swap_heights([1, 2, 3], [[0, 2]]) == [3, 2, 1] >>> swap_heights([1, 2, 3, 4], [[0, 2], [1, 3]]) == [3, 4, 1, 2] >>> swap_heights([1, 2, 3], []) == [1, 2, 3] >>> swap_heights([4, 3, 2, 1], [[0, 1], [1, 0]]) == [4, 3, 2, 1] >>> swap_heights([1, 4, 2, 3], [[1, 3], [1, 3]]) == [1, 4, 2, 3]","solution":"def swap_heights(heights, indices): Swaps the heights of students at the given positions in the indices array. :param heights: List[int] - List of students' heights. :param indices: List[List[int]] - List of pairs of indices to swap. :return: List[int] - List of students' heights after swaps. for i, j in indices: heights[i], heights[j] = heights[j], heights[i] return heights"},{"question":"def longest_subarray_with_one_removal(arr: List[int]) -> int: Given an array of integers \`arr\`, return the length of the longest contiguous subarray that contains only \`ones\` after performing at most one removal of a single element from the array. >>> longest_subarray_with_one_removal([1,1,0,1,1,1]) == 5 >>> longest_subarray_with_one_removal([0,0,0,0]) == 0 >>> longest_subarray_with_one_removal([1,1,1,1]) == 3 >>> longest_subarray_with_one_removal([1,1,0,1,1]) == 4 >>> longest_subarray_with_one_removal([0,1,1,1,1,0]) == 4 >>> longest_subarray_with_one_removal([1,1,1,0]) == 3 >>> longest_subarray_with_one_removal([]) == 0 >>> longest_subarray_with_one_removal([0]) == 0 >>> longest_subarray_with_one_removal([1]) == 0 >>> longest_subarray_with_one_removal([1,0,1,0,1]) == 2 >>> longest_subarray_with_one_removal([1,1,1,0,0,1]) == 3","solution":"def longest_subarray_with_one_removal(arr): Finds the length of the longest contiguous subarray that contains only ones after performing at most one removal of a single element from the array. max_length = 0 zero_count = 0 left = 0 for right in range(len(arr)): if arr[right] == 0: zero_count += 1 while zero_count > 1: if arr[left] == 0: zero_count -= 1 left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"from typing import List def minPipelineCost(depths: List[int]) -> int: Returns the minimum cost to connect all the wells in the village with the given depths. >>> minPipelineCost([10]) 0 >>> minPipelineCost([10, 20]) 10 >>> minPipelineCost([10, 20, 30]) 20 >>> minPipelineCost([30, 10, 20]) 20 >>> minPipelineCost([1, 3, 6, 10, 15]) 14 >>> minPipelineCost([4, 10, 8, 12, 2]) 10 >>> minPipelineCost([1, 1, 1, 1]) 0 >>> minPipelineCost([1, 2, 2, 3, 3]) 2 >>> minPipelineCost([]) 0","solution":"def minPipelineCost(depths): Returns the minimum cost to connect all the wells in the village. if not depths: return 0 depths.sort() min_cost = 0 for i in range(1, len(depths)): min_cost += depths[i] - depths[i-1] return min_cost"},{"question":"def max_subarray_sum(arr: List[int]) -> int: This function finds the maximum sum of any non-empty subarray. :param arr: List of integers :return: Integer, the maximum sum of any non-empty subarray. >>> max_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) 9 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([2, 3, -2, 1]) 5 >>> max_subarray_sum([100, -90, 200, -300, 400, -50]) 400","solution":"def max_subarray_sum(arr): This function finds the maximum sum of any non-empty subarray. :param arr: List of integers :return: Integer, the maximum sum of any non-empty subarray if not arr: # edge case: if arr is empty return 0 max_sum = arr[0] current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List from math import gcd from functools import reduce def gcd_of_list(lst: List[int]) -> int: return reduce(gcd, lst) def max_sum_subsequence_with_gcd(nums: List[int], k: int) -> int: Return the maximum possible sum of a non-empty subsequence of nums such that the greatest common divisor (GCD) of the elements of the subsequence is exactly k. >>> max_sum_subsequence_with_gcd([2, 4, 8, 16], 2) 30 >>> max_sum_subsequence_with_gcd([12, 15, 18, 30, 27], 3) 102 >>> max_sum_subsequence_with_gcd([2, 3, 5, 7, 11], 1) 28 >>> max_sum_subsequence_with_gcd([6, 9, 15], 3) 30 >>> max_sum_subsequence_with_gcd([1, 2, 5, 10], 10) 10 >>> max_sum_subsequence_with_gcd([1, 2, 5], 10) 0 >>> max_sum_subsequence_with_gcd([10], 10) 10","solution":"from math import gcd from functools import reduce def gcd_of_list(lst): return reduce(gcd, lst) def max_sum_subsequence_with_gcd(nums, k): valid_nums = [num for num in nums if num % k == 0] max_sum = 0 def helper(temp, index): nonlocal max_sum if temp and gcd_of_list(temp) == k: max_sum = max(max_sum, sum(temp)) for i in range(index, len(valid_nums)): helper(temp + [valid_nums[i]], i + 1) helper([], 0) return max_sum # Example usage: # nums = [2, 4, 8, 16] # k = 2 # max_sum_subsequence_with_gcd(nums, k)"},{"question":"def max_consecutive_days(costs: List[int], budget: int) -> int: Determines the maximum number of consecutive days the campaign can run without the total cost exceeding the budget. >>> max_consecutive_days([1, 2, 3, 4, 5], 9) == 3 >>> max_consecutive_days([1, 1, 1, 1, 1], 5) == 5 >>> max_consecutive_days([10, 20, 30], 15) == 1 >>> max_consecutive_days([10, 20, 30], 5) == 0 >>> max_consecutive_days([1, 2, 1, 1, 2, 1, 2, 1], 5) == 4 >>> max_consecutive_days([2, 2, 2, 2], 4) == 2","solution":"def max_consecutive_days(costs, budget): Determines the maximum number of consecutive days the campaign can run without the total cost exceeding the budget. Parameters: costs (List[int]): A list of integers representing the cost of the marketing campaign for each day. budget (int): An integer representing the budget. Returns: int: The maximum number of consecutive days. n = len(costs) max_days = 0 current_sum = 0 start = 0 for end in range(n): current_sum += costs[end] while current_sum > budget: current_sum -= costs[start] start += 1 max_days = max(max_days, end - start + 1) return max_days"},{"question":"def increment_integer(arr: List[int]) -> List[int]: Increment the integer represented by the array of digits by one. >>> increment_integer([1, 2, 3]) == [1, 2, 4] >>> increment_integer([1, 2, 9]) == [1, 3, 0] >>> increment_integer([9, 9, 9]) == [1, 0, 0, 0] >>> increment_integer([0]) == [1] >>> increment_integer([9]) == [1, 0] >>> increment_integer([1, 9, 9, 9]) == [2, 0, 0, 0] >>> increment_integer([2, 3, 4, 5, 6, 7, 8, 9, 9]) == [2, 3, 4, 5, 6, 7, 9, 0, 0]","solution":"def increment_integer(arr): Increment the integer represented by the array of digits by one. n = len(arr) # Start from the last digit of the array for i in reversed(range(n)): if arr[i] < 9: arr[i] += 1 return arr arr[i] = 0 # If all digits are 9, we need to add an extra 1 at the beginning return [1] + [0] * n"},{"question":"def coin_change(coins: List[int], amount: int) -> int: Given a list of coin denominations and an amount, compute the minimum number of coins needed to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. >>> coin_change([1, 2, 5], 11) 3 >>> coin_change([1, 2, 5], 3) 2 >>> coin_change([2], 3) -1 >>> coin_change([3, 5], 7) -1 >>> coin_change([1], 0) 0 >>> coin_change([2, 5], 0) 0 >>> coin_change([1, 2, 5], 100) 20 >>> coin_change([1], 5) 5 >>> coin_change([5], 5) 1 >>> coin_change([10], 15) -1","solution":"def coin_change(coins, amount): Given a list of coin denominations and an amount, compute the minimum number of coins needed to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. # Initialize a list to store the minimum number of coins needed for each amount from 0 to amount. dp = [float('inf')] * (amount + 1) dp[0] = 0 # Iterate over all amounts from 1 to 'amount'. for i in range(1, amount + 1): # Check each coin. for coin in coins: if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) # Return -1 if dp[amount] is still infinity, meaning it's impossible to form that amount. # Otherwise, return the minimum number of coins needed for the given amount. return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def is_even_path(grid: List[List[int]]) -> bool: Determine if there is a path from the top-left cell (0, 0) to the bottom-right cell (m-1, n-1) such that the sum of the values along the path is even. >>> is_even_path([[2]]) True >>> is_even_path([[1]]) False >>> is_even_path([[2, 4, 6], [8, 10, 12], [14, 16, 18]]) True >>> is_even_path([[1, 4, 6], [8, 2, 1], [14, 16, 18]]) False >>> is_even_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) False >>> is_even_path([[2, 2, 2], [2, 2, 2], [2, 2, 2]]) True >>> is_even_path([[2, 3, 2], [2, 4, 6], [8, 6, 8]]) True >>> is_even_path([[1, 2], [2, 1]]) False","solution":"def is_even_path(grid): m, n = len(grid), len(grid[0]) dp = [[False]*n for _ in range(m)] dp[0][0] = (grid[0][0] % 2 == 0) for i in range(m): for j in range(n): if i > 0: dp[i][j] |= (dp[i-1][j] and (grid[i][j] % 2 == 0)) if j > 0: dp[i][j] |= (dp[i][j-1] and (grid[i][j] % 2 == 0)) return dp[m-1][n-1]"},{"question":"def maximize_sum_after_k_operations(arr: List[int], k: int) -> int: Perform exactly k operations to maximize the sum of the array. In one operation, you can choose any element of the array and define its new value as -arr[i]. Return the maximum possible sum of the array after exactly k operations. >>> maximize_sum_after_k_operations([-2, 0, 5, -1, 2], 2) 10 >>> maximize_sum_after_k_operations([-2, -3, -4, -1, -5], 3) 9 >>> maximize_sum_after_k_operations([2, -1, 3], 5) 6 >>> maximize_sum_after_k_operations([1, 2, 3, 4], 3) 10 >>> maximize_sum_after_k_operations([-10], 1) 10 >>> maximize_sum_after_k_operations([10], 3) 10","solution":"def maximize_sum_after_k_operations(arr, k): Performs exactly k operations to maximize the sum of the array. In one operation, we can choose any element and define its new value as -arr[i]. Returns the maximum possible sum of the array after exactly k operations. arr.sort() # Sort the array to make operations on smallest values first for i in range(k): if arr[i % len(arr)] < 0: arr[i % len(arr)] = -arr[i % len(arr)] # Perform operation on the smallest value else: break # If the smallest value is non-negative, no further operations are useful return sum(arr)"},{"question":"def max_k_length_subsequence(arr: List[int], k: int) -> int: Given an array of integers \`arr\`, find the maximum \`k\`-length subsequence with the largest sum. A subsequence is a sequence derived by deleting some or no elements from the array without changing the order of the remaining elements. Return the largest possible sum of such a subsequence. >>> max_k_length_subsequence([3, -1, 4, 1, 2], 3) == 9 >>> max_k_length_subsequence([1, 2, 3, 4, 5], 2) == 9 >>> max_k_length_subsequence([-1, -2, -3, -4, -5], 3) == -6 >>> max_k_length_subsequence([0, 0, 0, 0, 0], 3) == 0 >>> max_k_length_subsequence([], 3) == 0 >>> max_k_length_subsequence([1, 2, 3], 0) == 0 >>> max_k_length_subsequence([1, 2, 3], 5) == 0 >>> max_k_length_subsequence([3, -1, 4, 1, 2], 5) == 9","solution":"def max_k_length_subsequence(arr, k): Returns the maximum sum of a k-length subsequence with the largest sum. if k <= 0 or not arr or k > len(arr): return 0 # Sort the array in descending order and take the sum of the first k elements sorted_arr = sorted(arr, reverse=True) return sum(sorted_arr[:k])"},{"question":"def min_unique_integers(colors: str) -> int: Returns the minimum number of unique integers needed such that no two adjacent bulbs have consecutive integers. >>> min_unique_integers(\\"RGBGR\\") 3 >>> min_unique_integers(\\"R\\") 1 >>> min_unique_integers(\\"G\\") 1 >>> min_unique_integers(\\"B\\") 1 >>> min_unique_integers(\\"RG\\") 3 >>> min_unique_integers(\\"GR\\") 3 >>> min_unique_integers(\\"RB\\") 3 >>> min_unique_integers(\\"BR\\") 3 >>> min_unique_integers(\\"GB\\") 3 >>> min_unique_integers(\\"BG\\") 3 >>> min_unique_integers(\\"RGB\\") 3 >>> min_unique_integers(\\"BRG\\") 3 >>> min_unique_integers(\\"GRB\\") 3 >>> min_unique_integers(\\"RRGBBGRR\\") 3 >>> min_unique_integers(\\"GRGRGRGR\\") 3 >>> min_unique_integers(\\"BGBGBGBG\\") 3","solution":"def min_unique_integers(colors): Returns the minimum number of unique integers needed such that no two adjacent bulbs have consecutive integers. n = len(colors) # If the string length is 1, we only need 1 unique integer if n == 1: return 1 # At minimum, we will need three unique integers since we have three colors return 3"},{"question":"def rearrange_numbers(nums): Rearrange the elements of nums such that all negative numbers appear before all positive numbers. Numbers within the same category should maintain their relative order. Modify nums in place and return nothing. >>> nums = [-1, 2, -3, 4, 5, -6] >>> rearrange_numbers(nums) >>> nums [-1, -3, -6, 2, 4, 5]","solution":"def rearrange_numbers(nums): This function rearranges the elements of nums such that all negative numbers appear before all positive numbers. Numbers within the same category should maintain their relative order. This function modifies nums in place and returns nothing. negative = [] positive = [] for num in nums: if num < 0: negative.append(num) else: positive.append(num) nums[:] = negative + positive"},{"question":"def min_flips_to_alternating(s: str) -> int: Given a binary string s, return the minimum number of flip operations needed to make the binary string alternating. A binary string is alternating if no two adjacent characters are the same. For example, the strings \\"0101\\" and \\"1010\\" are alternating, while \\"0110\\" and \\"1001\\" are not. >>> min_flips_to_alternating(\\"0000\\") == 2 >>> min_flips_to_alternating(\\"010101\\") == 0 >>> min_flips_to_alternating(\\"1111\\") == 2 >>> min_flips_to_alternating(\\"1100\\") == 2 >>> min_flips_to_alternating(\\"10101\\") == 0 >>> min_flips_to_alternating(\\"1001\\") == 2 >>> min_flips_to_alternating(\\"0100\\") == 1 >>> min_flips_to_alternating(\\"01000011\\") == 3","solution":"def min_flips_to_alternating(s): Given a binary string s, return the minimum number of flip operations needed to make s alternating. n = len(s) # Define target patterns alt1 = \\"\\".join([\\"0\\" if i % 2 == 0 else \\"1\\" for i in range(n)]) alt2 = \\"\\".join([\\"1\\" if i % 2 == 0 else \\"0\\" for i in range(n)]) # Calculate flips for both patterns flips1 = sum(s[i] != alt1[i] for i in range(n)) flips2 = sum(s[i] != alt2[i] for i in range(n)) # Return the minimum flips needed return min(flips1, flips2)"},{"question":"def alternate_arrays(arr1, arr2): Creates a new sequence by alternating the elements of arr1 and arr2. If one array is longer, append the remaining elements to the end. >>> alternate_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] >>> alternate_arrays([1, 3, 5, 7], [2, 4, 6]) == [1, 2, 3, 4, 5, 6, 7] >>> alternate_arrays([1, 3, 5], [2, 4, 6, 8]) == [1, 2, 3, 4, 5, 6, 8] >>> alternate_arrays([1, 3], [2, 4, 6, 8, 10]) == [1, 2, 3, 4, 6, 8, 10] >>> alternate_arrays([], [2, 4, 6]) == [2, 4, 6] >>> alternate_arrays([1, 3, 5], []) == [1, 3, 5] >>> alternate_arrays([], []) == [] >>> alternate_arrays([1], [2, 4, 6, 8]) == [1, 2, 4, 6, 8]","solution":"def alternate_arrays(arr1, arr2): Creates a new sequence by alternating the elements of arr1 and arr2. If one array is longer, append the remaining elements to the end. result = [] i, j = 0, 0 len1, len2 = len(arr1), len(arr2) while i < len1 and j < len2: result.append(arr1[i]) result.append(arr2[j]) i += 1 j += 1 while i < len1: result.append(arr1[i]) i += 1 while j < len2: result.append(arr2[j]) j += 1 return result"},{"question":"def kthLargestSum(arr, k): Returns the kth largest sum of a subarray. Args: arr (List[int]): An integer array. k (int): An integer representing which largest subarray sum to find. Returns: int: The kth largest sum of a subarray. Examples: >>> kthLargestSum([1, 2, 3, 4], 2) 9 >>> kthLargestSum([1, 2, 3, 4], 1) 10 >>> kthLargestSum([1, -2, 3, -4], 2) 2 >>> kthLargestSum([-1, -2, -3, -4], 1) -1 >>> kthLargestSum([5], 1) 5 >>> kthLargestSum([2, 1, 3], 4) 3 >>> kthLargestSum([2, 1, 3], 6) 1","solution":"import heapq def kthLargestSum(arr, k): Returns the kth largest sum of a subarray. n = len(arr) # Create a min heap to store the k largest sums min_heap = [] # Traverse through the array and compute subarray sums for start in range(n): subarray_sum = 0 for end in range(start, n): subarray_sum += arr[end] # If the heap has less than k elements, push the current sum if len(min_heap) < k: heapq.heappush(min_heap, subarray_sum) # If the heap is full and current sum is larger than the smallest sum in the heap, replace the smallest sum elif subarray_sum > min_heap[0]: heapq.heapreplace(min_heap, subarray_sum) # The top element of the heap is the kth largest sum return min_heap[0]"},{"question":"from typing import List def max_path_sum_mod_k(grid: List[List[int]], k: int) -> int: You are given a matrix represented by a two-dimensional array \`grid\` of size \`m x n\`, where each cell contains a non-negative integer. You are also given an integer \`k\`. Starting from the top-left cell, you need to find a path to the bottom-right cell where you can only move **right** or **down**. A path's \\"sum modulo \`k\`\\" is defined as the sum of all integers along the path taken, modulo \`k\`. Return the maximum possible \\"sum modulo \`k\`\\" achievable by any path from the top-left cell to the bottom-right cell. >>> grid = [[1, 3, 2], [4, 2, 5], [7, 1, 6]] >>> k = 5 >>> max_path_sum_mod_k(grid, k) 4 >>> grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> k = 10 >>> max_path_sum_mod_k(grid, k) 9 >>> grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> k = 1 >>> max_path_sum_mod_k(grid, k) 0 >>> grid = [[5]] >>> k = 5 >>> max_path_sum_mod_k(grid, k) 0 >>> grid = [[9, 9, 9], [9, 9, 9]] >>> k = 9 >>> max_path_sum_mod_k(grid, k) 0","solution":"def max_path_sum_mod_k(grid, k): m, n = len(grid), len(grid[0]) dp = [[None] * n for _ in range(m)] dp[0][0] = [grid[0][0] % k] for i in range(m): for j in range(n): if i == 0 and j == 0: continue current_values = set() if i > 0: for value in dp[i - 1][j]: current_values.add((value + grid[i][j]) % k) if j > 0: for value in dp[i][j - 1]: current_values.add((value + grid[i][j]) % k) dp[i][j] = list(current_values) return max(dp[-1][-1])"},{"question":"from collections import Counter def longest_palindrome(s: str) -> int: Returns the length of the longest palindrome that can be built with the letters of \`s\`. >>> longest_palindrome('abccccdd') 7 >>> longest_palindrome('a') 1 >>> longest_palindrome('ab') 1 >>> longest_palindrome('abbbbcccd') 7 >>> longest_palindrome('aaaaa') 5 >>> longest_palindrome('') 0 >>> longest_palindrome('aabbcc') 6","solution":"from collections import Counter def longest_palindrome(s): Returns the length of the longest palindrome that can be built with the letters of \`s\`. char_counts = Counter(s) length = 0 odd_found = False for count in char_counts.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"def max_product_of_three(arr: List[int]) -> int: Returns the maximum product of any three distinct elements in the array. If the array has fewer than three elements, return 0. >>> max_product_of_three([1, 2, 3]) 6 >>> max_product_of_three([1, 2, 3, 4]) 24 >>> max_product_of_three([-10, -10, 5, 2]) 500 >>> max_product_of_three([-1, -2, -3, -4]) -6 >>> max_product_of_three([-1, -2, 3, 4]) 8 >>> max_product_of_three([1, 2]) 0 >>> max_product_of_three([3]) 0 >>> max_product_of_three([]) 0 >>> max_product_of_three([1000, 999, 998, 2]) 997002000","solution":"import heapq def max_product_of_three(arr): Returns the maximum product of any three distinct elements in the array. If the array has fewer than three elements, return 0. n = len(arr) if n < 3: return 0 # Find the three largest numbers and the two smallest numbers three_largest = heapq.nlargest(3, arr) two_smallest = heapq.nsmallest(2, arr) # The maximum product of three numbers can be one of these two: # 1. Product of the three largest numbers # 2. Product of the two smallest numbers and the largest number (in case we have two large negative numbers) max_product = max(three_largest[0] * three_largest[1] * three_largest[2], two_smallest[0] * two_smallest[1] * three_largest[0]) return max_product"},{"question":"from typing import List import pytest def minPathCost(grid: List[List[int]]) -> int: Returns the minimum cost path from the top-left corner to the bottom-right corner of the grid. You can only move to the right or down from any cell in the grid. >>> minPathCost([[5]]) 5 >>> minPathCost([[1, 2, 5]]) 8 >>> minPathCost([[1], [2], [5]]) 8 >>> minPathCost([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> minPathCost([]) 0 >>> minPathCost([[]]) 0 pass def test_minPathCost_single_cell(): assert minPathCost([[5]]) == 5 def test_minPathCost_single_row(): assert minPathCost([[1, 2, 5]]) == 8 def test_minPathCost_single_column(): assert minPathCost([[1], [2], [5]]) == 8 def test_minPathCost_multiple_paths(): assert minPathCost([ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) == 7 def test_minPathCost_large_grid(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert minPathCost(grid) == 21 def test_minPathCost_empty_grid(): assert minPathCost([]) == 0 def test_minPathCost_empty_row(): assert minPathCost([[]]) == 0","solution":"from typing import List def minPathCost(grid: List[List[int]]) -> int: Returns the minimum cost path from the top-left corner to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"def find_cheapest_price(n: int, flights: List[List[int]], start: int, k: int) -> List[int]: Returns the minimum cost to reach each city from city \`start\` with at most \`k\` stops. >>> find_cheapest_price(3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 1) [0, 100, 200] >>> find_cheapest_price(3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 0) [0, 100, 500] >>> find_cheapest_price(2, [[0, 1, 1000]], 0, 1) [0, 1000] >>> find_cheapest_price(3, [], 0, 1) [0, -1, -1] >>> find_cheapest_price(3, [[0, 1, 100], [1, 2, 200], [0, 2, 500]], 0, 2) [0, 100, 300] >>> find_cheapest_price(3, [[0, 1, 100], [1, 2, 100]], 0, 0) [0, 100, -1]","solution":"from heapq import heappop, heappush import sys def find_cheapest_price(n, flights, start, k): Returns the minimum cost to reach each city from city \`start\` with at most \`k\` stops. # Building the graph graph = {i: [] for i in range(n)} for src, dst, cost in flights: graph[src].append((dst, cost)) # Priority Queue to keep track of (cost, current_node, stops) pq = [(0, start, 0)] # Costs array to store minimum costs min_costs = [float('inf')] * n min_costs[start] = 0 while pq: curr_cost, curr_node, stops = heappop(pq) if stops > k: continue for neighbor, price in graph[curr_node]: new_cost = curr_cost + price if new_cost < min_costs[neighbor]: min_costs[neighbor] = new_cost heappush(pq, (new_cost, neighbor, stops + 1)) return [cost if cost != float('inf') else -1 for cost in min_costs]"},{"question":"import heapq from typing import List def get_skyline(buildings: List[List[int]]) -> List[List[int]]: Returns the skyline formed by 'buildings'. The skyline is a list of triplets [left, height, right]. >>> get_skyline([[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]]) [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]] >>> get_skyline([[1, 5, 11]]) [[1, 11], [5, 0]] >>> get_skyline([[1, 5, 11], [6, 10, 13]]) [[1, 11], [5, 0], [6, 13], [10, 0]] >>> get_skyline([[0, 2, 3], [2, 5, 3]]) [[0, 3], [5, 0]] >>> get_skyline([[2, 4, 5], [2, 4, 7], [2, 4, 6], [5, 7, 5], [5, 7, 8]]) [[2, 7], [4, 0], [5, 8], [7, 0]]","solution":"import heapq def get_skyline(buildings): Returns the skyline formed by 'buildings'. The skyline is a list of triplets [left, height, right]. # Define a list to hold all events (start and end of buildings) events = [] for left, right, height in buildings: events.append((left, -height, right)) # Building starting event events.append((right, 0, 0)) # Building ending event # Sort events by position; start events before end events if they are the same position events.sort() # Result array to hold the skyline result = [] # Max-Heap to keep track of building heights and their end points heap = [(0, float('inf'))] # (height, end) for x, h, r in events: # Remove the buildings from the heap that are ended before current x position while heap[0][1] <= x: heapq.heappop(heap) if h != 0: heapq.heappush(heap, (h, r)) max_height = -heap[0][0] # If the highest building changes, this is a critical point if not result or result[-1][1] != max_height: result.append([x, max_height]) return result"},{"question":"def shuffle_string(s: str, indices: List[int]) -> str: Shuffles the string s according to the indices array. Parameters: s (str): The input string to be shuffled. indices (list of int): The list of indices that represents the new positions of the characters. Returns: str: The shuffled string. >>> shuffle_string(\\"abc\\", [0, 1, 2]) \\"abc\\" >>> shuffle_string(\\"abc\\", [2, 1, 0]) \\"cba\\" >>> shuffle_string(\\"\\", []) \\"\\" >>> shuffle_string(\\"a\\", [0]) \\"a\\" >>> shuffle_string(\\"aiohn\\", [3, 1, 4, 2, 0]) \\"nihao\\" >>> shuffle_string(\\"aaaa\\", [3, 0, 1, 2]) \\"aaaa\\" >>> shuffle_string(\\"abcdefghijklmnopqrstuvwxyz\\", [25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) \\"zyxwvutsrqponmlkjihgfedcba\\"","solution":"def shuffle_string(s, indices): Shuffles the string s according to the indices array. Parameters: s (str): The input string to be shuffled. indices (list of int): The list of indices that represents the new positions of the characters. Returns: str: The shuffled string. shuffled = [''] * len(s) for i, index in enumerate(indices): shuffled[index] = s[i] return ''.join(shuffled)"},{"question":"def rob(nums: List[int]) -> int: Returns the maximum amount of money that can be robbed without triggering alarms from adjacent houses. Parameters: nums (list): A list of integers representing the amount of money in each house. Returns: int: Maximum amount of money that can be robbed. Examples: >>> rob([]) 0 >>> rob([5]) 5 >>> rob([2, 3]) 3 >>> rob([3, 2]) 3 >>> rob([1, 2, 3, 1]) 4 >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([5, 1, 1, 5]) 10 >>> rob([10, 1, 1, 1]) 11 >>> rob([1, 100, 1, 100, 1]) 200","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without triggering alarms from adjacent houses. Parameters: nums (list): A list of integers representing the amount of money in each house. Returns: int: Maximum amount of money that can be robbed. if not nums: return 0 elif len(nums) == 1: return nums[0] # Dynamic programming approach n = len(nums) dp = [0] * n dp[0] = nums[0] if n > 1: dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i - 1], nums[i] + dp[i - 2]) return dp[-1]"},{"question":"def trap(height): Computes the maximum amount of trapped rainwater. Args: height (List[int]): A list of non-negative integers representing the elevation map. Returns: int: The maximum amount of water that can be trapped. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([]) 0 >>> trap([0, 1, 2, 3, 4, 5]) 0 >>> trap([5, 4, 3, 2, 1, 0]) 0 >>> trap([3, 0, 2]) 2 >>> trap([0, 2, 0, 2, 0, 2]) 4 >>> trap([1, 1, 1, 1, 1]) 0","solution":"def trap(height): Computes the maximum amount of trapped rainwater. Args: height (List[int]): A list of non-negative integers representing the elevation map. Returns: int: The maximum amount of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"def max_increasing_buildings(heights: List[int], k: int) -> int: Return the maximum number of buildings that can be retained such that their heights form a strictly increasing sequence by removing at most k buildings. >>> max_increasing_buildings([1, 2, 3, 4], 0) 4 >>> max_increasing_buildings([3, 5, 7, 13], 3) 4 >>> max_increasing_buildings([3, 4, 1, 5, 6, 2], 2) 4","solution":"def max_increasing_buildings(heights, k): Returns the maximum number of buildings that can be retained such that their heights form a strictly increasing sequence by removing at most k buildings. from bisect import bisect_left n = len(heights) dp = [1] * n # Compute lengths of the longest increasing subsequences ending at each position using dynamic programming for i in range(n): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) max_len_array = max(dp) max_kept_buildings = 0 for i in range(n): retained_buildings = [heights[i]] current_removal = 0 for j in range(i + 1, n): if heights[j] > retained_buildings[-1]: retained_buildings.append(heights[j]) else: current_removal += 1 if current_removal > k: break if current_removal <= k: max_kept_buildings = max(max_kept_buildings, len(retained_buildings)) return max_kept_buildings"},{"question":"def diagonal_traversal(matrix: List[List[int]]) -> List[int]: Returns the elements of the matrix in diagonal traversal order. Args: matrix (list of list of int): A 2D list representing the matrix. Returns: list of int: A list containing the elements of the matrix in diagonal traversal order. >>> diagonal_traversal([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [7, 4, 8, 1, 5, 9, 2, 6, 3] >>> diagonal_traversal([ ... [1, 2], ... [3, 4] ... ]) == [3, 1, 4, 2] >>> diagonal_traversal([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9], ... [10, 11, 12] ... ]) == [10, 7, 11, 4, 8, 12, 1, 5, 9, 2, 6, 3] >>> diagonal_traversal([]) == [] >>> diagonal_traversal([[1, 2, 3]]) == [1, 2, 3] >>> diagonal_traversal([ ... [1], ... [2], ... [3] ... ]) == [3, 2, 1]","solution":"def diagonal_traversal(matrix): Returns the elements of the matrix in diagonal traversal order. Args: matrix (list of list of int): A 2D list representing the matrix. Returns: list of int: A list containing the elements of the matrix in diagonal traversal order. if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] for d in range(m + n - 1): if d < m: row = m - 1 - d col = 0 else: row = 0 col = d - m + 1 diagonal = [] while row < m and col < n: diagonal.append(matrix[row][col]) row += 1 col += 1 result.extend(diagonal) return result"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4, 5], 6) [1, 3] >>> two_sum([3, 1, 4, 2], 6) [2, 3] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([-3, 4, 3, 90], 0) [0, 2]","solution":"def two_sum(nums, target): Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. :param nums: List[int] :param target: int :return: List[int] num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index"},{"question":"def contains_multiple(nums: List[int]) -> bool: Determine if there exist two distinct indices i and j such that nums[i] is a multiple of nums[j]. :param nums: List[int] - a list of positive integers :return: bool - True if there exist the indices i and j, otherwise False >>> contains_multiple([6, 3, 5, 10]) == True # 6 is a multiple of 3 >>> contains_multiple([4, 5, 7, 11]) == False # No multiples exist >>> contains_multiple([6]) == False # Only one element, no pairs exist >>> contains_multiple([8, 2]) == True # 8 is a multiple of 2 >>> contains_multiple([9, 2]) == False # 9 is not a multiple of 2","solution":"def contains_multiple(nums): Determine if there exist two distinct indices i and j such that nums[i] is a multiple of nums[j]. :param nums: List[int] - a list of positive integers :return: bool - True if there exist the indices i and j, otherwise False length = len(nums) for i in range(length): for j in range(length): if i != j and nums[i] % nums[j] == 0: return True return False"},{"question":"class StringStack: A class to perform stack-based string manipulation. >>> stack = StringStack() >>> stack.push('a') >>> stack.push('b') >>> stack.push('c') >>> stack.getCurrentState() 'abc' >>> stack.reverse() 'cba' >>> stack.pop() 'c' >>> stack.pop() 'b' >>> stack.pop() 'a' >>> stack.pop() '0' >>> stack.getCurrentState() '' >>> stack.reverse() '' def __init__(self): pass def push(self, c): Pushes the character \`c\` onto the stack. pass def pop(self): Removes and returns the character on the top of the stack. If the stack is empty, returns \`'0'\`. pass def getCurrentState(self): Returns the current string representation of the stack with all characters in the order they were pushed. pass def reverse(self): Reverses the characters in the stack and returns the reversed string without modifying the current state of the stack. pass","solution":"class StringStack: def __init__(self): self.stack = [] def push(self, c): Pushes the character \`c\` onto the stack. self.stack.append(c) def pop(self): Removes and returns the character on the top of the stack. If the stack is empty, returns \`'0'\`. if self.stack: return self.stack.pop() return '0' def getCurrentState(self): Returns the current string representation of the stack with all characters in the order they were pushed. return ''.join(self.stack) def reverse(self): Reverses the characters in the stack and returns the reversed string without modifying the current state of the stack. return ''.join(reversed(self.stack))"},{"question":"class Book: Represents a book in a library. def __init__(self, bookId, title): self.bookId = bookId self.title = title class Library: Handles the operations of adding a book, removing a book, and searching for a book. Methods: addBook(self, bookId: int, title: str) -> None: Adds a book with the given \`bookId\` and \`title\` to the library. removeBook(self, bookId: int) -> None: Removes the book with the given \`bookId\` from the library. searchBook(self, title: str) -> List[int]: Returns a list of \`bookId\`s for books in the library whose title contains the given \`title\` string as a substring, in ascending order. If no such book is found, returns an empty list. >>> library = Library() >>> library.addBook(1, \\"Python Programming\\") >>> library.searchBook(\\"Python\\") [1] >>> library.removeBook(1) >>> library.searchBook(\\"Python\\") []","solution":"class Book: def __init__(self, bookId, title): self.bookId = bookId self.title = title class Library: def __init__(self): self.books = {} def addBook(self, bookId, title): if bookId not in self.books: self.books[bookId] = Book(bookId, title) def removeBook(self, bookId): if bookId in self.books: del self.books[bookId] def searchBook(self, title): result = [bookId for bookId, book in self.books.items() if title in book.title] return sorted(result)"},{"question":"from typing import List def can_see_buildings(heights: List[int]) -> List[int]: Returns the indices of buildings that can be seen from the rooftop of the building at index 0. >>> can_see_buildings([4, 3, 2, 5, 6]) [3, 4] >>> can_see_buildings([4, 1, 2, 3, 5, 5, 6]) [4, 6] >>> can_see_buildings([4]) [] >>> can_see_buildings([4, 4, 4, 4]) [] >>> can_see_buildings([2, 3, 4, 5]) [1, 2, 3] pass","solution":"def can_see_buildings(heights): Returns the indices of buildings that can be seen from the rooftop of the building at index 0. parameters: heights (List[int]): Height of buildings returns: List[int]: Indices of buildings that can be seen visible_buildings = [] max_height = heights[0] for i in range(1, len(heights)): if heights[i] > max_height: visible_buildings.append(i) max_height = heights[i] return visible_buildings"},{"question":"from collections import defaultdict def arrange_characters_together(s: str) -> str: Arrange the characters of the string such that all occurrences of each character appear together. Parameters: - s (str): Input string consisting of lowercase letters Returns: - str: A string where all occurrences of each character appear together >>> arrange_characters_together(\\"a\\") 'a' >>> arrange_characters_together(\\"aaaa\\") 'aaaa' >>> arrange_characters_together(\\"aabb\\") 'aabb' or 'bbaa' >>> arrange_characters_together(\\"aaabbcccc\\") 'aaa' or 'bbb' or 'cccc' >>> arrange_characters_together(\\"abc\\") any permutation of 'abc' >>> arrange_characters_together(\\"\\") ''","solution":"from collections import defaultdict def arrange_characters_together(s): Arrange the characters of the string such that all occurrences of each character appear together. Parameters: - s (str): Input string consisting of lowercase letters Returns: - str: A string where all occurrences of each character appear together char_count = defaultdict(int) for char in s: char_count[char] += 1 result = [] for char, count in char_count.items(): result.append(char * count) return ''.join(result)"},{"question":"def can_transform(s1: str, s2: str) -> bool: Determines if s1 can be transformed into s2 by performing any number of adjacent swaps. Args: s1 (str): the first string. s2 (str): the second string. Returns: bool: True if s1 can be transformed into s2, otherwise False. >>> can_transform(\\"abc\\", \\"abc\\") True >>> can_transform(\\"abc\\", \\"cba\\") True >>> can_transform(\\"abcd\\", \\"bdca\\") True >>> can_transform(\\"aabbcc\\", \\"bbaacc\\") True >>> can_transform(\\"aabbcc\\", \\"abcabc\\") True >>> can_transform(\\"abc\\", \\"def\\") False >>> can_transform(\\"abc\\", \\"abcd\\") False >>> can_transform(\\"\\", \\"\\") True >>> can_transform(\\"a\\", \\"a\\") True >>> can_transform(\\"a\\", \\"b\\") False >>> can_transform(\\"abc\\", \\"ab\\") False >>> can_transform(\\"abcd\\", \\"abc\\") False","solution":"def can_transform(s1, s2): Determines if s1 can be transformed into s2 by performing any number of adjacent swaps. Args: s1 (str): the first string. s2 (str): the second string. Returns: bool: True if s1 can be transformed into s2, otherwise False. return sorted(s1) == sorted(s2)"},{"question":"from typing import Optional, List class TreeNode: def __init__(self, id: int, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.id = id self.left = left self.right = right def find_path_to_employee(root: TreeNode, employee_id: int) -> List[int]: Given the root of the tree and the employee_id, returns a list of ids representing the path from the root (CEO) to the specified employee. If the employee is not found within the company tree, return an empty list. >>> employee5 = TreeNode(5) >>> employee4 = TreeNode(4) >>> employee3 = TreeNode(3, employee4, employee5) >>> employee2 = TreeNode(2) >>> ceo = TreeNode(1, employee2, employee3) >>> find_path_to_employee(ceo, 4) [1, 3, 4] >>> find_path_to_employee(ceo, 5) [1, 3, 5] >>> find_path_to_employee(ceo, 2) [1, 2] >>> find_path_to_employee(ceo, 6) [] >>> find_path_to_employee(ceo, 1) [1] >>> find_path_to_employee(None, 1) []","solution":"from typing import Optional, List class TreeNode: def __init__(self, id: int, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.id = id self.left = left self.right = right def find_path_to_employee(root: TreeNode, employee_id: int) -> List[int]: def find_path(node: TreeNode, employee_id: int, path: List[int]) -> bool: if node is None: return False path.append(node.id) if node.id == employee_id: return True if (find_path(node.left, employee_id, path) or find_path(node.right, employee_id, path)): return True path.pop() return False path = [] if find_path(root, employee_id, path): return path else: return []"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root: TreeNode, k: int) -> int: Perform in-order traversal and return the k-th smallest element in the BST. >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.left.right = TreeNode(2) >>> kth_smallest(root, 1) 1 >>> kth_smallest(root, 2) 2 >>> values = [1, 2, 3, 4, 5] >>> def build_bst(values): ... if not values: ... return None ... mid = len(values) // 2 ... node = TreeNode(values[mid]) ... node.left = build_bst(values[:mid]) ... node.right = build_bst(values[mid + 1:]) ... return node >>> root = build_bst(values) >>> kth_smallest(root, 3) 3","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Perform in-order traversal and return the k-th smallest element in the BST. def in_order_traversal(node): if not node: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) in_order_list = in_order_traversal(root) return in_order_list[k-1]"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Calculate the largest rectangle area possible in a histogram given by \`heights\`. >>> largest_rectangle_area([1]) 1 >>> largest_rectangle_area([2, 1]) 2 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([3, 3, 3, 3, 3]) 15 >>> largest_rectangle_area([2, 4, 2, 1, 10, 6, 10, 10, 10]) 30 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([0, 0, 0, 0]) 0 pass","solution":"def largest_rectangle_area(heights): Function to calculate the largest rectangle area in a histogram. stack = [] max_area = 0 heights.append(0) # Append a zero to handle the end boundaries for i, h in enumerate(heights): while stack and heights[stack[-1]] >= h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) heights.pop() # Restore the original heights array return max_area"},{"question":"def find_peak_element(nums: List[int]) -> int: Finds any peak element's index in the list \`nums\`. A peak element is defined as an element that is strictly greater than its neighbors. :param nums: List[int] - list of integers :return: int - index of any one peak element","solution":"def find_peak_element(nums): Finds any peak element's index in the list \`nums\`. A peak element is defined as an element that is strictly greater than its neighbors. :param nums: List[int] - list of integers :return: int - index of any one peak element left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] < nums[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"def min_moves_to_sort(nums: List[int], k: int) -> int: Calculate the minimum number of moves required to sort the array in non-decreasing order where each move consists of a person swapping their position with an adjacent person. Args: nums (List[int]): Array of integers, where nums[i] represents the position of the i-th person in a line. k (int): Maximum distance a person can move from their original position. Returns: int: Minimum number of moves required to sort the array. >>> min_moves_to_sort([1, 2, 3, 4], 1) 0 >>> min_moves_to_sort([4, 3, 2, 1], 1) 6 >>> min_moves_to_sort([3, 1, 2, 4, 5], 1) 2 >>> min_moves_to_sort([3, 1, 2, 4, 5], 2) 2 >>> min_moves_to_sort([4, 3, 1, 2], 2) 5 >>> min_moves_to_sort([1], 0) 0 >>> min_moves_to_sort([], 0) 0","solution":"def count_inversions_and_sort(nums): if len(nums) < 2: return nums, 0 mid = len(nums) // 2 left, left_inversions = count_inversions_and_sort(nums[:mid]) right, right_inversions = count_inversions_and_sort(nums[mid:]) merged, split_inversions = merge_and_count(left, right) total_inversions = left_inversions + right_inversions + split_inversions return merged, total_inversions def merge_and_count(left, right): merged = [] inversions = 0 i = 0 j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 inversions += len(left) - i merged.extend(left[i:]) merged.extend(right[j:]) return merged, inversions def min_moves_to_sort(nums, k): # We just find the number of inversions here _, inversions = count_inversions_and_sort(nums) return inversions"},{"question":"def number_of_steps(n: int) -> int: Given a non-negative integer n, return the number of steps required to reduce n to zero. In one step, if n is odd, subtract 1; if n is even, divide by 2. >>> number_of_steps(0) 0 >>> number_of_steps(1) 1 >>> number_of_steps(2) 2 >>> number_of_steps(123) 12 >>> number_of_steps(16) 5 >>> number_of_steps(32) 6 >>> number_of_steps(64) 7 >>> number_of_steps(3) 3 >>> number_of_steps(7) 5","solution":"def number_of_steps(n): Returns the number of steps required to reduce n to zero. In one step, if n is odd, subtract 1; if n is even, divide by 2. steps = 0 while n > 0: if n % 2 == 0: n //= 2 else: n -= 1 steps += 1 return steps"},{"question":"def rearrange_list(nums, k): Rearranges the list such that the smallest k integers are at the beginning, and the rest of the integers are at the end. The order within the parts is preserved. :param nums: List of integers to be rearranged. :param k: Number of smallest integers to place at the beginning. :return: Rearranged list of integers.","solution":"def rearrange_list(nums, k): Rearranges the list such that the smallest k integers are at the beginning, and the rest of the integers are at the end. The order within the parts is preserved. :param nums: List of integers to be rearranged. :param k: Number of smallest integers to place at the beginning. :return: Rearranged list of integers. if k >= len(nums): return sorted(nums) sorted_nums = sorted(nums) smallest_k = sorted_nums[:k] remaining = sorted_nums[k:] result = smallest_k + remaining return result"},{"question":"class Customer: def __init__(self, thrillTolerance): self.thrillTolerance = thrillTolerance def getMaxRides(self, thrill): Returns the maximum number of rides the customer can enjoy without exceeding their thrill tolerance. Args: thrill (list of int): List of thrill levels for each ride. Returns: int: Maximum number of rides the customer can take. >>> customer = Customer(10) >>> customer.getMaxRides([2, 3, 5]) 3 >>> customer = Customer(6) >>> customer.getMaxRides([2, 3, 5]) 2 >>> customer = Customer(6) >>> customer.getMaxRides([2, 2, 2]) 3","solution":"class Customer: def __init__(self, thrillTolerance): self.thrillTolerance = thrillTolerance def getMaxRides(self, thrill): Returns the maximum number of rides the customer can enjoy without exceeding their thrill tolerance. Args: thrill (list of int): List of thrill levels for each ride. Returns: int: Maximum number of rides the customer can take. total_thrill = 0 rides_count = 0 for ride_thrill in thrill: if total_thrill + ride_thrill <= self.thrillTolerance: total_thrill += ride_thrill rides_count += 1 else: break return rides_count"},{"question":"def can_form_string(s: str, words: List[str]) -> bool: Determine if it is possible to form the string \`s\` by concatenating words from the \`words\` array in any order. Each word in the \`words\` array can be used multiple times. >>> can_form_string(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> can_form_string(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> can_form_string(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> can_form_string(\\"aaaaaaa\\", [\\"a\\", \\"aa\\"]) True >>> can_form_string(\\"a\\", [\\"a\\"]) True >>> can_form_string(\\"a\\", [\\"b\\"]) False >>> can_form_string(\\"helloworld\\", [\\"hello\\", \\"world\\", \\"hell\\", \\"oworld\\"]) True >>> can_form_string(\\"\\", [\\"a\\", \\"b\\"]) True >>> can_form_string(\\"cannotbeformed\\", [\\"can\\", \\"not\\", \\"be\\", \\"form\\"]) False","solution":"def can_form_string(s, words): Determine if it is possible to form the string \`s\` by concatenating words from the \`words\` array in any order. Each word in the \`words\` array can be used multiple times. from collections import Counter, deque def can_construct(s, word_dict): queue = deque([s]) while queue: current = queue.popleft() if current == \\"\\": return True for word in words: if current.startswith(word): next_state = current[len(word):] if next_state not in word_dict: queue.append(next_state) word_dict[next_state] = True return False word_dict = {} return can_construct(s, word_dict)"},{"question":"def smallestNumber(nums: List[int]) -> str: Returns the smallest possible number formed by arranging the integers in the array \`nums\`. >>> smallestNumber([3, 30, 34, 5, 9]) \\"3033459\\" >>> smallestNumber([10, 2]) \\"102\\" >>> smallestNumber([0, 0]) \\"0\\" >>> smallestNumber([1]) \\"1\\" >>> smallestNumber([20, 1]) \\"120\\" >>> smallestNumber([9, 8, 7, 6, 5]) \\"56789\\" >>> smallestNumber([0, 0, 0]) \\"0\\" pass","solution":"from functools import cmp_to_key def smallestNumber(nums): Returns the smallest possible number formed by arranging the integers in the array \`nums\`. def compare(a, b): if a + b < b + a: return -1 elif a + b > b + a: return 1 else: return 0 # Convert each number to a string str_nums = list(map(str, nums)) # Sort numbers based on their string comparison str_nums.sort(key=cmp_to_key(compare)) # Join the sorted numbers result = ''.join(str_nums) # Remove leading zeros return result if result[0] != '0' else '0'"},{"question":"def find_min_difference(weights): This function returns the minimized difference between the sums of two subsets of the given weights. >>> find_min_difference([1, 6, 11, 5]) 1 >>> find_min_difference([1, 2, 3, 4, 5]) 1 >>> find_min_difference([3, 1, 4, 2, 2]) 0 >>> find_min_difference([10, 20, 15, 5, 25]) 5 >>> find_min_difference([1]) 1 >>> find_min_difference([1, 1, 1, 1, 1, 1, 1, 1, 1]) 1 >>> find_min_difference([1, 2, 3, 9]) 3 >>> find_min_difference([1, 1, 1, 10]) 7 >>> find_min_difference([]) 0 >>> find_min_difference([0]) 0 >>> find_min_difference([0, 0, 0, 0]) 0","solution":"def find_min_difference(weights): This function returns the minimized difference between the sums of two subsets of the given weights. total_sum = sum(weights) n = len(weights) target = total_sum // 2 # dp[i] will be True if a sum i can be formed with the subset of weights dp = [False] * (target + 1) dp[0] = True # Update the dp array with weights for weight in weights: for j in range(target, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] for i in range(target, -1, -1): if dp[i]: return abs(total_sum - 2 * i)"},{"question":"def time_to_reach_highest_authority(manager: List[int]) -> int: Returns the maximum time it will take for any employee's message to reach the highest authority. >>> time_to_reach_highest_authority([1, 2, 3, -1]) 3 >>> time_to_reach_highest_authority([-1]) 0 >>> time_to_reach_highest_authority([-1, -1, -1, -1]) 0 >>> time_to_reach_highest_authority([1, 2, 3, 4, -1]) 4 >>> time_to_reach_highest_authority([-1, 0, 0, 1, 1, 2, 2]) 2 pass","solution":"def time_to_reach_highest_authority(manager): Returns the maximum time it will take for any employee's message to reach the highest authority. n = len(manager) memo = [-1] * n # memo[i] will store the time to reach the highest authority from employee i def dfs(emp): if manager[emp] == -1: # if employee has no manager return 0 if memo[emp] != -1: # if already computed return memo[emp] memo[emp] = 1 + dfs(manager[emp]) return memo[emp] max_time = 0 for emp in range(n): max_time = max(max_time, dfs(emp)) return max_time"},{"question":"def blocked_skyscrapers(heights): Returns an array of the number of skyscrapers blocked by each respective skyscraper in the heights array. >>> blocked_skyscrapers([3, 1, 4, 2]) [1, 0, 1, 0] >>> blocked_skyscrapers([2, 2, 2, 2]) [3, 2, 1, 0] >>> blocked_skyscrapers([1, 2, 3, 4]) [0, 0, 0, 0] >>> blocked_skyscrapers([4, 3, 2, 1]) [3, 2, 1, 0] >>> blocked_skyscrapers([5]) [0] >>> blocked_skyscrapers([]) [] >>> blocked_skyscrapers([10, 1, 1, 1, 20, 2, 2]) [3, 2, 1, 0, 2, 1, 0] >>> blocked_skyscrapers([1, 3, 2, 5, 4, 8]) [0, 1, 0, 1, 0, 0]","solution":"def blocked_skyscrapers(heights): Returns an array of the number of skyscrapers blocked by each respective skyscraper in the heights array. n = len(heights) result = [0] * n for i in range(n): count = 0 for j in range(i + 1, n): if heights[j] <= heights[i]: count += 1 else: break result[i] = count return result"},{"question":"def climbStairs(n: int) -> int: Returns the number of ways to climb a staircase of n steps, where each time you can either climb 1 or 2 steps. >>> climbStairs(0) 1 >>> climbStairs(1) 1 >>> climbStairs(2) 2 >>> climbStairs(3) 3 >>> climbStairs(4) 5 >>> climbStairs(5) 8","solution":"def climbStairs(n): Returns the number of ways to climb a staircase of n steps, where each time you can either climb 1 or 2 steps. if n <= 1: return 1 dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for i in range(2, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]"},{"question":"def largestIsland(grid): Finds the size of the largest island in the grid. An island is a group of 1s connected vertically or horizontally. Parameters: grid (list of list of int): 2D grid representing the map of land (1) and water (0) Returns: int: The size of the largest island pass def test_largestIsland_single_island(): grid = [[1, 0, 0, 1], [1, 1, 0, 0], [0, 0, 1, 1], [1, 0, 1, 1]] assert largestIsland(grid) == 4 def test_largestIsland_multiple_islands(): grid = [[1, 1, 0, 0], [0, 1, 0, 1], [1, 0, 0, 1], [1, 1, 1, 0]] assert largestIsland(grid) == 4 def test_largestIsland_all_water(): grid = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]] assert largestIsland(grid) == 0 def test_largestIsland_all_land(): grid = [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]] assert largestIsland(grid) == 16 def test_largestIsland_single_cell_island(): grid = [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]] assert largestIsland(grid) == 1","solution":"def largestIsland(grid): Finds the size of the largest island in the grid. An island is a group of 1s connected vertically or horizontally. Parameters: grid (list of list of int): 2D grid representing the map of land (1) and water (0) Returns: int: The size of the largest island def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] != 1: return 0 grid[x][y] = -1 # Mark the cell as visited size = 1 size += dfs(x+1, y) size += dfs(x-1, y) size += dfs(x, y+1) size += dfs(x, y-1) return size max_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"def find_peak_element(arr: List[int]) -> int: Returns the index of any one peak element in the array. A peak element is an element that is greater than its neighbors. >>> find_peak_element([1]) == 0 >>> find_peak_element([3, 2, 1]) == 0 >>> find_peak_element([1, 2, 3]) == 2 >>> find_peak_element([1, 3, 2]) == 1 >>> result = find_peak_element([1, 3, 2, 5, 4]) >>> result in {1, 3} >>> find_peak_element([1, 1, 1, 1]) == -1 >>> arr = list(range(1000, 0, -1)) >>> find_peak_element(arr) == 0 >>> arr = list(range(1000)) >>> find_peak_element(arr) == 999 >>> find_peak_element([]) == -1","solution":"def find_peak_element(arr): Returns the index of any one peak element in the array. A peak element is an element that is greater than its neighbors. if not arr: return -1 # to handle empty input list n = len(arr) if n == 1: return 0 # the only element is the peak if arr[0] > arr[1]: return 0 if arr[n-1] > arr[n-2]: return n-1 for i in range(1, n-1): if arr[i] > arr[i-1] and arr[i] > arr[i+1]: return i return -1 # no peak found"},{"question":"from typing import List def can_reach_destination(operations: List[List[int]]) -> List[bool]: Determine if it is possible to perform \`d\` steps, starting from a point \`(ai, bi)\` in a grid, such that you land on a point \`(x, y)\` exactly after \`d\` steps. Args: operations (List[List[int]]): A list of operations, where each operation is represented by a list \`[ai, bi, x, y, d]\`. Returns: List[bool]: A boolean array \`results\` where \`results[i]\` is the result of the \`ith\` query \`operations[i]\`. >>> can_reach_destination([[0, 0, 2, 2, 4]]) [True] >>> can_reach_destination([[0, 0, 3, 1, 6]]) [True] >>> can_reach_destination([[0, 0, 5, 5, 5]]) [False] >>> can_reach_destination([[0, 0, 1, 1, 3]]) [False] >>> can_reach_destination([[0, 0, 1, 0, 1]]) [True] >>> can_reach_destination([[0, 0, 2, 2, 4], [0, 0, 3, 1, 6], [0, 0, 1, 1, 3], [0, 0, 1, 0, 1], [0, 0, 5, 5, 5]]) [True, True, False, True, False] results = [] for op in operations: ai, bi, x, y, d = op manhattan_distance = abs(x - ai) + abs(y - bi) if manhattan_distance <= d and (d - manhattan_distance) % 2 == 0: results.append(True) else: results.append(False) return results","solution":"def can_reach_destination(operations): results = [] for op in operations: ai, bi, x, y, d = op manhattan_distance = abs(x - ai) + abs(y - bi) if manhattan_distance <= d and (d - manhattan_distance) % 2 == 0: results.append(True) else: results.append(False) return results"},{"question":"def significant_updates(timestampsA, timestampsB, T): Returns the user with the maximum number of significant updates or \\"tie\\" if both have the same number. Args: timestampsA: List[int] - list of timestamps for user A. timestampsB: List[int] - list of timestamps for user B. T: int - threshold for a significant update. Returns: str - \\"A\\", \\"B\\", or \\"tie\\". from solution import significant_updates def test_significant_updates_A_wins(): assert significant_updates([1, 4, 10, 14], [2, 6, 7], 4) == \\"A\\" def test_significant_updates_B_wins(): assert significant_updates([1, 5, 6], [2, 10, 20], 8) == \\"B\\" def test_significant_updates_tie(): assert significant_updates([1, 9, 20], [2, 10, 21], 8) == \\"tie\\" def test_significant_updates_no_significant_A(): assert significant_updates([1, 2, 3], [1, 5, 10], 4) == \\"B\\" def test_significant_updates_no_significant_B(): assert significant_updates([1, 10, 20], [1, 2, 3], 9) == \\"A\\" def test_significant_updates_empty_lists(): assert significant_updates([], [], 5) == \\"tie\\" def test_significant_updates_A_empty_list(): assert significant_updates([], [1, 10, 20], 9) == \\"B\\" def test_significant_updates_B_empty_list(): assert significant_updates([1, 10, 20], [], 9) == \\"A\\"","solution":"def significant_updates(timestampsA, timestampsB, T): Returns the user with the maximum number of significant updates or \\"tie\\" if both have the same number. Args: timestampsA: List[int] - list of timestamps for user A. timestampsB: List[int] - list of timestamps for user B. T: int - threshold for a significant update. Returns: str - \\"A\\", \\"B\\", or \\"tie\\". def count_significant_updates(timestamps, T): if not timestamps: return 0 count = 0 for i in range(1, len(timestamps)): if timestamps[i] - timestamps[i-1] >= T: count += 1 return count significantA = count_significant_updates(timestampsA, T) significantB = count_significant_updates(timestampsB, T) if significantA > significantB: return \\"A\\" elif significantB > significantA: return \\"B\\" else: return \\"tie\\""},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_from_preorder(preorder): Constructs a binary search tree from its pre-order traversal list. >>> tree_to_preorder_list(bst_from_preorder([])) == [] >>> tree_to_preorder_list(bst_from_preorder([8])) == [8] >>> tree_to_preorder_list(bst_from_preorder([8, 5, 1, 7, 10, 12])) == [8, 5, 1, 7, 10, 12] >>> tree_to_preorder_list(bst_from_preorder([10, 9, 8, 7, 6])) == [10, 9, 8, 7, 6] >>> tree_to_preorder_list(bst_from_preorder([6, 7, 8, 9, 10])) == [6, 7, 8, 9, 10] >>> tree_to_preorder_list(bst_from_preorder([10, 5, 1, 7, 15, 12, 20])) == [10, 5, 1, 7, 15, 12, 20] pass def tree_to_preorder_list(root): Given a tree root, return its pre-order traversal as a list. >>> tree_to_preorder_list(None) == [] >>> tree_to_preorder_list(TreeNode(1)) == [1] pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_from_preorder(preorder): Constructs a binary search tree from its pre-order traversal list. if not preorder: return None root = TreeNode(preorder[0]) stack = [root] for value in preorder[1:]: node, child = None, TreeNode(value) while stack and stack[-1].val < value: node = stack.pop() if node: node.right = child else: stack[-1].left = child stack.append(child) return root def tree_to_preorder_list(root): Given a tree root, return its pre-order traversal as a list. if root is None: return [] return [root.val] + tree_to_preorder_list(root.left) + tree_to_preorder_list(root.right)"},{"question":"def longest_increasing_subsequence_length(s: str) -> int: Determine the length of the longest subsequence of s where each character is lexicographically larger than the previous character. Each character in the subsequence must be distinct. >>> longest_increasing_subsequence_length(\\"abcde\\") == 5 >>> longest_increasing_subsequence_length(\\"aabbcc\\") == 3 >>> longest_increasing_subsequence_length(\\"aaaaa\\") == 1 >>> longest_increasing_subsequence_length(\\"\\") == 0 >>> longest_increasing_subsequence_length(\\"abcdcba\\") == 4 >>> longest_increasing_subsequence_length(\\"abacabadabacaba\\") == 4","solution":"def longest_increasing_subsequence_length(s): Returns the length of the longest subsequence of s where each character is lexicographically larger than the previous character. The subsequence must have distinct characters. unique_characters = set(s) return len(unique_characters)"},{"question":"def split_array(nums: List[int], m: int) -> int: Divide the array into m non-overlapping subarrays such that the maximum sum of any subarray is minimized. :param nums: List[int] - The array of integers to be split :param m: int - The number of subarrays :return: int - The minimum possible value of the maximum sum of the subarrays >>> split_array([7, 2, 5, 10, 8], 2) 18 >>> split_array([1, 2, 3, 4, 5], 2) 9 >>> split_array([1, 4, 4], 3) 4 >>> split_array([10], 1) 10 >>> split_array([10, 20, 30, 40, 50], 5) 50 >>> split_array([5, 5, 5, 5], 2) 10","solution":"def split_array(nums, m): Divide the array into m non-overlapping subarrays such that the maximum sum of any subarray is minimized. :param nums: List[int] - The array of integers to be split :param m: int - The number of subarrays :return: int - The minimum possible value of the maximum sum of the subarrays def is_valid(nums, m, mid): count, current_sum = 1, 0 for num in nums: current_sum += num if current_sum > mid: count += 1 current_sum = num if count > m: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if is_valid(nums, m, mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Calculate the number of unique paths in a grid from the top-left to the bottom-right corner, where some cells are obstacles (denoted by 1). :param grid: List[List[int]] - A 2D grid with 0s and 1s (0 = empty, 1 = blocked) :return: int - Number of unique paths >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 1]]) 0 >>> unique_paths_with_obstacles([[0, 1, 0], [0, 0, 0]]) 1 >>> unique_paths_with_obstacles([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> unique_paths_with_obstacles([]) 0","solution":"def unique_paths_with_obstacles(grid): Calculate the number of unique paths in a grid from the top-left to the bottom-right corner, where some cells are obstacles (denoted by 1). :param grid: List[List[int]] - A 2D grid with 0s and 1s (0 = empty, 1 = blocked) :return: int - Number of unique paths if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[-1][-1]"},{"question":"from typing import List def minCostPath(costs: List[List[int]]) -> int: Return the minimum cost path from the top-left to the bottom-right corner of a grid. Parameters: costs (List[List[int]]): A 2D array representing the cost grid Returns: int: The minimum cost to traverse from the top-left cell to the bottom-right cell >>> minCostPath([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minCostPath([[5]]) 5 >>> minCostPath([[1, 2, 3, 4]]) 10 >>> minCostPath([[1], [2], [3], [4]]) 10 >>> minCostPath([[1, 3, 1], [1, 5, 1], [4, 2, 1], [3, 1, 1]]) 8 >>> minCostPath([]) 0 >>> minCostPath([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"def minCostPath(costs): if not costs or not costs[0]: return 0 m, n = len(costs), len(costs[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = costs[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + costs[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + costs[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + costs[i][j] return dp[m-1][n-1]"},{"question":"from typing import List def length_of_lis(arr: List[int]) -> int: Determine the length of the longest increasing subsequence in a list of integers. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([]) 0 >>> length_of_lis([10]) 1","solution":"from bisect import bisect_left def length_of_lis(arr): Returns the length of the longest increasing subsequence in the given list of integers. if not arr: return 0 lis = [] for num in arr: pos = bisect_left(lis, num) if pos < len(lis): lis[pos] = num else: lis.append(num) return len(lis)"},{"question":"from typing import List, Dict def top_k_departments_with_highest_avg_salary(records: List[Dict], k: int) -> List[str]: Returns the top k departments with the highest average salary. If two departments have the same average salary, their order should be determined by their lexicographical order. :param records: List of employee records, where each record is a dictionary :param k: Number of top departments to return :return: List of top k departments >>> records = [ ... {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"department\\": \\"Engineering\\", \\"salary\\": 120000}, ... {\\"name\\": \\"Bob\\", \\"age\\": 35, \\"department\\": \\"Human Resources\\", \\"salary\\": 90000}, ... {\\"name\\": \\"Charlie\\", \\"age\\": 25, \\"department\\": \\"Engineering\\", \\"salary\\": 110000}, ... {\\"name\\": \\"David\\", \\"age\\": 40, \\"department\\": \\"Marketing\\", \\"salary\\": 100000}, ... {\\"name\\": \\"Eve\\", \\"age\\": 29, \\"department\\": \\"Marketing\\", \\"salary\\": 105000}, ... ] >>> top_k_departments_with_highest_avg_salary(records, 2) [\\"Engineering\\", \\"Marketing\\"] >>> records = [ ... {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"department\\": \\"Engineering\\", \\"salary\\": 100000}, ... {\\"name\\": \\"Bob\\", \\"age\\": 35, \\"department\\": \\"Human Resources\\", \\"salary\\": 100000}, ... ] >>> top_k_departments_with_highest_avg_salary(records, 2) [\\"Engineering\\", \\"Human Resources\\"] >>> records = [] >>> top_k_departments_with_highest_avg_salary(records, 1) [] >>> records = [ ... {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"department\\": \\"Engineering\\", \\"salary\\": 120000}, ... {\\"name\\": \\"David\\", \\"age\\": 40, \\"department\\": \\"Marketing\\", \\"salary\\": 100000}, ... ] >>> top_k_departments_with_highest_avg_salary(records, 5) [\\"Engineering\\", \\"Marketing\\"]","solution":"def top_k_departments_with_highest_avg_salary(records, k): Returns the top k departments with the highest average salary. If two departments have the same average salary, their order should be determined by their lexicographical order. :param records: List of employee records, where each record is a dictionary :param k: Number of top departments to return :return: List of top k departments from collections import defaultdict import heapq # Dictionary to store the total salary and count of employees for each department department_salary_map = defaultdict(lambda: {'total_salary': 0, 'count': 0}) for record in records: department = record['department'] salary = record['salary'] department_salary_map[department]['total_salary'] += salary department_salary_map[department]['count'] += 1 # List to store (average_salary, department_name) tuples avg_salary_list = [] for department, salary_data in department_salary_map.items(): avg_salary = salary_data['total_salary'] / salary_data['count'] avg_salary_list.append((avg_salary, department)) # Sort the list by average salary (descending) and then by department name (ascending) avg_salary_list.sort(key=lambda x: (-x[0], x[1])) # Extract top k department names top_k_departments = [dept_name for _, dept_name in avg_salary_list[:k]] return top_k_departments"},{"question":"def count_contiguous_periods(packets): Count the number of contiguous periods where each period consists of packet counts that are all the same. >>> count_contiguous_periods([1, 1, 2, 2, 3, 3, 3]) 3 >>> count_contiguous_periods([1]) 1 >>> count_contiguous_periods([4, 4, 4, 4, 4]) 1 >>> count_contiguous_periods([1, 2, 1, 2, 1, 2]) 6 >>> count_contiguous_periods([]) 0 >>> count_contiguous_periods([3, 3, 3, 3, 2, 2, 2]) 2 >>> count_contiguous_periods([5, 5, 8, 8, 8, 1, 3, 3]) 4","solution":"def count_contiguous_periods(packets): if not packets: return 0 count = 1 current_packet = packets[0] for i in range(1, len(packets)): if packets[i] != packets[i - 1]: count += 1 return count"},{"question":"from typing import List def search_range(nums: List[int], target: int) -> List[int]: Returns the starting and ending index of the target in a sorted list. If the target is not found, returns [-1, -1]. :param nums: List[int] - sorted list of integers :param target: int - the target value to search for :return: List[int] - the starting and ending index of the target pass # Test cases def test_search_range(): assert search_range([5,7,7,8,8,10], 8) == [3, 4] assert search_range([5,7,7,8,8,10], 6) == [-1, -1] assert search_range([5,7,7,8,8,10], 5) == [0, 0] assert search_range([1, 3, 3, 5, 5, 5, 8], 5) == [3, 5] assert search_range([], 5) == [-1, -1] assert search_range([1], 1) == [0, 0] assert search_range([2, 2], 2) == [0, 1] assert search_range([1, 3, 3, 3, 3, 3, 3, 5, 5, 5, 7], 3) == [1, 6] def test_search_range_extremes(): assert search_range([1, 2, 3, 4, 4, 4, 5], 4) == [3, 5] assert search_range([1, 2, 3, 4, 5, 6, 7, 8, 9], 6) == [5, 5] assert search_range([1, 1, 1, 1, 1, 1, 1, 1], 1) == [0, 7] if __name__ == '__main__': test_search_range() test_search_range_extremes()","solution":"def search_range(nums, target): Returns the starting and ending index of the target in a sorted list. If the target is not found, returns [-1, -1]. :param nums: List[int] - sorted list of integers :param target: int - the target value to search for :return: List[int] - the starting and ending index of the target def binary_search_left(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def binary_search_right(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right left_idx = binary_search_left(nums, target) right_idx = binary_search_right(nums, target) if left_idx <= right_idx and left_idx < len(nums) and nums[left_idx] == target: return [left_idx, right_idx] else: return [-1, -1]"},{"question":"def capitalizeWord(text: str) -> str: Takes a string and capitalizes the first letter of each word. A word is defined as a sequence of non-space characters. The function also removes extra spaces between words such that there is exactly one space separating words in the returned string. Return the modified string after applying the capitalizeWord operation. >>> capitalizeWord(\\"hello\\") \\"Hello\\" >>> capitalizeWord(\\"hello world\\") \\"Hello World\\" >>> capitalizeWord(\\"hello world this is a test\\") \\"Hello World This Is A Test\\" >>> capitalizeWord(\\"Hello World This Is A Test\\") \\"Hello World This Is A Test\\" >>> capitalizeWord(\\"hEllO wORld\\") \\"Hello World\\" >>> capitalizeWord(\\"\\") \\"\\"","solution":"def capitalizeWord(text): Returns a string where the first letter of each word is capitalized and extra spaces between words are removed. words = text.split() capitalized_words = [word.capitalize() for word in words] return ' '.join(capitalized_words)"},{"question":"def coinChange(coins: List[int], amount: int) -> int: Determine the minimum number of coins needed to make up the given amount. If it is not possible to make up the amount with the given coin denominations, return -1. Args: coins: List[int] - List of integers representing coin denominations. amount: int - Integer representing the total sum of money. Returns: int - Minimum number of coins needed to make up the amount, or -1 if not possible. from solution import coinChange def test_coinChange_example1(): assert coinChange([1, 2, 5], 11) == 3 # 5 + 5 + 1 def test_coinChange_example2(): assert coinChange([2], 3) == -1 # It's not possible to make 3 with denomination 2 def test_coinChange_example3(): assert coinChange([1], 0) == 0 # 0 coins needed to make 0 amount def test_coinChange_example4(): assert coinChange([1, 2, 5], 0) == 0 # 0 coins needed to make 0 amount def test_coinChange_example5(): assert coinChange([2, 5, 10], 12) == 2 # 10 + 2 def test_coinChange_largeAmount(): assert coinChange([1, 2, 5], 100) == 20 # 20 coins of denomination 5 def test_coinChange_notPossible(): assert coinChange([3, 7], 11) == -1 # It's not possible to make 11 with given denominations def test_coinChange_singleCoin(): assert coinChange([1], 2) == 2 # 1 + 1","solution":"def coinChange(coins, amount): Determine the minimum number of coins needed to make up the given amount. If it is not possible to make up the amount with the given coin denominations, return -1. Args: coins: List[int] - List of integers representing coin denominations. amount: int - Integer representing the total sum of money. Returns: int - Minimum number of coins needed to make up the amount, or -1 if not possible. dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the string s. A string is a palindrome when it reads the same backward as forward. A substring is a contiguous sequence of characters within the string. The input string may contain both lower-case and upper-case letters. >>> count_palindromic_substrings('a') 1 >>> count_palindromic_substrings('ab') 2 >>> count_palindromic_substrings('aa') 3 >>> count_palindromic_substrings('abc') 3 >>> count_palindromic_substrings('aaa') 6 >>> count_palindromic_substrings('') 0 >>> count_palindromic_substrings('aA') 2 >>> count_palindromic_substrings('aabaa') 9","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the string s. def is_palindrome(substring): return substring == substring[::-1] count = 0 for i in range(len(s)): for j in range(i, len(s)): if is_palindrome(s[i:j+1]): count += 1 return count"},{"question":"from collections import deque from typing import List def min_bridge_distance(grid: List[List[int]]) -> int: Return the minimum distance needed to connect an island to another island via a bridge. An island is a maximal 4-directionally connected group of 1's. A bridge can be built between two islands by flipping at most one water cell (0) to land (1). The distance is defined as the number of cells in the shortest path between two islands including the bridge. >>> min_bridge_distance([[1, 0, 0, 0, 1]]) 3 >>> min_bridge_distance([[1, 0, 1, 0, 1], [0, 0, 0, 0, 0], [0, 1, 0, 1, 0], [1, 0, 0, 0, 1]]) 1 >>> min_bridge_distance([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> min_bridge_distance([[1, 0, 1], [0, 0, 0], [0, 0, 0]]) 1 >>> min_bridge_distance([[1, 1, 0], [1, 0, 0]]) 0 pass","solution":"from collections import deque def min_bridge_distance(grid): m, n = len(grid), len(grid[0]) def get_islands(): islands = [] visited = [[False] * n for _ in range(m)] def dfs(x, y, island): stack = [(x, y)] while stack: i, j = stack.pop() if 0 <= i < m and 0 <= j < n and not visited[i][j] and grid[i][j] == 1: visited[i][j] = True island.append((i, j)) stack.extend([(i-1, j), (i+1, j), (i, j-1), (i, j+1)]) for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: island = [] dfs(i, j, island) islands.append(island) return islands def bfs(start_points, target_island): queue = deque(start_points) visited = set(start_points) steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if (nx, ny) in target_island: return steps if (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny)) steps += 1 islands = get_islands() if len(islands) < 2: return 0 island1, island2 = islands[0], islands[1] return min(bfs(island1, set(island2)), bfs(island2, set(island1)))"},{"question":"def next_permutation(matrix): Given an \`m x n\` matrix \`mat\` containing integers, return the next permutation of the matrix in lexicographical order. The next permutation is the next lexicographically greater permutation of the matrix. If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order). The replacement must be in-place and use only constant extra memory. The matrix is treated as a flattened array for permutation purposes. Args: matrix (List[List[int]]): 2D list of integers. Returns: None: The matrix is transformed in-place. # Example usage: # mat = [[1, 2], [3, 4]] # next_permutation(mat) # print(mat) # Output should be [[1, 2], [4, 3]]","solution":"def next_permutation(matrix): This function takes an m x n matrix and transforms it into its next lexicographical permutation in-place. If no such permutation exists, it rearranges it to the lowest possible order. def next_perm(nums): # Find the rightmost element which is smaller than its next element. i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 # If such element does not exist, reverse the entire array to get the lowest order. if i == -1: nums.reverse() return # Find the rightmost element which is greater than nums[i] j = len(nums) - 1 while nums[j] <= nums[i]: j -= 1 # Swap nums[i] and nums[j] nums[i], nums[j] = nums[j], nums[i] # Reverse the part of the array after i nums[i + 1:] = reversed(nums[i + 1:]) # Flatten the matrix into a 1D list flat_list = [item for sublist in matrix for item in sublist] # Apply next permutation next_perm(flat_list) # Reconstruct the matrix it = iter(flat_list) for i in range(len(matrix)): for j in range(len(matrix[0])): matrix[i][j] = next(it) # Example usage: # mat = [[1, 2], [3, 4]] # next_permutation(mat) # print(mat) # Output should be [[1, 2], [4, 3]]"},{"question":"import heapq def shortestPath(graph, src, dest): Returns the shortest path from src to dest using Dijkstra's algorithm. If there is no path, returns -1. >>> graph = [[(1, 1), (2, 4)], [(2, 2), (3, 5)], [(3, 1)], []] >>> shortestPath(graph, 0, 3) 4 >>> graph = [[(1, 1)], [(2, 2)], [], []] >>> shortestPath(graph, 0, 3) -1 >>> graph = [[(1, 1)], [(2, 2)], [(0, 1)]] >>> shortestPath(graph, 0, 0) 0 >>> graph = [[(1, 2), (2, 4)], [(2, 1), (3, 5)], [(3, 1)], []] >>> shortestPath(graph, 0, 3) 4 >>> graph = [[(1, 10), (2, 1)], [(3, 1)], [(1, 1), (3, 5)], []] >>> shortestPath(graph, 0, 3) 3","solution":"import heapq def shortestPath(graph, src, dest): Returns the shortest path from src to dest using Dijkstra's algorithm. If there is no path, returns -1. # Number of nodes in the graph n = len(graph) # Distance array to keep track of minimum distance to each node dist = [float('inf')] * n dist[src] = 0 # Priority queue to process nodes by distance pq = [(0, src)] # (distance, node) while pq: current_dist, u = heapq.heappop(pq) # If we have reached the destination if u == dest: return current_dist # If the distance is greater than the already found minimum distance if current_dist > dist[u]: continue # Explore neighbors for neighbor, weight in graph[u]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # If destination is unreachable return -1"},{"question":"def minimum_removals_to_make_increasing(heights: List[int]) -> int: Determine the minimum number of students that must be removed to make the remaining students' heights strictly increasing. >>> minimum_removals_to_make_increasing([10]) 0 >>> minimum_removals_to_make_increasing([1, 2, 3, 4, 5]) 0 >>> minimum_removals_to_make_increasing([5, 5, 5, 5, 5]) 4 >>> minimum_removals_to_make_increasing([5, 1, 4, 2, 3]) 2 >>> minimum_removals_to_make_increasing([5, 4, 3, 2, 1]) 4 >>> minimum_removals_to_make_increasing([1, 3, 2, 4, 3, 5]) 2","solution":"def minimum_removals_to_make_increasing(heights): Returns the minimum number of students that must be removed to make the remaining students' heights strictly increasing. if not heights: return 0 n = len(heights) dp = [1] * n # dp[i] will hold the length of the longest increasing subsequence ending at index i # Compute lengths of all LIS ending at each point for i in range(1, n): for j in range(0, i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence from the array lis_length = max(dp) # Minimum number of removals needed min_removals = n - lis_length return min_removals"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Reorder the characters of the string s according to the given indices array. Parameters: s (str): The input string. indices (List[int]): The list of indices indicating character positions in the reordered string. Returns: str: The reordered string. >>> restore_string(\\"codeleet\\", [4,5,6,7,0,2,1,3]) 'leetcode' >>> restore_string(\\"a\\", [0]) 'a' >>> restore_string(\\"abcabc\\", [0,1,2,3,4,5]) 'abcabc' >>> restore_string(\\"abcde\\", [4,3,2,1,0]) 'edcba' >>> restore_string(\\"aiohn\\", [3,1,4,2,0]) 'nihao' >>> restore_string(\\"art\\", [1,0,2]) 'rat' pass","solution":"def restore_string(s, indices): Reorder the characters of the string s according to the given indices array. Parameters: s (str): The input string. indices (List[int]): The list of indices indicating character positions in the reordered string. Returns: str: The reordered string. if len(s) != len(indices): raise ValueError(\\"The length of the string and the indices array must be the same.\\") # Create a list of the same length as \`s\` initialized with empty strings reordered_string = [''] * len(s) # Place each character at its new position for index, char in zip(indices, s): reordered_string[index] = char # Join the list to form the final string return ''.join(reordered_string)"},{"question":"class WordDictionary: A class to perform add and search operations for a dictionary of words. The search can include dots ('.') where a dot can match any letter. Example usage: >>> wd = WordDictionary() >>> wd.addWord(\\"bad\\") >>> wd.addWord(\\"dad\\") >>> wd.addWord(\\"mad\\") >>> wd.search(\\"pad\\") == False >>> wd.search(\\"bad\\") == True >>> wd.search(\\".ad\\") == True >>> wd.search(\\"b..\\") == True def __init__(self): Initializes the data structure. pass def addWord(self, word: str) -> None: Adds a word into the data structure. pass def search(self, word: str) -> bool: Returns true if there is any string in the data structure that matches word or false otherwise. A word could contain the dot character '.' to represent any one letter. pass","solution":"class WordDictionary: def __init__(self): self.words = {} def addWord(self, word: str) -> None: if len(word) not in self.words: self.words[len(word)] = [] self.words[len(word)].append(word) def search(self, word: str) -> bool: word_len = len(word) if word_len not in self.words: return False for candidate in self.words[word_len]: if all(wc == '.' or wc == cc for wc, cc in zip(word, candidate)): return True return False"},{"question":"def lexicographically_smallest_after_reverse(arr: List[int], k: int) -> List[int]: Returns the lexicographically smallest array that can be obtained by reversing a subarray of size k or smaller at most once. >>> lexicographically_smallest_after_reverse([1, 2, 3], 2) [1, 2, 3] >>> lexicographically_smallest_after_reverse([3, 2, 1], 3) [1, 2, 3] >>> lexicographically_smallest_after_reverse([4, 3, 2, 6, 1], 4) [2, 3, 4, 6, 1] >>> lexicographically_smallest_after_reverse([1], 1) [1] >>> lexicographically_smallest_after_reverse([4, 3, 2, 6, 5], 2) [3, 4, 2, 6, 5] >>> lexicographically_smallest_after_reverse([3, 5, 2, 6, 1], 3) [2, 5, 3, 6, 1] >>> lexicographically_smallest_after_reverse([1, 1, 1, 1, 1], 3) [1, 1, 1, 1, 1]","solution":"def lexicographically_smallest_after_reverse(arr, k): Returns the lexicographically smallest array that can be obtained by reversing a subarray of size k or smaller at most once. n = len(arr) smallest_arr = arr[:] for i in range(n): for j in range(i, min(i + k, n)): subarray = arr[i:j+1][::-1] new_arr = arr[:i] + subarray + arr[j+1:] if new_arr < smallest_arr: smallest_arr = new_arr return smallest_arr"},{"question":"def min_operations(s: str) -> int: Given a string \`s\` consisting of only the characters 'a' and 'b', return the minimum number of operations needed to make the string empty. Each operation consists of removing a contiguous substring of identical characters. >>> min_operations(\\"aaaa\\") 1 >>> min_operations(\\"bbbbb\\") 1 >>> min_operations(\\"aaaaabbbbb\\") 2 >>> min_operations(\\"bbbaaa\\") 2 >>> min_operations(\\"ababab\\") 6 >>> min_operations(\\"baba\\") 4 >>> min_operations(\\"aaabbbbaaa\\") 3 >>> min_operations(\\"aabbaabb\\") 4 >>> min_operations(\\"\\") 0 >>> min_operations(\\"a\\") 1 >>> min_operations(\\"b\\") 1","solution":"def min_operations(s: str) -> int: Return the minimum number of operations needed to make the string empty. Each operation consists of removing a contiguous substring of identical characters. if not s: return 0 operations = 1 for i in range(1, len(s)): if s[i] != s[i-1]: operations += 1 return operations"},{"question":"def longest_univalued_substring(s: str) -> int: Returns the length of the longest univalued substring of s. Parameters: s (str): A string consisting of only lowercase English letters. Returns: int: The length of the longest univalued substring. Examples: >>> longest_univalued_substring(\\"leetcode\\") 2 >>> longest_univalued_substring(\\"aaaaa\\") 5 >>> longest_univalued_substring(\\"abcde\\") 1 >>> longest_univalued_substring(\\"aaabbbccc\\") 3 >>> longest_univalued_substring(\\"\\") 0 >>> longest_univalued_substring(\\"a\\") 1 >>> longest_univalued_substring(\\"abba\\") 2 >>> longest_univalued_substring(\\"ccccaaaabbb\\") 4 >>> longest_univalued_substring(\\"baac\\") 2 >>> longest_univalued_substring(\\"bbccddaa\\") 2","solution":"def longest_univalued_substring(s): Returns the length of the longest univalued substring of s. Parameters: s (str): A string consisting of only lowercase English letters. Returns: int: The length of the longest univalued substring. if not s: return 0 max_len = 1 current_char = s[0] current_len = 1 for i in range(1, len(s)): if s[i] == current_char: current_len += 1 max_len = max(max_len, current_len) else: current_char = s[i] current_len = 1 return max_len"},{"question":"def generate_binary_string(a: int, b: int) -> str: Generate a binary string of length a + b that contains exactly a '0's and b '1's where no two '1's are adjacent. If no such binary string exists, return an empty string. >>> generate_binary_string(3, 2) # Example with 3 '0's and 2 '1's \\"01010\\" >>> generate_binary_string(1, 4) # Example with 1 '0' and 4 '1's \\"\\" >>> generate_binary_string(2, 3) # Example with 2 '0's and 3 '1's \\"10101\\" >>> generate_binary_string(0, 0) # Example with 0 '0's and 0 '1's \\"\\" >>> generate_binary_string(4, 1) # Example with 4 '0's and 1 '1's \\"01000\\"","solution":"def generate_binary_string(a, b): Generate a binary string of length a + b that contains exactly a '0's and b '1's where no two '1's are adjacent. If no such binary string exists, return an empty string. if b > (a + 1): return \\"\\" result = [] while a > 0 or b > 0: if b > a: result.append('1') b -= 1 if b > 0: result.append('0') a -= 1 else: if a > 0: result.append('0') a -= 1 if b > 0: result.append('1') b -= 1 return ''.join(result)"},{"question":"def count_scenic_buildings(heights: List[int], k: int) -> int: Returns the number of buildings that have a scenic view. Parameters: heights (list of int): A list of integers representing the heights of buildings. k (int): An additional parameter (not used in the computation). Returns: int: The number of buildings with a scenic view. >>> count_scenic_buildings([3, 3, 3], 1) == 1 >>> count_scenic_buildings([1, 2, 3, 4], 1) == 1 >>> count_scenic_buildings([4, 3, 2, 1], 1) == 4 >>> count_scenic_buildings([4, 2, 3, 1], 1) == 3 >>> count_scenic_buildings([], 1) == 0 >>> count_scenic_buildings([5], 1) == 1 >>> count_scenic_buildings([1, 3, 2, 5, 4], 1) == 2","solution":"def count_scenic_buildings(heights, k): Returns the number of buildings that have a scenic view. Parameters: heights (list of int): A list of integers representing the heights of buildings. k (int): An additional parameter (not used in the computation). Returns: int: The number of buildings with a scenic view. if not heights: return 0 count = 0 max_height = 0 for height in reversed(heights): if height > max_height: count += 1 max_height = height return count"},{"question":"def findMaximumXOR(arr: List[int]) -> int: Given a list of integers, returns the maximum XOR of any two elements in the list. >>> findMaximumXOR([3, 10, 5, 25, 2, 8]) 28 >>> findMaximumXOR([14, 70, 53, 83, 49, 91, 36, 80, 92, 51, 66, 70]) 127 >>> findMaximumXOR([1, 2, 3, 4, 5, 6, 7]) 7 >>> findMaximumXOR([8, 1, 2, 12, 7, 6]) 15 >>> findMaximumXOR([0, 0, 0, 0]) 0 >>> findMaximumXOR([0, 2, 5, 7]) 7","solution":"def findMaximumXOR(arr): Given a list of integers, returns the maximum XOR of any two elements in the list. max_xor = 0 mask = 0 for i in range(32)[::-1]: mask |= (1 << i) found = {num & mask for num in arr} start = max_xor | (1 << i) for prefix in found: if start ^ prefix in found: max_xor = start break return max_xor"},{"question":"def max_unique_dishes(dishes: list, k: int) -> int: Returns the maximum number of unique dishes that can be prepared given the list of dishes and the constraint k. Parameters: dishes (list): A list of strings representing the names of dishes. k (int): The maximum number of dishes that can be prepared. Returns: int: The maximum number of unique dishes that can be prepared. >>> max_unique_dishes([\\"apple pie\\", \\"salad\\", \\"burger\\", \\"salad\\", \\"apple pie\\", \\"soup\\"], 3) 3 >>> max_unique_dishes([\\"apple pie\\", \\"salad\\", \\"burger\\", \\"salad\\", \\"apple pie\\", \\"soup\\"], 5) 4 >>> max_unique_dishes([\\"pasta\\", \\"pizza\\", \\"salad\\", \\"soup\\"], 4) 4 >>> max_unique_dishes([\\"pasta\\", \\"pizza\\", \\"salad\\", \\"soup\\", \\"burger\\", \\"tacos\\"], 3) 3 >>> max_unique_dishes([\\"salad\\", \\"salad\\", \\"salad\\"], 2) 1 >>> max_unique_dishes([], 5) 0 >>> max_unique_dishes([\\"pasta\\", \\"pizza\\", \\"salad\\"], 0) 0 >>> max_unique_dishes([\\"pasta\\", \\"pizza\\", \\"salad\\"], 1) 1","solution":"def max_unique_dishes(dishes, k): Returns the maximum number of unique dishes that can be prepared given the list of dishes and the constraint k. Parameters: dishes (list): A list of strings representing the names of dishes. k (int): The maximum number of dishes that can be prepared. Returns: int: The maximum number of unique dishes that can be prepared. unique_dishes = set(dishes) return min(len(unique_dishes), k)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_path_sum(root: TreeNode) -> int: Given a binary tree with n nodes numbered from 0 to n - 1 where each node has a value, find the path from the root to any leaf such that the sum of values along the path is maximized. Return the maximum sum of values along any such path. If there are multiple paths with the same maximum sum, return the path that appears first in a preorder traversal. If the tree is empty, return 0. >>> root = TreeNode(5) >>> root.left = TreeNode(6) >>> root.right = TreeNode(7) >>> max_path_sum(root) 12 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> max_path_sum(root) 11","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_path_sum(root): def helper(node): if not node: return (0, []) if not node.left and not node.right: return (node.value, [node.value]) left_sum, left_path = helper(node.left) right_sum, right_path = helper(node.right) if left_sum > right_sum: return (left_sum + node.value, [node.value] + left_path) else: return (right_sum + node.value, [node.value] + right_path) if not root: return 0 max_sum, path = helper(root) return max_sum"},{"question":"def multiply_large_numbers(s1: str, s2: str) -> str: Multiplies two large non-negative integers represented as strings and returns the product as a string. >>> multiply_large_numbers(\\"123\\", \\"456\\") '56088' >>> multiply_large_numbers(\\"2\\", \\"3\\") '6' >>> multiply_large_numbers(\\"0\\", \\"100\\") '0' >>> multiply_large_numbers(\\"123456789123456789\\", \\"0\\") '0' >>> multiply_large_numbers(\\"99\\", \\"99\\") '9801' >>> multiply_large_numbers(\\"7\\", \\"8\\") '56' >>> multiply_large_numbers(\\"1\\", \\"1\\") '1' >>> multiply_large_numbers(\\"9\\", \\"9\\") '81' pass","solution":"def multiply_large_numbers(s1: str, s2: str) -> str: Multiplies two large non-negative integers represented as strings and returns the product as a string. # If either number is zero, the product is zero. if s1 == \\"0\\" or s2 == \\"0\\": return \\"0\\" # Initialize the result as a list of zeros. result = [0] * (len(s1) + len(s2)) # Reverse both strings to facilitate multiplication from right to left. s1 = s1[::-1] s2 = s2[::-1] # Multiply each digit and add it to the result. for i in range(len(s1)): for j in range(len(s2)): result[i + j] += int(s1[i]) * int(s2[j]) result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 # Remove leading zeros and convert list back to a string. while len(result) > 1 and result[-1] == 0: result.pop() return ''.join(map(str, result[::-1]))"},{"question":"def min_total_manhattan_dist(points: List[List[int]]) -> List[int]: Finds the point that minimizes the total sum of Manhattan distances to all other points in the given list of points. Args: points (List[List[int]]): List of points where each point is [x, y] Returns: List[int]: The coordinates of the optimal point that minimizes the total Manhattan distance. >>> min_total_manhattan_dist([[0, 0]]) == [0, 0] >>> min_total_manhattan_dist([[0, 0], [2, 2]]) in [[0, 0], [2, 2]] >>> min_total_manhattan_dist([[1, 2], [3, 4], [5, 6]]) in [[3, 2], [3, 4]] >>> min_total_manhattan_dist([[1, 5], [2, 5], [3, 5], [4, 5], [5, 5]]) == [3, 5] >>> min_total_manhattan_dist([[-1, -2], [1, 2], [-3, 4], [5, -6]]) in [[1, 2], [-1, -2]]","solution":"def min_total_manhattan_dist(points): Finds the point that minimizes the total sum of Manhattan distances to all other points in the given list \`points\`. Args: points (List[List[int]]): List of points where each point is [x, y] Returns: List[int]: The coordinates of the optimal point that minimizes the total Manhattan distance. def find_median(arr): arr.sort() length = len(arr) mid = length // 2 return arr[mid] if length % 2 != 0 else arr[mid - 1] x_coords = [point[0] for point in points] y_coords = [point[1] for point in points] optimal_x = find_median(x_coords) optimal_y = find_median(y_coords) return [optimal_x, optimal_y]"},{"question":"class Transactions: def __init__(self): Initializes an empty balance report for users. pass def addTransaction(self, user: str, amount: int): Takes the user's name and the transaction amount, updating their balance accordingly. >>> trx = Transactions() >>> trx.addTransaction(\\"Alice\\", 50) >>> trx.addTransaction(\\"Alice\\", -10) >>> trx.getBalances() {\\"Alice\\": 40} pass def getBalances(self) -> dict: Returns a map of all users and their final balances after all transactions have been processed. >>> trx = Transactions() >>> trx.getBalances() {} pass","solution":"class Transactions: def __init__(self): self.balances = {} def addTransaction(self, user, amount): Takes the user's name and the transaction amount, updating their balance accordingly. if user in self.balances: self.balances[user] += amount else: self.balances[user] = amount def getBalances(self): Returns a map of all users and their final balances after all transactions have been processed. return self.balances"},{"question":"def find_peaks(nums: List[int], k: int) -> Tuple[int, List[Tuple[int, int]]]: Given an integer array \`nums\` and a positive integer \`k\`, find and return the count of peak elements in the array and their indices as a list of tuples, where each tuple contains the value and index of a peak element. The list of tuples should be sorted by their indices in ascending order. A peak element is an element that is greater than or equal to both its neighbors. For an array of length \`n\`, consider its bounds to have negative infinity values. >>> find_peaks([1, 3, 2, 4, 3], 1) (2, [(3, 1), (4, 3)]) >>> find_peaks([1, 3, 2, 4, 2, 3, 1], 1) (3, [(3, 1), (4, 3), (3, 5)]) >>> find_peaks([1, 2, 3, 4], 1) (1, [(4, 3)]) >>> find_peaks([5, 4, 5, 4, 5], 1) (3, [(5, 0), (5, 2), (5, 4)]) >>> find_peaks([], 1) (0, []) >>> find_peaks([5], 1) (1, [(5, 0)])","solution":"def find_peaks(nums, k): peaks = [] n = len(nums) for i in range(n): left = nums[i - 1] if i - 1 >= 0 else float('-inf') right = nums[i + 1] if i + 1 < n else float('-inf') if nums[i] >= left and nums[i] >= right: peaks.append((nums[i], i)) return len(peaks), sorted(peaks, key=lambda x: x[1])"},{"question":"from typing import List def uniquePathsWithObstacles(grid: List[List[int]]) -> int: Determine the number of possible unique paths from the start to the destination point considering the obstacles. >>> uniquePathsWithObstacles([[0,0,0],[0,1,0],[0,0,0]]) 2 >>> uniquePathsWithObstacles([[1,0,0],[0,0,0],[0,0,0]]) 0 >>> uniquePathsWithObstacles([[0,0,0],[0,0,0],[0,0,1]]) 0 >>> uniquePathsWithObstacles([[0]]) 1 >>> uniquePathsWithObstacles([[1]]) 0","solution":"def uniquePathsWithObstacles(grid): if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"class MessageSystem: A real-time messaging application that supports posting messages and retrieving the most recent messages. def __init__(self): Initialize the message system. pass def postMessage(self, userId: int, message: str) -> None: Records a message posted by a user identified by userId. pass def getRecentMessages(self, userId: int, k: int) -> List[str]: Returns the k most recent messages posted by the user identified by userId. If the user has posted fewer than k messages, return all of their messages in the order they were posted. pass def test_post_and_get_single_message(): system = MessageSystem() system.postMessage(1, \\"Hello\\") assert system.getRecentMessages(1, 1) == [\\"Hello\\"] def test_get_recent_messages_limited_by_k(): system = MessageSystem() system.postMessage(1, \\"Hello\\") system.postMessage(1, \\"World\\") system.postMessage(1, \\"!\\") assert system.getRecentMessages(1, 2) == [\\"!\\", \\"World\\"] def test_get_recent_messages_with_fewer_than_k_messages(): system = MessageSystem() system.postMessage(1, \\"Hello\\") assert system.getRecentMessages(1, 5) == [\\"Hello\\"] def test_get_recent_messages_different_users(): system = MessageSystem() system.postMessage(1, \\"User1 Message1\\") system.postMessage(2, \\"User2 Message1\\") system.postMessage(1, \\"User1 Message2\\") assert system.getRecentMessages(1, 2) == [\\"User1 Message2\\", \\"User1 Message1\\"] assert system.getRecentMessages(2, 1) == [\\"User2 Message1\\"] def test_get_recent_messages_no_messages(): system = MessageSystem() assert system.getRecentMessages(1, 1) == [] def test_overflow_k_messages(): system = MessageSystem() system.postMessage(1, \\"Message1\\") system.postMessage(1, \\"Message2\\") system.postMessage(1, \\"Message3\\") system.postMessage(1, \\"Message4\\") assert system.getRecentMessages(1, 2) == [\\"Message4\\", \\"Message3\\"] assert system.getRecentMessages(1, 10) == [\\"Message4\\", \\"Message3\\", \\"Message2\\", \\"Message1\\"]","solution":"class MessageSystem: def __init__(self): self.user_messages = {} def postMessage(self, userId, message): if userId not in self.user_messages: self.user_messages[userId] = [] self.user_messages[userId].append(message) def getRecentMessages(self, userId, k): if userId not in self.user_messages: return [] return self.user_messages[userId][-k:][::-1] # Return last k messages in reverse order"},{"question":"def reverse_words(sentence: str) -> str: Reverses each word in the sentence while preserving whitespace and order of words. Args: sentence (str): The original sentence. Returns: str: The sentence with each word reversed. Examples: >>> reverse_words(\\"example\\") \\"elpmaxe\\" >>> reverse_words(\\"This is an example\\") \\"sihT si na elpmaxe\\" >>> reverse_words(\\"This is an example\\") \\"sihT si na elpmaxe\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\"a b c d\\") \\"a b c d\\" >>> reverse_words(\\"Hello, world!\\") \\",olleH !dlrow\\"","solution":"def reverse_words(sentence): Reverses each word in the sentence while preserving whitespace and order of words. Args: sentence (str): The original sentence. Returns: str: The sentence with each word reversed. # Split the sentence into words words = sentence.split(' ') # Reverse each word and join them with a space reversed_words = [word[::-1] for word in words] # Join the reversed words with a space to form the final sentence reversed_sentence = ' '.join(reversed_words) return reversed_sentence"},{"question":"def total_revenue(sales, start_time, end_time): Calculate the total revenue for each product within the given time range. Parameters: sales (list of tuples): List of sales where each sale is represented as a tuple (timestamp, product_id, price, quantity). start_time (int/float): Start of the time range. end_time (int/float): End of the time range. Returns: dict: A dictionary with product_ids as keys and their total revenue as values. from solution import total_revenue def test_total_revenue_basic(): sales = [ (1, 'A', 10, 2), (2, 'B', 15, 3), (3, 'A', 10, 1), (5, 'A', 10, 1), (7, 'C', 20, 2) ] start_time = 2 end_time = 5 expected = {'B': 45, 'A': 20} # Only sales within timestamp 2, 3, and 5 assert total_revenue(sales, start_time, end_time) == expected def test_total_revenue_empty_sales(): sales = [] start_time = 2 end_time = 5 expected = {} # No sales means no revenue assert total_revenue(sales, start_time, end_time) == expected def test_total_revenue_no_sales_in_time_range(): sales = [ (1, 'A', 10, 2), (6, 'B', 15, 3), ] start_time = 2 end_time = 5 expected = {} # No sales in the time range of 2 to 5 assert total_revenue(sales, start_time, end_time) == expected def test_total_revenue_all_sales_in_time_range(): sales = [ (2, 'A', 10, 2), (3, 'B', 15, 3), (4, 'C', 20, 1), ] start_time = 2 end_time = 5 expected = {'A': 20, 'B': 45, 'C': 20} # All sales are within the time range assert total_revenue(sales, start_time, end_time) == expected def test_total_revenue_partial_sales_in_time_range(): sales = [ (1, 'A', 10, 2), (3, 'B', 15, 3), (4, 'C', 20, 1), (6, 'A', 10, 1), ] start_time = 2 end_time = 5 expected = {'B': 45, 'C': 20} # Only sales within timestamp 3 and 4 assert total_revenue(sales, start_time, end_time) == expected","solution":"def total_revenue(sales, start_time, end_time): Calculate the total revenue for each product within the given time range. Parameters: sales (list of tuples): List of sales where each sale is represented as a tuple (timestamp, product_id, price, quantity). start_time (int/float): Start of the time range. end_time (int/float): End of the time range. Returns: dict: A dictionary with product_ids as keys and their total revenue as values. revenue = {} for timestamp, product_id, price, quantity in sales: if start_time <= timestamp <= end_time: if product_id not in revenue: revenue[product_id] = 0 revenue[product_id] += price * quantity return revenue"},{"question":"def can_form_target(nums, target): Determines if it is possible to perform operations to leave exactly one element in the array equal to the target. Args: nums (list of int): The array of integers. target (int): The target integer. Returns: bool: True if it's possible to obtain the target, otherwise False. >>> can_form_target([1, 2, 3, 4], 10) True >>> can_form_target([1, 2, 3, 4], 11) False >>> can_form_target([10], 10) True >>> can_form_target([5], 10) False >>> can_form_target([], 0) True >>> can_form_target([], 1) False >>> can_form_target([10**6, 10**6, 10**6], 3 * 10**6) True >>> can_form_target([-1, -2, -3, -4], -10) True >>> can_form_target([-1, -2, -3, -4], -11) False >>> can_form_target([-1, -1, -1, 3], 0) True >>> can_form_target([-1, 1, 2, 4], 6) True >>> can_form_target([-1, 1, 2, 4], 7) False >>> can_form_target([2, 2, 2, 2], 8) True >>> can_form_target([2, 2, 2, 2], 7) False","solution":"def can_form_target(nums, target): Determines if it is possible to perform operations to leave exactly one element in the array equal to the target. Args: nums (list of int): The array of integers. target (int): The target integer. Returns: bool: True if it's possible to obtain the target, otherwise False. current_sum = sum(nums) if current_sum < target: return False return (current_sum - target) % 2 == 0"},{"question":"from typing import List def longest_arith_seq_length(arr: List[int]) -> int: Given an array of integers, return the length of the longest arithmetic subsequence in the array. >>> longest_arith_seq_length([1, 7, 10, 13, 14, 19]) 4 >>> longest_arith_seq_length([3, 6, 9, 12]) 4 >>> longest_arith_seq_length([9, 4, 7, 2, 10]) 3 >>> longest_arith_seq_length([20, 1, 15, 3, 10, 5, 8]) 4 >>> longest_arith_seq_length([]) 0 >>> longest_arith_seq_length([1]) 1 >>> longest_arith_seq_length([83, 20, 17, 43, 52, 78, 68, 45]) 2 >>> longest_arith_seq_length([3, 3, 3, 3]) 4","solution":"from collections import defaultdict def longest_arith_seq_length(arr): if not arr: return 0 n = len(arr) if n <= 1: return n dp = [defaultdict(int) for _ in range(n)] max_length = 2 for i in range(n): for j in range(i): diff = arr[i] - arr[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"from typing import List def running_sum(nums: List[int]) -> List[int]: Given an array of integers \`nums\`, return the running sum of \`nums\`. The running sum of an array is defined as \`runningSum[i] = sum(nums[0]nums[i])\`. >>> running_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> running_sum([0, 0, 0, 0]) [0, 0, 0, 0] >>> running_sum([-1, -2, -3, -4]) [-1, -3, -6, -10] >>> running_sum([1, -1, 2, -2]) [1, 0, 2, 0] >>> running_sum([5]) [5] >>> running_sum([]) []","solution":"def running_sum(nums): Returns the running sum of nums. running_total = 0 running_sums = [] for num in nums: running_total += num running_sums.append(running_total) return running_sums"},{"question":"def can_construct_target(words: List[str], target: str) -> bool: Determines if the target can be constructed by concatenating two distinct strings from the words array. >>> can_construct_target([\\"hello\\", \\"world\\"], \\"helloworld\\") True >>> can_construct_target([\\"a\\", \\"b\\", \\"c\\"], \\"abc\\") False >>> can_construct_target([\\"go\\", \\"od\\", \\"morning\\"], \\"good\\") True >>> can_construct_target([\\"one\\", \\"two\\", \\"three\\"], \\"onetwoone\\") False >>> can_construct_target([\\"apple\\", \\"banana\\"], \\"applebananaapple\\") False >>> can_construct_target([\\"a\\", \\"a\\"], \\"aa\\") False >>> can_construct_target([\\"aa\\", \\"bb\\"], \\"ab\\") False >>> can_construct_target([\\"abc\\", \\"def\\"], \\"abd\\") False >>> can_construct_target([\\"a\\", \\"b\\", \\"c\\"], \\"\\") False >>> can_construct_target([\\"abc\\", \\"def\\", \\"abcd\\"], \\"abcdef\\") True","solution":"def can_construct_target(words, target): Determines if the target can be constructed by concatenating two distinct strings from the words array. :param words: List of strings :param target: The target string to construct :return: True if the target can be constructed, otherwise False word_set = set(words) for word in words: prefix, suffix = target[:len(word)], target[len(word):] if prefix == word and suffix in word_set and suffix != word: return True return False"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_linked_list(head: ListNode) -> ListNode: Sort a linked list using merge sort. The function should preserve the original structure and only rearrange the node values. >>> linked_list_to_list(merge_sort_linked_list(list_to_linked_list([4, 2, 1, 3]))) == [1, 2, 3, 4] >>> linked_list_to_list(merge_sort_linked_list(list_to_linked_list([1]))) == [1] >>> linked_list_to_list(merge_sort_linked_list(list_to_linked_list([]))) == [] >>> linked_list_to_list(merge_sort_linked_list(list_to_linked_list([4, 3, 2, 1]))) == [1, 2, 3, 4] >>> linked_list_to_list(merge_sort_linked_list(list_to_linked_list([4, 2, 2, 3, 1, 2]))) == [1, 2, 2, 2, 3, 4]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_linked_list(head): if not head or not head.next: return head # Find the middle of the linked list slow, fast = head, head.next while fast and fast.next: slow = slow.next fast = fast.next.next mid = slow.next slow.next = None # Recursively split and sort both halves left = merge_sort_linked_list(head) right = merge_sort_linked_list(mid) # Merge sorted halves return merge(left, right) def merge(left, right): dummy = ListNode() tail = dummy while left and right: if left.val < right.val: tail.next = left left = left.next else: tail.next = right right = right.next tail = tail.next tail.next = left or right return dummy.next"},{"question":"from typing import List def word_ladder_length(beginWord: str, endWord: str, wordList: List[str]) -> int: Returns the length of the shortest transformation sequence from beginWord to endWord, or 0 if such a sequence does not exist. >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) == 0 >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) == 5 >>> word_ladder_length(\\"hit\\", \\"hot\\", [\\"hot\\"]) == 2 >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"dog\\", \\"hog\\", \\"cog\\"]) == 0 >>> word_ladder_length(\\"game\\", \\"thee\\", [\\"gave\\", \\"came\\", \\"gape\\", \\"games\\", \\"tame\\", \\"take\\", \\"fame\\", \\"name\\", \\"fate\\", \\"late\\", \\"made\\", \\"tame\\", \\"lame\\", \\"bake\\", \\"gaze\\", \\"maze\\", \\"bate\\", \\"mate\\", \\"gate\\", \\"hate\\", \\"bone\\", \\"lore\\", \\"tine\\", \\"hone\\", \\"core\\", \\"time\\", \\"cone\\", \\"rope\\", \\"note\\", \\"cope\\", \\"lope\\"]) == 0","solution":"from collections import deque, defaultdict def word_ladder_length(beginWord, endWord, wordList): Returns the length of the shortest transformation sequence from beginWord to endWord, or 0 if such a sequence does not exist. if endWord not in wordList: return 0 # Pre-process the words in wordList to create a dictionary of all combinations of words with wildcards. L = len(beginWord) all_combo_dict = defaultdict(list) for word in wordList: for i in range(L): all_combo_dict[word[:i] + \\"*\\" + word[i+1:]].append(word) # BFS starting queue = deque([(beginWord, 1)]) visited = set(beginWord) while queue: current_word, level = queue.popleft() for i in range(L): intermediate_word = current_word[:i] + \\"*\\" + current_word[i+1:] for word in all_combo_dict[intermediate_word]: if word == endWord: return level + 1 if word not in visited: visited.add(word) queue.append((word, level + 1)) all_combo_dict[intermediate_word] = [] return 0"},{"question":"from typing import List def min_max_pages(pages: List[int], n: int, k: int) -> int: You are given a list of \`n\` books, where each book has a unique integer \`pages[i]\` representing the number of pages in the \`i\`th book. You want to distribute these books to \`k\` students such that each student gets at least one book and the maximum number of pages assigned to any student is minimized. Each book must be assigned to exactly one student. Return the minimum possible value of the maximum number of pages assigned to a student. >>> min_max_pages([12, 34, 67, 90], 4, 2) 113 >>> min_max_pages([10, 20, 30, 40], 4, 2) 60 >>> min_max_pages([10, 20, 30, 40, 50, 60], 6, 3) 90 >>> min_max_pages([100, 200, 300, 400, 500], 5, 4) 500 >>> min_max_pages([10, 20], 2, 3) -1 >>> min_max_pages([100], 1, 1) 100","solution":"def is_feasible(pages, n, k, max_pages): students_required = 1 current_pages = 0 for i in range(n): if current_pages + pages[i] > max_pages: students_required += 1 current_pages = pages[i] if students_required > k: return False else: current_pages += pages[i] return True def min_max_pages(pages, n, k): if n < k: return -1 start = max(pages) end = sum(pages) result = end while start <= end: mid = (start + end) // 2 if is_feasible(pages, n, k, mid): result = mid end = mid - 1 else: start = mid + 1 return result"},{"question":"class IntegerCollection: A data structure that efficiently maintains a collection of integers and supports the following operations: - void add(int num): Adds the integer \`num\` to the collection. - bool contains(int num): Returns \`true\` if the integer \`num\` is present in the collection, otherwise returns \`false\`. - void remove(int num): Removes the integer \`num\` from the collection if it is present. - double getMedian(): Returns the median of all elements in the collection. If the total number of elements is odd, the median is the middle value. If the total number of elements is even, the median is the average of the two middle values. >>> collection = IntegerCollection() >>> collection.add(1) >>> collection.add(3) >>> collection.add(2) >>> collection.contains(1) True >>> collection.contains(4) False >>> collection.getMedian() 2.0 def __init__(self): pass def add(self, num: int): pass def contains(self, num: int) -> bool: pass def remove(self, num: int): pass def getMedian(self) -> float: pass import pytest def test_add_and_contains(): collection = IntegerCollection() collection.add(1) collection.add(3) collection.add(2) assert collection.contains(1) == True assert collection.contains(3) == True assert collection.contains(2) == True assert collection.contains(4) == False def test_remove(): collection = IntegerCollection() collection.add(1) collection.add(3) collection.add(2) collection.remove(1) assert collection.contains(1) == False assert collection.contains(2) == True assert collection.contains(3) == True def test_get_median_odd(): collection = IntegerCollection() collection.add(1) collection.add(3) collection.add(2) assert collection.getMedian() == 2.0 def test_get_median_even(): collection = IntegerCollection() collection.add(1) collection.add(3) collection.add(2) collection.add(4) assert collection.getMedian() == 2.5 def test_get_median_empty(): collection = IntegerCollection() with pytest.raises(ValueError, match=\\"Collection is empty\\"): collection.getMedian()","solution":"import bisect class IntegerCollection: def __init__(self): self.nums = [] def add(self, num: int): bisect.insort(self.nums, num) def contains(self, num: int) -> bool: index = bisect.bisect_left(self.nums, num) return index < len(self.nums) and self.nums[index] == num def remove(self, num: int): index = bisect.bisect_left(self.nums, num) if index < len(self.nums) and self.nums[index] == num: self.nums.pop(index) def getMedian(self) -> float: n = len(self.nums) if n == 0: raise ValueError(\\"Collection is empty\\") if n % 2 == 1: return float(self.nums[n // 2]) else: return (self.nums[n // 2 - 1] + self.nums[n // 2]) / 2"},{"question":"def generate_parentheses(n: int) -> List[str]: Generate all combinations of well-formed parentheses of length 2n. :param n: Integer, number of pairs of parentheses :return: List of strings, all combinations of well-formed parentheses >>> generate_parentheses(2) == [\\"(())\\", \\"()()\\"] >>> generate_parentheses(3) == [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"]","solution":"def generate_parentheses(n): Generate all combinations of well-formed parentheses of length 2n. :param n: Integer, number of pairs of parentheses :return: List of strings, all combinations of well-formed parentheses def backtrack(s='', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + '(', left + 1, right) if right < left: backtrack(s + ')', left, right + 1) result = [] backtrack() return result"},{"question":"def mergeStones(piles, k): Merge exactly \`k\` consecutive piles into one pile, and the cost of merging these piles is equal to the total number of stones in the k piles. Return the minimum cost to merge all piles into one pile. If it is impossible to merge all piles into one pile, return \`-1\`. >>> mergeStones([3, 2, 4, 1], 2) 20 >>> mergeStones([3, 2, 4, 1], 3) -1 >>> mergeStones([3, 5, 1, 2, 6], 3) 25 >>> mergeStones([4], 2) 0 >>> mergeStones([4, 6, 2, 3], 5) -1","solution":"def mergeStones(piles, k): import sys from functools import lru_cache n = len(piles) if (n - 1) % (k - 1) != 0: return -1 prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i+1] = prefix_sum[i] + piles[i] @lru_cache(None) def dp(i, j, m): if i == j: return 0 if m == 1 else sys.maxsize if m == 1: return dp(i, j, k) + prefix_sum[j+1] - prefix_sum[i] min_cost = sys.maxsize for t in range(i, j, k - 1): min_cost = min(min_cost, dp(i, t, 1) + dp(t + 1, j, m - 1)) return min_cost return dp(0, n-1, 1)"},{"question":"def smallest_window(colors1, colors2): Returns the length of the smallest window in colors2 where all elements of colors1 appear in the same relative order. If no such window exists, returns -1. >>> smallest_window([1, 2, 3], [7, 1, 9, 2, 3, 4]) == 4 >>> smallest_window([1, 2, 3], [6, 7, 8, 9]) == -1 >>> smallest_window([1, 2, 3], [1, 2, 3]) == 3 >>> smallest_window([1, 2, 3], [1, 2, 1, 2, 3]) == 3 >>> smallest_window([3, 2, 1], [1, 2, 3, 4, 3, 2, 1]) == 3 >>> smallest_window([1, 2, 3, 4], [1, 2, 3]) == -1 >>> smallest_window([], [1, 2, 3, 4, 5]) == -1 >>> smallest_window([1, 2, 3], []) == -1","solution":"def smallest_window(colors1, colors2): Returns the length of the smallest window in colors2 where all elements of colors1 appear in the same relative order. If no such window exists, returns -1. n = len(colors1) m = len(colors2) # Corner case: if colors1 is empty or colors2 is smaller than colors1 if n == 0 or m < n: return -1 left_includes = {i: {} for i in range(n)} right = 0 window_len = float('inf') for right in range(m): current_color = colors2[right] if current_color == colors1[0]: left_includes[0][right] = 1 for i in range(1, n): for left_idx in left_includes[i-1].keys(): if colors2[right] == colors1[i]: distance = left_includes[i-1][left_idx] + (right - left_idx) if right not in left_includes[i]: left_includes[i][right] = distance else: left_includes[i][right] = min(left_includes[i][right], distance) for right_idx in left_includes[n-1].keys(): window_len = min(window_len, left_includes[n-1][right_idx]) return window_len if window_len != float('inf') else -1"},{"question":"from typing import List def find_task_order(num_tasks: int, prerequisites: List[List[int]]) -> List[int]: Determines if it is possible to finish all tasks with given prerequisites and returns an order of tasks. >>> find_task_order(4, []) in ([0, 1, 2, 3], [0, 1, 3, 2], [0, 2, 1, 3], [0, 2, 3, 1], [0, 3, 2, 1], [0, 3, 1, 2]) True >>> find_task_order(2, [[1, 0]]) [0, 1] >>> find_task_order(2, [[1, 0], [0, 1]]) [] >>> find_task_order(4, [[1, 0], [2, 0], [3, 1], [3, 2]]) in ([0, 1, 2, 3], [0, 2, 1, 3]) True >>> find_task_order(4, [[1, 0], [2, 1], [3, 2]]) in ([0, 1, 2, 3], [0, 1, 3, 2], [0, 2, 1, 3], [0, 3, 2, 1]) True >>> find_task_order(5, [[1, 0], [2, 1], [3, 2], [4, 3]]) [0, 1, 2, 3, 4] >>> find_task_order(3, [[0, 1], [1, 2], [2, 0]]) []","solution":"from collections import defaultdict, deque def find_task_order(num_tasks, prerequisites): Determines if it is possible to finish all tasks with given prerequisites and returns an order of tasks. :param num_tasks: int - Number of tasks :param prerequisites: List[List[int]] - List of prerequisites :return: List[int] - Ordered list of tasks or empty list if not possible # Create adjacency list and indegree array adj_list = defaultdict(list) indegree = [0] * num_tasks # Build the graph for dest, src in prerequisites: adj_list[src].append(dest) indegree[dest] += 1 # Queue for tasks having no prerequisites zero_indegree_queue = deque([i for i in range(num_tasks) if indegree[i] == 0]) top_order = [] while zero_indegree_queue: task = zero_indegree_queue.popleft() top_order.append(task) for neighbor in adj_list[task]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) # If top_order contains all tasks, return the order, otherwise return empty list if len(top_order) == num_tasks: return top_order else: return []"},{"question":"def longest_subarray_with_product_less_than_s(nums: List[int], s: int) -> int: Returns the length of the longest contiguous subarray where the product of its elements is less than s. >>> longest_subarray_with_product_less_than_s([10, 5, 2], 1) 0 >>> longest_subarray_with_product_less_than_s([1, 2, 3], 10) 3 >>> longest_subarray_with_product_less_than_s([10, 5, 2, 6], 100) 3 >>> longest_subarray_with_product_less_than_s([10], 5) 0 >>> longest_subarray_with_product_less_than_s([5], 10) 1 >>> longest_subarray_with_product_less_than_s([1, 1, 1, 1], 2) 4 >>> longest_subarray_with_product_less_than_s([1, 2, 3, 4], 10) 3 >>> longest_subarray_with_product_less_than_s([], 10) 0","solution":"def longest_subarray_with_product_less_than_s(nums, s): Returns the length of the longest contiguous subarray where the product of its elements is less than s. if s <= 1: return 0 product = 1 left = 0 max_length = 0 for right in range(len(nums)): product *= nums[right] while product >= s and left <= right: product //= nums[left] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def max_min_of_subarrays(arr, k): Returns the maximum possible value of the minimum value in each subarray of length \`k\`. Parameters: arr (list): A list of integers. k (int): Length of each subarray. Returns: int: Maximum value of the minimum values of subarrays of length \`k\`, or -1 if not possible. pass # Example test cases def test_subarrays_of_length_3(): arr = [10, 1, 30, 4, 7, 9] k = 3 assert max_min_of_subarrays(arr, k) == 4 def test_invalid_subarray_length(): arr = [1, 2, 3, 4] k = 5 assert max_min_of_subarrays(arr, k) == -1 def test_single_element_subarray(): arr = [5, 2, 9] k = 1 assert max_min_of_subarrays(arr, k) == 9 def test_length_equals_k(): arr = [20, 10, 40, 30] k = 4 assert max_min_of_subarrays(arr, k) == 10 def test_equal_elements(): arr = [5, 5, 5, 5, 5] k = 2 assert max_min_of_subarrays(arr, k) == 5","solution":"def max_min_of_subarrays(arr, k): Returns the maximum possible value of the minimum value in each subarray of length \`k\`. Parameters: arr (list): A list of integers. k (int): Length of each subarray. Returns: int: Maximum value of the minimum values of subarrays of length \`k\`, or -1 if not possible. # Edge case: If k is larger than the length of array, return -1 if k > len(arr): return -1 # List to store minimum values of each subarray mins = [] # Traverse the array for i in range(len(arr) - k + 1): # Find the minimum value of the current subarray min_val = min(arr[i:i + k]) mins.append(min_val) # Return the maximum value among the minimum values return max(mins)"},{"question":"def can_form_word(word: str, letters: str) -> bool: Returns True if \`word\` can be formed using characters from \`letters\`, otherwise returns False. Each character in \`letters\` can only be used once. >>> can_form_word(\\"hello\\", \\"eollh\\") == True >>> can_form_word(\\"hello\\", \\"ellohh\\") == True >>> can_form_word(\\"hello\\", \\"eolh\\") == False >>> can_form_word(\\"banana\\", \\"aabbnnaa\\") == True >>> can_form_word(\\"banana\\", \\"aabnnn\\") == False >>> can_form_word(\\"\\", \\"anything\\") == True >>> can_form_word(\\"nonempty\\", \\"\\") == False >>> can_form_word(\\"\\", \\"\\") == True","solution":"def can_form_word(word, letters): Returns True if \`word\` can be formed using characters from \`letters\`, otherwise returns False. Each character in \`letters\` can only be used once. from collections import Counter word_counter = Counter(word) letters_counter = Counter(letters) for char in word_counter: if word_counter[char] > letters_counter.get(char, 0): return False return True"},{"question":"def num_islands(matrix: List[List[int]]) -> int: Return the number of distinct islands in the given matrix. An island is a group of adjacent lands connected horizontally or vertically. >>> num_islands([ ... [1, 1, 0, 0], ... [1, 1, 0, 0], ... [0, 0, 1, 1], ... [0, 0, 0, 0] ... ]) == 2 >>> num_islands([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> num_islands([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) == 3 >>> num_islands([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 1 >>> num_islands([ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) == 5 pass","solution":"def num_islands(matrix): if not matrix: return 0 n = len(matrix) visited = [[False]*n for _ in range(n)] def dfs(i, j): if i < 0 or i >= n or j < 0 or j >= n or matrix[i][j] == 0 or visited[i][j]: return visited[i][j] = True dfs(i-1, j) dfs(i+1, j) dfs(i, j-1) dfs(i, j+1) count = 0 for i in range(n): for j in range(n): if matrix[i][j] == 1 and not visited[i][j]: dfs(i, j) count += 1 return count"},{"question":"def largest_lake(grid: List[List[int]]) -> int: Returns the size of the largest lake in the grid. A lake is a connected group of 0's (horizontal or vertical). :param grid: List of lists representing the 2D grid :return: Size of the largest lake >>> largest_lake([ ... [1, 0, 1], ... [1, 0, 1], ... [1, 1, 1] ... ]) == 2 >>> largest_lake([ ... [0, 1, 0, 1], ... [1, 1, 1, 0], ... [0, 1, 0, 0] ... ]) == 3 >>> largest_lake([ ... [0, 0], ... [0, 0] ... ]) == 4 >>> largest_lake([ ... [0, 1, 0], ... [1, 0, 1], ... [0, 1, 0] ... ]) == 1 >>> largest_lake([ ... [1, 0, 0, 1, 1, 0, 0, 0] ... ]) == 3 >>> largest_lake([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 0","solution":"def largest_lake(grid): Returns the size of the largest lake in the grid. A lake is a connected group of 0's (horizontal or vertical). :param grid: List of lists representing the 2D grid :return: Size of the largest lake if not grid: return 0 m, n = len(grid), len(grid[0]) visited = set() def dfs(x, y): if (x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != 0 or (x, y) in visited): return 0 visited.add((x, y)) size = 1 # Current cell is part of the lake size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size largest_size = 0 for i in range(m): for j in range(n): if grid[i][j] == 0 and (i, j) not in visited: lake_size = dfs(i, j) largest_size = max(largest_size, lake_size) return largest_size"},{"question":"from typing import List def splitArray(nums: List[int], m: int) -> int: Given an array of integers nums and an integer m, determine if you can split the array into m non-empty continuous subarrays, such that the largest sum of any subarray is minimized. Return the minimized value of the largest sum of the m subarrays. >>> splitArray([10], 1) 10 >>> splitArray([1, 1, 1, 1, 1], 2) 3 >>> splitArray([7, 2, 5, 10, 8], 2) 18 >>> splitArray([7, 2, 5, 10, 8], 3) 14 >>> splitArray([1, 2, 3, 4, 5], 2) 9 >>> splitArray([1, 4, 4], 3) 4","solution":"def splitArray(nums, m): def can_split(nums, m, max_sum): current_sum = 0 required_subarrays = 1 for num in nums: if current_sum + num > max_sum: required_subarrays += 1 current_sum = num if required_subarrays > m: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, m, mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List def min_jumps_to_end(arr: List[int], start: int, k: int) -> int: Determines the minimum number of jumps to reach the end of the array where stones are placed or -1 if not possible. Parameters: arr (list of int): Positions of the stones. start (int): Starting position. k (int): Maximum allowed jump distance. Returns: int: Minimum number of jumps to reach the end or -1 if not possible. pass # Unit Test Cases def test_simple_case(): arr = [1, 1, 1, 1, 1] start = 0 k = 2 assert min_jumps_to_end(arr, start, k) == 2 def test_no_jump_needed(): arr = [1, 1, 1, 1, 1] start = 4 k = 2 assert min_jumps_to_end(arr, start, k) == 0 def test_not_possible(): arr = [1, 0, 1, 0, 1] start = 0 k = 1 assert min_jumps_to_end(arr, start, k) == -1 def test_single_jump(): arr = [1, 1, 1, 1, 0, 1] start = 0 k = 5 assert min_jumps_to_end(arr, start, k) == 1 def test_start_out_of_bounds(): arr = [1, 1, 1, 1, 1] start = 10 k = 2 assert min_jumps_to_end(arr, start, k) == -1","solution":"from collections import deque def min_jumps_to_end(arr, start, k): Determines the minimum number of jumps to reach the end of the array where stones are placed or -1 if not possible. Parameters: arr (list of int): Positions of the stones. start (int): Starting position. k (int): Maximum allowed jump distance. Returns: int: Minimum number of jumps to reach the end or -1 if not possible. n = len(arr) if start >= n: return -1 # Early exit if already at the end if start == n - 1: return 0 queue = deque([(start, 0)]) # (current position, current jumps) visited = set([start]) while queue: current, jumps = queue.popleft() for i in range(current + 1, min(current + k + 1, n)): if i not in visited and arr[i] == 1: if i == n - 1: return jumps + 1 queue.append((i, jumps + 1)) visited.add(i) return -1"},{"question":"def min_absolute_difference(arr: List[int]) -> int: Returns the minimum absolute difference between the sums of two contiguous non-empty subarrays. >>> min_absolute_difference([1, 2, 3, 4]) == 2 >>> min_absolute_difference([1, 1, 1, 1]) == 0 >>> min_absolute_difference([3, 1, 2, 4, 3]) == 1 >>> min_absolute_difference([10, 1]) == 9 >>> min_absolute_difference([4, 5, -3, 10, 2, -7, 6]) == 1","solution":"def min_absolute_difference(arr): Returns the minimum absolute difference between the sums of two contiguous non-empty subarrays. # Compute the total sum of the array total_sum = sum(arr) # Initialize left sum to 0 and minimum absolute difference to a large value left_sum = 0 min_abs_diff = float('inf') # Iterate through the array to find the point of division for i in range(len(arr) - 1): left_sum += arr[i] right_sum = total_sum - left_sum min_abs_diff = min(min_abs_diff, abs(left_sum - right_sum)) return min_abs_diff"},{"question":"def min_days_to_eat_all_candies(candies: List[int]) -> int: Returns the minimum number of days required to eat all the candies in all piles where on each day you can eat 1, 2, or k (k < current pile size) candies from one chosen pile. >>> min_days_to_eat_all_candies([1, 1, 1]) 3 >>> min_days_to_eat_all_candies([3]) 3 >>> min_days_to_eat_all_candies([5]) 5 >>> min_days_to_eat_all_candies([1, 2, 3]) 6 >>> min_days_to_eat_all_candies([4, 5, 6]) 15 >>> min_days_to_eat_all_candies([0, 2, 3]) 5 >>> min_days_to_eat_all_candies([0, 0, 0, 1]) 1 >>> min_days_to_eat_all_candies([]) 0","solution":"def min_days_to_eat_all_candies(candies): Returns the minimum number of days required to eat all the candies in all piles where on each day you can eat 1, 2, or k (k < current pile size) candies from one chosen pile. days = 0 for pile in candies: days += pile return days"},{"question":"def min_sum_of_distances(arr: List[int], x: int) -> int: Returns the minimum sum of distances between an integer x and all integers in the list arr. >>> min_sum_of_distances([1, 2, 3], 2) 2 >>> min_sum_of_distances([-1, -2, -3], -2) 2 >>> min_sum_of_distances([-1, 0, 1, 2], 0) 4 >>> min_sum_of_distances([5], 5) 0 >>> min_sum_of_distances([1000, -1000, 500], 0) 2500 >>> min_sum_of_distances([], 5) 0","solution":"def min_sum_of_distances(arr, x): Returns the minimum sum of distances between an integer x and all integers in the list arr. return sum(abs(a - x) for a in arr)"},{"question":"def longest_special_subsequence(s: str) -> int: Returns the length of the longest special subsequence of s where no two consecutive characters are the same. >>> longest_special_subsequence(\\"\\") == 0 >>> longest_special_subsequence(\\"a\\") == 1 >>> longest_special_subsequence(\\"aaaa\\") == 1 >>> longest_special_subsequence(\\"ababab\\") == 6 >>> longest_special_subsequence(\\"abacadc\\") == 7 >>> longest_special_subsequence(\\"abcdef\\") == 6 >>> longest_special_subsequence(\\"aabbccddeeff\\") == 6","solution":"def longest_special_subsequence(s): Returns the length of the longest special subsequence of s where no two consecutive characters are the same. if not s: return 0 # Initialize length of longest special subsequence longest_length = 1 prev_char = s[0] for char in s[1:]: if char != prev_char: longest_length += 1 prev_char = char return longest_length"},{"question":"from typing import List def word_break(s: str, wordDict: List[str]) -> List[str]: Given a string \`s\` and a dictionary of strings \`wordDict\`, return all possible sentences you can form by concatenating words from the \`wordDict\` such that each word is used exactly once. Each word in the dictionary can only be used once in the sentence. Formed sentences should be space-separated sequences of dictionary words. Return the sentences in any order. >>> word_break(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) [\\"cat sand dog\\", \\"cats and dog\\"] >>> word_break(\\"catsanddog\\", [\\"apple\\", \\"banana\\", \\"kiwi\\"]) [] >>> word_break(\\"apple\\", [\\"apple\\"]) [\\"apple\\"] >>> word_break(\\"abcd\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) [\\"a b c d\\"] >>> word_break(\\"catcat\\", [\\"cat\\", \\"catcat\\"]) [\\"cat cat\\", \\"catcat\\"]","solution":"from typing import List def word_break(s: str, wordDict: List[str]) -> List[str]: def backtrack(start): if start == len(s): return [[]] # return empty list as part of the recursive call if start in memo: return memo[start] result = [] for end in range(start + 1, len(s) + 1): word = s[start:end] if word in wordDict: for sub_sentence in backtrack(end): result.append([word] + sub_sentence) memo[start] = result return result word_set = set(wordDict) memo = {} sentences = backtrack(0) return [' '.join(sentence) for sentence in sentences]"},{"question":"def count_buildings_with_west_view(heights: List[int]) -> int: Return the number of buildings with a clear view to the west. A building has a clear view to the west if all the buildings to its left are shorter than it. :param heights: List of integers representing the height of buildings. :return: Integer representing the number of buildings with a clear view to the west. >>> count_buildings_with_west_view([5]) 1 >>> count_buildings_with_west_view([1, 2, 3, 4]) 4 >>> count_buildings_with_west_view([4, 3, 2, 1]) 1 >>> count_buildings_with_west_view([3, 1, 4, 2, 5]) 3 >>> count_buildings_with_west_view([2, 2, 2, 2]) 1 >>> count_buildings_with_west_view([]) 0","solution":"def count_buildings_with_west_view(heights): Return the number of buildings with a clear view to the west. A building has a clear view to the west if all the buildings to its left are shorter than it. :param heights: List of integers representing the height of buildings. :return: Integer representing the number of buildings with a clear view to the west. count = 0 current_max = float('-inf') for height in heights: if height > current_max: count += 1 current_max = height return count"},{"question":"from typing import List def min_tunnel_cost(grid: List[List[str]]) -> int: Returns the minimum cost required to connect any two buildings in the grid through empty spaces 'E', or -1 if it is not possible. >>> min_tunnel_cost([['E', 'E'], ['E', 'E']]) -1 >>> min_tunnel_cost([['B', 'E'], ['E', 'E']]) -1 >>> min_tunnel_cost([['B', 'B'], ['E', 'E']]) 0 >>> min_tunnel_cost([['B', 'E', 'E'], ['E', 'E', 'B']]) 2 >>> min_tunnel_cost([['B', 'E', 'E'], ['E', 'B', 'E'], ['E', 'E', 'B']]) 1 >>> min_tunnel_cost([ ... ['B', 'E', 'E', 'E'], ... ['E', 'E', 'E', 'E'], ... ['E', 'B', 'E', 'B'], ... ['E', 'E', 'E', 'E'], ... ['B', 'E', 'E', 'B'] ... ]) 1","solution":"from collections import deque def min_tunnel_cost(grid): Returns the minimum cost required to connect any two buildings in the grid through empty spaces 'E', or -1 if it is not possible. n, m = len(grid), len(grid[0]) buildings = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 'B'] if len(buildings) < 2: return -1 def bfs(start): visited = [[False] * m for _ in range(n)] queue = deque([(start[0], start[1], 0)]) # (i, j, cost) visited[start[0]][start[1]] = True while queue: i, j, cost = queue.popleft() for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]: if 0 <= x < n and 0 <= y < m and not visited[x][y]: if grid[x][y] == 'B': return cost if grid[x][y] == 'E': visited[x][y] = True queue.append((x, y, cost + 1)) return float('inf') min_cost = float('inf') for building in buildings: min_cost = min(min_cost, bfs(building)) return -1 if min_cost == float('inf') else min_cost"},{"question":"def minPathSum(grid: List[List[int]]) -> int: Calculates the minimum path sum from top-left to bottom-right in a grid. :param grid: List[List[int]], the input grid of integers :return: int, the minimum path sum >>> minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minPathSum([[1, 2, 3, 4]]) 10 >>> minPathSum([[1], [2], [3], [4]]) 10 >>> minPathSum([[5]]) 5 >>> minPathSum([[1, 2, 5], [3, 2, 1]]) 6","solution":"def minPathSum(grid): Calculates the minimum path sum from top-left to bottom-right in a grid. :param grid: List[List[int]], the input grid of integers :return: int, the minimum path sum m = len(grid) n = len(grid[0]) # Initialize dp table for i in range(1, n): grid[0][i] += grid[0][i - 1] for i in range(1, m): grid[i][0] += grid[i - 1][0] # Fill the dp table for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]) return grid[m - 1][n - 1]"},{"question":"def min_prunes_to_ensure_height_difference(arr, d): Returns the minimum number of prunes necessary to ensure that the height difference between every pair of adjacent plants is less than d. >>> min_prunes_to_ensure_height_difference([1, 2, 3, 4], 3) == 0 >>> min_prunes_to_ensure_height_difference([1, 5, 3, 4], 3) == 1 >>> min_prunes_to_ensure_height_difference([1, 8, 12, 10], 5) == 2 >>> min_prunes_to_ensure_height_difference([1, 6, 10, 20], 1) == 3 >>> min_prunes_to_ensure_height_difference([1, 5, 10, 15], 1) == 3 >>> min_prunes_to_ensure_height_difference([0, 0, 0, 0], 2) == 0 >>> min_prunes_to_ensure_height_difference([8, 8, 8, 8], 6) == 0","solution":"def min_prunes_to_ensure_height_difference(arr, d): Returns the minimum number of prunes necessary to ensure that the height difference between every pair of adjacent plants is less than d. prunes = 0 for i in range(len(arr) - 1): while arr[i+1] - arr[i] >= d: arr[i+1] = arr[i] + d - 1 prunes += 1 return prunes"},{"question":"from typing import List def factorial_numbers(n: int) -> List[int]: Returns a list of all factorial numbers less than or equal to n. >>> factorial_numbers(1) == [1] >>> factorial_numbers(2) == [1, 2] >>> factorial_numbers(6) == [1, 2, 6] >>> factorial_numbers(10) == [1, 2, 6] >>> factorial_numbers(24) == [1, 2, 6, 24] >>> factorial_numbers(120) == [1, 2, 6, 24, 120] >>> factorial_numbers(5) == [1, 2] >>> factorial_numbers(7) == [1, 2, 6] >>> factorial_numbers(0) == [] >>> factorial_numbers(-5) == [] >>> factorial_numbers(150) == [1, 2, 6, 24, 120]","solution":"def factorial_numbers(n): Returns a list of all factorial numbers less than or equal to n. if n < 1: return [] factorials = [] i = 1 fact = 1 while fact <= n: factorials.append(fact) i += 1 fact *= i return factorials"},{"question":"def min_moves_to_equal_points(points: List[int]) -> int: Given an integer array points representing the coordinates of points on a number line, return the minimum number of moves required to make all the points equal. A move involves incrementing or decrementing a point by 1. Each move changes a single point by one unit at a time. >>> min_moves_to_equal_points([3, 3, 3, 3]) 0 >>> min_moves_to_equal_points([1, 2]) 1 >>> min_moves_to_equal_points([1, 2, 3, 4]) 4 >>> min_moves_to_equal_points([1, 2, 3, 4, 5]) 6 >>> min_moves_to_equal_points([-1, 2, -4, 3]) 10 >>> min_moves_to_equal_points([1, 1000]) 999 >>> min_moves_to_equal_points([5]) 0 >>> min_moves_to_equal_points([1, 2, 2, 2, 3]) 2","solution":"def min_moves_to_equal_points(points): Given an integer array points, return the minimum number of moves required to make all the points equal. A move involves incrementing or decrementing a point by 1. Parameters: points (list): List of integer coordinates on a number line. Returns: int: Minimum number of moves required. # To minimize the moves, choose the median of the coordinates, # as the median minimizes the sum of absolute deviations. points.sort() median = points[len(points) // 2] # Calculate total moves required to bring all points to the median moves = sum(abs(point - median) for point in points) return moves"},{"question":"class Calendar: A calendar class that can store events on specific dates and perform operations like adding, deleting, and fetching events. Methods: - addEvent(date: str, event: str) -> None: Adds an event on the given date. - removeEvent(date: str, event: str) -> None: Removes a specific event on the given date. - getEvents(date: str) -> List[str]: Returns a list of all events on the given date. Example: >>> cal = Calendar() >>> cal.addEvent(\\"2023-10-10\\", \\"Doctor Appointment\\") >>> cal.getEvents(\\"2023-10-10\\") [\\"Doctor Appointment\\"] >>> cal.addEvent(\\"2023-10-10\\", \\"Meeting\\") >>> cal.getEvents(\\"2023-10-10\\") [\\"Doctor Appointment\\", \\"Meeting\\"] >>> cal.removeEvent(\\"2023-10-10\\", \\"Doctor Appointment\\") >>> cal.getEvents(\\"2023-10-10\\") [\\"Meeting\\"] >>> cal.removeEvent(\\"2023-10-10\\", \\"Meeting\\") >>> cal.getEvents(\\"2023-10-10\\") [] def __init__(self): pass def addEvent(self, date: str, event: str) -> None: pass def removeEvent(self, date: str, event: str) -> None: pass def getEvents(self, date: str) -> List[str]: pass # Example usage: # cal = Calendar() # cal.addEvent(\\"2023-10-10\\", \\"Doctor Appointment\\") # cal.addEvent(\\"2023-10-10\\", \\"Meeting\\") # cal.removeEvent(\\"2023-10-10\\", \\"Doctor Appointment\\") # events = cal.getEvents(\\"2023-10-10\\")","solution":"class Calendar: def __init__(self): self.calendar = {} def addEvent(self, date, event): if date not in self.calendar: self.calendar[date] = [] self.calendar[date].append(event) def removeEvent(self, date, event): if date in self.calendar: if event in self.calendar[date]: self.calendar[date].remove(event) if not self.calendar[date]: # Remove the date if no events left del self.calendar[date] def getEvents(self, date): if date in self.calendar: return self.calendar[date] return [] # Example usage: # cal = Calendar() # cal.addEvent(\\"2023-10-10\\", \\"Doctor Appointment\\") # cal.addEvent(\\"2023-10-10\\", \\"Meeting\\") # cal.removeEvent(\\"2023-10-10\\", \\"Doctor Appointment\\") # events = cal.getEvents(\\"2023-10-10\\")"},{"question":"def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merge all overlapping intervals and return the list of intervals in sorted order by start points. >>> merge_intervals([]) == [] >>> merge_intervals([[1, 2], [3, 4], [6, 7]]) == [[1, 2], [3, 4], [6, 7]] >>> merge_intervals([[1, 3], [2, 4], [5, 7]]) == [[1, 4], [5, 7]] >>> merge_intervals([[1, 4], [2, 3]]) == [[1, 4]] >>> merge_intervals([[1, 10], [2, 6], [8, 10]]) == [[1, 10]] >>> merge_intervals([[1, 5], [2, 3], [4, 8]]) == [[1, 8]] >>> merge_intervals([[1, 2], [2, 3], [3, 4]]) == [[1, 4]] >>> merge_intervals([[1, 5], [5, 10]]) == [[1, 10]]","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns the list of merged intervals. if not intervals: return [] # Sort the intervals by the starting point intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # If merged list is empty or if there is no overlap with the last interval in merged if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # There is an overlap, merge the current interval merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"from typing import List def least_interval(tasks: List[str], n: int) -> int: Returns the minimum time required to complete all tasks given the cooldown period \`n\`. >>> least_interval(['A', 'A', 'A', 'B', 'B', 'B'], 2) 8 >>> least_interval(['A', 'A', 'A', 'B', 'B', 'B'], 0) 6 >>> least_interval(['A', 'A', 'A', 'A', 'A', 'A'], 2) 16 >>> least_interval(['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C'], 2) 9 >>> least_interval(['A', 'B', 'C', 'D', 'E', 'F'], 1) 6 >>> least_interval(['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C'], 3) 11","solution":"from collections import Counter def least_interval(tasks, n): Returns the minimum time required to complete all tasks given the cooldown period \`n\`. task_counts = Counter(tasks) max_count = max(task_counts.values()) max_count_tasks = list(task_counts.values()).count(max_count) part_count = max_count - 1 part_length = n - (max_count_tasks - 1) empty_slots = part_count * part_length available_tasks = len(tasks) - max_count * max_count_tasks idles = max(0, empty_slots - available_tasks) return len(tasks) + idles"},{"question":"from typing import List def min_changes_to_sort_heights(heights: List[int]) -> int: Arrange the heights of students in a class in non-decreasing order. Return the minimum number of changes required to turn heights into a non-decreasing order array. A change consists of moving one student to a different place in the array. >>> min_changes_to_sort_heights([5, 3, 4, 2, 1]) 3 >>> min_changes_to_sort_heights([1, 2, 3, 4, 5]) 0 >>> min_changes_to_sort_heights([5, 4, 3, 2, 1]) 4 >>> min_changes_to_sort_heights([2, 1, 5, 4, 3]) 3 >>> min_changes_to_sort_heights([1, 1, 1, 1]) 0 >>> min_changes_to_sort_heights([]) 0","solution":"def min_changes_to_sort_heights(heights): n = len(heights) if n == 0: return 0 sorted_heights = sorted(heights) # We will find the longest common subsequence (LCS) between heights and sorted_heights. # The minimum number of changes required will be the length of the array minus the length of the LCS. dp = [[0] * (n + 1) for _ in range(n + 1)] for i in range(n): for j in range(n): if heights[i] == sorted_heights[j]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]) lcs_length = dp[n][n] return n - lcs_length"},{"question":"from typing import List def is_path(grid: List[List[int]]) -> bool: Determines if there exists a path from the top-left cell to the bottom-right cell such that all cells along the path have the same value. :param grid: List[List[int]] - 2D list of integers :return: bool - True if such a path exists, else False >>> is_path([]) False >>> is_path([[1]]) True >>> is_path([[1, 2], [2, 1]]) False >>> is_path([[1, 1, 1], [2, 2, 1], [2, 2, 1]]) True >>> is_path([[1, 1, 2], [2, 1, 2], [2, 2, 2]]) False >>> is_path([[1, 1, 1, 1], [2, 1, 2, 1], [2, 1, 2, 1], [2, 2, 2, 1]]) True >>> is_path([[1, 2, 3, 1], [2, 1, 2, 4], [3, 3, 3, 1], [4, 4, 4, 4]]) False","solution":"from collections import deque def is_path(grid): Determines if there exists a path from the top-left cell to the bottom-right cell such that all cells along the path have the same value. :param grid: List[List[int]] - 2D list of integers :return: bool - True if such a path exists, else False if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) target_value = grid[0][0] visited = set() directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(r, c): queue = deque([(r, c)]) visited.add((r, c)) while queue: x, y = queue.popleft() if (x, y) == (rows - 1, cols - 1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == target_value: visited.add((nx, ny)) queue.append((nx, ny)) return False return bfs(0, 0)"},{"question":"from typing import List def is_tree(n: int, edges: List[List[int]]) -> bool: Determine if the given graph is a tree. >>> is_tree(5, [[1, 2], [1, 3], [2, 4], [2, 5]]) True >>> is_tree(4, [[1, 2], [2, 3], [3, 4], [4, 1]]) False","solution":"def is_tree(n, edges): Determine if the given graph is a tree. :param n: int - Number of nodes. :param edges: List[List[int]] - List of bidirectional edges. :return: bool - True if the graph is a tree, otherwise False. if len(edges) != n - 1: return False from collections import defaultdict, deque adj_list = defaultdict(list) for a, b in edges: adj_list[a].append(b) adj_list[b].append(a) visited = set() def bfs(start_node): queue = deque([start_node]) while queue: node = queue.popleft() if node in visited: continue visited.add(node) for neighbor in adj_list[node]: if neighbor not in visited: queue.append(neighbor) bfs(1) return len(visited) == n"},{"question":"def findMaxLength(nums: str) -> int: Returns the length of the longest contiguous subarray with an equal number of 0's and 1's. >>> findMaxLength(\\"110\\") == 2 >>> findMaxLength(\\"11010\\") == 4 >>> findMaxLength(\\"000111\\") == 6 >>> findMaxLength(\\"10101\\") == 4 >>> findMaxLength(\\"0000\\") == 0 >>> findMaxLength(\\"1111\\") == 0 >>> findMaxLength(\\"0101\\") == 4 >>> findMaxLength(\\"0\\") == 0 >>> findMaxLength(\\"1\\") == 0 >>> findMaxLength(\\"101010\\") == 6 >>> findMaxLength(\\"\\") == 0","solution":"def findMaxLength(nums): Returns the length of the longest contiguous subarray with an equal number of 0's and 1's. Parameters: nums (str): A binary string consisting of '0's and '1's. Returns: int: Length of the longest contiguous subarray with equal number of 0's and 1's. # Dictionary to store the first occurrence of each count count_map = {0: -1} max_length = 0 count = 0 for i, num in enumerate(nums): # Update count: +1 for 1 and -1 for 0 count += 1 if num == '1' else -1 if count in count_map: # If the count has been seen before, it means there is a subarray from # the previous index to the current index with equal number of 0's and 1's max_length = max(max_length, i - count_map[count]) else: # Otherwise, store the index for this count count_map[count] = i return max_length"},{"question":"def rob(nums: List[int]) -> int: Determine the maximum amount of money the thief can rob without alerting the police. >>> rob([]) == 0 >>> rob([10]) == 10 >>> rob([1, 2]) == 2 >>> rob([2, 3, 2]) == 4 >>> rob([1, 2, 3, 1]) == 4 >>> rob([2, 7, 9, 3, 1]) == 12 >>> rob([2, 1, 1, 2]) == 4 >>> rob([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 30","solution":"def rob(nums): Determine the maximum amount of money the thief can rob without alerting the police. :param nums: List[int] :return: int if not nums: return 0 n = len(nums) if n == 1: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def longest_word(words: List[str]) -> str: Find the longest word that can be built one character at a time by other words in words. :param words: List of strings :return: Longest word that can be built one character at a time pass from typing import List import pytest def test_single_letter_words(): assert longest_word([\\"a\\", \\"b\\", \\"c\\"]) == \\"a\\" def test_given_example(): assert longest_word([\\"w\\",\\"wo\\",\\"wor\\",\\"worl\\",\\"world\\"]) == \\"world\\" def test_no_valid_words(): assert longest_word([\\"a\\", \\"banana\\", \\"app\\", \\"appl\\", \\"ap\\", \\"apply\\", \\"apple\\"]) == \\"apple\\" def test_lexicographically_smallest(): assert longest_word([\\"a\\", \\"aa\\", \\"aaa\\", \\"aab\\"]) == \\"aaa\\" def test_empty_words(): assert longest_word([]) == \\"\\" def test_all_disjoint_words(): assert longest_word([\\"dog\\", \\"cat\\", \\"apple\\"]) == \\"\\"","solution":"def longest_word(words): Find the longest word that can be built one character at a time by other words in words. :param words: List of strings :return: Longest word that can be built one character at a time words.sort() word_set, longest = set(['']), '' for word in words: if word[:-1] in word_set: word_set.add(word) if len(word) > len(longest): longest = word return longest"},{"question":"def trap_rain_water(heights): Returns the total amount of trapped rain water given the heights of buildings. :param heights: List of integers representing the heights of buildings. :return: Total volume of trapped rain water. >>> trap_rain_water([]) == 0 >>> trap_rain_water([1, 2, 3, 4, 5]) == 0 >>> trap_rain_water([5, 4, 3, 2, 1]) == 0 >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 >>> trap_rain_water([3, 3, 3, 3, 3]) == 0 >>> trap_rain_water([3, 0, 3]) == 3 >>> trap_rain_water([3, 0, 2, 0, 4]) == 7","solution":"def trap_rain_water(heights): Returns the total amount of trapped rain water given the heights of buildings. :param heights: List of integers representing the heights of buildings. :return: Total volume of trapped rain water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"def longest_power_group(arr: List[int], P: int) -> int: Given an array of \`n\` integers, return the length of the longest contiguous subarray such that the sum of the power levels in the subarray is less than or equal to a given integer \`P\`. >>> longest_power_group([1, 2, 3], 3) == 2 >>> longest_power_group([2, 2, 2, 2], 4) == 2 >>> longest_power_group([], 10) == 0 >>> longest_power_group([10, 11, 12], 5) == 0 >>> longest_power_group([1, 1, 1, 1], 4) == 4 >>> longest_power_group([1, 2, 3, 4, 5], 7) == 3","solution":"def longest_power_group(arr, P): Returns the length of the longest contiguous subarray such that the sum of the subarray is less than or equal to P. max_len = 0 current_sum = 0 start = 0 for end in range(len(arr)): current_sum += arr[end] while current_sum > P: current_sum -= arr[start] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"from typing import List def group_anagrams(strs: List[str]) -> List[List[str]]: Given a list of n strings, group the anagrams together. Parameters: strs (List[str]): List of strings containing lowercase alphabets. Returns: List[List[str]]: List of lists where each sublist is a group of anagram strings. Example: >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] # Test cases def test_group_anagrams_example_case(): input_data = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] expected_output = [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] result = group_anagrams(input_data) for group in expected_output: assert sorted(group) in [sorted(g) for g in result] def test_group_anagrams_single_word(): input_data = [\\"abc\\"] expected_output = [[\\"abc\\"]] result = group_anagrams(input_data) for group in expected_output: assert sorted(group) in [sorted(g) for g in result] def test_group_anagrams_no_anagrams(): input_data = [\\"abc\\", \\"def\\", \\"ghi\\"] expected_output = [[\\"abc\\"], [\\"def\\"], [\\"ghi\\"]] result = group_anagrams(input_data) for group in expected_output: assert sorted(group) in [sorted(g) for g in result] def test_group_anagrams_all_anagrams(): input_data = [\\"abc\\", \\"bca\\", \\"cab\\"] expected_output = [[\\"abc\\", \\"bca\\", \\"cab\\"]] result = group_anagrams(input_data) for group in expected_output: assert sorted(group) in [sorted(g) for g in result] def test_group_anagrams_mixed_case(): input_data = [\\"aab\\", \\"aba\\", \\"baa\\", \\"abc\\", \\"bac\\"] expected_output = [[\\"aab\\", \\"aba\\", \\"baa\\"], [\\"abc\\", \\"bac\\"]] result = group_anagrams(input_data) for group in expected_output: assert sorted(group) in [sorted(g) for g in result]","solution":"from collections import defaultdict def group_anagrams(strs): Groups anagrams together from a list of strings. Parameters: strs (List[str]): List of strings. Returns: List[List[str]]: List of lists where each sublist contains anagrams. anagrams = defaultdict(list) for s in strs: # Sorting the string to find the anagrams sorted_str = ''.join(sorted(s)) anagrams[sorted_str].append(s) return list(anagrams.values())"},{"question":"def findOrder(numCourses: int, prerequisites: List[List[int]]) -> List[int]: Returns an ordering of courses to take to finish all courses given the prerequisite pairs. If it is impossible to finish all courses, returns an empty list. >>> findOrder(4, []) [0, 1, 2, 3] >>> findOrder(4, [[1, 0], [2, 1], [3, 2]]) [0, 1, 2, 3] >>> findOrder(4, [[1, 0], [2, 0], [3, 1], [3, 2]]) in [[0, 1, 2, 3], [0, 2, 1, 3]] True >>> findOrder(2, [[1, 0], [0, 1]]) [] >>> order = findOrder(5, [[1, 0], [2, 1], [4, 3]]); order.index(0) < order.index(1) and order.index(1) < order.index(2) and order.index(3) < order.index(4) True >>> order = findOrder(6, [[1, 0], [2, 1], [3, 2], [4, 3], [5, 2]]); order.index(0) < order.index(1) and order.index(1) < order.index(2) and order.index(2) < order.index(3) and order.index(2) < order.index(5) and order.index(3) < order.index(4) True >>> order = findOrder(4, [[1, 0], [2, 3]]); order.index(0) < order.index(1) and order.index(3) < order.index(2) True","solution":"from collections import defaultdict, deque def findOrder(numCourses, prerequisites): Returns an ordering of courses to take to finish all courses given the prerequisite pairs. If it is impossible to finish all courses, returns an empty list. # Create adjacency list and in-degrees array graph = defaultdict(list) in_degree = [0] * numCourses # Populate the graph and in-degrees array for course, prereq in prerequisites: graph[prereq].append(course) in_degree[course] += 1 # Find all nodes with no incoming edges zero_in_degree_queue = deque([i for i in range(numCourses) if in_degree[i] == 0]) order = [] # Process nodes with no incoming edges while zero_in_degree_queue: current_course = zero_in_degree_queue.popleft() order.append(current_course) # Decrease the in-degree of the neighboring nodes for neighbor in graph[current_course]: in_degree[neighbor] -= 1 # If in-degree becomes zero, add to the queue if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If the order contains all the courses, return it, otherwise return an empty array return order if len(order) == numCourses else []"},{"question":"from collections import defaultdict, deque def find_project_order(projects, dependencies): Determines the order of projects given the dependencies. :param projects: A list of projects :param dependencies: A list of dependencies where each element is a pair [Ai, Bi] indicating that project Bi can begin only after project Ai is completed. :return: A list of projects in the order they should be completed or an empty list if there is a cyclic dependency. >>> find_project_order(['A', 'B', 'C'], []) ['A', 'B', 'C'] >>> find_project_order(['A', 'B', 'C'], [['A', 'B'], ['B', 'C']]) ['A', 'B', 'C'] >>> find_project_order(['A', 'B', 'C', 'D'], [['A', 'B'], ['A', 'C'], ['B', 'D'], ['C', 'D']]) ['A', 'B', 'C', 'D'] >>> find_project_order(['A', 'B', 'C'], [['A', 'B'], ['B', 'C'], ['C', 'A']]) [] >>> find_project_order(['A', 'B', 'C', 'D', 'E', 'F'], [['A', 'D'], ['F', 'B'], ['B', 'D'], ['F', 'A'], ['D', 'C']]) ['E', 'F', 'A', 'B', 'D', 'C']","solution":"from collections import defaultdict, deque def find_project_order(projects, dependencies): Determines the order of projects given the dependencies. :param projects: A list of projects :param dependencies: A list of dependencies where each element is a pair [Ai, Bi] indicating that project Bi can begin only after project Ai is completed. :return: A list of projects in the order they should be completed or an empty list if there is a cyclic dependency. # Create a graph graph = defaultdict(list) in_degree = {project: 0 for project in projects} for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Find all nodes with no incoming edges queue = deque([project for project in projects if in_degree[project] == 0]) order = [] while queue: current = queue.popleft() order.append(current) for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == len(projects): return order else: return []"},{"question":"from typing import List def findMaxLength(nums: List[int]) -> int: Given an integer array nums consisting of n integers, find and return the length of the longest contiguous subarray with an equal number of 1s and 0s. >>> findMaxLength([1, 1, 1, 1, 1]) 0 >>> findMaxLength([0, 0, 0, 0, 0]) 0 >>> findMaxLength([0, 1, 0]) 2 >>> findMaxLength([0, 1, 0, 0, 1, 1, 0, 0]) 6 >>> findMaxLength([0, 1, 1, 0, 0, 1, 0, 1, 1, 0]) 10 >>> findMaxLength([1, 1, 0, 0]) 4 >>> findMaxLength([1]) 0 >>> findMaxLength([0]) 0 >>> findMaxLength([0, 1, 0, 1, 0, 1, 1]) 6","solution":"def findMaxLength(nums): count_map = {0: -1} max_length = 0 count = 0 for i, num in enumerate(nums): count += 1 if num == 1 else -1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"def minimize_difference(arr: List[int], m: int) -> int: Partition the array 'arr' into 'm' subarrays such that the difference between the maximum and minimum values of the largest and smallest subarrays (in terms of sum) is minimized. Returns the minimized difference. >>> minimize_difference([7, 2, 5, 10, 8], 2) 18 >>> minimize_difference([2, 2, 2, 2, 2], 2) 6 >>> minimize_difference([1, 3, 5], 1) 9 >>> minimize_difference([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) 17 >>> minimize_difference([1, 2, 3, 9, 10], 5) 10","solution":"def minimize_difference(arr, m): Partition the array 'arr' into 'm' subarrays such that the difference between the maximum and minimum values of the largest and smallest subarrays (in terms of sum) is minimized. Returns the minimized difference. def can_partition(max_sum): count, current_sum = 1, 0 for num in arr: if current_sum + num > max_sum: count += 1 current_sum = num if count > m: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_partition(mid): right = mid else: left = mid + 1 return left"},{"question":"class ListNode: def __init__(self, x=0, next=None): self.val = x self.next = next def addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode: Add two numbers represented by linked lists in reverse order. Each Node contains a single digit. >>> create_linked_list = lambda vals: ListNode(vals[0]) if not vals else ListNode(vals[0], create_linked_list(vals[1:])) >>> linked_list_to_list = lambda node: [] if node is None else [node.val] + linked_list_to_list(node.next) >>> l1 = create_linked_list([2, 4, 3]) >>> l2 = create_linked_list([5, 6, 4]) >>> result = addTwoNumbers(l1, l2) >>> linked_list_to_list(result) [7, 0, 8] >>> l1 = create_linked_list([0]) >>> l2 = create_linked_list([0]) >>> result = addTwoNumbers(l1, l2) >>> linked_list_to_list(result) [0] >>> l1 = create_linked_list([9, 9, 9]) >>> l2 = create_linked_list([1]) >>> result = addTwoNumbers(l1, l2) >>> linked_list_to_list(result) [0, 0, 0, 1] # your code here","solution":"class ListNode: def __init__(self, x=0, next=None): self.val = x self.next = next def addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode: dummy_head = ListNode(0) current = dummy_head carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 total_sum = val1 + val2 + carry carry = total_sum // 10 current.next = ListNode(total_sum % 10) current = current.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy_head.next"},{"question":"from typing import List import heapq from collections import Counter def rearrange_string(text: str, k: int) -> str: Rearrange the string such that no two adjacent characters are the same. If it is impossible, return an empty string. Return the lexicographically smallest one if multiple rearrangements are possible. Args: text (str): A string of alphabetic characters. k (int): A positive integer less than or equal to the length of the given string. Returns: str: The rearranged string or an empty string if rearrangement is not possible. Examples: >>> rearrange_string(\\"aabbcc\\", 3) == \\"abcabc\\" >>> rearrange_string(\\"aaabc\\", 2) in [\\"abaca\\", \\"acaba\\"]","solution":"import heapq from collections import Counter def rearrange_string(text, k): if k == 1: return ''.join(sorted(text)) counter = Counter(text) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) result = [] # To maintain the characters that are within 'k' distance. wait_queue = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) # Decrease the count and add to wait_queue wait_queue.append((count + 1, char)) if len(wait_queue) >= k: prev_count, prev_char = wait_queue.pop(0) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) result = ''.join(result) if len(result) != len(text): return \\"\\" return result"},{"question":"def findWords(board: List[List[str]], words: List[str]) -> List[str]: Return all words on the board that are in the list of words. Each word must be constructed from letters of sequentially adjacent cells, where 'adjacent' cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. >>> findWords([ ... ['o','a','a','n'], ... ['e','t','a','e'], ... ['i','h','k','r'], ... ['i','f','l','v'] ... ], [\\"oath\\"]) [\\"oath\\"] >>> findWords([ ... ['o','a','a','n'], ... ['e','t','a','e'], ... ['i','h','k','r'], ... ['i','f','l','v'] ... ], [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"]) [\\"oath\\", \\"eat\\"] from solution import findWords def test_findWords_single_word(): board = [ ['o','a','a','n'], ['e','t','a','e'], ['i','h','k','r'], ['i','f','l','v'] ] words = [\\"oath\\"] assert set(findWords(board, words)) == {\\"oath\\"} def test_findWords_multiple_words(): board = [ ['o','a','a','n'], ['e','t','a','e'], ['i','h','k','r'], ['i','f','l','v'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] assert set(findWords(board, words)) == {\\"oath\\", \\"eat\\"} def test_findWords_empty_board(): board = [] words = [\\"word\\"] assert findWords(board, words) == [] def test_findWords_no_words_found(): board = [ ['o','a','a','n'], ['e','t','a','e'], ['i','h','k','r'], ['i','f','l','v'] ] words = [\\"xyz\\", \\"abc\\"] assert findWords(board, words) == [] def test_findWords_board_with_overlapping_words(): board = [ ['o','a','b','n'], ['e','t','a','e'], ['i','h','k','r'], ['i','f','l','v'] ] words = [\\"oath\\", \\"bath\\"] assert set(findWords(board, words)) == {\\"oath\\", \\"bath\\"}","solution":"class TrieNode: def __init__(self): self.children = {} self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_word = True def findWords(board, words): def dfs(board, node, i, j, path, visited, result): if node.is_word: result.add(path) node.is_word = False # avoid duplicate word entries if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] not in node.children or (i, j) in visited: return visited.add((i, j)) char = board[i][j] next_node = node.children[char] for x, y in [(0, 1), (1, 0), (0, -1), (-1, 0)]: dfs(board, next_node, i + x, j + y, path + char, visited, result) visited.remove((i, j)) if not board or not board[0]: return [] trie = Trie() for word in words: trie.insert(word) result = set() for i in range(len(board)): for j in range(len(board[0])): visited = set() dfs(board, trie.root, i, j, '', visited, result) return list(result)"},{"question":"def longest_single_char_substring(s: str) -> int: Given a string s representing a sentence that consists of words and spaces, find the length of the longest contiguous substring that contains only a single unique character. A substring may be as short as one character. Return the length of this substring. >>> longest_single_char_substring(\\"aaabbbaac\\") == 3 >>> longest_single_char_substring(\\"a\\") == 1 >>> longest_single_char_substring(\\"abababab\\") == 1 >>> longest_single_char_substring(\\"aaabbbcccc\\") == 4 >>> longest_single_char_substring(\\"\\") == 0 >>> longest_single_char_substring(\\"aabbccdd\\") == 2 >>> longest_single_char_substring(\\"abcd\\") == 1 >>> longest_single_char_substring(\\"aaaa\\") == 4 >>> longest_single_char_substring(\\"a bb ccc dddd\\") == 4 >>> longest_single_char_substring(\\" \\") == 4 >>> longest_single_char_substring(\\"a b c d e f g h i j k\\") == 1 >>> longest_single_char_substring(\\"!@#%%^^^&&&&\\") == 4 >>> longest_single_char_substring(\\"ab!!cdef\\") == 4","solution":"def longest_single_char_substring(s): Returns the length of the longest contiguous substring that contains only a single unique character. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: current_length = 1 if current_length > max_length: max_length = current_length return max_length"},{"question":"def max_channels(channels: List[int], B: int) -> int: Returns the maximum number of channels that can be allocated without exceeding the total bandwidth B. :param channels: List of integers representing the bandwidth requirements of each channel :param B: Integer representing the total available bandwidth :return: Integer representing the maximum number of channels that can be allocated without exceeding B >>> max_channels([2, 1, 3, 4], 5) 2 >>> max_channels([3, 3, 3], 2) 0 >>> max_channels([2, 1, 2], 5) 3 >>> max_channels([1, 2, 3, 4], 10) 4 >>> max_channels([5], 5) 1 >>> max_channels([6], 5) 0 >>> max_channels([4, 2, 1, 6], 9) 3 >>> max_channels([0, 0, 0, 0], 1) 4 >>> max_channels([3, 2, 1], 6) 3","solution":"def max_channels(channels, B): Returns the maximum number of channels that can be allocated without exceeding the total bandwidth B. :param channels: List of integers representing the bandwidth requirements of each channel :param B: Integer representing the total available bandwidth :return: Integer representing the maximum number of channels that can be allocated without exceeding B channels.sort() total_bandwidth = 0 count = 0 for bandwidth in channels: if total_bandwidth + bandwidth <= B: total_bandwidth += bandwidth count += 1 else: break return count"},{"question":"def compress_string(s: str) -> str: Compresses the string using the described rules and returns the compressed string if it is shorter, otherwise returns the original string. Parameters: s (str): The input string consisting of lowercase letters. Returns: str: The compressed version of the string if it is shorter, otherwise the original string. >>> compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" >>> compress_string(\\"abcdef\\") == \\"abcdef\\" >>> compress_string(\\"aabbbcccc\\") == \\"a2b3c4\\" >>> compress_string(\\"a\\") == \\"a\\" >>> compress_string(\\"\\") == \\"\\" >>> compress_string(\\"aaabccccaaa\\") == \\"a3b1c4a3\\" >>> compress_string(\\"abcdefghij\\") == \\"abcdefghij\\" >>> compress_string(\\"aaaaaa\\") == \\"a6\\"","solution":"def compress_string(s): Compresses the string using the described rules and returns the compressed string if it is shorter, otherwise returns the original string. Parameters: s (str): The input string consisting of lowercase letters. Returns: str: The compressed version of the string if it is shorter, otherwise the original string. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(f\\"{s[i - 1]}{count}\\") count = 1 compressed.append(f\\"{s[-1]}{count}\\") compressed_str = ''.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"from typing import List, Tuple def can_make_palindrome(s: str, queries: List[Tuple[int, int, int]]) -> List[bool]: Given a string \`s\` and a list of queries \`(left, right, k)\`, determine if the substring \`s[left:right+1]\` can be made a palindrome by changing at most \`k\` characters. >>> can_make_palindrome(\\"abcba\\", [(0, 4, 0), (1, 3, 0), (0, 1, 1), (2, 4, 1)]) [True, True, True, True] >>> can_make_palindrome(\\"abcde\\", [(0, 4, 2), (0, 4, 1), (1, 3, 1), (2, 4, 0)]) [True, False, True, False] >>> can_make_palindrome(\\"abcde\\", [(0, 4, 0), (0, 2, 0), (1, 3, 0), (2, 4, 0)]) [False, False, False, False] >>> can_make_palindrome(\\"a\\", [(0, 0, 0), (0, 0, 1)]) [True, True] >>> can_make_palindrome(\\"\\", []) [] >>> can_make_palindrome(\\"abccba\\", [(0, 1, 0), (0, 2, 1), (0, 5, 0), (2, 5, 2)]) [False, True, True, True] pass","solution":"def can_make_palindrome(s, queries): def can_be_palindrome(subs, k): left, right = 0, len(subs) - 1 changes = 0 while left < right: if subs[left] != subs[right]: changes += 1 left += 1 right -= 1 return changes <= k results = [] for left, right, k in queries: substring = s[left:right+1] results.append(can_be_palindrome(substring, k)) return results"},{"question":"def can_reach_in_k_moves(grid: List[List[int]], k: int) -> List[str]: Determine if the robot can reach the bottom-right corner of the grid in exactly k moves. Parameters: grid (list of lists): A 2D list representing the grid. k (int): The exact number of moves to reach the bottom-right corner. Returns: list: A list of directions (\\"down\\", \\"right\\", \\"stay\\") representing the path if possible, otherwise an empty list. >>> can_reach_in_k_moves([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 4) [\\"right\\", \\"down\\", \\"down\\", \\"stay\\"] >>> can_reach_in_k_moves([[0, 0], [0, 0]], 1) [] >>> can_reach_in_k_moves([[0]], 0) [] >>> can_reach_in_k_moves([[0] * 10 for _ in range(10)], 18) [\\"right\\", \\"right\\", \\"right\\", \\"right\\", \\"right\\", \\"right\\", \\"right\\", \\"right\\", \\"right\\", \\"right\\", \\"down\\", \\"down\\", \\"down\\", \\"down\\", \\"down\\", \\"down\\", \\"down\\", \\"down\\"] >>> can_reach_in_k_moves([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 5) [\\"right\\", \\"right\\", \\"down\\", \\"down\\", \\"stay\\"]","solution":"def can_reach_in_k_moves(grid, k): Determine if the robot can reach the bottom-right corner of the grid in exactly k moves. Parameters: grid (list of lists): A 2D list representing the grid. k (int): The exact number of moves to reach the bottom-right corner. Returns: list: A list of directions (\\"down\\", \\"right\\", \\"stay\\") representing the path if possible, otherwise an empty list. m, n = len(grid), len(grid[0]) def dfs(x, y, moves_left, path): if x == m - 1 and y == n - 1: if moves_left == 0: return path else: return [] if moves_left <= 0: return [] # Try moving down if x + 1 < m: result = dfs(x + 1, y, moves_left - 1, path + [\\"down\\"]) if result: return result # Try moving right if y + 1 < n: result = dfs(x, y + 1, moves_left - 1, path + [\\"right\\"]) if result: return result # Try staying in the same place result = dfs(x, y, moves_left - 1, path + [\\"stay\\"]) if result: return result return [] return dfs(0, 0, k, [])"},{"question":"from typing import List def can_reach_end(grid: List[List[int]]) -> bool: Determines whether there is a valid path from the top-left to the bottom-right in the grid. You are allowed to move down, left, right, or up if the value in the next cell is greater than the value in the current cell. >>> can_reach_end([[1, 3, 2], [3, 2, 1], [2, 1, 0]]) == False >>> can_reach_end([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) == True >>> can_reach_end([[0]]) == True >>> can_reach_end([[0, 0], [0, 0]]) == False >>> can_reach_end([[1, 4, 5], [2, 3, 6], [7, 8, 9]]) == True >>> can_reach_end([]) == False >>> can_reach_end([[10, 30, 25], [20, 35, 29], [21, 40, 50]]) == True","solution":"def can_reach_end(grid): Determines whether there is a valid path from the top-left to the bottom-right in the grid. You are allowed to move down, left, right, or up if the value in the next cell is greater than the value in the current cell. :param grid: List[List[int]] - 2D list representing the grid :return: bool - True if a valid path exists, False otherwise if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] def dfs(r, c): if r == rows - 1 and c == cols - 1: return True visited[r][c] = True for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] > grid[r][c]: if dfs(nr, nc): return True return False return dfs(0, 0)"},{"question":"def shortest_subsequence_length(sequence: str) -> int: Given a string sequence consisting of only characters 'A' and 'B', return the length of the shortest subsequence of sequence such that it cannot be found as a contiguous part of sequence more than twice. A subsequence is derived from another string by deleting some or no characters while maintaining the relative positions of the remaining characters. >>> shortest_subsequence_length(\\"AAAA\\") 2 >>> shortest_subsequence_length(\\"BBBB\\") 2 >>> shortest_subsequence_length(\\"ABAB\\") 3 >>> shortest_subsequence_length(\\"AABBAA\\") 3 >>> shortest_subsequence_length(\\"A\\") 2 >>> shortest_subsequence_length(\\"B\\") 2 >>> shortest_subsequence_length(\\"\\") 2","solution":"def shortest_subsequence_length(sequence): if 'A' not in sequence or 'B' not in sequence: return 2 # The shortest subsequence would be \\"AB\\" or \\"BA\\" else: return 3 # The shortest subsequence would be \\"ABA\\" or \\"BAB\\""},{"question":"def find_repeated_dna_sequences(s: str) -> list: Returns all 10-letter-long sequences that occur more than once in the given DNA string. >>> find_repeated_dna_sequences(\\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\\") [\\"AAAAACCCCC\\", \\"CCCCCAAAAA\\"] >>> find_repeated_dna_sequences(\\"\\") [] >>> find_repeated_dna_sequences(\\"ACGTACGTAC\\") [] >>> find_repeated_dna_sequences(\\"AAAAAAAAAAAA\\") [\\"AAAAAAAAAA\\"] >>> find_repeated_dna_sequences(\\"AAAAAAAAAAAACCCCCCCCCCC\\") [\\"AAAAAAAAAA\\", \\"CCCCCCCCCC\\"]","solution":"def find_repeated_dna_sequences(s): Returns all 10-letter-long sequences that occur more than once in the given DNA string. sequences = {} for i in range(len(s) - 9): sequence = s[i:i+10] if sequence in sequences: sequences[sequence] += 1 else: sequences[sequence] = 1 repeated_sequences = [sequence for sequence, count in sequences.items() if count > 1] return repeated_sequences"},{"question":"def word_pattern(pattern: str, s: str) -> bool: Implement word pattern matching such that matches occur according to the specified pattern of characters. Each character in the pattern should map to a distinct word in the string s. >>> word_pattern(\\"abba\\", \\"dog cat cat dog\\") True >>> word_pattern(\\"abba\\", \\"dog cat cat fish\\") False >>> word_pattern(\\"aaaa\\", \\"dog cat cat dog\\") False >>> word_pattern(\\"a\\", \\"dog\\") True >>> word_pattern(\\"ab\\", \\"dog dog\\") False >>> word_pattern(\\"\\", \\"\\") True >>> word_pattern(\\"ab\\", \\"dog cat cat\\") False >>> word_pattern(\\"abcd\\", \\"dog cat dog cat\\") False","solution":"def word_pattern(pattern, s): Returns True if the string s matches the given pattern, False otherwise. Each character in the pattern should map to a distinct word in the string s. words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: if word in word_to_char and word_to_char[word] != char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"def unique_paths_with_obstacles(obstacle_grid: List[List[int]]) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner on an m x n grid with obstacles, represented by 1s. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 6 >>> unique_paths_with_obstacles([[0, 1], [0, 0]]) 1 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 1]]) 0 >>> unique_paths_with_obstacles([[0]]) 1 >>> unique_paths_with_obstacles([[1]]) 0 >>> unique_paths_with_obstacles([[0, 0, 1], [0, 1, 0], [0, 0, 0]]) 1","solution":"def unique_paths_with_obstacles(obstacle_grid): Returns the number of unique paths from the top-left corner to the bottom-right corner on an m x n grid with obstacles, represented by 1s. :param obstacle_grid: List[List[int]] - A 2D grid with obstacles (1s) and empty spaces (0s). :return: int - The number of unique paths from the top-left to the bottom-right corner. if not obstacle_grid or obstacle_grid[0][0] == 1 or obstacle_grid[-1][-1] == 1: return 0 m, n = len(obstacle_grid), len(obstacle_grid[0]) # Initialize the dp array with 0s dp = [[0] * n for _ in range(m)] # Start point dp[0][0] = 1 # Fill the dp array for i in range(m): for j in range(n): if obstacle_grid[i][j] == 1: dp[i][j] = 0 # No paths through an obstacle else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[m-1][n-1]"},{"question":"from typing import List def partition_string_max_unique_length(s: str, k: int) -> int: Partitions the string into k contiguous substrings and returns the maximum length of unique characters that can be present across these substrings combined. If it's not possible to partition the string into k substrings, return -1. >>> partition_string_max_unique_length(\\"abc\\", 4) -1 >>> partition_string_max_unique_length(\\"abcd\\", 4) 4 >>> partition_string_max_unique_length(\\"abcde\\", 3) 3 >>> partition_string_max_unique_length(\\"aabcde\\", 2) 2 >>> partition_string_max_unique_length(\\"aabbcc\\", 3) 3 >>> partition_string_max_unique_length(\\"aaaaa\\", 2) 1 >>> partition_string_max_unique_length(\\"aaaaa\\", 5) 1 >>> partition_string_max_unique_length(\\"abcdef\\", 1) 1","solution":"def partition_string_max_unique_length(s, k): Partitions the string into k contiguous substrings and returns the maximum length of unique characters that can be present across these substrings combined. If it's not possible to partition the string into k substrings, return -1. if k > len(s): return -1 unique_chars = set(s) return min(len(unique_chars), k) # Note: This is a simplified logic to fulfill the basic condition checks. # Actual logic may involve more complex partitioning strategies."},{"question":"def reverse_vowels(s: str) -> str: Given a string s, return the string after reversing all the vowels in s. The vowels are defined as 'a', 'e', 'i', 'o', 'u' (both lowercase and uppercase). >>> reverse_vowels(\\"aeiou\\") \\"uoiea\\" >>> reverse_vowels(\\"AEIOU\\") \\"UOIEA\\" >>> reverse_vowels(\\"bcdfghjklmnpqrstvwxz\\") \\"bcdfghjklmnpqrstvwxz\\" >>> reverse_vowels(\\"Hello\\") \\"Holle\\" >>> reverse_vowels(\\"leetcode\\") \\"leotcede\\" >>> reverse_vowels(\\"a\\") \\"a\\" >>> reverse_vowels(\\"c\\") \\"c\\" >>> reverse_vowels(\\"\\") \\"\\" >>> reverse_vowels(\\"A man a plan a canal Panama\\") \\"a man a plan a canal PanamA\\"","solution":"def reverse_vowels(s): Returns the string after reversing all the vowels in the input string s. vowels = 'aeiouAEIOU' s_list = list(s) i, j = 0, len(s_list) - 1 while i < j: if s_list[i] not in vowels: i += 1 elif s_list[j] not in vowels: j -= 1 else: s_list[i], s_list[j] = s_list[j], s_list[i] i += 1 j -= 1 return ''.join(s_list)"},{"question":"def final_position(s: str) -> list: Calculates the final position of a robot after executing a sequence of moves. The robot can move up ('U'), down ('D'), left ('L'), or right ('R'). The robot starts at position (0, 0) on an infinite grid. Arguments: s : str : A string representing the sequence of moves Returns: list : The final position of the robot in the form [x, y] >>> final_position(\\"\\") == [0, 0] >>> final_position(\\"U\\") == [0, 1] >>> final_position(\\"D\\") == [0, -1] >>> final_position(\\"L\\") == [-1, 0] >>> final_position(\\"R\\") == [1, 0] >>> final_position(\\"UDLR\\") == [0, 0] >>> final_position(\\"UUDDLLRR\\") == [0, 0] >>> final_position(\\"UUUU\\") == [0, 4] >>> final_position(\\"LLLL\\") == [-4, 0] >>> final_position(\\"RRRR\\") == [4, 0] >>> final_position(\\"UUDDLRLR\\") == [0, 0] >>> final_position(\\"UUDDLLRRU\\") == [0, 1] >>> final_position(\\"LLRRUUDD\\") == [0, 0] >>> final_position(\\"LLLRRRUUUDDD\\") == [0, 0]","solution":"def final_position(s): Calculates the final position of a robot after executing a sequence of moves. Arguments: s : str : A string representing the sequence of moves Returns: list : The final position of the robot in the form [x, y] x, y = 0, 0 for move in s: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return [x, y]"},{"question":"def binary_search(nums: List[int], target: int) -> int: Perform a binary search to find the index of a target integer in a sorted list of unique integers. If the target is not present, return -1. You must achieve this with O(log n) runtime complexity. >>> binary_search([1, 2, 3, 4, 5], 3) 2 >>> binary_search([10, 20, 30, 40, 50], 10) 0 >>> binary_search([1, 2, 3, 4, 5], 6) -1 >>> binary_search([], 1) -1 >>> binary_search([1], 1) 0 >>> binary_search([1], 2) -1 >>> binary_search([10, 20, 30, 40, 50], 20) 1 >>> binary_search([10, 20, 30, 40, 50], 40) 3","solution":"def binary_search(nums, target): Performs a binary search to find the index of target in a sorted list of integers. If the target is not found, returns -1. left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): Determines if a binary tree is symmetric around its center. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is symmetric, False otherwise def is_mirror(t1, t2): pass pass def test_symmetric_tree(): # Test symmetric tree root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(2) root.left.left = TreeNode(3) root.left.right = TreeNode(4) root.right.left = TreeNode(4) root.right.right = TreeNode(3) assert isSymmetric(root) == True def test_asymmetric_tree(): # Test asymmetric tree root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(2) root.left.right = TreeNode(3) root.right.right = TreeNode(3) assert isSymmetric(root) == False def test_single_node_tree(): # Test tree with single node root = TreeNode(1) assert isSymmetric(root) == True def test_empty_tree(): # Test empty tree root = None assert isSymmetric(root) == True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): Determines if a binary tree is symmetric around its center. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is symmetric, False otherwise def is_mirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right) return is_mirror(root, root)"},{"question":"def max_possible_minimum(arr: List[int], d: int) -> int: Given an array \`arr\` of positive integers and an integer \`d\`, this function returns the maximum possible value of the minimum element in the array after performing the operation: choose any element of the array and decrement it by \`d\`, any number of times. Args: arr (List[int]): A list of positive integers. d (int): The decrement value, which must be a positive integer. Returns: int: The maximum possible value of the minimum element in the array. Raises: ValueError: If \`arr\` is empty or \`d\` is non-positive. Examples: >>> max_possible_minimum([5, 15, 25], 4) 1 >>> max_possible_minimum([9, 9, 9], 3) 0 >>> max_possible_minimum([10, 20, 30], 31) 10 >>> max_possible_minimum([7], 5) 2 >>> max_possible_minimum([3, 2, 1], 5) 1","solution":"def max_possible_minimum(arr, d): Returns the maximum possible value of the minimum element in the array after decrementing any element by d any number of times. if not arr or d <= 0: raise ValueError(\\"Array must be non-empty and d must be positive\\") # The minimum value for each element in the array can only be a non-negative number # and at most d-1, since we can decrement them repeatedly by d. possible_minimum = min(arr) % d return possible_minimum"},{"question":"def longest_unique_substring(s: str, ignore: List[str]) -> int: Returns the length of the longest substring of \`s\` that contains unique characters and does not include any characters from \`ignore\` array. Parameters: s (str): The input string consisting of lowercase English letters. ignore (list): List of characters to be ignored while processing the string. Returns: int: The length of the longest unique substring. >>> longest_unique_substring(\\"abcabcbb\\", ['b']) 2 >>> longest_unique_substring(\\"bbbbb\\", ['b']) 0 >>> longest_unique_substring(\\"pwwkew\\", ['k', 'w']) 1 >>> longest_unique_substring(\\"abcdef\\", []) 6 >>> longest_unique_substring(\\"\\", ['a', 'b', 'c']) 0 >>> longest_unique_substring(\\"abcde\\", ['a', 'b', 'c', 'd', 'e']) 0 >>> longest_unique_substring(\\"abcdefgh\\", []) 8 >>> longest_unique_substring(\\"abcdefg\\", ['b', 'd', 'f']) 1 >>> longest_unique_substring(\\"abcdbcbb\\", ['c']) 2 >>> longest_unique_substring(\\"aabcbcdb\\", ['d']) 3 pass","solution":"def longest_unique_substring(s, ignore): Returns the length of the longest substring of \`s\` that contains unique characters and does not include any characters from \`ignore\` array. Parameters: s (str): The input string consisting of lowercase English letters. ignore (list): List of characters to be ignored while processing the string. Returns: int: The length of the longest unique substring. ignore_set = set(ignore) max_length = 0 start = 0 char_index = {} for end in range(len(s)): char = s[end] if char in ignore_set: start = end + 1 char_index.clear() else: if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def sortColors(nums): Sorts the array \`nums\` in place such that all 0s come before all 1s which come before all 2s. Args: nums (list): A list of integers (0, 1, or 2) Returns: None Examples: >>> nums = [2, 0, 2, 1, 1, 0] >>> sortColors(nums) >>> nums [0, 0, 1, 1, 2, 2] >>> nums = [2, 1, 0] >>> sortColors(nums) >>> nums [0, 1, 2]","solution":"def sortColors(nums): Sorts the array \`nums\` in place such that all 0s come before all 1s which come before all 2s. Args: nums (list): A list of integers (0, 1, or 2) Returns: None low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"def longest_subsequence_sum_k(nums: List[int], k: int) -> int: Returns the length of the longest subsequence of nums that sums up to k, or -1 if no such subsequence exists. >>> longest_subsequence_sum_k([1, -1, 5, -2, 3], 3) == 4 # [1, -1, 5, -2] >>> longest_subsequence_sum_k([-2, -1, 2, 1], 1) == 2 # [2, -1] >>> longest_subsequence_sum_k([1, 2, 3, 4, 5], 10) == 4 # [1, 2, 3, 4] >>> longest_subsequence_sum_k([3, 3, 3], 6) == 2 # [3, 3] >>> longest_subsequence_sum_k([1, 1, 1, 1], 2) == 2 # [1, 1] >>> longest_subsequence_sum_k([1, 2, 3], 7) == -1 # No subsequence sums to 7 >>> longest_subsequence_sum_k([1, -1, 1, -1], 0) == 4 # [1, -1, 1, -1]","solution":"def longest_subsequence_sum_k(nums, k): Returns the length of the longest subsequence of nums that sums up to k, or -1 if no such subsequence exists. # Using a dictionary to store the cumulative sum and its first occurrence index. sum_to_index = {0: -1} # Initialize with sum 0 at index -1 to handle sum from start cumulative_sum = 0 max_length = -1 for i, num in enumerate(nums): cumulative_sum += num # Check if there's a subsequence from some previous index to current index that sums to k if (cumulative_sum - k) in sum_to_index: length = i - sum_to_index[cumulative_sum - k] max_length = max(max_length, length) # Add the current cumulative sum to the dictionary if it's not already present if cumulative_sum not in sum_to_index: sum_to_index[cumulative_sum] = i return max_length"},{"question":"def min_operations(nums: List[int], target: int) -> int: You have an integer array \`nums\` and an integer \`target\`. You can perform the following operations on the array: - Increment or decrement any element of the array by 1. - Remove any element of the array. Your goal is to make at least one of the integers in the array equal to \`target\`, with the minimum possible number of operations. Return the minimum number of operations needed to achieve this goal. >>> min_operations([5], 5) 0 >>> min_operations([1, 2, 3, 4, 5], 5) 0 >>> min_operations([1, 2, 3, 4], 5) 1 >>> min_operations([-5, -3, -1, 2], -2) 1 >>> min_operations([-10, 0, 10], 3) 3 >>> min_operations([1000, 2000, 1500], 3000) 1000 >>> min_operations([], 5) inf","solution":"def min_operations(nums, target): Returns the minimum number of operations to make at least one of the integers in the array nums equal to the target value. min_operations_needed = float('inf') for num in nums: min_operations_needed = min(min_operations_needed, abs(num - target)) return min_operations_needed"},{"question":"def remove_vowels(s: str) -> str: Given a string \`s\`, remove the vowels 'a', 'e', 'i', 'o', 'u' (both lowercase and uppercase) from it. >>> remove_vowels(\\"hello\\") \\"hll\\" >>> remove_vowels(\\"world\\") \\"wrld\\" >>> remove_vowels(\\"aAeEiIoOuU\\") \\"\\" >>> remove_vowels(\\"a quick brown fox\\") \\" qck brwn fx\\" >>> remove_vowels(\\"Python Programming\\") \\"Pythn Prgrmmng\\" >>> remove_vowels(\\"rhythm\\") \\"rhythm\\" >>> remove_vowels(\\"\\") \\"\\"","solution":"def remove_vowels(s): Removes all vowels from the input string \`s\`. Vowels are 'a', 'e', 'i', 'o', 'u' (both lowercase and uppercase). vowels = \\"aeiouAEIOU\\" return ''.join(char for char in s if char not in vowels)"},{"question":"def get_folders_to_create(paths): Returns a list of folder paths that need to be created to ensure all paths exist. Args: paths (list of str): List of folder paths represented as strings. Returns: list of str: List of folders that need to be created in hierarchical order. >>> get_folders_to_create([\\"/a/b/c\\", \\"/a/b/d\\", \\"/e/f\\"]) ['/a', '/a/b', '/a/b/c', '/a/b/d', '/e', '/e/f'] >>> get_folders_to_create([\\"/x/y\\", \\"/x/y/z/a\\", \\"/x/y/z/b\\"]) ['/x', '/x/y', '/x/y/z', '/x/y/z/a', '/x/y/z/b'] >>> get_folders_to_create([\\"/x\\", \\"/y\\", \\"/z\\"]) ['/x', '/y', '/z'] >>> get_folders_to_create([\\"/a/b/c/\\", \\"/a/b/d/\\", \\"/e/f/\\"]) ['/a', '/a/b', '/a/b/c', '/a/b/d', '/e', '/e/f'] >>> get_folders_to_create([]) []","solution":"def get_folders_to_create(paths): Returns a list of folder paths that need to be created to ensure all paths exist. Args: paths (list of str): List of folder paths represented as strings. Returns: list of str: List of folders that need to be created in hierarchical order. folders = set() for path in paths: parts = path.strip('/').split('/') current_path = \\"\\" for part in parts: current_path += '/' + part folders.add(current_path) return sorted(folders) # Example usage # paths = [\\"/a/b/c\\", \\"/a/b/d\\", \\"/e/f\\"] # print(get_folders_to_create(paths)) # Output: ['/a', '/a/b', '/a/b/c', '/a/b/d', '/e', '/e/f']"},{"question":"class TreeNode: def __init__(self, val=0): self.val = val self.children = [] def countPaths(root, targetSum): Determine the total number of paths in the tree such that the sum of the values in the path is equal to a given target value. >>> root = TreeNode(5) >>> countPaths(root, 5) 1 >>> root = TreeNode(5) >>> countPaths(root, 6) 0 >>> root = TreeNode(1) >>> child1 = TreeNode(2) >>> child2 = TreeNode(3) >>> root.children = [child1, child2] >>> countPaths(root, 3) 2 >>> root = TreeNode(1) >>> child1 = TreeNode(2) >>> child2 = TreeNode(-1) >>> grandchild1 = TreeNode(1) >>> grandchild2 = TreeNode(2) >>> root.children = [child1, child2] >>> child1.children = [grandchild1] >>> child2.children = [grandchild2] >>> countPaths(root, 3) 2 >>> root = TreeNode(1) >>> child1 = TreeNode(1) >>> child2 = TreeNode(1) >>> root.children = [child1, child2] >>> countPaths(root, 5) 0","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.children = [] def countPaths(root, targetSum): def dfs(node, current_path): if not node: return 0 # Add current node to path current_path.append(node.val) # Check current path for sum path_count = 0 current_sum = 0 for val in reversed(current_path): current_sum += val if current_sum == targetSum: path_count += 1 # Traverse all children for child in node.children: path_count += dfs(child, current_path) # Remove current node from path current_path.pop() return path_count return dfs(root, [])"},{"question":"def minimize_length(s: str, t: str) -> int: Returns the length of the minimized string after deleting the matching characters from both strings, or -1 if it's not possible to perform such deletions. >>> minimize_length(\\"sea\\", \\"eat\\") == 2 >>> minimize_length(\\"abc\\", \\"def\\") == -1 >>> minimize_length(\\"abc\\", \\"abc\\") == 0 >>> minimize_length(\\"abcdef\\", \\"ace\\") == 3 >>> minimize_length(\\"\\", \\"\\") == -1 >>> minimize_length(\\"\\", \\"abc\\") == -1 >>> minimize_length(\\"abc\\", \\"\\") == -1 >>> minimize_length(\\"abcdefghij\\", \\"cdghij\\") == 4 pass","solution":"def minimize_length(s, t): Returns the length of the minimized string after deleting the matching characters from both strings, or -1 if it's not possible to perform such deletions. len_s, len_t = len(s), len(t) # Define a 2D DP array to store the lengths of the longest common subsequence dp = [[0] * (len_t + 1) for _ in range(len_s + 1)] # Fill the DP table for i in range(1, len_s + 1): for j in range(1, len_t + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_length = dp[len_s][len_t] # If there's no common subsequence, return -1 if lcs_length == 0: return -1 # The minimized length of the resulting string after deletions minimized_length = (len_s - lcs_length) + (len_t - lcs_length) return minimized_length"},{"question":"from typing import List def longest_subarray(arr: List[int], limit: int) -> int: Given a 0-indexed integer array \`arr\` of length \`n\`, return the length of the longest continuous subarray where the difference between the maximum and minimum elements in that subarray is less than or equal to a given integer \`limit\`. >>> longest_subarray([8, 2, 4, 7], 4) 2 >>> longest_subarray([10, 1, 2, 4, 7, 2], 5) 4 >>> longest_subarray([4, 2, 2, 2, 4, 4, 2, 2], 0) 3 >>> longest_subarray([1, 5, 9, 1, 5, 9], 5) 2 >>> longest_subarray([5, 5, 5, 5], 0) 4 >>> longest_subarray([10], 1) 1 >>> longest_subarray([1, 3, 6, 10, 15], 100) 5","solution":"from collections import deque def longest_subarray(arr, limit): Returns the length of the longest continuous subarray such that the difference between the maximum and minimum elements in that subarray is less than or equal to the specified limit. max_deque = deque() min_deque = deque() left = 0 max_length = 0 for right in range(len(arr)): while max_deque and arr[max_deque[-1]] <= arr[right]: max_deque.pop() while min_deque and arr[min_deque[-1]] >= arr[right]: min_deque.pop() max_deque.append(right) min_deque.append(right) while arr[max_deque[0]] - arr[min_deque[0]] > limit: if max_deque[0] == left: max_deque.popleft() if min_deque[0] == left: min_deque.popleft() left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def can_make_palindrome(s: str, queries: List[List[int]]) -> List[bool]: Determines if substrings can become palindromes with at most k replacements. Args: s: str - The input string queries: List of lists, where each query is [left, right, k] Returns: List of booleans corresponding to each query >>> can_make_palindrome(\\"abcd\\", [[0, 3, 2]]) [True] >>> can_make_palindrome(\\"abcd\\", [[0, 3, 1]]) [False] >>> can_make_palindrome(\\"abcba\\", [[0, 3, 1], [0, 4, 0], [1, 3, 1]]) [False, True, True] >>> can_make_palindrome(\\"aabbcc\\", [[0, 5, 3], [2, 5, 2], [1, 4, 1]]) [True, True, True] >>> can_make_palindrome(\\"racecar\\", [[0, 6, 0], [1, 5, 0]]) [True, True] >>> can_make_palindrome(\\"a\\", [[0, 0, 0], [0, 0, 1]]) [True, True]","solution":"def can_make_palindrome(s, queries): Determines if substrings can become palindromes with at most k replacements. Args: s: str - The input string queries: List of lists, where each query is [left, right, k] Returns: List of booleans corresponding to each query results = [] for left, right, k in queries: substring = s[left:right+1] l, r = 0, len(substring) - 1 replacements_needed = 0 while l < r: if substring[l] != substring[r]: replacements_needed += 1 l += 1 r -= 1 results.append(replacements_needed <= k) return results"},{"question":"def longest_substring_with_limit(s: str, limit: int) -> int: Find the length of the longest substring with at most 'limit' distinct characters. Args: s : str : input string consisting of lowercase English letters limit : int : maximum number of distinct characters allowed in the substring Returns: int : the length of the longest substring with at most 'limit' distinct characters Examples: >>> longest_substring_with_limit(\\"eceba\\", 2) 3 >>> longest_substring_with_limit(\\"aaaa\\", 1) 4","solution":"def longest_substring_with_limit(s, limit): Find the length of the longest substring with at most 'limit' distinct characters. if not s or limit == 0: return 0 start = 0 max_length = 0 char_count = {} for end in range(len(s)): char = s[end] char_count[char] = char_count.get(char, 0) + 1 while len(char_count) > limit: start_char = s[start] char_count[start_char] -= 1 if char_count[start_char] == 0: del char_count[start_char] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def top_k_frequent(arr: List[int], k: int) -> List[int]: Returns the k most frequent elements in the list arr. If there are multiple elements with the same frequency, return the ones with smaller values first. >>> top_k_frequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> top_k_frequent([1, 2, 3, 4, 5, 5, 5, 3, 3, 2, 2, 2], 3) [2, 3, 5] >>> top_k_frequent([4, 4, 4, 6, 6, 2, 2, 2, 2], 1) [2] >>> top_k_frequent([5, 5, 4, 4, 3, 3, 2, 2, 1, 1], 5) [1, 2, 3, 4, 5] >>> top_k_frequent([1], 1) [1]","solution":"from collections import Counter def top_k_frequent(arr, k): Returns the k most frequent elements in the list arr. If there are multiple elements with the same frequency, return the ones with smaller values first. # Count the frequency of each element in the list freq_count = Counter(arr) # Sort items by frequency (highest first) and then by value (smallest first) sorted_items = sorted(freq_count.items(), key=lambda x: (-x[1], x[0])) # Extract the top k frequent elements result = [item[0] for item in sorted_items[:k]] return result"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None from collections import deque def find_shortest_path(root, start, end): Find the shortest path (in terms of number of edges) between the nodes with values start and end in a binary tree. Return the list of node values that represent this shortest path. If there are multiple possible shortest paths, return any one of them. Examples: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> root.right.right.left = TreeNode(7) >>> find_shortest_path(root, 4, 7) [4, 2, 1, 3, 6, 7] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> find_shortest_path(root, 1, 3) [1, 3] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> find_shortest_path(root, 1, 4) [1, 2, 3, 4] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> find_shortest_path(root, 4, 1) [4, 3, 2, 1] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> find_shortest_path(root, 1, 4) [] >>> root = TreeNode(1) >>> find_shortest_path(root, 1, 1) [1]","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None from collections import deque def find_shortest_path(root, start, end): # BFS to build parent dictionary and find the start node node_queue = deque([root]) parent_dict = {root.val: None} start_node = None while node_queue: current = node_queue.popleft() if current.val == start: start_node = current if current.left: parent_dict[current.left.val] = current node_queue.append(current.left) if current.right: parent_dict[current.right.val] = current node_queue.append(current.right) # If we didn't find the start node in the tree if not start_node: return [] # BFS from start node to find the end node and record the path node_queue = deque([(start_node, [start_node.val])]) visited = set() while node_queue: current, path = node_queue.popleft() if current.val == end: return path if current.left and current.left.val not in visited: visited.add(current.left.val) node_queue.append((current.left, path + [current.left.val])) if current.right and current.right.val not in visited: visited.add(current.right.val) node_queue.append((current.right, path + [current.right.val])) parent = parent_dict[current.val] if parent and parent.val not in visited: visited.add(parent.val) node_queue.append((parent, path + [parent.val])) return []"},{"question":"def trap(height: List[int]) -> int: Computes the total amount of rainwater trapped. Parameters: height (List[int]): List of non-negative integers representing the elevation map. Returns: int: Total amount of rainwater trapped. pass from solution import trap def test_trap_example_case(): assert trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 def test_trap_no_elevation(): assert trap([]) == 0 def test_trap_constant_elevation(): assert trap([1, 1, 1, 1]) == 0 def test_trap_decreasing_elevation(): assert trap([5, 4, 3, 2, 1]) == 0 def test_trap_increasing_elevation(): assert trap([1, 2, 3, 4, 5]) == 0 def test_trap_random_elevation(): assert trap([4, 2, 0, 3, 2, 5]) == 9 def test_trap_single_peak(): assert trap([0, 4, 0]) == 0 def test_trap_multiple_peaks(): assert trap([2, 0, 2, 0, 2]) == 4","solution":"def trap(height): Computes the total amount of rainwater trapped. Parameters: height (List[int]): List of non-negative integers representing the elevation map. Returns: int: Total amount of rainwater trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def largest_island(grid: List[List[int]]) -> int: This function takes a 2D grid and returns the size of the largest island in the grid. An island is defined as a group of 1s (land) connected 4-directionally (horizontal or vertical). >>> largest_island([[1]]) 1 >>> largest_island([ [1, 1, 0, 0, 0], [1, 0, 0, 1, 1], [0, 0, 0, 1, 1], [0, 1, 1, 0, 0], [0, 0, 0, 1, 1] ]) 4 >>> largest_island([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0 >>> largest_island([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) 9 >>> largest_island([ [1, 0, 0, 1], [1, 1, 0, 1], [1, 0, 0, 1], [0, 0, 0, 1] ]) 4","solution":"def largest_island(grid): This function takes a 2D grid and returns the size of the largest island in the grid. An island is defined as a group of 1s (land) connected 4-directionally (horizontal or vertical). if not grid: return 0 nrows, ncols = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= nrows or y < 0 or y >= ncols or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark the cell as visited by setting it to 0 size = 1 size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_size = 0 for i in range(nrows): for j in range(ncols): if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"def removeDuplicates(s: str) -> str: Removes all adjacent duplicates in the string until no adjacent duplicates remain. Examples: >>> removeDuplicates(\\"abbaca\\") \\"ca\\" >>> removeDuplicates(\\"\\") \\"\\" >>> removeDuplicates(\\"abc\\") \\"abc\\" >>> removeDuplicates(\\"aabbcc\\") \\"\\" >>> removeDuplicates(\\"abccba\\") \\"\\" >>> removeDuplicates(\\"a\\") \\"a\\" >>> removeDuplicates(\\"aa\\") \\"\\" >>> removeDuplicates(\\"azxxzy\\") \\"ay\\"","solution":"def removeDuplicates(s): Removes all adjacent duplicates in the string until no adjacent duplicates remain. :param s: Input string :return: Resulting string with no adjacent duplicates stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"def drop_boxes(grid: List[List[int]]) -> List[List[int]]: Simulates the falling of the boxes within columns in a grid. Parameters: grid (list[list[int]]): A 2D integer grid representing the warehouse boxes. Returns: list[list[int]]: The resulting grid after all boxes have fallen. Examples: >>> drop_boxes([ [1, 0, 1], [0, 1, 0], [1, 0, 0] ]) [ [0, 0, 0], [1, 0, 0], [1, 1, 1] ] >>> drop_boxes([ [1], [0], [1], [0] ]) [ [0], [0], [1], [1] ] >>> drop_boxes([ [0, 0], [0, 0] ]) [ [0, 0], [0, 0] ]","solution":"def drop_boxes(grid): Simulates the falling of the boxes within columns in a grid. Parameters: grid (list[list[int]]): A 2D integer grid representing the warehouse boxes. Returns: list[list[int]]: The resulting grid after all boxes have fallen. m, n = len(grid), len(grid[0]) for col in range(n): # Collect all boxes in the current column stack = [grid[row][col] for row in range(m) if grid[row][col] == 1] # Empty the column for row in range(m): grid[row][col] = 0 # Drop the boxes to the bottom for i in range(len(stack)): grid[m - 1 - i][col] = 1 return grid"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_cost_path(root: TreeNode) -> int: Find the maximum cost to traverse from the root node to any leaf node in a binary tree. The cost to traverse from one node to another is the absolute difference between their values. >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(7) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(22) >>> max_cost_path(root) 12 >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(2) >>> root.left.left.left.left = TreeNode(1) >>> max_cost_path(root) 9","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_cost_path(root): if root is None: return 0 def helper(node, current_cost): if not node: return current_cost # Traverse left and right subtree and calculate their respective costs left_cost = helper(node.left, current_cost + (abs(node.value - node.left.value) if node.left else 0)) right_cost = helper(node.right, current_cost + (abs(node.value - node.right.value) if node.right else 0)) # Return the maximum cost from left or right subtree return max(left_cost, right_cost) return helper(root, 0)"},{"question":"from collections import deque def longest_subarray(nums, k): Returns the length of the longest continuous subarray where the difference between the maximum and minimum values is at most k. >>> longest_subarray([1, 3, 6, 7, 9], 3) == 3 >>> longest_subarray([10, 1, 2, 4, 7, 2], 5) == 4 >>> longest_subarray([4, 2, 2, 2, 4, 4, 2, 2], 0) == 3 >>> longest_subarray([1, 2, 3, 4, 5], 10) == 5 >>> longest_subarray([], 100) == 0 >>> longest_subarray([5], 0) == 1 >>> longest_subarray([5, 10], 1) == 1 >>> longest_subarray([1, 1, 1, 100], 100) == 4 pass","solution":"from collections import deque def longest_subarray(nums, k): Returns the length of the longest continuous subarray where the difference between the maximum and minimum values is at most k. if not nums: return 0 min_deque = deque() # to keep indexes of increasing elements max_deque = deque() # to keep indexes of decreasing elements left = 0 # left boundary of the window longest = 0 # result for right in range(len(nums)): # Maintain the min_deque in increasing order while min_deque and nums[min_deque[-1]] > nums[right]: min_deque.pop() min_deque.append(right) # Maintain the max_deque in decreasing order while max_deque and nums[max_deque[-1]] < nums[right]: max_deque.pop() max_deque.append(right) # Check if the current window is valid while nums[max_deque[0]] - nums[min_deque[0]] > k: if min_deque[0] == left: min_deque.popleft() if max_deque[0] == left: max_deque.popleft() left += 1 # Update the longest subarray length longest = max(longest, right - left + 1) return longest"},{"question":"def contains_nearby_almost_duplicate(arr: List[int], k: int) -> bool: Checks if there are two distinct indices i and j in the array such that: - The absolute difference between arr[i] and arr[j] is at most k - The absolute difference between i and j is at most k Arguments: arr : List[int] - List of integers k : int - Threshold value for differences Returns: bool - True if such indices exist, False otherwise >>> contains_nearby_almost_duplicate([1, 2, 3, 1], 3) True >>> contains_nearby_almost_duplicate([1, 0, 1, 1], 1) True >>> contains_nearby_almost_duplicate([1, 5, 9, 1, 5, 9], 2) False >>> contains_nearby_almost_duplicate([], 1) False >>> contains_nearby_almost_duplicate([1], 1) False >>> contains_nearby_almost_duplicate([1, 2, 3, 1], 0) False >>> contains_nearby_almost_duplicate([1, 2, 3, 1], 10) True","solution":"def contains_nearby_almost_duplicate(arr, k): Checks if there are two distinct indices i and j in the array such that: - The absolute difference between arr[i] and arr[j] is at most k - The absolute difference between i and j is at most k Arguments: arr : List[int] - List of integers k : int - Threshold value for differences Returns: bool - True if such indices exist, False otherwise if k <= 0: return False for i in range(len(arr)): for j in range(i + 1, min(i + k + 1, len(arr))): if abs(arr[i] - arr[j]) <= k: return True return False"},{"question":"def arrange_into_groups(n: int, k: int) -> int: Returns the number of ways to arrange n distinct items into k non-empty groups. >>> arrange_into_groups(0, 0) 0 >>> arrange_into_groups(5, 1) 1 >>> arrange_into_groups(3, 4) 0 >>> arrange_into_groups(4, 4) 1 >>> arrange_into_groups(5, 2) 15 >>> arrange_into_groups(7, 3) 301 >>> arrange_into_groups(10, 5) 42525 >>> arrange_into_groups(1, 1) 1 >>> arrange_into_groups(1, 2) 0","solution":"from math import comb def arrange_into_groups(n, k): Returns the number of ways to arrange n distinct items into k non-empty groups. # Using Stirling numbers of the second kind if k == 0 or n == 0: return 0 if k == 1: return 1 if n > 0 else 0 if k > n: return 0 S = [[0 for x in range(k+1)] for y in range(n+1)] S[0][0] = 1 for i in range(1, n+1): for j in range(1, k+1): S[i][j] = j * S[i-1][j] + S[i-1][j-1] return S[n][k]"},{"question":"def smallest_substring_containing_most_frequent_char(s: str) -> int: Find the length of the smallest substring that contains at least one occurrence of the most frequently occurring character in the string. >>> smallest_substring_containing_most_frequent_char(\\"aaaa\\") == 1 >>> smallest_substring_containing_most_frequent_char(\\"abc\\") == 1 >>> smallest_substring_containing_most_frequent_char(\\"abab\\") == 1 >>> smallest_substring_containing_most_frequent_char(\\"aaab\\") == 1 >>> smallest_substring_containing_most_frequent_char(\\"abcabcbb\\") == 1 >>> smallest_substring_containing_most_frequent_char(\\"aabbbcc\\") == 1 >>> smallest_substring_containing_most_frequent_char(\\"abba\\") == 1","solution":"def smallest_substring_containing_most_frequent_char(s): from collections import Counter # Step 1: Find the most frequent character(s) freq = Counter(s) most_frequent_char = max(freq, key=freq.get) max_freq = freq[most_frequent_char] # Step 2: Find the smallest substring containing at least one occurrence # of the most frequent character min_length = float('inf') n = len(s) for i in range(n): if s[i] == most_frequent_char: for j in range(i, n): if s[j] == most_frequent_char: min_length = min(min_length, j - i + 1) break return min_length"},{"question":"def longest_productive_subarray(days: List[int], threshold: int) -> int: Returns the length of the longest productive subarray where every element is greater than or equal to the threshold. :param days: List[int] - List of integers representing hours spent on each day. :param threshold: int - The threshold for productive hours. :return: int - Length of the longest productive subarray. >>> longest_productive_subarray([5, 6, 7, 8], 5) 4 >>> longest_productive_subarray([2, 3, 1, 4], 5) 0 >>> longest_productive_subarray([5, 6, 2, 7, 8, 3, 5, 6], 5) 2 >>> longest_productive_subarray([4, 5, 5, 5, 4], 5) 3 >>> longest_productive_subarray([2, 3, 4, 7, 4], 7) 1 >>> longest_productive_subarray([2, 3, 0, 1, 4], 0) 5 >>> longest_productive_subarray([6, 18, 2, 7, 9, 3, 5, 6], 10) 1 >>> longest_productive_subarray([5, 2, 5, 2, 5, 2], 5) 1","solution":"def longest_productive_subarray(days, threshold): Returns the length of the longest productive subarray where every element is greater than or equal to the threshold. :param days: List[int] - List of integers representing hours spent on each day. :param threshold: int - The threshold for productive hours. :return: int - Length of the longest productive subarray. max_length = 0 current_length = 0 for hours in days: if hours >= threshold: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def final_score(points: List[int]) -> int: Returns the final score of the player by summing the three highest-scoring levels, or the sum of all available points if there are less than three levels. >>> final_score([100]) == 100 >>> final_score([50, 60]) == 110 >>> final_score([50, 60, 70]) == 180 >>> final_score([100, 200, 300, 400]) == 900 >>> final_score([10, 20, 30, 40, 50]) == 120 >>> final_score([300, 100, 200, 400]) == 900 >>> final_score([5, 1, 2, 8, 7]) == 20 >>> final_score([-10, -20, -30, -40]) == -60 >>> final_score([-10, 20, 30, 40]) == 90 >>> final_score([-5, -10, -15]) == -30","solution":"def final_score(points): Returns the final score of the player by summing the three highest-scoring levels, or the sum of all available points if there are less than three levels. :param points: List of integers. :return: Integer representing the final score. if len(points) < 3: return sum(points) return sum(sorted(points, reverse=True)[:3])"},{"question":"def longest_common_subsequence(nums1: List[int], nums2: List[int]) -> int: Returns the length of the longest possible subsequence of nums1 that is also a subsequence in nums2. >>> longest_common_subsequence([1, 3, 4, 1], [3, 4, 1, 2, 1]) 3 >>> longest_common_subsequence([1, 2, 3], [4, 5, 6]) 0 >>> longest_common_subsequence([1, 2, 3], [1, 2, 3, 4]) 3 >>> longest_common_subsequence([], [1, 2, 3, 4]) 0 >>> longest_common_subsequence([1, 2, 3], []) 0 >>> longest_common_subsequence([4], [4]) 1 >>> longest_common_subsequence([1, 3, 4], [1, 2, 3, 4]) 3","solution":"def longest_common_subsequence(nums1, nums2): Returns the length of the longest possible subsequence of nums1 that is also a subsequence in nums2. n, m = len(nums1), len(nums2) # dp[i][j] will store the length of the longest common subsequence of nums1[0..i-1] and nums2[0..j-1] dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if nums1[i - 1] == nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"import heapq import collections from typing import List def find_shortest_travel_time(edges: List[List[int]], src: int, dst: int) -> int: Returns the shortest travel time from station src to station dst or -1 if no such path exists. Args: edges (List[List[int]]): List of routes represented as [u, v, w] where there is a direct bus route from station u to station v taking w minutes. src (int): The source station. dst (int): The destination station. Returns: int: The shortest travel time from station src to station dst, or -1 if no path exists. pass # Example Unit Tests: def test_no_path_exists(): edges = [[0, 1, 4], [1, 2, 5], [2, 3, 6]] assert find_shortest_travel_time(edges, 0, 4) == -1 def test_direct_path(): edges = [[0, 1, 2]] assert find_shortest_travel_time(edges, 0, 1) == 2 def test_single_node(): edges = [] assert find_shortest_travel_time(edges, 0, 0) == 0 def test_complex_graph(): edges = [[0, 1, 1], [0, 2, 4], [1, 2, 2], [2, 3, 1], [1, 3, 7]] assert find_shortest_travel_time(edges, 0, 3) == 4 def test_multiple_paths(): edges = [[0, 1, 3], [0, 3, 10], [1, 2, 1], [1, 3, 8], [2, 3, 2]] assert find_shortest_travel_time(edges, 0, 3) == 6","solution":"import heapq import collections def find_shortest_travel_time(edges, src, dst): Returns the shortest travel time from station src to station dst or -1 if no such path exists. Args: edges (List[List[int]]): List of routes represented as [u, v, w] where there is a direct bus route from station u to station v taking w minutes. src (int): The source station. dst (int): The destination station. Returns: int: The shortest travel time from station src to station dst, or -1 if no path exists. # Create a graph from the edges graph = collections.defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) # Min-heap to keep track of shortest distances heap = [(0, src)] # (travel_time, station) distances = {src: 0} while heap: current_time, u = heapq.heappop(heap) if u == dst: return current_time for v, w in graph[u]: new_time = current_time + w if v not in distances or new_time < distances[v]: distances[v] = new_time heapq.heappush(heap, (new_time, v)) return -1"},{"question":"def can_win_nim(nums): Determines if the first player can win the game given optimal play. :param nums: List[int] - a list of integers where each integer represents the number of stones in a pile :return: bool - True if the first player will win, False otherwise >>> can_win_nim([1]) True >>> can_win_nim([4]) False >>> can_win_nim([1, 2, 3]) True >>> can_win_nim([4, 5, 6]) False","solution":"def can_win_nim(nums): Determines if the first player can win the game given optimal play. :param nums: List[int] - a list of integers where each integer represents the number of stones in a pile :return: bool - True if the first player will win, False otherwise def can_win_single_pile(n): return n % 4 != 0 return all(can_win_single_pile(n) for n in nums)"},{"question":"def count_good_substrings_of_length_n(s: str, n: int) -> int: Returns the number of good substrings of length n in string s where all characters are distinct. Args: s (str): the input string consisting only of lowercase alphabetical characters. n (int): the length of the substrings to consider. Returns: int: the number of good substrings of length n. Examples: >>> count_good_substrings_of_length_n(\\"abcabc\\", 3) 4 >>> count_good_substrings_of_length_n(\\"aababcabcd\\", 3) 5 >>> count_good_substrings_of_length_n(\\"aaaaaa\\", 1) 6 >>> count_good_substrings_of_length_n(\\"abcdef\\", 2) 5 >>> count_good_substrings_of_length_n(\\"abc\\", 4) 0 >>> count_good_substrings_of_length_n(\\"\\", 1) 0 >>> count_good_substrings_of_length_n(\\"abcdefghij\\", 10) 1","solution":"def count_good_substrings_of_length_n(s, n): Returns the number of good substrings of length n in string s where all characters are distinct. if n > len(s): return 0 good_substring_count = 0 for i in range(len(s) - n + 1): substring = s[i:i+n] if len(set(substring)) == n: good_substring_count += 1 return good_substring_count"},{"question":"def length_of_longest_substring(s: str) -> int: Determine the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"def count_k_pairs(nums, k): Given an array of integers nums and an integer k, return the number of unique k-pairs where pair (i, j) (i < j) has the sum equal to k. A k-pair is a pair of distinct indices whose elements add up to k. Args: nums (List[int]): List of integers. k (int): Target sum. Returns: int: Number of unique k-pairs. from solution import count_k_pairs # Ensure to save the solution code in solution.py module def test_count_k_pairs_basic(): assert count_k_pairs([1, 2, 3, 4, 5], 5) == 2 # pairs: (1, 4), (2, 3) def test_count_k_pairs_no_pairs(): assert count_k_pairs([1, 2, 3, 4, 5], 10) == 0 def test_count_k_pairs_repeated_elements(): assert count_k_pairs([1, 1, 1, 2, 2], 3) == 1 # pair: (1, 2) def test_count_k_pairs_negative_numbers(): assert count_k_pairs([-1, -2, -3, -4, -5], -5) == 2 # pairs: (-1, -4), (-2, -3) def test_count_k_pairs_mixed_numbers(): assert count_k_pairs([-1, 1, 0, 2, -2], 0) == 2 # pairs: (-1, 1), (-2, 2) def test_count_k_pairs_large_input(): assert count_k_pairs(list(range(1000)), 1997) == 1 # only pair: (998, 999)","solution":"def count_k_pairs(nums, k): Given an array of integers nums and an integer k, return the number of unique k-pairs where pair (i, j) (i < j) has the sum equal to k. A k-pair is a pair of distinct indices whose elements add up to k. Args: nums (List[int]): List of integers. k (int): Target sum. Returns: int: Number of unique k-pairs. num_count = {} count = 0 pairs = set() for num in nums: if k - num in num_count: pair = tuple(sorted((num, k - num))) if pair not in pairs: pairs.add(pair) count += 1 num_count[num] = num_count.get(num, 0) + 1 return count"},{"question":"from collections import deque from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level_order(root: Optional[TreeNode]) -> List[List[int]]: Returns the zigzag (alternating order) level order traversal of a binary tree. >>> tree = TreeNode(3, TreeNode(9, TreeNode(4), TreeNode(5)), TreeNode(20, None, TreeNode(7))) >>> zigzag_level_order(tree) [[3], [20, 9], [4, 5, 7]] >>> zigzag_level_order(None) [] >>> tree = TreeNode(1) >>> zigzag_level_order(tree) [[1]] >>> tree = TreeNode(1, TreeNode(2), TreeNode(3)) >>> zigzag_level_order(tree) [[1], [3, 2]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level_order(root): Returns the zigzag (alternating order) level order traversal of a binary tree. if not root: return [] result = [] queue = deque([root]) left_to_right = True while queue: level_size = len(queue) level_nodes = deque() for _ in range(level_size): node = queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.appendleft(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(list(level_nodes)) left_to_right = not left_to_right return result"},{"question":"def find_kth_smallest(nums1: List[int], nums2: List[int], k: int) -> int: Given two integer arrays nums1 and nums2 sorted in non-decreasing order, merge nums1 and nums2 and return the k-th smallest element in the merged sorted array. If there is no such element, return -1. >>> find_kth_smallest([1, 3], [2], 1) == 1 >>> find_kth_smallest([1, 3], [2], 2) == 2 >>> find_kth_smallest([1, 3], [2], 3) == 3 >>> find_kth_smallest([1, 3], [2], 4) == -1 >>> find_kth_smallest([1, 5, 8], [2, 3, 7, 9], 4) == 5 >>> find_kth_smallest([1, 5, 8, 10], [2, 3, 7, 9], 6) == 8 >>> find_kth_smallest([1, 3, 5, 7], [2, 4, 6, 8], 5) == 5 >>> find_kth_smallest([], [1, 2, 3, 4], 2) == 2 >>> find_kth_smallest([1, 3, 4], [], 3) == 4 >>> find_kth_smallest([], [], 1) == -1 >>> find_kth_smallest([1], [], 1) == 1 >>> find_kth_smallest([1], [2], 1) == 1 >>> find_kth_smallest([1], [2], 2) == 2 >>> find_kth_smallest([1], [2], 3) == -1","solution":"def find_kth_smallest(nums1, nums2, k): def kth_smallest_util(arr1, arr2, k): len1, len2 = len(arr1), len(arr2) if len1 > len2: return kth_smallest_util(arr2, arr1, k) if len1 == 0: return arr2[k-1] if k <= len2 else -1 if k == 1: return min(arr1[0], arr2[0]) idx1 = min(len1, k // 2) idx2 = k - idx1 if arr1[idx1 - 1] < arr2[idx2 - 1]: return kth_smallest_util(arr1[idx1:], arr2, k - idx1) else: return kth_smallest_util(arr1, arr2[idx2:], k - idx2) total_length = len(nums1) + len(nums2) if k > total_length: return -1 return kth_smallest_util(nums1, nums2, k)"},{"question":"def shortest_subsequence(ingredients: str) -> str: Returns the shortest subsequence containing all unique ingredients in order of their first appearance. Args: ingredients (str): A string representing a recipe. Returns: str: The shortest subsequence containing all unique ingredients. from solution import shortest_subsequence def test_shortest_subsequence_simple(): assert shortest_subsequence(\\"abacbc\\") == \\"abc\\" def test_shortest_subsequence_with_repeats(): assert shortest_subsequence(\\"aadbbc\\") == \\"adbc\\" def test_shortest_subsequence_all_unique(): assert shortest_subsequence(\\"abcdef\\") == \\"abcdef\\" def test_shortest_subsequence_single_char(): assert shortest_subsequence(\\"a\\") == \\"a\\" def test_shortest_subsequence_empty(): assert shortest_subsequence(\\"\\") == \\"\\" def test_shortest_subsequence_all_repeats(): assert shortest_subsequence(\\"aaaa\\") == \\"a\\"","solution":"def shortest_subsequence(ingredients): Returns the shortest subsequence containing all unique ingredients in order of their first appearance. Args: ingredients (str): A string representing a recipe. Returns: str: The shortest subsequence containing all unique ingredients. seen = set() result = [] for ingredient in ingredients: if ingredient not in seen: seen.add(ingredient) result.append(ingredient) return ''.join(result)"},{"question":"def shortest_possible_string(s: str) -> int: Given a string s, you are allowed to choose one contiguous substring of s and delete all of its occurrences in the string. The operation can be performed any number of times, but not consecutively on overlapping substrings. Return the length of the shortest possible string you can achieve after performing the operation as many times as you wish. >>> shortest_possible_string(\\"ababcb\\") == 3 >>> shortest_possible_string(\\"\\") == 0 >>> shortest_possible_string(\\"aaaaa\\") == 1 >>> shortest_possible_string(\\"abcde\\") == 5 >>> shortest_possible_string(\\"abababab\\") == 2 >>> shortest_possible_string(\\"racecar\\") == 4","solution":"def shortest_possible_string(s): Given a string s, you are allowed to choose one contiguous substring of s and delete all of its occurrences in the string. Return the length of the shortest possible string you can achieve. # Create a set of unique characters in the string unique_chars = set(s) # The length of the shortest possible string would be # the number of unique characters in the string. return len(unique_chars)"},{"question":"def can_transform(s: str, t: str, m: int) -> bool: Determines if string s can be transformed into string t using exactly m operations. Parameters: s (str): The original string. t (str): The target string. m (int): The exact number of operations allowed. Returns: bool: True if s can be transformed into t using exactly m operations, False otherwise. >>> can_transform(\\"abc\\", \\"def\\", 3) == True >>> can_transform(\\"abc\\", \\"def\\", 5) == True >>> can_transform(\\"abc\\", \\"def\\", 2) == False >>> can_transform(\\"abc\\", \\"abc\\", 0) == True >>> can_transform(\\"abc\\", \\"abc\\", 4) == True >>> can_transform(\\"abc\\", \\"abc\\", 3) == False >>> can_transform(\\"abc\\", \\"abcd\\", 2) == False","solution":"def can_transform(s, t, m): Determines if string s can be transformed into string t using exactly m operations. Parameters: s (str): The original string. t (str): The target string. m (int): The exact number of operations allowed. Returns: bool: True if s can be transformed into t using exactly m operations, False otherwise. if len(s) != len(t): return False # Calculate the number of differing characters between s and t diff_count = sum(1 for a, b in zip(s, t) if a != b) if diff_count > m: return False # More differences than allowed operations means it's impossible # We need exactly m operations, so the remaining operations must be spare operations # where we can simply replace a character with itself remaining_operations = m - diff_count return remaining_operations % 2 == 0"},{"question":"def min_buildings_to_remove(arr: List[int]) -> int: Returns the minimum number of buildings that need to be removed to achieve a non-decreasing order of heights from left to right. >>> min_buildings_to_remove([1, 3, 2, 4, 2]) 2 >>> min_buildings_to_remove([1, 2, 3]) 0 >>> min_buildings_to_remove([3, 2, 1]) 2 >>> min_buildings_to_remove([]) 0 >>> min_buildings_to_remove([1]) 0 >>> min_buildings_to_remove([1, 1, 1, 1, 1]) 0 >>> min_buildings_to_remove([1, 2, 5, 3, 4]) 1 >>> min_buildings_to_remove([2, 3, 7, 6, 8, 10, 5]) 2 >>> min_buildings_to_remove([10, 5, 6, 1, 2, 3, 4]) 3","solution":"def min_buildings_to_remove(arr): Returns the minimum number of buildings that need to be removed to achieve a non-decreasing order of heights from left to right. def longest_increasing_subsequence_length(arr): if not arr: return 0 lis = [arr[0]] for height in arr[1:]: if height >= lis[-1]: lis.append(height) else: idx = binary_search(lis, height) lis[idx] = height return len(lis) def binary_search(lis, x): lo, hi = 0, len(lis) while lo < hi: mid = (lo + hi) // 2 if lis[mid] <= x: lo = mid + 1 else: hi = mid return lo return len(arr) - longest_increasing_subsequence_length(arr)"},{"question":"def merge_intervals(intervals): Merges overlapping intervals and returns a list of the merged intervals. Args: intervals (list of tuples): List of intervals represented as tuples (start, end). Returns: list of tuples: List of merged intervals sorted by start time. Examples: >>> merge_intervals([(1, 3), (2, 6), (8, 10), (15, 18)]) [(1, 6), (8, 10), (15, 18)] >>> merge_intervals([(1, 4), (4, 5)]) [(1, 5)] pass # Test cases def test_merge_intervals_no_overlap(): intervals = [(1, 3), (4, 6), (7, 8)] expected = [(1, 3), (4, 6), (7, 8)] assert merge_intervals(intervals) == expected def test_merge_intervals_with_overlap(): intervals = [(1, 4), (2, 5), (7, 9)] expected = [(1, 5), (7, 9)] assert merge_intervals(intervals) == expected def test_merge_intervals_with_full_overlap(): intervals = [(1, 10), (2, 3), (4, 5), (6, 7)] expected = [(1, 10)] assert merge_intervals(intervals) == expected def test_merge_intervals_unsorted_input(): intervals = [(15, 18), (1, 3), (8, 10), (2, 6)] expected = [(1, 6), (8, 10), (15, 18)] assert merge_intervals(intervals) == expected def test_merge_intervals_empty_input(): intervals = [] expected = [] assert merge_intervals(intervals) == expected def test_merge_intervals_single_interval(): intervals = [(5, 10)] expected = [(5, 10)] assert merge_intervals(intervals) == expected","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns a list of the merged intervals. Args: intervals (list of tuples): List of intervals represented as tuples (start, end). Returns: list of tuples: List of merged intervals sorted by start time. if not intervals: return [] # Sort intervals based on the starting time intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: merged_intervals[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged_intervals.append(current) return merged_intervals"},{"question":"def find_target_in_matrix(grid: List[List[int]], x: int) -> Tuple[int, int]: Finds a target integer x in a 2D matrix grid where each row is sorted in non-decreasing order and each column is sorted in non-decreasing order. If found, returns the position of x as a tuple (row, column). If x is not found, returns (-1, -1). >>> find_target_in_matrix([ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ], 5) (1, 1) >>> find_target_in_matrix([ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ], 20) (-1, -1) >>> find_target_in_matrix([], 5) (-1, -1) >>> find_target_in_matrix([[5]], 5) (0, 0) >>> find_target_in_matrix([[5]], 1) (-1, -1) >>> find_target_in_matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], 8) (2, 1) >>> find_target_in_matrix([ [1, 2], [3, 4] ], 2) (0, 1)","solution":"def find_target_in_matrix(grid, x): Finds a target integer x in a 2D matrix grid. If found, returns the position of x as a tuple (row, column). If x is not found, returns (-1, -1). if not grid or not grid[0]: return (-1, -1) rows, cols = len(grid), len(grid[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if grid[row][col] == x: return (row, col) elif grid[row][col] > x: col -= 1 else: row += 1 return (-1, -1)"},{"question":"def three_sum(nums: List[int], target: int) -> List[int]: Determine if there are three integers in \`nums\` that add up to the given \`target\`. If such a triplet exists, return the triplet as a list of integers in non-decreasing order. If no such triplet exists, return an empty list. >>> three_sum([2, 1, 3, 5, 6, 0], 9) [1, 3, 5] >>> three_sum([1, 2, 3, 4, 5], 50) [] >>> three_sum([1, 1, 1, 2, 2, 2, 3, 3, 3], 6) [1, 2, 3] >>> three_sum([12, 3, 4, 1, 6, 9], 24) [3, 9, 12] >>> three_sum([1, 2, 3, 0, -1, -2, -3, 4, -4], 0) [-3, -1, 4]","solution":"def three_sum(nums, target): Returns a triplet of integers from the list that add up to the target. If no such triplet exists, returns an empty list. nums.sort() n = len(nums) result = [] for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 if result: return result[0] return []"},{"question":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: Given an array of distinct integers, find all unique triplets in the array which gives the sum of zero. Each triplet must be in non-descending order (i.e., [x, y, z] with x <= y <= z). Return a list of all triplets such that their sum is zero. >>> three_sum([1, 2, -2, -1]) ==> [] >>> three_sum([-1, 0, 1, 2, -1, -4]) ==> [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([0, -1, 2, -3, 1]) ==> [[-3, 1, 2], [-1, 0, 1]] >>> three_sum([0, 0, 0, 0]) ==> [[0, 0, 0]]","solution":"def three_sum(nums): Returns a list of unique triplets in the array which gives the sum of zero. Each triplet is in non-descending order. nums.sort() res = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: s = nums[i] + nums[left] + nums[right] if s < 0: left += 1 elif s > 0: right -= 1 else: res.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 return res"},{"question":"def largest_rectangle_area(heights): Given an array \`heights\` representing the heights of columns in a histogram, find the area of the largest rectangle that can be formed by any number of consecutive columns. Return the area of the largest rectangle in the histogram. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([4]) 4 >>> largest_rectangle_area([1, 1, 1, 1]) 4 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([2, 4, 2, 1]) 6 >>> largest_rectangle_area([]) 0","solution":"def largest_rectangle_area(heights): Function to find the area of the largest rectangle in the histogram. stack = [] max_area = 0 for i, height in enumerate(heights): start = i while stack and stack[-1][1] > height: index, h = stack.pop() max_area = max(max_area, h * (i - index)) start = index stack.append((start, height)) for i, h in stack: max_area = max(max_area, h * (len(heights) - i)) return max_area"},{"question":"def minPathSum(matrix: List[List[int]]) -> int: Returns the minimum cost to travel from the top-left to the bottom-right of the grid. Only moves to the right or down are allowed. :param matrix: List[List[int]] - 2D list representing the grid :return: int - minimum cost to travel from top-left to bottom-right >>> minPathSum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> minPathSum([ ... [1, 2, 3] ... ]) == 6 >>> minPathSum([ ... [1], ... [2], ... [3] ... ]) == 6 >>> minPathSum([ ... [1000, 1000], ... [1000, 1000] ... ]) == 3000 >>> minPathSum([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 5 >>> minPathSum([ ... [5] ... ]) == 5 >>> minPathSum([]) == 0","solution":"def minPathSum(matrix): Returns the minimum cost to travel from the top-left to the bottom-right of the grid. Only moves to the right or down are allowed. :param matrix: List[List[int]] - 2D list representing the grid :return: int - minimum cost to travel from top-left to bottom-right if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) # Initialize the cost matrix with the same dimensions as matrix cost = [[0] * n for _ in range(m)] # Set the cost of the top-left cell cost[0][0] = matrix[0][0] # Fill out the first column for i in range(1, m): cost[i][0] = cost[i-1][0] + matrix[i][0] # Fill out the first row for j in range(1, n): cost[0][j] = cost[0][j-1] + matrix[0][j] # Fill out the rest of the cost matrix for i in range(1, m): for j in range(1, n): cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + matrix[i][j] # The cost of the bottom-right cell is the answer return cost[m-1][n-1]"},{"question":"def count_distinct_palindromic_substrings(s: str) -> int: Given a string \`s\`, find the number of distinct non-empty substrings of \`s\` that are palindromes. >>> count_distinct_palindromic_substrings(\\"a\\") 1 >>> count_distinct_palindromic_substrings(\\"aa\\") 2 >>> count_distinct_palindromic_substrings(\\"ab\\") 2 >>> count_distinct_palindromic_substrings(\\"aabaa\\") 5 >>> count_distinct_palindromic_substrings(\\"abc\\") 3 >>> count_distinct_palindromic_substrings(\\"racecar\\") 7 >>> count_distinct_palindromic_substrings(\\"aAa\\") 3 >>> count_distinct_palindromic_substrings(\\"abcdefg\\") 7 >>> count_distinct_palindromic_substrings(\\"aaaa\\") 4","solution":"def count_distinct_palindromic_substrings(s): Returns the number of distinct non-empty substrings of s that are palindromes. n = len(s) palindromes = set() # To check for palindromic substrings centered at every character: for center in range(n): # Odd-length palindromes: l, r = center, center while l >= 0 and r < n and s[l] == s[r]: palindromes.add(s[l:r+1]) l -= 1 r += 1 # Even-length palindromes: l, r = center, center + 1 while l >= 0 and r < n and s[l] == s[r]: palindromes.add(s[l:r+1]) l -= 1 r += 1 return len(palindromes)"},{"question":"def permute_string(s: str, indices: List[int]) -> str: Permute the characters of the string s such that the character at index i moves to indices[i] in the resulting string. :param s: A string consisting of lowercase alphabets. :param indices: A list of integers containing unique values from 0 to len(s)-1. :return: The permuted string. >>> permute_string(\\"abcd\\", [3, 1, 2, 0]) == \\"dbca\\" >>> permute_string(\\"a\\", [0]) == \\"a\\" >>> permute_string(\\"abc\\", [0, 1, 2]) == \\"abc\\" >>> permute_string(\\"abc\\", [2, 1, 0]) == \\"cba\\" >>> permute_string(\\"hello\\", [4, 3, 2, 1, 0]) == \\"olleh\\" >>> permute_string(\\"python\\", [5, 4, 3, 2, 1, 0]) == \\"nohtyp\\"","solution":"def permute_string(s, indices): Permute the characters of the string s such that the character at index i moves to indices[i] in the resulting string. :param s: A string consisting of lowercase alphabets. :param indices: A list of integers containing unique values from 0 to len(s)-1. :return: The permuted string. n = len(s) result = [''] * n # Create a list of empty strings with the same length as s for i, index in enumerate(indices): result[index] = s[i] # Place character s[i] at the position indices[i] return ''.join(result) # Combine the list into a single string and return"},{"question":"def decrypt_caesar_cipher(s: str, k: int) -> str: Decrypts a ciphertext \`s\` using a Caesar cipher with a right shift of \`k\`. >>> decrypt_caesar_cipher(\\"d e f!\\", 3) == \\"a b c!\\" >>> decrypt_caesar_cipher(\\"abc\\", 0) == \\"abc\\" >>> decrypt_caesar_cipher(\\"abc\\", 3) == \\"xyz\\" >>> decrypt_caesar_cipher(\\"DEF!\\", 3) == \\"ABC!\\" >>> decrypt_caesar_cipher(\\"dEf!\\", 3) == \\"aBc!\\" >>> decrypt_caesar_cipher(\\"!@# %^\\", 4) == \\"!@# %^\\" >>> decrypt_caesar_cipher(\\"xyz\\", 29) == \\"uvw\\" >>> decrypt_caesar_cipher(\\"\\", 5) == \\"\\"","solution":"def decrypt_caesar_cipher(s, k): Decrypts a ciphertext \`s\` using a Caesar cipher with a right shift of \`k\`. def shift_char(c, shift): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') - shift) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') - shift) % 26 + ord('A')) else: return c decrypted = ''.join(shift_char(c, k) for c in s) return decrypted"},{"question":"def count_substrings_with_one_distinct_letter(s: str) -> int: Returns the total number of substrings that contain exactly one distinct letter. >>> count_substrings_with_one_distinct_letter(\\"aaaa\\") 10 >>> count_substrings_with_one_distinct_letter(\\"abcd\\") 4 >>> count_substrings_with_one_distinct_letter(\\"a\\") 1 >>> count_substrings_with_one_distinct_letter(\\"aab\\") 4 >>> count_substrings_with_one_distinct_letter(\\"aabb\\") 6 >>> count_substrings_with_one_distinct_letter(\\"\\") 0","solution":"def count_substrings_with_one_distinct_letter(s): Returns the total number of substrings that contain exactly one distinct letter. total = 0 n = len(s) i = 0 while i < n: char = s[i] count = 0 while i < n and s[i] == char: i += 1 count += 1 total += count * (count + 1) // 2 return total"},{"question":"def merge_consecutive_duplicates(arr: List[int]) -> List[int]: Merges consecutive duplicate elements in the list 'arr' into single entries. >>> merge_consecutive_duplicates([2, 2, 1, 1, 1, 3, 3, 2]) [2, 1, 3, 2] >>> merge_consecutive_duplicates([1, 2, 3, 4]) [1, 2, 3, 4] >>> merge_consecutive_duplicates([5, 5, 5, 5, 5]) [5] >>> merge_consecutive_duplicates([]) [] >>> merge_consecutive_duplicates([10]) [10] >>> merge_consecutive_duplicates([1, 2, 2, 1, 1, 2, 2, 3]) [1, 2, 1, 2, 3] >>> merge_consecutive_duplicates([7]*1000 + [8]*1000) [7, 8]","solution":"def merge_consecutive_duplicates(arr): Merges consecutive duplicate elements in the list 'arr' into single entries. Args: arr (list): A list of integers representing packet sizes. Returns: list: A list with consecutive duplicates merged into single entries. if not arr: return [] merged_arr = [arr[0]] for packet in arr[1:]: if packet != merged_arr[-1]: merged_arr.append(packet) return merged_arr"},{"question":"def num_water_bodies(grid): Determine the number of distinct water bodies in the given grid. Returns the total number of water bodies found in the grid. >>> num_water_bodies([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) 9 >>> num_water_bodies([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) 1 >>> num_water_bodies([ [1, 2, 2], [3, 2, 2], [3, 3, 1] ]) 4 >>> num_water_bodies([ [1, 2, 1], [2, 1, 2], [1, 2, 1] ]) 9 >>> num_water_bodies([]) 0 >>> num_water_bodies([ [1, 1, 2, 2, 3, 3] ]) 3 >>> num_water_bodies([ [1], [1], [2], [2], [3], [3] ]) 3","solution":"def num_water_bodies(grid): Returns the number of distinct water bodies in the grid. if not grid: return 0 def dfs(x, y, height): Depth-First Search to mark the entire water body. if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != height: return grid[x][y] = None # mark as visited # Explore all four directions dfs(x + 1, y, height) dfs(x - 1, y, height) dfs(x, y + 1, height) dfs(x, y - 1, height) num_bodies = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] is not None: # found an unvisited water body num_bodies += 1 dfs(i, j, grid[i][j]) return num_bodies"},{"question":"def longest_increasing_subarray(temps): Returns the length of the longest strictly increasing subarray in the given list of temperatures. >>> longest_increasing_subarray([1, 2, 3, 1, 2, 3, 4, 1]) 4 >>> longest_increasing_subarray([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subarray([2, 2, 2, 2, 2]) 1 >>> longest_increasing_subarray([1, 2, 1, 2, 1, 2]) 2 >>> longest_increasing_subarray([1]) 1 >>> longest_increasing_subarray([]) 0 >>> longest_increasing_subarray([5, 4, 3, 2, 1, 2, 3, 4, 5]) 5","solution":"def longest_increasing_subarray(temps): Returns the length of the longest strictly increasing subarray in the given list of temperatures. if not temps: return 0 max_length = 1 current_length = 1 for i in range(1, len(temps)): if temps[i] > temps[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"from typing import List def find_largest_territory(grid: List[List[int]]) -> int: Determines the largest territory area (number of cells) that belongs to any single nation in the grid. >>> find_largest_territory([ ... [1, 1, 2], ... [3, 1, 2], ... [3, 3, 2] ... ]) == 3 >>> find_largest_territory([[1]]) == 1 >>> find_largest_territory([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 9 >>> find_largest_territory([ ... [1, 2, 3], ... [3, 2, 1], ... [1, 2, 1] ... ]) == 3 >>> find_largest_territory([]) == 0 >>> find_largest_territory([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 1","solution":"def find_largest_territory(grid): Determines the largest territory area (number of cells) that belongs to any single nation in the grid. if not grid: return 0 def dfs(r, c, nation): if r < 0 or c < 0 or r >= len(grid) or c >= len(grid[0]) or grid[r][c] != nation: return 0 grid[r][c] = -1 # Mark as visited return 1 + dfs(r-1, c, nation) + dfs(r+1, c, nation) + dfs(r, c-1, nation) + dfs(r, c+1, nation) max_area = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] > 0: nation = grid[r][c] area = dfs(r, c, nation) max_area = max(max_area, area) return max_area"},{"question":"def has_subarray_with_sum(power_levels: list[int], S: int) -> bool: Determines whether there exists a contiguous subarray of wizards' power levels that sums exactly up to S. Parameters: power_levels (list of int): The list of integers representing wizards' power levels. S (int): The target sum. Returns: bool: True if there exists a contiguous subarray that sums up to S, False otherwise. >>> has_subarray_with_sum([1, 2, 3, 4, 5], 20) False >>> has_subarray_with_sum([1, 2, 3, 7, 5], 10) True >>> has_subarray_with_sum([1, 2, -3, 4, -2], 1) True def test_no_subarray_found(): assert has_subarray_with_sum([1, 2, 3, 4, 5], 20) == False def test_subarray_found_at_start(): assert has_subarray_with_sum([1, 2, 3, 4, 5], 6) == True def test_subarray_found_in_middle(): assert has_subarray_with_sum([1, 2, 3, 7, 5], 10) == True def test_subarray_found_at_end(): assert has_subarray_with_sum([1, 2, 3, 4, 12], 12) == True def test_single_element_subarray(): assert has_subarray_with_sum([1, -1, 2, 3], 3) == True def test_negative_numbers_in_power_levels(): assert has_subarray_with_sum([1, 2, -3, 4, -2], 1) == True def test_large_sum(): assert has_subarray_with_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 55) == True def test_sum_zero(): assert has_subarray_with_sum([3, 4, -7, 1, 2], 0) == True def test_empty_list(): assert has_subarray_with_sum([], 5) == False def test_one_element_list(): assert has_subarray_with_sum([5], 5) == True assert has_subarray_with_sum([5], 6) == False","solution":"def has_subarray_with_sum(power_levels, S): Determines whether there exists a contiguous subarray of wizards' power levels that sums exactly up to S. Parameters: power_levels (list of int): The list of integers representing wizards' power levels. S (int): The target sum. Returns: bool: True if there exists a contiguous subarray that sums up to S, False otherwise. current_sum = 0 start_index = 0 sums_map = {} for end_index, power_level in enumerate(power_levels): current_sum += power_level if current_sum == S: return True if (current_sum - S) in sums_map: return True sums_map[current_sum] = end_index return False"},{"question":"from typing import List def critical_connections(n: int, connections: List[List[int]]) -> List[List[int]]: Find all critical connections in a network of computers. Args: n (int): number of computers labeled from 0 to n-1. connections (List[List[int]]): list of pairs representing the connected computers. Returns: List[List[int]]: list of all critical connections in the network. >>> critical_connections(4, [[0, 1], [1, 2], [2, 0], [1, 3]]) == [[1, 3]] >>> critical_connections(3, [[0, 1], [1, 2], [2, 0]]) == []","solution":"def critical_connections(n, connections): from collections import defaultdict def dfs(node, parent, depth): ids[node] = low[node] = depth for neighbor in graph[node]: if neighbor == parent: continue if ids[neighbor] == -1: dfs(neighbor, node, depth + 1) low[node] = min(low[node], low[neighbor]) if ids[node] < low[neighbor]: result.append([node, neighbor]) else: low[node] = min(low[node], ids[neighbor]) graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) ids = [-1] * n low = [-1] * n result = [] for i in range(n): if ids[i] == -1: dfs(i, -1, 0) return result"},{"question":"from typing import List, Tuple def sum_queries(data: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the sum of elements for each query in the list of queries. Parameters: - data (List[int]): A list of integers. - queries (List[Tuple[int, int]]): A list of tuples where each tuple represents a query with start and end indices (i, j). Returns: - List[int]: A list of sums corresponding to each query. Example: >>> sum_queries([1, 2, 3, 4, 5], [(0, 2), (1, 3), (2, 4)]) [6, 9, 12] >>> sum_queries([10], [(0, 0)]) [10] >>> sum_queries([1, 2, 3, 4, 5], [(0, 4)]) [15] >>> sum_queries([1, 2, 3, 4, 5], []) [] >>> sum_queries([3, 1, 4, 1, 5, 9], [(2, 5)]) [19] >>> sum_queries([-2, 5, -1, 7, 3], [(0, 0), (4, 4), (0, 4), (1, 3)]) [-2, 3, 12, 11]","solution":"def sum_queries(data, queries): Returns the sum of elements for each query in the list of queries. Parameters: data (list): A list of integers. queries (list): A list of tuples where each tuple represents a query with start and end indices (i, j). Returns: list: A list of sums corresponding to each query. results = [] for i, j in queries: results.append(sum(data[i:j+1])) return results"},{"question":"def merge_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two arrays such that the even indices are from arr1 in ascending order and odd indices are from arr2 in descending order. >>> merge_arrays([4, 1, 3], [9, 5, 6]) [1, 9, 3, 6, 4, 5] >>> merge_arrays([7, 2, 5], [8, 3, 6]) [2, 8, 5, 6, 7, 3] >>> merge_arrays([-2, -6, -4], [-1, -3, -5]) [-6, -1, -4, -3, -2, -5] >>> merge_arrays([5, 5, 5], [5, 5, 5]) [5, 5, 5, 5, 5, 5] >>> merge_arrays([0, 1, 0], [0, 2, 0]) [0, 2, 0, 0, 1, 0]","solution":"def merge_arrays(arr1, arr2): Merges two arrays such that the even indices are from arr1 in ascending order and odd indices are from arr2 in descending order. # Sort arr1 in ascending order arr1_sorted = sorted(arr1) # Sort arr2 in descending order arr2_sorted = sorted(arr2, reverse=True) # Initialize result array with the size of arr1 and arr2 result = [0] * (len(arr1) + len(arr2)) # Fill the even indices with elements from arr1_sorted result[0::2] = arr1_sorted # Fill the odd indices with elements from arr2_sorted result[1::2] = arr2_sorted return result # Example usage # arr1 = [4, 1, 3] # arr2 = [9, 5, 6] # Resultant array should be [1, 9, 3, 6, 4, 5] # print(merge_arrays(arr1, arr2))"},{"question":"def process_string(s: str) -> str: Processes the string by removing the character preceding every '#' and the '#' itself. Args: s (str): input string containing lowercase alphabets and '#' characters. Returns: str: the final processed string after applying the described rules. Examples: >>> process_string(\\"ab#c\\") \\"ac\\" >>> process_string(\\"abcd\\") \\"ad\\" >>> process_string(\\"a#b#c#d#\\") \\"\\" >>> process_string(\\"#\\") \\"\\" >>> process_string(\\"ab#\\") \\"\\" >>> process_string(\\"#a\\") \\"a\\" >>> process_string(\\"ab\\") \\"b\\"","solution":"def process_string(s): Processes the string by removing the character preceding every '#' and the '#' itself. Args: s (str): input string containing lowercase alphabets and '#' characters. Returns: str: the final processed string after applying the described rules. result = [] for char in s: if char == '#': if result: result.pop() else: result.append(char) return ''.join(result) # Example usage: # s = \\"ab#c\\" # print(process_string(s)) # Output: \\"ac\\""},{"question":"def shortest_subarray_with_sum_at_least_x(arr: List[int], x: int) -> int: Determine the length of the shortest subarray (contiguous sequence) of \`arr\` whose sum is at least \`x\`. If such a subarray does not exist, return \`-1\`. Examples: >>> shortest_subarray_with_sum_at_least_x([2, -1, 2], 3) 3 >>> shortest_subarray_with_sum_at_least_x([8], 8) 1 >>> shortest_subarray_with_sum_at_least_x([-1, -2, -3, -4, -5], -1) 1 >>> shortest_subarray_with_sum_at_least_x([1, 2, 3, 4, 5], 20) -1 >>> shortest_subarray_with_sum_at_least_x([1, 2, 3, 4, 5], 9) 2 >>> shortest_subarray_with_sum_at_least_x([], 3) -1 # Your code here from solution import shortest_subarray_with_sum_at_least_x def test_example_case(): arr = [2, -1, 2] x = 3 assert shortest_subarray_with_sum_at_least_x(arr, x) == 3 def test_single_element(): arr = [8] x = 8 assert shortest_subarray_with_sum_at_least_x(arr, x) == 1 def test_all_elements_negative(): arr = [-1, -2, -3, -4, -5] x = -1 assert shortest_subarray_with_sum_at_least_x(arr, x) == 1 def test_no_valid_subarray(): arr = [1, 2, 3, 4, 5] x = 20 assert shortest_subarray_with_sum_at_least_x(arr, x) == -1 def test_multiple_subarrays(): arr = [1, 2, 3, 4, 5] x = 9 assert shortest_subarray_with_sum_at_least_x(arr, x) == 2 def test_empty_array(): arr = [] x = 3 assert shortest_subarray_with_sum_at_least_x(arr, x) == -1","solution":"def shortest_subarray_with_sum_at_least_x(arr, x): Returns the length of the shortest subarray whose sum is at least x. If such a subarray does not exist, returns -1. from collections import deque import sys n = len(arr) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] min_len = sys.maxsize deque_prefix_sums = deque() for i in range(n + 1): while deque_prefix_sums and prefix_sums[i] - prefix_sums[deque_prefix_sums[0]] >= x: min_len = min(min_len, i - deque_prefix_sums.popleft()) while deque_prefix_sums and prefix_sums[i] <= prefix_sums[deque_prefix_sums[-1]]: deque_prefix_sums.pop() deque_prefix_sums.append(i) return min_len if min_len != sys.maxsize else -1"},{"question":"from typing import List def longest_common_prefix(strs: List[str]) -> str: Finds the longest common prefix string amongst an array of strings. Parameters: strs (List[str]): A list of strings Returns: str: The longest common prefix or an empty string if there is none >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) 'inters' >>> longest_common_prefix([\\"throne\\", \\"throne\\"]) 'throne' >>> longest_common_prefix([\\"throne\\", \\"dungeon\\"]) '' >>> longest_common_prefix([\\"prefix\\", \\"suffix\\"]) '' >>> longest_common_prefix([\\"\\"]) '' >>> longest_common_prefix([\\"\\", \\"\\"]) '' >>> longest_common_prefix([\\"abcd\\", \\"ab\\", \\"abcp\\", \\"abc\\"]) 'ab' >>> longest_common_prefix([\\"abc\\"]) 'abc' >>> longest_common_prefix([]) '' pass","solution":"def longest_common_prefix(strs): Finds the longest common prefix string amongst an array of strings. Parameters: strs (List[str]): A list of strings Returns: str: The longest common prefix or an empty string if there is none if not strs: return \\"\\" prefix = strs[0] for s in strs[1:]: while s.find(prefix) != 0: prefix = prefix[:-1] if not prefix: return \\"\\" return prefix"},{"question":"class Node: def __init__(self, value=None, children=None): self.value = value self.children = children if children is not None else [] def level_order_traversal(root): Perform a level-order traversal of an n-ary tree. Args: root (Node): Root node of the n-ary tree. Returns: List[List[int]]: A list of lists where each sublist represents the nodes at that particular level. >>> root = Node(1, [Node(3, [Node(5), Node(6)]), Node(2), Node(4)]) >>> level_order_traversal(root) [[1], [3, 2, 4], [5, 6]] >>> root = None >>> level_order_traversal(root) [] >>> root = Node(1) >>> level_order_traversal(root) [[1]]","solution":"class Node: def __init__(self, value=None, children=None): self.value = value self.children = children if children is not None else [] def level_order_traversal(root): if not root: return [] result = [] queue = [root] while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.pop(0) current_level.append(node.value) queue.extend(node.children) result.append(current_level) return result"},{"question":"def three_sum(nums: List[int]) -> List[List[int]]: Returns a list of lists of unique triplets in the list nums that sum to zero. >>> three_sum([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, 3, 4, 5]) == [] >>> three_sum([-1, -1, 0, 1, 1]) == [[-1, 0, 1]] >>> three_sum([0, 0, 0]) == [[0, 0, 0]] >>> three_sum([-1, 0, 1, 2, -1, -4, -1]) == [[-1, -1, 2], [-1, 0, 1]]","solution":"def three_sum(nums): Returns a list of lists of unique triplets in the list nums that sum to zero. nums.sort() result = [] n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue # skip duplicates left, right = i + 1, n - 1 while left < right: total_sum = nums[i] + nums[left] + nums[right] if total_sum < 0: left += 1 elif total_sum > 0: right -= 1 else: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # skip duplicates while left < right and nums[right] == nums[right - 1]: right -= 1 # skip duplicates left += 1 right -= 1 return result"},{"question":"def maxSubarraySum(arr, x): Returns the maximum sum of any subarray of length x. Parameters: arr (list of int): The input array of integers. x (int): The length of the subarray. Returns: int: The maximum sum of any subarray of length x, or None if x is greater than the array length. >>> maxSubarraySum([1, 2, 3, 4, 5], 2) 9 >>> maxSubarraySum([-1, -2, -3, -4, -5], 1) -1 >>> maxSubarraySum([1, 2, 3, 4, 5], 1) 5 >>> maxSubarraySum([3, -2, 5, -1, 6, -7, 8], 3) 10 >>> maxSubarraySum([-5, -2, -6, -3], 2) -7 >>> maxSubarraySum([1, 2, 3, 4, 5], 5) 15 >>> maxSubarraySum([3], 1) 3 >>> maxSubarraySum([1, 2, 3], 4) None","solution":"def maxSubarraySum(arr, x): Returns the maximum sum of any subarray of length x. # Edge case: if x is greater than array length n = len(arr) if x > n: return None max_sum = float('-inf') current_sum = 0 for i in range(x): current_sum += arr[i] max_sum = current_sum for i in range(x, n): current_sum += arr[i] - arr[i - x] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def dutch_national_flag(arr): Sorts the array containing 0s, 1s, and 2s in ascending order using the Dutch National Flag algorithm. :param arr: List of integers containing only 0s, 1s, and 2s :return: Sorted list with 0s followed by 1s and then 2s >>> dutch_national_flag([2, 0, 1]) [0, 1, 2] >>> dutch_national_flag([2, 0, 1, 1, 0, 2]) [0, 0, 1, 1, 2, 2] >>> dutch_national_flag([1, 0, 2, 0, 1, 2, 1, 0]) [0, 0, 0, 1, 1, 1, 2, 2] >>> dutch_national_flag([0, 0, 0]) [0, 0, 0] >>> dutch_national_flag([1, 1, 1]) [1, 1, 1] >>> dutch_national_flag([2, 2, 2]) [2, 2, 2] >>> dutch_national_flag([]) [] >>> dutch_national_flag([0]) [0] >>> dutch_national_flag([1]) [1] >>> dutch_national_flag([2]) [2]","solution":"def dutch_national_flag(arr): Sorts the array containing 0s, 1s, and 2s in ascending order using the Dutch National Flag algorithm. :param arr: List of integers containing only 0s, 1s, and 2s :return: Sorted list with 0s followed by 1s and then 2s low = 0 mid = 0 high = len(arr) - 1 while mid <= high: if arr[mid] == 0: arr[low], arr[mid] = arr[mid], arr[low] low += 1 mid += 1 elif arr[mid] == 1: mid += 1 else: # arr[mid] == 2 arr[mid], arr[high] = arr[high], arr[mid] high -= 1 return arr"},{"question":"def subarray_sum(nums: List[int], target: int) -> int: Returns the number of subarrays that add up to the target. :param nums: List of integers. :param target: The target sum. :return: Number of subarrays that sum to target. >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([5], 5) 1 >>> subarray_sum([5], 10) 0 >>> subarray_sum([2, 2, 2, 2], 8) 1 >>> subarray_sum([1, 2, 1, 2, 1], 3) 4 >>> subarray_sum([-1, -1, 1], 0) 1 >>> subarray_sum([1, -1, 0], 0) 3 >>> subarray_sum([1, 2, 3], 10) 0 >>> subarray_sum([1]*10000, 10000) 1 >>> subarray_sum([-1, 2, 9, -3, -5], -1) 1","solution":"def subarray_sum(nums, target): Returns the number of subarrays that add up to the target. :param nums: List of integers. :param target: The target sum. :return: Number of subarrays that sum to target. count = 0 current_sum = 0 prefix_sum = {0: 1} for num in nums: current_sum += num if (current_sum - target) in prefix_sum: count += prefix_sum[current_sum - target] if current_sum in prefix_sum: prefix_sum[current_sum] += 1 else: prefix_sum[current_sum] = 1 return count"},{"question":"class MyHashMap: Implements a simple Hash Map without using any built-in hash table libraries. Methods: -------- - __init__() -> None : Initializes the HashMap. - put(int key, int value) -> None : Inserts a (key, value) pair into the HashMap. Updates the value if key exists. - get(int key) -> int : Returns the value associated with the specified key, or -1 if key does not exist. - remove(int key) -> None : Removes the key-value pair if the key exists in the HashMap. Examples: >>> hash_map = MyHashMap() >>> hash_map.put(1, 1) >>> hash_map.put(2, 2) >>> hash_map.get(1) # returns 1 1 >>> hash_map.get(3) # returns -1 (not found) -1 >>> hash_map.put(1, 10) >>> hash_map.get(1) # returns 10 (updated value) 10 >>> hash_map.remove(2) >>> hash_map.get(2) # returns -1 (not found) -1 >>> hash_map.put(2, 3) >>> hash_map.put(3, 3) >>> hash_map.remove(3) >>> hash_map.get(3) # returns -1 (not found) -1 >>> hash_map.put(3, 4) >>> hash_map.get(3) # returns 4 (value after re-put) 4 def __init__(self): pass def put(self, key: int, value: int) -> None: pass def get(self, key: int) -> int: pass def remove(self, key: int) -> None: pass","solution":"class MyHashMap: def __init__(self): self.size = 10000 self.buckets = [[] for _ in range(self.size)] def _hash(self, key): return key % self.size def put(self, key, value): hash_key = self._hash(key) bucket = self.buckets[hash_key] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) def get(self, key): hash_key = self._hash(key) bucket = self.buckets[hash_key] for k, v in bucket: if k == key: return v return -1 def remove(self, key): hash_key = self._hash(key) bucket = self.buckets[hash_key] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] return"},{"question":"def word_ladder_length(startWord, endWord, wordList): Returns the length of the shortest transformation sequence from startWord to endWord, altering one character at a time and using only words from wordList. >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) == 5 >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) == 0 >>> word_ladder_length(\\"hit\\", \\"hit\\", [\\"hit\\"]) == 1 >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hut\\",\\"but\\",\\"put\\",\\"cot\\",\\"cut\\"]) == 0 >>> word_ladder_length(\\"hit\\", \\"hog\\", [\\"hit\\",\\"hot\\",\\"hog\\"]) == 3","solution":"from collections import deque def word_ladder_length(startWord, endWord, wordList): Returns the length of the shortest transformation sequence from startWord to endWord, altering one character at a time and using only words from wordList. if endWord not in wordList: return 0 wordSet = set(wordList) queue = deque([(startWord, 1)]) while queue: currentWord, level = queue.popleft() if currentWord == endWord: return level for i in range(len(currentWord)): for c in 'abcdefghijklmnopqrstuvwxyz': nextWord = currentWord[:i] + c + currentWord[i+1:] if nextWord in wordSet: wordSet.remove(nextWord) queue.append((nextWord, level + 1)) return 0"},{"question":"def word_break(s: str, wordDict: List[str]) -> List[str]: Given a string s and a dictionary of words wordDict, return all the sentences possible by segmenting s such that each word is a valid dictionary word. >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) [\\"apple pen apple\\"] >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) [] >>> word_break(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) [\\"cats and dog\\", \\"cat sand dog\\"] >>> word_break(\\"\\", [\\"cat\\", \\"dog\\"]) [\\"\\"] >>> word_break(\\"aaa\\", [\\"a\\", \\"aa\\", \\"aaa\\"]) [\\"a a a\\", \\"aa a\\", \\"a aa\\", \\"aaa\\"]","solution":"def word_break(s, wordDict): Returns all possible sentences by segmenting s such that each word is a valid dictionary word. def dfs(s, word_set, memo): if s in memo: return memo[s] if not s: return [\\"\\"] res = [] for word in word_set: if s.startswith(word): suffix_ways = dfs(s[len(word):], word_set, memo) for way in suffix_ways: if way: res.append(word + \\" \\" + way) else: res.append(word) memo[s] = res return res word_set = set(wordDict) memo = {} return dfs(s, word_set, memo)"},{"question":"def trap_water(heights: list[int]) -> int: Calculate the total amount of water that can be trapped after raining. :param heights: List of non-negative integers representing the heights of bars. :return: Total amount of water trapped in units. >>> trap_water([4, 2, 0, 3, 2, 5]) 9 >>> trap_water([]) 0 >>> trap_water([0, 1, 2, 3, 4, 5]) 0 >>> trap_water([5, 4, 3, 2, 1, 0]) 0 >>> trap_water([0, 4, 2, 0]) 0 >>> trap_water([4, 0, 4]) 4 >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_water([3, 3, 3, 3]) 0","solution":"def trap_water(heights): Calculate the total amount of water that can be trapped after raining. :param heights: List of non-negative integers representing the heights of bars. :return: Total amount of water trapped in units. if not heights: return 0 n = len(heights) left, right = 0, n - 1 left_max, right_max = heights[left], heights[right] trapped_water = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) trapped_water += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) trapped_water += right_max - heights[right] return trapped_water"},{"question":"from typing import List def find_employee_order(employees: List[str], rules: List[List[int]]) -> List[str]: Find a valid ordering of employees such that the rearranging rules are satisfied. Args: employees: List of employee names. rules: List of rules in the form [a, b] where 'a' should be ordered before 'b'. Returns: List of employee names in a valid order or an empty list if no valid order exists. # Test cases from solution import find_employee_order def test_find_employee_order_simple_case(): employees = [\\"A\\", \\"B\\", \\"C\\"] rules = [[1, 2]] result = find_employee_order(employees, rules) assert result.index(\\"B\\") < result.index(\\"C\\") assert len(result) == len(employees) def test_find_employee_order_multiple_simple_rules(): employees = [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] rules = [[1, 2], [2, 3], [0, 1]] result = find_employee_order(employees, rules) assert result.index(\\"A\\") < result.index(\\"B\\") assert result.index(\\"B\\") < result.index(\\"C\\") assert result.index(\\"C\\") < result.index(\\"D\\") assert len(result) == len(employees) def test_find_employee_order_with_cycle(): employees = [\\"A\\", \\"B\\", \\"C\\"] rules = [[0, 1], [1, 2], [2, 0]] result = find_employee_order(employees, rules) assert result == [] def test_find_employee_order_no_rules(): employees = [\\"A\\", \\"B\\", \\"C\\"] rules = [] result = find_employee_order(employees, rules) assert set(result) == set(employees) def test_find_employee_order_complex_case(): employees = [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] rules = [[0, 1], [2, 3]] result = find_employee_order(employees, rules) assert result.index(\\"A\\") < result.index(\\"B\\") assert result.index(\\"C\\") < result.index(\\"D\\") assert len(result) == len(employees)","solution":"from collections import defaultdict, deque def find_employee_order(employees, rules): Find a valid ordering of employees such that the rearranging rules are satisfied. Args: employees: List of employee names. rules: List of rules in the form [a, b] where 'a' should be ordered before 'b'. Returns: List of employee names in a valid order or an empty list if no valid order exists. # Create graph and in-degree dictionary graph = defaultdict(list) in_degree = defaultdict(int) for rule in rules: graph[employees[rule[0]]].append(employees[rule[1]]) in_degree[employees[rule[1]]] += 1 # Queue for nodes with no incoming edges queue = deque(employee for employee in employees if in_degree[employee] == 0) result = [] while queue: current = queue.popleft() result.append(current) for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If result contains all employees, return it, else return empty list return result if len(result) == len(employees) else []"},{"question":"def can_form_target(words: List[str], target: str) -> bool: Determines if the target can be constructed by concatenating exactly two different strings from words. >>> can_form_target([\\"ab\\", \\"cd\\", \\"ef\\"], \\"abcd\\") True >>> can_form_target([\\"ab\\", \\"cs\\", \\"ef\\"], \\"abcd\\") False >>> can_form_target([\\"ab\\", \\"cd\\", \\"abab\\"], \\"abab\\") False >>> can_form_target([\\"ab\\", \\"c\\", \\"cd\\", \\"d\\"], \\"abcd\\") True >>> can_form_target([], \\"abcd\\") False >>> can_form_target([\\"ab\\", \\"bc\\"], \\"abcd\\") False","solution":"def can_form_target(words, target): Determines if the target can be constructed by concatenating exactly two different strings from words. Parameters: * words: List[str] - A list of scrambled words. * target: str - The target string to form. Returns: * bool - True if target can be formed, False otherwise. word_set = set(words) for i in range(1, len(target)): prefix = target[:i] suffix = target[i:] if prefix in word_set and suffix in word_set and prefix != suffix: return True return False"},{"question":"def longest_common_subsequence(text1: str, text2: str) -> int: Returns the length of the longest common subsequence of two given strings. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"longest\\", \\"stone\\") 3 >>> longest_common_subsequence(\\"a\\", \\"a\\") 1 >>> longest_common_subsequence(\\"a\\", \\"b\\") 0 >>> longest_common_subsequence(\\"aa\\", \\"aa\\") 2 >>> longest_common_subsequence(\\"aaaa\\", \\"aa\\") 2 >>> longest_common_subsequence(\\"abcdef\\", \\"aaabbbccc\\") 3 >>> longest_common_subsequence(\\"a\\"*100, \\"a\\"*50) 50 >>> longest_common_subsequence(\\"a\\"*1000, \\"b\\"*1000) 0 >>> longest_common_subsequence(\\"abcde\\", \\"edcba\\") 1","solution":"def longest_common_subsequence(text1, text2): Returns the length of the longest common subsequence of two given strings. m, n = len(text1), len(text2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def getMaximumGold(grid: List[List[int]]) -> int: Find the maximum amount of gold you can collect starting from any cell containing gold and moving to any adjacent cell up, down, left, or right without visiting any cell more than once. Obstacle cells are represented by -1, empty cells by 0, and cells with gold by 1. >>> getMaximumGold([ ... [1, 0], ... [0, 0] ... ]) == 1 >>> getMaximumGold([ ... [1, 0], ... [0, 1] ... ]) == 1 >>> getMaximumGold([ ... [0, 0], ... [0, 0] ... ]) == 0 >>> getMaximumGold([ ... [1, -1], ... [-1, 1] ... ]) == 1 >>> getMaximumGold([ ... [0, 6, 0], ... [5, 8, 7], ... [0, 9, 0] ... ]) == 24 >>> getMaximumGold([ ... [1, 0, 7], ... [2, 0, 6], ... [3, 4, 5], ... [0, 3, 0], ... [9, 0, 20] ... ]) == 28","solution":"def getMaximumGold(grid): def dfs(x, y, current_gold): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] <= 0: return current_gold original_value = grid[x][y] grid[x][y] = 0 # mark the cell as visited current_gold += original_value max_gold = current_gold for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_x, new_y = x + dx, y + dy max_gold = max(max_gold, dfs(new_x, new_y, current_gold)) grid[x][y] = original_value # unmark the cell return max_gold max_collected_gold = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] > 0: max_collected_gold = max(max_collected_gold, dfs(i, j, 0)) return max_collected_gold"},{"question":"def largest_numerical_value(s: str) -> int: Returns the largest numerical value formed by concatenating all digit characters in the string s. If there are no digit characters in the string, returns -1. >>> largest_numerical_value(\\"12345\\") == 54321 >>> largest_numerical_value(\\"a1b2c3d4\\") == 4321 >>> largest_numerical_value(\\"abcdef\\") == -1 >>> largest_numerical_value(\\"\\") == -1 >>> largest_numerical_value(\\"1122334455\\") == 5544332211 >>> largest_numerical_value(\\"a1!2@3#4\\") == 4321","solution":"def largest_numerical_value(s): Returns the largest numerical value formed by concatenating all digit characters in the string s. If there are no digit characters in the string, returns -1. digits = [char for char in s if char.isdigit()] if not digits: return -1 digits.sort(reverse=True) return int(''.join(digits))"},{"question":"def remove_adjacent_pairs(s: str) -> str: Removes pairs of adjacent equal characters from the string s until no more pairs can be removed. Returns the resulting string. >>> remove_adjacent_pairs('') == '' >>> remove_adjacent_pairs('abc') == 'abc' >>> remove_adjacent_pairs('aabb') == '' >>> remove_adjacent_pairs('abbaca') == 'ca' >>> remove_adjacent_pairs('abccba') == '' >>> remove_adjacent_pairs('abccbaab') == 'ab'","solution":"def remove_adjacent_pairs(s): Removes pairs of adjacent equal characters from the string s until no more pairs can be removed. Returns the resulting string. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers, addition (+), and multiplication (*) operators. Multiplication has higher precedence over addition. :param expression: str, mathematical expression :return: int, result of evaluated expression >>> evaluate_expression(\\"2+3*2\\") 8 >>> evaluate_expression(\\"2*3+2*2\\") 10 >>> evaluate_expression(\\"1+2+3+4\\") 10 >>> evaluate_expression(\\"2*3*4\\") 24 >>> evaluate_expression(\\"2+3*4+5*6\\") 44","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers, addition (+), and multiplication (*) operators. Multiplication has higher precedence over addition. :param expression: str, mathematical expression :return: int, result of evaluated expression def evaluate(tokens): stack = [] current_number = 0 operator = '+' for i, token in enumerate(tokens): if token.isdigit(): current_number = current_number * 10 + int(token) if token in \\"+*\\": if operator == '+': stack.append(current_number) elif operator == '*': stack[-1] = stack[-1] * current_number operator = token current_number = 0 if i == len(tokens) - 1: if operator == '+': stack.append(current_number) elif operator == '*': stack[-1] = stack[-1] * current_number return sum(stack) return evaluate(expression)"},{"question":"from typing import List def max_keys_collected(intervals: List[List[int]], startTime: int, endTime: int) -> int: Returns the maximum number of distinct keys that the thief can collect during their time in the room. >>> max_keys_collected([[1, 4], [2, 5], [3, 6]], 1, 6) 3 >>> max_keys_collected([[1, 3], [2, 5], [4, 7]], 2, 6) 2 >>> max_keys_collected([[1, 3], [4, 5], [7, 8]], 3, 7) 1 >>> max_keys_collected([[1, 3], [4, 5], [7, 8]], 8, 10) 0 >>> max_keys_collected([[1, 10], [2, 5], [2, 7], [3, 8]], 1, 6) 4 >>> max_keys_collected([[1, 2], [2, 3], [3, 4], [4, 5]], 2, 4) 2","solution":"def max_keys_collected(intervals, startTime, endTime): Returns the maximum number of distinct keys that the thief can collect during their time in the room. starts = [] ends = [] for interval in intervals: if interval[0] < endTime and interval[1] > startTime: starts.append(max(interval[0], startTime)) ends.append(min(interval[1], endTime)) starts.sort() ends.sort() active_keys = 0 max_keys = 0 i, j = 0, 0 while i < len(starts): if starts[i] <= ends[j]: active_keys += 1 max_keys = max(max_keys, active_keys) i += 1 else: active_keys -= 1 j += 1 return max_keys"},{"question":"def canJump(nums: List[int]) -> bool: Determines if you can reach the last index starting from the first index. :param nums: List[int], a list of non-negative integers representing the maximum jump length at each position. :return: bool, True if you can reach the last index, False otherwise >>> canJump([2, 3, 1, 1, 4]) True >>> canJump([3, 2, 1, 0, 4]) False >>> canJump([0]) True >>> canJump([0, 0, 0, 0]) False >>> canJump([5, 9, 3, 2, 1, 0, 2, 3, 3, 1, 0, 0]) True >>> canJump([2, 5, 0, 0]) True >>> canJump([]) True >>> canJump([2, 0, 0]) True >>> canJump([0, 2, 0, 0]) False","solution":"def canJump(nums): Determines if you can reach the last index starting from the first index. :param nums: List[int], a list of non-negative integers representing the maximum jump length at each position. :return: bool, True if you can reach the last index, False otherwise max_reachable = 0 for i, jump in enumerate(nums): if i > max_reachable: # Can't move further than the current maximum reachable index return False max_reachable = max(max_reachable, i + jump) if max_reachable >= len(nums) - 1: return True return max_reachable >= len(nums) - 1"},{"question":"def num_islands(grid): Returns the number of islands in the given 2D integer grid. >>> num_islands([[\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"]]) == 0 >>> num_islands([[\\"1\\", \\"1\\", \\"1\\"], [\\"0\\", \\"1\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"]]) == 1 >>> num_islands([[\\"1\\", \\"0\\", \\"1\\"], [\\"0\\", \\"1\\", \\"0\\"], [\\"1\\", \\"0\\", \\"1\\"]]) == 5 >>> num_islands([ ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ... ]) == 3 >>> num_islands([]) == 0","solution":"def num_islands(grid): Returns the number of islands in the given grid. if not grid: return 0 def dfs(grid, i, j): if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == \\"0\\": return grid[i][j] = \\"0\\" dfs(grid, i-1, j) dfs(grid, i+1, j) dfs(grid, i, j-1) dfs(grid, i, j+1) num_of_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \\"1\\": num_of_islands += 1 dfs(grid, i, j) return num_of_islands"},{"question":"from typing import List def can_form_target(words: List[str], target: str) -> bool: Determine if target can be formed by concatenating any sub-sequence of strings from words. >>> can_form_target([\\"ab\\", \\"cde\\", \\"fg\\"], \\"abcdefg\\") True >>> can_form_target([\\"ab\\", \\"cd\\", \\"ef\\", \\"g\\", \\"d\\"], \\"abcdefg\\") True >>> can_form_target([\\"ab\\", \\"cd\\", \\"ef\\"], \\"abcdefg\\") False >>> can_form_target([\\"ab\\", \\"cd\\", \\"e\\"], \\"abcdefg\\") False >>> can_form_target([\\"ab\\", \\"cd\\", \\"ef\\"], \\"\\") True >>> can_form_target([], \\"abc\\") False >>> can_form_target([], \\"\\") True","solution":"def can_form_target(words, target): Determine if target can be formed by concatenating any sub-sequence of strings from words. from collections import Counter # Count the frequency of each character in target target_counter = Counter(target) # Count the frequency of each character in all words combined words_counter = Counter(''.join(words)) # Check if each character in target can be formed by characters in words for char in target_counter: if target_counter[char] > words_counter[char]: return False return True"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Compute the maximum area of a rectangle formed by any number of contiguous buildings. >>> largest_rectangle_area([4]) 4 >>> largest_rectangle_area([4, 4]) 8 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([3, 3, 3, 3]) 12 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([0, 2, 0, 3, 4, 0, 5, 0]) 6 # Implement the function to calculate the largest rectangle area","solution":"def largest_rectangle_area(heights): Returns the maximum rectangle area formed by any number of contiguous buildings. # Initialize max_area and stack max_area = 0 stack = [] # Iterate through each building along with the dummy end building height of 0 for i in range(len(heights) + 1): current_height = heights[i] if i < len(heights) else 0 # While the stack is not empty, and the current height is less than the height of the building at stack's top index while stack and current_height < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) # Push the current index into the stack stack.append(i) return max_area"},{"question":"def longest_distinct_substring_length(s: str) -> int: Given a string \`s\` containing only lowercase English letters, find the length of the longest substring with all distinct characters. >>> longest_distinct_substring_length(\\"abcabcbb\\") 3 >>> longest_distinct_substring_length(\\"bbbbb\\") 1 >>> longest_distinct_substring_length(\\"pwwkew\\") 3 >>> longest_distinct_substring_length(\\"\\") 0 >>> longest_distinct_substring_length(\\"abcdefgh\\") 8 >>> longest_distinct_substring_length(\\"aabbcc\\") 2 >>> longest_distinct_substring_length(\\"abac\\") 3 >>> longest_distinct_substring_length(\\"dvdf\\") 3 >>> longest_distinct_substring_length(\\"anviaj\\") 5 >>> longest_distinct_substring_length(\\" \\") 1 >>> longest_distinct_substring_length(\\"au\\") 2 >>> longest_distinct_substring_length(\\"abba\\") 2","solution":"def longest_distinct_substring_length(s): Returns the length of the longest substring with all distinct characters. start = 0 max_length = 0 used_chars = {} for i, char in enumerate(s): if char in used_chars and used_chars[char] >= start: start = used_chars[char] + 1 used_chars[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def can_make_amount(coins: List[int], amount: int) -> bool: Determines if it is possible to create the exact amount using any combination of given coin denominations. :param coins: List[int] - List of non-negative integers representing coin denominations. :param amount: int - The target amount to create. :return: bool - True if the amount can be made exactly using any combination of coins, False otherwise. >>> can_make_amount([1, 2, 5], 11) True >>> can_make_amount([2], 3) False >>> can_make_amount([1, 2, 5], 0) True >>> can_make_amount([], 1) False >>> can_make_amount([7], 14) True >>> can_make_amount([7], 15) False >>> can_make_amount([1, 3, 4], 6) True >>> can_make_amount([1, 3, 4], 7) True >>> can_make_amount([1, 3, 4], 2) True >>> can_make_amount([1, 3, 4], 11) True","solution":"def can_make_amount(coins, amount): Determines if it's possible to create the exact amount using given coin denominations. :param coins: List[int] - List of coin denominations. :param amount: int - The target amount to create. :return: bool - True if the amount can be made exactly using any combination of coins, False otherwise. dp = [False] * (amount + 1) dp[0] = True # Base case: zero amount can always be made with no coins. for coin in coins: for i in range(coin, amount + 1): if dp[i - coin]: dp[i] = True return dp[amount]"},{"question":"def min_moves_to_gather_tokens(arr: List[int]) -> int: Returns the minimum number of moves required to accumulate all tokens into a single pile. >>> min_moves_to_gather_tokens([5]) 0 >>> min_moves_to_gather_tokens([1, 2]) 1","solution":"def min_moves_to_gather_tokens(arr): Returns the minimum number of moves required to accumulate all tokens into a single pile. # The minimum moves to gather all tokens is simply the length of the array minus one, # because in each move we are reducing the number of piles by one. n = len(arr) return n - 1"},{"question":"def max_items_within_budget(nums: List[int], k: int) -> int: Given an array of integers \`nums\`, representing the prices of various items, and an integer \`k\` representing the budget limit, return the maximum number of items that can be purchased without exceeding the budget \`k\`. Each item can only be purchased once, and you must buy the items in whole. Parameters: nums (list of int): Prices of various items. k (int): The budget limit. Returns: int: Maximum number of items purchasable within the budget. Example: >>> max_items_within_budget([20, 10, 5, 30, 100], 35) 3 >>> max_items_within_budget([10, 20, 30], 5) 0 >>> max_items_within_budget([5, 2, 1, 3], 20) 4 >>> max_items_within_budget([7, 10, 3, 1, 2], 10) 3 >>> max_items_within_budget([12, 5, 7, 3, 1], 50) 5 >>> max_items_within_budget([5, 5, 5, 5, 5], 20) 4 # Your implementation here from typing import List def test_max_items_within_budget_example_case(): assert max_items_within_budget([20, 10, 5, 30, 100], 35) == 3 def test_max_items_within_budget_empty_list(): assert max_items_within_budget([], 10) == 0 def test_max_items_within_budget_no_items_within_budget(): assert max_items_within_budget([10, 20, 30], 5) == 0 def test_max_items_within_budget_all_items_within_budget(): assert max_items_within_budget([5, 2, 1, 3], 20) == 4 def test_max_items_within_budget_some_items_within_budget(): assert max_items_within_budget([7, 10, 3, 1, 2], 10) == 3 def test_max_items_within_budget_large_k_value(): assert max_items_within_budget([12, 5, 7, 3, 1], 50) == 5 def test_max_items_within_budget_repeated_prices(): assert max_items_within_budget([5, 5, 5, 5, 5], 20) == 4","solution":"def max_items_within_budget(nums, k): Returns the maximum number of items that can be purchased within the given budget k. Parameters: nums (list of int): Prices of various items. k (int): The budget limit. Returns: int: Maximum number of items purchasable within the budget. nums.sort() total_cost = 0 items_count = 0 for price in nums: if total_cost + price <= k: total_cost += price items_count += 1 else: break return items_count"},{"question":"def rob(nums, k): Returns the maximum amount of money that can be robbed from the houses, considering that after robbing one house, you must skip at least k houses. :param nums: List[int] - list of integers representing the amount of money at each house :param k: int - the number of houses you must skip after robbing one house :return: int - the maximum amount of money you can rob >>> rob([10], 3) == 10 >>> rob([10, 20], 1) == 20 >>> rob([10, 20, 30], 1) == 40 >>> rob([10, 20, 30], 2) == 30 >>> rob([10, 20, 30, 40], 1) == 60 >>> rob([10, 20, 30, 40], 3) == 40 >>> rob([0, 0, 0, 0], 1) == 0 >>> rob([5, 1, 1, 5], 1) == 10 >>> rob([5, 10, 15], 5) == 15 >>> rob([30, 20, 10, 5], 1) == 40","solution":"def rob(nums, k): Returns the maximum amount of money that can be robbed from the houses, considering that after robbing one house, you must skip at least k houses. :param nums: List[int] - list of integers representing the amount of money at each house :param k: int - the number of houses you must skip after robbing one house :return: int - the maximum amount of money you can rob if not nums: return 0 n = len(nums) if k >= n: return max(nums) dp = [0] * n dp[0] = nums[0] for i in range(1, n): if i <= k: dp[i] = max(dp[i-1], nums[i]) else: dp[i] = max(dp[i-1], nums[i] + dp[i-k-1]) return max(dp)"},{"question":"class ParkingLot: def __init__(self, num_slots): Initializes the parking lot with the given number of slots. def park(self, carPlate): Parks a car with the given plate number into the first available slot. Returns False if the car is already parked or the parking lot is full, otherwise parks the car and returns True. def leave(self, carPlate): Removes the car with the given plate number from the parking lot. Returns False if the car is not parked, otherwise removes the car and returns True. def status(self): Returns a list of the current car plate numbers in the parking lot, sorted from the first slot to the last slot. Empty slots are represented by None. # Unit Tests def test_park(): lot = ParkingLot(3) assert lot.park(\\"ABC123\\") == True assert lot.park(\\"DEF456\\") == True assert lot.park(\\"GHI789\\") == True assert lot.park(\\"JKL012\\") == False # Lot is full def test_park_already_parked(): lot = ParkingLot(3) assert lot.park(\\"ABC123\\") == True assert lot.park(\\"ABC123\\") == False # Car already parked def test_leave(): lot = ParkingLot(3) lot.park(\\"ABC123\\") lot.park(\\"DEF456\\") assert lot.leave(\\"ABC123\\") == True assert lot.leave(\\"ABC123\\") == False # Car already left assert lot.park(\\"ABC123\\") == True # Car can be parked again def test_status(): lot = ParkingLot(3) lot.park(\\"ABC123\\") lot.park(\\"DEF456\\") assert lot.status() == [\\"ABC123\\", \\"DEF456\\", None] lot.leave(\\"ABC123\\") assert lot.status() == [None, \\"DEF456\\", None] lot.park(\\"GHI789\\") assert lot.status() == [\\"GHI789\\", \\"DEF456\\", None]","solution":"class ParkingLot: def __init__(self, num_slots): Initializes the parking lot with the given number of slots. self.num_slots = num_slots self.slots = [None] * num_slots def park(self, carPlate): Parks a car with the given plate number into the first available slot. Returns False if the car is already parked or the parking lot is full, otherwise parks the car and returns True. if carPlate in self.slots: return False for i in range(self.num_slots): if self.slots[i] is None: self.slots[i] = carPlate return True return False def leave(self, carPlate): Removes the car with the given plate number from the parking lot. Returns False if the car is not parked, otherwise removes the car and returns True. if carPlate in self.slots: index = self.slots.index(carPlate) self.slots[index] = None return True return False def status(self): Returns a list of the current car plate numbers in the parking lot, sorted from the first slot to the last slot. Empty slots are represented by None. return self.slots"},{"question":"from typing import List def max_money_collected(grid: List[List[int]]) -> int: Computes the maximum amount of money that can be collected from the top-left corner to the bottom-right corner of the given grid. :param grid: List[List[int]] - 2D list of non-negative integers representing the grid :return: int - The maximum amount of money that can be collected >>> grid1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> max_money_collected(grid1) 29 # Path: 1 -> 2 -> 3 -> 6 -> 9 >>> grid2 = [ [1], [2], [3] ] >>> max_money_collected(grid2) 6 # Path: 1 -> 2 -> 3 >>> grid3 = [[1, 2, 3]] >>> max_money_collected(grid3) 6 # Path: 1 -> 2 -> 3 >>> grid4 = [[5]] >>> max_money_collected(grid4) 5 # Path: 5 >>> grid5 = [] >>> max_money_collected(grid5) 0 # Empty grid >>> grid6 = [[]] >>> max_money_collected(grid6) 0 # Empty inner grid","solution":"def max_money_collected(grid): Computes the maximum amount of money that can be collected from the top-left corner to the bottom-right corner of the given grid. :param grid: List[List[int]] - 2D list of non-negative integers representing the grid :return: int - The maximum amount of money that can be collected if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize a dp table dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def pruneTree(root): Prune the tree such that every subtree not containing a 1 is removed. pass import pytest def tree_equals(t1, t2): if not t1 and not t2: return True if t1 and t2: return t1.val == t2.val and tree_equals(t1.left, t2.left) and tree_equals(t1.right, t2.right) return False def test_prune_empty_tree(): assert pruneTree(None) == None def test_prune_all_zero_tree(): root = TreeNode(0) root.left = TreeNode(0) root.right = TreeNode(0) pruned = pruneTree(root) assert pruned == None def test_prune_already_pruned_tree(): root = TreeNode(1) root.left = TreeNode(1) root.right = TreeNode(1) pruned = pruneTree(root) assert tree_equals(pruned, root) def test_prune_tree_with_zeros_and_ones(): root = TreeNode(1) root.left = TreeNode(0) root.right = TreeNode(1) root.left.left = TreeNode(0) root.left.right = TreeNode(0) root.right.left = TreeNode(0) root.right.right = TreeNode(1) pruned = pruneTree(root) expected = TreeNode(1) expected.right = TreeNode(1) expected.right.right = TreeNode(1) assert tree_equals(pruned, expected)","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def pruneTree(root): Prune the tree such that every subtree not containing a 1 is removed. if not root: return None root.left = pruneTree(root.left) root.right = pruneTree(root.right) if root.val == 0 and not root.left and not root.right: return None return root"},{"question":"class MeetingScheduler: A class to manage a series of meetings. Methods: - scheduleMeeting(self, startTime: int, endTime: int) -> bool: Attempts to schedule a new meeting. - cancelMeeting(self, startTime: int, endTime: int) -> None: Cancels an existing meeting. - getAllMeetings(self) -> List[List[int]]: Returns a list of all scheduled meetings. Example Usage: >>> scheduler = MeetingScheduler() >>> scheduler.scheduleMeeting(9, 10) True >>> scheduler.scheduleMeeting(10, 11) True >>> scheduler.getAllMeetings() [[9, 10], [10, 11]] >>> scheduler.scheduleMeeting(9, 11) False >>> scheduler.cancelMeeting(9, 10) >>> scheduler.getAllMeetings() [[10, 11]] >>> scheduler.cancelMeeting(10, 11) >>> scheduler.getAllMeetings() [] def __init__(self): pass def scheduleMeeting(self, startTime: int, endTime: int) -> bool: pass def cancelMeeting(self, startTime: int, endTime: int) -> None: pass def getAllMeetings(self) -> List[List[int]]: pass","solution":"class MeetingScheduler: def __init__(self): # Initialize an empty list for meetings self.meetings = [] def scheduleMeeting(self, startTime, endTime): # Check for conflicts with existing meetings for meeting in self.meetings: if not (endTime <= meeting[0] or startTime >= meeting[1]): return False # If no conflicts, add the new meeting self.meetings.append([startTime, endTime]) # Sort meetings by start time self.meetings.sort() return True def cancelMeeting(self, startTime, endTime): # Find and cancel the meeting for meeting in self.meetings: if meeting[0] == startTime and meeting[1] == endTime: self.meetings.remove(meeting) break def getAllMeetings(self): # Return all meetings return self.meetings"},{"question":"def merge(nums1, m, nums2, n): Merge nums2 into nums1 as one sorted array in-place. :param nums1: List[int], first list with size m + n initialized with m elements followed by n zeros :param m: int, number of initialized elements in nums1 :param nums2: List[int], second list with n elements :param n: int, number of elements in nums2 :return: None, modifies nums1 in-place >>> nums1 = [1, 2, 3, 0, 0, 0] >>> nums2 = [2, 5, 6] >>> merge(nums1, 3, nums2, 3) >>> nums1 [1, 2, 2, 3, 5, 6] >>> nums1 = [0, 0, 0, 0, 0] >>> nums2 = [1, 2, 3, 4, 5] >>> merge(nums1, 0, nums2, 5) >>> nums1 [1, 2, 3, 4, 5] >>> nums1 = [1, 2, 3, 0, 0, 0] >>> nums2 = [] >>> merge(nums1, 3, nums2, 0) >>> nums1 [1, 2, 3, 0, 0, 0] >>> nums1 = [0, 0, 0] >>> nums2 = [1, 2, 3] >>> merge(nums1, 0, nums2, 3) >>> nums1 [1, 2, 3] >>> nums1 = [1, 1, 1, 0, 0, 0] >>> nums2 = [1, 1, 1] >>> merge(nums1, 3, nums2, 3) >>> nums1 [1, 1, 1, 1, 1, 1]","solution":"def merge(nums1, m, nums2, n): Merge nums2 into nums1 as one sorted array in-place. :param nums1: List[int], first list with size m + n initialized with m elements followed by n zeros :param m: int, number of initialized elements in nums1 :param nums2: List[int], second list with n elements :param n: int, number of elements in nums2 :return: None, modifies nums1 in-place # Start filling nums1 from the end p1, p2, p = m - 1, n - 1, m + n - 1 while p1 >= 0 and p2 >= 0: if nums1[p1] > nums2[p2]: nums1[p] = nums1[p1] p1 -= 1 else: nums1[p] = nums2[p2] p2 -= 1 p -= 1 # If there are remaining elements in nums2, add them while p2 >= 0: nums1[p] = nums2[p2] p -= 1 p2 -= 1"},{"question":"def longest_tired_shift(hours: List[int]) -> int: Returns the length of the longest shift of consecutive tired days. Args: hours (List[int]): List of integers representing hours worked each day. Returns: int: Length of the longest shift of consecutive tired days. >>> longest_tired_shift([7, 8, 6, 7]) 0 >>> longest_tired_shift([9]) 1 >>> longest_tired_shift([9, 10, 11, 12]) 4 >>> longest_tired_shift([10, 9, 8, 7]) 2 >>> longest_tired_shift([7, 8, 10, 9, 11]) 3 >>> longest_tired_shift([9, 10, 8, 7, 11, 12, 10, 8]) 3 >>> longest_tired_shift([]) 0","solution":"def longest_tired_shift(hours): Returns the length of the longest shift of consecutive tired days max_shift, current_shift = 0, 0 for hour in hours: if hour > 8: current_shift += 1 else: max_shift = max(max_shift, current_shift) current_shift = 0 return max(max_shift, current_shift)"},{"question":"def highest_elevation(changes: List[int]) -> int: Returns the highest elevation point that can be reached starting from an initial elevation of 0. Parameters: changes (list of int): The change in elevation at each step. Returns: int: The highest elevation point. >>> highest_elevation([1, 2, 3]) 6 >>> highest_elevation([1, -1, 1, 1, -1, 3, -2, 2]) 4 >>> highest_elevation([-1, -2, -3]) 0 >>> highest_elevation([2, 3, 1, 5]) 11 >>> highest_elevation([2, -2, 3, -3, 4, -4]) 4","solution":"def highest_elevation(changes): Returns the highest elevation point that can be reached starting from an initial elevation of 0. Parameters: changes (list of int): The change in elevation at each step. Returns: int: The highest elevation point. current_elevation = 0 highest_elevation_reached = 0 for change in changes: current_elevation += change if current_elevation > highest_elevation_reached: highest_elevation_reached = current_elevation return highest_elevation_reached"},{"question":"def maxArea(height: List[int]) -> int: This function returns the maximum area of water that can be trapped between buildings. >>> maxArea([1,8,6,2,5,4,8,3,7]) 49 >>> maxArea([1,1]) 1 >>> maxArea([4,3,2,1,4]) 16 >>> maxArea([1,2,1]) 2 >>> maxArea([1]) 0 >>> maxArea([]) 0 >>> maxArea([5,5,5,5,5]) 20","solution":"def maxArea(height): This function returns the maximum area of water that can be trapped between buildings. :param height: List of integers representing the height of buildings :return: Integer representing the maximum trapped water area left, right = 0, len(height) - 1 max_area = 0 while left < right: # Calculate the width and height for the current left and right pointers width = right - left current_height = min(height[left], height[right]) # Update the maximum area if the current calculated area is larger max_area = max(max_area, width * current_height) # Move the pointers inward to potentially find a larger area if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Implement a function that takes a list of integers and a target integer as input. The function should return the indices of the two numbers such that they add up to the target. Assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Args: nums (List[int]): List of integers. target (int): Target integer. Returns: List[int]: Indices of the two numbers. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([1, 2, 3, 4, 5], 9) [3, 4] >>> two_sum([-3, 4, 3, 90], 0) [0, 2]","solution":"def two_sum(nums, target): Returns indices of the two numbers such that they add up to the target. Args: nums (List[int]): List of integers. target (int): Target integer. Returns: List[int]: Indices of the two numbers. num_map = {} for i, num in enumerate(nums): complement = target - num if complement in num_map: return [num_map[complement], i] num_map[num] = i"},{"question":"def longest_str_chain(words: List[str]) -> int: Given a list of strings \`words\`, return the length of the longest sequence of strings such that each string in the sequence is formed by adding exactly one letter to the previous string in the sequence. Each added letter can be inserted at any position in the previous string. Each string in the list can only be used once in the sequence. >>> longest_str_chain([\\"a\\"]) 1 >>> longest_str_chain([\\"a\\", \\"b\\", \\"c\\"]) 1 >>> longest_str_chain([\\"a\\", \\"ab\\", \\"abc\\"]) 3 >>> longest_str_chain([\\"a\\", \\"ba\\", \\"bda\\", \\"bdca\\"]) 4 >>> longest_str_chain([\\"xbc\\",\\"pcxbcf\\",\\"xb\\",\\"cxbc\\",\\"pcxbc\\"]) 5 >>> longest_str_chain([\\"xyz\\", \\"xy\\", \\"x\\"]) 3 >>> longest_str_chain([\\"a\\", \\"b\\", \\"ba\\", \\"bca\\", \\"bda\\", \\"bdca\\", \\"bd\\"]) 4 pass","solution":"def longest_str_chain(words): Returns the length of the longest sequence of strings such that each string in the sequence is formed by adding exactly one letter to the previous string in the sequence. words.sort(key=len) dp = {} longest_chain_length = 1 for word in words: dp[word] = 1 for i in range(len(word)): predecessor = word[:i] + word[i+1:] if predecessor in dp: dp[word] = max(dp[word], dp[predecessor] + 1) longest_chain_length = max(longest_chain_length, dp[word]) return longest_chain_length"},{"question":"def num_increasing_subsequences(arr): Return the total number of strictly increasing subsequences derived from the array. The result is modulo 109 + 7. >>> num_increasing_subsequences([1]) == 1 >>> num_increasing_subsequences([1, 2]) == 3 >>> num_increasing_subsequences([2, 1]) == 2 >>> num_increasing_subsequences([1, 3, 2]) == 5 >>> num_increasing_subsequences([3, 3, 3]) == 3 >>> num_increasing_subsequences([1, 2, 3, 4]) == 15 # your code here","solution":"MOD = 10**9 + 7 def num_increasing_subsequences(arr): n = len(arr) dp = [0] * n total_subsequences = 0 for i in range(n): dp[i] = 1 # single element is considered as an increasing subsequence for j in range(i): if arr[j] < arr[i]: dp[i] = (dp[i] + dp[j]) % MOD total_subsequences = (total_subsequences + dp[i]) % MOD return total_subsequences"},{"question":"def remove_duplicates(s: str) -> str: Returns a new string such that each character from s appears exactly once in the same order as they appear in s. Only the first appearance is considered and all subsequent occurrences are ignored. >>> remove_duplicates(\\"abcdef\\") \\"abcdef\\" >>> remove_duplicates(\\"aabbcc\\") \\"abc\\" >>> remove_duplicates(\\"abacbd\\") \\"abcd\\" >>> remove_duplicates(\\"aaaaa\\") \\"a\\" >>> remove_duplicates(\\"\\") \\"\\" >>> remove_duplicates(\\"z\\") \\"z\\" >>> remove_duplicates(\\"thequickbrownfoxjumpsoverthelazydog\\") \\"thequickbrownfxjmpsvlazydg\\"","solution":"def remove_duplicates(s): Returns a new string with characters from s that appear only once in the order they first appear in s. seen = set() result = [] for char in s: if char not in seen: result.append(char) seen.add(char) return ''.join(result)"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters in the given string s. >>> length_of_longest_substring('') == 0 >>> length_of_longest_substring('a') == 1 >>> length_of_longest_substring('aaaaaa') == 1 >>> length_of_longest_substring('abcdef') == 6 >>> length_of_longest_substring('abcabcbb') == 3 >>> length_of_longest_substring('bbbbb') == 1 >>> length_of_longest_substring('pwwkew') == 3 >>> length_of_longest_substring('dvdf') == 3 pass","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters in the given string s. char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"def is_concatenation(s: str, words: List[str]) -> bool: Check if \`s\` is the concatenation of each word in \`words\` exactly once and without any intervening characters. >>> is_concatenation(\\"foobar\\", [\\"foo\\", \\"bar\\"]) == True >>> is_concatenation(\\"barfoo\\", [\\"foo\\", \\"bar\\"]) == True >>> is_concatenation(\\"foobarbaz\\", [\\"foo\\", \\"bar\\"]) == False >>> is_concatenation(\\"hello\\", [\\"hello\\"]) == True >>> is_concatenation(\\"hello\\", [\\"world\\"]) == False >>> is_concatenation(\\"\\", []) == True >>> is_concatenation(\\"\\", [\\"nonempty\\"]) == False >>> is_concatenation(\\"thequickbrownfox\\", [\\"quick\\", \\"brown\\", \\"the\\", \\"fox\\"]) == True >>> is_concatenation(\\"thequickbrownfox\\", [\\"quick\\", \\"brown\\", \\"fox\\"]) == False >>> is_concatenation(\\"thequickbrownfoxx\\", [\\"quick\\", \\"brown\\", \\"the\\", \\"fox\\"]) == False","solution":"def is_concatenation(s, words): Returns True if s can be formed by concatenating all the words in the words list exactly once. from itertools import permutations for perm in permutations(words): if \\"\\".join(perm) == s: return True return False"},{"question":"def smallest_lexicographical_string(s: str, indices: List[int]) -> str: Given a string s and an array of integers representing indices of the original string, return the smallest lexicographical string that can be obtained by removing characters at the given indices and shifting the remaining characters to the left. If no indices are provided, return the original string. >>> smallest_lexicographical_string(\\"abcdef\\", []) \\"abcdef\\" >>> smallest_lexicographical_string(\\"abcdef\\", [3]) \\"abcef\\" >>> smallest_lexicographical_string(\\"abcdef\\", [1, 3, 5]) \\"ace\\" >>> smallest_lexicographical_string(\\"abcdef\\", [0, 1, 2, 3, 4, 5]) \\"\\" >>> smallest_lexicographical_string(\\"abcdef\\", [5, 3, 1]) \\"ace\\" >>> smallest_lexicographical_string(\\"abcdef\\", [0, 2, 4]) \\"bdf\\"","solution":"def smallest_lexicographical_string(s, indices): Returns the smallest lexicographical string after removing the characters at the specified indices and shifting the remaining characters to the left. Parameters: s (str): The original string. indices (list[int]): The list of indices to remove from the string. Returns: str: The smallest lexicographical string. indices_set = set(indices) result = [s[i] for i in range(len(s)) if i not in indices_set] return ''.join(result)"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sum_root_to_leaf(root: TreeNode) -> int: Given a binary tree where each node has a value 0 or 1, return the sum of all the binary numbers represented by the root-to-leaf paths. The result should be modulo 10^9 + 7. >>> root = TreeNode(1) >>> root.left = TreeNode(0) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(0) >>> root.left.right = TreeNode(1) >>> root.right.left = TreeNode(0) >>> root.right.right = TreeNode(1) >>> sum_root_to_leaf(root) 22 >>> >>> root = TreeNode(1) >>> root.left = TreeNode(0) >>> sum_root_to_leaf(root) 2","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sum_root_to_leaf(root): MOD = 10**9 + 7 def dfs(node, current_number): if not node: return 0 current_number = (current_number << 1) | node.val if not node.left and not node.right: return current_number return (dfs(node.left, current_number) + dfs(node.right, current_number)) % MOD return dfs(root, 0)"},{"question":"from typing import List def max_circular_subarray_sum(arr: List[int], k: int) -> int: Given an integer array \`arr\` and an integer \`k\`, return the maximum sum of any non-empty subarray of \`arr\` that can be obtained by performing at most \`k\` circular shifts. A circular shift moves the element from the end of the array to the start. >>> max_circular_subarray_sum([1, -2, 3, -2], 1) == 3 >>> max_circular_subarray_sum([5, -3, 5], 1) == 10 >>> max_circular_subarray_sum([3, -1, 2, -1], 2) == 4 >>> max_circular_subarray_sum([3, -2, 2, -3], 3) == 3 >>> max_circular_subarray_sum([-2, -3, -1], 3) == -1 >>> max_circular_subarray_sum([10], 1) == 10","solution":"def max_circular_subarray_sum(arr, k): def max_subarray_sum(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far n = len(arr) if n == 0: return 0 overall_max = max_subarray_sum(arr) for shift in range(1, min(k, n) + 1): shift_arr = arr[-shift:] + arr[:-shift] overall_max = max(overall_max, max_subarray_sum(shift_arr)) return overall_max"},{"question":"from typing import List def min_steps_forest_cutting(forest: List[List[int]]) -> int: You are given a 2D array forest, where forest[i][j] represents the height of a tree at the cell (i, j). Your goal is to cut off all the trees in such a way that you cut them in non-decreasing order of their height. You can start at any tree and can use a Breadth-First Search (BFS) to move from one tree to another. You can move up, down, left, or right, and you can only traverse cells with heights less than or equal to the height of the tree being cut down. Return the minimum number of steps required to cut all the trees in the forest. If it is impossible to cut off all the trees, return -1. >>> min_steps_forest_cutting([[1, 2, 3], [0, 0, 4], [7, 6, 5]]) 6 >>> min_steps_forest_cutting([[1, 2, 3], [0, 0, 0], [7, 6, 5]]) -1 >>> min_steps_forest_cutting([[1, 2], [7, 3]]) 3 >>> min_steps_forest_cutting([[1, 2, 3, 4, 5]]) 4 >>> min_steps_forest_cutting([[1], [2], [3], [4], [5]]) 4 >>> min_steps_forest_cutting([[0, 0], [0, 0]]) 0 >>> min_steps_forest_cutting([[1, 2, 3], [0, 0, 0], [4, 5, 6]]) -1","solution":"from collections import deque def min_steps_forest_cutting(forest): def bfs(start, target): Helper function to perform Breadth-First Search queue, visited = deque([(start[0], start[1], 0)]), set((start[0], start[1])) while queue: x, y, steps = queue.popleft() if (x, y) == target: return steps for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(forest) and 0 <= ny < len(forest[0]) and (nx, ny) not in visited and forest[nx][ny] > 0: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1 trees = [(h, i, j) for i, row in enumerate(forest) for j, h in enumerate(row) if h > 1] trees.sort() steps = 0 curr_position = (0, 0) for height, i, j in trees: s = bfs(curr_position, (i, j)) if s == -1: return -1 steps += s curr_position = (i, j) return steps"},{"question":"from typing import List def is_valid_password_candidate(s: str) -> bool: Checks if the given string s is a valid password candidate. contains_digit = any(c.isdigit() for c in s) contains_uppercase = any(c.isupper() for c in s) contains_lowercase = any(c.islower() for c in s) contains_special = any(c in ['@', '#', '', '%', '&', '*', '!'] for c in s) return contains_digit and contains_uppercase and contains_lowercase and contains_special def valid_password_candidates(words: List[str]) -> List[str]: Returns the list of valid password candidates from the given list of words. A string s is called a valid password candidate if it meets the following criteria: - s contains at least one digit. - s contains both uppercase and lowercase letters. - s contains at least one special character from the set ['@', '#', '', '%', '&', '*', '!']. >>> valid_password_candidates(['Abc1@', 'Xyz2', 'Pwd3!']) ['Abc1@', 'Xyz2', 'Pwd3!'] >>> valid_password_candidates(['abc', 'XYZ123', 'password!', '1234#!']) [] >>> valid_password_candidates(['abc1A@', 'XYZabc', 'Pass!123', 'test1@']) ['abc1A@', 'Pass!123'] >>> valid_password_candidates([]) [] >>> valid_password_candidates(['Abc1@', 'Xyz2', 'Pwd3!', 'NoSpecial123']) ['Abc1@', 'Xyz2', 'Pwd3!'] return [word for word in words if is_valid_password_candidate(word)]","solution":"def is_valid_password_candidate(s): Checks if the given string s is a valid password candidate. contains_digit = any(c.isdigit() for c in s) contains_uppercase = any(c.isupper() for c in s) contains_lowercase = any(c.islower() for c in s) contains_special = any(c in ['@', '#', '', '%', '&', '*', '!'] for c in s) return contains_digit and contains_uppercase and contains_lowercase and contains_special def valid_password_candidates(words): Returns the list of valid password candidates from the given list of words. return [word for word in words if is_valid_password_candidate(word)]"},{"question":"def max_depth(s: str) -> int: Returns the maximum depth of nested parentheses sequence in the given string s. >>> max_depth(\\"()()\\") 1 >>> max_depth(\\"((()))\\") 3 >>> max_depth(\\"(())()\\") 2 >>> max_depth(\\"()((())())\\") 3 >>> max_depth(\\"\\") 0 >>> max_depth(\\"()\\") 1 >>> max_depth(\\"()()()()()()\\") 1 >>> max_depth(\\"(((())))\\") 4","solution":"def max_depth(s: str) -> int: Returns the maximum depth of nested parentheses sequence in the given string s. current_depth = max_depth = 0 for char in s: if char == '(': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == ')': current_depth -= 1 return max_depth"},{"question":"def num_connected_components(grid: List[List[str]]) -> int: Returns the number of connected components consisting exclusively of the character '1' in a given grid. >>> num_connected_components([]) == 0 >>> num_connected_components([[\\"1\\"]]) == 1 >>> num_connected_components([[\\"0\\"]]) == 0 >>> num_connected_components([ ... [\\"1\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\"] ... ]) == 2 >>> num_connected_components([ ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"] ... ]) == 1 >>> num_connected_components([ ... [\\"1\\", \\"0\\", \\"1\\"], ... [\\"0\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"1\\"] ... ]) == 5 >>> num_connected_components([ ... [\\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"] ... ]) == 0","solution":"def num_connected_components(grid): if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = set() def dfs(r, c): stack = [(r, c)] while stack: x, y = stack.pop() if (x, y) in visited: continue visited.add((x, y)) # add neighbors to stack for nx, ny in [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]: if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == '1' and (nx, ny) not in visited: stack.append((nx, ny)) component_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == '1' and (r, c) not in visited: dfs(r, c) component_count += 1 return component_count"},{"question":"from typing import List def rearrangeEvenOdd(nums: List[int]) -> List[int]: Rearrange the array such that all even numbers come before all odd numbers while preserving the original relative order of the even and the odd numbers. >>> rearrangeEvenOdd([2, 4, 6, 8]) == [2, 4, 6, 8] >>> rearrangeEvenOdd([1, 3, 5, 7]) == [1, 3, 5, 7] >>> rearrangeEvenOdd([1, 2, 3, 4, 5, 6]) == [2, 4, 6, 1, 3, 5] >>> rearrangeEvenOdd([2, 3, 4, 5, 6, 7]) == [2, 4, 6, 3, 5, 7] >>> rearrangeEvenOdd([1, 4, 3, 2, 5, 6]) == [4, 2, 6, 1, 3, 5] >>> rearrangeEvenOdd([]) == [] >>> rearrangeEvenOdd([2]) == [2] >>> rearrangeEvenOdd([1]) == [1]","solution":"from typing import List def rearrangeEvenOdd(nums: List[int]) -> List[int]: evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] return evens + odds"},{"question":"import math def count_ways(n: int) -> int: Returns the total number of ways to distribute n food items to friends such that each friend gets at least one food item and no friend receives more calories than a friend who has already been given food items. >>> count_ways(1) 1 >>> count_ways(2) 2 >>> count_ways(3) 5 >>> count_ways(4) 14 >>> count_ways(5) 42 >>> count_ways(6) 132","solution":"import math def count_ways(n): Returns the total number of ways to distribute n food items to friends such that each friend gets at least one food item and no friend receives more calories than a friend who has already been given food items. This is equivalent to finding the n-th Catalan number. # Catalan number formula: C(n) = (1 / (n + 1)) * (2n choose n) # C(n) = (2n)! / ((n + 1)! * n!) return math.comb(2 * n, n) // (n + 1)"},{"question":"def min_steps(s: str, t: str) -> int: Returns the minimum number of steps required to convert string s into string t. The operations allowed are insert, delete, and replace a character. >>> min_steps(\\"abc\\", \\"abc\\") == 0 >>> min_steps(\\"abc\\", \\"abcd\\") == 1 >>> min_steps(\\"a\\", \\"abc\\") == 2 >>> min_steps(\\"abcd\\", \\"abc\\") == 1 >>> min_steps(\\"abc\\", \\"a\\") == 2 >>> min_steps(\\"abc\\", \\"abd\\") == 1 >>> min_steps(\\"abc\\", \\"xyz\\") == 3 >>> min_steps(\\"intention\\", \\"execution\\") == 5 >>> min_steps(\\"\\", \\"abc\\") == 3 >>> min_steps(\\"abc\\", \\"\\") == 3 >>> min_steps(\\"\\", \\"\\") == 0","solution":"def min_steps(s, t): Returns the minimum number of steps required to convert string s into string t. The operations allowed are insert, delete, and replace a character. m, n = len(s), len(t) # Create a DP table to store the minimum number of steps. dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table with base cases. for i in range(m + 1): dp[i][0] = i # Deleting all characters from s to match an empty t for j in range(n + 1): dp[0][j] = j # Inserting all characters into an empty s to match t # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no additional step needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Replacement return dp[m][n]"},{"question":"def prime_factors(num): Returns the list of all unique prime factors of the given number sorted in ascending order. >>> prime_factors(60) [2, 3, 5] >>> prime_factors(7) [7] >>> prime_factors(28) [2, 7] >>> prime_factors(210) [2, 3, 5, 7] >>> prime_factors(45) [3, 5] >>> prime_factors(2) [2]","solution":"def prime_factors(num): Returns the list of all unique prime factors of the given number sorted in ascending order. factors = [] divisor = 2 while num > 1: if num % divisor == 0: if divisor not in factors: factors.append(divisor) num //= divisor else: divisor += 1 return factors"},{"question":"def num_cells_ball_can_reach(grid, start): Returns the number of distinct cells a ball can reach starting from a specific cell in a grid. :param grid: List of List of str, the grid of cells represented by '0' (empty) and '1' (wall) :param start: Tuple of (int, int), starting (row, col) position of the ball :return: int, the number of distinct cells the ball can reach >>> grid = [[\\"0\\"]] >>> start = (0, 0) >>> num_cells_ball_can_reach(grid, start) 1 >>> grid = [[\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"0\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"]] >>> start = (1, 1) >>> num_cells_ball_can_reach(grid, start) 1 >>> grid = [[\\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"]] >>> start = (1, 1) >>> num_cells_ball_can_reach(grid, start) 9 >>> grid = [[\\"1\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"1\\"], ... [\\"1\\", \\"0\\", \\"0\\"]] >>> start = (1, 1) >>> num_cells_ball_can_reach(grid, start) 5 >>> grid = [[\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"0\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"]] >>> start = (1, 1) >>> num_cells_ball_can_reach(grid, start) 1","solution":"def num_cells_ball_can_reach(grid, start): Returns the number of distinct cells a ball can reach starting from a specific cell in a grid. :param grid: List of List of str, the grid of cells represented by '0' (empty) and '1' (wall) :param start: Tuple of (int, int), starting (row, col) position of the ball :return: int, the number of distinct cells the ball can reach def valid_cell(x, y, m, n): return 0 <= x < m and 0 <= y < n and grid[x][y] == '0' def dfs(x, y, visited): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy while valid_cell(nx, ny, m, n): nx += dx ny += dy nx -= dx ny -= dy if (nx, ny) not in visited: visited.add((nx, ny)) dfs(nx, ny, visited) visited = set() m, n = len(grid), len(grid[0]) visited.add(start) dfs(start[0], start[1], visited) return len(visited)"},{"question":"def shortest_substring_with_m_distinct_chars(s: str, m: int) -> int: Returns the length of the shortest substring of 's' that contains exactly 'm' distinct characters. If no such substring exists, return -1. >>> shortest_substring_with_m_distinct_chars(\\"abcabc\\", 3) 3 >>> shortest_substring_with_m_distinct_chars(\\"aaabcabcde\\", 3) 3 >>> shortest_substring_with_m_distinct_chars(\\"abcdef\\", 7) -1 >>> shortest_substring_with_m_distinct_chars(\\"aabbcc\\", 2) 2 >>> shortest_substring_with_m_distinct_chars(\\"aaaaa\\", 1) 1 >>> shortest_substring_with_m_distinct_chars(\\"aaaaa\\", 2) -1 >>> shortest_substring_with_m_distinct_chars(\\"abac\\", 2) 2 >>> shortest_substring_with_m_distinct_chars(\\"abc\\", 4) -1","solution":"def shortest_substring_with_m_distinct_chars(s, m): Returns the length of the shortest substring of 's' that contains exactly 'm' distinct characters. If no such substring exists, return -1. from collections import defaultdict n = len(s) if m > n: return -1 left = 0 right = 0 char_count = defaultdict(int) distinct_count = 0 min_len = float('inf') while right < n: char_count[s[right]] += 1 if char_count[s[right]] == 1: distinct_count += 1 while distinct_count >= m: if distinct_count == m: min_len = min(min_len, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: distinct_count -= 1 left += 1 right += 1 return min_len if min_len != float('inf') else -1"},{"question":"def find_kth_element(arr1, arr2, k): Finds the k-th smallest element in the combined sorted array of arr1 and arr2. Args: arr1 (list): First sorted array. arr2 (list): Second sorted array. k (int): The 1-based index of the smallest element to find. Returns: int: The k-th smallest element. >>> find_kth_element([1, 3, 5], [2, 4, 6], 1) # should return 1 >>> find_kth_element([1, 3, 5], [2, 4, 6], 2) # should return 2 >>> find_kth_element([1, 3, 5], [2, 4, 6], 3) # should return 3 >>> find_kth_element([1, 3, 5], [2, 4, 6], 4) # should return 4 >>> find_kth_element([1, 3, 5], [2, 4, 6], 5) # should return 5 >>> find_kth_element([1, 3, 5], [2, 4, 6], 6) # should return 6 >>> find_kth_element([1, 2], [3, 4, 5, 6, 7, 8, 9], 4) # should return 4 >>> find_kth_element([1], [2, 3, 4, 5, 6], 3) # should return 3 >>> find_kth_element([], [2, 3, 4, 5, 6], 2) # should return 3 >>> find_kth_element([1, 2], [], 1) # should return 1 >>> find_kth_element([1, 2], [], 2) # should return 2","solution":"def find_kth_element(arr1, arr2, k): Finds the k-th smallest element in the combined sorted array of arr1 and arr2. Args: arr1 (list): First sorted array arr2 (list): Second sorted array k (int): The 1-based index of the smallest element to find Returns: int: The k-th smallest element def kth_smallest_helper(arr1, start1, arr2, start2, k): if start1 >= len(arr1): return arr2[start2 + k - 1] if start2 >= len(arr2): return arr1[start1 + k - 1] if k == 1: return min(arr1[start1], arr2[start2]) mid1 = start1 + k // 2 - 1 mid2 = start2 + k // 2 - 1 mid1_val = arr1[mid1] if mid1 < len(arr1) else float('inf') mid2_val = arr2[mid2] if mid2 < len(arr2) else float('inf') if mid1_val < mid2_val: return kth_smallest_helper(arr1, mid1 + 1, arr2, start2, k - k // 2) else: return kth_smallest_helper(arr1, start1, arr2, mid2 + 1, k - k // 2) return kth_smallest_helper(arr1, 0, arr2, 0, k)"},{"question":"def reorder_log_files(logs: List[str]) -> List[str]: Reorders logs such that: 1. Letter-logs come before digit-logs. 2. Letter-logs are ordered lexicographically by content, and in case of ties, by identifier. 3. Digit-logs maintain their relative ordering. >>> reorder_log_files([ \\"a1 9 2 3 1\\", \\"g1 act car\\", \\"zo4 4 7\\", \\"ab1 off key dog\\", \\"a8 act zoo\\", \\"a2 act car\\"]) [\\"a2 act car\\", \\"g1 act car\\", \\"a8 act zoo\\", \\"ab1 off key dog\\", \\"a1 9 2 3 1\\", \\"zo4 4 7\\"] >>> reorder_log_files([ \\"d1 8 1 5 1\\", \\"d2 3 6\\", \\"d3 2 4\\"]) [\\"d1 8 1 5 1\\", \\"d2 3 6\\", \\"d3 2 4\\"] >>> reorder_log_files([ \\"let1 art can\\", \\"let2 own kit dig\\", \\"let3 art zero\\"]) [\\"let1 art can\\", \\"let3 art zero\\", \\"let2 own kit dig\\"] >>> reorder_log_files([ \\"let2 art can\\", \\"let3 art can\\", \\"let1 art can\\"]) [\\"let1 art can\\", \\"let2 art can\\", \\"let3 art can\\"] >>> reorder_log_files([]) []","solution":"def reorder_log_files(logs): Reorders logs such that: 1. Letter-logs come before digit-logs. 2. Letter-logs are ordered lexicographically by content, and in case of ties, by identifier. 3. Digit-logs maintain their relative ordering. letter_logs = [] digit_logs = [] for log in logs: identifier, rest = log.split(' ', 1) if rest[0].isdigit(): digit_logs.append(log) else: letter_logs.append((rest, identifier)) # Sort letter logs by content, then by identifier letter_logs.sort(key=lambda x: (x[0], x[1])) # Combine the sorted letter logs and original order digit logs sorted_logs = [f\\"{identifier} {content}\\" for content, identifier in letter_logs] + digit_logs return sorted_logs"},{"question":"def min_cost_with_discounts(costs, discounts): Calculate the minimum cost after applying the best possible discount. Arguments: costs -- List of integers representing the cost of each material. discounts -- List of lists, where each list contains two integers [k, d] representing a discount 'd' applicable if at least 'k' materials are used. Returns: Integer representing the minimum cost after applying the best discount. >>> min_cost_with_discounts([10, 20, 30], []) 60 >>> min_cost_with_discounts([10, 20, 30], [[2, 5]]) 55 >>> min_cost_with_discounts([10, 20, 30], [[3, 10]]) 50 >>> min_cost_with_discounts([10, 20, 30], [[2, 5], [3, 10]]) 50 >>> min_cost_with_discounts([10, 20, 30, 40], [[2, 5], [3, 10], [4, 15]]) 85 >>> min_cost_with_discounts([10, 20], [[2, 5], [2, 7]]) 23 >>> min_cost_with_discounts([15, 25], [[3, 5], [4, 10]]) 40","solution":"def min_cost_with_discounts(costs, discounts): Calculate the minimum cost after applying the best possible discount. Arguments: costs -- List of integers representing the cost of each material. discounts -- List of lists, where each list contains two integers [k, d] representing a discount 'd' applicable if at least 'k' materials are used. Returns: Integer representing the minimum cost after applying the best discount. total_cost = sum(costs) max_discount = 0 for k, d in discounts: if len(costs) >= k: max_discount = max(max_discount, d) return total_cost - max_discount"},{"question":"from typing import List def findLHS(nums: List[int]) -> int: Finds the length of the longest harmonious subsequence in the array. Args: nums (List[int]): The input array of integers. Returns: int: The length of the longest harmonious subsequence. >>> findLHS([1,3,2,2,5,2,3,7]) 5 >>> findLHS([1,1,1,1]) 0 >>> findLHS([5,5,5,5,5]) 0 >>> findLHS([1,2,3,4,5,6,7,8,9,10]) 2 >>> findLHS([9,9,9,8,8,8,7,7,7,7]) 7 >>> findLHS([1, 2]) 2 >>> findLHS([]) 0","solution":"from collections import Counter def findLHS(nums): Finds the length of the longest harmonious subsequence in the array. Args: nums (List[int]): The input array of integers. Returns: int: The length of the longest harmonious subsequence. if not nums: return 0 num_counts = Counter(nums) max_length = 0 for num in num_counts: if num + 1 in num_counts: max_length = max(max_length, num_counts[num] + num_counts[num + 1]) return max_length"},{"question":"def lexicographically_smallest_string(s: str) -> str: Given a string \`s\` representing a sequence of lowercase English letters, return the lexicographically smallest string possible after applying the given operation any number of times. >>> lexicographically_smallest_string(\\"bcabc\\") == \\"abc\\" >>> lexicographically_smallest_string(\\"acbac\\") == \\"aac\\" >>> lexicographically_smallest_string(\\"abcd\\") == \\"abcd\\" >>> lexicographically_smallest_string(\\"zxyab\\") == \\"ab\\" >>> lexicographically_smallest_string(\\"aaaaa\\") == \\"aaaaa\\" >>> lexicographically_smallest_string(\\"cba\\") == \\"a\\"","solution":"def lexicographically_smallest_string(s): Given a string \`s\` representing a sequence of lowercase English letters, return the lexicographically smallest string possible after applying the given operation any number of times. stack = [] for char in s: while stack and stack[-1] > char: stack.pop() stack.append(char) return ''.join(stack)"},{"question":"from itertools import combinations from typing import List, Tuple def combine(n: int, k: int) -> List[Tuple[int]]: Returns all possible combinations of k numbers out of the range [1, n]. >>> combine(4, 2) [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] >>> combine(1, 1) [(1,)] >>> combine(3, 3) [(1, 2, 3)] >>> combine(5, 0) [()] >>> len(combine(10, 5)) 252","solution":"from itertools import combinations def combine(n, k): Returns all possible combinations of k numbers out of the range [1, n]. Parameters: n (int): Total number of elements. k (int): Size of each combination. Returns: List[List[int]]: List of all combinations. return list(combinations(range(1, n + 1), k))"},{"question":"def rotate_matrix(matrix): Rotate the given N x N matrix 90 degrees clockwise. :param matrix: List[List[int]], a 2D list representing the matrix. :return: The rotated matrix, which is modified in place. pass # Unit Tests def test_even_size_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix(matrix) == expected def test_odd_size_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(matrix) == expected def test_single_element_matrix(): matrix = [ [1] ] expected = [ [1] ] assert rotate_matrix(matrix) == expected def test_non_integer_matrix(): matrix = [ ['a', 'b'], ['c', 'd'] ] expected = [ ['c', 'a'], ['d', 'b'] ] assert rotate_matrix(matrix) == expected","solution":"def rotate_matrix(matrix): Rotate the given N x N matrix 90 degrees clockwise. :param matrix: List[List[int]], a 2D list representing the matrix. :return: The rotated matrix, which is modified in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"def min_removals_for_supersorted_line(heights): Returns the minimum number of removals needed to make the remaining students form a supersorted line. >>> min_removals_for_supersorted_line([1, 2, 3, 4]) 0 >>> min_removals_for_supersorted_line([4, 3, 2, 1]) 3 >>> min_removals_for_supersorted_line([1, 3, 4, 2, 5]) 2 >>> min_removals_for_supersorted_line([10, 3, 11, 4, 12, 5, 1]) 4 >>> min_removals_for_supersorted_line([1, 1, 1, 1]) 3 >>> min_removals_for_supersorted_line([1]) 0 >>> min_removals_for_supersorted_line([]) 0","solution":"def min_removals_for_supersorted_line(heights): Returns the minimum number of removals needed to make the remaining students form a supersorted line. if not heights: return 0 dp = [1] * len(heights) for i in range(1, len(heights)): for j in range(i): if heights[i] == heights[j] + 1: dp[i] = max(dp[i], dp[j] + 1) longest_supersorted_length = max(dp) return len(heights) - longest_supersorted_length"},{"question":"def partition_list(nums, pivot): Partitions the list \`nums\` such that all elements less than \`pivot\` come before all elements equal to \`pivot\`, and all elements greater than \`pivot\` come after all elements equal to \`pivot\`. The relative order of elements less than \`pivot\` and greater than \`pivot\` are maintained as in the original list. Args: nums: List of non-negative integers. pivot: The pivot integer to partition the list around. Returns: A list after partitioning. pass from solution import partition_list def test_partition_list_basic(): assert partition_list([1, 4, 3, 2, 5, 2], 3) == [1, 2, 2, 3, 4, 5] def test_partition_list_no_pivot(): assert partition_list([1, 2, 4, 5], 3) == [1, 2, 4, 5] def test_partition_list_all_less(): assert partition_list([1, 2, 2], 3) == [1, 2, 2] def test_partition_list_all_greater(): assert partition_list([4, 5, 6], 3) == [4, 5, 6] def test_partition_list_all_equal(): assert partition_list([3, 3, 3], 3) == [3, 3, 3] def test_partition_list_mixed(): assert partition_list([6, 5, 4, 3, 2, 1, 3, 0], 3) == [2, 1, 0, 3, 3, 6, 5, 4] def test_partition_list_empty(): assert partition_list([], 3) == []","solution":"def partition_list(nums, pivot): Partitions the list \`nums\` such that all elements less than \`pivot\` come before all elements equal to \`pivot\`, and all elements greater than \`pivot\` come after all elements equal to \`pivot\`. The relative order of elements less than \`pivot\` and greater than \`pivot\` are maintained as in the original list. Args: nums: List of non-negative integers. pivot: The pivot integer to partition the list around. Returns: A list after partitioning. less_than_pivot = [] equal_to_pivot = [] greater_than_pivot = [] for num in nums: if num < pivot: less_than_pivot.append(num) elif num == pivot: equal_to_pivot.append(num) else: greater_than_pivot.append(num) return less_than_pivot + equal_to_pivot + greater_than_pivot"},{"question":"from typing import List def longest_subarray(nums: List[int]) -> int: Given a 0-indexed array nums consisting of positive integers, determine the length of the longest possible subarray such that the bitwise AND of the subarray elements is strictly greater than 0. Return the length of the longest subarray with a bitwise AND greater than 0. If no such subarray exists, return 0. >>> longest_subarray([1]) 1 >>> longest_subarray([0]) 0 >>> longest_subarray([1, 2, 3, 4]) 4 >>> longest_subarray([0, 0, 0, 0]) 0 >>> longest_subarray([1, 0, 1, 1, 0, 1]) 2 >>> longest_subarray([1, 2, 0, 4, 5]) 2 >>> longest_subarray([1, 2, 3, 0, 4, 5, 0, 6, 7, 8]) 3","solution":"def longest_subarray(nums): Returns the length of the longest subarray with bitwise AND > 0. max_length = 0 current_length = 0 for num in nums: if num > 0: current_length += 1 else: current_length = 0 max_length = max(max_length, current_length) return max_length"},{"question":"def is_alien_sorted(words, order): Determine if the words in the array are sorted lexicographically according to the alien language. Returns True if words are sorted lexicographically according to the alien language order, otherwise False. >>> is_alien_sorted([\\"hello\\", \\"leetcode\\"], \\"hlabcdefgijkmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"word\\", \\"world\\", \\"row\\"], \\"worldabcefghijkmnpqstuvxyz\\") False >>> is_alien_sorted([\\"apple\\", \\"app\\"], \\"abcdefghijklmnopqrstuvwxyz\\") False >>> is_alien_sorted([], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"single\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"arc\\", \\"arw\\", \\"arz\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"arz\\", \\"arw\\", \\"arc\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") True","solution":"def is_alien_sorted(words, order): Returns True if words are sorted lexicographically according to the alien language order, otherwise False. order_index = {char: i for i, char in enumerate(order)} def is_sorted(word1, word2): min_length = min(len(word1), len(word2)) for i in range(min_length): if word1[i] != word2[i]: return order_index[word1[i]] < order_index[word2[i]] return len(word1) <= len(word2) for i in range(len(words) - 1): if not is_sorted(words[i], words[i + 1]): return False return True"},{"question":"def remove_duplicates(nums): Removes duplicates in-place from a sorted array \`nums\` such that each unique element appears only once. Returns the number of unique elements. Args: nums (List[int]): List of sorted integers where duplicates to be removed in-place. Returns: int: The count of unique elements. Examples: >>> nums = [1, 2, 3, 4, 5] >>> remove_duplicates(nums) 5 >>> nums[:5] [1, 2, 3, 4, 5] >>> nums = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5] >>> remove_duplicates(nums) 5 >>> nums[:5] [1, 2, 3, 4, 5] >>> nums = [1] >>> remove_duplicates(nums) 1 >>> nums[:1] [1] >>> nums = [] >>> remove_duplicates(nums) 0 >>> nums = [1, 1, 1, 1, 1] >>> remove_duplicates(nums) 1 >>> nums[:1] [1]","solution":"def remove_duplicates(nums): Removes duplicates in-place from a sorted array \`nums\` such that each unique element appears only once. Returns the number of unique elements. Args: nums (List[int]): List of sorted integers where duplicates to be removed in-place. Returns: int: The count of unique elements. if not nums: return 0 unique_index = 0 for i in range(1, len(nums)): if nums[i] != nums[unique_index]: unique_index += 1 nums[unique_index] = nums[i] # The new length of the array will be the index of the last unique element + 1 return unique_index + 1"},{"question":"def can_attend_all_meetings(startTimes: List[int], endTimes: List[int]) -> bool: Determines if a single person can attend all meetings without any overlap. :param startTimes: List of start times of meetings. :param endTimes: List of end times of meetings. :return: True if a person can attend all meetings without overlap, False otherwise. >>> can_attend_all_meetings([1, 3, 5], [2, 4, 6]) True >>> can_attend_all_meetings([1, 3, 4], [2, 5, 6]) False >>> can_attend_all_meetings([1], [2]) True >>> can_attend_all_meetings([1, 2], [2, 3]) True >>> can_attend_all_meetings([1, 3, 2, 5], [2, 4, 6, 7]) False >>> can_attend_all_meetings([1, 5, 10], [4, 8, 12]) True >>> can_attend_all_meetings([5, 1, 10], [8, 4, 12]) True >>> can_attend_all_meetings([5, 1, 2], [8, 4, 7]) False","solution":"def can_attend_all_meetings(startTimes, endTimes): Determines if a single person can attend all meetings without any overlap. :param startTimes: List of start times of meetings. :param endTimes: List of end times of meetings. :return: True if a person can attend all meetings without overlap, False otherwise. meetings = sorted(zip(startTimes, endTimes), key=lambda x: x[0]) for i in range(1, len(meetings)): if meetings[i][0] < meetings[i-1][1]: return False return True"},{"question":"from typing import List, Tuple, Union def grid_operations(operations: List[Tuple[str, Union[int, Tuple[int, int, int, int]]]]) -> List[int]: Given an \\"infinite\\" 2D grid of cells initially set to 0 and a list of operations, perform the operations and return the results of all query operations. Each operation is one of the following: 1. Increment a subgrid by 1, defined by its top-left and bottom-right corners (r1, c1, r2, c2). 2. Query the current value of a specific cell (r, c). Args: operations: A list of tuples where the first element is \\"Increment\\" or \\"Query\\", followed by the parameters for that operation. Returns: A list of results from all query operations in the order they appear. Example: >>> grid_operations([ ... (\\"Increment\\", 0, 0, 2, 2), ... (\\"Query\\", 1, 1), ... (\\"Increment\\", -1, -1, 0, 0), ... (\\"Query\\", 0, 0), ... (\\"Query\\", -1, -1) ... ]) [1, 2, 1] >>> grid_operations([ ... (\\"Query\\", 1, 1), ... (\\"Query\\", 0, 0), ... (\\"Query\\", -1, -1) ... ]) [0, 0, 0] >>> grid_operations([ ... (\\"Increment\\", 0, 0, 1, 1), ... (\\"Increment\\", 1, 1, 2, 2), ... (\\"Query\\", 1, 1), ... (\\"Query\\", 0, 0), ... (\\"Query\\", 2, 2) ... ]) [2, 1, 1] >>> grid_operations([ ... (\\"Increment\\", -2, -2, -1, -1), ... (\\"Increment\\", -1, -1, 0, 0), ... (\\"Query\\", -1, -1), ... (\\"Query\\", 0, 0) ... ]) [2, 1] >>> grid_operations([ ... (\\"Increment\\", 10, 10, 12, 12), ... (\\"Increment\\", -10, -10, -8, -8), ... (\\"Query\\", 11, 11), ... (\\"Query\\", -9, -9) ... ]) [1, 1]","solution":"def grid_operations(operations): grid = {} def increment(r1, c1, r2, c2): for r in range(r1, r2 + 1): for c in range(c1, c2 + 1): if (r, c) not in grid: grid[(r, c)] = 0 grid[(r, c)] += 1 def query(r, c): return grid.get((r, c), 0) results = [] for op in operations: if op[0] == \\"Increment\\": _, r1, c1, r2, c2 = op increment(r1, c1, r2, c2) elif op[0] == \\"Query\\": _, r, c = op results.append(query(r, c)) return results"},{"question":"class Node: Definition for a Node. def __init__(self, val=0, children=None): self.val = val self.left = None self.right = None self.children = children if children is not None else [] def flatten_nary_tree(root): Flattens an n-ary tree to a linked list in-place. The tree is traversed in pre-order and nodes are linked using the \`right\` pointers. pass # Unit Test def test_flatten_null_tree(): assert flatten_nary_tree(None) is None def test_flatten_single_node(): root = Node(val=1) result = flatten_nary_tree(root) assert result.val == 1 assert result.right is None def test_flatten_tree_with_one_level_children(): child1 = Node(val=2) child2 = Node(val=3) root = Node(val=1, children=[child1, child2]) result = flatten_nary_tree(root) assert result.val == 1 assert result.right.val == 2 assert result.right.right.val == 3 assert result.right.right.right is None def test_flatten_complex_tree(): child11 = Node(val=4) child12 = Node(val=5) child1 = Node(val=2, children=[child11, child12]) child21 = Node(val=6) child22 = Node(val=7) child23 = Node(val=8) child2 = Node(val=3, children=[child21, child22, child23]) root = Node(val=1, children=[child1, child2]) result = flatten_nary_tree(root) assert result.val == 1 assert result.right.val == 2 assert result.right.right.val == 4 assert result.right.right.right.val == 5 assert result.right.right.right.right.val == 3 assert result.right.right.right.right.right.val == 6 assert result.right.right.right.right.right.right.val == 7 assert result.right.right.right.right.right.right.right.val == 8 assert result.right.right.right.right.right.right.right.right is None","solution":"class Node: Definition for a Node. def __init__(self, val=0, children=None): self.val = val self.left = None self.right = None self.children = children if children is not None else [] def flatten_nary_tree(root): Flattens an n-ary tree to a linked list in-place. The tree is traversed in pre-order and nodes are linked using the \`right\` pointers. if not root: return None stack = [root] prev = None while stack: current = stack.pop() if prev: prev.right = current prev = current # We need to push children in reverse order for pre-order traversal if current.children: for child in reversed(current.children): stack.append(child) current.left = None # Ensure the left pointer is null return root"},{"question":"def min_trees_to_cut(heights: List[int]) -> int: Determines the minimum number of trees to cut down or trim to achieve a sequence with a difference of exactly 1. :param heights: list of integers representing the heights of the trees. :return: minimum number of trees to cut down or trim. >>> min_trees_to_cut([1, 2, 3, 4, 5]) 0 >>> min_trees_to_cut([10, 15, 20, 27, 30]) 4 >>> min_trees_to_cut([4, 2, 3, 1, 10]) 1 >>> min_trees_to_cut([5, 4, 3, 1, 2, 10]) 1 >>> min_trees_to_cut([1, 3, 104, 2, 105, 4, 107]) 3 >>> min_trees_to_cut([1, 2, 2, 3, 3, 4, 5]) 2 >>> min_trees_to_cut([3, 1, 2, 3, 2, 4, 5]) 2","solution":"def min_trees_to_cut(heights): Determines the minimum number of trees to cut down or trim to achieve a sequence with a difference of exactly 1. :param heights: list of integers representing the heights of the trees. :return: minimum number of trees to cut down or trim. heights.sort() n = len(heights) # To store the maximum possible length of height sequence that meets the condition. max_length_sequence = 1 current_length_sequence = 1 # List to track the longest sequence ending at each height. dp = [0] * n for i in range(n): dp[i] = 1 for j in range(i): if heights[i] == heights[j] + 1: dp[i] = max(dp[i], dp[j] + 1) max_length_sequence = max(max_length_sequence, dp[i]) return n - max_length_sequence"},{"question":"from typing import List def lexicographically_smallest_array(arr: List[int], k: int) -> List[int]: Returns the lexicographically smallest array after performing at most k swaps of any two distinct elements in the given array arr. >>> lexicographically_smallest_array([4, 3, 2, 1], 1) [3, 4, 2, 1] >>> lexicographically_smallest_array([4, 3, 2, 1], 2) [2, 3, 4, 1] >>> lexicographically_smallest_array([2, 1, 3], 0) [2, 1, 3] >>> lexicographically_smallest_array([1, 3, 2, 4], 2) [1, 2, 3, 4]","solution":"def lexicographically_smallest_array(arr, k): Returns the lexicographically smallest array after performing at most k swaps of any two distinct elements in the given array arr. n = len(arr) for i in range(n): # If no swaps left, break early if k <= 0: break # Find the smallest element to swap with arr[i] min_index = i for j in range(i + 1, min(n, i + k + 1)): if arr[j] < arr[min_index]: min_index = j # If the current element is already the smallest, continue to next index if min_index == i: continue # Perform the swap arr[i], arr[min_index] = arr[min_index], arr[i] # Decrease the swap count k -= (min_index - i) return arr"},{"question":"def smallest_window_containing_all_chars(s: str) -> str: Given a string \`s\` consisting of lowercase alphabets, return the smallest window in \`s\` that contains all the unique characters. If there are multiple such smallest windows, return the one that appears first. >>> smallest_window_containing_all_chars(\\"aabcbcdbca\\") == \\"dbca\\" >>> smallest_window_containing_all_chars(\\"abcabcbb\\") == \\"abc\\" >>> smallest_window_containing_all_chars(\\"aaab\\") == \\"ab\\" >>> smallest_window_containing_all_chars(\\"a\\") == \\"a\\" >>> smallest_window_containing_all_chars(\\"aabbaabbaa\\") == \\"ab\\" >>> smallest_window_containing_all_chars(\\"abbac\\") == \\"bac\\" >>> smallest_window_containing_all_chars(\\"\\") == \\"\\" >>> smallest_window_containing_all_chars(\\"a\\" * 1000) == \\"a\\"","solution":"def smallest_window_containing_all_chars(s): from collections import defaultdict unique_chars = set(s) required_char_count = len(unique_chars) left, right = 0, 0 formed = 0 window_counts = defaultdict(int) min_length = float('inf') min_window = \\"\\" while right < len(s): char = s[right] window_counts[char] += 1 if window_counts[char] == 1: formed += 1 while left <= right and formed == required_char_count: char = s[left] window_length = right - left + 1 if window_length < min_length: min_length = window_length min_window = s[left:right + 1] window_counts[char] -= 1 if window_counts[char] == 0: formed -= 1 left += 1 right += 1 return min_window"},{"question":"def shortest_path(grid): Finds the shortest path from top-left corner to bottom-right corner in a 2D grid avoiding obstacles. :param grid: List[List[int]] grid of obstacles (1) and open spaces (0) :return: The length of the shortest path or -1 if no path exists pass from solution import shortest_path def test_shortest_path_basic(): grid = [[0, 0, 0], [1, 1, 0], [0, 0, 0]] assert shortest_path(grid) == 5 def test_shortest_path_no_path(): grid = [[0, 1], [1, 0]] assert shortest_path(grid) == -1 def test_shortest_path_single_row(): grid = [[0, 0, 0, 1, 0]] assert shortest_path(grid) == -1 def test_shortest_path_single_column(): grid = [[0], [0], [1], [0]] assert shortest_path(grid) == -1 def test_shortest_path_immediate_obstacle(): grid = [[0, 1], [0, 0]] assert shortest_path(grid) == 3 def test_shortest_path_large_grid(): grid = [[0] * 50 for _ in range(50)] assert shortest_path(grid) == 99 def test_shortest_path_all_obstacles(): grid = [[1]] assert shortest_path(grid) == -1 def test_shortest_path_empty_grid(): grid = [] assert shortest_path(grid) == -1 def test_shortest_path_start_end_same(): grid = [[0]] assert shortest_path(grid) == 1 def test_shortest_path_path_blocked(): grid = [[0, 0, 0], [1, 1, 1], [0, 0, 0]] assert shortest_path(grid) == -1","solution":"from collections import deque def shortest_path(grid): Finds the shortest path from top-left corner to bottom-right corner in a 2D grid avoiding obstacles. :param grid: List[List[int]] grid of obstacles (1) and open spaces (0) :return: The length of the shortest path or -1 if no path exists if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) # If start or end points are obstacles if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: r, c, dist = queue.popleft() if r == m - 1 and c == n - 1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"def can_complete_tasks(tasks: str, dependencies: List[str]) -> bool: Determines if it is possible to complete all tasks in the order specified by tasks, respecting the given dependencies. :param tasks: str - A string representing the sequence of tasks. :param dependencies: list of str - A list of strings where each string is in the format \\"a->b\\" indicating that task \`a\` must be completed before task \`b\`. :return: bool - True if all tasks can be completed, considering dependencies; otherwise, False. >>> can_complete_tasks(\\"ABCD\\", []) True >>> can_complete_tasks(\\"ABCD\\", [\\"A->B\\"]) True >>> can_complete_tasks(\\"ABCDE\\", [\\"A->B\\", \\"B->C\\", \\"C->D\\"]) True >>> can_complete_tasks(\\"ABC\\", [\\"A->B\\", \\"B->C\\", \\"C->A\\"]) False >>> can_complete_tasks(\\"ABCDE\\", [\\"A->B\\", \\"C->D\\"]) True >>> can_complete_tasks(\\"ABCDE\\", [\\"A->B\\", \\"C->D\\", \\"B->E\\", \\"D->E\\"]) True >>> can_complete_tasks(\\"ABCDEF\\", [\\"A->B\\", \\"B->C\\", \\"C->D\\", \\"D->E\\", \\"E->F\\"]) True >>> can_complete_tasks(\\"ABCDEFG\\", [\\"A->B\\", \\"C->D\\", \\"E->F\\"]) True >>> can_complete_tasks(\\"ABCDE\\", [\\"A->B\\", \\"C->D\\", \\"F->A\\"]) False","solution":"def can_complete_tasks(tasks, dependencies): Determines if it is possible to complete all tasks in the order specified by tasks, respecting the given dependencies. :param tasks: str - A string representing the sequence of tasks. :param dependencies: list of str - A list of strings where each string is in the format \\"a->b\\" indicating that task \`a\` must be completed before task \`b\`. :return: bool - True if all tasks can be completed, considering dependencies; otherwise, False. from collections import defaultdict, deque graph = defaultdict(list) in_degree = {task: 0 for task in tasks} for dependency in dependencies: pre, post = dependency.split(\\"->\\") graph[pre].append(post) in_degree[post] += 1 zero_in_degree_queue = deque([task for task in tasks if in_degree[task] == 0]) count_of_tasks_processed = 0 while zero_in_degree_queue: task = zero_in_degree_queue.popleft() count_of_tasks_processed += 1 for neighbor in graph[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) return count_of_tasks_processed == len(tasks)"},{"question":"def has_subarray_with_sum_gte_average(nums: List[int], k: int) -> bool: Given an array of integers \`nums\` and an integer \`k\`, return \`true\` if there exists a contiguous subarray of size \`k\` that sums to a value greater than or equal to the average of the entire array, otherwise return \`false\`. >>> has_subarray_with_sum_gte_average([1, 2, 3, 4], 2) True >>> has_subarray_with_sum_gte_average([1, 2, 3], 3) True","solution":"def has_subarray_with_sum_gte_average(nums, k): This function checks if there exists a contiguous subarray of size k in nums whose sum is greater than or equal to the average of the entire array nums. :param nums: List of integers :param k: Size of the subarray :return: True if such a subarray exists, False otherwise n = len(nums) total_sum = sum(nums) average = total_sum / n # Calculate initial window sum of the first k elements current_window_sum = sum(nums[0:k]) # Check if the initial window sum is equal or greater than the average if current_window_sum >= average * k: return True # Slide the window across the array and keep updating the window sum. for i in range(k, n): current_window_sum += nums[i] - nums[i - k] if current_window_sum >= average * k: return True return False"},{"question":"from typing import List def networkDelayTime(times: List[List[int]], n: int, start: int) -> int: Returns the shortest time required for the signal to reach all nodes in the network from the starting node 'start'. If it is impossible for the signal to reach all nodes, return -1. >>> networkDelayTime([[2, 1, 1], [2, 3, 1], [3, 4, 1]], 4, 2) == 2 >>> networkDelayTime([[1, 2, 1]], 2, 1) == 1 >>> networkDelayTime([[1, 2, 1]], 2, 2) == -1 >>> networkDelayTime([], 1, 1) == 0 >>> networkDelayTime([[1, 2, 1], [x * row_factor for x in y] # Print the final 2D list for row in result: print(row)","solution":"import heapq from collections import defaultdict def networkDelayTime(times, n, start): Returns the shortest time required for the signal to reach all nodes in the network from the starting node 'start'. If it is impossible for the signal to reach all nodes, return -1. # create a graph from the input times graph = defaultdict(list) for u, v, w in times: graph[u].append((v, w)) # use Dijkstra's algorithm to find the shortest path from the start node to all other nodes heap = [(0, start)] shortest_times = {} while heap: time, node = heapq.heappop(heap) if node in shortest_times: continue shortest_times[node] = time for neighbor, weight in graph[node]: if neighbor not in shortest_times: heapq.heappush(heap, (time + weight, neighbor)) # if there are nodes that are not reachable, return -1 if len(shortest_times) != n: return -1 return max(shortest_times.values())"},{"question":"from typing import List def shortest_path(grid: List[List[str]]) -> int: Returns the length of the shortest path from the top-left cell to the bottom-right cell in a grid, where '-' represents land and 'W' represents water. If no path exists, returns -1. >>> shortest_path([['-', '-', '-'], ['-', 'W', '-'], ['-', '-', '-']]) 5 >>> shortest_path([['-', 'W', '-'], ['W', 'W', '-'], ['-', '-', '-']]) -1 >>> shortest_path([['-']]) 1 >>> shortest_path([['W']]) -1 >>> shortest_path([['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]) 5 >>> shortest_path([['-', 'W', '-'], ['-', 'W', '-'], ['-', 'W', '-']]) -1","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from the top-left cell to the bottom-right cell in a grid, where '-' represents land and 'W' represents water. If no path exists, returns -1. if not grid or grid[0][0] == 'W' or grid[-1][-1] == 'W': return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: r, c, dist = queue.popleft() if (r, c) == (m - 1, n - 1): return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == '-' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"def findOptimalPoint(towers, r): Find a point on the plane such that the sum of the distances from this point to all the towers is minimized. The distance is calculated using the Manhattan distance formula. Arguments: towers: List of tuples, where each tuple is (x, y) coordinates of a tower. r: An integer value, not used in the calculation. Returns: Tuple of integer coordinates representing the optimal point. # Test cases def test_single_tower(): towers = [(3, 4)] assert findOptimalPoint(towers, 5) == (3, 4) def test_two_towers(): towers = [(1, 2), (3, 4)] assert findOptimalPoint(towers, 5) in [(1, 2), (3, 4)] def test_three_towers(): towers = [(1, 2), (3, 4), (5, 6)] assert findOptimalPoint(towers, 5) == (3, 4) def test_four_towers(): towers = [(1, 1), (4, 4), (1, 4), (4, 1)] assert findOptimalPoint(towers, 5) in [(1, 4), (4, 1), (1, 1), (4, 4)] def test_empty_towers(): towers = [] assert findOptimalPoint(towers, 5) == (0, 0) def test_multiple_towers(): towers = [(1, 2), (2, 3), (3, 4), (4, 5)] assert findOptimalPoint(towers, 5) in [(2, 3), (3, 4)]","solution":"def findOptimalPoint(towers, r): Find a point on the plane such that the sum of the distances from this point to all the towers is minimized. The distance is calculated using the Manhattan distance formula. Arguments: towers: List of tuples, where each tuple is (x, y) coordinates of a tower. r: An integer value, not used in the calculation. Returns: Tuple of integer coordinates representing the optimal point. if not towers: return (0, 0) # To minimize Manhattan distance sum, the optimal x and y coordinates # will be the median of the tower's x and y coordinates respectively. x_coords = sorted([t[0] for t in towers]) y_coords = sorted([t[1] for t in towers]) median_x = x_coords[len(x_coords) // 2] median_y = y_coords[len(y_coords) // 2] return (median_x, median_y)"},{"question":"def max_overlapping_intervals(startTimes, endTimes): Returns the maximum number of overlapping intervals at any point in time. >>> max_overlapping_intervals([1, 3, 5], [2, 4, 6]) == 1 >>> max_overlapping_intervals([1, 1, 1], [10, 10, 10]) == 3 >>> max_overlapping_intervals([1, 2, 4], [5, 3, 6]) == 2 >>> max_overlapping_intervals([1, 2, 3, 5], [10, 3, 8, 7]) == 3 >>> max_overlapping_intervals([1, 2, 3, 4, 5], [5, 3, 6, 7, 8]) == 3 >>> max_overlapping_intervals([1, 2, 2, 2], [3, 3, 3, 3]) == 4","solution":"def max_overlapping_intervals(startTimes, endTimes): Returns the maximum number of overlapping intervals at any point in time. events = [] for start, end in zip(startTimes, endTimes): events.append((start, 'start')) events.append((end, 'end')) # Sort events first by time, and then by type of event such that 'end' comes before 'start' when times are the same events.sort(key=lambda x: (x[0], x[1] == 'start')) max_overlap = 0 current_overlap = 0 for event in events: if event[1] == 'start': current_overlap += 1 max_overlap = max(max_overlap, current_overlap) else: current_overlap -= 1 return max_overlap"},{"question":"def numDistinctIslands(grid: List[List[str]]) -> int: Given a rectangular grid of size \`m x n\` consisting of water and land where 1 represents land and 0 represents water, return the number of distinct islands. An island is formed by connecting adjacent lands horizontally or vertically, and two islands are considered distinct if one island is not identical to another (i.e., they are not reflections or rotations of one another). >>> grid = [ ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ... ] >>> numDistinctIslands(grid) 1 >>> grid = [ ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"1\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ... ] >>> numDistinctIslands(grid) 2 >>> grid = [ ... [\\"1\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"1\\"], ... [\\"0\\", \\"1\\", \\"1\\"] ... ] >>> numDistinctIslands(grid) 2 >>> grid = [ ... [\\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\"] ... ] >>> numDistinctIslands(grid) 1 >>> grid = [ ... [\\"1\\"] ... ] >>> numDistinctIslands(grid) 1","solution":"def numDistinctIslands(grid): def dfs(x, y, island, direction): # if out of bounds or at water cell, return if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == '0': return # mark the cell as visited grid[x][y] = '0' # record the direction island.append(direction) # do DFS in all directions dfs(x + 1, y, island, 'D') # down dfs(x - 1, y, island, 'U') # up dfs(x, y + 1, island, 'R') # right dfs(x, y - 1, island, 'L') # left # avoid same directions when coming back island.append('B') unique_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': island = [] dfs(i, j, island, 'O') # 'O' for origin unique_islands.add(tuple(island)) return len(unique_islands)"},{"question":"def sum_except_self(nums: List[int]) -> List[int]: Return an array where each element at index i is the sum of all elements in nums except nums[i]. >>> sum_except_self([1,2,3,4]) [9, 8, 7, 6] >>> sum_except_self([4, 1, 1, 2, 2]) [6, 9, 9, 8, 8] >>> sum_except_self([10]) [0] >>> sum_except_self([0, 0, 0, 0]) [0, 0, 0, 0] >>> sum_except_self([-1, -2, -3, -4]) [-9, -8, -7, -6] >>> sum_except_self([-1, 2, -3, 4]) [3, 0, 5, -2] pass","solution":"def sum_except_self(nums): Returns an array where each element at index i is the sum of all elements in nums except nums[i]. total_sum = sum(nums) answer = [total_sum - num for num in nums] return answer"},{"question":"from typing import List def min_time_to_reach_target(grid: List[List[int]], target_x: int, target_y: int) -> int: Determine the minimum time required to reach a target cell in the grid, starting from the fire cells. The fire spreads to adjacent cells (up, down, left, right) every minute and cannot pass through walls. If it is impossible to reach the target cell, return \`-1\`. >>> min_time_to_reach_target([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 2, 2) == -1 >>> min_time_to_reach_target([[2, 0, 0], [1, 1, 0], [0, 0, 0]], 2, 2) == 4 >>> min_time_to_reach_target([[2, 0, 0], [1, 1, 0], [0, 0, 1]], 2, 2) == -1 >>> min_time_to_reach_target([[2, 1, 0], [1, 1, 0], [0, 0, 0]], 2, 2) == -1 >>> min_time_to_reach_target([[2, 0], [0, 0]], 1, 1) == 2","solution":"from collections import deque def min_time_to_reach_target(grid, target_x, target_y): if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) target = (target_x, target_y) if grid[target_x][target_y] == 1: return -1 # Target cell is a wall directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque() visited = set() # Initialize the queue with all fire starting points for i in range(m): for j in range(n): if grid[i][j] == 2: queue.append((i, j, 0)) # (row, col, time) visited.add((i, j)) # BFS to spread the fire while queue: x, y, time = queue.popleft() if (x, y) == target: return time for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, time + 1)) visited.add((nx, ny)) return -1"},{"question":"def max_trees_visible(heights): Returns the maximum number of trees that can be viewed from the tower tree. heights: The list of integers representing the height of trees. The function considers all possible trees where the observation tower could be built and determines the maximum number of visible trees, including the tower tree. pass # Unit Test def test_single_tree(): assert max_trees_visible([5]) == 1 assert max_trees_visible([10]) == 1 def test_two_trees(): assert max_trees_visible([1, 2]) == 2 assert max_trees_visible([2, 1]) == 2 def test_three_trees(): assert max_trees_visible([1, 2, 3]) == 3 assert max_trees_visible([3, 2, 1]) == 3 assert max_trees_visible([2, 3, 1]) == 3 def test_varied_heights(): assert max_trees_visible([4, 2, 3, 6, 5, 1, 7]) == 7 assert max_trees_visible([1, 3, 2, 5, 7, 6, 4]) == 7 def test_decreasing_heights(): prev = -float('inf') count = 0 for height in heights: if height > prev: count += 1 prev = height return count","solution":"def max_trees_visible(heights): Returns the maximum number of trees that can be viewed from the tower tree. heights: The list of integers representing the height of trees. The function considers all possible trees where the observation tower could be built and determines the maximum number of visible trees, including the tower tree. n = len(heights) if n == 0: return 0 max_visible = 0 for i in range(n): left_visible = 0 right_visible = 0 # Counting visible trees to the left tallest_left = heights[i] for j in range(i - 1, -1, -1): if heights[j] > tallest_left: left_visible += 1 tallest_left = heights[j] else: left_visible += 1 # Counting visible trees to the right tallest_right = heights[i] for k in range(i + 1, n): if heights[k] > tallest_right: right_visible += 1 tallest_right = heights[k] else: right_visible += 1 max_visible = max(max_visible, 1 + left_visible + right_visible) return max_visible"},{"question":"def min_changes_to_make_anagram(s: str, t: str) -> int: Returns the minimum number of changes needed to make t an anagram of s. >>> min_changes_to_make_anagram(\\"abc\\", \\"abc\\") == 0 >>> min_changes_to_make_anagram(\\"anagram\\", \\"mangaar\\") == 0 >>> min_changes_to_make_anagram(\\"abc\\", \\"def\\") == 3 >>> min_changes_to_make_anagram(\\"abcd\\", \\"abc\\") Traceback (most recent call last): ValueError: The lengths of s and t must be the same >>> min_changes_to_make_anagram(\\"listen\\", \\"silent\\") == 0 >>> min_changes_to_make_anagram(\\"aabbcc\\", \\"abccba\\") == 0 >>> min_changes_to_make_anagram(\\"aaaaa\\", \\"bbbbb\\") == 5","solution":"from collections import Counter def min_changes_to_make_anagram(s, t): Returns the minimum number of changes needed to make t an anagram of s. if len(s) != len(t): raise ValueError(\\"The lengths of s and t must be the same\\") count_s = Counter(s) count_t = Counter(t) changes_needed = 0 for char in count_s: if count_s[char] > count_t[char]: changes_needed += count_s[char] - count_t[char] return changes_needed"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root: TreeNode) -> str: Encodes a tree to a single string. Args: root (TreeNode): The root of the binary tree. Returns: str: The serialized string representation of the binary tree. >>> root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))) >>> serialize(root) \\"1,2,null,null,3,4,null,null,5,null,null\\" >>> root = None >>> serialize(root) \\"null\\" def deserialize(data: str) -> TreeNode: Decodes your encoded data to tree. Args: data (str): The serialized string representation of the binary tree. Returns: TreeNode: The root of the deserialized binary tree. >>> root = deserialize(\\"1,2,null,null,3,4,null,null,5,null,null\\") >>> serialize(root) \\"1,2,null,null,3,4,null,null,5,null,null\\" >>> root = deserialize(\\"null\\") >>> root is None True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. def helper(node): if not node: serialized_values.append(\\"null\\") return serialized_values.append(str(node.val)) helper(node.left) helper(node.right) serialized_values = [] helper(root) return ','.join(serialized_values) def deserialize(data): Decodes your encoded data to tree. def helper(): value = next(values) if value == \\"null\\": return None node = TreeNode(int(value)) node.left = helper() node.right = helper() return node values = iter(data.split(',')) return helper()"},{"question":"def pacificAtlantic(matrix): Returns the number of cells from which water can flow to both the Pacific and Atlantic Ocean. >>> pacificAtlantic([ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4] ]) == 7 >>> pacificAtlantic([ [1, 2], [3, 4] ]) == 3 >>> pacificAtlantic([[1, 2, 1, 3, 4]]) == 5 >>> pacificAtlantic([ [1], [2], [3], [4] ]) == 4 >>> pacificAtlantic([]) == 0 >>> pacificAtlantic([ [1, 1], [1, 1] ]) == 4 pass","solution":"def pacificAtlantic(matrix): Returns the number of cells from which water can flow to both the Pacific and Atlantic Ocean. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) def dfs(matrix, visited, i, j): visited.add((i, j)) for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: if 0 <= x < m and 0 <= y < n and (x, y) not in visited and matrix[x][y] >= matrix[i][j]: dfs(matrix, visited, x, y) pacific_reachable = set() atlantic_reachable = set() for i in range(m): dfs(matrix, pacific_reachable, i, 0) dfs(matrix, atlantic_reachable, i, n-1) for j in range(n): dfs(matrix, pacific_reachable, 0, j) dfs(matrix, atlantic_reachable, m-1, j) return len(pacific_reachable & atlantic_reachable)"},{"question":"def min_deletions_to_make_anagrams(word1: str, word2: str) -> int: Returns the minimum number of deletions required to make the two strings anagrams. >>> min_deletions_to_make_anagrams(\\"abc\\", \\"abc\\") == 0 >>> min_deletions_to_make_anagrams(\\"abc\\", \\"def\\") == 6 >>> min_deletions_to_make_anagrams(\\"abc\\", \\"abd\\") == 2 >>> min_deletions_to_make_anagrams(\\"\\", \\"abc\\") == 3 >>> min_deletions_to_make_anagrams(\\"abc\\", \\"\\") == 3 >>> min_deletions_to_make_anagrams(\\"aab\\", \\"a\\") == 2 >>> min_deletions_to_make_anagrams(\\"aabbc\\", \\"abbcc\\") == 2 >>> min_deletions_to_make_anagrams(\\"aabbcc\\", \\"abbbcc\\") == 2","solution":"from collections import Counter def min_deletions_to_make_anagrams(word1, word2): Returns the minimum number of deletions required to make the two strings anagrams. count1 = Counter(word1) count2 = Counter(word2) # Find the characters that need to be deleted deletions = 0 for char in count1: if char in count2: deletions += abs(count1[char] - count2[char]) else: deletions += count1[char] for char in count2: if char not in count1: deletions += count2[char] return deletions"},{"question":"def second_smallest(numbers: List[int]) -> int: Returns the second smallest distinct number in the list. If there are less than two distinct numbers, returns -1. >>> second_smallest([4, 2, 5, 1, 3, 2, 5]) == 2 >>> second_smallest([1, 1, 1, 1]) == -1 >>> second_smallest([5, 2]) == 5 >>> second_smallest([10, 5, 3, 7, 6]) == 5 >>> second_smallest([-1, -2, -3, -4]) == -3 >>> second_smallest([]) == -1 >>> second_smallest([5]) == -1 >>> second_smallest([4, 1, 4, 1, 2]) == 2","solution":"def second_smallest(numbers): Returns the second smallest distinct number in the list. If there are less than two distinct numbers, returns -1. distinct_numbers = list(set(numbers)) # Remove duplicates if len(distinct_numbers) < 2: return -1 distinct_numbers.sort() return distinct_numbers[1]"},{"question":"def findLongestWord(s: str, words: List[str]) -> str: Returns the longest word in words that can be formed by deleting some characters of s without reordering the remaining characters. If there is more than one possible result, returns the longest word with the smallest lexicographical order. If no valid word can be formed, returns an empty string. >>> findLongestWord(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monkey\\", \\"plea\\"]) 'apple' >>> findLongestWord(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"c\\"]) 'a' >>> findLongestWord(\\"abpcplea\\", [\\"x\\", \\"y\\", \\"z\\"]) '' >>> findLongestWord(\\"abpcplea\\", [\\"ale\\", \\"plea\\", \\"ple\\"]) 'plea' >>> findLongestWord(\\"abpcplea\\", []) '' >>> findLongestWord(\\"\\", [\\"ale\\", \\"apple\\", \\"monkey\\", \\"plea\\"]) '' >>> findLongestWord(\\"\\", []) '' >>> findLongestWord(\\"abcabcabcabc\\", [\\"abc\\", \\"cba\\", \\"bca\\"]) 'abc'","solution":"def findLongestWord(s, words): Returns the longest word in words that can be formed by deleting some characters of s without reordering the remaining characters. If there is more than one possible result, returns the longest word with the smallest lexicographical order. If no valid word can be formed, returns an empty string. def is_subsequence(x): it = iter(s) return all(char in it for char in x) longest_word = '' for word in words: if is_subsequence(word): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"def count_matching_words(s: str, wordList: List[str]) -> int: Given a string \`s\` containing digits from 2 to 9 inclusive and a list of strings \`wordList\`, return the count of words from \`wordList\` that can exactly represent one of the possible concatenations of the letters that these digits could represent. >>> count_matching_words(\\"23\\", [\\"ad\\", \\"be\\", \\"cf\\", \\"dog\\"]) 3 >>> count_matching_words(\\"2\\", [\\"a\\", \\"b\\", \\"c\\"]) 3 >>> count_matching_words(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) 0 >>> count_matching_words(\\"23\\", []) 0 >>> count_matching_words(\\"234\\", [\\"adg\\", \\"beh\\", \\"cfi\\", \\"xyz\\"]) 3","solution":"def count_matching_words(s, wordList): Given a string \`s\` containing digits from 2 to 9 inclusive and a list of strings \`wordList\`, return the count of words from \`wordList\` that can exactly represent one of the possible concatenations of the letters that these digits could represent. # Mapping of digits to corresponding letters digit_to_letters = { '2': \\"abc\\", '3': \\"def\\", '4': \\"ghi\\", '5': \\"jkl\\", '6': \\"mno\\", '7': \\"pqrs\\", '8': \\"tuv\\", '9': \\"wxyz\\" } from itertools import product # Generate lists of letters for each digit in the string \`s\` letter_combinations = [digit_to_letters[digit] for digit in s] # Generate all possible concatenations possible_words = set(''.join(combination) for combination in product(*letter_combinations)) # Count how many words from wordList are in the possible_words set matching_words_count = sum(1 for word in wordList if word in possible_words) return matching_words_count"},{"question":"def can_split_into_equal_sum_subarrays(arr): Determines if an array can be split into two subarrays with equal sum. Arguments: arr -- a list of integers Returns: True if the array can be split into two subarrays with equal sum, False otherwise. >>> can_split_into_equal_sum_subarrays([1, 2, 3, 4, 5, 5]) == True >>> can_split_into_equal_sum_subarrays([10, 1, 1, 2, 2, 4]) == True >>> can_split_into_equal_sum_subarrays([1, 2, 3, 4, 5]) == False >>> can_split_into_equal_sum_subarrays([5]) == False >>> can_split_into_equal_sum_subarrays([]) == False >>> can_split_into_equal_sum_subarrays([1, 1, 1, 1]) == True >>> can_split_into_equal_sum_subarrays([-1, -1, 1, 2, -1, -3, 3]) == True","solution":"def can_split_into_equal_sum_subarrays(arr): Determines if an array can be split into two subarrays with equal sum. Arguments: arr -- a list of integers Returns: True if the array can be split into two subarrays with equal sum, False otherwise. total_sum = sum(arr) # If the total sum is odd, we can't split it into two equal parts if total_sum % 2 != 0: return False target_sum = total_sum // 2 current_sum = 0 for num in arr: current_sum += num if current_sum == target_sum: return True return False"},{"question":"def removeKdigits(num: str, k: int) -> str: Returns the smallest possible number as a string after removing exactly k digits from num. >>> removeKdigits(\\"1432219\\", 3) \\"1219\\" >>> removeKdigits(\\"10200\\", 1) \\"200\\" >>> removeKdigits(\\"10\\", 2) \\"0\\" >>> removeKdigits(\\"112\\", 1) \\"11\\" >>> removeKdigits(\\"9\\", 1) \\"0\\" >>> removeKdigits(\\"12345\\", 5) \\"0\\" >>> removeKdigits(\\"1234567890\\", 9) \\"0\\" >>> removeKdigits(\\"13579\\", 0) \\"13579\\"","solution":"def removeKdigits(num: str, k: int) -> str: Returns the smallest possible number as a string after removing exactly k digits from num. # Edge case where k is greater than or equal to the length of the number if k == len(num): return \\"0\\" stack = [] for digit in num: # While stack has elements, k is greater than 0, # and the current digit is less than the last digit in the stack, # remove the last digit from the stack (to get a smaller number) while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # Finally, remove the remaining digits from the end if k > 0 final_number = stack[:-k] if k else stack # Convert the list back to a string and strip leading zeroes result = \\"\\".join(final_number).lstrip('0') # Return \\"0\\" if the result is an empty string return result if result else \\"0\\""},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths in a m x n grid. The result is returned modulo 10^9 + 7. >>> unique_paths(3, 3) 6 >>> unique_paths(1, 1) 1 >>> unique_paths(2, 2) 2 >>> unique_paths(7, 3) 28 >>> unique_paths(100, 200) < 10**9 + 7 >>> unique_paths(1000, 1000) > 0 pass","solution":"def unique_paths(m, n): Returns the number of unique paths in a m x n grid. The result is returned modulo 10^9 + 7. MOD = 10**9 + 7 # Initialize a 2D array with zeros dp = [[0] * n for _ in range(m)] # Base case: One way to reach any cell in the first row or first column. for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD return dp[m-1][n-1]"},{"question":"def rearrange_string(s: str) -> str: Rearranges the input string such that no two adjacent characters are both \\"special\\". A \\"special\\" character appears at least three times in \`s\`. Returns the rearranged string if possible, else an empty string. >>> rearrange_string(\\"abc\\") 'abc' >>> rearrange_string(\\"aaabbb\\") in [\\"ababab\\", \\"bababa\\"] >>> rearrange_string(\\"aaabbc\\") in [\\"ababac\\", \\"abacab\\", \\"bacaba\\", \\"bcabab\\", \\"babaca\\", \\"bacbaa\\"] >>> rearrange_string(\\"aaab\\") '' >>> rearrange_string(\\"a\\") 'a' >>> rearrange_string(\\"abcd\\") 'abcd'","solution":"from collections import Counter from heapq import heappop, heappush def rearrange_string(s): Rearranges the input string such that no two adjacent characters are both \\"special\\". A \\"special\\" character appears at least three times in \`s\`. Returns the rearranged string if possible, else an empty string. # Count the frequency of each character in the string char_count = Counter(s) # Create a max heap based on the counts. Using negative because Python's heap is min heap by default heap = [] for char, count in char_count.items(): heappush(heap, (-count, char)) prev_count, prev_char = 0, '' result = [] while heap: count, char = heappop(heap) # Append the current character to the result result.append(char) # If the previous char exists and it's not zero, push it back into heap if prev_count < 0: heappush(heap, (prev_count, prev_char)) # Update the count of the current character count += 1 prev_count, prev_char = count, char # If the rearranged string's length matches the original string, it's valid if len(result) != len(s): return \\"\\" return \\"\\".join(result)"},{"question":"def find_min_diff(arr): Finds the minimum possible absolute difference between the sums of two parts of the array. >>> find_min_diff([1, 6, 11, 5]) 1 >>> find_min_diff([3, 1]) 2 >>> find_min_diff([2, 2]) 0 >>> find_min_diff([10, 20, 15, 5]) 0 >>> find_min_diff([8, 7, 5, 3]) 1 >>> find_min_diff([2, 10, 15, 5, 8]) 0 >>> find_min_diff([100, 200, 300, 400]) 0 >>> find_min_diff([1, 500, 500]) 1 >>> find_min_diff([1, 6]) 5 >>> find_min_diff([10, 10, 10, 10]) 0 >>> find_min_diff([3, 1, 4, 2, 2]) 0","solution":"def find_min_diff(arr): Finds the minimum possible absolute difference between the sums of two parts of the array. total_sum = sum(arr) n = len(arr) # Create a DP table where dp[i][j] is True if a subset of sum j can be formed using the first i elements dp = [[False] * (total_sum//2 + 1) for _ in range(n+1)] # Initialize for i in range(n+1): dp[i][0] = True # Fill the DP table for i in range(1, n+1): for j in range(1, total_sum//2 + 1): dp[i][j] = dp[i-1][j] if arr[i-1] <= j: dp[i][j] = dp[i][j] or dp[i-1][j-arr[i-1]] # Find the maximum sum that is possible to achieve with the first n elements for j in range(total_sum//2, -1, -1): if dp[n][j]: sum1 = j break sum2 = total_sum - sum1 return abs(sum2 - sum1)"},{"question":"def sort_nearly_sorted_array(arr: List[int]) -> List[int]: Given an integer array \`arr\` where each element is at most two positions away from its original position in a sorted array, return the sorted version of this array. Write an efficient algorithm to achieve this, ensuring your solution handles the given constraints optimally. >>> sort_nearly_sorted_array([2, 1]) == [1, 2] >>> sort_nearly_sorted_array([3, 1, 2]) == [1, 2, 3] >>> sort_nearly_sorted_array([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> sort_nearly_sorted_array([2, 3, 1, 5, 4]) == [1, 2, 3, 4, 5] >>> sort_nearly_sorted_array([3, 2, 4, 6, 5]) == [2, 3, 4, 5, 6] >>> sort_nearly_sorted_array([1]) == [1] >>> sort_nearly_sorted_array([5, 5, 5, 5]) == [5, 5, 5, 5] >>> sort_nearly_sorted_array([10, 9, 8, 7, 11, 25, 12, 10, 13, 15, 14]) == [7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 25]","solution":"import heapq def sort_nearly_sorted_array(arr): Given an array where each element is at most two positions away from its original position in a sorted array, return the sorted version of this array. n = len(arr) if n <= 2: return sorted(arr) # Initiate a min heap heap = [] result = [] # Add first 3 elements to the heap because any element in the sorted array # can only be present within the first 3 elements at maximum. for i in range(3): heapq.heappush(heap, arr[i]) # For the rest of the elements, add the next element and remove the # smallest element from the heap. for i in range(3, n): heapq.heappush(heap, arr[i]) result.append(heapq.heappop(heap)) # Add remaining elements in the heap to the result. while heap: result.append(heapq.heappop(heap)) return result"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_level_sum(root: Optional[TreeNode]) -> int: Return the deepest level sum of the binary tree. >>> root = TreeNode(1) >>> deepest_level_sum(root) 1 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> deepest_level_sum(root) 5 >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, None, TreeNode(5))) >>> deepest_level_sum(root) 9 >>> root = TreeNode(1, ... TreeNode(2, TreeNode(4, TreeNode(8)), TreeNode(5)), ... TreeNode(3, TreeNode(6), TreeNode(7, None, TreeNode(9)))) >>> deepest_level_sum(root) 17 >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3, None, TreeNode(4)))) >>> deepest_level_sum(root) 4 >>> root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4)))) >>> deepest_level_sum(root) 4 >>> deepest_level_sum(None) 0 pass","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_level_sum(root): if not root: return 0 queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"from typing import List def longest_str_chain(words: List[str]) -> int: Returns the length of the longest word chain that can be created from the given list of words. >>> longest_str_chain([\\"a\\", \\"b\\", \\"ba\\", \\"bca\\", \\"bda\\", \\"bdca\\"]) 4 >>> longest_str_chain([\\"a\\", \\"b\\", \\"c\\"]) 1","solution":"def longest_str_chain(words): Returns the length of the longest word chain that can be created from the given list of words. words.sort(key=len) longest_chain = {} max_length = 0 for word in words: longest_chain[word] = 1 for i in range(len(word)): prev_word = word[:i] + word[i+1:] if prev_word in longest_chain: longest_chain[word] = max(longest_chain[word], longest_chain[prev_word] + 1) max_length = max(max_length, longest_chain[word]) return max_length"},{"question":"def longest_contiguous_ones(s: str) -> int: Returns the length of the longest contiguous sequence of '1's that can be achieved by flipping at most one '0' to '1' in the given binary string \`s\`. :param s: A binary string consisting of '0' and '1'. :return: An integer representing the length of the longest contiguous sequence of '1's. >>> longest_contiguous_ones(\\"1111\\") 4 >>> longest_contiguous_ones(\\"1101101\\") 5 >>> longest_contiguous_ones(\\"1010101\\") 3 >>> longest_contiguous_ones(\\"0011100\\") 4 >>> longest_contiguous_ones(\\"0\\") 1 >>> longest_contiguous_ones(\\"1\\") 1 >>> longest_contiguous_ones(\\"\\") 0","solution":"def longest_contiguous_ones(s): Returns the length of the longest contiguous sequence of '1's that can be achieved by flipping at most one '0' to '1' in the given binary string \`s\`. :param s: A binary string consisting of '0' and '1'. :return: An integer representing the length of the longest contiguous sequence of '1's. n = len(s) if n == 0: return 0 # Count the number of 1s in the original string total_ones = s.count('1') if total_ones == n: # All are 1s return total_ones # Use two pointers to find the longest sequence left = 0 right = 0 max_ones_with_flip = 0 zeros_count = 0 while right < n: if s[right] == '0': zeros_count += 1 while zeros_count > 1: if s[left] == '0': zeros_count -= 1 left += 1 max_ones_with_flip = max(max_ones_with_flip, right - left + 1) right += 1 return max_ones_with_flip"},{"question":"def min_changes_to_avoid_consecutive_repeats(s: str) -> int: Returns the minimum number of changes needed to avoid consecutive repeating characters in the string. >>> min_changes_to_avoid_consecutive_repeats(\\"abcde\\") == 0 >>> min_changes_to_avoid_consecutive_repeats(\\"aab\\") == 1 >>> min_changes_to_avoid_consecutive_repeats(\\"aabb\\") == 2 >>> min_changes_to_avoid_consecutive_repeats(\\"aaaa\\") == 3 >>> min_changes_to_avoid_consecutive_repeats(\\"abababab\\") == 0 >>> min_changes_to_avoid_consecutive_repeats(\\"abacaba\\") == 0 >>> min_changes_to_avoid_consecutive_repeats(\\"\\") == 0","solution":"def min_changes_to_avoid_consecutive_repeats(s): Returns the minimum number of changes needed to avoid consecutive repeating characters in the string. if not s: return 0 changes = 0 n = len(s) for i in range(1, n): if s[i] == s[i-1]: changes += 1 # To avoid consecutive repeats, change the current character to some other character. # We can choose any character different from s[i-1] if i + 1 < n and s[i-1] == s[i+1]: # If the next character is the same as s[i-1], we need to change s[i+1] as well. # We'll assume changing s[i+1] will be handled in the next iterations. pass return changes"},{"question":"def visible_buildings(arr): Returns the indices of buildings that are visible from the left. Args: arr: List[int] - A list of integers representing the heights of buildings. Returns: List[int] - A list of indices of buildings that are visible from the left. Examples: >>> visible_buildings([5]) [0] >>> visible_buildings([3, 3, 3, 3]) [0] >>> visible_buildings([1, 2, 3, 4]) [0, 1, 2, 3] >>> visible_buildings([4, 3, 2, 1]) [0] >>> visible_buildings([3, 1, 4, 2, 5]) [0, 2, 4] >>> visible_buildings([1, 3, 2, 4, 3, 5]) [0, 1, 3, 5] >>> visible_buildings([]) [] >>> visible_buildings([1, 2, 1, 1, 1]) [0, 1]","solution":"def visible_buildings(arr): Returns the indices of buildings that are visible from the left. Args: arr: List[int] - A list of integers representing the heights of buildings. Returns: List[int] - A list of indices of buildings that are visible from the left. visible = [] max_height = float('-inf') for i, height in enumerate(arr): if height > max_height: visible.append(i) max_height = height return visible"},{"question":"class BankAccount: Class that simulates a simple bank account. >>> account = BankAccount(100.0) >>> account.getBalance() 100.0 >>> account.deposit(50.0) >>> account.getBalance() 150.0 >>> account.withdraw(50.0) True >>> account.getBalance() 100.0 >>> account.withdraw(150.0) False >>> account.getBalance() 100.0 def __init__(self, initialBalance): Initializes the account with a given initial balance. pass def deposit(self, amount): Adds the specified amount to the account balance. pass def withdraw(self, amount): Subtracts the specified amount from the account balance if sufficient funds are available. Returns True if the withdrawal was successful, False otherwise. pass def getBalance(self): Returns the current balance of the account. pass","solution":"class BankAccount: def __init__(self, initialBalance): Initializes the account with a given initial balance. if initialBalance < 0: raise ValueError(\\"Initial balance must be non-negative.\\") self.balance = round(initialBalance, 2) def deposit(self, amount): Adds the specified amount to the account balance. if amount < 0: raise ValueError(\\"Deposit amount must be non-negative.\\") self.balance = round(self.balance + amount, 2) def withdraw(self, amount): Subtracts the specified amount from the account balance if sufficient funds are available. Returns True if the withdrawal was successful, False otherwise. if amount < 0: raise ValueError(\\"Withdrawal amount must be non-negative.\\") if self.balance >= amount: self.balance = round(self.balance - amount, 2) return True else: return False def getBalance(self): Returns the current balance of the account. return self.balance"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_deepest_left_leaf(root): Function to find the deepest left leaf node in a binary tree. If there are multiple deepest left leaf nodes, return the value of the leftmost one. If there is no left leaf, return -1. pass # Unit Tests def test_find_deepest_left_leaf_empty_tree(): assert find_deepest_left_leaf(None) == -1 def test_find_deepest_left_leaf_single_node(): root = TreeNode(1) assert find_deepest_left_leaf(root) == -1 def test_find_deepest_left_leaf_with_left_child(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert find_deepest_left_leaf(root) == 2 def test_find_deepest_left_leaf_multiple_levels(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.left.left.left = TreeNode(7) assert find_deepest_left_leaf(root) == 7 def test_find_deepest_left_leaf_multiple_left_leaves(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(4) root.left.left.left = TreeNode(7) root.left.right = TreeNode(8) root.left.right.left = TreeNode(9) assert find_deepest_left_leaf(root) == 7 def test_find_deepest_left_leaf_with_only_right_tree(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) assert find_deepest_left_leaf(root) == -1","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_deepest_left_leaf(root): Function to find the deepest left leaf node in a binary tree. If there are multiple deepest left leaf nodes, return the value of the leftmost one. If there is no left leaf, return -1. if not root: return -1 # Queue for level order traversal, storing nodes along with their depth and whether they are left children queue = [(root, 0, False)] deepest_left_leaf_depth = -1 deepest_left_leaf_val = -1 while queue: current, depth, is_left = queue.pop(0) # Check if it's a left leaf node and deeper than the known deepest if is_left and not current.left and not current.right and depth > deepest_left_leaf_depth: deepest_left_leaf_depth = depth deepest_left_leaf_val = current.val # Add children to the queue if current.left: queue.append((current.left, depth + 1, True)) if current.right: queue.append((current.right, depth + 1, False)) return deepest_left_leaf_val"},{"question":"def get_special_characters(s: str) -> str: Returns a new string consisting of characters in \`s\` that appear exactly twice. :param s: Input string consisting of lowercase English letters :return: A new string with all non-special characters removed >>> get_special_characters(\\"aabcdd\\") == \\"aadd\\" >>> get_special_characters(\\"abcabc\\") == \\"abcabc\\" >>> get_special_characters(\\"abcdefg\\") == \\"\\" >>> get_special_characters(\\"abbcccdddde\\") == \\"bb\\" >>> get_special_characters(\\"aaabbbccc\\") == \\"\\" >>> get_special_characters(\\"\\") == \\"\\"","solution":"def get_special_characters(s): Returns a new string consisting of characters in \`s\` that appear exactly twice. :param s: Input string consisting of lowercase English letters :return: A new string with all non-special characters removed from collections import Counter char_count = Counter(s) special_chars = ''.join([char for char in s if char_count[char] == 2]) return special_chars"},{"question":"def min_moves_to_sort(heights: List[int]) -> int: Returns the minimum number of moves required for the line to be in non-decreasing order of heights. Args: heights (List[int]): A list of integers representing the heights of people. Returns: int: Minimum number of moves required. pass","solution":"def min_moves_to_sort(heights): Returns the minimum number of moves required for the line to be in non-decreasing order of heights. Args: heights (List[int]): A list of integers representing the heights of people. Returns: int: Minimum number of moves required. sorted_heights = sorted(heights) moves = 0 for i in range(len(heights)): if heights[i] != sorted_heights[i]: moves += 1 return moves"},{"question":"def can_travel(routes: List[List[str]], startCity: str, destinationCity: str) -> bool: Determines if there is a way to travel from a given starting city \`startCity\` to a destination city \`destinationCity\` using the given list of flight routes. Parameters: routes (List[List[str]]): A list of flight routes represented as pairs of cities. startCity (str): The city from which the travel starts. destinationCity (str): The city to which the travel is to be made. Returns: bool: True if it is possible to travel from \`startCity\` to \`destinationCity\`, otherwise False. If \`startCity\` and \`destinationCity\` are the same, returns True. Examples: >>> can_travel([['A', 'B'], ['B', 'C'], ['C', 'D']], 'A', 'D') True >>> can_travel([['A', 'B'], ['C', 'D']], 'A', 'D') False >>> can_travel([['A', 'B']], 'A', 'A') True >>> can_travel([['A', 'B'], ['B', 'C'], ['C', 'A']], 'A', 'C') True >>> can_travel([['A', 'B'], ['C', 'D'], ['B', 'E'], ['F', 'G']], 'A', 'E') True >>> can_travel([['A', 'B'], ['C', 'D'], ['B', 'E'], ['F', 'G']], 'A', 'G') False >>> can_travel([['A', 'B'], ['B', 'C'], ['C', 'D'], ['A', 'E'], ['E', 'F'], ['F', 'D']], 'A', 'D') True >>> can_travel([['A', 'B'], ['B', 'C'], ['C', 'D'], ['A', 'E'], ['E', 'F'], ['F', 'D']], 'B', 'F') True >>> can_travel([['A', 'B'], ['B', 'C'], ['C', 'D'], ['A', 'E'], ['E', 'F'], ['F', 'D']], 'E', 'C') True","solution":"def can_travel(routes, startCity, destinationCity): from collections import defaultdict, deque if startCity == destinationCity: return True # Create adjacency list graph = defaultdict(list) for cityA, cityB in routes: graph[cityA].append(cityB) graph[cityB].append(cityA) # Perform BFS to find a path from startCity to destinationCity visited = set() queue = deque([startCity]) while queue: current_city = queue.popleft() if current_city == destinationCity: return True if current_city not in visited: visited.add(current_city) for neighbor in graph[current_city]: if neighbor not in visited: queue.append(neighbor) return False"},{"question":"def max_consecutive_ones(binary_string: str) -> int: Given a binary string \`s\`, you are allowed to perform at most one operation where you can choose any substring of \`s\` and flip all the bits in it (i.e., change all \`0\`s to \`1\`s and all \`1\`s to \`0\`s). Your goal is to return the maximum number of consecutive \`1\`s that can be obtained by performing at most one flip operation. If no flipping is needed to achieve the maximum number of consecutive \`1\`s, return the length of the already longest sequence of consecutive \`1\`s. >>> max_consecutive_ones('11111') 5 >>> max_consecutive_ones('101') 3 >>> max_consecutive_ones('011111') 6 >>> max_consecutive_ones('111110') 6 >>> max_consecutive_ones('100110111') 6 >>> max_consecutive_ones('0000') 1 >>> max_consecutive_ones('') 0","solution":"def max_consecutive_ones(binary_string): Returns the maximum number of consecutive 1s obtainable by at most one flip operation on any substring of the binary string. n = len(binary_string) if n == 0: return 0 left_ones = [0] * n right_ones = [0] * n current_ones = 0 for i in range(n): if binary_string[i] == '1': current_ones += 1 else: current_ones = 0 left_ones[i] = current_ones current_ones = 0 for i in range(n-1, -1, -1): if binary_string[i] == '1': current_ones += 1 else: current_ones = 0 right_ones[i] = current_ones max_consecutive_1s = max(left_ones) # Without any flip for i in range(1, n - 1): if binary_string[i] == '0': # Sequence if flipped binary_string[i] from 0 to 1 max_consecutive_1s = max(max_consecutive_1s, left_ones[i-1] + 1 + right_ones[i+1]) if '0' in binary_string: max_consecutive_1s = max(max_consecutive_1s, max(left_ones) + 1) # Single flip for all zeroes return max_consecutive_1s"},{"question":"def longest_unique_substring_length(s: str) -> int: Given a string \`s\`, return the length of the longest substring containing only unique characters that can be generated by any permutation of the given string. >>> longest_unique_substring_length(\\"abc\\") 3 >>> longest_unique_substring_length(\\"abac\\") 3 >>> longest_unique_substring_length(\\"aaaa\\") 1 >>> longest_unique_substring_length(\\"\\") 0 >>> longest_unique_substring_length(\\"aabbcde\\") 5","solution":"def longest_unique_substring_length(s): Returns the length of the longest substring containing only unique characters that can be generated by any permutation of the given string. return len(set(s))"},{"question":"from typing import List, Optional def is_complete_binary_tree(tree: List[Optional[int]]) -> bool: Determines if the given binary tree (represented as a level order list of elements) is a Complete Binary Tree. >>> is_complete_binary_tree([1, 2, 3, 4, 5, 6, 7]) == True >>> is_complete_binary_tree([1, 2, 3, 4, 5, None, None]) == True >>> is_complete_binary_tree([1, 2, 3, 4, None, 6, 7]) == False >>> is_complete_binary_tree([1, 2, 3, None, 5, 6, 7]) == False >>> is_complete_binary_tree([]) == True >>> is_complete_binary_tree([None]) == True >>> is_complete_binary_tree([1, None, None]) == True >>> is_complete_binary_tree([1, 2, None]) == True","solution":"def is_complete_binary_tree(tree): Determines if the given binary tree (represented as a level order list of elements) is a Complete Binary Tree. if not tree: return True n = len(tree) # Identify the first occurrence of None for i in range(n): if tree[i] is None: # Check if all the elements after the first None are also None for j in range(i, n): if tree[j] is not None: return False break return True"},{"question":"def largest_square_submatrix(matrix: List[List[int]], k: int) -> int: Determine the length of the largest square submatrix with all 1's in the given k x k binary matrix. >>> largest_square_submatrix([], 0) == 0 >>> largest_square_submatrix([[0, 0], [0, 0]], 2) == 0 >>> largest_square_submatrix([[1, 1], [1, 1]], 2) == 2 >>> largest_square_submatrix([ >>> [1, 0, 1, 0, 0], >>> [1, 0, 1, 1, 1], >>> [1, 1, 1, 1, 1], >>> [1, 0, 0, 1, 0] >>> ], 4) == 2 >>> largest_square_submatrix([ >>> [1, 1, 1, 1], >>> [0, 0, 0, 0], >>> [0, 0, 0, 0], >>> [0, 0, 0, 0] >>> ], 4) == 1","solution":"def largest_square_submatrix(matrix, k): if k == 0: return 0 dp = [[0] * k for _ in range(k)] max_side = 0 for i in range(k): for j in range(k): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 # If it's on the first row or first column else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"def min_subarray_len(nums: List[int], target: int) -> int: Returns the length of the shortest, non-empty contiguous subarray of \`nums\` with a sum greater than or equal to \`target\`. If there is no such subarray, returns \`0\`. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 2, 3, 4], 15) 0 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1], 5) 5 >>> min_subarray_len([1, 2, 3, 4, 5], 4) 1 >>> min_subarray_len([1, 2, 3, 4, 5], 11) 3 >>> min_subarray_len([10, 20, 30, 40, 50], 60) 2 >>> min_subarray_len([10, 1, 2, 3], 9) 1 >>> min_subarray_len([1, 2, 3, 4, 5], 15) 5","solution":"def min_subarray_len(nums, target): Returns the length of the shortest, non-empty contiguous subarray of \`nums\` with a sum greater than or equal to \`target\`. n = len(nums) min_len = float('inf') # Initialize to a large number left = 0 curr_sum = 0 for right in range(n): curr_sum += nums[right] while curr_sum >= target: min_len = min(min_len, right - left + 1) curr_sum -= nums[left] left += 1 return 0 if min_len == float('inf') else min_len"},{"question":"def lexicalOrder(num: int) -> List[int]: Given a positive integer num, generate the lexicographical order (dictionary order) from 1 to num inclusive. >>> lexicalOrder(13) [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9] >>> lexicalOrder(5) [1, 2, 3, 4, 5] >>> lexicalOrder(20) [1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 20, 3, 4, 5, 6, 7, 8, 9] >>> lexicalOrder(30) [1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 3, 30, 4, 5, 6, 7, 8, 9] >>> lexicalOrder(1) [1]","solution":"def lexicalOrder(num): Given a positive integer num, generate the lexicographical order (dictionary order) from 1 to num inclusive. return sorted(range(1, num + 1), key=str)"},{"question":"def min_moves_to_make_palindrome(s: str, t: str) -> int: Returns the minimum number of moves needed to make s a palindrome using characters from t. >>> min_moves_to_make_palindrome(\\"level\\", \\"abcdef\\") 0 >>> min_moves_to_make_palindrome(\\"abcdef\\", \\"fedcba\\") 3 >>> min_moves_to_make_palindrome(\\"a\\", \\"b\\") 0 >>> min_moves_to_make_palindrome(\\"abccba\\", \\"fedcab\\") 0 >>> min_moves_to_make_palindrome(\\"abca\\", \\"dabc\\") 1 from solution import min_moves_to_make_palindrome def test_palindrome_with_no_moves_needed(): assert min_moves_to_make_palindrome(\\"level\\", \\"abcdef\\") == 0 def test_palindrome_with_minimum_moves(): assert min_moves_to_make_palindrome(\\"abcdef\\", \\"fedcba\\") == 3 def test_palindrome_with_single_char(): assert min_moves_to_make_palindrome(\\"a\\", \\"b\\") == 0 def test_palindrome_with_even_length_string(): assert min_moves_to_make_palindrome(\\"abccba\\", \\"fedcab\\") == 0 def test_palindrome_with_odd_length_string(): assert min_moves_to_make_palindrome(\\"abca\\", \\"dabc\\") == 1","solution":"def min_moves_to_make_palindrome(s, t): Returns the minimum number of moves needed to make s a palindrome using characters from t. n = len(s) moves = 0 for i in range(n // 2): left = s[i] right = s[n - 1 - i] if left != right: if left in t: s = s[:i] + right + s[i+1:] elif right in t: s = s[:n - 1 - i] + left + s[n - i:] else: s = s[:i] + right + s[i+1:] t = t.replace(left, '', 1).replace(right, '', 1) moves += 1 return moves"},{"question":"def min_steps_to_palindrome(s: str) -> int: Determines the minimum number of steps required to make the string a palindrome. :param s: Input string consisting only of lowercase English letters. :return: Minimum number of character replacements needed. >>> min_steps_to_palindrome(\\"abca\\") 1 >>> min_steps_to_palindrome(\\"racecar\\") 0 >>> min_steps_to_palindrome(\\"abcdef\\") 3 >>> min_steps_to_palindrome(\\"a\\") 0 >>> min_steps_to_palindrome(\\"aa\\") 0 >>> min_steps_to_palindrome(\\"aabb\\") 2 >>> min_steps_to_palindrome(\\"abcba\\") 0 >>> min_steps_to_palindrome(\\"abcde\\") 2 >>> min_steps_to_palindrome(\\"abccba\\") 0 >>> min_steps_to_palindrome(\\"ab\\") 1 # Your code here","solution":"def min_steps_to_palindrome(s: str) -> int: Determines the minimum number of steps required to make the string a palindrome. :param s: Input string consisting only of lowercase English letters. :return: Minimum number of character replacements needed. n = len(s) steps = 0 # Compare characters from both ends towards the center for i in range(n // 2): if s[i] != s[n - i - 1]: steps += 1 return steps"},{"question":"def find_palindromic_substrings(s: str) -> List[str]: Given a single string \`s\` consisting of lowercase English letters, find and return all the different palindromic substrings in \`s\`. A string is palindromic if it reads the same forward and backward. Your function should return a list of all unique palindromic substrings in lexicographical order. >>> find_palindromic_substrings(\\"a\\") [\\"a\\"] >>> find_palindromic_substrings(\\"abc\\") [\\"a\\", \\"b\\", \\"c\\"] >>> find_palindromic_substrings(\\"aa\\") [\\"a\\", \\"aa\\"] >>> find_palindromic_substrings(\\"aabb\\") [\\"a\\", \\"aa\\", \\"b\\", \\"bb\\"] >>> find_palindromic_substrings(\\"abac\\") [\\"a\\", \\"aba\\", \\"b\\", \\"c\\"] >>> find_palindromic_substrings(\\"\\") []","solution":"def find_palindromic_substrings(s): Returns a list of unique palindromic substrings in lexicographical order. def is_palindrome(sub): return sub == sub[::-1] palindromic_substrings = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): substring = s[i:j] if is_palindrome(substring): palindromic_substrings.add(substring) return sorted(palindromic_substrings)"},{"question":"def countDistinctSubstrings(s: str) -> int: Returns the total number of distinct substrings present in the string s. >>> countDistinctSubstrings(\\"abc\\") 6 >>> countDistinctSubstrings(\\"aaa\\") 3 >>> countDistinctSubstrings(\\"\\") 0 >>> countDistinctSubstrings(\\"abcd\\") 10 >>> countDistinctSubstrings(\\"abab\\") 7 >>> countDistinctSubstrings(\\"abac\\") 9","solution":"def countDistinctSubstrings(s): Returns the total number of distinct substrings present in the string s. n = len(s) substrings = set() for i in range(n): for j in range(i, n): substrings.add(s[i:j+1]) return len(substrings)"},{"question":"def number_of_distinct_maximums(arr: List[int]) -> List[int]: Given an array of integers \`arr\`, find the number of distinct maximum values in each of its subarrays. Return an array \`result\` where \`result[i]\` is the number of distinct maximum values in the subarray starting at index \`i\` and ending at any possible index \`j\` (where \`i <= j < len(arr)\`). >>> number_of_distinct_maximums([1]) [1] >>> number_of_distinct_maximums([1, 2, 3]) [3, 2, 1] >>> number_of_distinct_maximums([3, 2, 1]) [1, 1, 1] >>> number_of_distinct_maximums([1, 2, 1]) [2, 1, 1] >>> number_of_distinct_maximums([5, 5, 5, 5]) [1, 1, 1, 1] >>> number_of_distinct_maximums([10, 20, 30, 20, 10]) [3, 2, 1, 1, 1]","solution":"def number_of_distinct_maximums(arr): Returns an array where the ith element contains the number of distinct maximum values in all subarrays starting from index i. n = len(arr) result = [] for i in range(n): subarray_max = set() current_max = float('-inf') for j in range(i, n): current_max = max(current_max, arr[j]) subarray_max.add(current_max) result.append(len(subarray_max)) return result"},{"question":"def findClosestElements(arr, k, x): Given a sorted array of unique integers, return the k closest integers to x in the array. The result should be sorted in ascending order. If there is a tie, the smaller element is preferred. >>> findClosestElements([1, 2, 3, 4, 5], 4, 3) [1, 2, 3, 4] >>> findClosestElements([1, 2, 3, 4, 5], 4, -1) [1, 2, 3, 4] >>> findClosestElements([1, 2, 3, 4, 5], 4, 5) [2, 3, 4, 5] >>> findClosestElements([1, 2, 3, 4, 5], 1, 3) [3] >>> findClosestElements([1, 2, 3, 4, 5], 1, 0) [1] >>> findClosestElements([1, 2, 3, 4, 5, 6, 7, 8], 3, 6) [5, 6, 7] >>> findClosestElements([1, 3, 4, 8, 9, 10], 3, 5) [3, 4, 8] >>> findClosestElements([1, 2, 3, 4, 5], 5, 3) [1, 2, 3, 4, 5] >>> findClosestElements([], 3, 3) [] >>> findClosestElements([1], 1, 1) [1]","solution":"def findClosestElements(arr, k, x): Returns the k closest integers to x in the array. left = 0 right = len(arr) - 1 while right - left >= k: if abs(arr[left] - x) > abs(arr[right] - x): left += 1 else: right -= 1 return arr[left:left + k]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head): Reverses the linked list. Args: head (ListNode): The head of the linked list. Returns: ListNode: The new head of the reversed linked list. # Implementation goes here def list_to_linkedlist(lst): if not lst: return None head = ListNode(lst[0]) current = head for val in lst[1:]: current.next = ListNode(val) current = current.next return head def linkedlist_to_list(head): lst = [] while head: lst.append(head.val) head = head.next return lst def test_reverse_linked_list(): head = list_to_linkedlist([1, 2, 3, 4, 5]) reversed_head = reverse_linked_list(head) result = linkedlist_to_list(reversed_head) assert result == [5, 4, 3, 2, 1] def test_reverse_empty_list(): head = list_to_linkedlist([]) reversed_head = reverse_linked_list(head) assert reversed_head == None def test_reverse_single_element_list(): head = list_to_linkedlist([1]) reversed_head = reverse_linked_list(head) result = linkedlist_to_list(reversed_head) assert result == [1] def test_reverse_two_element_list(): head = list_to_linkedlist([1, 2]) reversed_head = reverse_linked_list(head) result = linkedlist_to_list(reversed_head) assert result == [2, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head): Reverses the linked list. Args: head (ListNode): The head of the linked list. Returns: ListNode: The new head of the reversed linked list. prev = None curr = head while curr: next_node = curr.next curr.next = prev prev = curr curr = next_node return prev"},{"question":"def singleNumber(nums: List[int]) -> int: Given an array of integers where every integer appears exactly three times except for one that appears only once, return the integer that appears only once. Args: nums (List[int]): The list of integers. Returns: int: The single number that appears only once. Examples: >>> singleNumber([2,2,3,2]) 3 >>> singleNumber([0,1,0,1,0,1,99]) 99 >>> singleNumber([1]) 1","solution":"def singleNumber(nums): Given an array of integers where every integer appears exactly three times except for one that appears only once, return the integer that appears only once. Args: nums (List[int]): The list of integers. Returns: int: The single number that appears only once. if not nums: return 0 # Initialize variables to hold bits showing up once and twice ones, twos = 0, 0 for num in nums: # First, calculate \`ones\` ones = (ones ^ num) & ~twos # Then, calculate \`twos\` twos = (twos ^ num) & ~ones # \`ones\` is holding the single number now since bits are cleared when they appear thrice return ones"},{"question":"def buildingsWithOceanView(heights): Given an array of integers representing the heights of \`n\` buildings, determine the number of buildings that have an ocean view. A building has an ocean view if all the buildings to its right have a smaller height. Assume the ocean is to the right side of the array. Returns an array containing the indices of all buildings that have an ocean view, in increasing order. >>> buildingsWithOceanView([1, 2, 3, 4]) [3] >>> buildingsWithOceanView([4, 3, 2, 1]) [0, 1, 2, 3] >>> buildingsWithOceanView([1, 3, 2, 4]) [3] >>> buildingsWithOceanView([5]) [0] >>> buildingsWithOceanView([4, 2, 3, 1]) [0, 2, 3]","solution":"def buildingsWithOceanView(heights): Returns an array containing the indices of all buildings that have an ocean view. n = len(heights) max_height = 0 result = [] for i in range(n-1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1]"},{"question":"def max_k_consecutive_sum(nums: List[int], threshold: int) -> int: Returns the maximum integer k such that there exists k consecutive elements in the array nums with their sum not exceeding the given threshold. >>> max_k_consecutive_sum([1, 2, 3, 4], 10) == 4 >>> max_k_consecutive_sum([5, 5, 5], 4) == -1 >>> max_k_consecutive_sum([1, 2, 3, 4, 5], 5) == 2 >>> max_k_consecutive_sum([1, 2, 3, 4, 5], 50) == 5 >>> max_k_consecutive_sum([5], 5) == 1 >>> max_k_consecutive_sum([5], 4) == -1 >>> max_k_consecutive_sum([2, 1, 4, 1, 2, 1, 5, 1], 5) == 3 >>> max_k_consecutive_sum([], 10) == -1 >>> max_k_consecutive_sum([1, 10], 10) == 1","solution":"def max_k_consecutive_sum(nums, threshold): Returns the maximum integer k such that there exists k consecutive elements in the array nums with their sum not exceeding the given threshold. n = len(nums) left, right = 1, n def can_find_k(k): current_sum = sum(nums[:k]) if current_sum <= threshold: return True for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum <= threshold: return True return False max_k = -1 while left <= right: mid = (left + right) // 2 if can_find_k(mid): max_k = mid left = mid + 1 else: right = mid - 1 return max_k"},{"question":"class Solution: def __init__(self, s: str, k: int): Initializes the object with the string \`s\` and the integer \`k\`. self.s = s self.k = k def minOperations(self) -> int: Returns the minimum number of operations required to transform the string \`s\` into a palindrome with a maximum of \`k\` consecutive characters being the same. >>> Solution(\\"abba\\", 2).minOperations() 0 >>> Solution(\\"abca\\", 2).minOperations() 1 >>> Solution(\\"abcd\\", 2).minOperations() 2 >>> Solution(\\"efghij\\", 3).minOperations() 3 >>> Solution(\\"\\", 1).minOperations() 0 >>> Solution(\\"a\\", 1).minOperations() 0 pass","solution":"class Solution: def __init__(self, s, k): self.s = s self.k = k def minOperations(self): s = self.s n = len(s) k = self.k operations = 0 # Traverse the string from both ends to the center for i in range(n // 2): if s[i] != s[n - i - 1]: operations += 1 return operations"},{"question":"def buildings_with_sunset_view(arr: List[int]) -> List[int]: Returns the indices of buildings that can see the sunset. A building can see the sunset if there are no buildings of equal or greater height to its right. :param arr: List of integers representing the heights of buildings. :return: List of indices of buildings that can see the sunset. >>> buildings_with_sunset_view([4, 4, 4, 4]) == [3] >>> buildings_with_sunset_view([1, 2, 3, 4, 5]) == [4] >>> buildings_with_sunset_view([5, 4, 3, 2, 1]) == [0, 1, 2, 3, 4] >>> buildings_with_sunset_view([4, 2, 8, 3, 7, 1, 5]) == [2, 4, 6] >>> buildings_with_sunset_view([10]) == [0] >>> buildings_with_sunset_view([]) == []","solution":"def buildings_with_sunset_view(arr): Returns the indices of buildings that can see the sunset. A building can see the sunset if there are no buildings of equal or greater height to its right. :param arr: List of integers representing the heights of buildings. :return: List of indices of buildings that can see the sunset. result = [] max_height = float('-inf') for i in range(len(arr)-1, -1, -1): if arr[i] > max_height: result.append(i) max_height = arr[i] return sorted(result)"},{"question":"def first_missing_positive(nums: List[int]) -> int: Find the smallest missing positive integer in the list nums. Args: nums: List[int] - List of non-negative integers Return: int - The smallest missing positive integer >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([1, 2, 3]) 4 >>> first_missing_positive([0]) 1 >>> first_missing_positive([1, 2, 2, 10, -2, -1, 3, 4, 5, 7]) 6 >>> first_missing_positive([]) 1","solution":"def first_missing_positive(nums): Find the smallest missing positive integer in the list nums. Args: nums: List[int] - List of non-negative integers Return: int - The smallest missing positive integer n = len(nums) # Step 1: Mark numbers which are out of range (negative numbers and numbers that are 0 or > n) for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Step 2: Use the index as a hash to record the frequency of the number for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Step 3: The first index which has positive number, its index + 1 is the result for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"def three_sum(arr, targetSum): Determines if there are three distinct elements in the array \`arr\` that sum up to \`targetSum\`. Parameters: arr (list of int): The list of integers. targetSum (int): The target sum to find in the array. Returns: bool: True if such a triplet exists, False otherwise. Examples: >>> three_sum([1, 2, 3, 4, 5], 9) True >>> three_sum([1, 2, 3, 4, 5], 20) False >>> three_sum([-1, 0, 1, 2, -1, -4], 0) True >>> three_sum([-1, 0, 1, 2, -1, -4], -5) True >>> three_sum([1, 1, 1], 5) False >>> three_sum([2, 2, 2, 2], 6) True","solution":"def three_sum(arr, targetSum): Determines if there are three distinct elements in the array \`arr\` that sum up to \`targetSum\`. Parameters: arr (list of int): The list of integers. targetSum (int): The target sum to find in the array. Returns: bool: True if such a triplet exists, False otherwise. arr.sort() n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == targetSum: return True elif current_sum < targetSum: left += 1 else: right -= 1 return False"},{"question":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Function to find the area of the largest rectangle that can be formed within the bounds of the histogram. Args: heights (List[int]): List of non-negative integers representing the heights of bars in a histogram. Returns: int: The area of the largest rectangle that can be formed within the bounds of the histogram. Example: >>> largestRectangleArea([2,1,5,6,2,3]) 10 >>> largestRectangleArea([2,2,2,2,2]) 10 >>> largestRectangleArea([]) 0 >>> largestRectangleArea([5]) 5 >>> largestRectangleArea([1,2,3,4,5]) 9 >>> largestRectangleArea([5,4,3,2,1]) 9 >>> largestRectangleArea([6,2,5,4,5,1,6]) 12 def test_largestRectangleArea_with_example(): assert largestRectangleArea([2,1,5,6,2,3]) == 10 def test_largestRectangleArea_with_all_equal_heights(): assert largestRectangleArea([2,2,2,2,2]) == 10 def test_largestRectangleArea_with_no_bars(): assert largestRectangleArea([]) == 0 def test_largestRectangleArea_with_one_bar(): assert largestRectangleArea([5]) == 5 def test_largestRectangleArea_with_increasing_heights(): assert largestRectangleArea([1,2,3,4,5]) == 9 def test_largestRectangleArea_with_decreasing_heights(): assert largestRectangleArea([5,4,3,2,1]) == 9 def test_largestRectangleArea_with_mixed_heights(): assert largestRectangleArea([6,2,5,4,5,1,6]) == 12","solution":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Function to find the area of the largest rectangle that can be formed within the bounds of the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"class NonDecreasingArray: @staticmethod def checkPossibility(nums: List[int]) -> bool: Determines if the array can be made non-decreasing by modifying at most one element. >>> NonDecreasingArray.checkPossibility([1, 2, 3, 4, 5]) == True >>> NonDecreasingArray.checkPossibility([4, 2, 3]) == True >>> NonDecreasingArray.checkPossibility([3, 4, 2, 3]) == False >>> NonDecreasingArray.checkPossibility([4, 2, 1]) == False >>> NonDecreasingArray.checkPossibility([1, 1, 1, 1]) == True >>> NonDecreasingArray.checkPossibility([1, 2, 3, 1]) == True >>> NonDecreasingArray.checkPossibility([1]) == True >>> NonDecreasingArray.checkPossibility([3, 2]) == True >>> NonDecreasingArray.checkPossibility([2, 3]) == True","solution":"class NonDecreasingArray: @staticmethod def checkPossibility(nums): Determines if the array can be made non-decreasing by modifying at most one element. count = 0 for i in range(1, len(nums)): if nums[i] < nums[i - 1]: if count == 1: return False count += 1 if i - 2 < 0 or nums[i - 2] <= nums[i]: nums[i - 1] = nums[i] else: nums[i] = nums[i - 1] return True"},{"question":"from typing import List def k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]: This function returns a list of k smallest pairs (u, v) where u is from nums1 and v is from nums2. >>> k_smallest_pairs([1, 2], [3, 4], 3) [[1, 3], [1, 4], [2, 3]] >>> k_smallest_pairs([1, 2], [3, 4], 0) []","solution":"import heapq def k_smallest_pairs(nums1, nums2, k): This function returns a list of k smallest pairs (u, v) where u is from nums1 and v is from nums2. if not nums1 or not nums2 or k <= 0: return [] min_heap = [] for i in range(min(k, len(nums1))): heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0)) result = [] while k > 0 and min_heap: sum_uv, i, j = heapq.heappop(min_heap) result.append([nums1[i], nums2[j]]) k -= 1 if j + 1 < len(nums2): heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1)) return result"},{"question":"from typing import List class DailyTemperatures: def dailyTemperatures(self, temperatures: List[int]) -> List[int]: Given a list of daily temperatures, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. >>> dt = DailyTemperatures() >>> dt.dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dt.dailyTemperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> dt.dailyTemperatures([30, 30, 30, 30]) [0, 0, 0, 0] >>> dt.dailyTemperatures([30]) [0] >>> dt.dailyTemperatures([90, 80, 70, 60]) [0, 0, 0, 0]","solution":"from typing import List class DailyTemperatures: def dailyTemperatures(self, temperatures: List[int]) -> List[int]: Given a list of daily temperatures, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. answer = [0] * len(temperatures) stack = [] # stores indices of the temperatures list for i, current_temp in enumerate(temperatures): while stack and temperatures[stack[-1]] < current_temp: index = stack.pop() answer[index] = i - index stack.append(i) return answer"},{"question":"def mergeStrings(word1: str, word2: str) -> str: You are given two strings \`word1\` and \`word2\`. You want to construct a new string \`merge\` using all the characters of \`word1\` and \`word2\` in a way that maintains their respective orders. Your task is to return the lexicographically smallest \`merge\` from all possible merges. For example: >>> mergeStrings(\\"abc\\", \\"def\\") 'abcdef' >>> mergeStrings(\\"ab\\", \\"zz\\") 'abzz' from solution import mergeStrings def test_mergeStrings_example1(): assert mergeStrings(\\"abc\\", \\"def\\") == \\"abcdef\\" def test_mergeStrings_example2(): assert mergeStrings(\\"ab\\", \\"zz\\") == \\"abzz\\" def test_mergeStrings_same_prefix(): assert mergeStrings(\\"abc\\", \\"abz\\") == \\"aabbcz\\" def test_mergeStrings_one_empty(): assert mergeStrings(\\"\\", \\"abc\\") == \\"abc\\" assert mergeStrings(\\"abc\\", \\"\\") == \\"abc\\" def test_mergeStrings_both_empty(): assert mergeStrings(\\"\\", \\"\\") == \\"\\" def test_mergeStrings_interleaved(): assert mergeStrings(\\"ace\\", \\"bdf\\") == \\"abcdef\\" def test_mergeStrings_different_lengths(): assert mergeStrings(\\"ab\\", \\"xyz\\") == \\"abxyz\\"","solution":"def mergeStrings(word1, word2): Returns the lexicographically smallest merge of \`word1\` and \`word2\`. i, j = 0, 0 merge = [] while i < len(word1) and j < len(word2): if word1[i:] < word2[j:]: merge.append(word1[i]) i += 1 else: merge.append(word2[j]) j += 1 merge.extend(word1[i:]) merge.extend(word2[j:]) return ''.join(merge)"},{"question":"def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Given a list of words and a pattern, return a list of all the words that match the given pattern. Note that a word matches the pattern if there exists a permutation of letters \`p\` so that after replacing every letter \`x\` in the pattern with \`p(x)\`, we get the word. All words and patterns consist of lowercase English letters only. Each word or pattern will be between 1 and 20 characters long. >>> find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], \\"abb\\") [\\"mee\\", \\"aqq\\"] >>> find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"xyz\\"], \\"aac\\") [] >>> find_and_replace_pattern([\\"a\\", \\"b\\", \\"c\\"], \\"a\\") [\\"a\\", \\"b\\", \\"c\\"] >>> find_and_replace_pattern([\\"abc\\", \\"xyz\\", \\"def\\"], \\"abc\\") [\\"abc\\", \\"xyz\\", \\"def\\"] >>> find_and_replace_pattern([\\"a\\", \\"aa\\", \\"aaa\\"], \\"aaa\\") [\\"aaa\\"]","solution":"def find_and_replace_pattern(words, pattern): Finds and returns a list of all the words that match the given pattern. def matches(word, pattern): if len(word) != len(pattern): return False word_to_pattern, pattern_to_word = {}, {} for w, p in zip(word, pattern): if word_to_pattern.get(w) != pattern_to_word.get(p): return False word_to_pattern[w] = pattern_to_word[p] = p return True return [word for word in words if matches(word, pattern)]"},{"question":"def min_additional_candies(nums: List[int]) -> int: Given an array of integers, nums, representing the number of candies each child has initially, this function returns the minimum number of additional candies needed to make the sequence non-decreasing. >>> min_additional_candies([5, 5, 5, 5]) 0 >>> min_additional_candies([1, 2, 3, 4]) 0 >>> min_additional_candies([4, 3, 2, 1]) 6 >>> min_additional_candies([1, 3, 2, 4, 2]) 3 >>> min_additional_candies([5]) 0 >>> min_additional_candies([]) 0 >>> min_additional_candies([2, 3]) 0 >>> min_additional_candies([3, 2]) 1 # Your code here","solution":"def min_additional_candies(nums): Given an array of integers, nums, representing the number of candies each child has initially, this function returns the minimum number of additional candies needed to make the sequence non-decreasing. additional_candies = 0 for i in range(1, len(nums)): if nums[i] < nums[i - 1]: additional_candies += nums[i - 1] - nums[i] nums[i] = nums[i - 1] return additional_candies"},{"question":"def numDistinctIslands(grid: List[List[str]]) -> int: Counts the number of distinct islands in the grid where '1' represents land and '0' represents water. :param grid: List[List[str]], a 2D grid where '1' represents land and '0' represents water :return: int, number of distinct islands >>> numDistinctIslands([ >>> \\"111\\", >>> \\"010\\", >>> \\"111\\" >>> ]) == 1 >>> numDistinctIslands([ >>> \\"11000\\", >>> \\"11000\\", >>> \\"00100\\", >>> \\"00011\\" >>> ]) == 3 >>> numDistinctIslands([ >>> \\"000\\", >>> \\"000\\", >>> \\"000\\" >>> ]) == 0 >>> numDistinctIslands([ >>> \\"11011\\", >>> \\"11011\\", >>> \\"00000\\", >>> \\"11011\\", >>> \\"11011\\" >>> ]) == 1 >>> numDistinctIslands([ >>> \\"111\\", >>> \\"101\\", >>> \\"111\\", >>> \\"000\\", >>> \\"111\\", >>> \\"101\\", >>> \\"111\\" >>> ]) == 1 >>> numDistinctIslands([ >>> \\"11000\\", >>> \\"11000\\", >>> \\"00100\\", >>> \\"00011\\", >>> \\"00011\\" >>> ]) == 2","solution":"def numDistinctIslands(grid): Counts the number of distinct islands in the grid. :param grid: List[List[str]], a 2D grid where '1' represents land and '0' represents water :return: int, number of distinct islands def dfs(x, y, grid, seen, island, origin): stack = [(x, y)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while stack: cx, cy = stack.pop() island.add((cx - origin[0], cy - origin[1])) # record relative position for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == '1' and (nx, ny) not in seen: seen.add((nx, ny)) stack.append((nx, ny)) seen = set() unique_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1' and (i, j) not in seen: island = set() seen.add((i, j)) dfs(i, j, grid, seen, island, (i, j)) if island: unique_islands.add(frozenset(island)) return len(unique_islands)"},{"question":"def max_balanced_length(s: str) -> int: Returns the maximum possible length of a \\"balanced\\" string obtained from the input string \`s\` by removing one or more characters. A \\"balanced\\" string is defined as a string where no letter appears more than once. >>> max_balanced_length(\\"abc\\") 3 >>> max_balanced_length(\\"aaaa\\") 1 >>> max_balanced_length(\\"abacabad\\") 4 >>> max_balanced_length(\\"\\") 0 >>> max_balanced_length(\\"z\\") 1 >>> max_balanced_length(\\"abcabcabc\\") 3 >>> max_balanced_length(\\"a b c a b c\\") 4 >>> max_balanced_length(\\"a1b2c3a1b2c3\\") 6","solution":"def max_balanced_length(s): Returns the maximum possible length of a \\"balanced\\" string obtained from the input string \`s\` by removing one or more characters. # A balanced string contains no character more than once # Thus, the maximum length of a balanced string is the number of unique characters in \`s\` return len(set(s))"},{"question":"def can_form_palindrome(s: str) -> bool: Checks if the given string can be rearranged to form a palindrome. :param s: input string :return: True if the input string can be rearranged to form a palindrome, False otherwise","solution":"def can_form_palindrome(s): Checks if the given string can be rearranged to form a palindrome. :param s: input string :return: True if the input string can be rearranged to form a palindrome, False otherwise from collections import Counter # Count the frequency of each character in the string. char_count = Counter(s) # To form a palindrome, at most one character can have an odd count. odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if there is at most one odd character count. return odd_count <= 1"},{"question":"from typing import List def possible_bipartition(n: int, edges: List[List[int]]) -> bool: Determine if it's possible to split the animals into two distinct groups such that no two animals within the same group interact with each other. >>> possible_bipartition(1, []) True >>> possible_bipartition(2, []) True >>> possible_bipartition(4, [[1, 2], [3, 4], [1, 3]]) True >>> possible_bipartition(3, [[1, 2], [2, 3], [3, 1]]) False >>> possible_bipartition(5, [[1, 2], [3, 4]]) True >>> possible_bipartition(6, [[1, 2], [2, 3], [4, 5], [5, 6], [6, 4]]) False >>> possible_bipartition(8, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 1]]) True >>> possible_bipartition(6, [[1, 2], [2, 3], [3, 4], [4, 1], [4, 5], [5, 6], [6, 4]]) False pass","solution":"def possible_bipartition(n, edges): from collections import defaultdict, deque graph = defaultdict(list) for a, b in edges: graph[a].append(b) graph[b].append(a) color = {} for node in range(1, n + 1): # assuming animals are labeled from 1 to n if node not in color: queue = deque([node]) color[node] = 0 # starting color while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in color: color[neighbor] = 1 - color[current] # flip color queue.append(neighbor) elif color[neighbor] == color[current]: return False return True"},{"question":"def max_taste_subarray(heights, tastes): You are given two arrays: \`heights\` and \`tastes\`, both of which are **0-indexed** and have the same length \`n\`. The \`heights\` array represents the heights of \`n\` plants in a garden, and the \`tastes\` array represents the taste factor of each respective plant. You want to select a contiguous subarray of plants such that the sum of their taste factors is maximized, but you must ensure that the height of each plant in the selected subarray is strictly increasing from left to right. Return the maximum sum of taste factors for such a subarray. If no such subarray exists, return 0. >>> max_taste_subarray([1], [5]) == 5 >>> max_taste_subarray([1, 2, 3], [4, 5, 6]) == 15 >>> max_taste_subarray([3, 2, 1], [4, 5, 6]) == 6 >>> max_taste_subarray([1, 3, 2, 4], [10, 20, 5, 15]) == 45 >>> max_taste_subarray([2, 2, 2], [1, 2, 3]) == 3 >>> max_taste_subarray([1, 5, 3, 6], [2, 10, 5, 15]) == 27 >>> max_taste_subarray([], []) == 0","solution":"def max_taste_subarray(heights, tastes): n = len(heights) if n == 0: return 0 # Initialize a dp array where dp[i] will be the maximum sum of taste factors # of a strictly increasing subarray that ends at index i. dp = [0] * n # Start by setting the dp value for the first plant for i in range(n): dp[i] = tastes[i] max_taste = 0 # Fill dp array using the given conditions for i in range(n): for j in range(i): if heights[j] < heights[i]: # Only consider j if height[j] is less than height[i] dp[i] = max(dp[i], dp[j] + tastes[i]) max_taste = max(max_taste, dp[i]) return max_taste"},{"question":"from typing import List def largestIsland(matrix: List[List[int]]) -> int: Given a binary matrix where \`0\` represents water and \`1\` represents land, find the largest island in the matrix. An island is formed by connecting adjacent lands horizontally or vertically. >>> largestIsland([[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0]]) 4 >>> largestIsland([[1, 0, 0, 1], [0, 1, 1, 0], [0, 0, 0, 1], [1, 0, 0, 1]]) 2 >>> largestIsland([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> largestIsland([[1, 1], [1, 1]]) 4","solution":"def largestIsland(matrix): def dfs(matrix, i, j, visited): if (i < 0 or i >= len(matrix) or j < 0 or j >= len(matrix[0]) or matrix[i][j] == 0 or (i, j) in visited): return 0 visited.add((i, j)) area = 1 area += dfs(matrix, i + 1, j, visited) area += dfs(matrix, i - 1, j, visited) area += dfs(matrix, i, j + 1, visited) area += dfs(matrix, i, j - 1, visited) return area max_area = 0 visited = set() for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 1 and (i, j) not in visited: max_area = max(max_area, dfs(matrix, i, j, visited)) return max_area"},{"question":"def pacific_atlantic(grid: List[List[int]]) -> List[List[int]]: Determine the list of coordinates where water can flow to both the Pacific and Atlantic oceans. >>> pacific_atlantic([ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4] ]) [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] >>> pacific_atlantic([ [1, 1], [1, 1] ]) [[0, 0], [0, 1], [1, 0], [1, 1]] >>> pacific_atlantic([]) [] >>> pacific_atlantic([[1, 2, 2, 3, 4]]) [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4]] >>> pacific_atlantic([ [1], [2], [3], [4], [5] ]) [[0, 0], [1, 0], [2, 0], [3, 0], [4, 0]]","solution":"def pacific_atlantic(grid): if not grid or not grid[0]: return [] rows, cols = len(grid), len(grid[0]) pacific_reachable = [[False for _ in range(cols)] for _ in range(rows)] atlantic_reachable = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c, reachable): reachable[r][c] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and not reachable[nr][nc] and grid[nr][nc] >= grid[r][c]: dfs(nr, nc, reachable) for i in range(rows): dfs(i, 0, pacific_reachable) dfs(i, cols - 1, atlantic_reachable) for j in range(cols): dfs(0, j, pacific_reachable) dfs(rows - 1, j, atlantic_reachable) result = [] for r in range(rows): for c in range(cols): if pacific_reachable[r][c] and atlantic_reachable[r][c]: result.append([r, c]) return result"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle(head): Given a linked list, return the node where the cycle begins. If there is no cycle, return \`None\`. >>> detect_cycle(None) is None True >>> node = ListNode(1) >>> detect_cycle(node) is None True >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node1.next = node2 >>> node2.next = node3 >>> detect_cycle(node1) is None True >>> node = ListNode(1) >>> node.next = node >>> detect_cycle(node) == node True >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node4 = ListNode(4) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> node4.next = node2 >>> detect_cycle(node1) == node2 True","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle(head): Detects the cycle in the linked list and returns the node where the cycle begins. Returns None if there is no cycle. if not head or not head.next: return None slow, fast = head, head has_cycle = False while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: has_cycle = True break if not has_cycle: return None # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"import heapq from typing import List def merge_sorted_strings(matrix: List[str], n: int) -> str: Merge rows of a matrix into a single lexicographically smallest string. Args: matrix (List[str]): A k x n matrix where each row is a string of lowercase English letters in alphabetical order. n (int): The length of each string in the matrix. Returns: str: The lexicographically smallest string obtained by merging the rows. >>> merge_sorted_strings([\\"ace\\", \\"bdf\\"], 3) 'abcdef' >>> merge_sorted_strings([\\"abc\\"], 3) 'abc' >>> merge_sorted_strings([\\"aaa\\", \\"aaa\\"], 3) 'phone'}) expected_label_dict = {'phone': 'android', 'result': 'success'} self.assertTokens(pred_label, expected_label_dict)","solution":"import heapq def merge_sorted_strings(matrix, n): # Min heap to keep track of the smallest elements min_heap = [] # Initialize the heap with the first element of each row for row in matrix: heapq.heappush(min_heap, (row[0], 0, row)) result = [] while min_heap: # Get the smallest element from the heap smallest, idx, string = heapq.heappop(min_heap) result.append(smallest) # If there are more elements in the same row, push the next element into the heap if idx + 1 < n: heapq.heappush(min_heap, (string[idx + 1], idx + 1, string)) # Return the result as a single string return ''.join(result)"},{"question":"def shortest_substring(s: str) -> str: Returns the shortest substring containing at least one 'G', one 'A', and one 'C'. If no such substring exists, returns an empty string. >>> shortest_substring(\\"GACGACG\\") \\"GAC\\" >>> shortest_substring(\\"CGA\\") \\"CGA\\" >>> shortest_substring(\\"GGGG\\") \\"\\" >>> shortest_substring(\\"AAA\\") \\"\\" >>> shortest_substring(\\"CCC\\") \\"\\" >>> shortest_substring(\\"GGGAC\\") \\"GAC\\" >>> shortest_substring(\\"GAAACCAGCAGT\\") \\"CAG\\" >>> shortest_substring(\\"CGATTACGAA\\") \\"CGA\\" >>> shortest_substring(\\"GACCGA\\") \\"GAC\\" >>> shortest_substring(\\"\\") \\"\\"","solution":"def shortest_substring(s): Returns the shortest substring containing at least one 'G', one 'A', and one 'C'. If no such substring exists, returns an empty string. if not s or len(set(s)) < 3: return \\"\\" required_chars = {'G', 'A', 'C'} min_length = float('inf') shortest_sub = \\"\\" left = 0 char_count = {'G': 0, 'A': 0, 'C': 0} for right, char in enumerate(s): if char in char_count: char_count[char] += 1 while all(char_count[c] > 0 for c in required_chars): current_length = right - left + 1 if current_length < min_length: min_length = current_length shortest_sub = s[left:right+1] if s[left] in char_count: char_count[s[left]] -= 1 left += 1 return shortest_sub"},{"question":"def has_pair_with_sum(arr: List[int], target_sum: int) -> bool: Determine if there are two distinct indices i and j in the array arr such that arr[i] + arr[j] == target_sum. >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([1], 1) False >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) True >>> has_pair_with_sum([1, -2, 3, 4, -5], -1) True >>> has_pair_with_sum([1, 1, 2, 4], 2) True","solution":"def has_pair_with_sum(arr, target_sum): Determine if there are two distinct indices i and j in the array arr such that arr[i] + arr[j] == target_sum. seen = set() for num in arr: if target_sum - num in seen: return True seen.add(num) return False"},{"question":"from typing import List def max_array_sum(nums: List[int]) -> int: Returns the maximum possible sum of the array after performing any number of flipping operations. >>> max_array_sum([1, 2, 3, 4]) 10 >>> max_array_sum([-1, -2, -3, -4]) 10 >>> max_array_sum([-1, 2, -3, 4]) 10 >>> max_array_sum([]) 0 >>> max_array_sum([5]) 5 >>> max_array_sum([-5]) 5 >>> max_array_sum([0, -1, 2, -3, 4]) 10 >>> max_array_sum([0, 0, 0]) 0","solution":"def max_array_sum(nums): Returns the maximum possible sum of the array after performing any number of flipping operations. max_sum = 0 for num in nums: max_sum += abs(num) return max_sum"},{"question":"def simplify_path(s: str) -> str: Simplify the given Unix-style file path. Args: s (str): The input path string. Returns: str: The simplified canonical path. >>> simplify_path(\\"/home/user\\") \\"/home/user\\" >>> simplify_path(\\"/home/./user/\\") \\"/home/user\\" >>> simplify_path(\\"/home/user/../data\\") \\"/home/data\\" >>> simplify_path(\\"/a/./b/../../c/\\") \\"/c\\" >>> simplify_path(\\"/\\") \\"/\\" >>> simplify_path(\\"\\") \\"/\\" >>> simplify_path(\\"/a//b///c/d/\\") \\"/a/b/c/d\\" >>> simplify_path(\\"/a/b/c/../..//..\\") \\"/\\" >>> simplify_path(\\"/home/user/../\\") \\"/home\\" >>> simplify_path(\\"/../../../../a\\") \\"/a\\"","solution":"def simplify_path(s): Simplify the given Unix-style file path. Args: s (str): The input path string. Returns: str: The simplified canonical path. parts = s.split('/') stack = [] for part in parts: if part == '' or part == '.': continue elif part == '..': if stack: stack.pop() else: stack.append(part) return '/' + '/'.join(stack)"},{"question":"from typing import List def longestEqualSubarray(nums: List[int]) -> int: Given an integer array \`nums\`, find the length of the longest contiguous subarray with an equal number of \`0\`s and \`1\`s. >>> longestEqualSubarray([0, 1, 0]) 2 >>> longestEqualSubarray([0, 1, 0, 1, 0, 1]) 6 >>> longestEqualSubarray([0, 1]) 2 >>> longestEqualSubarray([1, 1, 1, 0, 0, 0, 1, 1, 1]) 6 >>> longestEqualSubarray([1, 1, 0, 1, 0, 0, 1, 0]) 8 >>> longestEqualSubarray([1, 1, 1, 1]) 0 >>> longestEqualSubarray([0, 0, 0, 0]) 0 >>> longestEqualSubarray([]) 0 >>> longestEqualSubarray([0]) 0 >>> longestEqualSubarray([1]) 0","solution":"def longestEqualSubarray(nums): Returns the length of the longest contiguous subarray with equal number of 0s and 1s. count_map = {0: -1} max_length = 0 count = 0 for i, num in enumerate(nums): if num == 0: count -= 1 else: count += 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"def closest_element(nums: List[int], target: int) -> int: Returns the closest element to target in nums. If there are two elements equally close to target, return the smaller element. >>> closest_element([1, 2, 3, 4, 5], 3) == 3 >>> closest_element([1, 2, 3, 4, 5], 6) == 5 >>> closest_element([1, 2, 3, 4, 5], 0) == 1 >>> closest_element([1, 2, 3, 5, 5], 4) == 3 >>> closest_element([1, 2, 3, 5, 6], 4) == 3 >>> closest_element([1, 2, 3, 5, 6], 7) == 6 >>> closest_element([1, 2, 3, 5, 6], 3) == 3 >>> closest_element([1, 2, 3], 2) == 2 >>> closest_element([1, 4, 5, 7], 6) == 5 >>> closest_element([1], 7) == 1 >>> closest_element([1, 2], 0) == 1 >>> closest_element([1, 2], 3) == 2","solution":"def closest_element(nums, target): Returns the closest element to target in nums. If there are two elements equally close to target, return the smaller element. left, right = 0, len(nums) - 1 closest = nums[0] while left <= right: mid = (left + right) // 2 # Update closest if current mid is closer to target if abs(nums[mid] - target) < abs(closest - target) or (abs(nums[mid] - target) == abs(closest - target) and nums[mid] < closest): closest = nums[mid] if nums[mid] < target: left = mid + 1 elif nums[mid] > target: right = mid - 1 else: return nums[mid] return closest"},{"question":"def largest_constructible_length(words: List[str], target: str) -> int: Returns the length of the largest word in the list that can be constructed using the letters of the target word exactly once. Each letter in the target word can only be used once per word construction. If no words can be constructed, return -1. >>> largest_constructible_length([\\"apple\\", \\"plea\\", \\"ple\\", \\"dog\\"], \\"apple\\") 5 >>> largest_constructible_length([\\"cat\\", \\"dog\\", \\"elephant\\"], \\"bird\\") -1 >>> largest_constructible_length([\\"cat\\", \\"tac\\", \\"act\\"], \\"cat\\") 3 >>> largest_constructible_length([\\"a\\", \\"aa\\", \\"aaa\\"], \\"a\\") 1 >>> largest_constructible_length([\\"a\\", \\"bb\\", \\"ccc\\"], \\"\\") -1 >>> largest_constructible_length([], \\"abc\\") -1","solution":"def can_construct(word, target): Helper function to check if a word can be constructed from the letters of the target word. from collections import Counter word_count = Counter(word) target_count = Counter(target) for char in word_count: if word_count[char] > target_count.get(char, 0): return False return True def largest_constructible_length(words, target): Returns the length of the largest word in the list that can be constructed using the letters of the target word exactly once. max_length = -1 for word in words: if can_construct(word, target): max_length = max(max_length, len(word)) return max_length"},{"question":"from typing import List def max_pool_area(heights: List[int]) -> int: Returns the maximum area of a rectangular pool that can be constructed between two buildings. :param heights: List of integers representing the height of consecutive buildings :return: Integer representing the maximum pool area >>> max_pool_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_pool_area([]) 0 >>> max_pool_area([3, 3, 3, 3]) 9 >>> max_pool_area([1, 2]) 1 >>> max_pool_area([1, 2, 1]) 2 >>> max_pool_area([1, 2, 3, 4, 5]) 6 >>> max_pool_area([5, 4, 3, 2, 1]) 6 >>> max_pool_area([1, 2, 4, 3, 2]) 6","solution":"def max_pool_area(heights): Returns the maximum area of a rectangular pool that can be constructed between two buildings. :param heights: List of integers representing the height of consecutive buildings :return: Integer representing the maximum pool area if not heights: return 0 left, right = 0, len(heights) - 1 max_area = 0 while left < right: width = right - left current_height = min(heights[left], heights[right]) current_area = width * current_height max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def is_balanced(s: str) -> bool: Returns True if the string s has balanced brackets, otherwise returns False. >>> is_balanced(\\"(a + b) * [c - d]\\") == True >>> is_balanced(\\"{[a + b] * c}\\") == True >>> is_balanced(\\"((a + b)\\") == False >>> is_balanced(\\"a + b] * c{\\") == False >>> is_balanced(\\"\\") == True >>> is_balanced(\\"abc123\\") == True >>> is_balanced(\\"{[(a + b) * c] - (d / e)}\\") == True >>> is_balanced(\\"{[(a + b) * c] - (d / e)}]\\") == False","solution":"def is_balanced(s): Returns True if the string s has balanced brackets, otherwise returns False. stack = [] bracket_map = { ')': '(', '}': '{', ']': '[' } for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if stack == [] or bracket_map[char] != stack.pop(): return False return stack == []"},{"question":"def has_pair_with_sum(arr: List[int], k: int) -> bool: Returns True if there exists a pair of indices (i, j) such that i != j and arr[i] + arr[j] equals the target number k. Otherwise, returns False. >>> has_pair_with_sum([1, 2, 3, 4], 5) == True >>> has_pair_with_sum([1, 2, 3, 4], 7) == True >>> has_pair_with_sum([1, 2, 3, 4], 3) == True >>> has_pair_with_sum([1, 2, 3, 4], 8) == False >>> has_pair_with_sum([1, 2, 3, 4], -1) == False >>> has_pair_with_sum([1, 1, 1, 1], 3) == False >>> has_pair_with_sum([-1, -2, -3, -4], -5) == True >>> has_pair_with_sum([-1, -2, -3, -4], -6) == True >>> has_pair_with_sum([-1, -2, -3, -4], -7) == True >>> has_pair_with_sum([], 1) == False >>> has_pair_with_sum([1], 1) == False >>> has_pair_with_sum([5], 10) == False >>> has_pair_with_sum([1000000000, 2000000000, 3000000000], 5000000000) == True >>> has_pair_with_sum([1000000000, 2000000000, 3000000000], 7000000000) == False","solution":"def has_pair_with_sum(arr, k): Returns True if there exists a pair of indices (i, j) such that i != j and arr[i] + arr[j] equals the target number k. Otherwise, returns False. seen = set() for num in arr: if k - num in seen: return True seen.add(num) return False"},{"question":"def count_pairs_with_xor(nums: List[int], k: int) -> int: Returns the number of pairs (i, j) where 0 <= i < j < len(nums) and nums[i] xor nums[j] is equal to the given integer k. >>> count_pairs_with_xor([1, 4, 2, 7], 5) 2 >>> count_pairs_with_xor([1, 2, 3], 7) 0","solution":"def count_pairs_with_xor(nums, k): Returns the number of pairs (i, j) where 0 <= i < j < len(nums) and nums[i] xor nums[j] is equal to the given integer k. count = 0 n = len(nums) # Iterate through all pairs (i, j) and calculate nums[i] xor nums[j] for i in range(n): for j in range(i + 1, n): if nums[i] ^ nums[j] == k: count += 1 return count"},{"question":"def largest_string(s: str, k: int) -> str: Given a string of lowercase English letters \`s\`, you are allowed to turn every \`k\` consecutive characters into uppercase. Return the lexicographically largest string you can obtain by applying the operation any number of times (including zero). >>> largest_string(\\"abcde\\", 2) == \\"ABCDE\\" >>> largest_string(\\"a\\", 1) == \\"A\\" >>> largest_string(\\"azbycx\\", 3) == \\"AZBYCX\\" def test_example_case(): assert largest_string(\\"abcde\\", 2) == \\"ABCDE\\" def test_single_character(): assert largest_string(\\"a\\", 1) == \\"A\\" assert largest_string(\\"z\\", 1) == \\"Z\\" def test_alternating_case(): assert largest_string(\\"azbycx\\", 3) == \\"AZBYCX\\" def test_mixed_case_with_repeated_characters(): assert largest_string(\\"aabbcc\\", 2) == \\"AABBCC\\" def test_large_k(): assert largest_string(\\"abcdefghijklmnopqrstuvwxyz\\", 26) == \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" def test_minimal_k(): assert largest_string(\\"abcdefghijkl\\", 1) == \\"ABCDEFGHIJKL\\" def test_varied_string(): assert largest_string(\\"thequickbrownfox\\", 5) == \\"THEQUICKBROWNFOX\\"","solution":"def largest_string(s, k): Returns the lexicographically largest string by turning every k consecutive characters into uppercase any number of times. n = len(s) s = list(s) # Convert string to a list of characters for mutability # We can turn every character to upper case to ensure the largest lexicographical order for i in range(n): s[i] = s[i].upper() return ''.join(s)"},{"question":"def min_moves_to_make_non_decreasing(arr): Returns the minimum number of moves required to make the array non-decreasing. If it is already non-decreasing, return 0. Args: arr (List[int]): A list of integers. Returns: int: The minimum number of moves required to make the array non-decreasing. Examples: >>> min_moves_to_make_non_decreasing([1, 2, 3, 4, 5]) 0 >>> min_moves_to_make_non_decreasing([1, 3, 2, 4, 5]) 1 >>> min_moves_to_make_non_decreasing([5, 4, 3, 2, 1]) 2 >>> min_moves_to_make_non_decreasing([2, 2, 2, 2]) 0 >>> min_moves_to_make_non_decreasing([]) 0 >>> min_moves_to_make_non_decreasing([1]) 0 >>> min_moves_to_make_non_decreasing([20, 10, 30, 50, 40, 60]) 2","solution":"def min_moves_to_make_non_decreasing(arr): Returns the minimum number of moves required to make the array non-decreasing. If it is already non-decreasing, return 0. n = len(arr) sorted_arr = sorted(arr) # Count the number of elements out of place out_of_place = sum(1 for i in range(n) if arr[i] != sorted_arr[i]) # Each move can correct at most two out-of-place elements return out_of_place // 2"},{"question":"def min_max_items_group(numbers, k): Returns the smallest possible value of the largest number of items in any group after distributing the given items into exactly k groups. >>> min_max_items_group([10], 1) == 10 >>> min_max_items_group([5, 5, 5, 5], 2) == 10 >>> min_max_items_group([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) == 17 >>> min_max_items_group([1, 1, 1, 1, 1, 1, 1], 3) == 3 >>> min_max_items_group([100, 200, 300, 400, 500], 2) == 900","solution":"def min_max_items_group(numbers, k): Returns the smallest possible value of the largest number of items in any group after distributing the given items into exactly k groups. def is_feasible(limit): groups = 1 current_sum = 0 for num in numbers: if current_sum + num > limit: groups += 1 current_sum = num if groups > k: return False else: current_sum += num return True left, right = max(numbers), sum(numbers) while left < right: mid = (left + right) // 2 if is_feasible(mid): right = mid else: left = mid + 1 return left"},{"question":"def max_depth(s: str) -> int: Calculate the maximum depth of nested parentheses in the given sequence. Parameters: s (str): A string of '(' and ')' representing a balanced parentheses sequence. Returns: int: The maximum depth of nested parentheses. >>> max_depth(\\"()\\") == 1 >>> max_depth(\\"(())\\") == 2 >>> max_depth(\\"((()))\\") == 3 >>> max_depth(\\"(()(()))\\") == 3 >>> max_depth(\\"((()())())\\") == 3 >>> max_depth(\\"(((((((((\\") == 9 >>> max_depth(\\")))))))))\\") == 0 >>> max_depth(\\"\\") == 0","solution":"def max_depth(s): Calculate the maximum depth of nested parentheses in the given sequence. Parameters: s (str): A string of '(' and ')' representing a balanced parentheses sequence. Returns: int: The maximum depth of nested parentheses. max_depth = 0 current_depth = 0 for char in s: if char == '(': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == ')': current_depth -= 1 return max_depth"},{"question":"def single_number(nums): Given a non-empty array of integers nums, where each element appears twice except for one, find that single one. :param nums: List[int] :return: int >>> single_number([1]) 1 >>> single_number([2, 2, 3]) 3 >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([-1, -1, -2]) -2 >>> single_number([2, 2, 3, 3, 4]) 4 >>> single_number([4, 1, 2, 1, 2, -4, -4]) 4","solution":"def single_number(nums): Given a non-empty array of integers nums, where each element appears twice except for one, find that single one. :param nums: List[int] :return: int result = 0 for num in nums: result ^= num return result"},{"question":"def min_operations_to_match(source: List[int], target: List[int]) -> int: Returns the minimum number of operations required to make \`source\` an exact match to \`target\`. >>> min_operations_to_match([1, 2, 3], [1, 2, 3]) == 0 >>> min_operations_to_match([1, 2, 3], [2, 2, 3]) == 1 >>> min_operations_to_match([1, 2, 3], [4, 5, 6]) == 9 >>> min_operations_to_match([1, 2, 3], [5, 6, 7]) == 12 >>> min_operations_to_match([10, 20, 30], [30, 40, 50]) == 60 >>> min_operations_to_match([1, 2], [1, 2, 3]) # Raises ValueError: Source and Target arrays must be of the same length.","solution":"def min_operations_to_match(source, target): Returns the minimum number of operations required to make \`source\` an exact match to \`target\`. if len(source) != len(target): raise ValueError(\\"Source and Target arrays must be of the same length.\\") operations = 0 for s, t in zip(source, target): if s < t: operations += (t - s) return operations"},{"question":"def min_students_to_move(heights): Given an array of heights, determine the minimum number of movements required for all students to stand in non-decreasing order of height. Returns the number of moves required. >>> min_students_to_move([1, 2, 3, 4, 5]) == 0 >>> min_students_to_move([5, 4, 3, 2, 1]) == 4 >>> min_students_to_move([1, 3, 2, 4, 5]) == 2 >>> min_students_to_move([2, 2, 2, 2, 2]) == 0 >>> min_students_to_move([2]) == 0 >>> min_students_to_move([1, 4, 2, 3, 3, 5]) == 3 >>> min_students_to_move([]) == 0","solution":"def min_students_to_move(heights): Given an array of heights, determine the minimum number of movements required for all students to stand in non-decreasing order of height. Returns the number of moves required. sorted_heights = sorted(heights) moves_required = 0 for i in range(len(heights)): if heights[i] != sorted_heights[i]: moves_required += 1 return moves_required"},{"question":"def longest_unique_substring(s: str) -> tuple[int, str]: Given a string \`s\`, find the length of the longest substring without repeating characters and return the substring itself. The substring should be contiguous and should not contain any duplicate characters. Example: >>> longest_unique_substring(\\"abcabcbb\\") (3, \\"abc\\") >>> longest_unique_substring(\\"bbbbb\\") (1, \\"b\\") >>> longest_unique_substring(\\"pwwkew\\") (3, \\"wke\\")","solution":"def longest_unique_substring(s): This function finds the length of the longest substring without repeating characters and returns the substring itself. :param s: str :return: tuple(int, str) n = len(s) char_index_map = {} max_length = 0 start = 0 longest_substring = \\"\\" for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end if end - start + 1 > max_length: max_length = end - start + 1 longest_substring = s[start:end + 1] return (max_length, longest_substring)"},{"question":"def count_distinct_chars_with_exactly_k_occurrences(s: str, k: int) -> int: Given a string s consisting of lowercase English letters, return the number of distinct characters in s that appear exactly k times. :param s: Input string consisting of lowercase English letters :param k: The exact number of times the distinct characters must appear :return: Number of distinct characters that appear exactly k times >>> count_distinct_chars_with_exactly_k_occurrences(\\"aabbcc\\", 2) 3 >>> count_distinct_chars_with_exactly_k_occurrences(\\"abcdef\\", 1) 6 >>> count_distinct_chars_with_exactly_k_occurrences(\\"aaaaa\\", 2) 0 >>> count_distinct_chars_with_exactly_k_occurrences(\\"\\", 1) 0 >>> count_distinct_chars_with_exactly_k_occurrences(\\"aaabbbbcc\\", 3) 1 >>> count_distinct_chars_with_exactly_k_occurrences(\\"aabbccddeeff\\", 2) 6 >>> count_distinct_chars_with_exactly_k_occurrences(\\"a\\"*1000, 1000) 1","solution":"def count_distinct_chars_with_exactly_k_occurrences(s, k): Returns the number of distinct characters in s that appear exactly k times. :param s: Input string consisting of lowercase English letters :param k: The exact number of times the distinct characters must appear :return: Number of distinct characters that appear exactly k times from collections import Counter # Count occurrences of each character in the string char_count = Counter(s) # Count distinct characters that appear exactly k times exact_k_count = sum(1 for key, val in char_count.items() if val == k) return exact_k_count"},{"question":"def partition_by_min(nums: List[int]) -> List[List[int]]: Given a list of integers nums, partitions it into sublists such that each sublist contains at least one occurrence of the minimum value in nums, and the length of each sublist is minimized. Returns a list of these sublists. If it's not possible to partition the list as required, returns an empty list. >>> partition_by_min([1, 2, 3, 1, 4, 1]) == [[1], [2, 3, 1], [4, 1]] >>> partition_by_min([5, 5, 5, 1, 5, 5, 1, 5, 1]) == [[5, 5, 5, 1], [5, 5, 1], [5, 1]] >>> partition_by_min([1, 2, 3, 4, 1]) == [[1], [2, 3, 4, 1]] >>> partition_by_min([1]) == [[1]] >>> partition_by_min([1, 1, 1]) == [[1], [1], [1]] >>> partition_by_min([]) == [] >>> partition_by_min([2, 3, 4]) == []","solution":"def partition_by_min(nums): Partitions the list nums into sublists such that each sublist contains at least one occurrence of the minimum value in nums, and the length of each sublist is minimized. Returns a list of these sublists. If it's not possible to partition the list as required, returns an empty list. if not nums: return [] min_val = min(nums) partitions = [] current_partition = [] for num in nums: current_partition.append(num) if num == min_val: partitions.append(current_partition) current_partition = [] # If there are leftovers in current_partition which doesn't have the minimum value if current_partition: return [] # This means the last sublist does not have the minimum value, hence invalid partition. return partitions"},{"question":"def sortStringByCase(s: str) -> str: Returns a new string with all the uppercase letters coming before all the lowercase letters, preserving the original relative order of the letters within each group. >>> sortStringByCase(\\"ABC\\") \\"ABC\\" >>> sortStringByCase(\\"abc\\") \\"abc\\" >>> sortStringByCase(\\"aCAdBb\\") \\"CABadb\\" >>> sortStringByCase(\\"\\") \\"\\" >>> sortStringByCase(\\"a\\") \\"a\\" >>> sortStringByCase(\\"A\\") \\"A\\" >>> sortStringByCase(\\"BcDeFgHi\\") \\"BDFHcegi\\"","solution":"def sortStringByCase(s): Returns a new string with all the uppercase letters coming before all the lowercase letters, preserving the original relative order of the letters within each group. uppercase = [char for char in s if char.isupper()] lowercase = [char for char in s if char.islower()] return ''.join(uppercase + lowercase)"},{"question":"def increasing_triplet(arr: List[int]) -> bool: Returns true if there exist three indices i, j, and k such that 0 <= i < j < k < len(arr) and arr[i] < arr[j] < arr[k]. >>> increasing_triplet([1, 2, 3, 4, 5]) == True >>> increasing_triplet([5, 4, 3, 2, 1]) == False >>> increasing_triplet([1, 2]) == False >>> increasing_triplet([1]) == False >>> increasing_triplet([]) == False >>> increasing_triplet([5, 1, 5, 2, 6]) == True >>> increasing_triplet([1, 1, 1, 2, 2, 3]) == True >>> increasing_triplet([2, 1, 5, 0, 4, 6]) == True","solution":"def increasing_triplet(arr): Returns true if there exist three indices i, j, and k such that 0 <= i < j < k < len(arr) and arr[i] < arr[j] < arr[k]. if len(arr) < 3: return False first = second = float('inf') for num in arr: if num <= first: first = num elif num <= second: second = num else: return True return False"},{"question":"def min_path_cost(grid: List[List[int]]) -> int: Return the minimum cost of reaching the bottom-right cell from the top-left cell in a grid. >>> min_path_cost([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_cost([ ... [1, 2], ... [1, 1] ... ]) 3 >>> min_path_cost([[7]]) 7 >>> min_path_cost([]) 0 >>> min_path_cost([ ... [3], ... [2], ... [4], ... [1] ... ]) 10 >>> min_path_cost([ ... [5, 1, 2, 3] ... ]) 11","solution":"def min_path_cost(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize a DP array with the same dimensions as the grid dp = [[0] * n for _ in range(m)] # Start from the top-left corner dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right corner has the result, i.e., the minimum cost return dp[m - 1][n - 1]"},{"question":"def longest_consecutive(nums): Returns the length of the longest sequence of consecutive numbers in the array 'nums'. Parameters: nums (list): A list of distinct integers. Returns: int: The length of the longest consecutive elements sequence. >>> longest_consecutive([]) == 0 >>> longest_consecutive([7]) == 1 >>> longest_consecutive([100, 200, 1, 2, 3, 4]) == 4 # Sequence: 1, 2, 3, 4 >>> longest_consecutive([10, 5, 12, 3, 55, 30, 2, 44, 11, 4]) == 4 # Sequence: 2, 3, 4, 5 >>> longest_consecutive([2, 6, 1, 9, 4, 5, 3]) == 6 # Sequence: 1, 2, 3, 4, 5, 6 >>> longest_consecutive([-1, 0, 1, 2, -2, -3]) == 6 # Sequence: -3, -2, -1, 0, 1, 2","solution":"def longest_consecutive(nums): Returns the length of the longest sequence of consecutive numbers in the array 'nums'. Parameters: nums (list): A list of distinct integers. Returns: int: The length of the longest consecutive elements sequence. if not nums: return 0 nums_set = set(nums) max_length = 0 for num in nums: if num - 1 not in nums_set: current_num = num current_length = 1 while current_num + 1 in nums_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List, Tuple def find_peaks(grid: List[List[int]]) -> List[Tuple[int, int]]: Returns a list of pairs (i, j) representing the coordinates of peaks in the grid. A peak is an element that is strictly greater than its vertical and horizontal neighbors. >>> find_peaks([[1, 2, 1], [2, 1, 3], [1, 3, 1]]) [(0, 1), (1, 0), (1, 2), (2, 1)] >>> find_peaks([]) [] >>> find_peaks([[1]]) [(0, 0)] >>> find_peaks([[2, 2, 2], [2, 2, 2], [2, 2, 2]]) [] >>> find_peaks([[1, 4, 3, 1], [6, 1, 2, 5], [4, 0, 3, 4], [5, 4, 1, 2]]) [(0, 1), (1, 0), (1, 3), (3, 0)] >>> find_peaks([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) []","solution":"def find_peaks(grid): Returns a list of pairs (i, j) representing the coordinates of peaks in the grid. A peak is an element that is strictly greater than its vertical and horizontal neighbors. :param grid: List[List[int]] :return: List[Tuple[int, int]] rows = len(grid) cols = len(grid[0]) if rows > 0 else 0 peaks = [] def is_peak(i, j): for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]: ni, nj = i + di, j + dj if 0 <= ni < rows and 0 <= nj < cols and grid[i][j] <= grid[ni][nj]: return False return True for i in range(rows): for j in range(cols): if is_peak(i, j): peaks.append((i, j)) return peaks"},{"question":"from typing import List def reverse_pairs(nums: List[int]) -> int: Given an integer array nums, return the number of reverse pairs in the array. A reverse pair is a pair (i, j) where 0 <= i < j < nums.length and nums[i] > 2 * nums[j]. >>> reverse_pairs([1, 3, 2, 3, 1]) 2 >>> reverse_pairs([1, 2, 3, 4, 5]) 0 >>> reverse_pairs([5, 4, 3, 2, 1]) 4 >>> reverse_pairs([2, 4, 3, 5, 1]) 3 >>> reverse_pairs([]) 0 >>> reverse_pairs([1]) 0","solution":"def merge_count_rev_pairs(nums, left, mid, right): # Count the reverse pairs count = 0 j = mid + 1 for i in range(left, mid + 1): while j <= right and nums[i] > 2 * nums[j]: j += 1 count += (j - (mid + 1)) # Merge the two sorted halves temp = [] i, j = left, mid + 1 while i <= mid and j <= right: if nums[i] <= nums[j]: temp.append(nums[i]) i += 1 else: temp.append(nums[j]) j += 1 while i <= mid: temp.append(nums[i]) i += 1 while j <= right: temp.append(nums[j]) j += 1 for i in range(left, right + 1): nums[i] = temp[i - left] return count def count_reverse_pairs(nums, left, right): if left >= right: return 0 mid = (left + right) // 2 count = count_reverse_pairs(nums, left, mid) count += count_reverse_pairs(nums, mid + 1, right) count += merge_count_rev_pairs(nums, left, mid, right) return count def reverse_pairs(nums): if not nums: return 0 return count_reverse_pairs(nums, 0, len(nums) - 1)"},{"question":"def count_subarrays_with_k_distinct(arr, m, k): Given an integer array \`arr\` and an integer \`m\`, find all contiguous subarrays of length \`m\` that have at most \`k\` distinct integers. Return the number of such subarrays. >>> count_subarrays_with_k_distinct([1, 2, 3, 4], 2, 1) == 0 >>> count_subarrays_with_k_distinct([1, 1, 1, 1], 2, 1) == 3 >>> count_subarrays_with_k_distinct([1, 2, 1, 2, 3], 3, 2) == 2 >>> count_subarrays_with_k_distinct([1, 2, 3, 4, 5], 3, 3) == 3 >>> count_subarrays_with_k_distinct([1, 2, 2, 3], 4, 3) == 1 >>> count_subarrays_with_k_distinct([1], 1, 1) == 1 >>> count_subarrays_with_k_distinct([1], 1, 0) == 0 >>> count_subarrays_with_k_distinct([1, 2, 3, 4], 1, 1) == 4","solution":"def count_subarrays_with_k_distinct(arr, m, k): This function returns the number of contiguous subarrays of length m that have at most k distinct integers. def sliding_window(arr, m, k): count = 0 window = {} distinct_count = 0 for i in range(len(arr)): # Add current element to the window if arr[i] in window: window[arr[i]] += 1 else: window[arr[i]] = 1 distinct_count += 1 # Remove the element that slides out of the window if i >= m: if window[arr[i - m]] == 1: del window[arr[i - m]] distinct_count -= 1 else: window[arr[i - m]] -= 1 # Increment count if the current window has at most k distinct integers if i >= m - 1 and distinct_count <= k: count += 1 return count return sliding_window(arr, m, k)"},{"question":"def largest_island_area(grid: List[List[int]]) -> int: Given a 2D grid of binary values representing a map of an island, this function returns the area of the largest connected component of land (1s). pass from largest_island_area import largest_island_area def test_simple_case(): assert largest_island_area([[0, 1], [1, 0]]) == 1 def test_one_island(): assert largest_island_area([[1, 1], [1, 0]]) == 3 def test_grid_filled_with_land(): assert largest_island_area([[1, 1], [1, 1]]) == 4 def test_diagonal_islands(): assert largest_island_area([[1, 0], [0, 1]]) == 1 def test_no_land(): assert largest_island_area([[0, 0], [0, 0]]) == 0 def test_complex_island(): grid = [ [0, 0, 1, 0, 0], [0, 1, 1, 1, 0], [0, 0, 1, 0, 0], [1, 1, 0, 0, 0], [1, 1, 0, 0, 0] ] assert largest_island_area(grid) == 5","solution":"def largest_island_area(grid): Given a 2D grid of binary values representing a map of an island, this function returns the area of the largest connected component of land (1s). def dfs(x, y): # Edge cases and base case for DFS if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 # Mark the current land as visited grid[x][y] = 0 area = 1 # Explore adjacent cells in 4 directions area += dfs(x+1, y) area += dfs(x-1, y) area += dfs(x, y+1) area += dfs(x, y-1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: # Calculate area of the connected component using DFS max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Returns all root-to-leaf paths in a binary tree. :param TreeNode root: The root of the binary tree. :return: A list of lists, where each inner list represents a root-to-leaf path. from solution import TreeNode, binary_tree_paths def test_single_node_tree(): root = TreeNode(1) assert binary_tree_paths(root) == [[1]] def test_two_level_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert sorted(binary_tree_paths(root)) == sorted([[1, 2], [1, 3]]) def test_three_level_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(6) assert sorted(binary_tree_paths(root)) == sorted([[1, 2, 4], [1, 2, 5], [1, 3, 6]]) def test_unbalanced_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) root.left.left.right = TreeNode(5) assert sorted(binary_tree_paths(root)) == sorted([[1, 2, 3, 4], [1, 2, 3, 5]]) def test_empty_tree(): root = None assert binary_tree_paths(root) == [] def test_tree_with_single_child(): root = TreeNode(1) root.left = TreeNode(2) root.left.right = TreeNode(3) assert sorted(binary_tree_paths(root)) == sorted([[1, 2, 3]])","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Returns all root-to-leaf paths in a binary tree. :param TreeNode root: The root of the binary tree. :return: A list of lists, where each inner list represents a root-to-leaf path. if not root: return [] def dfs(node, path, paths): if not node: return path.append(node.val) if not node.left and not node.right: paths.append(list(path)) # Leaf node else: dfs(node.left, path, paths) dfs(node.right, path, paths) path.pop() # backtrack paths = [] dfs(root, [], paths) return paths"},{"question":"class NumberOfDistinctIslands: def numDistinctIslands(self, grid: List[List[int]]) -> int: Returns the number of distinct islands in the grid. >>> solution = NumberOfDistinctIslands() >>> solution.numDistinctIslands([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> solution.numDistinctIslands([[0, 1, 0], [0, 1, 0], [0, 0, 0]]) == 1 >>> solution.numDistinctIslands([[1, 1, 0, 0], [1, 0, 0, 1], [0, 0, 1, 1]]) == 2 >>> solution.numDistinctIslands([[1, 1, 0, 1, 1], [1, 0, 0, 1, 0], [0, 0, 1, 1, 0], [1, 0, 1, 0, 1]]) == 3 pass","solution":"class NumberOfDistinctIslands: def numDistinctIslands(self, grid): def dfs(x, y, direction): if (x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0): return grid[x][y] = 0 path_signature.append(direction) dfs(x + 1, y, \\"d\\") dfs(x - 1, y, \\"u\\") dfs(x, y + 1, \\"r\\") dfs(x, y - 1, \\"l\\") path_signature.append(\\"b\\") distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: path_signature = [] dfs(i, j, \\"o\\") distinct_islands.add(tuple(path_signature)) return len(distinct_islands)"},{"question":"def intersection(nums1, nums2): Returns the intersection of two sorted arrays nums1 and nums2 as a sorted array. Only unique elements that are present in both arrays are included in the result. # code here # Unit tests def test_intersection_distinct_elements(): assert intersection([1, 2, 3], [4, 5, 6]) == [] def test_intersection_some_common_elements(): assert intersection([1, 2, 3], [2, 3, 4]) == [2, 3] def test_intersection_all_common_elements(): assert intersection([1, 2, 3], [1, 2, 3]) == [1, 2, 3] def test_intersection_with_duplicates(): assert intersection([1, 2, 2, 3], [2, 2, 3, 3, 4]) == [2, 3] def test_intersection_single_element_intersection(): assert intersection([1, 2, 3], [3, 4, 5]) == [3] def test_intersection_empty_arrays(): assert intersection([], []) == [] def test_intersection_one_empty_array(): assert intersection([], [1, 2, 3]) == [] assert intersection([1, 2, 3], []) == [] def test_intersection_large_case(): assert intersection([1, 2, 5, 9, 14, 19], [14, 19, 20, 30, 50, 100]) == [14, 19]","solution":"def intersection(nums1, nums2): Returns the intersection of two sorted arrays nums1 and nums2 as a sorted array. Only unique elements that are present in both arrays are included in the result. set1 = set(nums1) set2 = set(nums2) intersect = set1 & set2 # Finding the intersection return sorted(list(intersect)) # Returning sorted list of the intersection"},{"question":"def is_magic_square(matrix): Determines if a given n x n matrix is a magic square. >>> is_magic_square([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) == True >>> is_magic_square([[2, 7, 6], [9, 5, 1], [4, 3, 9]]) == False >>> is_magic_square([[4]]) == True >>> is_magic_square([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == True >>> is_magic_square([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == False","solution":"def is_magic_square(matrix): Determines if a given n x n matrix is a magic square. n = len(matrix) if not matrix or n != len(matrix[0]): return False # Calculate the sum of the main diagonal main_diag_sum = sum(matrix[i][i] for i in range(n)) # Calculate the sum of the anti-diagonal anti_diag_sum = sum(matrix[i][n - i - 1] for i in range(n)) # If both diagonals do not have the same sum, it's not a magic square if main_diag_sum != anti_diag_sum: return False # Check each row and each column's sum for i in range(n): if sum(matrix[i]) != main_diag_sum or sum(matrix[j][i] for j in range(n)) != main_diag_sum: return False # If all checks are satisfied, return True return True"},{"question":"def max_contiguous_subarray_sum(hours: List[int]) -> int: Find the maximum sum of a contiguous subarray of hours array. >>> max_contiguous_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_contiguous_subarray_sum([-1, -2, -3, -4, -5]) == -1 >>> max_contiguous_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_contiguous_subarray_sum([5]) == 5 >>> max_contiguous_subarray_sum([-5]) == -5 >>> max_contiguous_subarray_sum([0, -3, 1, -2, 3, 0, -1]) == 3 >>> max_contiguous_subarray_sum([]) == 0","solution":"def max_contiguous_subarray_sum(hours): Finds the maximum sum of a contiguous subarray in hours array. if not hours: return 0 max_sum = float('-inf') current_sum = 0 for hour in hours: current_sum += hour if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum"},{"question":"def valid_ip_addresses(s: str) -> int: Given a string of digits, return the number of possible valid IP address combinations that can be formed by inserting exactly three dots into the string. An IP address consists of four sections of numbers separated by dots, and each section must be between 0 and 255 inclusively. Leading zeros are not allowed in any section except for 0 itself. Example: >>> valid_ip_addresses(\\"25525511135\\") 2 >>> valid_ip_addresses(\\"0000\\") 1 >>> valid_ip_addresses(\\"1111\\") 1 >>> valid_ip_addresses(\\"010010\\") 2 >>> valid_ip_addresses(\\"101023\\") 5 >>> valid_ip_addresses(\\"2550502511\\") 0 >>> valid_ip_addresses(\\"\\") 0 >>> valid_ip_addresses(\\"123\\") 0 >>> valid_ip_addresses(\\"1234567890123\\") 0 >>> valid_ip_addresses(\\"256256256256\\") 0","solution":"def is_valid_section(section): Checks if a given section of an IP address is valid. A valid section must be an integer between 0 and 255 and cannot have leading zeros (except for the number 0 itself). if len(section) > 1 and section[0] == '0': return False return 0 <= int(section) <= 255 def valid_ip_addresses(s): Returns the number of possible valid IP address combinations that can be formed by inserting exactly three dots into the string. n = len(s) if n < 4 or n > 12: return 0 valid_count = 0 for i in range(1, min(n, 4)): for j in range(i+1, min(n, i+4)): for k in range(j+1, min(n, j+4)): section1, section2, section3, section4 = s[:i], s[i:j], s[j:k], s[k:] if is_valid_section(section1) and is_valid_section(section2) and is_valid_section(section3) and is_valid_section(section4): valid_count += 1 return valid_count"},{"question":"def length_of_longest_substring_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring that contains no duplicate characters and at most k distinct characters. >>> length_of_longest_substring_k_distinct(\\"abc\\", 2) 2 >>> length_of_longest_substring_k_distinct(\\"abcdef\\", 6) 6 >>> length_of_longest_substring_k_distinct(\\"abcdef\\", 1) 1 >>> length_of_longest_substring_k_distinct(\\"aaabbcc\\", 1) 3 >>> length_of_longest_substring_k_distinct(\\"aaabbcc\\", 2) 5 >>> length_of_longest_substring_k_distinct(\\"abc\\", 0) 0 >>> length_of_longest_substring_k_distinct(\\"\\", 0) 0 >>> length_of_longest_substring_k_distinct(\\"abc\\", 5) 3 >>> length_of_longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> length_of_longest_substring_k_distinct(\\"aaabbbccc\\", 2) 6 >>> length_of_longest_substring_k_distinct(\\"aabbccdd\\", 3) 6 >>> length_of_longest_substring_k_distinct(\\"\\", 1) 0 >>> length_of_longest_substring_k_distinct(\\"\\", 100) 0","solution":"def length_of_longest_substring_k_distinct(s, k): Returns the length of the longest substring that contains no duplicate characters and at most k distinct characters. if k == 0: return 0 n = len(s) if n == 0: return 0 left = 0 right = 0 max_length = 0 char_count = {} while right < n: char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nodes_above_threshold(head: ListNode, T: int) -> ListNode: Removes all nodes from the linked list whose values are greater than T. Args: head (ListNode): The head of the linked list. T (int): The threshold value. Returns: ListNode: The head of the modified linked list. pass","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nodes_above_threshold(head, T): Removes all nodes from the linked list whose values are greater than T. Args: head (ListNode): The head of the linked list. T (int): The threshold value. Returns: ListNode: The head of the modified linked list. dummy = ListNode(0) dummy.next = head current = dummy while current.next: if current.next.val > T: current.next = current.next.next else: current = current.next return dummy.next"},{"question":"def longest_well_performing_sequence(nums): Returns the length of the longest well-performing sequence within nums. A well-performing sequence is defined as a subarray with a sum strictly greater than zero. >>> longest_well_performing_sequence([1, 2, 3, 4]) == 4 >>> longest_well_performing_sequence([1, -2, 3, 4, -1, 2]) == 6 >>> longest_well_performing_sequence([-1, -2, -3, -4]) == 0 >>> longest_well_performing_sequence([10]) == 1 >>> longest_well_performing_sequence([-10]) == 0 >>> longest_well_performing_sequence([]) == 0","solution":"def longest_well_performing_sequence(nums): Returns the length of the longest well-performing sequence within nums. A well-performing sequence is defined as a subarray with a sum strictly greater than zero. if not nums: return 0 max_length = 0 prefix_sum = 0 sum_indices = {} for i, num in enumerate(nums): prefix_sum += num if prefix_sum > 0: max_length = i + 1 else: if prefix_sum - 1 in sum_indices: max_length = max(max_length, i - sum_indices[prefix_sum - 1]) if prefix_sum not in sum_indices: sum_indices[prefix_sum] = i return max_length"},{"question":"from typing import List def max_possible_sum_of_minimums(arr: List[int], k: int) -> int: You are given a list of integers \`arr\` and an integer \`k\`. You can choose any subarray of \`arr\` with length exactly \`k\` and rearrange its elements in any order. Return the maximum possible sum of the minimum values of all subarrays of length \`k\` after you have rearranged the subarrays. >>> max_possible_sum_of_minimums([1, 3, 2, 4], 2) 7 >>> max_possible_sum_of_minimums([5, 1, 3, 2, 4], 3) 12 >>> max_possible_sum_of_minimums([1, 2, 3], 2) 5 >>> max_possible_sum_of_minimums([1, 1, 1, 1], 2) 2 >>> max_possible_sum_of_minimums([6, 6, 6, 6], 4) 24 # Write your code here.","solution":"def max_possible_sum_of_minimums(arr, k): Returns the maximum possible sum of the minimum values of all subarrays of length k after rearrangement. Parameters: arr (list of int): The list of integers. k (int): The length of each subarray to consider. Returns: int: The maximum sum of the minimum values of all subarrays of length k. # Sort the array in descending order to maximize the sum of the minimum values in subarrays of length k sorted_arr = sorted(arr, reverse=True) # Calculate the sum of the minimum values of each subarray of length k max_sum = sum(sorted_arr[i] for i in range(k)) return max_sum"},{"question":"from typing import List def max_length_subarray(arr: List[int]) -> int: Given an array of integers \`arr\`, returns the maximum length of a subarray where the absolute difference between any two elements in this subarray is less than or equal to \`1\`. Example usages: >>> max_length_subarray([]) == 0 >>> max_length_subarray([1]) == 1 >>> max_length_subarray([2, 2, 2, 2]) == 4 >>> max_length_subarray([1, 2, 2, 3, 1, 2]) == 5 >>> max_length_subarray([1, 3, 3, 2, 2, 1]) == 4 >>> max_length_subarray([1, 4, 7, 10]) == 1 >>> max_length_subarray([1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) == 10","solution":"def max_length_subarray(arr): Returns the maximum length of a subarray where the absolute difference between any two elements in this subarray is less than or equal to 1. if not arr: return 0 from collections import defaultdict count_map = defaultdict(int) max_length = 0 for num in arr: count_map[num] += 1 max_length = max(max_length, count_map[num] + count_map[num + 1], count_map[num] + count_map[num - 1]) return max_length"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Find the length of the longest substring that contains at most two distinct characters. :param s: Input string :return: Length of the longest substring with at most two distinct characters >>> length_of_longest_substring_two_distinct(\\"\\") == 0 >>> length_of_longest_substring_two_distinct(\\"a\\") == 1 >>> length_of_longest_substring_two_distinct(\\"aa\\") == 2 >>> length_of_longest_substring_two_distinct(\\"aba\\") == 3 >>> length_of_longest_substring_two_distinct(\\"abaccc\\") == 4 >>> length_of_longest_substring_two_distinct(\\"eceba\\") == 3 >>> length_of_longest_substring_two_distinct(\\"abcabcabc\\") == 2 >>> length_of_longest_substring_two_distinct(\\"aabbcc\\") == 4 >>> length_of_longest_substring_two_distinct(\\"aabbcddefgghhiijjkkllmm\\") == 4","solution":"def length_of_longest_substring_two_distinct(s): Find the length of the longest substring that contains at most two distinct characters. :param s: Input string :return: Length of the longest substring with at most two distinct characters from collections import defaultdict if len(s) == 0: return 0 left = 0 right = 0 max_length = 0 char_map = defaultdict(int) while right < len(s): char_map[s[right]] += 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def checkValidString(s: str) -> bool: Given a string s containing only three types of characters: '(', ')', and '*', determine if the string s is valid. The string is considered valid if it is possible to insert characters '(' and ')' in place of '*' such that the resulting string is a valid parentheses string. A valid parentheses string is defined as follows: 1. Any left parenthesis '(' must have a corresponding right parenthesis ')'. 2. Any right parenthesis ')' must have a corresponding left parenthesis '('. 3. Left parentheses '(' must go before the corresponding right parenthesis ')'. >>> checkValidString(\\"()*\\") == True >>> checkValidString(\\"(*)\\") == True >>> checkValidString(\\"(()\\") == False >>> checkValidString(\\"())\\") == False >>> checkValidString(\\"****\\") == True >>> checkValidString(\\"(*))\\") == True >>> checkValidString(\\"(*()\\") == True >>> checkValidString(\\"())*\\") == False >>> checkValidString(\\"\\") == True >>> checkValidString(\\"()()\\") == True >>> checkValidString(\\"(())\\") == True >>> checkValidString(\\"*(\\") == False >>> checkValidString(\\")*\\") == False","solution":"def checkValidString(s: str) -> bool: This function checks if a string with parentheses and wildcards is valid. :param s: A string containing '(', ')' and '*' :return: A boolean indicating if the string is a valid parentheses string low = 0 # The minimum number of open parentheses needed high = 0 # The maximum number of open parentheses possible for char in s: if char == '(': low += 1 high += 1 elif char == ')': low -= 1 high -= 1 elif char == '*': low -= 1 high += 1 if high < 0: return False if low < 0: low = 0 return low == 0"},{"question":"def max_ice_cream(prices: List[int], coins: int) -> int: Determines the maximum number of ice cream bars that can be bought with the available coins. :param prices: List of non-negative integers representing the price of each ice cream bar. :param coins: Integer representing the amount of money available to spend. :return: Integer representing the maximum number of ice cream bars that can be bought. >>> max_ice_cream([1, 3, 2, 4, 1], 7) == 4 >>> max_ice_cream([10, 6, 8, 7, 7, 8], 5) == 0 >>> max_ice_cream([1, 6, 3, 1, 2, 5], 20) == 6 >>> max_ice_cream([], 5) == 0 >>> max_ice_cream([1, 1, 1, 1, 1], 3) == 3 >>> max_ice_cream([2, 2, 2, 2, 2], 10) == 5","solution":"def max_ice_cream(prices, coins): Determines the maximum number of ice cream bars that can be bought with the available coins. :param prices: List of non-negative integers representing the price of each ice cream bar. :param coins: Integer representing the amount of money available to spend. :return: Integer representing the maximum number of ice cream bars that can be bought. prices.sort() count = 0 for price in prices: if price <= coins: coins -= price count += 1 else: break return count"},{"question":"def evaluate(s: str) -> int: Evaluates the given arithmetic expression string and returns the result as an integer. >>> evaluate(\\"3+2*2\\") 7 >>> evaluate(\\"3/2\\") 1 >>> evaluate(\\"3+5/2\\") 5 >>> evaluate(\\"(1+(4+5+2)-3)+(6+8)\\") 23 >>> evaluate(\\"2*(5+5*2)/3+(6/2+8)\\") 21 >>> evaluate(\\"2*(5+5*2)/((3)+(6/2)+8)\\") 2 >>> evaluate(\\"3-2*2\\") -1 >>> evaluate(\\"3+2*2-4/2\\") 5 >>> evaluate(\\"3+5*2-8/2\\") 9 >>> evaluate(\\"42\\") 42 >>> evaluate(\\"0\\") 0","solution":"def evaluate(s): Evaluates the given arithmetic expression string and returns the result as an integer. def operate(a, b, op): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': return int(a / b) # Ensure the result is an integer def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_operators(operators, values): right = values.pop() left = values.pop() op = operators.pop() values.append(operate(left, right, op)) operators = [] values = [] i = 0 while i < len(s): if s[i] == '(': operators.append(s[i]) elif s[i].isdigit(): val = 0 while i < len(s) and s[i].isdigit(): val = (val * 10) + int(s[i]) i += 1 values.append(val) i -= 1 # Adjust for the increment in the for loop elif s[i] == ')': while operators and operators[-1] != '(': apply_operators(operators, values) operators.pop() # Pop the opening parenthesis else: while operators and precedence(operators[-1]) >= precedence(s[i]): apply_operators(operators, values) operators.append(s[i]) i += 1 while operators: apply_operators(operators, values) return values[0]"},{"question":"def max_sum_under_limit(cards: List[int], limit: int) -> int: Given an array of integers \`cards\` where \`cards[i]\` represents the value of the i-th card, determine the maximum sum you can achieve that is less than or equal to the \`limit\`. You are allowed to pick cards in a sequence but must immediately stop if the sum of the picked cards exceeds the given integer \`limit\`. Return this maximum sum. >>> max_sum_under_limit([1, 2, 3, 4, 5], 15) 15 >>> max_sum_under_limit([1, 2, 3, 4, 5], 10) 10 >>> max_sum_under_limit([5, 6, 7, 8, 9], 17) 17 >>> max_sum_under_limit([2, 3, 7, 5], 10) 10 >>> max_sum_under_limit([1, 2, 3, 4, 5], 7) 7 >>> max_sum_under_limit([4, 5, 6], 3) 0 >>> max_sum_under_limit([10, 11, 12], 9) 0 >>> max_sum_under_limit([10, 20, 30], 5) 0 >>> max_sum_under_limit([100], 50) 0 >>> cards = [1]*1000 # An array of 1000 elements each equal to 1 >>> limit = 500 >>> max_sum_under_limit(cards, limit) 500","solution":"def max_sum_under_limit(cards, limit): Returns the maximum sum of a subsequence of \`cards\` that does not exceed the given \`limit\`. n = len(cards) max_sum = 0 for i in range(n): current_sum = 0 for j in range(i, n): if current_sum + cards[j] > limit: break current_sum += cards[j] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def can_form_by_deleting_and_rearranging(s: str, t: str) -> bool: Returns True if t can be formed by deleting exactly one character from s and rearranging the remaining characters. >>> can_form_by_deleting_and_rearranging(\\"abc\\", \\"ac\\") True >>> can_form_by_deleting_and_rearranging(\\"abcd\\", \\"acd\\") True >>> can_form_by_deleting_and_rearranging(\\"abcde\\", \\"abce\\") True >>> can_form_by_deleting_and_rearranging(\\"aabbcc\\", \\"abbcc\\") True >>> can_form_by_deleting_and_rearranging(\\"abc\\", \\"abc\\") False >>> can_form_by_deleting_and_rearranging(\\"abcde\\", \\"abcf\\") False >>> can_form_by_deleting_and_rearranging(\\"abc\\", \\"z\\") False >>> can_form_by_deleting_and_rearranging(\\"a\\", \\"\\") True >>> can_form_by_deleting_and_rearranging(\\"ab\\", \\"a\\") True >>> can_form_by_deleting_and_rearranging(\\"a\\", \\"a\\") False","solution":"def can_form_by_deleting_and_rearranging(s, t): Returns True if t can be formed by deleting exactly one character from s and rearranging the remaining characters. # Check the length conditions if len(s) != len(t) + 1: return False # Create frequency counts for both strings from collections import Counter s_count = Counter(s) t_count = Counter(t) # Check the character frequency difference differences = 0 for char in s_count: s_freq = s_count[char] t_freq = t_count[char] if char in t_count else 0 if s_freq != t_freq: differences += (s_freq - t_freq) if differences > 1: return False return differences == 1"},{"question":"from typing import List def longest_subsequence_with_replacement(products: List[int], k: int) -> int: Find the length of the longest subsequence of unique product types that can be achieved by performing at most one operation of replacing up to 'k' consecutive products. >>> longest_subsequence_with_replacement([1, 2, 3, 4], 0) 4 >>> longest_subsequence_with_replacement([1, 1, 1, 2, 3], 3) 3 >>> longest_subsequence_with_replacement([1, 2, 2, 3, 3, 3], 6) 3 >>> longest_subsequence_with_replacement([1, 2, 3], 5) 3 >>> longest_subsequence_with_replacement([1, 1, 1, 1, 1], 2) 1 >>> longest_subsequence_with_replacement([], 2) 0","solution":"def longest_subsequence_with_replacement(products, k): Find the length of the longest subsequence of unique product types that can be achieved by performing at most one operation of replacing up to 'k' consecutive products. n = len(products) if n == 0: return 0 # Initial count of unique products unique_products = set(products) initial_unique_count = len(unique_products) if k >= n: return initial_unique_count max_length = initial_unique_count # Consider segments of length at most k to replace for i in range(n): replacement_set = set() for j in range(i, min(i + k, n)): replacement_set.add(products[j]) after_replacement_unique_count = len(replacement_set) max_length = max(max_length, after_replacement_unique_count) return max_length"},{"question":"class CPU: Simulate a CPU scheduling algorithm using First-Come-First-Serve (FCFS) scheduling. The methods to be implemented are: * CPU(): Initializes the CPU with an empty process queue. * void addProcess(int pid, int arrival_time, int burst_time): Adds a new process to the CPU queue. * List<Integer> executeProcesses(): Executes the processes in the order of their arrival time. >>> cpu = CPU() >>> cpu.addProcess(1, 0, 5) >>> cpu.addProcess(2, 1, 3) >>> cpu.addProcess(3, 2, 2) >>> cpu.executeProcesses() [1, 2, 3] >>> cpu = CPU() >>> cpu.addProcess(1, 0, 5) >>> cpu.addProcess(2, 0, 3) >>> cpu.addProcess(3, 0, 2) >>> cpu.executeProcesses() [3, 2, 1] >>> cpu = CPU() >>> cpu.addProcess(1, 0, 3) >>> cpu.addProcess(2, 0, 3) >>> cpu.addProcess(3, 0, 3) >>> cpu.executeProcesses() [1, 2, 3] >>> cpu = CPU() >>> cpu.addProcess(1, 0, 4) >>> cpu.addProcess(2, 2, 1) >>> cpu.addProcess(3, 2, 6) >>> cpu.addProcess(4, 5, 3) >>> cpu.executeProcesses() [1, 2, 3, 4] >>> cpu = CPU() >>> cpu.addProcess(1, 0, 3) >>> cpu.addProcess(2, 5, 2) >>> cpu.addProcess(3, 10, 1) >>> cpu.executeProcesses() [1, 2, 3]","solution":"class CPU: def __init__(self): self.processes = [] def addProcess(self, pid, arrival_time, burst_time): self.processes.append((pid, arrival_time, burst_time)) def executeProcesses(self): # Sort by arrival_time, then by burst_time, and finally by pid self.processes.sort(key=lambda x: (x[1], x[2], x[0])) execution_order = [process[0] for process in self.processes] return execution_order"},{"question":"def max_items_within_budget(costs: List[int], budget: int) -> int: Returns the maximum number of items that can be bought without exceeding the given budget. :param costs: List of integers representing the costs of the items. :param budget: Integer representing the maximum budget. :return: Integer representing the maximum number of items that can be bought within the budget. >>> max_items_within_budget([1, 2, 3, 4], 10) 4 >>> max_items_within_budget([1, 2, 3, 4], 5) 2 >>> max_items_within_budget([1, 2, 3], 10) 3 >>> max_items_within_budget([1, 2, 3, 4], 0) 0 >>> max_items_within_budget([5], 5) 1 >>> max_items_within_budget([10, 20, 30], 5) 0 >>> max_items_within_budget([3, 3, 3, 3], 10) 3 >>> max_items_within_budget([1000, 2000, 3000], 5000) 2 >>> max_items_within_budget([], 10) 0","solution":"def max_items_within_budget(costs, budget): Returns the maximum number of items that can be bought without exceeding the given budget. :param costs: List of integers representing the costs of the items. :param budget: Integer representing the maximum budget. :return: Integer representing the maximum number of items that can be bought within the budget. costs.sort() count = 0 total_cost = 0 for cost in costs: if total_cost + cost <= budget: total_cost += cost count += 1 else: break return count"},{"question":"def longest_even_diff_subsequence(arr): Returns the length of the longest subsequence such that the difference between each pair of consecutive elements in the subsequence is an even number. Parameters: arr (list of int): The input array of integers. Returns: int: The length of the longest such subsequence. Examples: >>> longest_even_diff_subsequence([]) == 0 >>> longest_even_diff_subsequence([1]) == 1 >>> longest_even_diff_subsequence([2]) == 1 >>> longest_even_diff_subsequence([2, 4, 6, 8]) == 4 >>> longest_even_diff_subsequence([1, 3, 5, 7]) == 4 >>> longest_even_diff_subsequence([1, 2, 3, 4, 5, 6]) == 3 >>> longest_even_diff_subsequence([1, 2, 1, 2, 1, 2]) == 3","solution":"def longest_even_diff_subsequence(arr): Returns the length of the longest subsequence such that the difference between each pair of consecutive elements in the subsequence is an even number. Parameters: arr (list of int): The input array of integers. Returns: int: The length of the longest such subsequence. if not arr: return 0 # Separate all elements by even and odd even_elements = [num for num in arr if num % 2 == 0] odd_elements = [num for num in arr if num % 2 != 0] longest_subseq = max(len(even_elements), len(odd_elements)) return longest_subseq"},{"question":"def divide(dividend: int, divisor: int) -> int: Given two integers \`dividend\` and \`divisor\`, divide two integers without using multiplication, division, and mod operator. Return the quotient after dividing \`dividend\` by \`divisor\`. The integer division should truncate toward zero, which means losing its fractional part. >>> divide(10, 3) 3 >>> divide(20, 4) 5 >>> divide(-10, -3) 3 >>> divide(-20, -4) 5 >>> divide(10, -3) -3 >>> divide(-10, 3) -3 >>> divide(10, 1) 10 >>> divide(-10, 1) -10 >>> divide(10, -1) -10 >>> divide(-10, -1) 10 >>> divide(2**30, 1) 2**30 >>> divide(2**30, 2) 2**29 >>> divide(-2**31, 1) -2**31 >>> divide(-2**31, -1) 2**31 - 1 >>> divide(1, 2) 0 >>> divide(1, -2) 0 >>> divide(0, 1) 0 >>> divide(0, -1) 0","solution":"def divide(dividend, divisor): Divide two integers without using multiplication, division, and mod operator. Return the quotient after dividing dividend by divisor. # Handle edge cases for overflow MAX_INT = 2**31 - 1 MIN_INT = -2**31 # Special case for overflow if dividend == MIN_INT and divisor == -1: return MAX_INT negative = (dividend < 0) != (divisor < 0) # Convert both numbers to positive dividend, divisor = abs(dividend), abs(divisor) quotient = 0 while dividend >= divisor: temp, multiple = divisor, 1 while dividend >= (temp << 1): temp <<= 1 multiple <<= 1 dividend -= temp quotient += multiple return -quotient if negative else quotient"},{"question":"def max_contiguous_baskets(nums, threshold): Returns the maximum number of contiguous baskets from which the orange picker can pick oranges without exceeding the threshold. >>> max_contiguous_baskets([1, 2, 3, 4, 5], 5) 2 >>> max_contiguous_baskets([4], 5) 1 >>> max_contiguous_baskets([6], 5) 0 >>> max_contiguous_baskets([1, 1, 1, 1, 1], 5) 5 >>> max_contiguous_baskets([2, 2, 2, 2, 2], 8) 4 >>> max_contiguous_baskets([2, 1, 3, 1, 1, 1], 6) 4 >>> max_contiguous_baskets([3, 1, 4, 1, 2], 7) 3 >>> max_contiguous_baskets([5, 6, 7, 8], 4) 0","solution":"def max_contiguous_baskets(nums, threshold): Returns the maximum number of contiguous baskets from which the orange picker can pick oranges without exceeding the threshold. max_length = 0 current_sum = 0 left = 0 for right in range(len(nums)): current_sum += nums[right] while current_sum > threshold: current_sum -= nums[left] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def min_cost_to_make_divisible(arr: List[int], k: int) -> int: Function to calculate the minimum total cost to make all elements divisible by k. >>> min_cost_to_make_divisible([10, 20, 30], 10) 0 >>> min_cost_to_make_divisible([8], 5) 2 >>> min_cost_to_make_divisible([10, 21, 30], 10) 9 >>> min_cost_to_make_divisible([3, 5, 7], 2) 3 >>> min_cost_to_make_divisible([4, 8, 12], 4) 0 >>> min_cost_to_make_divisible([], 5) 0","solution":"def min_cost_to_make_divisible(arr, k): Function to calculate the minimum total cost to make all elements divisible by k. Parameters: arr (list): list of integers. k (int): positive integer. Returns: int: minimum total cost or -1 if it's impossible. cost = 0 for num in arr: remainder = num % k if remainder != 0: cost += k - remainder return cost"},{"question":"def find_words_in_one_row(words: List[str]) -> List[str]: Returns a list of words that can be typed using letters of only one row on QWERTY keyboard. The rows of the QWERTY keyboard are as follows: - First row: \\"qwertyuiop\\" - Second row: \\"asdfghjkl\\" - Third row: \\"zxcvbnm\\" >>> find_words_in_one_row([\\"qwerty\\", \\"asdf\\", \\"zxcvbn\\"]) [\\"qwerty\\", \\"asdf\\", \\"zxcvbn\\"] >>> find_words_in_one_row([\\"hello\\", \\"world\\", \\"dad\\", \\"peace\\"]) [\\"dad\\"] >>> find_words_in_one_row([]) [] >>> find_words_in_one_row([\\"hello\\", \\"world\\"]) [] >>> find_words_in_one_row([\\"qaz\\", \\"wsx\\", \\"edc\\", \\"rfv\\", \\"tgb\\", \\"yhn\\", \\"ujm\\"]) []","solution":"def find_words_in_one_row(words): Returns a list of words that can be typed using letters of only one row on QWERTY keyboard. first_row = set(\\"qwertyuiop\\") second_row = set(\\"asdfghjkl\\") third_row = set(\\"zxcvbnm\\") def can_be_typed_with_one_row(word, row): return all(char in row for char in word) result = [] for word in words: if can_be_typed_with_one_row(word, first_row) or can_be_typed_with_one_row(word, second_row) or can_be_typed_with_one_row(word, third_row): result.append(word) return result"},{"question":"def maximum_sum_subarray(arr: List[int], m: int) -> int: Returns the maximum sum of a subarray with length exactly m. Parameters: arr (list): A list of integers. m (int): Length of the subarray. Returns: int: The maximum sum of the subarray with length exactly m, or 0 if not possible. >>> maximum_sum_subarray([1, 2, 3, 4, 5], 2) == 9 # [4, 5] is the subarray with max sum >>> maximum_sum_subarray([1,4,2])) # Output: 12 print(max_diff_subsequence([7,5,3,1])) # Output: -1 print(max_diff_subsequence([1,3,7,9,2,5])) # Output: 8 print(max_diff_subsequence([])) # Output: 0","solution":"def maximum_sum_subarray(arr, m): Returns the maximum sum of a subarray with length exactly m. Parameters: arr (list): A list of integers. m (int): Length of the subarray. Returns: int: The maximum sum of the subarray with length exactly m, or 0 if not possible. n = len(arr) if m > n: return 0 max_sum = float('-inf') current_sum = sum(arr[:m]) for i in range(n - m + 1): if i == 0: max_sum = current_sum else: current_sum = current_sum - arr[i - 1] + arr[i + m - 1] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def max_points(points: List[int]) -> int: Determine the maximum points a player can collect without collecting points from adjacent games. >>> max_points([5]) 5 >>> max_points([2, 3]) 3 >>> max_points([2, 3, 4]) 6 >>> max_points([1, 2, 3, 1]) 4 >>> max_points([2, 7, 9, 3, 1]) 12 >>> max_points([4, 1, 2, 7, 5, 3, 1]) 14 >>> max_points([4, 4, 4, 4, 4]) 12 >>> max_points([]) 0 pass","solution":"def max_points(points): if not points: return 0 n = len(points) if n == 1: return points[0] if n == 2: return max(points[0], points[1]) dp = [0] * n dp[0] = points[0] dp[1] = max(points[0], points[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + points[i]) return dp[-1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_univalue_subtrees(root: TreeNode) -> int: Given a binary tree, return the number of uni-value subtrees. A uni-value subtree means all nodes of the subtree have the same value. >>> root = TreeNode(1) >>> count_univalue_subtrees(root) 1 >>> root = TreeNode(1, TreeNode(1), TreeNode(1)) >>> count_univalue_subtrees(root) 3 >>> root = TreeNode(5) >>> root.left = TreeNode(1) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(5) >>> count_univalue_subtrees(root) 4 >>> root = TreeNode(5) >>> root.left = TreeNode(5, TreeNode(5), TreeNode(5)) >>> root.right = TreeNode(5, None, TreeNode(5)) >>> count_univalue_subtrees(root) 6 >>> count_univalue_subtrees(None) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_univalue_subtrees(root): Returns the number of uni-value subtrees. def is_univalue_subtree(node, count): if not node: return True left_is_unival = is_univalue_subtree(node.left, count) right_is_unival = is_univalue_subtree(node.right, count) if left_is_unival and right_is_unival: if (node.left and node.val != node.left.val) or (node.right and node.val != node.right.val): return False count[0] += 1 return True return False count = [0] is_univalue_subtree(root, count) return count[0]"},{"question":"def two_sum(nums, target): Determine if any two distinct elements from the array add up to the target. Returns the indices of the two numbers. If there are no such elements, return an empty list. >>> two_sum([2, 7, 11, 15], 9) == [0, 1] >>> two_sum([-3, 4, 3, 90], 0) == [0, 2] >>> two_sum([1, 2, 3, 4, 5], 6) == [1, 3] >>> two_sum([1, 2, 3], 7) == [] >>> two_sum([123456789, 987654321], 1111111110) == [0, 1] >>> two_sum([3, 3], 6) == [0, 1] >>> two_sum([3, 2, 4], 6) == [1, 2]","solution":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to the target. num_indices = {} for index, num in enumerate(nums): complement = target - num if complement in num_indices: return [num_indices[complement], index] num_indices[num] = index return []"},{"question":"def collapsible_number_steps(num: int) -> int: Returns the number of steps required to transform \`num\` into 1 using the given rules: - If the number is even, divide it by 2. - If the number is odd, multiply it by 3 and add 1. >>> collapsible_number_steps(16) 4 >>> collapsible_number_steps(5) 5 >>> collapsible_number_steps(1) 0 >>> collapsible_number_steps(10) 6 >>> collapsible_number_steps(27) 111","solution":"def collapsible_number_steps(num): Returns the number of steps required to transform \`num\` into 1 using the given rules: - If the number is even, divide it by 2. - If the number is odd, multiply it by 3 and add 1. steps = 0 while num != 1: if num % 2 == 0: num //= 2 else: num = num * 3 + 1 steps += 1 return steps"},{"question":"def largest_product_by_deleting_one_digit(num: str) -> int: Given a number 'num' represented as a string, returns the largest product you can get by deleting exactly one digit from the string. It ensures the result is the maximum possible integer formed after removing a single digit. Args: num (str): A string representation of the number. Returns: int: The largest product by deleting one digit >>> largest_product_by_deleting_one_digit(\\"123\\") 23 >>> largest_product_by_deleting_one_digit(\\"2045\\") 245 >>> largest_product_by_deleting_one_digit(\\"105\\") 15 >>> largest_product_by_deleting_one_digit(\\"9087\\") 987 >>> largest_product_by_deleting_one_digit(\\"567\\") 67 >>> largest_product_by_deleting_one_digit(\\"2348\\") 348 >>> largest_product_by_deleting_one_digit(\\"10009\\") 1009 >>> largest_product_by_deleting_one_digit(\\"5001\\") 501 >>> largest_product_by_deleting_one_digit(\\"987654321\\") 98765432","solution":"def largest_product_by_deleting_one_digit(num): Returns the largest product of the number by deleting exactly one digit. Args: num (str): a string representation of the number Returns: int: the largest product by deleting one digit max_product = 0 n = len(num) for i in range(n): new_number = int(num[:i] + num[i+1:]) max_product = max(max_product, new_number) return max_product"},{"question":"def splitArray(nums: List[int], k: int) -> int: Split the list into k non-empty continuous subarrays such that the largest sum of any subarray is minimized. Returns the minimized largest sum among the k subarrays. :param nums: List[int] - List of integers :param k: int - Number of subarrays :return: int - Minimized largest sum among the subarrays >>> splitArray([7, 2, 5, 10, 8], 2) 18 >>> splitArray([10], 1) 10 >>> splitArray([5, 5, 5, 5], 2) 10 >>> splitArray([1, 2, 3, 4, 5], 5) 5 >>> splitArray([1, 2, 3, 4, 5], 1) 15","solution":"def splitArray(nums, k): Split the list into k non-empty continuous subarrays such that the largest sum of any subarray is minimized. Returns the minimized largest sum among the k subarrays. :param nums: List[int] - List of integers :param k: int - Number of subarrays :return: int - Minimized largest sum among the subarrays def can_split(mid): current_sum = 0 required_parts = 1 for num in nums: if current_sum + num > mid: required_parts += 1 current_sum = num if required_parts > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List def findCombinations(nums: List[int], target: int) -> List[List[int]]: You are given an array of integers \`nums\` and an integer \`target\`. Implement a function that returns an array containing all unique combinations of elements in \`nums\` where the chosen numbers sum to \`target\`. Each number in \`nums\` may only be used once in the combination. The solution set must not contain duplicate combinations, and the combinations can be returned in any order. >>> findCombinations([10,1,2,7,6,1,5], 8) [ [1,1,6], [1,2,5], [1,7], [2,6] ] >>> findCombinations([2, 4, 6], 5) [] >>> findCombinations([1, 2, 3], 6) [[1, 2, 3]] >>> findCombinations([2,3,5,7], 10) [ [3, 7], [2, 3, 5] ] >>> findCombinations([2, 5, 2, 1, 2], 5) [ [1, 2, 2], [5] ]","solution":"def findCombinations(nums, target): def backtrack(start, target, path): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(nums)): if i > start and nums[i] == nums[i-1]: continue backtrack(i+1, target-nums[i], path + [nums[i]]) nums.sort() result = [] backtrack(0, target, []) return result"},{"question":"def find_odd_occurrence(arr: List[int]) -> int: Given an array of integers \`arr\`, where every element is present an even number of times except for one element which is present an odd number of times, this function returns the element that is present an odd number of times. >>> find_odd_occurrence([1]) 1 >>> find_odd_occurrence([1, 2, 2, 3, 3, 1, 1]) 1 >>> find_odd_occurrence([4, 4, 6, 6, 6]) 6 >>> find_odd_occurrence([1000000000, 999999999, 1000000000]) 999999999 >>> find_odd_occurrence([10, 20, 20, 10, 20, 20, 10]) 10 >>> find_odd_occurrence([-1, -1, -2, -2, -3]) -3","solution":"def find_odd_occurrence(arr): Given an array of integers \`arr\`, where every element is present an even number of times except for one element which is present an odd number of times, this function returns the element that is present an odd number of times. result = 0 for num in arr: result ^= num return result"},{"question":"def process_operations(nums: List[int]) -> int: Processes a list of operations on an initial value of 0. Args: nums (list of int): List of integers representing operations. Returns: int: The final value after performing all operations. >>> process_operations([1, 2, 3]) 6 >>> process_operations([1, -5, 4, -2]) -2 >>> process_operations([0, 1, 2, -3, 0, 4, 5]) 9 >>> process_operations([]) 0 >>> process_operations([10, 0, -10]) -10 >>> process_operations([0, 0, 0]) 0 >>> process_operations([-1, -2, -3]) -6","solution":"def process_operations(nums): Processes a list of operations on an initial value of 0. Args: nums (list of int): List of integers representing operations. Returns: int: The final value after performing all operations. current_value = 0 for num in nums: if num == 0: current_value = 0 else: current_value += num return current_value"},{"question":"from typing import List def can_rearrange_adjacent_different(s: str) -> bool: Given a string \`s\`, check whether it is possible to rearrange the characters of \`s\` such that no two adjacent characters are the same. Return \`True\` if possible, otherwise \`False\`. >>> can_rearrange_adjacent_different(\\"aaaa\\") == False >>> can_rearrange_adjacent_different(\\"\\") == True >>> can_rearrange_adjacent_different(\\"a\\") == True >>> can_rearrange_adjacent_different(\\"ab\\") == True >>> can_rearrange_adjacent_different(\\"aabbcc\\") == True >>> can_rearrange_adjacent_different(\\"aaab\\") == False","solution":"from collections import Counter import heapq def can_rearrange_adjacent_different(s): Checks whether it is possible to rearrange the characters of the string \`s\` such that no two adjacent characters are the same. # Count the frequency of each character char_counts = Counter(s) # Max heap to get the character with the highest frequency first max_heap = [(-count, char) for char, count in char_counts.items()] heapq.heapify(max_heap) # Variables to store previous character and its count (init with dummy values) prev_count, prev_char = 0, '' result = [] while max_heap: # Pop the most frequent character count, char = heapq.heappop(max_heap) result.append(char) # If previous character was used and its count was greater than 0, push it back to the heap if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update previous character and its count (decrease count) prev_count, prev_char = count + 1, char rearranged = ''.join(result) return len(rearranged) == len(s)"},{"question":"def can_form_palindromic_ring(nums: List[int]) -> bool: Determine if the given list of non-negative integers \`nums\` can be arranged in a circular manner such that the sequence forms a palindrome. >>> can_form_palindromic_ring([]) == True >>> can_form_palindromic_ring([1]) == True >>> can_form_palindromic_ring([1, 1]) == True >>> can_form_palindromic_ring([1, 2]) == False >>> can_form_palindromic_ring([1, 2, 2, 1]) == True >>> can_form_palindromic_ring([1, 2, 1, 2, 1]) == True >>> can_form_palindromic_ring([1, 2, 3, 4]) == False >>> can_form_palindromic_ring([1, 2, 3, 2, 1, 3]) == True >>> can_form_palindromic_ring([2, 2, 2, 2]) == True pass","solution":"def can_form_palindromic_ring(nums): Determine if the given list of non-negative integers \`nums\` can be arranged in a circular manner such that the sequence forms a palindrome. from collections import Counter # Count the frequency of each number num_counts = Counter(nums) # Track the number of elements with odd occurrences odd_count = 0 for count in num_counts.values(): if count % 2 != 0: odd_count += 1 # A palindromic ring is possible if we have at most one odd character count return odd_count <= 1"},{"question":"from typing import List def max_product_subarray(arr: List[int]) -> int: Returns the maximum product of a contiguous subarray in the given integer array. >>> max_product_subarray([3]) 3 >>> max_product_subarray([-4]) -4 >>> max_product_subarray([1, 2, 3, 4]) 24 >>> max_product_subarray([-1, -2, -3, -4]) 24 >>> max_product_subarray([2, 3, -2, 4]) 6 >>> max_product_subarray([-2, 0, -1]) 0 >>> max_product_subarray([-2, 3, -4]) 24 >>> max_product_subarray([0, 2, -3, 4, 0, -2, 4]) 4 >>> max_product_subarray([-2, 0, -3, 0, -4]) 0 >>> max_product_subarray([i for i in range(1, 11)]) 3628800","solution":"def max_product_subarray(arr): Returns the maximum product of a contiguous subarray in the given integer array. if not arr: return 0 max_product = min_product = result = arr[0] for num in arr[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"def count_fixed_boundary_subarrays(arr, left, right): Counts the number of fixed-boundary subarrays in the given array. A subarray is considered fixed-boundary if its minimum value is at least \`left\` and its maximum value is at most \`right\`. :param arr: List of integers :param left: Integer, minimum value for the subarray :param right: Integer, maximum value for the subarray :return: Integer, the number of fixed-boundary subarrays >>> count_fixed_boundary_subarrays([2, 1, 4, 3], 1, 2) 3 >>> count_fixed_boundary_subarrays([1, 1, 1, 1], 1, 1) 10 >>> count_fixed_boundary_subarrays([3, 4, 5, 6], 1, 2) 0 >>> count_fixed_boundary_subarrays([1, 2, 3], 1, 3) 6 >>> count_fixed_boundary_subarrays([1, 3, 2, 4, 2], 2, 3) 4","solution":"def count_fixed_boundary_subarrays(arr, left, right): Counts the number of fixed-boundary subarrays in the given array. A subarray is considered fixed-boundary if its minimum value is at least \`left\` and its maximum value is at most \`right\`. :param arr: List of integers :param left: Integer, minimum value for the subarray :param right: Integer, maximum value for the subarray :return: Integer, the number of fixed-boundary subarrays n = len(arr) count = 0 for i in range(n): min_val, max_val = float('inf'), float('-inf') for j in range(i, n): min_val = min(min_val, arr[j]) max_val = max(max_val, arr[j]) if left <= min_val <= max_val <= right: count += 1 return count"},{"question":"def calculate_shadow_area(grid): Returns the total area covered by the shadows in the entire grid. Parameters: grid (List[List[int]]): A matrix of non-negative integers representing tower heights. Returns: int: The total area covered by the shadows. >>> calculate_shadow_area([[5]]) 5 >>> calculate_shadow_area([[5], [3], [8]]) 16 >>> calculate_shadow_area([[2, 1, 3, 4]]) 11 >>> calculate_shadow_area([[2, 1, 3, 4], [1, 1, 5, 1], [4, 4, 4, 4]]) 36 >>> calculate_shadow_area([[3, 0, 1], [2, 2, 2], [1, 3, 1]]) 23 >>> calculate_shadow_area([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"def calculate_shadow_area(grid): Returns the total area covered by the shadows in the entire grid. total_shadow_area = 0 for row in grid: max_height = 0 for height in row: if height > max_height: max_height = height total_shadow_area += max_height return total_shadow_area"},{"question":"def rob(nums): Determine the maximum amount of money the robber can rob without robbing two adjacent houses. The first and last house are adjacent. >>> rob([]) == 0 >>> rob([5]) == 5 >>> rob([2, 3]) == 3 >>> rob([2, 3, 2]) == 3 >>> rob([1, 2, 3]) == 3 >>> rob([2, 7, 9, 3, 1]) == 11 >>> rob([1, 2, 3, 1]) == 4 >>> rob([1, 20, 3, 10, 5]) == 30 >>> rob([2, 3, 2, 3, 2]) == 6","solution":"def rob(nums): Returns the maximum amount of money the robber can rob without robbing two adjacent houses. The first and last house are adjacent. if not nums: return 0 elif len(nums) == 1: return nums[0] elif len(nums) == 2: return max(nums) def rob_linear(houses): prev, curr = 0, 0 for money in houses: prev, curr = curr, max(curr, prev + money) return curr # Calculate two scenarios: without the first house and without the last house return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_list(head): Reorders the linked list in-place such that: L0 -> Ln -> L1 -> Ln-1 -> L2 -> Ln-2 -> ... Arguments: head -- ListNode, the head of the linked list. pass import pytest def list_to_linkedlist(elements): if not elements: return None head = ListNode(elements[0]) current = head for element in elements[1:]: current.next = ListNode(element) current = current.next return head def linkedlist_to_list(head): elements = [] current = head while current: elements.append(current.val) current = current.next return elements def test_reorder_list(): head = list_to_linkedlist([1, 2, 3, 4]) reorder_list(head) assert linkedlist_to_list(head) == [1, 4, 2, 3] def test_reorder_empty_list(): head = list_to_linkedlist([]) reorder_list(head) assert linkedlist_to_list(head) == [] def test_reorder_single_element_list(): head = list_to_linkedlist([1]) reorder_list(head) assert linkedlist_to_list(head) == [1] def test_reorder_two_element_list(): head = list_to_linkedlist([1, 2]) reorder_list(head) assert linkedlist_to_list(head) == [1, 2] def test_reorder_odd_number_elements_list(): head = list_to_linkedlist([1, 2, 3, 4, 5]) reorder_list(head) assert linkedlist_to_list(head) == [1, 5, 2, 4, 3] def test_reorder_even_number_elements_list(): head = list_to_linkedlist([1, 2, 3, 4, 5, 6]) reorder_list(head) assert linkedlist_to_list(head) == [1, 6, 2, 5, 3, 4]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_list(head): Reorders the linked list in-place such that: L0 -> Ln -> L1 -> Ln-1 -> L2 -> Ln-2 -> ... Arguments: head -- ListNode, the head of the linked list. if not head or not head.next: return # Step 1: Find the middle of the linked list slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Step 2: Reverse the second half of the linked list prev, curr = None, slow while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Step 3: Merge the two halves first, second = head, prev while second.next: tmp1, tmp2 = first.next, second.next first.next = second second.next = tmp1 first = tmp1 second = tmp2"},{"question":"def max_length_subsequence(nums, limit): Returns the length of the longest subsequence of nums such that its sum is less than or equal to the limit. >>> max_length_subsequence([1, 2, 3], 5) 2 >>> max_length_subsequence([1, 2, 3, 4], 5) 2 >>> max_length_subsequence([1, 2, 2], 5) 3 >>> max_length_subsequence([2, 4, 1, 3], 6) 3 >>> max_length_subsequence([5], 5) 1 >>> max_length_subsequence([6], 5) 0 >>> max_length_subsequence([1, 1, 1, 1], 5) 4 >>> max_length_subsequence([1, 1, 1, 1], 3) 3 >>> max_length_subsequence([100, 200, 300], 500) 2 >>> max_length_subsequence([100, 200, 100], 300) 2","solution":"def max_length_subsequence(nums, limit): Returns the length of the longest subsequence of nums such that its sum is less than or equal to the limit. nums.sort() current_sum = 0 length = 0 for num in nums: if current_sum + num <= limit: current_sum += num length += 1 else: break return length"},{"question":"def minimum_new_skyscraper_height(heights: List[int]) -> int: Returns the minimum height of the new skyscraper to ensure it does not block the view of any taller skyscrapers. :param heights: List[int] - The heights of the existing skyscrapers. :return: int - The minimum height of the new skyscraper. >>> minimum_new_skyscraper_height([]) == 1 >>> minimum_new_skyscraper_height([5]) == 6 >>> minimum_new_skyscraper_height([3, 1, 4, 2]) == 5 >>> minimum_new_skyscraper_height([1, 5, 2, 3]) == 6 >>> minimum_new_skyscraper_height([2, 2, 2, 2]) == 3 >>> minimum_new_skyscraper_height([5, 4, 3, 2, 1]) == 6 >>> minimum_new_skyscraper_height([1, 2, 3, 4, 5]) == 6 >>> minimum_new_skyscraper_height([8, 1, 7, 2, 5, 3, 6, 4]) == 9","solution":"def minimum_new_skyscraper_height(heights): Returns the minimum height of the new skyscraper to ensure it does not block the view of any taller skyscrapers. :param heights: List[int] - The heights of the existing skyscrapers. :return: int - The minimum height of the new skyscraper. if not heights: return 1 # In case there are no skyscrapers, return any height greater than 0 tallest_visible_skyscraper = max(heights) # The tallest existing skyscraper return tallest_visible_skyscraper + 1 # The new skyscraper should be at least 1 unit taller than the tallest existing one"},{"question":"from typing import List def min_deletions_to_make_good_string(s: str) -> int: Returns the minimum number of deletions needed to make string s a good string (no two consecutive characters should be the same). >>> min_deletions_to_make_good_string('abcdef') == 0 >>> min_deletions_to_make_good_string('aaaa') == 3 >>> min_deletions_to_make_good_string('abababa') == 0 >>> min_deletions_to_make_good_string('aabbcc') == 3 >>> min_deletions_to_make_good_string('') == 0 >>> min_deletions_to_make_good_string('a') == 0 >>> min_deletions_to_make_good_string('aabbaabb') == 4 pass","solution":"def min_deletions_to_make_good_string(s): Returns the minimum number of deletions needed to make string s a good string (no two consecutive characters should be the same). if not s: return 0 deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Reconstructs the string by rearranging the characters according to the given indices array. Parameters: s (str): The original string. indices (list of int): The indices array where indices[i] represents the new index of s[i]. Returns: str: The reconstructed string. >>> restore_string(\\"abc\\", [2, 1, 0]) \\"cba\\" >>> restore_string(\\"abc\\", [0, 1, 2]) \\"abc\\" >>> restore_string(\\"aiohn\\", [3, 1, 4, 2, 0]) \\"nihao\\" >>> restore_string(\\"ate\\", [2, 0, 1]) \\"tea\\" >>> restore_string(\\"\\", []) \\"\\"","solution":"def restore_string(s, indices): Reconstructs the string by rearranging the characters according to the given indices array. Parameters: s (str): The original string. indices (list of int): The indices array where indices[i] represents the new index of s[i]. Returns: str: The reconstructed string. # Initialize the resulting list with the same length as the string \`s\` result = [''] * len(s) # Place each character in the corresponding new index as per \`indices\` for i, index in enumerate(indices): result[index] = s[i] # Join the list into a string and return return ''.join(result)"},{"question":"def canSeeSunset(heights: List[int]) -> int: Returns the number of buildings that can see the sunset. Only buildings with no taller building to their left can see the sunset. >>> canSeeSunset([3, 3, 3, 3]) == 1 >>> canSeeSunset([1, 2, 3, 4, 5]) == 5 >>> canSeeSunset([5, 4, 3, 2, 1]) == 1 >>> canSeeSunset([3, 1, 4, 2, 5]) == 3 >>> canSeeSunset([4]) == 1 >>> canSeeSunset([]) == 0 # Your code here","solution":"from typing import List def canSeeSunset(heights: List[int]) -> int: Returns the number of buildings that can see the sunset. Only buildings with no taller building to their left can see the sunset. count = 0 max_height = float('-inf') for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): Initializes the iterator with the root node of a BST. def next(self) -> int: Returns the next smallest number in the BST. def hasNext(self) -> bool: Returns true if there is a next smallest number in the BST, or false otherwise. # Unit Tests def test_bst_iterator(): # Construct the BST root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) # Initialize the iterator iterator = BSTIterator(root) # Test the iterator methods assert iterator.next() == 3 assert iterator.next() == 7 assert iterator.hasNext() == True assert iterator.next() == 9 assert iterator.hasNext() == True assert iterator.next() == 15 assert iterator.hasNext() == True assert iterator.next() == 20 assert iterator.hasNext() == False def test_single_node_bst(): root = TreeNode(1) iterator = BSTIterator(root) assert iterator.next() == 1 assert iterator.hasNext() == False def test_right_heavy_bst(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) iterator = BSTIterator(root) assert iterator.next() == 1 assert iterator.next() == 2 assert iterator.next() == 3 assert iterator.hasNext() == False def test_left_heavy_bst(): root = TreeNode(3) root.left = TreeNode(2) root.left.left = TreeNode(1) iterator = BSTIterator(root) assert iterator.next() == 1 assert iterator.next() == 2 assert iterator.next() == 3 assert iterator.hasNext() == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root): # Initialize an empty stack and populate it with the leftmost path of the BST self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): # Add all the nodes along the leftmost branch of the tree to the stack while root: self.stack.append(root) root = root.left def next(self) -> int: # Node at the top of the stack is the next smallest element topmost_node = self.stack.pop() # If the node has a right child, add the leftmost branch of the right subtree if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self) -> bool: # Return true if there are elements in the stack return len(self.stack) > 0"},{"question":"def minPathSum(grid): Returns the minimum sum of the numbers along the path from the top-left corner to the bottom-right corner of the grid. >>> minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 >>> minPathSum([[0]]) == 0 >>> minPathSum([[1, 2], [1, 1]]) == 3 >>> minPathSum([[1, 2, 5], [3, 2, 1]]) == 6 >>> minPathSum([[]]) == 0 # your code here","solution":"def minPathSum(grid): Returns the minimum sum of the numbers along the path from the top-left corner to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the first row for i in range(1, n): grid[0][i] += grid[0][i-1] # Initialize the first column for i in range(1, m): grid[i][0] += grid[i-1][0] # Compute the minimum path sums for the rest of the grid for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[m-1][n-1]"},{"question":"def count_unique_pairs(arr: List[int], k: int) -> int: Given an array of integers \`arr\`, and an integer \`k\`, return the number of unique pairs \`(i, j)\` such that \`0 <= i < j < arr.length\` and \`arr[i] + arr[j] == k\`. Two pairs \`(i, j)\` and \`(j, i)\` are considered the same and should only be counted once. >>> count_unique_pairs([1, 2, 3], 7) == 0 >>> count_unique_pairs([1, 2, 3], 5) == 1 >>> count_unique_pairs([1, 2, 3, 4, 5], 6) == 2 >>> count_unique_pairs([1, 1, 1, 1], 2) == 1 >>> count_unique_pairs([1, 9, 11, 20], 31) == 1 >>> count_unique_pairs([], 5) == 0 >>> count_unique_pairs([1], 1) == 0 >>> count_unique_pairs([1, 5, 7, -1, 5], 6) == 2","solution":"def count_unique_pairs(arr, k): Returns the number of unique pairs (i, j) such that 0 <= i < j < arr.length and arr[i] + arr[j] == k. seen = set() unique_pairs = set() for num in arr: if k - num in seen: unique_pairs.add((min(num, k - num), max(num, k - num))) seen.add(num) return len(unique_pairs)"},{"question":"from typing import List def min_moves(grid: List[List[int]], startX: int, startY: int, targetX: int, targetY: int) -> int: A robot cleaning freely is placed on a grid represented by a 2D array, where \`0\` represents an empty cell and \`1\` represents a blocked cell. The robot can move freely into any empty cell in four directions (up, down, left, right) without crossing any blocked cell. Given the starting position of the robot as \`(startX, startY)\` and the target position as \`(targetX, targetY)\`, return the minimum number of moves required for the robot to reach the target or \`-1\` if it is impossible. from collections import deque def test_min_moves_possible_path(): grid = [ [0, 0, 1], [0, 0, 1], [1, 0, 0] ] assert min_moves(grid, 0, 0, 2, 2) == 4 def test_min_moves_impossible_path(): grid = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ] assert min_moves(grid, 0, 0, 2, 2) == -1 def test_min_moves_same_start_and_target(): grid = [ [0, 0], [0, 0] ] assert min_moves(grid, 0, 0, 0, 0) == 0 def test_min_moves_one_move_away(): grid = [ [0, 0], [1, 0] ] assert min_moves(grid, 0, 0, 0, 1) == 1 def test_min_moves_start_or_target_is_blocked(): grid = [ [0, 0], [0, 1] ] assert min_moves(grid, 0, 0, 1, 1) == -1 assert min_moves(grid, 1, 1, 0, 0) == -1","solution":"from collections import deque def min_moves(grid, startX, startY, targetX, targetY): Returns the minimum number of moves required for the robot to reach the target or -1 if it is impossible. def is_valid(x, y): Check if the cell (x, y) is valid and can be visited. return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0 if not is_valid(startX, startY) or not is_valid(targetX, targetY): return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(startX, startY, 0)]) visited = set((startX, startY)) while queue: x, y, moves = queue.popleft() if (x, y) == (targetX, targetY): return moves for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1"},{"question":"def maximalSquare(matrix: List[List[int]]) -> int: You are given a \`matrix\` of size \`m x n\` consisting of non-negative integers. Find the size of the largest square containing only 1's and return its area. If there is no such square, return 0. >>> maximalSquare([]) == 0 >>> maximalSquare([[]]) == 0 >>> maximalSquare([[0, 0], [0, 0]]) == 0 >>> maximalSquare([[1, 1], [1, 1]]) == 4 >>> maximalSquare( [[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]) == 4 >>> maximalSquare( [[0, 1, 1, 0, 0], [1, 1, 1, 1, 0], [1, 1, 1, 1, 0], [0, 1, 1, 1, 0]]) == 9 >>> maximalSquare([[1]]) == 1 >>> maximalSquare([[0]]) == 0 >>> maximalSquare([[1, 0], [0, 1]]) == 1 >>> maximalSquare([[1, 0, 1, 1], [1, 1, 1, 1], [0, 1, 1, 1]]) == 4","solution":"def maximalSquare(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"class Node: def __init__(self, val: int, prev: 'Node' = None, next: 'Node' = None, child: 'Node' = None, partner: 'Node' = None): self.val = val self.prev = prev self.next = next self.child = child self.partner = partner def flatten(head: 'Node') -> 'Node': Flattens a doubly-linked list with child and partner pointers into a single level doubly-linked list. >>> head = Node(1) >>> child = Node(2) >>> head.next = Node(3, prev=head) >>> head.child = child >>> flattened_head = flatten(head) >>> flat_list = [] >>> current = flattened_head >>> while current: ... flat_list.append(current.val) ... current = current.next >>> flat_list [1, 2, 3]","solution":"class Node: def __init__(self, val: int, prev: 'Node' = None, next: 'Node' = None, child: 'Node' = None, partner: 'Node' = None): self.val = val self.prev = prev self.next = next self.child = child self.partner = partner def flatten(head: 'Node') -> 'Node': if not head: return head def flatten_recursively(node): current = node last = node while current: next_node = current.next if current.child: child_last = flatten_recursively(current.child) # Connect current node to child current.next = current.child current.child.prev = current # Connect child's last to next_node if next_node: child_last.next = next_node next_node.prev = child_last current.child = None last = child_last else: last = current if current.partner: partner_last = flatten_recursively(current.partner) # Connect current node to partner partner_last.next = current.next current.next = current.partner current.partner.prev = current current.partner = None # Ensure the next node points to the correct position after partner if next_node: next_node.prev = partner_last last = partner_last current = next_node return last flatten_recursively(head) return head"},{"question":"def max_sum_subarray(nums: List[int], k: int) -> int: Returns the maximum sum of any contiguous subarray of length k. If there is no subarray of length k, return 0. >>> max_sum_subarray([1, 2, 3], 5) == 0 >>> max_sum_subarray([5], 1) == 5 >>> max_sum_subarray([1, 2, 3, 4, 5], 2) == 9 # 4 + 5 >>> max_sum_subarray([1, -2, 3, 4, -1, 2, 1, -5, 4], 4) == 8 # 3 + 4 - 1 + 2 >>> max_sum_subarray([-1, -2, -3, -4, -5], 2) == -3 # -1 + -2 >>> max_sum_subarray([1, 2, 3, 4, 5], 5) == 15 # sum of the entire array >>> nums = [i for i in range(1, 101)] >>> max_sum_subarray(nums, 10) == sum(range(91, 101))","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of any contiguous subarray of length k. If there is no subarray of length k, return 0. n = len(nums) if k > n: return 0 # Compute the initial sum of the first \`k\` elements max_sum = current_sum = sum(nums[:k]) # Use a sliding window to find the maximum sum of k-length subarray for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def generate_happy_string(n: int) -> str: Returns a happy string of length n. A happy string is a string that consists only of letters 'a', 'b', and 'c' and does not contain any substrings \\"aaa\\", \\"bbb\\", or \\"ccc\\". >>> len(generate_happy_string(5)) == 5 True >>> len(generate_happy_string(10)) == 10 True >>> len(generate_happy_string(0)) == 0 True >>> all(c in 'abc' for c in generate_happy_string(5)) True >>> forbidden_substrings = [\\"aaa\\", \\"bbb\\", \\"ccc\\"] >>> happy_string = generate_happy_string(20) >>> all(forbidden not in happy_string for forbidden in forbidden_substrings) True >>> generate_happy_string(1) in ['a', 'b', 'c'] True >>> generate_happy_string(2) in ['ab', 'bc', 'ca', 'ba', 'cb', 'ac'] True","solution":"def generate_happy_string(n): Returns a happy string of length n. A happy string is a string that consists only of letters 'a', 'b', and 'c' and does not contain any substrings \\"aaa\\", \\"bbb\\", or \\"ccc\\". if n <= 0: return \\"\\" # Initialize the string with 'a' happy_string = ['a'] for i in range(1, n): if happy_string[-1] == 'a': happy_string.append('b') # If last character was 'a', append 'b' elif happy_string[-1] == 'b': happy_string.append('c') # If last character was 'b', append 'c' else: happy_string.append('a') # If last character was 'c', append 'a' return ''.join(happy_string)"},{"question":"import heapq from typing import List def min_cost_to_connect_ropes(arr: List[int]) -> int: You are given an unsorted integer array \`arr\` representing different lengths of ropes. Your task is to connect the ropes into one single rope with the minimum cost. The cost of connecting two ropes is equal to the sum of their lengths. Return the minimum cost to connect all the ropes into one rope. >>> min_cost_to_connect_ropes([4, 3, 2, 6]) 29 >>> min_cost_to_connect_ropes([10]) 0 >>> min_cost_to_connect_ropes([1, 2]) 3 >>> min_cost_to_connect_ropes([1, 2, 3, 4, 5]) 33 >>> min_cost_to_connect_ropes([]) 0 >>> min_cost_to_connect_ropes([1, 1, 1, 1]) 8","solution":"import heapq def min_cost_to_connect_ropes(arr): if not arr: return 0 heapq.heapify(arr) total_cost = 0 while len(arr) > 1: first = heapq.heappop(arr) second = heapq.heappop(arr) cost = first + second total_cost += cost heapq.heappush(arr, cost) return total_cost"},{"question":"def minimum_partition_difference(arr: List[int]) -> int: Finds the minimum difference between the sums of two subsets. :param arr: List of integers :return: Minimum difference between the sums of the subsets >>> minimum_partition_difference([1, 6, 11, 5]) 1 >>> minimum_partition_difference([1, 5, 11, 5]) 0 >>> minimum_partition_difference([3, 1, 4, 2, 2]) 0 >>> minimum_partition_difference([5, 5, 5, 5]) 0 >>> minimum_partition_difference([1, 2, 3, 9]) 3 >>> minimum_partition_difference([1]) 1 >>> minimum_partition_difference([1, 2]) 1","solution":"def minimum_partition_difference(arr): Finds the minimum difference between the sums of two subsets. :param arr: List of integers :return: Minimum difference between the sums of the subsets total_sum = sum(arr) n = len(arr) dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] for j in range(total_sum // 2, -1, -1): if dp[n][j]: return total_sum - 2 * j"},{"question":"class EBookReader: def __init__(self, book: str): Initializes an EBookReader object with a given book string. >>> reader = EBookReader(\\"this is a very interesting book to read\\") def addHighlight(self, startIndex: int, endIndex: int): Highlights the segment of the book from startIndex to endIndex (inclusive). If the indices are invalid, the operation should be ignored. >>> reader = EBookReader(\\"this is a very interesting book to read\\") >>> reader.addHighlight(2, 3) >>> reader.getHighlights() [\\"a very\\"] def removeHighlight(self, startIndex: int, endIndex: int): Removes the highlighted segment from startIndex to endIndex (inclusive). If the segment does not exist, the operation should be ignored. >>> reader = EBookReader(\\"read and highlight in this book\\") >>> reader.addHighlight(2, 3) >>> reader.removeHighlight(2, 3) >>> reader.getHighlights() [] def getHighlights(self) -> List[str]: Returns a list of all highlighted segments in the order they appear in the book. >>> reader = EBookReader(\\"this is a very interesting book to read\\") >>> reader.addHighlight(0, 1) >>> reader.addHighlight(4, 6) >>> reader.getHighlights() [\\"this is\\", \\"interesting book to\\"]","solution":"class EBookReader: def __init__(self, book): self.book = book.split() self.highlights = [] def addHighlight(self, startIndex, endIndex): if 0 <= startIndex <= endIndex < len(self.book): for highlight in self.highlights: if not (endIndex < highlight[0] or startIndex > highlight[1]): return # Overlapping highlight self.highlights.append((startIndex, endIndex)) self.highlights.sort() def removeHighlight(self, startIndex, endIndex): for highlight in self.highlights: if highlight[0] == startIndex and highlight[1] == endIndex: self.highlights.remove(highlight) return def getHighlights(self): return [' '.join(self.book[start:end+1]) for start, end in self.highlights]"},{"question":"def longest_subarray_with_two_occurrences(arr: list[int]) -> int: Finds the length of the longest subarray where each element occurs exactly twice. Parameters: arr (list of int): The input array of integers. Returns: int: The length of the longest subarray where each element occurs exactly twice. Examples: >>> longest_subarray_with_two_occurrences([1, 2, 1, 2]) 4 >>> longest_subarray_with_two_occurrences([1, 2, 3, 1, 2, 3, 1, 1]) 6 >>> longest_subarray_with_two_occurrences([1, 1, 2, 2, 3, 3]) 6 >>> longest_subarray_with_two_occurrences([1]) 0 >>> longest_subarray_with_two_occurrences([1, 1]) 2 >>> longest_subarray_with_two_occurrences([1, 2, 3, 4, 5, 6]) 0 >>> longest_subarray_with_two_occurrences([]) 0 >>> longest_subarray_with_two_occurrences([1, 2, 1, 2, 3, 4, 3, 4]) 8","solution":"def longest_subarray_with_two_occurrences(arr): Finds the length of the longest subarray where each element occurs exactly twice. Parameters: arr (list of int): The input array of integers. Returns: int: The length of the longest subarray where each element occurs exactly twice. from collections import Counter if not arr: return 0 n = len(arr) max_length = 0 # Function to verify if all elements in the subarray occur exactly twice def check_twice(subarr): counter = Counter(subarr) return all(count == 2 for count in counter.values()) # Use sliding window approach to find the maximum length subarray for i in range(n): for j in range(i + 1, n, 2): # Increment by 2 for possible subarray with pairs if check_twice(arr[i:j+1]): max_length = max(max_length, j - i + 1) return max_length"},{"question":"def max_profit(arr: List[int]) -> int: Returns the maximum profit that can be achieved from exactly one transaction. :param arr: List[int], list of daily stock prices :return: int, maximum profit >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([]) 0 >>> max_profit([5]) 0 >>> max_profit([2, 2, 2, 2, 2]) 0 >>> max_profit([3, -3, -2, -1, 4]) 7 >>> max_profit([100, 180, 260, 310, 40, 535, 695]) 655","solution":"def max_profit(arr): Returns the maximum profit that can be achieved from exactly one transaction. :param arr: List[int], list of daily stock prices :return: int, maximum profit if not arr or len(arr) < 2: return 0 min_price = arr[0] max_profit = 0 for price in arr[1:]: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def count_good_pairs(nums: List[int], k: int) -> int: Returns the number of good pairs in the array where the sum of the elements is a multiple of k. Args: nums: List[int] - List of integers. k: int - The divisor. Returns: int - The number of good pairs. from typing import List from solution import count_good_pairs def test_count_good_pairs_example(): assert count_good_pairs([1, 2, 3, 4, 5], 3) == 4 def test_count_good_pairs_no_pairs(): assert count_good_pairs([1, 2, 3], 7) == 0 def test_count_good_pairs_all_pairs(): assert count_good_pairs([6, 3, 9], 3) == 3 def test_count_good_pairs_mixed_elements(): assert count_good_pairs([1, 2, 3, 4, 5, 6], 5) == 3 def test_count_good_pairs_single_element(): assert count_good_pairs([5], 3) == 0 def test_count_good_pairs_negative_elements(): assert count_good_pairs([-1, -2, -3, -4], 3) == 2","solution":"def count_good_pairs(nums, k): Returns the number of good pairs in the array where the sum of the elements is a multiple of k. Args: nums: List[int] - List of integers. k: int - The divisor. Returns: int - The number of good pairs. count = 0 n = len(nums) # Traverse through all pairs and check the condition for i in range(n): for j in range(i + 1, n): if (nums[i] + nums[j]) % k == 0: count += 1 return count"},{"question":"def max_sum_submatrix(matrix: List[List[int]], k: int) -> int: Finds the maximum sum of any submatrix that contains exactly k elements. :param matrix: List[List[int]]: 2D integer array. :param k: int: Number of elements the submatrix should contain. :return: int: Maximum sum of such a submatrix. >>> max_sum_submatrix([ ... [1, -2, 3], ... [4, -5, 6], ... [-7, 8, 9]], 3) 18 >>> max_sum_submatrix([ ... [1, 2], ... [3, 4]], 2) 7 >>> max_sum_submatrix([ ... [1, 2], ... [3, 4]], 4) 10 >>> max_sum_submatrix([ ... [-1, -2], ... [-3, 4]], 1) 4 >>> max_sum_submatrix([ ... [-1, -2], ... [-3, -4]], 2) -3","solution":"def max_sum_submatrix(matrix, k): Finds the maximum sum of any submatrix that contains exactly k elements. :param matrix: List[List[int]]: 2D integer array. :param k: int: Number of elements the submatrix should contain. :return: int: Maximum sum of such a submatrix. rows = len(matrix) cols = len(matrix[0]) max_sum = float('-inf') # Generate all possible submatrices for r1 in range(rows): for c1 in range(cols): for r2 in range(r1, rows): for c2 in range(c1, cols): # Get all elements in the submatrix (r1, c1) to (r2, c2) elements = [] for r in range(r1, r2+1): for c in range(c1, c2+1): elements.append(matrix[r][c]) # Check if the submatrix contains exactly k elements if len(elements) == k: max_sum = max(max_sum, sum(elements)) return max_sum"},{"question":"from typing import List def lexicographically_smallest_sequence(arr: List[int]) -> List[int]: Given a list of \`n\` integers, modify the list to create the lexicographically smallest sequence possible by removing exactly one element from the list. The lexicographically smallest sequence means a sequence that appears first in the dictionary order. If there are multiple valid results, return any of them. >>> lexicographically_smallest_sequence([1, 2, 3, 4, 5]) == [1, 2, 3, 4] >>> lexicographically_smallest_sequence([3, 2, 1]) == [2, 1] >>> lexicographically_smallest_sequence([1, 2, 3, 2]) == [1, 2, 2] >>> lexicographically_smallest_sequence([4, 3, 1, 2, 5]) == [3, 1, 2, 5] >>> lexicographically_smallest_sequence([5, 4, 3, 2, 1]) == [4, 3, 2, 1] >>> lexicographically_smallest_sequence([1, 2, 3, 4, 5]) == [1, 2, 3, 4] >>> lexicographically_smallest_sequence([2, 2, 2, 1, 2]) == [2, 2, 1, 2] >>> lexicographically_smallest_sequence([1]) == [] >>> lexicographically_smallest_sequence([2, 1]) == [1] >>> lexicographically_smallest_sequence([1, 2]) == [1]","solution":"def lexicographically_smallest_sequence(arr): Returns the lexicographically smallest sequence by removing exactly one element from the list. n = len(arr) for i in range(n - 1): if arr[i] > arr[i + 1]: return arr[:i] + arr[i+1:] # If no such element is found, remove the last element return arr[:-1]"},{"question":"def min_window_substring(s: str, word: str) -> str: Given a string \`s\` consisting of lowercase English letters and a word \`word\`, return the smallest substring of \`s\` that contains all the characters of \`word\` including duplicates in any order. If there is no such substring, return an empty string \\"\\". >>> min_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") 'BANC' >>> min_window_substring(\\"a\\", \\"a\\") 'a' >>> min_window_substring(\\"a\\", \\"aa\\") '' >>> min_window_substring(\\"this is a test string\\", \\"tist\\") 't stri' >>> min_window_substring(\\"abcdefg\\", \\"xyz\\") '' >>> min_window_substring(\\"aabbccdd\\", \\"abc\\") 'abbc' >>> min_window_substring(\\"aabbccdd\\", \\"aabbcc\\") 'aabbcc' pass","solution":"def min_window_substring(s, word): from collections import Counter, defaultdict word_count = Counter(word) missing_chars = len(word) min_len = float('inf') min_substr = \\"\\" left = 0 counts = defaultdict(int) for right, char in enumerate(s): if word_count[char] > 0: counts[char] += 1 if counts[char] <= word_count[char]: missing_chars -= 1 while missing_chars == 0: if right - left + 1 < min_len: min_len = right - left + 1 min_substr = s[left:right + 1] if word_count[s[left]] > 0: counts[s[left]] -= 1 if counts[s[left]] < word_count[s[left]]: missing_chars += 1 left += 1 return min_substr"},{"question":"def can_see_ocean(arr: List[int]) -> List[bool]: Determines if a building can see the ocean to its right. :param arr: List of integers representing the heights of buildings. :return: List of booleans indicating if each building can see the ocean. >>> can_see_ocean([3, 2, 3, 4, 1]) [False, False, False, True, True] >>> can_see_ocean([5]) [True] >>> can_see_ocean([1, 2, 3, 4, 5]) [False, False, False, False, True] >>> can_see_ocean([5, 4, 3, 2, 1]) [True, True, True, True, True] >>> can_see_ocean([3, 3, 3, 3]) [False, False, False, True] >>> can_see_ocean([1, 3, 2, 5, 3, 4]) [False, False, False, True, False, True] pass","solution":"def can_see_ocean(arr): Determines if a building can see the ocean to its right. :param arr: List of integers representing the heights of buildings. :return: List of booleans indicating if each building can see the ocean. n = len(arr) result = [False] * n max_height_to_right = -1 for i in range(n - 1, -1, -1): if arr[i] > max_height_to_right: result[i] = True max_height_to_right = arr[i] else: result[i] = False return result"},{"question":"def prune_binary_tree(parent: List[int], values: List[int]) -> List[int]: Prunes a binary tree with given node values and parent-child relationships, such that all nodes with value 0 that do not have a child with value 1 are removed. >>> prune_binary_tree([-1], [1]) [1] >>> prune_binary_tree([-1], [0]) [] >>> prune_binary_tree([-1, 0, 0, 1, 1, 2, 2, 3], [1, 0, 1, 0, 0, 0, 1, 0]) [1, 1, 1] >>> prune_binary_tree([-1, 0, 0, 1, 1, 2, 2], [0, 0, 0, 0, 0, 0, 0]) [] >>> prune_binary_tree([-1, 0, 0, 1, 1, 2, 2, 3, 3], [1, 0, 1, 1, 0, 0, 0, 0, 1]) [1, 0, 1, 1, 1]","solution":"class TreeNode: def __init__(self, value=0): self.value = value self.left = None self.right = None def build_tree(parent, values): n = len(parent) nodes = [TreeNode(values[i]) for i in range(n)] root = None for i in range(n): if parent[i] == -1: root = nodes[i] else: p = nodes[parent[i]] if not p.left: p.left = nodes[i] else: p.right = nodes[i] return root def prune_tree(node): if not node: return None node.left = prune_tree(node.left) node.right = prune_tree(node.right) if node.value == 0 and not node.left and not node.right: return None return node def level_order_traversal(root): if not root: return [] result, queue = [], [root] while queue: node = queue.pop(0) result.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result def prune_binary_tree(parent, values): root = build_tree(parent, values) root = prune_tree(root) return level_order_traversal(root)"},{"question":"def count_merged_intervals(nums1: List[int], nums2: List[int]) -> int: Merges overlapping intervals and returns the number of merged intervals. >>> count_merged_intervals([1], [2]) == 1 >>> count_merged_intervals([1, 3, 5], [2, 4, 6]) == 3 >>> count_merged_intervals([1, 2, 3], [3, 4, 5]) == 1 >>> count_merged_intervals([1, 2, 8], [3, 6, 10]) == 2 >>> count_merged_intervals([1, 2, 3, 4, 5, 6], [6, 5, 4, 8, 7, 9]) == 1 >>> count_merged_intervals([], []) == 0 >>> count_merged_intervals([1, 2], [3]) == 0 >>> count_merged_intervals([1], [2, 3]) == 0","solution":"def count_merged_intervals(nums1, nums2): Merges overlapping intervals and returns the number of merged intervals. if not nums1 or not nums2 or len(nums1) != len(nums2): return 0 intervals = sorted([(nums1[i], nums2[i]) for i in range(len(nums1))]) merged_intervals = [] for interval in intervals: if not merged_intervals or merged_intervals[-1][1] < interval[0]: merged_intervals.append(interval) else: merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], interval[1])) return len(merged_intervals)"},{"question":"def max_score(grid: List[List[int]]) -> int: Returns the maximum score that can be obtained by removing blocks following the given conditions. Parameters: grid (list of list of int): 2D array representing scores of blocks in the grid Returns: int: Maximum score possible >>> max_score([]) == 0 >>> max_score([[5]]) == 5 >>> max_score([[1], [2], [3]]) == 6 >>> max_score([[1, 2, 3]]) == 6 >>> max_score([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 45 >>> max_score([[1, 2], [3, 4], [5, 6]]) == 21","solution":"def max_score(grid): Returns the maximum score that can be obtained by removing blocks following the given conditions. Parameters: grid (list of list of int): 2D array representing scores of blocks in the grid Returns: int: Maximum score possible if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) max_score = 0 # Iterate through each column for j in range(m): # Accumulate the maximum score from each column for i in range(n): max_score += grid[i][j] return max_score"},{"question":"def min_cost_to_hire_workers(costs, k, candidates): Returns the minimum total cost to hire exactly k workers. :param costs: List[int] representing the cost of hiring the i-th worker. :param k: int, the number of workers to hire. :param candidates: int, the number of candidates from the beginning and end to interview. :return: int, the minimum total cost to hire exactly k workers. pass from solution import min_cost_to_hire_workers def test_min_cost_to_hire_workers_basic(): assert min_cost_to_hire_workers([10, 20, 30, 40], 2, 2) == 30 def test_min_cost_to_hire_workers_case2(): assert min_cost_to_hire_workers([5, 8, 9, 6, 3], 3, 2) == 14 def test_min_cost_to_hire_workers_case3(): assert min_cost_to_hire_workers([7, 4, 19, 3, 1], 2, 3) == 4 def test_min_cost_to_hire_workers_case4(): assert min_cost_to_hire_workers([1, 10, 3, 10, 1], 1, 2) == 1 def test_min_cost_to_hire_workers_large_k(): assert min_cost_to_hire_workers([1, 2, 3, 4, 5], 5, 3) == 15 def test_min_cost_zero_workers(): assert min_cost_to_hire_workers([8, 4, 6, 2], 0, 2) == 0 def test_min_cost_more_candidates_than_workers(): assert min_cost_to_hire_workers([6, 5, 4, 3], 2, 5) == 7 def test_min_cost_single_worker(): assert min_cost_to_hire_workers([10], 1, 1) == 10","solution":"import heapq def min_cost_to_hire_workers(costs, k, candidates): Returns the minimum total cost to hire exactly k workers. :param costs: List[int] representing the cost of hiring the i-th worker. :param k: int, the number of workers to hire. :param candidates: int, the number of candidates from the beginning and end to interview. :return: int, the minimum total cost to hire exactly k workers. if k == 0 or not costs: return 0 min_heap = [] left_candidates = min(len(costs), candidates) right_candidates = min(len(costs), candidates) for i in range(left_candidates): heapq.heappush(min_heap, (costs[i], i)) for j in range(len(costs) - right_candidates, len(costs)): heapq.heappush(min_heap, (costs[j], j)) total_cost = 0 hired = 0 hired_indices = set() while hired < k: cost, idx = heapq.heappop(min_heap) if idx not in hired_indices: total_cost += cost hired += 1 hired_indices.add(idx) if idx < left_candidates and left_candidates < len(costs): heapq.heappush(min_heap, (costs[left_candidates], left_candidates)) left_candidates += 1 elif idx >= len(costs) - right_candidates and len(costs) - right_candidates > 0: right_candidates -= 1 if right_candidates > 0: heapq.heappush(min_heap, (costs[len(costs) - right_candidates - 1], len(costs) - right_candidates - 1)) return total_cost"},{"question":"def max_length_subarray(nums: List[int], target: int) -> int: Returns the maximum length of a contiguous subarray whose sum is less than or equal to target. If there is no such subarray, returns 0. pass def test_max_length_normal_case(): assert max_length_subarray([1, 2, 3, 4, 5], 11) == 4 # [1,2,3,4] def test_max_length_small_target(): assert max_length_subarray([4, 2, 1, 7, 8], 5) == 2 # [2,1] def test_max_length_large_target(): assert max_length_subarray([1, 2, 3, 4, 5], 15) == 5 # [1,2,3,4,5] def test_max_length_no_valid_subarray(): assert max_length_subarray([10, 20, 30], 5) == 0 # No valid subarray def test_max_length_single_element_less_than_target(): assert max_length_subarray([3, 1, 2, 1], 4) == 3 # [1,2,1] def test_max_length_all_elements_equal_to_target(): assert max_length_subarray([5, 5, 5, 5], 5) == 1 # [5] def test_max_length_multiple_possible_subarrays(): assert max_length_subarray([1, 4, 2, 3, 5, 2], 8) == 3 # [2,3,3]","solution":"def max_length_subarray(nums, target): Returns the maximum length of a contiguous subarray whose sum is less than or equal to target. If there is no such subarray, returns 0. n = len(nums) max_len = 0 current_sum = 0 start = 0 # Start index of the current subarray for end in range(n): current_sum += nums[end] while current_sum > target and start <= end: current_sum -= nums[start] start += 1 if current_sum <= target: max_len = max(max_len, end - start + 1) return max_len"},{"question":"def contains_nearby_duplicate(nums, k): Checks if there are two distinct indices i and j in the array \`nums\` such that nums[i] == nums[j] and the absolute difference between i and j is at most \`k\`. Parameters: nums (list of int): The list of integers. k (int): The maximum allowed index difference. Returns: bool: True if such pair of indices exist, False otherwise. >>> contains_nearby_duplicate([1, 2, 3, 1], 3) True >>> contains_nearby_duplicate([1, 0, 1, 1], 1) True >>> contains_nearby_duplicate([1, 2, 3, 4], 1) False >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) False >>> contains_nearby_duplicate([], 0) False >>> contains_nearby_duplicate([1], 0) False >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 10) True >>> contains_nearby_duplicate([1, 2, 3, 1], 0) False","solution":"def contains_nearby_duplicate(nums, k): Checks if there are two distinct indices i and j in the array \`nums\` such that nums[i] == nums[j] and the absolute difference between i and j is at most \`k\`. Parameters: nums (list of int): The list of integers. k (int): The maximum allowed index difference. Returns: bool: True if such pair of indices exist, False otherwise. num_index_map = {} for index, num in enumerate(nums): if num in num_index_map and index - num_index_map[num] <= k: return True num_index_map[num] = index return False"},{"question":"def max_heat_wave_length(temperatures): Returns the maximum length of any heat wave found in the array of temperatures. A heat wave is defined as a consecutive sequence of days where each day's temperature is strictly higher than the previous day's. If no heat wave exists, returns 0. >>> max_heat_wave_length([]) == 0 >>> max_heat_wave_length([5]) == 0 >>> max_heat_wave_length([5, 5, 5, 5]) == 0 >>> max_heat_wave_length([10, 9, 8, 7]) == 0 >>> max_heat_wave_length([1, 2, 3, 4, 5]) == 5 >>> max_heat_wave_length([3, 4, 5, 3]) == 3 >>> max_heat_wave_length([1, 2, 1, 2, 3, 1]) == 3 >>> max_heat_wave_length([5, 6, 1, 2, 3, 4, 1, 2, 3]) == 4 >>> max_heat_wave_length([1, 2]) == 2 >>> max_heat_wave_length([1, 2, 2, 3, 4]) == 3 >>> max_heat_wave_length([1, 2, 3, 3, 4, 5]) == 3","solution":"def max_heat_wave_length(temperatures): Returns the maximum length of any heat wave found in the array of temperatures. A heat wave is defined as a consecutive sequence of days where each day's temperature is strictly higher than the previous day's. If no heat wave exists, returns 0. if not temperatures: return 0 max_length = 0 current_length = 0 for i in range(1, len(temperatures)): if temperatures[i] > temperatures[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 # Add 1 because the heat wave length includes the starting day return max_length + 1 if max_length > 0 else 0"},{"question":"def submatrix_sum_target(matrix, target): Determines if there is a sub-matrix with a sum equal to the target. Args: matrix: List of lists of integers, representing the 2D grid. target: Integer, the target sum for the sub-matrix. Returns: A boolean indicating whether a sub-matrix exists with sum equal to the target.","solution":"def submatrix_sum_target(matrix, target): Determines if there is a sub-matrix with a sum equal to the target. Args: matrix: List of lists of integers, representing the 2D grid. target: Integer, the target sum for the sub-matrix. Returns: A boolean indicating whether a sub-matrix exists with sum equal to the target. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) for left in range(cols): row_sum = [0] * rows for right in range(left, cols): for i in range(rows): row_sum[i] += matrix[i][right] if find_subarray_with_sum(row_sum, target): return True return False def find_subarray_with_sum(array, target): Helper function to find if there is a contiguous subarray with a sum equals to target. Args: array: List of integers. target: Integer, the target sum for the subarray. Returns: A boolean indicating whether a subarray exists with sum equal to the target. current_sum = 0 sum_dict = {0: -1} for i, num in enumerate(array): current_sum += num if current_sum - target in sum_dict: return True if current_sum not in sum_dict: sum_dict[current_sum] = i return False"},{"question":"from typing import List def uncompress(S: str) -> str: Uncompresses a given compressed string S where consecutive repeated characters are represented as the character followed by the number of repetitions. >>> uncompress(\\"a3b2\\") 'aaabb' >>> uncompress(\\"abcd\\") 'abcd' >>> uncompress(\\"a3b1c2\\") 'aaabcc' >>> uncompress(\\"a1\\") 'a' >>> uncompress(\\"a10\\") 'aaaaaaaaaa' >>> uncompress(\\"\\") '' >>> uncompress(\\"abcdef\\") 'abcdef' >>> uncompress(\\"x3y4z2x5\\") 'xxxyyyyzzxxxxx' >>> uncompress(\\"a15\\") 'aaaaaaaaaaaaaaa'","solution":"def uncompress(S): Uncompresses a given compressed string S. Args: S (str): Compressed string where consecutive repeated characters are represented as the character followed by the number of repetitions. Returns: str: The uncompressed string. result = [] i = 0 length = len(S) while i < length: char = S[i] i += 1 count = 0 while i < length and S[i].isdigit(): count = count * 10 + int(S[i]) i += 1 if count == 0: result.append(char) else: result.append(char * count) return ''.join(result)"},{"question":"def find_optimal_task_pairs(tasks, target): Finds the optimal pairing of tasks such that the sum of the times of the tasks in each pair is as close as possible to the target. Parameters: tasks (list): A list of integers where tasks[i] is the time in minutes required to complete the i-th task. target (int): The target sum of the times. Returns: list: A list of pairs of indices representing the tasks, where each pair is as close as possible to the target sum. >>> find_optimal_task_pairs([1, 3, 4, 6], 5) [(0, 2), (1, 3)] >>> find_optimal_task_pairs([1, 2, 3, 4], 5) [(0, 3), (1, 2)] >>> find_optimal_task_pairs([2, 3, 5, 8], 10) [(0, 3), (1, 2)] >>> find_optimal_task_pairs([1], 5) [] >>> find_optimal_task_pairs([2, 2, 2, 2], 4) [(0, 1), (2, 3)] pass","solution":"def find_optimal_task_pairs(tasks, target): Finds the optimal pairing of tasks such that the sum of the times of the tasks in each pair is as close as possible to the target. Parameters: tasks (list): A list of integers where tasks[i] is the time in minutes required to complete the i-th task. target (int): The target sum of the times. Returns: list: A list of pairs of indices representing the tasks, where each pair is as close as possible to the target sum. n = len(tasks) indices = list(range(n)) indices.sort(key=lambda i: tasks[i]) # Sort indices based on the tasks' values result = [] used = [False] * n # To keep track of used tasks for i in range(n): if used[i]: continue min_diff = float('inf') best_pair = None for j in range(i + 1, n): if used[j]: continue sum_pair = tasks[indices[i]] + tasks[indices[j]] diff = abs(sum_pair - target) if diff < min_diff: min_diff = diff best_pair = j if best_pair is not None: used[i] = True used[best_pair] = True result.append((indices[i], indices[best_pair])) return result"},{"question":"from typing import List def find_concatenation_substrings(s: str, words: List[str]) -> List[int]: Find and return all unique substrings in \`s\` that are concatenations of each word in \`words\` exactly once and without any intervening characters. The order of the words in \`words\` does not matter. The input strings are lowercase English letters. >>> find_concatenation_substrings(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) [0, 9] >>> find_concatenation_substrings(\\"wordwordword\\", [\\"word\\"]) [0, 4, 8] >>> find_concatenation_substrings(\\"barfoothefoobarman\\", [\\"foo\\", \\"baz\\"]) [] >>> find_concatenation_substrings(\\"wordgoodgoodgoodbestword\\", [\\"word\\",\\"good\\",\\"best\\",\\"word\\"]) [] >>> find_concatenation_substrings(\\"ab\\", []) [] pass def test_example_case(): assert find_concatenation_substrings(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) == [0, 9] def test_single_word(): assert find_concatenation_substrings(\\"wordwordword\\", [\\"word\\"]) == [0, 4, 8] def test_no_substring_match(): assert find_concatenation_substrings(\\"barfoothefoobarman\\", [\\"foo\\", \\"baz\\"]) == [] def test_partial_overlap(): assert find_concatenation_substrings(\\"wordgoodgoodgoodbestword\\", [\\"word\\",\\"good\\",\\"best\\",\\"word\\"]) == [] def test_all_words_matched_disjoint(): assert find_concatenation_substrings(\\"wordgoodgoodbestword\\", [\\"word\\",\\"good\\",\\"best\\",\\"word\\"]) == [] def test_input_with_repeated_words(): assert find_concatenation_substrings(\\"wordgoodgoodgoodbestword\\", [\\"good\\",\\"good\\",\\"good\\",\\"best\\"]) == [4] def test_empty_string(): assert find_concatenation_substrings(\\"\\", [\\"a\\", \\"b\\"]) == [] def test_empty_words(): assert find_concatenation_substrings(\\"abababab\\", []) == [] def test_both_empty(): assert find_concatenation_substrings(\\"\\", []) == []","solution":"from typing import List from collections import Counter def find_concatenation_substrings(s: str, words: List[str]) -> List[int]: if not s or not words: return [] word_length = len(words[0]) total_length = len(words) * word_length word_count = Counter(words) result_indices = [] for i in range(len(s) - total_length + 1): seen_words = {} j = i while j < i + total_length: word = s[j:j + word_length] if word in word_count: seen_words[word] = seen_words.get(word, 0) + 1 if seen_words[word] > word_count[word]: break else: break j += word_length if seen_words == word_count: result_indices.append(i) return result_indices"},{"question":"def count_water_receiving_buildings(heights): Returns the count of buildings that can collect water from their neighbors given the constraints. >>> count_water_receiving_buildings([]) == 0 >>> count_water_receiving_buildings([1]) == 0 >>> count_water_receiving_buildings([1, 2]) == 0 >>> count_water_receiving_buildings([1, 2, 3]) == 0 >>> count_water_receiving_buildings([2, 1, 2]) == 1 >>> count_water_receiving_buildings([3, 1, 2, 1, 3]) == 2 >>> count_water_receiving_buildings([1, 2, 3, 4, 5]) == 0 >>> count_water_receiving_buildings([5, 1, 2, 1, 2, 1, 5]) == 3","solution":"def count_water_receiving_buildings(heights): Returns the count of buildings that can collect water from their neighbors given the constraints. if len(heights) < 3: return 0 count = 0 for i in range(1, len(heights) - 1): if heights[i] < heights[i - 1] and heights[i] < heights[i + 1]: count += 1 return count"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Determines if the string s can be rearranged to form a palindrome. A string can be rearranged into a palindrome if and only if at most one character occurs an odd number of times. Parameters: s (str): A non-empty string consisting of lowercase English letters. Returns: bool: True if s can be rearranged to form a palindrome, False otherwise.","solution":"from collections import Counter def can_form_palindrome(s): Determines if the string s can be rearranged to form a palindrome. A string can be rearranged into a palindrome if and only if at most one character occurs an odd number of times. Parameters: s (str): A non-empty string consisting of lowercase English letters. Returns: bool: True if s can be rearranged to form a palindrome, False otherwise. # Count the occurrences of each character in the string char_count = Counter(s) # Count how many characters have an odd number of occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # There can be at most one odd count for the string to be rearranged into a palindrome return odd_count <= 1"},{"question":"def minCostToPaintBuildings(cost: List[List[int]]) -> int: Calculate the minimum cost to paint all the buildings such that no two adjacent buildings have the same color. Each building can be painted in one of three colors: Red, Green, or Blue. The cost of painting each building with a specific color is given as a cost matrix. Args: cost (List[List[int]]): A matrix where cost[i][0], cost[i][1], and cost[i][2] are the costs of painting building i with color Red, Green, and Blue respectively. Returns: int: The minimum cost to paint all buildings under the given constraints. >>> minCostToPaintBuildings([[17, 2, 17]]) 2 >>> minCostToPaintBuildings([[1, 2, 3], [1, 2, 3]]) 3 >>> minCostToPaintBuildings([[17, 2, 17], [16, 16, 5], [14, 3, 19]]) 10 >>> minCostToPaintBuildings([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 3 >>> minCostToPaintBuildings([]) 0","solution":"def minCostToPaintBuildings(cost): if not cost: return 0 n = len(cost) # Initialize the first row prev_red, prev_green, prev_blue = cost[0] # Iterate over each building from the second one to the last one for i in range(1, n): curr_red = cost[i][0] + min(prev_green, prev_blue) curr_green = cost[i][1] + min(prev_red, prev_blue) curr_blue = cost[i][2] + min(prev_red, prev_green) # Update for the next iteration prev_red, prev_green, prev_blue = curr_red, curr_green, curr_blue # The minimum cost would be the minimum of painting the last building in any of the three colors return min(prev_red, prev_green, prev_blue)"},{"question":"def longest_common_substring_length(a: str, b: str) -> int: Returns the length of the longest common substring of a and b. >>> longest_common_substring_length(\\"abcde\\", \\"abfce\\") == 2 >>> longest_common_substring_length(\\"abcde\\", \\"fghij\\") == 0 >>> longest_common_substring_length(\\"abcdef\\", \\"abcdef\\") == 6 >>> longest_common_substring_length(\\"abcdef\\", \\"cdefgh\\") == 4 >>> longest_common_substring_length(\\"a\\", \\"a\\") == 1 >>> longest_common_substring_length(\\"a\\", \\"b\\") == 0 >>> longest_common_substring_length(\\"abcdefgh\\", \\"xyzabcvo\\") == 3","solution":"def longest_common_substring_length(a, b): Returns the length of the longest common substring of a and b. n, m = len(a), len(b) dp = [[0] * (m + 1) for _ in range(n + 1)] max_length = 0 for i in range(1, n + 1): for j in range(1, m + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"def modify_string(s: str, k: int) -> str: Modify the string based on the given conditions. - Convert letters to uppercase. - Increment digits by k, wrapping around if necessary. Args: s (str): the input string consisting of lower-case letters and digits. k (int): the number to add to each digit. Returns: str: the modified string. >>> modify_string(\\"abc\\", 3) 'ABC' >>> modify_string(\\"123\\", 3) '456' >>> modify_string(\\"789\\", 3) '012' >>> modify_string(\\"a1b2\\", 5) 'A6B7' >>> modify_string(\\"9\\", 4) '3' >>> modify_string(\\"\\", 2) '' >>> modify_string(\\"5\\", 15) '0' >>> modify_string(\\"9\\", 100) '9'","solution":"def modify_string(s, k): Modify the string based on the given conditions. - Convert letters to uppercase. - Increment digits by k, wrapping around if necessary. Args: s (str): the input string consisting of lower-case letters and digits. k (int): the number to add to each digit. Returns: str: the modified string. result = [] for char in s: if char.isdigit(): new_digit = (int(char) + k) % 10 result.append(str(new_digit)) elif char.islower(): result.append(char.upper()) return \\"\\".join(result)"},{"question":"from typing import List def maxProfit(prices: List[int]) -> int: Returns the maximum profit possible from buying and then selling a stock. :param prices: List[int] - A list of stock prices on different days. :return: int - Maximum profit possible. If no profit is possible, returns 0. >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([3, 3, 3, 3]) 0 >>> maxProfit([1, 2]) 1 >>> maxProfit([2, 1]) 0 >>> maxProfit([2, 6]) 4 >>> maxProfit([2, 6, 5, 1, 3, 4, 8]) 7","solution":"from typing import List def maxProfit(prices: List[int]) -> int: Returns the maximum profit possible from buying and then selling a stock. :param prices: List[int] - List of stock prices on different days. :return: int - Maximum profit possible. If no profit is possible, returns 0. # Initialize variables to keep track of minimum price and maximum profit min_price = float('inf') max_profit = 0 # Iterate through each price in the list for price in prices: # Update the minimum price if the current price is lower if price < min_price: min_price = price # Calculate potential profit if sold at the current price profit = price - min_price # Update maximum profit if the current profit is higher if profit > max_profit: max_profit = profit return max_profit"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: def __init__(self, root: TreeNode): self.root = root def rangeSumBST(self, low: int, high: int) -> int: Returns the sum of values of all nodes with a value in the range [low, high], inclusive, in a given binary search tree. >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(7) >>> root.right.right = TreeNode(18) >>> solution = Solution(root) >>> solution.rangeSumBST(7, 15) 32 >>> solution.rangeSumBST(5, 10) 22 >>> solution.rangeSumBST(10, 18) 43 >>> solution.rangeSumBST(3, 7) 15 >>> root_single = TreeNode(10) >>> solution_single = Solution(root_single) >>> solution_single.rangeSumBST(5, 15) 10 >>> solution_single.rangeSumBST(10, 10) 10 >>> solution_single.rangeSumBST(0, 9) 0 >>> solution_empty = Solution(None) >>> solution_empty.rangeSumBST(1, 10) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: def __init__(self, root: TreeNode): self.root = root def rangeSumBST(self, low: int, high: int) -> int: def dfs(node): if not node: return 0 if node.val < low: return dfs(node.right) if node.val > high: return dfs(node.left) return node.val + dfs(node.left) + dfs(node.right) return dfs(self.root)"},{"question":"def merge_alternately(word1: str, word2: str) -> str: Merge two strings by interleaving their characters. If the lengths of the strings are different, append the remaining characters of the longer string to the result. >>> merge_alternately(\\"abc\\", \\"def\\") \\"adbecf\\" >>> merge_alternately(\\"abcd\\", \\"ef\\") \\"aebfcd\\" >>> merge_alternately(\\"ab\\", \\"cdef\\") \\"acbdef\\" >>> merge_alternately(\\"\\", \\"\\") \\"\\" >>> merge_alternately(\\"abc\\", \\"\\") \\"abc\\" >>> merge_alternately(\\"\\", \\"def\\") \\"def\\" >>> merge_alternately(\\"a\\", \\"bcdef\\") \\"abcdef\\" >>> merge_alternately(\\"ab\\", \\"cde\\") \\"acbde\\" >>> merge_alternately(\\"abcde\\", \\"fgh\\") \\"afbgchde\\"","solution":"def merge_alternately(word1, word2): Merge two strings by interleaving their characters. If the lengths of the strings are different, append the remaining characters of the longer string to the result. Parameters: word1 (str): The first string. word2 (str): The second string. Returns: str: The merged string. merged = [] i = 0 # Loop through both strings until the end of the shortest string while i < len(word1) and i < len(word2): merged.append(word1[i]) merged.append(word2[i]) i += 1 # Append any remaining characters from word1 if i < len(word1): merged.append(word1[i:]) # Append any remaining characters from word2 if i < len(word2): merged.append(word2[i:]) return ''.join(merged)"},{"question":"def count_occurrences(s: str, queries: List[Tuple[int, int, str]]) -> List[int]: Counts occurrences of a given character in a given substring for each query. Parameters: s (str): the input string consisting of lowercase English letters queries (list): a list of queries, each a triple (left, right, char) Returns: list: a list of integers where each integer is the result of each query >>> count_occurrences(\\"abcde\\", [(0, 4, 'a')]) [1] >>> count_occurrences(\\"abcde\\", [(0, 4, 'e')]) [1] >>> count_occurrences(\\"abcde\\", [(1, 3, 'b')]) [1] >>> count_occurrences(\\"abcde\\", [(1, 3, 'a')]) [0]","solution":"def count_occurrences(s, queries): Counts occurrences of a given character in a given substring for each query. Parameters: s (str): the input string consisting of lowercase English letters queries (list): a list of queries, each a triple (left, right, char) Returns: list: a list of integers where each integer is the result of each query results = [] for left, right, char in queries: results.append(s[left:right+1].count(char)) return results"},{"question":"def search_matrix(matrix, target): Searches for the target in a m x n matrix with sorted rows and columns. Returns the position [i, j] of the target if found, otherwise returns [-1, -1]. >>> search_matrix([ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ], 5) == [1, 1] >>> search_matrix([ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ], 20) == [-1, -1] >>> search_matrix([[5]], 5) == [0, 0] >>> search_matrix([[5]], 3) == [-1, -1] >>> search_matrix([], 1) == [-1, -1] >>> search_matrix([ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ], 19) == [3, 3]","solution":"def search_matrix(matrix, target): Searches for the target in a m x n matrix with sorted rows and columns. Returns the position [i, j] of the target if found, otherwise returns [-1, -1]. if not matrix: return [-1, -1] rows, cols = len(matrix), len(matrix[0]) # Start from the top-right corner of the matrix row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return [row, col] elif matrix[row][col] > target: col -= 1 else: row += 1 return [-1, -1]"},{"question":"def findWords(words: List[str]) -> List[str]: Returns the list of words that can be typed using letters of only one row of an American QWERTY keyboard. >>> findWords([\\"hello\\", \\"Alaska\\", \\"Dad\\", \\"peace\\"]) [\\"Alaska\\", \\"Dad\\"] >>> findWords([\\"qwerty\\", \\"asdf\\", \\"zxcvb\\"]) [\\"qwerty\\", \\"asdf\\", \\"zxcvb\\"] >>> findWords([\\"hello\\", \\"world\\", \\"python\\", \\"compile\\"]) [] >>> findWords([\\"Type\\", \\"Row\\", \\"Moon\\", \\"blue\\"]) [\\"Type\\", \\"Row\\"] >>> findWords([\\"QWERTYuiop\\", \\"ASDFghjkl\\", \\"Zxcvbnm\\"]) [\\"QWERTYuiop\\", \\"ASDFghjkl\\", \\"Zxcvbnm\\"]","solution":"def findWords(words): Returns the list of words that can be typed using letters of only one row of an American QWERTY keyboard. row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: lower_word = word.lower() if all(char in row1 for char in lower_word) or all(char in row2 for char in lower_word) or all(char in row3 for char in lower_word): result.append(word) return result"},{"question":"def min_moves_to_equal(nums): Returns the minimum number of moves required to make all elements of nums equal. >>> min_moves_to_equal([1, 2, 3]) == 2 >>> min_moves_to_equal([1, 10, 2, 9]) == 16 >>> min_moves_to_equal([1, 2, 3, 4, 5]) == 6 >>> min_moves_to_equal([5, 5, 5, 5, 5]) == 0 >>> min_moves_to_equal([4, 3, 4, 3, 4]) == 2 >>> min_moves_to_equal([1, 1, 1, 10]) == 9","solution":"def min_moves_to_equal(nums): Returns the minimum number of moves required to make all elements of nums equal. nums.sort() median = nums[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"def can_win_nim(piles: List[int]) -> bool: Determines if you can guarantee a win given the piles of stones. >>> can_win_nim([1]) True >>> can_win_nim([4]) False >>> can_win_nim([1, 2]) True >>> can_win_nim([1, 3]) False >>> can_win_nim([4, 1, 5, 6]) False >>> can_win_nim([7, 8, 9, 10]) True","solution":"def can_win_nim(piles): Determines if you can guarantee a win given the piles of stones. Parameters: piles (list of int): List of integers representing the number of stones in piles. Returns: bool: True if you can guarantee a win, False otherwise. # Calculate the total number of stones total_stones = sum(piles) # According to the Nim Game, you can guarantee a win if total number of stones is not multiple of 4 return total_stones % 4 != 0"},{"question":"def canTransformWithOneSwap(s1: str, s2: str) -> bool: Check if it is possible to transform s1 into s2 using exactly one swap between any two characters in s1. >>> canTransformWithOneSwap(\\"bank\\", \\"kanb\\") True >>> canTransformWithOneSwap(\\"attack\\", \\"defend\\") False >>> canTransformWithOneSwap(\\"abcd\\", \\"abdc\\") True","solution":"def canTransformWithOneSwap(s1, s2): if len(s1) != len(s2): return False diff = [] for i in range(len(s1)): if s1[i] != s2[i]: diff.append(i) # If there are exactly two indices that are different if len(diff) == 2: i, j = diff # Check if swapping the characters at these two indices will result in s2 return (s1[i] == s2[j] and s1[j] == s2[i]) # If there are not exactly two differences, return False return False"},{"question":"import heapq from typing import List def network_delay_time(edges: List[List[int]], n: int, start: int, end: int) -> int: Find the minimum time required to transfer data from the start node to the end node. Returns -1 if it is impossible to transfer data between the two nodes. >>> network_delay_time([], 2, 0, 1) == -1 >>> network_delay_time([[0, 1, 4]], 2, 0, 1) == 4 >>> network_delay_time([[0, 1, 4], [0, 2, 1], [2, 1, 2], [1, 3, 1], [2, 3, 5]], 4, 0, 3) == 4 # 0 -> 2 -> 1 -> 3 >>> network_delay_time([[0, 1, 1], [1, 2, 1]], 4, 0, 3) == -1 >>> network_delay_time([[0, 1, 1], [1, 2, 1], [2, 3, 1]], 4, 0, 0) == 0 >>> network_delay_time([[0, 1, 3], [0, 2, 1], [1, 2, 1], [1, 3, 6], [2, 3, 2], [3, 4, 1], [4, 5, 4]], 6, 0, 5) == 8 # 0 -> 2 -> 3 -> 4 -> 5","solution":"import heapq def network_delay_time(edges, n, start, end): Finds the minimum time required to transfer data from the start node to the end node. Returns -1 if it is impossible to transfer data between the two nodes. # Create an adjacency list representation of the graph graph = {i: [] for i in range(n)} for u, v, time in edges: graph[u].append((v, time)) graph[v].append((u, time)) # Use Dijkstra's algorithm to find the shortest path pq = [(0, start)] # Priority queue to store (time, node) pairs min_time = {i: float('inf') for i in range(n)} min_time[start] = 0 while pq: current_time, node = heapq.heappop(pq) if node == end: return current_time if current_time > min_time[node]: continue for neighbor, time in graph[node]: new_time = current_time + time if new_time < min_time[neighbor]: min_time[neighbor] = new_time heapq.heappush(pq, (new_time, neighbor)) return -1 if min_time[end] == float('inf') else min_time[end]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root, sumValue): Finds the number of paths that sum to a given value in the binary tree. Args: root (TreeNode): The root of the binary tree. sumValue (int): The target sum for the paths. Returns: int: Number of paths summing to the target value, modulo 10^9 + 7. pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right from collections import defaultdict def pathSum(root, sumValue): Finds the number of paths that sum to a given value in the binary tree. Args: root (TreeNode): The root of the binary tree. sumValue (int): The target sum for the paths. Returns: int: Number of paths summing to the target value, modulo 10^9 + 7. MOD = 10**9 + 7 def dfs(node, target): if not node: return 0 def count_paths_from_node(node, accumulated_sum): if not node: return 0 accumulated_sum += node.val return (accumulated_sum == target) + count_paths_from_node(node.left, accumulated_sum) + count_paths_from_node(node.right, accumulated_sum) return count_paths_from_node(node, 0) + dfs(node.left, target) + dfs(node.right, target) return dfs(root, sumValue) % MOD"},{"question":"def min_deletions_to_palindrome(s: str) -> int: Returns the minimum number of deletions required to make the string a palindrome. >>> min_deletions_to_palindrome('a') 0 >>> min_deletions_to_palindrome('aba') 0 >>> min_deletions_to_palindrome('abcdba') 1 >>> min_deletions_to_palindrome('abcdeca') 2 >>> min_deletions_to_palindrome('aaaa') 0 >>> min_deletions_to_palindrome('abcba') 0 >>> min_deletions_to_palindrome('abcdef') 5","solution":"def min_deletions_to_palindrome(s): Returns the minimum number of deletions required to make the string a palindrome. def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] lps_length = longest_palindromic_subsequence(s) return len(s) - lps_length"},{"question":"def is_cyclic(graph: List[List[int]]) -> bool: Determine if a directed graph contains a cycle. :param graph: adjacency list representation of the graph :return: True if there is a cycle in the graph, False otherwise >>> is_cyclic([[1], [2], [3], []]) False >>> is_cyclic([[0]]) True >>> is_cyclic([[1], [2], [0]]) True >>> is_cyclic([[1], [], [3], []]) False >>> is_cyclic([[1], [2], [0], [4], []]) True >>> is_cyclic([[1, 2], [2], []]) False >>> is_cyclic([[1, 2], [2, 3], [3], [0]]) True","solution":"def is_cyclic(graph): Function to detect if a directed graph contains a cycle. :param graph: adjacency list representation of the graph :return: True if there is a cycle in the graph, False otherwise def dfs(vertex): if rec_stack[vertex]: return True if visited[vertex]: return False visited[vertex] = True rec_stack[vertex] = True for neighbor in graph[vertex]: if dfs(neighbor): return True rec_stack[vertex] = False return False n = len(graph) visited = [False] * n rec_stack = [False] * n for node in range(n): if not visited[node]: if dfs(node): return True return False"},{"question":"class RangeFreqQuery: def __init__(self, nums): Initializes the RangeFreqQuery object with the integer array nums. def query(self, left, right, value): Returns the frequency of value in the subarray defined by the indices [left, right] (both inclusive). import pytest def test_query_basic(): obj = RangeFreqQuery([1, 4, 2, 4, 4, 3, 1]) assert obj.query(1, 5, 4) == 3 def test_query_non_existent_value(): obj = RangeFreqQuery([1, 4, 2, 4, 4, 3, 1]) assert obj.query(1, 5, 5) == 0 def test_query_single_element_range(): obj = RangeFreqQuery([1, 4, 2, 4, 4, 3, 1]) assert obj.query(3, 3, 4) == 1 def test_query_value_outside_range(): obj = RangeFreqQuery([1, 4, 2, 4, 4, 3, 1]) assert obj.query(1, 2, 4) == 1 def test_query_entire_array(): obj = RangeFreqQuery([1, 4, 2, 4, 4, 3, 1]) assert obj.query(0, 6, 4) == 3 assert obj.query(0, 6, 1) == 2 def test_query_empty_array(): obj = RangeFreqQuery([]) assert obj.query(0, 0, 1) == 0","solution":"class RangeFreqQuery: def __init__(self, nums): Initializes the RangeFreqQuery object with the integer array nums. self.nums = nums self.freq_map = {} for idx, num in enumerate(nums): if num not in self.freq_map: self.freq_map[num] = [] self.freq_map[num].append(idx) def query(self, left, right, value): Returns the frequency of value in the subarray defined by the indices [left, right] (both inclusive). if value not in self.freq_map: return 0 indices = self.freq_map[value] count = 0 for idx in indices: if left <= idx <= right: count += 1 return count"},{"question":"def longestTrainingSegment(intensities: List[int]) -> int: Returns the length of the longest continuous segment of days with strictly increasing or strictly decreasing practice intensities. >>> longestTrainingSegment([1, 2, 3, 4, 5]) 5 >>> longestTrainingSegment([5, 4, 3, 2, 1]) 5 >>> longestTrainingSegment([1, 3, 5, 2, 4, 6]) 3 >>> longestTrainingSegment([5]) 1 >>> longestTrainingSegment([]) 0 >>> longestTrainingSegment([2, 2, 2, 2]) 1 >>> longestTrainingSegment([1, 2, 3, 2, 1, 2, 3, 1]) 3","solution":"from typing import List def longestTrainingSegment(intensities: List[int]) -> int: if not intensities: return 0 max_length = 1 current_length = 1 increasing = None for i in range(1, len(intensities)): if intensities[i] == intensities[i - 1]: current_length = 1 increasing = None elif intensities[i] > intensities[i - 1]: if increasing is None or increasing: current_length += 1 else: current_length = 2 increasing = True else: if increasing is None or not increasing: current_length += 1 else: current_length = 2 increasing = False if current_length > max_length: max_length = current_length return max_length"},{"question":"from typing import List def maxProfitWithTwoTransactions(prices: List[int]) -> int: Determine the maximum profit achievable from at most two transactions given a list of daily stock prices. >>> maxProfitWithTwoTransactions([5]) 0 >>> maxProfitWithTwoTransactions([7, 6, 4, 3, 1]) 0 >>> maxProfitWithTwoTransactions([1, 2, 3, 4, 5]) 4 >>> maxProfitWithTwoTransactions([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> maxProfitWithTwoTransactions([1, 2, 4, 2, 5, 7, 2, 4, 9, 0]) 13 pass","solution":"from typing import List def maxProfitWithTwoTransactions(prices: List[int]) -> int: if len(prices) < 2: return 0 # Initialize variables to store the maximum profit up to each day with one and two transactions. n = len(prices) max_profit_one_transaction = [0] * n max_profit_two_transactions = [0] * n # Forward phase: compute max profit for one transaction up to day i. min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) max_profit_one_transaction[i] = max(max_profit_one_transaction[i-1], prices[i] - min_price) # Backward phase: compute max profit for two transactions. max_price = prices[-1] for i in range(n-2, -1, -1): max_price = max(max_price, prices[i]) max_profit_two_transactions[i] = max(max_profit_two_transactions[i+1], max_price - prices[i] + max_profit_one_transaction[i]) return max(max_profit_two_transactions)"},{"question":"def rob(nums: List[int]) -> int: Returns the maximum amount of money that can be robbed without alerting the police by robbing two adjacent houses. >>> rob([2, 3, 2]) 3 >>> rob([1, 2, 3, 1]) 4 >>> rob([]) 0 >>> rob([5]) 5 >>> rob([2, 3]) 3 >>> rob([1, 2, 3, 4, 5, 6]) 12 >>> rob([10, 10, 10, 10]) 20","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without robbing two adjacent houses. if not nums: return 0 if len(nums) == 1: return nums[0] def rob_linear(houses): prev, curr = 0, 0 for money in houses: prev, curr = curr, max(curr, prev + money) return curr return max(rob_linear(nums[1:]), rob_linear(nums[:-1]))"},{"question":"def decodeString(s: str) -> str: Decode the encoded string according to the given encoding rule. The encoding rule is k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. :param s: str :return: decoded string after applying the encoding rule pass # Test cases def test_simple_case(): assert decodeString(\\"3[a]2[bc]\\") == \\"aaabcbc\\" def test_nested_case(): assert decodeString(\\"3[a2[c]]\\") == \\"accaccacc\\" def test_longer_pattern(): assert decodeString(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" def test_multiple_nested_brackets(): assert decodeString(\\"3[a2[b4[F]c]]\\") == \\"abFFFFcbFFFFcabFFFFcbFFFFcabFFFFcbFFFFc\\" def test_single_character(): assert decodeString(\\"1[a]\\") == \\"a\\" def test_no_repetition(): assert decodeString(\\"a\\") == \\"a\\"","solution":"def decodeString(s): Decode the encoded string according to the given encoding rule. The encoding rule is k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. :param s: str :return: decoded string after applying the encoding rule stack = [] current_num = 0 current_string = '' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': # Push the current number and string to the stack stack.append((current_string, current_num)) # Reset the current string and number current_string = '' current_num = 0 elif char == ']': # Pop from the stack and repeat the current_string last_string, repeat_num = stack.pop() current_string = last_string + current_string * repeat_num else: current_string += char return current_string"},{"question":"def getFirstAction(logs: List[str]) -> Dict[str, int]: Returns the earliest action time for each user from the logs. Args: logs (list): List of logs in the \\"user_id action timestamp\\" format. Returns: dict: A dictionary where the keys are user_ids and the values are the timestamps of the first actions. Examples: >>> getFirstAction([\\"user1 login 100\\"]) {'user1': 100} >>> getFirstAction([\\"user1 login 100\\", \\"user1 logout 200\\", \\"user1 update 50\\"]) {'user1': 50} >>> getFirstAction([\\"user1 login 100\\", \\"user2 login 200\\", \\"user3 login 50\\"]) {'user1': 100, 'user2': 200, 'user3': 50} >>> getFirstAction([\\"user1 login 100\\", \\"user2 login 200\\", \\"user3 login 50\\", \\"user1 logout 150\\", \\"user2 update 180\\", \\"user3 logout 30\\"]) {'user1': 100, 'user2': 180, 'user3': 30} >>> getFirstAction([\\"user1 login 100\\", \\"user2 login 100\\", \\"user3 login 50\\"]) {'user1': 100, 'user2': 100, 'user3': 50} >>> getFirstAction([\\"user1 login 100\\", \\"user3 login 50\\", \\"user1 logout 150\\", \\"user2 login 200\\", \\"user3 logout 20\\"]) {'user1': 100, 'user2': 200, 'user3': 20}","solution":"def getFirstAction(logs): Returns the earliest action time for each user from the logs. Args: logs (list): List of logs in the \\"user_id action timestamp\\" format. Returns: dict: A dictionary where the keys are user_ids and the values are the timestamps of the first actions. user_first_action = {} for log in logs: user_id, _, timestamp = log.split() timestamp = int(timestamp) if user_id not in user_first_action or timestamp < user_first_action[user_id]: user_first_action[user_id] = timestamp return user_first_action"},{"question":"def can_transform_by_reversing_substring(s: str, t: str) -> bool: Determines if string s can be transformed into string t by reversing any one of its substrings exactly once. >>> can_transform_by_reversing_substring(\\"abc\\", \\"abc\\") True >>> can_transform_by_reversing_substring(\\"abc\\", \\"acb\\") True >>> can_transform_by_reversing_substring(\\"abc\\", \\"def\\") False >>> can_transform_by_reversing_substring(\\"abcdef\\", \\"fedcba\\") True >>> can_transform_by_reversing_substring(\\"abcdef\\", \\"abfedc\\") True >>> can_transform_by_reversing_substring(\\"abcdef\\", \\"abcfed\\") True >>> can_transform_by_reversing_substring(\\"abcdef\\", \\"abfcde\\") False >>> can_transform_by_reversing_substring(\\"abc\\", \\"abcd\\") False","solution":"def can_transform_by_reversing_substring(s, t): Determines if string s can be transformed into string t by reversing any one of its substrings exactly once. if s == t: return True len_s = len(s) # If lengths are not the same, no transformation is possible if len_s != len(t): return False # Try reversing every possible substring in s and see if any of them match t for i in range(len_s): for j in range(i+1, len_s+1): reversed_substring = s[:i] + s[i:j][::-1] + s[j:] if reversed_substring == t: return True return False"},{"question":"from typing import List def max_supplies_allocation(supplies: List[int], capacity: List[int]) -> int: Allocate the maximum number of supplies among friends such that no friend carries more than their maximum capacity. >>> max_supplies_allocation([1, 2, 3], [3, 5, 6]) 3 >>> max_supplies_allocation([4, 5, 6], [3, 8, 9]) 2 >>> max_supplies_allocation([7, 8, 9], [1, 2, 3]) 0 >>> max_supplies_allocation([], [1, 2, 3]) 0 >>> max_supplies_allocation([1, 2, 3], []) 0 >>> max_supplies_allocation([1, 2], [1, 3, 5]) 2 >>> max_supplies_allocation([1, 2, 3, 4], [3, 5]) 2","solution":"from typing import List def max_supplies_allocation(supplies: List[int], capacity: List[int]) -> int: supplies.sort() capacity.sort() supply_pointer, capacity_pointer = 0, 0 allocated_supplies = 0 while supply_pointer < len(supplies) and capacity_pointer < len(capacity): if supplies[supply_pointer] <= capacity[capacity_pointer]: allocated_supplies += 1 supply_pointer += 1 capacity_pointer += 1 return allocated_supplies"},{"question":"def max_area(height): Calculate the maximum amount of water a container can store given the heights of the columns. :param height: List[int], heights of the columns :return: int, maximum amount of water that can be stored >>> max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 >>> max_area([1, 1]) == 1 >>> max_area([4, 3, 2, 1, 4]) == 16 >>> max_area([1, 2, 1]) == 2 >>> max_area([1, 2, 4, 3]) == 4 >>> max_area([1, 3, 2, 5, 25, 24, 5]) == 24 >>> max_area([]) == 0 >>> max_area([5]) == 0 >>> max_area([5, 5, 5, 5]) == 15 >>> max_area([3, 3, 3]) == 6 >>> max_area([1, 2, 3, 4, 5]) == 6 >>> max_area([5, 4, 3, 2, 1]) == 6","solution":"def max_area(height): Calculate the maximum amount of water a container can store given the heights of the columns. :param height: List[int], heights of the columns :return: int, maximum amount of water that can be stored left = 0 right = len(height) - 1 max_water = 0 while left < right: # Calculate the height and width of the container. current_height = min(height[left], height[right]) current_width = right - left # Calculate the current water amount and update max_water if it's greater current_water = current_height * current_width max_water = max(max_water, current_water) # Move the pointers based on which height is shorter if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"from typing import List def valid_move(grid: List[List[int]], x: int, y: int, next_x: int, next_y: int, target: int) -> bool: Checks if the move from (x, y) to (next_x, next_y) is valid given the target elevation difference. def shortest_path(grid: List[List[int]], target: int) -> int: Finds the length of the shortest path from the top-left to the bottom-right corner, considering the target elevation difference. If such a path does not exist, returns -1. >>> grid = [ ... [1, 3, 5], ... [2, 8, 3], ... [6, 2, 1] ... ] >>> shortest_path(grid, 3) 4 >>> grid = [ ... [1, 10, 1], ... [10, 10, 10], ... [1, 10, 1] ... ] >>> shortest_path(grid, 2) -1 >>> grid = [[0]] >>> shortest_path(grid, 5) 0 >>> grid = [ ... [1, 2] ... ] >>> shortest_path(grid, 1) 1 >>> shortest_path(grid, 0) -1 >>> shortest_path(grid, 10) 4 >>> grid = [ ... [1, 100, 1], ... [100, 100, 100], ... [1, 100, 1] ... ] >>> shortest_path(grid, 2) -1","solution":"from collections import deque import sys def valid_move(grid, x, y, next_x, next_y, target): Checks if the move from (x, y) to (next_x, next_y) is valid given the target elevation difference. if 0 <= next_x < len(grid) and 0 <= next_y < len(grid[0]) and abs(grid[next_x][next_y] - grid[x][y]) <= target: return True return False def shortest_path(grid, target): Finds the length of the shortest path from the top-left to the bottom-right corner, considering the target elevation difference. If such a path does not exist, returns -1. if not grid: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0,1), (1,0), (0,-1), (-1,0)] # right, down, left, up queue = deque([(0, 0, 0)]) # (x, y, distance) visited = {(0, 0)} while queue: x, y, dist = queue.popleft() if x == rows - 1 and y == cols - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if valid_move(grid, x, y, nx, ny, target) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def is_subsequence(s: str, words: List[str]) -> List[bool]: Determines if each word in words is a subsequence of the string s. Parameters: s (str): The source string. words (list of str): List of words to check. Returns: list: A list of booleans indicating if each word is a subsequence of s. >>> is_subsequence(\\"abcde\\", [\\"ace\\"]) [True] >>> is_subsequence(\\"abcde\\", [\\"aec\\"]) [False] >>> is_subsequence(\\"abcde\\", [\\"ace\\", \\"aec\\", \\"abcd\\"]) [True, False, True] >>> is_subsequence(\\"\\", [\\"a\\", \\"\\"]) [False, True] >>> is_subsequence(\\"abcde\\", [\\"\\"]) [True] >>> is_subsequence(\\"abcde\\", []) [] >>> is_subsequence(\\"abcde\\", [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\"]) [True, True, True, True, True] >>> is_subsequence(\\"abcde\\", [\\"f\\", \\"gh\\", \\"ijk\\"]) [False, False, False]","solution":"def is_subsequence(s, words): Determines if each word in words is a subsequence of the string s. Parameters: s (str): The source string. words (list of str): List of words to check. Returns: list: A list of booleans indicating if each word is a subsequence of s. def check_subsequence(word): it = iter(s) return all(char in it for char in word) return [check_subsequence(word) for word in words]"},{"question":"def min_operations_to_sort(nums: List[int]) -> int: Returns the minimum number of operations needed to sort the array in non-decreasing order. :param nums: List[int] :return: int >>> min_operations_to_sort([1, 2, 3, 4, 5]) 0 >>> min_operations_to_sort([5, 4, 3, 2, 1]) 1 >>> min_operations_to_sort([1, 3, 5, 4, 2, 6]) 1 >>> min_operations_to_sort([1, 3, 4, 2, 5, 6]) 1 >>> min_operations_to_sort([1]) 0 >>> min_operations_to_sort([2, 2, 2, 2, 2]) 0","solution":"def min_operations_to_sort(nums): Returns the minimum number of operations needed to sort the array in non-decreasing order. :param nums: List[int] :return: int n = len(nums) start = 0 end = n - 1 # Find the leftmost position where array is unsorted while start < n - 1 and nums[start] <= nums[start + 1]: start += 1 # If array is already sorted if start == n - 1: return 0 # Find the rightmost position where array is unsorted while end > 0 and nums[end] >= nums[end - 1]: end -= 1 # Check the minimum and maximum in the unsorted subarray subarray_min = min(nums[start:end+1]) subarray_max = max(nums[start:end+1]) # Extend the left boundary if needed while start > 0 and nums[start - 1] > subarray_min: start -= 1 # Extend the right boundary if needed while end < n - 1 and nums[end + 1] < subarray_max: end += 1 # Only one subarray reversal needed to sort the array return 1"},{"question":"def numDistinctIslands(grid: List[List[str]]) -> int: Return the number of distinct islands in the grid. An island is defined as a group of '1's (land) connected 4-directionally. An island is considered distinct if its shape is not identical to any other island. >>> numDistinctIslands([ ... ['1', '1', '0', '0'], ... ['1', '1', '0', '0'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'] ... ]) 1 >>> numDistinctIslands([ ... ['1', '1', '0', '1'], ... ['1', '0', '0', '0'], ... ['0', '0', '1', '1'], ... ['0', '0', '0', '1'] ... ]) 3 >>> numDistinctIslands([ ... ['1', '0', '0', '1'], ... ['1', '0', '0', '1'], ... ['0', '0', '0', '0'], ... ['1', '0', '0', '1'] ... ]) 2 >>> numDistinctIslands([ ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'] ... ]) 0 >>> numDistinctIslands([ ... ['1', '0', '1', '0'], ... ['1', '0', '1', '0'], ... ['0', '0', '0', '0'], ... ['1', '0', '1', '0'], ... ['1', '0', '1', '0'] ... ]) 1 pass","solution":"def numDistinctIslands(grid): def dfs(x, y, direction, shape): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == '0': return grid[x][y] = '0' shape.append(direction) dfs(x + 1, y, 'd', shape) # down dfs(x - 1, y, 'u', shape) # up dfs(x, y + 1, 'r', shape) # right dfs(x, y - 1, 'l', shape) # left shape.append('b') # backtrack unique_shapes = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': shape = [] dfs(i, j, 'o', shape) # start new island unique_shapes.add(tuple(shape)) return len(unique_shapes)"},{"question":"def min_operations_to_single_char(s: str) -> int: Return the minimum number of operations required to make the string contain only one distinct character. >>> min_operations_to_single_char(\\"abac\\") 2 >>> min_operations_to_single_char(\\"aaaa\\") 0 >>> min_operations_to_single_char(\\"abc\\") 2 >>> min_operations_to_single_char(\\"aabbcc\\") 4 >>> min_operations_to_single_char(\\"xyzxyz\\") 4 >>> min_operations_to_single_char(\\"a\\") 0 >>> min_operations_to_single_char(\\"aaabbbccc\\") 6 >>> min_operations_to_single_char(\\"abcabcabc\\") 6","solution":"def min_operations_to_single_char(s): Returns the minimum number of operations required to make the string contain only one distinct character. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Return the length of the string minus the frequency of the most common character return len(s) - max(freq.values())"},{"question":"def count_single_char_substrings(s: str) -> int: Returns the number of substrings that contain exactly one distinct character. >>> count_single_char_substrings(\\"a\\") 1 >>> count_single_char_substrings(\\"abc\\") 3 >>> count_single_char_substrings(\\"aaa\\") 6 >>> count_single_char_substrings(\\"aabbbcc\\") 12 >>> count_single_char_substrings(\\"\\") 0 >>> count_single_char_substrings(\\"aabbcc\\") 9","solution":"def count_single_char_substrings(s): Returns the number of substrings that contain exactly one distinct character. n = len(s) total_count = 0 i = 0 while i < n: j = i while j < n and s[j] == s[i]: j += 1 length = j - i total_count += length * (length + 1) // 2 i = j return total_count"},{"question":"import heapq from typing import List class KthLargest: Class to find the k-th largest element in a stream of integers. Initialization: >>> kth_largest = KthLargest(3, [4, 5, 8, 2]) Add elements and get the k-th largest: >>> kth_largest.add(3) 4 >>> kth_largest.add(5) 5 >>> kth_largest.add(10) 5 >>> kth_largest.add(9) 8 >>> kth_largest.add(4) 8 def __init__(self, k: int, nums: List[int]): Initializes the object with the integer k and the stream of integers nums. pass def add(self, val: int) -> int: Appends the integer val to the array and returns the k-th largest element in the array. pass","solution":"import heapq class KthLargest: def __init__(self, k, nums): self.k = k self.min_heap = nums heapq.heapify(self.min_heap) while len(self.min_heap) > k: heapq.heappop(self.min_heap) def add(self, val): heapq.heappush(self.min_heap, val) if len(self.min_heap) > self.k: heapq.heappop(self.min_heap) return self.min_heap[0]"},{"question":"def is_vowel_query(s: str, queries: List[int]) -> List[bool]: Returns a list of booleans indicating if the character at each index in queries is a vowel. Parameters: s (str): The input string. queries (list of int): List of indices in the string s to check. Returns: list of bool: True if the character at the index is a vowel, False otherwise. >>> is_vowel_query(\\"hello\\", [1]) [True] >>> is_vowel_query(\\"hello\\", [2]) [False] >>> is_vowel_query(\\"hello\\", [5, 8]} ]","solution":"def is_vowel_query(s, queries): Returns a list of booleans indicating if the character at each index in queries is a vowel. Parameters: s (str): The input string. queries (list of int): List of indices in the string s to check. Returns: list of bool: True if the character at the index is a vowel, False otherwise. vowels = {'a', 'e', 'i', 'o', 'u'} result = [] for index in queries: if index < len(s) and s[index] in vowels: result.append(True) else: result.append(False) return result"},{"question":"def max_length_subarray_after_one_flip(s: str) -> int: You are given a binary string 's' consisting of only '0's and '1's. You can flip at most one '0' to '1' or one '1' to '0'. Your task is to find the maximum length of a contiguous subarray of 1s or a contiguous subarray of 0s that can be obtained by performing this operation at most once. Return the length of such a subarray. >>> max_length_subarray_after_one_flip(\\"0000\\") 5 >>> max_length_subarray_after_one_flip(\\"1111\\") 5 >>> max_length_subarray_after_one_flip(\\"110100110\\") 4 >>> max_length_subarray_after_one_flip(\\"1010110111\\") 6 >>> max_length_subarray_after_one_flip(\\"1\\") 2 >>> max_length_subarray_after_one_flip(\\"0\\") 2 >>> max_length_subarray_after_one_flip(\\"110011101\\") 5","solution":"def max_length_subarray_after_one_flip(s): def max_length_simplified(s, target): max_length = count = prev_count = 0 for char in s: if char == target: count += 1 else: prev_count, count = count, 0 max_length = max(max_length, count + prev_count + 1) return max_length max_length_1s = max_length_simplified(s, '1') max_length_0s = max_length_simplified(s, '0') return max(max_length_1s, max_length_0s)"},{"question":"def min_operations_to_make_unique(arr): Returns the minimum number of operations required to make all elements in 'arr' distinct. >>> min_operations_to_make_unique([1, 2, 2]) == 1 >>> min_operations_to_make_unique([4, 5, 6, 6]) == 1 >>> min_operations_to_make_unique([1, 1, 1, 1]) == 6 >>> min_operations_to_make_unique([3, 2, 1]) == 0 >>> min_operations_to_make_unique([1, 2, 3, 4, 5]) == 0 >>> min_operations_to_make_unique([5, 5, 5, 10, 10, 10]) == 6 >>> min_operations_to_make_unique([]) == 0 >>> min_operations_to_make_unique([1]) == 0 >>> min_operations_to_make_unique([1000, 1000]) == 1 >>> min_operations_to_make_unique([0, 0, 0, 0, 0]) == 10","solution":"def min_operations_to_make_unique(arr): Returns the minimum number of operations required to make all elements in 'arr' distinct. if not arr: return 0 arr.sort() operations = 0 for i in range(1, len(arr)): if arr[i] <= arr[i-1]: needed = arr[i-1] - arr[i] + 1 arr[i] = arr[i-1] + 1 operations += needed return operations"},{"question":"def rotateMatrix(matrix): Rotates the given n x n 2D matrix by 90 degrees clockwise in-place. Parameters: matrix (List[List[int]]): The input n x n matrix representing the image. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotateMatrix(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] from solution import rotateMatrix def test_rotateMatrix_3x3(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotateMatrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def test_rotateMatrix_4x4(): matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotateMatrix(matrix) assert matrix == [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] def test_rotateMatrix_2x2(): matrix = [ [1, 2], [3, 4] ] rotateMatrix(matrix) assert matrix == [ [3, 1], [4, 2] ] def test_rotateMatrix_1x1(): matrix = [ [1] ] rotateMatrix(matrix) assert matrix == [ [1] ] def test_rotateMatrix_5x5(): matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] rotateMatrix(matrix) assert matrix == [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ]","solution":"def rotateMatrix(matrix): Rotates the given n x n 2D matrix by 90 degrees clockwise in-place. Parameters: matrix (List[List[int]]): The input n x n matrix representing the image. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def trap_water(heights): Computes the total amount of water that can be trapped between the buildings. :param heights: List[int] Heights of the buildings :return: int Total amount of trapped water >>> trap_water([]) == 0 >>> trap_water([1]) == 0 >>> trap_water([1, 2]) == 0 >>> trap_water([2, 1]) == 0 >>> trap_water([1, 2, 3, 4, 5]) == 0 >>> trap_water([5, 4, 3, 2, 1]) == 0 >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_water([4, 2, 0, 3, 2, 5]) == 9 >>> trap_water([0, 3, 0, 2, 0, 4]) == 7 >>> trap_water([1, 0, 1, 0, 1, 0, 1]) == 3","solution":"def trap_water(heights): Computes the total amount of water that can be trapped between the buildings. :param heights: List[int] Heights of the buildings :return: int Total amount of trapped water if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def max_dominated_chain_length(points): Returns the maximum length of a chain of points such that each point in the chain dominates the next point in the chain. >>> max_dominated_chain_length([]) == 0 >>> max_dominated_chain_length([[1, 2]]) == 1 >>> max_dominated_chain_length([[1, 2], [3, 1]]) == 1 >>> max_dominated_chain_length([[1, 2], [2, 3]]) == 2 >>> max_dominated_chain_length([[1, 2], [2, 3], [3, 4]]) == 3 >>> max_dominated_chain_length([[1, 2], [2, 3], [1, 3], [3, 4], [2, 1], [2, 2]]) == 4 >>> max_dominated_chain_length([[3, 4], [2, 2], [1, 2], [2, 1], [2, 3], [1, 3]]) == 4","solution":"def max_dominated_chain_length(points): Returns the maximum length of a chain of points such that each point in the chain dominates the next point in the chain. if not points: return 0 # Sort points based on x coordinate first, and then by y coordinate points.sort(key=lambda p: (p[0], p[1])) # Initialize the dp array where dp[i] represents the length of the longest dominating chain ending at points[i] dp = [1] * len(points) # Compute the longest dominating chain using dynamic programming for i in range(len(points)): for j in range(i): if points[j][0] <= points[i][0] and points[j][1] <= points[i][1]: dp[i] = max(dp[i], dp[j] + 1) # Return the maximum value in dp, which represents the longest chain length return max(dp)"},{"question":"def combination_sum(k: int, n: int) -> List[List[int]]: Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. >>> combination_sum(3, 7) [[1, 2, 4]] >>> combination_sum(3, 9) [[1, 2, 6], [1, 3, 5], [2, 3, 4]] >>> combination_sum(4, 1) [] >>> combination_sum(3, 15) [[1, 5, 9], [1, 6, 8], [2, 4, 9], [2, 5, 8], [2, 6, 7], [3, 4, 8], [3, 5, 7], [4, 5, 6]] >>> combination_sum(2, 5) [[1, 4], [2, 3]]","solution":"def combination_sum(k, n): Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. def backtrack(start, path, k, n): if k == 0 and n == 0: result.append(path) return for i in range(start, 10): if i > n: break backtrack(i + 1, path + [i], k - 1, n - i) result = [] backtrack(1, [], k, n) return result"},{"question":"from typing import List def top_k_frequent(strings: List[str], k: int) -> List[str]: Return the k most frequent strings from the list. If two strings have the same frequency, they are ordered lexicographically. >>> top_k_frequent([\\"a\\"], 1) [\\"a\\"] >>> top_k_frequent([\\"i\\", \\"love\\", \\"leetcode\\", \\"i\\", \\"love\\", \\"coding\\"], 2) [\\"i\\", \\"love\\"] >>> top_k_frequent([\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"], 4) [\\"the\\", \\"is\\", \\"sunny\\", \\"day\\"] >>> top_k_frequent([\\"a\\", \\"b\\", \\"a\\", \\"b\\", \\"c\\"], 2) [\\"a\\", \\"b\\"] >>> top_k_frequent([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"melon\\", \\"banana\\"], 3) [\\"banana\\", \\"apple\\", \\"melon\\"]","solution":"from collections import Counter from typing import List def top_k_frequent(strings: List[str], k: int) -> List[str]: Return the k most frequent strings from the list. If two strings have the same frequency, they are ordered lexicographically. count = Counter(strings) # Sort primarily by frequency (descending), then alphabetically sorted_strings = sorted(count.keys(), key=lambda x: (-count[x], x)) return sorted_strings[:k]"},{"question":"def max_apples(nums: List[int], k: int) -> int: Returns the maximum number of apples that can be picked given the constraints. Parameters: nums (list): List of integers representing apples on consecutive days. k (int): Minimum number of days to wait before picking apples again. Returns: int: Maximum number of apples that can be picked. >>> max_apples([1, 2, 3, 0, 2, 3, 1, 0], 2) 6 >>> max_apples([5], 0) 5 >>> max_apples([5], 1) 5 >>> max_apples([0, 0, 0, 0, 0], 2) 0 >>> max_apples([1, 10, 1, 10, 1, 10], 1) 30 >>> max_apples([3, 1, 2, 4, 5], 10) 5 >>> max_apples([4, 2, 3, 6], 0) 15","solution":"def max_apples(nums, k): Returns the maximum number of apples that can be picked given the constraints. Parameters: nums (list): List of integers representing apples on consecutive days. k (int): Minimum number of days to wait before picking apples again. Returns: int: Maximum number of apples that can be picked. n = len(nums) max_apples_picked = [0] * n for i in range(n): if i <= k: max_apples_picked[i] = max(nums[:i + 1]) else: max_apples_picked[i] = max(max_apples_picked[i - k - 1] + nums[i], max_apples_picked[i - 1]) return max_apples_picked[-1]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(headA, headB): Adds two numbers represented by linked lists headA and headB and returns the sum as a new linked list. pass def list_to_linked_list(numbers): dummy = ListNode() current = dummy for number in numbers: current.next = ListNode(number) current = current.next return dummy.next def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result def test_add_two_numbers_case1(): list1 = [3, 4, 2] list2 = [4, 6, 5] headA = list_to_linked_list(list1) headB = list_to_linked_list(list2) result = addTwoNumbers(headA, headB) assert linked_list_to_list(result) == [8, 0, 7] def test_add_two_numbers_case2(): list1 = [1, 2, 3] list2 = [9, 9, 9] headA = list_to_linked_list(list1) headB = list_to_linked_list(list2) result = addTwoNumbers(headA, headB) assert linked_list_to_list(result) == [1, 1, 2, 2] def test_add_two_numbers_with_zero(): list1 = [0] list2 = [0] headA = list_to_linked_list(list1) headB = list_to_linked_list(list2) result = addTwoNumbers(headA, headB) assert linked_list_to_list(result) == [0] def test_add_two_numbers_with_different_lengths(): list1 = [9, 9] list2 = [1] headA = list_to_linked_list(list1) headB = list_to_linked_list(list2) result = addTwoNumbers(headA, headB) assert linked_list_to_list(result) == [1, 0, 0]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(headA, headB): Adds two numbers represented by linked lists headA and headB and returns the sum as a new linked list. def linkedListToNumber(head): number = 0 while head: number = number * 10 + head.val head = head.next return number def numberToLinkedList(number): if number == 0: return ListNode(0) prev_node = None for digit in str(number)[::-1]: node = ListNode(int(digit)) node.next = prev_node prev_node = node return prev_node numA = linkedListToNumber(headA) numB = linkedListToNumber(headB) total = numA + numB return numberToLinkedList(total)"},{"question":"def rearrangeStudents(heights: List[int], t: int) -> List[int]: Rearranges students in non-decreasing order of their heights while preserving relative order for students that have the same height within the difference \`t\`. Args: heights (list of int): List of heights of students. t (int): The tolerance value to consider students having same height. Returns: list of int: List of heights rearranged in the described order. >>> rearrangeStudents([5, 3, 8, 6], 0) [3, 5, 6, 8] >>> rearrangeStudents([5, 3, 5, 6], 1) [3, 5, 5, 6] >>> rearrangeStudents([5, 3, 5, 6], 0) [3, 5, 5, 6] >>> rearrangeStudents([5, 4, 3, 2, 1], 0) [1, 2, 3, 4, 5] >>> rearrangeStudents([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rearrangeStudents([1], 0) [1] >>> rearrangeStudents([5, 4, 4, 5, 6], 1) [4, 4, 5, 5, 6]","solution":"def rearrangeStudents(heights, t): Rearranges students in non-decreasing order of their heights while preserving relative order for students that have the same height within the difference \`t\`. Args: heights (list of int): List of heights of students. t (int): The tolerance value to consider students having same height. Returns: list of int: List of heights rearranged in the described order. sorted_heights = sorted(heights) rearranged = [] for h in sorted_heights: i = next((i for i, x in enumerate(heights) if abs(x - h) <= t and x == h), None) if i is not None: rearranged.append(heights[i]) heights[i] = float('inf') # Mark this height as processed return rearranged"},{"question":"def is_robot_in_loop(instructions: str) -> bool: Determines if the robot is in an infinite loop. Parameters: instructions (str): String consisting of instructions ('L', 'R', 'U', 'D') Returns: bool: True if robot returns to (0, 0), False otherwise >>> is_robot_in_loop('') True >>> is_robot_in_loop('LURD') True >>> is_robot_in_loop('LU') False >>> is_robot_in_loop('LLRR') True >>> is_robot_in_loop('RRUULL') False >>> is_robot_in_loop('LURDLURDLURD') True >>> is_robot_in_loop('LLLLUUUUURRRRLD') False","solution":"def is_robot_in_loop(instructions): Determines if the robot is in an infinite loop. Parameters: instructions (str): String consisting of instructions ('L', 'R', 'U', 'D') Returns: bool: True if robot returns to (0, 0), False otherwise # Initial position x, y = 0, 0 # Move the robot according to instructions for instruction in instructions: if instruction == 'L': x -= 1 elif instruction == 'R': x += 1 elif instruction == 'U': y += 1 elif instruction == 'D': y -= 1 # Check if the robot is back to the initial position return (x == 0 and y == 0)"},{"question":"def findDuplicate(nums: List[int]) -> int: Finds the duplicate number in the array without modifying the array, using constant extra space and with time complexity less than O(n^2). >>> findDuplicate([1, 3, 4, 2, 2]) 2 >>> findDuplicate([3, 1, 3, 4, 2]) 3 >>> findDuplicate([1, 2, 5, 4, 3, 6, 7, 9, 8, 10, 5]) 5 >>> findDuplicate([1, 4, 6, 3, 2, 5, 7, 6]) 6 >>> findDuplicate([1, 1]) 1 >>> findDuplicate([2, 5, 3, 2, 4, 2]) 2","solution":"def findDuplicate(nums): Finds the duplicate number in the array without modifying the array, using constant extra space and with time complexity less than O(n^2). # Using Floyd's Tortoise and Hare (Cycle Detection Algorithm) tortoise = hare = nums[0] while True: tortoise = nums[tortoise] hare = nums[nums[hare]] if tortoise == hare: break # Find the entrance to the cycle tortoise = nums[0] while tortoise != hare: tortoise = nums[tortoise] hare = nums[hare] return hare"},{"question":"def evaluate_expression(s: str) -> int: Given a string s representing a mathematical expression with positive integers and operators +, -, *, /, return the result of the expression after evaluating it. The integer division should truncate toward zero. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"3/2\\") 1 >>> evaluate_expression(\\"3+5/2\\") 5 >>> evaluate_expression(\\"10-3*2\\") 4 >>> evaluate_expression(\\"12/3+2\\") 6 >>> evaluate_expression(\\"1+2*5/3+6/4*2\\") 6 >>> evaluate_expression(\\"1\\") 1 >>> evaluate_expression(\\"100\\") 100 >>> evaluate_expression(\\"14/3*2\\") 8 >>> evaluate_expression(\\"14/3*2/3\\") 2 >>> evaluate_expression(\\"3+6/2*3-4\\") 8 >>> evaluate_expression(\\"10+10/5*2-2\\") 12","solution":"def evaluate_expression(s: str) -> int: def operate(a, b, op): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': return int(a / b) # Integer division truncating towards zero if not s: return 0 n = len(s) current_num = 0 stack = [] operation = '+' i = 0 while i < n: char = s[i] if char.isdigit(): current_num = current_num * 10 + int(char) if char in \\"+-*/\\" or i == n - 1: if operation == '+': stack.append(current_num) elif operation == '-': stack.append(-current_num) elif operation == '*': stack[-1] = stack[-1] * current_num elif operation == '/': stack[-1] = int(stack[-1] / current_num) operation = char current_num = 0 i += 1 return sum(stack)"},{"question":"def isValid(s: str) -> bool: Determines if the string s is a valid sequence of brackets. A valid sequence of brackets should have all opening brackets closed by the same type of brackets and should be closed in the correct order. :param s: Input string containing the sequence of brackets. :return: True if the sequence is valid, False otherwise. >>> isValid(\\"()\\") True >>> isValid(\\"()[]{}\\") True >>> isValid(\\"{[()]}\\") True >>> isValid(\\"\\") True >>> isValid(\\"(]\\") False >>> isValid(\\"([)]\\") False >>> isValid(\\"{\\") False >>> isValid(\\"[{]\\") False >>> isValid(\\"{[()][]}\\") True >>> isValid(\\"({[)})\\") False >>> isValid(\\"((\\") False >>> isValid(\\"][]\\") False","solution":"def isValid(s: str) -> bool: Determines if the string s is a valid sequence of brackets. A valid sequence of brackets should have all opening brackets closed by the same type of brackets and should be closed in the correct order. :param s: Input string containing the sequence of brackets. :return: True if the sequence is valid, False otherwise. stack = [] bracket_map = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"from typing import List, Tuple def three_sum_unique_triplets(arr: List[int], x: int) -> List[Tuple[int, int, int]]: Finds all unique triplets in the array which gives the sum of x. :param arr: List[int] - List of integers :param x: int - Target sum :return: List[Tuple[int, int, int]] - List of unique triplets that sum up to x >>> three_sum_unique_triplets([1, 2, 3, 4, 5, 6], 10) [(1, 3, 6), (2, 3, 5), (1, 4, 5)] >>> three_sum_unique_triplets([1, 1, 2, 2, 3, 3, 4, 4], 7) [(1, 2, 4), (1, 3, 3), (2, 2, 3)] >>> three_sum_unique_triplets([1, 2, 4, 5], 20) [] >>> three_sum_unique_triplets([-1, 0, 1, 2, -2, -3], 0) [(-3, 1, 2), (-2, 0, 2), (-1, 0, 1)] >>> three_sum_unique_triplets([], 0) [] result = set() # Your code goes here return list(result)","solution":"def three_sum_unique_triplets(arr, x): Finds all unique triplets in the array that sum up to x. :param arr: List[int] - List of integers :param x: int - Target sum :return: List[Tuple[int, int, int]] - List of unique triplets that sum up to x arr.sort() result = set() for i in range(len(arr) - 2): left, right = i + 1, len(arr) - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == x: result.add((arr[i], arr[left], arr[right])) left += 1 right -= 1 elif current_sum < x: left += 1 else: right -= 1 return list(result)"},{"question":"def is_valid_bracket_sequence(s: str) -> bool: Determine if the input string is a valid bracket sequence. Conditions for a valid bracket sequence: - Open brackets must be closed by the same type of brackets. - Open brackets must be closed in the correct order. Args: s (str): A string containing only brackets. Returns: bool: True if the string is a valid bracket sequence, False otherwise. Examples: >>> is_valid_bracket_sequence(\\"()\\") True >>> is_valid_bracket_sequence(\\"()[]{}\\") True >>> is_valid_bracket_sequence(\\"(]\\") False >>> is_valid_bracket_sequence(\\"([)]\\") False >>> is_valid_bracket_sequence(\\"{[]}\\") True","solution":"def is_valid_bracket_sequence(s): Returns True if the input string is a valid bracket sequence, otherwise False. Conditions for a valid bracket sequence: - Open brackets must be closed by the same type of brackets. - Open brackets must be closed in the correct order. Args: s (str): A string containing only brackets. Returns: bool: True if the string is a valid bracket sequence, False otherwise. bracket_map = {')': '(', '}': '{', ']': '['} open_brackets = set(bracket_map.values()) stack = [] for char in s: if char in open_brackets: stack.append(char) elif char in bracket_map: if stack and stack[-1] == bracket_map[char]: stack.pop() else: return False else: return False # Invalid character return not stack"},{"question":"def coin_change(coins, amount): Determine the fewest number of coins needed to make up the given amount using the provided denominations. If the amount can't be made up by any combination of the coins, return -1. Examples: >>> coin_change([1, 2, 5], 11) 3 >>> coin_change([2], 3) -1 >>> coin_change([1], 0) 0 >>> coin_change([1], 2) 2 >>> coin_change([1, 3, 4], 6) 2 >>> coin_change([1, 2, 5], 100) 20 >>> coin_change([2, 4], 7) -1 >>> coin_change([3], 9) 3 >>> coin_change([3], 10) -1","solution":"def coin_change(coins, amount): Returns the fewest number of coins needed to make up the given amount. If the amount can't be made up by any combination of the coins, returns -1. if amount == 0: return 0 # Initialize the DP array with infinity for all values except the 0th dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def max_rounds(nums: List[int]) -> int: Returns the maximum number of rounds a player participated in. :param nums: List of integers representing results of each player. :return: An integer representing the max length of a contiguous subsequence of non-decreasing results. >>> max_rounds([4, 3, 5, 5, 6, 7, 8, 2, 4]) == 6 >>> max_rounds([]) == 0 >>> max_rounds([5]) == 1 >>> max_rounds([0]) == 1 >>> max_rounds([1, 2, 3, 4, 5]) == 5 >>> max_rounds([3, 3, 3, 3]) == 4 >>> max_rounds([5, 4, 3, 2, 1]) == 1 >>> max_rounds([1, 2, 2, 3, 1, 1, 2, 3, 4, 0, 1]) == 5 >>> max_rounds([1] * 1000) == 1000 >>> max_rounds(list(range(1000))) == 1000 >>> max_rounds(list(range(500, 0, -1))) == 1","solution":"def max_rounds(nums): Returns the maximum number of rounds a player participated in. :param nums: List of integers representing results of each player. :return: An integer representing the max length of a contiguous subsequence of non-decreasing results. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] >= nums[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 # Check the last subsequence max_length = max(max_length, current_length) return max_length"},{"question":"def max_length_subarray(arr, k): Returns the maximum length of a contiguous subarray such that the absolute difference between any two elements in this subarray is less than or equal to k. >>> max_length_subarray([1, 3, 5, 7], 3) 2 >>> max_length_subarray([5], 2) 1 >>> max_length_subarray([-3, -2, -1, 0, 1], 2) 3 >>> max_length_subarray([1, 3, 5, 7], 10) 4 >>> max_length_subarray([], 5) 0 >>> max_length_subarray([5, 5, 5, 5], 0) 4 >>> max_length_subarray([1, 10, 20, 30], 3) 1 :param arr: List of integers :param k: Integer threshold for the absolute difference :return: Maximum length of the subarray","solution":"def max_length_subarray(arr, k): Returns the maximum length of a contiguous subarray such that the absolute difference between any two elements in this subarray is less than or equal to k. :param arr: List of integers :param k: Integer threshold for the absolute difference :return: Maximum length of the subarray n = len(arr) if n == 0: return 0 max_len = 1 start = 0 for end in range(1, n): while abs(arr[end] - min(arr[start:end+1])) > k or abs(arr[end] - max(arr[start:end+1])) > k: start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def matrix_multiplication(A, B): Given two integer matrices A and B of the same size, return a new matrix C where each element C[i][j] is the sum of the products of the corresponding elements from A and B in their respective row and column sub-matrices. Specifically, each element C[i][j] is computed as: C[i][j] = sum(A[i][k] * B[k][j] for all k from 0 to n-1) where A and B are m x n matrices. >>> A = [ ... [1, 2], ... [3, 4] ... ] >>> B = [ ... [5, 6], ... [7, 8] ... ] >>> matrix_multiplication(A, B) [[19, 22], [43, 50]] >>> A = [ ... [1, 2, 3], ... [4, 5, 6] ... ] >>> B = [ ... [7, 8], ... [9, 10], ... [11, 12] ... ] >>> matrix_multiplication(A, B) [[58, 64], [139, 154]] >>> A = [[2]] >>> B = [[3]] >>> matrix_multiplication(A, B) [[6]] >>> A = [ ... [0, 0], ... [0, 0] ... ] >>> B = [ ... [0, 0], ... [0, 0] ... ] >>> matrix_multiplication(A, B) [[0, 0], [0, 0]] >>> A = [ ... [1, 0], ... [0, 1] ... ] >>> B = [ ... [1, 2], ... [3, 4] ... ] >>> matrix_multiplication(A, B) [[1, 2], [3, 4]]","solution":"def matrix_multiplication(A, B): Returns the matrix multiplication of A and B. A and B are m x n matrices. The function returns a matrix C where C[i][j] = sum(A[i][k] * B[k][j] for all k from 0 to n-1). m = len(A) n = len(A[0]) p = len(B[0]) # Initialize the result matrix C with zeros C = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): C[i][j] = sum(A[i][k] * B[k][j] for k in range(n)) return C"},{"question":"def rotate(nums: List[int], k: int) -> None: Rotates the list nums to the right by k steps. Args: nums: List[int] - A list of integers. k: int - The number of steps to rotate the list to the right. The function modifies the list in-place. >>> nums = [1, 2, 3, 4, 5] >>> rotate(nums, 1) >>> nums [5, 1, 2, 3, 4] >>> nums = [1, 2, 3, 4, 5] >>> rotate(nums, 2) >>> nums [4, 5, 1, 2, 3] >>> nums = [1, 2, 3, 4, 5] >>> rotate(nums, 5) >>> nums [1, 2, 3, 4, 5] >>> nums = [1, 2, 3, 4, 5] >>> rotate(nums, 7) >>> nums [4, 5, 1, 2, 3] >>> nums = [1, 2, 3, 4, 5] >>> rotate(nums, 0) >>> nums [1, 2, 3, 4, 5] >>> nums = [1] >>> rotate(nums, 3) >>> nums [1] >>> nums = [1, 2] >>> rotate(nums, 4) >>> nums [1, 2]","solution":"def rotate(nums, k): Rotates the list nums to the right by k steps. Args: nums: List[int] - A list of integers. k: int - The number of steps to rotate the list to the right. n = len(nums) k = k % n # In case k is greater than the length of the list # Reverse the entire list nums.reverse() # Reverse the first k elements nums[:k] = reversed(nums[:k]) # Reverse the rest of the list nums[k:] = reversed(nums[k:])"},{"question":"def max_length_subarray(nums: List[int], k: int) -> int: Given an array of \`n\` unique integers, find the maximum length of a contiguous subarray where the difference between the minimum and maximum element is at most \`k\`. Parameters: nums (List[int]): List of unique integers. k (int): The allowed difference between maximum and minimum elements. Returns: int: Maximum length of the contiguous subarray. >>> max_length_subarray([], 5) 0 >>> max_length_subarray([5], 10) 1 >>> max_length_subarray([1, 10, 20, 30], 5) 1 >>> max_length_subarray([3, 6, 7, 9], 6) 4 >>> max_length_subarray([10, 1, 2, 4, 7, 2], 5) 4 >>> max_length_subarray([8, 2, 4, 7], 4) 2 >>> max_length_subarray([4, 2, -3, 7, 5], 5) 2 >>> max_length_subarray([4, 2, -3, 7, 5], 10) 5 >>> max_length_subarray([4, 2, -3, 7, 5], 2) 2 >>> max_length_subarray([1, 2, 3, 4, 5], 3) 4 >>> max_length_subarray([1, 2, 3, 4, 5], 1) 2 >>> max_length_subarray([5, 4, 3, 2, 1], 3) 4 >>> max_length_subarray([5, 4, 3, 2, 1], 1) 2","solution":"def max_length_subarray(nums, k): Given an array of \`n\` unique integers, find the maximum length of a contiguous subarray where the difference between the minimum and maximum element is at most \`k\`. Parameters: nums (List[int]): List of unique integers. k (int): The allowed difference between maximum and minimum elements. Returns: int: Maximum length of the contiguous subarray. if not nums: return 0 from collections import deque max_deque = deque() # stores indices of the numbers in descending order min_deque = deque() # stores indices of the numbers in ascending order left = 0 # left pointer for the sliding window max_len = 0 for right in range(len(nums)): # Ensure max_deque stores elements in descending order while max_deque and nums[max_deque[-1]] <= nums[right]: max_deque.pop() max_deque.append(right) # Ensure min_deque stores elements in ascending order while min_deque and nums[min_deque[-1]] >= nums[right]: min_deque.pop() min_deque.append(right) # If the current window does not meet the condition, move the left pointer while nums[max_deque[0]] - nums[min_deque[0]] > k: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() # Update the maximum length of the valid subarray max_len = max(max_len, right - left + 1) return max_len"},{"question":"class PhoneDirectory: def __init__(self, maxNumbers: int): Initialize a phone directory with phone numbers ranging from 0 to maxNumbers - 1 def get(self) -> int: Provide an available phone number. Return -1 if none available. def check(self, number: int) -> bool: Check if a phone number is available or not. def release(self, number: int) -> None: Recycle or release a phone number back to the pool of available numbers. # Unit Tests def test_phone_directory_initialization(): pd = PhoneDirectory(3) assert pd.check(0) == True assert pd.check(1) == True assert pd.check(2) == True assert pd.check(3) == False def test_get_phone_numbers(): pd = PhoneDirectory(2) number = pd.get() assert number in [0, 1] assert pd.check(number) == False another_number = pd.get() assert another_number in [0, 1] and another_number != number assert pd.check(another_number) == False assert pd.get() == -1 def test_check_phone_numbers(): pd = PhoneDirectory(2) assert pd.check(0) == True assert pd.check(1) == True number = pd.get() assert pd.check(number) == False another_number = pd.get() assert pd.check(another_number) == False assert pd.check(0 if number == 1 else 1) == False def test_release_phone_numbers(): pd = PhoneDirectory(2) number = pd.get() another_number = pd.get() pd.release(number) assert pd.check(number) == True assert pd.check(another_number) == False assert pd.get() == number pd.release(number) pd.release(another_number) assert pd.check(number) == True assert pd.check(another_number) == True assert pd.get() in [0, 1] assert pd.get() in [0, 1] assert pd.get() == -1","solution":"class PhoneDirectory: def __init__(self, maxNumbers: int): Initialize a phone directory with phone numbers ranging from 0 to maxNumbers - 1 self.available = set(range(maxNumbers)) self.in_use = set() def get(self) -> int: Provide an available phone number. Return -1 if none available. if self.available: number = self.available.pop() self.in_use.add(number) return number return -1 def check(self, number: int) -> bool: Check if a phone number is available or not. return number in self.available def release(self, number: int) -> None: Recycle or release a phone number back to the pool of available numbers. if number in self.in_use: self.in_use.remove(number) self.available.add(number)"},{"question":"def maxPathSum(matrix: List[List[int]]) -> int: Function to find the maximum sum path from top-left to bottom-right of a matrix, where you can only move right or down. Args: matrix (List[List[int]]): 2D list containing non-negative integers. Returns: int: Maximum sum achievable. Examples: >>> maxPathSum([ ... [5, 3], ... [2, 1] ... ]) 9 >>> maxPathSum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> maxPathSum([ ... [1] ... ]) 1","solution":"def maxPathSum(matrix): Function to find the maximum sum path from top-left to bottom-right of a matrix, where you can only move right or down. Args: matrix (List[List[int]]): 2D list containing non-negative integers. Returns: int: Maximum sum achievable. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) # Create a dp table to store the maximum sums dp = [[0] * n for _ in range(m)] dp[0][0] = matrix[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + matrix[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j] return dp[m - 1][n - 1]"},{"question":"def longest_palindrome_with_one_change(s: str) -> int: Returns the length of the longest palindrome that can be formed by changing at most one character in the string s. >>> longest_palindrome_with_one_change(\\"abba\\") == 4 >>> longest_palindrome_with_one_change(\\"racecar\\") == 7 >>> longest_palindrome_with_one_change(\\"abca\\") == 4 >>> longest_palindrome_with_one_change(\\"abcd\\") == 3 >>> longest_palindrome_with_one_change(\\"aabbcc\\") == 5 >>> longest_palindrome_with_one_change(\\"a\\") == 1 >>> longest_palindrome_with_one_change(\\"aa\\") == 2 >>> longest_palindrome_with_one_change(\\"aaa\\") == 3 >>> longest_palindrome_with_one_change(\\"abcde\\") == 4 >>> longest_palindrome_with_one_change(\\"abcba\\") == 5 >>> longest_palindrome_with_one_change(\\"abcaa\\") == 5 pass","solution":"def longest_palindrome_with_one_change(s): Returns the length of the longest palindrome that can be formed by changing at most one character in the string s. n = len(s) def is_palindrome(string): return string == string[::-1] if is_palindrome(s): return n max_palindrome_length = 0 for i in range(n): # Try changing character at position i to every other character for c in 'abcdefghijklmnopqrstuvwxyz': if s[i] != c: # make sure there is an actual change new_string = s[:i] + c + s[i+1:] if is_palindrome(new_string): max_palindrome_length = n return max_palindrome_length # If no single change makes it a palindrome, one character change can cover longest non-palindrome part return n - 1 # Example usage: # s = 'abca' # print(longest_palindrome_with_one_change(s)) # Output should be 4 (change 'c' to 'b')"},{"question":"def can_reach_end(nums: List[int]) -> bool: Determines if you can reach the end of the list starting from the first position. Args: nums: List[int] - A list of integers where each integer represents the number of steps you can move forward or backward. Returns: bool - True if you can reach the last position, otherwise False. >>> can_reach_end([2, 3, 1, 1, 4]) True >>> can_reach_end([3, 2, 1, 0, 4]) False >>> can_reach_end([0]) True >>> can_reach_end([2, 0, 2, 1, 4]) True >>> can_reach_end([1, -1, 1, -1, 1, -1, 1]) True >>> can_reach_end([1, -1, 1, -1, 0]) True >>> can_reach_end([0, 0, 0, 0]) False pass","solution":"def can_reach_end(nums): Determines if you can reach the end of the list starting from the first position. Args: nums: List[int] - A list of integers where each integer represents the number of steps you can move forward or backward. Returns: bool - True if you can reach the last position, otherwise False. n = len(nums) if n == 1: return True visited = set() def dfs(position): if position == n - 1: return True visited.add(position) forward = position + nums[position] backward = position - nums[position] if 0 <= forward < n and forward not in visited and dfs(forward): return True if 0 <= backward < n and backward not in visited and dfs(backward): return True return False return dfs(0)"},{"question":"from typing import List def trap(height: List[int]) -> int: Calculate the total amount of water that could be trapped after raining. :param height: List[int] representing the height of each elevation. :return: int total amount of trapped water. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([]) 0 >>> trap([1,1,1,1,1]) 0 >>> trap([2,0,2]) 2 >>> trap([4,2,0,3,2,5]) 9 >>> trap([3,3,3,3,3,3,3]) 0 >>> trap([5,4,3,2,1]) 0 >>> trap([1,2,3,4,5]) 0","solution":"def trap(height): Calculate the total amount of water that could be trapped after raining. :param height: List[int] representing the height of each elevation. :return: int total amount of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def count_good_pairs(nums: List[int], target: int) -> int: Returns the number of good pairs in the list \`nums\` such that nums[i] + nums[j] == target and i < j. >>> count_good_pairs([1, 2, 3], 10) 0 >>> count_good_pairs([1, 2, 3], 5) 1 >>> count_good_pairs([1, 2, 3, 2, 1], 3) 4 >>> count_good_pairs([-1, 1, -2, 3, 2], 1) 2 >>> count_good_pairs([0, 0, 0], 0) 3 >>> count_good_pairs([], 5) 0 >>> count_good_pairs([1, 1, 1, 1], 2) 6","solution":"def count_good_pairs(nums, target): Returns the number of good pairs in the list \`nums\` such that nums[i] + nums[j] == target and i < j. count = 0 for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: count += 1 return count"},{"question":"def rob(nums: List[int]) -> int: Given a list of non-negative integers representing the amount of money of each house, return the maximum amount of money you can collect without triggering the security system (i.e., no two adjacent houses can have security systems). >>> rob([10]) 10 >>> rob([10, 20]) 20 >>> rob([10, 20, 30]) 40 >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([1, 2, 3, 1]) 4 >>> rob([5, 5, 10, 100, 10, 5]) 110 >>> rob([]) 0 >>> rob([5, 5, 5, 5, 5]) 15 >>> rob([2, 1, 1, 2]) 4","solution":"def rob(nums): This function calculates the maximum amount of money you can rob without triggering the security system, given that no two adjacent houses can be robbed. :param nums: List[int] - a list of non-negative integers representing the amount of money in each house :return: int - the maximum amount of money that can be robbed if not nums: return 0 if len(nums) == 1: return nums[0] prev1, prev2 = 0, 0 for num in nums: current = max(prev1, prev2 + num) prev2 = prev1 prev1 = current return prev1"},{"question":"class WordDictionary: Implement a data structure that supports the following operations on a collection of strings. Each string consists only of lowercase letters ('a' to 'z'). WordDictionary() Initializes an empty word dictionary. void addWord(String word) Adds a word into the data structure. boolean search(String word) Returns \`true\` if there is any string in the data structure that matches \`word\` or else \`false\`. A word could contain dots \`'.'\` where dots can be matched with any letter. def __init__(self): Initializes an empty word dictionary. pass def addWord(self, word: str) -> None: Adds a word into the data structure. pass def search(self, word: str) -> bool: Returns whether there is any word in the data structure that matches the given word. A dot '.' can match any letter. pass from solution import WordDictionary def test_add_and_search_exact_match(): wd = WordDictionary() wd.addWord(\\"hello\\") assert wd.search(\\"hello\\") == True assert wd.search(\\"hell\\") == False assert wd.search(\\"helloo\\") == False def test_add_and_search_with_dots(): wd = WordDictionary() wd.addWord(\\"hello\\") assert wd.search(\\"h.llo\\") == True assert wd.search(\\"he.lo\\") == True assert wd.search(\\"h..lo\\") == True assert wd.search(\\"h...o\\") == True assert wd.search(\\".....\\") == True assert wd.search(\\"....\\") == False assert wd.search(\\"......\\") == False assert wd.search(\\"hell.\\") == True def test_add_multiple_words_and_search(): wd = WordDictionary() wd.addWord(\\"hello\\") wd.addWord(\\"world\\") assert wd.search(\\"hello\\") == True assert wd.search(\\"world\\") == True assert wd.search(\\"w.rld\\") == True assert wd.search(\\"h...o\\") == True def test_no_addition_then_search(): wd = WordDictionary() assert wd.search(\\"hello\\") == False assert wd.search(\\"h.llo\\") == False assert wd.search(\\".....\\") == False","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word: str) -> None: Adds a word into the data structure. self.words.append(word) def search(self, word: str) -> bool: Returns whether there is any word in the data structure that matches the given word. A dot '.' can match any letter. import re pattern = '^' + word.replace('.', '[a-z]') + '' for w in self.words: if re.match(pattern, w): return True return False"},{"question":"def minDriveCapacity(nums: List[int], k: int) -> int: Returns the minimum capacity required for the drives so that all files are distributed across the k drives without any drive exceeding this capacity. Parameters: nums (List[int]): List of integers representing the sizes of different files. k (int): Number of drives available. Returns: int: Minimum capacity required for the drives.","solution":"def minDriveCapacity(nums, k): Returns the minimum capacity required for the drives so that all files are distributed across the k drives without any drive exceeding this capacity. Parameters: nums (List[int]): List of integers representing the sizes of different files. k (int): Number of drives available. Returns: int: Minimum capacity required for the drives. def canDistribute(cap): drives_used = 1 current_capacity = 0 for size in nums: if current_capacity + size > cap: drives_used += 1 current_capacity = size if drives_used > k: return False else: current_capacity += size return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if canDistribute(mid): right = mid else: left = mid + 1 return left"},{"question":"def count_matching_patterns(s: str, patterns: List[str]) -> int: Returns the number of patterns that 's' matches. Args: s (str): Input string containing only lowercase English letters. patterns (List[str]): Array of strings where each string is a pattern containing wildcards '?' and '*'. Returns: int: Number of patterns 's' matches. Examples: >>> count_matching_patterns(\\"abxyzcd\\", [\\"a*d\\", \\"a?z*\\", \\"*z*d\\"]) 2 >>> count_matching_patterns(\\"hello\\", [\\"h?llo\\", \\"he*o\\", \\"h*llo\\"]) 3","solution":"import fnmatch def count_matching_patterns(s, patterns): Returns the count of patterns that match the input string s. Params: s (str): Input string to be matched against patterns. patterns (list): List of patterns with wildcards. Returns: int: Count of patterns that match the string s. count = 0 for pattern in patterns: if fnmatch.fnmatch(s, pattern): count += 1 return count"},{"question":"def search_rotated_array(arr, k): Returns the index of the target integer k in the rotated array arr. If k is not present in the array, return -1. Your solution should have a time complexity of O(log n). Parameters: - arr: List[int]: The rotated array of integers. - k: int: The target integer to search for. Returns: - int: The index of the target integer k if present, otherwise -1. >>> search_rotated_array([4, 5, 6, 7, 0, 1, 2], 0) 4 >>> search_rotated_array([4, 5, 6, 7, 0, 1, 2], 3) -1 >>> search_rotated_array([1], 1) 0 >>> search_rotated_array([30, 40, 50, 10, 20], 10) 3","solution":"def search_rotated_array(arr, k): Returns the index of the target integer k in the rotated array arr. If k is not present in the array, return -1. low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] == k: return mid if arr[low] <= arr[mid]: # Left half is sorted if arr[low] <= k < arr[mid]: high = mid - 1 # Target is in the left half else: low = mid + 1 # Target is in the right half else: # Right half is sorted if arr[mid] < k <= arr[high]: low = mid + 1 # Target is in the right half else: high = mid - 1 # Target is in the left half return -1 # Target not found"},{"question":"def canFormPalindrome(s: str) -> bool: Determines if the characters of the input string can be rearranged to form a palindrome. :param s: Input string consisting of lowercase English letters :return: True if the string can be rearranged to form a palindrome, False otherwise >>> canFormPalindrome(\\"civic\\") True >>> canFormPalindrome(\\"ivicc\\") True >>> canFormPalindrome(\\"hello\\") False >>> canFormPalindrome(\\"\\") True >>> canFormPalindrome(\\"a\\") True >>> canFormPalindrome(\\"abcd\\") False >>> canFormPalindrome(\\"aabb\\") True >>> canFormPalindrome(\\"aaabbbb\\") True","solution":"def canFormPalindrome(s): Determines if the characters of the input string can be rearranged to form a palindrome. :param s: Input string consisting of lowercase English letters :return: True if the string can be rearranged to form a palindrome, False otherwise from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Check the number of characters that have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # If the odd_count is more than 1, it cannot be rearranged to form a palindrome return odd_count <= 1"},{"question":"def find_starting_gas_stations(gas_stations): Determines the starting gas stations from which the circular route can be completed. Args: gas_stations (list): List of non-negative integers representing gasoline at gas stations. Returns: list: Indices of all starting gas stations from which the circular route can be completed. Example: >>> find_starting_gas_stations([1]) [0] >>> find_starting_gas_stations([0]) [] >>> find_starting_gas_stations([2, 3, 4]) [0, 1, 2] >>> find_starting_gas_stations([1, 2, 0, 1]) [0, 1, 3] >>> find_starting_gas_stations([1, 0, 0, 1]) [0, 3] >>> find_starting_gas_stations([0, 0, 0, 0]) [] >>> find_starting_gas_stations([4, 2, 0, 0]) [0, 1] >>> find_starting_gas_stations([]) [] >>> find_starting_gas_stations([5, 0, 5]) [0, 2]","solution":"def find_starting_gas_stations(gas_stations): Determines the starting gas stations from which the circular route can be completed. Args: gas_stations (list): List of non-negative integers representing gasoline at gas stations. Returns: list: Indices of all starting gas stations from which the circular route can be completed. n = len(gas_stations) start_indices = [] for start in range(n): tank = 0 for i in range(n): tank += gas_stations[(start + i) % n] if tank < 1: break else: start_indices.append(start) return start_indices"},{"question":"class IntervalManager: def __init__(self): Initializes an IntervalManager object self.intervals = [] def add_interval(self, start: int, end: int): Adds a new interval [start, end] to the collection. def find_overlaps(self, start: int, end: int): Returns a list of intervals from the collection that overlap with the interval [start, end]. >>> im = IntervalManager() >>> im.add_interval(1, 5) >>> im.add_interval(6, 10) >>> im.find_overlaps(4, 7) [(1, 5), (6, 10)] >>> im.find_overlaps(11, 15) []","solution":"class IntervalManager: def __init__(self): self.intervals = [] def add_interval(self, start, end): Adds a new interval [start, end] to the collection. self.intervals.append((start, end)) def find_overlaps(self, start, end): Returns a list of intervals from the collection that overlap with the interval [start, end]. overlaps = [] for (s, e) in self.intervals: if s <= end and start <= e: # Check for overlap overlaps.append((s, e)) return overlaps"},{"question":"def minPalindromicSplits(s: str) -> int: Given a string \`s\`, return the minimum number of splits needed such that each substring is a palindrome. Example: >>> minPalindromicSplits(\\"a\\") == 0 >>> minPalindromicSplits(\\"aa\\") == 0 >>> minPalindromicSplits(\\"ab\\") == 1 >>> minPalindromicSplits(\\"aba\\") == 0 >>> minPalindromicSplits(\\"abc\\") == 2 >>> minPalindromicSplits(\\"aab\\") == 1 >>> minPalindromicSplits(\\"aabb\\") == 1 >>> minPalindromicSplits(\\"racecar\\") == 0 >>> minPalindromicSplits(\\"abbac\\") == 1","solution":"def minPalindromicSplits(s): Returns the minimum number of splits needed such that each substring is a palindrome. n = len(s) # dp[i] will be the minimum cuts needed for a palindromic partition of substring s[0:i+1] dp = [0] * n # pal[i][j] will be true if s[i:j+1] is a palindrome pal = [[False] * n for _ in range(n)] for i in range(n): min_cut = i # Maximum cuts needed initially is the length of substring for j in range(i + 1): if s[j] == s[i] and (i - j <= 2 or pal[j + 1][i - 1]): pal[j][i] = True # If s[j:i+1] is a palindrome, minimize the cut min_cut = 0 if j == 0 else min(min_cut, dp[j - 1] + 1) dp[i] = min_cut return dp[-1]"},{"question":"from typing import List def has_cycle(num_nodes: int, edges: List[List[int]]) -> bool: Determine if there is a cycle in the directed graph. :param num_nodes: Number of nodes in the graph. :param edges: List of edges represented as pairs [ui, vi]. :return: True if there is a cycle, False otherwise. # Unit Tests def test_has_cycle_no_cycle(): num_nodes = 4 edges = [[0, 1], [1, 2], [2, 3]] assert has_cycle(num_nodes, edges) == False def test_has_cycle_with_cycle(): num_nodes = 4 edges = [[0, 1], [1, 2], [2, 0]] assert has_cycle(num_nodes, edges) == True def test_has_cycle_disconnected_graph(): num_nodes = 6 edges = [[0, 1], [2, 3], [3, 4]] assert has_cycle(num_nodes, edges) == False def test_has_cycle_single_node_no_edges(): num_nodes = 1 edges = [] assert has_cycle(num_nodes, edges) == False def test_has_cycle_single_cycle_graph(): num_nodes = 3 edges = [[0, 1], [1, 2], [2, 0]] assert has_cycle(num_nodes, edges) == True def test_has_cycle_longer_graph_with_cycle(): num_nodes = 6 edges = [[0, 1], [1, 2], [2, 3], [3, 1], [4, 5]] assert has_cycle(num_nodes, edges) == True","solution":"def has_cycle(num_nodes, edges): Determine if there is a cycle in the directed graph. :param num_nodes: Number of nodes in the graph. :param edges: List of edges represented as pairs [ui, vi]. :return: True if there is a cycle, False otherwise. from collections import defaultdict, deque # Build adjacency list adj_list = defaultdict(list) indegree = [0] * num_nodes for u, v in edges: adj_list[u].append(v) indegree[v] += 1 # Queue for nodes with no incoming edges (indegree 0) queue = deque([node for node in range(num_nodes) if indegree[node] == 0]) visited = 0 while queue: node = queue.popleft() visited += 1 for neighbor in adj_list[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If visited nodes count is not equal to the number of nodes, there is a cycle return visited != num_nodes"},{"question":"from collections import Counter class FrequentCharacter: Class to find the most frequently occurring character in a specified range and to update characters in a string. def __init__(self, s: str): Initializes the object with the string s. :param s: The initial string def query(self, left: int, right: int) -> str: Returns the character that appears most frequently in the substring s[left:right + 1]. If there are multiple characters with the same highest frequency, return the lexicographically smallest one. :param left: The starting index of the substring (inclusive) :param right: The ending index of the substring (inclusive) :return: The character with the highest frequency in the substring >>> freq_char = FrequentCharacter(\\"abacad\\") >>> freq_char.query(0, 2) 'a' def update(self, index: int, char: str) -> None: Updates the character at position index in the string s to char. :param index: The index to update :param char: The new character to set at the provided index >>> freq_char = FrequentCharacter(\\"abacad\\") >>> freq_char.update(1, 'c') # Test cases def test_initial_query(): freq_char = FrequentCharacter(\\"abacad\\") assert freq_char.query(0, 2) == 'a' assert freq_char.query(2, 4) == 'a' assert freq_char.query(0, 5) == 'a' assert freq_char.query(3, 5) == 'a' assert freq_char.query(4, 5) == 'a' def test_update_and_query(): freq_char = FrequentCharacter(\\"abacad\\") freq_char.update(1, 'c') assert freq_char.query(0, 2) == 'a' assert freq_char.query(0, 5) == 'a' assert freq_char.query(1, 3) == 'c' freq_char.update(2, 'c') assert freq_char.query(0, 5) == 'c' assert freq_char.query(2, 4) == 'c' def test_edge_cases(): freq_char = FrequentCharacter(\\"aaa\\") assert freq_char.query(0, 2) == 'a' freq_char.update(0, 'b') assert freq_char.query(0, 2) == 'a' freq_char.update(1, 'b') assert freq_char.query(0, 2) == 'b' freq_char.update(2, 'b') assert freq_char.query(0, 2) == 'b' assert freq_char.query(1, 2) == 'b'","solution":"from collections import Counter class FrequentCharacter: def __init__(self, s): self.s = list(s) # Store string as a list to enable mutable operations def query(self, left, right): Returns the character that appears most frequently in the substring s[left:right + 1]. If there are multiple characters with the same highest frequency, return the lexicographically smallest one. substring = self.s[left:right + 1] count = Counter(substring) # Find the max frequency max_freq = max(count.values()) # Find the lexicographically smallest character with the max frequency result = min([char for char in count if count[char] == max_freq]) return result def update(self, index, char): Updates the character at position index in the string s to char. self.s[index] = char"},{"question":"class TextEditor: A text editor class that supports basic text manipulation and undo operations. Methods: - TextEditor(): Initializes the text editor with an empty string. - addText(text: str): Appends the given text to the current text in the editor. - undo(): Reverts the text in the editor to the state it was in just before the most recent addText operation. - getText() -> str: Returns the current text in the editor. >>> editor = TextEditor() >>> editor.getText() == \\"\\" True >>> editor.addText(\\"hello\\") >>> editor.getText() == \\"hello\\" True >>> editor.addText(\\" world\\") >>> editor.getText() == \\"hello world\\" True >>> editor.undo() >>> editor.getText() == \\"hello\\" True >>> editor.undo() >>> editor.getText() == \\"\\" True from solution import TextEditor def test_initial_state(): editor = TextEditor() assert editor.getText() == \\"\\" def test_add_text(): editor = TextEditor() editor.addText(\\"hello\\") assert editor.getText() == \\"hello\\" editor.addText(\\" world\\") assert editor.getText() == \\"hello world\\" def test_undo_once(): editor = TextEditor() editor.addText(\\"hello\\") editor.addText(\\" world\\") editor.undo() assert editor.getText() == \\"hello\\" def test_undo_multiple_times(): editor = TextEditor() editor.addText(\\"hello\\") editor.addText(\\" world\\") editor.addText(\\" again\\") assert editor.getText() == \\"hello world again\\" editor.undo() assert editor.getText() == \\"hello world\\" editor.undo() assert editor.getText() == \\"hello\\" def test_undo_with_no_previous_actions(): editor = TextEditor() editor.undo() assert editor.getText() == \\"\\"","solution":"class TextEditor: def __init__(self): self.current_text = \\"\\" self.history = [] def addText(self, text): self.history.append(self.current_text) self.current_text += text def undo(self): if self.history: self.current_text = self.history.pop() def getText(self): return self.current_text"},{"question":"from typing import List def min_time(tasks: List[int], n: int) -> int: Find the minimum time needed to complete all tasks, given that you must wait for at least \`n\` units of time before executing the same task again. Args: tasks (List[int]): List of integers representing task CPU times. n (int): Cooldown period between two same tasks. Returns: int: The minimum time required to complete all tasks. >>> min_time([1], 2) == 1 >>> min_time([1, 2, 3], 0) == 3 >>> min_time([1, 1, 2, 1], 2) == 7 >>> min_time([], 2) == 0 >>> min_time([1, 1, 1, 2, 2, 3], 2) == 7 >>> min_time([1, 2, 1, 2, 1, 2], 2) == 8","solution":"from collections import Counter def minTime(tasks, n): Returns the minimum time required to complete all tasks with cooldown period. if not tasks: return 0 task_counts = Counter(tasks) max_freq = max(task_counts.values()) num_max_freq_tasks = list(task_counts.values()).count(max_freq) part_count = max_freq - 1 part_length = n - (num_max_freq_tasks - 1) empty_slots = part_count * part_length available_tasks = len(tasks) - max_freq * num_max_freq_tasks idles = max(0, empty_slots - available_tasks) return len(tasks) + idles"},{"question":"def shift_array(nums, k): Moves the first k elements of the array to the end in the same order, and shifts the remaining elements to the beginning. Return the modified array. >>> shift_array([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> shift_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> shift_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> shift_array([1, 2, 3, 4, 5], 6) [1, 2, 3, 4, 5] >>> shift_array([1], 1) [1] >>> shift_array([], 3) [] >>> shift_array([1, 2, 3, 4, 5], -1) [1, 2, 3, 4, 5]","solution":"def shift_array(nums, k): Moves the first k elements of the array to the end in the same order, and shifts the remaining elements to the beginning. n = len(nums) if n == 0 or k <= 0 or k >= n: return nums nums[:] = nums[k:] + nums[:k] return nums"},{"question":"def heap_sort(arr): Given an array of integers, sort the array in ascending order using the heap sort algorithm. You should not use any built-in sort functions or libraries. Output the sorted array. >>> heap_sort([]) == [] True >>> heap_sort([1]) == [1] True >>> heap_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] True >>> heap_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] True >>> heap_sort([3, 1, 4, 1, 5, 9, 2, 6, 5]) == [1, 1, 2, 3, 4, 5, 5, 6, 9] True >>> heap_sort([-3, -1, -4, -1, -5, -9, -2, -6, -5]) == [-9, -6, -5, -5, -4, -3, -2, -1, -1] True pass","solution":"def heapify(arr, n, i): Converts a subtree rooted with node i into a max heap. n is the size of the heap i is the index in arr[] largest = i # Initialize largest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if left < n and arr[i] < arr[left]: largest = left # See if right child of root exists and is greater than root if right < n and arr[largest] < arr[right]: largest = right # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root. heapify(arr, n, largest) def heap_sort(arr): Performs heap sort on the input array. n = len(arr) # Build a maxheap. for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) # One by one extract elements for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0) return arr"},{"question":"def can_partition(nums: List[int], target: int) -> bool: Determines if the nums array can be partitioned into two subsets such that the sum of both subsets is equal and each subset's total is equal to the target. >>> can_partition([1, 5, 11, 5], 11) True >>> can_partition([1, 2, 3, 5], 5) False >>> can_partition([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 5) True >>> can_partition([1, 2, 3, 4, 5], 7) False >>> can_partition([3, 3, 3, 4, 5], 9) True >>> can_partition([1, 2, 5], 7) False","solution":"def can_partition(nums, target): Determines if the nums array can be partitioned into two subsets each with a sum equal to the target. total_sum = sum(nums) # Check if total sum is less than twice the target or the sum is odd if total_sum < 2 * target or total_sum % 2 != 0: return False current_target = total_sum // 2 n = len(nums) dp = [False] * (current_target + 1) dp[0] = True for num in nums: for i in range(current_target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[current_target - target]"},{"question":"from typing import List def largest_number(nums: List[int]) -> str: Arrange a list of non-negative integers to form the largest possible number and return it as a string. >>> largest_number([10, 2]) \\"210\\" >>> largest_number([1, 1, 1]) \\"111\\" >>> largest_number([0, 0]) \\"0\\" >>> largest_number([0, 1]) \\"10\\" >>> largest_number([3, 30, 34, 5, 9]) \\"9534330\\" >>> largest_number([128, 12]) \\"12812\\" >>> largest_number([0, 0, 0, 0]) \\"0\\"","solution":"from functools import cmp_to_key def largest_number(nums): Arrange numbers to form the largest possible number and return it as a string. # Custom comparator to decide the order based on string concatenation def compare(x, y): if x + y > y + x: return -1 if x + y < y + x: return 1 return 0 # Convert numbers to strings for comparison nums_str = list(map(str, nums)) # Sort using the custom comparator nums_str.sort(key=cmp_to_key(compare)) # Join the sorted strings largest_num = ''.join(nums_str) # Handle the case where the number is zero if largest_num[0] == '0': return '0' return largest_num"},{"question":"def min_length_subsequence(arr: List[int], target: int) -> int: Returns the minimum length of a subsequence that sums to the target. If there is no such subsequence, returns -1. >>> min_length_subsequence([1, 2, 3, 4, 5], 9) 2 >>> min_length_subsequence([2, 3, 1, 2, 4, 3], 7) 2 >>> min_length_subsequence([1, 2, 3, 4, 5], 15) 5 >>> min_length_subsequence([1, 2, 3, 4, 5], 16) -1 >>> min_length_subsequence([5, 3, 2, 1], 8) 2 >>> min_length_subsequence([], 1) -1 >>> min_length_subsequence([1, 2, 3], 6) 3 >>> min_length_subsequence([1, 2], 10) -1 >>> min_length_subsequence([1], 1) 1 >>> min_length_subsequence([2], 1) -1 >>> min_length_subsequence([1], 2) -1 >>> min_length_subsequence([2, 2, 2, 2], 4) 2 >>> min_length_subsequence([2, 2, 2, 2], 8) 4 >>> min_length_subsequence([2, 2, 2, 2], 10) -1","solution":"def min_length_subsequence(arr, target): Returns the minimum length of a subsequence that sums to the target. If there is no such subsequence, returns -1. # We will use dynamic programming to solve this problem. from collections import defaultdict # Initialize a dictionary to store the minimum length for each possible sum dp = defaultdict(lambda: float('inf')) dp[0] = 0 # Iterate over each element in the array for num in arr: # Copy the current state of dp to avoid modifying it during iteration current_dp = dp.copy() for curr_sum, length in current_dp.items(): new_sum = curr_sum + num dp[new_sum] = min(dp[new_sum], length + 1) # Check if we have found a subsequence summing to target return dp[target] if dp[target] != float('inf') else -1"},{"question":"def count_filled_rows_and_columns(mat): Returns the number of rows and columns that are completely filled with 1s. Parameters: mat (list of list of int): The binary matrix Returns: int: Number of rows and columns filled with 1s Examples: >>> count_filled_rows_and_columns([[0, 1, 0], [1, 0, 1], [0, 1, 0]]) 0 >>> count_filled_rows_and_columns([[1, 1], [1, 1]]) 4 >>> count_filled_rows_and_columns([[1, 1, 0], [1, 1, 1], [1, 1, 1]]) 4 >>> count_filled_rows_and_columns([[1, 1, 1], [0, 1, 0], [1, 0, 1]]) 1 >>> count_filled_rows_and_columns([[1, 0, 0], [1, 1, 0], [1, 0, 0]]) 1 >>> count_filled_rows_and_columns([[1, 1, 0], [1, 1, 1], [1, 1, 0], [0, 1, 1]]) 2","solution":"def count_filled_rows_and_columns(mat): Returns the number of rows and columns that are completely filled with 1s. Parameters: mat (list of list of int): The binary matrix Returns: int: Number of rows and columns filled with 1s m = len(mat) n = len(mat[0]) filled_rows = set() filled_columns = set() # Check for filled rows for i in range(m): if all(mat[i][j] == 1 for j in range(n)): filled_rows.add(i) # Check for filled columns for j in range(n): if all(mat[i][j] == 1 for i in range(m)): filled_columns.add(j) return len(filled_rows) + len(filled_columns)"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Calculates the area of the largest rectangle in the histogram represented by heights. Arguments: heights -- list of integers representing the height of histogram bars Returns: The area of the largest rectangle. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 >>> largestRectangleArea([]) 0 >>> largestRectangleArea([1]) 1 >>> largestRectangleArea([2, 1, 2]) 3 >>> largestRectangleArea([2, 2, 2, 2]) 8 >>> largestRectangleArea([4, 3, 2, 1]) 6 >>> largestRectangleArea([1, 2, 3, 4]) 6 >>> largestRectangleArea([6, 7, 5, 4, 6, 6, 7]) 28","solution":"def largestRectangleArea(heights): Calculates the area of the largest rectangle in the histogram represented by heights. Arguments: heights -- list of integers representing the height of histogram bars Returns: The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top = stack.pop() if stack: area = heights[top] * (index - stack[-1] - 1) else: area = heights[top] * index max_area = max(max_area, area) while stack: top = stack.pop() if stack: area = heights[top] * (index - stack[-1] - 1) else: area = heights[top] * index max_area = max(max_area, area) return max_area"},{"question":"class CircularQueue: A class representing a circular queue with fixed capacity. Methods: * CircularQueue(int k) - Constructor to initialize the queue with a size \`k\`. * bool enQueue(int value) - Adds an item to the rear of the queue. Returns \`true\` if the operation is successful, \`false\` otherwise. * bool deQueue() - Deletes an item from the front of the queue. Returns \`true\` if the operation is successful, \`false\` otherwise. * int Front() - Gets the front item from the queue. If the queue is empty, return \`-1\`. * int Rear() - Gets the last item from the queue. If the queue is empty, return \`-1\`. * bool isEmpty() - Checks whether the queue is empty. * bool isFull() - Checks whether the queue is full. >>> cq = CircularQueue(3) >>> cq.isEmpty() True >>> cq.isFull() False >>> cq.enQueue(1) True >>> cq.enQueue(2) True >>> cq.enQueue(3) True >>> cq.enQueue(4) False >>> cq.Front() 1 >>> cq.Rear() 3 >>> cq.isFull() True >>> cq.deQueue() True >>> cq.deQueue() True >>> cq.Front() 3 >>> cq.Rear() 3 >>> cq.isFull() False >>> cq.isEmpty() False >>> cq.deQueue() True >>> cq.isEmpty() True >>> cq.deQueue() False >>> cq.Front() -1 >>> cq.Rear() -1 def __init__(self, k: int): pass def enQueue(self, value: int) -> bool: pass def deQueue(self) -> bool: pass def Front(self) -> int: pass def Rear(self) -> int: pass def isEmpty(self) -> bool: pass def isFull(self) -> bool: pass","solution":"class CircularQueue: def __init__(self, k: int): self.size = k self.queue = [None] * k self.head = -1 self.tail = -1 def enQueue(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.head = 0 self.tail = (self.tail + 1) % self.size self.queue[self.tail] = value return True def deQueue(self) -> bool: if self.isEmpty(): return False if self.head == self.tail: self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.size return True def Front(self) -> int: if self.isEmpty(): return -1 return self.queue[self.head] def Rear(self) -> int: if self.isEmpty(): return -1 return self.queue[self.tail] def isEmpty(self) -> bool: return self.head == -1 def isFull(self) -> bool: return (self.tail + 1) % self.size == self.head"},{"question":"def remove_outer_parentheses(s: str) -> str: Given a string \`s\` consisting of lowercase letters, remove the outermost parentheses of every primitive string in the primitive decomposition of \`s\`. A primitive string is defined as a non-empty substring of \`s\` that can be entirely decomposed into valid pairs of parentheses and is not further decomposable into smaller valid pairs. Return the resulting string after removing the outermost parentheses of every primitive substring. >>> remove_outer_parentheses(\\"(()())(())\\") \\"()()()\\" >>> remove_outer_parentheses(\\"(()())(())(()(()))\\") \\"()()()()(())\\" >>> remove_outer_parentheses(\\"()\\") \\"\\" >>> remove_outer_parentheses(\\"((())())(())\\") \\"(())()()\\" >>> remove_outer_parentheses(\\"\\") \\"\\" >>> remove_outer_parentheses(\\"((()))\\") \\"(())\\" >>> remove_outer_parentheses(\\"()()\\") \\"\\"","solution":"def remove_outer_parentheses(s): This function removes the outermost parentheses of every primitive string in the primitive decomposition of the input string. result = [] opened = 0 for char in s: if char == '(': if opened > 0: result.append(char) opened += 1 elif char == ')': if opened > 1: result.append(char) opened -= 1 return ''.join(result)"},{"question":"def max_count(m, n, instructions): Returns the number of cells in the grid with the maximum integer value after performing all the instructions. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. instructions (List[Tuple[int, int]]): List of instructions where each instruction is a point (x, y). Returns: int: Number of cells with the maximum integer value. >>> max_count(3, 3, []) == 9 >>> max_count(3, 3, [(2, 2)]) == 4 >>> max_count(3, 3, [(2, 2), (3, 3), (1, 2)]) == 2 >>> max_count(3, 3, [(2, 2), (2, 2), (2, 2)]) == 4 >>> max_count(3, 3, [(3, 3), (3, 3), (3, 3)]) == 9 >>> max_count(5, 5, [(4, 4), (2, 2), (3, 3)]) == 4","solution":"def max_count(m, n, instructions): Returns the number of cells in the grid with the maximum integer value after performing all the instructions. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. instructions (List[Tuple[int, int]]): List of instructions where each instruction is a point (x, y). Returns: int: Number of cells with the maximum integer value. if not instructions: return m * n x_min = min(x for x, y in instructions) y_min = min(y for x, y in instructions) return x_min * y_min"},{"question":"from typing import List def findSubarrays(nums: List[int], target: int) -> List[List[int]]: Given a list of integers, returns all contiguous subarrays whose sum equals the target value. Examples: >>> findSubarrays([1, 2, 3], 2) [[2]] >>> findSubarrays([1, 2, 3, 4, 5], 5) [[2, 3], [5]] >>> findSubarrays([1, 2, 3], 10) [] >>> findSubarrays([2, 3, 5], 10) [[2, 3, 5]] >>> findSubarrays([1, 1, 1, 1, 1], 2) [[1, 1], [1, 1], [1, 1], [1, 1]] >>> findSubarrays([2, 2, 2], 4) [[2, 2], [2, 2]]","solution":"from typing import List def findSubarrays(nums: List[int], target: int) -> List[List[int]]: Returns all contiguous subarrays whose sum equals the target value. result = [] for start in range(len(nums)): current_sum = 0 for end in range(start, len(nums)): current_sum += nums[end] if current_sum == target: result.append(nums[start:end+1]) return result"},{"question":"def min_removal_for_increasing(heights: List[int]) -> int: Returns the minimum number of trees that need to be removed to form a strictly increasing sequence. >>> min_removal_for_increasing([1, 2, 3, 4, 5]) == 0 >>> min_removal_for_increasing([5, 4, 3, 2, 1]) == 4 >>> min_removal_for_increasing([3, 1, 2, 4, 5]) == 1 >>> min_removal_for_increasing([1, 3, 2, 4]) == 1 >>> min_removal_for_increasing([10]) == 0 >>> min_removal_for_increasing([4, 4, 4, 4]) == 3 >>> min_removal_for_increasing([]) == 0","solution":"def min_removal_for_increasing(heights): Returns the minimum number of trees that need to be removed to form a strictly increasing sequence. if not heights: return 0 n = len(heights) # Create a list to store the length of the longest increasing subsequence that ends with heights[i] lis = [1] * n for i in range(1, n): for j in range(i): if heights[i] > heights[j]: lis[i] = max(lis[i], lis[j] + 1) # The length of the longest increasing subsequence max_lis = max(lis) # Minimum number of removals is the total number of trees minus the length of the longest increasing subsequence return n - max_lis"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(preorder, inorder): Constructs a binary search tree from its preorder and inorder traversals. >>> preorder = [1] >>> inorder = [1] >>> result = buildTree(preorder, inorder) >>> result.val 1 >>> preorder = [1, 2, 3] >>> inorder = [2, 1, 3] >>> result = buildTree(preorder, inorder) >>> result.val 1 >>> result.left.val 2 >>> result.right.val 3 >>> preorder = [3, 9, 20, 15, 7] >>> inorder = [9, 3, 15, 20, 7] >>> result = buildTree(preorder, inorder) >>> result.val 3 >>> result.left.val 9 >>> result.right.val 20 >>> result.right.left.val 15 >>> result.right.right.val 7 >>> preorder = [3, 2, 1] >>> inorder = [1, 2, 3] >>> result = buildTree(preorder, inorder) >>> result.val 3 >>> result.left.val 2 >>> result.left.left.val 1 >>> preorder = [1, 2, 3] >>> inorder = [1, 2, 3] >>> result = buildTree(preorder, inorder) >>> result.val 1 >>> result.right.val 2 >>> result.right.right.val 3","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(preorder, inorder): Constructs a binary search tree from its preorder and inorder traversals. if not preorder or not inorder: return None # Root is always the first element in preorder traversal root_val = preorder[0] root = TreeNode(root_val) # Find the root element in inorder traversal to divide left and right subtrees root_index_in_inorder = inorder.index(root_val) # Elements to the left of root_index_in_inorder in inorder are the left subtree left_inorder = inorder[:root_index_in_inorder] # Elements to the right of root_index_in_inorder in inorder are the right subtree right_inorder = inorder[root_index_in_inorder + 1:] # Elements in preorder corresponding to left and right inorder left_preorder = preorder[1:1 + len(left_inorder)] right_preorder = preorder[1 + len(left_inorder):] # Recursively build left and right subtrees root.left = buildTree(left_preorder, left_inorder) root.right = buildTree(right_preorder, right_inorder) return root"},{"question":"from typing import List def max_height_difference(grid: List[List[int]]) -> int: Returns the maximum height difference between two adjacent stacks in the warehouse. Arguments: grid -- A 2D integer matrix representing the warehouse Returns: int -- The maximum height difference between two adjacent stacks Examples: >>> max_height_difference([[5]]) 0 >>> max_height_difference([[1, 1], [1, 1]]) 0 >>> max_height_difference([[1, 2], [3, 4]]) 2 >>> max_height_difference([ ... [1, 3, 4], ... [2, 8, 5], ... [3, 6, 7] ...]) 6 >>> max_height_difference([ ... [1, -3], ... [4, -5] ...]) 9","solution":"def max_height_difference(grid): Returns the maximum height difference between two adjacent stacks in the warehouse. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) max_diff = 0 for i in range(m): for j in range(n): if i > 0: # Check top max_diff = max(max_diff, abs(grid[i][j] - grid[i-1][j])) if i < m - 1: # Check bottom max_diff = max(max_diff, abs(grid[i][j] - grid[i+1][j])) if j > 0: # Check left max_diff = max(max_diff, abs(grid[i][j] - grid[i][j-1])) if j < n - 1: # Check right max_diff = max(max_diff, abs(grid[i][j] - grid[i][j+1])) return max_diff"},{"question":"def count_isolated_networks(networks: List[List[int]]) -> int: Identify the number of isolated networks in a given list of networks represented by adjacency lists. Parameters: networks (list of lists): List of adjacency lists representing different networks. Returns: int: Number of isolated networks. >>> count_isolated_networks([[0, 1, 2]]) == 1 >>> count_isolated_networks([[0, 1, 2], [3, 4], [5]]) == 3 >>> count_isolated_networks([]) == 0 >>> count_isolated_networks([[1], [2], [3]]) == 3 >>> count_isolated_networks([[1, 2, 3], [4, 5, 6, 7, 8], [9, 10]]) == 3","solution":"def count_isolated_networks(networks): Returns the count of isolated networks. Parameters: networks (list of lists): List of adjacency lists representing different networks. Returns: int: Number of isolated networks. return len(networks)"},{"question":"def two_sum(nums: List[int], target: int) -> Tuple[int, int]: Returns the indices of the two numbers in the array that add up to the target. :param nums: List of integers :param target: Integer target sum :return: Tuple of two indices >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([-3, 4, 3, 90], 0) (0, 2) >>> two_sum([10000000, 29999999, 20000000, 7000000], 30000000) (0, 2) >>> two_sum([1, 5, 3, 6], 9) (2, 3)","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the array that add up to the target. :param nums: List of integers :param target: Integer target sum :return: Tuple of two indices num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i"},{"question":"def reverse_words(s: str) -> str: Reverses the characters in each word of the sentence while keeping the words in the same order. Parameters: s (str): The input sentence containing words separated by spaces. Returns: str: The sentence with each word's characters reversed. pass # Unit Tests def test_reverse_words_single_word(): assert reverse_words(\\"hello\\") == \\"olleh\\" def test_reverse_words_two_words(): assert reverse_words(\\"hello world\\") == \\"olleh dlrow\\" def test_reverse_words_multiple_words(): assert reverse_words(\\"this is a test\\") == \\"siht si a tset\\" def test_reverse_words_with_spaces(): assert reverse_words(\\"a b c\\") == \\"a b c\\" def test_reverse_words_empty_string(): assert reverse_words(\\"\\") == \\"\\"","solution":"def reverse_words(s: str) -> str: Reverses the characters in each word of the sentence while keeping the words in the same order. Parameters: s (str): The input sentence containing words separated by spaces. Returns: str: The sentence with each word's characters reversed. return ' '.join(word[::-1] for word in s.split())"},{"question":"def min_concat_cost(words: List[str], dict: Dict[str, int]) -> int: Returns the minimum cost to concatenate all words in the given order using the dictionary of pair costs. If it's not possible to concatenate all words, returns -1. def test_case_1(): words = [\\"a\\", \\"b\\", \\"c\\"] dict = {\\"ab\\": 1, \\"bc\\": 2} assert min_concat_cost(words, dict) == 3 def test_case_2(): words = [\\"a\\", \\"b\\"] dict = {\\"ab\\": 5} assert min_concat_cost(words, dict) == 5 def test_case_3(): words = [\\"x\\", \\"y\\", \\"z\\"] dict = {\\"xy\\": 3, \\"yz\\": 4, \\"xz\\": 7} assert min_concat_cost(words, dict) == 7 def test_case_4(): words = [\\"a\\", \\"b\\", \\"c\\"] dict = {\\"ab\\": 1, \\"bc\\": 2, \\"abc\\": 5} assert min_concat_cost(words, dict) == 3 def test_case_5(): words = [\\"a\\", \\"b\\", \\"c\\"] dict = {\\"ab\\": 1} assert min_concat_cost(words, dict) == -1 def test_case_6(): words = [] dict = {} assert min_concat_cost(words, dict) == 0 def test_case_7(): words = [\\"hello\\", \\"world\\"] dict = {\\"helloworld\\": 10} assert min_concat_cost(words, dict) == 10","solution":"def min_concat_cost(words, dict): Returns the minimum cost to concatenate all words in the given order using the dictionary of pair costs. If it's not possible to concatenate all words, returns -1. n = len(words) if n == 0: return 0 dp = [[float('inf')] * n for _ in range(n)] for i in range(n): current_word = words[i] for j in range(i + 1, n): combined = current_word + words[j] if combined in dict: dp[i][j] = dict[combined] dp[j][i] = dict[combined] for k in range(n): for i in range(n): for j in range(n): if dp[i][k] != float('inf') and dp[k][j] != float('inf'): dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]) minimum_cost = sum(dp[i][i + 1] for i in range(n - 1)) return minimum_cost if minimum_cost != float('inf') else -1"},{"question":"from typing import List def can_form_palindrome(nums: List[int]) -> bool: Given an array \`nums\` consisting of positive integers, determine if there exists a set of three distinct elements such that any permutation of these three elements can be concatenated to form a palindrome. Return \`true\` if such a set exists, otherwise return \`false\`. >>> can_form_palindrome([2, 2, 3, 4]) True >>> can_form_palindrome([1, 1, 1]) True >>> can_form_palindrome([1, 2, 3, 4]) False >>> can_form_palindrome([]) False >>> can_form_palindrome([1, 1]) False >>> can_form_palindrome([1, 1, 2]) False >>> can_form_palindrome([5, 5, 5, 7, 7, 8]) True","solution":"def can_form_palindrome(nums): Returns True if there exists a set of three distinct elements such that any permutation of these three elements can be concatenated to form a palindrome. from collections import Counter # Count the occurrences of each element counter = Counter(nums) # We want to check for the situation where at least 3 distinct elements exist where: # - One of them appears at least twice, and the other at least once, OR # - One appears at least thrice for key, value in counter.items(): if value >= 3: return True # Any permutation of three identical numbers works (e.g., 111) # Check for at least one pair and one different element count_pairs = close_to_unity = 0 for value in counter.values(): if value >= 2: count_pairs += 1 if value >= 1: close_to_unity += 1 return count_pairs >= 1 and close_to_unity >= 3 # Example usage: # print(can_form_palindrome([2, 2, 3, 4])) # Should return True (since [2, 2, 3] can form 223) # print(can_form_palindrome([1, 2, 3, 4])) # Should return False"},{"question":"def are_permutations(arr1, arr2): Determines if two arrays are permutations of each other. :param arr1: First list of integers :param arr2: Second list of integers :return: True if arr1 and arr2 have the same elements with the same frequencies, False otherwise >>> are_permutations([1, 2, 2], [1, 2]) False >>> are_permutations([1, 2, 2], [2, 1, 2]) True >>> are_permutations([3, 1, 2], [2, 3, 1]) True >>> are_permutations([1, 2, 3], [1, 2, 4]) False >>> are_permutations([], []) True >>> are_permutations([1, 2, 3], []) False >>> are_permutations([5], [5]) True >>> are_permutations([5], [6]) False >>> are_permutations([1]*1000 + [2]*1000, [2]*1000 + [1]*1000) True","solution":"from collections import Counter def are_permutations(arr1, arr2): Determines if two arrays are permutations of each other. :param arr1: First list of integers :param arr2: Second list of integers :return: True if arr1 and arr2 have the same elements with the same frequencies, False otherwise return Counter(arr1) == Counter(arr2)"},{"question":"def longest_str_chain(words: List[str]) -> int: Returns the length of the longest chain of words in which each word is a predecessor of the next word in the chain. >>> longest_str_chain([\\"a\\",\\"b\\",\\"ba\\",\\"bca\\",\\"bda\\",\\"bdca\\"]) == 4 >>> longest_str_chain([\\"word\\"]) == 1 >>> longest_str_chain([\\"abcd\\",\\"efgh\\",\\"ijkl\\"]) == 1 >>> longest_str_chain([\\"a\\", \\"ab\\"]) == 2 >>> longest_str_chain([\\"a\\", \\"ab\\", \\"abc\\"]) == 3 >>> longest_str_chain([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\"]) == 5","solution":"from collections import defaultdict def longestStrChain(words): Returns the length of the longest chain of words in which each word is a predecessor of the next word in the chain. words.sort(key=len) # Sort words based on their lengths word_dict = defaultdict(int) max_chain_length = 1 for word in words: for i in range(len(word)): predecessor = word[:i] + word[i+1:] if predecessor in word_dict: word_dict[word] = max(word_dict[word], word_dict[predecessor] + 1) word_dict[word] = max(word_dict[word], 1) max_chain_length = max(max_chain_length, word_dict[word]) return max_chain_length"},{"question":"import random class RandomizedSet: Design a data structure that supports insert, delete, and getRandom operations. Implement the class with optimal time complexities for each function. - insert(val) -> bool: Inserts an item val to the data structure if not already present. Returns True if inserted successfully, otherwise False. - delete(val) -> bool: Removes an item val from the data structure if present. Returns True if deleted successfully, otherwise False. - getRandom() -> int: Returns a random element from the current set of elements. Each element must have the same probability of being returned. Example: >>> rs = RandomizedSet() >>> rs.insert(1) True >>> rs.insert(2) True >>> rs.getRandom() in {1, 2} True >>> rs.delete(1) True >>> rs.getRandom() 2 def test_insert(): rs = RandomizedSet() assert rs.insert(1) == True assert rs.insert(1) == False assert rs.insert(2) == True assert set(rs.data) == {1, 2} def test_delete(): rs = RandomizedSet() rs.insert(1) rs.insert(2) assert rs.delete(1) == True assert rs.delete(1) == False assert rs.delete(3) == False assert set(rs.data) == {2} def test_getRandom(): rs = RandomizedSet() rs.insert(1) rs.insert(2) rs.insert(3) random_element = rs.getRandom() assert random_element in {1, 2, 3} def test_complex_operations(): rs = RandomizedSet() assert rs.insert(10) == True assert rs.insert(20) == True assert rs.delete(10) == True assert rs.delete(30) == False assert rs.insert(20) == False random_element = rs.getRandom() assert random_element in {20} def test_insert_delete_getRandom(): rs = RandomizedSet() assert rs.insert(1) == True assert rs.insert(2) == True assert rs.insert(3) == True assert rs.delete(1) == True assert rs.insert(4) == True assert rs.delete(3) == True random_element = rs.getRandom() assert random_element in {2, 4}","solution":"import random class RandomizedSet: def __init__(self): Initialize your data structure here. self.data = [] self.data_dict = {} def insert(self, val: int) -> bool: Inserts a value to the set. Returns true if the set did not already contain the specified element. if val in self.data_dict: return False self.data_dict[val] = len(self.data) self.data.append(val) return True def delete(self, val: int) -> bool: Removes a value from the set. Returns true if the set contained the specified element. if val not in self.data_dict: return False index = self.data_dict[val] last_element = self.data[-1] self.data[index] = last_element self.data_dict[last_element] = index self.data.pop() del self.data_dict[val] return True def getRandom(self) -> int: Get a random element from the set. return random.choice(self.data)"},{"question":"def reverse_sentence(words: List[str]) -> str: Given a list of strings \`words\` representing a sentence split into individual words, reverse the order of the words while maintaining their original casing. >>> reverse_sentence([\\"Hello\\"]) == \\"Hello\\" >>> reverse_sentence([\\"Hello\\", \\"World\\"]) == \\"World Hello\\" >>> reverse_sentence([\\"The\\", \\"quick\\", \\"brown\\", \\"fox\\"]) == \\"fox brown quick The\\" >>> reverse_sentence([]) == \\"\\" >>> reverse_sentence([\\"hello\\", \\"hello\\", \\"world\\"]) == \\"world hello hello\\" >>> reverse_sentence([\\"The\\", \\"QUICK\\", \\"Brown\\", \\"FOX\\"]) == \\"FOX Brown QUICK The\\"","solution":"def reverse_sentence(words): Reverses the order of words in the given list while maintaining their original casing. :param words: list of strings :return: reversed sentence as a single string with words separated by a space return ' '.join(reversed(words))"},{"question":"from typing import List def insert_intervals(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]: Insert a new interval into the list of non-overlapping intervals, merging if necessary. :param intervals: List of non-overlapping intervals sorted by start times. :param newInterval: A new interval to insert and merge. :return: The list of merged intervals after insertion of the newInterval. >>> insert_intervals([[1, 3], [6, 9]], [2, 5]) [[1, 5], [6, 9]] >>> insert_intervals([[1, 2], [3, 5], [6, 7]], [8, 9]) [[1, 2], [3, 5], [6, 7], [8, 9]] >>> insert_intervals([[1, 2], [3, 5], [6, 7]], [0, 8]) [[0, 8]]","solution":"def insert_intervals(intervals, newInterval): Insert a new interval into the list of non-overlapping intervals, merging if necessary. :param intervals: List of non-overlapping intervals sorted by start times. :param newInterval: A new interval to insert and merge. :return: The list of merged intervals after insertion of the newInterval. merged = [] i, n = 0, len(intervals) # Add all intervals ending before newInterval starts while i < n and intervals[i][1] < newInterval[0]: merged.append(intervals[i]) i += 1 # Merge intervals that overlap with newInterval while i < n and intervals[i][0] <= newInterval[1]: newInterval[0] = min(newInterval[0], intervals[i][0]) newInterval[1] = max(newInterval[1], intervals[i][1]) i += 1 merged.append(newInterval) # Add the remaining intervals while i < n: merged.append(intervals[i]) i += 1 return merged"},{"question":"def can_sum_to_target(arr: List[int], target: int) -> bool: Given an array of positive integers and a target integer, insert an operator \`+\` or \`-\` between each pair of adjacent elements in the array to determine if it is possible to create an expression whose sum is equal to the target. Args: arr (List[int]): The array of positive integers. target (int): The target sum to achieve. Returns: bool: True if the target sum can be achieved, otherwise False. Examples: >>> can_sum_to_target([5], 5) True >>> can_sum_to_target([5], 3) False >>> can_sum_to_target([1, 2], 3) True >>> can_sum_to_target([1, 2], -1) True >>> can_sum_to_target([1, 1, 1, 1, 1, 1], 0) True >>> can_sum_to_target([1, 2, 3], 10) False >>> can_sum_to_target([], 0) True >>> can_sum_to_target([], 5) False >>> can_sum_to_target([100, 200, 300], -400) True >>> can_sum_to_target([100, 200, 300], 1000) False from typing import List","solution":"def can_sum_to_target(arr, target): Given an array of positive integers and a target integer, checks if it is possible to create a sum to target by placing '+' or '-' between each pair of adjacent elements. def helper(index, current_sum): if index == len(arr): return current_sum == target return helper(index + 1, current_sum + arr[index]) or helper(index + 1, current_sum - arr[index]) return helper(1, arr[0]) if arr else target == 0"},{"question":"class StreamChecker: You are given a data stream input of characters, and you have to implement the class \`StreamChecker\` that checks if a given string is a suffix of a previously seen sequence of characters. Specifically, implement the \`StreamChecker\` class to support the following methods: * \`StreamChecker(String[] words)\`: Initializes the \`StreamChecker\` object with a list of \`words\`. * \`boolean query(char letter)\`: Returns \`true\` if any prefix of the \`query\` string formed by appending \`letter\` to the previous \`query\` still matches some suffix of any of the input \`words\`, otherwise returns \`false\`. The \`StreamChecker\` class needs to efficiently handle the data stream and ensure that the check operation can be performed in an optimal manner for real-time processing of the input characters. def __init__(self, words: List[str]): Initialize the StreamChecker object with a list of words. pass def query(self, letter: str) -> bool: Return true if any suffix of the query string matches a word in the stream, false otherwise. pass # Example usage and test cases def test_stream_checker_single_query(): stream_checker = StreamChecker([\\"cd\\", \\"f\\", \\"kl\\"]) assert stream_checker.query('a') == False assert stream_checker.query('b') == False assert stream_checker.query('c') == False assert stream_checker.query('d') == True # 'cd' is a suffix assert stream_checker.query('e') == False assert stream_checker.query('f') == True # 'f' is a suffix assert stream_checker.query('k') == False assert stream_checker.query('l') == True # 'kl' is a suffix def test_stream_checker_multiple_words(): stream_checker = StreamChecker([\\"hell\\", \\"world\\", \\"dell\\"]) assert stream_checker.query('h') == False assert stream_checker.query('e') == False assert stream_checker.query('l') == False assert stream_checker.query('l') == True # 'hell' is a suffix stream_checker = StreamChecker([\\"abc\\", \\"xyz\\", \\"mnop\\"]) assert stream_checker.query('m') == False assert stream_checker.query('n') == False assert stream_checker.query('o') == False assert stream_checker.query('p') == True # 'mnop' is a suffix assert stream_checker.query('x') == False assert stream_checker.query('y') == False assert stream_checker.query('z') == True # 'xyz' is a suffix def test_stream_checker_empty_stream(): stream_checker = StreamChecker([\\"abc\\"]) assert stream_checker.query('a') == False assert stream_checker.query('b') == False assert stream_checker.query('c') == True # 'abc' is a suffix assert stream_checker.query('d') == False def test_stream_checker_empty_words(): stream_checker = StreamChecker([]) assert stream_checker.query('a') == False assert stream_checker.query('b') == False assert stream_checker.query('c') == False","solution":"class StreamChecker: def __init__(self, words): Initializes the StreamChecker object with a list of words. self.trie = {} self.stream = [] # Build a trie in reverse order (to facilitate checking suffixes) for word in words: node = self.trie for char in reversed(word): if char not in node: node[char] = {} node = node[char] node[''] = True # End of word def query(self, letter): Returns true if any suffix of the query string matches a word in the stream, false otherwise. self.stream.append(letter) node = self.trie # Check the latest character stream in reverse order for char in reversed(self.stream): if char in node: node = node[char] if '' in node: return True else: break return False"},{"question":"def max_pairs(nums: List[int]) -> int: You are given an array of integers \`nums\` representing the number of items in each group. You want to arrange all items into pairs such that each pair contains items from different groups. The pairing can be done in the following way: - Choose one item from group \`i\` and one item from group \`j\` (where \`i != j\`). - Once paired, these two items are removed from their respective groups. Return the maximum number of such pairs that can be formed. >>> max_pairs([10]) == 0 >>> max_pairs([2, 2, 2, 2]) == 4 >>> max_pairs([5, 1, 1, 1]) == 3 >>> max_pairs([3, 5, 2, 8, 1]) == 9 >>> max_pairs([10, 1, 1, 1, 1, 1]) == 5","solution":"def max_pairs(nums): Returns the maximum number of pairs that can be formed from different groups. total_items = sum(nums) max_possible_pairs = total_items // 2 return min(max_possible_pairs, sum(nums) - max(nums))"},{"question":"def remove_n_chars(s: str, n: int) -> str: Construct the lexicographically smallest string by removing exactly n characters from s. >>> remove_n_chars('abcde', 2) 'abc' >>> remove_n_chars('abcde', 0) 'abcde' >>> remove_n_chars('a', 1) '' >>> remove_n_chars('a', 0) 'a' >>> remove_n_chars('bbabbb', 3) 'abb' >>> remove_n_chars('cba', 2) 'a' >>> remove_n_chars('bacb', 1) 'acb' >>> remove_n_chars('bdaec', 2) 'aec' >>> remove_n_chars('abc', 3) ''","solution":"def remove_n_chars(s, n): Construct the lexicographically smallest string by removing exactly n characters from s. result = [] for char in s: # While there's still characters to remove and the last character in result is larger and removable while n > 0 and result and result[-1] > char: result.pop() n -= 1 result.append(char) # If there are still characters to remove, remove from the end return ''.join(result[:len(result) - n])"},{"question":"def reverseParentheses(s: str) -> str: Reverse the strings in each pair of matching parentheses starting from the innermost one. The result should not contain any brackets. >>> reverseParentheses(\\"(abcd)\\") 'dcba' >>> reverseParentheses(\\"(u(love)i)\\") 'iloveu' >>> reverseParentheses(\\"(ed(et(oc))el)\\") 'leetcode' >>> reverseParentheses(\\"abcde\\") 'abcde' >>> reverseParentheses(\\"\\") '' >>> reverseParentheses(\\"a(bcdefghijkl(mno)p)q\\") 'apmnolkjihgfedcbq' pass","solution":"def reverseParentheses(s): Reverse the strings in each pair of matching parentheses starting from the innermost one. The result should not contain any brackets. stack = [] for char in s: if char == ')': temp = [] while stack and stack[-1] != '(': temp.append(stack.pop()) stack.pop() # pop the '(' stack.extend(temp) else: stack.append(char) return ''.join(stack)"},{"question":"class MedianFinder: def __init__(self, k: int): Initializes the \`MedianFinder\` class with the maximum size \`k\`. pass def addNum(self, num: int): Adds the integer \`num\` to the stream. pass def findMedian(self) -> float: Returns the median of the last \`k\` elements. If the stream contains fewer than \`k\` elements, return the median of all elements in the stream. >>> mf = MedianFinder(3) >>> mf.addNum(1) >>> mf.findMedian() 1.0 >>> mf.addNum(5) >>> mf.findMedian() 3.0 >>> mf.addNum(3) >>> mf.findMedian() 3.0 >>> mf.addNum(8) >>> mf.findMedian() 5.0 pass import pytest def test_median_finder_initialization(): mf = MedianFinder(3) assert mf.k == 3 assert mf.findMedian() is None def test_add_num_and_find_median(): mf = MedianFinder(3) mf.addNum(1) assert mf.findMedian() == 1.0 mf.addNum(5) assert mf.findMedian() == 3.0 mf.addNum(3) assert mf.findMedian() == 3.0 mf.addNum(8) assert mf.findMedian() == 5.0 def test_median_with_less_than_k_elements(): mf = MedianFinder(5) mf.addNum(1) assert mf.findMedian() == 1.0 mf.addNum(4) assert mf.findMedian() == 2.5 mf.addNum(3) assert mf.findMedian() == 3.0 def test_median_with_more_than_k_elements(): mf = MedianFinder(4) mf.addNum(2) mf.addNum(3) assert mf.findMedian() == 2.5 mf.addNum(4) mf.addNum(5) assert mf.findMedian() == 3.5 mf.addNum(6) assert mf.findMedian() == 4.5 mf.addNum(7) assert mf.findMedian() == 5.5 def test_median_with_exactly_k_elements(): mf = MedianFinder(3) mf.addNum(10) mf.addNum(12) mf.addNum(14) assert mf.findMedian() == 12.0 mf.addNum(16) assert mf.findMedian() == 14.0 def test_median_order_preservation(): mf = MedianFinder(2) mf.addNum(1) assert mf.findMedian() == 1.0 mf.addNum(10) assert mf.findMedian() == 5.5 mf.addNum(5) assert mf.findMedian() == 7.5 mf.addNum(2) assert mf.findMedian() == 3.5","solution":"import heapq class MedianFinder: def __init__(self, k): self.k = k self.min_heap = [] self.max_heap = [] self.stream = [] def addNum(self, num): self.stream.append(num) if len(self.stream) > self.k: self.stream.pop(0) # Add to the appropriate heap if not self.max_heap or num <= -self.max_heap[0]: heapq.heappush(self.max_heap, -num) else: heapq.heappush(self.min_heap, num) # Balance the heaps if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def findMedian(self): if not self.stream: return None if len(self.stream) < self.k: data = sorted(self.stream) else: data = sorted(self.stream[-self.k:]) n = len(data) if n % 2 == 1: return float(data[n // 2]) else: return (data[n // 2 - 1] + data[n // 2]) / 2.0"},{"question":"def array_rank_transform(arr): Transforms the given array into its rank array. Args: arr (list): The input array. Returns: list: The rank array. pass # Test Cases def test_array_rank_transform(): assert array_rank_transform([40, 10, 20, 30]) == [4, 1, 2, 3] assert array_rank_transform([100, 200, 100, 200, 100]) == [1, 2, 1, 2, 1] assert array_rank_transform([20, 10, 30, 30, 40]) == [2, 1, 3, 3, 4] assert array_rank_transform([]) == [] assert array_rank_transform([5, 5, 5, 5]) == [1, 1, 1, 1] assert array_rank_transform([1]) == [1] assert array_rank_transform([-10, 0, 10, -10, 0]) == [1, 2, 3, 1, 2] def test_large_numbers(): assert array_rank_transform([100000, 10000, 1000, 100]) == [4, 3, 2, 1] def test_negative_numbers(): assert array_rank_transform([-5, -10, 0, 5]) == [2, 1, 3, 4] def test_mix_numbers(): assert array_rank_transform([3, 0, 100, -100, 50]) == [3, 2, 5, 1, 4] def test_duplicate_numbers(): assert array_rank_transform([30, 20, 10, 30, 30]) == [3, 2, 1, 3, 3]","solution":"def array_rank_transform(arr): Transforms the given array into its rank array. Args: arr (list): The input array. Returns: list: The rank array. if not arr: return [] sorted_unique_arr = sorted(set(arr)) rank_map = {value: rank + 1 for rank, value in enumerate(sorted_unique_arr)} return [rank_map[value] for value in arr]"},{"question":"def min_operations_to_make_equal(nums: List[int]) -> int: Calculate the minimum number of operations to make all heaps equal. Args: nums: List[int] -- A list of integers representing the number of stones in each heap. Returns: int -- The minimum number of operations needed to make all heaps contain the same number of stones. pass # Test cases def test_all_equal(): assert min_operations_to_make_equal([4, 4, 4]) == 0 def test_already_sorted(): assert min_operations_to_make_equal([1, 2, 3]) == 3 # remove 2 from 3, 1 from 2 def test_general_case(): assert min_operations_to_make_equal([7, 4, 3, 8]) == 6 def test_single_heap(): assert min_operations_to_make_equal([10]) == 0 def test_two_heaps(): assert min_operations_to_make_equal([5, 1]) == 1 def test_some_equal_some_not(): assert min_operations_to_make_equal([5, 5, 3, 3, 1]) == 6","solution":"def min_operations_to_make_equal(nums): Calculate the minimum number of operations to make all heaps equal. Args: nums: List[int] -- A list of integers representing the number of stones in each heap. Returns: int -- The minimum number of operations needed to make all heaps contain the same number of stones. # Sort the array in non-decreasing order nums.sort() # Initialize counters for operations and unique stone counts seen operations = 0 unique_count = 0 # Iterate through the array, counting the unique number of stone heaps seen so far # and adding it to the total number of operations needed. for i in range(1, len(nums)): if nums[i] != nums[i - 1]: unique_count += 1 operations += unique_count return operations"},{"question":"def countBits(n: int) -> List[int]: Returns an array ret where ret[i] is the number of 1 bits in the binary representation of i for 0  i  n. >>> countBits(0) == [0] >>> countBits(1) == [0, 1] >>> countBits(2) == [0, 1, 1] >>> countBits(3) == [0, 1, 1, 2] >>> countBits(4) == [0, 1, 1, 2, 1]","solution":"def countBits(n): Returns an array ret where ret[i] is the number of 1 bits in the binary representation of i for 0  i  n. ret = [0] * (n + 1) for i in range(1, n + 1): ret[i] = ret[i >> 1] + (i & 1) return ret"},{"question":"def max_cost(nums: List[int]) -> int: Returns the maximum total cost the traveler can incur without staying at adjacent hotels. >>> max_cost([1, 2, 3, 1]) 4 >>> max_cost([2, 7, 9, 3, 1]) 12 >>> max_cost([1, 3, 1, 3, 100]) 103","solution":"def max_cost(nums): Returns the maximum total cost the traveler can incur without staying at adjacent hotels. if not nums: return 0 n = len(nums) if n == 1: return nums[0] prev1 = 0 prev2 = 0 for cost in nums: current = max(prev1, prev2 + cost) prev2 = prev1 prev1 = current return prev1"},{"question":"def closed_island(grid: List[List[int]]) -> int: Returns the number of closed islands in the given grid. An island is considered closed if it is surrounded by water on all sides. >>> closed_island([ [1, 1, 1, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 1] ]) == 1 >>> closed_island([ [1, 1, 1, 1, 0], [1, 0, 0, 1, 0], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0] ]) == 1 >>> closed_island([ [1, 1, 1, 1], [1, 0, 0, 0], [1, 1, 0, 1], [0, 0, 1, 1] ]) == 0 >>> closed_island([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) == 0 >>> closed_island([ [1], [0], [1] ]) == 0 >>> closed_island([ [1, 0, 1] ]) == 0 pass","solution":"def closed_island(grid): Returns the number of closed islands in the given grid. An island is considered closed if it is surrounded by water on all sides. if not grid: return 0 rows, cols = len(grid), len(grid[0]) def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols: return False if grid[r][c] == 1: return True grid[r][c] = 1 # Mark as visited up = dfs(r - 1, c) down = dfs(r + 1, c) left = dfs(r, c - 1) right = dfs(r, c + 1) return up and down and left and right closed_islands = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 0: if dfs(i, j): closed_islands += 1 return closed_islands"},{"question":"from typing import List import random def find_kth_smallest(arr: List[int], k: int) -> int: Find the kth smallest element in an unsorted array. Args: arr: List[int] - The array of integers. k: int - The order of the smallest element to find. Returns: int - The kth smallest element in the array. >>> find_kth_smallest([3, 1, 2, 5, 4], 1) 1 >>> find_kth_smallest([3, 1, 2, 5, 4], 3) 3 >>> find_kth_smallest([3, 1, 2, 5, 4], 5) 5 >>> find_kth_smallest([1, 3, 3, 3, 2, 1], 1) 1 >>> find_kth_smallest([1, 3, 3, 3, 2, 1], 2) 1 >>> find_kth_smallest([1, 3, 3, 3, 2, 1], 4) 3 >>> find_kth_smallest([100, 44, 3, 55, 17, 18], 6) 100 >>> find_kth_smallest([0, -2, 3, -4, 5, -1], 1) -4 >>> find_kth_smallest([0, -2, 3, -4, 5, -1], 2) -2 >>> find_kth_smallest([11, 14, 14, 14, 12, 11, 13], 1) 11 >>> find_kth_smallest([11, 14, 14, 14, 12, 11, 13], 3) 12 >>> find_kth_smallest([11, 14, 14, 14, 12, 11, 13], 5) 14","solution":"import random def partition(arr, left, right, pivot_index): pivot_value = arr[pivot_index] # Move pivot to end arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left # Move all smaller elements to the left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 # Move pivot to its final place arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def quickselect(arr, left, right, k_smallest): Returns the k-th smallest element of list within left..right if left == right: # If the list contains only one element, return arr[left] # Return that element # Select a random pivot_index between pivot_index = random.randint(left, right) # Find the pivot position in a sorted list pivot_index = partition(arr, left, right, pivot_index) # The pivot is in its final sorted position if k_smallest == pivot_index: return arr[k_smallest] # go left elif k_smallest < pivot_index: return quickselect(arr, left, pivot_index - 1, k_smallest) # go right else: return quickselect(arr, pivot_index + 1, right, k_smallest) def find_kth_smallest(arr, k): return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"from typing import List def max_path_sum(grid: List[List[int]]) -> int: Returns the maximum sum of integers collected on a valid path from the top-left to the bottom-right corner in a grid where you can only move right or down and cannot step on any cell that contains a negative integer. :param grid: List[List[int]]: The m x n grid :return: int: The maximum sum of collected integers or -1 if no valid path exists >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> max_path_sum(grid) 29 >>> grid = [ ... [1, -2, 3], ... [4, 5, -6], ... [7, 8, 9] ... ] >>> max_path_sum(grid) 29 >>> grid = [ ... [1, -2, 3], ... [-4, 5, 6], ... [7, 8, 9] ... ] >>> max_path_sum(grid) -1 >>> grid = [[5]] >>> max_path_sum(grid) 5 >>> grid = [[1, 2, 3, 4, 5]] >>> max_path_sum(grid) 15 >>> grid = [[1], [2], [3], [4], [5]] >>> max_path_sum(grid) 15 >>> grid = [ ... [-1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> max_path_sum(grid) -1 >>> grid = [ ... [1, 2, 3], ... [4, 5, -6], ... [7, 8, -9] ... ] >>> max_path_sum(grid) -1","solution":"def max_path_sum(grid): Returns the maximum sum of integers collected on a valid path from the top-left to the bottom-right corner in a grid where you can only move right or down and cannot step on any cell that contains a negative integer. :param grid: List[List[int]]: The m x n grid :return: int: The maximum sum of collected integers or -1 if no valid path exists m, n = len(grid), len(grid[0]) if grid[0][0] < 0 or grid[m-1][n-1] < 0: return -1 for i in range(m): for j in range(n): if grid[i][j] < 0: grid[i][j] = float('-inf') else: if i == 0 and j == 0: continue if i == 0: # first row, can only come from the left grid[i][j] += grid[i][j-1] elif j == 0: # first column, can only come from above grid[i][j] += grid[i-1][j] else: grid[i][j] += max(grid[i-1][j], grid[i][j-1]) return grid[m-1][n-1] if grid[m-1][n-1] != float('-inf') else -1"},{"question":"def minPathSum(grid): Calculates the minimum path sum from top-left to bottom-right in a grid. You can only move either down or right at any point in time. Args: grid (List[List[int]]): 2D list of non-negative integers representing the cost grid Returns: int: Minimum cost to reach the bottom-right cell >>> minPathSum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> minPathSum([ ... [1, 2, 3] ... ]) 6 >>> minPathSum([ ... [1], ... [2], ... [3] ... ]) 6 >>> minPathSum([ ... [0] ... ]) 0 >>> minPathSum([ ... ]) 0 >>> minPathSum([ ... [] ... ]) 0","solution":"def minPathSum(grid): Calculates the minimum path sum from top-left to bottom-right in a grid. You can only move either down or right at any point in time. Args: grid (List[List[int]]): 2D list of non-negative integers representing the cost grid Returns: int: Minimum cost to reach the bottom-right cell if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) # Initialize the cost for the first cell dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Initialize the cost for the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the cost for the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Compute the minimum paths for the inner cells for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"from typing import List, Tuple def find_pairs_with_sum(arr: List[int], s: int) -> List[Tuple[int, int]]: Returns a sorted list of unique pairs (a, b) from arr such that a + b = s and a < b. >>> find_pairs_with_sum([1, 3, 2, 2, -1], 3) [(1, 2)] >>> find_pairs_with_sum([1, 3, 2, 2, -1, 3, -2, 1], 1) [(-2, 3), (-1, 2)] >>> find_pairs_with_sum([-3, -1, -2, 0, 1, 2, 3], 0) [(-3, 3), (-2, 2), (-1, 1)] >>> find_pairs_with_sum([1, 2, 3, 4, 5], 10) [] >>> find_pairs_with_sum([0, 2, 4, 6, 8], 10) [(2, 8), (4, 6)] >>> find_pairs_with_sum([1000000, 500000, 500000, 0], 1000000) [(0, 1000000), (500000, 500000)] >>> find_pairs_with_sum([], 5) [] >>> find_pairs_with_sum([1, -1, 2, -2, 3, -3], 0) [(-3, 3), (-2, 2), (-1, 1)]","solution":"def find_pairs_with_sum(arr, s): Returns a sorted list of unique pairs (a, b) from arr such that a + b = s and a < b. seen = set() unique_pairs = set() for num in arr: target = s - num if target in seen: pair = (min(num, target), max(num, target)) unique_pairs.add(pair) seen.add(num) return sorted(unique_pairs)"},{"question":"def is_scramble(s1: str, s2: str) -> bool: Determine whether s1 is a scrambled string of s2. >>> is_scramble(\\"abcde\\", \\"abcde\\") == True >>> is_scramble(\\"great\\", \\"rgeat\\") == True >>> is_scramble(\\"abcde\\", \\"caebd\\") == False >>> is_scramble(\\"abc\\", \\"bca\\") == True >>> is_scramble(\\"abc\\", \\"ab\\") == False >>> is_scramble(\\"abcdefghijklmnopq\\", \\"efghijklmnopqcadb\\") == False >>> is_scramble(\\"abb\\", \\"bba\\") == True >>> is_scramble(\\"\\", \\"\\") == True","solution":"def is_scramble(s1, s2): Determine if s1 is a scrambled string of s2. if len(s1) != len(s2): return False if s1 == s2: return True if sorted(s1) != sorted(s2): return False n = len(s1) for i in range(1, n): if (is_scramble(s1[:i], s2[:i]) and is_scramble(s1[i:], s2[i:])) or (is_scramble(s1[:i], s2[-i:]) and is_scramble(s1[i:], s2[:-i])): return True return False"},{"question":"def max_unique_integers(nums, k): Returns the maximum number of unique integers among all possible contiguous subarrays of length k in the array. >>> max_unique_integers([1, 2, 3, 1, 2, 3], 3) 3 >>> max_unique_integers([1, 2, 1, 2, 3, 3], 3) 3 >>> max_unique_integers([1, 1, 1, 1], 5) 1 >>> max_unique_integers([1, 2, 3, 4], 4) 4 >>> max_unique_integers([5], 1) 1 >>> max_unique_integers([], 1) 0 >>> max_unique_integers([1, 2, 3, 4, 5], 1) 1","solution":"def max_unique_integers(nums, k): Returns the maximum number of unique integers among all possible contiguous subarrays of length k in the array. if k > len(nums): return len(set(nums)) from collections import Counter # Initial window window = Counter(nums[:k]) max_unique = len(window) for i in range(k, len(nums)): # Remove the element leaving the window leaving_elem = nums[i - k] window[leaving_elem] -= 1 if window[leaving_elem] == 0: del window[leaving_elem] # Add the new element entering the window new_elem = nums[i] window[new_elem] += 1 # Update the max_unique count max_unique = max(max_unique, len(window)) return max_unique"},{"question":"def rotate(arr: List[int], k: int) -> None: Rotates the array to the right by k steps in-place. pass def reverse(arr, start, end): pass # Example test cases def arrays_equal(arr1, arr2): return arr1 == arr2 def test_rotate_normal_case(): arr = [1, 2, 3, 4, 5, 6, 7] rotate(arr, 3) assert arrays_equal(arr, [5, 6, 7, 1, 2, 3, 4]) def test_rotate_zero(): arr = [1, 2, 3, 4, 5, 6, 7] rotate(arr, 0) assert arrays_equal(arr, [1, 2, 3, 4, 5, 6, 7]) def test_rotate_k_equals_length(): arr = [1, 2, 3, 4, 5, 6, 7] rotate(arr, len(arr)) assert arrays_equal(arr, [1, 2, 3, 4, 5, 6, 7]) def test_rotate_k_greater_than_length(): arr = [1, 2, 3, 4, 5, 6, 7] rotate(arr, 10) assert arrays_equal(arr, [5, 6, 7, 1, 2, 3, 4]) def test_rotate_single_element(): arr = [1] rotate(arr, 3) assert arrays_equal(arr, [1]) def test_rotate_two_elements(): arr = [1, 2] rotate(arr, 1) assert arrays_equal(arr, [2, 1]) def test_rotate_with_negative_k(): arr = [1, 2, 3, 4, 5, 6, 7] rotate(arr, -3) assert arrays_equal(arr, [4, 5, 6, 7, 1, 2, 3])","solution":"def reverse(arr, start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 def rotate(arr, k): Rotates the array to the right by k steps in-place. n = len(arr) k = k % n # To handle cases where k > n reverse(arr, 0, n-1) reverse(arr, 0, k-1) reverse(arr, k, n-1)"},{"question":"def complete_tasks(arr: List[int]) -> List[int]: Simulates the completion of tasks where each unit of time, the person with the most tasks (ties broken by smallest index) completes exactly one task until all tasks are completed. Args: arr (list of int): An array representing the initial number of tasks assigned to each person. Returns: list of int: An array representing the state of the queue after all tasks have been completed. >>> complete_tasks([3, 2, 1, 4]) [0, 0, 0, 0] >>> complete_tasks([5]) [0] >>> complete_tasks([3, 3, 3]) [0, 0, 0] >>> complete_tasks([2, 7, 5, 7, 4]) [0, 0, 0, 0, 0] >>> complete_tasks([0, 0, 0, 0]) [0, 0, 0, 0] >>> complete_tasks([5, 4, 3, 2, 1]) [0, 0, 0, 0, 0] >>> complete_tasks([1, 3, 2, 4, 1, 3]) [0, 0, 0, 0, 0, 0]","solution":"def complete_tasks(arr): Simulates the completion of tasks where each unit of time, the person with the most tasks (ties broken by smallest index) completes exactly one task until all tasks are completed. Args: arr (list of int): An array representing the initial number of tasks assigned to each person. Returns: list of int: An array representing the state of the queue after all tasks have been completed. # Copy the list to avoid modifying the input list task_queue = arr[:] while any(task_queue): # Find the person with the most tasks max_tasks = max(task_queue) # Find the leftmost person with the most tasks max_index = task_queue.index(max_tasks) # Complete one task for that person task_queue[max_index] -= 1 return task_queue"},{"question":"def split_array_minimize_max_sum(arr: list[int], k: int) -> int: Divide an array into k non-empty subarrays such that the maximum sum of the elements in any subarray is minimized. Return the minimum possible value of that maximum sum. >>> split_array_minimize_max_sum([7, 2, 5, 10, 8], 2) 18 >>> split_array_minimize_max_sum([10], 1) 10 >>> split_array_minimize_max_sum([5, 5, 5, 5], 2) 10 >>> split_array_minimize_max_sum([1, 679 320 euros), MIEEG and Robert-Collin Foundation. Axel Kgi received a grant from the Swiss Research Foundation for Electricity and Mobile Communication via project SAFE (Scientific Advice to policy makers For the protection of workers and population against EMF). Competing interests: Rainer Brauchli was founder and shareholder of ICTR Advanced Measurements and Communications, Schwerzenbach, Switzerland. *** # Instructions: Complete the following function \`split_array_minimize_max_sum\` which takes an integer array \`arr\` of size \`n\` and an integer \`k\` as inputs and returns the minimum possible value of the maximum sum of the elements in any subarray when the array is divided into \`k\` non-empty subarrays. Also provided are some sample test cases to check your implementation. def split_array_minimize_max_sum(arr: list[int], k: int) -> int: Divide an array into k non-empty subarrays such that the maximum sum of the elements in any subarray is minimized. Return the minimum possible value of that maximum sum. >>> split_array_minimize_max_sum([7, 2, 5, 10, 8], 2) 18 >>> split_array_minimize_max_sum([10], 1) 10 >>> split_array_minimize_max_sum([5, 5, 5, 5], 2) 10 >>> split_array_minimize_max_sum([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) 17 >>> split_array_minimize_max_sum([1, 2, 3, 4, 5], 5) 5 >>> split_array_minimize_max_sum([1, 2, 3], 5) 3","solution":"def split_array_minimize_max_sum(arr, k): Divide an array into k non-empty subarrays such that the maximum sum of the elements in any subarray is minimized. Return the minimum possible value of that maximum sum. def can_split(maximum_sum): current_sum = 0 required_subarrays = 1 for num in arr: if current_sum + num > maximum_sum: required_subarrays += 1 current_sum = num if required_subarrays > k: return False else: current_sum += num return True low, high = max(arr), sum(arr) while low < high: mid = (low + high) // 2 if can_split(mid): high = mid else: low = mid + 1 return low"},{"question":"def max_subarray_len(arr: List[int], x: int) -> int: Returns the maximum length of a contiguous subarray that sums to x. If there isn't one, returns 0. >>> max_subarray_len([1, -1, 5, -2, 3], 3) 4 >>> max_subarray_len([-2, -1, 2, 1], 1) 2 >>> max_subarray_len([1, 2, 3], 7) 0 >>> max_subarray_len([1, 2, 3], 6) 3 >>> max_subarray_len([1, 1, 1, 1, 1, -1, -1, 2], 2) 6 >>> max_subarray_len([-1, -1, 1, 1, 1], 0) 4","solution":"def max_subarray_len(arr, x): Returns the maximum length of a contiguous subarray that sums to x. If there isn't one, returns 0. prefix_sum = {} cur_sum = 0 max_len = 0 for i in range(len(arr)): cur_sum += arr[i] if cur_sum == x: max_len = i + 1 if cur_sum - x in prefix_sum: max_len = max(max_len, i - prefix_sum[cur_sum - x]) if cur_sum not in prefix_sum: prefix_sum[cur_sum] = i return max_len"},{"question":"def can_rearrange_tokens(nums, target): Determine if tokens can be rearranged such that the distance between any two adjacent tokens is exactly \`target\`. Parameters: nums (list of int): List of token positions. target (int): Target distance between adjacent tokens. Returns: bool: True if tokens can be rearranged such that every two adjacent tokens have a distance of \`target\`, False otherwise. # Example Test Cases # Test Case 1: # Input: [1, 3, 5, 7], 2 # Output: True # Test Case 2: # Input: [7, 1, 3, 5], 2 # Output: True # Test Case 3: # Input: [1, 2, 4, 7], 2 # Output: False # Test Case 4: # Input: [5], 2 # Output: True # Test Case 5: # Input: [1, 3], 2 # Output: True # Test Case 6: # Input: [1, 4], 2 # Output: False","solution":"def can_rearrange_tokens(nums, target): Determine if tokens can be rearranged such that the distance between any two adjacent tokens is exactly \`target\`. Parameters: nums (list of int): List of token positions. target (int): Target distance between adjacent tokens. Returns: bool: True if tokens can be rearranged such that every two adjacent tokens have a distance of \`target\`, False otherwise. if len(nums) < 2: return True nums.sort() for i in range(1, len(nums)): if nums[i] - nums[i-1] != target: return False return True"},{"question":"def longestUniqueSubstring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longestUniqueSubstring(\\"pwwkew\\") == 3 >>> longestUniqueSubstring(\\"abcabcbb\\") == 3 >>> longestUniqueSubstring(\\"bbbbb\\") == 1 >>> longestUniqueSubstring(\\"abcdef\\") == 6 >>> longestUniqueSubstring(\\"aab\\") == 2","solution":"def longestUniqueSubstring(s): Returns the length of the longest substring without repeating characters. :param s: String input :return: Length of the longest substring without repeating characters char_index = {} max_length = 0 start = 0 for i, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def canFormPalindrome(s: str) -> bool: Given a string \`s\`, determine if it can be made a palindrome by removing at most one character. >>> canFormPalindrome(\\"racecar\\") True >>> canFormPalindrome(\\"abca\\") True >>> canFormPalindrome(\\"abc\\") False >>> canFormPalindrome(\\"a\\") True >>> canFormPalindrome(\\"\\") True >>> canFormPalindrome(\\"aa\\") True >>> canFormPalindrome(\\"ab\\") True >>> canFormPalindrome(\\"racecars\\") True >>> canFormPalindrome(\\"abcdef\\") False","solution":"def canFormPalindrome(s): Determines if a string can be made a palindrome by removing at most one character. def is_palindrome(st): return st == st[::-1] left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Try by removing one character from either end return is_palindrome(s[left + 1:right + 1]) or is_palindrome(s[left:right]) left += 1 right -= 1 return True"},{"question":"def longest_substring_with_k_replacements(s: str, k: int) -> int: Returns the length of the longest contiguous substring containing only one unique character that can be achieved with at most k character replacements. >>> longest_substring_with_k_replacements(\\"aaaa\\", 2) == 4 >>> longest_substring_with_k_replacements(\\"aabccbb\\", 2) == 5 >>> longest_substring_with_k_replacements(\\"abab\\", 4) == 4 >>> longest_substring_with_k_replacements(\\"aabbc\\", 0) == 2 >>> longest_substring_with_k_replacements(\\"\\", 3) == 0 >>> longest_substring_with_k_replacements(\\"abcdef\\", 2) == 3 from solution import longest_substring_with_k_replacements def test_no_replacements_needed(): assert longest_substring_with_k_replacements(\\"aaaa\\", 2) == 4 def test_replacements_smaller_than_k(): assert longest_substring_with_k_replacements(\\"aabccbb\\", 2) == 5 def test_full_string_replacement(): assert longest_substring_with_k_replacements(\\"abab\\", 4) == 4 def test_k_is_zero(): assert longest_substring_with_k_replacements(\\"aabbc\\", 0) == 2 def test_empty_string(): assert longest_substring_with_k_replacements(\\"\\", 3) == 0 def test_all_unique_characters(): assert longest_substring_with_k_replacements(\\"abcdef\\", 2) == 3","solution":"def longest_substring_with_k_replacements(s, k): Returns the length of the longest contiguous substring containing only one unique character that can be achieved with at most k character replacements. max_length = 0 left = 0 counts = {} max_count = 0 for right in range(len(s)): char = s[right] if char in counts: counts[char] += 1 else: counts[char] = 1 max_count = max(max_count, counts[char]) while right - left + 1 - max_count > k: reduce_char = s[left] counts[reduce_char] -= 1 if counts[reduce_char] == 0: del counts[reduce_char] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def min_duplication_operations(s: str) -> int: Return the minimum number of duplication operations needed to make \`s\` a string where there is no substring that occurs more than once. >>> min_duplication_operations(\\"abcdef\\") 6 >>> min_duplication_operations(\\"aabc\\") 4 >>> min_duplication_operations(\\"a\\") 1 >>> min_duplication_operations(\\"aaaa\\") 4 >>> min_duplication_operations(\\"ababab\\") 6","solution":"def min_duplication_operations(s: str) -> int: if not s: return 0 n = len(s) # Check if there are no duplicate substrings in the string def has_no_duplicates(s: str) -> bool: seen = set() for i in range(n): for j in range(i+1, n+1): substring = s[i:j] if substring in seen: return False seen.add(substring) return True # Since a single letter can always be duplicated, we always need at least len(s) operations # This is because to avoid duplication we need each letter to be something unique # therefore the lowest number of operations required is the length of the string return n"},{"question":"def min_subarray_len(nums: List[int], target: int) -> int: Returns the length of the smallest subarray that adds up to the target. If no such subarray exists, return -1. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 1, 1, 1, 1], 11) -1 >>> min_subarray_len([5], 5) 1 >>> min_subarray_len([5], 10) -1 >>> min_subarray_len([1, 2, 3, 4], 10) 4 >>> min_subarray_len([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) 2 >>> min_subarray_len([1, 4, 4], 4) 1","solution":"def min_subarray_len(nums, target): Returns the length of the smallest subarray that adds up to the target. If no such subarray exists, return -1. n = len(nums) min_length = float('inf') left = 0 sum_ = 0 for right in range(n): sum_ += nums[right] while sum_ >= target: min_length = min(min_length, right - left + 1) sum_ -= nums[left] left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def max_diff_in_contiguous_subarray(nums: List[int]) -> int: Given an integer array nums, return the maximum difference between the largest and smallest values in any contiguous subarray of nums. If the array contains fewer than 2 elements, return 0. >>> max_diff_in_contiguous_subarray([]) == 0 >>> max_diff_in_contiguous_subarray([5]) == 0 >>> max_diff_in_contiguous_subarray([1, 7]) == 6 >>> max_diff_in_contiguous_subarray([7, 1]) == 6 >>> max_diff_in_contiguous_subarray([2, 3, 1, 5]) == 4 >>> max_diff_in_contiguous_subarray([-3, -2, -6, -1]) == 5 >>> max_diff_in_contiguous_subarray([1, -2, 3, -4, 5]) == 9 >>> max_diff_in_contiguous_subarray([1, 1, 1, 1]) == 0 >>> max_diff_in_contiguous_subarray([1, 5, 3, 1, 5, 1]) == 4","solution":"def max_diff_in_contiguous_subarray(nums): if len(nums) < 2: return 0 max_diff = 0 for i in range(len(nums)): current_min = nums[i] current_max = nums[i] for j in range(i, len(nums)): current_min = min(current_min, nums[j]) current_max = max(current_max, nums[j]) max_diff = max(max_diff, current_max - current_min) return max_diff"},{"question":"def partition_index(nums): Returns the index at which the array nums can be partitioned into two contiguous subarrays with equal sums, or -1 if no such partition exists. >>> partition_index([1, 2, 3, 4, 5, 5]) == 4 >>> partition_index([2, 2, 2, 2, 4, 4]) == 4 >>> partition_index([1, 1, 1, 1, 1]) == -1 >>> partition_index([2, 4, 6, 8]) == -1 >>> partition_index([1]) == -1 >>> partition_index([10]) == -1 >>> partition_index([1, 1, 1, 1, 2, 2, 4, 4]) == 6 >>> partition_index([]) == -1","solution":"def partition_index(nums): Returns the index at which the array nums can be partitioned into two contiguous subarrays with equal sums, or -1 if no such partition exists. total_sum = sum(nums) if total_sum % 2 != 0: return -1 left_sum = 0 for i in range(len(nums)): left_sum += nums[i] if left_sum * 2 == total_sum: return i + 1 return -1"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1: ListNode, l2: ListNode) -> ListNode: Given two linked lists representing non-negative integers in reverse order, add the two numbers and return the resulting linked list in reverse order. >>> linked_list_to_list(add_two_numbers(list_to_linked_list([2, 4, 3]), list_to_linked_list([5, 6, 4]))) [7, 0, 8] >>> linked_list_to_list(add_two_numbers(list_to_linked_list([9, 9, 9]), list_to_linked_list([1]))) [0, 0, 0, 1] >>> linked_list_to_list(add_two_numbers(list_to_linked_list([0, 1]), list_to_linked_list([0, 1]))) [0, 2] >>> linked_list_to_list(add_two_numbers(list_to_linked_list([1, 8]), list_to_linked_list([0]))) [1, 8] >>> linked_list_to_list(add_two_numbers(list_to_linked_list([0, 0, 0]), list_to_linked_list([0, 0, 0]))) [0, 0, 0]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): dummy_head = ListNode(0) current = dummy_head carry = 0 while l1 is not None or l2 is not None or carry != 0: val1 = l1.val if l1 is not None else 0 val2 = l2.val if l2 is not None else 0 total = val1 + val2 + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1 is not None: l1 = l1.next if l2 is not None: l2 = l2.next return dummy_head.next"},{"question":"def min_travel_cost(grid): Returns the minimum travel cost to journey from the top-left to the bottom-right of the grid. >>> min_travel_cost([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_travel_cost([[5]]) 5 >>> min_travel_cost([]) 0 >>> min_travel_cost([[1, 2, 3]]) 6 >>> min_travel_cost([[1], [2], [3]]) 6 >>> min_travel_cost([[1, 2, 5], [3, 2, 1], [4, 1, 1]]) 7","solution":"def min_travel_cost(grid): Returns the minimum travel cost to journey from the top-left to the bottom-right of the grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"from collections import Counter import heapq from typing import List def rearrange_string(text: str, k: int) -> str: Rearrange the string such that different characters are at least \`k\` distance from each other. >>> rearrange_string(\\"aabbcc\\", 3) in [\\"abcabc\\", \\"acbacb\\", \\"bcabca\\", \\"bacbac\\", \\"cabacb\\", \\"acbacb\\"] >>> rearrange_string(\\"aaabc\\", 3) == \\"\\" >>> rearrange_string(\\"aaadbbcc\\", 2) in [\\"abacabcd\\", \\"abacbadc\\", \\"abadbcac\\", \\"abdabcac\\", \\"abcadbac\\"] >>> rearrange_string(\\"aaadbbcc\\", 0) == \\"aaadbbcc\\" >>> rearrange_string(\\"aaadbbcc\\", 1) == \\"aaadbbcc\\" >>> rearrange_string(\\"\\", 2) == \\"\\" >>> rearrange_string(\\"a\\", 2) == \\"a\\" >>> rearrange_string(\\"aaaa\\", 4) == \\"\\" >>> rearrange_string(\\"abcd\\", 2) == \\"abcd\\" >>> rearrange_string(\\"abcd\\", 1) == \\"abcd\\" >>> rearrange_string(\\"abcd\\", 0) == \\"abcd\\" pass","solution":"from collections import Counter import heapq def rearrange_string(text, k): if k <= 1: return text # No need to rearrange counter = Counter(text) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) queue = [] result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) queue.append((freq + 1, char)) # we use freq + 1 because freq is negative if len(queue) < k: continue # Prepare to push back an element if its k distance has passed front = queue.pop(0) if front[0] < 0: heapq.heappush(max_heap, front) return ''.join(result) if len(result) == len(text) else ''"},{"question":"def max_buildings_climbed(arr: List[int], bricks: int) -> int: Returns the maximum number of buildings that can be climbed using the given bricks. :param arr: List of integers representing heights of buildings. :param bricks: Integer representing the amount of bricks available. :return: Integer representing the maximum number of buildings that can be climbed. >>> max_buildings_climbed([5, 4, 3, 2, 1], 5) 5 >>> max_buildings_climbed([1, 2, 3, 4], 3) 4 >>> max_buildings_climbed([1, 2, 5, 6], 3) 2 >>> max_buildings_climbed([], 5) 0 >>> max_buildings_climbed([1, 3, 5, 7], 10) 4","solution":"def max_buildings_climbed(arr, bricks): Returns the maximum number of buildings that can be climbed using the given bricks. :param arr: List of integers representing heights of buildings. :param bricks: Integer representing the amount of bricks available. :return: Integer representing the maximum number of buildings that can be climbed. n = len(arr) if n == 0: return 0 bricks_used = 0 for i in range(n - 1): if arr[i + 1] > arr[i]: bricks_needed = arr[i + 1] - arr[i] if bricks_used + bricks_needed <= bricks: bricks_used += bricks_needed else: return i + 1 return n"},{"question":"def max_absolute_difference_pair(nums: list[int]) -> list[int]: Given an integer array nums of length n, return an array containing two integers [num1, num2] such that: * 0 <= num1 < num2 < n * The absolute difference abs(nums[num1] - nums[num2]) is the maximum amongst all pairs (num1, num2). If there are multiple pairs with the same maximum difference, return the pair with the smaller num1 value. If no such pair exists, return [-1, -1]. >>> max_absolute_difference_pair([5]) [-1, -1] >>> max_absolute_difference_pair([1, 2]) [0, 1] >>> max_absolute_difference_pair([1, 2, 10, 8, 5]) [0, 2] >>> max_absolute_difference_pair([]) [-1, -1] >>> max_absolute_difference_pair([3, 3, 3, 3]) [0, 1] >>> max_absolute_difference_pair([1, 2, 3, 4, 5]) [0, 4] >>> max_absolute_difference_pair([5, 4, 3, 2, 1]) [0, 4] >>> max_absolute_difference_pair([7, 3, 5, 9, 2, 11]) [4, 5]","solution":"def max_absolute_difference_pair(nums): Given an integer array nums of length n, return an array containing two integers [num1, num2] such that: * 0 <= num1 < num2 < n * The absolute difference abs(nums[num1] - nums[num2]) is the maximum amongst all pairs (num1, num2). If there are multiple pairs with the same maximum difference, return the pair with the smaller num1 value. If no such pair exists, return [-1, -1]. if len(nums) < 2: return [-1, -1] n = len(nums) num1, num2 = -1, -1 max_diff = -1 # A loop to go through each pair (i, j) where 0 <= i < j < n for i in range(n - 1): for j in range(i + 1, n): current_diff = abs(nums[i] - nums[j]) if current_diff > max_diff or (current_diff == max_diff and i < num1): num1, num2 = i, j max_diff = current_diff return [num1, num2]"},{"question":"def pacific_atlantic(matrix: List[List[int]]) -> List[List[int]]: Given a 2D grid of integers representing the height of cells, find all the coordinates where water can flow to both the Atlantic and Pacific oceans. >>> pacific_atlantic([ ... [1, 2, 2, 3, 5], ... [3, 2, 3, 4, 4], ... [2, 4, 5, 3, 1], ... [6, 7, 1, 4, 5], ... [5, 1, 1, 2, 4] ... ]) [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] >>> pacific_atlantic([]) [] >>> pacific_atlantic([ ... [3, 3, 3], ... [3, 1, 3], ... [3, 3, 3] ... ]) [[0, 0], [0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1], [2, 2]] >>> pacific_atlantic([[1]]) [[0, 0]]","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) pacific_reachable = [[False] * cols for _ in range(rows)] atlantic_reachable = [[False] * cols for _ in range(rows)] def dfs(x, y, reachable): reachable[x][y] = True directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and not reachable[nx][ny] and matrix[nx][ny] >= matrix[x][y]: dfs(nx, ny, reachable) for i in range(rows): dfs(i, 0, pacific_reachable) dfs(i, cols - 1, atlantic_reachable) for j in range(cols): dfs(0, j, pacific_reachable) dfs(rows - 1, j, atlantic_reachable) result = [] for i in range(rows): for j in range(cols): if pacific_reachable[i][j] and atlantic_reachable[i][j]: result.append([i, j]) return result"},{"question":"def find_no_incoming_edges_nodes(n, edges): Returns a list of all nodes with no incoming edges in the given DAG. :param n: Number of nodes :param edges: List of edges in the DAG :return: Sorted list of nodes with no incoming edges # Test Cases >>> find_no_incoming_edges_nodes(1, []) == [0] >>> find_no_incoming_edges_nodes(3, []) == [0, 1, 2] >>> find_no_incoming_edges_nodes(3, [[0, 1], [1, 2], [2, 0]]) == [] >>> find_no_incoming_edges_nodes(4, [[0, 2], [1, 2], [3, 2]]) == [0, 1, 3] >>> find_no_incoming_edges_nodes(5, [[0, 1], [0, 2], [1, 3], [3, 4], [2, 4]]) == [0] >>> find_no_incoming_edges_nodes(6, [[0, 1], [2, 3], [4, 5]]) == [0, 2, 4]","solution":"def find_no_incoming_edges_nodes(n, edges): Returns a list of all nodes with no incoming edges in the given DAG. :param n: Number of nodes :param edges: List of edges in the DAG :return: Sorted list of nodes with no incoming edges incoming_count = [0] * n for edge in edges: source, target = edge incoming_count[target] += 1 no_incoming_nodes = [i for i in range(n) if incoming_count[i] == 0] return sorted(no_incoming_nodes)"},{"question":"class CourseScheduler: def __init__(self, courses): Initializes the CourseScheduler with a list of courses. Each course is represented as a list [start, end]. self.courses = courses def maxCourses(self): Returns the maximum number of non-overlapping courses a student can attend. >>> scheduler = CourseScheduler([[1, 2], [2, 3], [2, 4], [3, 5], [4, 6], [5, 7]]) >>> scheduler.maxCourses() 4 >>> scheduler = CourseScheduler([[1, 3], [2, 4], [3, 5], [6, 7]]) >>> scheduler.maxCourses() 3 >>> scheduler = CourseScheduler([[1, 2], [3, 4], [5, 6]]) >>> scheduler.maxCourses() 3 >>> scheduler = CourseScheduler([[1, 2]]) >>> scheduler.maxCourses() 1 >>> scheduler = CourseScheduler([]) >>> scheduler.maxCourses() 0","solution":"class CourseScheduler: def __init__(self, courses): Initializes the CourseScheduler with a list of courses. Each course is represented as a list [start, end]. self.courses = courses def maxCourses(self): Returns the maximum number of non-overlapping courses a student can attend. # Sort courses by their end time self.courses.sort(key=lambda x: x[1]) last_end_time = float('-inf') count = 0 for start, end in self.courses: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"import heapq def min_cost_connect_points(points): Returns the minimum cost to connect all points such that each point is connected to at least one other point. The cost to connect two points is the Manhattan distance between them: |xi - xj| + |yi - yj|. pass def test_min_cost_connect_points_single_point(): assert min_cost_connect_points([[0, 0]]) == 0 def test_min_cost_connect_points_two_points(): assert min_cost_connect_points([[0, 0], [1, 1]]) == 2 def test_min_cost_connect_points_three_points(): assert min_cost_connect_points([[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]) == 20 def test_min_cost_connect_points_spread_points(): assert min_cost_connect_points([[3, 12], [-2, 5], [-4, 1]]) == 18 def test_min_cost_connect_points_multiple_close_points(): assert min_cost_connect_points([[0, 0], [1, 0], [2, 0], [3, 0], [4, 0]]) == 4","solution":"import heapq def min_cost_connect_points(points): Returns the minimum cost to connect all points such that each point is connected to at least one other point. The cost to connect two points is the Manhattan distance between them: |xi - xj| + |yi - yj|. def manhattan_distance(point1, point2): return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1]) n = len(points) min_heap = [(0, 0)] # (cost, point index) in_mst = [False] * n min_cost = 0 edges_used = 0 while edges_used < n: cost, i = heapq.heappop(min_heap) if in_mst[i]: continue in_mst[i] = True min_cost += cost edges_used += 1 for j in range(n): if not in_mst[j]: heapq.heappush(min_heap, (manhattan_distance(points[i], points[j]), j)) return min_cost"},{"question":"def count_matching_even_odd_positions(arr1, arr2): Given two integer arrays arr1 and arr2 of the same length, the function returns the count of positions i where arr1[i] and arr2[i] are both even or both odd. >>> count_matching_even_odd_positions([1, 2, 3, 4], [5, 6, 7, 8]) 4 >>> count_matching_even_odd_positions([1, 3, 5], [2, 4, 6]) 0 >>> count_matching_even_odd_positions([2, 4, 6], [8, 10, 12]) 3 >>> count_matching_even_odd_positions([1, 2, 3], [1, 2, 3]) 3 >>> count_matching_even_odd_positions([1], [2]) 0 >>> count_matching_even_odd_positions([], []) 0 >>> count_matching_even_odd_positions([2], [4]) 1 >>> count_matching_even_odd_positions([3], [5]) 1 >>> count_matching_even_odd_positions([2], [5]) 0 >>> count_matching_even_odd_positions([3], [4]) 0","solution":"def count_matching_even_odd_positions(arr1, arr2): Given two integer arrays arr1 and arr2 of the same length, the function returns the count of positions i where arr1[i] and arr2[i] are both even or both odd. count = 0 for a, b in zip(arr1, arr2): if (a % 2 == 0 and b % 2 == 0) or (a % 2 == 1 and b % 2 == 1): count += 1 return count"},{"question":"def contains_duplicate(nums: List[int]) -> bool: Given an array of integers \`nums\`, return \`true\` if any value appears at least twice in the array, otherwise \`false\`. The solution should have a time complexity of O(n) and use O(n) extra space. >>> contains_duplicate([1, 2, 3, 1]) True >>> contains_duplicate([1, 2, 3, 4]) False >>> contains_duplicate([]) False >>> contains_duplicate([1]) False >>> contains_duplicate([2, 3, 4, 5, 6, 6, 7, 8, 9, 9]) True >>> contains_duplicate([1, 1, 1, 1]) True >>> nums = list(range(10000)) + [9999] >>> contains_duplicate(nums) True","solution":"def contains_duplicate(nums): Returns True if any value appears at least twice in the array, otherwise False. seen = set() for num in nums: if num in seen: return True seen.add(num) return False"},{"question":"def remove_subdirectories(words: List[str]) -> List[str]: Removes subdirectories from the list and returns only unique parent directories sorted in lexicographic order. Args: words (List[str]): A list of directory paths. Returns: List[str]: A list of unique parent directories sorted in lexicographic order. >>> remove_subdirectories([\\"/a\\", \\"/a/b\\", \\"/c/d\\", \\"/c/d/e\\", \\"/c/f\\"]) [\\"/a\\", \\"/c/d\\", \\"/c/f\\"] >>> remove_subdirectories([\\"/a/b/c\\", \\"/a/b/ca\\", \\"/a/b/d\\"]) [\\"/a/b/c\\", \\"/a/b/ca\\", \\"/a/b/d\\"] >>> remove_subdirectories([\\"/a/b\\", \\"/a/b\\", \\"/a\\", \\"/a/c\\"]) [\\"/a\\"] >>> remove_subdirectories([\\"/a/b/c\\"]) [\\"/a/b/c\\"] >>> remove_subdirectories([]) [] >>> remove_subdirectories([\\"/a\\", \\"/a/b\\", \\"/A/B\\"]) [\\"/A/B\\", \\"/a\\"]","solution":"def remove_subdirectories(words): Removes subdirectories from the list and returns only unique parent directories sorted in lexicographic order. Args: words (List[str]): A list of directory paths. Returns: List[str]: A list of unique parent directories sorted in lexicographic order. words.sort() result = [] for word in words: if not result or not word.startswith(result[-1] + '/'): result.append(word) return result"},{"question":"class TextEditor: A text editing application supporting multiple documents. * \`createDocument(self, content: str) -> int\` : Creates a new document and returns the documentId. * \`deleteDocument(self, documentId: int) -> None\` : Deletes the document associated with the given documentId. * \`readDocument(self, documentId: int, startIndex: int, endIndex: int) -> str\` : Retrieves a substring from the document's content. * \`appendContent(self, documentId: int, additionalContent: str) -> None\` : Appends additional content to the document. * \`editContent(self, documentId: int, startIndex: int, endIndex: int, newContent: str) -> None\` : Edits the document's content by replacing a portion of it. * \`searchContent(self, query: str) -> List[int]\` : Searches for a query in all documents and returns a list of documentIds where the query is found. def __init__(self): pass def createDocument(self, content: str) -> int: Creates a new document with given content and returns documentId. pass def deleteDocument(self, documentId: int) -> None: Deletes the document associated with documentId. pass def readDocument(self, documentId: int, startIndex: int, endIndex: int) -> str: Returns substring of document's content from startIndex to endIndex. pass def appendContent(self, documentId: int, additionalContent: str) -> None: Appends additionalContent to the document's content. pass def editContent(self, documentId: int, startIndex: int, endIndex: int, newContent: str) -> None: Replaces substring of document's content with newContent. pass def searchContent(self, query: str) -> List[int]: Returns a list of documentIds containing the query. pass from solution import TextEditor def test_create_and_read_document(): editor = TextEditor() doc_id = editor.createDocument(\\"Hello, World!\\") assert editor.readDocument(doc_id, 0, 4) == \\"Hello\\" assert editor.readDocument(doc_id, 7, 11) == \\"World\\" assert editor.readDocument(doc_id, 0, 20) == \\"Hello, World!\\" def test_delete_document(): editor = TextEditor() doc_id = editor.createDocument(\\"Sample Text\\") editor.deleteDocument(doc_id) assert editor.readDocument(doc_id, 0, 5) == \\"-1\\" def test_append_content(): editor = TextEditor() doc_id = editor.createDocument(\\"Sample\\") editor.appendContent(doc_id, \\" Text\\") assert editor.readDocument(doc_id, 0, 11) == \\"Sample Text\\" def test_edit_content(): editor = TextEditor() doc_id = editor.createDocument(\\"Hello, World!\\") editor.editContent(doc_id, 7, 11, \\"Universe\\") assert editor.readDocument(doc_id, 0, 15) == \\"Hello, Universe!\\" editor.editContent(doc_id, 0, 4, \\"Hey\\") assert editor.readDocument(doc_id, 0, 14) == \\"Hey, Universe!\\" def test_search_content(): editor = TextEditor() doc_id1 = editor.createDocument(\\"Find the query here.\\") doc_id2 = editor.createDocument(\\"Another query document.\\") doc_id3 = editor.createDocument(\\"No match here.\\") result = editor.searchContent(\\"query\\") assert sorted(result) == sorted([doc_id1, doc_id2]) assert editor.searchContent(\\"nomatch\\") == []","solution":"class TextEditor: def __init__(self): self.documents = {} self.next_document_id = 0 def createDocument(self, content): document_id = self.next_document_id self.documents[document_id] = content self.next_document_id += 1 return document_id def deleteDocument(self, documentId): if documentId in self.documents: del self.documents[documentId] def readDocument(self, documentId, startIndex, endIndex): if documentId in self.documents: content = self.documents[documentId] start = max(0, startIndex) end = min(endIndex, len(content) - 1) return content[start:end + 1] return \\"-1\\" def appendContent(self, documentId, additionalContent): if documentId in self.documents: self.documents[documentId] += additionalContent def editContent(self, documentId, startIndex, endIndex, newContent): if documentId in self.documents: content = self.documents[documentId] if startIndex <= endIndex: start = max(0, startIndex) end = min(endIndex, len(content) - 1) self.documents[documentId] = content[:start] + newContent + content[end + 1:] def searchContent(self, query): result = [] for documentId, content in self.documents.items(): if query in content: result.append(documentId) return result"},{"question":"def evaluate_polynomial(coefficients: List[int], x: int) -> int: Evaluates an nth-order polynomial at a given x. :param coefficients: List[int] - a list of coefficients for the polynomial where the i-th element is the coefficient for the x^i term. :param x: int - the value at which to evaluate the polynomial. :return: int - the result of the polynomial evaluation at x. >>> evaluate_polynomial([1, 0, -2, 3], 2) 17 >>> evaluate_polynomial([1, 0, -2, 3], 0) 1 >>> evaluate_polynomial([1, 1, 1], 2) 7 >>> evaluate_polynomial([1, 0, -2, 3], -1) -4 >>> evaluate_polynomial([], 2) 0 >>> evaluate_polynomial([5], 100) 5 >>> evaluate_polynomial([0, 0, 3], 3) 27 >>> evaluate_polynomial([3, 0, 2], 1000) 2000003","solution":"def evaluate_polynomial(coefficients, x): Evaluates an nth-order polynomial at a given x. :param coefficients: List[int] - a list of coefficients for the polynomial where the i-th element is the coefficient for the x^i term. :param x: int - the value at which to evaluate the polynomial. :return: int - the result of the polynomial evaluation at x. n = len(coefficients) result = 0 for i in range(n): result += coefficients[i] * (x ** i) return result"},{"question":"def max_tasks(employees, tasks): Returns the maximum number of tasks that can be assigned to employees based on their skill levels. :param employees: List[int]  skill values of the employees :param tasks: List[int]  skill levels required for the tasks :return: int  maximum number of tasks that can be assigned >>> max_tasks([4, 5, 6], [1, 2, 3]) 3 >>> max_tasks([1, 1, 1], [2, 2, 2]) 0 >>> max_tasks([5, 9, 3], [4, 2, 9]) 3 >>> max_tasks([10, 3, 4, 7, 8], [5, 9]) 2 >>> max_tasks([10, 3], [1, 2, 3, 4, 5, 6]) 2 >>> max_tasks([5, 3, 8], [4, 7, 6]) 2 >>> max_tasks([1, 2, 8], [4, 2, 6]) 2","solution":"def max_tasks(employees, tasks): Returns the maximum number of tasks that can be assigned to employees based on their skill levels. employees.sort() tasks.sort() employee_index = 0 task_index = 0 count = 0 while employee_index < len(employees) and task_index < len(tasks): if employees[employee_index] >= tasks[task_index]: count += 1 task_index += 1 employee_index += 1 return count"},{"question":"def combination_sum(arr, target): Return the number of all possible combinations of elements in arr that sum up to the target. Each element in arr can be used as many times as needed. The result is returned modulo 10^9 + 7. >>> combination_sum([1, 2, 3], 4) == 7 >>> combination_sum([2], 3) == 0 >>> combination_sum([2, 3], 5) == 2 >>> combination_sum([1, 2], 10) == 89 >>> combination_sum([5, 10], 1) == 0 >>> combination_sum([1, 5, 10], 1000) is not None # Should complete without error >>> combination_sum([10**6], 10**6) == 1 >>> combination_sum([10**6], 10**6 + 1) == 0","solution":"def combination_sum(arr, target): MOD = 10**9 + 7 dp = [0] * (target + 1) dp[0] = 1 # There is one way to make the sum 0 (by choosing nothing) for t in range(1, target + 1): for num in arr: if t >= num: dp[t] = (dp[t] + dp[t - num]) % MOD return dp[target]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_increasing_path(root): Find the length of the longest path where each node in the path has a value that is one more than the previous node in the path in a binary tree. Example: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(3) >>> root.right.left = TreeNode(2) >>> root.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(5) >>> longest_increasing_path(root) 3 >>> root = TreeNode(1) >>> longest_increasing_path(root) 1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_increasing_path(root): def dfs(node, parent_val, length): if not node: return length if node.val == parent_val + 1: length += 1 else: length = 1 left_length = dfs(node.left, node.val, length) right_length = dfs(node.right, node.val, length) return max(length, left_length, right_length) if not root: return 0 return dfs(root, root.val - 1, 0)"},{"question":"def trap(height: List[int]) -> int: Calculate how much water it can trap after raining given an elevation map. :param height: List[int] representing the elevation at each index. :return: int representing the total units of trapped water. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([]) 0 >>> trap([3, 2, 1, 0, 1, 2, 3]) 9 >>> trap([1, 1, 1, 1, 1]) 0 >>> trap([0, 2, 0]) 0 >>> trap([2, 0, 2]) 2 >>> trap([2, 0, 2, 0, 2]) 4","solution":"def trap(height): Calculate how much water it can trap after raining given an elevation map. :param height: List[int] representing the elevation at each index. :return: int representing the total units of trapped water. if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) water_trapped += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) water_trapped += max(0, right_max - height[right]) return water_trapped"},{"question":"def digital_root(num: int) -> int: Returns the sum of its digits until only a single digit remains. >>> digital_root(493193) 2 >>> digital_root(999999999999) 9 >>> digital_root(10) 1 >>> digital_root(0) 0 >>> digital_root(11) 2 >>> digital_root(5) 5","solution":"def digital_root(num): Returns the digital root of the given number 'num' by summing its digits repeatedly until only a single digit remains. while num >= 10: num = sum(int(digit) for digit in str(num)) return num"},{"question":"def maximize_value(s: str) -> int: Given a string s that consists of only digits, returns the maximum possible value of the string by placing the '*' operator optimally. Parameters: s (str): The input string consisting of only digits. Returns: int: The maximum possible value. >>> maximize_value('') == 0 >>> maximize_value('5') == 5 >>> maximize_value('35') == 15 >>> maximize_value('57') == 35 >>> maximize_value('123') == 6 >>> maximize_value('235') == 30 >>> maximize_value('584') == 160 >>> maximize_value('999') == 729 >>> maximize_value('88888') == 32768","solution":"def maximize_value(s): Given a string s that consists of only digits, returns the maximum possible value of the string by placing the '*' operator optimally. Parameters: s (str): The input string consisting of only digits. Returns: int: The maximum possible value. if not s: return 0 result = int(s[0]) for i in range(1, len(s)): num = int(s[i]) result *= num return result"},{"question":"def trap(height: List[int]) -> int: Calculate the total amount of rainwater trapped. :param height: List[int] - List of building heights :return: int - Total amount of rainwater trapped Example: >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9 >>> trap([1, 2, 3, 4, 5]) 0 >>> trap([5, 4, 3, 2, 1]) 0 >>> trap([]) 0 >>> trap([3, 3, 3, 3, 3]) 0 >>> trap([1000, 2000, 1500, 3000, 1000, 2000]) 1500 pass","solution":"def trap(height): Calculate the total amount of rainwater trapped. :param height: List[int] - List of building heights :return: int - Total amount of rainwater trapped if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"from typing import List def count_paths(n: int, edges: List[List[int]], dest: int, restricted: List[int]) -> int: Return the number of distinct paths from node 1 to node dest that do not pass through any restricted nodes. >>> count_paths(4, [[1, 2], [2, 3], [3, 4]], 4, []) 1 >>> count_paths(4, [[1, 2], [2, 3], [3, 4]], 4, [2]) 0 >>> count_paths(4, [[1, 2], [2, 3], [3, 4], [1, 3]], 4, []) 2 >>> count_paths(5, [[1, 2], [2, 3], [3, 4], [2, 5], [5, 4]], 4, [2]) 0 >>> count_paths(5, [[1, 2], [2, 3], [3, 4], [2, 5], [5, 4]], 4, [5]) 1 >>> count_paths(3, [[1, 2]], 3, []) 0 >>> count_paths(2, [[1, 2]], 2, []) 1","solution":"def count_paths(n, edges, dest, restricted): from collections import defaultdict def dfs(node): if node == dest: return 1 visited.add(node) path_count = 0 for neighbor in graph[node]: if neighbor not in visited and neighbor not in restricted_set: path_count += dfs(neighbor) visited.remove(node) return path_count graph = defaultdict(list) for u, v in edges: graph[u].append(v) restricted_set = set(restricted) visited = set() return dfs(1)"},{"question":"def is_valid_ipv4_address(s: str) -> bool: Return True if s is a valid IPv4 address, False otherwise. A valid IPv4 address consists of four numbers (each between 0-255) separated by dots, and cannot have leading zeros. >>> is_valid_ipv4_address(\\"192.168.1.1\\") == True >>> is_valid_ipv4_address(\\"256.256.256.256\\") == False >>> is_valid_ipv4_address(\\"192.168.01.1\\") == False pass","solution":"def is_valid_ipv4_address(s): Returns True if s is a valid IPv4 address, False otherwise. A valid IPv4 address consists of four numbers (each between 0-255) separated by dots, and cannot have leading zeros. parts = s.split('.') # IPv4 address must have exactly 4 parts if len(parts) != 4: return False for part in parts: # Each part must be a number and not empty if not part.isdigit(): return False # Convert part to an integer num = int(part) # Check if each number is between 0 and 255 (inclusive) if not (0 <= num <= 255): return False # Check for leading zeros (part[0] can't be '0' if part is more than one digit long) if part[0] == '0' and len(part) > 1: return False return True"},{"question":"def count_valid_concatenations(s: str, words: List[str]) -> int: Returns the number of words in the list \`words\` that are valid concatenations of a suffix and a prefix of the string \`s\`. >>> count_valid_concatenations(\\"wordformation\\", [\\"formation\\", \\"ordwor\\", \\"wordword\\", \\"formationwor\\"]) 2 >>> count_valid_concatenations(\\"abcdef\\", [\\"ghijk\\", \\"lmnop\\", \\"qrstuv\\"]) 0","solution":"def count_valid_concatenations(s, words): Returns the number of words in the list \`words\` that are valid concatenations of a suffix and a prefix of the string \`s\`. concatenations = set() n = len(s) # Generate all valid concatenations of a suffix and a prefix for i in range(n + 1): suffix = s[i:] for j in range(n + 1): prefix = s[:j] concatenations.add(suffix + prefix) # Count how many words in \`words\` are in the set of valid concatenations count = 0 for word in words: if word in concatenations: count += 1 return count"},{"question":"def is_path_exist(grid: List[List[int]], path: List[int]) -> bool: Verify if there exists a path in the grid that matches the given path of elevations. >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> path = [1, 2, 3] >>> is_path_exist(grid, path) True >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> path = [1, 5, 9] >>> is_path_exist(grid, path) False >>> grid = [ ... [1, 2, 2], ... [1, 1, 2], ... [2, 2, 2] ... ] >>> path = [1, 2, 1, 2] >>> is_path_exist(grid, path) True >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> path = [5] >>> is_path_exist(grid, path) True >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> path = [10] >>> is_path_exist(grid, path) False","solution":"def is_path_exist(grid, path): def dfs(x, y, path_index): if path_index == len(path): return True if (x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != path[path_index]): return False temp, grid[x][y] = grid[x][y], None # mark the cell as visited found = (dfs(x + 1, y, path_index + 1) or dfs(x - 1, y, path_index + 1) or dfs(x, y + 1, path_index + 1) or dfs(x, y - 1, path_index + 1)) grid[x][y] = temp # unmark the cell return found for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == path[0] and dfs(i, j, 0): return True return False"},{"question":"from typing import List def min_minutes_to_rot_apples(grid: List[List[int]]) -> int: You are given a matrix \`grid\` of \`m x n\` size, where each cell contains an integer value, either \`0\`, \`1\`, or \`2\`. The cells represent: - \`0\` - an empty cell - \`1\` - a fresh apple - \`2\` - a rotten apple Every minute, any fresh apple that is adjacent (up, down, left, right) to a rotten apple will become rotten. Return the minimum number of minutes that must elapse until no fresh apple remains. If this is not possible, return \`-1\`. >>> min_minutes_to_rot_apples([[2, 1, 1], [1, 1, 0], [0, 1, 1]]) 4 >>> min_minutes_to_rot_apples([[2, 1, 1], [0, 1, 1], [1, 0, 1]]) -1 >>> min_minutes_to_rot_apples([[0, 2]]) 0 >>> min_minutes_to_rot_apples([[0, 0], [0, 0]]) 0 >>> min_minutes_to_rot_apples([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) -1 >>> min_minutes_to_rot_apples([[2, 2, 2], [2, 2, 2], [2, 2, 2]]) 0 >>> min_minutes_to_rot_apples([[2, 0, 1], [0, 1, 0], [1, 0, 1]]) -1","solution":"from collections import deque def min_minutes_to_rot_apples(grid): rows, cols = len(grid), len(grid[0]) fresh_apples = 0 queue = deque() # Initialize the queue with all already rotten apples and count fresh apples for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c, 0)) # (row, col, minutes) elif grid[r][c] == 1: fresh_apples += 1 # Directions for adjacents (up, down, left, right) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] minutes_elapsed = 0 while queue: r, c, minutes = queue.popleft() minutes_elapsed = max(minutes_elapsed, minutes) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1: grid[nr][nc] = 2 fresh_apples -= 1 queue.append((nr, nc, minutes + 1)) return minutes_elapsed if fresh_apples == 0 else -1"},{"question":"from typing import List def find_outstanding_scores(nums: List[int]) -> List[int]: Given a list of integers \`nums\`, return a sorted list of outstanding scores. A score is considered outstanding if it is strictly greater than the median score of the list. Args: nums (List[int]): List of integer scores. Returns: List[int]: Sorted list of outstanding scores. Examples: >>> find_outstanding_scores([5, 3, 8, 6, 7]) [7, 8] >>> find_outstanding_scores([1, 2, 3, 4]) [3, 4] >>> find_outstanding_scores([3, 3, 3, 3]) []","solution":"def find_outstanding_scores(nums): Returns a sorted list of scores that are strictly greater than the median score of nums. Args: nums (list of int): List of integer scores. Returns: list of int: Sorted list of outstanding scores. if not nums: return [] nums_sorted = sorted(nums) n = len(nums_sorted) if n % 2 == 1: median = nums_sorted[n // 2] else: median = (nums_sorted[n // 2 - 1] + nums_sorted[n // 2]) / 2 outstanding_scores = [score for score in nums_sorted if score > median] return outstanding_scores"},{"question":"def find_unique(arr): Finds the integer that appears exactly once in an array where all other integers appear exactly twice. Args: arr (list): List of integers where each integer appears exactly twice except one integer. Returns: int: The integer that appears exactly once. >>> find_unique([2, 2, 1, 3, 3]) 1 >>> find_unique([4, 1, 2, 1, 2]) 4 >>> find_unique([-1, -1, -2]) -2 >>> find_unique([1, 2, 3, 2, 3, 1, 5]) 5 >>> find_unique([3, 4, 4, 5, 5, 6, 6]) 3","solution":"def find_unique(arr): Finds the integer that appears exactly once in an array where all other integers appear exactly twice. Args: arr (list): List of integers where each integer appears exactly twice except one integer. Returns: int: The integer that appears exactly once. unique = 0 for num in arr: unique ^= num return unique"},{"question":"def trap_water(heights): Calculate the total amount of trapped water given the heights of buildings. :param heights: List[int] - heights of the buildings :return: int - total trapped water Example: >>> trap_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap_water([4,2,0,3,2,5]) == 9 from solution import trap_water def test_trap_water_example_cases(): assert trap_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 assert trap_water([4,2,0,3,2,5]) == 9 def test_trap_water_empty(): assert trap_water([]) == 0 def test_trap_water_no_trapped_water(): assert trap_water([1, 1, 1, 1]) == 0 assert trap_water([3, 2, 1, 0]) == 0 def test_trap_water_single_element(): assert trap_water([5]) == 0 def test_trap_water_two_elements(): assert trap_water([2, 5]) == 0 assert trap_water([5, 2]) == 0 def test_trap_water_decreasing_and_increasing(): assert trap_water([5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5]) == 25 assert trap_water([0, 1, 2, 3, 4, 5, 4, 3, 2, 1, 0]) == 0","solution":"def trap_water(heights): Calculate the total amount of trapped water given the heights of buildings. :param heights: List[int] - heights of the buildings :return: int - total trapped water if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate total trapped water total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"class LRUCache: Implement a Least Recently Used (LRU) Cache. Your implementation should provide the following functionalities: - \`LRUCache(int capacity)\`: Initializes the LRU cache with a positive integer capacity. - \`int get(int key)\`: Returns the value of the \`key\` if the \`key\` exists in the cache. Otherwise, returns \`-1\`. - \`void put(int key, int value)\`: Updates the value of the \`key\` if the \`key\` exists. Otherwise, adds the \`key-value\` pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The cache should follow the Least Recently Used (LRU) policy, which removes the least recently used items first. >>> lru_cache = LRUCache(2) >>> lru_cache.put(1, 1) >>> lru_cache.put(2, 2) >>> lru_cache.get(1) 1 >>> lru_cache.put(3, 3) >>> lru_cache.get(2) -1 >>> lru_cache.get(3) 3 >>> lru_cache.put(4, 4) >>> lru_cache.get(1) -1 >>> lru_cache.get(3) 3 >>> lru_cache.get(4) 4 >>> lru_cache = LRUCache(1) >>> lru_cache.put(1, 1) >>> lru_cache.get(1) 1 >>> lru_cache.put(2, 2) >>> lru_cache.get(1) -1 >>> lru_cache.get(2) 2 def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = value"},{"question":"def is_path(grid): Determines if there is a path from the top-left to the bottom-right corner of the maze. Args: grid (list of list of int): The maze represented as a 2D list where 1 is a wall and 0 is an open path. Returns: bool: True if there is a path, False otherwise. def test_is_path_exists(): grid = [ [0, 1, 0, 0], [0, 0, 0, 1], [1, 1, 0, 1], [0, 0, 0, 0] ] assert is_path(grid) def test_is_path_not_exists(): grid = [ [0, 1, 0, 0], [0, 0, 1, 1], [1, 1, 1, 1], [0, 0, 0, 0] ] assert not is_path(grid) def test_is_path_small_grid_path_exists(): grid = [ [0, 0], [0, 0] ] assert is_path(grid) def test_is_path_small_grid_path_not_exists(): grid = [ [0, 1], [1, 0] ] assert not is_path(grid) def test_is_path_single_cell(): grid = [ [0] ] assert is_path(grid) grid = [ [1] ] assert not is_path(grid)","solution":"def is_path(grid): Determines if there is a path from the top-left to the bottom-right corner of the maze. Args: grid (list of list of int): The maze represented as a 2D list where 1 is a wall and 0 is an open path. Returns: bool: True if there is a path, False otherwise. if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return False m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right def dfs(x, y): if x == m-1 and y == n-1: return True grid[x][y] = 1 # Mark as visited by setting to 1 (wall) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0: if dfs(nx, ny): return True grid[x][y] = 0 # Unmark (backtrack) return False return dfs(0, 0)"},{"question":"def find_k_pairs(nums: List[int], k: int) -> int: Returns the number of unique k-pairs in the array. A k-pair is defined as (nums[i], nums[j]) with i < j and nums[j] - nums[i] == k. >>> find_k_pairs([1, 5, 2, 3, 6], 4) 2 >>> find_k_pairs([1, 2, 3, 4, 5], 10) 0 >>> find_k_pairs([3, 1, 4, 1, 5], 2) 2 >>> find_k_pairs([1, 1, 1, 1], 0) 1 >>> find_k_pairs([-1, -2, -3, -4, -5], 1) 4 >>> find_k_pairs([2, 4, 6, 8], 2) 3 pass # Your code here","solution":"def find_k_pairs(nums, k): Returns the number of unique k-pairs in the array. A k-pair is defined as (nums[i], nums[j]) with i < j and nums[j] - nums[i] == k. count = 0 seen = set(nums) visited = set() for num in nums: if num not in visited: if num + k in seen: count += 1 if num - k in seen: count += 1 visited.add(num) # Divided by 2 since each pair (a, b) and (b, a) might be counted twice return count // 2"},{"question":"def min_employees_required(projs, H): Returns the minimum number of employees required to complete all projects under the given constraints. Parameters: projs (list of list of int): List of projects with each project being a list of task durations. H (int): Maximum number of hours an employee can work in a week. Returns: int: Minimum number of employees required. >>> min_employees_required([[5]], 5) 1 >>> min_employees_required([[5]], 10) 1 >>> min_employees_required([[5, 6, 7]], 10) 2 >>> min_employees_required([[4, 4, 4]], 8) 2 >>> min_employees_required([[5,6], [7,8]], 10) 3 >>> min_employees_required([[3, 5], [2, 2, 2], [5, 1, 1, 3]], 8) 3 >>> min_employees_required([[2, 2, 2, 2], [3, 3, 3]], 12) 2 >>> min_employees_required([[5, 10, 5], [5, 5, 5, 5]], 20) 2 >>> min_employees_required([[2]], 10) 1 >>> min_employees_required([[1,1],[1,1],[1,1]], 10) 1 >>> min_employees_required([], 10) 0 >>> min_employees_required([[]], 10) 0","solution":"import math def min_employees_required(projs, H): Returns the minimum number of employees required to complete all projects under the given constraints. Parameters: projs (list of list of int): List of projects with each project being a list of task durations. H (int): Maximum number of hours an employee can work in a week. Returns: int: Minimum number of employees required. total_hours = sum(sum(proj) for proj in projs) num_employees = math.ceil(total_hours / H) return num_employees"},{"question":"def minConnectionsToAdd(connections, n): Returns the minimal number of connections that need to be added to ensure that every computer in the network is connected to every other computer. :param connections: List of tuples (a, b) representing direct connections. :param n: Total number of computers in the network. :return: Minimum number of connections to be added. >>> minConnectionsToAdd([], 4) 3 >>> minConnectionsToAdd([(0, 1), (1, 2), (2, 3)], 4) 0 >>> minConnectionsToAdd([(0, 1), (2, 3)], 4) 1 >>> minConnectionsToAdd([], 1) 0 >>> minConnectionsToAdd([(0, 1), (1, 2)], 4) 1","solution":"def minConnectionsToAdd(connections, n): Returns the minimal number of connections that need to be added to ensure that every computer in the network is connected to every other computer. :param connections: List of tuples (a, b) representing direct connections. :param n: Total number of computers in the network. :return: Minimum number of connections to be added. parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY for a, b in connections: union(a, b) components = len(set(find(i) for i in range(n))) return components - 1"},{"question":"def merge_alternately_lexicographically(arr1, arr2): Merge two arrays alternately to form the lexicographically smallest array. You are given two arrays \`arr1\` and \`arr2\` each of length \`n\` consisting of positive integers. You are required to create a single sorted array from \`arr1\` and \`arr2\` containing all the elements from both arrays. However, you can only pick elements alternately from \`arr1\` and \`arr2\` starting with any of the arrays. Return the lexicographically smallest possible array. In case of picking the same element from both arrays, prefer the element from \`arr1\`. Parameters: arr1 (list of int): The first input array. arr2 (list of int): The second input array. Returns: list of int: The lexicographically smallest possible merged array. >>> merge_alternately_lexicographically([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_alternately_lexicographically([1, 7, 8], [2, 3, 4]) [1, 2, 3, 4, 7, 8] >>> merge_alternately_lexicographically([4, 5, 6], [1, 2, 3]) [1, 2, 3, 4, 5, 6] >>> merge_alternately_lexicographically([1, 3, 5], [1, 3, 5]) [1, 1, 3, 3, 5, 5] >>> merge_alternately_lexicographically([], []) []","solution":"def merge_alternately_lexicographically(arr1, arr2): Merges two arrays alternately to form the lexicographically smallest array. Parameters: arr1 (list of int): The first input array. arr2 (list of int): The second input array. Returns: list of int: The lexicographically smallest possible merged array. n = len(arr1) idx1, idx2 = 0, 0 result = [] while idx1 < n and idx2 < n: if arr1[idx1] < arr2[idx2]: result.append(arr1[idx1]) idx1 += 1 elif arr2[idx2] < arr1[idx1]: result.append(arr2[idx2]) idx2 += 1 else: result.append(arr1[idx1]) idx1 += 1 while idx1 < n: result.append(arr1[idx1]) idx1 += 1 while idx2 < n: result.append(arr2[idx2]) idx2 += 1 return result"},{"question":"def count_reachable_cells(mat): Return the number of reachable cells in a matrix. A cell is reachable if it has a path on row or column comprised entirely of 1s that connects it to any edge of the matrix. >>> count_reachable_cells([ ... [1, 1], ... [1, 1] ... ]) == 4 >>> count_reachable_cells([ ... [0, 0], ... [0, 0] ... ]) == 0 >>> count_reachable_cells([ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) == 5 >>> count_reachable_cells([ ... [1, 0, 1, 1] ... ]) == 3 >>> count_reachable_cells([ ... [1], ... [0], ... [1], ... [1] ... ]) == 3 pass","solution":"def is_reachable(mat, i, j, m, n): # Check if cell mat[i][j] is reachable by moving horizontally or vertically to the matrix edge for c in range(n): if mat[i][c] == 1 and any(mat[i][k] == 1 for k in range(c+1)): return True for r in range(m): if mat[r][j] == 1 and any(mat[k][j] == 1 for k in range(r+1)): return True return False def count_reachable_cells(mat): m, n = len(mat), len(mat[0]) count = 0 for i in range(m): for j in range(n): if mat[i][j] == 1 and is_reachable(mat, i, j, m, n): count += 1 return count"},{"question":"def maxSubmatrixSumDivisibleByK(matrix: List[List[int]], k: int) -> int: Find the maximum sum of a submatrix such that the sum is divisible by k. If there is no such submatrix, return 0. Args: matrix (List[List[int]]): The matrix of integers. k (int): The divisor. Returns: int: The maximum sum of the submatrix divisible by k, or 0 if no such submatrix exists. Examples: >>> maxSubmatrixSumDivisibleByK([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], 3) 45 >>> maxSubmatrixSumDivisibleByK([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ], 10) 0","solution":"def maxSubmatrixSumDivisibleByK(matrix, k): Returns the maximum sum of submatrix such that the sum is divisible by k. If there is no such submatrix, returns 0. n = len(matrix) m = len(matrix[0]) if n > 0 else 0 # Function to calculate prefix sums for the matrix def calculate_prefix_sums(matrix): prefix_sums = [[0] * (m + 1) for _ in range(n + 1)] for i in range(n): for j in range(m): prefix_sums[i + 1][j + 1] = (matrix[i][j] + prefix_sums[i + 1][j] + prefix_sums[i][j + 1] - prefix_sums[i][j]) return prefix_sums # Get prefix sums prefix_sums = calculate_prefix_sums(matrix) max_sum = float('-inf') # Iterate over all possible submatrices for r1 in range(1, n + 1): for r2 in range(r1, n + 1): for c1 in range(1, m + 1): for c2 in range(c1, m + 1): submatrix_sum = (prefix_sums[r2][c2] - prefix_sums[r2][c1 - 1] - prefix_sums[r1 - 1][c2] + prefix_sums[r1 - 1][c1 - 1]) if submatrix_sum % k == 0: max_sum = max(max_sum, submatrix_sum) return max_sum if max_sum != float('-inf') else 0 # Example Usage: # matrix = [[1, 2, 3], # [4, 5, 6], # [7, 8, 9]] # k = 3 # print(maxSubmatrixSumDivisibleByK(matrix, k)) # Output should be a maximum sum submatrix divisible by 3"},{"question":"def trap(height: List[int]) -> int: Calculate the maximum amount of rainwater that can be trapped between the buildings. >>> trap([]) == 0 >>> trap([0, 1, 2, 3, 4]) == 0 >>> trap([0, 1, 0, 2]) == 1 >>> trap([3, 0, 2, 0, 4]) == 7 >>> trap([4, 2, 0, 3, 2, 5]) == 9 >>> trap([1, 1, 1, 1]) == 0 >>> trap([5, 5, 5, 5, 5]) == 0","solution":"def trap(height): This function computes the maximum amount of rainwater that can be trapped between the buildings. :param height: List[int] :return: int if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def longest_unique_subarray(nums: List[int]) -> List[int]: Given an array of integers \`nums\`, return the longest contiguous subarray that contains only unique elements. If there are multiple such subarrays, return the one that occurs first. >>> longest_unique_subarray([1, 2, 3, 1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> longest_unique_subarray([5, 5, 5, 5, 5]) == [5]","solution":"def longest_unique_subarray(nums): Returns the longest contiguous subarray with unique elements. If there are multiple such subarrays, returns the one that occurs first. n = len(nums) if n == 0: return [] max_length = 0 longest_subarray_start = 0 current_subarray_start = 0 element_index_map = {} for i in range(n): if nums[i] in element_index_map and element_index_map[nums[i]] >= current_subarray_start: current_subarray_start = element_index_map[nums[i]] + 1 element_index_map[nums[i]] = i current_length = i - current_subarray_start + 1 if current_length > max_length: max_length = current_length longest_subarray_start = current_subarray_start return nums[longest_subarray_start:longest_subarray_start + max_length]"},{"question":"def min_swaps_to_make_palindrome(s: str) -> int: Returns the minimum number of swaps required to make the string a palindrome. If it is impossible to form a palindrome, returns -1. >>> min_swaps_to_make_palindrome(\\"aabb\\") == 2 >>> min_swaps_to_make_palindrome(\\"ab\\") == -1 >>> min_swaps_to_make_palindrome(\\"aa\\") == 0 >>> min_swaps_to_make_palindrome(\\"racecar\\") == 0 >>> min_swaps_to_make_palindrome(\\"mamad\\") == 3 >>> min_swaps_to_make_palindrome(\\"abc\\") == -1 >>> min_swaps_to_make_palindrome(\\"a\\") == 0 >>> min_swaps_to_make_palindrome(\\"\\") == 0","solution":"def min_swaps_to_make_palindrome(s): Returns the minimum number of swaps required to make the string a palindrome. If it is impossible to form a palindrome, returns -1. if not can_form_palindrome(s): return -1 s = list(s) n = len(s) swaps = 0 for i in range(n // 2): left = i right = n - left - 1 while left < right: if s[left] == s[right]: break else: right -= 1 if left == right: s[left], s[left + 1] = s[left + 1], s[left] swaps += 1 right = n - left - 1 for j in range(right, n - left - 1): s[j], s[j + 1] = s[j + 1], s[j] swaps += 1 return swaps def can_form_palindrome(s): Helper function to determine if it is possible to rearrange the string to form a palindrome. from collections import Counter freq = Counter(s) odd_count = sum(1 for count in freq.values() if count % 2 != 0) return odd_count <= 1"},{"question":"class Library: Implements a system to manage a library of digital books. Methods: - addBook(title: str, author: str) -> int - borrowBook(userId: int, bookId: int) -> bool - returnBook(userId: int, bookId: int) - getAvailableBooks() -> List - rateBook(bookId: int, rating: int) - getAverageRating(bookId: int) -> float def __init__(self): Initializes the Library object. def addBook(self, title: str, author: str) -> int: Adds a new book with the given title and author to the library. Args: title (str): The title of the book. author (str): The author of the book. Returns: int: The ID of the newly added book. def borrowBook(self, userId: int, bookId: int) -> bool: Borrows a book for the user with the given user ID. Args: userId (int): The ID of the user. bookId (int): The ID of the book. Returns: bool: True if the book was successfully borrowed, otherwise False. def returnBook(self, userId: int, bookId: int): Returns a borrowed book to the library. Args: userId (int): The ID of the user. bookId (int): The ID of the book. def getAvailableBooks(self) -> list: Retrieves a list of all available books in the library. Returns: list: List of dictionaries representing available books. def rateBook(self, bookId: int, rating: int): Rates a book with the given rating. Args: bookId (int): The ID of the book. rating (int): The rating to be given to the book (1 to 5). def getAverageRating(self, bookId: int) -> float: Retrieves the average rating of a book. Args: bookId (int): The ID of the book. Returns: float: The average rating of the book. If the book has no ratings, returns 0.0.","solution":"class Library: def __init__(self): self.books = {} self.book_counter = 1 self.borrowed_books = {} self.ratings = {} self.book_users = {} def addBook(self, title, author): book_id = self.book_counter self.books[book_id] = {\\"title\\": title, \\"author\\": author, \\"borrowed\\": False} self.book_counter += 1 return book_id def borrowBook(self, userId, bookId): if bookId in self.books and not self.books[bookId][\\"borrowed\\"]: self.books[bookId][\\"borrowed\\"] = True self.borrowed_books[bookId] = userId return True return False def returnBook(self, userId, bookId): if bookId in self.borrowed_books and self.borrowed_books[bookId] == userId: self.books[bookId][\\"borrowed\\"] = False del self.borrowed_books[bookId] def getAvailableBooks(self): return [ {\\"id\\": book_id, \\"title\\": book[\\"title\\"], \\"author\\": book[\\"author\\"]} for book_id, book in self.books.items() if not book[\\"borrowed\\"] ] def rateBook(self, bookId, rating): if bookId in self.books and 1 <= rating <= 5: if bookId not in self.ratings: self.ratings[bookId] = [] self.ratings[bookId].append(rating) def getAverageRating(self, bookId): if bookId in self.ratings and self.ratings[bookId]: return sum(self.ratings[bookId]) / len(self.ratings[bookId]) return 0.0"},{"question":"def is_anagram_possible(s: str, t: str) -> bool: Determine if one string can be converted to another by swapping adjacent characters any number of times. :param s: String to be converted :param t: Target string :return: Boolean value indicating if s can be converted to t >>> is_anagram_possible(\\"listen\\", \\"silent\\") True >>> is_anagram_possible(\\"triangle\\", \\"integral\\") True >>> is_anagram_possible(\\"apple\\", \\"papel\\") True >>> is_anagram_possible(\\"hello\\", \\"billion\\") False >>> is_anagram_possible(\\"rat\\", \\"car\\") False >>> is_anagram_possible(\\"\\", \\"\\") True >>> is_anagram_possible(\\"a\\", \\"\\") False >>> is_anagram_possible(\\"\\", \\"a\\") False >>> is_anagram_possible(\\"aabbcc\\", \\"abcabc\\") True >>> is_anagram_possible(\\"aabbcc\\", \\"abcabca\\") False","solution":"def is_anagram_possible(s, t): Determine if one string can be converted to another by swapping adjacent characters any number of times. :param s: String to be converted :param t: Target string :return: Boolean value indicating if s can be converted to t if sorted(s) == sorted(t): return True return False"},{"question":"from typing import List def can_see_in_front(heights: List[int]) -> int: Return the number of people who can see at least one person standing in front of them. Args: heights: List[int] - a list of integers representing heights of people in a line. Returns: int - the number of people who can see at least one person standing in front of them. Examples: >>> can_see_in_front([1, 2, 3]) 2 >>> can_see_in_front([3, 2, 1]) 0 >>> can_see_in_front([1, 3, 2, 4]) 3 >>> can_see_in_front([1]) 0 >>> can_see_in_front([2, 2, 2, 2]) 3","solution":"def can_see_in_front(heights): n = len(heights) count = 0 for i in range(n): for j in range(i + 1, n): if heights[j] >= heights[i]: break else: count += 1 return n - count"},{"question":"def find_k_peaks(arr: List[int], k: int) -> List[int]: Finds up to k peak positions in the array \`arr\`. Parameters: - arr: List[int] : The input array of integers - k: int : The number of peak positions to find Returns: - List[int] : A list of at most k peak indices, in ascending order >>> find_k_peaks([1, 3, 1, 3, 1], 2) [1, 3] >>> find_k_peaks([3, 1, 3], 2) [0, 2] >>> find_k_peaks([1, 5], 1) [1] >>> find_k_peaks([], 2) [] from solution import find_k_peaks def test_no_peaks(): assert find_k_peaks([1, 1, 1, 1], 3) == [] assert find_k_peaks([], 2) == [] def test_single_peak(): assert find_k_peaks([1, 3, 1], 1) == [1] assert find_k_peaks([1, 3, 1], 2) == [1] def test_multiple_peaks(): assert find_k_peaks([1, 3, 1, 3, 1], 2) == [1, 3] assert find_k_peaks([1, 3, 1, 3, 1], 1) == [1] def test_k_exceeds_peaks(): assert find_k_peaks([1, 3, 1, 3, 1], 5) == [1, 3] assert find_k_peaks([1, 5, 3, 4, 2], 4) == [1, 3] def test_peaks_at_edges(): assert find_k_peaks([3, 1, 3], 2) == [0, 2] assert find_k_peaks([5, 1], 1) == [0] assert find_k_peaks([1, 5], 1) == [1]","solution":"def find_k_peaks(arr, k): Finds up to k peak positions in the array \`arr\`. Parameters: - arr: List[int] : The input array of integers - k: int : The number of peak positions to find Returns: - List[int] : A list of at most k peak indices, in ascending order n = len(arr) if n == 0: return [] peaks = [] # Check if the first element is a peak if n > 1 and arr[0] > arr[1]: peaks.append(0) # Check for peaks in the middle of the array for i in range(1, n - 1): if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: peaks.append(i) # Check if the last element is a peak if n > 1 and arr[n - 1] > arr[n - 2]: peaks.append(n - 1) # Return up to k peaks return peaks[:k]"},{"question":"import heapq from typing import List, Tuple def shortest_travel_time(n: int, edges: List[Tuple[int, int, int]], a: int, b: int) -> int: Returns the shortest travel time from intersection a to intersection b. :param n: Integer, number of intersections. :param edges: List of tuples, each containing three integers (u, v, w) representing a road between intersections u and v with travel time w. :param a: Integer, starting intersection. :param b: Integer, ending intersection. :return: Integer, minimum travel time if a path exists, or -1 if no path exists. pass def test_shortest_travel_time_direct_path(): assert shortest_travel_time(4, [(0, 1, 4), (1, 2, 6), (1, 3, 1)], 0, 3) == 5 def test_shortest_travel_time_no_path(): assert shortest_travel_time(4, [(0, 1, 4), (1, 2, 6)], 0, 3) == -1 def test_shortest_travel_time_same_start_end(): assert shortest_travel_time(4, [(0, 1, 4), (1, 2, 6), (1, 3, 1)], 0, 0) == 0 def test_shortest_travel_time_longer_path(): assert shortest_travel_time(4, [(0, 1, 1), (1, 2, 1), (2, 3, 1), (0, 3, 10)], 0, 3) == 3 def test_shortest_travel_time_multiple_paths(): assert shortest_travel_time(5, [(0, 1, 2), (0, 2, 4), (1, 2, 1), (1, 3, 7), (2, 3, 3), (3, 4, 1)], 0, 4) == 7","solution":"import heapq def shortest_travel_time(n, edges, a, b): Returns the shortest travel time from intersection a to intersection b. :param n: Integer, number of intersections. :param edges: List of lists, each containing three integers [u, v, w] representing a road between intersections u and v with travel time w. :param a: Integer, starting intersection. :param b: Integer, ending intersection. :return: Integer, minimum travel time if a path exists, or -1 if no path exists. graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) min_heap = [(0, a)] # (cost, node) min_time = {i: float('inf') for i in range(n)} min_time[a] = 0 while min_heap: curr_time, u = heapq.heappop(min_heap) if u == b: return curr_time if curr_time > min_time[u]: continue for v, weight in graph[u]: time = curr_time + weight if time < min_time[v]: min_time[v] = time heapq.heappush(min_heap, (time, v)) return -1 if min_time[b] == float('inf') else min_time[b]"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reorder_even_after_odd(head: ListNode) -> ListNode: Reorder the linked list such that all nodes with even values are positioned after the nodes with odd values, maintaining their relative order. >>> linked_list_to_list(reorder_even_after_odd(None)) == [] True >>> node = ListNode(1) >>> linked_list_to_list(reorder_even_after_odd(node)) == [1] True >>> head = ListNode(1, ListNode(3, ListNode(5))) >>> linked_list_to_list(reorder_even_after_odd(head)) == [1, 3, 5] True >>> head = ListNode(2, ListNode(4, ListNode(6))) >>> linked_list_to_list(reorder_even_after_odd(head)) == [2, 4, 6] True >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6)))))) >>> linked_list_to_list(reorder_even_after_odd(head)) == [1, 3, 5, 2, 4, 6] True >>> head = ListNode(4, ListNode(1, ListNode(3, ListNode(2, ListNode(5, ListNode(8, ListNode(7, ListNode(10)))))))) >>> linked_list_to_list(reorder_even_after_odd(head)) == [1, 3, 5, 7, 4, 2, 8, 10] True","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reorder_even_after_odd(head: ListNode) -> ListNode: if not head or not head.next: return head odd_dummy = ListNode(0) even_dummy = ListNode(0) odd_tail, even_tail = odd_dummy, even_dummy current = head while current: if current.value % 2 == 0: even_tail.next = current even_tail = even_tail.next else: odd_tail.next = current odd_tail = odd_tail.next current = current.next even_tail.next = None # end the even list odd_tail.next = even_dummy.next # append even list after odd list return odd_dummy.next"},{"question":"def reformat(s: str) -> str: Reformats the string s so that letters and digits alternate, starting with a letter if there are at least as many letters as digits, and otherwise starting with a digit. Returns an empty string if it's not possible to reformat in this way. >>> reformat(\\"abc\\") == \\"\\" >>> reformat(\\"123\\") == \\"\\" >>> reformat(\\"a1b2\\") in [\\"a1b2\\", \\"1a2b\\"] >>> reformat(\\"abc123\\") in [\\"a1b2c3\\", \\"1a2b3c\\"] >>> reformat(\\"a1b2c3d\\") in [\\"a1b2c3d\\", \\"1a2b3c4\\"] >>> reformat(\\"\\") == \\"\\" >>> reformat(\\"a\\") == \\"a\\" >>> reformat(\\"1\\") == \\"1\\" >>> reformat(\\"a1\\") in [\\"a1\\", \\"1a\\"]","solution":"def reformat(s): Reformats the string s so that letters and digits alternate, starting with a letter if there are at least as many letters as digits, and otherwise starting with a digit. Returns an empty string if it's not possible to reformat in this way. letters = [ch for ch in s if ch.isalpha()] digits = [ch for ch in s if ch.isdigit()] if abs(len(letters) - len(digits)) > 1: return \\"\\" if len(letters) > len(digits): result = ''.join([x for y in zip(letters, digits + ['']) for x in y]) else: result = ''.join([x for y in zip(digits, letters + ['']) for x in y]) return result"},{"question":"def find_max_levels(n: int, reportees: List[List[int]], CEO: int) -> int: Calculate the maximum number of levels in the company hierarchy including the CEO. Args: n (int): Total number of employees. reportees (List[List[int]]): The hierarchical structure where each element is [manager, employee]. CEO (int): The employee number of the CEO. Returns: int: The total number of levels in the company hierarchy. >>> find_max_levels(1, [], 1) 1 >>> find_max_levels(3, [[1, 2], [1, 3]], 1) 2 >>> find_max_levels(4, [[1, 2], [2, 3], [3, 4]], 1) 4 >>> find_max_levels(5, [[1, 2], [1, 3], [1, 4], [1, 5]], 1) 2 >>> find_max_levels(7, [[1, 2], [1, 3], [3, 4], [3, 5], [4, 6], [4, 7]], 1) 4 >>> find_max_levels(3, [[1, 2]], 1) 2 # Employee 3 is not connected to the hierarchy","solution":"def find_max_levels(n, reportees, CEO): from collections import defaultdict, deque # Building the adjacency list for the company's hierarchy hierarchy = defaultdict(list) for manager, employee in reportees: hierarchy[manager].append(employee) # Perform BFS to find the maximum number of levels in the hierarchy queue = deque([(CEO, 1)]) # (current_employee, current_level) max_level = 0 while queue: employee, level = queue.popleft() max_level = max(max_level, level) for reportee in hierarchy[employee]: queue.append((reportee, level + 1)) return max_level"},{"question":"def findElementAfterKSwaps(arr: List[int], k: int) -> int: Returns the element that ends up at the first position after exactly k swaps, where in each swap any two consecutive elements can be exchanged. >>> findElementAfterKSwaps([4, 5, 6, 7], 0) 4 >>> findElementAfterKSwaps([3], 10) 3 >>> findElementAfterKSwaps([4, 3, 2, 1], 1) 3 >>> findElementAfterKSwaps([10, 3, 5, 2], 3) 2 >>> findElementAfterKSwaps([7, 1, 5, 9], 10) 1 >>> findElementAfterKSwaps([5, 5, 5, 5], 2) 5","solution":"def findElementAfterKSwaps(arr, k): Returns the element that ends up at the first position after exactly k swaps, where in each swap any two consecutive elements can be exchanged. if k == 0 or len(arr) == 1: return arr[0] # Ensure k does not exceed the length of the array minus one k = min(k, len(arr) - 1) # Perform k swaps (each swap essentially shifts the first k+1 elements) first_k_elements = arr[:k + 1] first_k_elements.sort() return first_k_elements[0]"},{"question":"def distinct_substrings(s: str) -> int: Returns the number of distinct substrings that can be formed from s. >>> distinct_substrings(\\"a\\") 1 >>> distinct_substrings(\\"ab\\") 3 >>> distinct_substrings(\\"aaa\\") 3 >>> distinct_substrings(\\"abc\\") 6 >>> distinct_substrings(\\"abab\\") 7","solution":"def distinct_substrings(s): Returns the number of distinct substrings that can be formed from s. n = len(s) substrings = set() for i in range(n): for j in range(i, n): substrings.add(s[i:j+1]) return len(substrings)"},{"question":"def min_length_after_removals(text: str, words: list) -> int: Returns the minimum length of the text after removing all possible words from the words array. Parameters: text (str): The original string from which substrings will be removed. words (list): A list of substrings to be removed from the text. Returns: int: The minimum length of the text after all removals. Example: >>> min_length_after_removals(\\"abcde\\", [\\"ab\\", \\"cd\\"]) 1 >>> min_length_after_removals(\\"abcde\\", [\\"fg\\", \\"hi\\"]) 5 pass # Unit tests def test_min_length_after_removals_basic(): assert min_length_after_removals(\\"abcde\\", [\\"ab\\", \\"cd\\"]) == 1 def test_min_length_after_removals_no_removal(): assert min_length_after_removals(\\"abcde\\", [\\"fg\\", \\"hi\\"]) == 5 def test_min_length_after_removals_partial_match(): assert min_length_after_removals(\\"abcde\\", [\\"bc\\", \\"e\\"]) == 2 def test_min_length_after_removals_empty_word(): assert min_length_after_removals(\\"abcde\\", [\\"\\"]) == 5 def test_min_length_after_removals_multiple_words(): assert min_length_after_removals(\\"abba\\", [\\"a\\", \\"b\\"]) == 0 def test_min_length_after_removals_overlap(): assert min_length_after_removals(\\"abcabc\\", [\\"abc\\", \\"bc\\"]) == 0 def test_min_length_after_removals_all_characters(): assert min_length_after_removals(\\"aaaa\\", [\\"a\\"]) == 0","solution":"def min_length_after_removals(text, words): Returns the minimum length of the text after removing all possible words from the words array. while True: initial_length = len(text) for word in words: if word in text: text = text.replace(word, \\"\\") if len(text) == initial_length: break return len(text)"},{"question":"from typing import List def find_peak_element(arr: List[int]) -> int: Find the index of a peak element in an array. A peak element is an element that is strictly greater than its neighbors. An element is considered a peak if it is greater than its neighbors or if it is at the boundary of the array (i.e., first or last element) and greater than its neighbor. This function aims to find a peak element with a time complexity of O(log n), achieved through a binary search approach. Parameters: arr (List[int]): The input list of integers. Returns: int: The index of a peak element. Examples: >>> find_peak_element([5, 4, 3, 2, 1]) 0 >>> find_peak_element([1, 2, 3, 4, 5]) 4 >>> find_peak_element([1, 3, 20, 4, 1, 0]) 2 >>> find_peak_element([1]) 0 >>> find_peak_element([1, 2]) 1 >>> find_peak_element([2, 1]) 0 >>> find_peak_element([1, 2, 2, 3, 4, 3, 5, 4]) 4 # The result can be index 4 or 6 as both are peak elements >>> find_peak_element([1, 3, 20, 4, 1, 6, 0]) 2 # The result can be index 2 or 5 as both are peak elements >>> find_peak_element([1, 3, 1, 4, 1]) 1 # The result can be index 1 or 3 as both are peak elements","solution":"def find_peak_element(arr): Function to find the index of a peak element. Parameters: arr (list): A list of integers. Returns: int: The index of one of the peak elements. left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] < arr[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"import heapq from typing import List def connect_sticks(sticks: List[int]) -> int: Returns the minimum cost of connecting all the sticks into one. :param sticks: List[int] - List of the lengths of the sticks :return: int - Minimum cost of connecting all the sticks >>> connect_sticks([5]) 0 >>> connect_sticks([1, 2]) 3 >>> connect_sticks([1, 2, 3]) 9 >>> connect_sticks([5, 4, 3, 2, 1]) 33 >>> connect_sticks([2, 2, 2, 2]) 16 >>> connect_sticks([1, 8, 3, 5]) 30 >>> connect_sticks([]) 0","solution":"import heapq def connect_sticks(sticks): Returns the minimum cost of connecting all the sticks into one. :param sticks: List[int] - List of the lengths of the sticks :return: int - Minimum cost of connecting all the sticks if not sticks: return 0 heapq.heapify(sticks) total_cost = 0 while len(sticks) > 1: # Pop two smallest sticks first = heapq.heappop(sticks) second = heapq.heappop(sticks) # Cost to connect them cost = first + second # Add the connected stick back to the heap heapq.heappush(sticks, cost) # Accumulate total cost total_cost += cost return total_cost"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root: TreeNode) -> List[List[int]]: Given a binary tree, return the values of its nodes obtained by traversing the tree in level-order (breadth-first search). The result should be a list of lists, where each inner list contains the values at a particular level of the tree. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> level_order(root) [[3], [9, 20], [15, 7]] >>> root = TreeNode(1) >>> level_order(root) [[1]] >>> level_order(None) [] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.right = TreeNode(4) >>> root.right.right = TreeNode(5) >>> root.right.right.right = TreeNode(6) >>> level_order(root) [[1], [2, 3], [4, 5], [6]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root): Returns the level-order traversal of a binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"def min_cost_to_avoid_consecutive_as(s: str) -> int: Given a string s containing only 'a' and 'b', returns the minimum cost required to remove characters such that there are no consecutive 'a's. Args: s (str): The input string. Returns: int: The minimum cost to achieve the desired string. pass # Test cases def test_single_character(): assert min_cost_to_avoid_consecutive_as(\\"a\\") == 0 assert min_cost_to_avoid_consecutive_as(\\"b\\") == 0 def test_no_consecutive_as(): assert min_cost_to_avoid_consecutive_as(\\"ab\\") == 0 assert min_cost_to_avoid_consecutive_as(\\"ba\\") == 0 assert min_cost_to_avoid_consecutive_as(\\"bab\\") == 0 def test_simple_case(): assert min_cost_to_avoid_consecutive_as(\\"aa\\") == 2 assert min_cost_to_avoid_consecutive_as(\\"aab\\") == 2 assert min_cost_to_avoid_consecutive_as(\\"baa\\") == 3 def test_more_complex_case(): assert min_cost_to_avoid_consecutive_as(\\"aabb\\") == 2 assert min_cost_to_avoid_consecutive_as(\\"baaa\\") == 7 assert min_cost_to_avoid_consecutive_as(\\"bbbaa\\") == 5 assert min_cost_to_avoid_consecutive_as(\\"aaa\\") == 2 + 3 def test_long_string(): assert min_cost_to_avoid_consecutive_as(\\"a\\" * 5) == 2 + 3 + 4 + 5 assert min_cost_to_avoid_consecutive_as(\\"baaaaaaaa\\") == sum(range(3, 10))","solution":"def min_cost_to_avoid_consecutive_as(s): Given a string s containing only 'a' and 'b', returns the minimum cost required to remove characters such that there are no consecutive 'a's. Args: s (str): The input string. Returns: int: The minimum cost to achieve the desired string. n = len(s) if n <= 1: return 0 cost = 0 i = 0 while i < n: if s[i] == 'a': # Find the subsequence of consecutive 'a's start = i while i < n and s[i] == 'a': i += 1 end = i length = end - start if length > 1: # Remove (length - 1) 'a's to leave a single 'a'. remove_count = length - 1 cost += sum(range(start + 2, start + 2 + remove_count)) else: i += 1 return cost"},{"question":"def reverse_string_preserve_spaces(s: str) -> str: Given a string s consisting of only alphabetic characters and spaces, return a new string where the characters appear in reverse order but the positions of spaces remain unchanged. Lowercase and uppercase letters are maintained in their original form (e.g., 'a' remains 'a' and 'A' remains 'A'). >>> reverse_string_preserve_spaces(\\"hello world\\") == \\"dlrow olleh\\" >>> reverse_string_preserve_spaces(\\" hello\\") == \\" olleh\\" >>> reverse_string_preserve_spaces(\\"hello \\") == \\"olleh \\" >>> reverse_string_preserve_spaces(\\"abcdef\\") == \\"fedcba\\" >>> reverse_string_preserve_spaces(\\"\\") == \\"\\" >>> reverse_string_preserve_spaces(\\" \\") == \\" \\" >>> reverse_string_preserve_spaces(\\"Hello World\\") == \\"dlroW olleH\\" >>> reverse_string_preserve_spaces(\\"Ab C dE\\") == \\"Ed C bA\\"","solution":"def reverse_string_preserve_spaces(s): Returns a new string where the characters appear in reverse order but the positions of spaces remain unchanged. # List to collect characters from the input string chars = [] # Collecting non-space characters for char in s: if char != ' ': chars.append(char) # Reverse the list of collected characters chars.reverse() # Index for the reversed characters reversed_char_index = 0 result = [] # Construct the result string by considering the positions of spaces for char in s: if char == ' ': result.append(' ') else: result.append(chars[reversed_char_index]) reversed_char_index += 1 return ''.join(result)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_bottom_left_value(root: TreeNode) -> int: Given a binary tree, return the bottom-left value in the last row of the tree. >>> find_bottom_left_value(TreeNode(1, TreeNode(2), TreeNode(3))) 2 >>> find_bottom_left_value(TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, TreeNode(5), TreeNode(6)))) 4 from solution import TreeNode, find_bottom_left_value def test_single_node(): root = TreeNode(1) assert find_bottom_left_value(root) == 1 def test_two_levels(): root = TreeNode(1, TreeNode(2), TreeNode(3)) assert find_bottom_left_value(root) == 2 def test_three_levels(): root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, TreeNode(5), TreeNode(6))) assert find_bottom_left_value(root) == 4 def test_only_left_children(): root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4)))) assert find_bottom_left_value(root) == 4 def test_only_right_children(): root = TreeNode(1, None, TreeNode(2, None, TreeNode(3, None, TreeNode(4)))) assert find_bottom_left_value(root) == 4 def test_complex_tree(): root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, TreeNode(5, TreeNode(7)), TreeNode(6))) assert find_bottom_left_value(root) == 7","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_bottom_left_value(root): from collections import deque queue = deque([root]) while queue: node = queue.popleft() if node.right: queue.append(node.right) if node.left: queue.append(node.left) return node.val"},{"question":"def max_perimeter(arr): Finds the maximum perimeter of a triangle that can be formed with three sticks. :param arr: List of integers representing the lengths of the sticks. :return: The maximum perimeter of a valid triangle, or 0 if no valid triangle can be formed. pass from max_perimeter import max_perimeter def test_max_perimeter_valid_triangle(): assert max_perimeter([2, 3, 4, 5, 10]) == 12 # 4, 5, 3 forms the triangle with perimeter 12 def test_max_perimeter_no_triangle_possible(): assert max_perimeter([1, 2, 3]) == 0 # No valid triangle can be formed def test_max_perimeter_multiple_triangles(): assert max_perimeter([10, 21, 22, 100]) == 53 # 10, 21, 22 forms the triangle with perimeter 53 def test_max_perimeter_all_same_lengths(): assert max_perimeter([5, 5, 5]) == 15 # All sticks are the same length (5), forms a valid triangle with perimeter 15 def test_max_perimeter_large_input(): assert max_perimeter([1000, 2000, 3000, 4000, 5000]) == 12000 # 3000, 4000, 5000 forms the triangle with perimeter 12000 def test_max_perimeter_no_sticks(): assert max_perimeter([]) == 0 # No sticks provided def test_max_perimeter_not_enough_sticks(): assert max_perimeter([1, 1]) == 0 # Not enough sticks to form a triangle def test_max_perimeter_four_sticks(): assert max_perimeter([1, 2, 2, 3]) == 7 # 2, 2, 3 forms the triangle with perimeter 7","solution":"def max_perimeter(arr): Finds the maximum perimeter of a triangle that can be formed with three sticks. :param arr: List of integers representing the lengths of the sticks. :return: The maximum perimeter of a valid triangle, or 0 if no valid triangle can be formed. arr.sort(reverse=True) n = len(arr) for i in range(n - 2): if arr[i] < arr[i + 1] + arr[i + 2]: return arr[i] + arr[i + 1] + arr[i + 2] return 0"},{"question":"from typing import List def update_traffic_lights(lights: List[str]) -> List[str]: Update the state of traffic lights based on the given rules. :param lights: List of strings representing the state of each traffic light. :return: List of strings representing the state of traffic lights after one state transition. >>> update_traffic_lights([\\"Green\\", \\"Green\\", \\"Green\\"]) [\\"Yellow\\", \\"Yellow\\", \\"Yellow\\"] >>> update_traffic_lights([\\"Yellow\\", \\"Yellow\\", \\"Yellow\\"]) [\\"Red\\", \\"Red\\", \\"Red\\"] >>> update_traffic_lights([\\"Red\\", \\"Red\\", \\"Red\\"]) [\\"Green\\", \\"Green\\", \\"Green\\"] >>> update_traffic_lights([\\"Green\\", \\"Yellow\\", \\"Red\\"]) [\\"Yellow\\", \\"Red\\", \\"Green\\"] >>> update_traffic_lights([\\"Blue\\"]) Traceback (most recent call last): ... ValueError: Invalid traffic light state >>> update_traffic_lights([]) [] next_state = [] for light in lights: if light == \\"Green\\": next_state.append(\\"Yellow\\") elif light == \\"Yellow\\": next_state.append(\\"Red\\") elif light == \\"Red\\": next_state.append(\\"Green\\") else: raise ValueError(\\"Invalid traffic light state\\") return next_state","solution":"def update_traffic_lights(lights): Update the state of traffic lights based on the given rules. :param lights: List of strings representing the state of each traffic light. :return: List of strings representing the state of traffic lights after one state transition. next_state = [] for light in lights: if light == \\"Green\\": next_state.append(\\"Yellow\\") elif light == \\"Yellow\\": next_state.append(\\"Red\\") elif light == \\"Red\\": next_state.append(\\"Green\\") else: raise ValueError(\\"Invalid traffic light state\\") return next_state"},{"question":"def find_special_characters(s: str, k: int) -> List[str]: Returns a list of unique special characters appearing exactly \`k\` times in the string \`s\`, sorted in alphabetical order. Parameters: s (str): The input string with only lowercase alphabet characters. k (int): The specified number of appearances to be considered special. Returns: list: A list of unique special characters sorted in alphabetical order. >>> find_special_characters(\\"abcdef\\", 2) [] >>> find_special_characters(\\"abbccc\\", 2) ['b'] >>> find_special_characters(\\"aabbccddeeff\\", 2) ['a', 'b', 'c', 'd', 'e', 'f'] >>> find_special_characters(\\"aabbccdd\\", 1) [] >>> find_special_characters(\\"aabbccddaa\\", 4) ['a'] >>> find_special_characters(\\"\\", 1) [] >>> find_special_characters(\\"aabbcc\\", 2) ['a', 'b', 'c']","solution":"def find_special_characters(s, k): Returns a list of unique special characters appearing exactly \`k\` times in the string \`s\`, sorted in alphabetical order. Parameters: s (str): The input string with only lowercase alphabet characters. k (int): The specified number of appearances to be considered special. Returns: list: A list of unique special characters sorted in alphabetical order. from collections import Counter # Count occurrences of each character character_count = Counter(s) # Find characters appearing exactly k times special_characters = [char for char, count in character_count.items() if count == k] # Return the sorted list of unique special characters return sorted(special_characters)"},{"question":"def count_good_substrings(s: str) -> int: Return the number of distinct good substrings of s. A good substring has all distinct characters. >>> count_good_substrings(\\"abac\\") 5 >>> count_good_substrings(\\"aaaa\\") 1","solution":"def count_good_substrings(s): Returns the number of distinct good substrings of s. A good substring has all distinct characters. n = len(s) good_substrings = set() for i in range(n): seen = set() for j in range(i, n): if s[j] in seen: break seen.add(s[j]) good_substrings.add(s[i:j + 1]) return len(good_substrings)"},{"question":"def largest_product_of_three(nums: List[int]) -> int: Given a list of integers nums, returns the largest product that can be obtained from any three integers in the list. >>> largest_product_of_three([1, 2, 3]) 6 >>> largest_product_of_three([1, 2, 3, 4]) 24 >>> largest_product_of_three([-1, -2, -3, -4]) -6","solution":"def largest_product_of_three(nums): # Sorting the list in ascending order nums.sort() # Maximum of product of the three largest numbers # or product of the two smallest numbers and the largest number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"from typing import List def count_ongoing_events(startTimes: List[int], endTimes: List[int], queryTime: int) -> int: Returns the number of events that are ongoing at the given queryTime. :param startTimes: List of start times of the events. :param endTimes: List of end times of the events. :param queryTime: The time at which we are querying the number of ongoing events. :return: The count of ongoing events at queryTime. >>> count_ongoing_events([1, 2, 3], [4, 5, 6], 3) 3 >>> count_ongoing_events([1, 2, 3], [4, 5, 6], 7) 0 >>> count_ongoing_events([1, 2, 3], [4, 5, 6], 0) 0 >>> count_ongoing_events([1, 2, 3], [2, 4, 6], 2) 2 >>> count_ongoing_events([1, 2, 3], [2, 3, 4], 3) 2 >>> count_ongoing_events([1, 2, 3], [1, 2, 3], 2) 1 >>> count_ongoing_events([1, 2, 3], [2, 2, 3], 2) 2","solution":"def count_ongoing_events(startTimes, endTimes, queryTime): Returns the number of events that are ongoing at the given queryTime. :param startTimes: List of start times of the events. :param endTimes: List of end times of the events. :param queryTime: The time at which we are querying the number of ongoing events. :return: The count of ongoing events at queryTime. ongoing_count = 0 for start, end in zip(startTimes, endTimes): if start <= queryTime <= end: ongoing_count += 1 return ongoing_count"},{"question":"def longest_non_palindromic_substring_length(s: str) -> int: Given a string \`s\` consisting of lowercase letters, return the length of the longest non-palindromic substring that can be obtained after removing at most one substring of characters that are consecutive and form a palindrome. >>> longest_non_palindromic_substring_length(\\"aaaa\\") 3 >>> longest_non_palindromic_substring_length(\\"racecar\\") 6 >>> longest_non_palindromic_substring_length(\\"abcdefgh\\") 8 >>> longest_non_palindromic_substring_length(\\"aabbccdd\\") 8 >>> longest_non_palindromic_substring_length(\\"abcba\\") 4 >>> longest_non_palindromic_substring_length(\\"abcbaf\\") 6 >>> longest_non_palindromic_substring_length(\\"abccba\\") 5 >>> longest_non_palindromic_substring_length(\\"a\\") 0 >>> longest_non_palindromic_substring_length(\\"aa\\") 1 >>> longest_non_palindromic_substring_length(\\"ab\\") 2","solution":"def is_palindrome(s): return s == s[::-1] def longest_non_palindromic_substring_length(s): n = len(s) if not s or n == 1: return 0 if not is_palindrome(s): return n # Since s is a palindrome, the result is n - 1: return n - 1"},{"question":"from typing import List class AutocompleteSystem: def __init__(self, products: List[str], scores: List[int]): Initializes the system with an array of product names and their corresponding scores. pass def top3(self, prefix: str) -> List[str]: Returns the top 3 product names that start with the given prefix, sorted in descending order by their scores. If multiple products have the same score, the order is determined lexicographically. pass def test_system_initialization(): autocomplete = AutocompleteSystem([\\"apple\\", \\"app\\", \\"apricot\\"], [5, 3, 7]) assert autocomplete.products == [\\"apple\\", \\"app\\", \\"apricot\\"] assert autocomplete.scores == [5, 3, 7] def test_top3_single_match(): autocomplete = AutocompleteSystem([\\"apple\\", \\"app\\", \\"apricot\\"], [5, 3, 7]) assert autocomplete.top3(\\"apple\\") == [\\"apple\\"] def test_top3_multiple_matches(): autocomplete = AutocompleteSystem([\\"apple\\", \\"app\\", \\"apricot\\"], [5, 3, 7]) assert autocomplete.top3(\\"app\\") == [\\"apple\\", \\"app\\"] assert autocomplete.top3(\\"ap\\") == [\\"apricot\\", \\"apple\\", \\"app\\"] def test_top3_tie_scores(): autocomplete = AutocompleteSystem([\\"apple\\", \\"app\\"], [5, 5]) assert autocomplete.top3(\\"app\\") == [\\"app\\", \\"apple\\"] def test_top3_no_match(): autocomplete = AutocompleteSystem([\\"apple\\", \\"app\\", \\"apricot\\"], [5, 3, 7]) assert autocomplete.top3(\\"banana\\") == [] def test_top3_more_than_3_results(): autocomplete = AutocompleteSystem([\\"apple\\", \\"app\\", \\"apricot\\", \\"ape\\", \\"apex\\"], [5, 3, 7, 6, 4]) assert autocomplete.top3(\\"ap\\") == [\\"apricot\\", \\"ape\\", \\"apple\\"]","solution":"from typing import List class AutocompleteSystem: def __init__(self, products: List[str], scores: List[int]): Initializes the system with an array of product names and their corresponding scores. self.products = products self.scores = scores self.product_score_pairs = list(zip(products, scores)) def top3(self, prefix: str) -> List[str]: Returns the top 3 product names that start with the given prefix, sorted in descending order by their scores. If multiple products have the same score, the order is determined lexicographically. filtered = [ps for ps in self.product_score_pairs if ps[0].startswith(prefix)] sorted_filtered = sorted(filtered, key=lambda ps: (-ps[1], ps[0])) return [ps[0] for ps in sorted_filtered[:3]]"},{"question":"def rowWithMaximumOnes(matrix): Returns the index of the row that has the maximum number of 1s. If multiple rows have the same number of 1s, the smallest row index is returned. The time complexity of the algorithm is O(n + m). >>> matrix1 = [ ... [0, 0, 0, 1], ... [0, 1, 1, 1], ... [1, 1, 1, 1], ... [0, 0, 0, 0] ...] >>> rowWithMaximumOnes(matrix1) 2 >>> matrix2 = [ ... [0, 0], ... [0, 1], ... [1, 1] ...] >>> rowWithMaximumOnes(matrix2) 2 >>> matrix3 = [ ... [0, 0, 0], ... [0, 0, 1], ... [0, 1, 1], ... [1, 1, 1] ...] >>> rowWithMaximumOnes(matrix3) 3 >>> matrix4 = [ ... [0, 1], ... [1, 1], ... [0, 0] ...] >>> rowWithMaximumOnes(matrix4) 1 >>> matrix5 = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ...] >>> rowWithMaximumOnes(matrix5) 0 >>> matrix6 = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ...] >>> rowWithMaximumOnes(matrix6) -1 >>> matrix7 = [ ... [1] ...] >>> rowWithMaximumOnes(matrix7) 0 >>> matrix8 = [] >>> rowWithMaximumOnes(matrix8) -1","solution":"def rowWithMaximumOnes(matrix): Returns the index of the row that has the maximum number of 1s. If multiple rows have the same number of 1s, the smallest row index is returned. The time complexity of the algorithm is O(n + m). n = len(matrix) if n == 0: return -1 m = len(matrix[0]) # Variables to keep track of the maximum number of 1s and the corresponding row index maxOnesRowIndex = -1 maxOnesCount = 0 # Start from the top-right corner of the matrix row = 0 col = m - 1 while row < n and col >= 0: if matrix[row][col] == 1: # Move left maxOnesRowIndex = row maxOnesCount = m - col col -= 1 else: # Move down row += 1 return maxOnesRowIndex"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def list_to_binary_tree(nodes: List[Optional[int]]) -> Optional[TreeNode]: if not nodes: return None n = len(nodes) root = TreeNode(nodes[0]) queue = [(root, 0)] while queue: node, index = queue.pop(0) left_index, right_index = 2 * index + 1, 2 * index + 2 if left_index < n and nodes[left_index] is not None: node.left = TreeNode(nodes[left_index]) queue.append((node.left, left_index)) if right_index < n and nodes[right_index] is not None: node.right = TreeNode(nodes[right_index]) queue.append((node.right, right_index)) return root def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Perform level-order traversal of binary tree. >>> level_order_traversal(list_to_binary_tree([3, 9, 20, None, None, 15, 7])) [[3], [9, 20], [15, 7]] >>> level_order_traversal(list_to_binary_tree([1, 2, 3, 4, 5, 6, 7])) [[1], [2, 3], [4, 5, 6, 7]] >>> level_order_traversal(list_to_binary_tree([1])) [[1]] >>> level_order_traversal(list_to_binary_tree([1, None, 2, None, None, None, 3])) [[1], [2], [3]] >>> level_order_traversal(list_to_binary_tree([1, 2, None, 3, 4, None, None, 5, 6])) [[1], [2], [3, 4], [5, 6]] pass def get_level_order(nodes: List[Optional[int]]) -> List[List[int]]: Return the level-order traversal of the binary tree as a list of lists. >>> get_level_order([3, 9, 20, None, None, 15, 7]) [[3], [9, 20], [15, 7]] >>> get_level_order([1, 2, 3, 4, 5, 6, 7]) [[1], [2, 3], [4, 5, 6, 7]] >>> get_level_order([1]) [[1]] >>> get_level_order([1, None, 2, None, None, None, 3]) [[1], [2], [3]] >>> get_level_order([1, 2, None, 3, 4, None, None, 5, 6]) [[1], [2], [3, 4], [5, 6]] pass","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def list_to_binary_tree(nodes: List[Optional[int]]) -> Optional[TreeNode]: if not nodes: return None n = len(nodes) root = TreeNode(nodes[0]) queue = [(root, 0)] while queue: node, index = queue.pop(0) left_index, right_index = 2 * index + 1, 2 * index + 2 if left_index < n and nodes[left_index] is not None: node.left = TreeNode(nodes[left_index]) queue.append((node.left, left_index)) if right_index < n and nodes[right_index] is not None: node.right = TreeNode(nodes[right_index]) queue.append((node.right, right_index)) return root def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] level_order, queue = [], [root] while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.pop(0) current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) level_order.append(current_level) return level_order def get_level_order(nodes: List[Optional[int]]) -> List[List[int]]: root = list_to_binary_tree(nodes) return level_order_traversal(root)"},{"question":"class UserActivityLog: def __init__(self): Initializes the log with an empty list of user actions. self.log = [] def record(self, timestamp: int, action: str): Records an action taken by a user at a specific timestamp. :param timestamp: int, the timestamp at which the action was taken :param action: str, the action taken by the user pass def getActions(self, startTime: int, endTime: int): Returns a list of actions that were recorded between startTime and endTime (inclusive). :param startTime: int, the start time of the interval :param endTime: int, the end time of the interval :return: List of actions (str) recorded between startTime and endTime Example: >>> log = UserActivityLog() >>> log.record(1, \\"login\\") >>> log.record(2, \\"view\\") >>> log.record(5, \\"logout\\") >>> log.getActions(1, 5) [\\"login\\", \\"view\\", \\"logout\\"] pass","solution":"class UserActivityLog: def __init__(self): self.log = [] def record(self, timestamp, action): Records an action taken by a user at a specific timestamp. :param timestamp: int, the timestamp at which the action was taken :param action: str, the action taken by the user self.log.append((timestamp, action)) def getActions(self, startTime, endTime): Returns a list of actions that were recorded between startTime and endTime (inclusive). :param startTime: int, the start time of the interval :param endTime: int, the end time of the interval :return: List of actions (str) recorded between startTime and endTime return [action for (timestamp, action) in self.log if startTime <= timestamp <= endTime]"},{"question":"def is_subsequence(s: str, p: str) -> bool: Determines if the pattern p exists as a subsequence within the string s. Args: s (str): The string to be searched. p (str): The pattern to be found as a subsequence. Returns: bool: True if p is a subsequence of s, False otherwise. Examples: >>> is_subsequence('abcdefgh', 'ace') True >>> is_subsequence('abcdefgh', 'aec') False >>> is_subsequence('abcdefgh', '') True >>> is_subsequence('', 'a') False >>> is_subsequence('', '') True >>> is_subsequence('ab', 'abc') False >>> is_subsequence('abcd', 'abcd') True >>> is_subsequence('aaabbbccc', 'abc') True >>> is_subsequence('abcabcabc', 'aaabbb') False","solution":"def is_subsequence(s, p): Determines if the pattern p exists as a subsequence within the string s. Args: s (str): The string to be searched. p (str): The pattern to be found as a subsequence. Returns: bool: True if p is a subsequence of s, False otherwise. iter_s = iter(s) return all(char in iter_s for char in p)"},{"question":"def longest_subsequence_length(s: str) -> int: Return the length of the longest subsequence that contains all three characters 'a', 'b', and 'c' in that order. >>> longest_subsequence_length(\\"abcaabbbcabc\\") == 3 >>> longest_subsequence_length(\\"aaa\\") == 0 >>> longest_subsequence_length(\\"bbb\\") == 0 >>> longest_subsequence_length(\\"ccc\\") == 0 >>> longest_subsequence_length(\\"abc\\") == 1 >>> longest_subsequence_length(\\"aabbcc\\") == 2 >>> longest_subsequence_length(\\"abaccaabbcc\\") == 3 >>> longest_subsequence_length(\\"aaabbbccc\\") == 3 >>> longest_subsequence_length(\\"\\") == 0 >>> longest_subsequence_length(\\"a\\") == 0 >>> longest_subsequence_length(\\"b\\") == 0 >>> longest_subsequence_length(\\"c\\") == 0 >>> longest_subsequence_length(\\"acb\\") == 0 >>> longest_subsequence_length(\\"bac\\") == 0 >>> longest_subsequence_length(\\"bca\\") == 0 pass","solution":"def longest_subsequence_length(s): Returns the length of the longest subsequence that contains all three characters 'a', 'b', and 'c' in that order. a_count, b_count, c_count = 0, 0, 0 for char in s: if char == 'a': a_count += 1 elif char == 'b': b_count = min(a_count, b_count + 1) elif char == 'c': c_count = min(b_count, c_count + 1) return c_count"},{"question":"def maximize_sum(arr: List[int], k: int) -> int: Maximizes the sum of the array after performing k operations. In each operation, one array element can be increased by 1. Args: arr (list): List of integers. k (int): Number of operations. Returns: int: The maximum possible sum of the array after k operations. >>> maximize_sum([1, 2, 3], 3) sum([1, 2, 3]) + 3 >>> maximize_sum([0, 0, 0], 5) sum([0, 0, 0]) + 5 >>> maximize_sum([-1, -2, -3], 6) sum([-1, -2, -3]) + 6 >>> maximize_sum([4, 6, 2], 0) sum([4, 6, 2]) >>> maximize_sum([3, 3, 3], 1) sum([3, 3, 3]) + 1","solution":"def maximize_sum(arr, k): Maximizes the sum of the array after performing k operations. In each operation, one array element can be increased by 1. Args: arr (list): List of integers. k (int): Number of operations. Returns: int: The maximum possible sum of the array after k operations. sum_arr = sum(arr) return sum_arr + k"},{"question":"def trap(height: List[int]) -> int: Calculate the maximum amount of water that can be trapped after raining. Parameters: height (List[int]): List of non-negative integers representing the height of bars. Returns: int: Maximum amount of water that can be trapped. >>> trap([]) == 0 >>> trap([0, 1, 2, 3, 4]) == 0 >>> trap([4, 3, 2, 1, 0]) == 0 >>> trap([4]) == 0 >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap([2, 2, 2, 2]) == 0 >>> trap([3, 0, 2, 0, 4]) == 7","solution":"def trap(height): Calculate the maximum amount of water that can be trapped after raining. Parameters: height (List[int]): List of non-negative integers representing the height of bars. Returns: int: Maximum amount of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += max(0, min(left_max[i], right_max[i]) - height[i]) return water_trapped"},{"question":"def restore_ip_addresses(s: str) -> List[str]: Return all possible valid IP address combinations that can be formed by inserting dots into the string \`s\`. >>> restore_ip_addresses(\\"25525511135\\") ['255.255.11.135', '255.255.111.35'] >>> restore_ip_addresses(\\"0000\\") ['0.0.0.0'] >>> restore_ip_addresses(\\"101023\\") ['1.0.10.23', '1.0.102.3', '10.1.0.23', '10.10.2.3', '101.0.2.3'] >>> restore_ip_addresses(\\"1111\\") ['1.1.1.1'] >>> restore_ip_addresses(\\"55555555\\") ['55.55.55.55'] >>> restore_ip_addresses(\\"25550111135\\") ['255.50.111.135'] >>> restore_ip_addresses(\\"256256256256\\") [] >>> restore_ip_addresses(\\"10203040\\") ['10.20.30.40', '102.0.30.40', '10.203.0.40'] >>> restore_ip_addresses(\\"123\\") [] >>> restore_ip_addresses(\\"123456789012\\") [] >>> restore_ip_addresses(\\"010010\\") ['0.10.0.10', '0.100.1.0']","solution":"def restore_ip_addresses(s): Return all possible valid IP address combinations that can be formed by inserting dots into the string \`s\`. def is_valid(segment): # '0' is valid but '00' or '01' is not. return int(segment) <= 255 and (segment == \\"0\\" or segment[0] != \\"0\\") def backtrack(start=0, path=[]): # If we have 4 segments and we're at the end of the string, add to results. if start == len(s) and len(path) == 4: results.append(\\".\\".join(path)) return # If we have 4 segments but haven't used up the whole string, return. if len(path) == 4: return # Try all possible splits of the string. for end in range(start + 1, min(start + 4, len(s) + 1)): segment = s[start:end] if is_valid(segment): backtrack(end, path + [segment]) results = [] backtrack() return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(inorder, postorder): Constructs a binary tree from inorder and postorder traversal. :param inorder: List[int], the inorder traversal of the tree :param postorder: List[int], the postorder traversal of the tree :return: TreeNode, the root of the constructed binary tree def are_trees_equal(tree1, tree2): Helper function to check if two binary trees are equal. if not tree1 and not tree2: return True if tree1 and tree2: return (tree1.val == tree2.val and are_trees_equal(tree1.left, tree2.left) and are_trees_equal(tree1.right, tree2.right)) return False def test_build_tree_empty(): assert buildTree([], []) is None def test_build_tree_single_node(): inorder = [1] postorder = [1] expected = TreeNode(1) result = buildTree(inorder, postorder) assert are_trees_equal(expected, result) def test_build_tree_multiple_nodes(): inorder = [9, 3, 15, 20, 7] postorder = [9, 15, 7, 20, 3] expected = TreeNode(3) expected.left = TreeNode(9) expected.right = TreeNode(20) expected.right.left = TreeNode(15) expected.right.right = TreeNode(7) result = buildTree(inorder, postorder) assert are_trees_equal(expected, result) def test_build_tree_left_skewed(): inorder = [1, 2, 3, 4, 5] postorder = [1, 2, 3, 4, 5] expected = TreeNode(5) expected.left = TreeNode(4) expected.left.left = TreeNode(3) expected.left.left.left = TreeNode(2) expected.left.left.left.left = TreeNode(1) result = buildTree(inorder, postorder) assert are_trees_equal(expected, result) def test_build_tree_right_skewed(): inorder = [1, 2, 3, 4, 5] postorder = [5, 4, 3, 2, 1] expected = TreeNode(1) expected.right = TreeNode(2) expected.right.right = TreeNode(3) expected.right.right.right = TreeNode(4) expected.right.right.right.right = TreeNode(5) result = buildTree(inorder, postorder) assert are_trees_equal(expected, result)","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(inorder, postorder): Constructs a binary tree from inorder and postorder traversal. :param inorder: List[int], the inorder traversal of the tree :param postorder: List[int], the postorder traversal of the tree :return: TreeNode, the root of the constructed binary tree if not inorder or not postorder: return None # The last element of postorder is the root root_val = postorder.pop() root = TreeNode(root_val) # Find the index of the root in inorder traversal inorder_index = inorder.index(root_val) # Build right and left subtrees root.right = buildTree(inorder[inorder_index+1:], postorder) root.left = buildTree(inorder[:inorder_index], postorder) return root"},{"question":"def num_decodings(s: str) -> int: Calculate the number of ways to decode a string containing only digits to letters. >>> num_decodings('1') == 1 >>> num_decodings('9') == 1 >>> num_decodings('0') == 0 >>> num_decodings('10') == 1 >>> num_decodings('12') == 2 >>> num_decodings('27') == 1 >>> num_decodings('226') == 3 >>> num_decodings('1234') == 3 >>> num_decodings('111111') == 13 >>> num_decodings('') == 0 >>> num_decodings('012') == 0 >>> num_decodings('100') == 0 >>> num_decodings('301') == 0 >>> num_decodings('110') == 1","solution":"def num_decodings(s): Calculate the number of ways to decode a string containing only digits to letters. if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) # Base case initialization dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): one_digit = int(s[i-1:i]) two_digits = int(s[i-2:i]) # Check if single digit decode is possible if 1 <= one_digit <= 9: dp[i] += dp[i-1] # Check if two digits decode is possible if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"def count_characters(words: List[str], characters: str) -> int: Returns the maximum sum of lengths of all words that can be formed using characters from \`characters\`. Each character in \`characters\` can only be used once per word formation. >>> count_characters([\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"], \\"atach\\") 6 >>> count_characters([\\"hello\\", \\"world\\", \\"leetcode\\"], \\"welldonehoneyr\\") 10 >>> count_characters([\\"apple\\", \\"plea\\", \\"banana\\"], \\"appleabn\\") 9 >>> count_characters([], \\"abc\\") 0 >>> count_characters([\\"a\\", \\"b\\", \\"c\\"], \\"\\") 0 >>> count_characters([\\"a\\", \\"b\\", \\"c\\"], \\"abc\\") 3","solution":"def count_characters(words, characters): Returns the maximum sum of lengths of all words that can be formed using characters from \`characters\`. Each character in \`characters\` can only be used once per word formation. from collections import Counter def can_form(word, char_count): Check if the word can be formed using the characters in char_count. word_count = Counter(word) for char, count in word_count.items(): if char not in char_count or word_count[char] > char_count[char]: return False return True char_count = Counter(characters) total_length = 0 for word in words: if can_form(word, char_count): total_length += len(word) return total_length"},{"question":"def count_paths(grid: List[List[int]]) -> int: Returns the number of distinct paths from the top-left to bottom-right of the grid where each move is to a cell with equal or greater value. >>> count_paths([[1, 2], [3, 4]]) == 2 >>> count_paths([[1, 2, 3], [6, 5, 4]]) == 1 >>> count_paths([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 6 >>> count_paths([[3, 2, 1], [6, 5, 4]]) == 0 >>> count_paths([[1]]) == 1 >>> count_paths([[1, 3, 2], [3, 3, 4], [2, 1, 3]]) == 0","solution":"def count_paths(grid): Returns the number of distinct paths from the top-left to bottom-right of the grid where each move is to a cell with equal or greater value. from collections import defaultdict, deque n, m = len(grid), len(grid[0]) # Stores number of ways to reach each cell paths = [[0] * m for _ in range(n)] paths[0][0] = 1 # Starting point directions = [(0, 1), (1, 0)] # Right and Down moves cells = [(grid[row][col], row, col) for row in range(n) for col in range(m)] cells.sort() for value, r, c in cells: for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] >= grid[r][c]: paths[nr][nc] += paths[r][c] return paths[n-1][m-1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_max_heap(nums): Constructs a max-heap based binary tree from a list of non-negative integers. Args: nums (list of int): List of non-negative integers. Returns: TreeNode: The root of the max-heap tree. def get_tree_values(root): Helper function to get the list representation of the tree for simpler validation if not root: return [] result = [] queue = [root] while queue: node = queue.pop(0) result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result def test_single_element(): root = build_max_heap([10]) assert get_tree_values(root) == [10] def test_two_elements(): root = build_max_heap([1, 10]) assert get_tree_values(root) == [10, 1] def test_three_elements(): root = build_max_heap([3, 1, 2]) assert get_tree_values(root) == [3, 1, 2] def test_multiple_elements(): root = build_max_heap([4, 7, 8, 3, 2, 6, 5]) assert get_tree_values(root) == [8, 7, 6, 3, 2, 4, 5] def test_presorted_elements(): root = build_max_heap([1, 2, 3, 4, 5, 6, 7]) assert get_tree_values(root) == [7, 5, 6, 4, 2, 1, 3]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_max_heap(nums): Constructs a max-heap based binary tree from a list of non-negative integers. Args: nums (list of int): List of non-negative integers. Returns: TreeNode: The root of the max-heap tree. def heapify(nums, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and nums[i] < nums[left]: largest = left if right < n and nums[largest] < nums[right]: largest = right if largest != i: nums[i], nums[largest] = nums[largest], nums[i] heapify(nums, n, largest) n = len(nums) for i in range(n // 2 - 1, -1, -1): heapify(nums, n, i) nodes = [TreeNode(val=num) for num in nums] for i in range(n): if 2 * i + 1 < n: nodes[i].left = nodes[2 * i + 1] if 2 * i + 2 < n: nodes[i].right = nodes[2 * i + 2] return nodes[0]"},{"question":"def contains_nearby_duplicate(arr: List[int], k: int) -> bool: Given an integer array \`arr\` of size \`n\`, check if there are two distinct indices \`i\` and \`j\` in the array such that \`arr[i] == arr[j]\` and the absolute difference between \`i\` and \`j\` is at most \`k\`. >>> contains_nearby_duplicate([1, 2, 3, 4, 5], 3) == False >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) == False >>> contains_nearby_duplicate([1, 2, 3, 4, 1], 4) == True >>> contains_nearby_duplicate([], 3) == False >>> contains_nearby_duplicate([1, 2, 3, 4], 0) == False >>> contains_nearby_duplicate([1], 1) == False >>> contains_nearby_duplicate([1, 2, 3, 1], 10) == True >>> contains_nearby_duplicate([1, 1, 1, 1], 1) == True","solution":"def contains_nearby_duplicate(arr, k): Checks if there are any duplicates within k distance. if not arr or k <= 0: return False index_map = {} for i, value in enumerate(arr): if value in index_map and i - index_map[value] <= k: return True index_map[value] = i return False"},{"question":"def binary_search(nums: List[int], target: int) -> bool: Determine if the target exists in the sorted array nums using binary search. Returns True if found, else False. >>> binary_search([1, 2, 3, 4, 5], 3) == True >>> binary_search([10, 20, 30, 40, 50], 10) == True >>> binary_search([10, 20, 30, 40, 50], 50) == True >>> binary_search([1, 2, 3, 4, 5], 6) == False >>> binary_search([10, 20, 30, 40, 50], 25) == False >>> binary_search([10, 20, 30, 40, 50], 0) == False >>> binary_search([], 3) == False >>> binary_search([5], 5) == True >>> binary_search([5], 3) == False >>> binary_search([1, 2, 2, 2, 3], 2) == True >>> binary_search([1, 2, 2, 2, 3], 4) == False","solution":"def binary_search(nums, target): Determine if the target exists in the sorted array nums using binary search. Returns True if found, else False. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return True elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return False"},{"question":"def min_operations_to_equalize(matrix): Returns the minimum number of operations required to make all the elements of the matrix equal. >>> min_operations_to_equalize([[1, 1], [1, 1]]) 0 >>> min_operations_to_equalize([[5, 5, 5], [5, 5, 5], [5, 5, 5]]) 0 >>> min_operations_to_equalize([[1, 2], [2, 1]]) 1 >>> min_operations_to_equalize([[3, 1, 4], [1, 1, 1], [1, 1, 1]]) 3 >>> min_operations_to_equalize([[10, 12, 11, 13], [11, 14, 11, 10], [12, 15, 12, 12], [13, 15, 12, 10]]) 5","solution":"def min_operations_to_equalize(matrix): Returns the minimum number of operations required to make all the elements of the matrix equal. max_val = max(map(max, matrix)) min_val = min(map(min, matrix)) if max_val == min_val: return 0 return (max_val - min_val)"},{"question":"def island_perimeter(grid: List[List[int]]) -> int: Given a rectangular m x n binary grid that represents a map of an island, return the perimeter of the island. The grid consists of 0s (representing water) and 1s (representing land). Each cell is square with a side length of 1. The island is connected 4-directionally (horizontal or vertical). >>> island_perimeter([[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]) 16 >>> island_perimeter([[1]]) 4 >>> island_perimeter([[1,0]]) 4 >>> island_perimeter([[1,1],[1,1]]) 8 >>> island_perimeter([[1,0,1,0,1]]) 12 >>> island_perimeter([[1], [0], [1], [0], [1]]) 12","solution":"def island_perimeter(grid): Given a rectangular m x n binary grid that represents a map of an island, return the perimeter of the island. The grid consists of 0s (representing water) and 1s (representing land). Each cell is square with a side length of 1. The island is connected 4-directionally (horizontal or vertical). rows = len(grid) cols = len(grid[0]) perimeter = 0 def is_water_or_outside(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0: return True return False for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Check all 4 directions for water or grid boundary if is_water_or_outside(r-1, c): # up perimeter += 1 if is_water_or_outside(r+1, c): # down perimeter += 1 if is_water_or_outside(r, c-1): # left perimeter += 1 if is_water_or_outside(r, c+1): # right perimeter += 1 return perimeter"},{"question":"from typing import List def maxConsecutiveMountains(heights: List[int], threshold: int) -> int: Returns the length of the longest consecutive subarray where the difference between the highest and lowest mountain is no more than the given threshold. >>> maxConsecutiveMountains([1, 2, 3, 4, 5], 3) 4 >>> maxConsecutiveMountains([1, 10, 3, 4, 5], 5) 3 >>> maxConsecutiveMountains([8, 2, 4, 7], 4) 2 >>> maxConsecutiveMountains([], 3) 0 >>> maxConsecutiveMountains([5], 0) 1 >>> maxConsecutiveMountains([1, 2, 3, 4, 5], 0) 1 >>> maxConsecutiveMountains([1, 2, 3, 4], 3) 4 >>> maxConsecutiveMountains([4, 2, 2, 2, 4], 2) 5 >>> maxConsecutiveMountains([10, 10, 10, 10], 0) 4 >>> maxConsecutiveMountains([1, 2, 1, 2, 1], 0) 1 >>> maxConsecutiveMountains([3, 3, 3, 3], 1) 4 >>> maxConsecutiveMountains([1, 2, 3, 4, 5], 10) 5 >>> maxConsecutiveMountains([6, 9, 3, 8, 2], 6) 4","solution":"from typing import List def maxConsecutiveMountains(heights: List[int], threshold: int) -> int: Returns the length of the longest consecutive subarray where the difference between the highest and lowest mountain is no more than the given threshold. n = len(heights) if n == 0: return 0 max_length = 0 start = 0 for end in range(n): current_window = heights[start:end + 1] min_height = min(current_window) max_height = max(current_window) while max_height - min_height > threshold: start += 1 current_window = heights[start:end + 1] min_height = min(current_window) max_height = max(current_window) max_length = max(max_length, end - start + 1) return max_length"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_node_depth_product(root): Given a binary tree represented by the root node, where each node in the tree contains an integer value and a pointer to its left and right child nodes, returns the total sum of all node values in the tree multiplied by the depth of their respective nodes. The depth of each node is defined as the number of edges from the root to the node. >>> root = TreeNode(10) >>> sum_node_depth_product(root) 10 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> sum_node_depth_product(root) 12","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_node_depth_product(root): Returns the total sum of all node values in the binary tree multiplied by the depth of their respective nodes. def dfs(node, depth): if not node: return 0 return depth * node.val + dfs(node.left, depth + 1) + dfs(node.right, depth + 1) return dfs(root, 1)"},{"question":"def highest_call_count(functionCalls: List[int]) -> int: Returns the id of the function with the highest call count. If there are multiple functions with the same highest count, return the one with the smallest id. >>> highest_call_count([1, 3, 7, 4]) == 2 >>> highest_call_count([5, 7, 7, 2]) == 1 >>> highest_call_count([2, 2, 2, 2]) == 0","solution":"def highest_call_count(functionCalls): Returns the id of the function with the highest call count. If there are multiple functions with the same highest count, return the one with the smallest id. :param functionCalls: List[int] - a list where each element represents the number of times a specific function is called :return: int - the id of the function with the highest call count max_calls = max(functionCalls) # Find the maximum call count for i, calls in enumerate(functionCalls): if calls == max_calls: return i # Return the index of the first occurrence of the maximum call count"},{"question":"def min_repair_cost(parent: List[int], costs: List[int]) -> int: Find the minimum total repair cost to restore the network with the given conditions. >>> min_repair_cost([-1, 0, 0, 1, 1, 2, 2], [1, 2, 2, 3, 3, 4, 4]) 19 >>> min_repair_cost([-1], [5]) 5 >>> min_repair_cost([-1, 0], [5, 10]) 15 >>> min_repair_cost([-1, 0, 0, 1, 1], [5, 4, 3, 2, 1]) 15 >>> min_repair_cost([-1, 0, 0, 1, 2], [0, 0, 0, 0, 0]) 0","solution":"def min_repair_cost(parent, costs): def dfs(node): total_cost = costs[node] for child in tree[node]: total_cost += dfs(child) return total_cost n = len(parent) tree = [[] for _ in range(n)] root = -1 for i in range(n): if parent[i] == -1: root = i else: tree[parent[i]].append(i) return dfs(root)"},{"question":"def num_identical_pairs(arr): Returns the number of good pairs in the array such that arr[i] == arr[j] and i < j. Parameters: arr (list): List of integers Returns: int: Number of good pairs >>> num_identical_pairs([1, 2, 3, 4]) == 0 >>> num_identical_pairs([1, 1, 2, 3]) == 1 >>> num_identical_pairs([1, 1, 1, 1]) == 6 >>> num_identical_pairs([1, 2, 3, 1, 1, 3]) == 4 >>> num_identical_pairs([3, 3, 3, 2, 2, 1]) == 4 >>> num_identical_pairs([1]) == 0 >>> num_identical_pairs([]) == 0","solution":"def num_identical_pairs(arr): Returns the number of good pairs in the array such that arr[i] == arr[j] and i < j. Parameters: arr (list): List of integers Returns: int: Number of good pairs from collections import Counter count = Counter(arr) good_pairs = 0 for val in count.values(): if val > 1: good_pairs += (val * (val - 1)) // 2 return good_pairs"},{"question":"def smallest_subarray_with_sum_at_least_x(nums: List[int], x: int) -> int: Find the smallest length of a subarray that has a sum greater than or equal to x. >>> smallest_subarray_with_sum_at_least_x([2, 3, 1, 2, 4, 3], 7) 2 >>> smallest_subarray_with_sum_at_least_x([1, 1, 1, 1, 1, 1, 1, 1], 11) -1 >>> smallest_subarray_with_sum_at_least_x([1, 4, 4], 8) 2 >>> smallest_subarray_with_sum_at_least_x([1, 2, 3, 4, 5], 11) 3 >>> smallest_subarray_with_sum_at_least_x([1, 2, 3, 4, 5], 5) 1","solution":"def smallest_subarray_with_sum_at_least_x(nums, x): n = len(nums) min_length = float('inf') curr_sum = 0 start = 0 for end in range(n): curr_sum += nums[end] while curr_sum >= x: min_length = min(min_length, end - start + 1) curr_sum -= nums[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def count_visible_buildings(heights): Counts the number of buildings visible when looking from the left. Parameters: heights (list): List of integers representing heights of buildings. Returns: int: Count of visible buildings. >>> count_visible_buildings([]) 0 >>> count_visible_buildings([5]) 1 >>> count_visible_buildings([1, 2, 3, 4, 5]) 5 >>> count_visible_buildings([5, 4, 3, 2, 1]) 1 >>> count_visible_buildings([3, 1, 4, 1, 5]) 3 >>> count_visible_buildings([4, 4, 4, 4, 4]) 1 >>> count_visible_buildings([2, 4, 2, 4, 2]) 2","solution":"def count_visible_buildings(heights): Counts the number of buildings visible when looking from the left. Parameters: heights (list): List of integers representing heights of buildings. Returns: int: Count of visible buildings. if not heights: return 0 max_height = heights[0] visible_count = 1 for height in heights[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"def min_bit_flips(s: str, t: str) -> int: Given two binary strings s and t of the same length, returns the minimum number of bit flips required to make s equal to t. >>> min_bit_flips(\\"1100\\", \\"1100\\") == 0 >>> min_bit_flips(\\"0000\\", \\"1111\\") == 4 >>> min_bit_flips(\\"1010\\", \\"0101\\") == 4 >>> min_bit_flips(\\"1100\\", \\"1111\\") == 2 >>> min_bit_flips(\\"1111\\", \\"1111\\") == 0 # write your code here","solution":"def min_bit_flips(s, t): Given two binary strings s and t of the same length, returns the minimum number of bit flips required to make s equal to t. if len(s) != len(t): raise ValueError(\\"Strings must be of the same length\\") bit_flips = 0 for bit_s, bit_t in zip(s, t): if bit_s != bit_t: bit_flips += 1 return bit_flips"},{"question":"def min_operations_to_palindrome(s: str, k: int) -> int: Returns the minimum number of operations required to make the string a palindrome. If it is not possible within k operations, returns -1. Parameters: s (str): input string k (int): maximum number of allowed operations Returns: int: minimum number of operations to make the string a palindrome or -1 if not possible >>> min_operations_to_palindrome(\\"abca\\", 1) == 1 >>> min_operations_to_palindrome(\\"racecar\\", 0) == 0 >>> min_operations_to_palindrome(\\"abcdefg\\", 3) == 3 >>> min_operations_to_palindrome(\\"abcdefg\\", 2) == -1 >>> min_operations_to_palindrome(\\"a\\", 1) == 0 >>> min_operations_to_palindrome(\\"\\", 0) == 0","solution":"def min_operations_to_palindrome(s, k): Returns the minimum number of operations required to make the string a palindrome. If it is not possible within k operations, returns -1. Parameters: s (str): input string k (int): maximum number of allowed operations Returns: int: minimum number of operations to make the string a palindrome or -1 if not possible n = len(s) # Find initial number of mismatch pairs mismatch_count = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: mismatch_count += 1 # If the required number of changes to make a palindrome is more than k, return -1 if mismatch_count > k: return -1 return mismatch_count"},{"question":"from collections import Counter def min_removals_to_make_anagram(s: str, t: str) -> int: Returns the minimum number of characters to remove from \`s\` to make it an anagram of \`t\`. If it is impossible to form such a string, return \\"-1\\". >>> min_removals_to_make_anagram(\\"abcbca\\", \\"abc\\") == 3 >>> min_removals_to_make_anagram(\\"aabbcc\\", \\"aabbcc\\") == 0 >>> min_removals_to_make_anagram(\\"abcd\\", \\"efg\\") == \\"-1\\" >>> min_removals_to_make_anagram(\\"aaabbbccc\\", \\"abc\\") == 6 >>> min_removals_to_make_anagram(\\"abc\\", \\"\\") == 3 >>> min_removals_to_make_anagram(\\"aabbcc\\", \\"abcdef\\") == \\"-1\\" >>> min_removals_to_make_anagram(\\"abc\\", \\"abcd\\") == \\"-1\\"","solution":"from collections import Counter def min_removals_to_make_anagram(s, t): Returns the minimum number of characters to remove from \`s\` to make it an anagram of \`t\`. If it is impossible to form such a string, return \\"-1\\". count_s = Counter(s) count_t = Counter(t) # If there are any characters in t not in s, it's impossible to form an anagram of t from s for char in count_t: if count_t[char] > count_s[char]: return \\"-1\\" # Calculate the minimum number of deletions required removals = 0 for char in count_s: if count_s[char] > count_t[char]: removals += count_s[char] - count_t[char] return removals"},{"question":"def max_sum_submatrix(matrix): Find the submatrix with the largest sum within a given matrix. The submatrix must contain at least one element. >>> max_sum_submatrix([[1, 2], [3, 4]]) 10 >>> max_sum_submatrix([[1, -2], [-3, 4]]) 4 >>> max_sum_submatrix([[-1, -2], [-3, -4]]) -1 >>> max_sum_submatrix([[1, 2], [-1, 2], [1, -1]]) 4 >>> max_sum_submatrix([[1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6]]) 29","solution":"def max_sum_submatrix(matrix): def max_sum_subarray(arr): max_sum = arr[0] current_sum = arr[0] for x in arr[1:]: current_sum = max(x, current_sum + x) max_sum = max(max_sum, current_sum) return max_sum if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) max_sum = float('-inf') for left in range(cols): temp = [0] * rows for right in range(left, cols): for i in range(rows): temp[i] += matrix[i][right] max_sum = max(max_sum, max_sum_subarray(temp)) return max_sum"},{"question":"def max_area(nums: List[int]) -> int: Returns the maximum amount of water that can be contained between two lines. >>> max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_area([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 25 >>> max_area([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 25 >>> max_area([4, 4, 4, 4, 4]) 16 >>> max_area([1, 1]) 1 >>> nums = [i for i in range(1000, 0, -1)] >>> max_area(nums) 250000","solution":"def max_area(nums): Returns the maximum amount of water that can be contained between two lines. max_water = 0 left, right = 0, len(nums) - 1 while left < right: # Calculate the area with the current pair of lines height = min(nums[left], nums[right]) width = right - left current_area = height * width max_water = max(max_water, current_area) # Move the pointers if nums[left] < nums[right]: left += 1 else: right -= 1 return max_water"},{"question":"def can_win_nim(nums): Return True if the starting player can guarantee a win, otherwise return False. Assumes both players play optimally. >>> can_win_nim([1]) == True >>> can_win_nim([1, 2]) == True >>> can_win_nim([4]) == False >>> can_win_nim([1, 3]) == False >>> can_win_nim([1, 2, 3, 4, 5]) == True >>> can_win_nim([4, 4, 4, 4]) == False >>> can_win_nim([2, 2, 2, 2, 2]) == True pass","solution":"def can_win_nim(nums): Returns True if the starting player can guarantee a win, otherwise False. Assumes both players play optimally. # If the total number of stones is not a multiple of 4, you will always win # Otherwise, you will always lose if your opponent plays optimally. total_stones = sum(nums) return total_stones % 4 != 0"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSumLeafToLeaf(root): Returns the maximum sum of any path from one leaf node to another leaf node. # Test case 1: Basic binary tree with multiple paths def test_maxPathSumLeafToLeaf_basic(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert maxPathSumLeafToLeaf(root) == 18 # Path is 4 -> 2 -> 1 -> 3 -> 7 # Test case 2: Tree with only left side nodes def test_maxPathSumLeafToLeaf_left_side(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) assert maxPathSumLeafToLeaf(root) == 0 # No path between two leaf nodes # Test case 3: Tree with only right side nodes def test_maxPathSumLeafToLeaf_right_side(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) assert maxPathSumLeafToLeaf(root) == 0 # No path between two leaf nodes # Test case 4: Tree with no nodes def test_maxPathSumLeafToLeaf_empty(): root = None assert maxPathSumLeafToLeaf(root) == 0 # Test case 5: Tree with multiple negative values def test_maxPathSumLeafToLeaf_negative_values(): root = TreeNode(-10) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) assert maxPathSumLeafToLeaf(root) == 42 # Path is 15 -> 20 -> 7 # Test case 6: Complex tree def test_maxPathSumLeafToLeaf_complex(): root = TreeNode(1) root.left = TreeNode(-2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(-6) root.right.right = TreeNode(2) assert maxPathSumLeafToLeaf(root) == 9 # Path is 4 -> -2 -> 1 -> 3 -> 2","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSumLeafToLeaf(root): Returns the maximum sum of any path from one leaf node to another leaf node. def dfs(node): nonlocal max_sum if not node: return 0 if not node.left and not node.right: return node.val left_sum = dfs(node.left) if node.left else float('-inf') right_sum = dfs(node.right) if node.right else float('-inf') if node.left and node.right: max_sum = max(max_sum, left_sum + right_sum + node.val) return max(left_sum, right_sum) + node.val return left_sum + node.val if node.left else right_sum + node.val if not root: return 0 max_sum = float('-inf') result = dfs(root) return max_sum if max_sum != float('-inf') else 0"},{"question":"def construct_sums(arr, k): Constructs a new array where each element at index i is the sum of the elements at indices i to i + k - 1 in the original array. If there are fewer than k elements remaining, sum all the elements from i to the end of the array. Parameters: arr (list of int): The original array of integers k (int): The number of elements to sum Returns: list of int: The resultant array containing the sums >>> construct_sums([1, 2, 3, 4, 5], 3) [6, 9, 12, 9, 5] >>> construct_sums([1, 2, 3], 3) [6, 5, 3] >>> construct_sums([1, 2], 3) [3, 2] >>> construct_sums([0, 0, 0, 0], 2) [0, 0, 0, 0] >>> construct_sums([5], 1) [5] >>> construct_sums([], 3) [] >>> construct_sums([-1, -2, -3, -4], 2) [-3, -5, -7, -4] >>> construct_sums([1, -1, 1, -1], 2) [0, 0, 0, -1]","solution":"def construct_sums(arr, k): Constructs a new array where each element at index i is the sum of the elements at indices i to i + k - 1 in the original array. If there are fewer than k elements remaining, sum all the elements from i to the end of the array. Parameters: arr (list of int): The original array of integers k (int): The number of elements to sum Returns: list of int: The resultant array containing the sums result = [] n = len(arr) for i in range(n): sum_value = sum(arr[i:i+k]) result.append(sum_value) return result"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): Add two numbers represented by linked lists in reverse order. >>> linked_list_to_list(addTwoNumbers(list_to_linked_list([2, 4, 3]), list_to_linked_list([5, 6, 4]))) [7, 0, 8] >>> linked_list_to_list(addTwoNumbers(list_to_linked_list([9, 9, 9]), list_to_linked_list([1]))) [0, 0, 0, 1] >>> linked_list_to_list(addTwoNumbers(list_to_linked_list([]), list_to_linked_list([]))) [] >>> linked_list_to_list(addTwoNumbers(list_to_linked_list([0]), list_to_linked_list([1, 2, 3]))) [1, 2, 3] >>> linked_list_to_list(addTwoNumbers(list_to_linked_list([5]), list_to_linked_list([5]))) [0, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): Add two numbers represented by linked lists in reverse order. dummy = ListNode(0) p = dummy carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 total = val1 + val2 + carry carry = total // 10 new_val = total % 10 p.next = ListNode(new_val) p = p.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy.next"},{"question":"class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def max_depth(root: Node) -> int: Given a \`n\`-ary tree, find the maximum depth of the tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. >>> node1 = Node(1) >>> max_depth(node1) 1 >>> child1 = Node(2) >>> root = Node(1, [child1]) >>> max_depth(root) 2 >>> child1 = Node(2, [Node(5), Node(6)]) >>> child2 = Node(3) >>> child3 = Node(4, [Node(7, [Node(8)])]) >>> root = Node(1, [child1, child2, child3]) >>> max_depth(root) 4","solution":"class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def max_depth(root): if root is None: return 0 if not root.children: return 1 return 1 + max(max_depth(child) for child in root.children)"},{"question":"def longest_consecutive_subsequence(nums: List[int]) -> int: Returns the length of the longest consecutive elements subsequence. >>> longest_consecutive_subsequence([]) == 0 >>> longest_consecutive_subsequence([1]) == 1 >>> longest_consecutive_subsequence([2, 2, 2, 2, 2]) == 1 >>> longest_consecutive_subsequence([10, 5, 2, 7]) == 1 >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive_subsequence([1, 2, 2, 3, 4, 4, 5, 3, 1]) == 5 >>> longest_consecutive_subsequence([-1, -2, -3, -4, 0, 1, 2]) == 7 >>> longest_consecutive_subsequence([8, 7, 1, 2, 3, 4, 6, 5, 0]) == 9","solution":"def longest_consecutive_subsequence(nums): Returns the length of the longest consecutive elements subsequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # only check for the start of a streak if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from collections import deque from typing import Optional, List class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_sums(root: Optional[TreeNode]) -> List[int]: Given the root of a binary tree, returns an array where the i-th element is the sum of the node values at the i-th level. >>> level_sums(None) [] >>> root = TreeNode(1) >>> level_sums(root) [1] >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> level_sums(root) [1, 5] >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> level_sums(root) [1, 5, 9] >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, None, TreeNode(5))) >>> level_sums(root) [1, 5, 9] >>> root = TreeNode(1, ... TreeNode(2, ... TreeNode(4), ... TreeNode(5, TreeNode(8), TreeNode(9))), ... TreeNode(3, ... TreeNode(6), ... TreeNode(7))) >>> level_sums(root) [1, 5, 22, 17]","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_sums(root): Given the root of a binary tree, returns an array where the i-th element is the sum of the node values at the i-th level. if not root: return [] result = [] queue = deque([root]) while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node = queue.popleft() level_sum += node.value if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum) return result"},{"question":"def max_product(nums: List[int]) -> int: Given a list of non-negative integers \`nums\`, find the maximum product you can obtain by multiplying two different elements from the list. Return the maximum product you can get. >>> max_product([1, 2, 3, 4]) == 12 >>> max_product([0, 1, 2, 3]) == 6 >>> max_product([1, 1, 1, 1, 1]) == 1 >>> max_product([100, 90, 80, 70]) == 9000 >>> max_product([5]) == 0 >>> max_product([]) == 0","solution":"def max_product(nums): Returns the maximum product obtained by multiplying two different elements from the list nums. if len(nums) < 2: return 0 nums.sort() return nums[-1] * nums[-2]"},{"question":"def reconstructQueue(people: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Reconstruct the queue based on the given list of people. Each person is represented as a tuple (h, k), where h is the height and k is the number of people in front of this person with a height greater than or equal to h. Args: people (list of tuples): A list of tuples where each tuple contains two integers (h, k). Returns: list of tuples: The reconstructed queue. >>> reconstructQueue([(7, 0), (4, 4), (7, 1), (5, 0), (6, 1), (5, 2)]) == [(5, 0), (7, 0), (5, 2), (6, 1), (4, 4), (7, 1)] >>> reconstructQueue([(1, 0)]) == [(1, 0)] >>> reconstructQueue([(2, 0), (1, 1)]) == [(2, 0), (1, 1)] >>> reconstructQueue([(7, 1), (7, 0), (7, 2)]) == [(7, 0), (7, 1), (7, 2)] >>> reconstructQueue([(1, 0), (2, 0), (3, 0), (4, 0)]) == [(1, 0), (2, 0), (3, 0), (4, 0)]","solution":"def reconstructQueue(people): Reconstructs the queue based on the given list of people. Args: people (list of tuples): A list of tuples where each tuple contains two integers (h, k). Returns: list of tuples: The reconstructed queue. # Sort people based on height in descending order. # For people with the same height, sort based on k in ascending order. people.sort(key=lambda x: (-x[0], x[1])) queue = [] # Insert each person at the index specified by k for person in people: queue.insert(person[1], person) return queue"},{"question":"def shortest_unique_char_substring_length(s: str) -> int: Determines the length of the shortest substring that contains all unique characters of the input string \`s\`. >>> shortest_unique_char_substring_length(\\"\\") == 0 >>> shortest_unique_char_substring_length(\\"A\\") == 1 >>> shortest_unique_char_substring_length(\\"ABCDEFG\\") == 7 >>> shortest_unique_char_substring_length(\\"ABAC\\") == 3 >>> shortest_unique_char_substring_length(\\"AAAAA\\") == 1 >>> shortest_unique_char_substring_length(\\"AABBCDDE\\") == 7 >>> shortest_unique_char_substring_length(\\"AABCBCADE\\") == 5","solution":"def shortest_unique_char_substring_length(s): Determines the length of the shortest substring that contains all unique characters of the input string \`s\`. :param s: A string consisting of uppercase English letters :return: Length of the shortest substring containing all unique characters in \`s\` # Edge Case: if input string is empty if not s: return 0 unique_chars = set(s) required_char_count = len(unique_chars) left = 0 min_length = len(s) + 1 char_frequency = {} unique_count = 0 for right in range(len(s)): char = s[right] if char not in char_frequency: char_frequency[char] = 0 char_frequency[char] += 1 if char_frequency[char] == 1: unique_count += 1 while unique_count == required_char_count: min_length = min(min_length, right - left + 1) left_char = s[left] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: unique_count -= 1 left += 1 return min_length if min_length != len(s) + 1 else 0"},{"question":"from typing import List from collections import Counter def is_anagram_of_subsequence(s: str, t: str) -> bool: Determine if t is an anagram of any subsequence of s. >>> is_anagram_of_subsequence(\\"abcde\\", \\"abc\\") == True >>> is_anagram_of_subsequence(\\"abcde\\", \\"edc\\") == True >>> is_anagram_of_subsequence(\\"abcde\\", \\"e\\") == True >>> is_anagram_of_subsequence(\\"abcde\\", \\"f\\") == False >>> is_anagram_of_subsequence(\\"abcdefg\\", \\"gfedcba\\") == True >>> is_anagram_of_subsequence(\\"abcdefg\\", \\"gfedcbaz\\") == False >>> is_anagram_of_subsequence(\\"aaaaa\\", \\"aaa\\") == True >>> is_anagram_of_subsequence(\\"aaaaa\\", \\"aaaaa\\") == True >>> is_anagram_of_subsequence(\\"aaaaa\\", \\"aaaaaa\\") == False >>> is_anagram_of_subsequence(\\"xyz\\", \\"zxy\\") == True >>> is_anagram_of_subsequence(\\"xyz\\", \\"zxya\\") == False >>> is_anagram_of_subsequence(\\"\\", \\"\\") == True >>> is_anagram_of_subsequence(\\"a\\", \\"\\") == True >>> is_anagram_of_subsequence(\\"\\", \\"a\\") == False","solution":"from collections import Counter def is_anagram_of_subsequence(s, t): Determine if t is an anagram of any subsequence of s. counter_s = Counter(s) counter_t = Counter(t) for char in counter_t: if counter_t[char] > counter_s.get(char, 0): return False return True"},{"question":"from typing import List def find_min_courses(courseList: List[str], prerequisites: List[List[str]]) -> int: Determine the minimum number of courses you must complete in order to be able to take any of the given courses. If it is impossible to take all courses due to cyclic prerequisites, return -1. >>> find_min_courses(['A', 'B', 'C'], []) 3 >>> find_min_courses(['A', 'B', 'C'], [['B', 'A']]) 3 >>> find_min_courses(['A', 'B', 'C', 'D'], [['B', 'A'], ['C', 'B'], ['D', 'C']]) 4 >>> find_min_courses(['A', 'B', 'C'], [['B', 'A'], ['C', 'B'], ['A', 'C']]) -1 >>> find_min_courses(['A', 'B', 'C', 'D'], [['B', 'A'], ['C', 'D'], ['A', 'C'], ['D', 'B']]) -1 >>> find_min_courses(['A', 'B', 'C', 'D'], [['B', 'A'], ['D', 'C']]) 4","solution":"def find_min_courses(courseList, prerequisites): from collections import defaultdict, deque # Map to store each course's prerequisites pre_map = defaultdict(set) # Map to store each course that is a prerequisite for other courses post_map = defaultdict(set) for a, b in prerequisites: pre_map[a].add(b) post_map[b].add(a) # Compute the in-degree for each course in_degree = {course: 0 for course in courseList} for course in pre_map: for pre in pre_map[course]: in_degree[course] += 1 # Initialize a queue with courses that have no prerequisites queue = deque([course for course in courseList if in_degree[course] == 0]) completed_courses = 0 while queue: course = queue.popleft() completed_courses += 1 # For each course that the current course is a prerequisite for for dependent_course in post_map[course]: in_degree[dependent_course] -= 1 if in_degree[dependent_course] == 0: queue.append(dependent_course) # Check if all courses are processed if completed_courses == len(courseList): return completed_courses else: return -1"},{"question":"def get_unique_indices(nums: List[int]) -> List[int]: Given a list of integers \`nums\`, return the indices of all the unique elements in the list. If there are no unique elements, return an empty list. An element is considered unique if it appears exactly once in the list. The order of the returned indices should be in ascending order. >>> get_unique_indices([1, 1, 2, 2, 3, 3]) [] >>> get_unique_indices([1, 2, 3, 4]) [0, 1, 2, 3] >>> get_unique_indices([1, 2, 2, 3, 4, 4, 5]) [0, 3, 6] >>> get_unique_indices([1]) [0] >>> get_unique_indices([]) [] >>> get_unique_indices([2, 3, 3, 2, 4, 5, 5, 6]) [4, 7]","solution":"def get_unique_indices(nums): Returns the indices of all the unique elements in the list \`nums\`. If there are no unique elements, returns an empty list. from collections import Counter count = Counter(nums) unique_indices = [i for i, num in enumerate(nums) if count[num] == 1] return sorted(unique_indices)"},{"question":"def find_prefix_patterns(patterns: List[str], s: str) -> List[str]: Returns a list of all patterns from 'patterns' that are prefixes of 's', sorted lexicographically. >>> find_prefix_patterns([\\"a\\", \\"ab\\", \\"abc\\"], \\"abcde\\") == [\\"a\\", \\"ab\\", \\"abc\\"] >>> find_prefix_patterns([\\"def\\", \\"ghi\\", \\"jkl\\"], \\"abc\\") == [] >>> find_prefix_patterns([\\"abc\\", \\"a\\", \\"xyz\\", \\"ab\\"], \\"abcde\\") == [\\"a\\", \\"ab\\", \\"abc\\"] >>> find_prefix_patterns([], \\"abc\\") == [] >>> find_prefix_patterns([\\"a\\", \\"ab\\", \\"abc\\"], \\"\\") == [] >>> find_prefix_patterns([\\"ab\\", \\"abc\\", \\"a\\", \\"b\\"], \\"abcde\\") == [\\"a\\", \\"ab\\", \\"abc\\"]","solution":"def find_prefix_patterns(patterns, s): Returns a list of all patterns from 'patterns' that are prefixes of 's', sorted lexicographically. :param patterns: List of strings :param s: String :return: List of strings prefix_patterns = [pattern for pattern in patterns if s.startswith(pattern)] return sorted(prefix_patterns)"},{"question":"def count_distinct_triplets(arr: List[int], target: int) -> int: Returns the number of distinct triplets (i, j, k) such that 0 <= i < j < k < len(arr) and arr[i] + arr[j] + arr[k] == target. Example: >>> count_distinct_triplets([1, 2, 3, 4, 5], 9) 2 >>> count_distinct_triplets([1, 1, 1, 1], 10) 0 >>> count_distinct_triplets([1, 2, 3], 6) 1 >>> count_distinct_triplets([1, 2, 2, 3, 4], 7) 3 >>> count_distinct_triplets([], 0) 0 >>> count_distinct_triplets([1, 2, 3, 4, 5], 100) 0 >>> count_distinct_triplets([-1, -2, -3, -4, -5], -6) 1 >>> count_distinct_triplets([-1, 1, 2, 3, 0], 0) 1","solution":"def count_distinct_triplets(arr, target): Returns the number of distinct triplets (i, j, k) such that 0 <= i < j < k < len(arr) and arr[i] + arr[j] + arr[k] == target n = len(arr) count = 0 for i in range(n - 2): for j in range(i + 1, n - 1): for k in range(j + 1, n): if arr[i] + arr[j] + arr[k] == target: count += 1 return count"},{"question":"def max_candles(candles: List[int]) -> int: Returns the maximum number of candles you can blow out consecutively in one go. :param candles: List of integers representing the heights of the candles :return: Integer, maximum number of consecutive candles that can be blown out >>> max_candles([]) == 0 >>> max_candles([1, 1, 1, 1]) == 4 >>> max_candles([4, 3, 2, 1]) == 4 >>> max_candles([1, 2, 3, 4]) == 1 >>> max_candles([4, 4, 4, 3, 2, 1, 3, 2]) == 6 >>> max_candles([5, 4, 3, 2, 2, 3, 4]) == 5 >>> max_candles([3, 1, 2, 2, 1, 4, 1, 3]) == 3 >>> max_candles([5]) == 1 >>> max_candles([2, 2]) == 2 >>> max_candles([3, 1]) == 2 >>> max_candles([1, 3]) == 1","solution":"def max_candles(candles): Returns the maximum number of candles you can blow out consecutively in one go. :param candles: List of integers representing the heights of the candles :return: Integer, maximum number of consecutive candles that can be blown out if not candles: return 0 max_count = 1 for start in range(len(candles)): count = 1 for i in range(start + 1, len(candles)): if candles[i] <= candles[i - 1]: count += 1 else: break max_count = max(max_count, count) return max_count"},{"question":"from typing import Dict, Optional class LFUCache: LFU Cache class that supports O(1) get and put operations. Methods: - __init__(self, capacity: int) - get(self, key: int) -> int - put(self, key: int, value: int) -> None Usage: >>> lfu = LFUCache(2) >>> lfu.put(1, 1) >>> lfu.put(2, 2) >>> lfu.get(1) == 1 >>> lfu.put(3, 3) >>> lfu.get(2) == -1 >>> lfu.get(3) == 3 >>> lfu.put(4, 4) >>> lfu.get(1) == -1 >>> lfu.get(3) == 3 >>> lfu.get(4) == 4 def __init__(self, capacity: int): Initialize the LFU Cache with a given capacity. pass def get(self, key: int) -> int: Return the value corresponding to the given key, if present. Updates the usage frequency of the key. pass def put(self, key: int, value: int) -> None: Inserts or updates the value associated with the given key. If the cache is full, it invalidates the least frequently used item. If there is a tie in frequency, the least recently used item is invalidated. pass","solution":"from collections import defaultdict, OrderedDict class LFUCache: def __init__(self, capacity: int): self.capacity = capacity self.minFreq = 0 self.freq = defaultdict(OrderedDict) self.keyVal = {} self.keyFreq = {} def _update(self, key, value=None): freq = self.keyFreq[key] self.freq[freq].pop(key) if not self.freq[freq]: del self.freq[freq] if self.minFreq == freq: self.minFreq += 1 if value is not None: self.keyVal[key] = value self.keyFreq[key] += 1 self.freq[self.keyFreq[key]][key] = self.keyVal[key] def get(self, key: int) -> int: if key not in self.keyVal: return -1 self._update(key) return self.keyVal[key] def put(self, key: int, value: int) -> None: if self.capacity == 0: return if key in self.keyVal: self._update(key, value) else: if len(self.keyVal) >= self.capacity: k, _ = self.freq[self.minFreq].popitem(last=False) del self.keyVal[k] del self.keyFreq[k] self.keyVal[key] = value self.keyFreq[key] = 1 self.minFreq = 1 self.freq[1][key] = value"},{"question":"def longest_unique_substring_with_k_distinct(s: str, k: int) -> int: Returns the length of the longest unique substring of \`s\` that contains exactly \`k\` distinct characters. If no such substring exists, return -1. >>> longest_unique_substring_with_k_distinct(\\"eceba\\", 2) == 3 >>> longest_unique_substring_with_k_distinct(\\"aa\\", 1) == 2 >>> longest_unique_substring_with_k_distinct(\\"\\", 2) == -1 >>> longest_unique_substring_with_k_distinct(\\"a\\", 1) == 1 >>> longest_unique_substring_with_k_distinct(\\"a\\", 0) == -1 >>> longest_unique_substring_with_k_distinct(\\"abaccc\\", 2) == 4 >>> longest_unique_substring_with_k_distinct(\\"abcdef\\", 6) == 6 >>> longest_unique_substring_with_k_distinct(\\"aaaa\\", 1) == 4 >>> longest_unique_substring_with_k_distinct(\\"aabacbebebe\\", 3) == 7","solution":"def longest_unique_substring_with_k_distinct(s, k): Returns the length of the longest unique substring of \`s\` that contains exactly \`k\` distinct characters. If no such substring exists, return -1. n = len(s) if k == 0 or n == 0: return -1 max_len = -1 left = 0 char_count = {} for right in range(n): char = s[right] char_count[char] = char_count.get(char, 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if len(char_count) == k: max_len = max(max_len, right - left + 1) return max_len"},{"question":"class WordDictionary: Implements a data structure to store words and support search with wildcards. Usage: >>> wordDict = WordDictionary() >>> wordDict.addWord(\\"bad\\") >>> wordDict.addWord(\\"dad\\") >>> wordDict.addWord(\\"mad\\") >>> wordDict.search(\\"pad\\") False >>> wordDict.search(\\"bad\\") True >>> wordDict.search(\\".ad\\") True >>> wordDict.search(\\"b..\\") True def __init__(self): pass def addWord(self, word): pass def search(self, word): pass","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word): self.words.append(word) def search(self, word): import re pattern = re.compile('^' + word + '') for w in self.words: if pattern.match(w): return True return False"},{"question":"import heapq class KthLargest: A class to find the k-th largest element in a stream. Methods: def __init__(self, k: int, nums: list): Initializes the KthLargest object with the integer k and the stream of integers nums. def add(self, val: int) -> int: Adds the integer val to the stream and returns the k-th largest element in the stream. def test_kth_largest_initial_array_larger_than_k(): kth = KthLargest(3, [4, 5, 8, 2]) assert kth.add(3) == 4 assert kth.add(5) == 5 assert kth.add(10) == 5 assert kth.add(9) == 8 assert kth.add(4) == 8 def test_kth_largest_initial_array_smaller_than_k(): kth = KthLargest(3, [5]) assert kth.add(12) == 5 assert kth.add(1) == 1 assert kth.add(3) == 3 assert kth.add(8) == 5 assert kth.add(10) == 8 def test_kth_largest_with_negative_numbers(): kth = KthLargest(2, [1, -1]) assert kth.add(-2) == -1 assert kth.add(-3) == -1 assert kth.add(2) == 1 def test_kth_largest_empty_initial_array(): kth = KthLargest(1, []) assert kth.add(-10) == -10 assert kth.add(4) == 4 assert kth.add(0) == 4","solution":"import heapq class KthLargest: def __init__(self, k: int, nums: list): self.k = k self.min_heap = nums heapq.heapify(self.min_heap) while len(self.min_heap) > self.k: heapq.heappop(self.min_heap) def add(self, val: int) -> int: if len(self.min_heap) < self.k: heapq.heappush(self.min_heap, val) elif val > self.min_heap[0]: heapq.heapreplace(self.min_heap, val) return self.min_heap[0]"},{"question":"def longestDistinctSubstringLength(s: str) -> int: Returns the length of the longest substring with all distinct characters. :param s: A string consisting of only lowercase letters. :return: An integer representing the length of the longest substring with all distinct characters. >>> longestDistinctSubstringLength(\\"\\") == 0 >>> longestDistinctSubstringLength(\\"abcdef\\") == 6 >>> longestDistinctSubstringLength(\\"aaaaa\\") == 1 >>> longestDistinctSubstringLength(\\"abcabcbb\\") == 3 >>> longestDistinctSubstringLength(\\"bbbbb\\") == 1 >>> longestDistinctSubstringLength(\\"pwwkew\\") == 3 >>> longestDistinctSubstringLength(\\"aab\\") == 2 >>> longestDistinctSubstringLength(\\"dvdf\\") == 3","solution":"def longestDistinctSubstringLength(s): Returns the length of the longest substring with all distinct characters. :param s: A string consisting of only lowercase letters. :return: An integer representing the length of the longest substring with all distinct characters. last_seen = {} start = 0 max_length = 0 for end, char in enumerate(s): if char in last_seen and last_seen[char] >= start: start = last_seen[char] + 1 last_seen[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def lexicographically_smallest_subsequence(s: str, k: int) -> str: Select k characters from the string s such that the selected characters form the lexicographically smallest possible substring of length k, maintaining their relative order. Args: s (str): The input string consisting of lowercase English letters. k (int): The length of the desired subsequence. Returns: str: The lexicographically smallest subsequence of length k. >>> lexicographically_smallest_subsequence(\\"abcde\\", 3) 'abc' >>> lexicographically_smallest_subsequence(\\"dbca\\", 2) 'ba' >>> lexicographically_smallest_subsequence(\\"abcd\\", 4) 'abcd' >>> lexicographically_smallest_subsequence(\\"aaaaa\\", 3) 'aaa' >>> lexicographically_smallest_subsequence(\\"dcab\\", 3) 'cab' >>> lexicographically_smallest_subsequence(\\"debac\\", 3) 'bac'","solution":"def lexicographically_smallest_subsequence(s, k): Returns the lexicographically smallest subsequence of length k from the string s. stack = [] to_remove = len(s) - k for char in s: while stack and to_remove > 0 and stack[-1] > char: stack.pop() to_remove -= 1 stack.append(char) # The stack may be larger than k due to the initial fills return ''.join(stack[:k])"},{"question":"def rob(nums): Returns the maximum amount of money that can be robbed without triggering the alarm. :param nums: List[int] - List of non-negative integers representing the amount of money of each house. :return: int - Maximum amount of money that can be robbed. pass # Test Cases def test_rob_empty(): assert rob([]) == 0 def test_rob_one_house(): assert rob([5]) == 5 def test_rob_two_houses(): assert rob([1, 2]) == 2 assert rob([10, 5]) == 10 def test_rob_multiple_houses(): assert rob([1, 2, 3, 1]) == 4 assert rob([2, 7, 9, 3, 1]) == 12 assert rob([2, 1, 1, 2]) == 4 def test_rob_large_numbers(): assert rob([100, 200, 300, 400, 500]) == 900 assert rob([1000, 2000, 3000, 1000, 5000, 4000]) == 9000","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without triggering the alarm. :param nums: List[int] - List of non-negative integers representing the amount of money of each house. :return: int - Maximum amount of money that can be robbed. if not nums: return 0 elif len(nums) == 1: return nums[0] elif len(nums) == 2: return max(nums[0], nums[1]) prev2 = nums[0] prev1 = max(nums[0], nums[1]) for i in range(2, len(nums)): current = max(prev1, prev2 + nums[i]) prev2, prev1 = prev1, current return prev1"},{"question":"def process_inventory(items, operations): Process a sequence of operations on the inventory. Parameters: items (list of int): List where the i-th element represents the number of items of type i. operations (list of tuples): Each tuple contains (type, order). - \`type\` is 0 to add items or 1 to remove items. - \`order\` is the number of items to add/remove of the corresponding type. Returns: list of int: Final state of the inventory after processing all operations. >>> process_inventory([5, 3, 2], [(0, (0, 5)), (0, (1, 3))]) [10, 6, 2] >>> process_inventory([5, 3, 2], [(1, (0, 3)), (1, (1, 1))]) [2, 2, 2] >>> process_inventory([5, 3, 2], [(1, (0, 10)), (1, (1, 5))]) [0, 0, 2] >>> process_inventory([5, 3, 2], [(0, (0, 2)), (1, (0, 3)), (1, (1, 2)), (0, (2, 1))]) [4, 1, 3] >>> process_inventory([5, 3, 2], []) [5, 3, 2]","solution":"def process_inventory(items, operations): Process a sequence of operations on the inventory. Parameters: items (list of int): List where the i-th element represents the number of items of type i. operations (list of tuples): Each tuple contains (type, order). - \`type\` is 0 to add items or 1 to remove items. - \`order\` is the number of items to add/remove of the corresponding type. Returns: list of int: Final state of the inventory after processing all operations. for operation in operations: type, order = operation if type == 0: items[order[0]] += order[1] elif type == 1: items[order[0]] = max(0, items[order[0]] - order[1]) return items"},{"question":"def count_high_temperature_days(temperatures: List[int], k: int) -> int: Counts the number of days such that the temperature on day i is strictly higher than the temperature on each of the previous k days. :param temperatures: List[int], list of daily temperatures. :param k: int, number of previous days to compare with. :return: int, number of days meeting the criteria. pass # Test cases def test_no_days_meeting_criteria(): assert count_high_temperature_days([30, 29, 28, 27], 2) == 0 def test_all_days_meeting_criteria(): assert count_high_temperature_days([10, 20, 30, 40], 2) == 2 def test_some_days_meeting_criteria(): assert count_high_temperature_days([30, 31, 29, 32, 33], 2) == 2 def test_k_equal_to_1(): assert count_high_temperature_days([10, 20, 15, 25], 1) == 2 def test_k_equal_to_n(): assert count_high_temperature_days([10, 20, 30, 40], 4) == 0 def test_short_list(): assert count_high_temperature_days([20], 1) == 0 def test_boundary_conditions(): assert count_high_temperature_days([25, 25, 25, 25, 25], 2) == 0 assert count_high_temperature_days([1, 2, 3, 4], 1) == 3","solution":"def count_high_temperature_days(temperatures, k): Counts the number of days such that the temperature on day i is strictly higher than the temperature on each of the previous k days. :param temperatures: List[int], list of daily temperatures. :param k: int, number of previous days to compare with. :return: int, number of days meeting the criteria. count = 0 n = len(temperatures) for i in range(k, n): if all(temperatures[i] > temperatures[j] for j in range(i - k, i)): count += 1 return count"},{"question":"from typing import List def most_popular_id(nums: List[int], friends: List[List[int]]) -> int: Determine the identifier of the most popular person who has the most friends. >>> most_popular_id([1], []) == 1 >>> most_popular_id([1, 2, 3, 4], [[1, 2], [2, 3], [3, 4], [4, 1]]) == 1 >>> most_popular_id([1, 2, 3], [[1, 3], [2, 3]]) == 3 >>> most_popular_id([1, 2, 3, 4], [[1, 2], [1, 3], [2, 4], [3, 4]]) == 1 >>> most_popular_id([1, 2, 3, 4], [[1, 2], [3, 4]]) == 1 >>> most_popular_id([1, 2, 3, 4], [[1, 2], [3, 4], [1, 3]]) == 1 >>> most_popular_id(list(range(1, 10)), [[1,2], [2,3], [3,4], [4,5], [5,6], [6,7], [7,8], [8,9], [9,1], [1,6]]) == 1","solution":"from typing import List from collections import defaultdict def most_popular_id(nums: List[int], friends: List[List[int]]) -> int: # Create a dictionary to count the number of friends each person ID has friend_count = defaultdict(int) # Iterate over each friend pair and increment the count for each person for friend1, friend2 in friends: friend_count[friend1] += 1 friend_count[friend2] += 1 # Initialize the most popular person ID and the count of friends most_popular = None max_friends = -1 # Iterate over each person in nums to determine the most popular person for person in nums: count = friend_count[person] # Check if current person has more friends or if it is a tie with a smaller identifier if count > max_friends or (count == max_friends and (most_popular is None or person < most_popular)): most_popular = person max_friends = count return most_popular"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> int: Returns the length of the longest common subsequence of str1 and str2. >>> longest_common_subsequence(\\"\\", \\"\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"ac\\") 2 >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"bl\\", \\"yby\\") 1 >>> longest_common_subsequence(\\"blues\\", \\"clues\\") 4 >>> longest_common_subsequence(\\"abc\\", \\"a\\") 1","solution":"def longest_common_subsequence(str1, str2): Returns the length of the longest common subsequence of str1 and str2. m, n = len(str1), len(str2) # Create a 2D array to store lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The last cell will have the length of longest common subsequence return dp[m][n]"},{"question":"def min_cost_to_make_elements_equal(nums: List[int]) -> int: Returns the minimum cost to make all elements in nums equal. The cost is defined as the sum of absolute differences between each element and the chosen target value. >>> min_cost_to_make_elements_equal([1, 3, 2, 4]) == 4 >>> min_cost_to_make_elements_equal([1, 2, 3]) == 2 >>> min_cost_to_make_elements_equal([5]) == 0 >>> min_cost_to_make_elements_equal([1000, 2000, 3000]) == 2000 >>> min_cost_to_make_elements_equal([-1, -5, -3]) == 4","solution":"def min_cost_to_make_elements_equal(nums): Returns the minimum cost to make all elements in nums equal. The cost is defined as the sum of absolute differences between each element and the chosen target value. :param nums: List[int] - a list of integers :return: int - minimum cost to make all elements equal nums.sort() median = nums[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_sum_path(root: TreeNode) -> list[int]: Return the path with the maximum sum from the root node to any leaf node. >>> root = TreeNode(1) >>> max_sum_path(root) [1] >>> root = TreeNode(1, TreeNode(2, TreeNode(4))) >>> max_sum_path(root) [1, 2, 4] >>> root = TreeNode(1, None, TreeNode(3, None, TreeNode(5))) >>> max_sum_path(root) [1, 3, 5] >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> max_sum_path(root) [1, 3] >>> root = TreeNode(1, ... TreeNode(2, TreeNode(4), TreeNode(5)), ... TreeNode(3, None, TreeNode(6, TreeNode(7)))) >>> max_sum_path(root) [1, 3, 6, 7]","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_sum_path(root): def helper(node): if not node: return (0, []) if not node.left and not node.right: return (node.value, [node.value]) left_sum, left_path = helper(node.left) right_sum, right_path = helper(node.right) if left_sum >= right_sum: return (node.value + left_sum, [node.value] + left_path) else: return (node.value + right_sum, [node.value] + right_path) _, path = helper(root) return path"},{"question":"def findPeakElement(nums): Finds a peak element index in the array. A peak element is an element that is greater than its neighbors. The function runs in O(log n) time using a binary search approach. :param nums: List[int] - Input list of integers :return: int - The index of any peak element >>> findPeakElement([1]) == 0 >>> findPeakElement([1, 2]) == 1 >>> findPeakElement([2, 1]) == 0 >>> findPeakElement([1, 3, 2, 1, 2, 3, 1]) in [1, 5] >>> findPeakElement([7, 7, 7, 7, 7]) in [0, 1, 2, 3, 4] >>> findPeakElement([5, 4, 3, 2, 1]) == 0 >>> findPeakElement([1, 2, 3, 4, 5]) == 4","solution":"def findPeakElement(nums): Finds a peak element index in the array. A peak element is an element that is greater than its neighbors. The function runs in O(log n) time using a binary search approach. :param nums: List[int] - Input list of integers :return: int - The index of any peak element left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"def largest_connected_component(grid: List[List[int]]) -> int: Find the size of the largest connected component in the grid where a component is formed by adjoining 1's. :param grid: List[List[int]] - a 2D list representing the grid :return: int - size of the largest connected component >>> largest_connected_component([ ... [1, 1, 0, 0], ... [1, 0, 0, 1], ... [0, 0, 1, 1] ... ]) == 3 >>> largest_connected_component([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> largest_connected_component([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 9 >>> largest_connected_component([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) == 1 >>> largest_connected_component([ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) == 1 >>> largest_connected_component([]) == 0 >>> largest_connected_component([[0]]) == 0 >>> largest_connected_component([[1]]) == 1","solution":"def largest_connected_component(grid): Returns the size of the largest connected component in the given grid where adjacent cells with value 1 are considered connected. :param grid: List[List[int]] - a 2D list representing the grid :return: int - size of the largest connected component if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(x, y): # Out of bounds or already visited or 0 cell if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or grid[x][y] == 0: return 0 visited[x][y] = True size = 1 # Current cell is part of the component # Explore the four adjacent directions size += dfs(x+1, y) size += dfs(x-1, y) size += dfs(x, y+1) size += dfs(x, y-1) return size max_size = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"def rearrangeString(s: str, k: int) -> str: Given a string \`s\` which contains only lowercase letters, and an integer \`k\`, construct a new string by rearranging the letters of \`s\` such that the same letter is at least \`k\` distance apart. If it is not possible to rearrange the letters of \`s\` in this way, return an empty string. If multiple rearrangements are possible, return any one of them. >>> rearrangeString(\\"aabbcc\\", 3) 'abcabc' >>> rearrangeString(\\"aaabc\\", 3) '' >>> rearrangeString(\\"aabbcc\\", 0) 'aabbcc' >>> rearrangeString(\\"\\", 1) '' >>> rearrangeString(\\"a\\", 1) 'a' >>> rearrangeString(\\"aabbcc\\", 100) ''","solution":"import heapq from collections import Counter, deque def rearrangeString(s, k): if k == 0: return s counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) queue = deque() result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) queue.append((freq + 1, char)) if len(queue) < k: continue front = queue.popleft() if front[0] < 0: heapq.heappush(max_heap, front) return ''.join(result) if len(result) == len(s) else \\"\\""},{"question":"def countHomogeneous(s: str) -> int: Returns the number of non-empty homogeneous substrings of \`s\`, modulo 10^9 + 7. >>> countHomogeneous(\\"abbcccaa\\") 13 >>> countHomogeneous(\\"xy\\") 2 >>> countHomogeneous(\\"a\\") 1 >>> countHomogeneous(\\"aaaa\\") 10 >>> countHomogeneous(\\"ababab\\") 6 >>> countHomogeneous(\\"abcdefg\\") 7 >>> countHomogeneous(\\"a\\" * 100000) (100000 * (100000 + 1) // 2) % (10**9 + 7)","solution":"def countHomogeneous(s): Returns the number of non-empty homogeneous substrings of \`s\`, modulo 10^9 + 7. MOD = 10**9 + 7 count = 0 length = 1 for i in range(1, len(s) + 1): if i < len(s) and s[i] == s[i - 1]: length += 1 else: count += length * (length + 1) // 2 count %= MOD length = 1 return count"},{"question":"def find_odd_occurrence(arr: List[int]) -> int: Given an array of integers where every element appears an even number of times except for one element, find the single element that appears an odd number of times. >>> find_odd_occurrence([2, 2, 3, 3, 5, 5, 5]) == 5 >>> find_odd_occurrence([1, 1, 2, 2, 3, 3, 4]) == 4 >>> find_odd_occurrence([99]) == 99 >>> find_odd_occurrence([10]*1000 + [20, 20, 30, 30, 40, 50, 50, 40, 60, 60, 70, 70, 80]) == 80 >>> find_odd_occurrence([-1, -1, -2, -2, -3]) == -3 pass","solution":"def find_odd_occurrence(arr): Returns the single element that appears an odd number of times in the array. result = 0 for num in arr: result ^= num return result"},{"question":"def findPowerfulNumbers(n: int) -> list: Finds all powerful numbers between 1 and n (inclusive). A powerful number is an integer that is equal to or greater than the sum of its positive divisors excluding itself. Args: n (int): The upper limit to look for powerful numbers (1  n  10^4). Returns: list: A list of powerful numbers in ascending order. >>> findPowerfulNumbers(12) [12] >>> findPowerfulNumbers(5) [] >>> findPowerfulNumbers(25) [12, 18, 20, 24] >>> findPowerfulNumbers(7) [] >>> findPowerfulNumbers(100) [12, 18, 20, 24, 30, 36, 40, 42, 48, 54, 56, 60, 66, 70, 72, 78, 80, 84, 88, 90, 96, 100]","solution":"def findPowerfulNumbers(n): Finds all powerful numbers between 1 and n (inclusive). A powerful number is an integer that is equal to or greater than the sum of its positive divisors excluding itself. Args: n (int): The upper limit to look for powerful numbers (1  n  10^4). Returns: list: A list of powerful numbers in ascending order. def sum_of_divisors_excluding_itself(num): # Helper function to calculate the sum of divisors of a number excluding the number itself total_sum = 0 for i in range(1, (num // 2) + 1): if num % i == 0: total_sum += i return total_sum powerful_numbers = [] for i in range(1, n+1): if sum_of_divisors_excluding_itself(i) > i: powerful_numbers.append(i) return powerful_numbers"},{"question":"def pacificAtlantic(heights: List[List[int]]) -> List[List[int]]: Return a list of coordinates from where water can flow to both the Pacific and Atlantic oceans. >>> pacificAtlantic([ ... [1, 2, 2, 3, 5], ... [3, 2, 3, 4, 4], ... [2, 4, 5, 3, 1], ... [6, 7, 1, 4, 5], ... [5, 1, 1, 2, 4] ... ]) [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] >>> pacificAtlantic([ ... [1] ... ]) [[0, 0]] >>> pacificAtlantic([ ... [1, 2], ... [4, 3] ... ]) [[0, 1], [1, 0], [1, 1]] >>> pacificAtlantic([]) []","solution":"def pacificAtlantic(heights): if not heights: return [] def dfs(x, y, visited, prev_height): if ((x, y) in visited or x < 0 or x >= len(heights) or y < 0 or y >= len(heights[0]) or heights[x][y] < prev_height): return visited.add((x, y)) for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)): dfs(x + dx, y + dy, visited, heights[x][y]) pacific, atlantic = set(), set() rows, cols = len(heights), len(heights[0]) for i in range(rows): dfs(i, 0, pacific, heights[i][0]) # Left edge (Pacific) dfs(i, cols - 1, atlantic, heights[i][cols - 1]) # Right edge (Atlantic) for j in range(cols): dfs(0, j, pacific, heights[0][j]) # Top edge (Pacific) dfs(rows - 1, j, atlantic, heights[rows - 1][j]) # Bottom edge (Atlantic) return list(map(list, pacific & atlantic))"},{"question":"def is_valid_palindrome(s: str) -> bool: Returns True if input string \`s\` is a valid palindrome, False otherwise. A string is considered a valid palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. >>> is_valid_palindrome(\\"\\") True >>> is_valid_palindrome(\\"a\\") True >>> is_valid_palindrome(\\"A\\") True >>> is_valid_palindrome(\\"Madam\\") True >>> is_valid_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_valid_palindrome(\\"hello\\") False >>> is_valid_palindrome(\\"race car\\") True >>> is_valid_palindrome(\\"12321\\") True >>> is_valid_palindrome(\\"12345\\") False >>> is_valid_palindrome(\\"!!!\\") True >>> is_valid_palindrome(\\"A1B2C3\\") False >>> is_valid_palindrome(\\"A1B3B1a\\") True","solution":"def is_valid_palindrome(s: str) -> bool: Returns True if input string \`s\` is a valid palindrome, False otherwise. # Convert to lower case and filter out non-alphanumeric characters filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered list of characters reads the same forward and backward return filtered_chars == filtered_chars[::-1]"},{"question":"class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def maxDepth(root): Returns the maximum depth of the n-ary tree. Example: >>> maxDepth(Node(1)) 1 >>> maxDepth(None) 0 from solution import Node, maxDepth def test_maxDepth_single_node(): assert maxDepth(Node(1)) == 1 def test_maxDepth_multiple_levels(): root = Node(1, [ Node(2, [ Node(5) ]), Node(3), Node(4, [ Node(6), Node(7, [ Node(8) ]) ]) ]) assert maxDepth(root) == 4 def test_maxDepth_empty_tree(): assert maxDepth(None) == 0 def test_maxDepth_two_level_tree(): root = Node(1, [ Node(2), Node(3), Node(4) ]) assert maxDepth(root) == 2 def test_maxDepth_three_level_tree(): root = Node(1, [ Node(2, [ Node(5), Node(6) ]), Node(3), Node(4, [ Node(7) ]) ]) assert maxDepth(root) == 3","solution":"class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def maxDepth(root): Returns the maximum depth of the n-ary tree. if not root: return 0 if not root.children: return 1 else: return 1 + max(maxDepth(child) for child in root.children)"},{"question":"def contains_nearby_duplicate(arr, k): Determines if there are two distinct indices i and j in the array \`arr\` such that arr[i] == arr[j] and the absolute difference between i and j is at most \`k\`. Returns \`true\` if such indices exist, and \`false\` otherwise. pass # Unit tests def test_no_duplicate(): assert contains_nearby_duplicate([1, 2, 3, 4, 5], 2) == False def test_duplicate_within_k(): assert contains_nearby_duplicate([1, 2, 3, 1], 3) == True assert contains_nearby_duplicate([1, 0, 1, 1], 1) == True def test_duplicate_not_within_k(): assert contains_nearby_duplicate([1, 2, 3, 1], 2) == False def test_large_k(): assert contains_nearby_duplicate([1, 2, 2], 10) == True def test_empty_array(): assert contains_nearby_duplicate([], 1) == False def test_single_element(): assert contains_nearby_duplicate([1], 1) == False def test_k_zero(): assert contains_nearby_duplicate([1, 2, 3, 1], 0) == False def test_all_elements_same(): assert contains_nearby_duplicate([1, 1, 1, 1], 1) == True assert contains_nearby_duplicate([5, 5, 5, 5], 0) == False","solution":"def contains_nearby_duplicate(arr, k): Determines if there are two distinct indices i and j in the array \`arr\` such that arr[i] == arr[j] and the absolute difference between i and j is at most \`k\`. Returns \`true\` if such indices exist, and \`false\` otherwise. index_map = {} for i, value in enumerate(arr): if value in index_map and i - index_map[value] <= k: return True index_map[value] = i return False"},{"question":"def min_absolute_sum_diff(nums1, nums2): Returns the minimum sum of the absolute differences of the paired elements from arrays nums1 and nums2. >>> min_absolute_sum_diff([1, 2, 3], [2, 3, 4]) 2 >>> min_absolute_sum_diff([1, 2, 3], [1, 2, 3]) 0 >>> min_absolute_sum_diff([1, 3, 5], [5, 3, 1]) 4 >>> min_absolute_sum_diff([-1, -2, -3], [-2, -3, -4]) 2 >>> min_absolute_sum_diff([1000000000, 1000000000], [999999999, 999999999]) 2","solution":"def min_absolute_sum_diff(nums1, nums2): Returns the minimum sum of the absolute differences of the paired elements from arrays nums1 and nums2. nums1_sorted = sorted(nums1) def find_closest(num): low, high = 0, len(nums1_sorted) - 1 while low < high: mid = (low + high) // 2 if nums1_sorted[mid] < num: low = mid + 1 else: high = mid return nums1_sorted[low] if abs(nums1_sorted[low] - num) < abs(nums1_sorted[low - 1] - num) else nums1_sorted[low - 1] total_diff = sum(abs(a - b) for a, b in zip(nums1, nums2)) min_diff = total_diff for a, b in zip(nums1, nums2): closest = find_closest(b) minimized_diff = total_diff - abs(a - b) + abs(closest - b) if minimized_diff < min_diff: min_diff = minimized_diff return min_diff"},{"question":"from typing import List def rearrangeArray(arr: List[int], k: int) -> List[int]: You are given an array of integers 'arr' and an integer 'k'. Rearrange the array such that any two adjacent integers in the rearranged array are at least 'k' units apart in absolute difference. Return the rearranged array if it is possible to do so. If it is not possible, return an empty array. >>> rearrangeArray([1, 3, 6, 8], 3) [1, 6, 3, 8] >>> rearrangeArray([1, 2, 3], 2) []","solution":"from typing import List def rearrangeArray(arr: List[int], k: int) -> List[int]: def is_valid_rearrangement(arr, k): for i in range(1, len(arr)): if abs(arr[i] - arr[i-1]) < k: return False return True # Recursive function to generate all permutations def permutations(arr, k): if len(arr) == 1: yield arr else: for i in range(len(arr)): for perm in permutations(arr[:i] + arr[i+1:], k): if i > 0 and abs(arr[i] - perm[-1]) < k: continue yield [arr[i]] + perm arr.sort() for perm in permutations(arr, k): if is_valid_rearrangement(perm, k): return perm return []"},{"question":"def max_height_difference(heights: List[int], start: int, end: int) -> int: Finds the maximum height difference between buildings in the given range [start, end]. Parameters: heights (list): List of integers representing the heights of buildings. start (int): Start index of the range. end (int): End index of the range. Returns: int: The maximum height difference or -1 if the range is invalid or there are fewer than two buildings. >>> max_height_difference([1, 5, 9, 3, 6, 8], 1, 4) 6 >>> max_height_difference([1, 5, 9, 3, 6, 8], 4, 1) -1 >>> max_height_difference([1, 5, 9, 3, 6, 8], -1, 2) -1 >>> max_height_difference([1, 5, 9, 3, 6, 8], 2, 6) -1 >>> max_height_difference([1, 5], 1, 1) -1 >>> max_height_difference([2, 2, 2, 2, 2], 1, 3) 0","solution":"def max_height_difference(heights, start, end): Finds the maximum height difference between buildings in the given range [start, end]. Parameters: heights (list): List of integers representing the heights of buildings. start (int): Start index of the range. end (int): End index of the range. Returns: int: The maximum height difference or -1 if the range is invalid or there are fewer than two buildings. if start < 0 or end >= len(heights) or start > end or end >= len(heights): #To validate if the start and end indexes are valid return -1 # Extract the sub-list of heights within the range [start, end] sub_heights = heights[start:end + 1] #range should include the last index mention hence end+1 if len(sub_heights) < 2: return -1 max_height = max(sub_heights) min_height = min(sub_heights) return max_height - min_height"},{"question":"def shortest_bridge(grid: List[List[int]]) -> int: Return the length of the shortest bridge needed to connect two islands in a grid. A \`n x n\` grid represents an island, where \`1\` represents land and \`0\` represents water. The goal is to return the shortest bridge's length as the number of 0s in the shortest path. >>> shortest_bridge([ ... [0, 1], ... [1, 0] ... ]) 1 >>> shortest_bridge([ ... [0,1,0], ... [0,0,0], ... [0,0,1] ... ]) 2 >>> shortest_bridge([ ... [1,1,1,1,1], ... [1,0,0,0,1], ... [1,0,1,0,1], ... [1,0,0,0,1], ... [1,1,1,1,1], ... ]) 1 >>> shortest_bridge([ ... [0,0,1,0,0], ... [0,0,0,0,0], ... [0,0,0,0,0], ... [0,0,0,0,0], ... [0,0,1,0,0], ... ]) 3 >>> shortest_bridge([ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 0, 0], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ]) 2","solution":"from collections import deque def shortest_bridge(grid): n = len(grid) def get_neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n: yield nx, ny def dfs(x, y): stack = [(x, y)] while stack: i, j = stack.pop() if (i, j) not in visited: visited.add((i, j)) grid[i][j] = 2 # Marking the island with a 2 for ni, nj in get_neighbors(i, j): if grid[ni][nj] == 1: stack.append((ni, nj)) q.append((i, j)) # For BFS later # Step 1: Find the first island and mark it found = False visited = set() q = deque() for i in range(n): if found: break for j in range(n): if grid[i][j] == 1: dfs(i, j) found = True break # Step 2: Use BFS to find the shortest path to the second island steps = 0 while q: for _ in range(len(q)): x, y = q.popleft() for nx, ny in get_neighbors(x, y): if grid[nx][ny] == 1: return steps if grid[nx][ny] == 0: grid[nx][ny] = 2 q.append((nx, ny)) steps += 1 return -1"},{"question":"def minStepsToEmptyPiles(nums): Returns the minimum number of steps required to empty all piles of candies. :param nums: List of non-negative integers representing the candies in each pile. :return: Minimum number of steps to empty all piles. >>> minStepsToEmptyPiles([4]) 4 >>> minStepsToEmptyPiles([0]) 0 >>> minStepsToEmptyPiles([3, 3, 3]) 9 >>> minStepsToEmptyPiles([1, 2, 3]) 6 >>> minStepsToEmptyPiles([]) 0 >>> minStepsToEmptyPiles([0, 0, 0]) 0 >>> minStepsToEmptyPiles([10, 5]) 15 >>> minStepsToEmptyPiles([100]) 100","solution":"import heapq def minStepsToEmptyPiles(nums): Returns the minimum number of steps required to empty all piles of candies. :param nums: List of non-negative integers representing the candies in each pile. :return: Minimum number of steps to empty all piles. # Initialize a max heap max_heap = [-candy for candy in nums if candy > 0] heapq.heapify(max_heap) steps = 0 while max_heap: # Remove the pile with the maximum candies max_candies = -heapq.heappop(max_heap) # If there are candies left, we have two options: # 1. Remove one candy remaining_candies = max_candies - 1 if remaining_candies > 0: heapq.heappush(max_heap, -remaining_candies) # Increment the number of steps steps += 1 return steps"},{"question":"def min_deletions_to_make_anagrams(s1: str, s2: str) -> int: Returns the minimum number of deletions required to make s1 and s2 anagrams of each other. >>> min_deletions_to_make_anagrams(\\"aabbcc\\", \\"abcabc\\") == 0 >>> min_deletions_to_make_anagrams(\\"abc\\", \\"def\\") == 6 >>> min_deletions_to_make_anagrams(\\"abc\\", \\"bcd\\") == 2 >>> min_deletions_to_make_anagrams(\\"abcdef\\", \\"abcdef\\") == 0 >>> min_deletions_to_make_anagrams(\\"\\", \\"\\") == 0 >>> min_deletions_to_make_anagrams(\\"abc\\", \\"\\") == 3 >>> min_deletions_to_make_anagrams(\\"\\", \\"def\\") == 3 >>> min_deletions_to_make_anagrams(\\"a\\" * 1000 + \\"b\\" * 2000, \\"a\\" * 1500 + \\"b\\" * 1500) == 1000","solution":"def min_deletions_to_make_anagrams(s1, s2): Returns the minimum number of deletions required to make s1 and s2 anagrams of each other. from collections import Counter counter1 = Counter(s1) counter2 = Counter(s2) deletions = 0 for char in set(counter1.keys()).union(set(counter2.keys())): deletions += abs(counter1[char] - counter2[char]) return deletions"},{"question":"def longest_power_of_two_subsequence(nums): Returns the length of the longest subsequence such that every element is a power of two. >>> longest_power_of_two_subsequence([1, 2, 4, 8, 16]) == 5 >>> longest_power_of_two_subsequence([]) == 0 >>> longest_power_of_two_subsequence([3, 5, 6, 7, 9]) == 0 >>> longest_power_of_two_subsequence([1, 3, 2, 9, 16, 8]) == 4 >>> longest_power_of_two_subsequence([8]) == 1 >>> longest_power_of_two_subsequence([3]) == 0 >>> longest_power_of_two_subsequence([1024, 2048, 4096, 8192, 16384, 32768]) == 6 >>> longest_power_of_two_subsequence([2, 2, 4, 4, 8, 8]) == 6","solution":"def longest_power_of_two_subsequence(nums): Returns the length of the longest subsequence such that every element is a power of two. def is_power_of_two(n): return n > 0 and (n & (n - 1)) == 0 longest_subseq = [num for num in nums if is_power_of_two(num)] return len(longest_subseq)"},{"question":"def min_steps_to_palindrome(s: str) -> int: Returns the minimum number of steps required to make the string a palindrome. In one step, you can change any character to any other character. Parameters: s (str): The input string. Returns: int: The minimum number of steps to make the string a palindrome. Examples: >>> min_steps_to_palindrome(\\"racecar\\") 0 >>> min_steps_to_palindrome(\\"ab\\") 1","solution":"def min_steps_to_palindrome(s): Returns the minimum number of steps required to make the string a palindrome. In one step, you can change any character to any other character. Parameters: s (str): The input string. Returns: int: The minimum number of steps to make the string a palindrome. n = len(s) steps = 0 for i in range(n // 2): if s[i] != s[n - 1 - i]: steps += 1 return steps"},{"question":"class MaxConsecutiveSum: def __init__(self, nums, k): Initialize the object with the integer array nums and the integer k. Args: nums (List[int]): list of integers k (int): number of consecutive elements to consider self.nums = nums self.k = k def findMaxConsecutiveSum(self) -> int: Returns the maximum sum of k consecutive elements in nums. Returns: int: maximum sum of k consecutive elements >>> mcs = MaxConsecutiveSum([1, 2, 3, 4, 5], 2) >>> mcs.findMaxConsecutiveSum() 9 >>> mcs = MaxConsecutiveSum([1, 2, 3, 4, 5], 1) >>> mcs.findMaxConsecutiveSum() 5 >>> mcs = MaxConsecutiveSum([1, 2, 3, 4, 5], 5) >>> mcs.findMaxConsecutiveSum() 15 >>> mcs = MaxConsecutiveSum([], 3) >>> mcs.findMaxConsecutiveSum() 0 >>> mcs = MaxConsecutiveSum([1, 2, 3], 4) >>> mcs.findMaxConsecutiveSum() 0 >>> mcs = MaxConsecutiveSum([-1, -2, -3, -4], 2) >>> mcs.findMaxConsecutiveSum() -3 >>> mcs = MaxConsecutiveSum([0, 0, 0, 0], 2) >>> mcs.findMaxConsecutiveSum() 0","solution":"class MaxConsecutiveSum: def __init__(self, nums, k): self.nums = nums self.k = k def findMaxConsecutiveSum(self): if not self.nums or self.k <= 0 or self.k > len(self.nums): return 0 # Calculate the sum of the first 'k' elements max_sum = current_sum = sum(self.nums[:self.k]) # Use a sliding window to find the maximum sum of 'k' consecutive elements for i in range(self.k, len(self.nums)): current_sum += self.nums[i] - self.nums[i - self.k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def single_number(nums): Returns the integer that appears only once in a non-empty array where each integer appears twice except for one that appears only once. The algorithm has a linear runtime complexity and uses only constant extra space. >>> single_number([2, 3, 2, 4, 4]) == 3 >>> single_number([-1, -1, -2, -2, -3]) == -3 >>> single_number([-1, 1, -1, 2, 2]) == 1 >>> single_number([0]) == 0 >>> single_number([7]) == 7 >>> single_number([1, 2, 1, 2, 3, 4, 4]) == 3","solution":"def single_number(nums): Returns the integer that appears only once in a non-empty array where each integer appears twice except for one that appears only once. The algorithm has a linear runtime complexity and uses only constant extra space. unique = 0 for num in nums: unique ^= num return unique"},{"question":"def is_eardition_sequence_possible(arr): Determines whether it is possible to rearrange the array to form an eardition sequence. Parameters: arr (list): A list of integers. Returns: list: A valid permutation of the array that forms an eardition sequence, or an empty list if not possible.","solution":"def is_eardition_sequence_possible(arr): Determines whether it is possible to rearrange the array to form an eardition sequence. Parameters: arr (list): A list of integers. Returns: list: A valid permutation of the array that forms an eardition sequence, or an empty list if not possible. if not arr: return [] # Sort the array arr.sort() # Check if it's possible to rearrange to form an eardition sequence for i in range(1, len(arr)): if abs(arr[i] - arr[i-1]) > 1: return [] return arr"},{"question":"def can_transform(s1: str, s2: str) -> bool: Determine if you can transform s1 into s2 by performing some set of operations. Each operation consists of choosing a character in s1 and replacing it with any other lowercase English letter. The operation can be performed at most once for each character in s1. Return true if you can transform s1 into s2 and false otherwise. Note that the lengths of s1 and s2 are always the same. >>> can_transform(\\"abc\\", \\"abc\\") == True >>> can_transform(\\"abc\\", \\"acc\\") == True >>> can_transform(\\"abcde\\", \\"fghij\\") == True >>> can_transform(\\"abcdefghijklmnopqrstuvwxyz\\", \\"zyxwvutsrqponmlkjihgfedcba\\") == True >>> can_transform(\\"ab\\", \\"bc\\") == True >>> can_transform(\\"abcd\\", \\"abc\\") == False >>> can_transform(\\"abcd\\", \\"abce\\") == True","solution":"def can_transform(s1, s2): Determines if s1 can be transformed into s2 by performing an operation that replaces each character in s1 with any other lowercase English letter at most once. if len(s1) != len(s2): return False # Use set to track unique transformations seen_pairs = set() for c1, c2 in zip(s1, s2): if c1 != c2: seen_pairs.add((c1, c2)) return len(seen_pairs) <= 26"},{"question":"class EventScheduler: def __init__(self): Initializes the scheduler with no events. pass def addEvent(self, startTime: int, duration: int) -> bool: Tries to add an event with the given startTime and duration. If the event does not conflict with any existing events, it adds the event to the schedule and returns True. Otherwise, it returns False. >>> scheduler = EventScheduler() >>> scheduler.addEvent(1, 2) True >>> scheduler.addEvent(2, 2) False pass def getAllEvents(self): Returns a list of all currently scheduled events as tuples (startTime, duration). >>> scheduler = EventScheduler() >>> scheduler.addEvent(1, 2) True >>> scheduler.addEvent(4, 1) True >>> scheduler.getAllEvents() [(1, 2), (4, 1)] pass","solution":"class EventScheduler: def __init__(self): self.events = [] def addEvent(self, startTime, duration): Tries to add an event with the given startTime and duration. If the event does not conflict with any existing events, it adds the event to the schedule and returns True. Otherwise, it returns False. new_event_end = startTime + duration for event_start, event_duration in self.events: event_end = event_start + event_duration if not (new_event_end <= event_start or startTime >= event_end): return False self.events.append((startTime, duration)) self.events.sort() # keep events sorted for easier management return True def getAllEvents(self): Returns a list of all currently scheduled events as tuples (startTime, duration). return self.events"},{"question":"def max_depth(s: str) -> int: Returns the maximum depth of nested parentheses in the given valid parentheses string s. >>> max_depth(\\"()\\") 1 >>> max_depth(\\"((()))\\") 3 >>> max_depth(\\"()()()\\") 1 >>> max_depth(\\"(()(()))\\") 3 >>> max_depth(\\"(()())\\") 2 >>> max_depth(\\"\\") 0","solution":"def max_depth(s: str) -> int: Returns the maximum depth of nested parentheses in the given valid parentheses string s. current_depth = 0 max_depth = 0 for char in s: if char == '(': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == ')': current_depth -= 1 return max_depth"},{"question":"from collections import OrderedDict class ProductCache: def __init__(self, capacity): Initializes the cache with a capacity for N products. pass def addProduct(self, productId, productName): Adds a product to the cache or updates an existing product's name. pass def accessProduct(self, productId): Accesses the product identified by productId making it the most recently accessed product. pass def getProducts(self): Retrieves all products currently in the cache sorted by the most recently accessed first. pass # Unit Tests def test_product_cache_initialization(): pc = ProductCache(3) assert pc.getProducts() == [] def test_product_cache_add_product(): pc = ProductCache(3) pc.addProduct(1, \\"Product1\\") assert pc.getProducts() == [\\"Product1\\"] pc.addProduct(2, \\"Product2\\") assert pc.getProducts() == [\\"Product2\\", \\"Product1\\"] pc.addProduct(3, \\"Product3\\") assert pc.getProducts() == [\\"Product3\\", \\"Product2\\", \\"Product1\\"] def test_product_cache_eviction(): pc = ProductCache(3) pc.addProduct(1, \\"Product1\\") pc.addProduct(2, \\"Product2\\") pc.addProduct(3, \\"Product3\\") pc.addProduct(4, \\"Product4\\") assert pc.getProducts() == [\\"Product4\\", \\"Product3\\", \\"Product2\\"] def test_product_cache_access_product(): pc = ProductCache(3) pc.addProduct(1, \\"Product1\\") pc.addProduct(2, \\"Product2\\") pc.addProduct(3, \\"Product3\\") pc.accessProduct(1) assert pc.getProducts() == [\\"Product1\\", \\"Product3\\", \\"Product2\\"] def test_product_cache_update_product_name(): pc = ProductCache(3) pc.addProduct(1, \\"Product1\\") pc.addProduct(2, \\"Product2\\") pc.addProduct(3, \\"Product3\\") pc.addProduct(1, \\"UpdatedProduct1\\") assert pc.getProducts() == [\\"UpdatedProduct1\\", \\"Product3\\", \\"Product2\\"]","solution":"from collections import OrderedDict class ProductCache: def __init__(self, capacity): Initializes the cache with a capacity for N products. self.capacity = capacity self.cache = OrderedDict() def addProduct(self, productId, productName): Adds a product to the cache or updates an existing product's name. if productId in self.cache: # Update product name and move it to end (most recently accessed) self.cache.move_to_end(productId) self.cache[productId] = productName if len(self.cache) > self.capacity: # Remove the least recently accessed product self.cache.popitem(last=False) def accessProduct(self, productId): Accesses the product identified by productId making it the most recently accessed product. if productId in self.cache: # Move the accessed product to the end (most recently accessed) self.cache.move_to_end(productId) def getProducts(self): Retrieves all products currently in the cache sorted by the most recently accessed first. return [self.cache[productId] for productId in reversed(self.cache)]"},{"question":"from collections import deque def max_sliding_window(nums, k): Return the maximums of each sliding window of size k in the array nums. Args: nums: List of integers. k: Integer, size of the sliding window. Returns: List of integers representing the maximums of each sliding window of size k. >>> max_sliding_window([1,3,-1,-3,5,3,6,7], 3) == [3,3,5,5,6,7] >>> max_sliding_window([1], 1) == [1] >>> max_sliding_window([1,-1], 1) == [1, -1] >>> max_sliding_window([9, 11], 2) == [11] >>> max_sliding_window([4, -2], 2) == [4]","solution":"from collections import deque def max_sliding_window(nums, k): Return the maximums of each sliding window of size k in the array nums. Args: nums: List of integers. k: Integer, size of the sliding window. Returns: List of integers representing the maximums of each sliding window of size k. if not nums or k == 0: return [] if k == 1: return nums # Every number in the window is the max if window size is 1 dq = deque() # stores indices result = [] for i in range(len(nums)): # Remove indexes of elements not from sliding window if dq and dq[0] < i - k + 1: dq.popleft() # Remove from dq indexes of all elements which are smaller than current element nums[i] while dq and nums[dq[-1]] < nums[i]: dq.pop() # Add current element at the end of dq dq.append(i) # The element at the front of the deque is the largest element of the previous window if i >= k - 1: result.append(nums[dq[0]]) return result"},{"question":"def longest_subarray(nums: List[int], k: int) -> int: Given an array of integers \`nums\` and an integer \`k\`, return the length of the longest subarray where the difference between the maximum and minimum elements is at most \`k\`. >>> longest_subarray([8, 2, 4, 7], 4) 2 >>> longest_subarray([10, 1, 2, 4, 7, 2], 5) 4 >>> longest_subarray([4, 2, 2, 2, 4, 4, 2, 2], 0) 3 >>> longest_subarray([1], 0) 1 >>> longest_subarray([], 10) 0 >>> longest_subarray([1, 5, 6, 7, 8, 10, 6, 5, 6], 4) 5 Additional edge cases: >>> longest_subarray([1, 1, 1, 1], 0) 4 >>> longest_subarray([1, 2, 3, 4, 5], 100) 5 >>> longest_subarray([1, 100, 1, 100], 1) 1","solution":"from collections import deque def longest_subarray(nums, k): max_deque = deque() min_deque = deque() left = 0 max_len = 0 for right, num in enumerate(nums): while max_deque and nums[max_deque[-1]] < num: max_deque.pop() while min_deque and nums[min_deque[-1]] > num: min_deque.pop() max_deque.append(right) min_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > k: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def swap_pairs(head: ListNode) -> ListNode: Swap every two adjacent nodes of the linked list. :param head: ListNode, head of the linked list. :return: ListNode, head of the modified linked list. >>> def list_to_python_list(head): ... lst = [] ... while head: ... lst.append(head.val) ... head = head.next ... return lst >>> def python_list_to_list(lst): ... dummy = ListNode() ... current = dummy ... for item in lst: ... current.next = ListNode(item) ... current = current.next ... return dummy.next >>> list_to_python_list(swap_pairs(python_list_to_list([1, 2, 3, 4]))) == [2, 1, 4, 3] True >>> swap_pairs(None) is None True >>> head = ListNode(1) >>> swap_pairs(head).val == 1 True >>> swap_pairs(head).next is None True >>> list_to_python_list(swap_pairs(python_list_to_list([1, 2]))) == [2, 1] True >>> list_to_python_list(swap_pairs(python_list_to_list([1, 2, 3, 4, 5]))) == [2, 1, 4, 3, 5] True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def swap_pairs(head): Swap every two adjacent nodes of the linked list. :param head: ListNode, head of the linked list. :return: ListNode, head of the modified linked list. dummy = ListNode(0) dummy.next = head prev = dummy while prev.next and prev.next.next: first = prev.next second = prev.next.next first.next = second.next second.next = first prev.next = second prev = first return dummy.next"},{"question":"def count_slices_with_target_sum(nums: List[int], targetSum: int) -> int: Returns the number of contiguous subarrays (slices) whose sum equals targetSum. >>> count_slices_with_target_sum([5], 5) 1 >>> count_slices_with_target_sum([5], 3) 0 >>> count_slices_with_target_sum([1, 2, 3], 3) 2 >>> count_slices_with_target_sum([1, 1, 1, 1], 2) 3 >>> count_slices_with_target_sum([1, 2, 3], 7) 0 >>> count_slices_with_target_sum([1, 1, 1, 1], 1) 4 >>> count_slices_with_target_sum([1, 2, -1, 2, 3], 3) 3 >>> count_slices_with_target_sum([-1, -1, -1], -2) 2","solution":"def count_slices_with_target_sum(nums, targetSum): Returns the number of contiguous subarrays (slices) whose sum equals targetSum. :param nums: List[int] - List of integers. :param targetSum: int - The desired sum of subarrays. :return: int - Number of contiguous subarrays that add up to targetSum. count = 0 for start in range(len(nums)): curr_sum = 0 for end in range(start, len(nums)): curr_sum += nums[end] if curr_sum == targetSum: count += 1 return count"},{"question":"def merge_sorted_arrays(arr1, arr2, k): Returns the first k elements that would appear in the sorted order of the merged arrays arr1 and arr2. If k is larger than the total length of merged arrays, return all elements of the merged arrays in sorted order. Parameters: arr1 (list of int): first sorted integer array arr2 (list of int): second sorted integer array k (int): number of elements to return Returns: list of int: first k elements in sorted order of the merged arrays >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6], 3) [1, 2, 3] >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6], 6) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6], 10) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 2, 3], [4, 5, 6], 4) [1, 2, 3, 4] >>> merge_sorted_arrays([], [1, 2, 3], 2) [1, 2] >>> merge_sorted_arrays([1, 2, 3], [], 2) [1, 2] >>> merge_sorted_arrays([], [], 3) []","solution":"def merge_sorted_arrays(arr1, arr2, k): Returns the first k elements that would appear in the sorted order of the merged arrays arr1 and arr2. If k is larger than the total length of merged arrays, return all elements of the merged arrays in sorted order. Parameters: arr1 (list of int): first sorted integer array arr2 (list of int): second sorted integer array k (int): number of elements to return Returns: list of int: first k elements in sorted order of the merged arrays merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2) and len(merged) < k: if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 while i < len(arr1) and len(merged) < k: merged.append(arr1[i]) i += 1 while j < len(arr2) and len(merged) < k: merged.append(arr2[j]) j += 1 return merged"},{"question":"from typing import List def max_unique_integers_after_removal(arr: List[int], d: int) -> int: Returns the maximum number of unique integers after removing exactly d elements from the array. >>> max_unique_integers_after_removal([1, 2, 3, 4, 5], 2) 3 >>> max_unique_integers_after_removal([1, 1, 2, 2, 3], 2) 2 >>> max_unique_integers_after_removal([1, 1, 1, 1, 1], 3) 1 >>> max_unique_integers_after_removal([4, 4, 4, 3, 3, 2, 2, 1, 1], 4) 2 >>> max_unique_integers_after_removal([1, 2], 1) 1","solution":"def max_unique_integers_after_removal(arr, d): Returns the maximum number of unique integers after removing exactly d elements from the array. from collections import Counter # Count the frequency of each element freq = Counter(arr) # Get a list of frequencies, sorted in decreasing order freq_list = sorted(freq.values(), reverse=True) # Remove d elements starting from the least frequent ones while d > 0 and freq_list: # If the maximum number of elements we can remove is more than \`d\`, we just reduce \`d\` to 0 if freq_list[-1] <= d: d -= freq_list.pop() else: freq_list[-1] -= d d = 0 # Number of unique items left will be the length of the frequencies list that are not zero return len(freq_list)"},{"question":"def max_apples(nums: List[int]) -> int: Returns the maximum number of apples that can be collected without picking from two adjacent buckets. >>> max_apples([]) == 0 >>> max_apples([5]) == 5 >>> max_apples([1, 2]) == 2 >>> max_apples([10, 5]) == 10 >>> max_apples([1, 2, 3]) == 4 >>> max_apples([2, 1, 4]) == 6 >>> max_apples([1, 2, 3, 1]) == 4 >>> max_apples([2, 7, 9, 3, 1]) == 12 >>> max_apples([10, 1, 1, 10]) == 20 >>> max_apples([5, 5, 10, 100, 10, 5]) == 110 >>> max_apples([3, 2, 5, 10, 7]) == 15","solution":"def max_apples(nums): Returns the maximum number of apples that can be collected without picking from two adjacent buckets. if not nums: return 0 if len(nums) == 1: return nums[0] n = len(nums) dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def product_except_self(nums): Given a 0-indexed integer array nums, which contains n integers, return a new array result where result[i] is equal to the product of all the elements of nums except nums[i], without using division operations. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5]) [1] >>> product_except_self([2, 3]) [3, 2] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([1, -2, 3, -4]) [24, -12, 8, -6]","solution":"def product_except_self(nums): Given an array nums of n integers, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. n = len(nums) result = [1] * n left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] right_product = 1 for i in range(n - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def find_dominant_index(arr): Returns the index of the dominant element if one exists, otherwise returns -1. >>> find_dominant_index([3, 6, 1, 0]) 1 >>> find_dominant_index([1, 2, 3, 4]) -1","solution":"def find_dominant_index(arr): Returns the index of the dominant element if one exists, otherwise returns -1. if not arr: return -1 max_value = max(arr) max_index = arr.index(max_value) for i in range(len(arr)): if i != max_index and arr[i] * 2 > max_value: return -1 return max_index"},{"question":"def smallest_length_after_operations(s: str) -> int: Returns the smallest possible length of the string after performing the given operations. >>> smallest_length_after_operations(\\"aaaa\\") 4 >>> smallest_length_after_operations(\\"bbbb\\") 4 >>> smallest_length_after_operations(\\"abab\\") 0 >>> smallest_length_after_operations(\\"aaabbbab\\") 0 >>> smallest_length_after_operations(\\"bbaaabbb\\") 2 >>> smallest_length_after_operations(\\"abababababababab\\") 0 >>> smallest_length_after_operations(\\"\\") 0","solution":"def smallest_length_after_operations(s): Returns the smallest possible length of the string after performing the given operations. # Counting the number of 'a's and 'b's in the string count_a = s.count('a') count_b = s.count('b') # The smallest length after applying the operations is the absolute difference return abs(count_a - count_b)"},{"question":"def longest_palindromic_length(input_str: str) -> int: Given a string 'input_str' consisting of lowercase English letters and '*' characters, return the length of the longest possible palindromic string that can be formed by replacing each '*' with any lowercase English letter. >>> longest_palindromic_length(\\"racecar\\") 7 >>> longest_palindromic_length(\\"race*ar\\") 7 >>> longest_palindromic_length(\\"*****\\") 5 >>> longest_palindromic_length(\\"a*b*a\\") 5 >>> longest_palindromic_length(\\"ab*ba\\") 5 >>> longest_palindromic_length(\\"abac\\") 0 >>> longest_palindromic_length(\\"\\") 0 >>> longest_palindromic_length(\\"a\\") 1","solution":"def longest_palindromic_length(input_str): Returns the length of the longest possible palindromic string that can be formed by replacing '*' characters with any lowercase English letters. Args: input_str (str): The input string containing lowercase letters and '*' characters. Returns: int: The length of the longest possible palindromic string. n = len(input_str) # Check from both ends towards the middle left, right = 0, n - 1 while left <= right: if input_str[left] != input_str[right] and input_str[left] != '*' and input_str[right] != '*': # If both characters are different and not '*', cannot form a palindrome return 0 left += 1 right -= 1 # If we exit cleanly, the whole string can be made into a palindrome return n"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum among all possible segments of the array nums. >>> max_subarray_sum([1, 2, 3, 4]) == 10 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([0, -3, 1, 1, 1]) == 3 >>> max_subarray_sum([5]) == 5 >>> max_subarray_sum([-5]) == -5 >>> max_subarray_sum([]) == 0","solution":"def max_subarray_sum(nums): Returns the maximum sum among all possible segments of the array nums. if not nums: return 0 max_sum = nums[0] current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_unique_integers(nums, k): Returns the maximum number of unique integers among all possible contiguous subarrays of size k. >>> max_unique_integers([1, 2, 3, 1, 2, 3], 3) 3 >>> max_unique_integers([1, 2, 3, 4], 5) 4 >>> max_unique_integers([1, 2, 2, 3, 4, 5, 5], 3) 3 >>> max_unique_integers([1, 1, 1, 1], 2) 1 >>> max_unique_integers([1, 2, 3, 4, 5], 2) 2 >>> max_unique_integers([1, 2, 3, 4, 2, 1], 4) 4 pass","solution":"def max_unique_integers(nums, k): Returns the maximum number of unique integers among all possible contiguous subarrays of size k. if k > len(nums): return len(set(nums)) from collections import defaultdict current_counts = defaultdict(int) max_unique = 0 unique_count = 0 # Initialize the first window for i in range(k): if current_counts[nums[i]] == 0: unique_count += 1 current_counts[nums[i]] += 1 max_unique = unique_count # Slide the window for i in range(k, len(nums)): # Remove the element going out if current_counts[nums[i - k]] == 1: unique_count -= 1 current_counts[nums[i - k]] -= 1 # Add the new element if current_counts[nums[i]] == 0: unique_count += 1 current_counts[nums[i]] += 1 # Update the maximum unique count max_unique = max(max_unique, unique_count) return max_unique"},{"question":"def longest_uniform_substring_length(s: str) -> int: Given a string s consisting of exactly two distinct characters, return the length of the longest possible substring that consists of only one unique character. :param s: str - input string consisting of exactly two distinct characters :return: int - length of the longest substring with one unique character >>> longest_uniform_substring_length(\\"aaaa\\") 4 >>> longest_uniform_substring_length(\\"ababab\\") 3 >>> longest_uniform_substring_length(\\"aaaabbbb\\") 4 >>> longest_uniform_substring_length(\\"abcabc\\") 2 >>> longest_uniform_substring_length(\\"ab\\") 1 >>> longest_uniform_substring_length(\\"\\") 0","solution":"def longest_uniform_substring_length(s): Given a string s consisting of exactly two distinct characters, return the length of the longest possible substring that consists of only one unique character. :param s: str - input string consisting of exactly two distinct characters :return: int - length of the longest substring with one unique character if not s: return 0 from collections import Counter counts = Counter(s) longest_length = max(counts.values()) return longest_length"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle(head): Detects the node at the beginning of the cycle in the linked list. If there is no cycle, return None. :param head: ListNode - The head of the linked list. :return: ListNode or None - The node where the cycle begins, or None if there is no cycle. pass def test_no_cycle(): head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) assert detect_cycle(head) == None def test_cycle_at_head(): head = ListNode(1) second = ListNode(2) third = ListNode(3) fourth = ListNode(4) head.next = second second.next = third third.next = fourth fourth.next = head # Cycle assert detect_cycle(head) == head def test_cycle_at_middle(): head = ListNode(1) second = ListNode(2) third = ListNode(3) fourth = ListNode(4) head.next = second second.next = third third.next = fourth fourth.next = second # Cycle assert detect_cycle(head) == second def test_single_element_no_cycle(): head = ListNode(1) assert detect_cycle(head) == None def test_single_element_with_cycle(): head = ListNode(1) head.next = head # Cycle assert detect_cycle(head) == head def test_longer_list_with_cycle(): head = ListNode(1) second = ListNode(2) third = ListNode(3) fourth = ListNode(4) fifth = ListNode(5) head.next = second second.next = third third.next = fourth fourth.next = fifth fifth.next = third # Cycle assert detect_cycle(head) == third","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle(head): Detects the node at the beginning of the cycle in the linked list. If there is no cycle, return None. :param head: ListNode - The head of the linked list. :return: ListNode or None - The node where the cycle begins, or None if there is no cycle. if not head or not head.next: return None slow, fast = head, head # Detect if there is a cycle using the slow and fast pointers while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # No cycle return None # Find the start of the cycle while head != slow: head = head.next slow = slow.next return head"},{"question":"from collections import deque from typing import List def longest_subarray(nums: List[int], limit: int) -> int: Finds the longest contiguous subarray such that the absolute difference between the maximum and minimum elements in this subarray is less than or equal to a given integer limit. Parameters: nums (List[int]): The input array of integers. limit (int): The maximum allowed absolute difference between the maximum and minimum elements in the subarray. Returns: int: The length of the longest such subarray. >>> longest_subarray([8, 2, 4, 7], 4) 2 >>> longest_subarray([10, 1, 2, 4, 7, 2], 5) 4 >>> longest_subarray([4, 2, 2, 2, 4, 4, 2, 2], 0) 3 >>> longest_subarray([1], 0) 1 >>> longest_subarray([1, 1, 1, 1], 0) 4 >>> longest_subarray([10, 20, 30, 40], 5) 1 >>> large_input = list(range(100000)) >>> longest_subarray(large_input, 5000) 5001 def test_longest_subarray(): assert longest_subarray([8, 2, 4, 7], 4) == 2 assert longest_subarray([10, 1, 2, 4, 7, 2], 5) == 4 assert longest_subarray([4, 2, 2, 2, 4, 4, 2, 2], 0) == 3 assert longest_subarray([1], 0) == 1 assert longest_subarray([1, 1, 1, 1], 0) == 4 assert longest_subarray([10, 20, 30, 40], 5) == 1 large_input = list(range(100000)) assert longest_subarray(large_input, 5000) == 5001","solution":"from collections import deque def longest_subarray(nums, limit): Finds the longest contiguous subarray such that the absolute difference between the maximum and minimum elements in this subarray is less than or equal to a given integer limit. Parameters: nums (List[int]): The input array of integers. limit (int): The maximum allowed absolute difference between the maximum and minimum elements in the subarray. Returns: int: The length of the longest such subarray. min_deque = deque() max_deque = deque() left = 0 max_len = 0 for right in range(len(nums)): while min_deque and nums[right] < nums[min_deque[-1]]: min_deque.pop() while max_deque and nums[right] > nums[max_deque[-1]]: max_deque.pop() min_deque.append(right) max_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > limit: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"from typing import List def min_max_work(tasks: List[int], d: int) -> int: Return the minimum possible maximum task time you have to work on any single day, including the extra days, to complete all the tasks within the given time limit. >>> min_max_work([7, 2, 5, 10, 8], 2) 18 >>> min_max_work([7, 2, 5, 10, 8], 5) 10 >>> min_max_work([15], 3) 15 >>> min_max_work([5, 5, 5, 5], 2) 10 >>> min_max_work([1, 1, 1, 1, 1, 1, 1, 1], 1) 8","solution":"def min_max_work(tasks, d): def feasible(capacity): days = 1 total = 0 for task in tasks: if total + task <= capacity: total += task else: days += 1 total = task return days <= d left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if feasible(mid): right = mid else: left = mid + 1 return left"},{"question":"def minMeetings(n: int, managers: List[int]) -> int: Determine the minimum number of meetings required for all employees to receive information from the CEO in a hierarchical company structure. >>> minMeetings(1, []) 0 >>> minMeetings(5, [0, 1, 2, 3]) 4 >>> minMeetings(7, [0, 0, 1, 1, 2, 2]) 2 >>> minMeetings(6, [0, 0, 0, 0, 0]) 1 >>> minMeetings(6, [0, 0, 1, 1, 3]) 3","solution":"def minMeetings(n, managers): from collections import deque, defaultdict # Build the tree structure from the managers list tree = defaultdict(list) for i, manager in enumerate(managers): tree[manager].append(i + 1) # BFS to determine the minimum number of meetings required queue = deque([(0, 0)]) # (current employee, current level) max_depth = 0 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) for subordinate in tree[node]: queue.append((subordinate, depth + 1)) return max_depth"},{"question":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root: Optional[TreeNode]) -> List[List[int]]: Returns the level order traversal of a binary tree. Args: root (TreeNode): The root of the binary tree. Returns: List[List[int]]: A list of lists where each sublist contains the values of the nodes at the respective level. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> levelOrder(root) [[3], [9, 20], [15, 7]] >>> levelOrder(None) []","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root): Returns the level order traversal of a binary tree. Args: root (TreeNode): The root of the binary tree. Returns: List[List[int]]: A list of lists where each sublist contains the values of the nodes at the respective level. if not root: return [] result = [] queue = deque([root]) while queue: level = [] for _ in range(len(queue)): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"def words_from_string(s: str, words: List[str]) -> List[str]: Returns the list of words from the input list that can be formed by characters from string s. The result list is sorted in lexicographical order. >>> words_from_string(\\"a\\", [\\"a\\", \\"b\\"]) ['a'] >>> words_from_string(\\"abc\\", [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"]) ['a', 'ab', 'abc'] from solution import words_from_string def test_single_character_words(): assert words_from_string(\\"a\\", [\\"a\\", \\"b\\"]) == [\\"a\\"] def test_multiple_character_words(): assert words_from_string(\\"abc\\", [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"]) == [\\"a\\", \\"ab\\", \\"abc\\"] def test_no_matches(): assert words_from_string(\\"xyz\\", [\\"a\\", \\"b\\", \\"c\\"]) == [] def test_empty_string(): assert words_from_string(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) == [] def test_empty_words_list(): assert words_from_string(\\"abc\\", []) == [] def test_repeated_characters(): assert words_from_string(\\"aabbcc\\", [\\"abc\\", \\"aabb\\", \\"aabbb\\"]) == [\\"aabb\\", \\"abc\\"] def test_exact_characters_multiple_words(): assert words_from_string(\\"aabbcc\\", [\\"abc\\", \\"cab\\", \\"acb\\"]) == [\\"abc\\", \\"acb\\", \\"cab\\"] def test_mixed_case(): assert words_from_string(\\"AaBbCc\\", [\\"abc\\", \\"ABC\\", \\"aBc\\"]) == [\\"ABC\\", \\"aBc\\", \\"abc\\"]","solution":"def can_form_word(word, s): s_char_count = {} for char in s: if char in s_char_count: s_char_count[char] += 1 else: s_char_count[char] = 1 for char in word: if char in s_char_count and s_char_count[char] > 0: s_char_count[char] -= 1 else: return False return True def words_from_string(s, words): Returns the list of words from the input list that can be formed by characters from string s. The result list is sorted in lexicographical order. result = [] for word in words: if can_form_word(word, s): result.append(word) return sorted(result)"},{"question":"def count_palindromic_substrings(s: str) -> int: Implement a function that takes a string \`s\` consisting of lowercase English letters. The function should return the number of palindromic substrings in \`s\`. A string is palindromic if it reads the same forward and backward. Note that the single-character substrings are palindromic by default. >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the given string s. n = len(s) count = 0 def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for i in range(n): # Count odd length palindromes centered at i expand_around_center(i, i) # Count even length palindromes centered at i and i + 1 expand_around_center(i, i + 1) return count"},{"question":"def can_form_sentence(s: str, words: List[int]) -> bool: Given a string \`s\` representing a sentence consisting of lowercase letters and spaces, and an integer array \`words\` where each element is the length of a word that should appear in the sentence, determine if the sentence can be constructed by following the exact order and lengths of the words specified in the \`words\` array. Each word in \`words\` must be separated by exactly one space. Returns True if the sentence can be constructed by following the exact order and lengths of the words specified in the \`words\` array, otherwise returns False. >>> can_form_sentence(\\"the quick brown fox\\", [3, 5, 5, 3]) True >>> can_form_sentence(\\"the quick brown fox\\", [3, 4, 5, 3]) False >>> can_form_sentence(\\"the quick brown brown fox\\", [3, 5, 5, 3]) False >>> can_form_sentence(\\"the quick brown fox\\", [3, 5, 5, 3, 3]) False >>> can_form_sentence(\\"\\", []) True >>> can_form_sentence(\\"\\", [3]) False >>> can_form_sentence(\\"hello\\", []) False","solution":"def can_form_sentence(s, words): Returns true if the sentence can be constructed by following the exact order and lengths of the words specified in the \`words\` array, otherwise returns false. s_split = s.split() if len(s_split) != len(words): return False for i, word in enumerate(s_split): if len(word) != words[i]: return False return True"},{"question":"from typing import List, Tuple def pacific_atlantic(grid: List[List[int]]) -> List[Tuple[int, int]]: Given a grid of elevations, find all coordinates where water can flow from that point to any border of the grid. Args: grid (List[List[int]]): A 2D grid representing the elevation map. Returns: List[Tuple[int, int]]: A list of coordinates where water can flow to the border. Example: >>> grid = [ ... [1, 2, 2, 3, 5], ... [3, 2, 3, 4, 4], ... [2, 4, 5, 3, 1], ... [6, 7, 1, 4, 5], ... [5, 1, 1, 2, 4] ... ] >>> sorted(pacific_atlantic(grid)) [(0, 4), (1, 3), (1, 4), (2, 2), (3, 0), (3, 1), (4, 0)] >>> grid = [ ... [1, 1], ... [1, 1] ... ] >>> sorted(pacific_atlantic(grid)) [(0, 0), (0, 1), (1, 0), (1, 1)] >>> grid = [ ... [10, 10, 10], ... [10, 1, 10], ... [10, 10, 10] ... ] >>> sorted(pacific_atlantic(grid)) [(0, 0), (0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)] >>> grid = [ ... [1] ... ] >>> sorted(pacific_atlantic(grid)) [(0, 0)]","solution":"def pacific_atlantic(grid): if not grid or not grid[0]: return [] m, n = len(grid), len(grid[0]) def bfs(starts): visited = set(starts) queue = starts[:] while queue: i, j = queue.pop(0) for di, dj in ((0, 1), (1, 0), (0, -1), (-1, 0)): ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visited and grid[ni][nj] >= grid[i][j]: visited.add((ni, nj)) queue.append((ni, nj)) return visited pacific_starts = [(i, 0) for i in range(m)] + [(0, j) for j in range(1, n)] atlantic_starts = [(i, n - 1) for i in range(m)] + [(m - 1, j) for j in range(n - 1)] pacific_reachable = bfs(pacific_starts) atlantic_reachable = bfs(atlantic_starts) return list(pacific_reachable.intersection(atlantic_reachable))"},{"question":"class IntervalManager: A class to manage a set of intervals on the number line and merge overlapping intervals. Usage: >>> im = IntervalManager() >>> im.addInterval([1, 3]) >>> im.addInterval([2, 5]) >>> im.getMergedIntervals() [[1, 5]] >>> im.addInterval([6, 8]) >>> im.getMergedIntervals() [[1, 5], [6, 8]] Supported methods: - addInterval(interval: List[int]) -> None: Adds a new interval to the set. - getMergedIntervals() -> List[List[int]]: Returns a list of merged intervals. def __init__(self): pass # Initializes the object with an empty set of intervals def addInterval(self, interval: List[int]) -> None: pass # Adds a new interval to the set def getMergedIntervals(self) -> List[List[int]]: pass # Returns a list of merged intervals","solution":"class IntervalManager: def __init__(self): self.intervals = [] def addInterval(self, interval): self.intervals.append(interval) self.intervals.sort() def getMergedIntervals(self): if not self.intervals: return [] merged = [] for interval in self.intervals: if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"def compare_version(s: str, t: str) -> int: Compare two version strings, return 1 if s > t, -1 if s < t, and 0 if s == t. Args: s (str): first version string. t (str): second version string. Returns: int: comparison result. >>> compare_version(\\"1.0\\", \\"1.0\\") == 0 >>> compare_version(\\"1.0\\", \\"1.1\\") == -1 >>> compare_version(\\"1.2\\", \\"1.1\\") == 1 >>> compare_version(\\"1.0.1\\", \\"1.0.0\\") == 1 >>> compare_version(\\"1.0\\", \\"1\\") == 0 >>> compare_version(\\"3.5\\", \\"3.05.0\\") == 0 >>> compare_version(\\"1.0.1\\", \\"1\\") == 1 >>> compare_version(\\"1\\", \\"1.0.1\\") == -1 >>> compare_version(\\"01\\", \\"1\\") == 0 >>> compare_version(\\"1.0.0.0\\", \\"1\\") == 0 >>> compare_version(\\"1.01\\", \\"1.001\\") == 0 >>> compare_version(\\"1.0.0.1\\", \\"1.0.0.01\\") == 0 >>> compare_version(\\"1.2.3.4\\", \\"1.2.3.5\\") == -1 >>> compare_version(\\"2.3.4.5\\", \\"1.2.3.4\\") == 1 >>> compare_version(\\"1.0.0.0.1\\", \\"1\\") == 1 >>> compare_version(\\"1.2.3.4.5.6.7.8.9\\", \\"1.2.3.4.5.6.7.8.10\\") == -1 >>> compare_version(\\"5.5.5.5.5\\", \\"5.5.5.5.5\\") == 0","solution":"def compare_version(s, t): Compare two version strings, return 1 if s > t, -1 if s < t, and 0 if s == t. Args: s (str): first version string. t (str): second version string. Returns: int: comparison result. s_segments = s.split('.') t_segments = t.split('.') # Pad the shorter list with zeros max_length = max(len(s_segments), len(t_segments)) s_segments += ['0'] * (max_length - len(s_segments)) t_segments += ['0'] * (max_length - len(t_segments)) for s_seg, t_seg in zip(s_segments, t_segments): s_num, t_num = int(s_seg), int(t_seg) if s_num > t_num: return 1 elif s_num < t_num: return -1 return 0"},{"question":"def first_missing_positive(arr: List[int]) -> int: Returns the smallest missing positive integer from the unsorted array. This function runs in O(n) time complexity and uses O(1) additional space. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([1, 2, 3, 4, 5]) 6 >>> first_missing_positive([2, 3, 7, 6, 8, -1, -10, 15]) 1 >>> first_missing_positive([1, 1, 0, -1, -2]) 2 >>> first_missing_positive([]) 1 >>> first_missing_positive([0, 0, 0, 0]) 1","solution":"def first_missing_positive(arr): Returns the smallest missing positive integer from the unsorted array. This function runs in O(n) time complexity and uses O(1) additional space. n = len(arr) # First, segregate all positive numbers for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] # Then find the first instance where the index + 1 does not match the value for i in range(n): if arr[i] != i + 1: return i + 1 # All positions are filled correctly, thus return n + 1 return n + 1"},{"question":"def max_logs_per_user(logs): Determine the user(s) who have the maximum number of logs at a particular timestamp. If there are multiple users with the same number of logs at that timestamp, return a list of user IDs sorted lexicographically. Parameters: logs (List[str]): A list of log strings where each log is a space-separated user ID and timestamp Returns: List[str]: A list of user IDs sorted lexicographically from solution import max_logs_per_user def test_single_user_single_log(): logs = [\\"user1 123456\\"] assert max_logs_per_user(logs) == [\\"user1\\"] def test_single_user_multiple_logs(): logs = [\\"user1 123456\\", \\"user1 234567\\", \\"user1 345678\\"] assert max_logs_per_user(logs) == [\\"user1\\"] def test_multiple_users_same_log_count(): logs = [\\"user1 123456\\", \\"user2 123456\\", \\"user3 123456\\"] assert max_logs_per_user(logs) == [\\"user1\\", \\"user2\\", \\"user3\\"] def test_multiple_users_different_log_counts(): logs = [\\"user1 123456\\", \\"user2 123456\\", \\"user1 234567\\", \\"user1 345678\\"] assert max_logs_per_user(logs) == [\\"user1\\"] def test_multiple_users_tie_in_log_counts(): logs = [\\"user1 123456\\", \\"user1 234567\\", \\"user2 123456\\", \\"user2 234567\\"] assert max_logs_per_user(logs) == [\\"user1\\", \\"user2\\"] def test_empty_logs(): logs = [] assert max_logs_per_user(logs) == []","solution":"def max_logs_per_user(logs): Determine the user(s) who have the maximum number of logs at a particular timestamp. If there are multiple users with the same number of logs at that timestamp, return a list of user IDs sorted lexicographically. Parameters: logs (List[str]): A list of log strings where each log is a space-separated user ID and timestamp Returns: List[str]: A list of user IDs sorted lexicographically from collections import defaultdict user_logs = defaultdict(lambda: defaultdict(int)) # Nested dictionary for user -> timestamp -> count for log in logs: user_id, timestamp = log.split() user_logs[user_id][timestamp] += 1 max_count = 0 max_users = [] for user_id, timestamps in user_logs.items(): total_logs = sum(timestamps.values()) if total_logs > max_count: max_count = total_logs max_users = [user_id] elif total_logs == max_count: max_users.append(user_id) return sorted(max_users)"},{"question":"def min_moves_to_sort_queue(heights): Returns the minimum number of moves required to make the queue sorted. >>> min_moves_to_sort_queue([1, 2, 3, 4, 5]) == 0 >>> min_moves_to_sort_queue([5, 4, 3, 2, 1]) == 4 >>> min_moves_to_sort_queue([1, 3, 2, 4, 5]) == 2 >>> min_moves_to_sort_queue([1, 1, 1, 1, 1]) == 0 >>> min_moves_to_sort_queue([1]) == 0 >>> min_moves_to_sort_queue([]) == 0","solution":"def min_moves_to_sort_queue(heights): Returns the minimum number of moves required to make the queue sorted. n = len(heights) sorted_heights = sorted(heights) mismatch_count = 0 for i in range(n): if heights[i] != sorted_heights[i]: mismatch_count += 1 return mismatch_count"},{"question":"from typing import List def containsNearbyDuplicate(nums: List[int], k: int) -> bool: Determines if there are two distinct indices i and j in the array nums such that nums[i] == nums[j] and the absolute difference between i and j is at most k. >>> containsNearbyDuplicate([1, 2, 3, 1], 3) == True >>> containsNearbyDuplicate([1, 0, 1, 1], 1) == True >>> containsNearbyDuplicate([1, 2, 3, 1, 2, 3], 2) == False >>> containsNearbyDuplicate([1, 2, 3, 4, 5], 3) == False >>> containsNearbyDuplicate([1, 2, 3, 1], 2) == False >>> containsNearbyDuplicate([], 0) == False >>> containsNearbyDuplicate([1, 2, 3, 4, 1], 10) == True >>> containsNearbyDuplicate([1, 1], 1) == True >>> containsNearbyDuplicate([1], 0) == False","solution":"from typing import List def containsNearbyDuplicate(nums: List[int], k: int) -> bool: Determines if there are two distinct indices i and j in the array nums such that nums[i] == nums[j] and the absolute difference between i and j is at most k. num_indices = {} for i, num in enumerate(nums): if num in num_indices and i - num_indices[num] <= k: return True num_indices[num] = i return False"},{"question":"def search_matrix(matrix: List[List[int]], target: int) -> bool: Searches for the target in a matrix where each row is sorted in non-decreasing order. Uses a time complexity of O(n + m). Parameters: matrix (list of list of int): The 2D matrix. target (int): The target number to be searched. Returns: bool: True if the target is found, False otherwise. >>> search_matrix([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 5) True >>> search_matrix([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 20) False >>> search_matrix([], 5) False >>> search_matrix([[5]], 5) True >>> search_matrix([[5]], 2) False >>> search_matrix([ ... [1], ... [2], ... [3], ... [4], ... [5] ... ], 3) True >>> search_matrix([ ... [1], ... [2], ... [3], ... [4], ... [5] ... ], 6) False >>> search_matrix([ ... [1, 2, 3, 4, 5] ... ], 3) True >>> search_matrix([ ... [1, 2, 3, 4, 5] ... ], 6) False","solution":"def search_matrix(matrix, target): Searches for the target in a matrix where each row is sorted in non-decreasing order. Uses a time complexity of O(n + m). Parameters: matrix (list of list of int): The 2D matrix. target (int): The target number to be searched. Returns: bool: True if the target is found, False otherwise. if not matrix or not matrix[0]: return False n = len(matrix) m = len(matrix[0]) # Start from the top right corner row = 0 col = m - 1 while row < n and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"def min_substrings_with_k_chars(s: str, k: int) -> int: Return the minimum number of substrings containing at least one of the k selected characters. >>> min_substrings_with_k_chars(\\"abcabc\\", 2) 4 >>> min_substrings_with_k_chars(\\"aabbcc\\", 2) 4 >>> min_substrings_with_k_chars(\\"abcde\\", 1) 1 >>> min_substrings_with_k_chars(\\"aaaaa\\", 1) 5 >>> min_substrings_with_k_chars(\\"abcdef\\", 3) 3 >>> min_substrings_with_k_chars(\\"zyxwvuts\\", 4) 4","solution":"def min_substrings_with_k_chars(s, k): Returns the minimum number of substrings containing at least one of the k selected characters. from collections import Counter # Count the frequency of each character in the string s freq = Counter(s) # Sort the frequencies in ascending order sorted_freq = sorted(freq.values()) # Sum the lowest k frequencies min_substrings = sum(sorted_freq[:k]) return min_substrings"},{"question":"from typing import List def generate_binary_matrix(n: int, m: int) -> List[List[int]]: Generate a binary matrix of size \`n x m\` such that each row and each column contain an equal number of 1's and 0's if possible. Otherwise, return an empty array. >>> generate_binary_matrix(2, 2) [[1, 0], [0, 1]] or [[0, 1], [1, 0]] >>> generate_binary_matrix(4, 4) [[1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1]] or [[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]] >>> generate_binary_matrix(3, 4) [] >>> generate_binary_matrix(4, 3) [] >>> generate_binary_matrix(2, 4) [[1, 0, 1, 0], [0, 1, 0, 1]] or [[0, 1, 0, 1], [1, 0, 1, 0]]","solution":"def generate_binary_matrix(n, m): Generate a binary matrix of size \`n x m\` such that each row and each column contain an equal number of 1's and 0's if possible. Otherwise, return an empty array. # Check if it is possible to create such a matrix if n % 2 != 0 or m % 2 != 0: return [] # Initialize the matrix with 0's matrix = [[0] * m for _ in range(n)] for i in range(n): for j in range(i % 2, m, 2): matrix[i][j] = 1 # Return the generated binary matrix return matrix"},{"question":"def isNested(s: str) -> bool: Determine whether the string \`s\` has proper nesting of brackets. Parameters: s (str): The string to check for proper nesting of brackets. Returns: bool: True if the string has proper nesting of brackets, False otherwise. Examples: >>> isNested(\\"\\") True >>> isNested(\\"()\\") True >>> isNested(\\"({[]})\\") True >>> isNested(\\"([{]})\\") False >>> isNested(\\"a(b)c{d}[e]\\") True","solution":"def isNested(s): Returns true if the string s has proper nesting of brackets, otherwise returns false. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in '({[': stack.append(char) elif char in ')}]': if not stack or stack[-1] != matching_bracket[char]: return False stack.pop() return not stack"},{"question":"def merge_decreasing(nums1, nums2): Merges two arrays, nums1 and nums2, that represent positive integers in non-increasing order into a single array that is sorted in strictly decreasing order and contains no duplicates. >>> merge_decreasing([7, 5, 3], [8, 6, 4]) [8, 7, 6, 5, 4, 3] >>> merge_decreasing([7, 5, 3], [5, 5, 3, 2]) [7, 5, 3, 2] >>> merge_decreasing([10, 9, 7], [6, 4, 2]) [10, 9, 7, 6, 4, 2] >>> merge_decreasing([9, 5, 2], [10, 5, 1]) [10, 9, 5, 2, 1] >>> merge_decreasing([], [5, 3, 2]) [5, 3, 2] >>> merge_decreasing([7, 4, 1], []) [7, 4, 1] >>> merge_decreasing([], []) [] >>> merge_decreasing([5], [5]) [5] >>> merge_decreasing([6], [4]) [6, 4]","solution":"def merge_decreasing(nums1, nums2): Merges two arrays, nums1 and nums2, that represent positive integers in non-increasing order into a single array that is sorted in strictly decreasing order and contains no duplicates. # Combine the arrays and convert to a set to remove duplicates merged_set = set(nums1 + nums2) # Convert the set back to a list and sort in decreasing order merged_list = sorted(merged_set, reverse=True) return merged_list"},{"question":"def reverse_words(s: str) -> str: Reverses the order of words in the given sentence. >>> reverse_words(\\"hello\\") == \\"hello\\" >>> reverse_words(\\"hello world\\") == \\"world hello\\" >>> reverse_words(\\"the quick brown fox\\") == \\"fox brown quick the\\" >>> reverse_words(\\"space separated words\\") == \\"words separated space\\" >>> reverse_words(\\"Hello World\\") == \\"World Hello\\" >>> reverse_words(\\"Hello, world!\\") == \\"world! Hello,\\" >>> reverse_words(\\"123 456 789\\") == \\"789 456 123\\"","solution":"def reverse_words(s): Reverses the order of words in the given sentence. Parameters: s (str): The input sentence. Returns: str: The sentence with words in reversed order. words = s.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def wordBreak(s: str, wordDict: List[str]) -> bool: Determine if s can be segmented into a sequence of one or more words found in wordDict. :param s: String to be segmented :param wordDict: List of words that can be used in segmentation :return: True if s can be segmented, otherwise False >>> wordBreak(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == True >>> wordBreak(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) == True >>> wordBreak(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == False >>> wordBreak(\\"\\", [\\"leet\\", \\"code\\"]) == True >>> wordBreak(\\"hello\\", [\\"world\\", \\"python\\"]) == False >>> wordBreak(\\"aaaaaaa\\", [\\"a\\", \\"aa\\", \\"aaa\\"]) == True >>> wordBreak(\\"abcdef\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\"]) == True >>> wordBreak(\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\\", [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\", \\"aaaaa\\"]) == False","solution":"def wordBreak(s, wordDict): Determine if s can be segmented into a sequence of one or more words found in wordDict. :param s: String to be segmented :param wordDict: List of words that can be used in segmentation :return: True if s can be segmented, otherwise False dp = [False] * (len(s) + 1) dp[0] = True wordSet = set(wordDict) for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in wordSet: dp[i] = True break return dp[-1]"},{"question":"def can_transform(s1: str, s2: str) -> bool: Determine if you can transform s1 into s2 by only inserting characters zero or more times. >>> can_transform(\\"abc\\", \\"abc\\") True >>> can_transform(\\"abc\\", \\"aabbcc\\") True >>> can_transform(\\"ace\\", \\"abcde\\") True >>> can_transform(\\"abc\\", \\"ab\\") False >>> can_transform(\\"abc\\", \\"acb\\") False >>> can_transform(\\"\\", \\"\\") True >>> can_transform(\\"\\", \\"abc\\") True >>> can_transform(\\"a\\", \\"\\") False >>> can_transform(\\"a\\", \\"a\\") True >>> can_transform(\\"a\\", \\"aa\\") True >>> can_transform(\\"a\\", \\"b\\") False >>> can_transform(\\"a\\", \\"ab\\") True >>> can_transform(\\"a\\", \\"ba\\") False","solution":"def can_transform(s1, s2): Determines if s1 can be transformed into s2 by only inserting characters. # If s1 is longer than s2, transformation is impossible if len(s1) > len(s2): return False # Pointers to track positions in s1 and s2 i, j = 0, 0 # Traverse both strings to check if all characters in s1 appear in s2 in the same order while i < len(s1) and j < len(s2): if s1[i] == s2[j]: i += 1 j += 1 # If we have traversed the entire s1, then transformation is possible return i == len(s1)"},{"question":"def max_profit(prices): Calculate the maximum profit with as many transactions as allowed. :param prices: List of integers representing daily stock prices :return: Integer, maximum profit achievable >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1]) 0 >>> max_profit([1, 5, 3, 6, 4, 8]) 11 >>> max_profit([3, 3, 3, 3]) 0 >>> max_profit([]) 0 >>> max_profit([5]) 0 >>> max_profit([1, 2, 1, 2, 1, 2, 1, 2]) 4","solution":"def max_profit(prices): Calculate the maximum profit with as many transactions as allowed. :param prices: List of integers representing daily stock prices :return: Integer, maximum profit achievable profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: profit += prices[i] - prices[i - 1] return profit"},{"question":"def rob(nums: List[int]) -> int: Determine the maximum amount of money you can rob tonight without alerting the police. You are given a list of non-negative integers representing the money at each house. Adjacent houses have security systems connected, and it will automatically contact the police if two adjacent houses were broken into on the same night. Args: nums (List[int]): A list of non-negative integers representing the money of each house. Returns: int: The maximum amount of money you can rob without robbing two adjacent houses. Example: >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([1, 2, 3, 1]) 4","solution":"def rob(nums): if not nums: return 0 if len(nums) == 1: return nums[0] dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def min_moves_to_transform(start: str, end: str) -> int: Returns the minimum number of moves required to transform start into end. Parameters: start (str): The starting string. end (str): The ending string which needs to be achieved. Returns: int: The minimum number of moves required to transform start to end. Raises: ValueError: If the lengths of start and end are not the same. Examples: >>> min_moves_to_transform(\\"test\\", \\"test\\") 0 >>> min_moves_to_transform(\\"test\\", \\"tent\\") 1 >>> min_moves_to_transform(\\"abcd\\", \\"wxyz\\") 4 >>> min_moves_to_transform(\\"abcde\\", \\"abfde\\") 1 >>> min_moves_to_transform(\\"hello\\", \\"hxllo\\") 1 >>> min_moves_to_transform(\\"aaaa\\", \\"zzzz\\") 4 >>> min_moves_to_transform(\\"short\\", \\"longer\\") Traceback (most recent call last): ... ValueError: The lengths of start and end must be the same.","solution":"def min_moves_to_transform(start, end): Returns the minimum number of moves required to transform start into end. if len(start) != len(end): raise ValueError(\\"The lengths of start and end must be the same.\\") moves = 0 for s_char, e_char in zip(start, end): if s_char != e_char: moves += 1 return moves"},{"question":"import heapq from typing import List def connect_sticks(sticks: List[int]) -> int: Returns the minimum cost to connect all the sticks into one stick. >>> connect_sticks([2, 4, 3]) == 14 >>> connect_sticks([5]) == 0 >>> connect_sticks([1, 8]) == 9 >>> connect_sticks([1, 2, 3, 4, 5]) == 33 >>> connect_sticks([]) == 0 >>> connect_sticks([5, 5, 5, 5]) == 40","solution":"import heapq def connect_sticks(sticks): Returns the minimum cost to connect all the sticks into one stick. :param sticks: List[int], a list of integers representing the lengths of the sticks. :return: int, the minimum cost to connect all sticks. if not sticks: return 0 # Create a min heap heapq.heapify(sticks) total_cost = 0 while len(sticks) > 1: # Extract two shortest sticks first = heapq.heappop(sticks) second = heapq.heappop(sticks) # Combine sticks and calculate the cost cost = first + second total_cost += cost # Add the combined stick back to the heap heapq.heappush(sticks, cost) return total_cost"},{"question":"def maximum_sum_removing_one_element(nums: List[int]) -> int: Returns the maximum possible sum of any subarray of nums with exactly one element removed. >>> maximum_sum_removing_one_element([1, 2, 3, 4]) == 9 >>> maximum_sum_removing_one_element([-1, -2, -3, -4]) == -1 >>> maximum_sum_removing_one_element([1, -2, 3, 5, -1, 2]) == 10 >>> maximum_sum_removing_one_element([10]) == 0 >>> maximum_sum_removing_one_element([1, 2]) == 2 >>> maximum_sum_removing_one_element([2, -1]) == 2 >>> maximum_sum_removing_one_element([1000, -10000, 2000, 3000, -5000, 1000]) == 6000","solution":"def maximum_sum_removing_one_element(nums): Returns the maximum possible sum of any subarray of nums with exactly one element removed. n = len(nums) if n == 1: return 0 left_max = [0] * n right_max = [0] * n max_ending_here = nums[0] left_max[0] = nums[0] for i in range(1, n): max_ending_here = max(max_ending_here + nums[i], nums[i]) left_max[i] = max(left_max[i-1], max_ending_here) max_ending_here = nums[-1] right_max[-1] = nums[-1] for i in range(n-2, -1, -1): max_ending_here = max(max_ending_here + nums[i], nums[i]) right_max[i] = max(right_max[i+1], max_ending_here) max_sum = float('-inf') for i in range(n): if i == 0: max_sum = max(max_sum, right_max[i+1]) elif i == n-1: max_sum = max(max_sum, left_max[i-1]) else: max_sum = max(max_sum, left_max[i-1] + right_max[i+1]) return max_sum"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: 'TreeNode' = None, right: 'TreeNode' = None): self.val = val self.left = left self.right = right def rightSideView(root: Optional[TreeNode]) -> List[int]: Given a binary tree, return the values of the nodes you can see ordered from right side view, top to bottom. >>> rightSideView(None) [] >>> root = TreeNode(1) >>> rightSideView(root) [1] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(4) >>> rightSideView(root) [1, 3, 4] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> rightSideView(root) [1, 2, 3] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> rightSideView(root) [1, 2, 3]","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: 'TreeNode' = None, right: 'TreeNode' = None): self.val = val self.left = left self.right = right def rightSideView(root: Optional[TreeNode]) -> List[int]: if not root: return [] result = [] queue = [root] while queue: level_length = len(queue) for i in range(level_length): node = queue.pop(0) if i == level_length - 1: # If it's the rightmost element at the level result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"def can_finish(num_courses: int, prerequisites: List[List[int]]) -> bool: Determines if all courses can be finished given the prerequisite constraints. Parameters: num_courses (int): The total number of courses. prerequisites (List[List[int]]): A list where each element is a pair [a, b] indicating that course a requires course b as prerequisite. Returns: bool: True if all courses can be finished, False otherwise. Examples: >>> can_finish(2, [[1, 0]]) True >>> can_finish(2, [[1, 0], [0, 1]]) False","solution":"def can_finish(num_courses, prerequisites): Determines if all courses can be finished given the prerequisite constraints. Parameters: num_courses (int): The total number of courses. prerequisites (List[List[int]]): A list where each element is a pair [a, b] indicating that course a requires course b as prerequisite. Returns: bool: True if all courses can be finished, False otherwise. from collections import defaultdict, deque # Create adjacency list course_dict = defaultdict(list) indegree = [0] * num_courses # Build the graph and calculate in-degrees for prerequisite in prerequisites: next_course, prev_course = prerequisite course_dict[prev_course].append(next_course) indegree[next_course] += 1 # Initialize queue with courses having 0 in-degree zero_indegree_queue = deque([course for course in range(num_courses) if indegree[course] == 0]) # Count of courses that have 0 in-degree count_of_courses = 0 while zero_indegree_queue: course = zero_indegree_queue.popleft() count_of_courses += 1 for next_course in course_dict[course]: indegree[next_course] -= 1 if indegree[next_course] == 0: zero_indegree_queue.append(next_course) # If count_of_courses equals num_courses, all courses can be finished return count_of_courses == num_courses"},{"question":"from typing import List def num_similar_groups(words: List[str]) -> int: Given a list of non-empty strings \`words\` where each string is composed of lowercase English letters, return the number of distinct groups of similar strings that can be formed. Two strings are considered similar if they have the same characters with the same frequency of occurrences, but possibly in different orders. >>> num_similar_groups([\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"zyx\\", \\"yxz\\", \\"foo\\", \\"ofo\\"]) 3 >>> num_similar_groups([\\"abc\\"]) 1 >>> num_similar_groups([\\"abc\\", \\"def\\"]) 2 >>> num_similar_groups([\\"abc\\", \\"def\\", \\"ghi\\"]) 3 >>> num_similar_groups([\\"a\\", \\"a\\", \\"a\\"]) 1 >>> num_similar_groups([\\"abc\\", \\"bca\\", \\"xy\\", \\"yx\\", \\"foo\\", \\"bar\\"]) 4","solution":"def num_similar_groups(words): from collections import Counter def get_signature(word): return tuple(sorted((char, count) for char, count in Counter(word).items())) unique_signatures = set() for word in words: signature = get_signature(word) unique_signatures.add(signature) return len(unique_signatures)"},{"question":"def minInsertionsToPalindrome(s: str) -> int: Returns the minimum number of insertions required to make the string a palindrome. >>> minInsertionsToPalindrome(\\"racecar\\") == 0 >>> minInsertionsToPalindrome(\\"a\\") == 0 >>> minInsertionsToPalindrome(\\"aa\\") == 0 >>> minInsertionsToPalindrome(\\"ab\\") == 1 >>> minInsertionsToPalindrome(\\"abc\\") == 2 >>> minInsertionsToPalindrome(\\"abca\\") == 1 >>> minInsertionsToPalindrome(\\"abcda\\") == 2 >>> minInsertionsToPalindrome(\\"abcde\\") == 4 >>> minInsertionsToPalindrome(\\"aacecaaa\\") == 1 >>> minInsertionsToPalindrome(\\"abcd\\") == 3","solution":"def minInsertionsToPalindrome(s): Returns the minimum number of insertions required to make s a palindrome. n = len(s) # Create a dp array to store the minimum insertions needed # to make substring s[i:j] a palindrome dp = [[0] * n for _ in range(n)] # Fill the dp array for length in range(2, n + 1): # length of the substring for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1 return dp[0][n - 1]"},{"question":"def find_missing_number(numbers: List[int]) -> int: Finds the missing number in the array of first n natural numbers. :param numbers: List[int] - array containing first n natural numbers from 1 to n with one missing :return: int - the missing number >>> find_missing_number([2, 3, 4, 5]) == 1 >>> find_missing_number([1, 2, 3, 4]) == 5 >>> find_missing_number([1, 2, 4, 5]) == 3 >>> find_missing_number([1]) == 2 >>> find_missing_number(list(range(1, 101)) + list(range(102, 201))) == 101","solution":"def find_missing_number(numbers): Finds the missing number in the array of first n natural numbers. :param numbers: List[int] - array containing first n natural numbers from 1 to n with one missing :return: int - the missing number n = len(numbers) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(numbers) return total_sum - actual_sum"},{"question":"def smallest_subgrid(grid: List[List[int]]) -> List[int]: Find the smallest rectangular subgrid that contains all the 1s present in the entire grid. If there are no 1s in the grid, return an empty list. >>> smallest_subgrid([[0, 0], [0, 0]]) == [] >>> smallest_subgrid([[0, 1], [0, 0]]) == [0, 1, 0, 1] >>> smallest_subgrid([[1, 0, 0], [0, 1, 1], [0, 0, 0]]) == [0, 0, 1, 2] >>> smallest_subgrid([[1, 1], [1, 1]]) == [0, 0, 1, 1] >>> smallest_subgrid([[0], [1], [0]]) == [1, 0, 1, 0] >>> smallest_subgrid([[0, 1, 0]]) == [0, 1, 0, 1] >>> smallest_subgrid([[1, 0], [0, 1]]) == [0, 0, 1, 1]","solution":"def smallest_subgrid(grid): n = len(grid) if n == 0: return [] m = len(grid[0]) if m == 0: return [] min_row, max_row = n, -1 min_col, max_col = m, -1 for i in range(n): for j in range(m): if grid[i][j] == 1: if i < min_row: min_row = i if i > max_row: max_row = i if j < min_col: min_col = j if j > max_col: max_col = j if min_row == n: return [] return [min_row, min_col, max_row, max_col]"},{"question":"from typing import List def min_operations(nums: List[int]) -> int: Returns the minimum number of operations needed to make all buildings' heights zero. Parameters: nums (list): A list of non-negative integers representing the heights of buildings. Returns: int: The minimum number of operations to make all heights zero. >>> min_operations([1, 2, 3, 2, 1]) 3 >>> min_operations([4]) 4 >>> min_operations([3, 3, 3]) 3 >>> min_operations([0, 1, 0, 2, 0]) 3 >>> min_operations([0, 0, 0]) 0 >>> min_operations([1, 2, 3, 4, 5]) 5 >>> min_operations([5, 4, 3, 2, 1]) 5 >>> min_operations([]) 0 >>> min_operations([1, 3, 2, 2, 1, 3]) 5","solution":"def min_operations(nums): Returns the minimum number of operations needed to make all buildings' heights zero. Parameters: nums (list): A list of non-negative integers representing the heights of buildings. Returns: int: The minimum number of operations to make all heights zero. if not nums: return 0 operations = 0 current_height = 0 for height in nums: if height > current_height: operations += height - current_height current_height = height return operations"},{"question":"def min_max_elevation_path(grid): Find the path from the top-left to the bottom-right corner that minimizes the maximum elevation encountered along the path. :param grid: List[List[int]]: 2D grid of integers representing elevations :return: int: The maximum elevation encountered along the optimal path >>> min_max_elevation_path([ ... [1, 2, 2], ... [3, 8, 2], ... [5, 3, 5] ... ]) == 5 >>> min_max_elevation_path([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 1 >>> min_max_elevation_path([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 9 >>> min_max_elevation_path([ ... [9, 8, 7], ... [6, 5, 4], ... [3, 2, 1] ... ]) == 9 >>> min_max_elevation_path([[1, 2, 3]]) == 3 >>> min_max_elevation_path([ ... [1], ... [2], ... [3] ... ]) == 3 >>> min_max_elevation_path([[1]]) == 1","solution":"import heapq def min_max_elevation_path(grid): Find the path from the top-left to the bottom-right corner that minimizes the maximum elevation encountered along the path. :param grid: List[List[int]]: 2D grid of integers representing elevations :return: int: The maximum elevation encountered along the optimal path rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] pq = [(grid[0][0], 0, 0)] # (elevation, row, col) max_elevation = [[float('inf')]*cols for _ in range(rows)] max_elevation[0][0] = grid[0][0] while pq: elevation, r, c = heapq.heappop(pq) if r == rows - 1 and c == cols - 1: return elevation for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols: new_elevation = max(elevation, grid[nr][nc]) if new_elevation < max_elevation[nr][nc]: max_elevation[nr][nc] = new_elevation heapq.heappush(pq, (new_elevation, nr, nc)) return -1 # In case there's no valid path"},{"question":"def count_pairs(arr: List[int], k: int) -> int: Returns the number of pairs (i, j) such that 0 <= i < j < n and (arr[i] + arr[j]) % k == 0. :param arr: List of distinct integers :param k: Integer k :return: Number of such pairs >>> count_pairs([1, 3, 2, 6, 4, 5], 3) == 5 >>> count_pairs([1, 2, 3], 10) == 0 >>> count_pairs([3, 6, 9], 3) == 3 >>> count_pairs([1], 1) == 0 >>> count_pairs([1, 2, 3, 4, 5], 100) == 0 >>> count_pairs([-1, -2, 3, 7, 8], 5) == 3 # Your code here","solution":"def count_pairs(arr, k): Returns the number of pairs (i, j) such that 0 <= i < j < n and (arr[i] + arr[j]) % k == 0. :param arr: List of distinct integers :param k: Integer k :return: Number of such pairs n = len(arr) count = 0 for i in range(n): for j in range(i+1, n): if (arr[i] + arr[j]) % k == 0: count += 1 return count"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def level_order_traversal(root): Returns the level order traversal of a binary tree. :param root: TreeNode, the root of the binary tree :return: List[List[int]], list of levels with node values >>> root = TreeNode(3) ... root.left = TreeNode(9) ... root.right = TreeNode(20) ... root.right.left = TreeNode(15) ... root.right.right = TreeNode(7) ... level_order_traversal(root) [[3], [9, 20], [15, 7]] >>> root = TreeNode(1) ... level_order_traversal(root) [[1]] >>> level_order_traversal(None) []","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def level_order_traversal(root): Returns the level order traversal of a binary tree. :param root: TreeNode, the root of the binary tree :return: List[List[int]], list of levels with node values if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"def find_winning_candidate(nums): Returns the index of the candidate with the highest number of votes. If there is a tie, the candidate who appears first in the array is returned. Parameters: nums (list of int): A list of integers representing votes for each candidate. Returns: int: The index of the winning candidate.","solution":"def find_winning_candidate(nums): Returns the index of the candidate with the highest number of votes. If there is a tie, the candidate who appears first in the array is returned. Parameters: nums (list of int): A list of integers representing votes for each candidate. Returns: int: The index of the winning candidate. if not nums: return -1 # Return -1 if the list is empty max_votes = nums[0] winning_index = 0 for i in range(1, len(nums)): if nums[i] > max_votes: max_votes = nums[i] winning_index = i return winning_index"},{"question":"from typing import List def count_valleys(heights: List[int]) -> int: Returns the count of valleys in the given terrain heights list. A valley is defined as a segment i (1 <= i < len(heights) - 1) such that: heights[i-1] > heights[i] < heights[i+1] :param heights: List[int] :return: int >>> count_valleys([1, 0, 1]) 1 >>> count_valleys([1, 0, 1, 0, 1]) 2 >>> count_valleys([1, 2, 3, 4, 5]) 0 >>> count_valleys([5, 4, 3, 2, 1]) 0 >>> count_valleys([1, 2, 1]) 0 >>> count_valleys([2, 1, 2]) 1 >>> count_valleys([1, 1, 1, 1]) 0 >>> count_valleys([]) 0 >>> count_valleys([1]) 0 >>> count_valleys([1, 2]) 0","solution":"def count_valleys(heights): Returns the count of valleys in the given terrain heights list. A valley is defined as a segment i (1 <= i < len(heights) - 1) such that: heights[i-1] > heights[i] < heights[i+1] :param heights: List[int] :return: int valley_count = 0 for i in range(1, len(heights) - 1): if heights[i-1] > heights[i] < heights[i+1]: valley_count += 1 return valley_count"},{"question":"def can_form_square(nums): Returns whether all the sticks in the list nums can form a square. >>> can_form_square([1, 1, 2, 2, 2]) True >>> can_form_square([1, 1, 1, 1]) True >>> can_form_square([5, 5, 5, 5, 7, 7, 7, 7]) True >>> can_form_square([1, 1, 1, 2, 2]) False >>> can_form_square([3, 3, 3, 3, 4]) False >>> can_form_square([5, 5, 5, 6]) False >>> can_form_square([20, 10, 10, 5, 5, 5, 5]) False >>> can_form_square([1, 2, 3]) False >>> can_form_square([8]) False >>> can_form_square([]) False","solution":"def can_form_square(nums): Returns whether all the sticks in the list nums can form a square. if not nums or len(nums) < 4: return False total_length = sum(nums) if total_length % 4 != 0: return False side_length = total_length // 4 nums.sort(reverse=True) sides = [0] * 4 def dfs(index): if index == len(nums): return all(side == side_length for side in sides) for i in range(4): if sides[i] + nums[index] <= side_length: sides[i] += nums[index] if dfs(index + 1): return True sides[i] -= nums[index] return False return dfs(0)"},{"question":"def minSubArrayLen(nums, threshold): Returns the length of the shortest contiguous subarray such that the sum of its elements is greater than or equal to threshold. If no such subarray exists, returns -1. >>> minSubArrayLen([2, 3, 1, 2, 4, 3], 7) == 2 >>> minSubArrayLen([1, 4, 4], 4) == 1 >>> minSubArrayLen([1, 1, 1, 1, 1, 1, 1, 1], 11) == -1","solution":"def minSubArrayLen(nums, threshold): Returns the length of the shortest contiguous subarray such that the sum of its elements is greater than or equal to threshold. If no such subarray exists, returns -1. n = len(nums) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= threshold: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def max_r_pairs(s: str) -> int: Given a binary string s, return the maximum number of r-pairs of substrings (s1, s2) that you can get, where both s1 and s2 are non-empty substrings of s and s1 + s2 is still a binary string with equal number of 0s and 1s. Note that the substrings s1 and s2 cannot overlap. >>> max_r_pairs('0000') == 0 >>> max_r_pairs('1111') == 0 >>> max_r_pairs('1010') == 2 >>> max_r_pairs('0101') == 2 >>> max_r_pairs('11010') == 2 >>> max_r_pairs('10101') == 2 >>> max_r_pairs('10000') == 1 >>> max_r_pairs('1000010') == 2","solution":"def max_r_pairs(s): Returns the maximum number of r-pairs of substrings (s1, s2) that can be obtained where both s1 and s2 are non-empty substrings of s and s1 + s2 has an equal number of 0s and 1s. zeros = s.count('0') ones = s.count('1') return min(zeros, ones)"},{"question":"def count_substrings(patterns, text): Returns a list of integers where each integer is the count of how many times each pattern appears as a substring in the text. >>> count_substrings([\\"a\\", \\"aa\\", \\"aaa\\"], \\"aaaaa\\") == [5, 4, 3] >>> count_substrings([\\"a\\", \\"b\\"], \\"ababa\\") == [3, 2] >>> count_substrings([\\"x\\", \\"y\\"], \\"aaaaabbbbb\\") == [0, 0] >>> count_substrings([\\"a\\", \\"ab\\", \\"abc\\"], \\"abcabcabc\\") == [3, 3, 3] >>> count_substrings([\\"a\\", \\"ab\\", \\"abc\\"], \\"\\") == [0, 0, 0]","solution":"def count_substrings(patterns, text): Returns a list of integers where each integer is the count of how many times each pattern appears as a substring in the text. :param patterns: List of strings to search for in the text :param text: The text in which to search for patterns :return: List of counts of each pattern in the text result = [] for pattern in patterns: count = 0 for i in range(len(text) - len(pattern) + 1): if text[i:i+len(pattern)] == pattern: count += 1 result.append(count) return result"},{"question":"def min_operations_to_k_consecutive(s: str, k: int) -> int: Returns the minimum number of operations needed to ensure that there are at least k consecutive identical characters in the string s. >>> min_operations_to_k_consecutive(\\"abac\\", 2) == 1 >>> min_operations_to_k_consecutive(\\"aaa\\", 3) == 0 >>> min_operations_to_k_consecutive(\\"abcd\\", 2) == 1 >>> min_operations_to_k_consecutive(\\"ababab\\", 3) == 1 >>> min_operations_to_k_consecutive(\\"a\\" * 50 + \\"b\\" * 50, 50) == 0 >>> min_operations_to_k_consecutive(\\"a\\" * 50 + \\"b\\" * 50, 51) == 1","solution":"def min_operations_to_k_consecutive(s, k): Returns the minimum number of operations needed to ensure that there are at least k consecutive identical characters in the string s. from collections import defaultdict max_freq = 0 counter = defaultdict(int) for i in range(len(s)): counter[s[i]] += 1 if i >= k: counter[s[i - k]] -= 1 max_freq = max(max_freq, counter[s[i]]) return k - max_freq"},{"question":"def maximize_array_sum(numbers: List[int], k: int) -> int: Maximizes the sum of the array after performing up to k operations. In each operation, we choose two adjacent elements and replace one of them with their sum to maximize the array sum. >>> maximize_array_sum([10], 5) 10 >>> maximize_array_sum([1, 2], 1) 3 >>> maximize_array_sum([1, 2, 3], 2) 6 >>> maximize_array_sum([1, 2, 3, 4], 3) 10 >>> maximize_array_sum([1, 2, 3, 4], 10) 10 >>> maximize_array_sum([1, 2, 3, 4], 0) 10","solution":"def maximize_array_sum(numbers, k): Maximizes the sum of the array after performing up to k operations. In each operation, we choose two adjacent elements and replace one of them with their sum to maximize the array sum. while k > 0 and len(numbers) > 1: max_sum_index = None max_sum_value = float('-inf') for i in range(len(numbers) - 1): current_sum = numbers[i] + numbers[i + 1] if current_sum > max_sum_value: max_sum_value = current_sum max_sum_index = i numbers[max_sum_index] = max_sum_value del numbers[max_sum_index + 1] k -= 1 return sum(numbers)"},{"question":"def can_form_balanced_array(arr: List[int]) -> bool: Check if the given array can be rearranged to form a balanced array. Parameters: arr (list of int): The input array. Returns: bool: True if a balanced array can be formed, otherwise False. >>> can_form_balanced_array([1, 2, 3, 4, 5, 5]) True >>> can_form_balanced_array([1, 1, 1, 1, 1, 10]) False >>> can_form_balanced_array([1, 2, 1, 2, 1, 2, 1, 2]) True >>> can_form_balanced_array([2, 2, 2, 2, 2, 2, 2, 2]) True >>> can_form_balanced_array([1, 2, 3, 6, 8, 9]) False >>> can_form_balanced_array([10]) False >>> can_form_balanced_array([3, 3]) True >>> can_form_balanced_array([3, 4]) False >>> can_form_balanced_array([]) False","solution":"def can_form_balanced_array(arr): Check if the given array can be rearranged to form a balanced array. Parameters: arr (list of int): The input array. Returns: bool: True if a balanced array can be formed, otherwise False. total_sum = sum(arr) n = len(arr) # total_sum must be divisible by 2 for a balanced array if total_sum % 2 != 0: return False half_sum = total_sum // 2 left_sum = 0 # Find if there exists a subset with sum equal to half_sum seen_sums = set() for num in arr: left_sum += num seen_sums.add(left_sum) if (left_sum - half_sum) in seen_sums or left_sum == half_sum: return True return False"},{"question":"def max_profit_with_two_transactions(prices: List[int]) -> int: Given a list of \`n\` positive integers representing daily stock prices, find the maximum profit you can achieve by making at most two transactions. Note that you cannot engage in multiple transactions simultaneously (you must sell the stock before you buy again). A transaction is defined as buying and then selling one share of the stock. >>> max_profit_with_two_transactions([3,3,5,0,0,3,1,4]) == 6 >>> max_profit_with_two_transactions([1,2,3,4,5]) == 4 >>> max_profit_with_two_transactions([7,6,4,3,1]) == 0 >>> max_profit_with_two_transactions([1,2,4,2,5,7,2,4,9,0]) == 13 >>> max_profit_with_two_transactions([]) == 0 >>> max_profit_with_two_transactions([5]) == 0 >>> max_profit_with_two_transactions([2, 2, 2, 2, 2]) == 0 >>> max_profit_with_two_transactions([1, 5, 2, 8, 3, 5]) == 10","solution":"def max_profit_with_two_transactions(prices): if not prices: return 0 n = len(prices) left_profits = [0] * n right_profits = [0] * n # Forward phase - maximum profit up to day i min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) left_profits[i] = max(left_profits[i - 1], prices[i] - min_price) # Backward phase - maximum profit from day i onward max_price = prices[-1] for i in range(n - 2, -1, -1): max_price = max(max_price, prices[i]) right_profits[i] = max(right_profits[i + 1], max_price - prices[i]) # Combine the two profits max_profit = 0 for i in range(n): max_profit = max(max_profit, left_profits[i] + right_profits[i]) return max_profit"},{"question":"def count_homogeneous_substrings(s: str) -> int: Returns the number of homogeneous substrings in the given string s. >>> count_homogeneous_substrings(\\"a\\") == 1 >>> count_homogeneous_substrings(\\"aa\\") == 3 >>> count_homogeneous_substrings(\\"aaa\\") == 6 >>> count_homogeneous_substrings(\\"ab\\") == 2 >>> count_homogeneous_substrings(\\"aab\\") == 4","solution":"def count_homogeneous_substrings(s): Returns the number of homogeneous substrings in the given string s. count = 0 length = 1 # length of the current homogeneous substring for i in range(1, len(s)): if s[i] == s[i - 1]: length += 1 else: count += length * (length + 1) // 2 length = 1 # Adding the count for the last homogeneous sequence count += length * (length + 1) // 2 return count"},{"question":"def largest_island_perimeter(grid): Returns the perimeter of the largest island in the grid. >>> grid = [ ... [\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"1\\",\\"0\\"], ... [\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\"] ... ] >>> largest_island_perimeter(grid) 16 >>> grid = [ ... [\\"1\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\"] ... ] >>> largest_island_perimeter(grid) 4 >>> grid = [ ... [\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\"] ... ] >>> largest_island_perimeter(grid) 0 >>> grid = [ ... [\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"1\\"] ... ] >>> largest_island_perimeter(grid) 12 >>> grid = [ ... [\\"1\\",\\"0\\",\\"1\\"], ... [\\"0\\",\\"1\\",\\"0\\"], ... [\\"1\\",\\"0\\",\\"1\\"] ... ] >>> largest_island_perimeter(grid) 4 >>> grid = [ ... [\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"0\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"1\\"] ... ] >>> largest_island_perimeter(grid) 16","solution":"def largest_island_perimeter(grid): Returns the perimeter of the largest island in the grid. def dfs(r, c): stack = [(r, c)] visited.add((r, c)) perimeter = 0 island_size = 0 while stack: x, y = stack.pop() island_size += 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if grid[nx][ny] == '0': perimeter += 1 elif grid[nx][ny] == '1' and (nx, ny) not in visited: stack.append((nx, ny)) visited.add((nx, ny)) else: perimeter += 1 return perimeter, island_size m, n = len(grid), len(grid[0]) visited = set() max_perimeter = 0 for i in range(m): for j in range(n): if grid[i][j] == '1' and (i, j) not in visited: perimeter, island_size = dfs(i, j) if island_size > 0: max_perimeter = max(max_perimeter, perimeter) return max_perimeter"},{"question":"def max_contiguous_1s_after_one_flip(A: List[int]) -> int: Given an integer array A which consists of only 0s and 1s. The function should determine the maximum number of contiguous 1s that can be achieved by performing at most one flip operation (flipping the values in one continuous subarray of A). >>> max_contiguous_1s_after_one_flip([1, 1, 1, 1, 1]) 5 >>> max_contiguous_1s_after_one_flip([1, 0, 1, 1, 1]) 5 >>> max_contiguous_1s_after_one_flip([1, 0, 1, 0, 1]) 3 >>> max_contiguous_1s_after_one_flip([0, 0, 0, 0]) 1 >>> max_contiguous_1s_after_one_flip([1, 0, 1, 0, 1, 0, 1, 0, 1]) 3 >>> max_contiguous_1s_after_one_flip([]) 0","solution":"def max_contiguous_1s_after_one_flip(A): n = len(A) # Track maximum sequence of 1s we can achieve with one flip max_1s = 0 # Use two pointers to consider every possible range for a flip for L in range(n): original_sequence_length = 0 flip_count = 0 for R in range(L, n): if A[R] == 0: flip_count += 1 original_sequence_length += 1 # Ensure we are only flipping at most one set of 0s if flip_count <= 1: max_1s = max(max_1s, original_sequence_length) else: break return max_1s"},{"question":"def longest_consecutive(nums: List[int]) -> int: Returns the length of the longest consecutive elements sequence in the list nums. >>> longest_consecutive([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive([]) == 0 >>> longest_consecutive([1, 2, 0, 1]) == 3 >>> longest_consecutive([10, 5, 12, 3, 55, 30, 4, 11]) == 3 >>> longest_consecutive([4, 2, 1]) == 2 >>> longest_consecutive([1, 3, 5, 2, 4]) == 5 >>> longest_consecutive([10, 9, 5, 0, 8, 6, 7, 4, 3, 2, 1]) == 11 >>> longest_consecutive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in the list nums. if not nums: return 0 num_set = set(nums) max_length = 0 for num in nums: if num - 1 not in num_set: # only start counting from the beginning of a sequence current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"def exists_pair_with_difference(arr1: List[int], arr2: List[int], x: int) -> bool: Determines if there exist two integers i and j such that 0 <= i, j < n and abs(arr1[i] - arr2[j]) == x. :param arr1: List[int] - First list of integers :param arr2: List[int] - Second list of integers :param x: int - The target difference :return: bool - True if such a pair exists, False otherwise >>> exists_pair_with_difference([1, 2, 3], [4, 5, 6], 3) True >>> exists_pair_with_difference([1, 2, 3], [4, 5, 6], 100) False >>> exists_pair_with_difference([1, 2, 3], [-1, -2, -3], 4) True >>> exists_pair_with_difference([1, 1, 1], [1, 1, 1], 0) True >>> exists_pair_with_difference([1, 2, 3, 4], [0, 3, 6, 9], 1) True >>> exists_pair_with_difference([1000000, 2000000], [1500000], 500000) True >>> exists_pair_with_difference([], [], 1) False >>> exists_pair_with_difference([5], [2], 3) True >>> exists_pair_with_difference([5], [2], 4) False # Your implementation here","solution":"def exists_pair_with_difference(arr1, arr2, x): Determines if there exist two integers i and j such that 0 <= i, j < n and abs(arr1[i] - arr2[j]) == x. :param arr1: List[int] - First list of integers :param arr2: List[int] - Second list of integers :param x: int - The target difference :return: bool - True if such a pair exists, False otherwise set_arr2 = set(arr2) for a in arr1: if a - x in set_arr2 or a + x in set_arr2: return True return False"},{"question":"def find_indices(nums: List[int], target: int) -> List[int]: Returns the indices [i, j] such that nums[i] * nums[j] == target and i < j. If no such pair exists, returns an empty array. >>> find_indices([2, 4, 1, 6], 8) == [0, 1] >>> find_indices([3, 1, 5, 7], 15) == [0, 2] >>> find_indices([1, 2, 3], 10) == [] >>> find_indices([2, 3, 5, 7], 15) == [1, 2] >>> find_indices([5, 4, 3, 2, 1], 8) == [1, 3] >>> find_indices([1, 9, 12, 3, 4, 7], 28) == [4, 5] >>> find_indices([1, 2], 2) == [0, 1] >>> find_indices([9], 9) == [] pass","solution":"def find_indices(nums, target): Returns the indices [i, j] such that nums[i] * nums[j] == target and i < j. If no such pair exists, returns an empty array. n = len(nums) for i in range(n): for j in range(i + 1, n): if nums[i] * nums[j] == target: return [i, j] return []"},{"question":"def findKthSmallest(nums: List[int], k: int) -> int: Given an array of integers \`nums\` and an integer \`k\`, find the \`k-th\` smallest element in the array. Note that it is the \`k-th\` smallest element in the sorted order, not the \`k-th\` distinct element. >>> findKthSmallest([3, 2, 1, 5, 6, 4], 2) 2 >>> findKthSmallest([3, 2, 1, 5, 6, 4], 5) 5","solution":"def quickSelect(nums, low, high, k): if low == high: return nums[low] pivot_index = partition(nums, low, high) if k == pivot_index: return nums[k] elif k < pivot_index: return quickSelect(nums, low, pivot_index - 1, k) else: return quickSelect(nums, pivot_index + 1, high, k) def partition(nums, low, high): pivot = nums[high] i = low for j in range(low, high): if nums[j] <= pivot: nums[i], nums[j] = nums[j], nums[i] i += 1 nums[i], nums[high] = nums[high], nums[i] return i def findKthSmallest(nums, k): return quickSelect(nums, 0, len(nums) - 1, k - 1)"},{"question":"from collections import deque from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_width_of_binary_tree(root: Optional[TreeNode]) -> int: Given a binary tree, find the maximum width of the tree. The width of a binary tree is the maximum number of nodes in a single level. >>> root = TreeNode(1, ... TreeNode(2, TreeNode(4), TreeNode(5)), ... TreeNode(3, None, TreeNode(8, None, TreeNode(9)))) >>> max_width_of_binary_tree(root) 3 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> max_width_of_binary_tree(root) 2 def test_empty_tree(): assert max_width_of_binary_tree(None) == 0 def test_single_node(): root = TreeNode(1) assert max_width_of_binary_tree(root) == 1 def test_balanced_tree(): root = TreeNode(1, TreeNode(2), TreeNode(3)) assert max_width_of_binary_tree(root) == 2 def test_unbalanced_tree(): root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(8, None, TreeNode(9)))) assert max_width_of_binary_tree(root) == 3 def test_full_binary_tree(): root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) assert max_width_of_binary_tree(root) == 4 def test_sparse_tree(): root = TreeNode(1, None, TreeNode(3, TreeNode(6, None, TreeNode(9)), TreeNode(7))) assert max_width_of_binary_tree(root) == 2","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_width_of_binary_tree(root): if not root: return 0 max_width = 0 queue = deque([root]) while queue: level_length = len(queue) max_width = max(max_width, level_length) for _ in range(level_length): node = queue.popleft() if node.left: queue.append(node.left) if node.right: queue.append(node.right) return max_width"},{"question":"def can_rearrange_to_sum(nums: List[int], target: int) -> bool: Determine if it is possible to rearrange the elements of nums to form a strictly increasing order of elements that sums up to target. >>> can_rearrange_to_sum([4, 1, 3, 2], 10) == True >>> can_rearrange_to_sum([5, 6, 7], 14) == False","solution":"def can_rearrange_to_sum(nums, target): Determine if it is possible to rearrange nums to form a strictly increasing order of elements that sums up to target. nums.sort() current_sum = 0 for num in nums: current_sum += num if current_sum == target: return True if current_sum > target: return False return False"},{"question":"def maximalSquare(grid: List[List[int]]) -> int: Given an m x n matrix grid of integers, return the length of the side of the largest square containing only 1's. Args: grid (List[List[int]]): The input grid of integers. Returns: int: The length of the side of the largest square containing only 1's. Return 0 if no such square exists. Examples: >>> maximalSquare([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ...]) 2 >>> maximalSquare([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ...]) 3 >>> maximalSquare([ ... [0, 1], ... [1, 0] ...]) 1 >>> maximalSquare([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ...]) 0 >>> maximalSquare([]) 0 >>> maximalSquare([[1]]) 1 >>> maximalSquare([[0]]) 0","solution":"def maximalSquare(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"from typing import List, Tuple def shortest_path(n: int, edges: List[Tuple[int, int, int]]) -> int: Return the length of the shortest path from node 0 to node n-1. If there is no such path, return -1. :param n: Number of nodes. :param edges: List of edges where each edge is represented as a triplet (u, v, w) indicating an edge between nodes u and v with weight w. :return: Length of the shortest path from node 0 to node n-1 or -1 if no such path exists. >>> shortest_path(3, [(0, 1, 1), (1, 2, 2), (0, 2, 4)]) == 3 >>> shortest_path(4, [(0, 1, 1), (1, 2, 2)]) == -1 >>> shortest_path(3, [(0, 1, 5), (1, 2, 5), (0, 2, 3)]) == 3 >>> shortest_path(5, [(0, 1, 1), (0, 2, 4), (1, 2, 2), (2, 3, 1), (3, 4, 3), (0, 4, 10)]) == 7 >>> shortest_path(1, []) == 0 # Your implementation here","solution":"import heapq from collections import defaultdict def shortest_path(n, edges): Return the length of the shortest path from node 0 to node n-1. If there is no such path, return -1. :param n: Number of nodes. :param edges: List of edges where each edge is represented as a triplet (u, v, w) indicating an edge between nodes u and v with weight w. :return: Length of the shortest path from node 0 to node n-1 or -1 if no such path exists. # Create adjacency list graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's Algorithm initialization min_heap = [(0, 0)] # (distance, node) distances = {i: float('inf') for i in range(n)} distances[0] = 0 visited = set() while min_heap: current_distance, u = heapq.heappop(min_heap) if u in visited: continue visited.add(u) for v, weight in graph[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(min_heap, (distance, v)) shortest_distance = distances[n-1] return shortest_distance if shortest_distance != float('inf') else -1"},{"question":"def length_of_lis(nums: List[int]) -> int: Given an integer array \`nums\` of length \`n\`, return the length of the longest subsequence such that elements of the subsequence are sorted in a strictly increasing order. >>> length_of_lis([]) == 0 >>> length_of_lis([10]) == 1 >>> length_of_lis([1, 2, 3, 4, 5]) == 5 >>> length_of_lis([5, 4, 3, 2, 1]) == 1 >>> length_of_lis([3, 10, 2, 1, 20]) == 3 >>> length_of_lis([3, 4, -1, 0, 6, 2, 3]) == 4 >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> length_of_lis([1, 3, 2, 4, 3, 5]) == 4","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence. if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def find_largest_island(grid: List[List[int]]) -> int: Find the largest island formed by flipping one \`0\` (water cell) into a \`1\` (land cell). The grid is a 2D binary grid of size \`m x n\`, where each cell is either \`0\` (representing water) or \`1\` (representing land). This function returns the maximum size of an island you can obtain by flipping exactly one \`0\` to \`1\`. >>> find_largest_island([[1, 0], [0, 1]]) == 3 >>> find_largest_island([[1, 1], [0, 1]]) == 4 >>> find_largest_island([[1, 1], [1, 1]]) == 4 >>> find_largest_island([[0, 0], [0, 0]]) == 1 >>> find_largest_island([[1, 1, 1, 0], [1, 0, 0, 1], [1, 1, 0, 0], [0, 0, 0, 1]]) == 8 >>> find_largest_island([[1]]) == 1","solution":"def find_largest_island(grid): from collections import defaultdict def dfs(x, y, index): stack = [(x, y)] grid[x][y] = index area = 0 while stack: i, j = stack.pop() area += 1 for ni, nj in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1: grid[ni][nj] = index stack.append((ni, nj)) return area m, n = len(grid), len(grid[0]) index = 2 area_map = defaultdict(int) for i in range(m): for j in range(n): if grid[i][j] == 1: area_map[index] = dfs(i, j, index) index += 1 max_area = max(area_map.values(), default=0) for i in range(m): for j in range(n): if grid[i][j] == 0: seen = set() for ni, nj in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] > 1: seen.add(grid[ni][nj]) new_area = 1 + sum(area_map[ind] for ind in seen) max_area = max(max_area, new_area) return max_area"},{"question":"def count_clear_view_buildings(heights: List[int]) -> int: Returns the number of buildings that have a clear view to the west. Parameters: heights (list of int): List of building heights. Returns: int: Number of buildings with a clear view to the west. >>> count_clear_view_buildings([]) == 0 >>> count_clear_view_buildings([10]) == 1 >>> count_clear_view_buildings([1, 2, 3, 4, 5]) == 5 >>> count_clear_view_buildings([5, 4, 3, 2, 1]) == 1 >>> count_clear_view_buildings([3, 1, 4, 2, 5]) == 3 >>> count_clear_view_buildings([3, 3, 3, 2, 4, 4, 5]) == 3 >>> count_clear_view_buildings([1, 3, 2, 1, 5, 4, 6]) == 4","solution":"def count_clear_view_buildings(heights): Returns the number of buildings that have a clear view to the west. Parameters: heights (list of int): List of building heights. Returns: int: Number of buildings with a clear view to the west. if not heights: return 0 count = 1 # The first building always has a clear view max_height = heights[0] for height in heights[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"from typing import List def can_traverse(grid: List[List[int]], m: int, n: int, sr: int, sc: int, threshold: int) -> int: Helper function to check the number of cells that can be traversed starting from (sr, sc). pass def find_best_starting_point(grid: List[List[int]], m: int, n: int, height_threshold: int) -> int: Determine the smallest value in the grid greater than or equal to height_threshold that allows the maximum path. If no such path exists, return -1. >>> grid = [ [1, 2, 3], [6, 5, 4], [7, 8, 7], ] >>> find_best_starting_point(grid, 3, 3, 5) 5 >>> grid = [ [10, 12, 10], [8, 9, 11], [7, 9, 9], ] >>> find_best_starting_point(grid, 3, 3, 9) 9 >>> grid = [ [1, 2, 3, 4], [5, 7, 6, 1], [8, 9, 9, 10], [4, 4, 5, 5] ] >>> find_best_starting_point(grid, 4, 4, 5) 5 >>> grid = [ [20, 22, 24], [18, 19, 21], [15, 17, 18], ] >>> find_best_starting_point(grid, 3, 3, 23) 24 >>> grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0], ] >>> find_best_starting_point(grid, 3, 3, 1) -1 pass","solution":"from collections import deque def can_traverse(grid, m, n, sr, sc, threshold): visited = [[False] * n for _ in range(m)] queue = deque([(sr, sc)]) visited[sr][sc] = True count = 1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc]: if abs(grid[nr][nc] - grid[r][c]) <= 1: visited[nr][nc] = True queue.append((nr, nc)) count += 1 return count def find_best_starting_point(grid, m, n, height_threshold): best_start_value = float('inf') max_reachable_cells = 0 for r in range(m): for c in range(n): if grid[r][c] >= height_threshold: reachable_cells = can_traverse(grid, m, n, r, c, height_threshold) if reachable_cells > max_reachable_cells or (reachable_cells == max_reachable_cells and grid[r][c] < best_start_value): best_start_value = grid[r][c] max_reachable_cells = reachable_cells return -1 if best_start_value == float('inf') else best_start_value"},{"question":"def find_dominant_elements(nums): Returns an array of dominant elements from the given list of integers. An element is dominant if it is greater than all elements to its right. >>> find_dominant_elements([]) [] >>> find_dominant_elements([1]) [1] >>> find_dominant_elements([7, 7, 7, 7]) [7] >>> find_dominant_elements([1, 2, 3, 4, 5]) [5] >>> find_dominant_elements([5, 4, 3, 2, 1]) [5, 4, 3, 2, 1] >>> find_dominant_elements([16, 17, 4, 3, 5, 2]) [17, 5, 2] >>> find_dominant_elements([16, 17, 4, 3, 10, 5, 2]) [17, 10, 5, 2]","solution":"def find_dominant_elements(nums): Returns an array of dominant elements from the given list of integers. An element is dominant if it is greater than all elements to its right. if not nums: return [] dominant_elements = [] max_from_right = float('-inf') for num in reversed(nums): if num > max_from_right: dominant_elements.append(num) max_from_right = num return dominant_elements[::-1]"},{"question":"def canPartitionKSubsets(arr: List[int], k: int) -> bool: Determines whether it is possible to partition the list \`arr\` into \`k\` subsets such that the sum of the elements in each subset is the same. >>> canPartitionKSubsets([4, 3, 2, 3, 5, 2, 1], 4) True >>> canPartitionKSubsets([1, 2, 3, 4], 3) False","solution":"def canPartitionKSubsets(arr, k): def can_partition(start, k, current_sum, target, visited): if k == 1: return True if current_sum == target: return can_partition(0, k - 1, 0, target, visited) for i in range(start, len(arr)): if not visited[i] and current_sum + arr[i] <= target: visited[i] = True if can_partition(i + 1, k, current_sum + arr[i], target, visited): return True visited[i] = False return False total = sum(arr) if total % k != 0: return False target_sum = total // k visited = [False] * len(arr) arr.sort(reverse=True) return can_partition(0, k, 0, target_sum, visited)"},{"question":"def final_position(s: str) -> List[int]: Returns the final position of the robot after executing the commands in s. >>> final_position('RRRR') == [4, 0] >>> final_position('LLLL') == [-4, 0] >>> final_position('UUUU') == [0, 4] >>> final_position('LUUR') == [0, 2] >>> final_position('') == [0, 0] >>> final_position('UUULU') == [-1, 4]","solution":"def final_position(s): Returns the final position of the robot after executing the commands in s. x, y = 0, 0 for command in s: if command == 'L': x -= 1 elif command == 'R': x += 1 elif command == 'U': y += 1 return [x, y]"},{"question":"def process_operations(s, operations): Processes the given operations on the string \`s\`. Args: - s (str): The input string. - operations (list of lists): The list of operations where each operation is represented by a list. Returns: - list: A list of results for all type 2 queries. from typing import List def test_process_operations(): # Test case with both replacement and count s = \\"abcde\\" operations = [ [1, 0, 1, 'a'], # Replace 'a' with 'b', resulting string: \\"bbcde\\" [1, 2, 4, 'd'], # Replace 'd' with 'e', resulting string: \\"bbcee\\" [2, 0, 4, 'b'], # Count occurrences of 'b' in \\"bbcee\\", expected result: 2 [2, 0, 4, 'e'] # Count occurrences of 'e' in \\"bbcee\\", expected result: 2 ] assert process_operations(s, operations) == [2, 2] # Test case with wrap around s = \\"az\\" operations = [ [1, 0, 1, 'z'], # Replace 'z' with 'a', resulting string: \\"aa\\" [2, 0, 1, 'a'] # Count occurrences of 'a' in \\"aa\\", expected result: 2 ] assert process_operations(s, operations) == [2] # Test case with no matching character to replace s = \\"abc\\" operations = [ [1, 0, 2, 'z'], # No 'z' in \\"abc\\", resulting string remains: \\"abc\\" [2, 0, 2, 'a'], # Count occurrences of 'a' in \\"abc\\", expected result: 1 ] assert process_operations(s, operations) == [1] # Test case with multiple type 2 queries s = \\"abcabc\\" operations = [ [2, 0, 5, 'a'], # Count occurrences of 'a' in \\"abcabc\\", expected result: 2 [2, 0, 5, 'b'], # Count occurrences of 'b' in \\"abcabc\\", expected result: 2 [2, 0, 5, 'c'], # Count occurrences of 'c' in \\"abcabc\\", expected result: 2 ] assert process_operations(s, operations) == [2, 2, 2] # Test case with only type 2 queries s = \\"abcdefgh\\" operations = [ [2, 0, 7, 'a'], # Count occurrences of 'a' in \\"abcdefgh\\", expected result: 1 [2, 0, 7, 'h'], # Count occurrences of 'h' in \\"abcdefgh\\", expected result: 1 ] assert process_operations(s, operations) == [1, 1]","solution":"def process_operations(s, operations): Processes the given operations on the string \`s\`. Args: - s (str): The input string. - operations (list of lists): The list of operations where each operation is represented by a list. Returns: - list: A list of results for all type 2 queries. def replace_next_char(c): return chr(((ord(c) - ord('a') + 1) % 26) + ord('a')) s_list = list(s) results = [] for operation in operations: type_op, left, right, char = operation if type_op == 1: for i in range(left, right + 1): if s_list[i] == char: s_list[i] = replace_next_char(char) elif type_op == 2: count = sum(1 for i in range(left, right + 1) if s_list[i] == char) results.append(count) return results"},{"question":"from typing import List, Dict from collections import defaultdict def maxPerformanceInLineOfCommand(CEO: int, edges: List[List[int]], performance: Dict[int, int]) -> int: Given the hierarchical structure of a company represented as a tree, find the maximum total performance score of any direct line of command starting from the CEO down to any of the hierarchy's leaf nodes. Parameters: - CEO (int): The id of the CEO. - edges (List[List[int]]): A list where edges[i] = [manager, employee] indicates that the employee directly reports to the manager. - performance (Dict[int, int]): A dictionary where performance[i] represents the performance score of employee i. Returns: - int: The maximum total performance score from the CEO to any leaf node. Example: >>> maxPerformanceInLineOfCommand(1, [[1, 2], [1, 3], [2, 4], [3, 5], [3, 6]], {1: 5, 2: 3, 3: 4, 4: 2, 5: 1, 6: 7}) 16","solution":"from collections import defaultdict def maxPerformanceInLineOfCommand(CEO, edges, performance): def dfs(node): if node not in tree: return performance[node] max_perf = float('-inf') for child in tree[node]: max_perf = max(max_perf, dfs(child)) return performance[node] + max_perf # Create the hierarchical tree tree = defaultdict(list) for manager, employee in edges: tree[manager].append(employee) return dfs(CEO)"},{"question":"def find_longest_balanced_substring(s: str) -> str: Given a string \`s\` consisting only of characters 'a' and 'b', find the longest balanced substring in \`s\`. A balanced substring contains an equal number of 'a's and 'b's. If there are multiple longest balanced substrings, return the first one. If there is no balanced substring, return an empty string. >>> find_longest_balanced_substring(\\"aababb\\") \\"aababb\\" >>> find_longest_balanced_substring(\\"aaaa\\") \\"\\"","solution":"def find_longest_balanced_substring(s): Returns the longest balanced substring containing equal number of 'a's and 'b's. If multiple longest balanced substrings exist, returns the first one. If no balanced substring exists, returns an empty string. max_len = 0 max_substr_start = -1 for i in range(len(s)): count_a = 0 count_b = 0 for j in range(i, len(s)): if s[j] == 'a': count_a += 1 else: count_b += 1 if count_a == count_b: if (j - i + 1) > max_len: max_len = j - i + 1 max_substr_start = i if max_len > 0: return s[max_substr_start:max_substr_start + max_len] return \\"\\""},{"question":"def longest_vowel_substring(s: str) -> int: Returns the length of the longest contiguous substring that contains only vowels. Parameters: s (str): The input string Returns: int: The length of the longest contiguous vowel-only substring >>> longest_vowel_substring(\\"bcdfg\\") == 0 >>> longest_vowel_substring(\\"a\\") == 1 >>> longest_vowel_substring(\\"bca\\") == 1 >>> longest_vowel_substring(\\"aeiou\\") == 5 >>> longest_vowel_substring(\\"hellobeautifulworld\\") == 3 >>> longest_vowel_substring(\\"abcdeiouxyz\\") == 4 >>> longest_vowel_substring(\\"aaeeiioouu\\") == 10","solution":"def longest_vowel_substring(s): Returns the length of the longest contiguous substring that contains only vowels. Parameters: s (str): The input string Returns: int: The length of the longest contiguous vowel-only substring vowels = {'a', 'e', 'i', 'o', 'u'} max_len = 0 current_len = 0 for char in s: if char in vowels: current_len += 1 max_len = max(max_len, current_len) else: current_len = 0 return max_len"},{"question":"def count_zeros(matrix): Counts the total number of 0s in a sorted binary matrix. :param matrix: 2D list representing the binary matrix :return: int representing the total number of 0s in matrix >>> count_zeros([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 9 >>> count_zeros([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 0 >>> count_zeros([[0, 0, 1], [0, 1, 1], [0, 0, 0]]) == 6 >>> count_zeros([]) == 0 >>> count_zeros([[0, 0, 1, 1]]) == 2 >>> count_zeros([[0], [0], [1]]) == 2","solution":"def count_zeros(matrix): Counts the total number of 0s in a sorted binary matrix. :param matrix: 2D list representing the binary matrix :return: int representing the total number of 0s in matrix total_zeros = 0 for row in matrix: # Find the first occurrence of 1 in the row for elem in row: if elem == 1: break total_zeros += 1 return total_zeros"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BinarySearchTreeIterator: Iterator for binary tree that returns values in in-order traversal. def __init__(self, root: TreeNode): Initializes the iterator with the root of the binary tree. def next(self) -> int: Returns the next smallest number in the binary tree. def hasNext(self) -> bool: Returns true if there exists a number within the tree traversal to be visited, otherwise returns false. def test_single_node_tree(): root = TreeNode(1) iterator = BinarySearchTreeIterator(root) assert iterator.hasNext() == True assert iterator.next() == 1 assert iterator.hasNext() == False def test_simple_tree(): root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(3) iterator = BinarySearchTreeIterator(root) assert iterator.hasNext() == True assert iterator.next() == 1 assert iterator.hasNext() == True assert iterator.next() == 2 assert iterator.hasNext() == True assert iterator.next() == 3 assert iterator.hasNext() == False def test_large_tree(): Tree structure: 4 / 2 6 / / 1 3 5 7 root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(6) root.left.left = TreeNode(1) root.left.right = TreeNode(3) root.right.left = TreeNode(5) root.right.right = TreeNode(7) iterator = BinarySearchTreeIterator(root) expected_order = [1, 2, 3, 4, 5, 6, 7] for val in expected_order: assert iterator.hasNext() == True assert iterator.next() == val assert iterator.hasNext() == False def test_empty_tree(): iterator = BinarySearchTreeIterator(None) assert iterator.hasNext() == False","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BinarySearchTreeIterator: def __init__(self, root): Initializes the iterator with the root of the binary tree. self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): Helper function to add all the nodes in the leftmost branch of the tree to the stack. while root: self.stack.append(root) root = root.left def next(self): Returns the next smallest number in the binary tree. # The topmost element of the stack is the next smallest element topmost_node = self.stack.pop() # If the node has a right child, we do the inorder traversal for the right child if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self): Returns true if there exists a number within the tree traversal to be visited, otherwise returns false. return len(self.stack) > 0"},{"question":"def findLongestSubstring(s: str, k: int) -> int: Determines the length of the longest substring of s that is both a valid integer and less than or equal to k without leading zeros, unless it is exactly '0'. >>> findLongestSubstring(\\"12345678\\", 123) 3 >>> findLongestSubstring(\\"012345\\", 12) 2 pass","solution":"def findLongestSubstring(s, k): Determines the length of the longest substring of s that is both a valid integer and less than or equal to k without leading zeros, unless it is exactly '0'. max_length = 0 n = len(s) for i in range(n): if s[i] == '0': # Always consider '0' as valid max_length = max(max_length, 1) continue num = 0 for j in range(i, n): num = num * 10 + int(s[j]) if num > k: break if s[i] != '0': # check if the substring has valid non-leadning zero integer max_length = max(max_length, j - i + 1) return max_length"},{"question":"def maximize_final_element(nums: List[int]) -> int: Maximize the final element remaining in the array after performing the specified operations. In each operation, you can pick any two adjacent elements and replace them with their sum. After each operation, the length of the array decreases by one. Args: nums: List[int] - list of integers Returns: int - the maximum possible value of the final element >>> maximize_final_element([5]) 5 >>> maximize_final_element([1, 2, 3, 4]) 10 >>> maximize_final_element([-1, -2, -3, -4]) -10 >>> maximize_final_element([-1, 2, -3, 4]) 2 >>> maximize_final_element([0, 0, 0, 0]) 0 >>> maximize_final_element([100000, 200000, 300000]) 600000 >>> maximize_final_element([1, -1, 1, -1]) 0","solution":"def maximize_final_element(nums): Returns the maximum possible value of the final element after performing the given operations. In each operation, you can replace any two adjacent elements with their sum. return sum(nums)"},{"question":"import heapq from typing import List def kthSmallest(matrix: List[List[int]], k: int) -> int: Returns the k-th smallest element in a n x n matrix that is sorted row-wise and column-wise. >>> kthSmallest([ [1, 5, 9], [10, 11, 13], [12, 13, 15] ], 8) 13 >>> kthSmallest([[1]], 1) 1 >>> kthSmallest([ [1, 1, 3], [1, 1, 3], [3, 3, 3] ], 5) 3 >>> kthSmallest([ [2, 2], [2, 2] ], 3) 2 >>> kthSmallest([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], 9) 9","solution":"import heapq def kthSmallest(matrix, k): Returns the k-th smallest element in a n x n matrix that is sorted row-wise and column-wise. n = len(matrix) min_heap = [] # Start with the first element of each row for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min k-1 times for _ in range(k - 1): element, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) # The root of the heap is the k-th smallest element return heapq.heappop(min_heap)[0]"},{"question":"def longest_sentence_length(paragraph: str) -> int: Given a string \`paragraph\`, return the length of the longest sentence in the paragraph. A sentence is defined as a sequence of words separated by spaces and terminated by a period (.), exclamation mark (!), or question mark (?). Words consist of only alphabetic characters and may be connected by apostrophes (e.g., it's). >>> longest_sentence_length(\\"Hello world!\\") == 2 >>> longest_sentence_length(\\"Hello world! This is an example sentence.\\") == 5 >>> longest_sentence_length(\\"It's a sunny day! Isn't it wonderful?\\") == 4","solution":"def longest_sentence_length(paragraph): Returns the length of the longest sentence in the paragraph. import re # Split the paragraph by sentence terminators sentences = re.split(r'[.!?]', paragraph) # Removing leading/trailing spaces and calculate words in each sentence max_length = 0 for sentence in sentences: words = sentence.strip().split() word_count = len(words) if word_count > max_length: max_length = word_count return max_length"},{"question":"def maximize_sum_after_k_negations(arr, k): Returns the maximum possible sum of the array after performing exactly k negations. Parameters: arr (list): List of integers. k (int): Number of negation operations to perform. Returns: int: Maximum possible sum of the array after k negations. >>> maximize_sum_after_k_negations([4, 2, 3], 1) 5 >>> maximize_sum_after_k_negations([3, -1, 0, 2], 3) 6 >>> maximize_sum_after_k_negations([-2, -3, -4], 2) 5 >>> maximize_sum_after_k_negations([2, -3, -1, 5, -4], 5) 15 >>> maximize_sum_after_k_negations([-5], 1) 5 >>> maximize_sum_after_k_negations([-1, -2, -3], 0) -6","solution":"def maximize_sum_after_k_negations(arr, k): Returns the maximum possible sum of the array after performing exactly k negations. Parameters: arr (list): List of integers. k (int): Number of negation operations to perform. Returns: int: Maximum possible sum of the array after k negations. # Sort the array arr.sort() # Perform the negations for i in range(len(arr)): if k > 0 and arr[i] < 0: arr[i] = -arr[i] k -= 1 # If we still have an odd number of negations remaining, perform one more negation if k % 2 == 1: # Find the smallest element in the array arr.sort() arr[0] = -arr[0] # Return the sum of the array return sum(arr)"},{"question":"def longestSubsequence(arr: List[int]) -> int: Finds the length of the longest subsequence where the difference between adjacent elements is exactly 1. >>> longestSubsequence([4, 2, 3, 5, 3, 2, 1, 4]) == 4 # Expected subsequence: [2, 3, 2, 1] >>> longestSubsequence([1]) == 1 >>> longestSubsequence([10, 20, 30, 40]) == 1 >>> longestSubsequence([1, 1, 1, 1]) == 1 >>> longestSubsequence([1, 2, 1, 2, 1]) == 5 # Expected subsequence: [1, 2, 1, 2, 1] >>> longestSubsequence([5, 4, 3, 2, 1]) == 5 # Expected subsequence: [5, 4, 3, 2, 1] >>> longestSubsequence([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9 # The whole array is already a valid sequence","solution":"def longestSubsequence(arr): Finds the length of the longest subsequence where the difference between adjacent elements is exactly 1. if not arr: return 0 from collections import defaultdict dp = defaultdict(int) # To store the longest subsequence ending with a particular number max_length = 1 for num in arr: # The longest subsequence ending with \`num\` is either starting a new sequence or extending the sequence ending with \`num-1\` or \`num+1\` dp[num] = max(dp[num], dp[num-1] + 1, dp[num+1] + 1) max_length = max(max_length, dp[num]) return max_length"},{"question":"def min_operations_to_transform(s: str, t: str) -> int: Returns the minimum number of operations required to transform s into t. If it's impossible to transform s into t, return -1. >>> min_operations_to_transform(\\"abc\\", \\"abc\\") 0 >>> min_operations_to_transform(\\"abc\\", \\"aaa\\") 1 >>> min_operations_to_transform(\\"abc\\", \\"def\\") -1 >>> min_operations_to_transform(\\"abcd\\", \\"abc\\") -1 >>> min_operations_to_transform(\\"abb\\", \\"aaa\\") 1 >>> min_operations_to_transform(\\"abcd\\", \\"aaaa\\") 1 >>> min_operations_to_transform(\\"abbcc\\", \\"abcac\\") 1","solution":"def min_operations_to_transform(s, t): Returns the minimum number of operations required to transform s into t. If it's impossible to transform s into t, return -1. if len(s) != len(t): return -1 # Create a set of unique characters in both strings unique_s = set(s) unique_t = set(t) # Check if for every character in t, there exists a corresponding character in s if not unique_t.issubset(unique_s): return -1 # If s == t, no operation is needed if s == t: return 0 return 1"},{"question":"def min_remove_to_increase(nums) -> tuple: Given a sorted list \`nums\`, returns a tuple where: - The first element is the minimum number of elements to remove so that the remaining list is strictly increasing. - The second element is the length of the longest strictly increasing subsequence that can be achieved from the original list. >>> min_remove_to_increase([1, 2, 2, 2, 3, 4, 5, 6]) == (2, 6) >>> min_remove_to_increase([1, 2, 3, 4, 5]) == (0, 5) >>> min_remove_to_increase([5, 5, 5, 5, 5]) == (4, 1) >>> min_remove_to_increase([1]) == (0, 1) >>> min_remove_to_increase([]) == (0, 0) >>> min_remove_to_increase(list(range(1, 101)) + list(range(1, 51))) == (50, 100)","solution":"from bisect import bisect_left def min_remove_to_increase(nums): Given a sorted list \`nums\`, returns a tuple where: - The first element is the minimum number of elements to remove so that the remaining list is strictly increasing. - The second element is the length of the longest strictly increasing subsequence that can be achieved from the original list. if not nums: return (0, 0) # To store the end elements of the increasing subsequences lis = [] for num in nums: pos = bisect_left(lis, num) if pos < len(lis): lis[pos] = num else: lis.append(num) # The length of LIS length_of_lis = len(lis) # The minimum number of elements to remove to form LIS min_remove = len(nums) - length_of_lis return min_remove, length_of_lis"},{"question":"from typing import List class AnagramGrouper: def __init__(self, words: List[str]): Initializes the object with the array of words. >>> grouper = AnagramGrouper([\\"listen\\"]) self.words = words def group(self) -> List[List[str]]: Returns a list of lists of strings, where each list contains all the anagrams grouped together from the original array. >>> grouper = AnagramGrouper([\\"listen\\", \\"silent\\", \\"rat\\", \\"tar\\", \\"god\\", \\"dog\\"]) >>> result = grouper.group() >>> sorted(result) == sorted([[\\"listen\\", \\"silent\\"], [\\"rat\\", \\"tar\\"], [\\"god\\", \\"dog\\"]]) True","solution":"from collections import defaultdict class AnagramGrouper: def __init__(self, words): self.words = words def group(self): anagram_map = defaultdict(list) for word in self.words: sorted_word = ''.join(sorted(word)) anagram_map[sorted_word].append(word) return list(anagram_map.values())"},{"question":"def min_rectangles_to_form_skyline(height): Calculates the minimum number of rectangles required to form the skyline. Parameters: height (List[int]): A list of integer heights of buildings. Returns: int: The minimum number of rectangles needed to represent the skyline. >>> min_rectangles_to_form_skyline([4]) == 1 >>> min_rectangles_to_form_skyline([4, 4, 4, 4]) == 1 >>> min_rectangles_to_form_skyline([1, 2, 3, 4]) == 4 >>> min_rectangles_to_form_skyline([4, 3, 2, 1]) == 4 >>> min_rectangles_to_form_skyline([1, 2, 2, 3, 2, 1]) == 5 >>> min_rectangles_to_form_skyline([]) == 0 >>> min_rectangles_to_form_skyline([1, 3, 2, 3, 1, 2]) == 6","solution":"def min_rectangles_to_form_skyline(height): Calculates the minimum number of rectangles required to form the skyline. Parameters: height (List[int]): A list of integer heights of buildings. Returns: int: The minimum number of rectangles needed to represent the skyline. if not height: return 0 count = 0 n = len(height) # Scan through the buildings and count the number of height changes for i in range(1, n): if height[i] != height[i-1]: count += 1 # Including the initial rectangle return count + 1"},{"question":"def allocate_tables(tables, reservations): Determines if each reservation can be allocated to a table. Parameters: tables (List[int]): A 1-indexed list of integers representing the table's sizes. reservations (List[int]): A list of integers where each integer represents a reservation size. Returns: List[bool]: A list of booleans indicating if a reservation can be successfully allocated. Examples: >>> allocate_tables([2, 3, 4], [2]) [True] >>> allocate_tables([1, 2, 3], [1, 2, 3]) [True, True, True] >>> allocate_tables([2, 3], [4]) [False] >>> allocate_tables([2, 3, 4], [2, 5, 3]) [True, False, True] >>> allocate_tables([2, 2, 2], [2, 2, 2]) [True, True, True] >>> allocate_tables([], [1, 2, 3]) [False, False, False] >>> allocate_tables([1, 2, 3], []) [] >>> allocate_tables([1, 2, 3, 4], [4, 3, 2, 1]) [True, True, True, True] >>> allocate_tables([3, 3, 3], [3, 3]) [True, True] >>> allocate_tables([2, 2, 4], [2, 5, 2]) [True, False, True]","solution":"def allocate_tables(tables, reservations): Determines if each reservation can be allocated to a table. Parameters: tables (List[int]): A 1-indexed list of integers representing the table's sizes. reservations (List[int]): A list of integers where each integer represents a reservation size. Returns: List[bool]: A list of booleans indicating if a reservation can be successfully allocated. available_tables = tables[:] # Copy of the table sizes to keep track of available capacities allocation_results = [] for reservation in reservations: # Iterate through available tables to find a suitable one successful_allocation = False for i in range(len(available_tables)): if available_tables[i] >= reservation: # Mark table as occupied by setting its size to 0 available_tables[i] = 0 successful_allocation = True break allocation_results.append(successful_allocation) return allocation_results"},{"question":"def reverse_first_k_chars(s: str, k: int) -> str: Reverse the order of the first k characters of the string s. If k is greater than the length of the string, reverse the entire string. >>> reverse_first_k_chars(\\"abcdefg\\", 3) \\"cbadefg\\" >>> reverse_first_k_chars(\\"abcdefg\\", 10) \\"gfedcba\\" >>> reverse_first_k_chars(\\"abcdefg\\", 7) \\"gfedcba\\" >>> reverse_first_k_chars(\\"\\", 5) \\"\\" >>> reverse_first_k_chars(\\"abcdefg\\", 0) \\"abcdefg\\" >>> reverse_first_k_chars(\\"abcdefg\\", 1) \\"abcdefg\\" >>> reverse_first_k_chars(\\"a\\", 2) \\"a\\" >>> reverse_first_k_chars(\\"ab\\", 1) \\"ab\\" >>> reverse_first_k_chars(\\"abcdef\\", 3) \\"cbadef\\"","solution":"def reverse_first_k_chars(s, k): Reverse the order of the first k characters of the string s. If k is greater than the length of string s, reverse the entire string. :param s: str - The input string to be partially reversed :param k: int - The number of characters to reverse from the start :return: str - The resulting string after the reversal if k > len(s): return s[::-1] return s[:k][::-1] + s[k:]"},{"question":"from typing import List def sort_by_frequency(arr: List[int]) -> List[int]: Sorts the array in descending order of frequency of their occurrence. If two elements have the same frequency, their order in the output array should be in descending numerical order. >>> sort_by_frequency([4, 3, 1, 2, 2, 3, 3, 4, 4, 4]) [4, 3, 2, 1] >>> sort_by_frequency([1, 2, 3, 4]) [4, 3, 2, 1] >>> sort_by_frequency([4, 3, 2, 1, 4, 3, 2, 1]) [4, 3, 2, 1] >>> sort_by_frequency([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) [4, 3, 2, 1] >>> sort_by_frequency([1, 1, 1, 1]) [1]","solution":"from collections import Counter def sort_by_frequency(arr): Sorts the array in descending order of frequency of their occurrence. If two elements have the same frequency, their order in the output array should be in descending numerical order. # Count the frequency of each element frequency_count = Counter(arr) # Sort primarily by frequency (descending) and secondarily by value (descending) sorted_elements = sorted(frequency_count.keys(), key=lambda x: (-frequency_count[x], -x)) return sorted_elements"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root: TreeNode) -> bool: Determine if the binary tree is symmetric around its center. >>> root = TreeNode(1) >>> root.left = TreeNode(2, TreeNode(3), TreeNode(4)) >>> root.right = TreeNode(2, TreeNode(4), TreeNode(3)) >>> is_symmetric(root) True >>> is_symmetric(None) True >>> root = TreeNode(1) >>> is_symmetric(root) True >>> root.left = TreeNode(2, None, TreeNode(3)) >>> root.right = TreeNode(2, None, TreeNode(3)) >>> is_symmetric(root) False >>> root.left = TreeNode(2, None, TreeNode(3)) >>> root.right = TreeNode(2, TreeNode(4), TreeNode(3)) >>> is_symmetric(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root): Determines if the binary tree is symmetric. if not root: return True def is_mirror(left, right): if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left) return is_mirror(root.left, root.right)"},{"question":"def merge_inventories(inventory1, inventory2): Merges inventories from two separate warehouses. :param inventory1: List of tuples (sku, quantity, price) :param inventory2: List of tuples (sku, quantity, price) :return: Merged and sorted list of inventory tuples (sku, quantity, price) >>> merge_inventories([(\\"apple\\", 50, 1.2), (\\"banana\\", 70, 0.8), (\\"orange\\", 80, 1.1)], [(\\"apple\\", 30, 1.5), (\\"banana\\", 90, 0.7), (\\"pear\\", 60, 1.3)]) [('apple', 80, 1.5), ('banana', 160, 0.8), ('orange', 80, 1.1), ('pear', 60, 1.3)] >>> merge_inventories([(\\"apple\\", 50, 1.2)], [(\\"banana\\", 90, 0.7)]) [('apple', 50, 1.2), ('banana', 90, 0.7)] >>> merge_inventories([(\\"apple\\", 50, 1.2)], [(\\"apple\\", 30, 1.5)]) [('apple', 80, 1.5)] >>> merge_inventories([], [(\\"banana\\", 90, 0.7)]) [('banana', 90, 0.7)] >>> merge_inventories([], []) [] >>> merge_inventories([(\\"apple\\", -10, 1.2)], [(\\"apple\\", 30, 1.5)]) [('apple', 20, 1.5)]","solution":"def merge_inventories(inventory1, inventory2): Merges inventories from two separate warehouses. :param inventory1: List of tuples (sku, quantity, price) :param inventory2: List of tuples (sku, quantity, price) :return: Merged and sorted list of inventory tuples (sku, quantity, price) from collections import defaultdict merged_inventory = defaultdict(lambda: [0, 0]) for sku, quantity, price in inventory1 + inventory2: merged_inventory[sku][0] += quantity merged_inventory[sku][1] = max(merged_inventory[sku][1], price) merged_inventory_list = [(sku, info[0], info[1]) for sku, info in merged_inventory.items()] merged_inventory_list.sort(key=lambda x: x[0]) return merged_inventory_list"},{"question":"def two_sum(nums, target): Return the indices of the two numbers such that they add up to a specific target. Parameters: nums (list of int): The list of integers. target (int): The target sum. Returns: tuple: A tuple containing the indices of the two numbers. >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([1, 2, 3, 4], 7) (2, 3) >>> two_sum([-1, -2, -3, -4], -7) (2, 3) >>> two_sum([-3, 4, 3, 90], 0) (0, 2) >>> two_sum([1000000, 3, 7, -1000000], 0) (0, 3) >>> two_sum([3, 3], 6) (0, 1)","solution":"def two_sum(nums, target): Return the indices of the two numbers such that they add up to a specific target. Parameters: nums (list of int): The list of integers. target (int): The target sum. Returns: tuple: A tuple containing the indices of the two numbers. num_map = {} for i, num in enumerate(nums): complement = target - num if complement in num_map: return (num_map[complement], i) num_map[num] = i # Example usage print(two_sum([2, 7, 11, 15], 9)) # Output should be (0, 1)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_left_leaves(root): Return the sum of all left leaves in the binary tree rooted at \`root\`. >>> root = TreeNode(1, TreeNode(2)) >>> sum_of_left_leaves(root) 2 >>> root = TreeNode(1, right=TreeNode(3, right=TreeNode(4))) >>> sum_of_left_leaves(root) 0 >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, TreeNode(5, TreeNode(7)), TreeNode(6))) >>> sum_of_left_leaves(root) 11 >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) >>> sum_of_left_leaves(root) 10 >>> root = TreeNode(1) >>> sum_of_left_leaves(root) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_left_leaves(root): Return the sum of all left leaves in the binary tree rooted at \`root\`. def is_leaf(node): return node is not None and node.left is None and node.right is None def dfs(node): if node is None: return 0 sum_left_leaves = 0 if node.left and is_leaf(node.left): sum_left_leaves += node.left.val sum_left_leaves += dfs(node.left) sum_left_leaves += dfs(node.right) return sum_left_leaves return dfs(root)"},{"question":"def apply_operations(nums: List[int]) -> List[int]: Given an array of integers 'nums', this function returns an array 'operations' where each element at index 'i' of 'operations' is incremented based on the elements in 'nums'. The length of 'operations' is the maximum value in 'nums' plus one. >>> apply_operations([]) == [] >>> apply_operations([2]) == [0, 0, 1] >>> apply_operations([1, 2, 2, 3]) == [0, 1, 2, 1] >>> apply_operations([0, 0, 0, 0]) == [4] >>> apply_operations([0, 3, 3, 1]) == [1, 1, 0, 2] >>> apply_operations([10, 10, 5]) == [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2] pass","solution":"def apply_operations(nums): Given an array of integers 'nums', this function returns an array 'operations' where each element at index 'i' of 'operations' is incremented based on the elements in 'nums'. The length of 'operations' is the maximum value in 'nums' plus one. if not nums: return [] max_val = max(nums) operations = [0] * (max_val + 1) for num in nums: operations[num] += 1 return operations"},{"question":"def remove_adjacent_duplicates(s: str) -> str: Removes adjacent duplicate characters in the string s until no such duplicates are left. >>> remove_adjacent_duplicates(\\"abbacca\\") == \\"a\\" >>> remove_adjacent_duplicates(\\"abcde\\") == \\"abcde\\" >>> remove_adjacent_duplicates(\\"aabbcc\\") == \\"\\" >>> remove_adjacent_duplicates(\\"abcddcba\\") == \\"\\" >>> remove_adjacent_duplicates(\\"a\\") == \\"a\\" >>> remove_adjacent_duplicates(\\"\\") == \\"\\"","solution":"def remove_adjacent_duplicates(s): Removes adjacent duplicates characters in the string s until no such duplicates are left. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"from typing import List, Tuple import itertools def is_valid_permutation(perm: Tuple[int], k: int) -> bool: Check if the permutation is valid by ensuring the absolute difference between each adjacent element is at least k. >>> is_valid_permutation([1, 4, 7], 3) == True >>> is_valid_permutation([1, 2, 3], 2) == False pass def valid_permutations(nums: List[int], k: int) -> List[Tuple[int]]: Returns all permutations of nums where the absolute difference between each adjacent element in the permutation is at least k. >>> valid_permutations([1, 2, 3], 2) == [] >>> valid_permutations([1, 3, 5], 2) == [(1, 3, 5), (1, 5, 3), (3, 1, 5), (3, 5, 1), (5, 1, 3), (5, 3, 1)] >>> valid_permutations([4, 1, 7], 3) == [(1, 4, 7), (1, 7, 4), (4, 1, 7), (4, 7, 1), (7, 1, 4), (7, 4, 1)] pass","solution":"import itertools def is_valid_permutation(perm, k): for i in range(1, len(perm)): if abs(perm[i] - perm[i - 1]) < k: return False return True def valid_permutations(nums, k): Returns all permutations of nums where the absolute difference between each adjacent element in the permutation is at least k. all_perms = itertools.permutations(nums) valid_perms = [perm for perm in all_perms if is_valid_permutation(perm, k)] return valid_perms"},{"question":"def minAddToMakeValid(s: str) -> int: Return the minimum number of parentheses to be added to make the string valid. >>> minAddToMakeValid(\\"(()())\\") == 0 >>> minAddToMakeValid(\\"()\\") == 0 >>> minAddToMakeValid(\\")))((\\") == 5 >>> minAddToMakeValid(\\"(()))\\") == 1 >>> minAddToMakeValid(\\"((())\\") == 1 >>> minAddToMakeValid(\\"\\") == 0 >>> minAddToMakeValid(\\"(\\") == 1 >>> minAddToMakeValid(\\")\\") == 1 >>> minAddToMakeValid(\\"()(\\") == 1 >>> minAddToMakeValid(\\"())\\") == 1","solution":"def minAddToMakeValid(s): Return the minimum number of parentheses to be added to make the string valid. left_count = 0 right_needed = 0 for char in s: if char == '(': left_count += 1 elif char == ')': if left_count > 0: left_count -= 1 else: right_needed += 1 return left_count + right_needed"},{"question":"from typing import List def min_changes_to_satisfy_condition(heights: List[int]) -> int: Determine the minimum number of students that need to change positions so that all the students have heights strictly different from both their neighbors (if they have two neighbors). Args: - heights: A list of integers representing the heights of students in a line. Returns: - An integer representing the minimum number of students that need to change positions. Examples: >>> min_changes_to_satisfy_condition([1, 2, 3]) == 0 >>> min_changes_to_satisfy_condition([1, 3, 2, 4]) == 0 >>> min_changes_to_satisfy_condition([1, 1, 1, 1]) == 2 >>> min_changes_to_satisfy_condition([1, 2, 2, 3, 4]) == 1 >>> min_changes_to_satisfy_condition([1, 2, 2, 2, 3]) == 2 >>> min_changes_to_satisfy_condition([5, 5, 5, 5, 5, 5]) == 4 >>> min_changes_to_satisfy_condition([1, 1]) == 0 >>> min_changes_to_satisfy_condition([1]) == 0","solution":"def min_changes_to_satisfy_condition(heights): Returns the minimum number of students that need to change positions so that all students have heights strictly different from both their neighbors. n = len(heights) if n < 3: return 0 # If there are less than 3 students, no changes are needed. changes = 0 for i in range(1, n-1): if heights[i] == heights[i-1] or heights[i] == heights[i+1]: changes += 1 if heights[i-1] != heights[i+1]: heights[i] = heights[i-1] if heights[i] != heights[i-1] else heights[i+1] else: heights[i] = heights[i-1] + 1 # Changing height to ensure it's different from both neighbors return changes"},{"question":"from collections import deque def shortest_path(graph, source, destination): Finds the length of the shortest path between source and destination in a directed graph. Parameters: graph (dict): The graph represented as an adjacency list. source (int): The start node. destination (int): The end node. Returns: int: Length of the shortest path, or -1 if no path exists. Example usage: >>> shortest_path({0: [1], 1: [2], 2: []}, 0, 2) 2 >>> shortest_path({0: [1], 1: [], 2: [3], 3: []}, 0, 3) -1 >>> shortest_path({0: [1], 1: [2], 2: [0, 3], 3: [1]}, 0, 3) 3","solution":"from collections import deque def shortest_path(graph, source, destination): Finds the length of the shortest path between source and destination in a directed graph. Parameters: graph (dict): The graph represented as an adjacency list. source (int): The start node. destination (int): The end node. Returns: int: Length of the shortest path, or -1 if no path exists. if source == destination: return 0 visited = set() queue = deque([(source, 0)]) # (current_node, current_distance) while queue: current_node, current_distance = queue.popleft() if current_node == destination: return current_distance visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor not in visited: queue.append((neighbor, current_distance + 1)) return -1"},{"question":"def max_profit_with_two_transactions(prices: List[int]) -> int: Calculate the maximum profit from at most two transactions. >>> max_profit_with_two_transactions([]) 0 >>> max_profit_with_two_transactions([5]) 0 >>> max_profit_with_two_transactions([1, 5]) 4 >>> max_profit_with_two_transactions([7, 6, 4, 3, 1]) 0 >>> max_profit_with_two_transactions([1, 2, 4, 2, 5, 7, 2, 4, 9, 0]) 13 >>> max_profit_with_two_transactions([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> max_profit_with_two_transactions([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 9 >>> max_profit_with_two_transactions([3, 2, 6, 5, 0, 3]) 7","solution":"def max_profit_with_two_transactions(prices): if not prices: return 0 n = len(prices) # Initialize the dp arrays left_profits = [0] * n right_profits = [0] * n # Fill the left_profits array where left_profits[i] represents # the max profit that can be achieved from day 0 to day i min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) left_profits[i] = max(left_profits[i-1], prices[i] - min_price) # Fill the right_profits array where right_profits[i] represents # the max profit that can be achieved from day i to the last day max_price = prices[-1] for i in range(n-2, -1, -1): max_price = max(max_price, prices[i]) right_profits[i] = max(right_profits[i+1], max_price - prices[i]) # Calculate the maximum profit by adding left and right profits max_profit = 0 for i in range(n): max_profit = max(max_profit, left_profits[i] + right_profits[i]) return max_profit"},{"question":"from typing import List def max_path_sum(grid: List[List[int]]) -> int: Finds the maximum sum of values along any path from the top-left to the bottom-right corner. :param grid: List of lists of integers, the grid data :return: Integer, the maximum sum >>> max_path_sum([[5]]) 5 >>> max_path_sum([[1, 3], [2, 4]]) 8 >>> max_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_path_sum([[1, 2, 3], [4, 5, 6]]) 16 >>> max_path_sum([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5 pass","solution":"def max_path_sum(grid): Finds the maximum sum of values along any path from the top-left to the bottom-right corner. :param grid: List of lists of integers, the grid data :return: Integer, the maximum sum if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # iterate through grid and update the sum path for i in range(m): for j in range(n): if i == 0 and j == 0: continue # starting point elif i == 0: grid[i][j] += grid[i][j-1] elif j == 0: grid[i][j] += grid[i-1][j] else: grid[i][j] += max(grid[i-1][j], grid[i][j-1]) return grid[m-1][n-1]"},{"question":"def good_buildings(heights: List[int]) -> List[int]: Returns the indices of all buildings that are \\"good\\", in ascending order. A building is considered \\"good\\" if there can be no shorter building to its right blocking its sunset view. >>> good_buildings([1, 2, 3, 4, 5]) [0, 1, 2, 3, 4] >>> good_buildings([5, 4, 3, 2, 1]) [0] >>> good_buildings([4, 3, 1, 5, 6]) [0, 3, 4] >>> good_buildings([3, 1, 4, 2, 5]) [0, 2, 4] >>> good_buildings([10]) [0] >>> good_buildings([7, 7, 7, 7, 7]) [0] >>> good_buildings([]) []","solution":"def good_buildings(heights): Returns the indices of all buildings that are \\"good\\", in ascending order. A building is considered \\"good\\" if there can be no shorter building to its right blocking its sunset view. n = len(heights) max_height = float('-inf') result = [] for i in range(n): if heights[i] > max_height: result.append(i) max_height = heights[i] return result"},{"question":"class ParkingLot: A system that simulates a parking lot with multiple floors and slots. Implement the following methods: - __init__(self, n: int, m: int): Initializes a parking lot with \`n\` floors and \`m\` slots per floor. - park(self, vehicleId: str, floor: int, slot: int) -> str: Parks the vehicle with ID \`vehicleId\` at the specified floor and slot. - leave(self, vehicleId: str) -> str: Removes the vehicle with the given ID from the parking lot. - getSlot(self, vehicleId: str) -> str: Returns the location (floor and slot) of the vehicle with the given ID. >>> pl = ParkingLot(3, 3) >>> pl.park(\\"ABC123\\", 0, 0) 'Vehicle ABC123 parked at floor 0, slot 0' >>> pl.park(\\"DEF456\\", 0, 1) 'Vehicle DEF456 parked at floor 0, slot 1' >>> pl.park(\\"GHI789\\", 0, 0) 'Error: Slot already taken' >>> pl.park(\\"JKL012\\", 3, 0) 'Error: Invalid floor or slot' >>> pl.park(\\"JKL012\\", 0, 3) 'Error: Invalid floor or slot' >>> pl.leave(\\"ABC123\\") 'Vehicle ABC123 left from floor 0, slot 0' >>> pl.leave(\\"DEF456\\") 'Error: Vehicle not found' >>> pl.getSlot(\\"ABC123\\") 'Error: Vehicle not found' >>> pl.getSlot(\\"DEF456\\") 'Vehicle DEF456 is at floor 1, slot 1'","solution":"class ParkingLot: def __init__(self, n, m): self.floors = n self.slots_per_floor = m self.parking_lot = [[None for _ in range(m)] for _ in range(n)] self.vehicle_map = {} def park(self, vehicleId, floor, slot): if floor >= self.floors or slot >= self.slots_per_floor: return \\"Error: Invalid floor or slot\\" if self.parking_lot[floor][slot] is not None: return \\"Error: Slot already taken\\" self.parking_lot[floor][slot] = vehicleId self.vehicle_map[vehicleId] = (floor, slot) return f\\"Vehicle {vehicleId} parked at floor {floor}, slot {slot}\\" def leave(self, vehicleId): if vehicleId not in self.vehicle_map: return \\"Error: Vehicle not found\\" floor, slot = self.vehicle_map[vehicleId] self.parking_lot[floor][slot] = None del self.vehicle_map[vehicleId] return f\\"Vehicle {vehicleId} left from floor {floor}, slot {slot}\\" def getSlot(self, vehicleId): if vehicleId not in self.vehicle_map: return \\"Error: Vehicle not found\\" floor, slot = self.vehicle_map[vehicleId] return f\\"Vehicle {vehicleId} is at floor {floor}, slot {slot}\\""},{"question":"def smallest_x_with_product(n: int) -> int: Returns the smallest integer x such that the product of the digits of x equals n. If no such number exists, returns -1. >>> smallest_x_with_product(1) == 1 >>> smallest_x_with_product(2) == 2 >>> smallest_x_with_product(3) == 3 >>> smallest_x_with_product(138) == -1 >>> smallest_x_with_product(10) == 25 >>> smallest_x_with_product(18) == 29 >>> smallest_x_with_product(48) == 68 >>> smallest_x_with_product(1000) == 5558 >>> smallest_x_with_product(97) == -1","solution":"def smallest_x_with_product(n): Returns the smallest integer x such that the product of the digits of x equals n. If no such number exists, returns -1. if n == 1: return 1 digits = [] for d in range(9, 1, -1): while n % d == 0: digits.append(d) n //= d if n > 1: return -1 digits.sort() x = int(''.join(map(str, digits))) return x"},{"question":"def min_subarray_length(nums: List[int], k: int) -> int: Returns the minimum size of a contiguous subarray of which the sum is greater than or equal to k. If there is no such subarray, returns 0. >>> min_subarray_length([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_length([1, 1, 1, 1], 5) 0 >>> min_subarray_length([1, 2, 3, 4, 5], 15) 5 >>> min_subarray_length([1, 4, 4], 4) 1 >>> min_subarray_length([1, 2, 3, 4, 5, 10], 15) 2 >>> min_subarray_length([1, 2, 3, 4, 15], 15) 1 >>> min_subarray_length([], 1) 0","solution":"def min_subarray_length(nums, k): Returns the minimum size of a contiguous subarray of which the sum is greater than or equal to k. If there is no such subarray, returns 0. n = len(nums) min_length = n + 1 current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length <= n else 0"},{"question":"from typing import List def smallestStringWithSwaps(s: str, pairs: List[List[int]]) -> str: You are given a string \`s\` and an array of pairs of indices \`pairs\` where each pair \`[a, b]\` indicates that the characters at indices \`a\` and \`b\` can be swapped. You can swap characters at any pair of indices in \`pairs\` any number of times. Return the lexicographically smallest string that can be obtained by making any number of swaps. Example 1: >>> smallestStringWithSwaps(\\"dcab\\", [[0, 3], [1, 2]]) \\"bacd\\" Example 2: >>> smallestStringWithSwaps(\\"dcab\\", [[0, 3], [1, 2], [0, 2]]) \\"abcd\\"","solution":"from typing import List from collections import defaultdict def smallestStringWithSwaps(s: str, pairs: List[List[int]]) -> str: def dfs(node, visited, component): visited.add(node) component.append(node) for neighbor in graph[node]: if neighbor not in visited: dfs(neighbor, visited, component) # Create adjacency list from the pairs graph = defaultdict(list) for a, b in pairs: graph[a].append(b) graph[b].append(a) visited = set() components = [] # Find all connected components for i in range(len(s)): if i not in visited: component = [] dfs(i, visited, component) components.append(component) # Construct the result string result = list(s) for component in components: indices = sorted(component) letters = sorted(result[i] for i in indices) for i, idx in enumerate(indices): result[idx] = letters[i] return ''.join(result)"},{"question":"def judgeCircle(S: str) -> bool: Determines if the robot returns to the original starting position after the sequence of moves. >>> judgeCircle(\\"UD\\") == True >>> judgeCircle(\\"UUDDLL\\") == False >>> judgeCircle(\\"UUDDLRLR\\") == True >>> judgeCircle(\\"UDLRR\\") == False >>> judgeCircle(\\"\\") == True >>> judgeCircle(\\"U\\") == False >>> judgeCircle(\\"D\\") == False >>> judgeCircle(\\"L\\") == False >>> judgeCircle(\\"R\\") == False pass","solution":"def judgeCircle(S): Determines if the robot returns to the original starting position after the sequence of moves. :param S: A string representing a sequence of moves :return: True if the robot returns to the starting position, False otherwise x, y = 0, 0 for move in S: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x == 0 and y == 0"},{"question":"def longest_palindromic_subsequence(word: str) -> int: Returns the length of the longest palindromic subsequence in the given word. >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"ab\\") 1 >>> longest_palindromic_subsequence(\\"aa\\") 2 >>> longest_palindromic_subsequence(\\"racecar\\") 7 >>> longest_palindromic_subsequence(\\"abcde\\") 1 >>> longest_palindromic_subsequence(\\"bbbab\\") 4","solution":"def longest_palindromic_subsequence(word): Returns the length of the longest palindromic subsequence in the given word. n = len(word) dp = [[0] * n for _ in range(n)] for i in range(n-1, -1, -1): dp[i][i] = 1 for j in range(i + 1, n): if word[i] == word[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"def longest_substring_with_one_replacement(s: str) -> int: Returns the length of the longest substring containing at most one unique character after performing one replacement. >>> longest_substring_with_one_replacement(\\"a\\") 1 >>> longest_substring_with_one_replacement(\\"aaaa\\") 4 >>> longest_substring_with_one_replacement(\\"bbaba\\") 4 >>> longest_substring_with_one_replacement(\\"abbaba\\") 4 >>> longest_substring_with_one_replacement(\\"bbbb\\") 4 >>> longest_substring_with_one_replacement(\\"aabb\\") 3 >>> longest_substring_with_one_replacement(\\"abcd\\") 2 >>> longest_substring_with_one_replacement(\\"\\") 0","solution":"def longest_substring_with_one_replacement(s): Returns the length of the longest substring containing at most one unique character after performing one replacement. if not s: return 0 def max_length_with_replacement(s, target_char): left = 0 max_len = 0 replacement_used = 0 for right in range(len(s)): if s[right] != target_char: replacement_used += 1 while replacement_used > 1: if s[left] != target_char: replacement_used -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len max_len = 0 for char in set(s): max_len = max(max_len, max_length_with_replacement(s, char)) return max_len"},{"question":"def min_moves_to_make_equal(nums: List[int]) -> int: Returns the minimum number of moves to make all elements in the array equal. Each element can be incremented or decremented by 1. >>> min_moves_to_make_equal([1, 2, 3]) == 2 >>> min_moves_to_make_equal([1, 1, 1, 1]) == 0 >>> min_moves_to_make_equal([1, 10]) == 9 >>> min_moves_to_make_equal([-1, 2, -3, 4]) == 10 >>> min_moves_to_make_equal([1000000, 1000001, 999999, 1000000]) == 2","solution":"def min_moves_to_make_equal(nums): Returns the minimum number of moves to make all elements in the array equal. Each element can be incremented or decremented by 1. nums.sort() median = nums[len(nums) // 2] # Median minimizes the absolute deviation sum return sum(abs(num - median) for num in nums)"},{"question":"def wave_sort(nums: List[int]) -> List[int]: Given an array of integers \`nums\`, the function sorts the array in wave form. An array is in wave form if \`nums[0] >= nums[1] <= nums[2] >= nums[3] <= nums[4] >= ...\` The transformed array should have the elements arranged in such a manner that forms the wave property. >>> wave_sort([1, 2, 3, 4]) [2, 1, 4, 3] >>> wave_sort([1, 2, 3, 4, 5]) [2, 1, 4, 3, 5] >>> wave_sort([1]) [1] >>> wave_sort([1, 2]) [2, 1] >>> wave_sort([3, 3, 3, 3]) [3, 3, 3, 3] >>> wave_sort([8, 7, 6, 5, 4, 3]) [4, 3, 6, 5, 8, 7] >>> wave_sort([1, 2, 3, 4, 4, 5]) [2, 1, 4, 3, 5, 4]","solution":"def wave_sort(nums): Sorts the array in wave form such that nums[0] >= nums[1] <= nums[2] >= nums[3] and so on. # Sort the array nums.sort() # Swap adjacent elements to form wave pattern for i in range(0, len(nums) - 1, 2): nums[i], nums[i + 1] = nums[i + 1], nums[i] return nums"},{"question":"def safe_position(n: int, k: int) -> int: Returns the safe position in the Josephus problem with n people and every k-th person eliminated. >>> safe_position(1, 1) == 1 >>> safe_position(5, 2) == 3 >>> safe_position(7, 3) == 4 >>> safe_position(10, 4) == 5 >>> safe_position(6, 2) == 5","solution":"def safe_position(n, k): Returns the safe position in the Josephus problem with n people and every k-th person eliminated. if n == 1: return 1 else: return (safe_position(n-1, k) + k-1) % n + 1"},{"question":"def max_sum_subarray(arr, window_size): Finds the maximum sum of any subarray of length window_size. Parameters: arr (list of int): The input array of integers. window_size (int): The length of the subarray. Returns: int: The maximum sum of any subarray of length window_size. # Unit Tests def test_max_sum_subarray_basic(): assert max_sum_subarray([1, 2, 3, 4, 5], 3) == 12 def test_max_sum_subarray_single_element(): assert max_sum_subarray([4], 1) == 4 def test_max_sum_subarray_exact_length(): assert max_sum_subarray([1, 2, 3, 4, 5], 5) == 15 def test_max_sum_subarray_with_negatives(): assert max_sum_subarray([1, -2, 3, -1, 5], 2) == 4 def test_max_sum_subarray_empty(): assert max_sum_subarray([], 3) == 0 def test_max_sum_subarray_window_size_zero(): assert max_sum_subarray([1, 2, 3], 0) == 0 def test_max_sum_subarray_window_size_greater_than_arr_length(): assert max_sum_subarray([1, 2], 3) == 0 def test_max_sum_subarray_all_negative(): assert max_sum_subarray([-1, -2, -3, -4], 2) == -3","solution":"def max_sum_subarray(arr, window_size): Finds the maximum sum of any subarray of length window_size. Parameters: arr (list of int): The input array of integers. window_size (int): The length of the subarray. Returns: int: The maximum sum of any subarray of length window_size. if not arr or window_size <= 0 or window_size > len(arr): return 0 max_sum = sum(arr[:window_size]) current_sum = max_sum for i in range(window_size, len(arr)): current_sum = current_sum - arr[i - window_size] + arr[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def check_subarray_sum(nums: List[int], k: int) -> bool: Checks if there is a contiguous subarray that sums to a multiple of k. >>> check_subarray_sum([23, 2, 4, 6, 7], 6) True >>> check_subarray_sum([23, 2, 6, 4, 7], 6) True >>> check_subarray_sum([23, 2, 6, 4, 7], 0) False >>> check_subarray_sum([0, 0], 0) True >>> check_subarray_sum([1, 0], 2) False","solution":"def check_subarray_sum(nums, k): Checks if there is a contiguous subarray that sums to a multiple of k. Parameters: nums (list of int): List of non-negative integers. k (int): Target multiple integer. Returns: bool: True if such a subarray exists, otherwise False. if k == 0: return any(sum(nums[i:i+2]) == 0 for i in range(len(nums) - 1)) mod_map = {0: -1} # remainder -> first index where this remainder was seen total = 0 for i in range(len(nums)): total += nums[i] remainder = total % k if remainder in mod_map: if i - mod_map[remainder] > 1: return True else: mod_map[remainder] = i return False"},{"question":"class CustomQueue: A class used to simulate a queue with dynamic resizing capabilities. CustomQueue(int initialSize) initializes the queue with the given initial size. void enqueue(int val) adds the element \`val\` to the end of the queue. int dequeue() removes and returns the element at the front of the queue. int size() returns the current number of elements in the queue. bool isEmpty() returns whether the queue is empty. Examples: >>> queue = CustomQueue(3) >>> queue.size() 0 >>> queue.isEmpty() True >>> queue.enqueue(1) >>> queue.size() 1 >>> queue.enqueue(2) >>> queue.enqueue(3) >>> queue.enqueue(4) # This should trigger a resize >>> queue.size() 4 >>> queue.dequeue() 1 >>> queue.size() 3 >>> queue.isEmpty() False def __init__(self, initialSize: int): pass def enqueue(self, val: int): pass def dequeue(self) -> int: pass def size(self) -> int: pass def isEmpty(self) -> bool: pass def resize(self): pass # Unit test case examples import pytest def test_initial_size(): queue = CustomQueue(3) assert queue.size() == 0 assert queue.isEmpty() def test_enqueue_single_element(): queue = CustomQueue(3) queue.enqueue(10) assert queue.size() == 1 assert not queue.isEmpty() def test_enqueue_multiple_elements(): queue = CustomQueue(3) queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) assert queue.size() == 3 assert not queue.isEmpty() def test_dequeue_single_element(): queue = CustomQueue(3) queue.enqueue(10) assert queue.dequeue() == 10 assert queue.size() == 0 assert queue.isEmpty() def test_dequeue_multiple_elements(): queue = CustomQueue(3) queue.enqueue(1) queue.enqueue(2) assert queue.dequeue() == 1 assert queue.size() == 1 assert queue.dequeue() == 2 assert queue.size() == 0 assert queue.isEmpty() def test_resize_works_correctly(): queue = CustomQueue(2) queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) # This should trigger a resize assert queue.size() == 3 assert not queue.isEmpty() assert queue.dequeue() == 1 assert queue.dequeue() == 2 assert queue.dequeue() == 3 assert queue.isEmpty() def test_dequeue_empty_queue(): queue = CustomQueue(2) with pytest.raises(IndexError, match=\\"dequeue from an empty queue\\"): queue.dequeue()","solution":"class CustomQueue: def __init__(self, initialSize): self.queue = [None] * initialSize self.head = 0 self.tail = 0 self.max_size = initialSize self.count = 0 def enqueue(self, val): if self.count == self.max_size: self.resize() self.queue[self.tail] = val self.tail = (self.tail + 1) % self.max_size self.count += 1 def dequeue(self): if self.isEmpty(): raise IndexError(\\"dequeue from an empty queue\\") value = self.queue[self.head] self.head = (self.head + 1) % self.max_size self.count -= 1 return value def size(self): return self.count def isEmpty(self): return self.count == 0 def resize(self): new_max_size = self.max_size * 2 new_queue = [None] * new_max_size for i in range(self.count): new_queue[i] = self.queue[(self.head + i) % self.max_size] self.queue = new_queue self.head = 0 self.tail = self.count self.max_size = new_max_size"},{"question":"def shuffle_string(s: str, indices: List[int]) -> str: Returns the shuffled string according to the indices array. Args: s (str): The input string. indices (list of int): The list of indices to shuffle the string. Returns: str: The shuffled string. >>> shuffle_string(\\"abc\\", [2, 0, 1]) \\"bca\\" >>> shuffle_string(\\"abcd\\", [3, 1, 2, 0]) \\"dbca\\" >>> shuffle_string(\\"a\\", [0]) \\"a\\" >>> shuffle_string(\\"aabb\\", [3, 2, 1, 0]) \\"bbaa\\" >>> shuffle_string(\\"\\", []) \\"\\"","solution":"def shuffle_string(s, indices): Returns the shuffled string according to the indices array. Args: s (str): The input string. indices (list of int): The list of indices to shuffle the string. Returns: str: The shuffled string. shuffled = [''] * len(s) for i, index in enumerate(indices): shuffled[index] = s[i] return ''.join(shuffled)"},{"question":"import heapq def minAssemblyCost(costs): Returns the minimum cost required to assemble all given products into a single product. >>> minAssemblyCost([1, 2, 3, 4]) == 19 >>> minAssemblyCost([5]) == 0 >>> minAssemblyCost([3, 7]) == 10 >>> minAssemblyCost([4, 3, 2, 6]) == 29 >>> minAssemblyCost([1, 1, 1, 1]) == 8 >>> minAssemblyCost([1000, 2000, 3000, 4000]) == 19000","solution":"import heapq def minAssemblyCost(costs): Returns the minimum cost required to assemble all given products into a single product. # Use a min heap to always combine the least costly products heapq.heapify(costs) total_cost = 0 while len(costs) > 1: # Pop the two smallest elements first = heapq.heappop(costs) second = heapq.heappop(costs) # Combine the two products combined_cost = first + second total_cost += combined_cost # Add the combined product back into the heap heapq.heappush(costs, combined_cost) return total_cost"},{"question":"def can_form_increasing_sequence(arr: List[int]) -> bool: Determine if it is possible to achieve a strictly increasing sequence by removing at most one element. >>> can_form_increasing_sequence([1, 2, 3, 4, 5]) True >>> can_form_increasing_sequence([1, 2, 5, 3, 5]) True >>> can_form_increasing_sequence([1, 3, 2, 5, 4]) False >>> can_form_increasing_sequence([10]) True >>> can_form_increasing_sequence([5, 4, 3, 2, 1]) False","solution":"def can_form_increasing_sequence(arr): def is_strictly_increasing(a): for i in range(1, len(a)): if a[i-1] >= a[i]: return False return True # Check if arr is already strictly increasing if is_strictly_increasing(arr): return True # Try removing each element and check if the resulting array is strictly increasing for i in range(len(arr)): if is_strictly_increasing(arr[:i] + arr[i+1:]): return True return False"},{"question":"def count_unique_pairs(arr: List[int], k: int) -> int: Returns the count of unique pairs (i, j) such that arr[i] + arr[j] = k and i < j. :param arr: List of integers :param k: Target sum :return: Count of unique pairs >>> count_unique_pairs([1, 2, 3, 4, 3], 6) 2 >>> count_unique_pairs([1, 1, 1, 1], 2) 1 >>> count_unique_pairs([1, 2, 3, 4], 8) 0 >>> count_unique_pairs([2, 4, 3, 5, 7], 9) 2 >>> count_unique_pairs([3, 3, 3, 3, 3], 6) 1 >>> count_unique_pairs([], 5) 0 >>> count_unique_pairs([1], 1) 0 >>> count_unique_pairs([5, 5, 5, 5, 5], 10) 1 pass","solution":"def count_unique_pairs(arr, k): Returns the count of unique pairs (i, j) such that arr[i] + arr[j] = k and i < j. :param arr: List of integers :param k: Target sum :return: Count of unique pairs seen = set() pairs = set() count = 0 for i, num in enumerate(arr): target = k - num if target in seen: pairs.add((min(num, target), max(num, target))) seen.add(num) return len(pairs)"},{"question":"def findAntiDiagonals(matrix: List[List[int]]) -> List[List[int]]: Given an \`n\` x \`n\` matrix of integers, return an array of the matrix's anti-diagonals. >>> findAntiDiagonals([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1], [2, 4], [3, 5, 7], [6, 8], [9]] >>> findAntiDiagonals([[1, 2], [3, 4]]) == [[1], [2, 3], [4]]","solution":"def findAntiDiagonals(matrix): Given an \`n\` x \`n\` matrix of integers, return an array of the matrix's anti-diagonals. n = len(matrix) result = [] # Collect all anti-diagonals starting from the first row for col in range(n): anti_diagonal = [] i, j = 0, col while i < n and j >= 0: anti_diagonal.append(matrix[i][j]) i += 1 j -= 1 result.append(anti_diagonal) # Collect all anti-diagonals starting from the last column for row in range(1, n): anti_diagonal = [] i, j = row, n - 1 while i < n and j >= 0: anti_diagonal.append(matrix[i][j]) i += 1 j -= 1 result.append(anti_diagonal) return result"},{"question":"from typing import List def min_moves_to_make_heights_equal(heights: List[int]) -> int: Returns the minimum number of moves required to make all building heights equal. Each move can only increase the height of one building by 1. >>> min_moves_to_make_heights_equal([3, 3, 3]) 0 >>> min_moves_to_make_heights_equal([1, 2, 3]) 3 >>> min_moves_to_make_heights_equal([5]) 0 >>> min_moves_to_make_heights_equal([2, 3]) 1 >>> min_moves_to_make_heights_equal([4, 3, 4]) 1","solution":"def min_moves_to_make_heights_equal(heights): Returns the minimum number of moves required to make all building heights equal. Each move can only increase the height of one building by 1. max_height = max(heights) moves = 0 for height in heights: moves += max_height - height return moves"},{"question":"def longest_beautiful_substring(s: str, k: int) -> int: Returns the length of the longest beautiful substring of 's' which contains no more than 'k' distinct characters. >>> longest_beautiful_substring(\\"eceba\\", 2) 3 >>> longest_beautiful_substring(\\"abcdef\\", 1) 1 >>> longest_beautiful_substring(\\"abcdef\\", 2) 2 >>> longest_beautiful_substring(\\"aaaaa\\", 1) 5 >>> longest_beautiful_substring(\\"abaccc\\", 3) 6 >>> longest_beautiful_substring(\\"\\", 1) 0 >>> longest_beautiful_substring(\\"abcd\\", 0) 0 >>> longest_beautiful_substring(\\"a\\", 1) 1 >>> longest_beautiful_substring(\\"a\\", 0) 0 >>> longest_beautiful_substring(\\"aabbcc\\", 2) 4 >>> longest_beautiful_substring(\\"aabbaacc\\", 3) 8","solution":"def longest_beautiful_substring(s, k): Returns the length of the longest beautiful substring of s which contains no more than k distinct characters. from collections import defaultdict n = len(s) if n == 0 or k == 0: return 0 char_count = defaultdict(int) left = 0 max_len = 0 distinct_count = 0 for right in range(n): # Add current character to the count if char_count[s[right]] == 0: distinct_count += 1 char_count[s[right]] += 1 # While distinct character count exceeds k, # Move the left pointer to maintain the condition while distinct_count > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: distinct_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def diagonal_difference(matrix): Calculate the absolute difference between the sums of the main diagonal and secondary diagonal of a square matrix. Args: matrix (List[List[int]]): A square matrix of integers. Returns: int: The absolute difference between the sums of the main diagonal and secondary diagonal. >>> diagonal_difference([ ... [11, 2, 4], ... [4, 5, 6], ... [10, 8, -12] ... ]) 15 >>> diagonal_difference([ ... [1, 2], ... [3, 4] ... ]) 0 >>> diagonal_difference([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) 0 >>> diagonal_difference([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) 0 >>> diagonal_difference([ ... [5] ... ]) 0","solution":"def diagonal_difference(matrix): Returns the absolute difference between the sums of the main diagonal and secondary diagonal of a square matrix. n = len(matrix) # Sum of main diagonal main_diagonal_sum = sum(matrix[i][i] for i in range(n)) # Sum of secondary diagonal secondary_diagonal_sum = sum(matrix[i][n - i - 1] for i in range(n)) # Absolute difference return abs(main_diagonal_sum - secondary_diagonal_sum)"},{"question":"from typing import List def find_longest_logged_in_user(logs: List[List[int]]) -> int: Given a list \`logs\` of logged in and log-out times of different users represented as 2D integer vectors where logs[i] = [userid, loginTime, logoutTime]. Each log represents a user logging in at loginTime and logging out at logoutTime. A user is considered logged in for any duration between loginTime and logoutTime, inclusive of loginTime, but exclusive of logoutTime. Return the userid of the user who was logged in for the longest total duration. If there are multiple users with the same longest total duration, return the userid with the smallest userid. >>> find_longest_logged_in_user([[1, 1, 10], [2, 2, 5], [1, 5, 7]]) 1 >>> find_longest_logged_in_user([[1, 1, 5], [2, 2, 6]]) 1 >>> find_longest_logged_in_user([[1, 1, 5], [2, 1, 5], [3, 1, 5]]) 1 >>> find_longest_logged_in_user([]) None","solution":"def find_longest_logged_in_user(logs): user_duration = {} for log in logs: userid, loginTime, logoutTime = log duration = logoutTime - loginTime if userid in user_duration: user_duration[userid] += duration else: user_duration[userid] = duration max_duration = -1 user_with_max_duration = None for userid, duration in user_duration.items(): if duration > max_duration or (duration == max_duration and userid < user_with_max_duration): max_duration = duration user_with_max_duration = userid return user_with_max_duration"},{"question":"def successful_pairs(spells: List[int], potions: List[int], success: int) -> List[int]: Returns an array where the ith element is the number of potions that can form a successful pair with the ith spell. >>> successful_pairs([10, 20, 30], [1, 2, 3, 4, 5], 30) [3, 4, 5] >>> successful_pairs([5], [2], 10) [1] >>> successful_pairs([5], [1], 10) [0] >>> successful_pairs([1, 2, 3], [1, 2, 3], 0) [3, 3, 3] >>> successful_pairs([1, 1, 1], [1, 1, 1], 10) [0, 0, 0] >>> successful_pairs([10, 100, 1000], [10, 100, 1000], 1000000) [0, 0, 1] >>> successful_pairs([10, 20, 30], [5, 1, 3, 2, 4], 30) [3, 4, 5] pass","solution":"def successful_pairs(spells, potions, success): Returns an array where the ith element is the number of potions that can form a successful pair with the ith spell. potions.sort() result = [] for spell in spells: left, right = 0, len(potions) while left < right: mid = left + (right - left) // 2 if potions[mid] * spell >= success: right = mid else: left = mid + 1 result.append(len(potions) - left) return result"},{"question":"def fill_region(matrix, row, col, newColor, oldColor): Fill the entire connected region containing the coordinate (row, col) with newColor. A connected region is formed by pixels with the same oldColor connected vertically or horizontally. Parameters: - matrix: A list of lists representing the image. - row: The starting row for the fill operation. - col: The starting column for the fill operation. - newColor: The color to fill the region with. - oldColor: The color of the region to fill. Returns: - The modified matrix after performing the fill operation. pass # Unit Tests def test_fill_region_basic(): matrix = [ [1, 1, 1], [1, 1, 0], [1, 0, 1] ] expected = [ [2, 2, 2], [2, 2, 0], [2, 0, 1] ] assert fill_region(matrix, 0, 0, 2, 1) == expected def test_fill_region_no_change(): matrix = [ [1, 1, 1], [1, 1, 0], [1, 0, 1] ] expected = [ [1, 1, 1], [1, 1, 0], [1, 0, 1] ] assert fill_region(matrix, 2, 2, 1, 1) == expected def test_fill_region_small_matrix(): matrix = [ [0, 0], [0, 0] ] expected = [ [2, 2], [2, 2] ] assert fill_region(matrix, 1, 1, 2, 0) == expected def test_fill_region_different_color(): matrix = [ [1, 2, 2], [2, 2, 2], [2, 2, 1] ] expected = [ [1, 3, 3], [3, 3, 3], [3, 3, 1] ] assert fill_region(matrix, 1, 1, 3, 2) == expected def test_fill_region_single_element(): matrix = [[0]] expected = [[1]] assert fill_region(matrix, 0, 0, 1, 0) == expected","solution":"def fill_region(matrix, row, col, newColor, oldColor): Fill the entire connected region containing the coordinate (row, col) with newColor. A connected region is formed by pixels with the same oldColor connected vertically or horizontally. Parameters: - matrix: A list of lists representing the image. - row: The starting row for the fill operation. - col: The starting column for the fill operation. - newColor: The color to fill the region with. - oldColor: The color of the region to fill. Returns: - The modified matrix after performing the fill operation. def valid(r, c): return 0 <= r < len(matrix) and 0 <= c < len(matrix[0]) and matrix[r][c] == oldColor def dfs(r, c): if not valid(r, c): return matrix[r][c] = newColor directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dr, dc in directions: dfs(r + dr, c + dc) if oldColor != newColor: dfs(row, col) return matrix"},{"question":"class RangeSumQuery: def __init__(self, nums): Initializes the object with the integer array nums. self.nums = nums # Generate prefix sums to make range sum queries more efficient self.prefix_sums = [0] * (len(nums) + 1) for i in range(1, len(nums) + 1): self.prefix_sums[i] = self.prefix_sums[i - 1] + nums[i - 1] def sumRange(self, queries): Returns an integer array answer where answer[i] is the sum of elements between indices left and right inclusive for the ith query. >>> nums = [1, 2, 3, 4, 5] >>> queries = [(0, 2), (1, 3), (0, 4)] >>> rsq = RangeSumQuery(nums) >>> rsq.sumRange(queries) [6, 9, 15] >>> nums = [1, 2, 3, 4, 5] >>> queries = [(0, 0), (1, 1), (4, 4)] >>> rsq = RangeSumQuery(nums) >>> rsq.sumRange(queries) [1, 2, 5] >>> nums = [-1, -2, -3, -4, -5] >>> queries = [(0, 2), (1, 3), (2, 4)] >>> rsq = RangeSumQuery(nums) >>> rsq.sumRange(queries) [-6, -9, -12]","solution":"class RangeSumQuery: def __init__(self, nums): self.nums = nums # Generate prefix sums to make range sum queries more efficient self.prefix_sums = [0] * (len(nums) + 1) for i in range(1, len(nums) + 1): self.prefix_sums[i] = self.prefix_sums[i - 1] + nums[i - 1] def sumRange(self, queries): result = [] for left, right in queries: range_sum = self.prefix_sums[right + 1] - self.prefix_sums[left] result.append(range_sum) return result"},{"question":"def count_characters(words: List[str], chars: str) -> int: Returns the total length of all good words that can be formed using characters in chars. >>> count_characters([\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"], \\"atach\\") == 6 >>> count_characters([\\"xyz\\", \\"abc\\"], \\"defg\\") == 0 >>> count_characters([\\"a\\", \\"aa\\", \\"aaa\\"], \\"aaaa\\") == 6 >>> count_characters([\\"apple\\", \\"orange\\", \\"grape\\"], \\"appleorangegrape\\") == 16 >>> count_characters([\\"aaa\\", \\"aa\\", \\"a\\"], \\"aaaaa\\") == 6 >>> count_characters([], \\"abc\\") == 0 >>> count_characters([\\"abc\\", \\"def\\"], \\"\\") == 0","solution":"def count_characters(words, chars): Returns the total length of all good words that can be formed using characters in chars. from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(chars_count[char] >= count for char, count in word_count.items()): total_length += len(word) return total_length"},{"question":"def longest_even_subset_length(s: str) -> int: Determine the length of the longest even subset of characters in a string. >>> longest_even_subset_length(\\"aabbcc\\") 6 >>> longest_even_subset_length(\\"aaabbbccc\\") 6 >>> longest_even_subset_length(\\"aabbccc\\") 6 >>> longest_even_subset_length(\\"a\\") 0 >>> longest_even_subset_length(\\"\\") 0 >>> longest_even_subset_length(\\"aaaaaa\\") 6 >>> longest_even_subset_length(\\"aaaaa\\") 4 >>> longest_even_subset_length(\\"abccbaabccba\\") 12","solution":"def longest_even_subset_length(s): from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Initialize the length of the longest even subset long_even_subset_length = 0 # Iterate through the character counts for count in char_count.values(): if count % 2 == 0: # If the count is even, add the count to the subset length long_even_subset_length += count else: # If the count is odd, add the even part of the count to the subset length long_even_subset_length += count - 1 return long_even_subset_length"},{"question":"from typing import List def find_lexicographic_rank(s: str) -> int: Given a string \`s\`, return the rank of the string amongst its permutations sorted lexicographically. The rank should be 1-indexed. Example: >>> find_lexicographic_rank(\\"abc\\") 1 >>> find_lexicographic_rank(\\"acb\\") 2 >>> find_lexicographic_rank(\\"bac\\") 3 >>> find_lexicographic_rank(\\"cab\\") 5 >>> find_lexicographic_rank(\\"cba\\") 6 >>> find_lexicographic_rank(\\"a\\") 1 >>> find_lexicographic_rank(\\"ab\\") 1 >>> find_lexicographic_rank(\\"ba\\") 2","solution":"from math import factorial def find_lexicographic_rank(s): Returns the rank of the string s amongst its permutations sorted lexicographically. rank = 1 n = len(s) for i, char in enumerate(s): smaller_chars = sum(c < char for c in s[i+1:]) rank += smaller_chars * factorial(n - i - 1) return rank"},{"question":"def num_islands(grid: List[List[int]]) -> int: Given a grid with m rows and n columns represented by a 2D array grid, each cell in the grid can either be 0 (an empty cell) or 1 (a land cell). A group of connected land cells (horizontal or vertical but not diagonal) form an island. Write a function to count the number of islands in the given grid. >>> num_islands([ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 1, 1] ... ]) == 3 >>> num_islands([]) == 0 >>> num_islands([ ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> num_islands([ ... [1, 0], ... [0, 0] ... ]) == 1 >>> num_islands([ ... [1, 1, 0, 1, 1], ... [1, 0, 0, 0, 1], ... [0, 0, 1, 0, 0], ... [1, 1, 0, 1, 1] ... ]) == 5 >>> num_islands([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) == 0 >>> num_islands([[1]]) == 1 >>> num_islands([[0]]) == 0","solution":"def num_islands(grid): if not grid: return 0 def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # Mark as visited dfs(i+1, j) # Check down dfs(i-1, j) # Check up dfs(i, j+1) # Check right dfs(i, j-1) # Check left count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: count += 1 dfs(i, j) return count"},{"question":"from typing import List def find_pivot_index(arr: List[int]) -> int: This function returns the pivot index of a rotated sorted array. If the array is not rotated, it returns 0. >>> find_pivot_index([1, 2, 3, 4, 5]) == 0 >>> find_pivot_index([10]) == 0 >>> find_pivot_index([2, 1]) == 1 >>> find_pivot_index([4, 5, 6, 7, 0, 1, 2]) == 4 >>> find_pivot_index([30, 40, 50, 10, 20]) == 3 >>> find_pivot_index([10, 20, 30, 40, 50]) == 0 >>> find_pivot_index([40, 50, 10, 20, 30]) == 2 >>> find_pivot_index([15, 18, 2, 3, 6, 12]) == 2 >>> find_pivot_index([7, 8, 9, 1, 2, 3, 5, 6]) == 3 >>> find_pivot_index([]) == -1 >>> find_pivot_index([10, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == 1 >>> find_pivot_index([2, 3, 4, 5, 6, 7, 8, 9, 10, 1]) == 9","solution":"def find_pivot_index(arr): This function returns the pivot index of a rotated sorted array. If the array is not rotated, it returns 0. if not arr: return -1 # Handle empty array edge case low, high = 0, len(arr) - 1 while low < high: mid = (low + high) // 2 # If mid element is greater than high element, the pivot must be in the right half if arr[mid] > arr[high]: low = mid + 1 else: high = mid return low"}]`),F={name:"App",components:{PoemCard:j},data(){return{searchQuery:"",visibleCount:4,poemsData:A,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},I={class:"card-container"},S={key:0,class:"empty-state"},z=["disabled"],D={key:0},P={key:1};function E(i,e,l,c,s,a){const h=g("PoemCard");return r(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),p(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[b,s.searchQuery]]),s.searchQuery?(r(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")},"  ")):u("",!0)]),t("div",I,[(r(!0),n(x,null,y(a.displayedPoems,(o,f)=>(r(),v(h,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(r(),n("div",S,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(r(),n("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(r(),n("span",P,"Loading...")):(r(),n("span",D,"See more"))],8,z)):u("",!0)])}const M=_(F,[["render",E],["__scopeId","data-v-df793367"]]),G=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/7.md","filePath":"guide/7.md"}'),B={name:"guide/7.md"},W=Object.assign(B,{setup(i){return(e,l)=>(r(),n("div",null,[w(M)]))}});export{G as __pageData,W as default};
