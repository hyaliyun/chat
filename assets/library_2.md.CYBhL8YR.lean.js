import{_ as m,o as n,c as r,a as t,m as d,t as h,C as p,M as _,U as b,f as l,F as y,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},R={class:"review-title"},j={class:"review-content"};function Y(i,e,u,c,s,a){return n(),r("div",q,[t("div",T,[t("div",R,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(h(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",j,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(h(u.poem.solution),1)])])])}const I=m(k,[["render",Y],["__scopeId","data-v-58827025"]]),F=JSON.parse('[{"question":"Given a binary tree, implement a function `rightSideView` that returns the values of the nodes you can see ordered from top to bottom when looking at the tree from the right side. Here\'s the function signature: ```python def rightSideView(root: Optional[TreeNode]) -> List[int]: # Your code here ``` Where `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root: Optional[TreeNode]) -> List[int]: if not root: return [] right_view = [] queue = [(root, 0)] while queue: node, depth = queue.pop(0) if len(right_view) == depth: right_view.append(node.val) else: right_view[depth] = node.val if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return right_view"},{"question":"Implement a function that takes a 2D grid representing a map of \'1\'s (land) and \'0\'s (water) and counts the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water.","solution":"def num_islands(grid): Given a 2D grid map of \'1\'s (land) and \'0\'s (water), counts the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. if not grid: return 0 nrows, ncols = len(grid), len(grid[0]) visited = [[False for _ in range(ncols)] for _ in range(nrows)] def dfs(row, col): if row < 0 or col < 0 or row >= nrows or col >= ncols or grid[row][col] == \'0\' or visited[row][col]: return visited[row][col] = True dfs(row + 1, col) dfs(row - 1, col) dfs(row, col + 1) dfs(row, col - 1) count = 0 for i in range(nrows): for j in range(ncols): if grid[i][j] == \'1\' and not visited[i][j]: count += 1 dfs(i, j) return count"},{"question":"A company has a management hierarchy organized as a tree. The tree consists of `n` nodes, where each node represents an employee. Each employee has a unique ID from `0` to `n-1`. You are given a 0-indexed integer array `manager` of length `n`, where `manager[i]` is the direct manager of the `i-th` employee and `manager[0] == -1`, indicating that the employee with ID `0` is the CEO of the company. The `directReports` array is a 2D list where `directReports[i]` is the list of employees who report directly to employee `i`. It is possible to change some managers, but there must still be a valid tree hierarchy. If changing the manager of exactly one employee maximizes the total number of direct reports for that employee, determine the maximum number of direct reports that this employee can have after the change. **Inputs:** - A 0-indexed integer array `manager` of length `n`. - A 2D list `directReports`, where each element is a list of integers representing the direct reports of an employee. **Outputs:** - Return an integer representing the maximum number of direct reports an employee can have after changing the manager of exactly one employee.","solution":"def find_max_direct_reports(manager, directReports): Returns the maximum number of direct reports an employee can have after changing the manager of exactly one employee. :param manager: List of integers representing the current manager of each employee. :param directReports: 2D List where each element is a list of direct reports of an employee. :return: Integer representing the maximum number of direct reports any employee can have after one change. n = len(manager) # Calculate the total direct reports for each employee before any change total_direct_reports = [0] * n for i in range(n): total_direct_reports[manager[i]] += 1 max_direct_reports = max(total_direct_reports) for emp in range(1, n): old_manager = manager[emp] # Remove emp from its old_manager\'s direct reports total_direct_reports[old_manager] -= 1 # Try to reassign emp to every other manager for new_manager in range(n): if new_manager != old_manager: # Add emp to the new_manager\'s direct reports total_direct_reports[new_manager] += 1 new_max = max(total_direct_reports) max_direct_reports = max(max_direct_reports, new_max) # Restore the counts back to their original state total_direct_reports[new_manager] -= 1 # Restore the original state for the old manager total_direct_reports[old_manager] += 1 return max_direct_reports"},{"question":"You are given two strings `s` and `t`, both of which only contain lowercase letters. You need to determine if a substring of `s` can be rearranged to match `t`. Return `true` if it is possible and `false` otherwise. Note that a substring of `s` can be rearranged to match `t` if and only if the frequency of each character in `t` is less than or equal to the frequency of the same character in some substring of `s`.","solution":"def can_rearrange_to_match(s, t): Determines if a substring of s can be rearranged to match t. from collections import Counter len_s = len(s) len_t = len(t) if len_t > len_s: return False counter_t = Counter(t) window_counter = Counter(s[:len_t]) if window_counter == counter_t: return True for i in range(len_t, len_s): window_counter[s[i]] += 1 window_counter[s[i - len_t]] -= 1 if window_counter[s[i - len_t]] == 0: del window_counter[s[i - len_t]] if window_counter == counter_t: return True return False"},{"question":"Given a string `s`, you need to split `s` into the minimum number of substrings such that each substring is a palindrome. A palindrome is defined as a string that reads the same backward as forward. Implement the function `int minCutPalindrome(string s)`, which takes a string `s` as input and returns the minimum number of cuts needed to split `s` into palindromic substrings. For example: Given the string `s = \\"aab\\"`, the function should return `1` because splitting `s` into [\\"aa\\", \\"b\\"] results in palindromic substrings. Given the string `s = \\"a\\"`, the function should return `0` because splitting `s` is unnecessary as it is already a palindrome.","solution":"def minCutPalindrome(s): n = len(s) if n == 0: return 0 dp = [0] * n palindrome = [[False] * n for _ in range(n)] for i in range(n): minCut = i for j in range(i+1): if s[j] == s[i] and (i-j <= 1 or palindrome[j+1][i-1]): palindrome[j][i] = True minCut = 0 if j == 0 else min(minCut, dp[j-1] + 1) dp[i] = minCut return dp[-1]"},{"question":"There is a variation of the sliding puzzle game consisting of a board with an `m x n` grid of tiles, where each tile is a number from `1` to `m*n - 1`, and one space is represented by `0`. A move consists of swapping the `0` tile with an adjacent tile (up, down, left, right). Given the initial configuration of the board as a 2D list `board`, return the minimum number of moves required to rearrange the tiles to match the target state where the numbers are in ascending order from left to right, top to bottom, with the `0` in the bottom-right corner. If it is impossible to reach the target state, return `-1`. The function prototype is `def sliding_puzzle(board: List[List[int]]) -> int:`","solution":"from collections import deque from typing import List, Tuple def sliding_puzzle(board: List[List[int]]) -> int: target = ((1, 2, 3), (4, 5, 0)) m, n = 2, 3 def serialize(board: List[List[int]]) -> Tuple[Tuple[int, ...], Tuple[int, ...]]: return tuple(tuple(row) for row in board) def get_neighbors(state: Tuple[Tuple[int, ...], Tuple[int, ...]]) -> List[Tuple[Tuple[int, ...], Tuple[int, ...]]]: flat_board = [x for row in state for x in row] empty_index = flat_board.index(0) x, y = empty_index // n, empty_index % n neighbors = [] for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: new_board = list(flat_board) new_board[empty_index], new_board[nx * n + ny] = new_board[nx * n + ny], new_board[empty_index] new_board_2d = tuple(tuple(new_board[i*n:(i+1)*n]) for i in range(m)) neighbors.append(new_board_2d) return neighbors initial_state = serialize(board) if initial_state == target: return 0 queue = deque([(initial_state, 0)]) seen = set() seen.add(initial_state) while queue: state, moves = queue.popleft() for neighbor in get_neighbors(state): if neighbor == target: return moves + 1 if neighbor not in seen: seen.add(neighbor) queue.append((neighbor, moves + 1)) return -1"},{"question":"Given a **0-indexed** integer array `nums` containing `n` elements, return _the length of the longest subarray of consecutive elements in `nums` that contains only distinct values_. A subarray is a contiguous part of the array.","solution":"def length_of_longest_subarray_with_distinct_values(nums): Returns the length of the longest subarray of consecutive elements in nums that contains only distinct values. n = len(nums) max_length = 0 start = 0 seen = {} for end in range(n): if nums[end] in seen: start = max(start, seen[nums[end]] + 1) seen[nums[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a string of lowercase English letters `s` and an integer array `cost` where `cost[i]` is the cost of deleting the `i-th` character in the string `s`. You want to choose a substring from `s` and delete it such that the sum of the costs of the deleted characters is minimized. A substring is a contiguous sequence of characters within a string. Return the minimum possible cost to delete one such substring from `s`.","solution":"def min_cost_to_delete_substring(s, cost): Calculate the minimum cost to delete one substring of consecutive characters from s. :param s: str, the input string. :param cost: List[int], the cost array where cost[i] is the deletion cost of s[i]. :return: int, the minimum possible deletion cost. total_min_cost = float(\'inf\') i = 0 n = len(s) while i < n: # Start of the segment j = i segment_cost = 0 # Find the end of the segment of identical characters while j < n and s[j] == s[i]: segment_cost += cost[j] j += 1 if j > i + 1: # Subtract the maximum cost in the segment to get the minimal removal cost max_cost_in_segment = max(cost[i:j]) total_min_cost = min(total_min_cost, segment_cost - max_cost_in_segment) # Move to the next different character i = j return total_min_cost if total_min_cost != float(\'inf\') else 0"},{"question":"You are given a string `s` representing a sentence containing words separated by spaces. Each word can consist of lowercase and uppercase English letters. Reverse the order of the characters in each word while keeping the word order intact. Return the manipulated sentence as a single string.","solution":"def reverse_words_in_sentence(s): Reverse each word in the sentence while keeping the word order intact. Parameters: s (str): Input sentence containing words separated by spaces. Returns: str: Manipulated sentence with each word reversed but word order intact. words = s.split() reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"Given a string `s` and an integer array `indices` of the same length, return a new string where the character at the ith position of the new string is s[indices[i]]. You may assume that the input values are valid and uniquely map to positions in the initial string.","solution":"def restore_string(s, indices): Restores a string such that the character at the ith position of the new string is s[indices[i]]. Parameters: s (str): The input string. indices (List[int]): The list of indices. Returns: str: The modified string based on the given indices. n = len(s) restored = [\'\'] * n for i, index in enumerate(indices): restored[index] = s[i] return \'\'.join(restored)"},{"question":"You are given a string `s` consisting only of the characters \'a\' and \'b\'. You can transform `s` by applying the following operation any number of times: select a pair of non-overlapping substrings \\"ab\\" and \\"ba\\" and swap them. Return _the lexicographically smallest string_ you can obtain by applying this operation any number of times.","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string by swapping \'ab\' with \'ba\' any number of times. # We\'ll count the number of \'a\'s and \'b\'s first a_count = s.count(\'a\') b_count = s.count(\'b\') # The lexicographically smallest string will have all \'a\'s first followed by all \'b\'s return \'a\' * a_count + \'b\' * b_count"},{"question":"You are given a binary string `s` of length `n` and an integer `k`. In one move, you can choose any character from the string and flip it (change \'0\' to \'1\' or \'1\' to \'0\'). Your task is to determine the minimum number of moves required to make the binary string contain at least one sequence of `k` consecutive \'1\'s. Return the minimum number of moves needed.","solution":"def min_moves_to_k_consecutive_ones(s: str, k: int) -> int: Returns the minimum number of moves required to make the binary string s contain at least one sequence of k consecutive \'1\'s. n = len(s) # Special case: If k is greater than n, it\'s impossible to create a k-length sequence if k > n: return float(\'inf\') # or raise an Exception # Initialize the initial number of zeroes in the first window of size k zero_count = s[:k].count(\'0\') min_moves = zero_count # Slide the window across the string to find the minimum moves for i in range(1, n - k + 1): if s[i-1] == \'0\': zero_count -= 1 if s[i+k-1] == \'0\': zero_count += 1 min_moves = min(min_moves, zero_count) return min_moves"},{"question":"You are given a **0-indexed** array `nums` of `n` integers and an integer `target`. Your task is to find a unique pair of integers in the array whose sum equals `target` and return their indices in a **tuple** `(i, j)`, where `i` and `j` are the indices of the two integers such that `nums[i] + nums[j] == target` and `i < j`. It is guaranteed that exactly one such pair exists. Your solution should have a time complexity better than O(n^2).","solution":"def find_pair_with_sum(nums, target): Returns a tuple of indices (i, j) such that nums[i] + nums[j] == target and i < j. Assumes exactly one such pair exists. :param nums: List[int] - List of integers :param target: int - Target sum for the pair :return: Tuple[int, int] - Indices of the two numbers adding up to target num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i"},{"question":"Given an array of integers `arr`, return an array of the same length where each element is replaced by the sum of all the elements to the right of it in the original array. If there are no elements to the right, the value should be `0`. For example, given the array [1, 2, 3, 4], the output should be [9, 7, 4, 0].","solution":"def replace_with_right_sum(arr): Given an array of integers, replace each element with the sum of all elements to the right of it. If there are no elements to the right, the value should be 0. Parameters: arr (list of int): The input array. Returns: list of int: The transformed array. if not arr: return [] right_sum = 0 result = [0] * len(arr) for i in range(len(arr) - 1, -1, -1): result[i] = right_sum right_sum += arr[i] return result"},{"question":"You are given a list of strings `words`. A string is considered a **subsequence** of another string if it can be derived from the other string by deleting some or no characters without changing the order of the remaining characters. Return _an integer_ indicating the **length of the longest string** in `words` that is a subsequence of all the other strings in `words`. If no such string exists, return `0`.","solution":"def is_subsequence(s, t): Helper function to determine if s is a subsequence of t. it = iter(t) return all(c in it for c in s) def longest_common_subsequence_length(words): Returns the length of the longest string in `words` that is a subsequence of all other strings in `words`. Returns 0 if no such string exists. words.sort(key=len) for word in words: if all(is_subsequence(word, other) for other in words if other != word): return len(word) return 0"},{"question":"Given two integers `n` and `k`, return an array of the first `n` integers such that each integer is unique and the absolute difference between each pair of consecutive integers is less than or equal to `k`. If such an array is not possible, return an empty array. For example, for `n = 5` and `k = 2`, possible arrays could be `[1, 2, 3, 4, 5]` or `[1, 3, 2, 4, 5]`.","solution":"def generate_unique_integers(n, k): Generate an array of the first n integers such that each integer is unique and the absolute difference between each pair of consecutive integers is less than or equal to k. If such an array is not possible, return an empty array. :param n: Number of integers to generate. :param k: Maximum allowed absolute difference between consecutive integers. :return: List of integers meeting the criteria. if n <= 0: return [] result = [] used = set() current = 1 while len(result) < n: result.append(current) used.add(current) next_num = current + 1 if current < (n + k) else current - 1 while next_num in used or abs(next_num - current) > k: if next_num in used: next_num += 1 if abs(next_num - current) > k: break if next_num in used or abs(next_num - current) > k: break current = next_num if len(result) == n: return result else: return []"},{"question":"You are given a **0-indexed** integer array `temperatures` of length `n`, where `temperatures[i]` represents the temperature on the `i-th` day. You are also given a **0-indexed** integer array `ranges` of length `m`, where `ranges[j] = [leftj, rightj]`. Each `ranges[j]` represents a query where you need to find the **average temperature** between `leftj` and `rightj` days inclusive. Return an array `results`, equal in length to `ranges`, where `results[j]` is the answer to the `j-th` query. The average temperature should be rounded down to the nearest integer.","solution":"def average_temperature(temperatures, ranges): Calculate the average temperature for each of the given ranges, rounded down to the nearest integer. Parameters: temperatures (list of int): The array of temperatures. ranges (list of list of int): The array of ranges where each range is a list [left, right]. Returns: list of int: The array of average temperatures for each range. results = [] for left, right in ranges: range_sum = sum(temperatures[left:right+1]) range_len = right - left + 1 average = range_sum // range_len # Floor division to round down to nearest integer results.append(average) return results"},{"question":"Given an array of strings `words` and a string `chars`, you need to determine the total length of all the strings you can form with the characters from `chars` using each character at most once. You can assume that each character in `chars` is lowercase English letters. Return the sum of lengths of all such strings from the array `words`.","solution":"def count_characters(words, chars): from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) can_form = True for char in word_count: if word_count[char] > chars_count.get(char, 0): can_form = False break if can_form: total_length += len(word) return total_length"},{"question":"You are given a list of intervals where each interval is represented as a pair `[start, end]`, and each `start` and `end` are integers representing an inclusive range. Merge all overlapping intervals and return _an array of the non-overlapping intervals that cover all the intervals in the input_. Note that an interval `[a, b]` overlaps with `[c, d]` if `a <= d` and `c <= b`. For example, given the intervals `[[1,3], [2,6], [8,10], [15,18]]`, the function should return `[[1,6], [8,10], [15,18]]` since intervals `[1,3]` and `[2,6]` overlap and are merged into `[1,6]`.","solution":"def merge_intervals(intervals): Merge all overlapping intervals. Parameters: intervals (List[List[int]]): A list of intervals represented by [start, end]. Returns: List[List[int]]: A list of merged non-overlapping intervals. if not intervals: return [] # Sort intervals based on the starting time intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: prev = merged[-1] # Check if there is an overlap if current[0] <= prev[1]: # If overlap, merge the intervals merged[-1] = [prev[0], max(prev[1], current[1])] else: # If no overlap, add the current interval to merged list merged.append(current) return merged"},{"question":"You are given an integer array `arr` of length `n` and an integer `k`. Your task is to determine if there exists a contiguous subarray of length `k` that has an average value greater than or equal to a given number `threshold`. Return `true` if such a subarray exists, otherwise return `false`.","solution":"def subarray_with_avg_at_least_threshold(arr, k, threshold): Determines if there exists a contiguous subarray of length `k` with an average value greater than or equal to `threshold`. Parameters: arr (list): The input array of integers. k (int): The length of the subarray. threshold (int): The threshold value. Returns: bool: True if such a subarray exists, else False. n = len(arr) if n < k: return False threshold_sum = k * threshold current_sum = sum(arr[:k]) if current_sum >= threshold_sum: return True for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum >= threshold_sum: return True return False"},{"question":"A binary tree is a data structure where each node has at most two children, referred to as the left child and the right child. You are given the `root` of a binary tree. Implement an algorithm to determine if the binary tree is height-balanced. A binary tree in which the left and right subtrees of every node differ in height by no more than 1 is considered height-balanced. Return `true` if the tree is height-balanced, and `false` otherwise.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determine if the binary tree is height-balanced. :type root: TreeNode :rtype: bool def check_balance(node): if not node: return 0, True left_height, is_left_balanced = check_balance(node.left) right_height, is_right_balanced = check_balance(node.right) current_height = max(left_height, right_height) + 1 is_current_balanced = is_left_balanced and is_right_balanced and abs(left_height - right_height) <= 1 return current_height, is_current_balanced _, balanced = check_balance(root) return balanced"},{"question":"A company is developing a new application to manage the flow of documents within its departments. Every document can be transferred from one department to another, and each department has a unique identifier. You are required to design a system to keep track of document transfers in real-time. Implement the `DocumentSystem` class: * `void transferDocument(int documentId, int fromDepartment, int toDepartment, int timestamp)`: A document with ID `documentId` is transferred from `fromDepartment` to `toDepartment` at the given `timestamp`. * `List<Integer> getTransferHistory(int documentId)`: Returns a list of department identifiers that the document with ID `documentId` has been transferred through, in chronological order. The following constraints must be adhered to: - All transfers are consistent such that `timestamp` always increases for the same document. - A document can be transferred multiple times, and the list of departments in the history should be distinct. - There will be at least one transfer recorded before `getTransferHistory` is called.","solution":"class DocumentSystem: def __init__(self): self.documents = {} def transferDocument(self, documentId, fromDepartment, toDepartment, timestamp): if documentId not in self.documents: self.documents[documentId] = [] self.documents[documentId].append((toDepartment, timestamp)) def getTransferHistory(self, documentId): if documentId in self.documents: history = sorted(self.documents[documentId], key=lambda x: x[1]) return [entry[0] for entry in history] return []"},{"question":"Given a string `s` and an integer `k`, find and return the maximum number of substrings you can remove from `s` such that each substring is of length `k` and all characters in the substring are distinct. The substrings removed should not overlap.","solution":"def max_distinct_substrings(s, k): Returns the maximum number of substrings of length k with distinct characters that can be removed from the string s without overlap. def are_all_chars_distinct(substring): return len(set(substring)) == len(substring) n = len(s) count = 0 i = 0 while i <= n - k: potential_substring = s[i:i+k] if are_all_chars_distinct(potential_substring): count += 1 i += k else: i += 1 return count"},{"question":"You are given a binary tree with `n` nodes. Each node is labeled uniquely with integers from `1` to `n`. You are also given two integers, `a` and `b`. Your task is to determine the length of the shortest path between the nodes labeled `a` and `b`. You can assume that the tree is rooted at node `1`. Return the length of the shortest path as an integer.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def findLCA(root, n1, n2): if root is None: return None if root.val == n1 or root.val == n2: return root left_lca = findLCA(root.left, n1, n2) right_lca = findLCA(root.right, n1, n2) if left_lca and right_lca: return root return left_lca if left_lca is not None else right_lca def findLevel(root, data, level): if root is None: return -1 if root.val == data: return level left = findLevel(root.left, data, level + 1) if left == -1: return findLevel(root.right, data, level + 1) return left def shortestPath(root, a, b): lca = findLCA(root, a, b) d1 = findLevel(lca, a, 0) d2 = findLevel(lca, b, 0) return d1 + d2"},{"question":"Given a list of integers, return the length of the longest subsequence such that elements in the subsequence are **consecutive** integers. The subsequence does not need to be contiguous, but the order must be strictly increasing. For example, given the list `[100, 4, 200, 1, 3, 2]`, the longest consecutive subsequence is `[1, 2, 3, 4]`, and the length is 4.","solution":"def longest_consecutive_subsequence(nums): Finds the length of the longest subsequence with consecutive integers in a given list `nums`. Args: nums (List[int]): The list of integers. Returns: int: The length of the longest consecutive subsequence. if not nums: return 0 nums = set(nums) longest_length = 0 for num in nums: if num - 1 not in nums: # Check if it is the start of a sequence current_num = num current_length = 1 while current_num + 1 in nums: current_num += 1 current_length += 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"Write a function `calculateWaterTrapped(heights: List[int]) -> int` that takes a list of non-negative integers representing the heights of blocks where the width of each block is `1` and returns the total amount of water trapped after it rains. The height of the blocks and the width between blocks determine the amount of water trapped. Use the following rules: * Water accumulation occurs in regions where it is bounded by taller blocks on both sides. * You need to return the total volume of water trapped between the blocks. For example, given `heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`, the function should return `6`.","solution":"def calculateWaterTrapped(heights): Calculate the total amount of water trapped between the blocks defined by their heights. Parameters: heights (List[int]): A list of non-negative integers representing the heights of blocks Returns: int: The total amount of water trapped if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Compute left max heights array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Compute right max heights array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the total water trapped for i in range(1, n-1): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"Given two integers `n` and `k`, return the lexicographically smallest string containing `n` distinct lowercase English letters such that each letter in the string appears exactly `k` times. If there are multiple valid results, return any one.","solution":"def smallest_string(n, k): Returns the lexicographically smallest string containing n distinct lowercase English letters such that each letter appears exactly k times. # Generate the required distinct characters (first n lowercase letters) chars = [chr(ord(\'a\') + i) for i in range(n)] # Repeat each character k times result = \'\'.join(char * k for char in chars) # Return the final string return result"},{"question":"You are given a list of integers `nums` representing a non-negative integer. The list is such that each element in the list is a digit of the integer in order. Your task is to add one to this integer and return the resulting list of digits. For example, if the input list is `[1, 2, 3]`, representing the integer 123, the output should be `[1, 2, 4]`. Handle the scenario where the integer might have trailing zeros or might result in an overflow to a new digit length.","solution":"def plus_one(nums): Increment the integer represented by a list of digits by one. Args: nums (list): a list of integers where each element is a digit. Returns: list: list of integers representing the incremented integer. n = len(nums) for i in range(n - 1, -1, -1): if nums[i] < 9: nums[i] += 1 return nums nums[i] = 0 # If we have all nines, we need an extra digit at the beginning return [1] + [0] * n"},{"question":"Given an array of `n` integers, where `n` is even and all elements appear exactly twice, except for two elements which appear only once. Your task is to find the two elements that appear only once. Return the two elements in any order. For example, given the array `[1, 2, 1, 3, 2, 5]`, your program should return `[3, 5]` or `[5, 3]`.","solution":"def find_two_unique_numbers(arr): Finds the two unique numbers in the array where every other number appears twice. :param arr: List of integers :return: List with the two unique integers xor_result = 0 # Step 1: XOR all elements for num in arr: xor_result ^= num # Step 2: Find a set bit in xor_result set_bit = xor_result & -xor_result # Step 3: Divide numbers into two groups and find the unique numbers num1 = 0 num2 = 0 for num in arr: if num & set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"You are given a **0-indexed** integer array `nums`. An index `i` is called **special** if `nums[i]` is greater than `nums[i-1]` (if `i > 0`) and greater than `nums[i+1]` (if `i < nums.length - 1`). Return _the number of special indices_ in the array. Example 1: Input: `nums = [1, 2, 1, 3, 5, 6, 4]` Output: `2` Explanation: Indices `1` and `5` are special because `nums[1] > nums[0]` and `nums[1] > nums[2]` and `nums[5] > nums[4]` and `nums[5] > nums[6]`. Example 2: Input: `nums = [1, 2, 3, 4, 5]` Output: `0` Explanation: There are no special indices in the array. Note: - An element cannot be special if it is at the boundary of the array.","solution":"def count_special_indices(nums): Returns the number of special indices in the array `nums`. if len(nums) < 3: return 0 # There can\'t be any special indices in arrays shorter than 3 special_count = 0 for i in range(1, len(nums) - 1): if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]: special_count += 1 return special_count"},{"question":"You are given a string `s` which consists of only lowercase English letters. You need to find if it is possible to rearrange the characters of the string such that no two adjacent characters are the same. If possible, return one possible rearrangement of the string. If not possible, return an empty string. Write a function with the following signature: ```python def rearrangeString(s: str) -> str: # your code here ``` # Example: ***Input:*** `s = \\"aab\\"` ***Output:*** `\\"aba\\"` ***Input:*** `s = \\"aaab\\"` ***Output:*** `\\"\\"`","solution":"from collections import Counter import heapq def rearrangeString(s: str) -> str: if not s: return \\"\\" # Count the frequency of each character char_count = Counter(s) max_heap = [] # Build a max heap based on the frequency of the characters for char, count in char_count.items(): heapq.heappush(max_heap, (-count, char)) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_char is not None and prev_count < 0: # Push the previous character back if it has remaining count heapq.heappush(max_heap, (prev_count, prev_char)) # Update the previous character and its count prev_char = char prev_count = count + 1 # Increment because it\'s negative result_string = \'\'.join(result) # If the length of the result is not equal to the original string, it means it was not possible if len(result_string) != len(s): return \\"\\" return result_string"},{"question":"You are given a string `s` consisting of lowercase English letters. A substring of `s` is called a **good substring** if all the characters of the substring are distinct. Return the number of distinct **good substrings** in `s`. Note: - A substring is a contiguous sequence of characters within the string. - Two substrings are considered distinct if they start or end at different positions in the string.","solution":"def count_good_substrings(s): Returns the number of distinct good substrings in s. A good substring is defined as a substring where all characters are distinct. good_substrings = set() n = len(s) for i in range(n): seen = set() for j in range(i, n): if s[j] in seen: break seen.add(s[j]) good_substrings.add(s[i:j+1]) return len(good_substrings)"},{"question":"You are given a string `s` and an integer array `indices` of the same length. The string `s` has been shuffled such that the character at the `i`-th position in `s` was moved to `indices[i]`. Write a function to return the original string by restoring the characters to their respective positions. Use the provided `indices` to rearrange the characters in `s` back to the original order.","solution":"def restore_string(s, indices): Restores the original string by rearranging the characters in the given string \'s\' based on the provided array \'indices\'. Parameters: s (str): The shuffled string. indices (list): The list of indices indicating the original positions of characters. Returns: str: The restored original string. restored = [\'\'] * len(s) # Create a list of empty strings of the same length as \'s\' for char, idx in zip(s, indices): restored[idx] = char # Place each character at its original position return \'\'.join(restored) # Join the list into a single string and return"},{"question":"You are given a string `s` representing a formula in a chemical equation, which consists of letters, digits, and parenthesis. Each letter represents an element, and digits following letters represent the number of atoms of that element. Digits following a closing parenthesis represent the multiplier for the enclosed group of atoms. Return a dictionary where the keys are element names and the values are their respective counts in the formula. Assume that the formula is always valid. **Example**: - Input: `s` = \\"Mg(OH)2\\" - Output: {\'Mg\': 1, \'O\': 2, \'H\': 2}","solution":"from collections import defaultdict import re def count_atoms(formula): def parse_formula(formula): stack = [defaultdict(int)] idx, n = 0, len(formula) while idx < n: if formula[idx] == \'(\': stack.append(defaultdict(int)) idx += 1 elif formula[idx] == \')\': idx += 1 start = idx while idx < n and formula[idx].isdigit(): idx += 1 multiplier = int(formula[start:idx] or \'1\') top = stack.pop() for el, count in top.items(): stack[-1][el] += count * multiplier else: start = idx idx += 1 while idx < n and formula[idx].islower(): idx += 1 element = formula[start:idx] start = idx while idx < n and formula[idx].isdigit(): idx += 1 count = int(formula[start:idx] or \'1\') stack[-1][element] += count return stack[-1] return dict(parse_formula(formula))"},{"question":"You are given a 2D grid `grid` of size `m x n` where each cell represents a wall (1) or free space (0). You can walk up, down, left, or right from a free space cell to another free space cell. Write a function `findShortestPath` that takes `grid`, a starting coordinate `(sx, sy)`, and an ending coordinate `(ex, ey)` and returns the length of the shortest path from `(sx, sy)` to `(ex, ey)`. If there is no path, return -1. The path must not include diagonal steps or pass through any walls.","solution":"from collections import deque def findShortestPath(grid, sx, sy, ex, ey): Finds the length of the shortest path in a grid from start (sx, sy) to end (ex, ey). Parameters: grid (list of list of int): 2D grid representing the map with walls (1) and free spaces (0) sx (int): starting x coordinate sy (int): starting y coordinate ex (int): ending x coordinate ey (int): ending y coordinate Returns: int: length of the shortest path, or -1 if no path exists if not grid or grid[sx][sy] != 0 or grid[ex][ey] != 0: return -1 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(sx, sy, 0)]) visited[sx][sy] = True while queue: x, y, steps = queue.popleft() if (x, y) == (ex, ey): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0: visited[nx][ny] = True queue.append((nx, ny, steps + 1)) return -1"},{"question":"You are given a linked list where the nodes contain integers. The linked list may have a cycle formed if a node\'s next pointer points to one of its previous nodes, forming a loop. Detect if the linked list has a cycle in it. _Return a boolean_ indicating whether there is a cycle or not. You must implement a solution with a linear runtime complexity and use only constant extra space.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def has_cycle(head): Detect if the linked list has a cycle in it. :param head: The head of the linked list. :return: True if there is a cycle, False otherwise. slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"You are given a string `s` consisting solely of characters `\'a\'`, `\'b\'`, and `\'c\'`. You can perform the following operation any number of times: Remove three consecutive characters that are all different (\'abc\' or \'acb\' or \'bac\' or \'bca\' or \'cab\' or \'cba\') from the string. Your goal is to determine if you can make the string empty by applying the above operation any number of times. Return `true` if you can make the string empty, otherwise return `false`.","solution":"def can_be_empty(s): Returns true if the string can be made empty by removing all instances of \'abc\', \'acb\', \'bac\', \'bca\', \'cab\', or \'cba\'. stack = [] for char in s: stack.append(char) if len(stack) >= 3: if (stack[-3] != stack[-2] and stack[-2] != stack[-1] and stack[-1] != stack[-3]): stack.pop() stack.pop() stack.pop() return len(stack) == 0"},{"question":"Given an integer array `nums`, find the maximum length of a subarray consisting of elements that appear an even number of times in the array. A **subarray** is a contiguous non-empty sequence of elements within an array. Return _the maximum length of such subarray_.","solution":"def max_length_even_frequency_subarray(nums): Returns the maximum length of a subarray consisting of elements that appear an even number of times in the subarray. max_len = 0 freq = {0: -1} # Dictionary to store the first occurrence of each state (even or odd frequency) state = 0 # This will act as a bitmask to toggle states for i, num in enumerate(nums): state ^= 1 << (num - min(nums)) # Flip the bit corresponding to the current number if state in freq: max_len = max(max_len, i - freq[state]) # Update max_len if this state was seen before else: freq[state] = i # Store the first occurrence of this state return max_len"},{"question":"Given a list of unsorted integers `nums`, find the **minimum difference** between the maximum and minimum elements in any **subsequence** of length `k`. A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return the minimum difference you can achieve.","solution":"def min_diff_subsequence(nums, k): Find the minimum difference between the maximum and minimum elements in any subsequence of length k. Args: - nums (list of int): List of unsorted integers. - k (int): The length of the subsequence. Returns: - int: The minimum difference. if len(nums) < k: return None # Cannot form a subsequence of length k nums.sort() min_diff = float(\'inf\') for i in range(len(nums) - k + 1): min_diff = min(min_diff, nums[i + k - 1] - nums[i]) return min_diff"},{"question":"You are given a string `s` and an integer `k`. Your task is to determine whether the string `s` can be rearranged such that the difference between the positions of any two adjacent occurrences of the same character is at least `k`. Return `true` if it is possible to rearrange the string in such a way, and `false` otherwise.","solution":"from collections import Counter import heapq def reorganize_string(s, k): Check if a string can be rearranged so that the same character appears at least k distance apart. :param s: Input string :param k: Minimum distance between identical characters :return: True if rearrangement is possible, False otherwise if k <= 1: return True # Count frequency of each character freq = Counter(s) # Using a max heap (invert frequencies to use heapq as max heap) max_heap = [(-value, key) for key, value in freq.items()] heapq.heapify(max_heap) queue = [] # Queue to keep track of previous K characters and their frequencies result = [] while max_heap: current_freq, current_char = heapq.heappop(max_heap) result.append(current_char) # Decrease the count and add to the queue with its new frequency and index queue.append((current_char, current_freq + 1)) # If queue has reached size k, re-add the item at the front of the queue back to the heap if len(queue) >= k: previous_char, previous_freq = queue.pop(0) if previous_freq < 0: heapq.heappush(max_heap, (previous_freq, previous_char)) return len(result) == len(s)"},{"question":"You are given two strings `s1` and `s2` which represent two different binary numbers. Your task is to perform the **XOR** operation on these two binary numbers and return the result as a binary string. The XOR operation, also known as exclusive or, is a bitwise operation that returns `1` if the corresponding bits of the operands are different, and `0` if they are the same. Ensure that the leading zeros in the result are correctly removed unless the result is `0`. Return _the **binary string** that results from the XOR operation on `s1` and `s2`_.","solution":"def binary_xor(s1, s2): Perform the XOR operation on two binary strings and return the result as a binary string. :param s1: First binary string :param s2: Second binary string :return: Resulting binary string after performing XOR # Ensure both strings are the same length by prefixing the shorter one with zeroes max_len = max(len(s1), len(s2)) s1 = s1.zfill(max_len) s2 = s2.zfill(max_len) result = [] for i in range(max_len): bit1 = s1[i] bit2 = s2[i] # XOR operation if bit1 == bit2: result.append(\'0\') else: result.append(\'1\') # Combine result into a string and strip leading zeros, return \'0\' if result is empty result_str = \'\'.join(result).lstrip(\'0\') return result_str or \'0\'"},{"question":"A `Playlist` is a class that manages a list of songs. Each song is uniquely identified by its title, and the songs in the playlist should be ordered based on their addition sequence. The `Playlist` class should support adding songs, removing songs by title, and shuffling the playlist randomly. Implement the `Playlist` class: * `Playlist()` Initializes the empty `Playlist` object. * `void addSong(string title)` Adds a song with the specified `title` to the playlist. * `bool removeSong(string title)` Removes the song with the specified `title` from the playlist. Returns `true` if the song was successfully removed, `false` if the song does not exist. * `List<string> shuffle()` Returns a new List containing all the current songs in a random order, without modifying the order in the original playlist. Your implementation should ensure that the `addSong`, `removeSong`, and `shuffle` methods work efficiently regardless of the number of songs in the playlist. **Note:** You can assume that the song titles will be unique when added.","solution":"import random class Playlist: def __init__(self): self.songs = [] self.song_set = set() # To keep track of unique song titles def addSong(self, title): if title not in self.song_set: self.songs.append(title) self.song_set.add(title) def removeSong(self, title): if title in self.song_set: self.songs.remove(title) self.song_set.remove(title) return True return False def shuffle(self): shuffled_songs = self.songs[:] random.shuffle(shuffled_songs) return shuffled_songs"},{"question":"You are given two sorted arrays of integers `nums1` and `nums2` of lengths `m` and `n` respectively, and an integer `k`. Merge the two arrays into one sorted array such that the resulting array contains exactly `k` smallest elements from the original arrays. Return _the sorted array containing exactly the first `k` smallest elements._","solution":"def merge_and_get_k_smallest(nums1, nums2, k): Merges two sorted arrays nums1 and nums2 and returns the first k smallest elements. Parameters: nums1 (list): The first sorted array. nums2 (list): The second sorted array. k (int): The number of smallest elements to return. Returns: list: The first k smallest elements from the merged array. merged_array = [] i = j = 0 while len(merged_array) < k: if i < len(nums1) and (j >= len(nums2) or nums1[i] <= nums2[j]): merged_array.append(nums1[i]) i += 1 else: merged_array.append(nums2[j]) j += 1 return merged_array"},{"question":"You are given a **2D matrix** `matrix` of integers where each row is sorted in ascending order from left to right and each column is sorted in ascending order from top to bottom. Given an integer `target`, write a function to find the `target` in the `matrix`. If `target` is found, return the **indices** of the `target` as a list `[i, j]` where `i` is the row index and `j` is the column index. If `target` is not found, return `[-1, -1]`.","solution":"def search_matrix(matrix, target): Searches given target in a 2D matrix and returns its indices if found. Each row and column of the matrix is sorted in ascending order. Parameters: matrix (list of list of int): The 2D matrix to search. target (int): The target value to search for. Returns: list of int: Indices of the target in the form [i, j] if found, otherwise [-1, -1]. if not matrix or not matrix[0]: return [-1, -1] rows = len(matrix) cols = len(matrix[0]) i, j = 0, cols - 1 while i < rows and j >= 0: if matrix[i][j] == target: return [i, j] elif matrix[i][j] < target: i += 1 else: j -= 1 return [-1, -1]"},{"question":"You are given a list of `n` projects, each project `i` is represented as an array `projects[i] = [durationi, lastDayi]`, where `durationi` is the number of days required to complete the project and `lastDayi` is the last day on which the project can be completed. You need to schedule these projects in such a way that the maximum number of projects can be completed before their respective deadlines. Return _the maximum number of projects that can be completed_ considering the constraints of their durations and deadlines.","solution":"def max_projects(projects): Given a list of projects, each represented by [durationi, lastDayi], returns the maximum number of projects that can be completed before their respective deadlines. # Sort projects based on their deadline (lastDayi) projects.sort(key=lambda x: x[1]) current_time = 0 count = 0 # Iterate through the sorted list of projects for duration, lastDay in projects: if current_time + duration <= lastDay: # If the project can be completed before its last day, we take it current_time += duration count += 1 return count"},{"question":"Given a binary tree where each node contains a value from `0` to `100`, return the length of the longest path where each adjacent node in the path has a difference of `1`. The path can go up, down, and turn at any node as long as the difference in values between every consecutive node on the path is exactly `1`. A path is defined by a sequence of nodes where each pair of consecutive nodes in the sequence have a direct parent-child relationship. Return the length of the longest such path.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_consecutive_path(root): Function to return the length of the longest path in a binary tree where the values have a difference of 1 between consecutive nodes. def dfs(node, parent, length): if not node: return length if parent and abs(node.val - parent.val) == 1: length += 1 else: length = 1 left_length = dfs(node.left, node, length) right_length = dfs(node.right, node, length) return max(length, left_length, right_length) if not root: return 0 return dfs(root, None, 0)"},{"question":"You are given an array `intervals` where `intervals[i] = [starti, endi]` represent the start and end of the `i`-th interval. The intervals are non-overlapping and sorted by their start time. A new interval `newInterval = [startNew, endNew]` needs to be added to the `intervals` array while preserving the order and the non-overlapping property. Return the updated array of intervals after merging `newInterval` into the correct position, and merging any necessary intervals to maintain the non-overlapping property.","solution":"def insert_and_merge_intervals(intervals, new_interval): Insert a new interval into the list of non-overlapping sorted intervals and merge where necessary to ensure the resulting list remains non-overlapping. result = [] i = 0 n = len(intervals) # Add all intervals that end before the new interval starts unchanged while i < n and intervals[i][1] < new_interval[0]: result.append(intervals[i]) i += 1 # Merge all overlapping intervals to the new interval while i < n and intervals[i][0] <= new_interval[1]: new_interval[0] = min(new_interval[0], intervals[i][0]) new_interval[1] = max(new_interval[1], intervals[i][1]) i += 1 # Add the merged new_interval result.append(new_interval) # Add remaining intervals unchanged while i < n: result.append(intervals[i]) i += 1 return result"},{"question":"You are given a string `s` consisting of lowercase alphabets. You can perform the following operation any number of times: choose any two adjacent characters and remove them if they are the same. Return the length of the smallest string that you can obtain after performing some number of operations (possibly zero or more). Note that the order of the characters in the resulting string should be maintained.","solution":"def smallestStringLength(s): Returns the length of the smallest string that can be obtained by removing any number of adjacent pairs of the same characters. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"You are given a string `s` consisting of lowercase English letters. A **duplicate letter** is defined as a letter that has occurred more than once in the string. Your task is to remove all **duplicate letters** from the string and return the resultant string. The final string should contain the letters in the order they first appear in `s`. If there are no duplicate letters, return the original string. (This question aligns with concepts like string manipulation, set operations, and maintaining order in an array, which are common in coding assessments.)","solution":"def remove_duplicate_letters(s): Removes duplicate letters from the given string and returns the resultant string. The letters in the final string are in the order they first appear in `s`. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are given a list of `n` integers `arr` and an integer `k`. Your task is to find the length of the longest contiguous subarray that contains at most `k` distinct integers. If `n` is 0, return 0. Implement the function to achieve this in an optimal manner.","solution":"def longest_subarray_with_k_distinct(arr, k): Finds the length of the longest contiguous subarray with at most k distinct integers. Parameters: arr (List[int]): List of integers. k (int): Maximum number of distinct integers allowed in subarray. Returns: int: Length of the longest contiguous subarray with at most k distinct integers. if not arr or k == 0: return 0 from collections import defaultdict left = 0 longest = 0 current_distinct_count = 0 frequency_map = defaultdict(int) for right in range(len(arr)): if frequency_map[arr[right]] == 0: current_distinct_count += 1 frequency_map[arr[right]] += 1 while current_distinct_count > k: frequency_map[arr[left]] -= 1 if frequency_map[arr[left]] == 0: current_distinct_count -= 1 left += 1 longest = max(longest, right - left + 1) return longest"},{"question":"You are given a string `s` containing only the characters \'a\', \'b\', and \'c\'. You want to split the string into the minimum number of substrings such that each substring is either \\"abc\\" or \\"acb\\". Return the minimum number of such substrings that you can obtain. Note that each character in the string must be used exactly once, and every substring must be one of the specified patterns.","solution":"def min_substrings(s): Returns the minimum number of substrings that you can obtain such that each substring is either \\"abc\\" or \\"acb\\". count = 0 i = 0 while i < len(s): if i + 2 < len(s) and (s[i:i+3] == \\"abc\\" or s[i:i+3] == \\"acb\\"): count += 1 i += 3 else: return -1 # If we cannot find a valid substring of length 3, we cannot split the string as required. return count"},{"question":"Design a function that takes in a 2D grid of size `n x m` where each cell represents an elevator. Each cell can be either `0` or `1` where `1` means the elevator is operational and `0` means it is out of service. A person can only move to adjacent cells (up, down, left, right) if the elevator in the target cell is operational (`1`). Determine the minimum number of moves required for a person to travel from the top-left corner of the grid to the bottom-right corner. If it is not possible to reach the bottom-right corner, return `-1`.","solution":"from collections import deque def min_moves_to_reach_end(grid): if not grid or not grid[0] or grid[0][0] == 0 or grid[-1][-1] == 0: return -1 n, m = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (i, j, steps) visited = set((0, 0)) while queue: i, j, steps = queue.popleft() if i == n - 1 and j == m - 1: return steps for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < n and 0 <= nj < m and (ni, nj) not in visited and grid[ni][nj] == 1: visited.add((ni, nj)) queue.append((ni, nj, steps + 1)) return -1"},{"question":"You are given a **0-indexed** integer array `points` where `points[i] = [xi, yi]` represents a point in a 2D coordinate plane. A **rectangle** is defined by its diagonal points `(x1, y1)` and `(x2, y2)` such that its sides are parallel to the `x`-axis and `y`-axis. You are asked to determine how many rectangles can be formed using any four points in the `points` array. A valid rectangle requires that for any two points `(x1, y1)` and `(x2, y2)` there must also exist points `(x1, y2)` and `(x2, y1)` in the `points` array. Return _the number of rectangles that can be formed using any four points in `points`_.","solution":"def count_rectangles(points): # Convert the list of points to a set for O(1) lookup times. point_set = set(map(tuple, points)) rectangles = 0 # Iterate over all pairs of points for i in range(len(points)): for j in range(i + 1, len(points)): x1, y1 = points[i] x2, y2 = points[j] if x1 != x2 and y1 != y2: # They must form a diagonal if (x1, y2) in point_set and (x2, y1) in point_set: rectangles += 1 return rectangles // 2 # Each rectangle is counted twice, once for each diagonal"},{"question":"You are given a string `s` that consists of only digits. Each digit represents the number of times its accompanying character repeats. For example, the string \\"2a3b1c\\" should be expanded to \\"aabbbbc\\". Return the expanded string.","solution":"def expand_string(s): Expands a given string where each digit represents the number of times the subsequent character repeats. Args: s (str): The input string consisting of digits and characters. Returns: str: The expanded string. expanded_str = \\"\\" i = 0 while i < len(s): # Check if the current character is a digit if s[i].isdigit(): # Get the repetition count count = int(s[i]) # Move to the next character which needs to be repeated i += 1 # Repeat the character and add to the result expanded_str += s[i] * count i += 1 return expanded_str"},{"question":"You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. Implement the class `MergeKSortedLists` with the following method: - `ListNode mergeKLists(ListNode[] lists)` where `ListNode` is the node class used for linked list which has two properties: `int val` for storing value and `ListNode next` for storing reference to the next node. Example: ``` Input: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] ``` Explanation: The linked-lists are: ``` [ 1->4->5, 1->3->4, 2->6 ] Combining all lists results in the sorted linked-list: 1->1->2->3->4->4->5->6 ```","solution":"import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class MergeKSortedLists: def mergeKLists(self, lists): Merge all the sorted linked-lists into one sorted linked-list. min_heap = [] # Push the head of each list into the min heap for i, l in enumerate(lists): if l: heapq.heappush(min_heap, (l.val, i, l)) dummy = ListNode() current = dummy while min_heap: val, i, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"A company has decided to organize a team-building activity involving a series of stages. Each stage has a challenge that needs to be completed before moving to the next stage. The company has `n` unique stages, and each stage *i* (0 <= `i` < `n`) has a difficulty level represented by an integer `difficulty[i]`. Each participant has a skill level represented by a positive integer. If a participant\'s skill level is `s`, they can successfully complete any stage `i` if `s >= difficulty[i]`. The company wants to distribute participants into groups such that each group is able to complete at least one stage, meaning the highest difficulty of the stages they can complete should be maximized. Return the maximum difficulty level that can be achieved by any of the groups.","solution":"def max_difficulty(stages, difficulties): Given the number of stages and their corresponding difficulty levels, return the maximum difficulty level that can be achieved by any participants group. Parameters: stages (int): number of stages difficulties (list): difficulty levels of the stages Returns: int: maximum difficulty level if not difficulties or stages == 0: return 0 return max(difficulties)"},{"question":"Given two strings `s1` and `s2`, each representing a non-negative integer (for example, `s1 = \\"123\\"` and `s2 = \\"4567\\"`), return a string representing the sum of the two integers. You should not convert the input strings to integers directly and should handle the addition manually as if you were adding two numbers on paper.","solution":"def add_strings(s1, s2): Returns the sum of two non-negative integers represented as strings. # Initialize the result, carry, and pointers to the end of both strings result = [] carry = 0 i, j = len(s1) - 1, len(s2) - 1 # Iterate through both strings from right to left while i >= 0 or j >= 0 or carry: # Get the digit or use 0 if the index is out of bounds digit1 = int(s1[i]) if i >= 0 else 0 digit2 = int(s2[j]) if j >= 0 else 0 # Calculate sum of digits including carry total = digit1 + digit2 + carry carry = total // 10 # Update carry for next iteration result.append(str(total % 10)) # Append the unit place of total to result i -= 1 # Move to the next digits j -= 1 # The result is reversed because we added digits from the end of the strings return \'\'.join(result[::-1])"},{"question":"A company\'s employee records are stored as a list of dictionaries, where each dictionary holds information about an employee with the keys \'id\', \'experience\', and \'salary\'. You need to implement a function to filter and return the list of employees who meet certain criteria. Given the list `employees` and a dictionary `criteria` with the keys \'min_experience\' and \'max_salary\', return _a list of employee ids_ who have experience greater than or equal to `min_experience` and a salary less than or equal to `max_salary`. The order of the returned ids does not matter. If no employees meet the criteria, return an empty list.","solution":"def filter_employees(employees, criteria): Filter employees based on criteria of minimum experience and maximum salary. Parameters: employees (list of dict): List of employee records where each record is a dict with \'id\', \'experience\', and \'salary\'. criteria (dict): Dictionary with \'min_experience\' and \'max_salary\'. Returns: list: List of employee ids who meet the filter criteria. min_experience = criteria.get(\'min_experience\', 0) max_salary = criteria.get(\'max_salary\', float(\'inf\')) filtered_ids = [ employee[\'id\'] for employee in employees if employee[\'experience\'] >= min_experience and employee[\'salary\'] <= max_salary ] return filtered_ids"},{"question":"You are given an array of non-negative integers representing the heights of columns where the width of each column is `1`. The goal is to find two columns such that together with the horizontal line they form a container which holds the most water. You need to return the maximum amount of water that can be stored in such a container. Write a function `maxWaterContainer` that takes in an array of integers `heights` and returns the maximum amount of water the container can store. Note: - You may not slant the container. - The constraints should account for efficient performance with large input sizes.","solution":"def maxWaterContainer(heights): Returns the maximum amount of water the container can store. :param heights: List[int] :return: int max_water = 0 left = 0 right = len(heights) - 1 while left < right: width = right - left height = min(heights[left], heights[right]) max_water = max(max_water, width * height) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given an array of integers `heights` representing the height of individuals standing in a line. Each person can either increase or decrease their height once, swapping it with another person adjacent to them, or keeping their current height. Determine the maximum number of people that can be sorted in non-decreasing order after performing at most one move for each person. Return _an integer representing the maximum number of people sorted in non-decreasing order._","solution":"def max_sorted_after_one_move(heights): Determines the maximum number of people that can be sorted in non-decreasing order after performing at most one move for each person. :param heights: List[int] - List of integers representing heights :return: int - Maximum number of people that can be sorted in non-decreasing order n = len(heights) if n <= 1: return n max_sorted = 1 for i in range(n): current_sorted = 1 for j in range(n-1): # Check original or swapped order if heights[j] <= heights[j + 1] or (j + 2 < n and heights[j] <= heights[j + 2]): current_sorted += 1 max_sorted = max(max_sorted, current_sorted) # Try swapping adjacent elements if i + 1 < n: heights[i], heights[i + 1] = heights[i + 1], heights[i] current_sorted = 1 for j in range(n-1): if heights[j] <= heights[j + 1]: current_sorted += 1 max_sorted = max(max_sorted, current_sorted) heights[i], heights[i + 1] = heights[i + 1], heights[i] # swap back return max_sorted"},{"question":"You are given two integer arrays `nums1` and `nums2`, each representing a list of unique integers. A common subsequence is a sequence that appears in both `nums1` and `nums2` in the same order, but not necessarily consecutively. Return _the length of the longest common subsequence of `nums1` and `nums2`_. Note that a subsequence is derived by deleting some or no elements without changing the order of the remaining elements.","solution":"def longest_common_subsequence(nums1, nums2): Returns the length of the longest common subsequence between nums1 and nums2. # Create a 2D DP array dp = [[0] * (len(nums2) + 1) for _ in range(len(nums1) + 1)] # Fill the DP array for i in range(1, len(nums1) + 1): for j in range(1, len(nums2) + 1): if nums1[i - 1] == nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence return dp[len(nums1)][len(nums2)]"},{"question":"John is organizing a fancy dinner party and needs to assign seats to his guests. He wants to make sure that each guest sits in the best possible seat based on their preferences. You are given two integer arrays `guests` and `seats` where `guests[i]` is the preference score of guest `i` for a good seat, and `seats[j]` is the quality score of the `jth` seat. The preference score indicates how much a guest prefers a better seat, while the quality score indicates how good a seat actually is. John wants to assign exactly one seat to each guest in such a way that the sum of the absolute differences between each guest’s preference score and their assigned seat’s quality score is minimized. Return _an array_ `assignedSeats` _where_ `assignedSeats[i]` _is the index of the seat assigned to the guest `i` to minimize the total dissatisfaction. If there are multiple assignments with the same total dissatisfaction, you may return any of them._","solution":"def assign_seats(guests, seats): Assigns seats to guests to minimize total dissatisfaction. Parameters: guests (list of int): Preference scores of guests. seats (list of int): Quality scores of seats. Returns: list of int: Assigned seat indices for each guest. # Create a list of tuples with guest index and their preference scores guest_prefs = [(i, pref) for i, pref in enumerate(guests)] # Create a list of tuples with seat index and their quality scores seat_quality = [(j, quality) for j, quality in enumerate(seats)] # Sort both lists based on their scores (ascending) guest_prefs.sort(key=lambda x: x[1]) seat_quality.sort(key=lambda x: x[1]) # Initialize the result list with -1 assignedSeats = [-1] * len(guests) # Assign seats based on sorted preferences and qualities for guest, seat in zip(guest_prefs, seat_quality): guest_index = guest[0] seat_index = seat[0] assignedSeats[guest_index] = seat_index return assignedSeats"},{"question":"A company needs to assign `n` tasks to a team of `k` workers. Each task `i` has a specific duration `tasks[i]`, and each worker can only work on one task at a time. The goal is to find an optimal way to assign the tasks to minimize the overall time it takes to complete all tasks. You are given an array `tasks` where `tasks[i]` is the duration of the `i`th task, and an integer `k` representing the number of workers. Return _the minimum possible time to complete all tasks when they are optimally assigned to the workers_.","solution":"def min_time_to_complete_tasks(tasks, k): # Helper function to check if a given time limit is feasible def is_feasible(time_limit): workers = 1 current_time = 0 for task in tasks: if current_time + task <= time_limit: current_time += task else: workers += 1 if workers > k or task > time_limit: return False current_time = task return True # Binary search for the minimal time required to complete all tasks left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if is_feasible(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given two arrays of integers `arr1` and `arr2`, each of length `n`. Your task is to form a 2D grid of size `n x n` where each cell `(i, j)` contains the value `arr1[i] * arr2[j]`. After forming the grid, you can perform a single operation any number of times: swap two adjacent rows or swap two adjacent columns. Return _the **minimum** possible value of the sum of the diagonal elements after performing the operations_.","solution":"def min_diagonal_sum(arr1, arr2): Forms a 2D grid of size n x n with cell (i, j) containing the value arr1[i] * arr2[j] and returns the minimum possible value of the sum of the diagonal elements after performing row or column swaps. arr1.sort() arr2.sort() n = len(arr1) diagonal_sum = 0 for i in range(n): diagonal_sum += arr1[i] * arr2[i] return diagonal_sum"},{"question":"Given a string `s` consisting of lowercase English letters, you need to transform the string into palindrome by insertion of characters if necessary. A palindrome is a word that reads the same both forwards and backwards. You are required to insert as few characters as possible to make the entire string a palindrome. Return _the length of the shortest palindrome that can be formed by inserting characters into the given string_.","solution":"def shortest_palindrome_length(s): Returns the length of the shortest palindrome that can be formed by inserting characters into the given string. def lcs(X, Y): m = len(X) n = len(Y) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] # Reverse of the string s rev_s = s[::-1] # Longest palindromic subsequence length will be LCS of s and rev_s lps_length = lcs(s, rev_s) # Length of the shortest palindrome return len(s) + (len(s) - lps_length)"},{"question":"You are given a **0-indexed** array `paintings` where each element `paintings[i]` represents the height of a painting in a gallery. Two paintings can be considered for a **pair exhibition** if their heights differ by at most `d`. Determine the maximum number of pairs you can form from the given array. Each painting can only participate in one pair. Return _the maximum number of pairs_ you can form.","solution":"def max_pairs(paintings, d): This function takes an array of painting heights and an integer d. It returns the maximum number of pairs that can be formed where the height difference between paintings in each pair is at most d. paintings.sort() n = len(paintings) i = 0 pairs = 0 while i < n - 1: if paintings[i + 1] - paintings[i] <= d: pairs += 1 i += 2 # Skip the next painting as it has been paired else: i += 1 # Move to the next painting return pairs"},{"question":"You are given a list of strings `words` where each word consists of lowercase English letters. You need to determine if there exists a pair of distinct indices `(i, j)` such that the concatenation of `words[i] + words[j]` forms a palindrome. Return _a boolean value indicating the existence of such a pair._","solution":"def is_palindrome(s: str) -> bool: Helper function to check if a string is a palindrome. return s == s[::-1] def pairs_forming_palindrome(words): Returns True if there exists a pair of distinct indices (i, j) such that the concatenation of words[i] + words[j] forms a palindrome. n = len(words) for i in range(n): for j in range(n): if i != j: if is_palindrome(words[i] + words[j]): return True return False"},{"question":"Given a string `s` which consists of lowercase letters, return a new string where each character that appears more than once in `s` is replaced by the character followed by the number of occurrences in the entire string. Characters that appear only once should remain unchanged. For example, given the string `\\"programming\\"`, the function should return `\\"p1r2o1g2r2a1m2m2i1n1g2\\"`.","solution":"def transform_string(s): Transforms the given string such that each character that appears more than once is replaced by the character followed by the number of occurrences in the entire string. Characters that appear only once remain unchanged. Args: s (str): The input string consisting of lowercase letters. Returns: str: The transformed string. from collections import Counter char_count = Counter(s) result = [] for char in s: result.append(char + str(char_count[char])) return \'\'.join(result)"},{"question":"You are given a string `s` containing lowercase letters, and an integer array `cost` where `cost[i]` is the cost of deleting the `i`-th character in `s`. A string is considered good if there are no two consecutive characters that are the same. Return the minimum total cost required to make the string `s` good by deleting some characters.","solution":"def min_cost_to_make_good_string(s, cost): Returns the minimum cost required to make the string good. Parameters: s (str): The input string cost (List[int]): The cost of deleting each character in s Returns: int: Minimum cost to make the string good if not s or len(s) != len(cost): return 0 total_cost = 0 # Traverse the string to check for consecutive duplicates for i in range(1, len(s)): if s[i] == s[i - 1]: # If consecutive characters are the same, we need to delete one with the lower cost if cost[i] < cost[i - 1]: total_cost += cost[i] cost[i] = cost[i - 1] # Retain the higher cost for comparison in subsequent checks else: total_cost += cost[i - 1] return total_cost"},{"question":"Given an array of integers `nums`, you need to find the **contiguous subarray** (containing at least one number) which has the **largest sum** and return its sum. Implement the `maxSubArray` function that takes in a list of integers `nums` and returns the maximum sum of the contiguous subarray. For example, given the input array `nums = [-2,1,-3,4,-1,2,1,-5,4]`, the function should return `6`, which is the sum of the subarray `[4,-1,2,1]`. Implement the function `maxSubArray` as follows: ***Python*** ```python def maxSubArray(nums): # Your implementation here ```","solution":"def maxSubArray(nums): Finds the contiguous subarray which has the largest sum and returns that sum. :param nums: List of integers :return: Integer - maximum sum of a contiguous subarray if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an array `nums` of size `n`, where every element represents the height of a block, calculate the total amount of water trapped after raining. You may assume each block has a unit width. The amount of water trapped is the sum of water accumulated on top of each block between the taller blocks. Return the total amount of water trapped.","solution":"def trap(height): Calculate the total amount of water trapped after raining. :param height: List[int] :return: int if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Given an unsorted array of integers `arr`, find the smallest positive integer that is missing from the array. Your solution should run in O(n) time and use O(1) space, excluding the input array. The array can contain duplicates and negative numbers as well. Return the smallest positive integer that does not appear in `arr`.","solution":"def find_missing_positive(arr): Find the smallest positive integer missing from the array. n = len(arr) # Step 1: Replace negative numbers and zeros with a number larger than the array size for i in range(n): if arr[i] <= 0: arr[i] = n + 1 # Step 2: Mark the presence of numbers within the range 1 to n by using indices for i in range(n): num = abs(arr[i]) if num <= n: arr[num - 1] = -abs(arr[num - 1]) # Step 3: Find the first positive index for i in range(n): if arr[i] > 0: return i + 1 return n + 1"},{"question":"Given a list of integers `nums` and a target sum `target`, determine if there are two different indices `i` and `j` in the list such that `nums[i] + nums[j]` equals the target sum. Return a list of the two indices `i` and `j`. If more than one pair of indices meets the condition, return the first pair found. If no such pair exists, return an empty list. For example, given the list `nums = [2, 7, 11, 15]` and `target = 9`, the function should return `[0, 1]` since `nums[0] + nums[1]` equals 9.","solution":"def find_two_sum_indices(nums, target): Given a list of integers nums and a target sum target, return the indices of the two numbers that add up to target. If no such numbers exist, return an empty list. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"Given a list of `n` integers, `arr`, and an integer `k`, write a function to count the number of contiguous subarrays that have a sum equal to `k`. A subarray is defined as a contiguous non-empty sequence of elements within the array. You need to return the count of such subarrays.","solution":"def subarray_sum(arr, k): Returns the count of contiguous subarrays that sum to k. count = 0 cumulative_sum = 0 sum_dict = {0: 1} for num in arr: cumulative_sum += num if (cumulative_sum - k) in sum_dict: count += sum_dict[cumulative_sum - k] if cumulative_sum in sum_dict: sum_dict[cumulative_sum] += 1 else: sum_dict[cumulative_sum] = 1 return count"},{"question":"You are given a string `s` representing a sequence of parentheses, where `s[i]` is either `\'(\'` or `\')\'`. A valid parentheses sequence is one where every opening parenthesis can be paired with a closing parenthesis in the correct order. You have to correct the string by either removing or replacing invalid brackets to make the sequence valid. You can perform any number of the following operations: * Remove a parenthesis. * Replace a parenthesis with the opposite type (i.e., replace `\'(\'` with `\')\'` or vice versa). Determine the minimum number of operations required to make the sequence valid. Return the minimum number of operations necessary to achieve a valid parentheses sequence.","solution":"def min_operations_to_make_valid(s): Returns the minimum number of operations required to make the parentheses sequence valid. An operation is defined as either removing or replacing a parenthesis. balance = 0 operations = 0 for char in s: if char == \'(\': balance += 1 else: if balance > 0: balance -= 1 else: operations += 1 # Any remaining balance indicates unbalanced opening parentheses operations += balance return operations"},{"question":"Given a list of unique strings, each representing a directory path in a filesystem. You need to delete all the files under these directories recursively. If a directory becomes empty after deleting files, it should also be deleted. Return the remaining directory paths in the list after deletion. The remaining paths should be sorted in **lexicographical order**. If the directory list becomes empty after deleting files, return an empty list.","solution":"def delete_files_and_return_directories(directory_paths): Given a list of unique strings, each representing a directory path in a filesystem, delete all files under these directories recursively. If a directory becomes empty after deleting files, it should also be deleted. Return the remaining directory paths in the list after deletion, sorted in lexicographical order. If the directory list becomes empty after deleting files, return an empty list. # Assuming a function that actually deletes files and directories, here we will just simulate the behavior. # An actual implementation would involve filesystem operations like os.remove, os.rmdir, etc. # Here we assume that each directory path points to a non-empty directory before deletion, # and becomes empty after deletion of all files inside. # In our simulation, to reflect the deletion of files and empty directories, # we will consider all given paths as empty after the operation. remaining_directories = [] # As all directories will be empty, nothing remains return sorted(remaining_directories)"},{"question":"You are given two **0-indexed** integer arrays `nums1` and `nums2`, both of the same length `n`. The task is to create the longest possible new array such that every element of the new array is the maximum of the corresponding elements from `nums1` and `nums2` at each index. For example, given `nums1 = [2, 3, 1]` and `nums2 = [1, 5, 3]`, the resulting array should be `[2, 5, 3]`. Return the new array formed from these maximum elements.","solution":"def max_elements(nums1, nums2): Returns an array where each element is the maximum of the corresponding elements from nums1 and nums2. Args: nums1 : List[int] - First input list of integers. nums2 : List[int] - Second input list of integers. Returns: List[int] - A list of maximum elements from nums1 and nums2. return [max(a, b) for a, b in zip(nums1, nums2)]"},{"question":"You are given an integer array `cards` where the `ith` element represents the value of the `i-th` card. You are allowed to pick any subset of cards, but the sum of the selected cards\' values must be a multiple of a given integer `k`. Your task is to determine if there\'s a non-empty subset of cards whose values sum up to a multiple of `k`. Return `true` if such a subset exists, and `false` otherwise.","solution":"def check_subarray_sum(cards, k): Determines if there\'s a non-empty subset of cards whose sum is a multiple of k. Parameters: cards (list of int): List of integer card values. k (int): The integer multiple to check against. Returns: bool: True if such a subset exists, False otherwise. if k == 0: return any(card == 0 for card in cards) prefix_sum = 0 mods = {0} for card in cards: prefix_sum += card modulus = prefix_sum % k if modulus in mods: return True mods.add(modulus) return False"},{"question":"You are given an array of integers `arr` where each integer occurs exactly three times, except for one integer which occurs only once. Find the element that occurs only once. Your solution should have a linear runtime complexity and use extra memory linear to the size of the input (i.e., O(n) space complexity). Implement the function `int singleNumber(int[] arr)` that returns the integer which occurs only once in the array.","solution":"def singleNumber(arr): Find the element that occurs only once in the array where every other element occurs exactly thrice. :param arr: List[int], input list of integers :return: int, the single integer that occurs only once from collections import Counter # Count the frequency of each integer in the array count = Counter(arr) # Iterate over count dictionary to find the element that occurs only once for key, value in count.items(): if value == 1: return key"},{"question":"You are given a `matrix` of size `m x n` where `matrix[i][j]` represents the height of the cell `(i, j)` in a 2D grid. An island is formed by grouping adjacent cells with the same height, where you can move in four possible directions (left, right, up, down). Two cells belong to the same island if they share the same height and are connected directly or indirectly. Your task is to find the **size of the largest island**. The size of an island is defined as the number of cells in that island. Return _the size of the largest island in the given grid_. (Note: The matrix contains non-negative integers, and two or more islands can have the same height but not necessarily be part of the same grouping as defined by the problem.)","solution":"def largest_island(matrix): Finds the size of the largest island in the matrix. Parameters: matrix (List[List[int]]): 2D list of integers representing heights of cells in the grid. Returns: int: Size of the largest island. if not matrix: return 0 m, n = len(matrix), len(matrix[0]) visited = [[False] * n for _ in range(m)] max_island_size = 0 def dfs(i, j, height): if i < 0 or i >= m or j < 0 or j >= n or visited[i][j] or matrix[i][j] != height: return 0 visited[i][j] = True return 1 + dfs(i + 1, j, height) + dfs(i - 1, j, height) + dfs(i, j + 1, height) + dfs(i, j - 1, height) for i in range(m): for j in range(n): if not visited[i][j]: island_size = dfs(i, j, matrix[i][j]) max_island_size = max(max_island_size, island_size) return max_island_size"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. You are allowed to choose **exactly one** subarray of `nums` and either: - Reverse the order of the subarray or - Rotate the subarray any number of times Return `true` _if it is possible to make `nums` strictly increasing_ after performing the chosen operation on any single subarray of length `k`, otherwise return `false`.","solution":"def can_be_strictly_increasing(nums, k): def is_strictly_increasing(arr): return all(x < y for x, y in zip(arr, arr[1:])) n = len(nums) # Check if the array is already strictly increasing if is_strictly_increasing(nums): return True for i in range(n - k + 1): # Try reversing subarray new_nums = nums[:i] + nums[i:i+k][::-1] + nums[i+k:] if is_strictly_increasing(new_nums): return True # Try rotating subarray subarray = nums[i:i+k] for j in range(1, k): rotated = subarray[j:] + subarray[:j] new_nums = nums[:i] + rotated + nums[i+k:] if is_strictly_increasing(new_nums): return True return False"},{"question":"Given an integer array `arr`, return _the length of the longest subarray with positive product_.","solution":"def get_max_len(arr): Returns the length of the longest subarray with a positive product. max_len = 0 pos_len = 0 neg_len = 0 for num in arr: if num == 0: pos_len = 0 neg_len = 0 elif num > 0: pos_len += 1 if neg_len != 0: neg_len += 1 else: neg_len = 0 else: temp = pos_len if neg_len != 0: pos_len = neg_len + 1 else: pos_len = 0 neg_len = temp + 1 max_len = max(max_len, pos_len) return max_len"},{"question":"You are given a list of non-negative integers `nums` which are arranged in a **triangle**. Your task is to find the **minimum path sum** from the top to the bottom of the triangle. Each step you may move to an adjacent number on the row below. Return _the minimum path sum_. For example, given the following triangle: ``` [ [2], [3, 4], [6, 5, 7], [4, 1, 8, 3] ] ``` The minimum path sum from top to bottom is `11` (i.e., `2 + 3 + 5 + 1 = 11`).","solution":"def minimum_total(triangle): Find the minimum path sum from top to bottom of the triangle. # Start from the second last row and move upwards for row in range(len(triangle) - 2, -1, -1): for col in range(len(triangle[row])): # Update the value to be itself plus the minimum of the two adjacent values from the row below triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1]) # The top element contains the minimum path sum return triangle[0][0]"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings. Two buildings `i` and `j` are considered **beautiful** if the area formed between them (considering the height of the lower building) is larger than any other pair of buildings. The area between buildings `i` and `j` (where `i < j`) can be calculated as `(j - i) * min(heights[i], heights[j])`. Return the indices `[i, j]` of the pair of buildings that forms the largest area. If there are multiple pairs with the same largest area, return the pair with the smallest `i`. If there are still multiple pairs, return the one with the smallest `j` among them.","solution":"def max_area(heights): max_area = 0 result = (0, 0) for i in range(len(heights)): for j in range(i + 1, len(heights)): area = (j - i) * min(heights[i], heights[j]) if area > max_area: max_area = area result = (i, j) elif area == max_area: if i < result[0] or (i == result[0] and j < result[1]): result = (i, j) return list(result)"},{"question":"Given a string `s` consisting of lowercase English letters and the \'*\' character, return _the minimum number of moves to make `s` consist only of lowercase English letters_. A move consists of selecting a contiguous substring of up to two characters that contains at least one \'*\' character and changing both characters to any lowercase English letter. For example, if `s = \\"a*bc*d\\"`, one possible series of moves to convert all \'*\' characters could be: 1. Select the substring \\"a*\\" and change it to \\"ab\\" (1 move) 2. Select the substring \\"c*\\" and change it to \\"cd\\" (1 move) In this scenario, the minimum number of moves to make `s` consist only of lowercase English letters is 2.","solution":"def min_moves_to_remove_stars(s): Returns the minimum number of moves to make `s` consist only of lowercase English letters. if not s: return 0 moves = 0 i = 0 while i < len(s): if s[i] == \'*\': moves += 1 i += 2 else: i += 1 return moves"},{"question":"Given a list of integers `nums`, your task is to return a **doubled array** `result` such that for each integer in the original list, there are two consecutive occurrences in the returned doubled array maintaining their order. For example, if `nums` = `[1, 2, 3]`, the doubled array would be `[1, 1, 2, 2, 3, 3]`. Return _the **doubled array** based on the given list of integers._","solution":"def double_array(nums): Returns a doubled array such that each integer in the original list appears twice consecutively in the resulting list. result = [] for num in nums: result.extend([num, num]) return result"},{"question":"Given an integer array `nums`, rotate the array to the right by `k` steps, where `k` is non-negative. Implement a function that achieves this rotation in-place with O(1) extra space complexity. The function should modify the input array without returning a new one.","solution":"def rotate(nums, k): Rotates the array `nums` to the right by `k` steps in-place with O(1) extra space. n = len(nums) k %= n # in case k is greater than n # Define a helper function to reverse parts of the list def reverse(array, start, end): while start < end: array[start], array[end] = array[end], array[start] start += 1 end -= 1 # Reverse the entire array reverse(nums, 0, n - 1) # Reverse the first k elements reverse(nums, 0, k - 1) # Reverse the rest of the array reverse(nums, k, n - 1)"},{"question":"Given a string `s` consisting of lowercase alphabets, determine if it\'s possible to rearrange the characters in `s` such that no two adjacent characters are the same. If it is possible, return any such rearrangement. If it is not possible, return an empty string. Implement the function: ```python def rearrangeString(s: str) -> str: # your code here ``` - **Input**: A string `s` with length `1 <= s.length <= 10^4`, consisting of only lowercase English letters. - **Output**: A rearranged string with no two adjacent characters being the same, or an empty string if no such rearrangement is possible.","solution":"def rearrangeString(s: str) -> str: from collections import Counter import heapq counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, \'\' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char if len(result) != len(s): return \\"\\" return \'\'.join(result)"},{"question":"You are given a string `s` and a string `pattern`. Return _the starting indices of all occurrences of_ `pattern` _in_ `s`. A valid occurrence is one where the characters of `pattern` can be rearranged to form another substring of `s`. The order of starting indices does not matter.","solution":"from collections import Counter def find_pattern_indices(s, pattern): Returns the starting indices of all occurrences of pattern in s where the characters of pattern can be rearranged to form another substring of s. len_p = len(pattern) len_s = len(s) if len_p > len_s: return [] pattern_count = Counter(pattern) window_count = Counter(s[:len_p-1]) result = [] for i in range(len_p-1, len_s): window_count[s[i]] += 1 if window_count == pattern_count: result.append(i-len_p+1) window_count[s[i-len_p+1]] -= 1 if window_count[s[i-len_p+1]] == 0: del window_count[s[i-len_p+1]] return result"},{"question":"Given a list of unique integers, write a function to find the smallest missing positive integer. Your algorithm should run in O(n) time and use constant extra space.","solution":"def first_missing_positive(nums): Finds the smallest missing positive integer in the list nums. The algorithm runs in O(n) time and uses O(1) extra space. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"You are given a binary tree with `n` nodes where each node in the tree is assigned a value between `1` and `1000`. Two nodes can be swapped in order to recover the binary search tree (BST). Write a function to restore the tree without changing its structure. The function should return the root of the restored binary search tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def recoverTree(root): Recover the binary search tree by swapping the values of two nodes. Parameters: root (TreeNode): The root of the binary tree. Returns: TreeNode: The root of the recovered binary search tree. def inorder_traversal(node): if node: yield from inorder_traversal(node.left) yield node yield from inorder_traversal(node.right) first_element = second_element = prev_element = TreeNode(float(\'-inf\')) for node in inorder_traversal(root): if node.val < prev_element.val: if first_element.val == float(\'-inf\'): first_element = prev_element second_element = node prev_element = node first_element.val, second_element.val = second_element.val, first_element.val return root"},{"question":"You are given a list of integers `nums`. A **triplet** is defined as any three elements `(nums[i], nums[j], nums[k])` where `0 <= i < j < k < nums.length` and `nums[i] < nums[j] < nums[k]`. Write a function to return the total number of **triplets** in the array. Return _the **number** of such triplets_.","solution":"def count_triplets(nums): Returns the total number of triplets (nums[i], nums[j], nums[k]) where 0 <= i < j < k < len(nums) and nums[i] < nums[j] < nums[k]. count = 0 n = len(nums) # Check all possible combinations of triplets for i in range(n): for j in range(i+1, n): for k in range(j+1, n): if nums[i] < nums[j] < nums[k]: count += 1 return count"},{"question":"You are given an array of integers `nums` where the elements are in the range from `1` to `n` and appear exactly once except for one number which appears twice and one number which is missing. Find the duplicate number and the missing number and return them as a pair `(duplicate, missing)`.","solution":"def find_duplicate_and_missing(nums): Find the duplicate and missing numbers in the array. Args: nums (List[int]): A list of integers where each element is in the range from 1 to n, except for one element which is replaced by a duplicate. Returns: Tuple[int, int]: A tuple containing the duplicate number and the missing number. n = len(nums) actual_sum = sum(nums) actual_sum_sq = sum(x*x for x in nums) expected_sum = n * (n + 1) // 2 expected_sum_sq = n * (n + 1) * (2*n + 1) // 6 diff = actual_sum - expected_sum diff_sq = actual_sum_sq - expected_sum_sq sum_diff = diff_sq // diff duplicate = (diff + sum_diff) // 2 missing = sum_diff - duplicate return duplicate, missing"},{"question":"You are given a list `events` where each event is represented as a tuple `(start, end)` denoting the start and end times of the event. You have an integer `k` that represents the maximum number of events you can attend. Your task is to return the maximum number of non-overlapping events you can attend. An event `(a, b)` is considered overlapping with an event `(c, d)` if and only if `a < d` and `c < b`. Ensure that you select the events such that none of the selected events overlap with each other and the total selected events does not exceed `k`.","solution":"def max_non_overlapping_events(events, k): Returns the maximum number of non-overlapping events that can be attended from a list of events. Each event is represented as a tuple (start, end). # Sort events based on end time to maximize the number of non-overlapping events events.sort(key=lambda x: x[1]) max_events = 0 last_end_time = float(\'-inf\') for event in events: if max_events < k and event[0] >= last_end_time: max_events += 1 last_end_time = event[1] return max_events"},{"question":"You are given two strings, `s1` and `s2`, which consist of lowercase English letters. Your task is to determine if `s1` can be transformed into `s2` by a sequence of operations. In one operation, you can insert one character in any position of the string, remove one character from any position of the string, or replace one character with another in any position of the string. Return the minimum number of operations required to transform `s1` into `s2`.","solution":"def min_distance(s1, s2): Returns the minimum number of operations required to transform s1 into s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[m][n]"},{"question":"Given an integer array `arr`, return the length of the **longest subarray** such that all elements are divisible by the same non-zero integer `k`. If there are multiple such subarrays with the maximum length, return the length of any one of them. Note that `k` must be greater than 1 and should divide at least one element in `arr` completely.","solution":"def longest_subarray_divisible_by_same_k(arr): def gcd(x, y): while y: x, y = y, x % y return x max_len = 0 for i in range(len(arr)): current_gcd = 0 for j in range(i, len(arr)): current_gcd = gcd(current_gcd, arr[j]) if current_gcd == 1: break max_len = max(max_len, j - i + 1) return max_len"},{"question":"You are given an integer array `cards` where `cards[i]` is the number on the `i-th` card. We define a *card pair* as two different cards with the same number. Your task is to determine the minimum length of a subarray that contains at least one *card pair*. If no such subarray exists, return `-1`.","solution":"def minimum_card_pair_subarray_length(cards): Determines the minimum length of a subarray that contains at least one card pair. Returns -1 if no such subarray exists. :param cards: List of integers representing card numbers. :return: Minimum length of a subarray containing at least one card pair, or -1 if not possible. card_indices = {} min_length = float(\'inf\') for i, card in enumerate(cards): if card in card_indices: min_length = min(min_length, i - card_indices[card] + 1) card_indices[card] = i return min_length if min_length != float(\'inf\') else -1"},{"question":"Given an array of strings `patterns` and a string `text`, return _an array of integers where each element represents the starting index of a substring in_ `text` _that matches any of the strings in_ `patterns`. _If a pattern string occurs multiple times in the_ `text`, _include each starting index. The order of indices in the output array should correspond to their occurrence in the_ `text`.","solution":"def find_pattern_indices(patterns, text): Returns a list of starting indices of substrings in text that match any of the patterns. indices = [] for pattern in patterns: start = 0 while start != -1: start = text.find(pattern, start) if start != -1: indices.append(start) start += 1 # Increment to find subsequent occurrences indices.sort() # Indices should be in order of their occurrence return indices"},{"question":"You are given a string `text` and an array `words` of unique strings. Your task is to find the maximum number of substrings present in the string `text` that match any of the strings in the `words` array. The substrings in `text` may overlap. Return the count of the maximum number of matches found. For example, if `text` is \\"ababa\\" and `words` contains [\\"aba\\", \\"ab\\"], the result should be 2 because \\"ab\\" appears twice overlapping and \\"aba\\" appears once.","solution":"def max_substrings(text, words): Returns the maximum number of substrings present in the string `text` that match any of the strings in the `words` array. The substrings may overlap. max_count = 0 for word in words: start = 0 count = 0 while start <= len(text) - len(word): if text[start:start + len(word)] == word: count += 1 start += 1 # Move only one character ahead to allow overlapping else: start += 1 max_count = max(max_count, count) return max_count"},{"question":"You are given an integer array `nums` and an integer `target`. Your task is to find a pair of distinct integers in the array that adds up to the target sum. Return the indices of these two numbers in an array. If no such pair exists, return an empty array. The returned array must be sorted in ascending order. You may assume that each input would have exactly one solution. For instance, given `nums = [2, 7, 11, 15]` and `target = 9`, the output should be `[0, 1]` because `nums[0] + nums[1] = 2 + 7 = 9`.","solution":"def two_sum(nums, target): Returns the indices of the two numbers that add up to the target. Parameters: nums (List[int]): The array of integers. target (int): The target sum. Returns: List[int]: A sorted list with the indices of the two numbers. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement], i]) num_to_index[num] = i return []"},{"question":"You are given an array of `n` integers representing the heights of buildings along a street. The city planning department has decided to build a new front garden that must be visible from the street. A garden is considered visible if it is higher than any of the buildings to its left or right when viewed from any position on the street. You need to determine the minimum height required for the garden to be visible. Let `heights[i]` represent the height of the building at position `i`. Write a function that takes an array `heights` as input and returns the minimum height required for the garden to be visible. For example: * Input: `heights = [3, 1, 4, 1, 5]` * Output: `6` In this example, the garden needs to be a minimum of 6 units high because it needs to be taller than the tallest building (which is of height 5) to ensure visibility from both sides of the street.","solution":"def min_visible_garden_height(heights): Returns the minimum height required for the garden to be visible from both sides of the street, given a list of building heights. if not heights: return 1 # Minimum height required if no buildings exist. tallest_building = max(heights) return tallest_building + 1"},{"question":"Given an m x n grid `grid` of characters where each cell represents a different character, and a string `word`, determine if `word` can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Return `true` if `word` exists in the grid, and `false` otherwise.","solution":"def exist(grid, word): Determines if the word can be constructed from sequentially adjacent cells in the grid. if not grid: return False def backtrack(r, c, index): if index == len(word): return True if r < 0 or c < 0 or r >= len(grid) or c >= len(grid[0]) or grid[r][c] != word[index]: return False # Temp mark the cell as visited by replacing with placeholder temp = grid[r][c] grid[r][c] = \'#\' for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]: if backtrack(r + dr, c + dc, index + 1): return True # Restore the cell\'s value after visiting grid[r][c] = temp return False for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == word[0] and backtrack(i, j, 0): return True return False"},{"question":"You are given a list of intervals `intervals` where each interval is a pair of integers `[start, end]` representing a time period during which a job is being performed. Determine _the minimum number of intervals you need to remove_ to make the remaining intervals non-overlapping. Return _the number of intervals that need to be removed_.","solution":"def min_intervals_to_remove(intervals): Determine the minimum number of intervals you need to remove to make the remaining intervals non-overlapping. if not intervals: return 0 # Sort intervals by the end time intervals.sort(key=lambda x: x[1]) # Initialize the count of non-overlapping intervals count = 0 end = float(\'-inf\') for interval in intervals: if interval[0] >= end: # If the current interval starts after or when the last # interval ends, it\'s non-overlapping end = interval[1] else: # Else, we need to remove this interval count += 1 return count"},{"question":"Given a `dictionary` (array of strings) and a string `target`, write a function to determine if the `target` can be composed using any combination of words from the `dictionary`. Words in the `dictionary` can be repeated as many times as needed. You may assume all characters in all words and the `target` are lowercase letters. Return `true` if `target` can be composed using words from the `dictionary`, otherwise return `false`.","solution":"def can_construct(dictionary, target): Determine if the target can be composed using any combination of words from the dictionary. :param dictionary: List of strings representing words in the dictionary. :param target: The target string to be composed. :return: True if target can be composed using words from the dictionary, otherwise False. memo = {} def can_construct_recursive(target): if target in memo: return memo[target] if target == \\"\\": return True for word in dictionary: if target.startswith(word): suffix = target[len(word):] if can_construct_recursive(suffix): memo[target] = True return True memo[target] = False return False return can_construct_recursive(target)"},{"question":"You are given two integer arrays `hours` and `profit`. The array `hours` represents the number of work hours required to complete different projects and `profit` represents the corresponding profit gained from completing those projects. You have a limited number of work hours available in a week, represented by the integer `totalHours`. Write a function that returns the maximum profit you can achieve by choosing a subset of projects to complete within the given `totalHours`. Note that you can only choose each project once and you cannot exceed the total available hours. The function signature is: ```python def maxProfit(hours: List[int], profit: List[int], totalHours: int) -> int: ```","solution":"from typing import List def maxProfit(hours: List[int], profit: List[int], totalHours: int) -> int: n = len(hours) dp = [[0] * (totalHours + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(totalHours + 1): if hours[i - 1] <= j: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - hours[i - 1]] + profit[i - 1]) else: dp[i][j] = dp[i - 1][j] return dp[n][totalHours]"},{"question":"A magic dictionary is a dictionary that simplifies spellchecking by allowing exactly one character substitution. Design a class `MagicDictionary` that can build a dictionary through a list of words and identify if a given word can be transformed into one of the words in the dictionary by changing exactly one character. Implement the `MagicDictionary` class: - `MagicDictionary()` Initializes the dictionary object without any words. - `void buildDict(List<String> dictionary)` Sets the dictionary words list. - `boolean search(String searchWord)` Returns `true` if there is any word in the dictionary that can be obtained by modifying exactly one character in `searchWord`, otherwise returns `false`. For example: MagicDictionary magicDictionary = new MagicDictionary(); magicDictionary.buildDict(List.of(\\"hello\\", \\"leetcode\\")); magicDictionary.search(\\"hhllo\\"); // returns true magicDictionary.search(\\"hello\\"); // returns false magicDictionary.search(\\"hell\\"); // returns false magicDictionary.search(\\"leetcoded\\"); // returns false __Note:__ - Each word in the dictionary\'s length is in the range `1` to `100`. - All words in `dictionary` and `searchWord` are only lower case letters. - `1 <= dictionary.length <= 100`.","solution":"class MagicDictionary: def __init__(self): Initialize the dictionary object. self.words = set() def buildDict(self, dictionary): Build the dictionary from a list of words. :param dictionary: List of words. self.words = set(dictionary) def search(self, searchWord): Returns True if there is any word in the dictionary that can be transformed into the searchWord by changing exactly one character. :param searchWord: The word to search. for word in self.words: if len(word) == len(searchWord): difference = sum(w != s for w, s in zip(word, searchWord)) if difference == 1: return True return False"},{"question":"You are given an array of **n** integers `nums` and an integer `target`. Return _the number of distinct pairs `(i, j)` where `0 <= i < j < n` and `nums[i] * nums[j] == target`._","solution":"def count_pairs(nums, target): Returns the number of distinct pairs (i, j) where 0 <= i < j < n and nums[i] * nums[j] == target. count = 0 n = len(nums) # Use a set to keep track of the pairs and avoid counting the same pair more than once seen_pairs = set() for i in range(n): for j in range(i + 1, n): if nums[i] * nums[j] == target: # Ensure (i, j) is counted and not (j, i) if (i, j) not in seen_pairs: seen_pairs.add((i, j)) count += 1 return count"},{"question":"Given a string `s` and a string `p`, return _the list of all **start** indices of `p`\'s anagrams in `s`_. You may return the answer in **any order**. An **Anagram** of a string is a string that contains the same characters with a different (or the same) ordering. For instance, given `s = \\"cbaebabacd\\"` and `p = \\"abc\\"`, the output would be `[0, 6]` since the substrings `s[0:3]` (\\"cba\\") and `s[6:9]` (\\"bac\\") are anagrams of \\"abc\\".","solution":"def find_anagrams(s, p): Returns a list of all start indices of p\'s anagrams in s. from collections import Counter p_len = len(p) p_count = Counter(p) s_count = Counter(s[:p_len-1]) result = [] for i in range(p_len-1, len(s)): # Add the current character to the window s_count[s[i]] += 1 # Window size is out-of-bound, subtract the character that is left behind if i >= p_len: if s_count[s[i - p_len]] == 1: del s_count[s[i - p_len]] else: s_count[s[i - p_len]] -= 1 # Compare window with p_count if s_count == p_count: result.append(i - p_len + 1) return result"},{"question":"Given a string `s`, consisting of lowercase letters and asterisks (`\'*\'`), return _all possible strings after replacing each `\'*\'` with any lowercase letter from `\'a\'` to `\'z\'`_. Ensure the returned strings are **sorted** in lexicographical order.","solution":"from itertools import product def expand_asterisks(s): Returns all possible strings after replacing each \'*\' with any lowercase letter \'a\' to \'z\'. The returned strings are sorted in lexicographical order. if not s: return [] # Determine the positions of the asterisks asterisk_positions = [i for i, char in enumerate(s) if char == \'*\'] num_asterisks = len(asterisk_positions) # Generate all combinations for the asterisks place combinations = [\'\'.join(p) for p in product(\'abcdefghijklmnopqrstuvwxyz\', repeat=num_asterisks)] possible_strings = [] for combo in combinations: new_string = list(s) for i, char in zip(asterisk_positions, combo): new_string[i] = char possible_strings.append(\'\'.join(new_string)) # Return the list sorted in lexicographical order return sorted(possible_strings)"},{"question":"You are given an integer array `arr` and an integer `k`. `k` represents the number of unique integers you need to find from the array that appear most frequently. Return an array of these `k` most frequent integers in descending order of their frequency. If there are multiple integers with the same frequency, return them in ascending order.","solution":"from collections import Counter import heapq def top_k_frequent(arr, k): Returns the k most frequent integers from the array in descending order of their frequency. If multiple integers have the same frequency, they are returned in ascending order. # Count the frequency of each number in the array frequency = Counter(arr) # Create a heap with (-freq, num) so we can get the max frequency elements heap = [(-freq, num) for num, freq in frequency.items()] # Convert it into a heap heapq.heapify(heap) # Extract the top k elements top_k = [] for _ in range(k): top_k.append(heapq.heappop(heap)[1]) # For the resulting top k elements, we need them in descending frequency and then ascending number if tie in freq return sorted(top_k, key=lambda x: (-frequency[x], x))"},{"question":"You have been given a list of integers `nums` that consists of `n` elements. Your task is to find the longest contiguous subarray within `nums` which has a sum equal to `k`. Return the length of this subarray. If no such subarray exists, return 0.","solution":"def max_subarray_len(nums, k): Returns the length of the longest contiguous subarray that sums to k. Args: nums : list[int] : list of integers k : int : target sum of subarray Returns: int : length of longest subarray with sum equal to k cumulative_sum = 0 sum_indices = {0: -1} max_length = 0 for i, num in enumerate(nums): cumulative_sum += num if (cumulative_sum - k) in sum_indices: max_length = max(max_length, i - sum_indices[cumulative_sum - k]) if cumulative_sum not in sum_indices: sum_indices[cumulative_sum] = i return max_length"},{"question":"You are given a string `s` consisting of lowercase English letters. You can apply the following operation to `s` any number of times: 1. Select a substring that starts and ends with the same character, and reverse it. Return `true` if you can make `s` a palindrome using the above operation, and `false` otherwise. A string is a palindrome if it reads the same forward and backward.","solution":"def can_be_palindrome(s): Returns True if string `s` can be rearranged to form a palindrome by reversing substrings that start and end with the same character. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # A string can be rearranged to form a palindrome if at most one character # has an odd count (for the middle character in an odd-length palindrome) odd_count = sum(1 for count in char_count.values() if count % 2 == 1) return odd_count <= 1"},{"question":"You are given an array `books` where `books[i]` represents the number of pages in the `i-th` book. You are also given an integer `k` which represents the number of students. The books need to be divided among the `k` students in such a way that each student gets at least one book and the maximum number of pages assigned to a student is minimized. Return _the minimum possible value of the maximum number of pages assigned to a student_.","solution":"def is_feasible(books, k, max_pages): students_required = 1 current_sum = 0 for pages in books: if current_sum + pages > max_pages: students_required += 1 current_sum = pages if students_required > k: return False else: current_sum += pages return True def min_max_pages(books, k): if len(books) < k: return -1 left, right = max(books), sum(books) result = right while left <= right: mid = (left + right) // 2 if is_feasible(books, k, mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"You are given a list of tasks represented by `start` and `end` times. Each task is represented as a tuple `(start, end)`, indicating that the task starts at `start` and ends at `end`. You need to find the maximum number of tasks that can be scheduled without overlapping. A task `a` and a task `b` are considered overlapping if `a`\'s `end` time is greater than `b`\'s `start` time and `a`\'s `start` time is less than `b`\'s `end` time. Write a function `int maxTasks(vector<pair<int, int>> tasks)` that returns the maximum number of non-overlapping tasks that can be scheduled.","solution":"def maxTasks(tasks): Returns the maximum number of non-overlapping tasks that can be scheduled. # First sort the tasks by their end times tasks.sort(key=lambda x: x[1]) # Initialize the count of non-overlapping tasks count = 0 last_end_time = -1 # Iterate through the tasks for start, end in tasks: # If the task starts after the last selected task ends, include it if start >= last_end_time: count += 1 last_end_time = end # Return the count of non-overlapping tasks return count"},{"question":"You are given a string `s` containing only lowercase letters, and an integer `k`. You need to select some characters from the string such that you obtain `k` distinct characters. Return the length of the smallest possible substring which contains these `k` distinct characters. If there is no such substring, return `-1`.","solution":"def smallest_substring_with_k_distinct_chars(s, k): Returns the length of the smallest substring which contains exactly k distinct characters. If such a substring does not exist, returns -1. from collections import defaultdict n = len(s) if k > n: return -1 left = 0 min_length = float(\'inf\') char_count = defaultdict(int) distinct_count = 0 for right in range(n): char_count[s[right]] += 1 if char_count[s[right]] == 1: distinct_count += 1 while distinct_count == k: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: distinct_count -= 1 left += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"Implement a `TimeMap` class to store key-value pairs, with each key associated with multiple values each having a timestamp. This class should support two operations: * `void set(String key, String value, int timestamp)` - Stores the key `\'key\'` with the value `\'value\'` at a specific timestamp `\'timestamp\'`. * `String get(String key, int timestamp)` - Returns a value such that for any value, the timestamp is less than or equal to `\'timestamp\'`. If there are multiple values assigned to the same key with timestamps less than or equal to `\'timestamp\'`, it returns the value with the latest timestamp. If there are no values with timestamps less than or equal to `\'timestamp\'`, it returns an empty string `\\"\\"`. Implement the `TimeMap` class to efficiently perform these operations.","solution":"class TimeMap: def __init__(self): self.store = {} def set(self, key, value, timestamp): if key not in self.store: self.store[key] = [] self.store[key].append((timestamp, value)) def get(self, key, timestamp): if key not in self.store or not self.store[key]: return \\"\\" values = self.store[key] left, right = 0, len(values) - 1 result = \\"\\" while left <= right: mid = (left + right) // 2 if values[mid][0] <= timestamp: result = values[mid][1] left = mid + 1 else: right = mid - 1 return result"},{"question":"Given a directed acyclic graph (DAG) with `n` nodes labeled from `0` to `n-1`, and an array `edges` where `edges[i] = [ui, vi]` indicates there is a directed edge from node `ui` to node `vi`, find the number of different topological sorts of the graph. A topological sort of a directed graph is a linear ordering of its nodes such that for every directed edge `ui -> vi`, `ui` comes before `vi` in the ordering. Return the number of distinct topological sorts possible for the given graph. If the graph is not a DAG, meaning it contains cycles, return 0.","solution":"from collections import defaultdict, deque def count_topological_sorts(n, edges): Returns the number of distinct topological sorts for a given DAG. Parameters: - n: Number of nodes in the graph. - edges: List of directed edges in the graph. Returns: - int: The number of distinct topological sorts. def all_topological_sorts(): visited = [False] * n indegree = [0] * n for u, v in edges: indegree[v] += 1 all_orders = [] current_order = [] def dfs(): flag = False for node in range(n): if not visited[node] and indegree[node] == 0: for neighbor in adj[node]: indegree[neighbor] -= 1 current_order.append(node) visited[node] = True dfs() visited[node] = False current_order.pop() for neighbor in adj[node]: indegree[neighbor] += 1 flag = True if not flag: all_orders.append(current_order[:]) dfs() return len(all_orders) def is_cyclic(): visited = [0] * n # 0: Not visited, 1: Visiting, 2: Fully visited def dfs(v): if visited[v] == 1: return True if visited[v] == 2: return False visited[v] = 1 for u in adj[v]: if dfs(u): return True visited[v] = 2 return False for v in range(n): if visited[v] == 0: if dfs(v): return True return False adj = defaultdict(list) for u, v in edges: adj[u].append(v) if is_cyclic(): return 0 return all_topological_sorts()"},{"question":"Given a list of integers `nums`, write a function to return the length of the longest subsequence of `nums` such that all elements of the subsequence are consecutive integers (i.e., the difference between adjacent elements is one). The subsequence does not need to be contiguous but should maintain the order of the original list. Implement your solution with a time complexity lower than `O(n^2)`.","solution":"def longest_consecutive_subsequence(nums): Returns the length of the longest subsequence of nums such that all elements of the subsequence are consecutive integers. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in num_set: # start a new streak current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given a list of integers, `arr`, representing the heights of a group of people. Your task is to determine the minimum number of people that need to be moved in order to ensure that the people are standing in non-decreasing order of height. You can only move people directly to the beginning or the end of the list. Return the minimum number of moves required.","solution":"def min_moves_to_sort(arr): Returns the minimum number of moves required to arrange people in non-decreasing order of height by moving people only to the beginning or the end of the list. n = len(arr) if n == 0: return 0 # Find the longest non-decreasing subsequence from the start longest_inc_subseq_length = 1 inc_length = 1 for i in range(1, n): if arr[i] >= arr[i - 1]: inc_length += 1 longest_inc_subseq_length = max(longest_inc_subseq_length, inc_length) else: inc_length = 1 # Find the longest non-decreasing subsequence from the end longest_dec_subseq_length = 1 dec_length = 1 for i in range(n - 2, -1, -1): if arr[i] <= arr[i + 1]: dec_length += 1 longest_dec_subseq_length = max(longest_dec_subseq_length, dec_length) else: dec_length = 1 # The longest non-decreasing subsequence found will be max(longest_inc_subseq_length, longest_dec_subseq_length) max_sorted_length = max(longest_inc_subseq_length, longest_dec_subseq_length) # Minimum number of moves is total length - max sorted length return n - max_sorted_length"},{"question":"You are given a string `s` consisting of only lowercase English letters and an integer `k`. You need to remove the `k` adjacent duplicate characters from the string until no more such adjacent duplicate characters can be removed. The result should be the final string after all such removals have been done. If `k` is greater than the length of the string or no adjacent duplicate characters of length `k` exist, return the original string. Return _the final string after all possible adjacent duplicate character removals._","solution":"def remove_adjacent_duplicates(s, k): Removes k adjacent duplicate characters from the string s until no more such adjacent duplicate characters can be removed. Parameters: s (str): The input string consisting of only lowercase English letters. k (int): The number of adjacent duplicate characters to be removed. Returns: str: The final string after all possible adjacent duplicate character removals. stack = [] for char in s: if stack and stack[-1][0] == char: stack[-1][1] += 1 if stack[-1][1] == k: stack.pop() else: stack.append([char, 1]) result = \'\'.join(char * count for char, count in stack) return result"},{"question":"Given a `string` s containing only lowercase alphabets, you need to find the length of the longest substring that contains **at most k distinct characters**. Return the length of such a substring. Implement the method `int longestSubstringKDistinct(String s, int k)` that achieves this result. Consider the efficiency of your algorithm in terms of both time and space complexity.","solution":"def longestSubstringKDistinct(s, k): Returns the length of the longest substring that contains at most k distinct characters. from collections import defaultdict # Edge case if k == 0: return 0 n = len(s) if n == 0: return 0 left, right = 0, 0 max_len = 0 char_count = defaultdict(int) while right < n: char_count[s[right]] += 1 right += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left) return max_len"},{"question":"You are given a 2D array `matrix` representing an `m x n` grid where each cell contains an integer. Your task is to find the maximum sum of any subrectangle in the `matrix`. A subrectangle is defined by selecting four integers `(r1, c1)` and `(r2, c2)` where `0 <= r1 <= r2 < m` and `0 <= c1 <= c2 < n`, and summing all elements `matrix[i][j]` for `r1 <= i <= r2` and `c1 <= j <= c2`. Return the maximum sum of any subrectangle.","solution":"def max_subrectangle_sum(matrix): Returns the maximum sum of any subrectangle in the given matrix. if not matrix or not matrix[0]: return 0 def kadane(arr): Helper function to find the maximum sum of a 1D array. max_end_here = max_so_far = arr[0] for num in arr[1:]: max_end_here = max(num, max_end_here + num) max_so_far = max(max_so_far, max_end_here) return max_so_far rows, cols = len(matrix), len(matrix[0]) max_sum = float(\'-inf\') for left_col in range(cols): temp_row_sum = [0] * rows for right_col in range(left_col, cols): for row in range(rows): temp_row_sum[row] += matrix[row][right_col] current_max_sum = kadane(temp_row_sum) max_sum = max(max_sum, current_max_sum) return max_sum"},{"question":"You are given a list of `words` and a string `prefix`. Return a list of all the words in the `words` list that start with the given `prefix`. Note that the returned list should maintain the original order of words in the `words` list. If no words match the given prefix, return an empty list. For example, given the words list `[\\"apple\\", \\"banana\\", \\"apricot\\", \\"cherry\\", \\"blueberry\\"]` and the prefix `\\"ap\\"`, the result should be `[\\"apple\\", \\"apricot\\"]`.","solution":"def words_with_prefix(words, prefix): Returns a list of all words that start with the given prefix. :param words: List of words :param prefix: Prefix string to match :return: List of words starting with the prefix result = [word for word in words if word.startswith(prefix)] return result"},{"question":"[Question] 4: Given an undirected graph represented as an adjacency list, determine if it is a **bipartite** graph. A graph is bipartite if we can split its set of nodes into two independent subsets A and B such that every edge connects a node in A to a node in B. Return _true_ if the given graph is bipartite, otherwise return _false_.","solution":"from collections import deque def is_bipartite(graph): Determines if the given graph is bipartite. Parameters: graph (dict): The adjacency list representation of the graph. Returns: bool: True if the graph is bipartite, False otherwise. color = {} for node in graph: if node not in color: queue = deque([node]) color[node] = 0 # Start coloring node with color 0 while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in color: color[neighbor] = 1 - color[current] # Assign alternate color to the neighbor queue.append(neighbor) elif color[neighbor] == color[current]: return False return True"},{"question":"You are given an integer array `arr` of length `n` and an integer `d`. Your task is to find the number of **distinct elements** in every **subarray** of length `d` of the array `arr`. A subarray is defined as a **contiguous** sequence of elements in the array. Return an array of integers where the `i-th` element corresponds to the number of distinct elements in the `i-th` subarray of length `d` in `arr`. If there are fewer than `d` elements remaining in `arr` to form a subarray, do not include such subarrays in the result.","solution":"def count_distinct_elements(arr, d): Returns a list where each element corresponds to the number of distinct elements in every subarray of length d. if d > len(arr): return [] distinct_counts = [] for i in range(len(arr) - d + 1): subarray = arr[i:i+d] distinct_counts.append(len(set(subarray))) return distinct_counts"},{"question":"Given three integers `x`, `y`, and `n`, return an array of the first `n` integers that are multiples of both `x` and `y`. The resulting integers should be in ascending order. If `n` is less than or equal to 0, return an empty array.","solution":"def common_multiples(x, y, n): Returns an array of the first n integers that are multiples of both x and y. Parameters: - x (int): the first integer - y (int): the second integer - n (int): the number of multiples to return Returns: - List[int]: an array of the first n common multiples of x and y if n <= 0: return [] common_mults = [] lcm = x * y // gcd(x, y) # Using the Least Common Multiple (LCM) formula current_multiple = lcm while len(common_mults) < n: common_mults.append(current_multiple) current_multiple += lcm return common_mults def gcd(a, b): Computes the greatest common divisor (GCD) of a and b using the Euclidean algorithm. Parameters: - a (int) - b (int) Returns: - int: the GCD of a and b while b: a, b = b, a % b return a"},{"question":"You are given a string `allowed` consisting of distinct characters and an array of strings `words`. A string is considered consistent if all characters in the string appear in the string `allowed`. Return _the number of consistent strings in `words`._","solution":"def count_consistent_strings(allowed, words): Count the number of consistent strings in the list of words. A string is consistent if all characters in the string appear in the string `allowed`. allowed: str words: list of str return: int allowed_set = set(allowed) consistent_count = 0 for word in words: if all(char in allowed_set for char in word): consistent_count += 1 return consistent_count"},{"question":"You are given a sorted **1-indexed** array of integers `nums` of length `n`, and an integer `target`. The array is **rotated** at an unknown pivot, meaning the array is initially sorted in ascending order, then possibly rotated at some pivot. For example, the array `[1, 2, 3, 4, 5]` could become `[4, 5, 1, 2, 3]` or `[3, 4, 5, 1, 2]`. Your task is to determine the **original index** of the given `target` if it were to be in the **non-rotated** version of the array. If the target does not exist in the array, return `-1`. Implement the function `int findOriginalIndex(int[] nums, int target)` that performs this task.","solution":"def find_original_index(nums, target): Finds the original index of the target in the non-rotated sorted array. Arguments: nums -- An array of integers that has been rotated. (1-indexed) target -- The target integer to find. Returns: The original index (1-indexed) of the target in the non-rotated sorted array, or -1 if the target is not found. if not nums: return -1 left, right = 0, len(nums) - 1 pivot = -1 # First, we find the pivot point where the rotation happened while left <= right: mid = (left + right) // 2 if mid < right and nums[mid] > nums[mid + 1]: pivot = mid break if mid > left and nums[mid] < nums[mid - 1]: pivot = mid - 1 break if nums[left] >= nums[mid]: right = mid - 1 else: left = mid + 1 if pivot == -1: pivot = len(nums) - 1 # Perform binary search in the rotated array def binary_search(nums, left, right, target): while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1 # Binary search applied on both subarrays split by pivot result = binary_search(nums, 0, pivot, target) if result != -1: return result + 1 # Convert to 1-indexed result = binary_search(nums, pivot + 1, len(nums) - 1, target) if result != -1: return result + 1 # Convert to 1-indexed return -1"},{"question":"Given a string `s` consisting of only characters \'a\', \'b\', and \'c\', you are allowed to perform operations to convert `s` into a string with no three consecutive characters being the same. Your task is to determine the minimum number of operations required to achieve this. In one operation, you can change any single character in the string to any other character (\'a\', \'b\', or \'c\'). Write a function: ```python def min_operations(s: str) -> int: ``` that takes in a string `s` and returns an integer representing the minimum number of operations needed. # Example: ```text Input: s = \\"aaabccc\\" Output: 1 Explanation: Changing the second or third \'a\' to \'b\' will remove the three consecutive \'a\'s. ``` # Constraints: - `s` contains only characters \'a\', \'b\', and \'c\'. - `1 <= len(s) <= 10^5`.","solution":"def min_operations(s: str) -> int: Returns the minimum number of operations needed to ensure there are no three consecutive characters being the same in the string. operations = 0 n = len(s) i = 0 while i < n - 2: if s[i] == s[i+1] == s[i+2]: operations += 1 i += 2 # Skip next character since we need to change this one else: i += 1 return operations"},{"question":"You are given a list of **n** pairs of integers representing intervals. Each interval `i` is represented as `[starti, endi]` where `0 <= starti < endi <= 10^6`. Find all the **non-overlapping** intervals from the given list that maximize the total length of intervals selected. Return _the list of selected intervals sorted by their starting points_. If there are multiple solutions with the same total interval length, return any of them. **Note**: - Two intervals `[starti, endi]` and `[startj, endj]` are considered non-overlapping if `endi < startj` or `endj < starti`. - The total length of intervals is defined as the sum of the lengths of individual intervals, where the length of interval `[starti, endi]` is `endi - starti`. **Example**: Input: intervals = [[1,3],[2,4],[3,5],[7,9]] Output: [[1,3],[7,9]] In this example, the selected intervals are [1,3] and [7,9], which are non-overlapping and have a total length of 4 (2+2).","solution":"def maximize_interval_length(intervals): Returns the list of selected non-overlapping intervals that maximize the total length sorted by start point. # Sort intervals by their end time intervals = sorted(intervals, key=lambda x: x[1]) selected_intervals = [] last_end_time = -1 for interval in intervals: start, end = interval if start > last_end_time: selected_intervals.append(interval) last_end_time = end return selected_intervals"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to construct a new string from `s` such that it contains exactly `k` distinct characters. To achieve this, you can perform the following operations any number of times: * Choose a non-empty substring of `s` and remove all occurrences of it from `s`. * After performing the operations, if it\'s possible to construct the new string with exactly `k` distinct characters, return the new string. Otherwise, return an empty string. Note: * The order of characters in the new string matters. * The new string should be the lexicographically smallest string possible. Example 1: Input: s = \\"bbacccabc\\", k = 2 Output: \\"bc\\" Example 2: Input: s = \\"abcd\\", k = 3 Output: \\"\\" Explanation: In the first example, we can remove all occurrences of \\"a\\" and \\"c\\" to get \\"bbbc\\", and then \\"bbb\\" to get \\"bc\\" which contains exactly 2 distinct characters. This is the lexicographically smallest possible string with 2 distinct characters. In the second example, it\'s not possible to construct a string with exactly 3 distinct characters from \\"abcd\\".","solution":"from collections import Counter def smallest_string_with_k_distinct_chars(s, k): Constructs the lexicographically smallest string with exactly k distinct characters from the given string s by removing substrings. # Base case: if k is greater than the number of unique characters in s, return \\"\\" if k > len(set(s)): return \\"\\" # Count the frequency of each character in the string freq_counter = Counter(s) # Sort characters by their frequency and then lexicographically sorted_chars = sorted(freq_counter) # Try to form a string with exactly k unique characters result = [] distinct_chars_used = 0 for char in sorted_chars: if distinct_chars_used < k: result.append(char) distinct_chars_used += 1 else: break return \\"\\".join(result)"},{"question":"You are given two strings `s` and `t` of the same length, only containing lowercase English letters. You are allowed to take any character from `s` and replace it with any other character at most `k` times. Return _the minimum number of distinct characters between the original string `s` and the resulting string after performing at most `k` replacements in `t`_.","solution":"def min_distinct_characters_after_replacements(s, t, k): Returns the minimum number of distinct characters between the original string `s` and the resulting string `t` after performing at most `k` replacements in `t`. Parameters: s (str): The original string. t (str): The string to be transformed. k (int): The maximum number of replacements allowed. Returns: int: The minimum number of distinct characters between the original string `s` and the resulting string. # Count the number of different characters between s and t at the beginning diff_count = sum(1 for i in range(len(s)) if s[i] != t[i]) # The minimum distinct characters is either reduced by making replacements or just the original diff_count return max(0, diff_count - k)"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. A **substring** is called balanced if all characters in the substring appear the same number of times. In one move, you can replace any character in `s` with any other lowercase English letter. Return _the **minimum** number of moves required to make any substring of length `k` balanced_.","solution":"def min_moves_to_make_k_balanced(s, k): Returns the minimum number of moves required to make any substring of length k balanced. Parameters: s (str): the input string consisting of lowercase English letters. k (int): the length of the substring to be balanced. Returns: int: minimum number of moves required. min_moves = float(\'inf\') n = len(s) for i in range(n - k + 1): substring = s[i:i+k] char_freq = {} for ch in substring: if ch in char_freq: char_freq[ch] += 1 else: char_freq[ch] = 1 max_freq = max(char_freq.values()) moves = k - max_freq min_moves = min(min_moves, moves) return min_moves"},{"question":"You are given a list of schedules where each schedule is a list of strings representing booked time intervals. Each string represents an interval in the format `\\"HH:MM-HH:MM\\"`, where `\\"HH:MM\\"` is a time string in 24-hour format. For example, a schedule could be `[\\"09:00-10:30\\", \\"12:00-13:00\\", \\"16:00-18:00\\"]`. You are also given the duration of a meeting in minutes. Your task is to find the earliest time a new meeting can be scheduled such that the meeting does not overlap with any existing meetings in any of the given schedules and falls within the working hours of `09:00` to `18:00`. Given a list of schedules and an integer duration, return the earliest available time slot for the meeting as a string in the `\\"HH:MM\\"` format. If no such time slot exists, return `\\"No Available Slot\\"`. Note that the provided schedules can be from multiple persons and merge them properly to determine the available times. For example, given the schedules `[[\'09:00-10:30\', \'12:00-13:00\', \'16:00-18:00\'], [\'10:00-11:00\', \'12:30-13:30\', \'14:00-15:00\']]` and a meeting duration of `30` minutes, the earliest available time slot would be `\\"11:00\\"`.","solution":"from datetime import datetime, timedelta def find_earliest_meeting_time(schedules, duration): fmt = \'%H:%M\' work_start = datetime.strptime(\'09:00\', fmt) work_end = datetime.strptime(\'18:00\', fmt) duration_td = timedelta(minutes=duration) intervals = [] for schedule in schedules: for interval in schedule: start, end = interval.split(\'-\') intervals.append((datetime.strptime(start, fmt), datetime.strptime(end, fmt))) sorted_intervals = sorted(intervals) available_time = work_start for start, end in sorted_intervals: if available_time + duration_td <= start: return available_time.strftime(fmt) available_time = max(available_time, end) if available_time + duration_td <= work_end: return available_time.strftime(fmt) return \\"No Available Slot\\" # Example usage: # schedules = [[\'09:00-10:30\', \'12:00-13:00\', \'16:00-18:00\'], [\'10:00-11:00\', \'12:30-13:30\', \'14:00-15:00\']] # duration = 30 # print(find_earliest_meeting_time(schedules, duration)) # should return \'11:00\'"},{"question":"Given an integer array `nums`, move all instances of a specified element `val` in the array to the end while maintaining the relative order of the non-`val` elements. Return the modified array. Do this in-place and without making a copy of the array.","solution":"def move_element_to_end(nums, val): Moves all instances of `val` in the array `nums` to the end while maintaining the relative order of the non-`val` elements. This is done in-place. :param nums: List[int] - Array of integers :param val: int - Element to be moved :return: List[int] - Modified array with `val` elements moved to the end i = 0 # Pointer for iterating through the array last_non_val_position = 0 # Position to place the next non-val element # Move non-val elements to the front of the array while i < len(nums): if nums[i] != val: nums[last_non_val_position] = nums[i] last_non_val_position += 1 i += 1 # Fill the remaining positions with val for i in range(last_non_val_position, len(nums)): nums[i] = val return nums"},{"question":"Given a binary tree, where each node has a value of `0` or `1`, prune the tree so that subtrees containing all `0`s are removed. A subtree of a node `node` is `node` plus every node that is a descendant of `node`. Return the same tree where every subtree (of the given tree) not containing a `1` has been removed.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root): Prune the binary tree such that subtrees containing all 0s are removed. if not root: return None root.left = pruneTree(root.left) root.right = pruneTree(root.right) if root.val == 0 and not root.left and not root.right: return None return root"},{"question":"Given a list of integers `arr`, you need to implement a function that finds the **maximum product** of any three distinct numbers in the array. Return the maximum product. If the array contains fewer than three elements, return `-1`.","solution":"def maximum_product_of_three(arr): Returns the maximum product of any three distinct numbers in the array. If the array contains fewer than three elements, return -1. if len(arr) < 3: return -1 arr.sort() # The maximum product of three numbers can be either: # 1. The product of the three largest numbers. # 2. The product of the two smallest numbers (most negative) and the largest number. max_product = max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1]) return max_product"},{"question":"Given a list of non-negative integers `nums`, find the contiguous subarray (containing at least one number) which has the largest product, and return the product. Note that the contiguous subarray could include negative numbers as well, but the sign of the product will be determined by the even or odd count of those negative numbers.","solution":"def max_product_subarray(nums): Finds the contiguous subarray within an array (containing at least one number) which has the largest product. if not nums: return 0 max_prod = min_prod = result = nums[0] for num in nums[1:]: if num < 0: max_prod, min_prod = min_prod, max_prod max_prod = max(num, max_prod * num) min_prod = min(num, min_prod * num) result = max(result, max_prod) return result"},{"question":"You are given a string `s` consisting only of characters \'a\', \'b\', and \'c\', and an integer `k`. Your task is to find the length of the longest substring of `s` that contains at most `k` distinct characters. Implement a function with the following signature: ```cpp int longestSubstringWithKDistinctChars(const string& s, int k); ``` **Example:** ```plaintext Input: s = \\"abcba\\", k = 2 Output: 3 Explanation: The longest substring with at most 2 distinct characters is \\"bcb\\" with length 3. ```","solution":"def longestSubstringWithKDistinctChars(s, k): Returns the length of the longest substring containing at most k distinct characters. if k == 0: return 0 n = len(s) if n == 0: return 0 left = 0 right = 0 max_length = 0 char_count = {} while right < n: current_char = s[right] if current_char in char_count: char_count[current_char] += 1 else: char_count[current_char] = 1 while len(char_count) > k: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"You are given a **non-empty** array `nums` of positive integers representing the amount of money of each house. You are a burglar trying to rob these houses, but you cannot rob two adjacent houses because the alarms will go off. Write a function to return _the maximum amount of money you can rob tonight **without alerting the police**_. Analyze the function signature and constraints before writing your solution. Try to consider both **time** and **space** optimization in your approach and ensure the solution is efficient for reasonably large inputs.","solution":"def rob(nums): Return the maximum amount of money you can rob tonight without alerting the police. :param nums: List[int] - a list of positive integers representing the amount of money of each house. :return: int - the maximum amount of money that can be robbed without alerting the police. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # Initialize two variables to store the maximum money robbed so far prev1 = 0 prev2 = 0 for num in nums: temp = prev1 prev1 = max(prev2 + num, prev1) prev2 = temp return prev1"},{"question":"Given a **2D integer array** `grid` representing a rectangular grid where `grid[i][j]` is the height of a building located at `(i, j)`, return _the skyline profile of the grid from both top-bottom and left-right perspectives_. The **skyline profile** is the maximum height of the buildings viewed from the respective perspectives. The returned result should be a tuple where the first element is a list of the maximum heights seen from the left to right perspective (one entry per row), and the second element is a list of the maximum heights seen from the top to bottom perspective (one entry per column).","solution":"def skyline_profiles(grid): Given a 2D integer array `grid`, returns the skyline profiles from both top-bottom and left-right perspectives. Parameters: grid (list of list of int): 2D array representing the heights of buildings. Returns: tuple: A tuple (left_right, top_bottom) where left_right is the list of maximum heights seen from left to right perspective and top_bottom is the list of maximum heights seen from top to bottom perspective. if not grid or not grid[0]: return ([], []) left_right = [max(row) for row in grid] top_bottom = [max(grid[i][j] for i in range(len(grid))) for j in range(len(grid[0]))] return (left_right, top_bottom)"},{"question":"You are given a binary tree where each node represents an operation in a computation process. Each operation can either be a \\"store\\" operation, which saves its value, or an \\"add\\" operation, which sums the values of its left and right children. The leaf nodes of the tree are all \\"store\\" operations and contain an integer value. Internal nodes are \\"add\\" operations and do not contain a value but depend on their children nodes\' values. Implement a function that takes the root of such a binary tree and returns the final computed value at the root. Here is the structure of a node in the binary tree: ```python class TreeNode: def __init__(self, operation, value=0, left=None, right=None): self.operation = operation # \'store\' or \'add\' self.value = value # only relevant for \'store\' operations self.left = left self.right = right ``` The function should be defined as: ```python def compute_tree(root: TreeNode) -> int: # Your code here ``` - If the operation is \'store\', return the node\'s value. - If the operation is \'add\', recursively compute the values of the left and right children and return their sum.","solution":"class TreeNode: def __init__(self, operation, value=0, left=None, right=None): self.operation = operation # \'store\' or \'add\' self.value = value # only relevant for \'store\' operations self.left = left self.right = right def compute_tree(root: TreeNode) -> int: if root.operation == \'store\': return root.value elif root.operation == \'add\': left_value = compute_tree(root.left) right_value = compute_tree(root.right) return left_value + right_value # Example usage: # tree = TreeNode(\'add\', left=TreeNode(\'store\', value=1), right=TreeNode(\'add\', left=TreeNode(\'store\', value=2), right=TreeNode(\'store\', value=3))) # assert compute_tree(tree) == 6 # 1 + (2 + 3)"},{"question":"Given a string `s` representing a valid IPv4 address, remove the third octet from the IPv4 address and return the modified address. An IPv4 address is a string in the format \\"x.x.x.x\\", where x is a number between 0 and 255. For example, given an input string \\"192.168.0.1\\", the function should return \\"192.168.1\\". If the input string is not a valid IPv4 address, return an empty string.","solution":"def remove_third_octet(ip): Removes the third octet from a valid IPv4 address. Args: ip: A string representing a valid IPv4 address. Returns: A string with the third octet removed. If the input is not a valid IPv4 address, returns an empty string. parts = ip.split(\'.\') if len(parts) == 4 and all(part.isdigit() and 0 <= int(part) <= 255 for part in parts): return f\\"{parts[0]}.{parts[1]}.{parts[3]}\\" return \\"\\""},{"question":"Given an array of integers `nums` and an integer `target`, return _**all unique pairs** of numbers in the array that add up to `target`_. Each pair should be presented as a list `[num1, num2]`, and the pairs should be in **non-descending order**. If no such pairs exist, return an empty list. **Note**: - The integers in a pair `(num1, num2)` should be ordered such that `num1 <= num2`. - Pairs must be sorted in ascending order based on the first then second element of the pair. - The solution set must not contain duplicate pairs. For example, two pairs `(1, 2)` and `(2, 1)` are considered the same and only one should be included.","solution":"def two_sum_pairs(nums, target): Returns all unique pairs of numbers in the array that add up to target. Each pair is presented as a list [num1, num2] in non-descending order. nums.sort() # Sort the list to handle non-descending order requirement easily. pairs = [] seen = set() # To keep track of pairs to avoid duplicates. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: if (nums[left], nums[right]) not in seen: pairs.append([nums[left], nums[right]]) seen.add((nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return pairs"},{"question":"Given an integer array `nums`, return _the number of inversions_ in the array. An inversion is a pair of indices `(i, j)` such that `i < j` and `nums[i] > nums[j]`.","solution":"def count_inversions(nums): Returns the number of inversions in the array `nums`. An inversion is a pair of indices (i, j) such that i < j and nums[i] > nums[j]. def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn\'t exceed the mid and j doesn\'t exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right) // 2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count temp_arr = [0] * len(nums) return merge_sort_and_count(nums, temp_arr, 0, len(nums) - 1)"},{"question":"You are given a matrix `grid` of `m` x `n` integers and an array `queries` of integers. Each element in the `queries` array represents a query to find the minimum value in the entire `grid` after performing a sequence of `k` operations. In each operation, you can choose any submatrix of `grid` and increment each of its elements by 1. For each query, return the minimum value in the `grid` after exactly `k` operations. Note that the modifications from the previous query are not carried over to the next query. Return the results as an array of integers.","solution":"def min_value_after_operations(grid, queries): def min_in_grid(grid): return min(min(row) for row in grid) results = [] for k in queries: minim_val = min_in_grid(grid) results.append(minim_val + k) return results"},{"question":"Given an integer array `nums`, return the maximum difference between the increasing elements of `nums` such that for some `i < j`, `nums[j] > nums[i]`. If no such `j` exists, return -1. Note that the elements need not be consecutive.","solution":"def maximumDifference(nums): Given an integer array nums, return the maximum difference between the increasing elements of nums such that for some i < j, nums[j] > nums[i]. If no such j exists, return -1. max_diff = -1 min_element = nums[0] for num in nums[1:]: if num > min_element: max_diff = max(max_diff, num - min_element) min_element = min(min_element, num) return max_diff"},{"question":"Given an integer `num`, repeatedly add all its digits until the result has only one digit. You must do this without any kind of loop or recursion. Return the resulting single-digit number.","solution":"def add_digits(num): Given an integer num, repeatedly add all its digits until the result has only one digit. The function solves this without using any kind of loop or recursion. if num == 0: return 0 return 1 + (num - 1) % 9"},{"question":"Write a function that takes a string `s` consisting of characters `\'0\'` and `\'1\'`. The function should return the maximum length of a contiguous subarray such that the number of `\'0\'`s and the number of `\'1\'`s in this subarray are equal.","solution":"def find_max_length(s): Returns the maximum length of a contiguous subarray with equal number of \'0\'s and \'1\'s. count_map = {0: -1} max_len = 0 count = 0 for i, char in enumerate(s): count += 1 if char == \'1\' else -1 if count in count_map: max_len = max(max_len, i - count_map[count]) else: count_map[count] = i return max_len"},{"question":"Given an array `arr` of integers, find the maximum value of `j - i` such that `arr[j] >= arr[i]` and `i <= j`. Return the maximum value of `j - i`. If no pair of indices satisfy this condition, return `-1`.","solution":"def max_index_diff(arr): Given an array of integers, returns the maximum value of j - i such that arr[j] >= arr[i] and i <= j. if not arr: return -1 n = len(arr) left_min = [0] * n right_max = [0] * n left_min[0] = arr[0] for i in range(1, n): left_min[i] = min(left_min[i-1], arr[i]) right_max[n-1] = arr[n-1] for j in range(n-2, -1, -1): right_max[j] = max(right_max[j+1], arr[j]) i = j = 0 max_diff = -1 while i < n and j < n: if left_min[i] <= right_max[j]: max_diff = max(max_diff, j - i) j += 1 else: i += 1 return max_diff"},{"question":"You are given a list of `items`, where each `item` is a pair of strings representing the `type` and `name` of the object. You need to group the items by their types and then sort each group alphabetically by the item names. Finally, return the grouped and sorted list of items while maintaining the order of types as they appear in the input list. For example, given the list: ``` python items = [[\\"fruit\\", \\"apple\\"], [\\"fruit\\", \\"banana\\"], [\\"vegetable\\", \\"carrot\\"], [\\"fruit\\", \\"cherry\\"], [\\"vegetable\\", \\"beetroot\\"]] ``` You should return: ``` python [ [\\"fruit\\", [\\"apple\\", \\"banana\\", \\"cherry\\"]], [\\"vegetable\\", [\\"beetroot\\", \\"carrot\\"]] ] ```","solution":"def group_and_sort_items(items): from collections import defaultdict # Step 1: Group items by type grouped_items = defaultdict(list) order_of_types = [] for item_type, item_name in items: if item_type not in grouped_items: order_of_types.append(item_type) grouped_items[item_type].append(item_name) # Step 2: Sort each group alphabetically by item names result = [] for item_type in order_of_types: sorted_names = sorted(grouped_items[item_type]) result.append([item_type, sorted_names]) return result"},{"question":"Given a string `s` and an integer `n`, split the string into parts of length `n`. If the string length is not a multiple of `n`, pad the last part with the character `\'_ \'` (underscore) to make its length equal to `n`. Return a list of the resulting parts.","solution":"def split_string(s, n): Split the string s into parts of length n. If the string length is not a multiple of n, pad the last part with the character \'_\' (underscore) to make its length equal to n. :param s: string to be split :param n: length of each part :return: list of parts result = [] for i in range(0, len(s), n): part = s[i:i+n] if len(part) < n: part += \'_\' * (n - len(part)) result.append(part) return result"},{"question":"Given an integer array `nums` and an integer `k`, return _the length of the longest consecutive elements sequence in `nums`_ that appears at least `k` times. You must implement a solution with a time complexity better than `O(n log n)`. Note that the elements of the sequence do not need to be adjacent in the original array, but they must follow each other in increasing order by exactly 1.","solution":"def longest_consecutive_sequence_with_k_occurrences(nums, k): Returns the length of the longest consecutive elements sequence in nums that appears at least k times. if not nums: return 0 from collections import defaultdict # Count occurrences of each number in nums num_count = defaultdict(int) for num in nums: num_count[num] += 1 longest_seq_length = 0 # Find the longest consecutive sequence length that appears at least k times for num in set(nums): # Only do this for the start of a sequence if num - 1 not in num_count: current_num = num current_seq_length = 0 count_of_elements_met = True while current_num in num_count and count_of_elements_met: if num_count[current_num] >= k: current_seq_length += 1 current_num += 1 else: count_of_elements_met = False longest_seq_length = max(longest_seq_length, current_seq_length) return longest_seq_length"},{"question":"Given a string `s` and an array of words `words`, determine if `s` is a concatenated substring formed by concatenating all the words exactly once without any intervening characters. Each word in the `words` array has the same length. Return `true` if `s` matches such a concatenation pattern, otherwise return `false`.","solution":"def is_concatenated_substring(s, words): Check if the string `s` is a concatenated substring formed by concatenating all words in `words` exactly once with no intervening characters. Args: s (str): The main string to check. words (list): List of words to concatenate and form the substring. Returns: bool: True if `s` matches the concatenation pattern, False otherwise. if not s or not words: return False word_length = len(words[0]) word_count = len(words) total_length = word_length * word_count if len(s) != total_length: return False from collections import Counter word_freq = Counter(words) for i in range(0, len(s), word_length): word = s[i:i + word_length] if word not in word_freq: return False word_freq[word] -= 1 if word_freq[word] < 0: return False return True"},{"question":"You are given two strings `s1` and `s2`. Write a function to determine if `s2` contains any permutation of `s1`. In other words, one string is a permutation of another if it contains the same characters with the same frequency. Return `true` if `s2` contains a permutation of `s1`, otherwise, return `false`.","solution":"def check_permutation_inclusion(s1, s2): Determine if any permutation of s1 is a substring of s2. Args: s1: The string of which permutations are to be checked. s2: The string within which to find permutations of s1. Returns: bool: True if any permutation of s1 is a substring of s2, else False. from collections import Counter if len(s1) > len(s2): return False s1_count = Counter(s1) window_count = Counter(s2[:len(s1)]) if s1_count == window_count: return True for i in range(len(s1), len(s2)): window_count[s2[i]] += 1 window_count[s2[i - len(s1)]] -= 1 if window_count[s2[i - len(s1)]] == 0: del window_count[s2[i - len(s1)]] if window_count == s1_count: return True return False"},{"question":"You are given a string `s` consisting of the characters \'A\', \'B\', and \'C\' and an integer `k`. You need to construct a new string by replacing exactly `k` characters in `s` with any of the characters \'A\', \'B\', or \'C\' such that there are no two adjacent characters that are the same in the resulting string. Return `true` _if such a transformation is possible._ Otherwise, return `false`.","solution":"def can_transform(s, k): Determines if it\'s possible to replace exactly k characters in s such that no two adjacent characters are the same. :param s: str, input string consisting of \'A\', \'B\', and \'C\' :param k: int, number of characters to replace :return: bool, True if transformation is possible, otherwise False n = len(s) # Case when k >= n if k >= n: return True # Count adjacent same characters adjacent_count = 0 for i in range(1, n): if s[i] == s[i - 1]: adjacent_count += 1 # transformation is possible if adjacent block count <= k return adjacent_count <= k"},{"question":"You are given a string `s` consisting of only lowercase English letters. You need to determine if you can rearrange the characters in the string such that every pair of adjacent characters are different. If such a rearrangement exists, return _one_ valid rearrangement. If no such arrangement exists, return an empty string. **Example:** _Input:_ s = \\"aab\\" _Output:_ \\"aba\\" _Input:_ s = \\"aaab\\" _Output:_ \\"\\"","solution":"from collections import Counter import heapq def rearrange_string(s): Rearrange the string such that no two adjacent characters are the same. If possible, return one valid rearrangement. Otherwise, return an empty string. # Count frequency of each character counter = Counter(s) # Create a max heap based on the counts (-ve for max heap in python) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) # Initialize the previous character and count prev_count, prev_char = 0, \'\' result = [] while max_heap or prev_count < 0: if not max_heap: return \\"\\" count, char = heapq.heappop(max_heap) result.append(char) # As we have used one instance of \'char\', decrement the count and push previous char back into heap if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char return \'\'.join(result)"},{"question":"You are given a 2D integer matrix `matrix` of size `m x n` and an integer `target`. You need to return the number of submatrices that sum to `target`. A submatrix is a contiguous part of the matrix, and submatrices that differ in starting or ending position but have the same elements (position-wise) are considered different. Return _the number of submatrices that sum to `target`_.","solution":"def num_submatrix_sum_target(matrix, target): from collections import defaultdict m, n = len(matrix), len(matrix[0]) # To store the cumulative sum of elements in each row, column-wise. cumulative_row_sum = [[0] * (n+1) for _ in range(m)] for i in range(m): for j in range(n): cumulative_row_sum[i][j+1] = cumulative_row_sum[i][j] + matrix[i][j] result = 0 for col_start in range(n): for col_end in range(col_start, n): sum_freq = defaultdict(int) sum_freq[0] = 1 curr_sum = 0 for row in range(m): curr_sum += cumulative_row_sum[row][col_end+1] - cumulative_row_sum[row][col_start] result += sum_freq[curr_sum - target] sum_freq[curr_sum] += 1 return result"},{"question":"You are given a **0-indexed** binary string `s` of length `n` containing only \'0\'s and \'1\'s. You can perform the following operation any number of times: - Select any substring of `s` and flip all its characters (change \'0\' to \'1\' and \'1\' to \'0\'). Return _the minimum number of operations needed to make all characters in the string equal_.","solution":"def min_operations_to_equal_chars(s): Returns the minimum number of operations needed to make all characters in the binary string equal. n = len(s) num_zeros = s.count(\'0\') num_ones = n - num_zeros # since the rest will be ones # The strategy is to count the number of 0\'s and 1\'s and the minimum number of # operations is to flip the lesser frequency character to match the higher frequency character. return min(num_zeros, num_ones)"},{"question":"Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. You must write an algorithm that utilizes dynamic programming to solve the problem efficiently.","solution":"def word_break(s, wordDict): Returns True if s can be segmented into a space-separated sequence of one or more dictionary words. word_set = set(wordDict) n = len(s) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[n]"},{"question":"You are given a binary tree where each node contains a single digit (0-9). Each root-to-leaf path in the tree represents a number. Compute the sum of all the numbers represented by root-to-leaf paths. Return the total sum modulo `10^9 + 7`. Consider the following binary tree for reference: ``` 4 / 9 0 / 5 1 ``` The root-to-leaf paths are 495, 491, and 40, which represent the numbers 495, 491, and 40 respectively. The sum of these numbers is 495 + 491 + 40 = 1026. Therefore, the result should be 1026 % (10^9 + 7) = 1026. Return the total sum of all numbers represented by root-to-leaf paths modulo `10^9 + 7`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root): Returns the sum of all the numbers represented by root-to-leaf paths modulo 10^9 + 7. MOD = 10**9 + 7 def dfs(node, current_number): Depth-first search helper function to calculate the sum of numbers. if not node: return 0 current_number = current_number * 10 + node.val if not node.left and not node.right: # if it\'s a leaf return current_number # recursively sum the numbers from both subtrees left_sum = dfs(node.left, current_number) right_sum = dfs(node.right, current_number) return (left_sum + right_sum) % MOD return dfs(root, 0)"},{"question":"Given a non-negative integer `x`, write a function to determine whether it is a palindrome when considered as a string. Do not convert the integer into a string directly or any other data structure that could mimic the properties of a string. Instead, use only integer-based operations to check if the number reads the same backward as forward. For example, input `x = 121` should return `true`, whereas input `x = 123` should return `false`.","solution":"def is_palindrome_number(x): Determines whether a non-negative integer is a palindrome without converting it to a string. Args: x (int): A non-negative integer. Returns: bool: True if x is a palindrome, False otherwise. if x < 0: return False original_x = x reversed_x = 0 while x > 0: reversed_x = reversed_x * 10 + x % 10 x //= 10 return original_x == reversed_x"},{"question":"You have been given an `n`-ary tree, where every node has a variable number of children. The tree is rooted at the node with value `root`. Each node in the tree has a unique value represented as an integer. The depth of a node is defined as the number of edges from the root to the node. Your task is to implement a function that, given the root node of an `n`-ary tree, returns a list of lists, where each list contains the values of the nodes at the corresponding depth level. The nodes at each depth level should be listed from left to right as they appear in the tree. The input is guaranteed to be a well-formed `n`-ary tree. Each node is represented as an object with two attributes: - `val` (integer): The value of the node. - `children` (list): A list of children nodes.","solution":"class Node: def __init__(self, val, children=None): self.val = val self.children = children if children is not None else [] def levelOrder(root): Perform a level order traversal (breadth-first search) of an n-ary tree. Returns a list of lists representing the node values at each depth level. if not root: return [] queue = [(root, 0)] result = [] while queue: node, depth = queue.pop(0) if depth == len(result): result.append([]) result[depth].append(node.val) for child in node.children: queue.append((child, depth + 1)) return result"},{"question":"You are given two strings `word1` and `word2`. Implement a function `canTransform` that determines if `word1` can be transformed into `word2` using the following set of operations any number of times: - Insert a character at any position in `word1`. - Delete a character from any position in `word1`. - Replace a character in `word1` with any character. Return `true` if `word1` can be transformed into `word2` using the above operations, otherwise return `false`.","solution":"def canTransform(word1, word2): Returns True if word1 can be transformed into word2 using insert, delete, or replace operations any number of times. return sorted(word1) == sorted(word2)"},{"question":"You are given an integer array `arr` and a target sum `S`. Determine if there exists two non-overlapping continuous subarrays within `arr` whose sums are both equal to `S`. Return `true` if such subarrays exist, and `false` otherwise.","solution":"def find_two_subarrays_with_sum(arr, S): Determines if there exist two non-overlapping continuous subarrays within `arr` whose sums are both equal to `S`. def find_subarrays_with_sum(arr, S): subarrays = [] current_sum = 0 start_index = 0 for end_index, value in enumerate(arr): current_sum += value while current_sum > S and start_index <= end_index: current_sum -= arr[start_index] start_index += 1 if current_sum == S: subarrays.append((start_index, end_index)) return subarrays subarrays = find_subarrays_with_sum(arr, S) for i in range(len(subarrays)): for j in range(i + 1, len(subarrays)): if subarrays[i][1] < subarrays[j][0] or subarrays[j][1] < subarrays[i][0]: return True return False"},{"question":"You are given a list of projects each having a start and an end time represented as a list of lists `projects` where `projects[i] = [start_i, end_i]`. Each project requires exactly one unit of a specific resource to be executed and no two projects can use the resource simultaneously if their time intervals overlap. Your task is to determine the minimum number of units of the resource required to execute all the projects. Return _the minimum number of resource units needed_.","solution":"def min_resource_units(projects): Returns the minimum number of resource units required to execute all projects. if not projects: return 0 # Separate out the start and end timings start_times = sorted([project[0] for project in projects]) end_times = sorted([project[1] for project in projects]) # Pointers to traverse start_times and end_times start_ptr = end_ptr = 0 current_resources = max_resources = 0 # Try to schedule each project while start_ptr < len(projects): if start_times[start_ptr] < end_times[end_ptr]: current_resources += 1 max_resources = max(max_resources, current_resources) start_ptr += 1 else: current_resources -= 1 end_ptr += 1 return max_resources"},{"question":"You are given a 2D grid representing a map of \'1\'s (land) and \'0\'s (water). An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. You need to determine the size of the largest island. The size of an island is the number of \'1\'s that make up the island. Write a function that receives this grid and then returns the size of the largest island.","solution":"def largest_island(grid): Returns the size of the largest island in the grid. if not grid: return 0 rows = len(grid) cols = len(grid[0]) visited = set() def dfs(r, c): if (r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == \'0\' or (r, c) in visited): return 0 visited.add((r, c)) size = 1 # Current land size += dfs(r + 1, c) size += dfs(r - 1, c) size += dfs(r, c + 1) size += dfs(r, c - 1) return size largest_size = 0 for r in range(rows): for c in range(cols): if grid[r][c] == \'1\' and (r, c) not in visited: island_size = dfs(r, c) largest_size = max(largest_size, island_size) return largest_size"},{"question":"Given an array of integers where some elements appear **twice** and others appear **once**, find all the elements that appear **twice**. Your solution should run in **O(n)** time and use **O(1)** extra space. You can assume the returned list is in **any order**.","solution":"def find_duplicates(nums): Find all elements that appear twice in the array. :param nums: List[int], list of integers where some elements appear twice and others appear once :return: List[int], list of elements that appear twice duplicates = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: duplicates.append(abs(num)) else: nums[index] = -nums[index] return duplicates"},{"question":"You are given a string `s` consisting of only characters \'a\', \'b\', and \'c\'. You can perform several operations on this string where each operation involves selecting a pair of adjacent characters and deleting them if they are different (i.e., \\"ab\\", \\"ba\\", \\"bc\\", \\"cb\\", \\"ac\\", \\"ca\\"). Your goal is to find the length of the smallest possible string that can be obtained after applying the aforementioned operations any number of times. Return _the length of the smallest possible string after performing any number of operations_.","solution":"def smallest_possible_string_length(s): stack = [] for char in s: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"Given a binary tree, count the number of uni-value subtrees. A uni-value subtree means all nodes of the subtree have the same value. A binary tree node is represented as `TreeNode` where `TreeNode.val` is the node\'s value, `TreeNode.left` is the left child and `TreeNode.right` is the right child. Implement a function that takes the root node of this binary tree and returns the number of uni-value subtrees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def countUnivalSubtrees(root): Returns the count of uni-value subtrees. A uni-value subtree means all nodes of the subtree have the same value. def is_unival_tree(node, val): if not node: return True if node.val != val: return False return is_unival_tree(node.left, val) and is_unival_tree(node.right, val) def count_unival_subtrees(node): if not node: return 0 left_count = count_unival_subtrees(node.left) right_count = count_unival_subtrees(node.right) count = left_count + right_count if is_unival_tree(node, node.val): count += 1 return count return count_unival_subtrees(root)"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`. Initially, you start with a score of `0`. You can perform the following operation any number of times: - Select an element `nums[i]` where `i` is any index in the array. - Add `nums[i]` to your score. - Remove `nums[i]` and all elements to its right from the array. Return the maximum score you can obtain by performing the above operation any number of times.","solution":"def maxScore(nums): Returns the maximum score that can be obtained by repeatedly selecting an element nums[i] and adding nums[i] to the score while removing nums[i] and all elements to its right from the array. max_score = 0 current_sum = 0 for num in nums: current_sum += num max_score = max(max_score, current_sum) return max_score"},{"question":"Given a string `s` which represents a series of keystrokes, implement a `TextEditor` class that can simulate the typing and deletion of characters. The `TextEditor` class should provide the following methods: - `TextEditor()`: Initializes an empty text editor. - `void typeCharacter(char c)`: Adds the character `c` to the text at the current cursor position. - `void deleteCharacter()`: Deletes the character immediately before the current cursor position. - `String getText()`: Returns the text currently in the editor. The cursor position should be maintained and updated accordingly with each keystroke (typing or deleting). Implement the `TextEditor` class so that it behaves as a simple text editor.","solution":"class TextEditor: A simple text editor class to simulate typing and deletion of characters. def __init__(self): Initialize an empty text editor. self.text = [] self.cursor = 0 def typeCharacter(self, c): Add the character `c` to the text at the current cursor position. self.text.insert(self.cursor, c) self.cursor += 1 def deleteCharacter(self): Delete the character immediately before the current cursor position. Move the cursor one position back if possible. if self.cursor > 0: del self.text[self.cursor - 1] self.cursor -= 1 def getText(self): Returns the text currently in the editor. return \'\'.join(self.text)"},{"question":"Write a function that takes in a **0-indexed** binary array `nums` of length `n`, consisting of only `0` and `1`. A subarray is a contiguous part of the array. You can flip at most `k` elements from `0` to `1` in the array. Return _the **length** of the longest subarray consisting of only `1`\'s after flipping at most `k` `0`\'s_. **Note** that the flips should be done optimally to maximize the length of the subarray.","solution":"def longest_ones(nums, k): Returns the length of the longest subarray consisting of only 1s after flipping at most k 0s to 1s. left = 0 max_length = 0 zeros_count = 0 # Use a sliding window approach for right in range(len(nums)): if nums[right] == 0: zeros_count += 1 while zeros_count > k: if nums[left] == 0: zeros_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"A **binary tree** is a tree data structure in which each node has at most two children, referred to as the left child and the right child. Given the root of a binary tree, the task is to calculate the **maximum depth** of the tree. The maximum depth is the number of nodes along the longest path from the root node to the farthest leaf node. Implement the `BinaryTree` class: * `BinaryTree()` Initializes the object. * `int maxDepth(TreeNode root)` Given the root of a binary tree, returns the maximum depth of the binary tree. Note: The `TreeNode` class is defined with `int val`, `TreeNode left`, and `TreeNode right` attributes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self): pass def maxDepth(self, root: TreeNode) -> int: Given the root of a binary tree, returns the maximum depth of the binary tree. if not root: return 0 left_depth = self.maxDepth(root.left) right_depth = self.maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"You are given a 2D `board` of characters and a list of words `words`. Your task is to find all the words from the list that are present in the board. Each word must be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Return all words that were found, sorted in lexicographical order. **Example:** Input: ``` board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"] ``` Output: ``` [\\"eat\\",\\"oath\\"] ``` **Note:** * All inputs are valid. * The returned list of words should be in lexicographical order.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def findWords(board: List[List[str]], words: List[str]) -> List[str]: def dfs(node, x, y, path, visited): if node.is_end_of_word: result.add(path) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(board) and 0 <= ny < len(board[0]) and (nx, ny) not in visited: char = board[nx][ny] if char in node.children: visited.add((nx, ny)) dfs(node.children[char], nx, ny, path + char, visited) visited.remove((nx, ny)) trie = Trie() for word in words: trie.insert(word) result = set() for i in range(len(board)): for j in range(len(board[0])): char = board[i][j] if char in trie.root.children: dfs(trie.root.children[char], i, j, char, {(i, j)}) return sorted(list(result)) # Example usage: # board = [ # [\'o\',\'a\',\'a\',\'n\'], # [\'e\',\'t\',\'a\',\'e\'], # [\'i\',\'h\',\'k\',\'r\'], # [\'i\',\'f\',\'l\',\'v\'] # ] # words = [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"] # print(findWords(board, words)) # Output: [\\"eat\\", \\"oath\\"]"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. Choose `k` distinct characters from `s`, then find the smallest substring of `s` that contains all the chosen `k` characters at least once. Return the length of that smallest substring. If it is not possible to choose `k` distinct characters, return `-1`. For example: Input: `s = \\"abcabcbb\\"`, `k = 3` Output: `3` Explanation: The smallest substring containing \'a\', \'b\', and \'c\' is \\"abc\\" which has a length of 3.","solution":"def smallest_substring_length(s, k): Finds the length of the smallest substring that contains exactly k distinct characters at least once. Parameters: s (str): the input string consisting of lowercase English letters. k (int): the number of distinct characters to be included in the substring. Returns: int: length of the smallest substring that contains k distinct characters or -1 if not possible. from collections import Counter if len(set(s)) < k: return -1 n = len(s) min_len = float(\'inf\') for start in range(n): distinct_chars = Counter() for end in range(start, n): distinct_chars[s[end]] += 1 if len(distinct_chars) == k: min_len = min(min_len, end - start + 1) break return min_len if min_len != float(\'inf\') else -1"},{"question":"Given an undirected graph represented as an adjacency list, write a function that determines if the graph is bipartite. A bipartite graph is a type of graph where you can divide its vertices into two disjoint and independent sets \'U\' and \'V\' such that every edge connects a vertex in \'U\' to one in \'V\'. Return _true_ if the graph is bipartite, and _false_ otherwise.","solution":"def is_bipartite(graph): Determines if the given undirected graph is bipartite. Args: graph (dict): The adjacency list representing the graph. Returns: bool: True if the graph is bipartite, False otherwise. from collections import deque color = {} for node in graph: if node not in color: color[node] = 0 queue = deque([node]) while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in color: color[neighbor] = 1 - color[current] queue.append(neighbor) elif color[neighbor] == color[current]: return False return True"},{"question":"You are given a string `s` consisting of lowercase Latin letters. You need to find the smallest window in `s` that contains all the distinct characters in `s` at least once. If there are multiple such windows, return the one which appears first lexicographically. Return the smallest window or an empty string if `s` is empty. Implement a function: - `String smallestWindow(String s)` which takes in a string `s` and returns the smallest window containing all distinct characters in `s`.","solution":"def smallestWindow(s): if not s: return \\"\\" # All unique characters in the string unique_chars = set(s) unique_count = len(unique_chars) n = len(s) min_window = s min_length = n + 1 left = 0 char_count = {} for right in range(n): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) == unique_count: if right - left + 1 < min_length: min_length = right - left + 1 min_window = s[left:right + 1] char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 return min_window"},{"question":"You are given a list of `n` integers representing the heights of students standing in a line. The students must rearrange themselves such that no student is taller than the person directly behind them and no student is immediately standing in the same height group as another student with the same height. Return the minimum number of students that must be moved to achieve this arrangement. An arrangement is characterized by heights `h1, h2, ..., hn` where the conditions `hi <= hi+1` and `hi != hi+1` for all `1 <= i <= n-1` must hold true.","solution":"def min_students_to_move(heights): Returns the minimum number of students that must be moved to achieve the required arrangement. n = len(heights) if n <= 1: return 0 heights_sorted = sorted(heights) # To ensure no two students with the same height are adjacent, we must count the number of # such adjacent duplicates in the sorted list. moves = 0 for i in range(n - 1): if heights_sorted[i] == heights_sorted[i + 1]: moves += 1 return moves * 2"},{"question":"You are given an integer array `arr`. An **ideal subsequence** is defined as a subsequence in which every adjacent element maintains an ascending order and the difference between any two adjacent elements in the subsequence is a prime number. Return the length of the longest **ideal subsequence** in `arr`.","solution":"from sympy import isprime def longest_ideal_subsequence(arr): if not arr: return 0 n = len(arr) dp = [1]*n # dp[i] will be the length of longest ideal subsequence ending with arr[i] for i in range(1, n): for j in range(i): if arr[i] > arr[j] and isprime(arr[i] - arr[j]): dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a matrix `matrix` and an integer `target`. The matrix has the following properties: - Each row is sorted in non-decreasing order. - Each column is sorted in non-decreasing order. Write a function that returns `true` if `target` is found in `matrix`, and `false` otherwise. Your solution should be efficient given the sorted structure of the matrix. Return whether `target` exists in `matrix` or not.","solution":"def search_matrix(matrix, target): Returns True if target is found in the matrix, otherwise returns False. The matrix has sorted rows and columns in non-decreasing order. if not matrix: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner of the matrix row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"Given an `n x n` grid representing a perfectly connected city, where `city[i][j]` tells you the number of days it would take to repair the road between cell `(i, j)` and its neighboring cells. Each cell is connected to its four direct neighbors (left, right, up, down). Initially, all roads are in disrepair. You start from the city center at cell `(n//2, n//2)` and need to determine the minimum number of days required to repair all the roads in the city. You can repair one road per day. You may only repair roads that connect directly to already accessible cells (cells that are reachable from the starting cell via repaired roads). Return _the minimum number of days needed to repair all roads in the city_.","solution":"from heapq import heappop, heappush def min_days_to_repair_all_roads(city): n = len(city) start = n // 2, n // 2 # create a min-heap heap = [(0, start[0], start[1])] # (days, row, col) visited = set() while heap: days, row, col = heappop(heap) if (row, col) in visited: continue visited.add((row, col)) # Explore neighbors for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = row + dr, col + dc if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in visited: heappush(heap, (city[nr][nc], nr, nc)) return days"},{"question":"Given a binary tree, write a function to return the values of its nodes as if you were performing a level-order traversal (also known as a breadth-first traversal). The tree is represented by a `TreeNode` class. Each `TreeNode` has an integer `val`, a `left` child TreeNode, and a `right` child TreeNode. The function should return a list of integer values that represents the values of the nodes you visited in order.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Returns the values of the nodes of a binary tree in level-order traversal. if not root: return [] result = [] queue = deque([root]) while queue: current_node = queue.popleft() result.append(current_node.val) if current_node.left: queue.append(current_node.left) if current_node.right: queue.append(current_node.right) return result"},{"question":"You are given a 2D grid of integers where each integer represents the height of a cell. Each cell can \\"flow\\" water to its neighboring cells (up, down, left, or right) if the neighboring cell\'s height is equal to or less than the current cell\'s height. Determine how many cells in the grid can flow water to both the Pacific Ocean (cells connected to the left or top edge of the grid) and the Atlantic Ocean (cells connected to the right or bottom edge of the grid). Return the list of coordinates (row, column) of all such cells.","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) def dfs(x, y, visited, prev_height): if (x, y) in visited or x < 0 or y < 0 or x >= rows or y >= cols or matrix[x][y] < prev_height: return visited.add((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy, visited, matrix[x][y]) pacific_reachable = set() atlantic_reachable = set() for i in range(rows): dfs(i, 0, pacific_reachable, matrix[i][0]) dfs(i, cols - 1, atlantic_reachable, matrix[i][cols - 1]) for j in range(cols): dfs(0, j, pacific_reachable, matrix[0][j]) dfs(rows - 1, j, atlantic_reachable, matrix[rows - 1][j]) return list(pacific_reachable & atlantic_reachable)"},{"question":"You are given an `m x n` 2D grid initialized with the value `0` (**0 represents water**) and a list of `positions` where positions[i] = [row, col] represents a **land cell** created at [row, col]. Each time addLand is called, a new land cell is created, and if it merges with other lands, it creates an island. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You should return a list of the number of islands after each addLand operation.","solution":"def numIslands2(m, n, positions): Returns a list of the number of islands after each addLand operation on an m x n grid. parent = {} rank = {} def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def add(x, y): if (x, y) in parent: return 0 parent[(x, y)] = (x, y) rank[(x, y)] = 0 island_count = 1 for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]: nx, ny = x + dx, y + dy if (nx, ny) in parent: if find((nx, ny)) != find((x, y)): union((nx, ny), (x, y)) island_count -= 1 return island_count grid = [[0] * n for _ in range(m)] result = [] current_islands = 0 for x, y in positions: current_islands += add(x, y) result.append(current_islands) return result"},{"question":"Given an array of integers `arr`, your task is to partition the array into as many subarrays as possible such that each subarray\'s elements are strictly increasing. Return the maximum number of such partitions. A subarray is a contiguous part of an array. For example, given `arr = [1, 2, 1, 3, 2]`, you can partition it into subarrays `[1, 2]`, `[1, 3]`, `[2]`, and the maximum number of partitions would be `3`.","solution":"def max_increasing_subarrays(arr): Given an array of integers `arr`, partition the array into subarrays such that each subarray\'s elements are strictly increasing. Return the maximum number of such partitions. if not arr: return 0 count = 1 for i in range(1, len(arr)): if arr[i] <= arr[i-1]: count += 1 return count"},{"question":"You are given an array `arr` of `n` integers and an integer `k`, where `k` is a positive integer. A contiguous subarray is defined as a subset of elements from the array that are consecutive. The problem is to find the length of the shortest contiguous subarray whose sum is greater than or equal to `k`. If no such subarray exists, return `-1`.","solution":"def shortest_subarray_with_sum_at_least_k(arr, k): Finds the length of the shortest contiguous subarray whose sum is greater than or equal to k. Returns -1 if no such subarray exists. n = len(arr) min_len = n + 1 # Initialize to a value larger than the possible size of subarray current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= k: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len <= n else -1"},{"question":"You are given a string `s` and an integer `k`. You need to construct `k` non-empty palindromic subsequences (not necessarily distinct) from `s` such that removing these subsequences leaves the string empty. Return _the number of ways_ you can do this. If it\'s not possible, return `0`. A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. A **palindrome** is a string that reads the same forward and backward. Since the output can be very large, return it **modulo** `109 + 7`.","solution":"MOD = 10**9 + 7 def can_construct_palindromic_subsequences(s, k): def is_palindromic(s): return s == s[::-1] # We need at least k palindromic subsequences in a string of length at least k if len(s) < k: return 0 unique_chars = set(s) # We can only create at most as many palindromes as unique characters in the string if len(unique_chars) < k: return 0 # You can always construct k unique palindromic subsequences from string with size at least k # and with at least k unique characters by picking each character k times (one for each subsequence) return 1"},{"question":"Given a string `s`, you need to determine the length of the longest palindrome that can be constructed by reordering the characters of `s`. Note that in constructing the palindrome, each character in the string can appear an even number of times, and at most one character may appear an odd number of times. Return _the length of the longest palindrome that can be constructed from the characters in the string_.","solution":"from collections import Counter def longest_palindrome_length(s): Determines the length of the longest palindrome that can be constructed from the characters of s. Parameters: s (str): Input string Returns: int: The length of longest possible palindrome char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"You are given an array of `n` integers, `arr`, where each integer represents the height of a building. You need to find all the buildings that have a **sunset view**. A building has a sunset view if it\'s not blocked by any taller (or equal height) building to its right. Formally, a building at index `i` (0-based) has a sunset view if there is no building `j` such that `i < j` and `arr[i] <= arr[j]`. Return _a list of the indices of the buildings that have a sunset view, sorted in increasing order_.","solution":"def buildings_with_sunset_view(arr): Returns the indices of the buildings that have a sunset view. A building has a sunset view if it\'s not blocked by any taller or equal height building to its right. :param arr: List of integers representing the heights of buildings :return: List of indices (in increasing order) of buildings with a sunset view n = len(arr) if n == 0: return [] result = [] max_height_from_right = -1 for i in range(n - 1, -1, -1): if arr[i] > max_height_from_right: result.append(i) max_height_from_right = arr[i] return sorted(result)"},{"question":"**[Question 4]**: Suppose you are developing a software containing a list of distinct integers. Your task is to create a function that finds all unique quadruplets `(a, b, c, d)` such that their sum is equal to a given target integer. Specifically, you need to find quadruplets `(a, b, c, d)` that satisfy: - `a + b + c + d == target` You should return the list of all unique quadruplets in any order. Ensure that there are no duplicate quadruplets in the returned list. For example, given the input list nums = [1, 0, -1, 0, -2, 2] and target = 0, the output should be: `[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]` Write a function that efficiently finds all such unique quadruplets given an array of integers and a target sum.","solution":"def four_sum(nums, target): Find all unique quadruplets in the list that sum up to the target value. :param nums: List of distinct integers :param target: Target sum for the quadruplets :return: List of unique quadruplets nums.sort() quadruplets = [] n = len(nums) for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left = j + 1 right = n - 1 while left < right: s = nums[i] + nums[j] + nums[left] + nums[right] if s == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif s < target: left += 1 else: right -= 1 return quadruplets"},{"question":"Given an array of integers `arr` and an integer `m`, return the length of the longest contiguous subarray where the difference between the maximum and minimum values in the subarray is less than or equal to `m`.","solution":"def longest_subarray_with_limit(arr, m): Returns the length of the longest contiguous subarray where the difference between the maximum and minimum values in the subarray is less than or equal to m. from collections import deque if not arr: return 0 max_dq = deque() min_dq = deque() start = 0 max_length = 0 for end in range(len(arr)): while max_dq and arr[max_dq[-1]] <= arr[end]: max_dq.pop() while min_dq and arr[min_dq[-1]] >= arr[end]: min_dq.pop() max_dq.append(end) min_dq.append(end) while arr[max_dq[0]] - arr[min_dq[0]] > m: start += 1 if max_dq[0] < start: max_dq.popleft() if min_dq[0] < start: min_dq.popleft() max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a string `s`, which consists of lowercase English letters. You are also given an integer `k`. You can choose any character in the string and delete it, but each deletion costs you one point. Your goal is to delete some characters from the string to create a string in which no letter appears more than `k` times. Return _the **minimum** number of points required to achieve this goal_.","solution":"from collections import Counter def min_deletions_to_k_repetitions(s, k): Returns the minimum number of deletions required so that no character appears more than k times in the given string. char_count = Counter(s) deletions = 0 for count in char_count.values(): if count > k: deletions += count - k return deletions"},{"question":"You are given a 2D integer matrix `matrix` of size `m x n`. Your task is to count the number of cells that have at least one neighboring cell with a greater value than the current cell. Two cells are considered neighboring if they are adjacent horizontally, vertically, or diagonally. Implement a function that takes an integer matrix as input and returns the count of such cells. For example, given the matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The function should return `8`.","solution":"def count_cells_with_greater_neighbors(matrix): Count the number of cells that have at least one neighboring cell with a greater value. Args: matrix (list of list of int): 2D integer matrix of size m x n. Returns: int: Count of cells with at least one neighboring cell with a greater value. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) count = 0 # Define the 8 possible neighbors for a cell (including diagonal) directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] for i in range(m): for j in range(n): current_value = matrix[i][j] for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > current_value: count += 1 break return count"},{"question":"Implement a file system that can perform the following operations: * **createPath**: Creates a new path in the file system. * **get**: Retrieves the value associated with a given path. Paths are represented as strings that are separated by \'/\' such as \'/a\' and \'/a/b\'. Note that the root path \'/\' is not included in any other paths. Each path must be created sequentially, meaning that to create a path \'/a/b\', path \'/a\' must already exist. Implement the `FileSystem` class: * `FileSystem()` Initializes the object with an empty file system. * `bool createPath(string path, int value)` Creates a new path `path` with a value `value` and returns `true` if the operation is successful. Returns `false` if the parent path does not exist or the path already exists. * `int get(string path)` Returns the value associated with `path`, or `-1` if the path does not exist.","solution":"class FileSystem: def __init__(self): self.paths = {} def createPath(self, path: str, value: int) -> bool: # Ensure the path starts with a \'/\' and is not the only \'/\' if not path or path == \'/\' or path[0] != \'/\': return False # Split the path into parts and find the parent path parts = path.split(\'/\') parent_path = \'/\'.join(parts[:-1]) # Check if parent path exists or this is trying to rewrite an existing path if parent_path and parent_path not in self.paths: return False if path in self.paths: return False # Create the new path self.paths[path] = value return True def get(self, path: str) -> int: return self.paths.get(path, -1)"},{"question":"In a **0-indexed** grid of size `m x n`, a square is called a **1-connected square** if it contains only the value `1` and all adjacent cells (up, down, left, right) are also squares containing only the value `1`. You need to find the maximum side length of a square that is a **1-connected square**. Given an `m x n` integer `grid`, where each cell contains `0` or `1`, return _the side length of the largest **1-connected square**._","solution":"def max_1_connected_square(grid): if not grid: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"You are given a list of integers `nums` where each integer represents a coordinate on a number line. You are also given an integer `k`. A set of `k` points is said to be valid if no two points in the set have a Manhattan distance less than 2 (i.e., the absolute difference between them is at least 2). Return the maximum number of valid points you can select from the list `nums`.","solution":"def max_valid_points(nums, k): Returns the maximum number of valid points from `nums` such that no two points in the set have a Manhattan distance less than 2. Parameters: nums (list of int): List of integers representing coordinates on a number line. k (int): The size of the set to select. Returns: int: The count of maximum number of valid points. # Sort the list of coordinates nums.sort() # Initialize the count of valid points valid_points = [] for num in nums: if not valid_points or abs(num - valid_points[-1]) >= 2: valid_points.append(num) if len(valid_points) == k: break return len(valid_points)"},{"question":"You are given an m x n grid filled with non-negative numbers representing the elevation of various points on a terrain. You need to calculate the total area of water that can be trapped after it rains. Assume the entire edges of the grid are unable to trap any water, as it can escape freely from the edges. Write a function that takes the 2D list of elevations and returns the total trapped water.","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] heap = [] # Push all the cells on the border into the heap for i in range(m): for j in [0, n-1]: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True for j in range(n): for i in [0, m-1]: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: water_trapped += max(0, height - heightMap[nx][ny]) heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) visited[nx][ny] = True return water_trapped"},{"question":"Given a list of integers `numbers` and an integer `target`, find two distinct indices `i` and `j` such that `numbers[i] + numbers[j]` equals `target`. Return the indices as a list `[i, j]`. You may assume that each input would have exactly one solution, and you may not use the same element twice. For example, for the input `numbers = [2, 7, 11, 15]` and `target = 9`, the correct output would be `[0, 1]` as `numbers[0] + numbers[1]` equals `9`.","solution":"def two_sum(numbers, target): Finds two distinct indices such that the sum of the numbers at those indices equals the target. :param numbers: List of integers. :param target: Integer target sum. :return: List containing two indices [i, j]. num_to_index = {} for i, num in enumerate(numbers): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i # Assuming there\'s always a solution as per the problem statement return []"},{"question":"Given an array of integers `arr`, write a function that returns the length of the longest contiguous subarray such that all its elements are distinct. [Question] 4:","solution":"def longest_distinct_subarray(arr): Returns the length of the longest contiguous subarray with all distinct elements. n = len(arr) longest = 0 start = 0 seen = {} for end in range(n): if arr[end] in seen: start = max(start, seen[arr[end]] + 1) seen[arr[end]] = end longest = max(longest, end - start + 1) return longest"},{"question":"You are given an array of integers `arr` and an integer `k`. A subarray is defined as a contiguous portion of the array. Return _the number of **distinct** subarrays of length `k` that have all elements in the subarray in **strictly increasing** order._ If no such subarray exists, return `0`.","solution":"def count_increasing_subarrays(arr, k): Returns the number of distinct subarrays of length k that have all elements in strictly increasing order. Args: arr (list of int): The input array of integers. k (int): The length of the subarray. Returns: int: The number of distinct strictly increasing subarrays of length k. if k > len(arr) or k <= 0: return 0 distinct_subarrays = set() for i in range(len(arr) - k + 1): subarray = arr[i:i+k] if all(subarray[j] < subarray[j+1] for j in range(k-1)): distinct_subarrays.add(tuple(subarray)) return len(distinct_subarrays)"},{"question":"You are given an integer array `arr` of size `n` and a target value `k`. The array is circular, meaning the next element of `arr[n-1]` is `arr[0]`. Your task is to determine if there exists a subarray (of at least one element) whose sum is exactly `k`. Return `true` if such a subarray exists, and `false` otherwise.","solution":"def circular_subarray_sum(arr, k): Determines if there exists a subarray in the circular array whose sum is exactly k. n = len(arr) # Create the extended array extended_arr = arr + arr for start in range(n): current_sum = 0 for end in range(start, start + n): current_sum += extended_arr[end] if current_sum == k: return True return False"},{"question":"Given a list of non-negative integers `stones` where each integer represents the weight of a stone, repeatedly choose the two heaviest stones and smash them together. If both stones have the same weight, both stones are destroyed; otherwise, the heaviest stone is destroyed, and the weight difference is pushed back into the list of stones. Continue this process until a single stone is left or no stones are left. Return _the weight of the last remaining stone_ (or `0` if there are no stones left). ```python def lastStoneWeight(stones): # Your implementation here ``` Example: ```python Input: stones = [2, 7, 4, 1, 8, 1] Output: 1 Explanation: We combine the 7 and 8 to get 1, so the array converts to [2, 4, 1, 1, 1] then, we combine 2 and 4 to get 2, so the array converts to [2, 1, 1, 1] then, we combine 2 and 1 to get 1, so the array converts to [1, 1, 1] then, we combine 1 and 1 to get 0, so the array converts to [1] then, that’s the last stone in the end. ```","solution":"import heapq def lastStoneWeight(stones): Returns the weight of the last remaining stone, or 0 if there are no stones left. # Create a max-heap by pushing negative values of the stones max_heap = [-stone for stone in stones] heapq.heapify(max_heap) while len(max_heap) > 1: first = heapq.heappop(max_heap) # Largest stone second = heapq.heappop(max_heap) # Second largest stone if first != second: # If they are not equal, push the difference back into the heap heapq.heappush(max_heap, first - second) # If there are no stones left, return 0, otherwise return the weight of the last remaining stone return -max_heap[0] if max_heap else 0"},{"question":"Given an integer array `prices` where `prices[i]` is the price of a given commodity on the `i-th` day, and an integer `k` representing the maximum number of transactions you can make, determine the maximum profit you can achieve. You can only hold one unit of the commodity at a time, and you must sell the commodity before you buy it again. Return _the maximum profit achievable with at most_ `k` _transactions_.","solution":"def maxProfit(k, prices): Calculates the maximum profit with at most k transactions. Parameters: k (int): Maximum number of transactions. prices (List[int]): List of commodity prices on each day. Returns: int: The maximum profit achievable. # If there are no prices or k is zero, the maximum profit is zero. if not prices or k == 0: return 0 n = len(prices) # If k >= n // 2, it means we can perform unlimited transactions. if k >= n // 2: return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1)) # DP table profits = [[0] * n for _ in range(k + 1)] for t in range(1, k + 1): max_curr = -prices[0] for d in range(1, n): profits[t][d] = max(profits[t][d - 1], prices[d] + max_curr) max_curr = max(max_curr, profits[t - 1][d] - prices[d]) return profits[k][n - 1]"},{"question":"You are given a **0-indexed** integer array `arr` of length `n` where all the integers lie between `1` and `n` (inclusive). Each integer in the array appears exactly once except for one integer which is replaced by another integer that already appears in the array (causing that integer to appear exactly twice). Return _the missing integer and the duplicated integer_ as a tuple.","solution":"def find_missing_and_duplicate(arr): Returns the missing integer and the duplicated integer as a tuple. :param arr: list of integers :return: tuple (missing, duplicate) n = len(arr) total_sum = n * (n + 1) // 2 sum_of_arr = sum(arr) sum_of_squares = sum(x*x for x in arr) expected_sum_of_squares = sum(x*x for x in range(1, n + 1)) diff = total_sum - sum_of_arr # missing - duplicate square_diff = expected_sum_of_squares - sum_of_squares # missing^2 - duplicate^2 # missing + duplicate = square_diff / diff sum_of_numbers = square_diff // diff missing = (diff + sum_of_numbers) // 2 duplicate = sum_of_numbers - missing return (missing, duplicate)"},{"question":"You are given an array of `n` integers `heights` representing the heights of a collection of candles. A candle can be extinguished if there is a taller candle to its right that can block the view of the wind. Determine the _number of candles that cannot be extinguished._ A candle is considered to be not extinguished if there is no taller candle to its right in the array. Return the _number of such candles_ that cannot be extinguished.","solution":"def count_non_extinguished_candles(heights): Returns the number of candles that cannot be extinguished. :param list heights: List of integer heights of the candles. :return int: The count of candles that cannot be extinguished. n = len(heights) if n == 0: return 0 # Initialize the count and the maximum height from the right non_extinguished_count = 1 max_height_from_right = heights[-1] # Traverse the list from the second last element to the first for i in range(n - 2, -1, -1): if heights[i] > max_height_from_right: non_extinguished_count += 1 max_height_from_right = heights[i] return non_extinguished_count"},{"question":"Given a string `s` consisting of lowercase English letters, you need to compute the number of distinct substrings (subsequences are not considered) of `s`. For example, if `s = \\"abab\\"`, the distinct substrings are `\\"a\\"`, `\\"b\\"`, `\\"ab\\"`, `\\"ba\\"`, `\\"aba\\"`, and `\\"bab\\"`, so the output should be `6`. Write a function that returns the number of distinct substrings in the string `s`.","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings of the input string s. substrings = set() n = len(s) for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"You are given a string `s` that represents a sentence containing words separated by exactly one space. Each word consists of lowercase English letters only. Your task is to move the first character of each word to the end of the word and then add \\"ay\\" to the end of the word. Return a single string representing the transformed sentence. For example: - If `s` is \\"hello world\\", then the transformed sentence is \\"ellohay orldway\\". Create a function that accepts the string `s` and returns the transformed string.","solution":"def transform_sentence(s): Transform the input sentence by moving the first character of each word to the end, and then adding \\"ay\\" to the end of the word. :param s: The input sentence as a string :return: The transformed sentence as a string words = s.split() transformed_words = [word[1:] + word[0] + \\"ay\\" for word in words] return \\" \\".join(transformed_words)"},{"question":"You are given two integer arrays `nums` and `index` of the same length `n`. Your task is to create a new array `target` of length `n` following these rules: for each `i` (0 <= i < n), insert the value `nums[i]` at index `index[i]` in `target`. If a value is inserted at an index that already contains another value, shift the existing value and all subsequent values to the right. Return the array `target` after processing all the elements of `nums` according to the given rules.","solution":"def create_target_array(nums, index): Create a target array following the specified rules. Parameters: - nums: List[int], the list of integers to be placed into target - index: List[int], the list of indices where the corresponding nums elements should be placed Returns: - List[int]: the resulting target array target = [] for i in range(len(nums)): target.insert(index[i], nums[i]) return target"},{"question":"Given a list of integers `arr`, return the length of the longest subarray that contains only odd numbers. For example, given the array `[1, 3, 2, 5, 7, 8, 9]`, the longest subarray of odd numbers would be `[5, 7]`, so the function should return `2`.","solution":"def longest_odd_subarray(arr): Returns the length of the longest subarray that contains only odd numbers. max_len = 0 current_len = 0 for num in arr: if num % 2 != 0: # Check if the number is odd current_len += 1 max_len = max(max_len, current_len) else: current_len = 0 # Reset for even number return max_len"},{"question":"Given a non-empty array of integers `nums`, write a function that returns the k most frequent elements. Implement the `Solution` class: * `Solution(vector<int> &nums, int k)` initializes the object with the array `nums` and integer `k`. * `vector<int> topKFrequent()` returns a list of the k most frequent elements in `nums`. You must solve it in `O(n log n)` time complexity or better.","solution":"import heapq from collections import Counter class Solution: def __init__(self, nums, k): self.nums = nums self.k = k def topKFrequent(self): Returns the k most frequent elements in the nums array. count = Counter(self.nums) return [item for item, frequency in heapq.nlargest(self.k, count.items(), key=lambda x: x[1])]"},{"question":"You are given a list of `n` integers `nums` which could contain both positive and negative numbers. You need to determine if there exists a subarray whose sum is equal to zero. A subarray is any contiguous part of the array. Return `true` if such a subarray exists, otherwise return `false`.","solution":"def subarray_sum_zero_exists(nums): This function checks if there is any subarray with sum equal to zero. :param nums: List of integers (both positive and negative) :return: Boolean value indicating if there is a subarray with sum zero sum_set = set() curr_sum = 0 for num in nums: curr_sum += num if curr_sum == 0 or curr_sum in sum_set: return True sum_set.add(curr_sum) return False"},{"question":"You are given an integer array `arr` consisting of positive numbers. You can perform the following operation any number of times: * Choose any two adjacent elements in the array. * Decrease the larger element by 1 or increase the smaller element by 1. Return _the minimum number of operations required to make all elements in the array equal_.","solution":"def min_operations_to_make_equal(arr): Returns the minimum number of operations required to make all elements in the array equal. Parameters: arr (List[int]): List of positive integers Returns: int: Minimum number of operations required. # For all the elements to be the same, they have to be equal to the median of the array. median = sorted(arr)[len(arr) // 2] # Calculate the number of operations operations = sum(abs(x - median) for x in arr) return operations"},{"question":"You are given a `k x k` grid consisting of lowercase letters and an integer `n`. Your task is to find the longest path such that no letter repeats in any path. A path may start and end at any cell, but each step must be to an adjacent cell (including diagonals). Return the length of the longest path. If there is no valid path, return `0`.","solution":"def longest_unique_path(grid, k, n): def is_valid(x, y): return 0 <= x < k and 0 <= y < k def dfs(x, y, visited): max_path_length = 0 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]: nx, ny = x + dx, y + dy if is_valid(nx, ny) and grid[nx][ny] not in visited: visited.add(grid[nx][ny]) max_path_length = max(max_path_length, dfs(nx, ny, visited) + 1) visited.remove(grid[nx][ny]) return max_path_length max_length = 0 for i in range(k): for j in range(k): max_length = max(max_length, dfs(i, j, set([grid[i][j]])) + 1) return max_length"},{"question":"You are given two strings `word1` and `word2`. Consider a string that is the interleaving of `word1` and `word2` which preserves the order of characters in both strings. Implement an algorithm to find the length of the shortest possible superstring that contains both `word1` and `word2` as subsequences. The superstring may include extra characters as long as both `word1` and `word2` can be found within it as subsequences. Implement the function `int shortestSuperstring(String word1, String word2)` that returns the length of the shortest possible superstring.","solution":"def shortestSuperstring(word1, word2): Finds the length of the shortest possible superstring that contains both word1 and word2 as subsequences. m, n = len(word1), len(word2) # Create a 2D DP table dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = i + j elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1 return dp[m][n]"},{"question":"You are given a collection of `n` strings `words`. A string `s` is formed by concatenating a **subsequence** of the `words` array. A **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. A string `s` is said to be **universal** if for every word in the `words` array, at least one of the characters of the word appears in `s`. Return the _length of the smallest possible universal string `s` that can be formed from the given `words` array_. If no universal string can be formed, return `-1`. For example, given the words `[\\"abc\\", \\"def\\", \\"ghi\\"]`, a possible universal string could be `\\"adg\\"`, which contains one character from each of the words, and the length of this string is `3`.","solution":"def smallest_universal_string_length(words): Returns the length of the smallest universal string `s` that can be formed from the given `words` array. if not words: return -1 # Consider the set of characters from all words. char_set = set() for word in words: char_set = char_set.union(set(word)) # Length of the universal string will be equal to the number of distinct characters return len(char_set)"},{"question":"You are given a **0-indexed** 2D integer array `intervals` where `intervals[i] = [starti, endi]` represents the **inclusive** interval `[starti...endi]`. You are also given another **0-indexed** integer array `queries` where each `queries[j]` represents a single query to determine if it lies within any of the given intervals. Return _an integer array_ `answer` _where_ `answer[j] = 1` _if_ `queries[j]` _lies within at least one interval, and_ `answer[j] = 0` _otherwise_.","solution":"def find_queries_in_intervals(intervals, queries): Determines if each query lies within any of the given intervals. Parameters: intervals (list of lists of int): A 2D integer array where intervals[i] = [starti, endi] represents the inclusive interval [starti...endi]. queries (list of int): A list of queries to determine if they lie within any of the given intervals. Returns: list of int: An integer array where answer[j] = 1 if queries[j] lies within at least one interval, and answer[j] = 0 otherwise. answers = [] for query in queries: found = 0 for start, end in intervals: if start <= query <= end: found = 1 break answers.append(found) return answers"},{"question":"You are given an array of integers `nums` representing the numerical values of the cards in a deck. Two players take turns taking one card from either end of the deck until all cards have been taken. The player whose collected card values have the highest sum wins. Assume that both players play optimally. Return `true` if the first player is guaranteed to win, otherwise return `false`. In summary, given the array `nums`, determine if the first player will win when both players make the best possible moves.","solution":"def first_player_wins(nums): n = len(nums) # dp[i][j] will be the maximum score difference for the current player from subarray nums[i:j+1] dp = [[0] * n for _ in range(n)] # For a subarray of length 1, the max difference is the value of the single element for i in range(n): dp[i][i] = nums[i] # Fill the dp table for length in range(2, n + 1): # subarray lengths from 2 to n for i in range(n - length + 1): j = i + length - 1 dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]) # The first player wins if the score difference is greater than or equal to 0 return dp[0][n - 1] >= 0"},{"question":"You are given a binary tree where each node can have an arbitrary number of children, but nodes are guaranteed to have a value of either `0` or `1`. Write a function to prune the tree such that subtrees that are all zeros (i.e., all their nodes have the value `0`) are removed. Your function should return the pruned tree.","solution":"class TreeNode: def __init__(self, x, children=None): self.val = x self.children = children if children is not None else [] def prune_tree(node): Prunes the tree such that subtrees that are all zeroes are removed. if node is None: return None # Prune children first pruned_children = [] for child in node.children: pruned_child = prune_tree(child) if pruned_child is not None: pruned_children.append(pruned_child) node.children = pruned_children # Determine if current node should be pruned if node.val == 0 and not node.children: return None return node"},{"question":"You are given a list of integers `nums` and an integer `k`. Your task is to rearrange the elements of `nums` such that the difference between the maximum number and the minimum number in each contiguous subarray of length `k` is minimized. If it is impossible to rearrange the elements to achieve the desired condition, return `-1`. Otherwise, return the rearranged list. Ensure that the order of the integers in the given subarray of length `k` (after rearrangement) remains contiguous in the original list. The list should be returned in any valid order that meets the condition. For example: - Given `nums = [1, 5, 6, 2, 8]` and `k = 3`, one possible return value is `[1, 2, 5, 6, 8]`. - Given `nums = [10, 1, 2, 7]` and `k = 2`, one possible return value is `[1, 2, 7, 10]`.","solution":"def rearrange(nums, k): Rearranges the elements of nums such that the difference between the maximum and minimum number in each contiguous subarray of length k is minimized. Parameters: nums (list): A list of integers k (int): Length of the subarray Returns: list: Rearranged list of integers or -1 if not possible if not nums or k > len(nums): return -1 nums.sort() return nums"},{"question":"Given an array of integers `arr` and an integer `length`, your task is to determine if it\'s possible to partition the array into `length` contiguous subarrays such that each subarray has an equal sum. If it is possible, return `true`; otherwise, return `false`. Each subarray must have at least one element.","solution":"def can_partition_into_equal_subarrays(arr, length): Determine if it\'s possible to partition the array into `length` contiguous subarrays such that each subarray has an equal sum. total_sum = sum(arr) # If total_sum is not divisible by length, we can\'t partition the array if total_sum % length != 0: return False target_sum = total_sum // length current_sum = 0 count_subarrays = 0 for num in arr: current_sum += num if current_sum == target_sum: count_subarrays += 1 current_sum = 0 # Check if we have found exactly \'length\' subarrays return count_subarrays == length"},{"question":"Implement a stack that supports the following operations in constant time O(1): * `push(int x)` -- Push element `x` onto the stack. * `pop()` -- Removes the element on top of the stack. * `top()` -- Get the top element of the stack. * `getMin()` -- Retrieve the minimum element in the stack. You must implement a class `MinStack` that achieves these functionalities. Each method should perform their respective actions optimally in constant time. **Example:** ```python minStack = MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --> Returns -3. minStack.pop(); minStack.top(); --> Returns 0. minStack.getMin(); --> Returns -2. ``` **Note:** * `pop`, `top` and `getMin` methods should not retrieve or return `None` values. Ensure appropriate handling of stack operations and maintain the integrity of the stack.","solution":"class MinStack: def __init__(self): Initialize your data structure here. self.stack = [] self.min_stack = [] def push(self, x: int) -> None: Push element x onto stack. self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: Removes the element on top of the stack. if self.stack: top = self.stack.pop() if top == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: Get the top element. if self.stack: return self.stack[-1] def getMin(self) -> int: Retrieve the minimum element in the stack. if self.min_stack: return self.min_stack[-1]"},{"question":"You are managing \'n\' server requests represented in an array `requests` where `requests[i] = [start, end]` indicates that a particular request needs to be processed from `start` to `end` time (inclusive). Each server can handle only one request at a time. Write a function to return the total number of requests that can be processed by the server. Note that once a server starts processing a request, it must complete without interruption before starting another.","solution":"def max_requests(requests): Determines the maximum number of non-overlapping requests that can be processed by a single server. Args: requests (List[List[int]]): A list of requests where each request is represented as [start, end]. Returns: int: The maximum number of non-overlapping requests that can be handled. # Sort the requests by their end time requests.sort(key=lambda x: x[1]) # Initialize variables to keep track of the number of processed requests and the end time of the last processed request processed_requests = 0 last_end_time = -1 # Iterate through the sorted requests for start, end in requests: # If the start time of the current request is greater than the end time of the last processed request if start > last_end_time: # Process this request processed_requests += 1 # Update the end time of the last processed request last_end_time = end return processed_requests"},{"question":"You are given a string consisting of lowercase English letters. You need to find and return the length of the longest substring that contains at most two distinct characters. If the string is empty, return 0.","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. if not s: return 0 left, right = 0, 0 max_length = 0 char_map = {} while right < len(s): char_map[s[right]] = right if len(char_map) > 2: min_index = min(char_map.values()) del char_map[s[min_index]] left = min_index + 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"You are given a string `s` and an array of strings `words`. Your task is to determine how many strings in `words` are subsequences of `s`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Implement the function `int numMatchingSubseq(String s, String[] words)` that returns the count of words in `words` which are subsequences of `s`.","solution":"def num_matching_subseq(s, words): Returns the number of words that are subsequences of the string `s`. def is_subsequence(x, y): it = iter(y) return all(c in it for c in x) count = 0 for word in words: if is_subsequence(word, s): count += 1 return count"},{"question":"You are given an integer array `arr` representing the initial state of a sequence of numbers. You can perform at most one swap operation on the sequence: choose any two elements and swap them. Return the maximum possible value of the sequence you can achieve using at most one swap operation. Note that the sequence is evaluated as the concatenation of its elements (i.e., joining all elements as strings) to form a single number.","solution":"def max_value_with_one_swap(arr): Returns the maximum possible value of the sequence by performing at most one swap operation. The sequence is evaluated as the concatenation of its elements to form a single number. n = len(arr) # Convert array elements to strings for easier concatenation arr_str = [str(x) for x in arr] # Early return if array length is less than 2 if n < 2: return int(\'\'.join(arr_str)) best_arr = arr_str.copy() max_num = int(\'\'.join(arr_str)) for i in range(n): for j in range(i + 1, n): # Swap elements at indices i and j arr_str[i], arr_str[j] = arr_str[j], arr_str[i] current_num = int(\'\'.join(arr_str)) if current_num > max_num: max_num = current_num best_arr = arr_str.copy() # Swap them back to try next pair arr_str[i], arr_str[j] = arr_str[j], arr_str[i] return max_num"},{"question":"You are given a string `s` consisting of only characters `a`, `b`, and `c`. In one operation, you can choose any substring of `s` and sort it in non-decreasing order. Return _the minimum number of operations required to sort the entire string `s` in non-decreasing order_. For example: * `s = \\"cba\\"` should return `2` because sorting the entire string in one go would take one operation, and another operation is needed to sort \\"cbc\\" into \\"abc\\". * `s = \\"abc\\"` should return `0` because the string is already sorted.","solution":"def min_operations_to_sort_string(s): Returns the minimum number of operations required to sort the entire string `s` in non-decreasing order. def count_inversions(s): Helper function to count inversions in the string. inv_count = 0 n = len(s) for i in range(n): for j in range(i + 1, n): if s[i] > s[j]: inv_count += 1 return inv_count # If the string is already sorted, no operations are needed if s == \\"\\".join(sorted(s)): return 0 # Otherwise, the number of operations is equal to the number of inversions return count_inversions(s)"},{"question":"You are given a list of integers `nums` and an integer `k`. Write a function that retrieves the `k` most frequent elements from the list. Return the result in any order. **Note**: Your solution should have linear time complexity, assuming `k` is much smaller than the number of unique elements in `nums`.","solution":"from typing import List import heapq from collections import Counter def top_k_frequent(nums: List[int], k: int) -> List[int]: Retrieves the k most frequent elements from the list nums. Args: nums (List[int]): List of integers. k (int): Number of top frequent elements to return. Returns: List[int]: List of k most frequent elements. if not nums or k <= 0: return [] # Count frequencies of each element in nums frequency = Counter(nums) # Use a heap to find the k most frequent elements heap = heapq.nlargest(k, frequency.keys(), key=frequency.get) return heap"},{"question":"Given an array of integers `nums`, find the maximum length of a subarray where the absolute difference between any two elements is less than or equal to `limit`. You are required to solve the problem using a sliding window approach to achieve an efficient solution. The function signature should be: ```python def longest_subarray(nums: List[int], limit: int) -> int: ``` Implement the function and return _the length of the longest such subarray_.","solution":"from collections import deque from typing import List def longest_subarray(nums: List[int], limit: int) -> int: min_deque = deque() max_deque = deque() left = 0 max_len = 0 for right in range(len(nums)): while min_deque and nums[min_deque[-1]] >= nums[right]: min_deque.pop() while max_deque and nums[max_deque[-1]] <= nums[right]: max_deque.pop() min_deque.append(right) max_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > limit: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a rectangular grid of size `m x n`, where each cell in the grid is either empty (represented by `0`) or blocked by an obstacle (represented by `1`). You need to determine if there is a path from the top-left corner of the grid (i.e., position `(0,0)`) to the bottom-right corner (i.e., position `(m-1,n-1)`). You can move **up**, **down**, **left**, or **right**, but you cannot move through any cells that contain an obstacle. Return _a boolean indicating whether such a path exists in the grid_.","solution":"def is_path(m, n, grid): from collections import deque if grid[0][0] == 1 or grid[m-1][n-1] == 1: return False directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False]*n for _ in range(m)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == m-1 and y == n-1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0: queue.append((nx, ny)) visited[nx][ny] = True return False"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of `n` skyscrapers in a city skyline. The array `heights` has `n` elements where `heights[i]` is the height of the `ith` skyscraper. You need to compute the **sunset view** for each skyscraper. A skyscraper has a sunset view if there are no taller skyscrapers to its right. Return _an array_ `result` _of length_ `n` _where_ `result[i]` _is a boolean indicating whether the_ `i`th _skyscraper has a sunset view._","solution":"def sunset_views(heights): Determine whether each skyscraper has a sunset view. Parameters: heights (list): A 0-indexed list of integers representing skyscraper heights. Returns: list: A list of booleans indicating whether each skyscraper has a sunset view. n = len(heights) result = [False] * n max_height = float(\'-inf\') for i in range(n-1, -1, -1): if heights[i] > max_height: result[i] = True max_height = heights[i] return result"},{"question":"A company\'s payroll system stores information about employees in an array of records, where each record is a tuple (employeeId, salary). The company wants to understand the salaries of its employees better and perform certain operations on this data. Implement the `EmployeePayroll` class: * `EmployeePayroll(Tuple<int, int>[] records)` Initializes the class with an array of employee records. * `int getTotalPayroll()` Returns the total sum of all salaries in the payroll. * `float getAverageSalary()` Returns the average salary of all employees rounded to two decimal places. * `Tuple<int, int> getHighestSalary()` Returns the record of the employee with the highest salary. If there are multiple employees with the highest salary, return any one of them.","solution":"from typing import List, Tuple class EmployeePayroll: def __init__(self, records: List[Tuple[int, int]]): self.records = records def getTotalPayroll(self) -> int: return sum(salary for _, salary in self.records) def getAverageSalary(self) -> float: total_salary = self.getTotalPayroll() return round(total_salary / len(self.records), 2) def getHighestSalary(self) -> Tuple[int, int]: return max(self.records, key=lambda record: record[1])"},{"question":"You are given two strings `word1` and `word2`. You want to concatenate the two strings in such a way that the resulting string contains `word1` as a substring, `word2` as a substring, and the length of the resulting string is minimized. Return the resulting string. If there are multiple answers, return any of them.","solution":"def concatenate_strings(word1, word2): Concatenates two strings word1 and word2 in such a way that the resulting string contains both as substrings and the length is minimized. def find_overlap(w1, w2): max_overlap = 0 for i in range(1, min(len(w1), len(w2)) + 1): if w1[-i:] == w2[:i]: max_overlap = i return max_overlap overlap1 = find_overlap(word1, word2) overlap2 = find_overlap(word2, word1) result1 = word1 + word2[overlap1:] result2 = word2 + word1[overlap2:] return min(result1, result2, key=len)"},{"question":"An island in the middle of a river has been explored, and a few treasures have been found and labeled with decreasing positive integers. The treasures are distributed in a 2D grid, where the rows and columns are full of zeros except at certain locations where treasures are buried. You are given a 2D grid `grid` of size `m x n` where `grid[i][j]` is `0` if there is no treasure at that location or a positive integer with the treasure\'s value otherwise. Your task is to return the maximum number of treasures you can collect in a single sequence of steps that only moves right (`R`) or down (`D`) starting from the top-left corner `(0,0)` and ending at the bottom-right corner `(m-1,n-1)`. Note that you cannot revisit a cell, and each step must move to an adjacent cell.","solution":"def max_treasures(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"You are given a string `s` consisting only of characters \'a\', \'b\', and \'c\'. You can perform one operation on this string: choose any index `i` and delete the character at that index. Your goal is to determine the **minimum** number of operations required to make the string a \\"perfect\\" string. A \\"perfect\\" string is defined as a string in which no two adjacent characters are the same. Return the minimum number of operations required to make `s` a \\"perfect\\" string.","solution":"def min_operations_to_perfect(s): Returns the minimum number of operations required to make the string \\"perfect\\". A \\"perfect\\" string is defined as a string in which no two adjacent characters are the same. if not s: return 0 # Count the number of adjacent repeated characters operations = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: operations += 1 return operations"},{"question":"You are given a string `s` containing only lowercase letters and an integer `n`. Your task is to determine the number of distinct substrings of length `n` that appear more than once in the string `s`. Return _the number of such substrings_.","solution":"def count_repeated_substrings(s, n): Returns the count of distinct substrings of length n that appear more than once in the string s. if n > len(s): return 0 substring_count = {} for i in range(len(s) - n + 1): substring = s[i:i+n] if substring in substring_count: substring_count[substring] += 1 else: substring_count[substring] = 1 repeated_substrings_count = 0 for count in substring_count.values(): if count > 1: repeated_substrings_count += 1 return repeated_substrings_count"},{"question":"Given an array of integers `arr`, we define the \\"teetering point\\" of the array as an index `i` such that the sum of the elements to the left of `i` equals the sum of the elements to the right of `i`. If such an index does not exist, return -1. The array may contain both positive and negative integers. Your task is to find this \\"teetering point\\" and return the index `i`. For example, for the array `[1, 7, 3, 6, 5, 6]`, the teetering point is at index `3` because the sum of elements to the left `[1, 7, 3]` equals the sum of elements to the right `[5, 6]`. If the array is `[1, 2, 3]`, since no teetering point exists, you would return `-1`. Given an integer array `arr`, return the index of the \\"teetering point\\" or `-1` if no such index exists.","solution":"def find_teetering_point(arr): Returns the index of the teetering point of the array, or -1 if no such index exists. total_sum = sum(arr) left_sum = 0 for i, num in enumerate(arr): if left_sum == (total_sum - left_sum - num): return i left_sum += num return -1"},{"question":"You are given a string `s` representing a mathematical expression containing only non-negative integers and the operators `+`, `-`, `*`, and `/` (without any spaces). The expression should be evaluated following the standard operator precedence rules (multiplication and division have higher precedence than addition and subtraction). Return the integer result of the expression. For example, given the string \\"3+2*2\\", your function should return `7` because 2 and 2 are multiplied first to get 4, and then 3 is added to 4, resulting in 7.","solution":"def evaluate_expression(s): Evaluate a mathematical expression string containing only non-negative integers and the operators +, -, *, and / without any spaces. def helper(s, index): stack = [] num = 0 sign = \\"+\\" # initialize sign as \'+\' to handle the first number correctly while index < len(s): char = s[index] if char.isdigit(): num = num * 10 + int(char) if char in \\"+-*/\\" or index == len(s) - 1: if sign == \\"+\\": stack.append(num) elif sign == \\"-\\": stack.append(-num) elif sign == \\"*\\": stack[-1] *= num elif sign == \\"/\\": stack[-1] = int(stack[-1] / num) sign = char num = 0 index += 1 return sum(stack), index result, _ = helper(s, 0) return result"},{"question":"You are given a 2D grid of characters, where each character represents a part of a landscape. The grid has dimensions `m x n`, and each cell can be one of `\'L\'`, `\'W\'`, or `\'F\'` representing land, water, or forest, respectively. You can travel up, down, left, or right between adjacent cells in the grid that share the same type of landscape. Return the number of distinct regions in the grid. A region is a connected component of cells that share the same character.","solution":"def numDistinctRegions(grid): if not grid: return 0 m, n = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] def dfs(x, y, char): stack = [(x, y)] while stack: cx, cy = stack.pop() if 0 <= cx < m and 0 <= cy < n and grid[cx][cy] == char: grid[cx][cy] = \'#\' for dx, dy in directions: stack.append((cx+dx, cy+dy)) regions = 0 for i in range(m): for j in range(n): if grid[i][j] != \'#\': regions += 1 dfs(i, j, grid[i][j]) return regions"},{"question":"You are given two non-negative integers `num1` and `num2` represented as strings. The strings contain digits only and have no leading zeros. Write a function to multiply the two numbers and return the product as a string. * For example, if `num1 = \\"123\\"` and `num2 = \\"456\\"`, the function should return `\\"56088\\"`.","solution":"def multiply_strings(num1, num2): Multiplies two non-negative integers represented as strings and returns the product as a string. if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" m, n = len(num1), len(num2) result = [0] * (m + n) for i in range(m - 1, -1, -1): for j in range(n - 1, -1, -1): product = int(num1[i]) * int(num2[j]) p1, p2 = i + j, i + j + 1 sum = product + result[p2] result[p2] = sum % 10 result[p1] += sum // 10 while result[0] == 0: result.pop(0) return \'\'.join(map(str, result))"},{"question":"Given a list of integers `nums` and an integer `target`, return _any two distinct indices_ `(i, j)` in the list such that `nums[i] + nums[j] == target`. If such indices do not exist, return an empty list.","solution":"def two_sum(nums, target): Returns indices of the two numbers that add up to the target. If no such pair exists, returns an empty list. Args: nums (list of int): List of integers. target (int): Target sum. Returns: list of int: a list containing two distinct indices. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"You are given a list of integers `arr` and an integer `d`. In one **move**, you can increment or decrement an element of `arr` by 1. You need to make all elements of `arr` the same, with the constraint that the difference between any two elements in the resulting array does not exceed `d`. Return the minimum number of **moves** needed to achieve this. If it is not possible to make all elements equal under the given constraint, return `-1`.","solution":"def min_moves_to_equal_elements(arr, d): Returns the minimum number of moves to make all elements in the list \'arr\' equal, with the constraint that the difference between any two elements does not exceed \'d\'. If it is not possible, returns -1. if not arr: return 0 # Check if the difference between any two elements exceeds d if max(arr) - min(arr) > d: return -1 median = sorted(arr)[len(arr) // 2] moves = sum(abs(x - median) for x in arr) return moves"},{"question":"You are given an array of integers `nums` representing the number of steps on a ladder. If each step is exactly `1` unit above the previous step, and you can either jump `k` units or move `1` unit at a time, determine the **minimum number of jumps or moves** required to reach the top of the ladder. Return the _minimum number of moves or jumps_ required to reach the top.","solution":"def min_steps(nums, k): Returns the minimum number of moves or jumps required to reach the top of the ladder. Parameters: nums (List[int]): List of integers representing steps on a ladder. k (int): Maximum units one can jump. Returns: int: Minimum number of moves or jumps required to reach the top. n = len(nums) if n == 0: return 0 # Initialize a list to store the minimum steps needed to reach each step. min_steps_to_reach = [float(\'inf\')] * n min_steps_to_reach[0] = 0 # Starting point needs 0 steps for i in range(1, n): for j in range(1, k + 1): if i - j >= 0: min_steps_to_reach[i] = min(min_steps_to_reach[i], min_steps_to_reach[i - j] + 1) return min_steps_to_reach[-1]"},{"question":"Given a string `s` consisting only of uppercase and lowercase English letters, you need to rearrange the characters of the string in such a way that no two adjacent characters are the same. If it is not possible to transform the string in this way, return an empty string. Otherwise, return the rearranged string.","solution":"import heapq from collections import Counter def reorganize_string(s): Rearranges the string s such that no two adjacent characters are the same. If not possible, returns an empty string. # Create a counter for the characters counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, \'\' result = [] while max_heap: freq, char = heapq.heappop(max_heap) # Append the current character to the result result.append(char) # If prev_freq is less than 0, push it back to the heap if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update the previous character and frequency for the next iteration prev_freq, prev_char = freq + 1, char result_str = \'\'.join(result) if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"You are given a string `s` and an array of integers `indices` of the same length. The string `s` and the array `indices` represent the characters of a scattered string where each character `s[i]` should occupy the position `indices[i]` in a rearranged string. Return _the rearranged string_.","solution":"def restore_string(s, indices): Restores the scattered string `s` by placing each character `s[i]` at the position defined by `indices[i]`. Parameters: s (str): The scattered string to be restored. indices (List[int]): Positions of characters in the rearranged string. Returns: str: The rearranged string. # Create a list for the rearranged string with the same length as the input string rearranged = [\'\'] * len(s) # Place each character in its respective position for char, index in zip(s, indices): rearranged[index] = char # Join the list into a string and return it return \'\'.join(rearranged)"},{"question":"You are given an `m x n` integer matrix `matrix` with the following two properties: - Each row is sorted in non-decreasing order. - The first integer of each row is greater than the last integer of the previous row. Write a function that, given a target integer `target`, returns _`true` if target is in `matrix`, or `false` otherwise_. The function should strive for an efficient solution.","solution":"def search_matrix(matrix, target): Given a target integer, return true if target is in matrix, or false otherwise. Args: matrix: List[List[int]] target : int Returns: bool if not matrix or not matrix[0]: return False m, n = len(matrix), len(matrix[0]) # Start with an imaginary row array constructed by combining all rows left, right = 0, m * n - 1 while left <= right: mid = (left + right) // 2 mid_value = matrix[mid // n][mid % n] if mid_value == target: return True elif mid_value < target: left = mid + 1 else: right = mid - 1 return False"},{"question":"You are given a string `s` containing only lowercase English letters. You need to create another string `t` by removing characters from `s` such that each character in `t` appears an even number of times. You can remove any number of characters (including none). Return `true` _if it is possible to create such a string_ `t`, or_ `false` _otherwise_.","solution":"def can_form_even_char_str(s): Returns True if it is possible to form a string with each character appearing an even number of times by removing characters from the input string s. Otherwise, returns False. from collections import Counter counter = Counter(s) for count in counter.values(): if count % 2 != 0: return False return True"},{"question":"You are given a string `s` containing only digits. By moving from a digit at position `i` to the digit at position `i+1`, the allowed movement cost is the absolute difference between the digit at those positions. However, you are allowed to jump between any two positions in the string at no cost. Your task is to find the minimum cost to move from the first digit to the last digit of the string. Return _the minimum movement cost_.","solution":"def min_movement_cost(s): Returns the minimum movement cost to move from the first digit to the last digit of the string. Parameters: s (str): A string containing only digits. Returns: int: The minimum movement cost. # The cost of moving can always be considered 0 because we are allowed to jump directly # from any position to any other position at no cost. Therefore, the minimum cost # from beginning to the end will always be 0. return 0"},{"question":"You are given a binary tree with `n` nodes where each node has a value. You need to find the **maximum** sum of node values in any **root-to-leaf** path in the tree. Return the value of this maximum sum. Provide the class definition and a function which returns an integer representing the maximum sum. The binary tree is represented by the `TreeNode` class where each node has an integer value (`val`), a left child (`left`), and a right child (`right`).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_sum_root_to_leaf(root): Returns the maximum sum of node values in any root-to-leaf path in the binary tree. if not root: return 0 left_sum = max_sum_root_to_leaf(root.left) right_sum = max_sum_root_to_leaf(root.right) return root.val + max(left_sum, right_sum)"},{"question":"You are given a list of strings `words` where each word consists of lowercase English letters. Your task is to group the anagrams together. An anagram is a word formed by rearranging the letters of another word. Return a list of lists, where each sublist contains all the anagrams from the input list. Each sublist should be a list of anagrams sorted in lexicographical order. The entire list should be sorted based on the first word of each sublist in lexicographical order. Example: Input: `words = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]` Output: `[[\\"ate\\", \\"eat\\", \\"tea\\"], [\\"bat\\"], [\\"nat\\", \\"tan\\"]]`","solution":"from collections import defaultdict def group_anagrams(words): Groups anagrams together from the given list of words. Parameters: words (list of str): A list containing words consisting of lowercase English letters. Returns: list of lists: A list of lists, where each sublist contains all anagrams from the input list, sorted in lexicographical order. The entire list is sorted based on the first word of each sublist. anagrams = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) result = [sorted(group) for group in anagrams.values()] result.sort(key=lambda x: x[0]) return result"},{"question":"Given an integer array `nums` and an integer `x`, you need to find a subarray of `nums` whose sum equals `x`. Return the _length of the smallest such subarray_. If no such subarray exists, return `-1`.","solution":"def min_subarray_len(nums, x): Returns the length of the smallest subarray whose sum equals x. If no such subarray exists, return -1. n = len(nums) if n == 0: return -1 left, sum = 0, 0 min_length = float(\'inf\') for right in range(n): sum += nums[right] while sum >= x: if sum == x: min_length = min(min_length, right - left + 1) sum -= nums[left] left += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"Given a string `s` and a string `t`, you need to find the **minimum window** in `s` which will contain all the characters in `t` (including duplicates). If there is no such window in `s` that covers all characters in `t`, return the empty string `\\"\\"`. If there are multiple such windows, you should return the leftmost one. **Note**: A window is defined as leftmost when it starts at the smallest index among all possible minimum windows. # Example Input: `s = \\"ADOBECODEBANC\\"`, `t = \\"ABC\\"` Output: `\\"BANC\\"` # Constraints: - `1 <= s.length, t.length <= 10^5` - `s` and `t` consist of English letters. The answer needs to be done in linear time complexity.","solution":"from collections import Counter def min_window_substring(s, t): Finds the minimum window in s that contains all characters of t. if not s or not t: return \\"\\" t_count = Counter(t) current_count = Counter() required = len(t_count) formed = 0 l, r = 0, 0 min_length = float(\\"inf\\") min_left = 0 while r < len(s): character = s[r] current_count[character] += 1 if character in t_count and current_count[character] == t_count[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < min_length: min_length = r - l + 1 min_left = l current_count[character] -= 1 if character in t_count and current_count[character] < t_count[character]: formed -= 1 l += 1 r += 1 return s[min_left:min_left + min_length] if min_length != float(\\"inf\\") else \\"\\""},{"question":"Design a class `LRUCache` to represent a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the `LRUCache` class with the following methods: * `LRUCache(int capacity)` Initializes the LRU cache with positive size capacity. * `int get(int key)` Return the value of the key if the key exists, otherwise return `-1`. * `void put(int key, int value)` Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.","solution":"class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node: Node): prev = node.prev next = node.next prev.next = next next.prev = prev def _add(self, node: Node): node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int): if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.tail.prev self._remove(lru) del self.cache[lru.key]"},{"question":"You are given a **0-indexed** integer array `nums` which represents the positions of different items on a conveyor belt. Each position in `nums` contains a unique identifier for an item. The conveyor belt moves in rounds, and in each round, every item moves from its current position to the position of the item directly to its right (with the item at the last position moving to the first position). Design a function that, given an integer `k` representing the number of rounds the conveyor belt should move, returns the state of `nums` after `k` rounds. For example, given `nums = [1, 2, 3, 4]` and `k = 2`, after 2 rounds, `nums` would be `[3, 4, 1, 2]`. Return _the array_ `nums` _after_ `k` _rounds_.","solution":"def rotate_conveyor_belt(nums, k): Function to rotate the conveyor belt (array) `k` times. Each element moves to the position of the next element, with the last moving to the first. Args: nums (list): The original list of items on the conveyor belt. k (int): The number of rounds to move the conveyor belt. Returns: list: The state of the conveyor belt after `k` moves. n = len(nums) k = k % n # To handle the case where k is larger than the length of nums return nums[-k:] + nums[:-k]"},{"question":"Given an **n-ary** tree, where each node has an arbitrary number of children, and each node is labeled with an integer value, find the **maximum depth** of the tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. `NaryTreeNode` is the class used to define a node in the tree. The class has the following structure: ```python class NaryTreeNode: def __init__(self, val=0, children=None): self.val = val self.children = children if children is not None else [] ``` Implement the function `def max_depth(root: Optional[NaryTreeNode]) -> int:` that takes the root of the n-ary tree and returns the maximum depth.","solution":"from typing import Optional class NaryTreeNode: def __init__(self, val=0, children=None): self.val = val self.children = children if children is not None else [] def max_depth(root: Optional[NaryTreeNode]) -> int: Returns the maximum depth of the n-ary tree. if not root: return 0 if not root.children: return 1 # Compute the depth of each subtree and take the maximum max_child_depth = max(max_depth(child) for child in root.children) return 1 + max_child_depth"},{"question":"You are given a binary tree where each node has an integer value. The value of each node in the binary tree represents the \\"amount of money\\" the node has. You need to find the maximum amount of money you can collect without ever taking money from two directly connected nodes. In other words, if you take money from a node, you cannot take money from its parent or any of its children. Return the maximum amount of money you can collect from this binary tree. The binary tree is represented by the root node, which is a class `TreeNode` defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rob(root): def helper(node): if not node: return (0, 0) left = helper(node.left) right = helper(node.right) rob_current = node.val + left[1] + right[1] not_rob_current = max(left) + max(right) return (rob_current, not_rob_current) return max(helper(root))"},{"question":"You are given a **0-indexed** grid of size `m x n` composed of lowercase English letters. You need to find the largest rectangle containing only one distinct letter and return its area. A rectangle is defined by selecting four points `(r1, c1)`, `(r1, c2)`, `(r2, c1)`, `(r2, c2)` in the grid such that `r1 <= r2` and `c1 <= c2`, and every cell in the rectangle defined by these points must contain the same letter. Return the area of the largest rectangle that contains only one distinct letter. If there are multiple such areas, return the maximum.","solution":"def largestRectangleArea(grid): Given a 2D grid of lowercase English letters, this function finds the largest rectangle that contains only one distinct letter and returns its area. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) max_area = 0 def largestRectangleInHistogram(heights): This helper function calculates the largest rectangle in a histogram represented by the heights array. stack = [] max_area = 0 heights.append(0) # Add a zero-height bar to force calculation of remaining areas in stack for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area for char in set(char for row in grid for char in row): heights = [0] * n for row in range(m): for col in range(n): if grid[row][col] == char: heights[col] += 1 else: heights[col] = 0 max_area = max(max_area, largestRectangleInHistogram(heights)) return max_area"},{"question":"You are given an integer array `arr` where each element is either a `0` or a `1`. The array represents a series of light bulbs, where `1` means the light bulb is turned on and `0` means it is turned off. You can flip the state of any single bulb (from `0` to `1` or from `1` to `0`). Your task is to determine the minimum number of flips required to make all the light bulbs have the same state (all `0`s or all `1`s). Return the _minimum number of flips_ needed to achieve this.","solution":"def min_flips(arr): Returns the minimum number of flips required to make all the light bulbs have the same state (all 0s or all 1s). count_0 = arr.count(0) count_1 = len(arr) - count_0 # We can either turn all to 0s or all to 1s return min(count_0, count_1)"},{"question":"You are given an integer array `nums` of size `n`, and a positive integer `target`. Find the **minimum length** of a contiguous subarray of which the sum is greater than or equal to `target`. If there is no such subarray, return 0 instead. A **contiguous** subarray is a sequence of consecutive elements within the array.","solution":"def min_sub_array_len(target, nums): Finds the minimum length of a contiguous subarray of which the sum is greater than or equal to target. If there is no such subarray, return 0. n = len(nums) min_length = float(\'inf\') left = 0 current_sum = 0 for right in range(n): current_sum += nums[right] while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return 0 if min_length == float(\'inf\') else min_length"},{"question":"You are given a list of integers `height` representing the heights of buildings. The width of each building is 1. It is guaranteed that the buildings are arrayed from left to right in the given order. Determine the maximum area of a rectangle that can be formed by choosing consecutive buildings and taking their heights into account. **Note**: Each rectangle\'s height is determined by the smallest building in the sequence of chosen buildings. Write a method that returns the maximum area of such a rectangle. The method should efficiently compute the result, aiming for an `O(n)` time complexity.","solution":"def largestRectangleArea(heights): Returns the maximum area of a rectangle that can be formed by choosing consecutive buildings. This function uses a stack to achieve the solution in O(n) time complexity. stack = [] # stack to keep indices of the heights array max_area = 0 # variable to store the maximum area index = 0 # current index in the heights array while index < len(heights): # If this building is higher than the building at stack top, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top index top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest(height) area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now pop the remaining buildings from stack and calculate area while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a binary search tree (BST) and an integer `val`. Find the node in the BST that the node\'s value equals `val` and return the subtree rooted with that node. If such a node does not exist, return `null`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def searchBST(root, val): Searches for a node with value `val` in a binary search tree (BST) and returns the subtree rooted with that node. If such a node does not exist, returns `None`. while root is not None and root.val != val: if val < root.val: root = root.left else: root = root.right return root"},{"question":"Given a list of integers `nums`, implement a function `findAllThreeSum(nums)` that returns a list of all unique triplets `[nums[i], nums[j], nums[k]]` such that `i != j != k`, and `nums[i] + nums[j] + nums[k] == 0`. Each triplet in the result list should be sorted in non-descending order, and the result set should not contain any duplicate triplets. For example, given `nums = [-1, 0, 1, 2, -1, -4]`, the solution should return `[[-1, -1, 2], [-1, 0, 1]]`. If no such triplets exist, return an empty list.","solution":"def findAllThreeSum(nums): Returns all unique triplets in the list which sum up to zero. nums.sort() result = [] n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue # Skip duplicates for i left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # Skip duplicates for left while left < right and nums[right] == nums[right - 1]: right -= 1 # Skip duplicates for right left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"Given an integer array `A` representing the number of apples in each basket positioned in a row, you can perform an operation to collect apples from a subarray of consecutive baskets. The operation is defined as follows: 1. Pick a subarray of length `k` (where `k` can vary but must be at least 1 and at most the length of `A`). 2. For the selected subarray, remove all apples from the baskets within that subarray, i.e., make all the elements 0 in that subarray. The goal is to maximize the number of apples collected. You are allowed to perform the above operation exactly once. Write a function `maxApples(A)` that takes the array `A` as input and returns the maximum number of apples you can collect with one operation.","solution":"def maxApples(A): Function to find the maximum number of apples that can be collected in one operation. Args: A (list of int): List of integers representing the number of apples in each basket. Returns: int: The maximum number of apples that can be collected. n = len(A) max_apples = 0 # Variable to store the maximum apples collected for k in range(1, n + 1): # Calculate the sum of the first subarray of length `k` current_sum = sum(A[:k]) max_apples = max(max_apples, current_sum) # Slide the window of length `k` and calculate for other subarrays for i in range(k, n): current_sum += A[i] - A[i - k] max_apples = max(max_apples, current_sum) return max_apples"},{"question":"You are given a string `s` consisting of lowercase English letters. A contiguous substring is defined as a \\"beautiful segment\\" if it contains each letter of the English alphabet at most once. Write a function to find the length of the longest beautiful segment in `s`. Return the length of this segment.","solution":"def longest_beautiful_segment(s): Returns the length of the longest beautiful segment in the string s. start = 0 max_len = 0 char_map = {} for end in range(len(s)): if s[end] in char_map: start = max(start, char_map[s[end]] + 1) char_map[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given an integer array `nums` of length `n`. Your task is to find the length of the longest zigzag subsequence. A subsequence is called zigzag if the differences between consecutive elements are strictly alternating between positive and negative. Return _the length of the longest zigzag subsequence_ in `nums`.","solution":"def longest_zigzag_subsequence(nums): Returns the length of the longest zigzag subsequence in nums. A subsequence is called zigzag if the differences between consecutive elements are strictly alternating between positive and negative. :param nums: List[int], the input list of integers :return: int, length of the longest zigzag subsequence if not nums: return 0 n = len(nums) if n == 1: return 1 up = [1] * n down = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: up[i] = max(up[i], down[j] + 1) elif nums[i] < nums[j]: down[i] = max(down[i], up[j] + 1) return max(max(up), max(down))"},{"question":"Given a list of integers `nums`, return the length of the longest **subsequence** that is both strictly increasing and its values form an **arithmetic progression**. An arithmetic progression is a sequence of numbers such that the difference of any two successive members is a constant. Note that the subsequence must be strictly increasing but does not need to be contiguous within the original list.","solution":"def length_of_longest_arithmetic_subsequence(nums): if not nums: return 0 # dp dictionary where dp[i][d] is the length of the longest arithmetic subsequence ending at index i with common difference d dp = {} max_length = 1 for i in range(len(nums)): for j in range(i): diff = nums[i] - nums[j] if (j, diff) in dp: dp[(i, diff)] = dp[(j, diff)] + 1 else: dp[(i, diff)] = 2 max_length = max(max_length, dp[(i, diff)]) return max_length"},{"question":"You are given an integer array `ar` sorted in **non-decreasing** order, and an integer `x`. Write a function to determine the number of occurrences of `x` in `ar`. If `x` is not present in the array, return `0`. Your solution should have a time complexity better than O(n), ideally O(log n).","solution":"def count_occurrences(ar, x): Returns the number of occurrences of x in the sorted array ar. def find_first_occurrence(ar, x): left, right = 0, len(ar) - 1 first_occurrence = -1 while left <= right: mid = (left + right) // 2 if ar[mid] == x: first_occurrence = mid right = mid - 1 elif ar[mid] < x: left = mid + 1 else: right = mid - 1 return first_occurrence def find_last_occurrence(ar, x): left, right = 0, len(ar) - 1 last_occurrence = -1 while left <= right: mid = (left + right) // 2 if ar[mid] == x: last_occurrence = mid left = mid + 1 elif ar[mid] < x: left = mid + 1 else: right = mid - 1 return last_occurrence first_occurrence = find_first_occurrence(ar, x) if first_occurrence == -1: return 0 last_occurrence = find_last_occurrence(ar, x) return last_occurrence - first_occurrence + 1"},{"question":"You are given two strings, `s1` and `s2`, and your task is to find the longest common subsequence of these two strings. A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return the longest common subsequence. If there is no common subsequence, return an empty string. The solution should be efficient in time complexity.","solution":"def longest_common_subsequence(s1, s2): Returns the longest common subsequence of two strings s1 and s2. If there is no common subsequence, returns an empty string. m, n = len(s1), len(s2) dp = [[\\"\\" for _ in range(n + 1)] for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + s1[i - 1] else: dp[i][j] = dp[i - 1][j] if len(dp[i - 1][j]) > len(dp[i][j - 1]) else dp[i][j - 1] return dp[m][n]"},{"question":"You are given two strings `s` and `t` of length `n`. Determine if `t` can be obtained by rotating `s` exactly `k` times to the right for a given integer `k`. Return `true` if `t` can be obtained, otherwise return `false`.","solution":"def can_obtain_by_rotating(s, t, k): Determine if `t` can be obtained by rotating `s` exactly `k` times to the right. :param s: The original string :param t: The target string after rotation :param k: Number of times to rotate `s` to the right :return: True if `t` can be obtained by rotating `s` exactly `k` times, otherwise False n = len(s) k = k % n # Normalize k to be within the range of the string length rotated_s = s[-k:] + s[:-k] return rotated_s == t"},{"question":"You are given a **0-indexed** integer array `transactions` where `transactions[i]` represents the profit or loss on the `i-th` transaction. A transaction can either add to the profit if it is positive or reduce the profit if it is negative. Return _the **maximum possible profit** that can be achieved by summing up a non-empty subsequence of the `transactions` array._","solution":"def max_profit(transactions): Returns the maximum possible profit that can be achieved by summing up a non-empty subsequence of the transactions array. # Filter out the positive profits positive_profits = [t for t in transactions if t > 0] # If there are no positive profits, return the maximum single transaction if not positive_profits: return max(transactions) # Otherwise, return the sum of all positive profits return sum(positive_profits)"},{"question":"Given an array of integers `arr` and an integer `sum`, determine the total number of distinct pairs of integers in the array that add up to `sum`. Each pair must be a tuple `(arr[i], arr[j])` where `i != j` and `arr[i]` and `arr[j]` are elements of the array. Pairs `(arr[i], arr[j])` and `(arr[j], arr[i])` are considered the same and should not be counted twice. Ensure the pairs are distinct and count the number of such pairs. Return the total count of distinct pairs that sum up to the given `sum`.","solution":"def count_pairs_with_sum(arr, target_sum): Counts the number of distinct pairs in the array that add up to the target sum. Parameters: arr (list): List of integers target_sum (int): Target sum for the pairs Returns: int: Number of distinct pairs seen = set() pairs = set() for number in arr: complement = target_sum - number if complement in seen: pair = tuple(sorted((number, complement))) pairs.add(pair) seen.add(number) return len(pairs)"},{"question":"You are given a string `s` containing only lowercase alphabetic characters. A palindrome is a word that reads the same backward as forward. You can remove at most one character from the string to form a palindrome. Return _`true` if it is possible to make the string a palindrome after removing at most one character, or `false` otherwise_. Example 1: ``` Input: s = \\"abca\\" Output: true Explanation: You could remove the character \'b\' or \'c\' from the string to make \\"aca\\", which is a palindrome. ``` Example 2: ``` Input: s = \\"racecar\\" Output: true Explanation: The string is already a palindrome, so no removals are necessary. ```","solution":"def valid_palindrome(s): Returns whether it is possible to make the string a palindrome after removing at most one character. :param s: str - input string containing only lowercase alphabetic characters. :return: bool - True if the string can be made palindrome by removing at most one character, otherwise False. def is_palindrome(s, left, right): Helper function to check if the substring s[left:right+1] is a palindrome while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Check by removing one character from either side return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1) left += 1 right -= 1 return True"},{"question":"Given a string `s` consisting of only the characters \'x\' and \'y\', return the minimum number of deletions required to make the number of \'x\'s in the string equal to the number of \'y\'s.","solution":"def min_deletions_to_balance(s): Returns the minimum number of deletions required to make the number of \'x\'s equal to the number of \'y\'s in the string s. count_x = s.count(\'x\') count_y = s.count(\'y\') return abs(count_x - count_y)"},{"question":"You are given an array of `n` positive integers representing a binary tree in level order traversal (i.e., left to right, level by level). Each integer in the array corresponds to a node\'s value. Return the highest sum of values that can be obtained by any root-to-leaf path in the tree. - Consider `null` (missing nodes) to be represented as -1 in the array. - Ignore -1 when calculating the root-to-leaf path sum. For example, given the tree: `[1, 2, 3, -1, 4, 5, 6]`, the highest root-to-leaf path sum is `10` (1 -> 3 -> 6).","solution":"def max_root_to_leaf_path_sum(tree): Function to find the highest root-to-leaf path sum in a binary tree represented in level order traversal. Parameters: tree (list): A list of positive integers representing the binary tree in level order traversal. -1 is used for null nodes. Returns: int: The highest sum of values that can be obtained by any root-to-leaf path in the tree. def dfs(index, path_sum): if index >= len(tree) or tree[index] == -1: return path_sum left_index = 2 * index + 1 right_index = 2 * index + 2 left_sum = dfs(left_index, path_sum + tree[index]) right_sum = dfs(right_index, path_sum + tree[index]) return max(left_sum, right_sum) return dfs(0, 0)"},{"question":"Consider an array of **2n** integers in the format [x1, x2, ..., xn, y1, y2, ..., yn]. You are tasked with creating a new array formatted as [x1, y1, x2, y2, ..., xn, yn] by interleaving the first half and the second half of the original array. Write a function that takes an array of **2n** integers and returns the interleaved array. For example, given the array `[1,2,3,4,5,6]`, the output should be `[1,4,2,5,3,6]`.","solution":"def interleave_array(arr): Takes an array of 2n integers and returns the interleaved array. n = len(arr) // 2 interleaved = [] for i in range(n): interleaved.append(arr[i]) interleaved.append(arr[n + i]) return interleaved"},{"question":"You are given a string array `words` where each `words[i]` is a word. Two words are defined as being \\"connected\\" if they can be formed by either swapping one character or by replacing one character with another character. For example, \\"cat\\" and \\"bat\\" are connected by a replacement and \\"abc\\" and \\"acb\\" are connected by a swap. Return the number of distinct connected components in the array. Each connected component is a group of words that are connected directly or indirectly.","solution":"from collections import defaultdict def numConnectedComponents(words): def is_connected(word1, word2): if len(word1) != len(word2): return False diff_count = 0 diff_indices = [] for i in range(len(word1)): if word1[i] != word2[i]: diff_count += 1 diff_indices.append(i) if diff_count > 2: return False if diff_count == 1: return True # Replacement case if diff_count == 2: if word1[diff_indices[0]] == word2[diff_indices[1]] and word1[diff_indices[1]] == word2[diff_indices[0]]: return True # Swap case return False def dfs(word, visited, graph): visited.add(word) for neighbor in graph[word]: if neighbor not in visited: dfs(neighbor, visited, graph) graph = defaultdict(list) for i in range(len(words)): for j in range(i + 1, len(words)): if is_connected(words[i], words[j]): graph[words[i]].append(words[j]) graph[words[j]].append(words[i]) visited = set() components = 0 for word in words: if word not in visited: dfs(word, visited, graph) components += 1 return components"},{"question":"You are given a `string s` representing a sentence containing words separated by spaces. Some words are **duplicates**. Write an algorithm to remove all duplicate words and retain only the first occurrence of each word, preserving the original order of words in the sentence. Implement the `removeDuplicates` function to achieve this. For example, given the input `s = \\"the cat is in the hat\\"`, the output should be `s = \\"the cat is in hat\\"`. Note: - You may assume the input string contains only lowercase letters and spaces. - The result should not contain any leading or trailing spaces, and there should be exactly one space between words.","solution":"def removeDuplicates(s): Removes duplicate words from the sentence, retaining only the first occurrence. :param s: str - input sentence :return: str - sentence with duplicates removed words = s.split() seen = set() result = [] for word in words: if word not in seen: seen.add(word) result.append(word) return \' \'.join(result)"},{"question":"You are given a string `s` consisting of lowercase English letters. A palindrome subsequence is a subsequence of `s` which reads the same backward as forward. You can delete some characters from `s` to form a palindrome subsequence. Your task is to determine the minimum number of deletions required to make the string a palindrome. Return the minimum number of deletions needed.","solution":"def min_deletions_to_make_palindrome(s): Returns the minimum number of deletions required to make the string `s` a palindrome. def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * (n + 1) for _ in range(n + 1)] for i in range(n): for j in range(n): if s[i] == s[n - j - 1]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]) return dp[n][n] lps_length = longest_palindromic_subsequence(s) return len(s) - lps_length"},{"question":"You are given a binary tree with `n` nodes. Each node has a value associated with it, and the tree is rooted at node `0`. You are also given an integer `threshold`. You need to prune the tree by removing subtrees whose total sum of node values is less than `threshold`. The subtree rooted at a node includes the node itself and all its descendants. Write a function to return the root of the pruned tree. If the entire tree is pruned, return `null`. The tree is represented as a list of tuples where each tuple contains the parent node and the child node values `(parent, child, value)`, and the root node\'s value is given as an integer.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.children = [] def build_tree(edges, root_value): nodes = {} root = TreeNode(val=root_value) nodes[0] = root for parent, child, value in edges: if parent in nodes: parent_node = nodes[parent] else: parent_node = TreeNode() nodes[parent] = parent_node if child in nodes: child_node = nodes[child] else: child_node = TreeNode(val=value) nodes[child] = child_node parent_node.children.append(child_node) return root def prune_tree(root, threshold): def helper(node): if not node: return 0 total_sum = node.val pruned_children = [] for child in node.children: child_sum = helper(child) if child_sum >= threshold: pruned_children.append(child) total_sum += child_sum node.children = pruned_children return total_sum if root: total_sum = helper(root) if total_sum < threshold: return None return root"},{"question":"You are given a **0-indexed** integer array `nums` containing `n` integers, where `n` is even. The elements in `nums` represent the height of various towers. Two players take turns choosing a tower. On each player\'s turn, they must choose a tower with the **minimum height** among all possible options. Both players use an optimal strategy where they not only seek to minimize the height but also aim to maximize the minimum height of any remaining tower. The second player wins if they can force a draw or win situation after both players have taken their turns. Implement the function `bool canSecondPlayerWin(int[] nums)` that determines if the second player has a winning strategy. **Note** that all towers are non-negative integers.","solution":"def canSecondPlayerWin(nums): Determines if the second player has a winning strategy given the list of tower heights. Since the first player always chooses from the minimum height left, the second player always faces a decided set of choices. If n (number of towers) is even, the second player will always make the final pick from two towers with the 2 smallest heights, ensuring a draw or win. if len(nums) % 4 == 0: return False else: return True"},{"question":"Given an `n x n` matrix where each of the rows and columns is sorted in ascending order, find the k-th smallest element in the matrix. Note that it is the k-th smallest element in the sorted order, not the k-th distinct element. Ensure to design an algorithm that runs in `O(n log n)` time complexity.","solution":"import heapq def kth_smallest(matrix, k): Returns the k-th smallest element in an n x n matrix that is sorted row-wise and column-wise. :param matrix: List[List[int]], the input n x n matrix :param k: int, the position of the smallest element to find :return: int, the k-th smallest element in the matrix n = len(matrix) min_heap = [] # Build a min-heap of elements from the first row. for col in range(min(k, n)): heapq.heappush(min_heap, (matrix[0][col], 0, col)) # Extract-min k-1 times from the heap. for _ in range(k - 1): element, row, col = heapq.heappop(min_heap) if row + 1 < n: heapq.heappush(min_heap, (matrix[row + 1][col], row + 1, col)) return heapq.heappop(min_heap)[0]"},{"question":"You are given a string `s` of length `n` consisting of lowercase English letters. Your task is to sort the characters in the string based on their frequency in descending order, and if two characters have the same frequency, they should be sorted alphabetically. Return the resulting string after sorting. For example, given the string `s = \\"tree\\"`, the characters \'e\' and \'r\' both appear twice, but \'e\' comes before \'r\' alphabetically, so the result is `\\"eetr\\"`.","solution":"def frequency_sort(s): Sorts the characters in the string s based on their frequency in descending order. If two characters have the same frequency, they are sorted alphabetically. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Sort characters first by frequency in descending order, then alphabetically sorted_characters = sorted(freq.items(), key=lambda x: (-x[1], x[0])) # Reconstruct sorted string based on sorted characters and their frequency sorted_string = \'\'.join([char * count for char, count in sorted_characters]) return sorted_string"},{"question":"You are given a 2D integer array `matrix` representing an m x n grid where each element can either be `0` or `1`. An island is a group of `1`s (representing land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the `matrix` are surrounded by water. Find the largest island and return its area. In case there are no islands, return `0`.","solution":"def largest_island_area(matrix): Given a 2D grid of 0s and 1s, find the largest island (group of connected 1s) and return its area. If there are no islands, return 0. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or matrix[x][y] == 0: return 0 matrix[x][y] = 0 # Mark as visited area = 1 # Move in 4 directions area += dfs(x+1, y) area += dfs(x-1, y) area += dfs(x, y+1) area += dfs(x, y-1) return area max_area = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"A company runs multiple projects using a **Kanban** board that tracks tasks in three states: `Todo`, `In Progress`, and `Done`. Each state can have multiple tasks represented by a list of strings. Tasks can only move from `Todo` to `In Progress` or from `In Progress` to `Done`. Given the initial state of the board as three lists of strings `todo`, `in_progress`, and `done`, implement a function to return the optimal sequence of moves to shift all tasks from `Todo` through `In Progress` to `Done` with minimal steps. Each task can move at most once from `Todo` to `In Progress` and once from `In Progress` to `Done`. Output the sequence of moves as a list of tuples where each tuple is in the form `(\\"task_name\\", \\"source_state\\", \\"destination_state\\")`.","solution":"def optimal_moves(todo, in_progress, done): Generates the optimal sequence of moves to shift all tasks from `Todo` to `In Progress` to `Done`. Parameters: - todo (list of str): Tasks in the `Todo` state. - in_progress (list of str): Tasks in the `In Progress` state. - done (list of str): Tasks in the `Done` state. Returns: - list of tuples: Each tuple is in the form (\\"task_name\\", \\"source_state\\", \\"destination_state\\"). moves = [] # First, move everything from todo to in_progress for task in todo: moves.append((task, \'Todo\', \'In Progress\')) # Then, move everything from in_progress to done for task in in_progress + todo: # after moving `todo` tasks, they will be in `in_progress` moves.append((task, \'In Progress\', \'Done\')) return moves"},{"question":"You are given a matrix `mat` of size `m x n` with **non-negative** integers. You are also given an integer `sumTarget`. Count the number of submatrices that sum to `sumTarget`. Return _the **number** of such submatrices_. A submatrix is a rectangular part of the matrix where the sum of its elements is equal to `sumTarget`. A submatrix can be as small as a single element or as large as the entire matrix.","solution":"def count_submatrices_with_sum(mat, sumTarget): def subarray_sum(nums, k): count = 0 curr_sum = 0 sum_ = {0: 1} for num in nums: curr_sum += num if curr_sum - k in sum_: count += sum_[curr_sum - k] if curr_sum in sum_: sum_[curr_sum] += 1 else: sum_[curr_sum] = 1 return count rows = len(mat) cols = len(mat[0]) count = 0 for start_row in range(rows): cumulative_sum = [0] * cols for row in range(start_row, rows): for col in range(cols): cumulative_sum[col] += mat[row][col] count += subarray_sum(cumulative_sum, sumTarget) return count"},{"question":"You are given a list of strings `words` and a single string `chars`. Each string in `words` can be formed by characters from `chars` if the frequency of each character in the string does not exceed the frequency of the character in `chars`. Return _the sum of the lengths of all strings in `words` that can be formed by characters from `chars`_.","solution":"def count_characters(words, chars): Returns the sum of the lengths of all strings in `words` that can be formed using the characters from `chars`. from collections import Counter # Count the frequency of each character in chars chars_count = Counter(chars) total_length = 0 for word in words: # Count the frequency of each character in the current word word_count = Counter(word) # Check if the current word can be formed if all(word_count[c] <= chars_count[c] for c in word_count): total_length += len(word) return total_length"},{"question":"You are given a string `s` consisting of lowercase alphabets. A string can be constructed by taking characters from `s` and reordering them, but any two characters that are next to each other in the original string `s` should not be adjacent to each other in the new string. Determine if it is possible to create such a string, and if so, return any one possible rearrangement of the string. If it is not possible, return an empty string.","solution":"import heapq from collections import Counter def rearrange_string(s): Returns a possible rearrangement of the string such that no two adjacent characters in the original string are adjacent in the new string. If not possible, returns an empty string. # Count the frequency of each character freq = Counter(s) # Create a max heap based on the character count max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) # Previous character and its count prev_count, prev_char = 0, \'\' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) # Since we use this character, we need to decrease the count if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update prev_count and prev_char prev_count, prev_char = count + 1, char rearranged_string = \'\'.join(result) # Check if we can achieve the desired condition if len(rearranged_string) == len(s): return rearranged_string else: return \\"\\""},{"question":"You are given an integer array `height` representing the heights of buildings adjacent to each other. The array is such that `height[i]` represents the height of the `i-th` building. Consider that the buildings form a skyline viewed from a distance. Compute the maximum rectangular area in the skyline formed by any subset of buildings. Return the area of that rectangle.","solution":"def max_rectangle_area(heights): Calculate the maximum rectangular area in the skyline formed by any subset of buildings. :param heights: List of integers representing the height of the buildings :return: Maximum rectangular area stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a **0-indexed** string `t` and a positive integer `k`. Your task is to find the length of the longest substring such that the number of distinct characters in the substring is **at most** `k`. Return _the length of the **longest** substring of_ `t` _which contains at most_ `k` _distinct characters._","solution":"def longest_substring_k_distinct(t, k): Returns the length of the longest substring of t which contains at most k distinct characters. if k == 0 or not t: return 0 left = 0 max_length = 0 char_count = {} for right in range(len(t)): char_count[t[right]] = char_count.get(t[right], 0) + 1 while len(char_count) > k: char_count[t[left]] -= 1 if char_count[t[left]] == 0: del char_count[t[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an array of integers `arr` of length `n`. An element `arr[i]` is considered a **peak** if it is greater than its immediate neighbors, i.e., `arr[i-1] < arr[i] > arr[i+1]`. If the element is at the boundary of the array, then we only consider the one neighbor that exists. Write a function to return the **index** of any one peak element in the array. If no peak element exists, return `-1`. Note: - You can assume that `arr[-1]` and `arr[n]` are negative infinity (`-∞`). - There may be multiple peak elements in the array; return the index of any one of them.","solution":"def find_peak_element(arr): Returns the index of any one peak element in the array. If no peak element exists, returns -1. n = len(arr) if n == 0: return -1 if n == 1: return 0 # Check the first element if arr[0] > arr[1]: return 0 # Check the last element if arr[n - 1] > arr[n - 2]: return n - 1 # Check the rest of the array for i in range(1, n - 1): if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: return i return -1"},{"question":"You are given an array of integers `nums` and an integer `k`. A contiguous subarray of `nums` is called a **balanced subarray** if the sum of its elements is exactly `k`. Return _the number of **unique balanced subarrays** of_ `nums`. Each subarray is considered unique based on its starting and ending indices.","solution":"def count_balanced_subarrays(nums, k): Returns the number of unique balanced subarrays where the sum of elements is exactly k. count = 0 n = len(nums) # Iterate over all possible starting points of subarrays for start in range(n): current_sum = 0 # Iterate over all possible ending points of subarrays starting from \'start\' for end in range(start, n): current_sum += nums[end] # Check if the current subarray sum is equal to k if current_sum == k: count += 1 return count"},{"question":"You are given a string `s` that consists of only lowercase English letters. You need to **reorganize** the string such that no two adjacent characters are the same. If it is not possible to rearrange the string in such a way, return an empty string. Otherwise, return the reorganized string.","solution":"import heapq from collections import Counter def reorganize_string(s): Reorganizes the input string such that no two adjacent characters are the same. If it is not possible, returns an empty string. count = Counter(s) max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) previous_char, previous_freq = None, 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if previous_char and previous_freq < 0: heapq.heappush(max_heap, (previous_freq, previous_char)) previous_char = char previous_freq = freq + 1 reorganized_string = \\"\\".join(result) if len(reorganized_string) == len(s): return reorganized_string else: return \\"\\""},{"question":"You are given an array `heights` of `n` integers where `heights[i]` represents the height of the `i-th` student in a line. You need to rearrange the students to form a new line such that the minimum height between any two neighboring students in the new line is maximized. Return the maximized value of the minimum height difference between any two neighboring students. For example, for heights `[1, 3, 5, 7, 9]`, the optimal rearrangement would be `[1, 3, 5, 7, 9]` with the minimum height difference being `2`. Your task is to implement a function that efficiently computes this value.","solution":"def maximize_min_difference(heights): Returns the maximized value of the minimum height difference between any two neighboring students after rearrangement. heights.sort() # Sort the heights in non-decreasing order n = len(heights) # After sorting, the minimum difference is between any two neighboring elements min_diff = float(\'inf\') for i in range(1, n): min_diff = min(min_diff, heights[i] - heights[i-1]) return min_diff"},{"question":"Given two integers `start` and `end`, return an array of all integers between `start` and `end` (inclusive) in increasing order. However, if `start` is greater than `end`, return the array of all integers between `start` and `end` in decreasing order. Each integer in the range should appear only once in the result array.","solution":"def range_inclusive(start, end): Returns an array of all integers between start and end (inclusive). If start is less than or equal to end, the array will be in increasing order. If start is greater than end, the array will be in decreasing order. if start <= end: return list(range(start, end + 1)) else: return list(range(start, end - 1, -1))"},{"question":"You are given a rectangular matrix `mat` of integers and two positive integers `numRows` and `numCols`. The task is to convert the matrix `mat` to a new matrix of size `numRows` x `numCols`. The elements in the new matrix should be filled in the same row-wise order as they appear in the original matrix. If it is not possible to reshape the matrix to the desired dimensions, return the original matrix. Write a function to perform this matrix transformation.","solution":"def reshape_matrix(mat, numRows, numCols): Reshapes a matrix into a new matrix with numRows and numCols. If it\'s not possible, returns the original matrix. Args: mat (List[List[int]]): The original matrix. numRows (int): The number of rows for the new matrix. numCols (int): The number of columns for the new matrix. Returns: List[List[int]]: The reshaped matrix or the original matrix if transformation isn\'t possible. original_rows = len(mat) original_cols = len(mat[0]) if mat else 0 # Check if reshape is possible if original_rows * original_cols != numRows * numCols: return mat # Flatten the matrix flat_list = [val for row in mat for val in row] # Construct the new matrix new_matrix = [] for r in range(numRows): row = flat_list[r*numCols:(r+1)*numCols] new_matrix.append(row) return new_matrix"},{"question":"Given an integer array `nums`, return _the **number of longest increasing subsequences**_. Notice that the sequence can be non-continuous but must be strictly increasing. The length of the longest subsequence among all is `n`. For instance, in the array `[1,3,5,4,7]`, the longest increasing subsequences can be `[1,3,4,7]` and `[1,3,5,7]`, and thus there are 2 of them. The test cases are generated so that the answer fits in a 32-bit integer.","solution":"def findNumberOfLIS(nums): Returns the number of longest increasing subsequences in the given array. if not nums: return 0 n = len(nums) lengths = [1] * n counts = [1] * n for i in range(n): for j in range(i): if nums[i] > nums[j]: if lengths[j] + 1 > lengths[i]: lengths[i] = lengths[j] + 1 counts[i] = counts[j] elif lengths[j] + 1 == lengths[i]: counts[i] += counts[j] max_length = max(lengths) return sum(c for l, c in zip(lengths, counts) if l == max_length)"},{"question":"A library needs to manage its book borrowing system more efficiently. Each book can be borrowed for a maximum of `k` days. You are given a list of integers where each integer represents the number of days a book has been borrowed by a reader. The library wants to identify and move books that have been borrowed for more than `k` days to a priority return list. Write a function that takes in the list of borrowed days and an integer `k`, and returns a new list containing only the books that need to be returned based on the priority condition. **Example:** If the list of borrowed days is `[5, 13, 8, 2, 10]` and `k` is `7`, the function should return `[13, 8, 10]` because these books have been borrowed for more than `7` days.","solution":"def priority_return_list(borrowed_days, k): Returns a list of books to be returned based on borrowing days exceeding k. :param borrowed_days: List[int] - List of days books have been borrowed :param k: int - Number of days threshold for a book to be flagged for return :return: List[int] - List of books to be returned return [days for days in borrowed_days if days > k]"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to find the smallest window (substring) in `s` that contains all the unique characters of `s` at least once. If there are multiple such smallest windows, return the first one that appears in the string. Return _the smallest window in string_ `s` _that contains all the unique characters of_ `s` _at least once_. If `s` is empty, return an empty string.","solution":"def smallest_window(s): if not s: return \\"\\" unique_chars = set(s) unique_count = len(unique_chars) char_count = {} min_length = float(\'inf\') min_window = \\"\\" left = 0 for right, char in enumerate(s): char_count[char] = char_count.get(char, 0) + 1 while len(char_count) == unique_count: window_length = right - left + 1 if window_length < min_length: min_length = window_length min_window = s[left:right + 1] char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 return min_window"},{"question":"You are given a **0-indexed** integer array `heights` representing the height of an obstacle at each position on a track. You also have a robot that can move either left or right across this track and jump over obstacles. The robot has an initial strength `s`, which indicates the maximum height it can jump over. Your task is to determine if the robot can successfully move from the start of the track at position `0` to the end of the track at position `n-1` (where `n` is the length of the array) without running out of strength. The robot can only jump over an obstacle if its strength is greater than or equal to the height of the obstacle. Each successful jump over an obstacle decreases the robot\'s strength by 1. If the robot\'s strength is exactly equal to the height of an obstacle, it can jump over it but the strength becomes `0` and it can\'t jump over any further obstacles. Return `true` if the robot can reach the end of the track and `false` otherwise.","solution":"def can_reach_end(heights, s): Determine if the robot can reach the end of the track given its strength `s`. Parameters: heights (list): A list of integers representing the heights of obstacles. s (int): The initial strength of the robot. Returns: bool: True if the robot can reach the end of the track, otherwise False. for height in heights: if s < height: return False s -= 1 if s < 0: return False return True"},{"question":"Design an algorithm to determine whether a Sudoku board is valid. A Sudoku board is a 9x9 grid containing digits from 1 to 9 and empty cells represented by \'.\'. The board is valid if the following conditions are met: * Each row must contain the digits 1-9 without repetition. * Each column must contain the digits 1-9 without repetition. * Each of the nine 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled Sudoko board could be valid but is not necessarily solvable. Implement the function `bool isValidSudoku(char[][] board)` that returns true if the board is valid according to the rules described above, and false otherwise.","solution":"def isValidSudoku(board): Checks whether a given Sudoku board is valid. Args: board: List[List[str]] - A 9x9 grid representing a Sudoku board, with digits \'1\'-\'9\' and empty cells \'.\'. Returns: bool - True if the board is valid, False otherwise. rows = [set() for _ in range(9)] columns = [set() for _ in range(9)] boxes = [set() for _ in range(9)] for i in range(9): for j in range(9): num = board[i][j] if num == \'.\': continue # Check row if num in rows[i]: return False rows[i].add(num) # Check column if num in columns[j]: return False columns[j].add(num) # Check 3x3 box box_index = (i // 3) * 3 + (j // 3) if num in boxes[box_index]: return False boxes[box_index].add(num) return True"},{"question":"You are given an integer array `arr` and an integer `k`. If the length of the array is less than `k`, return an empty array. Otherwise, return _an array of all possible **contiguous subarrays** of length `k`_. Each subarray should appear in **the order they appear in the original array**.","solution":"def find_contiguous_subarrays(arr, k): Returns a list of all possible contiguous subarrays of length k. If the array\'s length is less than k, returns an empty list. if len(arr) < k: return [] result = [] for i in range(len(arr) - k + 1): result.append(arr[i:i+k]) return result"},{"question":"Given a binary tree, where each node can have at most two children, find the length of the longest path such that each node in the path has a consecutive value (i.e., current node value is 1 more than the previous node value). Return _the length of the longest path of consecutive values in the binary tree_. Note: The path can be either from parent to child or from child to parent but cannot zigzag between children of the same parent.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_consecutive_path(root): def dfs(node, parent_value, length): if not node: return length current_length = length + 1 if parent_value + 1 == node.value else 1 left_length = dfs(node.left, node.value, current_length) right_length = dfs(node.right, node.value, current_length) return max(current_length, left_length, right_length) return dfs(root, root.value - 1, 0) if root else 0"},{"question":"Given an array `A` of integers, you can choose any two indices `i` and `j` (`i < j`) and swap `A[i]` with `A[j]`. Return the minimum number of swaps required to sort the array in non-decreasing order. If the array is already sorted, return `0`.","solution":"def minimum_swaps_to_sort(arr): Returns the minimum number of swaps required to sort the array in non-decreasing order. n = len(arr) # Create a list of tuples where each tuple is (value, index) arr_pos = [(value, index) for index, value in enumerate(arr)] # Sort the list of tuples by the value arr_pos.sort(key=lambda it: it[0]) # Create a visited list to mark the visited nodes visited = [False] * n # Initialize the result swaps = 0 for i in range(n): # If the element is already at the correct position or visited, continue if visited[i] or arr_pos[i][1] == i: continue # Initialize cycle length cycle_length = 0 x = i while not visited[x]: visited[x] = True x = arr_pos[x][1] # Get the index positions cycle_length += 1 # Update result by subtracting 1 from cycle length if cycle_length > 0: swaps += (cycle_length - 1) return swaps"},{"question":"[Question] 4: Given a matrix of integers `matrix` where each row is sorted in increasing order, create a function `kthSmallest(matrix, k)` that returns the `k`th smallest element in the matrix. You need to consider that `matrix` is n x n and k is a valid integer such that 1 ≤ k ≤ n^2. The function should use an efficient algorithm to find the solution without explicitly sorting all the elements of the matrix.","solution":"import heapq def kthSmallest(matrix, k): Returns the kth smallest element in the sorted matrix. n = len(matrix) min_heap = [] for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) kth_smallest = 0 for _ in range(k): kth_smallest, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return kth_smallest"},{"question":"You are given an integer array `weights` where `weights[i]` represents the weight of the `ith` item, and an integer `maxLoad` representing the maximum weight a single container can hold. You need to distribute these items into the minimum number of containers such that the sum of the weights of the items in each container does not exceed `maxLoad`. Return the minimum number of containers required. A container can hold multiple items as long as their total weight does not exceed `maxLoad`. Each item must be placed in exactly one container.","solution":"from typing import List def min_containers(weights: List[int], maxLoad: int) -> int: weights.sort(reverse=True) containers = [] for w in weights: placed = False for i in range(len(containers)): if containers[i] + w <= maxLoad: containers[i] += w placed = True break if not placed: containers.append(w) return len(containers)"},{"question":"You are given a string `s` containing only lowercase English letters and a pattern `p` which can include lowercase English letters and the character `.` (dot). Each dot in the pattern can match any single character. Write a function to determine if the pattern `p` matches the entire string `s` (not partial substrings). Your function should return `true` if `p` matches `s`, and `false` otherwise. Note that the pattern `p` must match the entire length of the string `s`. Implement the function `boolean isMatch(String s, String p)` which takes in the string `s` and the pattern `p` as inputs and returns a boolean indicating whether the pattern matches the string.","solution":"import re def isMatch(s, p): Determines if the pattern p matches the entire string s. :param s: The input string, contains only lowercase English letters. :param p: The pattern, contains only lowercase English letters and the character \'.\'. :return: True if the pattern matches the entire string, False otherwise. # Use re.fullmatch to check if the pattern p matches the entire string s return re.fullmatch(p, s) is not None"},{"question":"You are given an integer `n` representing the number of courses you have to take, labeled from `0` to `n-1`. You are also given a 2D integer array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` before you can take course `ai`. The array `prerequisites` might not contain all courses, and there may be courses with no prerequisites. Return the minimum number of semesters required to complete all courses. If it is impossible to complete all courses, return `-1`.","solution":"from collections import deque, defaultdict def minNumberOfSemesters(n, prerequisites): Returns the minimum number of semesters required to complete all courses. If it is impossible to complete all courses, return -1. :param n: int - the total number of courses. :param prerequisites: List[List[int]] - the prerequisite relationships between the courses. :return: int - the minimum number of semesters required to complete all courses or -1 if impossible. in_degree = [0] * n adj_list = defaultdict(list) for course, prereq in prerequisites: in_degree[course] += 1 adj_list[prereq].append(course) queue = deque([i for i in range(n) if in_degree[i] == 0]) semesters = 0 completed_courses = 0 while queue: num_courses_this_semester = len(queue) for _ in range(num_courses_this_semester): course = queue.popleft() completed_courses += 1 for next_course in adj_list[course]: in_degree[next_course] -= 1 if in_degree[next_course] == 0: queue.append(next_course) semesters += 1 return semesters if completed_courses == n else -1"},{"question":"You are given two strings `s` and `p`. Write a function to return the **list of starting indices** of all anagrams of `p` in `s`. **Note**: * An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. * The given strings contain only lowercase English letters, and the length of `p` is less than or equal to the length of `s`.","solution":"from collections import Counter def find_anagrams(s, p): Finds the starting indices of all anagrams of \'p\' in \'s\'. result = [] p_count = Counter(p) s_count = Counter() p_length = len(p) for i, char in enumerate(s): s_count[char] += 1 if i >= p_length: left_char = s[i - p_length] if s_count[left_char] == 1: del s_count[left_char] else: s_count[left_char] -= 1 if s_count == p_count: start_index = i - p_length + 1 result.append(start_index) return result"},{"question":"You are given a list of `n` integers, representing the heights of buildings in a straight line street. You are also given an integer `k`. Each building can catch fire and spread it to its neighboring buildings. The fire spreads from one building to the immediate next building in one unit of time. Your task is to determine the minimum amount of time required to set all the buildings on fire if initially the fire can be started from at most `k` different buildings at the same time. Write a function `minTimeToBurnAllBuildings(heights: List[int], k: int) -> int` that returns the minimum amount of time needed to catch fire in all buildings starting from any `k` buildings. The function should account for possibly different heights but should not depend on the height values in determining the spread of fire. **Input** - `heights`: a list containing `n` integers, where `n` is the number of buildings. - `k`: an integer representing the maximum number of starting points for the fire. **Output** - An integer representing the minimum time needed to burn all the buildings. **Example:** ```python minTimeToBurnAllBuildings([3, 4, 5, 10, 8], 2) # This should return the minimum time required for fire to spread through all the buildings starting from any 2 buildings. ```","solution":"def minTimeToBurnAllBuildings(heights, k): n = len(heights) if k >= n: return 0 # To minimize the time, we need to divide the line into k segments # and pick the furthest building in each segment to start the fire. min_time = (n - 1) // k # This is essentially ceiling(n-1/k) because each building will at least cover that much distance return min_time"},{"question":"You are given an integer array `heights` where each element represents the height of a person. A peak is defined as a person who is taller than both their immediate neighbors (the element before and the element after them). Return _the number of peaks_ in the array `heights`. **Example:** ``` Input: heights = [1, 3, 2, 5, 4, 6, 3] Output: 3 Explanation: The peaks are at indices 1, 3, and 5. (heights[1] = 3, heights[3] = 5, heights[5] = 6) ``` **Note:** - A peak cannot be the first or the last element of the array.","solution":"def count_peaks(heights): Returns the number of peaks in the array heights. A peak is an element which is higher than its immediate neighbors. if len(heights) < 3: return 0 peak_count = 0 for i in range(1, len(heights) - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: peak_count += 1 return peak_count"},{"question":"Given an array of integers `nums` where `nums[i]` represents the number of cookies in the `i`-th pile, your goal is to distribute the cookies to `k` children such that the maximum number of cookies any child gets is minimized. Each child gets a contiguous block of cookies, meaning the array must be partitioned into `k` parts. Return _the minimized maximum number of cookies any child can get_.","solution":"def minimize_max_cookies(nums, k): This function distributes the cookies such that the maximum number of cookies any child gets is minimized. def canDistributeWithMaxSum(max_sum): current_sum, parts = 0, 1 for num in nums: if current_sum + num > max_sum: parts += 1 current_sum = num if parts > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if canDistributeWithMaxSum(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a list of `n` integers representing an order of items with their weights. Your task is to implement a data structure that supports the following operations: * `WeightManager(int n, vector<int>& weights)`: Initializes the object with a list of weights. * `void updateWeight(int index, int weight)`: Updates the weight of an item at the given index. * `int getTotalWeight(int start, int end)`: Returns the sum of weights of items within the inclusive range from `start` to `end`. Implement the `WeightManager` class that makes these operations efficient, especially in terms of updating an item\'s weight and getting the total weight of a given range.","solution":"class WeightManager: def __init__(self, n, weights): Initializes the object with a list of weights. self.n = n self.weights = weights self.tree = [0] * (2 * n) self.build_tree() def build_tree(self): Builds the segment tree for efficient range sum query. # Initialize leaves for i in range(self.n): self.tree[self.n + i] = self.weights[i] # Build the tree for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def updateWeight(self, index, weight): Updates the weight of an item at the given index. pos = index + self.n self.tree[pos] = weight # Update ancestors while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def getTotalWeight(self, start, end): Returns the sum of weights of items within the inclusive range from start to end. start += self.n end += self.n sum_weights = 0 while start <= end: if start % 2 == 1: sum_weights += self.tree[start] start += 1 if end % 2 == 0: sum_weights += self.tree[end] end -= 1 start //= 2 end //= 2 return sum_weights"},{"question":"Given two strings `s` and `t`, return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. If no such substring exists, return an empty string. If there are multiple minimum-length windows, return the one that appears first. Implement a function: ```python def minWindowSubstring(s: str, t: str) -> str: pass ``` # Example Input: `s = \\"ADOBECODEBANC\\", t = \\"ABC\\"` Output: `\\"BANC\\"` # Note - You may assume that both strings consist only of uppercase and lowercase letters. - Your algorithm should have a time complexity better than O(n^2).","solution":"def minWindowSubstring(s: str, t: str) -> str: from collections import Counter, defaultdict if not s or not t: return \\"\\" # Dictionary which keeps a count of all the unique characters in t. dict_t = Counter(t) # Number of unique characters in t that need to be present in the desired window. required = len(dict_t) # Left and Right pointer l, r = 0, 0 # Formed is used to keep track of how many unique characters in t # are present in the current window in its desired frequency. # e.g. if t is \\"AABC\\" then the window must have two A\'s, one B and one C. # thus formed should be 3 if the window is valid. formed = 0 # Dictionary which keeps a count of all the unique characters in the current window. window_counts = defaultdict(int) # ans tuple of the form (window length, left, right) ans = float(\\"inf\\"), None, None while r < len(s): # Add one character from the right to the window character = s[r] window_counts[character] += 1 # If the frequency of the current character added equals to the # desired count in t then increment the formed count by 1. if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 # Try and contract the window till the point where it ceases to be \'desirable\'. while l <= r and formed == required: character = s[l] # Save the smallest window until now. if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) # The character at the position pointed by the # `Left` pointer is no longer a part of the window. window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 # Move the left pointer ahead, this would help to look for a new window. l += 1 # Keep expanding the window once we are done contracting. r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]: ans[2] + 1]"},{"question":"You are given an integer array `arr` and an integer `k`. The array contains distinct integers and is initially sorted in ascending order. Your task is to rearrange the array such that every `k`-th element remains in its original position while the rest of the array is sorted in ascending order. Return _the **rearranged** array_.","solution":"def rearrange_array(arr, k): Rearranges the array such that every k-th element remains in its original position while the rest of the array is sorted in ascending order. Parameters: - arr (List[int]): A list of distinct integers initially sorted in ascending order - k (int): An integer denoting the position interval which must remain in its original position Returns: - List[int]: The rearranged list n = len(arr) # Extract the elements that will stay and their indices stay_indices = [i for i in range(n) if (i+1) % k == 0] stay_elements = [arr[i] for i in stay_indices] # Extract the elements that will be rearranged move_elements = [arr[i] for i in range(n) if (i+1) % k != 0] # Sort the elements that need to be moved move_elements.sort() # Create a new array and fill in the elements result = [] move_index = 0 stay_index = 0 for i in range(n): if (i+1) % k == 0: result.append(stay_elements[stay_index]) stay_index += 1 else: result.append(move_elements[move_index]) move_index += 1 return result"},{"question":"Given an array of integers `arr`, you can perform the following operation as many times as you want: choose any subarray (contiguous part) and decrease each element of the subarray by 1. Find the minimum number of operations required to make all the elements of the array equal to zero. Return the number of these operations.","solution":"def min_operations_to_zero(arr): Given an array of integers arr, find the minimum number of operations required to make all the elements of the array equal to zero. if not arr: return 0 # Count the number of segments with positive integers operations = 0 in_positive_segment = False for num in arr: if num > 0 and not in_positive_segment: operations += 1 in_positive_segment = True elif num == 0: in_positive_segment = False return operations"},{"question":"Given a list of words and a pattern, return a list of all the words that match the pattern. A word matches the pattern if there exists a permutation of letters `p` such that after replacing every letter `x` in the pattern with `p(x)`, we get the desired word. Ensure that each letter in the pattern maps to a unique letter in the word and vice versa. For example: - If the input words are [\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"] and the pattern is \\"abb\\", the matching words are [\\"mee\\",\\"aqq\\"].","solution":"def find_and_replace_pattern(words, pattern): Given an array of words and a pattern, returns an array of the words that match the given pattern. :param words: List[str] - A list of words to be matched against the pattern. :param pattern: str - The pattern to compare the words against. :return: List[str] - A list of words that match the pattern. def match_pattern(word, pattern): Helper function to determine if a word matches a given pattern. :param word: str - A word to be matched against the pattern. :param pattern: str - The pattern to compare the word against. :return: bool - True if word matches the pattern, False otherwise. if len(word) != len(pattern): return False char_mapping_word_to_pattern = {} char_mapping_pattern_to_word = {} for char_word, char_pattern in zip(word, pattern): if char_word not in char_mapping_word_to_pattern: char_mapping_word_to_pattern[char_word] = char_pattern if char_pattern not in char_mapping_pattern_to_word: char_mapping_pattern_to_word[char_pattern] = char_word if char_mapping_word_to_pattern[char_word] != char_pattern or char_mapping_pattern_to_word[char_pattern] != char_word: return False return True return [word for word in words if match_pattern(word, pattern)]"},{"question":"Given an array of integers `arr`, write a function to determine if it contains a continuous subarray of size at least 2 that sums up to a multiple of `k`, where `k` is a given integer. A continuous subarray is a sequence of elements within the array that you can identify by specifying two indices, a start and an end, where the sequence must contain at least two elements. Return `true` if such a subarray exists, otherwise, return `false`.","solution":"def check_subarray_sum(arr, k): Determines if the array contains a continuous subarray of size at least 2 that sums up to a multiple of k. Parameters: arr (list): List of integers. k (int): The integer multiple to check against. Returns: bool: Returns True if such a subarray exists, otherwise False. # Dictionary to store the remainder and its corresponding index remainder_dict = {0: -1} cumulative_sum = 0 for i, num in enumerate(arr): cumulative_sum += num remainder = cumulative_sum % k if k != 0 else cumulative_sum if remainder in remainder_dict: if i - remainder_dict[remainder] > 1: return True else: remainder_dict[remainder] = i return False"},{"question":"You are given a string `s` consisting of lowercase letters, and an integer `k`. You need to perform a series of operations to transform `s` into a \\"nice\\" string. A string is considered \\"nice\\" if there are no two adjacent characters that are the same. In one operation, you can choose any character in the string and replace it with any other lowercase letter. Return the minimum number of operations required to make the string \\"nice\\".","solution":"def min_operations_to_make_nice(s, k): Return the minimum number of operations required to make the string \'nice\'. if not s: return 0 n = len(s) operations = 0 for i in range(n - 1): if s[i] == s[i + 1]: # Find a character to replace with replacements = set(\'abcdefghijklmnopqrstuvwxyz\') - {s[i], s[i + 2] if i + 2 < n else \'\'} s = s[:i + 1] + replacements.pop() + s[i + 2:] operations += 1 return operations"},{"question":"You are given a string `s` consisting of lowercase English letters. Define the **cost** of a string as the number of distinct characters it contains. You can delete any number of characters from the string `s` to form a new string. Return _the minimum cost to make the string `s` **uniform**_, i.e., all characters in the string should be the same.","solution":"def min_cost_to_uniform(s): Returns the minimum cost to make the string `s` uniform. if not s: return 0 cost = len(set(s)) - 1 return cost"},{"question":"Given an integer array `arr` and an integer `k`, you need to find the maximum sum of a subarray of length `k`. A subarray is a contiguous part of an array. Implement the function `maxSumSubarray(int[] arr, int k)` that returns the maximum sum obtainable from a subarray of length `k` in the array `arr`.","solution":"def maxSumSubarray(arr, k): Returns the maximum sum obtainable from a subarray of length k. n = len(arr) if n < k: # if there are fewer elements than k, return 0 or error return 0 # Calculate the sum of the first subarray of length k max_sum = current_sum = sum(arr[:k]) # Use sliding window to calculate the sum of other subarrays of length k for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You are given a matrix `mat` of integers with `m` rows and `n` columns, and an integer `k`. Your task is to find the maximum possible sum of a submatrix with the sum less than or equal to `k`. A submatrix is defined by selecting some contiguous rows and some contiguous columns from the original matrix. Return the maximum sum possible of such a submatrix.","solution":"import bisect def max_sum_submatrix(mat, k): def max_sum_no_larger_than_k(nums, k): max_sum = float(\'-inf\') sum_so_far = 0 sorted_prefix_sums = [0] for num in nums: sum_so_far += num idx = bisect.bisect_left(sorted_prefix_sums, sum_so_far - k) if idx < len(sorted_prefix_sums): max_sum = max(max_sum, sum_so_far - sorted_prefix_sums[idx]) bisect.insort(sorted_prefix_sums, sum_so_far) return max_sum m, n = len(mat), len(mat[0]) max_sum = float(\'-inf\') for left in range(n): row_sums = [0] * m for right in range(left, n): for i in range(m): row_sums[i] += mat[i][right] max_sum = max(max_sum, max_sum_no_larger_than_k(row_sums, k)) return max_sum"},{"question":"You are given a permutation of the first `n` natural numbers (1, 2, 3, ..., n) stored in an array `arr` of length `n`. Your task is to find the previous permutation of the given permutation in lexicographical order. If no such permutation exists (i.e., the given permutation is the smallest possible), return the permutation sorted in descending order. Implement a function that returns the previous permutation. For example: - Example 1: - Input: `arr = [1, 3, 2]` - Output: `[1, 2, 3]` - Example 2: - Input: `arr = [3, 2, 1]` - Output: `[3, 1, 2]` - Example 3: - Input: `arr = [2, 1, 3]` - Output: `[1, 3, 2]`","solution":"def previous_permutation(arr): Find the previous permutation of the given permutation array in lexicographical order. If no such permutation exists, return the permutation sorted in descending order. n = len(arr) # Step 1 - Find the largest index k such that arr[k] > arr[k + 1] k = n - 2 while k >= 0 and arr[k] <= arr[k + 1]: k -= 1 # If no such index exists, the array is sorted in ascending order if k == -1: return arr[::-1] # Step 2 - Find the largest index l > k such that arr[k] > arr[l] l = n - 1 while arr[k] <= arr[l]: l -= 1 # Step 3 - Swap the value of arr[k] with that of arr[l] arr[k], arr[l] = arr[l], arr[k] # Step 4 - Reverse the sequence from arr[k+1] to the end arr = arr[:k+1] + arr[k+1:][::-1] return arr"},{"question":"Given an integer `n`, return a list of all **unique** combinations of numbers from `1` to `n` that sum up to `n`. Each number in the range `[1, n]` can appear at most once in the combination. The combinations can be returned in any order.","solution":"def combination_sum(n): def backtrack(start, target, path, res): if target == 0: res.append(path) return for i in range(start, n + 1): if i > target: break backtrack(i + 1, target - i, path + [i], res) result = [] backtrack(1, n, [], result) return result"},{"question":"Implement a data structure `FreqStack` that simulates the function of a stack-like data structure with frequency-based popping. The `FreqStack` class should have the following methods: * `FreqStack()` - Initializes the stack object. * `void push(int x)` - Pushes an integer `x` onto the stack. * `int pop()` - Removes and returns the most frequent element in the stack. If there is a tie for the most frequent element, the element closest to the top of the stack is removed and returned. You must create a solution that supports `O(1)` push operation and `O(logn)` pop operation.","solution":"from collections import defaultdict import heapq class FreqStack: def __init__(self): self.freq = defaultdict(int) self.max_heap = [] self.index = 0 def push(self, x): self.freq[x] += 1 heapq.heappush(self.max_heap, (-self.freq[x], -self.index, x)) self.index += 1 def pop(self): freq, index, x = heapq.heappop(self.max_heap) self.freq[x] -= 1 if self.freq[x] == 0: del self.freq[x] return x"},{"question":"Given a string `s` consisting of lowercase English letters and integers, your task is to group all the characters in the string in such a way that: 1. All letters appear before numbers. 2. The letters maintain their original relative ordering. 3. The numbers maintain their original relative ordering. Return _the newly arranged string_. Example: Input: `s = \\"a1b2c3\\"` Output: `\\"abc123\\"`","solution":"def rearrange_string(s): Rearranges the input string such that all letters appear before all numbers, both maintaining their original relative order. Parameters: s (str): Input string consisting of lowercase English letters and integers. Returns: str: The rearranged string. letters = [] numbers = [] for char in s: if char.isdigit(): numbers.append(char) else: letters.append(char) return \'\'.join(letters + numbers)"},{"question":"You are given an integer array `arr` of size `n` and an integer `d`. Your task is to find the maximum number of elements that can be picked from the array such that the absolute difference between any two elements picked is greater than or equal to `d`. Return _an integer_ denoting the maximum number of elements that can be picked from the array.","solution":"def max_elements_with_difference(arr, d): Returns the maximum number of elements that can be picked from the array such that the absolute difference between any two elements picked is greater than or equal to d. Parameters: arr (list of int): The array of integers. d (int): The minimum absolute difference between elements. Returns: int: The maximum number of elements that can be picked. if not arr or d < 0: return 0 # Sort the array to easily check the differences arr.sort() count = 1 last_picked = arr[0] for i in range(1, len(arr)): if arr[i] - last_picked >= d: count += 1 last_picked = arr[i] return count"},{"question":"In a row of seats, labeled from `0` to `n - 1`, where `n` is the total number of seats, there are some students sitting. Each student has a unique label represented as an integer in the array `arr`. Each student needs a certain amount of `space` on either side to feel comfortable, defined as an integer array `space` where `space[i]` is the space required by the student at seat `arr[i]`. Given these requirements, write a function to determine if it\'s possible for all students to sit comfortably. Return `true` if it\'s possible for all students to sit comfortably, otherwise return `false`.","solution":"def can_students_sit_comfortably(arr, space, n): positions = sorted(zip(arr, space)) for i in range(len(positions)): seat, required_space = positions[i] # Checking the space on the left side if i == 0: left_boundary = 0 else: left_boundary = positions[i-1][0] + positions[i-1][1] + 1 left_space = seat - left_boundary if left_space < required_space: return False # Checking the space on the right side if i == len(positions) - 1: right_boundary = n - 1 else: right_boundary = positions[i+1][0] - positions[i+1][1] - 1 right_space = right_boundary - seat if right_space < required_space: return False return True"},{"question":"You are given an integer array `arr` where each element is distinct. You need to find all the pairs of elements (a, b) such that a and b come from different positions in the array and gcd(a, b) equals 1. Return the total number of such pairs.","solution":"from math import gcd from itertools import combinations def find_coprime_pairs(arr): Returns the total number of pairs (a, b) such that gcd(a, b) == 1 and a and b are from different positions in the array. count = 0 for a, b in combinations(arr, 2): if gcd(a, b) == 1: count += 1 return count"},{"question":"You are given an array of integers `nums` and a positive integer `k`. Return _the length of the longest subsequence of `nums` that satisfies the given conditions:_ 1. The absolute difference between any two elements in the subsequence is less than or equal to `k`. 2. The subsequence can be in any order, meaning you do not need to maintain the original order of elements in `nums`. For example, if `nums = [1, 3, 4, 9]` and `k = 2`, the longest subsequence would be `[1, 3, 4]` with length 3. **Constraints**: - `1 <= nums.length <= 10^5` - `1 <= nums[i] <= 10^9` - `1 <= k <= 10^9`","solution":"def longest_subsequence_length(nums, k): Returns the length of the longest subsequence where the difference between any two elements is <= k. nums.sort() # Sort the array to simplify checking subsequences longest_length = 1 # At least one element can be the shortest subsequence current_length = 1 for i in range(1, len(nums)): if nums[i] - nums[i - 1] <= k: current_length += 1 longest_length = max(longest_length, current_length) else: current_length = 1 return longest_length"},{"question":"Given the root of a binary tree, determine if it is a balanced binary tree. A balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. Your function should return a boolean value indicating whether the tree is balanced or not.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determines if a binary tree is balanced. :param root: TreeNode, the root of the binary tree :return: boolean, True if the tree is balanced, False otherwise def check_balance(node): if not node: return 0, True left_depth, left_balanced = check_balance(node.left) right_depth, right_balanced = check_balance(node.right) current_balance = abs(left_depth - right_depth) <= 1 balanced = left_balanced and right_balanced and current_balance return max(left_depth, right_depth) + 1, balanced _, balanced = check_balance(root) return balanced"},{"question":"Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`. A linked list is said to contain a cycle if any node in the list can be reached again by continuously following the `next` pointer. Use constant memory to determine the result.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head): Detects the node where the cycle begins in the linked list. Args: head (ListNode): The head of the linked list. Returns: ListNode: The node where the cycle begins, or None if there is no cycle. if not head or not head.next: return None slow = head fast = head # First, determine if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # No cycle detected return None # To find the starting node of the cycle, reset one pointer to the head # and move both pointers one step at a time until they meet slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"Given a list of unique integers `arr`, you need to find the length of the longest arithmetic subsequence in the list. An arithmetic subsequence of a list is a subsequence that derives from the original list and maintains the order of elements and has a common difference between consecutive elements. For example, in the list `[3, 6, 9, 12, 15]`, the entire list is an arithmetic subsequence with a common difference of 3. Return the length of the longest arithmetic subsequence in the original list `arr`.","solution":"def longest_arith_seq_length(arr): if len(arr) <= 1: return len(arr) dp = [{} for _ in range(len(arr))] max_length = 2 for i in range(1, len(arr)): for j in range(i): diff = arr[i] - arr[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"You are given two strings `s1` and `s2` of equal length consisting of lowercase letters only. You can perform the following operation on `s1` at most once: choose any character in `s1` and replace it with any other lowercase letter. Determine the minimum number of single-character substitutions required to make `s1` and `s2` equal after at most one operation. If it\'s impossible to make the strings equal, return `-1`.","solution":"def min_operations_to_equal(s1, s2): Determines the minimum number of single-character substitutions required to make two strings s1 and s2 equal after at most one operation. If it\'s impossible to make the strings equal, returns -1. # First, count the number of different positions between s1 and s2 diff_count = sum(1 for a, b in zip(s1, s2) if a != b) # If there are no differences, no operation is needed if diff_count == 0: return 0 # If there is exactly one difference, check if it\'s possible to fix it with one change if diff_count == 1: return 1 # If there are exactly two differences, see if swapping the characters would work if diff_count == 2: diff_positions = [(a, b) for a, b in zip(s1, s2) if a != b] if (diff_positions[0][0] == diff_positions[1][1] and diff_positions[0][1] == diff_positions[1][0]): return 1 # If there are more than two differences, it\'s not possible with one operation return -1"},{"question":"Given a string `s` consisting of parentheses `(` and `)`, determine if the string is valid. A string is valid if: 1. Open parentheses must be closed by the same type of parentheses. 2. Open parentheses must be closed in the correct order. Return `true` if the string is valid and `false` otherwise.","solution":"def is_valid_parentheses(s): Determines if the input string `s` consisting of parentheses `(` and `)` is valid according to the given rules. Parameters: s (str): The input string containing parentheses. Returns: bool: True if the string is valid, False otherwise. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if len(stack) == 0 or stack[-1] != \'(\': return False stack.pop() return len(stack) == 0"},{"question":"You are given a string `s` representing a sentence containing words separated by spaces. Some words are repeated multiple times. Your task is to return a list of words that appear only once in the sentence. The words should be returned in the order of their appearance in the sentence. For example, given the sentence `\\"this is a test this is only a test\\"`, the words that appear only once are `[\\"only\\"]`. Function signature: `def unique_words(sentence: str) -> List[str]:`","solution":"from typing import List from collections import Counter def unique_words(sentence: str) -> List[str]: Returns a list of words that appear only once in the sentence. Parameters: sentence (str): The input sentence containing words separated by spaces. Returns: List[str]: A list of unique words that appear only once in the sentence. # Split the sentence into words words = sentence.split() # Count the occurrences of each word word_counts = Counter(words) # Filter the words that appear only once unique_words_list = [word for word in words if word_counts[word] == 1] return unique_words_list"},{"question":"You are given a list of integers `arr` representing the amount of time `N` students took to complete their respective tasks. You need to select a subset of students such that the difference between the maximum and minimum times of the selected subset is as small as possible, and the size of the subset is exactly `K` (where `K` is a given integer and 1 <= K <= N). Return _the minimum difference between the maximum and minimum times among all possible subsets of size `K`_.","solution":"def min_difference(arr, K): Returns the minimum difference between the maximum and minimum times among all possible subsets of size K. if K > len(arr): raise ValueError(\\"K should not be greater than the length of the array\\") arr.sort() min_diff = float(\'inf\') for i in range(len(arr) - K + 1): diff = arr[i + K - 1] - arr[i] if diff < min_diff: min_diff = diff return min_diff"},{"question":"You are given a matrix of integers `grid` where each row is sorted in non-decreasing order. Implement a function that returns the k-th smallest element in the matrix. You can assume `k` is always valid, 1 ≤ k ≤ n^2 where n is the number of rows (and columns) of the matrix. The matrix is of size `n x n`. Implement the `kthSmallest` function that takes the matrix `grid` and integer `k` as inputs and returns an integer representing the k-th smallest element in the matrix.","solution":"import heapq def kthSmallest(grid, k): Returns the k-th smallest element in the sorted matrix. n = len(grid) min_heap = [] # Add the first column of the matrix to the heap for r in range(min(k, n)): # only need first k rows min_heap.append((grid[r][0], r, 0)) heapq.heapify(min_heap) # Remove the minimum elements from the heap k times for _ in range(k - 1): smallest, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (grid[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"You are given a list of strings `strs` where each string consists of lower case English letters. Two strings are considered anagrams if they can be formed by rearranging the letters of each other. Write a function that groups the anagrams together. Return a list of lists, where each sublist contains strings that are anagrams of each other, ordered lexicographically within each sublist. The sublists themselves can be in any order.","solution":"from collections import defaultdict def group_anagrams(strs): Groups anagrams together and returns a list of lists with grouped anagrams, sorted lexicographically within each sublist. Args: strs (list of str): The list of strings to be grouped. Returns: list of lists of str: Grouped anagrams. # Dictionary to hold groups of anagrams anagrams = defaultdict(list) # Group anagrams by sorted tuple of characters for s in strs: key = tuple(sorted(s)) anagrams[key].append(s) # Sort each group lexicographically for key in anagrams: anagrams[key].sort() # Return the list of grouped anagrams return list(anagrams.values())"},{"question":"You are given a list of `n` integers `nums` representing the heights of n people standing in a straight line. The heights are not necessarily unique. Rearrange the integers in the list such that the tallest person is on one end of the list, and the shortest person is on the other end, with heights in a non-decreasing order in between. Return the rearranged list. If there are multiple valid arrangements, return any one of them.","solution":"def rearrange_heights(nums): Rearranges the list of heights such that the tallest person is on one end, the shortest person is on the other end, with heights in non-decreasing order in between. if not nums: return nums sorted_heights = sorted(nums) sorted_heights.insert(0, sorted_heights.pop(-1)) # Moving the tallest to the start return sorted_heights"},{"question":"Given an integer array `plants` where each element represents the amount of water needed by a plant and an integer `capacity` representing the watering can\'s capacity: - You water the plants in order from left to right. - Once you reach a plant, you water it, and the amount of water in your can decreases by the required amount. If you cannot fully water the next plant due to insufficient water, you must return to the starting point and refill the can. - Continue this process until all plants are watered. Return the _minimum number of refills_ needed to water all the plants.","solution":"def min_refills(plants, capacity): Calculate the minimum number of refills needed to water all the plants. Parameters: plants - list of ints, where each int represents the amount of water needed by a plant. capacity - int, represents the capacity of the watering can. Returns: int - minimum number of refills needed. refills = 0 current_water = capacity for i in range(len(plants)): if plants[i] <= current_water: current_water -= plants[i] else: refills += 1 current_water = capacity - plants[i] return refills"},{"question":"You are given an array of `n` integers, where each integer represents the frequency of a particular element. The array follows a specific rule: every element except one appears an even number of times, while one element appears an odd number of times. Your task is to identify and return the element that appears an odd number of times. You must implement a solution with a time complexity of O(n) and a space complexity of O(1).","solution":"def find_odd_frequency_element(arr): Returns the element that appears an odd number of times in the input array. Args: arr (list): List of integers where every element except one appears an even number of times. Returns: int: The element that appears an odd number of times. result = 0 for num in arr: result ^= num # XOR operation will result in the odd frequency element return result"},{"question":"Design a data structure that supports the following operations in average O(1) time complexity: 1. `insert(val)`: Inserts a value `val` to the set if it is not already present. 2. `remove(val)`: Removes a value `val` from the set if it is present. 3. `getRandom()`: Returns a random element from the set. Each element must have the same probability of being returned. Implement the `RandomizedSet` class: ```python class RandomizedSet: def __init__(self): # Your initialization here def insert(self, val: int) -> bool: # Inserts a value to the set. Returns true if the set did # not already contain the specified element. def remove(self, val: int) -> bool: # Removes a value from the set. Returns true if the set # contained the specified element. def getRandom(self) -> int: # Get a random element from the set. ``` **Note:** You must support each function with an average time complexity of O(1).","solution":"import random class RandomizedSet: def __init__(self): Initialize your data structure here. self.vals = [] self.vals_map = {} def insert(self, val: int) -> bool: Inserts a value to the set. Returns true if the set did not already contain the specified element. if val in self.vals_map: return False self.vals.append(val) self.vals_map[val] = len(self.vals) - 1 return True def remove(self, val: int) -> bool: Removes a value from the set. Returns true if the set contained the specified element. if val not in self.vals_map: return False index = self.vals_map[val] last_element = self.vals[-1] self.vals[index] = last_element self.vals_map[last_element] = index self.vals.pop() del self.vals_map[val] return True def getRandom(self) -> int: Get a random element from the set. return random.choice(self.vals)"},{"question":"You are given an array `arr` of `n` integers, where all integers are unique. The array can be rotated at any pivot, meaning the order of the elements can be changed by placing any element at the start and rearranging the rest accordingly. Your task is to find the *maximum* sum of the products of corresponding elements from two identical `n`-length arrays `A` and `B`, where `B` is a rotation of `A`. Formally, given the array `A`, you need to compute the maximum value of the sum `A[i] * B[i]` where `B` is a rotation of `A`. Return the maximum sum.","solution":"def max_sum_of_product(arr): Returns the maximum sum of the products of corresponding elements from two identical n-length arrays A and B, where B is a rotation of A. n = len(arr) arr_sorted = sorted(arr) # Calculate the maximum sum by using the sorted array max_sum = 0 for i in range(n): max_sum += arr_sorted[i] * arr_sorted[i] return max_sum"},{"question":"You are given a list of integers and a target integer `t`. Design an algorithm to determine if there exists a continuous subarray (of size at least one) within the list that sums up to `t`. If such a subarray exists, return `true`; otherwise, return `false`. Implement the following method: * `boolean hasSubarrayWithSum(int[] nums, int t)` where `nums` is the list of integers and `t` is the target sum.","solution":"def has_subarray_with_sum(nums, t): Determines if there exists a continuous subarray within nums that sums up to t. Args: nums: List of integers. t: Target sum. Returns: True if such a subarray exists, otherwise False. current_sum = 0 sum_set = set() sum_set.add(0) for num in nums: current_sum += num if current_sum - t in sum_set: return True sum_set.add(current_sum) return False"},{"question":"Given an array of integers `heights` representing the heights of trees in a forest, and an integer `k`, your task is to return the **maximum height** you can obtain by cutting down exactly `k` trees. You are allowed to cut down any `k` trees, and the height of the forest is determined by the height of the tallest tree left standing. If the array has less than `k` elements, return `-1`. For example, if `heights = [3, 9, 7, 4, 2]` and `k = 2`, you can cut down the two tallest trees (with heights 9 and 7), leaving trees with heights [3, 4, 2]. The maximum height of the forest will be 4. Therefore, the function should return `4`.","solution":"def max_height_after_cut(heights, k): Returns the maximum height of the remaining forest after cutting down exactly k trees. If k is greater than the number of trees, return -1. if k > len(heights): return -1 # Sort the heights in descending order sorted_heights = sorted(heights, reverse=True) # Remove the top k elements heights_after_cut = sorted_heights[k:] # The maximum height of the remaining trees if not heights_after_cut: return 0 # If no trees left, height is 0 return max(heights_after_cut)"},{"question":"You are given two non-empty arrays `nums1` and `nums2` of integers, where each array is sorted in **non-decreasing order**. Merge the two arrays into a single array that is sorted in non-decreasing order and return it. You must not use any extra space and modify the arrays in-place.","solution":"def merge(nums1, m, nums2, n): Merges two sorted arrays nums1 and nums2. Args: nums1 (List[int]): First sorted array with additional space at the end to merge nums2 m (int): Number of initial elements in nums1 nums2 (List[int]): Second sorted array n (int): Number of elements in nums2 # Last index of nums1 last = m + n - 1 # Start from the ends of nums1 and nums2 and merge in reverse order while m > 0 and n > 0: if nums1[m - 1] > nums2[n - 1]: nums1[last] = nums1[m - 1] m -= 1 else: nums1[last] = nums2[n - 1] n -= 1 last -= 1 # Add remaining elements of nums2 if any while n > 0: nums1[last] = nums2[n - 1] n -= 1 last -= 1"},{"question":"You are given an array of integers `nums` representing the inorder traversal of a binary search tree. Create the binary search tree from this traversal, and return its root. A binary search tree is a binary tree in which for every node, values in its left subtree are smaller and values in its right subtree are greater. You are required to construct the tree maintaining the properties of binary search trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_bst_from_inorder(nums): Construct binary search tree from the given inorder traversal list. if not nums: return None def build(nums, left, right): if left > right: return None # Midpoint to split the nums array mid = (left + right) // 2 # Root node for this subtree root = TreeNode(nums[mid]) # Recursively build the left and right subtrees root.left = build(nums, left, mid - 1) root.right = build(nums, mid + 1, right) return root return build(nums, 0, len(nums) - 1)"},{"question":"You are given a list of intervals where each interval is represented as `[start, end]`. Two intervals overlap if they have at least one common point. Return the minimum number of intervals you need to remove from the list so that the rest of the intervals do not overlap.","solution":"def erase_overlap_intervals(intervals): Returns the minimum number of intervals to remove so that the rest of the intervals do not overlap. :param intervals: List of intervals as [start, end] :returns: Minimum number of intervals to remove # Sort the intervals by their end time intervals.sort(key=lambda x: x[1]) # Initialize the end time of the first interval end = float(\'-inf\') # Counter for the non-overlapping intervals non_overlap_count = 0 for interval in intervals: if interval[0] >= end: # No overlap, move the end time to the end of the current interval end = interval[1] non_overlap_count += 1 # The number of intervals to remove is the total number of intervals minus the count of non-overlapping intervals return len(intervals) - non_overlap_count"},{"question":"You are given a 2D grid of size `n x n` representing a maze. Each cell in the maze can either be empty or blocked. You are also given two points, a start point `(start_x, start_y)` and an end point `(end_x, end_y)`. Your task is to determine if there is a **path** from the start point to the end point. You can move up, down, left, or right through empty cells. Return `true` if there is a path, otherwise return `false`. Implement the function `boolean hasPath(int[][] maze, int[] start, int[] destination)`: * `maze`: a 2D integer array representing the grid, where `0` represents an empty cell that you can walk through, and `1` represents a blocked cell that you cannot walk through. * `start`: an integer array representing the starting point `[start_x, start_y]`. * `destination`: an integer array representing the destination point `[end_x, end_y]`. The function should return a boolean indicating whether there is a path from `start` to `destination`.","solution":"def hasPath(maze, start, destination): def is_valid(x, y): return 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] == 0 def dfs(x, y): if not is_valid(x, y) or visited[x][y]: return False if (x, y) == (destination[0], destination[1]): return True visited[x][y] = True for dir_x, dir_y in [(-1,0), (1,0), (0,-1), (0,1)]: next_x, next_y = x, y # Move in one direction until hitting a wall or boundary while is_valid(next_x + dir_x, next_y + dir_y): next_x += dir_x next_y += dir_y if dfs(next_x, next_y): return True return False visited = [[False] * len(maze[0]) for _ in range(len(maze))] return dfs(start[0], start[1])"},{"question":"You are given an initially empty stack. Implement a data structure that supports the following operations: * `void push(int x)` -- Push element x onto the stack. * `int pop()` -- Removes the element on the top of the stack and returns that element. * `int top()` -- Get the top element. * `int getMin()` -- Retrieve the minimum element in the stack. **Note:** All operations must perform in constant time.","solution":"class MinStack: def __init__(self): Initialize your data structure here. self.stack = [] self.min_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> int: if self.stack: popped = self.stack.pop() if popped == self.min_stack[-1]: self.min_stack.pop() return popped def top(self) -> int: if self.stack: return self.stack[-1] def getMin(self) -> int: if self.min_stack: return self.min_stack[-1]"},{"question":"You are given a `linked list` where each node contains an integer value. The linked list might have a `cycle`, where a node\'s next pointer points back to a previous node, forming a loop. Your task is to determine if the linked list has a cycle in it. If there is a cycle, return _the node_ where the cycle begins. If there is no cycle, return `null`. To complete this task, define a function `detectCycle(head: ListNode) -> ListNode` where `head` is the head of the linked list. You are not allowed to modify the linked list. Use `O(1)` (i.e., constant) memory. For example: ```plaintext Input: head = [3,2,0,-4], pos = 1 (which means tail connects to the second node) Output: node with value 2 Explanation: There is a cycle in the linked list, where the tail connects to the second node. ```","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head: ListNode) -> ListNode: Detects if there is a cycle in the linked list. If there is a cycle, returns the node where the cycle begins. Otherwise, returns None. if not head or not head.next: return None slow = head fast = head # Using the Floyd’s Tortoise and Hare algorithm to find if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected, find the entry point of the cycle entry = head while slow != entry: slow = slow.next entry = entry.next return entry return None"},{"question":"Given an integer array `arr` and an integer `d`, you must select a subsequence from the array such that the absolute difference between any two consecutive elements in the subsequence is less than or equal to `d`. Return _the length of the **longest** possible subsequence that can be chosen under these constraints_. If there is no valid subsequence, return `0`.","solution":"def longest_subsequence(arr, d): if not arr: return 0 n = len(arr) dp = [1] * n # dp[i] is the length of longest subsequence ending at index i for i in range(1, n): for j in range(i): if abs(arr[i] - arr[j]) <= d: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given an integer array `arr`, where each element represents the height of a building. A building is deemed **visible** if there are no taller buildings to its right. The rightmost building is always visible. Return _the **number of visible buildings** from right to left_ in the given array.","solution":"def count_visible_buildings(arr): Returns the number of visible buildings from right to left. Args: arr (list): List of integers where each integer represents the height of a building. Returns: int: Number of visible buildings. count = 0 max_height = float(\'-inf\') for height in reversed(arr): if height > max_height: count += 1 max_height = height return count"},{"question":"Given an array of integers `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same, and you should not use extra space (an O(1) space complexity solution is required). Return the number of unique elements that remain in `nums` after duplicates have been removed. For example: - If `nums` is `[1, 1, 2]`, after removing duplicates, it should become `[1, 2, _]` and the function should return `2`. - If `nums` is `[0,0,1,1,1,2,2,3,3,4]`, after removing duplicates, it should become `[0, 1, 2, 3, 4, _, _, _, _, _]` and the function should return `5`. The underscore `_` in the examples represents values beyond the new length that are irrelevant.","solution":"def remove_duplicates(nums): Removes duplicates in-place in the sorted array nums and returns the number of unique elements. Args: nums (List[int]): A list of integers sorted in non-decreasing order. Returns: int: The number of unique elements that remain. if not nums: return 0 unique_count = 1 # start with the first element which is always unique for i in range(1, len(nums)): if nums[i] != nums[unique_count - 1]: nums[unique_count] = nums[i] unique_count += 1 return unique_count"},{"question":"You are given an array of integers `heights` representing the height of buildings in a row. The task is to identify the **skyline contour** formed by these buildings. The **skyline** is represented by a list of \\"key points\\" in the format `[x, y]` where `x` is the x-coordinate of a key point and `y` is the height at that point. The key points should form a stair-like outline of the buildings when viewed from a distance. The highest points should create the contour, while changes in height and the start/end of buildings should be captured. Return _the `skyline` of the row of buildings in the form of a list of key points sorted by their x-coordinates_.","solution":"def get_skyline(heights): Returns the skyline contour formed by a list of building heights. if not heights: return [] skyline = [] max_height = 0 for i, height in enumerate(heights): if height != max_height: skyline.append([i, height]) max_height = height # Append the point where the last building ends skyline.append([len(heights), 0]) return skyline"},{"question":"You are given a list of integers `nums` and a target integer `target`. You can perform any of the following operations on the list: 1. Increase any element by 1. 2. Decrease any element by 1. 3. Remove any element. Return the minimum number of operations required to make the sum of the elements in the list equal to `target`. If it is not possible, return -1.","solution":"def min_operations(nums, target): Returns the minimum number of operations required to make the sum of the elements in the list equal to target. If it is not possible, returns -1. The allowed operations are: 1. Increase any element by 1. 2. Decrease any element by 1. 3. Remove any element. current_sum = sum(nums) # If we need to remove elements because the sum is greater than the target if current_sum >= target: return current_sum - target # If the sum of all elements is less than the target, we need to add up the deficit. # Calculate the deficit deficit = target - current_sum return deficit"},{"question":"You are given a `0-indexed` integer array `arr` representing the daily temperatures recorded for `n` consecutive days. The temperature on the `i-th` day is represented by `arr[i]`. Implement a method that returns an array `answer` such that `answer[i]` is the number of days you have to wait after the `i-th` day to get a higher temperature. If there is no future day for which this is possible, put `0` instead. Implement the `TemperatureTracker` class: - `TemperatureTracker(int[] arr)` Initializes the class with the daily temperatures recorded. - `int[] waitDaysForHigherTemperature()` Returns an array where each element represents the number of days to wait for a warmer temperature compared to the current day.","solution":"from typing import List class TemperatureTracker: def __init__(self, arr: List[int]): self.temperatures = arr def waitDaysForHigherTemperature(self) -> List[int]: n = len(self.temperatures) answer = [0] * n stack = [] # This will store the indices of the temperatures array for i in range(n): while stack and self.temperatures[i] > self.temperatures[stack[-1]]: idx = stack.pop() answer[idx] = i - idx stack.append(i) return answer"},{"question":"You are given a **binary tree** with `n` nodes, where each node has a unique identifier from `1` to `n`. Each node also has an additional attribute `value` which is an integer. Identify the **largest sum** of node values in any of the **root-to-leaf paths** in the tree. Return _the largest sum you can obtain swithin such a path_.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_path_sum(root): def helper(node): if not node: return 0 left_sum = helper(node.left) right_sum = helper(node.right) return node.val + max(left_sum, right_sum) return helper(root)"},{"question":"You are given an empty 2D binary grid of size `n x n`. Perform the following operations: 1. Add a value `1` to a cell of the grid. 2. Remove a value `1` from a cell of the grid (turning it back to `0`). 3. Determine if there is a path of 1s from the top-left corner (0,0) to the bottom-right corner (n-1,n-1). A path consists of adjacent cells (horizontally or vertically) that contain the value `1`. Implement the three functions `add_value(x, y)`, `remove_value(x, y)`, and `has_path()` where: - `add_value(x, y)` adds a 1 to the cell at position (x, y). - `remove_value(x, y)` removes the 1 from the cell at position (x, y). - `has_path()` checks if there\'s a path of 1s from (0, 0) to (n-1, n-1). Return `True` if such a path exists, else return `False`. Use an efficient algorithm to ensure that the path detection is optimized given the possible frequent modification of the grid.","solution":"class Grid: def __init__(self, n): self.n = n self.grid = [[0 for _ in range(n)] for _ in range(n)] def add_value(self, x, y): self.grid[x][y] = 1 def remove_value(self, x, y): self.grid[x][y] = 0 def has_path(self): if self.grid[0][0] == 0 or self.grid[self.n-1][self.n-1] == 0: return False visited = [[False for _ in range(self.n)] for _ in range(self.n)] return self._dfs(0, 0, visited) def _dfs(self, x, y, visited): if x == self.n-1 and y == self.n-1: return True visited[x][y] = True for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]: nx, ny = x + dx, y + dy if 0 <= nx < self.n and 0 <= ny < self.n and not visited[nx][ny] and self.grid[nx][ny] == 1: if self._dfs(nx, ny, visited): return True return False"},{"question":"You are given an integer array `nums` and an integer `k`. Return the _maximum sum of a subarray of length `k`_. A **subarray** is defined as a contiguous portion of the array. If `k` is larger than the length of the array, return `0`. The answer is **guaranteed** to fit into a signed **32-bit** integer.","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of a subarray of length k. If k is larger than the length of the array, returns 0. n = len(nums) if k > n: return 0 # Calculate the sum of the first subarray of length k max_sum = sum(nums[:k]) current_sum = max_sum # Use sliding window to find maximum sum of subarray of length k for i in range(k, n): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a binary tree with `n` nodes, where each node has a unique value between `1` and `n`. The nodes are structured in a way that some nodes have exactly two children, which are direct successors of said node, while leaf nodes do not have any children. Each node contains a value, and these values are unique in the binary tree. Your task is to serialize the binary tree into a string using pre-order traversal (Node -> Left Subtree -> Right Subtree). If the tree is empty, return an empty string. Serialize the tree such that each node value is followed by a comma, and there should be no trailing commas. __Note:__ Assume the binary tree is provided in the form of a root node reference of a tree structure definition.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def serialize_preorder(root): if not root: return \\"\\" result = [] def preorder(node): if node: result.append(str(node.value)) preorder(node.left) preorder(node.right) preorder(root) return \\",\\".join(result)"},{"question":"A robot is placed on a grid with `m` rows and `n` columns. The robot can move either one step to the right or one step down. Starting from the top-left corner of the grid, the robot needs to reach the bottom-right corner. Calculate the number of unique paths that the robot can take to reach from the top-left corner to the bottom-right corner.","solution":"def unique_paths(m, n): Calculate the number of unique paths for a robot to move from the top-left corner to the bottom-right corner of a grid with m rows and n columns. The robot can only move either down or right at any point in time. Args: m (int): Number of rows in the grid. n (int): Number of columns in the grid. Returns: int: Number of unique paths to reach the bottom-right corner. # Create a 2D array (list of lists) with m rows and n columns initialized to 1 dp = [[1] * n for _ in range(m)] # Start from cell (1, 1) and fill the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] # The bottom-right corner will have the answer return dp[m - 1][n - 1]"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. Your goal is to perform `k` transformations on the string, where in each transformation, you can: - Select a character in the string and replace it with any other lowercase English letter. After performing exactly `k` transformations, return _the length of the longest substring with all identical characters_ in the resulting string.","solution":"def longest_substring_with_replacements(s, k): Returns the length of the longest substring with all identical characters after exactly `k` transformations by replacing any characters in the string `s`. from collections import defaultdict def max_length_with_char_replacements(char): left, max_len, max_count = 0, 0, 0 count = defaultdict(int) for right in range(len(s)): if s[right] == char: max_count += 1 count[s[right]] += 1 while (right - left + 1 - max_count) > k: if s[left] == char: max_count -= 1 count[s[left]] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len result = 0 for char in \\"abcdefghijklmnopqrstuvwxyz\\": result = max(result, max_length_with_char_replacements(char)) return result"},{"question":"Given a `2D` grid `matrix` of size `m x n` consisting of non-negative integers, determine the length of the **shortest path** from the top-left cell `(0, 0)` to the bottom-right cell `(m-1, n-1)` such that the sum of all elements along the path is less than or equal to `k`. You can only move either down or right at any point in time. If there is no such path, return `-1`.","solution":"from collections import deque def shortest_path(matrix, k): Determines the shortest path from the top-left cell to the bottom-right cell such that the sum of the path is less than or equal to k. if not matrix or not matrix[0]: return -1 m, n = len(matrix), len(matrix[0]) directions = [(0, 1), (1, 0)] queue = deque([(0, 0, matrix[0][0], 1)]) visited = set([(0, 0, matrix[0][0])]) while queue: x, y, current_sum, path_length = queue.popleft() if x == m - 1 and y == n - 1: if current_sum <= k: return path_length for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: next_sum = current_sum + matrix[nx][ny] if next_sum <= k and (nx, ny, next_sum) not in visited: visited.add((nx, ny, next_sum)) queue.append((nx, ny, next_sum, path_length + 1)) return -1"},{"question":"You are given an array `points` where `points[i] = [xi, yi]` represents the coordinates of a point on a 2D plane. Find and return the **minimum** number of moves required to move from the first point to the last point in the array, visiting each point in the order given. A move consists of traveling from one point to another in a straight line. However, you can only travel to a point having a positive slope with respect to your current point. If it is not possible to move in a positive slope to the next point, return `-1`.","solution":"def min_moves_with_positive_slope(points): Returns the minimum number of moves required to move from the first point to the last point in the array, visiting each point in the order given with only positive slope allowed. n = len(points) moves = 0 for i in range(n - 1): if points[i+1][0] > points[i][0] and points[i+1][1] > points[i][1]: moves += 1 else: return -1 return moves"},{"question":"You are given a list of integers representing the heights of buildings in a cityscape where the width of each building is 1. It is raining, and you need to determine how much water can be trapped between the buildings after it rains. Implement a function `trapRainWater(int[] height)` that returns the total amount of rainwater trapped, according to the elevation map given by the `height` list. The width of each bar is 1.","solution":"def trapRainWater(height): Given a list of integers representing the heights of buildings, calculate how much water can be trapped between the buildings after it rains. :param height: List[int] - List of non-negative integers representing the heights of the buildings. :return: int - Total amount of rainwater trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"A **Robot Cleaner** is cleaning a rectangular grid. The grid is represented by a 2D integer array `room` where `room[i][j]` can be `0` (an empty cell) or `1` (an obstacle). The robot starts at a specified location `(startRow, startCol)` in the room and is initially facing `north`. The movements of the robot are limited to: * **Move**: The robot moves one step forward in the direction it is facing. If the cell it moves to is an obstacle or it goes out of bounds, the robot stays in the current cell. * **Turn Left**: The robot turns 90 degrees to its left. * **Turn Right**: The robot turns 90 degrees to its right. The robot must clean the room by visiting every empty cell at least once, recording the cells it visits as `visited`. You need to implement the `RobotCleaner` class to simulate this behavior: - `RobotCleaner(int[][] room, int startRow, int startCol)`: Initializes the robot in the room with the given starting position. - `void move()`: Commands the robot to move one step forward. - `void turnLeft()`: Commands the robot to turn left. - `void turnRight()`: Commands the robot to turn right. - `int[] getPosition()`: Returns the current position of the robot as an array `[currentRow, currentCol]`. - `boolean isVisited(int row, int col)`: Returns `true` if the robot has visited the cell at `(row, col)` at least once, `false` otherwise. The robot should continue cleaning until it has visited all the empty cells that can be reached starting from the initial position.","solution":"class RobotCleaner: def __init__(self, room, startRow, startCol): self.room = room self.currentRow = startRow self.currentCol = startCol self.visited = set() self.visited.add((startRow, startCol)) self.directions = [\\"north\\", \\"east\\", \\"south\\", \\"west\\"] self.currentDirection = 0 # Start by facing north self.move_dir = { \\"north\\": (-1, 0), \\"east\\": (0, 1), \\"south\\": (1, 0), \\"west\\": (0, -1) } self.clean() def move(self): # Calculate the next position direction = self.directions[self.currentDirection] drow, dcol = self.move_dir[direction] newRow, newCol = self.currentRow + drow, self.currentCol + dcol # Check if it\'s within bounds and not an obstacle if 0 <= newRow < len(self.room) and 0 <= newCol < len(self.room[0]) and self.room[newRow][newCol] == 0: self.currentRow = newRow self.currentCol = newCol self.visited.add((newRow, newCol)) def turnLeft(self): self.currentDirection = (self.currentDirection - 1) % 4 def turnRight(self): self.currentDirection = (self.currentDirection + 1) % 4 def getPosition(self): return [self.currentRow, self.currentCol] def isVisited(self, row, col): return (row, col) in self.visited def clean(self): # Use DFS to clean all reachable parts of the room self.dfs(self.currentRow, self.currentCol) def dfs(self, row, col): self.visited.add((row, col)) for _ in range(4): self.move() newRow, newCol = self.getPosition() if (newRow, newCol) not in self.visited: self.dfs(newRow, newCol) # Move back to original position self.turnRight() self.turnRight() self.move() self.turnLeft() self.turnLeft() # Turn to original direction self.turnRight()"},{"question":"Given a string `s` and a list of strings `words`, return the **number of distinct subsequences** of `s` that are equal to any string in `words`. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. For example, given `s = \\"abcde\\"` and `words = [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"]`, the answer is `3` since there are three subsequences in `s` that match strings in `words`: `\\"a\\"`, `\\"acd\\"`, and `\\"ace\\"`.","solution":"def num_distinct_subseq(s, words): from collections import defaultdict def is_subsequence(x, y): it = iter(y) return all(c in it for c in x) word_dict = defaultdict(int) for word in words: word_dict[word] += 1 distinct_count = 0 for word in word_dict: if is_subsequence(word, s): distinct_count += 1 return distinct_count"},{"question":"Given a list `words` of strings and a string `target`, return the minimum number of adjacent swaps required to bring all occurrences of `target` together in the `words` list. If `target` does not exist in the list, return `-1`.","solution":"def min_swaps_to_bring_target_together(words, target): Returns the minimum number of adjacent swaps required to bring all occurrences of `target` together in the `words` list. If `target` does not exist in the list, returns `-1`. :param words: List of strings :param target: Target string to bring together :return: Minimum number of adjacent swaps or -1 if target not present in list positions = [i for i, word in enumerate(words) if word == target] if not positions: return -1 median_idx = len(positions) // 2 median_position = positions[median_idx] swaps = 0 for i, pos in enumerate(positions): swaps += abs(median_position - pos - (median_idx - i)) return swaps"},{"question":"You are given a `rectangular grid` of `m` rows and `n` columns where each cell is either: * `0` representing water * `1` representing land A **single island** is a connected component of **1\'s** formed by traversing north, south, east, and west (i.e., horizontal or vertical adjacency). You can assume all four edges of the grid are surrounded by water. Determine the `maximum area` of an island in the given grid. An island\'s area is the number of **1\'s** in that cluster. If there is no island, return `0`.","solution":"def maxAreaOfIsland(grid): Given a m x n grid of \'0\'s (water) and \'1\'s (land), returns the maximum area of an island in the grid. An island is a connected component of \'1\'s formed by traversing north, south, east, and west. def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 area = 1 area += dfs(x - 1, y) area += dfs(x + 1, y) area += dfs(x, y - 1) area += dfs(x, y + 1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"You are given a binary tree where each node contains an integer value. Your task is to determine if there exists a root-to-leaf path in the binary tree such that the sum of the values along the path equals a given target sum. Write a function `hasPathSum(root, targetSum)` that returns `true` if such a path exists, and `false` otherwise. The binary tree is defined with the following structure: ``` class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` Your function should handle edge cases where the tree is empty, or where no such path exists.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def hasPathSum(root, targetSum): Determines if there exists a root-to-leaf path in the binary tree such that the sum of the values along the path equals the targetSum. :param root: TreeNode, the root node of the binary tree :param targetSum: int, the target sum to find :return: bool, True if such a path exists, False otherwise if not root: return False if not root.left and not root.right: # Check if it is a leaf node return root.value == targetSum targetSum -= root.value return hasPathSum(root.left, targetSum) or hasPathSum(root.right, targetSum)"},{"question":"You are given two integer arrays `nums1` and `nums2` both of the same length. The advantage of `nums1[i]` relative to `nums2[i]` is defined as `nums1[i] - nums2[i]`. Rearrange `nums1` such that the sum of its advantages with respect to `nums2` is maximized. Return the rearranged array `nums1`.","solution":"def maximize_advantage(nums1, nums2): Rearrange nums1 to maximize the sum of advantages with respect to nums2. The advantage of nums1[i] relative to nums2[i] is defined as nums1[i] - nums2[i]. Args: nums1 (List[int]): The first list of integers to be rearranged. nums2 (List[int]): The second list of integers. Returns: List[int]: The rearranged nums1 array. nums1.sort() sorted_indices_nums2 = sorted(range(len(nums2)), key=lambda i: nums2[i]) result = [0] * len(nums1) lo, hi = 0, len(nums1) - 1 for num in nums1: if num > nums2[sorted_indices_nums2[lo]]: result[sorted_indices_nums2[lo]] = num lo += 1 else: result[sorted_indices_nums2[hi]] = num hi -= 1 return result"},{"question":"You are given an integer array `nums` that represents a sequence of non-negative integers. Your task is to determine if it is possible to split the array into two subsequences such that each subsequence is strictly increasing. A subsequence of an array is a new array generated by deleting some elements (possibly none) from the original array without changing the order of the remaining elements. If such a split is possible, return `true`. Otherwise, return `false`. For example, given `nums = [1, 3, 5, 2, 2, 7, 6]`, you can split it into `[1, 3, 5]` and `[2, 2, 7, 6]`.","solution":"from collections import defaultdict def can_split_into_two_increasing_subsequences(nums): Returns True if nums can be split into two strictly increasing subsequences, else False. # Dictionary to store frequency of each number frequency = defaultdict(int) for num in nums: frequency[num] += 1 tails = [] # List to store end elements of increasing subsequences for num in nums: # Add new subsequence or extend if possible found = False for i in range(len(tails)): if tails[i] < num: tails[i] = num found = True break if not found: tails.append(num) if len(tails) > 2: return False return True"},{"question":"You are given an integer array `arr` of length `n` representing the height of `n` stacked boxes. The height of a stack is the sum of the heights of individual boxes within that stack. You can separate or merge boxes to form a different configuration. The goal is to minimize the difference between the heights of the tallest and shortest stacks after re-arranging any number of boxes. Return the minimum possible difference between the height of the tallest and the shortest stacks.","solution":"def min_stack_height_difference(arr): total_sum = sum(arr) n = len(arr) dp = [False] * (total_sum // 2 + 1) dp[0] = True for num in arr: for j in range(total_sum // 2, num - 1, -1): if dp[j - num]: dp[j] = True for i in range(total_sum // 2, -1, -1): if dp[i]: s1 = i break s2 = total_sum - s1 return abs(s2 - s1)"},{"question":"You are given a string `s` representing an expression. You need to implement a basic calculator to evaluate the expression. The expression string contains only non-negative integers, `+`, `-`, `*`, `/` operators, and empty spaces. The integer division should truncate toward zero. Return _the result of evaluating the expression_. The given expression is assumed to be always valid. **Example**: - The expression `\\"3+2*2\\"` evaluates to `7`. - The expression `\\" 3/2 \\"` evaluates to `1`. - The expression `\\" 3+5 / 2 \\"` evaluates to `5`.","solution":"def calculate(s): Evaluates the string s which is a basic arithmetic expression containing only non-negative integers, +, -, *, / operators, and empty spaces. The integer division should truncate toward zero. # This is a stack-based approach num, stack, sign = 0, [], \\"+\\" s += \\"+0\\" for c in s: if c.isdigit(): num = num * 10 + int(c) elif c in \\"+-*/\\": if sign == \\"+\\": stack.append(num) elif sign == \\"-\\": stack.append(-num) elif sign == \\"*\\": stack.append(stack.pop() * num) elif sign == \\"/\\": stack.append(int(stack.pop() / num)) sign = c num = 0 return sum(stack)"},{"question":"Design and implement a data structure called `MinHeap` that supports adding elements, deleting the minimum element, and obtaining the minimum element efficiently. Implement the `MinHeap` class with the following methods: * `MinHeap()` Initializes the heap object. * `void insert(int x)` Inserts element `x` into the heap. * `int deleteMin()` Removes and returns the minimum element from the heap. * `int getMin()` Returns the minimum element from the heap without removing it. Your solution should ensure the following time complexities: * `insert`: O(log n) * `deleteMin`: O(log n) * `getMin`: O(1) You may assume that the heap will be used with only integer values.","solution":"import heapq class MinHeap: def __init__(self): Initializes the MinHeap object. self.heap = [] def insert(self, x: int): Inserts element x into the heap. :param x: integer to be inserted into the heap heapq.heappush(self.heap, x) def deleteMin(self) -> int: Removes and returns the minimum element from the heap. :return: the minimum element from the heap return heapq.heappop(self.heap) def getMin(self) -> int: Returns the minimum element from the heap without removing it. :return: the minimum element from the heap return self.heap[0]"},{"question":"You are given a list of non-negative integers `nums`. Each element in the list can be rounded up or down to the nearest multiple of a given integer `k`. Multiple rounding operations on the same element are allowed. Return the minimum possible sum of rounded elements after performing the rounding operations on each element in the list.","solution":"def min_rounded_sum(nums, k): Returns the minimum possible sum of elements in nums after rounding each element to the nearest multiple of k. Parameters: nums (List[int]): List of non-negative integers. k (int): The rounding base. Returns: int: The minimum possible sum of rounded elements. def round_down(n, k): return (n // k) * k return sum(round_down(num, k) for num in nums)"},{"question":"You are given a list of strings `words` and a string `s`. A word is considered a **prefix** of string `s` if it can be found at the beginning of `s`. A prefix must be a non-empty string that is originally present in `words` and exactly matches the initial segment of `s`. Return the **longest prefix** string from `words` that is a prefix of `s`. If there are multiple words of the same maximum length, return the one that appears first in the list `words`. If no such prefix exists, return an empty string.","solution":"def longest_prefix(words, s): Returns the longest word from the list \'words\' that is a prefix of the string \'s\'. If there are multiple prefixes of the same maximum length, returns the first one. If no prefix matches, returns an empty string. longest = \\"\\" for word in words: if s.startswith(word) and len(word) > len(longest): longest = word return longest"},{"question":"Given a string `s` containing only lowercase English letters, you can perform the following operations on any character in `s`: - Change `s[i]` to any of its neighboring characters (i.e., you can change \'a\' to \'b\', \'b\' to either \'a\' or \'c\', and so on up to \'z\' which can be changed to \'y\'). The cost of performing an operation on a character `s[i]` is defined as the absolute difference in their positions in the alphabet. Your task is to transform `s` into a palindrome with the minimum total cost. Return the minimum cost required to change `s` into a palindrome.","solution":"def min_cost_to_palindrome(s): Given a string s containing only lowercase English letters, return the minimum cost required to transform s into a palindrome. def char_distance(c1, c2): return abs(ord(c1) - ord(c2)) n = len(s) cost = 0 for i in range(n // 2): cost += char_distance(s[i], s[n - i - 1]) return cost"},{"question":"Given a string `s` containing only lowercase English letters, return an integer array `answer` where `answer` contains the number of occurrences of each letter in the alphabet. The array should be of size 26 where `answer[0]` represents the count of \'a\', `answer[1]` represents the count of \'b\', and so on up to `answer[25]` which represents the count of \'z\'. You can assume that the input string `s` will have at least one character and contain only lowercase English letters.","solution":"def count_letters(s): Returns an array of size 26 where each element represents the number of occurrences of a corresponding lowercase English letter in the string s. `answer[0]` is the count of \'a\', `answer[1]` is the count of \'b\', and so on. answer = [0] * 26 for char in s: answer[ord(char) - ord(\'a\')] += 1 return answer"},{"question":"Given a string `s` and an integer array `indices` of the same length, the task is to shuffle the characters in the string such that the character at the `i-th` position moves to `indices[i]` in the shuffled string. Return the shuffled string. Write an efficient algorithm to achieve this.","solution":"def restore_string(s, indices): Shuffles the characters in the string `s` based on the given `indices` array. Parameters: s (str): The original string. indices (List[int]): List of indices representing the position of each character in the shuffled string. Returns: str: The shuffled string based on `indices`. # Create a list of the same length as s initialized with empty strings shuffled = [\'\'] * len(s) # Assign each character to its new position based on the indices array for i, index in enumerate(indices): shuffled[index] = s[i] # Combine the list into a single string and return return \'\'.join(shuffled)"},{"question":"You are given a 2D `grid` of size `m x n` where each cell represents either water (`\'W\'`) or land (`\'L\'`). An **island** is a group of contiguous `\'L\'` cells connected horizontally or vertically. You need to find and return the number of distinct islands in the grid. Two islands are considered distinct if one is not identical to the other (not considering rotations or reflections). Write a function `numDistinctIslands(grid: List[List[str]]) -> int:` that takes a 2D list of characters representing the grid and returns the number of distinct islands.","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in the grid. def dfs(r, c, direction): if (0 <= r < m and 0 <= c < n and grid[r][c] == \'L\' and (r, c) not in visited): visited.add((r, c)) shape.add(direction) dfs(r + 1, c, \'D\') # down dfs(r - 1, c, \'U\') # up dfs(r, c + 1, \'R\') # right dfs(r, c - 1, \'L\') # left shape.add(\'B\') # backtracking m, n = len(grid), len(grid[0]) visited = set() unique_islands = set() for r in range(m): for c in range(n): if grid[r][c] == \'L\' and (r, c) not in visited: shape = set() dfs(r, c, \'O\') # origin unique_islands.add(frozenset(shape)) return len(unique_islands)"},{"question":"You are given a **0-indexed** array `heights` representing the heights of students in a class. You need to arrange the students in non-decreasing order of their heights. However, you also need to ensure that no two students with adjacent heights are seated next to each other, as adjacent heights might cause measurement errors in a hypothetical height-measuring device. To achieve this, rearrange the array such that the absolute difference between the heights of any two students seated next to each other is always greater than 1. Return _**any** rearrangement of_ `heights` _that meets the requirements, or an empty array if it\'s not possible to achieve the arrangement._","solution":"def rearrange_heights(heights): Rearranges the list of heights such that no two adjacent heights differ by 1 or less. Returns an empty list if such an arrangement is not possible. heights.sort() n = len(heights) if n < 2: return heights for i in range(1, n): if heights[i] - heights[i-1] <= 1: break else: return heights left, right = heights[:n // 2], heights[n // 2:] rearranged = [] for r, l in zip(right, left): rearranged.append(r) rearranged.append(l) if n % 2 == 1: rearranged.append(right[-1]) for i in range(1, len(rearranged)): if abs(rearranged[i] - rearranged[i-1]) <= 1: return [] return rearranged"},{"question":"You are given an integer array `nums` sorted in non-decreasing order, and an integer `x`. Your task is to find if there exist two elements in the array whose sum equals `x`. Return `true` if such a pair exists, and `false` otherwise. You must implement an algorithm that runs in `O(n)` time.","solution":"def two_sum(nums, x): Given a sorted array nums and an integer x, returns True if there exist two elements in the array whose sum equals x, and False otherwise. Args: nums (List[int]): A sorted list of integers. x (int): The target sum. Returns: bool: True if such a pair exists, False otherwise. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == x: return True elif current_sum < x: left += 1 else: right -= 1 return False"},{"question":"Given a string `s` and an integer `k`, write a function to determine if you can rearrange the characters in `s` such that the same characters are at least `k` distance apart. If it is possible, return any one of the possible rearrangements. If it is not possible, return an empty string. Implement the `Solution` class: * `Solution(String s, int k)` Initializes the object with the string `s` and the integer `k`. * `String rearrange()` Returns a rearranged string where the same characters are at least `k` distance apart. If it is not possible to rearrange the string this way, return an empty string.","solution":"import heapq from collections import Counter class Solution: def __init__(self, s, k): self.s = s self.k = k def rearrange(self): if self.k == 0: return self.s count = Counter(self.s) max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) result = [] queue = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) queue.append((char, freq + 1)) if len(queue) >= self.k: front = queue.pop(0) if -front[1] > 0: heapq.heappush(max_heap, (front[1], front[0])) if len(result) != len(self.s): return \\"\\" return \\"\\".join(result)"},{"question":"Given an array of integers `arr`, you are required to implement a system that can efficiently handle multiple queries. Each query is of one of the following two types: 1. **Update**: Update the element at index `i` in the array to the value `val`. 2. **Sum Range**: Calculate and return the sum of the elements between indices `left` and `right` (inclusive). Implement a class `NumArray` with the following methods: * `NumArray(int[] arr)` Initializes the object with the integer array `arr`. * `void update(int i, int val)` Updates the element at index `i` to the value `val`. * `int sumRange(int left, int right)` Returns the sum of the elements between indices `left` and `right`.","solution":"class NumArray: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, i, val): # Update the value at the leaf node pos = self.n + i self.tree[pos] = val # Update the internal nodes while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def sumRange(self, left, right): l, r = self.n + left, self.n + right s = 0 while l <= r: if l % 2 == 1: s += self.tree[l] l += 1 if r % 2 == 0: s += self.tree[r] r -= 1 l //= 2 r //= 2 return s"},{"question":"Given a string `s` and an integer `n`, determine if the string can be transformed into a palindrome by inserting exactly `n` characters. Return `true` if it is possible to form a palindrome by inserting `n` characters, otherwise return `false`. Note that a palindrome is a string that reads the same backward as forward.","solution":"def can_transform_to_palindrome(s, n): Determines if the string `s` can be transformed into a palindrome by inserting exactly `n` characters. Args: s (str): The input string. n (int): The number of characters to be inserted. Returns: bool: True if the string can be transformed into a palindrome by inserting `n` characters, otherwise False. def longest_palindromic_subsequence_length(s): Helper function to find the length of the longest palindromic subsequence in a given string. l = len(s) dp = [[0] * l for _ in range(l)] for i in range(l): dp[i][i] = 1 for cl in range(2, l + 1): for i in range(l - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][l-1] lps_length = longest_palindromic_subsequence_length(s) min_insertions = len(s) - lps_length return min_insertions == n"},{"question":"You are given a string `s` consisting of lowercase English letters. A substring is considered valid if it contains at most two distinct characters. Return _the length of the longest valid substring_. For example, if the input string is `\\"eceba\\"`, the longest valid substring is `\\"ece\\"`, with the length being `3`. If the input string is `\\"ccaabbb\\"`, the longest valid substring is `\\"aabbb\\"`, with the length being `5`.","solution":"def longest_valid_substring(s): Returns the length of the longest valid substring which contains at most two distinct characters. if not s: return 0 max_len = 0 left = 0 char_count = {} for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given an array of integers `nums` and a positive integer `k`, return the maximum sum of any contiguous subarray of length `k`. If there are fewer than `k` elements in the array, return `0`. The array can contain both positive and negative integers. Use the sliding window technique to achieve an efficient solution with O(n) time complexity.","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of any contiguous subarray of length `k`. If there are fewer than `k` elements in the array, return `0`. n = len(nums) if n < k: return 0 max_sum = current_sum = sum(nums[:k]) for i in range(k, n): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an array of integers `nums`. A **partition** of this array is an arrangement of its elements into one or more subarrays, such that the concatenation of these subarrays is equal to the original array and each subarray is sorted in **non-decreasing order**. Return _the minimum number of subarrays required to partition_ `nums` _in such a way that each subarray is sorted in non-decreasing order_. For example, given the array `nums = [1, 3, 2, 4, 5]`, one possible partition could be `[[1, 3], [2, 4, 5]]`, and the minimum number of subarrays needed would be `2`.","solution":"def min_partitions(nums): Returns the minimum number of subarrays required to partition \'nums\' such that each subarray is sorted in non-decreasing order. if not nums: return 0 partitions = 1 for i in range(1, len(nums)): if nums[i] < nums[i - 1]: partitions += 1 return partitions"},{"question":"Design a data structure that simulates an order system for a restaurant. Implement the `OrderSystem` class, which allows customers to place and cancel orders, and for the restaurant to fulfill orders in the sequence they were placed: * `void placeOrder(int orderId, string dishName)` * Places an order with a unique `orderId` for the specified `dishName`. * `void cancelOrder(int orderId)` * Cancels an order with the given `orderId` if it exists. * `string fulfillOrder()` * Fulfills the order that was placed first and returns the name of the dish. * If no orders are left, it should return the empty string. The system should ensure that orders are fulfilled in the same sequence they were placed and that cancelling an order removes it from the sequence without affecting the remaining orders.","solution":"from collections import deque class OrderSystem: def __init__(self): self.orders = deque() self.order_map = {} def placeOrder(self, orderId, dishName): if orderId not in self.order_map: self.orders.append(orderId) self.order_map[orderId] = dishName def cancelOrder(self, orderId): if orderId in self.order_map: self.orders.remove(orderId) del self.order_map[orderId] def fulfillOrder(self): if self.orders: orderId = self.orders.popleft() dishName = self.order_map.pop(orderId) return dishName return \\"\\""},{"question":"You are given an array `arr` of size `n` consisting of positive integers, and an integer `k`. Write a function to find the **minimum number** of subarrays of `arr` such that the **maximum sum** of any subarray does not exceed `k`. If it\'s impossible to divide `arr` in such a way, return `-1`.","solution":"def min_subarrays(arr, n, k): Return the minimum number of subarrays such that the maximum sum of any subarray does not exceed k. If it\'s impossible to divide arr in such a way, return -1. if max(arr) > k: return -1 subarrays_count = 1 current_sum = 0 for num in arr: if current_sum + num > k: subarrays_count += 1 current_sum = num else: current_sum += num return subarrays_count"},{"question":"Imagine you are building a web service to manage a dynamic leaderboard. The leaderboard needs to support the following functionalities: adding a new score for a player, top `K` scores query, and reassigning the rank after every update to the score. Write a class `Leaderboard` that supports the following operations: * `Leaderboard` initializes the leaderboard object. * `void addScore(int playerId, int score)` adds a `score` to the `playerId` if already present, otherwise initializes the player with the given `score`. * `List<Integer> top(int k)` returns the top `k` players\' scores in descending order. * `void reset(int playerId)` resets the score for the given `playerId` to 0, effectively removing them from the leaderboard. Each `playerId` and `score` will be non-negative integers.","solution":"class Leaderboard: def __init__(self): self.scores = {} def addScore(self, playerId, score): if playerId in self.scores: self.scores[playerId] += score else: self.scores[playerId] = score def top(self, k): return sorted(self.scores.values(), reverse=True)[:k] def reset(self, playerId): if playerId in self.scores: self.scores[playerId] = 0"},{"question":"You are given a matrix `grid` consisting of `0`s (water) and `1`s (land). An island is a maximal 4-directionally connected group of `1`s. The island\'s perimeter is the total number of edges where the island touches the water or the matrix boundary. Write a function that takes such a matrix and returns the perimeter of the island. Assume there is exactly one island in the grid.","solution":"def island_perimeter(grid): Returns the perimeter of the island in the grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) perimeter = 0 for row in range(rows): for col in range(cols): if grid[row][col] == 1: # Check top if row == 0 or grid[row - 1][col] == 0: perimeter += 1 # Check bottom if row == rows - 1 or grid[row + 1][col] == 0: perimeter += 1 # Check left if col == 0 or grid[row][col - 1] == 0: perimeter += 1 # Check right if col == cols - 1 or grid[row][col + 1] == 0: perimeter += 1 return perimeter"},{"question":"You are given an array of integers `arr` where each element appears exactly three times, except for one element which appears exactly once. Your task is to find the element that appears only once. Write a function that takes the array `arr` as input and returns that single element. You should aim for a solution with linear runtime complexity and without using extra memory space. This question tests your ability to handle array manipulation and bitwise operations.","solution":"def single_number(arr): Find the element that appears only once in an array where every other element appears exactly three times. Args: arr: List[int] - a list of integers Returns: int - the integer that appears exactly once ones, twos = 0, 0 for num in arr: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"You are given an array of integers `nums` and an integer `k`. A **subarray** is a contiguous non-empty sequence of elements within the array. Return _the maximum sum of a subarray of length exactly `k` in `nums`_. If no such subarray exists, return `None`.","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of a subarray of length exactly k. If no such subarray exists, return None. n = len(nums) if k > n or k < 1: return None max_sum = float(\'-inf\') current_sum = sum(nums[:k]) max_sum = max(max_sum, current_sum) for i in range(k, n): current_sum = current_sum + nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a string `s` and an integer array `indices` of the same length. The string `s` will be shuffled such that the character at the `i-th` position moves to `indices[i]` in the shuffled string. Return the shuffled string. Write the function `string restoreString(string s, vector<int>& indices)` that performs this shuffling operation.","solution":"def restore_string(s, indices): Restores the shuffled string according to the provided indices. Parameters: s (str): The input string. indices (list of int): The list of indices indicating the new positions of characters. Returns: str: The restored string. shuffled = [\'\'] * len(s) for i, index in enumerate(indices): shuffled[index] = s[i] return \'\'.join(shuffled)"},{"question":"**[Question 4]:** Given a **non-empty** array of integers `nums`, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space.","solution":"def single_number(nums): Returns the element that appears only once in the array. result = 0 for num in nums: result ^= num return result"},{"question":"You are a customs officer at an airport and are given a list of `passengerTimes` where `passengerTimes[i] = [arrivalTimei, departureTimei]` represents the arrival and departure times of the ith passenger. You need to determine the maximum number of passengers present at the airport at the same time. A passenger is considered present at the airport from their arrival time to their departure time, inclusively. Return _the **maximum** number of passengers present at the same time_.","solution":"def maxPassengers(passengerTimes): events = [] for arrival, departure in passengerTimes: events.append((arrival, 1)) # +1 for arrival events.append((departure + 1, -1)) # -1 for departure # Sort events first by time, then by type (-1 should come before +1 at same time) events.sort() max_passengers = 0 current_passengers = 0 for time, change in events: current_passengers += change if current_passengers > max_passengers: max_passengers = current_passengers return max_passengers"},{"question":"You are given the head of a singly linked list. Each node contains an integer value and a pointer to the next node. Your task is to reorder the list in such a way that the nodes with even indices come before the nodes with odd indices (considering the zero-based index of the list). The relative order of nodes within the even and odd groups must remain as they were in the original list. Return the reordered list. For example, if the original list is `1 -> 2 -> 3 -> 4 -> 5`, after reordering it should become `1 -> 3 -> 5 -> 2 -> 4`. If the list is `2 -> 1 -> 4 -> 7 -> 8 -> 5`, after reordering it should become `2 -> 4 -> 8 -> 1 -> 7 -> 5`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_list(head): if not head or not head.next: return head even_head = ListNode(0) odd_head = ListNode(0) even = even_head odd = odd_head is_even = True current = head while current: if is_even: even.next = current even = even.next else: odd.next = current odd = odd.next is_even = not is_even current = current.next even.next = odd_head.next odd.next = None return even_head.next"},{"question":"You are given a `nums` array of size `n` containing non-negative integers. You are also given a positive integer `goal`. You need to find the minimum length of a contiguous subarray such that the sum of its elements is **exactly** equal to `goal`. If there is no such subarray, return `-1`. Return _the minimum length of such a subarray or `-1` if no such subarray exists_.","solution":"def min_subarray_len(nums, goal): Returns the minimum length of a contiguous subarray with a sum exactly equal to goal. If no such subarray exists, returns -1. n = len(nums) min_length = float(\'inf\') current_sum = 0 left = 0 for right in range(n): current_sum += nums[right] while current_sum >= goal: if current_sum == goal: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given a list of strings `words`. Implement a function to find the longest word in `words` that can be built one character at a time by other words in `words`. If there are multiple possible answers, return the longest word with the smallest lexicographical order. If no such word exists, return an empty string. **Example:** ``` Input: words = [\\"a\\", \\"banana\\", \\"app\\", \\"appl\\", \\"ap\\", \\"apply\\", \\"apple\\"] Output: \\"apple\\" Explanation: Both \\"apple\\" and \\"apply\\" can be built from other words in the list. However, \\"apple\\" is lexicographically smaller. ```","solution":"def longest_word(words): words.sort() word_set = set([\'\']) longest = \'\' for word in words: if word[:-1] in word_set: word_set.add(word) if len(word) > len(longest): longest = word return longest"},{"question":"Design a data structure that supports adding integers to a collection and querying for the median integer efficiently. The median of a collection is the middle value if the size of the collection is odd, or the average of the two middle values if the size is even. Implement the `MedianFinder` class: * `MedianFinder()` initializes an empty MedianFinder object. * `void addNum(int num)` adds an integer `num` to the data structure. * `double findMedian()` returns the median of all integers added so far.","solution":"import heapq class MedianFinder: def __init__(self): self.low = [] # max heap (inverted min-heap) self.high = [] # min heap def addNum(self, num: int) -> None: if len(self.low) == len(self.high): heapq.heappush(self.low, -heapq.heappushpop(self.high, num)) else: heapq.heappush(self.high, -heapq.heappushpop(self.low, -num)) def findMedian(self) -> float: if len(self.low) > len(self.high): return -self.low[0] return (-self.low[0] + self.high[0]) / 2.0"},{"question":"Given a string `s` consisting of only the characters `\'(\'` and `\')\'`, find the maximum length of a substring that is a balanced parenthesis. A balanced parenthesis is a substring that has every opening parenthesis `\'(\'` matched with a corresponding closing parenthesis `\')\'`. Return the length of the longest balanced substring.","solution":"def longest_balanced_parentheses(s): Given a string s consisting of only the characters \'(\' and \')\', find the maximum length of a substring that is a balanced parenthesis. A balanced parenthesis is a substring that has every opening parenthesis \'(\' matched with a corresponding closing parenthesis \')\'. Args: s (str): Input string consisting only of \'(\' and \')\' Returns: int: The length of the longest balanced substring. max_length = 0 stack = [-1] for i, char in enumerate(s): if char == \'(\': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length"},{"question":"You are given an m x n 2D grid `grid` of integers. Each cell can either contain a value `0` (representing an empty cell), `1` (representing an obstacle), or `2` (representing a target). Starting from the top-left corner of the grid, find the shortest path to any target (a cell with value `2`). You can move up, down, left, or right, and cannot visit cells more than once. If there is no such path, return -1. Return the length of this shortest path.","solution":"from collections import deque def shortest_path_to_target(grid): if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] directions = [(-1,0),(1,0),(0,-1),(0,1)] queue = deque([(0, 0, 0)]) # (x, y, steps) visited[0][0] = True if grid[0][0] == 2: return 0 while queue: x, y, steps = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and grid[nx][ny] != 1: if grid[nx][ny] == 2: return steps + 1 visited[nx][ny] = True queue.append((nx, ny, steps + 1)) return -1"},{"question":"Given an array of integers `arr`, return an array of integers where each element is the product of all the elements of `arr` except the one at the same index. Each element in the array `arr` is at least `1`. You must solve it without using the division operation and in `O(n)` time complexity.","solution":"def product_except_self(arr): Return an array where each element is the product of all the elements of the input array except the one at the same index. n = len(arr) result = [1] * n # Fill result array with products of elements to the left of each index left_product = 1 for i in range(n): result[i] = left_product left_product *= arr[i] # Multiply with the product of elements to the right of each index right_product = 1 for i in range(n - 1, -1, -1): result[i] *= right_product right_product *= arr[i] return result"},{"question":"4. You are given a binary tree where each node contains an integer value. Write a function to determine if the tree is height-balanced. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. The function should return `true` if the tree is height-balanced and `false` otherwise. A binary tree node is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Implement the function `isBalanced(root)` that determines if the tree is height-balanced.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root): def check(root): if not root: return 0, True left_depth, left_balanced = check(root.left) right_depth, right_balanced = check(root.right) if not left_balanced or not right_balanced: return 0, False if abs(left_depth - right_depth) > 1: return 0, False return max(left_depth, right_depth) + 1, True _, balanced = check(root) return balanced"},{"question":"Given an array of integers `tasks` where `tasks[i]` represents the duration of the `i-th` task and an integer `k` representing the maximum number of tasks that can be performed in parallel at any time, return the minimum time required to complete all tasks. You can assume that each task can start at any time but once started, it must run uninterrupted.","solution":"import heapq def minTime(tasks, k): Calculates the minimum time required to complete all tasks given that no more than k tasks can run in parallel. :param tasks: List of task durations :param k: Maximum number of tasks running in parallel at any time :return: Minimum time required to complete all tasks # If there are no tasks, return 0 if not tasks: return 0 # If k > len(tasks), we only need the longest task duration if k >= len(tasks): return max(tasks) # Priority queue to keep track of running tasks ongoing_tasks = [0] * k for task in tasks: # Tying to the core which will be free the earliest based on the task duration earliest_completion = heapq.heappop(ongoing_tasks) heapq.heappush(ongoing_tasks, earliest_completion + task) # The time needed will be the maximum time in the ongoing_tasks since this will be when the last task finishes. return max(ongoing_tasks)"},{"question":"You are given a matrix `mat` of integers with `m` rows and `n` columns. Your task is to find the maximum value in a path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1) of the matrix such that the value at each cell in the path is greater than or equal to the value in the previous cell. The path can only move to the right or down. Return _the maximum path value_ if such a path exists. Otherwise, return `-1`.","solution":"def max_path_value(mat): Returns the maximum value in a path from the top-left corner to the bottom-right corner where each cell value in the path is greater than or equal to the value in the previous cell. if not mat or not mat[0]: return -1 m, n = len(mat), len(mat[0]) dp = [[-1] * n for _ in range(m)] dp[0][0] = mat[0][0] for i in range(m): for j in range(n): if i > 0 and dp[i-1][j] != -1 and mat[i][j] >= mat[i-1][j]: dp[i][j] = max(dp[i][j], mat[i][j]) if j > 0 and dp[i][j-1] != -1 and mat[i][j] >= mat[i][j-1]: dp[i][j] = max(dp[i][j], mat[i][j]) return dp[-1][-1]"},{"question":"You are given a string `s` consisting of only letters `\'a\'`, `\'b\'`, and `\'c\'`. You are allowed to insert the characters `\'a\'`, `\'b\'`, and `\'c\'` at any position in the string `s`. Return _the minimum number of insertions required to form a valid string_. A string is considered valid if it has at least one substring of each of the following patterns: `\\"abc\\"`, `\\"bac\\"`, or `\\"cab\\"`. Each pattern must appear at least once in the resulting string.","solution":"def min_insertions(s): Return the minimum number of insertions required to form a valid string. from collections import Counter def contains_pattern(pattern, counter): Check if all characters in the pattern exist in the given counter. return all(counter[char] > 0 for char in pattern) min_insertions_needed = float(\'inf\') patterns = [\\"abc\\", \\"bac\\", \\"cab\\"] for pattern in patterns: counter = Counter(s) insertions_needed = 0 for char in pattern: if counter[char] == 0: insertions_needed += 1 else: counter[char] -= 1 min_insertions_needed = min(min_insertions_needed, insertions_needed) return min_insertions_needed"},{"question":"You are given two strings, `s1` and `s2`, both of equal length. Determine the minimum number of adjacent swaps required to transform `s1` into `s2`. If it is impossible to do so, return `-1`.","solution":"def min_swaps_to_transform(s1, s2): Returns the minimum number of adjacent swaps required to transform s1 into s2. If it is impossible to do so, return -1. def count_frequency(s): # Helper function to count frequency of each character in a string freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 return freq # Check if transformation is possible by comparing character frequencies if count_frequency(s1) != count_frequency(s2): return -1 # Convert s1 to a list to perform swaps s1 = list(s1) swaps = 0 for i in range(len(s1)): # When s1[i] != s2[i], we need to swap s1[i] with the next correct character if s1[i] != s2[i]: j = i while s1[j] != s2[i]: j += 1 # Perform adjacent swaps to bring s2[i] to position i while j > i: s1[j], s1[j - 1] = s1[j - 1], s1[j] swaps += 1 j -= 1 return swaps"},{"question":"Implement an `LruCache` class, which stands for Least Recently Used Cache. Your implementation should support two methods: - `LruCache(int capacity)`: Initialize the LRU cache with a positive size `capacity`. - `int get(int key)`: Return the value of the key if the key exists in the cache, otherwise return -1. - `void put(int key, int value)`: Update or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. # Example: ``` LruCache lru = new LruCache(2); lru.put(1, 1); lru.put(2, 2); lru.get(1); // returns 1 lru.put(3, 3); // evicts key 2 lru.get(2); // returns -1 (not found) lru.put(4, 4); // evicts key 1 lru.get(1); // returns -1 (not found) lru.get(3); // returns 3 lru.get(4); // returns 4 ``` You should assume that: - all operations will be called in a consistent manner. - the get method should return the appropriate value and update the recency of the access. - the put method should insert or update the value accordingly and manage recency and capacity constraints. Note: This is to be implemented using appropriate data structures to ensure efficient use of time complexities in get and put operations.","solution":"from collections import OrderedDict class LruCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"Given a list of daily stock prices `prices`, you are to determine the maximum profit you can achieve. You can buy and sell the stock multiple times, but you must sell the stock before you buy again. Return _the maximum profit you can achieve from these transactions_. Note that you cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). For example, given `prices = [7, 1, 5, 3, 6, 4]`, the maximum profit is `7` (buy on day 2 and sell on day 3, profit = 4; then buy on day 4 and sell on day 5, profit = 3).","solution":"def max_profit(prices): Calculate the maximum profit from buying and selling stocks multiple times. :param prices: List of daily stock prices :return: The maximum profit achievable profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: profit += prices[i] - prices[i - 1] return profit"},{"question":"You are given a **directed acyclic graph (DAG)** with `n` nodes, labeled from `0` to `n-1`. The graph is represented by a **0-indexed** list of lists `edges`, where `edges[i]` is a list of all nodes `i` has a direct edge to. Design an algorithm to find the **longest path** in the DAG. Return the **length** of the longest path.","solution":"def longest_path_dag(n, edges): from collections import defaultdict, deque graph = defaultdict(list) indegree = [0] * n for u in range(n): for v in edges[u]: graph[u].append(v) indegree[v] += 1 topo_order = [] queue = deque([u for u in range(n) if indegree[u] == 0]) while queue: node = queue.popleft() topo_order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) longest = [0] * n for u in topo_order: for v in graph[u]: longest[v] = max(longest[v], longest[u] + 1) return max(longest)"},{"question":"You are given a square matrix `mat` of size `n x n` consisting of non-negative integers. Your task is to find the sum of the elements on the anti-diagonals of the matrix. An anti-diagonal is defined as a diagonal line that runs from the top-right to the bottom-left direction. The elements on the main anti-diagonal are those where the sum of the row and column indices is equal to `n-1`. Return the sum of these anti-diagonal elements.","solution":"def anti_diagonal_sum(mat): Returns the sum of the elements on the main anti-diagonal of the square matrix mat. n = len(mat) anti_diagonal_sum = 0 for i in range(n): anti_diagonal_sum += mat[i][n - 1 - i] return anti_diagonal_sum"},{"question":"You are given an integer array `nums` and an integer `k`. The array is sorted in non-decreasing order but rotated at an unknown pivot. Find the `kth` smallest element in the array. Note that you must use a binary search approach to find the element, ensuring a time complexity of `O(log n)`.","solution":"def find_kth_smallest(nums, k): Returns the kth smallest element from the rotated sorted array nums. def find_pivot(nums): Helper function to find the index of the smallest element, which is the pivot point of the rotated sorted array. low, high = 0, len(nums) - 1 while low < high: mid = (low + high) // 2 if nums[mid] > nums[high]: low = mid + 1 else: high = mid return low n = len(nums) pivot = find_pivot(nums) if k <= (n - pivot): return nums[pivot + k - 1] else: return nums[k - (n - pivot) - 1]"},{"question":"You are given a List `nums` representing the population of a city distributed across several districts, where `nums[i]` represents the population of the `i-th` district. The city administration wants to redistribute the population such that the variance among district populations is minimized. You can move people between any two districts, and you can perform this operation any number of times. Return _the **minimum variance** of the population distribution you can achieve_. [Note]: Variance is given by the formula: ( frac{1}{n}sum_{i=1}^n (text{nums}[i] - text{mean of nums})^2 ). For simplicity, consider the mean as the integer floor of the actual mean value of the list.","solution":"import math from typing import List def minimum_variance(nums: List[int]) -> float: Returns the minimum variance of the population distribution across districts. n = len(nums) total_population = sum(nums) mean_population = math.floor(total_population / n) # Calculate variance variance = sum([(x - mean_population) ** 2 for x in nums]) / n return variance"},{"question":"Given a list of integers `nums`, you are to create a function that returns the length of the longest contiguous subarray where the absolute difference between any two elements in this subarray is less than or equal to a specified integer `t`.","solution":"def longest_subarray_length(nums, t): Returns the length of the longest contiguous subarray where the absolute difference between any two elements in this subarray is less than or equal to t. if not nums: return 0 start, max_len = 0, 0 for end in range(len(nums)): while start < end and max(nums[start:end+1]) - min(nums[start:end+1]) > t: start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given a binary tree with `n` nodes. Each node is given a value. Write a function to find the largest subset of the tree nodes that forms a Binary Search Tree (BST). Return the number of nodes in this largest BST subtree. A Binary Search Tree is a binary tree in which for each node, the left child is less than the parent node and the right child is greater than the parent node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestBSTSubtree(root): def postorder(node): if not node: return 0, float(\'inf\'), float(\'-inf\'), True left_size, left_min, left_max, left_is_bst = postorder(node.left) right_size, right_min, right_max, right_is_bst = postorder(node.right) if left_is_bst and right_is_bst and left_max < node.val < right_min: return (left_size + right_size + 1), min(node.val, left_min), max(node.val, right_max), True else: return max(left_size, right_size), 0, 0, False max_size, _, _, _ = postorder(root) return max_size"},{"question":"You are given a list of `n` intervals where each interval is represented as a pair `[start, end]`. Each interval represents a task that needs to be performed during that time frame. You need to determine the minimum number of intervals you must remove to ensure that the remaining intervals do not overlap. Two intervals `[a1, b1]` and `[a2, b2]` overlap if `a1` < `b2` and `a2` < `b1`. Write a function that returns the minimum number of intervals to remove so that the remaining intervals are non-overlapping.","solution":"def erase_overlap_intervals(intervals): Given a list of intervals, returns the minimum number of intervals to be removed to make the rest of the intervals non-overlapping. if not intervals: return 0 # Sort intervals by end time intervals.sort(key=lambda interval: interval[1]) # Initialize count of removed intervals remove_count = 0 # Initialize the end time of the previous interval to the minimum possible value prev_end_time = float(\'-inf\') for start, end in intervals: if start >= prev_end_time: # No overlap prev_end_time = end else: # Overlap remove_count += 1 return remove_count"},{"question":"You are given a string `s` and an integer `k`. The string `s` consists of lowercase English letters. You need to divide the string into as many parts as possible such that each part contains exactly `k` distinct characters. Return _the maximum number of parts you can divide the string into_. If it is not possible to divide the string as required, return `0`.","solution":"def max_parts_with_k_distinct_chars(s, k): Returns the maximum number of parts the string s can be divided into such that each part contains exactly k distinct characters. If not possible, returns 0. # Length of string s n = len(s) # If k is greater than the number of distinct characters in s, # it\'s impossible to have even one part satisfying the condition if k > len(set(s)): return 0 # Frequency dictionary to count occurrence of each character freq = {} num_distinct = 0 parts = 0 start = 0 for end in range(n): char = s[end] # Update frequency dictionary if char not in freq: freq[char] = 0 freq[char] += 1 # If this char is a new distinct char, update the count if freq[char] == 1: num_distinct += 1 # When we have k distinct characters in the current window [start...end] if num_distinct == k: parts += 1 # This is one valid part # Reset starting position and frequency counts for the next potential part start = end + 1 freq = {} num_distinct = 0 return parts"},{"question":"Given a 0-indexed array of integers `arr`, you need to determine whether there exists a subarray of length at least 2 that sums up to a given target integer `k`. A subarray is a contiguous portion of the array. Return `true` if such a subarray exists and `false` otherwise.","solution":"def has_subarray_with_sum(arr, k): Determine if there exists a subarray of length at least 2 that sums up to k. :param arr: List of integers. :param k: Target integer. :return: True if such a subarray exists, False otherwise. # Dictionary to store the prefix sum and its index prefix_sum = 0 sum_indices = {0: -1} # Initialize with prefix sum 0 at index -1 for i in range(len(arr)): prefix_sum += arr[i] if prefix_sum - k in sum_indices and i - sum_indices[prefix_sum - k] >= 2: return True # Only add the prefix_sum to the dictionary if it is not already present if prefix_sum not in sum_indices: sum_indices[prefix_sum] = i return False"},{"question":"You are given an array `nums` of `n` integers, and an integer `i` is dominant if `twice the value of` `nums[i]` is greater than or equal to each element in the array, except for the element `nums[i]` itself. Return the index of the **dominant integer** if it exists, otherwise return `-1`. If there are multiple dominant integers, return the `index of the first` occurrence.","solution":"def find_dominant_index(nums): Finds the index of the dominant integer in the list. An integer i is dominant if twice the value of nums[i] is greater than or equal to each element in the array, except for nums[i] itself. Return the index of the dominant integer if it exists, otherwise return -1. If there are multiple dominant integers, return the index of the first occurrence. if not nums: return -1 n = len(nums) max_index = 0 # Find the index of the maximum element for i in range(1, n): if nums[i] > nums[max_index]: max_index = i # Check if this maximum element is dominant for i in range(n): if i != max_index and nums[max_index] < 2 * nums[i]: return -1 return max_index"},{"question":"Given a list of `n` distinct integers representing the heights of individuals standing in a queue, find the minimum number of adjacent swaps required to sort the queue in non-decreasing order of height. Each swap can only involve two adjacent individuals. Return _the minimum number of adjacent swaps needed_.","solution":"def min_adjacent_swaps(nums): Returns the minimum number of adjacent swaps needed to sort the queue in non-decreasing order of height. swaps = 0 nums = list(nums) # Create a mutable copy of the list # Bubble sort and count swaps n = len(nums) for i in range(n): for j in range(n - 1 - i): if nums[j] > nums[j + 1]: nums[j], nums[j + 1] = nums[j + 1], nums[j] swaps += 1 return swaps"},{"question":"Given a string `s` consisting only of letters \'a\' and \'b\', with each letter denoting a specific action, determine whether it is possible to rearrange the string such that no two adjacent letters are the same. Return `true` if possible, otherwise return `false`.","solution":"from collections import Counter def can_rearrange_string(s): Determines if it\'s possible to rearrange the string such that no two adjacent letters are the same. :param s: input string consisting only of letters \'a\' and \'b\'. :return: True if it\'s possible to rearrange the string, otherwise False. # Count occurrences of \'a\' and \'b\' count = Counter(s) # Get the maximum count of either \'a\' or \'b\' max_count = max(count[\'a\'], count[\'b\']) # If the maximum count is more than half the length of the string (rounded up), it\'s impossible to rearrange if max_count > (len(s) + 1) // 2: return False return True"},{"question":"You are given a string `s` that consists of only digits. You may change at most one digit to any other digit (0 through 9) to maximize the numerical value of the resulting string. Return _the maximum possible value of the string after at most one digit change_.","solution":"def maximize_digit_string(s): This function takes a string s consisting of only digits and returns the maximum possible value of the string after changing at most one digit. s_list = list(s) for i, char in enumerate(s_list): if char != \'9\': s_list[i] = \'9\' return \'\'.join(s_list) return s"},{"question":"Given the `root` of a binary search tree (BST) and an integer `k`, find the `k`-th smallest element in the BST. A binary search tree is a tree in which for each node, all values in the left subtree are smaller than the node\'s value, and all values in the right subtree are greater than the node\'s value. You must solve this problem by implementing an in-order traversal of the tree to obtain the elements in ascending order. Return the `k`-th smallest element.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Find the k-th smallest element in a BST. :param root: TreeNode - The root of the BST :param k: int - The k-th position (1-indexed) :return: int - The value of the k-th smallest element def in_order_traversal(node): if not node: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) inorder_elements = in_order_traversal(root) return inorder_elements[k - 1] # k is 1-indexed"},{"question":"You are given a string `s` and an integer `k`. You need to find the maximum number of distinct characters that can appear in any substring of length `k` of `s`. If `s` has a length smaller than `k`, return the number of distinct characters in the entire string. Implement a function `int maxDistinctChars(string s, int k)` that returns the result.","solution":"def maxDistinctChars(s, k): Returns the maximum number of distinct characters that can appear in any substring of length k of the string s. If the length of s is smaller than k, returns the number of distinct characters in the entire string. if len(s) <= k: return len(set(s)) max_distinct = 0 for i in range(len(s) - k + 1): substring = s[i:i + k] distinct_chars = len(set(substring)) max_distinct = max(max_distinct, distinct_chars) return max_distinct"},{"question":"You are given a list of strings `words` and another string `s`. In one operation, you can select any word from the list `words` and check if `s` starts with that word. If it does, remove that word from the beginning of `s`. Return `true` _if you can make_ `s` _empty after a finite number of operations; otherwise, return_ `false`.","solution":"def can_form_empty_string(words, s): Determine if you can make the string `s` empty by sequentially removing words from the beginning of `s`. Parameters: words (list of str): List of words to use for removal s (str): The string to be made empty Returns: bool: True if `s` can be made empty, False otherwise while s: matched = False for word in words: if s.startswith(word): s = s[len(word):] matched = True break if not matched: return False return True"},{"question":"You are given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, and a target integer `target`. Write a function that returns an index pair `(i, j)` such that the sum of `nums1[i]` and `nums2[j]` is equal to `target`. If there are multiple valid pairs, return any of them. If no such pair exists, return `-1`. The indices `i` and `j` should be such that `0 <= i < m` and `0 <= j < n`.","solution":"def find_pair_with_sum(nums1, nums2, target): Given two sorted arrays nums1 and nums2 of size m and n respectively, and a target integer target, returns an index pair (i, j) such that the sum of nums1[i] and nums2[j] is equal to target. If no such pair exists, returns -1. i, j = 0, len(nums2) - 1 while i < len(nums1) and j >= 0: current_sum = nums1[i] + nums2[j] if current_sum == target: return (i, j) elif current_sum < target: i += 1 else: j -= 1 return -1"},{"question":"You are given a linked list where each node contains an extra random pointer which could point to any node in the list or null. Create a deep copy of the list. The linked list is represented as a set of n nodes: `Node { int val; Node next; Node random; }`. Return the head of the copied linked list.","solution":"class Node: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def copy_random_list(head): if not head: return None # Step 1: Create a copy of each node and insert it right next to the original node current = head while current: new_node = Node(current.val, current.next, None) current.next = new_node current = new_node.next # Step 2: Assign random pointers to the copied nodes current = head while current: if current.random: current.next.random = current.random.next current = current.next.next # Step 3: Separate the original list and the copied list current_old_list = head current_new_list = head.next new_head = head.next while current_old_list: current_old_list.next = current_old_list.next.next if current_new_list.next: current_new_list.next = current_new_list.next.next current_old_list = current_old_list.next current_new_list = current_new_list.next return new_head"},{"question":"Given a binary tree, implement a function `binaryTreePaths` that returns all root-to-leaf paths in the tree. Each path should be returned as a string formatted as \\"root->node1->node2->...->leaf\\". Example: ``` Input: root = [1, 2, 3, null, 5] Output: [\\"1->2->5\\", \\"1->3\\"] Explanation: All root-to-leaf paths are: 1->2->5, 1->3 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binaryTreePaths(root): def construct_paths(node, path): if node: path += str(node.val) if not node.left and not node.right: paths.append(path) else: path += \'->\' construct_paths(node.left, path) construct_paths(node.right, path) paths = [] construct_paths(root, \'\') return paths"},{"question":"Given an integer array `arr`, and a target integer `sum`, determine if there exists a subset of elements in `arr` that adds up to `sum`. Return `true` if such a subset exists, otherwise return `false`. Consider that an empty subset cannot sum to a non-zero target.","solution":"def subset_sum(arr, target): Determines if there exists a subset of elements in `arr` that adds up to `target`. :param arr: List of integers. :param target: The target sum to find. :return: True if such a subset exists, otherwise False. n = len(arr) # Create a DP table to store results of sub-problems dp = [[False] * (target + 1) for _ in range(n + 1)] # Initialize the dp array for the case when target sum is 0 for i in range(n + 1): dp[i][0] = True # Fill the DP table for i in range(1, n + 1): for j in range(1, target + 1): if arr[i-1] > j: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] or dp[i-1][j - arr[i-1]] return dp[n][target]"},{"question":"Given an integer array `arr` of length `n` where each element represents a bar\'s height in a histogram, return the area of the largest rectangle that can be formed using consecutive bars. Example: For `arr = [2, 1, 5, 6, 2, 3]`, the largest rectangle can be formed with heights `[5, 6]` with an area of `5 * 2 = 10`. Note: You should implement an efficient algorithm with time complexity less than O(n^2).","solution":"def largest_rectangle_area(arr): Calculate the area of the largest rectangle in a histogram represented by `arr`. stack = [] max_area = 0 index = 0 while index < len(arr): if not stack or arr[stack[-1]] <= arr[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (arr[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (arr[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given an `n x n` 2D matrix representing an image where each element is either `0` or `1`, write a function to calculate the number of distinct islands in the matrix. An island is a group of connected `1`s (horizontal or vertical connections only). The function should return the total number of distinct islands. Two islands are considered distinct if one island is not identical to another (after potential rotations and flips).","solution":"def num_distinct_islands(grid): Returns the number of distinct islands in the given 2D matrix grid. :param grid: List[List[int]], 2D matrix representing the image :return: int, number of distinct islands def extract_island(r, c): island = [] stack = [(r, c)] while stack: x, y = stack.pop() if (x, y) not in visited and 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1: visited.add((x, y)) island.append((x - r, y - c)) stack.extend([(x+1, y), (x-1, y), (x, y+1), (x, y-1)]) return island def canonical_shapes(island): # generate all rotations and flips of the island shape shapes = [] for _ in range(2): island = [(y, x) for x, y in island] # transpose for _ in range(4): island = [(-y, x) for x, y in island] # rotate 90 degrees shapes.append(sorted(island)) return min(shapes) visited = set() distinct_islands = set() for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1 and (r, c) not in visited: island = extract_island(r, c) distinct_islands.add(tuple(canonical_shapes(island))) return len(distinct_islands)"},{"question":"You are given a list of non-negative integers `nums`. A subsequence of this list is considered **beautiful** if the elements in the subsequence have alternating parity (odd/even). Your task is to determine the length of the longest beautiful subsequence that can be formed from `nums`. Return _the length of the longest beautiful subsequence_.","solution":"def longest_beautiful_subsequence(nums): Returns the length of the longest beautiful subsequence with alternating parity. if not nums: return 0 # Initialize dp arrays for odd and even subsequences odd_dp = [0] * len(nums) even_dp = [0] * len(nums) if nums[0] % 2 == 0: even_dp[0] = 1 odd_dp[0] = 0 else: odd_dp[0] = 1 even_dp[0] = 0 max_length = 1 for i in range(1, len(nums)): if nums[i] % 2 == 0: even_dp[i] = odd_dp[i-1] + 1 odd_dp[i] = odd_dp[i-1] else: odd_dp[i] = even_dp[i-1] + 1 even_dp[i] = even_dp[i-1] max_length = max(max_length, odd_dp[i], even_dp[i]) return max_length"},{"question":"You are given a list of `n` intervals, where each interval is represented as a pair `[starti, endi]`. The intervals are closed, meaning they include both the start and end points. You need to perform queries on these intervals. Each query is given as a pair `[queryi, x]`, where `queryi` represents a type of query and `x` represents an integer value associated with the query. The queries can be of three types: 1. Add a new interval `[x, x]` to the list of intervals. 2. Remove all intervals that contain the point `x`. 3. Check if there is an interval in the list that contains the point `x`. Return the results of the queries of the third type as a list of boolean values. Each boolean value represents whether the point `x` is contained in any interval after applying each query successfully.","solution":"def process_intervals_and_queries(intervals, queries): Processes a list of intervals and a list of queries to modify and query the intervals. intervals: List of pairs [start, end] representing the intervals. queries: List of pairs [query_type, x] representing the queries. Returns: List of boolean values for the third type of query. def contains_point(interval, point): return interval[0] <= point <= interval[1] def remove_intervals_containing_point(intervals, point): return [interval for interval in intervals if not contains_point(interval, point)] results = [] for query_type, x in queries: if query_type == 1: intervals.append([x, x]) elif query_type == 2: intervals = remove_intervals_containing_point(intervals, x) elif query_type == 3: found = any(contains_point(interval, x) for interval in intervals) results.append(found) return results"},{"question":"A company wants to optimize its task scheduling system. You are given a list of `tasks` where each task is represented by a character and takes one unit of time to execute. Additionally, you are given an integer `n` that represents the cooldown period between two identical tasks. During this cooldown period, the CPU can either execute different tasks or stay idle. Your goal is to determine the minimum number of units of time the CPU will take to finish all the given tasks. Return the minimum number of units of time required to finish all tasks. Note: - The array `tasks` will have upper-case English letters where `A` represents task type A, `B` represents task type B, and so on. - The integer `n` is the cooldown period between two identical tasks. Example: ``` Input: tasks = [\'A\',\'A\',\'A\',\'B\',\'B\',\'B\'], n = 2 Output: 8 Explanation: A -> B -> idle -> A -> B -> idle -> A -> B ```","solution":"from collections import Counter def leastInterval(tasks, n): Returns the minimum number of units of time required to finish all tasks with given cooldown period. task_counts = Counter(tasks) max_count = max(task_counts.values()) max_count_tasks = sum(1 for count in task_counts.values() if count == max_count) # Considering the most frequent tasks part_count = max_count - 1 part_length = n - (max_count_tasks - 1) empty_slots = part_count * part_length available_tasks = len(tasks) - max_count * max_count_tasks idles = max(0, empty_slots - available_tasks) return len(tasks) + idles"},{"question":"You are given a string `s` consisting of only lowercase English letters. Define a move as swapping any two adjacent characters in the string. Devise a function that, given two strings `s` and `t` of the same length, determines if `t` can be obtained from `s` by no more than `k` moves. Return true if it\'s possible and false otherwise.","solution":"def can_transform(s, t, k): Determines if t can be obtained from s by no more than k adjacent swaps. if sorted(s) != sorted(t): return False # Count the minimum number of adjacent swaps needed to match t n = len(s) num_swaps = 0 s_list = list(s) for i in range(n): if s_list[i] != t[i]: # Find the matching character in the remaining substring for j in range(i + 1, n): if s_list[j] == t[i]: # Perform the adjacent swaps to move s_list[j] to position i while j > i: s_list[j], s_list[j - 1] = s_list[j - 1], s_list[j] j -= 1 num_swaps += 1 return num_swaps <= k"},{"question":"Given a set of `n` tasks labeled from `1` to `n`, represented by an array `tasks` where each task has an associated positive integer indicating its time to complete. You are also given a two-dimensional array `dependencies` where `dependencies[i] = [a, b]` indicates that you must complete task `a` before you can start task `b`. Write a function to determine the minimum time required to complete all tasks, given that you can perform multiple tasks simultaneously if their dependencies are satisfied. If it is impossible to complete all tasks due to cyclic dependencies, return -1.","solution":"from collections import defaultdict, deque def minimum_time_to_complete_tasks(n, tasks, dependencies): # Create graph and indegree count graph = defaultdict(list) indegree = [0] * n task_time = [0] * n for a, b in dependencies: graph[a-1].append(b-1) indegree[b-1] += 1 for i in range(n): task_time[i] = tasks[i] # Initializing queue with tasks having no dependencies queue = deque() for i in range(n): if indegree[i] == 0: queue.append(i) # Kahn\'s Algorithm for Topological Sorting completed_tasks = 0 process_time = [0] * n while queue: current = queue.popleft() completed_tasks += 1 current_task_time = task_time[current] process_time[current] += current_task_time for neighbor in graph[current]: indegree[neighbor] -= 1 process_time[neighbor] = max(process_time[neighbor], process_time[current]) if indegree[neighbor] == 0: queue.append(neighbor) if completed_tasks != n: return -1 return max(process_time)"},{"question":"You are given an integer `n` representing the total number of courses you need to take, labeled from `0` to `n-1`. You are also given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` before course `ai`. Find the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array. Example: Given `n = 4` and `prerequisites = [[1,0], [2,0], [3,1], [3,2]]`, a possible ordering of courses could be `[0, 1, 2, 3]` or `[0, 2, 1, 3]`.","solution":"from collections import deque, defaultdict def findOrder(numCourses, prerequisites): Returns the order of courses to finish all given the number of courses and their prerequisites. If it is impossible to finish all courses, returns an empty list. # Create a graph and an array to count the in-degrees of each node graph = defaultdict(list) in_degree = [0] * numCourses # Build the graph and populate in-degrees for dest, src in prerequisites: graph[src].append(dest) in_degree[dest] += 1 # Initialize a queue with all nodes having in-degree of 0 queue = deque([i for i in range(numCourses) if in_degree[i] == 0]) order = [] # Process each node in the queue while queue: node = queue.popleft() order.append(node) # Decrease the in-degree of each neighbor by 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 # If in-degree of neighbor becomes 0, add it to the queue if in_degree[neighbor] == 0: queue.append(neighbor) # If the length of the order list is equal to the number of courses, return the order if len(order) == numCourses: return order else: return []"},{"question":"Given a `root` of a Binary Search Tree (BST), write a function that checks if the tree is balanced. A balanced tree is defined as one where the depth of the two subtrees of every node never differ by more than one. Return `true` if the tree is balanced, otherwise return `false`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Checks if a binary tree is balanced. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is balanced, otherwise False def check_balance(node): if not node: return 0, True left_depth, is_left_balanced = check_balance(node.left) right_depth, is_right_balanced = check_balance(node.right) current_balanced = is_left_balanced and is_right_balanced and abs(left_depth - right_depth) <= 1 return max(left_depth, right_depth) + 1, current_balanced _, result = check_balance(root) return result"},{"question":"Given a 2D board and a word, write a function to determine if the word exists in the board. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. ```python def exist(board: List[List[str]], word: str) -> bool: # Your implementation here ```","solution":"from typing import List def exist(board: List[List[str]], word: str) -> bool: rows, cols = len(board), len(board[0]) path = set() def dfs(r, c, i): if i == len(word): return True if (r < 0 or r >= rows or c < 0 or c >= cols or word[i] != board[r][c] or (r, c) in path): return False path.add((r, c)) res = (dfs(r + 1, c, i + 1) or dfs(r - 1, c, i + 1) or dfs(r, c + 1, i + 1) or dfs(r, c - 1, i + 1)) path.remove((r, c)) return res for row in range(rows): for col in range(cols): if dfs(row, col, 0): return True return False"},{"question":"Given an integer array `nums`, return the length of the **longest** subsequence such that the subsequence is divisible by at least one element of a given integer divisor array `divisors`. A subsequence is a sequence derived by deleting some or none of the elements from the original array without changing the order of the remaining elements.","solution":"def longest_subsequence_length(nums, divisors): Returns the length of the longest subsequence such that each element in the subsequence is divisible by at least one element in the divisors array. :param nums: List of integers representing the original array. :param divisors: List of integers representing the divisor array. :return: Length of the longest subsequence satisfying the condition. longest_length = 0 for num in nums: if any(num % divisor == 0 for divisor in divisors): longest_length += 1 return longest_length"},{"question":"Given a 2D grid of size `m x n` where each cell represents a different colored tile, return the maximum number of consecutive cells in a line (horizontally, vertically, or diagonally) that have the same color. Each color is denoted by a distinct positive integer. The grid is guaranteed to have at least one cell.","solution":"def max_consecutive_cells(grid): Returns the maximum number of consecutive cells in a line (horizontally, vertically, or diagonally) that have the same color in a 2D grid. def check_direction(x, y, dx, dy): color = grid[x][y] count = 0 while 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == color: count += 1 x += dx y += dy return count max_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): # Check right, down, down-right, and down-left max_count = max(max_count, check_direction(i, j, 0, 1)) max_count = max(max_count, check_direction(i, j, 1, 0)) max_count = max(max_count, check_direction(i, j, 1, 1)) max_count = max(max_count, check_direction(i, j, 1, -1)) return max_count"},{"question":"You are given an array `steps` where `steps[i]` represents the number of ways to reach the `i-th` step from the previous steps in a staircase. Each time you can either climb 1 or 2 steps. Your task is to determine the total number of distinct ways to reach the top of the staircase, which is `n` steps high. Return the number of distinct ways to reach the `n-th` step.","solution":"def climb_stairs(n): Returns the number of distinct ways to climb a staircase with n steps. Each time you can either climb 1 or 2 steps. if n == 0: return 0 elif n == 1: return 1 elif n == 2: return 2 # Initialize the base cases prev_prev = 1 # ways to reach step 0 prev = 2 # ways to reach step 1 # Calculate the number of ways for each step from 3 to n for i in range(3, n + 1): current = prev_prev + prev prev_prev = prev prev = current return prev"},{"question":"You are given a string `s` consisting only of characters \'a\', \'b\', and \'c\'. We want to partition the string into as few parts as possible, such that each part forms a valid word. A word is defined as a substring that contains at least one of each character \'a\', \'b\', and \'c\'. Return the minimum number of parts the string can be partitioned into.","solution":"def min_partitions(s): Returns the minimum number of parts the string \'s\' can be partitioned into, such that each part contains at least one of each character \'a\', \'b\', and \'c\'. n = len(s) if n < 3: return 0 a_count = b_count = c_count = 0 partitions = 0 for char in s: if char == \'a\': a_count += 1 elif char == \'b\': b_count += 1 elif char == \'c\': c_count += 1 if a_count > 0 and b_count > 0 and c_count > 0: partitions += 1 a_count = b_count = c_count = 0 return partitions"},{"question":"Given a list of `logs`, where each log is a space-delimited string of words. The first word in each log is a unique identifier. Each log can be one of two types: 1. **Letter-log**: All words (except the identifier) consist of lowercase English letters. 2. **Digit-log**: All words (except the identifier) consist only of digits. You have to reorder the logs such that all letter-logs come before any digit-log. The letter-logs are sorted lexicographically ignoring identifier, and in case of ties, identifier is used as a tiebreaker. The digit-logs should be put in their original order. Return the list of logs after sorting them in the described order.","solution":"def reorder_log_files(logs): Reorders a list of logs such that all letter-logs come before any digit-log. The letter-logs are sorted lexicographically ignoring identifier, and in case of ties, identifier is used as a tiebreaker. The digit-logs should be put in their original order. letter_logs = [] digit_logs = [] for log in logs: identifier, rest = log.split(\\" \\", 1) if rest[0].isdigit(): digit_logs.append(log) else: letter_logs.append((identifier, rest)) # Sort letter-logs first by the log content, and then by the identifier in case of ties letter_logs.sort(key=lambda x: (x[1], x[0])) # Convert sorted letter logs back to their original form sorted_letter_logs = [identifier + \\" \\" + rest for identifier, rest in letter_logs] # Append digit-logs to the result return sorted_letter_logs + digit_logs"},{"question":"Given a string `s` and an integer `k`, determine if `s` can be rearranged such that it contains `k` consecutive vowels. The vowels are \'a\', \'e\', \'i\', \'o\', \'u\', and they can appear in any order. If it is possible, return `true`; otherwise, return `false`. Note that the length of `s` will be at least `k`.","solution":"def can_rearrange_with_k_consecutive_vowels(s, k): Determines if the string s can be rearranged to contain k consecutive vowels. Args: s (str): The input string. k (int): The required number of consecutive vowels. Returns: bool: True if it\'s possible to rearrange the string to have k consecutive vowels, else False. # Define the vowels set vowels = {\'a\', \'e\', \'i\', \'o\', \'u\'} # Count the number of vowels in the string vowel_count = sum(1 for char in s if char in vowels) # Return whether the number of vowels is at least k return vowel_count >= k"},{"question":"A company uses a specific encryption technique to secure its data. The technique involves taking an input string and adding the ASCII values of its characters together, then converting that sum into its binary representation. As a result, an encrypted string is always a binary string. You are given two binary strings representing the encrypted data from two different sources. Your task is to determine whether the data from the first source can be transformed into the data from the second source by performing zero or more of the following operations: 1. Invert a bit (`0` becomes `1` and `1` becomes `0`). 2. Rotate the string to the right by one position. Write a function `canTransform` that takes two parameters `source` and `target`, both of which are binary strings. The function should return `True` if the `source` string can be transformed into the `target` string by using the allowed operations, and `False` otherwise. ```python def canTransform(source: str, target: str) -> bool: pass ```","solution":"def canTransform(source: str, target: str) -> bool: Check if source can be transformed into target by inverting bits or rotating right. :param source: The source binary string. :param target: The target binary string. :return: True if source can be transformed into target, else False. if len(source) != len(target): return False # Generate all rotations of the source string rotations = [] current = source for _ in range(len(source)): rotations.append(current) current = current[-1] + current[:-1] # Invert the source string and generate all its rotations inverted_source = \'\'.join(\'1\' if c == \'0\' else \'0\' for c in source) inverted_rotations = [] current = inverted_source for _ in range(len(inverted_source)): inverted_rotations.append(current) current = current[-1] + current[:-1] # Check if target is present in the standard or inverted rotations return target in rotations or target in inverted_rotations"},{"question":"Given a matrix `M` of size `m x n` (m rows and n columns) filled with non-negative integers, you are allowed to move either down or right starting from the top-left cell. You need to reach the bottom-right cell of the matrix. Write a function to calculate the minimum sum of the numbers along a path from the top-left cell to the bottom-right cell. You can only move to the right or down at each step. Return the minimum path sum.","solution":"def minPathSum(M): Calculate the minimum path sum from top-left to bottom-right of the matrix M. Args: M (list of list of int): The matrix of non-negative integers. Returns: int: The minimum path sum. if not M or not M[0]: return 0 m, n = len(M), len(M[0]) # Create a 2D dp array filled with 0s dp = [[0] * n for _ in range(m)] # Initialize the top-left cell dp[0][0] = M[0][0] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + M[i][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + M[0][j] # Fill the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + M[i][j] return dp[m-1][n-1]"},{"question":"You are given a string `s`, consisting of lowercase English letters. You need to select a non-empty subsequence from `s` and re-arrange its characters to form a string that is a palindrome. Return `true` if it is possible to form such a palindrome; otherwise, return `false`.","solution":"def can_form_palindrome(s): Returns true if it is possible to form a palindrome with any non-empty subsequence of `s`. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"Given a string `s`, split the string into as many parts as possible so that each letter appears in at most one part, and return _a list of integers_ representing the size of these parts.","solution":"def partition_labels(s): Partition the string s into as many parts as possible so that each letter appears in at most one part. Return a list of integers representing the size of these parts. last_occurrences = {char: idx for idx, char in enumerate(s)} partitions = [] start, end = 0, 0 for i, char in enumerate(s): end = max(end, last_occurrences[char]) if i == end: partitions.append(i - start + 1) start = i + 1 return partitions"},{"question":"You are given a **non-empty** string `s`. You can remove at most one character from the string such that the resulting string is a palindrome. Return _a boolean value indicating whether it is possible to derive a palindrome from the given string by removing at most one character_. For example, given the string `\\"abca\\"`, you can remove the character `\'c\'` to get the string `\\"aba\\"`, which is a palindrome.","solution":"def valid_palindrome(s): Checks if a string can be palindrome by removing at most one character. def is_palindrome_range(i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True i, j = 0, len(s) - 1 while i < j: if s[i] != s[j]: return is_palindrome_range(i+1, j) or is_palindrome_range(i, j-1) i += 1 j -= 1 return True"},{"question":"You are given an array of integers `arr` and an integer `k`. A subset of the array is considered special if the sum of the elements in the subset is equal to `k`. Return the number of special subsets of the array `arr`. Implement the function `int countSpecialSubsets(int[] arr, int k)` that returns the number of special subsets of `arr` whose sum is equal to `k`. Note: A subset can contain duplicate elements from the original array, and an empty subset should not be considered special.","solution":"def countSpecialSubsets(arr, k): Returns the number of subsets whose sum is equal to k. from itertools import combinations def subset_sum(arr, k): count = 0 for r in range(1, len(arr) + 1): for subset in combinations(arr, r): if sum(subset) == k: count += 1 return count return subset_sum(arr, k)"},{"question":"A **strobogrammatic number** is a number that looks the same when rotated 180 degrees (looked at upside down). For example, `69`, `88`, and `818` are strobogrammatic, but `962` is not. Given a string `num` representing a number, determine if it is strobogrammatic. Return _`true` if the number is strobogrammatic and `false` otherwise_.","solution":"def is_strobogrammatic(num: str) -> bool: Determines if the given number is strobogrammatic. Args: num (str): The number represented as a string. Returns: bool: True if the number is strobogrammatic, False otherwise. strobogrammatic_pairs = {\'0\': \'0\', \'1\': \'1\', \'6\': \'9\', \'8\': \'8\', \'9\': \'6\'} left, right = 0, len(num) - 1 while left <= right: if num[left] not in strobogrammatic_pairs or num[right] not in strobogrammatic_pairs: return False if strobogrammatic_pairs[num[left]] != num[right]: return False left += 1 right -= 1 return True"},{"question":"Given an integer array `arr`, return an array of the length of each contiguous sequence of identical numbers in `arr`. The resulting array should be generated in the order of the sequences as they appear in `arr`.","solution":"def sequence_lengths(arr): Returns the lengths of contiguous sequences of identical numbers in the given list. if not arr: return [] lengths = [] current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i-1]: current_length += 1 else: lengths.append(current_length) current_length = 1 lengths.append(current_length) return lengths"},{"question":"You are given an array of `n` integers `arr` that represents a mountain array. A mountain array is defined as an array that: 1. has at least `3` elements. 2. There exists some `i` (0 < i < n-1) such that: - `arr[0] < arr[1] < ... < arr[i]` - `arr[i] > arr[i+1] > ... > arr[n-1]` Find and return the element at the peak of the mountain array. If no valid mountain array structure is present, return `-1`.","solution":"def find_peak_mountain_array(arr): This function returns the peak element in the mountain array. If no valid mountain array structure is present, it returns -1. if len(arr) < 3: return -1 left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] < arr[mid + 1]: left = mid + 1 else: right = mid # Verify that the array is a valid mountain array if left == 0 or left == len(arr) - 1: return -1 return arr[left]"},{"question":"Given a string `s` consisting of lowercase English letters, determine whether you can generate the string by concatenating only one character a certain number of times. For example, \\"aaa\\" can be generated by concatenating the character \'a\' three times, but \\"abc\\" cannot be generated by repeating a single character. Return `true` if it is possible and `false` otherwise.","solution":"def can_generate_by_repeating_one_char(s): Determine if the string can be generated by repeating one character. Args: s (str): The input string consisting of lowercase English letters. Returns: bool: True if the string can be generated by repeating one character, False otherwise. if not s: return False first_char = s[0] for char in s: if char != first_char: return False return True"},{"question":"You are given a string `word` and an integer `n`. Your task is to shift each letter in the string `word` by `n` positions forward in the alphabet. If the shift moves past \'z\', it should wrap around to the beginning of the alphabet. Maintain the case of the letters (i.e., lowercase and uppercase) and ensure that non-letter characters remain unchanged. Return _the resulting string after shifting each letter by `n` positions forward_.","solution":"def shift_letter(ch, n): if \'a\' <= ch <= \'z\': return chr((ord(ch) - ord(\'a\') + n) % 26 + ord(\'a\')) elif \'A\' <= ch <= \'Z\': return chr((ord(ch) - ord(\'A\') + n) % 26 + ord(\'A\')) return ch def shift_string(word, n): Shifts each letter in the string `word` by `n` positions forward in the alphabet. Non-letter characters remain unchanged. return \'\'.join(shift_letter(ch, n) for ch in word)"},{"question":"Given a list of non-negative integers `nums`, arrange them such that they form the largest number possible. Return the result as a string. For example, if `nums = [3, 30, 34, 5, 9]`, the largest formed number is `9534330`. Implement the function `String largestNumber(int[] nums)`, which will receive an array of integers and return the largest possible number as a string. Note: The result may be very large, so you need to return a string instead of an integer.","solution":"from functools import cmp_to_key def largestNumber(nums): Given a list of non-negative integers nums, arrange them such that they form the largest number possible. Return the result as a string. def compare(a, b): if a + b > b + a: return -1 elif a + b < b + a: return 1 else: return 0 # Convert the numbers to strings for easier comparison nums_str = list(map(str, nums)) # Sort nums based on the custom comparator nums_str.sort(key=cmp_to_key(compare)) # Join sorted strings largest_num = \'\'.join(nums_str) # Edge case: if the largest number starts with 0, the number is actually 0 if largest_num[0] == \'0\': return \'0\' return largest_num"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `limit`. Your task is to split the string into as many parts as possible such that each part is a substring of `s` and the length of each substring does not exceed `limit`. The substrings should be as balanced as possible in length. Return _a list containing all possible balanced substring splits_. If `limit` is greater than or equal to the length of the string, return the entire string as the only element in the list.","solution":"def split_string(s, limit): Splits string `s` into as many parts as possible such that each part is a substring of `s` and the length of each substring does not exceed `limit`. Parameters: s (str): the input string limit (int): the maximum length of each substring Returns: list: a list of substrings if limit >= len(s): return [s] substrings = [] for i in range(0, len(s), limit): substrings.append(s[i:i+limit]) return substrings"},{"question":"Given an array of integers `nums` and a positive integer `k`, you need to rotate the array to the right by `k` steps. Return the modified array after performing the rotation. Note that the rotation should be performed in-place with O(1) extra space complexity.","solution":"def rotate(nums, k): Rotates the given list to the right by k steps in-place. Arguments: nums -- a list of integers k -- a positive integer indicating the number of steps to rotate n = len(nums) k = k % n # In case k is greater than length of nums def reverse(lst, start, end): while start < end: lst[start], lst[end] = lst[end], lst[start] start += 1 end -= 1 # Reverse the entire list reverse(nums, 0, n - 1) # Reverse first k elements reverse(nums, 0, k - 1) # Reverse remaining elements reverse(nums, k, n - 1) return nums"},{"question":"You are given a list of strings `words`. Each string in `words` consists of lowercase English letters. Write a function to find the word that appears the most number of times in `words`. If there are multiple words with the same highest frequency, return the one that appears last in the list. If the list is empty, return an empty string.","solution":"def most_frequent_word(words): Finds the word that appears the most number of times in words. If multiple words have the same highest frequency, returns the one that appears last in the list. :param words: List of strings :return: String that is the most frequent word from collections import Counter if not words: return \\"\\" word_count = Counter(words) max_frequency = max(word_count.values()) # Find the last word with max frequency most_frequent = \\"\\" for word in words: if word_count[word] == max_frequency: most_frequent = word return most_frequent"},{"question":"You are given an integer array `arr` representing the number of chips placed at positions `[0, 1, 2, ..., arr.length - 1]` on a line. Chips can be moved to either of the two adjacent positions or can remain at their current position. Moving a chip to an adjacent position costs `0` if the positions are of the same parity (both even or both odd) and costs `1` otherwise. Find the _minimum cost required_ to move all chips to the same position. Return this minimum cost.","solution":"def min_cost_to_move_chips(arr): Returns the minimum cost required to move all chips to the same position. even = sum(1 for x in arr if x % 2 == 0) odd = sum(1 for x in arr if x % 2 != 0) return min(even, odd)"},{"question":"You are given an array of integers `arr` representing a list of n books, where `arr[i]` denotes the total number of pages in the i-th book. You need to allocate these books to `k` students such that each student receives at least one book, and the maximum number of pages assigned to any student is minimized. Return the minimal possible value of the maximum pages allocation. Implement the function `int allocateBooks(int[] arr, int k)` where `arr` is the array of books and `k` is the number of students. You may assume: - The total number of pages is greater than or equal to the number of students. - It is always possible to assign books such that each student gets at least one book.","solution":"def allocateBooks(arr, k): Allocates books to k students such that the maximum number of pages assigned to any student is minimized. The function returns the minimal possible value of the maximum pages allocation. :param arr: List of integers representing the number of pages in each book. :param k: Integer representing the number of students. :return: Integer representing the minimal possible value of the maximum pages allocation. def is_possible(mid): students = 1 current_pages = 0 for pages in arr: if current_pages + pages > mid: students += 1 current_pages = pages if students > k: return False else: current_pages += pages return True if k > len(arr): return -1 low = max(arr) high = sum(arr) result = high while low <= high: mid = (low + high) // 2 if is_possible(mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"Write a function that takes a 2-dimensional array `matrix` of size `m x n` where each element represents the cost of a cell to step on. You start at the top-left corner `(0,0)` and you must move to the bottom-right corner `(m-1, n-1)`. You can only move right or down at each step. Return the minimum cost to reach the bottom-right corner of the matrix.","solution":"def min_path_sum(matrix): Return the minimum cost to reach from the top-left corner to the bottom-right corner of the matrix. You can only move right or down at each step. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) for i in range(1, m): matrix[i][0] += matrix[i-1][0] # Fill in the first column by adding the cell above for j in range(1, n): matrix[0][j] += matrix[0][j-1] # Fill in the first row by adding the cell to the left for i in range(1, m): for j in range(1, n): matrix[i][j] += min(matrix[i-1][j], matrix[i][j-1]) # Choose the minimum path sum from the top or from the left return matrix[-1][-1] # The bottom-right corner will contain the minimum path sum"},{"question":"You are given a 2D integer array `intervals`, where `intervals[i] = [starti, endi]` represent the start and end time of the `ith` meeting. You need to attend as many non-overlapping meetings as possible. Return _the maximum number of non-overlapping meetings you can attend_.","solution":"def max_non_overlapping_meetings(intervals): Returns the maximum number of non-overlapping meetings. Args: intervals: List of [start, end] times of the meetings. Returns: Integer representing the maximum number of non-overlapping meetings. # Sort intervals based on end time intervals.sort(key=lambda x: x[1]) max_meetings = 0 last_end_time = float(\'-inf\') for start, end in intervals: if start >= last_end_time: max_meetings += 1 last_end_time = end return max_meetings"},{"question":"You are given a 2D list of integers `matrix` where each row is sorted in ascending order from left to right and each column is sorted in ascending order from top to bottom. Write a function that takes this `matrix` and a target integer `k` and returns `true` if `k` is present in the `matrix`, otherwise return `false`.","solution":"def search_matrix(matrix, k): Returns True if k is present in the 2D list matrix, otherwise False. Each row in the matrix is sorted in ascending order from left to right. Each column in the matrix is sorted in ascending order from top to bottom. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == k: return True elif matrix[row][col] > k: col -= 1 else: row += 1 return False"},{"question":"Given a string `s`, return the length of the longest substring where all the characters are unique. If a character repeats, the substring ends before the repeating character. Write the code that finds this length, ensuring the solution is efficient.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. n = len(s) char_index_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a list of non-negative integers `nums` and an integer target `k`. Your task is to determine if there are two distinct indices `i` and `j` in `nums` such that the absolute difference between `nums[i]` and `nums[j]` is exactly `k`. Implement the function: * `boolean containsDifference(int[] nums, int k)` - Returns `true` if there exist two distinct indices with the said property, otherwise returns `false`. For example: * Given `nums = [1, 7, 5, 9, 3, 2]` and `k = 4`, the function should return `true` because `|7 - 3| = 4`. * Given `nums = [1, 5, 3, 1]` and `k = 2`, the function should return `true` because `|3 - 1| = 2`. **Note** that: * An absolute difference between two numbers is the non-negative value of their subtraction. * The indices `i` and `j` must be distinct (i.e., `i != j`).","solution":"def contains_difference(nums, k): Returns true if there exist two distinct indices i and j in nums such that the absolute difference between nums[i] and nums[j] is exactly k, otherwise returns false. num_set = set(nums) for num in nums: if (num + k) in num_set or (num - k) in num_set: return True return False"},{"question":"You are given a directed acyclic graph (DAG) represented by a `0-indexed` integer array `edges` of length `n`, where `edges[i]` indicates that there is a directed edge from node `i` to node `edges[i]` in the graph. If there is no outgoing edge from node `i`, `edges[i]` will be `-1`. Each node is initially colored white. You need to perform a sequence of operations where in each operation you can select any white node and color it either red or blue. Once a node is colored red, it turns all its descendants red, and similarly, once a node is colored blue, it turns all its descendants blue. All nodes colored in one operation must be direct descendants of the initially chosen white node. Your task is to determine the minimum number of operations required to color all the nodes in the graph such that no two nodes with a direct edge between them have the same color. Return _the minimum number of operations needed to color the graph_.","solution":"def minOperationsToColorGraph(edges): Returns the minimum number of operations needed to color the graph such that no two nodes with a direct edge between them have the same color. :param edges: List[int] - the directed acyclic graph (DAG) represented as an integer array. :return: int - the minimum number of operations needed. # Create an adjacency list from edges n = len(edges) adj = [[] for _ in range(n)] for i in range(n): if edges[i] != -1: adj[i].append(edges[i]) # Utility function for DFS to track the depth of each node def dfs(node, depth): visited[node] = True max_depth[0] = max(max_depth[0], depth) for neighbor in adj[node]: if not visited[neighbor]: dfs(neighbor, depth + 1) # Array to keep track of full depth traversal visited = [False] * n max_depth = [0] # Perform DFS on each node for i in range(n): if not visited[i]: dfs(i, 0) # The minimum number of nodes needed to be colored is maximum depth + 1 # (since each depth level requires alternation in colors) return max_depth[0] + 1"},{"question":"Given a 2D grid `grid` of `m` x `n` size containing the characters `\'0\'` and `\'1\'`, where `\'1\'` represents land, and `\'0\'` represents water, return the number of **islands**. An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. The signature of the function is `def numIslands(grid: List[List[str]]) -> int:`.","solution":"from typing import List def numIslands(grid: List[List[str]]) -> int: if not grid: return 0 m, n = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != \'1\': return grid[x][y] = \'0\' dfs(x-1, y) dfs(x+1, y) dfs(x, y-1) dfs(x, y+1) num_islands = 0 for i in range(m): for j in range(n): if grid[i][j] == \'1\': num_islands += 1 dfs(i, j) return num_islands"},{"question":"You are given two strings, `s` and `t`, both consisting of lowercase letters. You need to determine if it is possible to convert `s` into `t` by performing a series of operations. In one operation, you can: 1. Choose one character from string `s` and delete it. 2. Choose one character from string `t` and delete it. Return _the minimum number of operations required to convert `s` into `t`_. If it is not possible to convert `s` into `t`, return `-1`.","solution":"def min_operations_to_convert(s, t): Returns the minimum number of operations required to convert string `s` into string `t`. If it is not possible, returns -1. from collections import Counter s_counter = Counter(s) t_counter = Counter(t) # Check if conversion is possible for char in t_counter: if t_counter[char] > s_counter[char]: return -1 # Calculate minimum operations min_operations = 0 for char in s_counter: if s_counter[char] > t_counter[char]: min_operations += s_counter[char] - t_counter[char] return min_operations"},{"question":"Given an integer array `arr` where the values are in the range [1, n] and an integer `sum`, _find all unique combinations in arr where the numbers sum to `sum`_. Each number in `arr` may only be used once in the combination. Return the list of all combinations.","solution":"def combination_sum(arr, target): Finds all unique combinations of numbers in `arr` that sum to `target`. Each number in `arr` may be used at most once in each combination. :param arr: List[int], the array of numbers. :param target: int, the target sum. :return: List[List[int]], all unique combinations that sum to the target. def backtrack(start, target, path, result): if target == 0: result.append(path[:]) return if target < 0: return for i in range(start, len(arr)): if i > start and arr[i] == arr[i-1]: continue path.append(arr[i]) backtrack(i + 1, target - arr[i], path, result) path.pop() arr.sort() result = [] backtrack(0, target, [], result) return result"},{"question":"Given a string `s` representing a valid parentheses sequence, where each opening parenthesis \'(\' has a corresponding closing parenthesis \')\', determine the maximum depth of nested parentheses. The maximum depth is defined as the largest number of pairs of balanced parentheses that are nested inside each other. Return _the maximum depth_. Example: Input: ```s = \\"((()))\\"``` Output: ```3``` Input: ```s = \\"(())()()\\"``` Output: ```2```","solution":"def max_depth(s: str) -> int: Computes the maximum depth of nested parentheses. Parameters: s (str): The string representing a valid parentheses sequence. Returns: int: The maximum depth of nested parentheses. max_depth = 0 current_depth = 0 for char in s: if char == \'(\': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == \')\': current_depth -= 1 return max_depth"},{"question":"You are given a string array `words` and an integer `k`. A string `words[i]` is considered \\"unique\\" if it appears exactly `k` times in the array. Write a function that returns the number of unique strings that appear exactly `k` times in the array `words`. The return value should be an integer representing the count of such unique strings.","solution":"from collections import Counter def count_unique_strings(words, k): Returns the number of unique strings that appear exactly k times in the array words. Args: words (list of str): List of words. k (int): The exact number of times a word should appear to be considered unique. Returns: int: The count of unique strings appearing exactly k times. word_counts = Counter(words) unique_count = sum(1 for count in word_counts.values() if count == k) return unique_count"},{"question":"You are given a string `expression` representing a valid mathematical expression consisting of digits and the characters `+`, `-`, `*`, and `/`. Implement an algorithm to evaluate the given arithmetic expression and return the result as an integer. Note that division should truncate toward zero. The given expression is guaranteed to be valid and will not contain any spaces. Consider the operator precedence and the order of operations. For example, the expression \\"3+2*2\\" should be evaluated to 7, and the expression \\"14-3/2\\" should be evaluated to 13.","solution":"def evaluate_expression(expression): Evaluates a valid mathematical expression and returns the result as an integer. Division should truncate toward zero. def operate(operand1, operand2, operator): if operator == \'+\': return operand1 + operand2 elif operator == \'-\': return operand1 - operand2 elif operator == \'*\': return operand1 * operand2 elif operator == \'/\': return int(operand1 / operand2) # Truncate toward zero current_number = 0 result = 0 last_operator = \'+\' stack = [] for i, char in enumerate(expression): if char.isdigit(): current_number = current_number * 10 + int(char) if char in \'+-*/\' or i == len(expression) - 1: if last_operator in \'+-\': if last_operator == \'+\': stack.append(current_number) else: stack.append(-current_number) elif last_operator in \'*/\': if last_operator == \'*\': stack.append(stack.pop() * current_number) else: stack.append(int(stack.pop() / current_number)) current_number = 0 last_operator = char return sum(stack)"},{"question":"A message containing letters from A-Z can be encoded into numbers using the following mapping: ``` \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 ``` To decode an encoded message, you may decode it in multiple ways. For instance, \\"12\\" could be decoded as \\"AB\\" (1 2) or \\"L\\" (12). Given a string `s` containing only digits, return the total number of ways to decode it. Note that the decoded ways should be counted if and only if each split of the string could represent a valid mapping of characters (\'A\' to \'Z\'). Consider the following example: ``` Input: s = \\"226\\" Output: 3 Explanation: \\"226\\" can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), and \\"BBF\\" (2 2 6). ```","solution":"def num_decodings(s): Given a string s containing only digits, return the total number of ways to decode it. if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 # An empty string has one way to decode for i in range(1, n + 1): if s[i-1] != \'0\': dp[i] += dp[i-1] if i != 1 and \'10\' <= s[i-2:i] <= \'26\': dp[i] += dp[i-2] return dp[-1]"},{"question":"Given an array of integers `arr` representing the prices of items over a series of days, find the maximum profit you can achieve by buying and selling the item\'s shares considering that you may complete up to `k` transactions. However, you cannot engage in multiple transactions at the same time (you must sell the item shares before you can buy again). Return the maximum profit you can achieve.","solution":"def maxProfit(k, prices): if not prices or k == 0: return 0 n = len(prices) # If k >= n // 2, then we can complete as many transactions as we want. if k >= n // 2: return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1)) # dp[i][j] represents the maximum profit up to day i with at most j transactions. dp = [[0] * (k + 1) for _ in range(n)] for j in range(1, k + 1): max_diff = -prices[0] for i in range(1, n): dp[i][j] = max(dp[i - 1][j], prices[i] + max_diff) max_diff = max(max_diff, dp[i][j - 1] - prices[i]) return dp[-1][-1]"},{"question":"A binary tree is given with `n` nodes where each node has a unique value from `1` to `n`. You are also provided an integer `target` which represents the sum you need to find in the tree. Your task is to determine _whether there\'s a root-to-leaf path in the binary tree such that adding up all the values along the path equals the given `target`. Return `true` if such a path exists, otherwise, return `false`._ Each node in the tree is represented by a structure `TreeNode` which has a value `val`, and pointers to its left child and right child.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, target): Returns True if there\'s a root-to-leaf path in the binary tree such that adding up all the values along the path equals the given target. Otherwise, returns False. if not root: return False # If this is a leaf node if not root.left and not root.right: return root.val == target # Recursively check the left and right subtrees target -= root.val return has_path_sum(root.left, target) or has_path_sum(root.right, target)"},{"question":"Given an m x n matrix `grid` filled with non-negative integers, you can move from one cell to another cell in four possible directions (up, down, left, or right). You cannot move through a cell that contains a `0`. From any cell, you can only move to another cell if the latter has a strictly greater value than the current cell. Find and return the length of the longest path in the grid that satisfies these conditions.","solution":"def longestIncreasingPath(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) memo = [[-1] * n for _ in range(m)] def dfs(x, y): if memo[x][y] != -1: return memo[x][y] longest = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] > grid[x][y]: longest = max(longest, 1 + dfs(nx, ny)) memo[x][y] = longest return longest max_path = 0 for i in range(m): for j in range(n): max_path = max(max_path, dfs(i, j)) return max_path"},{"question":"A university has a new online system that issues unique IDs to all its students. Each ID is a string consisting only of uppercase English letters. Due to a programming error, some of the IDs have very similar patterns. The university considers an ID \\"suspicious\\" if it contains two consecutive identical characters. You are given a list of strings `ids` representing the issued IDs. Write a function `remove_suspicious` that identifies and removes all suspicious IDs from the list. Return the list of valid IDs in their original order. ``` Example: Input: ids = [\\"ABCD\\", \\"AABF\\", \\"XYXY\\", \\"ZZZZ\\", \\"MNOP\\"] Output: [\\"ABCD\\", \\"XYXY\\", \\"MNOP\\"] ```","solution":"def remove_suspicious(ids): Removes IDs that contain two consecutive identical characters. def is_suspicious(id_): Returns True if the ID contains two consecutive identical characters. for i in range(len(id_) - 1): if id_[i] == id_[i + 1]: return True return False valid_ids = [id_ for id_ in ids if not is_suspicious(id_)] return valid_ids"},{"question":"You are given an array of integers `nums` and an integer `threshold`. Implement the function `int smallestDivisor(int[] nums, int threshold)` which returns the smallest positive integer `d` such that the sum of the result of dividing each element in `nums` by `d` is less than or equal to `threshold`. Each division result should be rounded up to the nearest integer. Example: Given `nums = [1, 2, 5, 9]` and `threshold = 6`, the smallest divisor is 5 because 1/5 + 2/5 + 5/5 + 9/5 (rounded up) equals 1 + 1 + 1 + 2 = 5 which is <= 6.","solution":"import math def smallestDivisor(nums, threshold): def compute_sum(divisor): return sum(math.ceil(num / divisor) for num in nums) left, right = 1, max(nums) while left < right: mid = (left + right) // 2 if compute_sum(mid) > threshold: left = mid + 1 else: right = mid return left"},{"question":"You are given a 2D integer array `matrix` and two 1D integer arrays `rows` and `cols`. Each element `matrix[i][j]` represents the value at the `i-th` row and the `j-th` column of the matrix. The arrays `rows` and `cols` contain indices of certain rows and columns, respectively. A cell in the matrix is called **active** if its row index is present in `rows` or its column index is present in `cols`. Return _the **sum** of all active cells in the matrix._","solution":"def active_cells_sum(matrix, rows, cols): Returns the sum of all active cells in the matrix. A cell in the matrix is called active if its row index is present in `rows` or its column index is present in `cols`. matrix: List[List[int]] - 2D list of integers rows: List[int] - List of integers indicating the row indices to be considered active cols: List[int] - List of integers indicating the column indices to be considered active return: int - Sum of all active cells in the matrix active_sum = 0 num_rows = len(matrix) num_cols = len(matrix[0]) if num_rows > 0 else 0 active_rows = set(rows) active_cols = set(cols) for i in range(num_rows): for j in range(num_cols): if i in active_rows or j in active_cols: active_sum += matrix[i][j] return active_sum"},{"question":"You are given an array of integers `heights` representing the heights of buildings along a street, where `heights[i]` is the height of the `ith` building. Two buildings can form a container for water, where the width of the container is the distance between the two buildings, and the height of the container is the minimum height of the two buildings. Return the maximum amount of water a container can store. Implement the following function: ```python def max_water(heights: List[int]) -> int: # Your code here ``` Example: ```python max_water([1,8,6,2,5,4,8,3,7]) # Output: 49 (container between buildings at index 1 and index 8) ```","solution":"from typing import List def max_water(heights: List[int]) -> int: Calculate the maximum amount of water that can be stored between buildings. :param heights: List of integers representing building heights. :return: Maximum water that can be stored. max_water = 0 left, right = 0, len(heights) - 1 while left < right: height = min(heights[left], heights[right]) width = right - left current_water = height * width max_water = max(max_water, current_water) # Move the pointer that points to the shorter building if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"Given a list of non-negative integers `arr`, you need to find the maximum sum of elements such that no two elements are adjacent in the list. Implement the `findMaxSum` function: * `int findMaxSum(int[] arr)` - This function takes an array of non-negative integers and returns the maximum sum of elements with the no-two-elements-adjacent constraint. For example, given the array `[3, 2, 5, 10, 7]`, the function should return `15` by picking elements `3, 5, and 7`. Consider edge cases where the array might be empty or contain only one element.","solution":"def findMaxSum(arr): Returns the maximum sum of elements such that no two elements are adjacent. Parameters: arr (list of int): List of non-negative integers. Returns: int: Maximum sum of non-adjacent elements. if not arr: return 0 if len(arr) == 1: return arr[0] incl = arr[0] # Maximum sum including the previous element excl = 0 # Maximum sum excluding the previous element for i in range(1, len(arr)): # Current maximum excluding i (No two adjacent elements) new_excl = max(incl, excl) # Current maximum including i incl = excl + arr[i] excl = new_excl return max(incl, excl)"},{"question":"You are given a string `s` of lowercase alphabet characters. You can apply the following operation any number of times: choose any character in the string and change it to the next character in the alphabetical order (i.e., \'a\' becomes \'b\', \'b\' becomes \'c\', ..., \'z\' becomes \'a\'). Find the lexicographically smallest string that can be obtained after applying the operation any number of times. Note that the lexicographical order of strings is the order in which they appear in a standard dictionary.","solution":"def lexicographically_smallest_string(s): Find the lexicographically smallest string that can be obtained by changing any character in the string to the next character in alphabetical order any number of times. # The lexicographically smallest string would be where every character is \'a\' return \'a\' * len(s)"},{"question":"You are given a sorted array of integers `nums` and an integer `k`. Find the `k-th` smallest missing positive integer in the array. Return the `k-th` smallest missing positive integer. If there are multiple correct answers, you may return any of them.","solution":"def find_kth_missing_positive(nums, k): Finds the k-th smallest missing positive integer in a sorted array of integers. :param nums: List[int] - A sorted list of integers. :param k: int - The k-th missing positive integer to find. :return: int - The k-th missing positive integer. missing_count = 0 current = 1 index = 0 while missing_count < k: if index < len(nums) and nums[index] == current: index += 1 else: missing_count += 1 if missing_count < k: current += 1 return current"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `degree`. The **degree** of an array is defined as the maximum frequency of any one of its elements. Find the length of the smallest contiguous subarray of `nums` that has the same degree as `nums` and return its length. For example, given `nums = [1, 2, 2, 3, 1]`, the degree of this array is 2 because `2` and `1` appear twice each. The smallest subarray with a degree of 2 is either `[2, 2]` with a length of 2, or `[1, 2, 2, 1]` with a length of 4. Return _the length of the smallest contiguous subarray of_ `nums` _with the same degree_.","solution":"from collections import defaultdict def findShortestSubArray(nums): Returns the length of the smallest contiguous subarray of nums that has the same degree as nums. if not nums: return 0 # Dictionary to store the frequency, first index and last index of each number num_info = defaultdict(lambda: [0, 0, 0]) # [frequency, first_index, last_index] for i, num in enumerate(nums): if num_info[num][0] == 0: num_info[num][1] = i num_info[num][0] += 1 num_info[num][2] = i degree = max(num_info[num][0] for num in num_info) shortest_length = float(\'inf\') for num in num_info: if num_info[num][0] == degree: length = num_info[num][2] - num_info[num][1] + 1 shortest_length = min(shortest_length, length) return shortest_length"},{"question":"You are given a list of integers `arr` representing a permutation of the first `n` positive integers in random order. Your task is to reorder `arr` in place to obtain the next lexicographically greater permutation of integers. If such an arrangement is not possible, you must rearrange `arr` as the lowest possible order (i.e., sorted in ascending order). Implement the function: ```python def nextPermutation(arr: List[int]) -> None: pass # Your implementation here ``` **Example:** ```python arr = [1, 2, 3] nextPermutation(arr) print(arr) # Output: [1, 3, 2] ``` ```python arr = [3, 2, 1] nextPermutation(arr) print(arr) # Output: [1, 2, 3] ``` ```python arr = [1, 1, 5] nextPermutation(arr) print(arr) # Output: [1, 5, 1] ``` **Constraints:** - The length of `arr` is at least 1 and at most 10,000. - `arr` is guaranteed to be a valid permutation of the first `n` integers, where `n` is the length of `arr`.","solution":"from typing import List def nextPermutation(arr: List[int]) -> None: Reorders `arr` in place to the next lexicographically greater permutation. If such an arrangement is not possible, `arr` is arranged to the lowest possible order. n = len(arr) if n <= 1: return # Step 1: Find the largest index k such that arr[k] < arr[k + 1]. If no such index exists, just reverse arr. k = -1 for i in range(n - 1): if arr[i] < arr[i + 1]: k = i if k == -1: arr.reverse() return # Step 2: Find the largest index l greater than k such that arr[k] < arr[l]. for l in range(n - 1, k, -1): if arr[k] < arr[l]: # Step 3: Swap elements at k and l arr[k], arr[l] = arr[l], arr[k] break # Step 4: Reverse the sequence from k + 1 to the end of the array arr[k + 1:] = reversed(arr[k + 1:])"},{"question":"You are given a **binary** tree with `n` nodes, where each node contains an integer value. The value of each node is unique. Write a function that returns _the largest value that can be found in any root-to-leaf path in the binary tree_. A root-to-leaf path is defined as a path starting from the root and ending at any leaf node. Implement this function and ensure that it traverses the tree efficiently.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def find_largest_value_in_path(root): def find_max_recursive(node): if not node: return float(\'-inf\') if not node.left and not node.right: return node.value max_left = find_max_recursive(node.left) max_right = find_max_recursive(node.right) return max(node.value, max_left, max_right) return find_max_recursive(root)"},{"question":"You are given two strings `s1` and `s2` both of length `n` consisting of lowercase English letters. You can change any character in `s1` to another character any number of times. Write a function that returns the minimum number of changes needed to make `s1` and `s2` anagrams of each other. An anagram of a string is a string that contains the same characters, only the order of characters can be different.","solution":"def min_changes_to_anagram(s1, s2): from collections import Counter # Count frequency of each character in s1 and s2 count_s1 = Counter(s1) count_s2 = Counter(s2) # Calculate the number of changes for each character changes = 0 for char in count_s1: if char in count_s2: # Calculate the difference in counts for characters present in both strings changes += abs(count_s1[char] - count_s2[char]) else: # All characters in s1 that are not in s2 must be changed changes += count_s1[char] for char in count_s2: if char not in count_s1: # All characters in s2 that are not in s1 must be added to changes changes += count_s2[char] # Since each change may have been counted twice, halve the final count return changes // 2"},{"question":"You are given an integer array `arr`. Your task is to determine whether the array can be partitioned into three non-empty parts with equal sums. If possible, return `true`; otherwise, return `false`. A partition is a split of the array into three contiguous subarrays, denoted as `[arr[0], …, arr[i-1]]`, `[arr[i], …, arr[j-1]]`, and `[arr[j], …, arr[n-1]]` where `0 < i < j < n`.","solution":"def can_partition_three_parts_equal_sum(arr): total_sum = sum(arr) # If total sum is not divisible by 3, we cannot partition it into three parts with equal sum if total_sum % 3 != 0: return False target = total_sum // 3 current_sum = 0 count = 0 for num in arr: current_sum += num if current_sum == target: count += 1 current_sum = 0 # We need at least three parts with equal sum return count >= 3"},{"question":"Given a string `p` consisting of lowercase English letters, return the number of distinct non-empty **substrings** of `p` that can be found at least once on an infinitely concatenated string consisting of `p` repeated indefinitely. Each distinct substring should appear exactly as it did in the original string `p`.","solution":"def distinct_substrings_in_concatenated_string(p): Returns the number of distinct non-empty substrings of `p` that can be found at least once in an infinitely concatenated string of `p`. n = len(p) substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(p[i:j]) return len(substrings)"},{"question":"You are given a string `time` in the format of \\"HH:MM\\" which represents a 24-hour clock time. Write a function that returns the next closest time that can be formed by reusing the current digits of `time`. You can reuse each digit as many times as needed and the result should be in the same format. Example: ``` Input: time = \\"19:34\\" Output: \\"19:39\\" Input: time = \\"23:59\\" Output: \\"22:22\\" ```","solution":"def nextClosestTime(time): Given a string time in the format \\"HH:MM\\", returns the next closest time that can be formed by reusing the current digits of time. # Extract digits from the given time string digits = {int(x) for x in time if x != \':\'} current_minutes = int(time[:2]) * 60 + int(time[3:]) while True: current_minutes = (current_minutes + 1) % (24 * 60) next_time = f\'{current_minutes // 60:02}:{current_minutes % 60:02}\' if all(int(c) in digits for c in next_time if c != \':\'): return next_time"},{"question":"You are given an array of integers `heights` representing the heights of students in a class. The array is not necessarily sorted. Your task is to return the minimum number of students that must move to different positions in the array so that the heights become sorted in non-decreasing order.","solution":"def height_checker(heights): Returns the minimum number of students that must move to different positions in the array so that the heights become sorted in non-decreasing order. sorted_heights = sorted(heights) move_count = 0 for i in range(len(heights)): if heights[i] != sorted_heights[i]: move_count += 1 return move_count"},{"question":"You have been given a 2D integer array `matrix` representing an `m x n` grid where each cell contains either a `0` or a `1`. You are also given an integer `k`. A **block** is a submatrix containing only `1`s. Return the maximum area of a block you can form in the grid that contains exactly `k` `1`s. If no such block exists, return `0`.","solution":"def max_area_of_block_with_k_ones(matrix, k): Return the maximum area of a block containing exactly k 1\'s. If no such block exists, return 0. The input matrix is a 2D integer array where each cell contains either a 0 or a 1. m, n = len(matrix), len(matrix[0]) # Prepare auxiliary dp arrays to store consecutive 1s left = [[0] * n for _ in range(m)] up = [[0] * n for _ in range(m)] # Populate left and up arrays for i in range(m): for j in range(n): if matrix[i][j] == 1: left[i][j] = (left[i][j-1] + 1) if j > 0 else 1 up[i][j] = (up[i-1][j] + 1) if i > 0 else 1 max_area = 0 # Explore all possible submatrices for i in range(m): for j in range(n): if matrix[i][j] == 1: min_width = left[i][j] for row in range(i, -1, -1): if matrix[row][j] == 0: break min_width = min(min_width, left[row][j]) height = i - row + 1 area = min_width * height ones_count = sum(matrix[r][j-min_width+1:j+1].count(1) for r in range(row, row + height)) if ones_count == k: max_area = max(max_area, area) return max_area"},{"question":"You are given a 0-indexed integer array `nums` and an integer `threshold`. You need to find the **smallest** integer `k` such that the array formed by **dividing** each element of `nums` by `k` and then taking the **ceiling** of each division result, has a **sum** that is less than or equal to `threshold`. Return _the smallest integer `k`_, or _-1 if no such `k` exists_.","solution":"import math def smallest_divisor(nums, threshold): Finds the smallest integer k such that the sum of the ceilings of nums divided by k is <= threshold. Args: nums (list of int): The input list of integers. threshold (int): The threshold to compare the sum against. Returns: int: The smallest integer k that satisfies the condition or -1 if no such k exists. def compute_sum(divisor): return sum(math.ceil(num / divisor) for num in nums) left, right = 1, max(nums) result = -1 while left <= right: mid = (left + right) // 2 if compute_sum(mid) <= threshold: result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"You are given a **0-indexed** integer array `arr` representing the initial state of a sequence. You can perform the following types of operations on `arr`: 1. For an operation of type 1, `operation[i] = [1, idx, val]`, update the element at index `idx` to `val`. 2. For an operation of type 2, `operation[i] = [2, idx]`, find the sum of elements from the start of the array to index `idx`. Given a 2D array `operations` where each `operations[i]` represents an operation to be performed on `arr`, return an array containing the results of all type 2 operations in the order they appear.","solution":"def perform_operations(arr, operations): Perform operations on the given array and return the results of all type 2 operations. :param arr: List[int] - Initial state of the array. :param operations: List[List[int]] - List of operations to be performed on the array. :return: List[int] - Results of all type 2 operations. result = [] for operation in operations: if operation[0] == 1: # Update operation: [1, idx, val] idx, val = operation[1], operation[2] arr[idx] = val elif operation[0] == 2: # Sum operation: [2, idx] idx = operation[1] result.append(sum(arr[:idx + 1])) return result"},{"question":"Given a list of `points` where `points[i] = [xi, yi]` represents a point in the 2D plane, return the **number of boomeranges**. A boomerang is defined as a tuple of points (i, j, k) such that the distance between `i` and `j` equals the distance between `i` and `k` (the order of the tuple matters). You may assume that the number of points is at most 500 and all coordinates are integers.","solution":"def number_of_boomerangs(points): from collections import defaultdict def get_distance(p1, p2): return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 boomerangs = 0 for i in range(len(points)): distance_count = defaultdict(int) for j in range(len(points)): if i != j: distance = get_distance(points[i], points[j]) distance_count[distance] += 1 for count in distance_count.values(): if count > 1: boomerangs += count * (count - 1) return boomerangs"},{"question":"You are given two strings `word1` and `word2`. You want to construct the string `target` by alternating characters from `word1` and `word2` starting with the first character of `word1`. If `word1` or `word2` runs out of characters, continue with the remaining characters of the other string. Return the constructed string `target`.","solution":"def merge_alternately(word1, word2): Merge two strings alternately starting with the first character of word1. If one string is exhausted, append the remaining characters of the other string. target = [] len1, len2 = len(word1), len(word2) i, j = 0, 0 while i < len1 or j < len2: if i < len1: target.append(word1[i]) i += 1 if j < len2: target.append(word2[j]) j += 1 return \'\'.join(target)"},{"question":"Implement a function that takes a string `s` and returns the length of the longest substring that contains only unique characters. For example, given the string `\\"abcabcbb\\"`, the function should return `3` because the longest substring with all unique characters is `\\"abc\\"`. If the string is empty, the function should return `0`.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. Args: s (str): The input string. Returns: int: The length of the longest substring with all unique characters. n = len(s) if n == 0: return 0 char_set = set() left = 0 max_length = 0 for right in range(n): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given an array of integers, return the length of the longest contiguous subarray that contains at most two different numbers.","solution":"def longest_subarray_with_two_distinct(nums): Finds the length of the longest subarray with at most two distinct numbers. if not nums: return 0 start = 0 max_len = 0 count = {} for end, num in enumerate(nums): count[num] = count.get(num, 0) + 1 while len(count) > 2: count[nums[start]] -= 1 if count[nums[start]] == 0: del count[nums[start]] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given an array of integers `arr` and an integer `sum`. Your task is to find if there exists a pair of elements in the array whose sum is equal to the given `sum`. Return `true` if such a pair exists, otherwise, return `false`. The function should have a time complexity of O(n).","solution":"def has_pair_with_sum(arr, target_sum): Returns True if there exists a pair of elements in arr whose sum is equal to target_sum, otherwise False. seen = set() for num in arr: if target_sum - num in seen: return True seen.add(num) return False"},{"question":"Implement a function to perform matrix multiplication of two matrices `A` and `B`. The function should return the resultant matrix after multiplication. Ensure that the number of columns in matrix `A` equals the number of rows in matrix `B` for the multiplication to be valid. If the input matrices cannot be multiplied, return an appropriate error message.","solution":"def matrix_multiply(A, B): Multiplies two matrices A and B. Parameters: - A: List of lists, where each sublist is a row of matrix A - B: List of lists, where each sublist is a row of matrix B Returns: - Resultant matrix after multiplication or an error message if dimensions are invalid. # Get the dimensions of the matrices rows_A, cols_A = len(A), len(A[0]) rows_B, cols_B = len(B), len(B[0]) # Check if multiplication is possible if cols_A != rows_B: return \\"Invalid dimensions: cannot multiply\\" # Create the result matrix with zeroes result = [[0 for _ in range(cols_B)] for _ in range(rows_A)] # Perform matrix multiplication for i in range(rows_A): for j in range(cols_B): for k in range(cols_A): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"You are given an integer array `heights` representing the height of students standing in a line. Write a function that returns the minimum number of students that must be moved to make all the students stand in non-decreasing order of their heights. Note that when a student is moved, they must be placed at either the beginning or the end of the line and cannot be placed between any two students.","solution":"def min_moves_to_sort(heights): Returns the minimum number of students that must be moved to make all the students stand in non-decreasing order of their heights. # Sort the heights list to get the target non-decreasing order sorted_heights = sorted(heights) # Initialize two pointers for comparison left = 0 right = len(heights) - 1 # Find the longest prefix in heights that matches sorted_heights while left < len(heights) and heights[left] == sorted_heights[left]: left += 1 # Find the longest suffix in heights that matches sorted_heights while right >= 0 and heights[right] == sorted_heights[right]: right -= 1 # If left is greater than right, it means the whole array is already sorted if left >= right: return 0 # The minimum number of moves needed is the number of elements between left and right index, inclusive return right - left + 1"},{"question":"You are given an **n x n** 2D integer array `matrix` representing an image. Rotate the image **90 degrees clockwise**. You have to rotate the image in-place, which means you have to modify the input 2D array directly. Do not allocate another 2D array for the rotation. Return the matrix after it has been rotated.","solution":"def rotate(matrix): Rotate the image (matrix) 90 degrees clockwise in-place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"A supermarket wants to monitor the prices of products over a period of `n` days. You are given an integer array `prices` where `prices[i]` represents the price of a particular product on day `i`. A price drop is defined as a day where the price of the product is lower than the previous day. Given the array `prices` of length `n`, return the total number of price drop days observed in the given period.","solution":"def count_price_drops(prices): Returns the number of days where the price dropped compared to the previous day. Parameters: - prices (list): A list of integers where prices[i] represents the price of a product on day i. Returns: - int: Total number of price drop days. if len(prices) < 2: return 0 price_drops = 0 # Iterate through the price array to count price drops for i in range(1, len(prices)): if prices[i] < prices[i - 1]: price_drops += 1 return price_drops"},{"question":"Write a function `longestCommonPrefix(String[] strs)` that finds the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string `\\"\\"`. The algorithm for `longestCommonPrefix(String[] strs)` is as follows: 1. If the array is empty, return an empty string. 2. Iterate through the characters of the first string in the array. 3. For each character, compare it with the corresponding character of all other strings. 4. If a mismatch is found or the end of any string is reached, return the prefix found until that point. 5. If the loop completes, return the first string as the common prefix. Example: - Input: `[\\"flower\\", \\"flow\\", \\"flight\\"]` - Output: `\\"fl\\"` - Input: `[\\"dog\\", \\"racecar\\", \\"car\\"]` - Output: `\\"\\"` **Note:** - All given inputs are in lowercase letters and contain only lowercase letters `a-z`.","solution":"def longestCommonPrefix(strs): Finds the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string. if not strs: return \\"\\" # Take the first string as a reference first_str = strs[0] for i in range(len(first_str)): char = first_str[i] for string in strs[1:]: # If i is out of range or there\'s a mismatch if i >= len(string) or string[i] != char: return first_str[:i] return first_str"},{"question":"Given two strings `s` and `goal`, return `True` if and only if `s` can become `goal` after some number of **shifts** on `s`. A **shift** on `s` consists of moving the leftmost character of `s` to the rightmost position. For example, if `s = \\"abcde\\"`, then it will be `\\"bcdea\\"` after one shift. Note that `s` and `goal` may contain any lowercase English letters.","solution":"def can_become_goal(s, goal): Returns True if s can become goal after some number of shifts, False otherwise. if len(s) != len(goal): return False return goal in (s + s)"},{"question":"You are given two strings `word1` and `word2`, both consisting of only lowercase English letters. You need to determine if `word1` can be transformed into `word2` by rearranging its characters, swapping any pair of characters any number of times. Return `true` if it is possible to transform `word1` into `word2` in this way, otherwise return `false`.","solution":"def can_transform(word1, word2): Returns True if word1 can be transformed into word2 by rearranging its characters. Returns False otherwise. # Both words must have the same length to be transformable if len(word1) != len(word2): return False # Both words must have the same character frequencies to be transformable from collections import Counter return Counter(word1) == Counter(word2)"},{"question":"You are given an integer array `arr` and an integer `k`. For each index `i` (where `0 <= i < arr.length`), find the product of the maximum element and the minimum element among the subarrays of length `k` that end at index `i`. If there is no subarray of length `k` that ends at index `i`, the value at index `i` in the result should be -1. Return the array of results. For example, given `arr = [1,3,2,5,4]` and `k = 3`, the result would be `[-1,-1,3,10,10]`, where: - For index `i = 0` and `i = 1`, the value is -1 because there are no subarrays of length `k`. - For index `i = 2`, the subarray is [1, 3, 2] where min is 1 and max is 3, product is 3. - For index `i = 3`, the subarray is [3, 2, 5] where min is 2 and max is 5, product is 10. - For index `i = 4`, the subarray is [2, 5, 4] where min is 2 and max is 5, product is 10.","solution":"def product_of_max_and_min(arr, k): Given an integer array `arr` and an integer `k`, returns an array where for each index `i` (0 <= i < arr.length), contains the product of the maximum element and the minimum element among the subarrays of length `k` that end at index `i`. If there is no subarray of length `k` that ends at index `i`, the value at index `i` in the result should be -1. :param arr: List[int] :param k: int :return: List[int] if k > len(arr): return [-1] * len(arr) result = [-1] * len(arr) for i in range(len(arr)): if i >= k - 1: subarray = arr[i - k + 1:i + 1] min_elem = min(subarray) max_elem = max(subarray) result[i] = min_elem * max_elem return result"},{"question":"You are given an integer array `arr` and a target integer `sum`. Your task is to determine whether there are three distinct elements in `arr` whose sum equals the given `sum`. Return `true` if such a triplet exists, otherwise return `false`. It is guaranteed that each element in the array is unique.","solution":"def three_sum(arr, target_sum): Determines if there are three distinct elements in the array whose sum equals the given sum. Parameters: arr (list of int): The array of integers. target_sum (int): The target sum. Returns: bool: True if such a triplet exists, False otherwise. arr.sort() n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target_sum: return True elif current_sum < target_sum: left += 1 else: right -= 1 return False"},{"question":"Given an array of integers `nums`, you are tasked to process a series of range queries, each of the following types: 1. **Multiply** all elements within a specified range by a given integer. 2. **Retrieve** the maximum element within a specified range. Implement the RangeMaxModify class: - `RangeMaxModify(int[] nums)` Initializes the object with the integer array `nums`. - `void multiplyRange(int left, int right, int value)` Multiplies all elements in the subarray `nums[left...right]` by `value`. - `int maxInRange(int left, int right)` Returns the maximum element in the subarray `nums[left...right]`.","solution":"class RangeMaxModify: def __init__(self, nums): self.nums = nums def multiplyRange(self, left, right, value): for i in range(left, right + 1): self.nums[i] *= value def maxInRange(self, left, right): return max(self.nums[left:right + 1])"},{"question":"You are given a string `s` representing a code snippet, where each character can be a lowercase English letter, a digit, or a special character (`{\'(\', \')\', \'{\', \'}\', \'[\', \']\', \',\', \';\', \':\'}`). You need to determine if the parentheses `()`, curly braces `{}`, and square brackets `[]` in the code snippet are balanced. A sequence of symbols is balanced if all open brackets are closed by the same type of brackets in the correct order. Implement a function `bool isBalanced(string s)` that returns `true` if the string is balanced, or `false` otherwise.","solution":"def isBalanced(s: str) -> bool: Returns True if the parentheses (), curly braces {}, and square brackets [] in the string are balanced, and False otherwise. stack = [] matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket: if not stack or stack.pop() != matching_bracket[char]: return False return not stack"},{"question":"You are given an array of integers `arr` representing a sequence of positions on a number line. You are also given an integer `k` which represents the maximum distance a person can jump from any given position. Starting from the first position in the array (`arr[0]`), determine if it\'s possible to reach the last position (`arr[n-1]`) following the rules below: - From any position `arr[i]`, you can jump to any other position `arr[j]` such that `|arr[j] - arr[i]| <= k`. - You can only move forward from your current position. That is, from `arr[i]`, you can only jump to `arr[j]` if `j > i`. Return `true` if it\'s possible to reach the last position from the first position, otherwise return `false`.","solution":"def can_reach_end(arr, k): Returns whether it\'s possible to reach the last position from the first position following the given jump rules. Parameters: arr (list of int): An array of integers representing positions on a number line. k (int): The maximum distance a person can jump from any given position. Returns: bool: True if it\'s possible to reach the last position from the first position, otherwise False. n = len(arr) if n == 1: return True # We use a BFS-like approach to explore reachable positions from collections import deque queue = deque([0]) while queue: current_index = queue.popleft() current_position = arr[current_index] for next_index in range(current_index + 1, n): if arr[next_index] - current_position <= k: if next_index == n - 1: return True queue.append(next_index) else: break return False"},{"question":"A company database contains information about products in the following format: `Product(name: String, price: Double)`. You need to implement functionality that processes a list of `Product` objects to answer queries about the products. Implement a class `ProductManager` with the following methods: * `ProductManager()` Initializes the `ProductManager` object. * `void addProduct(String name, double price)` Adds a `Product` object with the given `name` and `price` to the list. * `List<String> findProductsWithPriceHigherThan(double minPrice)` Returns a list of product names with a price higher than `minPrice`, sorted in ascending order. * `double getProductPrice(String name)` Returns the price of the product with the given `name`. If the product is not found, return `-1.0`.","solution":"class Product: def __init__(self, name, price): self.name = name self.price = price class ProductManager: def __init__(self): self.products = [] def addProduct(self, name, price): self.products.append(Product(name, price)) def findProductsWithPriceHigherThan(self, minPrice): result = [product.name for product in self.products if product.price > minPrice] result.sort() return result def getProductPrice(self, name): for product in self.products: if product.name == name: return product.price return -1.0"},{"question":"Given a string `s` that contains only lowercase English letters, you can perform the following operation any number of times: choose two distinct indices `i` and `j` where `s[i] == s[j]` and swap the characters at `i` and `j`. Return _the lexicographically smallest string that can be obtained by performing the above operations_.","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by performing the given operations. # Convert the string to a list of characters chars = list(s) # Sort the characters to achieve the lexicographically smallest string chars.sort() # Join the sorted characters back into a string smallest_string = \'\'.join(chars) return smallest_string"},{"question":"You are given a string `s` and an integer `x`. The string consists of lowercase English letters and numbers. Your task is to iterate through the string and find the first digit (if any) that is greater than `x`. If there is such a digit, return the index of the first occurrence of this digit. If no such digit exists, return `-1`.","solution":"def find_first_digit_greater_than_x(s, x): Find the index of the first digit in the string `s` that is greater than the given integer `x`. Args: s (str): Input string containing lowercase English letters and numbers. x (int): The threshold integer. Returns: int: The index of the first digit greater than `x`, or -1 if no such digit exists. for index, char in enumerate(s): if char.isdigit() and int(char) > x: return index return -1"},{"question":"You are given a string `s` consisting of only lowercase English letters. You can apply the following operation any number of times: choose a non-empty substring of `s` and delete it to earn points equal to the square of the length of the substring. Your goal is to delete the string such that the total points earned are maximized. Return _the **maximum number of points** you can earn by applying the above operation._","solution":"def max_points(s: str) -> int: Returns the maximum number of points by deleting substrings such that the total points earned are maximized. Parameters: s (str): The input string consisting of only lowercase English letters. Returns: int: The maximum number of points. def calculate_points(freq): return max(freq**2 for freq in letter_counts.values()) letter_counts = {} for char in s: if char in letter_counts: letter_counts[char] += 1 else: letter_counts[char] = 1 return calculate_points(letter_counts)"},{"question":"You are given a tree, which is a connected and acyclic undirected graph, with `n` nodes labeled from `1` to `n` and `n-1` edges. You need to find **two nodes** such that their **distance** (defined as the number of edges in the shortest path connecting them) is maximized. Return _this maximum distance_.","solution":"from collections import deque def bfs_farthest_node(start, graph, n): Performs BFS to find the farthest node from the start node. visited = [False] * (n + 1) distance = [0] * (n + 1) queue = deque([start]) visited[start] = True farthest_node = start while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True distance[neighbor] = distance[node] + 1 queue.append(neighbor) if distance[neighbor] > distance[farthest_node]: farthest_node = neighbor return farthest_node, distance[farthest_node] def max_distance(n, edges): Finds the maximum distance between two nodes in a tree. if n == 1: return 0 graph = {i: [] for i in range(1, n + 1)} for u, v in edges: graph[u].append(v) graph[v].append(u) # Perform BFS from an arbitrary node to find one endpoint of the longest path start = 1 farthest_node, _ = bfs_farthest_node(start, graph, n) # Perform BFS from the farthest node found to determine the longest path in the tree other_end, max_dist = bfs_farthest_node(farthest_node, graph, n) return max_dist"},{"question":"You are given a list of `n` strings `words`. Each string represents a word. The words can only contain lowercase English letters. Your task is to find the length of the longest chain of words where each word in the chain can be formed by adding exactly one letter to the previous word in the chain. A word `b` can follow a word `a` if and only if `a` is a subsequence of `b`. Return _the length of the longest possible chain of words_.","solution":"def longestStrChain(words): Returns the length of the longest possible chain of words where each word can be formed by adding exactly one letter to the previous word in the chain. :param words: List of strings where each string represents a word. :return: Length of the longest chain of words. words.sort(key=len) # Sort words by length longest_chain = {} max_length = 1 for word in words: current_length = 1 # Check all possible predecessors of the current word for i in range(len(word)): predecessor = word[:i] + word[i+1:] if predecessor in longest_chain: current_length = max(current_length, longest_chain[predecessor] + 1) longest_chain[word] = current_length max_length = max(max_length, current_length) return max_length"},{"question":"Given a string `s` consisting of lowercase English letters and a list of pairs of integers representing indices in the string, determine the lexicographically smallest string that can be obtained by swapping the characters at the indices of any pair any number of times. You can assume that the given pairs are zero-based indices.","solution":"def lexicographically_smallest_string(s, pairs): Returns the lexicographically smallest string by swapping characters at the given pairs of indices any number of times. from collections import defaultdict def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX # Create parents array for union-find parent = list(range(len(s))) # Process each pair to build union-find structures for x, y in pairs: union(x, y) # Group all connected components groups = defaultdict(list) for i in range(len(s)): root = find(i) groups[root].append(i) # Sort each group and arrange characters accordingly s = list(s) for group in groups.values(): indices = sorted(group) chars = sorted(s[i] for i in indices) for i, char in zip(indices, chars): s[i] = char return \\"\\".join(s)"},{"question":"Given a binary tree, implement a function to return the in-order traversal of its nodes\' values, without using recursion. You need to implement the following class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` The solution should include this function: ```python def inOrderTraversal(root: TreeNode) -> list[int]: ``` This function should traverse the binary tree in in-order and return the values as a list.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inOrderTraversal(root: TreeNode) -> list: result = [] stack = [] current = root while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result"},{"question":"You are given two non-negative integers `num1` and `num2` represented as strings. The task is to implement function `addStrings` such that it returns the sum of `num1` and `num2` as a string. You are not allowed to convert the input strings to integers directly. The function should handle arbitrarily large numbers. * For example: - Input: `num1 = \\"123\\"`, `num2 = \\"456\\"` Output: `\\"579\\"` - Input: `num1 = \\"999\\"`, `num2 = \\"1\\"` Output: `\\"1000\\"` Write a function that takes `num1` and `num2` as input and returns their sum as a string.","solution":"def addStrings(num1, num2): Given two non-negative integers num1 and num2 represented as strings, returns the sum of num1 and num2 as a string. # Make sure num1 and num2 have the same length max_len = max(len(num1), len(num2)) num1 = num1.zfill(max_len) num2 = num2.zfill(max_len) carry = 0 result = [] # Start from the end of both strings for i in range(max_len - 1, -1, -1): n1 = ord(num1[i]) - ord(\'0\') n2 = ord(num2[i]) - ord(\'0\') total = n1 + n2 + carry carry = total // 10 result.append(total % 10) if carry > 0: result.append(carry) # The result is currently reversed result.reverse() return \'\'.join(map(str, result))"},{"question":"Given an unsorted array of positive integers, find a pair of integers (a, b) such that the difference between `a` and `b` is the minimum among all pairs in the array. If there are multiple pairs with the same minimum difference, return the pair with the smallest sum. If multiple pairs have the same sum, return the pair with the smallest first element. Return _the pair as a tuple `(a, b)` with `a <= b`_.","solution":"def min_diff_pair(arr): Given an unsorted array of positive integers, find a pair (a, b) such that the difference between a and b is the minimum among all pairs. If multiple pairs have the same minimum difference, return the pair with the smallest sum. If multiple pairs have the same sum, return the pair with the smallest first element. Return the pair as a tuple (a, b) with a <= b. if len(arr) < 2: return None # Sort the array arr.sort() min_diff = float(\'inf\') candidate_pairs = [] for i in range(len(arr) - 1): a, b = arr[i], arr[i + 1] diff = b - a if diff < min_diff: min_diff = diff candidate_pairs = [(a, b)] elif diff == min_diff: candidate_pairs.append((a, b)) # Find the pair with the smallest sum, and if tie, smallest first element. candidate_pairs.sort(key=lambda x: (x[0] + x[1], x[0])) return candidate_pairs[0]"},{"question":"You are given a grid represented by an array of arrays `grid` where `grid[i][j]` is the number of apples at cell `(i, j)`. You start from the top-left cell and want to collect as many apples as possible. You can only move to the right or the bottom at each step until you reach the bottom-right cell. Return _the maximum number of apples you can collect from the top-left to the bottom-right cell_. Make sure your question matches the style, tone, and complexity of the existing questions, and tests similar but not identical skills or concepts.","solution":"def max_apples(grid): Returns the maximum number of apples that can be collected from the top-left to the bottom-right cell in the grid. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Initialize a dp table with the same dimensions as the grid dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"You are given an integer array `numCourses` where `numCourses[i]` represents the number of courses you want to take at time `i` and another array `dependencies` where `dependencies[j] = [a, b]` indicates that course `b` is a prerequisite for course `a`. Determine if you can finish all courses. Return `true` if you can finish all courses, and `false` otherwise. Note that you may graphically represent the problem as a directed graph where each node is a course and a directed edge from node `b` to node `a` indicates that course `a` depends on course `b`.","solution":"from collections import defaultdict, deque def can_finish(numCourses, dependencies): Determine if you can finish all courses given the prerequisites. :param numCourses: int, the total number of courses :param dependencies: list of list of int, each element [a, b] means course a has a prerequisite course b :returns: bool, True if all courses can be finished, otherwise False adjacency_list = defaultdict(list) in_degree = {i: 0 for i in range(numCourses)} # Build the graph and compute in-degrees of nodes for dest, src in dependencies: adjacency_list[src].append(dest) in_degree[dest] += 1 # Queue for nodes with no incoming edges zero_in_degree_queue = deque([k for k in in_degree if in_degree[k] == 0]) visited_count = 0 while zero_in_degree_queue: node = zero_in_degree_queue.popleft() visited_count += 1 for neighbor in adjacency_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) return visited_count == numCourses"},{"question":"A string `S` is said to be a **unique letter string** if no two characters in `S` are the same. Given a string `S`, return _the number of substrings of `S` that are unique letter strings_. A substring is a contiguous sequence of characters within a string. Note that individual characters are counted as substrings as well. Two substrings are considered different if they have different starting or ending indices, even if they are identical in content.","solution":"def count_unique_letter_substrings(S): Returns the number of unique letter substrings of the given string S. n = len(S) total_unique_substrings = 0 for i in range(n): seen_letters = set() for j in range(i, n): if S[j] in seen_letters: break seen_letters.add(S[j]) total_unique_substrings += 1 return total_unique_substrings"},{"question":"You are given an array `heights` representing the heights of buildings along a street and an integer `bricks` representing the number of bricks you have. You can climb a building directly or use bricks to climb down if it is higher than the previous one. Each building can be climbed if it is of greater or equal height than the previous one, or if you can use the bricks to lower the height difference. Determine the maximum number of buildings you can climb starting from the first one with the available bricks. Return the maximum count of buildings climbed.","solution":"def max_buildings_climbed(heights, bricks): Given `heights` list representing heights of buildings and `bricks` representing number of bricks, determine the maximum number of buildings you can climb starting from the first one with the available bricks. Args: heights (List[int]): List of building heights. bricks (int): Number of bricks available. Returns: int: Maximum number of buildings climbed. used_bricks = 0 buildings_climbed = 1 for i in range(1, len(heights)): if heights[i] >= heights[i - 1]: buildings_climbed += 1 else: difference = heights[i - 1] - heights[i] if used_bricks + difference <= bricks: used_bricks += difference buildings_climbed += 1 else: break return buildings_climbed"},{"question":"Write a function `findErrorNums(int[] nums)` that takes an array `nums` containing `n` distinct numbers taken from the set {1, 2, ..., n} with one duplicate and one missing number. The function should return an array of two integers `[duplicate, missing]`, where `duplicate` is the number that appears twice and `missing` is the number that is missing from the set. Assume the input array is not sorted and that the function should run in O(n) time complexity and use constant space. For example, if `nums = [1, 2, 2, 4]`, then the function should return `[2, 3]` since 2 is duplicated and 3 is missing.","solution":"def findErrorNums(nums): Returns the duplicate and missing numbers in the given array. Parameters: nums (list): list of integers with one duplicate and one missing number. Returns: list: list containing the duplicate number and the missing number. n = len(nums) num_set = set() duplicate = -1 total_sum = sum(nums) expected_sum = n * (n + 1) // 2 for num in nums: if num in num_set: duplicate = num else: num_set.add(num) missing = expected_sum - (total_sum - duplicate) return [duplicate, missing]"},{"question":"You are building a social media platform and need to implement a hashtag suggestion feature. Given a list of posts, each represented as a string, and a dictionary representing hashtag frequencies, find the top `k` trending hashtags. A hashtag is defined as a string starting with the \'#\' character and containing only alphanumeric characters. Make sure to return the hashtags in decreasing order of their frequencies. If two hashtags have the same frequency, return them in lexicographical order. Implement a function `topKHashtags(posts: List[str], k: int) -> List[str]` that returns a list of the top `k` trending hashtags.","solution":"from typing import List, Dict import re from collections import Counter def topKHashtags(posts: List[str], k: int) -> List[str]: hashtags = [] hashtag_pattern = re.compile(r\'#w+\') for post in posts: hashtags.extend(hashtag_pattern.findall(post)) hashtag_counts = Counter(hashtags) sorted_hashtags = sorted(hashtag_counts.items(), key=lambda x: (-x[1], x[0])) return [hashtag for hashtag, _ in sorted_hashtags[:k]]"},{"question":"You are given a `m x n` matrix where each element has a value of **0** or **1**. Each row and column of the matrix is sorted in non-decreasing order. Find the position of a given `target` value within the matrix. Return a list containing the row and column indices of the target if it exists, otherwise return `[-1, -1]`. The search should be carried out efficiently to adhere to the sorted properties of the matrix.","solution":"def search_matrix(matrix, target): Returns the position of the target value within the matrix if found, otherwise returns [-1, -1]. Args: matrix (list of list of int): 2D sorted matrix. target (int): The target value to search for. Returns: list: A list containing the row and column indices of the target if found, otherwise [-1, -1]. if not matrix or not matrix[0]: return [-1, -1] rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return [row, col] elif matrix[row][col] < target: row += 1 else: col -= 1 return [-1, -1]"},{"question":"Given a list of `n` integers `nums`, a **range addition** operation is defined as adding a given value `inc` to all the elements within a specified inclusive range `[left, right]`. Once the range addition operations are performed, return the modified list. Implement the `RangeAddition` class: * `RangeAddition(int n)` Initializes a list of zeroes with size `n`. * `void addRange(int left, int right, int inc)` Adds `inc` to all the elements within the inclusive range `[left, right]`. * `List<Integer> getModifiedList()` Returns the modified list after all the range addition operations are performed.","solution":"class RangeAddition: def __init__(self, n): Initializes a list of zeroes with size `n`. self.n = n self.diff = [0] * (n + 1) # Using a difference array to optimize range updates def addRange(self, left, right, inc): Adds `inc` to all the elements within the inclusive range `[left, right]`. self.diff[left] += inc if right + 1 < self.n: self.diff[right + 1] -= inc def getModifiedList(self): Returns the modified list after all the range addition operations are performed. res = [0] * self.n res[0] = self.diff[0] for i in range(1, self.n): res[i] = res[i-1] + self.diff[i] return res"},{"question":"Given an integer array `arr`, determine if there exist three indices `i`, `j`, and `k` such that `0 <= i < j < k < arr.length` and `arr[i] < arr[j] > arr[k]`. If such indices exist, return `true`; otherwise, return `false`.","solution":"def find_triplet(arr): Determine if there exist three indices i, j, and k such that 0 <= i < j < k < len(arr) and arr[i] < arr[j] > arr[k]. Parameters: arr (list): The list of integers. Returns: bool: True if such indices exist, False otherwise. n = len(arr) if n < 3: return False left_min = [0] * n right_max = [0] * n # Initialize the left_min array left_min[0] = arr[0] for i in range(1, n): left_min[i] = min(left_min[i - 1], arr[i]) # Initialize the right_max array right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) # Check for the triplet condition for j in range(1, n - 1): if left_min[j - 1] < arr[j] > right_max[j + 1]: return True return False"},{"question":"You are given a `string` s consisting of lowercase English letters. You need to construct a new string by picking some characters from the original string such that every character appears an even number of times. The characters can be in any order. Return the longest possible new string that can be formed with such characters. If there is no such string, return an empty string.","solution":"from collections import Counter def longest_even_string(s): Returns the longest possible string where every character appears an even number of times. count = Counter(s) result = [] for char, freq in count.items(): if freq >= 2: result.append(char * (freq // 2 * 2)) return \'\'.join(result)"},{"question":"You are given a list of strings `words` and another string `targetWord`. The goal is to determine the minimum number of changes (insertions, deletions, or substitutions) required to convert any one of the strings in `words` to `targetWord`. Each change counts as one operation. Return the minimum number of operations needed to transform any string in the list to the target string. If the list of strings is empty, return `-1`.","solution":"def min_distance(word1, word2): Helper function to calculate the minimum edit distance between two strings using dynamic programming. m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) return dp[m][n] def min_changes(words, targetWord): Returns the minimum number of changes required to convert any of the strings in `words` to the `targetWord`. If `words` is empty, return -1. if not words: return -1 min_ops = float(\'inf\') for word in words: min_ops = min(min_ops, min_distance(word, targetWord)) return min_ops"},{"question":"You are given an integer array `nums` and an integer `x`. In one move, you can either remove the leftmost or the rightmost element from the array `nums`. The cost of this move is equal to the value of the element removed. Return the minimum number of moves required to reduce the sum of the remaining elements in the array to exactly `x`. If it is not possible to achieve this, return `-1`.","solution":"def min_operations(nums, x): target = sum(nums) - x if target == 0: return len(nums) left, current_sum = 0, 0 max_len = -1 for right in range(len(nums)): current_sum += nums[right] while current_sum > target and left <= right: current_sum -= nums[left] left += 1 if current_sum == target: max_len = max(max_len, right - left + 1) return len(nums) - max_len if max_len != -1 else -1"},{"question":"Given a 2-dimensional grid of size `m x n` where each cell represents a potential building lot, calculate the number of unique rectangular buildings that can be formed within the grid. A rectangular building is defined by selecting two distinct sets of horizontal and vertical grid lines to form the top, bottom, left, and right edges of the building. For example, in a `2 x 3` grid: ``` +---+---+---+ | | | | +---+---+---+ | | | | +---+---+---+ ``` There are 18 unique rectangular buildings one can form: - Rectangles of various sizes: `1x1`, `1x2`, `1x3`, `2x1`, `2x2`, `2x3` Implement the function `countRectangles(m, n)`, which returns the total number of unique rectangular buildings that can be formed within an `m x n` grid. # Example: - `countRectangles(2, 3)` -> `18` - `countRectangles(3, 3)` -> `36`","solution":"def countRectangles(m, n): Given a grid of size m x n, returns the total number of unique rectangles that can be formed. # To select the top and bottom edges, we choose 2 out of m+1 horizontal lines, i.e., C(m+1, 2) # To select the left and right edges, we choose 2 out of n+1 vertical lines, i.e., C(n+1, 2) num_horizontal_choices = (m * (m + 1)) // 2 num_vertical_choices = (n * (n + 1)) // 2 return num_horizontal_choices * num_vertical_choices"},{"question":"Given a binary tree, return _the sum of all nodes with an even-valued grandparent_. A **grandparent** of a node is the parent of its parent, if it exists. If there are no such nodes with an even-valued grandparent, return `0`. Each node in the tree has a `val` attribute. The tree is represented as follows: ``` class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_even_grandparent(root): Return the sum of all nodes with an even-valued grandparent. def dfs(node, parent, grandparent): if not node: return 0 total = 0 if grandparent and grandparent.val % 2 == 0: total += node.val total += dfs(node.left, node, parent) total += dfs(node.right, node, parent) return total return dfs(root, None, None)"},{"question":"You are given a string `s` consisting of lowercase alphabets and an integer `k`. You can apply one transformation to `s`, in which you can choose one character from the string and change it to another character. You are allowed to perform this transformation at most `k` times. Return _the length of the longest substring containing only one unique character that you can achieve after performing at most `k` transformations_.","solution":"def longest_substring_with_k_transforms(s, k): Returns the length of the longest substring containing only one unique character that can be achieved after performing at most k transformations. if not s: return 0 max_length = 0 left = 0 max_count = 0 frequency = [0] * 26 # As only lowercase alphabets are considered. for right in range(len(s)): frequency[ord(s[right]) - ord(\'a\')] += 1 max_count = max(max_count, frequency[ord(s[right]) - ord(\'a\')]) while (right - left + 1 - max_count) > k: frequency[ord(s[left]) - ord(\'a\')] -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are provided with a list of integers representing the amount of rainfall collected each day over a month. Your task is to find the length of the longest subsequence of days where the amount of rainfall is strictly increasing. Implement a function `longestIncreasingRainfall` that takes a list of integers `rainfalls` as input and returns an integer representing the length of the longest subsequence of strictly increasing rainfall amounts. **Note**: A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","solution":"def longestIncreasingRainfall(rainfalls): if not rainfalls: return 0 dp = [1] * len(rainfalls) for i in range(1, len(rainfalls)): for j in range(i): if rainfalls[i] > rainfalls[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a list of words and a pattern string. Return a list of words that match the pattern. A word matches the pattern if there exists a permutation of letters \'a\' to \'z\' such that after applying the permutation to the word, it exactly matches the pattern. For example, given words = [\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"] and pattern = \\"abb\\", return [\\"mee\\",\\"aqq\\"]. **Clarification:** You may assume that the words in the input list are of the same length as the pattern.","solution":"def findAndReplacePattern(words, pattern): def encode(word): mapping = {} return [mapping.setdefault(char, len(mapping)) for char in word] pattern_encoded = encode(pattern) return [word for word in words if encode(word) == pattern_encoded]"},{"question":"Given a list of integers `nums` and an integer `m`, partition the list into `m` contiguous subarrays such that the **maximum** sum of the subarrays is minimized. Return the minimized maximum sum. The partitioning must be non-empty and contiguous, and there must be exactly `m` subarrays.","solution":"def can_partition(nums, m, max_sum): Helper function to determine if we can partition the list into m subarrays with the given maximum sum. current_sum = 0 count = 1 for num in nums: if current_sum + num > max_sum: count += 1 current_sum = num if count > m: return False else: current_sum += num return True def minimize_max_sum(nums, m): Returns the minimized maximum sum of the m partitions. left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_partition(nums, m, mid): right = mid else: left = mid + 1 return left"},{"question":"Write a function `findAnagrams(s: str, p: str) -> List[int]` that finds all the start indices of `p`\'s anagrams in `s`. The function should return these start indices as a list, in ascending order. An anagram is a permutation of a string. You may assume the string `s` and `p` consist of lowercase English letters.","solution":"from collections import Counter from typing import List def findAnagrams(s: str, p: str) -> List[int]: Finds all start indices of p\'s anagrams in s and returns them as a list in ascending order. len_s, len_p = len(s), len(p) result = [] if len_p > len_s: return result p_count = Counter(p) s_count = Counter() for i in range(len_s): s_count[s[i]] += 1 # add current char to the window if i >= len_p: if s_count[s[i - len_p]] == 1: del s_count[s[i - len_p]] # remove char at the beginning as it slides out of the window else: s_count[s[i - len_p]] -= 1 # decrement count of the char as it slides if s_count == p_count: result.append(i - len_p + 1) return result"},{"question":"You are given a **0-indexed** array `heights` consisting of `n` integers. A subsequence of `heights` is called a **staircase subsequence** if it is strictly increasing and each element is exactly `1` greater than the previous element. For example, if `heights = [4, 5, 6, 7, 8, 3, 2, 1]`, then `[4, 5, 6, 7, 8]` is a staircase subsequence, but `[4, 5, 7, 8]` is not. Return _the length of the longest staircase subsequence that can be found in_ `heights`.","solution":"def longest_staircase_subsequence(heights): Returns the length of the longest staircase subsequence found in heights. if not heights: return 0 n = len(heights) longest_length = 1 current_length = 1 for i in range(1, n): if heights[i] == heights[i - 1] + 1: current_length += 1 longest_length = max(longest_length, current_length) else: current_length = 1 return longest_length"},{"question":"Write a function that takes a list of strings representing different book titles and returns the title that appears the most frequently in the list. If there is a tie, return the title that comes first lexicographically (i.e., in alphabetical order).","solution":"def most_frequent_book(titles): Returns the title that appears most frequently in the list of book titles. In case of a tie, returns the title that comes first lexicographically. from collections import Counter # Count occurrences of each title title_count = Counter(titles) # Find the maximum frequency max_frequency = max(title_count.values()) # Filter titles with the maximum frequency most_frequent_titles = [title for title, count in title_count.items() if count == max_frequency] # Return the lexicographically smallest title return min(most_frequent_titles)"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to find the length of the longest contiguous subarray such that the absolute difference between any two elements of this subarray is less than or equal to `k`. Implement a function `longestSubarray(arr, k)` that returns this length. For example, given the array `arr = [1, 5, 6, 7, 8, 10, 6, 5, 6]` and `k = 4`, the function should return `5` because the longest subarray is `[5, 6, 7, 8, 6]`.","solution":"def longestSubarray(arr, k): from collections import deque max_length = 0 min_deque, max_deque = deque(), deque() i = 0 for j in range(len(arr)): while min_deque and arr[j] < arr[min_deque[-1]]: min_deque.pop() while max_deque and arr[j] > arr[max_deque[-1]]: max_deque.pop() min_deque.append(j) max_deque.append(j) while arr[max_deque[0]] - arr[min_deque[0]] > k: if min_deque[0] == i: min_deque.popleft() if max_deque[0] == i: max_deque.popleft() i += 1 max_length = max(max_length, j - i + 1) return max_length"},{"question":"You are given an `n` x `n` 2D matrix representing an image, rotate the image by 90 degrees (clockwise). Implement the function `rotate90Clockwise(matrix: List[List[int]]) -> None` which modifies the input matrix in-place. You are not allowed to use any extra space for another 2D matrix. The rotation should be done within the original matrix itself.","solution":"from typing import List def rotate90Clockwise(matrix: List[List[int]]) -> None: Rotates the matrix by 90 degrees clockwise in place. n = len(matrix) # First step is to transpose the matrix for i in range(n): for j in range(i+1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Second step is to reverse each row for i in range(n): matrix[i].reverse()"},{"question":"Given an integer array `arr` and an integer `k`, return the count of distinct pairs `(i, j)` where `i < j` such that `arr[i] + arr[j]` is divisible by `k`. Two pairs `(i, j)` and `(u, v)` are considered distinct if `i`, `j`, `u`, and `v` are distinct indices.","solution":"def count_divisible_pairs(arr, k): Returns the count of distinct pairs (i, j) where i < j such that arr[i] + arr[j] is divisible by k. count = 0 n = len(arr) for i in range(n): for j in range(i + 1, n): if (arr[i] + arr[j]) % k == 0: count += 1 return count"},{"question":"You are given an array of integers `nums` where each integer represents the number of stones on a consecutive tile. You are allowed to remove stones from the tiles consecutively in one move. In one move, you can remove stones from a tile and, possibly, from the next consecutive tiles until you remove `rem_val` stones from one of those tiles. You should determine the minimum number of moves to remove exactly `k` stones from the sequence. Return the minimum number of moves to achieve this task.","solution":"def minMovesToRemoveKStones(nums, k): Returns the minimum number of moves to remove exactly k stones from the sequence. Parameters: nums (list): An array of integers where each integer represents the number of stones on a consecutive tile. k (int): The exact number of stones to be removed. Returns: int: The minimum number of moves to remove exactly k stones. if k == 0: return 0 moves = float(\'inf\') # Traverse through each tile for i in range(len(nums)): total_stones = 0 for j in range(i, len(nums)): total_stones += nums[j] if total_stones == k: moves = min(moves, j - i + 1) break if total_stones > k: break return moves if moves != float(\'inf\') else -1"},{"question":"You are given an array of strings `words` and an integer `k`. Each string in `words` consists of lowercase alphabets only. A string is called \\"k-alphabetical\\" if there are at least `k` different alphabets present in the string. Return the total count of \\"k-alphabetical\\" strings in the input array `words`.","solution":"def count_k_alphabetical_strings(words, k): Returns the count of strings that contain at least k different alphabets. :param words: List of strings :param k: Integer representing the minimum number of different alphabets required :return: Integer count of k-alphabetical strings count = 0 for word in words: if len(set(word)) >= k: count += 1 return count"},{"question":"**Question 4**: You are given a list of integers representing prices of different items. You are also given a budget. Your task is to determine the maximum number of items that can be bought without exceeding the budget. Return _the maximum number of items that can be bought within the given budget_.","solution":"def max_items_within_budget(prices, budget): Determines the maximum number of items that can be bought without exceeding the budget. :param prices: List of integers representing prices of different items. :param budget: An integer representing the budget. :return: Maximum number of items that can be bought within the given budget. # Sort the prices in ascending order prices.sort() # Initialize variables total_spent = 0 items_count = 0 # Iterate through the sorted prices and count the number of items bought within the budget for price in prices: if total_spent + price <= budget: total_spent += price items_count += 1 else: break return items_count"},{"question":"Given a string `s` consisting of lowercase letters, you need to perform operations to construct a new string `target`. In each operation, you can choose a subsequence of characters from `s` (the characters do not need to be contiguous), remove those characters from `s`, and append them to the end of `target`. You aim to construct `target` as lexicographically smallest as possible. Return _the **lexicographically smallest** string_ `target` _you can construct through the operations_.","solution":"def lexicographically_smallest_string(s): Construct the lexicographically smallest string based on the operations described. from collections import Counter char_count = Counter(s) target = [] seen = set() for char in s: # Reduce count of the character in the original string char_count[char] -= 1 # Skip the character already in result if char in seen: continue while target and char < target[-1] and char_count[target[-1]] > 0: seen.remove(target.pop()) target.append(char) seen.add(char) return \'\'.join(target)"},{"question":"Given an array of `n` integers where each value represents the height of a bar in a histogram, design an algorithm to find the area of the largest rectangle that can be formed within the bounds of the histogram. Return the maximum area of such a rectangle. For example, given the heights `[2, 1, 5, 6, 2, 3]`, the largest possible rectangle has an area of `10` and spans across heights `[5, 6]` with a width of `2`. Implement the function: ```python def largestRectangleArea(heights: List[int]) -> int: ``` where `heights` is a list of integers representing the heights of the histogram bars, and the function should return an integer representing the area of the largest rectangle.","solution":"from typing import List def largestRectangleArea(heights: List[int]) -> int: stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an integer `n`. Your task is to rotate the digits of `n` by 1 position to the left and return the resulting number. If `n` is negative, ignore the negative sign during the rotation and add it back in the result. For example, given `n = 12345`, the result should be `23451`; and for `n = -123`, the result should be `-231`. Return the resulting integer after the rotation.","solution":"def rotate_left_by_one(n): Rotates the digits of the integer n by 1 position to the left. If n is negative, the negative sign is ignored during the rotation and added back in the result. Parameters: n (int): The integer to be rotated. Returns: int: The resulting integer after rotation. is_negative = n < 0 num_str = str(abs(n)) if len(num_str) == 1: return n # Single digit numbers remain unchanged rotated_num_str = num_str[1:] + num_str[0] rotated_num = int(rotated_num_str) return -rotated_num if is_negative else rotated_num"},{"question":"Given a linked list, rearrange the nodes in such a way that all nodes with odd indices appear before nodes with even indices, while preserving the relative order of both the odd and even indexed nodes. Return the head of the reordered linked list. For example, if the input linked list is `1 -> 2 -> 3 -> 4 -> 5`, the output should be `1 -> 3 -> 5 -> 2 -> 4`.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def odd_even_list(head): if not head or not head.next: return head odd = head even = head.next even_head = even while even and even.next: odd.next = odd.next.next even.next = even.next.next odd = odd.next even = even.next odd.next = even_head return head # Helper function to create a linked list from a list def create_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head # Helper function to convert linked list to list def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result"},{"question":"Given a non-empty 2D array `grid` of integers representing a land map where `0` represents water and `1` represents land, an island is a group of `1`s (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Write a function to identify the number of distinct islands.","solution":"def num_islands(grid): Returns the number of distinct islands in the given 2D grid. if not grid: return 0 def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 # mark as visited for dx, dy in directions: nx, ny = x + dx, y + dy dfs(nx, ny) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: islands += 1 dfs(i, j) return islands"},{"question":"Given an array of integers `nums`, return the minimum element in a rotated sorted array. A rotated sorted array is an array that has initially been sorted in ascending order, but then one or more elements from the start of the array have been moved to the end. You must write an algorithm with O(log n) complexity.","solution":"def find_min(nums): Find the minimum element in a rotated sorted array. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 else: right = mid return nums[left]"},{"question":"You are given an array of integers `heights` representing the heights of buildings, each building being 1 unit wide. The goal is to find the **maximum area of water** that can be contained between the buildings when it rains. The amount of water that can be contained between two buildings is determined by the shorter of the two buildings and the distance between them. Return _the maximum area of water that can be retained between any two buildings in the array_.","solution":"def max_area(heights): Returns the maximum area of water that can be contained between the buildings. :param heights: List[int] representing the heights of buildings. :return: int representing the maximum area of water. left, right = 0, len(heights) - 1 max_area = 0 while left < right: width = right - left height = min(heights[left], heights[right]) max_area = max(max_area, width * height) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"Implement a data structure that supports the following operations on a binary tree: 1. **Insert a value** into the binary search tree (BST). 2. **Delete a value** from the BST. 3. **Find the lowest common ancestor (LCA)** of two given nodes in the BST. The class should be defined as follows: ```python class BinarySearchTree: def __init__(self): # Initializes an empty BST pass def insert(self, val: int) -> None: # Inserts a value into the BST pass def delete(self, val: int) -> None: # Deletes a value from the BST if it exists pass def findLCA(self, node1: int, node2: int) -> int: # Returns the lowest common ancestor of node1 and node2 pass ``` # Example: ```python # Initialize the BST bst = BinarySearchTree() # Insert values bst.insert(5) bst.insert(3) bst.insert(8) bst.insert(2) bst.insert(4) # Delete a value bst.delete(3) # Find LCA bst.findLCA(2, 8) # returns 5 bst.findLCA(2, 4) # returns 4 ```","solution":"class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node: TreeNode, val: int) -> None: if val < node.val: if node.left: self._insert(node.left, val) else: node.left = TreeNode(val) else: if node.right: self._insert(node.right, val) else: node.right = TreeNode(val) def delete(self, val: int) -> None: self.root = self._deleteNode(self.root, val) def _deleteNode(self, node: TreeNode, val: int) -> TreeNode: if not node: return node if val < node.val: node.left = self._deleteNode(node.left, val) elif val > node.val: node.right = self._deleteNode(node.right, val) else: if not node.left: return node.right elif not node.right: return node.left min_node = self._findMin(node.right) node.val = min_node.val node.right = self._deleteNode(node.right, min_node.val) return node def _findMin(self, node: TreeNode) -> TreeNode: while node.left: node = node.left return node def findLCA(self, node1: int, node2: int) -> int: return self._findLCA(self.root, node1, node2).val def _findLCA(self, node: TreeNode, node1: int, node2: int) -> TreeNode: if not node: return None if node1 < node.val and node2 < node.val: return self._findLCA(node.left, node1, node2) elif node1 > node.val and node2 > node.val: return self._findLCA(node.right, node1, node2) else: return node"},{"question":"You are given an immutable linked list, and you need to implement an iterator that can traverse the list. The iterator should also support an additional operation to count the number of elements in the linked list that are smaller than a given value `x`. Implement the `ImmutableLinkedListIterator` class: - `ImmutableLinkedListIterator(ListNode head)` Initializes the iterator with the head of the linked list. - `int next()` Returns the next element in the linked list and moves the pointer to the next element. - `boolean hasNext()` Returns `true` if there are still elements in the linked list. - `int countSmaller(int x)` Returns the number of elements in the linked list that are smaller than `x`. **Note:** Each language may have a different implementation of the constructor and the `ListNode` definition, but they all support the `int next()` and `boolean hasNext()` functions. The `ListNode` is a standard linked list node with an integer value and a next pointer to the following node.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class ImmutableLinkedListIterator: def __init__(self, head: ListNode): self.head = head self.current = head def next(self) -> int: if self.current is not None: val = self.current.val self.current = self.current.next return val def hasNext(self) -> bool: return self.current is not None def countSmaller(self, x: int) -> int: count = 0 node = self.head while node is not None: if node.val < x: count += 1 node = node.next return count"},{"question":"You are given an integer array `arr` representing the number of candies each student has and an integer `k` representing the number of additional candies you have. Return _a boolean array_ where each element is `true` if, after giving the corresponding student in the array `arr` some (or none) of the `k` additional candies, they can have the greatest number of candies among all the students; otherwise, the element should be `false`. If there are multiple students that can have the greatest number of candies, all of them should be marked `true`.","solution":"def kidsWithCandies(arr, k): Determines which kids can have the greatest number of candies after distributing the additional candies. Args: arr (List[int]): List of candies each kid has initially. k (int): Number of additional candies available to distribute. Returns: List[bool]: A list where each element is True if the corresponding kid can have the greatest number of candies, otherwise False. max_candies = max(arr) result = [candies + k >= max_candies for candies in arr] return result"},{"question":"Given a string `s` containing only lowercase letters and a string `target` containing distinct lowercase letters, write a function to return the **maximum number of times** that `target` can be formed using the letters from `s`. Each letter from `s` can be used at most once in each instance of forming the `target`.","solution":"from collections import Counter def max_instances(s, target): Returns the maximum number of times the target can be formed using the letters from s. Each letter from s can be used at most once in each instance. s_count = Counter(s) target_count = Counter(target) # Find the minimum ratio of available letters to needed letters max_instances_count = float(\'inf\') for char in target_count: if char in s_count: max_instances_count = min(max_instances_count, s_count[char] // target_count[char]) else: return 0 return max_instances_count"},{"question":"You are given a string `s` consisting of the characters `\'a\'`, `\'b\'`, and `\'c\'`. Your task is to partition the string into as few substrings as possible such that each substring contains only one unique character. Return _the list of the lengths of the substrings after partitioning_. For example, given `s = \\"aaabbbcc\\"`, the answer would be `[3, 3, 2]`.","solution":"def partition_string(s): Partitions the string into as few substrings as possible such that each substring contains only one unique character. Returns the list of the lengths of the substrings after partitioning. if not s: return [] result = [] current_char = s[0] count = 0 for char in s: if char == current_char: count += 1 else: result.append(count) current_char = char count = 1 # Append the last counted substring result.append(count) return result"},{"question":"Given an integer array `nums` and an integer `k`, modify the array in the following way: 1. Leave elements that are divisible by `k` unchanged. 2. For elements that are not divisible by `k`, increase their value to the next multiple of `k`. Return the modified array after performing the above operations.","solution":"def modify_array(nums, k): Modifies the array based on the rules specified: - Leave elements that are divisible by k unchanged. - For elements that are not divisible by k, increase their value to the next multiple of k. Args: nums (list of int): List of integers to be modified. k (int): The integer to check divisibility against and to find multiples of. Returns: list of int: The modified array. def next_multiple(n, k): return ((n + k - 1) // k) * k return [num if num % k == 0 else next_multiple(num, k) for num in nums]"},{"question":"You are given an array of `n` strings where each string consists of lowercase English letters. Design an algorithm to find the length of the longest string that can be formed by concatenating some of the given strings (each string can be used at most once), such that each letter from \'a\' to \'z\' appears at most once in the concatenated string. Return the length of the longest string.","solution":"def maxLength(arr): Returns the length of the longest string that can be formed by concatenating some of the given strings such that each letter from \'a\' to \'z\' appears at most once in the concatenated string. def is_unique(s): Checks if all characters in the string \'s\' are unique. return len(s) == len(set(s)) def backtrack(start, current): Backtracks to generate all possible combinations and keep track of the maximum length. max_len = len(current) for i in range(start, len(arr)): new_str = arr[i] if is_unique(new_str) and not set(current) & set(new_str): max_len = max(max_len, backtrack(i + 1, current + new_str)) return max_len return backtrack(0, \\"\\")"},{"question":"Given two strings `s` and `t`, each containing only lowercase characters, your goal is to transform string `s` into string `t` by using a set of operations. In one operation, you can insert a character at any position of the string, delete a character from any position of the string, or replace a character at any position of the string with another character. Return the minimum number of operations needed to transform `s` into `t`.","solution":"def min_distance(s, t): Calculates the minimum number of operations required to transform string s into string t. :param s: Source string :param t: Target string :return: Minimum number of operations m, n = len(s), len(t) # Create a matrix to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # Insert all characters of t elif j == 0: dp[i][j] = i # Remove all characters of s elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"Given a list of non-negative integers `nums`, you are tasked with finding the **smallest missing positive integer**. Implement a function that returns this smallest missing positive integer. For example, given `nums = [3, 4, -1, 1]`, the smallest missing positive integer is `2`.","solution":"def smallest_missing_positive(nums): Returns the smallest missing positive integer from the list of non-negative integers. nums = set(nums) i = 1 while i in nums: i += 1 return i"},{"question":"Given a 2D integer array `grid` representing a matrix of integers, return the maximum sum of any non-empty submatrix that can be obtained by deleting zero or more rows and/or columns. A submatrix is defined as any contiguous block of elements within the original matrix.","solution":"def max_sum_submatrix(grid): Returns the maximum sum of any non-empty submatrix by potentially deleting zero or more rows and/or columns from the grid. def max_subarray_sum(nums): max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) max_sum = float(\'-inf\') for left in range(cols): temp = [0] * rows for right in range(left, cols): for i in range(rows): temp[i] += grid[i][right] current_max_sum = max_subarray_sum(temp) max_sum = max(max_sum, current_max_sum) return max_sum"},{"question":"**[Question 4]:** Given a list of integers `arr` and an integer `target`, return all unique combinations in `arr` where the integers sum to `target`. Each number in `arr` may only be used once in the combination. The combinations can be returned in any order. The solution set must not contain duplicate combinations.","solution":"from typing import List def combination_sum2(arr: List[int], target: int) -> List[List[int]]: arr.sort() result = [] def backtrack(start, target, path): if target == 0: result.append(path) return for i in range(start, len(arr)): if i > start and arr[i] == arr[i-1]: continue if arr[i] > target: break backtrack(i + 1, target - arr[i], path + [arr[i]]) backtrack(0, target, []) return result"},{"question":"Given a grid of size `m x n`, an initial starting point `(startX, startY)`, and a destination point `(endX, endY)`, determine the **minimum** number of steps required to move from the start to the destination. You can move up, down, left, or right, but you cannot move through obstacles represented by the character `\'#\'`. Empty spaces are represented by the character `\'.\'`. If it is not possible to reach the destination, return `-1`.","solution":"from collections import deque def min_steps(grid, startX, startY, endX, endY): Determines the minimum number of steps required to move from (startX, startY) to (endX, endY). Returns -1 if it is not possible to reach the destination. if not grid or not grid[0] or grid[startX][startY] == \'#\' or grid[endX][endY] == \'#\': return -1 m, n = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(startX, startY, 0)]) # (x, y, steps) visited = set((startX, startY)) while queue: x, y, steps = queue.popleft() if x == endX and y == endY: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == \'.\': visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"In a 2D grid of size `m x n`, each cell can either be a `0` (representing water) or a `1` (representing land). A cell is called a connected component if there is another land cell directly above, below, left, or right of it. An island is made up of one or more connected components. Return _the total number of islands in the given grid_.","solution":"def numIslands(grid): Returns the number of islands in the given grid. if not grid: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == \'0\': return grid[i][j] = \'0\' # Mark the cell as visited dfs(grid, i + 1, j) dfs(grid, i - 1, j) dfs(grid, i, j + 1) dfs(grid, i, j - 1) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': dfs(grid, i, j) count += 1 return count"},{"question":"You are given an integer array `nums` and an integer `target`. Return _the number of **unique pairs**_ `(a, b)` _in the array such that_ `a + b == target`. Each pair should be treated as unordered, meaning `(a, b)` is considered the same as `(b, a)`. For example, given `nums = [1, 1, 2, 2, 3, 3]` and `target = 4`: - The unique pairs that sum to 4 are `(1, 3)` and `(2, 2)`. - Therefore, the return value should be `2`.","solution":"def count_unique_pairs(nums, target): Returns the number of unique pairs (a, b) in the array such that a + b == target. nums_sorted = sorted(nums) seen = set() unique_pairs = set() for num in nums_sorted: complement = target - num if complement in seen: unique_pairs.add((min(num, complement), max(num, complement))) seen.add(num) return len(unique_pairs)"},{"question":"You are given a string `s` consisting of lowercase English letters. We want to perform operations that will transform `s` into a string with the following properties: 1. Each character appears at most once. 2. The resulting string is the lexicographically smallest possible. In one operation, you can select any character in the string `s` and remove it. Design an algorithm to determine the lexicographically smallest string you can obtain after performing the necessary operations. Return the resulting string.","solution":"def remove_duplicate_letters(s): Returns the lexicographically smallest string that can be obtained by removing duplicate letters from the input string. counter = {char: 0 for char in set(s)} for char in s: counter[char] += 1 stack = [] seen = set() for char in s: if char in seen: counter[char] -= 1 continue while stack and char < stack[-1] and counter[stack[-1]] > 0: seen.remove(stack.pop()) stack.append(char) seen.add(char) counter[char] -= 1 return \'\'.join(stack)"},{"question":"Given a string `s`, return _a list of all distinct permutations of the string that do not contain consecutive identical characters_. Each permutation in the answer list should be lexicographically sorted.","solution":"from itertools import permutations def distinct_permutations_no_consecutive(s): def has_consecutive_identical_chars(permut): return any(permut[i] == permut[i+1] for i in range(len(permut) - 1)) unique_perms = set(permutations(s)) valid_perms = [\\"\\".join(permut) for permut in unique_perms if not has_consecutive_identical_chars(permut)] return sorted(valid_perms)"},{"question":"Given the `root` of a binary tree, connect each node to its next right node in the same level using a pointer, in place. If there is no next right node, the pointer should be set to `NULL`. Initially, all next right pointers are set to `NULL`. The binary tree could be a complete binary tree but not necessarily a perfect binary tree. Return the `root` of the modified tree.","solution":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): if not root: return root # Start with the root node current_level_start = root while current_level_start: # Set up a dummy node to build the next level connections dummy_head = Node(0) current = dummy_head node = current_level_start while node: if node.left: current.next = node.left current = current.next if node.right: current.next = node.right current = current.next node = node.next # Move to the next level current_level_start = dummy_head.next return root"},{"question":"Given an undirected graph with `n` nodes labeled from `0` to `n-1`, and an array `edges` where `edges[i] = [ui, vi]` represents an undirected edge between nodes `ui` and `vi`, return _the number of connected components in the graph_.","solution":"def countComponents(n, edges): Returns the number of connected components in an undirected graph. Parameters: n (int): Number of nodes in the graph. edges (List[List[int]]): List of undirected edges. Returns: int: Number of connected components. def dfs(node): for neighbor in adjacency_list[node]: if neighbor not in visited: visited.add(neighbor) dfs(neighbor) if n == 0: return 0 adjacency_list = {i: [] for i in range(n)} for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = set() count = 0 for i in range(n): if i not in visited: dfs(i) count += 1 return count"},{"question":"You are given an `m x n` grid filled with non-negative numbers representing heights. Find a path from the top-left corner to the bottom-right corner of the grid such that the maximum height difference between adjacent cells of the path is minimized. You can move up, down, left, or right. Return the minimum possible value of the maximum height difference for such a path.","solution":"from heapq import heappush, heappop def min_max_diff_path(grid): Finds the minimum possible value of the maximum height difference between adjacent cells of the path from top-left corner to bottom-right corner of the grid. Args: grid: List[List[int]] - The m x n grid filled with non-negative numbers. Returns: int: The minimum possible value of the maximum height difference. m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < m and 0 <= y < n def dijkstra(): min_heap = [(0, 0, 0)] # (max_diff, x, y) max_diff_grid = [[float(\'inf\')] * n for _ in range(m)] max_diff_grid[0][0] = 0 while min_heap: max_diff, x, y = heappop(min_heap) if x == m - 1 and y == n - 1: return max_diff for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): curr_diff = abs(grid[nx][ny] - grid[x][y]) max_diff_path = max(max_diff, curr_diff) if max_diff_path < max_diff_grid[nx][ny]: max_diff_grid[nx][ny] = max_diff_path heappush(min_heap, (max_diff_path, nx, ny)) return dijkstra()"},{"question":"You are given a list of integers `nums` and an integer `target`. Write a function that finds all unique pairs of integers in the list that sum up to the target. Return _a list of the pairs (as tuples) in which the integers are sorted in non-decreasing order_. Ensure that each pair appears only once in the result list. For example, given `nums = [1, 2, 3, 4, 3, 2, 1]` and `target = 4`, you should return `[(1, 3), (2, 2)]`.","solution":"def find_pairs(nums, target): Finds all unique pairs of integers in the list nums that sum up to the target. Args: nums (list): List of integers. target (int): Target sum. Returns: list: A list of unique pairs (tuples) that sum up to the target. nums.sort() left, right = 0, len(nums) - 1 seen_pairs = set() result = [] while left < right: current_sum = nums[left] + nums[right] if current_sum == target: pair = (nums[left], nums[right]) if pair not in seen_pairs: seen_pairs.add(pair) result.append(pair) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return result"},{"question":"You are given an array of integers `nums` and an integer `k`. A continuous subarray is called `good` if there are at least `k` unique elements in it. Return the length of the shortest `good` subarray. If no such subarray exists, return `-1`.","solution":"def shortest_good_subarray(nums, k): Returns the length of the shortest good subarray containing at least k unique elements. If no such subarray exists, returns -1. from collections import defaultdict n = len(nums) left = 0 shortest_length = float(\'inf\') element_count = defaultdict(int) unique_count = 0 for right in range(n): current_element = nums[right] element_count[current_element] += 1 if element_count[current_element] == 1: unique_count += 1 while unique_count >= k: shortest_length = min(shortest_length, right - left + 1) left_element = nums[left] element_count[left_element] -= 1 if element_count[left_element] == 0: unique_count -= 1 left += 1 return shortest_length if shortest_length != float(\'inf\') else -1"},{"question":"You are given a binary search tree (BST) with distinct values and an array `queries`. For each query `queries[i]`, you have to find the value in the BST that is closest to `queries[i]`. If there are multiple such values, return the smallest one. Implement the function `closestNode(TreeNode root, int[] queries)`, where `root` is the root of the BST, and `queries` is the array of query values. The function should return an array of integers where the `i-th` element is the closest value in the BST to `queries[i]`. The BST is guaranteed to have at least one node, and the queries array will contain at least one query.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closestNode(root, queries): result = [] def search_closest(node, target): closest = node.val while node: if abs(closest - target) > abs(node.val - target): closest = node.val elif abs(closest - target) == abs(node.val - target): closest = min(closest, node.val) if target < node.val: node = node.left elif target > node.val: node = node.right else: break return closest for query in queries: result.append(search_closest(root, query)) return result"},{"question":"You are given an array of integers `nums` representing the number of points on a line, and an integer `k`. You need to calculate the minimum number of operations required to reduce the array to `k` points or less. In one operation, you can remove a point or you can merge two consecutive points `nums[i]` and `nums[i+1]` into a single point with a value equal to their sum. Write a function `min_operations_to_reduce_points(nums, k)` that returns the minimum number of operations needed. Note: It is guaranteed that `k` is less than or equal to the length of `nums`.","solution":"def min_operations_to_reduce_points(nums, k): This function calculates the minimum number of operations required to reduce the array to `k` points or less. In one operation, you can remove a point or you can merge two consecutive points into a single point equal to their sum. Parameters: nums (List[int]): The list of integers. k (int): The target number of points. Returns: int: The minimum number of operations needed. n = len(nums) if k >= n: return 0 # Merging `n - k` times will reduce the array to size `k` operations = n - k return operations"},{"question":"You are given a list of integers `nums` and an integer `target`. You need to find the **minimum length subarray** of `nums` such that the sum of the subarray is equal to `target`. If there are multiple subarrays with the same minimum length, return any of them. If no such subarray exists, return an empty list. Example: - Given `nums = [1, 1, 2, 3, 1, 1, 1, 2]` and `target = 6`, one possible solution is `[1, 2, 3]`. - Given `nums = [5, 1, 3, 5, 10, 7, 4, 9, 2, 8]` and `target = 15`, one possible solution is `[5, 10]`.","solution":"def min_length_subarray(nums, target): Finds minimum length subarray with sum equal to target. min_length = float(\'inf\') subarray = [] for start in range(len(nums)): current_sum = 0 for end in range(start, len(nums)): current_sum += nums[end] if current_sum == target: if end - start + 1 < min_length: min_length = end - start + 1 subarray = nums[start:end+1] break return subarray"},{"question":"Given a binary tree, your task is to find the length of the longest consecutive sequence path. The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive sequence path must be strictly increasing by 1 at each step. Implement the function `int longestConsecutive(TreeNode root)` where `TreeNode` is a node in the tree. Example: ``` 1 3 / 2 4 5 ``` In the above example, the longest consecutive sequence path is 3->4->5, so the function should return 3. # Constraints: - The number of nodes in the tree is in the range `[1, 3 * 10^4]`. - `-10^4 <= Node.val <= 10^4`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestConsecutive(root: TreeNode) -> int: def dfs(node, parent_val, length): if not node: return length current_len = length + 1 if node.val == parent_val + 1 else 1 left_len = dfs(node.left, node.val, current_len) right_len = dfs(node.right, node.val, current_len) return max(current_len, left_len, right_len) return dfs(root, root.val - 1, 0) if root else 0"},{"question":"You are given a string `s` consisting only of characters \'a\', \'b\', and \'c\'. You can apply the following operation on the string any number of times: - Choose any substring of the string `s` and replace it with another substring of the same length where each character is replaced by one of the other two characters (\'a\' can be replaced with \'b\' or \'c\', \'b\' can be replaced with \'a\' or \'c\', and \'c\' can be replaced with \'a\' or \'b\'). Your task is to determine the minimum number of operations required to make all the characters in the string `s` the same. Return the minimum number of operations needed.","solution":"def min_operations_to_uniform(s): Returns the minimum number of operations required to make all characters in the string s the same. count_a = s.count(\'a\') count_b = s.count(\'b\') count_c = s.count(\'c\') max_count = max(count_a, count_b, count_c) return len(s) - max_count"},{"question":"You are given a directed graph represented by a list of edges `edges`, where each element in `edges` is a pair of integers `[u, v]` representing a directed edge from node `u` to node `v`. You are also given two nodes `source` and `destination`. Write a function to determine if there is a valid path from `source` to `destination` in the graph, under the condition that each node in the graph must only be visited at most once during traversal. Your function should return a boolean indicating whether such a path exists.","solution":"def valid_path(edges, source, destination): Determines if there is a valid path from source to destination in a directed graph. from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) # BFS to check for path from source to destination to_visit = deque([source]) visited = set() while to_visit: current = to_visit.popleft() if current == destination: return True if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: to_visit.append(neighbor) return False"},{"question":"You are given a string `s` that consists of lowercase English letters. Rearrange the characters of `s` by grouping all the vowels together and all the consonants together, while preserving the relative order of vowels and consonants as in the original string. Return the rearranged string where vowels come first followed by consonants.","solution":"def rearrange_string(s): Rearranges the given string by grouping all vowels together followed by consonants. Preserves the relative order of vowels and consonants as in the original string. :param s: Input string consisting of lowercase English letters :return: Rearranged string with vowels first followed by consonants vowels = \\"aeiou\\" vowel_part = \'\'.join([char for char in s if char in vowels]) consonant_part = \'\'.join([char for char in s if char not in vowels]) return vowel_part + consonant_part"},{"question":"A company has a system that logs data in a specific format. Each log entry is a string containing an `identifier` and the actual `log` content, separated by a space. An `identifier` consists of a unique string of letters and/or numbers, while the `log` content consists of a lowercase string of letters and/or digits. You are given an array of `log entries`, each represented as a string. Your task is to reorder the log entries so that all `letter-logs` come before any `digit-logs`. The letter-logs should be ordered lexicographically by their content. If the contents are the same, order them lexicographically by their identifiers. Digit-logs should be ordered in the same relative order they were given. Return the reordered array of log entries. For example, given the input `[\\"log1 9 2 3 1\\", \\"let1 art can\\", \\"dig1 8 1 5 1\\", \\"let2 own kit dig\\", \\"let3 art zero\\"]`, the output should be `[\\"let1 art can\\", \\"let3 art zero\\", \\"let2 own kit dig\\", \\"log1 9 2 3 1\\", \\"dig1 8 1 5 1\\"]`.","solution":"def reorder_log_entries(logs): Reorder log entries so that all letter-logs come before any digit-logs. The letter-logs are ordered lexicographically by their content; if their contents are the same, then order them lexicographically by their identifiers. Digit-logs should remain in the same relative order they were given. Args: logs (List[str]): List of log entries. Returns: List[str]: The reordered list of log entries. def get_key(log): identifier, rest = log.split(\\" \\", 1) if rest[0].isdigit(): return (1,) else: return (0, rest, identifier) logs.sort(key=get_key) return logs"},{"question":"You are given a grid of size `m x n` filled with non-negative numbers representing gold quantities. You start at the top-left cell `(0,0)` and your goal is to collect as much gold as possible and reach the bottom-right cell `(m-1,n-1)`. However, there is a constraint: You can only move either **right** or **down** at any point in time. Write a function `maxGold(grid: List[List[int]]) -> int` that returns the maximum amount of gold you can collect while reaching the bottom-right cell. **Example:** ``` Input: grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] Output: 12 Explanation: The path 1→3→5→2→1 maximizes the gold, and the total gold collected is 12. ```","solution":"from typing import List def maxGold(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"Write a function to find and return the starting and ending indices of the largest contiguous subarray in an integer array `nums` that has the maximum sum. If there are multiple subarrays with the same maximum sum, return the indices of the first one. You may assume that the array contains at least one element.","solution":"def max_subarray_indices(nums): Finds and returns the starting and ending indices of the largest contiguous subarray in an integer array nums that has the maximum sum. max_sum = float(\'-inf\') current_sum = 0 start_index = 0 temp_start = 0 end_index = 0 for i in range(len(nums)): current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start_index = temp_start end_index = i if current_sum < 0: current_sum = 0 temp_start = i + 1 return (start_index, end_index)"},{"question":"You are given a string `s` representing a valid expression containing digits `0-9`, `+`, `-`, `*`, `/`, and empty spaces. Implement an integer calculator with the following requirements: * All the operations should be performed respecting the usual operator precedence (i.e., `*` and `/` have higher precedence than `+` and `-`). * The division operator `/` should truncate towards zero. * Do not use any builtin libraries for arithmetic operations directly like `eval`. Write a function `int calculate(String s)` that takes the string expression `s` and returns the result as an integer.","solution":"def calculate(s: str) -> int: Calculate the result of the given mathematical expression string `s`. Parameters: s (str): A string containing a valid mathematical expression with digits, \'+\', \'-\', \'*\', \'/\', and spaces. Returns: int: The result of the expression evaluation. def operate(num1, num2, op): if op == \'+\': return num1 + num2 elif op == \'-\': return num1 - num2 elif op == \'*\': return num1 * num2 elif op == \'/\': return int(num1 / num2) # division should truncate towards zero if not s: return 0 stack = [] current_num = 0 operation = \'+\' s += \'+\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char in \\"+-*/\\": if operation == \'+\': stack.append(current_num) elif operation == \'-\': stack.append(-current_num) elif operation == \'*\': stack.append(stack.pop() * current_num) elif operation == \'/\': stack.append(int(stack.pop() / current_num)) operation = char current_num = 0 return sum(stack)"},{"question":"You are given a list of integers `arr` representing the heights of buildings that form a skyline. You are also given an integer `v` which represents the maximum view distance. A building can be seen from the left if there is no taller building in front of it within the distance `v`. Write a function that returns the number of buildings that have an unobstructed view from the left within the given distance `v`.","solution":"def unobstructed_view_buildings(arr, v): Returns the number of buildings that have an unobstructed view from the left within the given distance v. count = 0 for i in range(len(arr)): has_view = True for j in range(1, v + 1): if i - j >= 0 and arr[i - j] >= arr[i]: has_view = False break if has_view: count += 1 return count"},{"question":"You are given an integer array `arr` and an integer `k`. A pair of integers `(x, y)` is considered \\"good\\" if `x <= y`. Find the maximum sum of the elements in `arr` such that the sum is divisible by `k`. Implement a function `maxSumDivisibleByK(arr, k)` that returns the maximum sum possible that is divisible by `k`.","solution":"def maxSumDivisibleByK(arr, k): Returns the maximum sum of elements in arr such that the sum is divisible by k. # Initialize an array to store maximum sums with remainders 0 to k-1 dp = [0] * k for num in arr: # Update dp array, starting from the back to prevent overwriting current_dp = dp[:] for remainder in current_dp: new_sum = remainder + num dp[new_sum % k] = max(dp[new_sum % k], new_sum) return dp[0] # Return the maximum sum divisible by k"},{"question":"You are given a square matrix `mat` of integers. Your task is to re-arrange the rows of the matrix in such a way that the first column of the matrix is sorted in **ascending** order, while maintaining the relative order of the corresponding rows. Return _the modified matrix_. Example: Input: mat = [[5, 4, 3], [3, 2, 1], [8, 7, 6]] Output: [[3, 2, 1], [5, 4, 3], [8, 7, 6]]","solution":"def sort_matrix_by_first_column(mat): Rearranges the rows of the matrix such that the first column of the matrix is sorted in ascending order. Parameters: mat (list of list of int): A square matrix of integers. Returns: list of list of int: The modified matrix with rows sorted by the first column. return sorted(mat, key=lambda x: x[0])"},{"question":"A network of `n` computers (labeled `0` through `n-1`) are connected by `directed`- `edges` representing direct communication links. The goal is to send a message from computer `0` to all other computers. You are given an array `times`, where each element is of the form `[u, v, w]` indicating that a message sent from computer `u` to computer `v` takes `w` units of time to reach. Your task is to determine the `minimum time` needed for the message to reach all the computers. If it\'s impossible for the message to reach all the computers, return `-1`. Note: - The network may have cycles. - The given graph is `weighted` and the edges have non-negative weights. Return the minimum time to send a message from computer `0` to all computers.","solution":"import heapq def network_delay_time(times, n): Returns the minimum time to send a message from computer 0 to all computers. If it is impossible, returns -1. graph = [[] for _ in range(n)] for u, v, w in times: graph[u].append((v, w)) # Dijkstra\'s algorithm min_heap = [(0, 0)] # (distance, node) dist = {i: float(\'inf\') for i in range(n)} dist[0] = 0 while min_heap: current_dist, node = heapq.heappop(min_heap) if current_dist > dist[node]: continue for neighbor, weight in graph[node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) max_dist = max(dist.values()) return max_dist if max_dist < float(\'inf\') else -1"},{"question":"Given an array of integers `nums`, return _the count of distinct pairs (i, j) where i < j and nums[i] + nums[j] is an odd number_. The array may contain both positive and negative integers and the numbers can be repeated. For example, given `nums = [1, 2, 3, 4, 5]`, the valid pairs are `(0, 1)`, `(0, 3)`, `(1, 2)`, `(1, 4)`, `(2, 3)`, `(3, 4)`, totaling 6 pairs. Thus, the output should be 6.","solution":"def count_odd_sum_pairs(nums): Returns the count of distinct pairs (i, j) where i < j and nums[i] + nums[j] is an odd number. count = 0 for i in range(len(nums)): for j in range(i+1, len(nums)): if (nums[i] + nums[j]) % 2 != 0: count += 1 return count"},{"question":"You are given two strings `s1` and `s2` consisting of lowercase English letters only. You need to find the length of the longest string that can be formed by deleting some characters (possibly none) from both strings such that the resulting strings are anagrams. An anagram is a word, phrase, or name formed by rearranging the letters of another, using all the original letters exactly once. Return an integer representing the length of the longest possible anagram that can be formed.","solution":"def longest_anagram_length(s1, s2): Returns the length of the longest anagram that can be formed by deleting characters from both strings. from collections import Counter # Count the frequency of each character in both strings counter1 = Counter(s1) counter2 = Counter(s2) # Find the total length of the common characters length = sum(min(counter1[char], counter2[char]) for char in counter1 if char in counter2) return length"},{"question":"You are given a **0-indexed** list of integers `arr` and two integers `x` and `k`. An **operation** involves selecting an element of the list and replacing it with the absolute difference between that element and `x`. Return _the minimum number of operations needed to ensure every pair of consecutive elements in_ `arr` _has a difference of at most_ `k`. If it is impossible to achieve such a configuration, return `-1`.","solution":"def min_operations(arr, x, k): Returns the minimum number of operations needed to ensure every pair of consecutive elements in `arr` has a difference of at most `k`. If it is impossible to achieve such a configuration, return -1. An operation involves selecting an element of the list and replacing it with the absolute difference between that element and `x`. def can_be_converted(a, b, x, k): Helper function to check if two elements can be made k-close via operations return abs(a - x) <= k or abs(b - x) <= k operations = 0 for i in range(len(arr) - 1): if abs(arr[i] - arr[i + 1]) > k: if can_be_converted(arr[i], arr[i + 1], x, k): operations += 1 else: return -1 return operations"},{"question":"Given an array of integers `arr` and an integer `k`, implement a function to find the **length of the longest subarray** that contains at most `k` distinct numbers. The function should return an integer representing the length of this subarray. Write a function to accomplish this task. **Function signature:** ```python def longest_subarray_with_k_distinct(arr: List[int], k: int) -> int: ```","solution":"from typing import List from collections import defaultdict def longest_subarray_with_k_distinct(arr: List[int], k: int) -> int: Find the length of the longest subarray with at most k distinct elements. n = len(arr) if n == 0 or k == 0: return 0 freq = defaultdict(int) left = 0 max_length = 0 distinct_count = 0 for right in range(n): if freq[arr[right]] == 0: distinct_count += 1 freq[arr[right]] += 1 while distinct_count > k: freq[arr[left]] -= 1 if freq[arr[left]] == 0: distinct_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given a list of non-negative integers `nums`, return the maximum possible sum of the elements of any contiguous subarray of `nums`.","solution":"def max_subarray_sum(nums): Returns the maximum possible sum of the elements of any contiguous subarray of nums. if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given a list of integers `nums` representing the amounts of money in various houses along a street, and the constraint that you cannot rob two adjacent houses, write a function that returns the maximum amount of money you can rob tonight without alerting the police. Each house has a unique amount of money, and the street is laid out in a linear fashion. You are only permitted to rob houses under the condition that no two consecutive houses are robbed. Return the maximum amount of money you can obtain by robbing houses under these conditions.","solution":"def rob(nums): Calculate the maximum amount of money you can rob tonight without alerting police. You cannot rob two adjacent houses. :param nums: List[int], amounts of money in various houses along the street. :return: int, maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] # Initialize the maximum money at the first two houses prev1 = max(nums[0], nums[1]) if len(nums) > 1 else nums[0] prev2 = nums[0] for i in range(2, len(nums)): current = max(prev1, prev2 + nums[i]) prev2 = prev1 prev1 = current return prev1"},{"question":"Given an array of integers, there is exactly one integer that appears an odd number of times. All other integers appear an even number of times. Find and return the integer that appears an odd number of times.","solution":"def find_odd_occurrence(arr): Returns the integer that appears an odd number of times in the array. :param arr: List[int] - An array of integers :return: int - The integer that appears an odd number of times result = 0 for num in arr: result ^= num return result"},{"question":"Given an integer array `arr`, you are asked to find the **sum** of the elements between indices `left` and `right` (**inclusive**), where `left` and `right` are given indices into the array (0-indexed). Additionally, you have to update an element in the array at a particular index, with a new value. Implement a class to handle multiple such queries efficiently. The class should support the following operations: 1. `sumRange(left, right)`: Returns the sum of the elements between indices `left` and `right` inclusive. 2. `update(index, value)`: Updates the element at `index` to `value`.","solution":"class NumArray: def __init__(self, nums): Initializes the object with the integer array nums. self.nums = nums self.prefix_sum = self._build_prefix_sum(nums) def _build_prefix_sum(self, nums): Builds the prefix sum array for the given nums array. prefix_sum = [0] * (len(nums) + 1) for i in range(len(nums)): prefix_sum[i + 1] = prefix_sum[i] + nums[i] return prefix_sum def update(self, index, value): Updates the element at index to value. diff = value - self.nums[index] self.nums[index] = value for i in range(index + 1, len(self.prefix_sum)): self.prefix_sum[i] += diff def sumRange(self, left, right): Returns the sum of the elements between indices left and right inclusive. return self.prefix_sum[right + 1] - self.prefix_sum[left]"},{"question":"Given a `m x n` binary matrix `mat` filled with `0`s and `1`s, find the largest rectangle containing only `1`s and return its area. You need to solve this problem using dynamic programming. Implement the function `maximalRectangle(char[][] matrix)` that takes a `2D` array representing the binary matrix and returns the area of the largest rectangle containing only `1`s. **Example:** Input: ``` [ [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"1\\",\\"0\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"0\\",\\"0\\",\\"1\\",\\"0\\"] ] ``` Output: ``` 6 ```","solution":"def maximalRectangle(matrix): if not matrix: return 0 m, n = len(matrix), len(matrix[0]) max_area = 0 dp = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): if matrix[i][j] == \'1\': dp[i][j] = dp[i][j - 1] + 1 if j > 0 else 1 width = dp[i][j] for k in range(i, -1, -1): if dp[k][j] == 0: break width = min(width, dp[k][j]) max_area = max(max_area, width * (i - k + 1)) return max_area"},{"question":"You are given a list of integers `nums` and an integer `k`. A **subarray** is a contiguous sequence of elements within an array. The task is to return the maximum sum of a subarray of size `k` in the list. If there are multiple subarrays with the same maximum sum, return any one of them. If `k` is greater than the length of the list, return `null`.","solution":"def max_subarray_sum(nums, k): Returns the maximum sum of a subarray of size k in the list nums. If k is greater than the length of nums, returns None. n = len(nums) if k > n: return None # Find the sum of the first subarray of size k max_sum = sum(nums[:k]) current_sum = max_sum # Slide the window through the array, updating the sum for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You are given an array of integers representing the prices of a stock on different days. You are allowed to perform at most one transaction (i.e., buy one and sell one share of the stock). Write an algorithm to find the maximum profit you can achieve. Note that you cannot sell a stock before you buy one. Implement the function `maxProfit(prices: List[int]) -> int` which takes a list of stock prices and returns the maximum profit achievable. # Example: ```python prices = [7, 1, 5, 3, 6, 4] print(maxProfit(prices)) # Output: 5 ``` In this example, the optimal strategy is to buy on day 2 (price = 1) and sell on day 5 (price = 6), yielding a profit of 6 - 1 = 5. Now implement the function to solve that problem.","solution":"from typing import List def maxProfit(prices: List[int]) -> int: Returns the maximum profit that can be achieved from a list of stock prices by performing at most one transaction. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"You are given an array of integers `heights` representing the heights of students in a class. The students are seated in rows such that each row is ordered according to their heights in non-decreasing order. A new student is added to one of the rows and is seated in such a way that the order is maintained. Return the number of rows that need to be rearranged to maintain the non-decreasing order of heights across all rows after adding the new student.","solution":"def rows_to_rearrange(heights, new_student_height): Determines the number of rows that need to be rearranged to maintain a non-decreasing order of heights after adding the new student. :param heights: List of lists of integers where each list represents a row of students\' heights. :param new_student_height: Integer representing the height of the new student. :return: Integer representing the number of rows that need to be rearranged. rearrange_count = 0 for row in heights: if not row: continue # Skip empty rows if new_student_height < row[-1]: rearrange_count += 1 return rearrange_count"},{"question":"You are given a list of integers `nums` representing the population of different cities, and an integer `limit` representing the population limit that a government has set for providing resources to the cities. The goal is to find out the minimum number of cities that need to be provided resources such that the total affected population is as close to the `limit` as possible without exceeding it. Return the minimum number of cities whose total population is equal to or closest to (but does not exceed) the `limit`. **Note that:** - You may assume there is always a possible selection of cities that meets the requirements.","solution":"def min_cities_to_provide_resources(nums, limit): Returns the minimum number of cities whose total population is equal to or closest to (but does not exceed) the limit. # Sort the population list in descending order nums.sort(reverse=True) # Initialize variables to track the total population and city count total_population = 0 city_count = 0 # Iterate over the sorted list for population in nums: if total_population + population <= limit: total_population += population city_count += 1 # If adding the current city\'s population exceeds the limit, move to the next city else: continue return city_count"},{"question":"Given a list of `n` integers where each integer appears exactly three times except for one integer which appears exactly once, find and return the integer that appears only once. You must implement a solution with a linear runtime complexity and use only constant extra space.","solution":"def single_number(nums): Finds the element that appears only once in the list where every other element appears exactly three times. :param nums: List[int] :return: int # Initialize variables to hold bit counts ones = 0 twos = 0 for num in nums: # \'twos\' holds the bits that appear twice twos |= ones & num # \'ones\' holds the bits that appear once ones ^= num # \'threes\' holds the bits that appear three times threes = ones & twos # If a bit appears three times, clear it from \'ones\' and \'twos\' ones &= ~threes twos &= ~threes return ones"},{"question":"Write a function that takes the `head` of a singly linked list and reverses the nodes in `k`-group chunks, where `k` is a given positive integer. If the number of nodes is not a multiple of `k`, leave the last remaining nodes as they are. Return the modified head of the list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): Reverses nodes in the k-group chunks in the linked list. :param head: ListNode, the head of the linked list :param k: int, the size of the group to reverse :return: ListNode, the modified head of the linked list if not head or k == 1: return head dummy = ListNode(0) dummy.next = head curr, curr_dummy = head, dummy length = 0 while curr: next_curr = curr.next length += 1 if length % k == 0: next_dummy = curr_dummy.next reverse(curr_dummy, curr.next) curr_dummy = next_dummy curr = next_curr return dummy.next def reverse(start, end): curr, prev = start.next, start first = curr while curr != end: temp = curr.next curr.next = prev prev = curr curr = temp start.next = prev first.next = curr"},{"question":"Given an array of integers `arr`, return true if there are three consecutive odd numbers in the array. Otherwise, return false.","solution":"def three_consecutive_odds(arr): Returns True if there are three consecutive odd numbers in the array, otherwise False. count = 0 for num in arr: if num % 2 != 0: count += 1 if count == 3: return True else: count = 0 return False"},{"question":"You are given a string `s` and a list of queries `queries` where each query is a tuple `(left, right, k)`. For each query, you need to determine if it\'s possible to rearrange the substring `s[left:right+1]` such that it forms a palindrome after performing at most `k` replacements of characters. Return an array of boolean values, each representing the result of the corresponding query.","solution":"def can_form_palindrome(s, queries): Determines if it\'s possible to rearrange the substrings of s to form a palindrome after at most k replacements. Args: - s (str): The input string. - queries (List[Tuple[int, int, int]]): A list of queries where each query is a tuple (left, right, k). Returns: - List[bool]: A list of boolean values, each representing the result of the corresponding query. def is_palindrome_possible(substring, k): from collections import Counter # Count the frequency of each character in the substring count = Counter(substring) # Find the number of characters with an odd frequency odd_count = sum(1 for key in count if count[key] % 2 != 0) # We can make at most `k` replacements to turn odd frequencies even # A palindrome allows at most one character with an odd count return (odd_count // 2) <= k result = [] for left, right, k in queries: substring = s[left:right + 1] result.append(is_palindrome_possible(substring, k)) return result"},{"question":"You are given a string `s` and a list of indices `indices` of the same length. Shuffle the string `s` such that the character at the `ith` position moves to `indices[i]` in the shuffled string. Return the shuffled string. For example, if `s = \\"abc\\"` and `indices = [2, 0, 1]`, the function should return \\"bca\\" because the character at position `0` in `s` moves to position `2`, the character at position `1` in `s` moves to position `0`, and the character at position `2` in `s` moves to position `1`.","solution":"def shuffle_string(s, indices): Shuffles the string s according to the provided indices. Parameters: s (str): The original string. indices (list of int): The list of indices indicating where each character in s should be moved. Returns: str: The shuffled string. shuffled = [\'\'] * len(s) for i, index in enumerate(indices): shuffled[index] = s[i] return \'\'.join(shuffled)"},{"question":"You are given two strings `s` and `t` of length `n` consisting of lowercase letters only. You need to check if you can transform string `s` into string `t` by following these rules: - You can swap any two characters in `s`. - Each character in `s` can be swapped at most once. Return `true` if you can transform `s` into `t` by the above rule, or `false` otherwise.","solution":"def can_transform(s, t): Determines if string s can be transformed into string t by swapping any two characters in s, with each character of s being swapped at most once. Returns True if transformable, False otherwise. from collections import Counter # Both strings must have the same characters with the same frequencies if Counter(s) != Counter(t): return False # Find the indices where the strings differ differences = [(i, s[i], t[i]) for i in range(len(s)) if s[i] != t[i]] # If there are no differences, transformation is possible without swaps if len(differences) == 0: return True # If there are exactly two differences, swap should be possible if len(differences) == 2: i1, s1, t1 = differences[0] i2, s2, t2 = differences[1] # Check if swapping these will match the characters if s1 == t2 and s2 == t1: return True # Otherwise, it\'s not possible to transform by a single swap return False"},{"question":"You are given an array of `reviews` where `reviews[i]` is a string representing a review left by a customer. A review is considered **positive** if it contains the word \\"good\\" and **negative** if it contains the word \\"bad\\". The words in each review are separated by spaces. Your goal is to analyze the reviews and count the number of positive and negative reviews. Return _a tuple containing two integers where the first integer is the count of positive reviews and the second integer is the count of negative reviews_. If a review contains both \\"good\\" and \\"bad\\", count it only as negative.","solution":"def count_reviews(reviews): Counts the number of positive and negative reviews. A review is considered positive if it contains the word \\"good\\" and negative if it contains the word \\"bad\\". If a review contains both \\"good\\" and \\"bad\\", it is considered as negative. Args: - reviews (list of str): A list of review strings. Returns: - tuple of int: A tuple where the first element is the count of positive reviews and the second element is the count of negative reviews. positive_count = 0 negative_count = 0 for review in reviews: if \\"bad\\" in review: negative_count += 1 elif \\"good\\" in review: positive_count += 1 return (positive_count, negative_count)"},{"question":"Given a string `s`, return all possible palindromic substrings of `s`. Each substring must be unique and you may return the answer in **any order**. A palindromic string is a string that reads the same forward and backward.","solution":"def all_palindromic_substrings(s): Returns all unique palindromic substrings of the given string s. def is_palindrome(sub): return sub == sub[::-1] palindromes = set() for i in range(len(s)): for j in range(i, len(s)): substring = s[i:j+1] if is_palindrome(substring): palindromes.add(substring) return list(palindromes)"},{"question":"You are given a matrix `grid` consisting of `m` rows and `n` columns. Each cell in the matrix contains an integer which can be either 0 (empty cell) or 1 (blocked cell). Your task is to find the length of the shortest path from the top-left corner to the bottom-right corner, avoiding blocked cells. The path moves can only be made in four possible directions: up, down, left, or right. If no such path exists, return -1.","solution":"from collections import deque def shortest_path(grid): Given a matrix grid consisting of m rows and n columns where each cell contains either 0 (empty cell) or 1 (blocked cell), this function returns the length of the shortest path from the top-left corner to the bottom-right corner avoiding the blocked cells. If no such path exists, it returns -1. # Check if the start or end is blocked if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, dist) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == m - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"You are given a string `s` and an integer `k`. Your task is to determine whether `s` can be rearranged to form a palindrome with at most `k` characters that are odd. If it is possible, return the palindrome formed using such a rearrangement. If there are multiple palindromes possible, return any one of them. If it is impossible, return an empty string.","solution":"from collections import Counter def can_form_palindrome(s, k): Determine if the string `s` can be rearranged to form a palindrome with at most `k` characters that have an odd frequency count. :param s: Input string :param k: Maximum number of characters allowed to have an odd frequency count :return: A palindrome formed using a rearrangement of `s` if possible, otherwise an empty string char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) if odd_count > k: return \\"\\" # Build the first half of the palindrome and collect the middle character(s) if any half_palindrome = [] middle = [] for char, count in char_count.items(): if count % 2 != 0: middle.append(char) half_palindrome.extend(char * (count // 2)) first_half = \'\'.join(half_palindrome) # Sort the first half to ensure consistent output, although any permutation is valid first_half = \'\'.join(sorted(first_half)) if middle: return first_half + middle[0] + first_half[::-1] return first_half + first_half[::-1]"},{"question":"You are given an array of integers `nums`. The **mode** of `nums` is the integer that appears most frequently. If there is a tie for the mode, the smaller integer among the tied values should be considered the mode. Your task is to modify the array so that every integer is replaced with the mode of the array. Return the modified array.","solution":"from collections import Counter def replace_with_mode(nums): Replace every integer in nums with the mode of the array. If there is a tie for the mode, the smaller integer among the tied values is chosen. if not nums: return [] # Count the frequency of each number in the array counter = Counter(nums) # Determine the mode - smallest number with the highest frequency mode = min(counter.keys(), key=lambda x: (-counter[x], x)) # Replace every number in the array with the mode return [mode] * len(nums)"},{"question":"You are given a grid with `m` rows and `n` columns, where each cell in the grid is either a land cell (denoted by `1`) or a water cell (denoted by `0`). A **cell** is said to be **lowland** if it is a land cell and all its neighboring cells (up, down, left, and right) are also land cells. Return _the number of lowland cells in the grid_. When computing the neighboring cells, if any neighboring cell is out of bounds of the grid, treat it as a water cell.","solution":"def count_lowland_cells(grid): Counts the number of lowland cells in the grid. if not grid or not grid[0]: return 0 rows = len(grid) columns = len(grid[0]) lowland_count = 0 for i in range(rows): for j in range(columns): if grid[i][j] == 1: # Check all neighboring cells # Up up = grid[i-1][j] if i > 0 else 0 # Down down = grid[i+1][j] if i < rows - 1 else 0 # Left left = grid[i][j-1] if j > 0 else 0 # Right right = grid[i][j+1] if j < columns - 1 else 0 # If all neighboring cells are land cells if up == 1 and down == 1 and left == 1 and right == 1: lowland_count += 1 return lowland_count"},{"question":"Given the `head` of a singly linked list, write a function to **reverse** the linked list and return the head of the modified list. Explain your approach and provide the implementation in Python.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head): Reverses a singly linked list. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The head of the reversed linked list. prev = None curr = head while curr: next_node = curr.next # temporary store the next node curr.next = prev # reverse the current node\'s pointer prev = curr # move the prev and curr pointers one step forward curr = next_node return prev # prev will be the new head of the reversed list"},{"question":"**[Question 4]:** Given a string `s` and an integer `k`, return the number of unique substrings of length `k` that appear in the string. A substring is a contiguous sequence of characters within a string. The substrings are considered different if they have different starting positions in the string. --- This question aligns with the existing set by maintaining a similar length, complexity, and exploring the fundamental concept of string manipulation and substring operations in programming.","solution":"def unique_substrings(s, k): Returns the number of unique substrings of length k in the given string s. Parameters: s (str): The input string. k (int): The length of substrings to consider. Returns: int: The number of unique substrings of length k. if not s or k <= 0 or k > len(s): return 0 substrings = set() for i in range(len(s) - k + 1): substring = s[i:i + k] substrings.add(substring) return len(substrings)"},{"question":"You are given a string s and an array of strings words. Determine if s contains all the words as subsequences in the same order as they appear in the array. A string b is a subsequence of string a if b can be formed by deleting some (or none) of the characters from a without changing the order of the remaining characters. Return a boolean indicating whether s contains all the words as subsequences in the given order.","solution":"def is_subsequence(s, words): Determines if the string s contains all the words as subsequences in the same order. :param s: The main string :param words: List of words to check as subsequences :return: Boolean value indicating if s contains all the words as subsequences in order idx = 0 for word in words: idx = find_subsequence_from_index(s, word, idx) if idx == -1: return False return True def find_subsequence_from_index(s, word, start_idx): Helper function to find if word is a subsequence of s starting from start_idx. :param s: The main string :param word: The word to find as a subsequence :param start_idx: The index in s to start searching from :return: The index just after the ending of the subsequence in s, or -1 if not found word_len = len(word) s_len = len(s) j = 0 # Pointer for the word for i in range(start_idx, s_len): if j < word_len and s[i] == word[j]: j += 1 if j == word_len: return i + 1 return -1"},{"question":"You are given a **0-indexed** integer array `stones` where `stones[i]` represents the weight of the `i`-th stone. A frog is trying to move from the first stone to the last stone using a series of jumps. The frog can jump to any stone such that the absolute difference in weight between the current stone and the next stone is less than or equal to a given integer `k`. Determine if the frog can reach the last stone. If the frog can reach the last stone, return `true`; otherwise, return `false`. To clarify, the frog starts at the 0th stone and can only jump to stones within the given weight difference constraint. Return a boolean indicating whether the frog can reach the last stone or not.","solution":"def can_frog_reach_last_stone(stones, k): Determines if the frog can reach the last stone given the jumping constraint k. :param stones: List[int] - List of stone weights. :param k: int - Maximum allowed absolute difference in weight for a jump. :return: bool - True if the frog can reach the last stone, False otherwise. n = len(stones) if n == 1: return True reachable = [False] * n reachable[0] = True for i in range(n): if reachable[i]: for j in range(i + 1, n): if abs(stones[j] - stones[i]) <= k: reachable[j] = True if j == n - 1: return True else: break return reachable[-1]"},{"question":"You are given a list of `n` unique integers, `nums`, where `n > 1`, representing numbers from `1` to `n` in a random order. Write a function to find the length of the longest consecutive elements sequence in `nums`. Your algorithm should run in O(n) time complexity.","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in nums. The algorithm runs in O(n) time complexity. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # Look for the starting point of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 # Count the length of the sequence while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given a series of `n` steps to be recorded in an array `steps`, where `steps[i]` is the `i-th` step in either `U` (up) or `D` (down). When taking a step `U`, you move one unit upward, and when taking a step `D`, you move one unit downward. A \\"valley\\" is defined as a sequence of consecutive steps below the starting level that begin with a step down from sea level and end with a step up to sea level. Return the total number of valleys walked through.","solution":"def count_valleys(steps): Returns the total number of valleys walked through given a list of steps. Parameters: steps (list of str): A list representing steps where \'U\' is up and \'D\' is down. Returns: int: Number of valleys. sea_level = 0 current_level = 0 valleys = 0 in_valley = False for step in steps: if step == \'U\': current_level += 1 elif step == \'D\': current_level -= 1 if not in_valley and current_level < sea_level: # Entering a valley in_valley = True if in_valley and current_level == sea_level: # Exiting the valley valleys += 1 in_valley = False return valleys"},{"question":"You are given an integer array `heights` representing a billboard with `n` heights, where `heights[i]` is the height of the `ith` location on the billboard. Your task is to find the maximum number of water units the billboard can hold under the following condition: using one horizontal board, you can connect any two different locations `i` and `j` (such that `i < j`) and the elevation of the water between these two points should be the minimum height of `heights[i]` and `heights[j]`. The width between any two billboard locations is one unit. Implement the function `maxWaterStored(int[] heights)` that returns the maximum number of water units the billboard can hold. **Example:** ``` Input: heights = [1,8,6,2,5,4,8,3,7] Output: 49 Explanation: Vertical lines are drawn between positions 1 and 8. The height of water storage is min(heights[1], heights[8]) = min(8, 7) = 7. The width between them is 8 - 1 = 7, so the area is 49. ```","solution":"def maxWaterStored(heights): Returns the maximum number of water units the billboard can hold. :param heights: List[int] - heights of each position on the billboard. :return: int - maximum units of water stored. n = len(heights) max_water = 0 left, right = 0, n - 1 while left < right: current_water = min(heights[left], heights[right]) * (right - left) max_water = max(max_water, current_water) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"Given a string `s`, which consists of lowercase letters, remove duplicates such that every letter appears only once in the resulting string but keep the order of their first occurrences. Return the resulting string with removed duplicates.","solution":"def remove_duplicates(s): Removes duplicates from the string s while maintaining the order of first occurrences. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are given a **0-indexed** integer array `nums` and a positive integer `k`. A subarray of `nums` is called **k-ascending** if the subarray length is at least `k`, and for every consecutive elements `nums[i]` and `nums[i+1]` in the subarray, `nums[i] < nums[i+1]`. Return the length of the longest **k-ascending** subarray in `nums`. If no such subarray exists, return `-1`.","solution":"def longest_k_ascending_subarray(nums, k): Returns the length of the longest k-ascending subarray in nums. If no such subarray exists, returns -1. :param nums: List of integers :param k: Positive integer :return: Length of the longest k-ascending subarray, or -1 n = len(nums) if n < k: return -1 max_length = -1 current_length = 1 for i in range(1, n): if nums[i] > nums[i - 1]: current_length += 1 else: current_length = 1 if current_length >= k: max_length = max(max_length, current_length) return max_length"},{"question":"You are given a string `s` consisting of lowercase English letters and a character `k`. You need to remove the first occurrence of the character `k` from the string. If the character `k` is not present in the string, return the string as is. Return the resulting string after deleting the first occurrence of `k`.","solution":"def remove_first_occurrence(s, k): Removes the first occurrence of character k from the string s. If the character k is not present in the string, returns the string as is. index = s.find(k) if index != -1: return s[:index] + s[index+1:] return s"},{"question":"Given two sorted arrays `nums1` and `nums2` of lengths `m` and `n` respectively, merge `nums2` into `nums1` as one sorted array. The number of elements initialized in `nums1` and `nums2` are `m` and `n` respectively. `nums1` has a length of `m + n` to hold additional elements from `nums2`. Return _the merged sorted array_.","solution":"def merge(nums1, m, nums2, n): Merges two sorted arrays nums1 and nums2 and sorts them in place. nums1: List[int], has a length of m + n with the first m elements being initialized nums2: List[int], has a length of n m: int, the number of initialized elements in nums1 n: int, the number of elements in nums2 returns: List[int], the merged and sorted array # Last index of nums1 last = m + n - 1 # Merge nums1 and nums2 starting from the last elements while m > 0 and n > 0: if nums1[m - 1] > nums2[n - 1]: nums1[last] = nums1[m - 1] m -= 1 else: nums1[last] = nums2[n - 1] n -= 1 last -= 1 # If there are elements left in nums2, move them to nums1 while n > 0: nums1[last] = nums2[n - 1] n -= 1 last -= 1 return nums1"},{"question":"You are given a list of `n` distinct integers, `nums`, representing the positions of `n` people standing in a line. Each person in the line will be rearranged according to their position in the input list such that `nums[i]` denotes the new position of the person originally standing at position `i`. Implement a function that returns the final arrangement of people in the line after the rearrangement process is complete. The output should be an array representing the final positions in sequential order from the first person to the last.","solution":"def rearrange_line(nums): Returns the final arrangement of people in the line after rearranging as per nums. :param nums: List[int], a list of n distinct integers representing the new positions :return: List[int], the final arrangement of people in the line n = len(nums) result = [0] * n for i, pos in enumerate(nums): result[pos] = i return result"},{"question":"You are given an array `height` representing the heights of buildings along a street, where each `height[i]` is the height of the `i-th` building. There\'s a window washer who starts on the ground and wants to clean all the windows by standing on a ladder, which he can place on any building. The ladder has a maximum height `ladderHeight` he can reach from the ground. The washer can clean all windows on a building if the building\'s height is less than or equal to the ladder\'s height. If not, the washer cannot clean the building unless he places the ladder on top of another building. Return _the minimum number of positions the washer needs to place the ladder so he can clean all the windows on the given street_.","solution":"def min_ladder_positions(height, ladderHeight): Returns the minimum number of positions the washer needs to place the ladder to clean all the buildings. Parameters: height (list): A list of integers representing the height of buildings. ladderHeight (int): The maximum height the ladder can reach. Returns: int: The minimum number of positions required for the ladder. if not height: return 0 positions = 1 current_max_height = ladderHeight for h in height: if h > current_max_height: positions += 1 current_max_height += ladderHeight return positions"},{"question":"You are given two non-empty strings `s1` and `s2` consisting of lowercase English letters. Write a function that determines if `s1` and `s2` are isomorphic. Two strings `s1` and `s2` are isomorphic if the characters in `s1` can be replaced to get `s2`. For example, `\\"egg\\"` and `\\"add\\"` are isomorphic but `\\"foo\\"` and `\\"bar\\"` are not. Return `true` if `s1` and `s2` are isomorphic, and `false` otherwise.","solution":"def are_isomorphic(s1, s2): Determines if two strings s1 and s2 are isomorphic. Parameters: - s1 (str): The first string. - s2 (str): The second string. Returns: - bool: True if strings are isomorphic, False otherwise. if len(s1) != len(s2): return False mapping_s1_to_s2 = {} mapping_s2_to_s1 = {} for char1, char2 in zip(s1, s2): if char1 in mapping_s1_to_s2: if mapping_s1_to_s2[char1] != char2: return False if char2 in mapping_s2_to_s1: if mapping_s2_to_s1[char2] != char1: return False mapping_s1_to_s2[char1] = char2 mapping_s2_to_s1[char2] = char1 return True"},{"question":"You are given a string `s` and a dictionary of words `wordDict`, all consisting of lowercase letters. You need to find the **minimum number of segments** into which the string `s` can be segmented such that each segment is a valid word present in `wordDict`. If it is not possible to segment the string `s` in such a way, return `-1`. Return the minimum number of segments as an integer.","solution":"def min_segments_to_form_words(s, wordDict): Returns the minimum number of segments needed to segment the string such that each segment is a valid word in the wordDict. If it\'s not possible, returns -1. word_set = set(wordDict) n = len(s) # dp[i] will hold the minimum number of segments to segment s[0:i] dp = [float(\'inf\')] * (n + 1) dp[0] = 0 # No segments needed for an empty string for i in range(1, n + 1): for j in range(i): if s[j:i] in word_set: dp[i] = min(dp[i], dp[j] + 1) return dp[n] if dp[n] != float(\'inf\') else -1"},{"question":"You are given a string `word` consisting of alphabetical characters. A **palindromic substring** is a substring that reads the same backward as forward. Return _the length of the longest palindromic substring in_ `word`. The solution should have a time complexity better than `O(n^2)`.","solution":"def longest_palindromic_substring_length(word): Returns the length of the longest palindromic substring in the given word. if not word: return 0 n = len(word) start = 0 max_length = 1 low, high = 0, 0 for i in range(1, n): # Check for even length palindromes centered around `i-1` and `i` low = i - 1 high = i while low >= 0 and high < n and word[low] == word[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 # Check for odd length palindromes centered around `i` low = i - 1 high = i + 1 while low >= 0 and high < n and word[low] == word[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 return max_length"},{"question":"Given a linked list, determine if it has a cycle in it. A linked list is considered to have a cycle if it repeats infinitely. Implement the function `hasCycle` that takes the head of the linked list as input and returns `true` if there is a cycle, and `false` otherwise. **Class definition for a singly-linked list node:** ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` **Notes:** - Use Floyd\'s Tortoise and Hare algorithm to achieve this in linear time and constant space. - Assume that the linked list can contain up to 10^4 nodes.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def hasCycle(head): Detects if the linked list has a cycle in it using Floyd\'s Tortoise and Hare algorithm. Parameters: head (ListNode): The head of the linked list. Returns: bool: True if the linked list has a cycle, False otherwise. if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"You are given a binary tree where each node contains an integer value. Your task is to return the sum of values of the nodes you can visit following these conditions: 1. Start at any node of the tree. 2. From any node, you can move to its left child, right child, or parent (if it exists). 3. You can only visit each node once. Write a function to return the maximum possible sum of values from such a path in the binary tree. The input to the function is the root of the tree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def maxPathSum(root): Calculate the maximum path sum in the binary tree. Args: root (TreeNode): The root of the binary tree. Returns: int: The maximum sum of values from a path in the tree. def max_gain(node, visited): nonlocal max_sum if not node or node in visited: return 0 visited.add(node) left_gain = max(0, max_gain(node.left, visited)) right_gain = max(0, max_gain(node.right, visited)) current_sum = node.value + left_gain + right_gain max_sum = max(max_sum, current_sum) visited.remove(node) return node.value + max(left_gain, right_gain) max_sum = float(\'-inf\') max_gain(root, set()) return max_sum"},{"question":"You are given an integer array `arr` representing the lengths of bamboo sticks. You can perform a series of operations to bundle these sticks. In each operation, you can choose any two sticks and tie them together to form a new stick whose length is the sum of the chosen sticks\' lengths. The cost of this operation is equal to the sum of the lengths of the chosen sticks. Your task is to find the minimum cost required to bundle all the bamboo sticks into a single stick. Return _the minimum cost of bundling all sticks into one stick._","solution":"import heapq def minimum_cost_to_bundle_sticks(arr): Returns the minimum cost required to bundle all sticks into one stick. if len(arr) == 1: return 0 heapq.heapify(arr) total_cost = 0 while len(arr) > 1: first_min = heapq.heappop(arr) second_min = heapq.heappop(arr) cost = first_min + second_min total_cost += cost heapq.heappush(arr, cost) return total_cost"},{"question":"Write a function that determines whether a given positive integer `n` is a super palindrome. A super palindrome is an integer whose square is a palindrome. Return `true` if `n` is a super palindrome and `false` otherwise.","solution":"def is_palindrome(x): Check if a given number x is a palindrome. return str(x) == str(x)[::-1] def is_super_palindrome(n): Determines whether a given positive integer n is a super palindrome. A super palindrome is an integer whose square is a palindrome. if n < 1: return False square = n * n return is_palindrome(square)"},{"question":"Given a string `s` which represents a **binary string** (contains only \'0\' and \'1\'), return _the number of substrings that contain an equal number of \'0\'s and \'1\'s_. The substrings should be **contiguous** blocks within the original string.","solution":"def count_binary_substrings(s): Returns the number of substrings with equal number of \'0\'s and \'1\'s. count = 0 prev_run_length, curr_run_length = 0, 1 for i in range(1, len(s)): if s[i] == s[i - 1]: curr_run_length += 1 else: count += min(prev_run_length, curr_run_length) prev_run_length, curr_run_length = curr_run_length, 1 count += min(prev_run_length, curr_run_length) return count"},{"question":"Given a string `s`, determine if it is a valid string according to the following rules: 1. The string must contain only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. 2. The characters must be arranged to form a well-formed string, where parentheses are correctly matched and nested. A well-formed string follows these rules: - Open brackets (\'(\', \'{\', \'[\') must be closed by the same type of bracket. - Open brackets must be closed in the correct order. Return `true` if the string is valid, and `false` otherwise.","solution":"def is_valid_parentheses(s): Determines if the given string s containing only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' is a well-formed string with correctly matched and nested parentheses. stack = [] matching_parentheses = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in matching_parentheses: if stack and stack[-1] == matching_parentheses[char]: stack.pop() else: return False else: stack.append(char) return not stack"},{"question":"You are given an integer array `arr`, and your task is to find the number of pairs `(i, j)` such that `arr[i] == arr[j]` and `i < j`. Return the number of such pairs. Note that the array can have duplicate elements.","solution":"def count_pairs(arr): Returns the number of pairs (i, j) such that arr[i] == arr[j] and i < j. count = 0 element_count = {} for value in arr: if value in element_count: count += element_count[value] element_count[value] += 1 else: element_count[value] = 1 return count"},{"question":"You are given a list of integers `weights` representing the weights of different items and an integer `capacity` representing the maximum weight capacity of a bag. Each item can either be included in or excluded from the bag. Your task is to determine the maximum weight that can be achieved without exceeding the `capacity` of the bag using the given items. Return the maximum weight that can be achieved. This is a variation of the classic \\"Knapsack Problem\\".","solution":"def knapsack(weights, capacity): Determines the maximum weight that can be achieved without exceeding the capacity of the bag. :param weights: List of integers representing the weights of items. :param capacity: An integer representing the maximum weight capacity of the bag. :return: An integer representing the maximum weight that can be achieved without exceeding the capacity. n = len(weights) dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): if weights[i-1] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w - weights[i-1]] + weights[i-1]) else: dp[i][w] = dp[i-1][w] return dp[n][capacity]"},{"question":"You are given a `string` `path` representing a UNIX-style file path. Determine if the file path is valid by checking the following conditions: - Paths should start with a single slash `/`. - Consecutive slashes `//` should be treated as a single slash `/`. - Paths can contain dot `.` characters which refer to the current directory and double dots `..` which refer to the parent directory, but they should not exceed the root directory. A valid path is always navigating within the root directory, and it should simplify `.` or `..` representations correctly. Return `true` if the path is valid and `false` otherwise.","solution":"def is_valid_unix_path(path): Determine if the given UNIX-style file path is valid. if not path or path[0] != \'/\': return False components = path.split(\'/\') stack = [] for component in components: if component == \'\' or component == \'.\': continue elif component == \'..\': if stack: stack.pop() else: return False else: stack.append(component) return True"},{"question":"Given a 2D integer array `matrix` of size `m x n`, return a list of the matrix\'s **spiral order** traversal starting from the top-left corner. The traversal should proceed in a clockwise direction, from left to right, then top to bottom, then right to left, and finally bottom to top, repeating this pattern until all elements are visited.","solution":"def spiral_order(matrix): Returns the spiral order traversal of a 2D matrix. res = [] if not matrix: return res top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: for col in range(left, right + 1): res.append(matrix[top][col]) top += 1 for row in range(top, bottom + 1): res.append(matrix[row][right]) right -= 1 if top <= bottom: for col in range(right, left - 1, -1): res.append(matrix[bottom][col]) bottom -= 1 if left <= right: for row in range(bottom, top - 1, -1): res.append(matrix[row][left]) left += 1 return res"},{"question":"A sequence of numbers is called a **Fibonacci sequence** if it meets the following condition: each number, after the first two, is the sum of the two preceding ones. The first two numbers are `0` and `1`. Given a number `n`, return _the first `n` numbers in the Fibonacci sequence as a list_.","solution":"def fibonacci_sequence(n): Returns the first n numbers in the Fibonacci sequence as a list. if n <= 0: return [] elif n == 1: return [0] fib_sequence = [0, 1] while len(fib_sequence) < n: next_fib = fib_sequence[-1] + fib_sequence[-2] fib_sequence.append(next_fib) return fib_sequence"},{"question":"Given an array of integers `arr`, return an array containing the result of adding 1 to each element of the input array using recursion. The function should not use any loops, and should modify the input array in place.","solution":"def add_one_to_each_element(arr, index=0): Adds one to each element of the array using recursion. Parameters: arr (list): A list of integers. index (int): Current index to be processed in the recursion (default 0). Returns: list: The array with each element incremented by 1. if index == len(arr): return arr arr[index] += 1 return add_one_to_each_element(arr, index + 1)"},{"question":"You are given a **2D** matrix `mat` of size `m x n` and an integer `target`. Each element in the matrix represents the cost of stepping on that cell. Starting from the top-left corner of the matrix, return `true` _if it is possible to reach the bottom-right corner with a path whose cost is less than or equal to_ `target`_, otherwise return_ `false`. You can only move either down or right at any point in time.","solution":"def is_path_possible(mat, target): if not mat or not mat[0]: return False m, n = len(mat), len(mat[0]) dp = [[float(\'inf\')] * n for _ in range(m)] dp[0][0] = mat[0][0] for i in range(m): for j in range(n): if i > 0: dp[i][j] = min(dp[i][j], dp[i-1][j] + mat[i][j]) if j > 0: dp[i][j] = min(dp[i][j], dp[i][j-1] + mat[i][j]) return dp[m-1][n-1] <= target"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to determine if you can obtain a string that is a permutation of a palindrome. A palindrome is a word or phrase that reads the same backward as forward. Return `true` if there is at least one permutation of `s` that is a palindrome, otherwise return `false`.","solution":"def can_form_palindrome(s): Determines if any permutation of the input string can be a palindrome. :param s: A string consisting of lowercase English letters. :return: True if any permutation of the string can be a palindrome, False otherwise. # Frequency dictionary to count occurrences of each character char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Count how many characters have an odd number of occurrences odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # For a string to be able to form a palindrome, it can have at most one character with an odd count return odd_count <= 1"},{"question":"You are given a **circular array** `nums` of integers. A circular array means the end of the array is connected to the beginning of the array. Formally, the next element of `nums[i]` is `nums[(i + 1) % n]` and the previous element of `nums[i]` is `nums[(i - 1 + n) % n]`, where `n` is the size of the `nums`. Each element in the array represents the gas at that station. You also have an integer array `cost` of the same length where `cost[i]` is the amount of gas required to travel from the `ith` station to the `(i + 1)`th station. Return the starting gas station\'s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.","solution":"def can_complete_circuit(nums, cost): Determines if you can travel around the circular array once. Returns the starting gas station\'s index or -1 if not possible. total_tank = 0 curr_tank = 0 starting_station = 0 for i in range(len(nums)): total_tank += nums[i] - cost[i] curr_tank += nums[i] - cost[i] # If one station fails, reset the start position and the current tank if curr_tank < 0: starting_station = i + 1 curr_tank = 0 return starting_station if total_tank >= 0 else -1"},{"question":"You are given a string `s` consisting of lowercase English letters. A **duplicate removal** consists of choosing two adjacent and equal letters and removing them. We repeatedly make duplicate removals on `s` until no adjacent letters are equal. Return _the final string after all such duplicate removals have been made_. Ensure the returned string has the smallest lexicographical order if there is a tie.","solution":"def remove_duplicates(s): Removes adjacent duplicates in the string until no adjacent duplicates remain. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given an integer array `heights` representing the heights of students in a class. The students will be arranged in non-decreasing order of their heights, but with an additional constraint: students with the same height should remain in their original relative order. Write a function that modifies the array `heights` to reflect the new order while maintaining this constraint. You must do this in-place, with O(1) additional space, and within O(n log n) time complexity.","solution":"def sort_heights_stable(heights): Sort the heights array in non-decreasing order while maintaining the relative order of students with the same height. # Using Timsort which is a stable sort and works in O(n log n) time complexity. heights.sort()"},{"question":"You are given a **0-indexed** integer array `strength` where `strength[i]` represents the strength of the `i-th` candidate. We need to form teams of exactly `k` candidates from the `n` candidates in such a way that the sum of the strengths of the candidates in each team is maximized. Return _the maximum possible sum of the strengths of the chosen teams._ For example, if the input `strength` = [1, 2, 3, 4, 5] and `k` = 2, the optimal teams would be (4,5), (2,3), resulting in the maximum possible sum being 14. You need to implement the function: ```python def max_team_strength(strength: List[int], k: int) -> int: pass ``` **Note:** You need to ensure that each candidate can only be included in one team.","solution":"def max_team_strength(strength, k): Returns the maximum possible sum of the strengths of the chosen teams. Parameters: - strength: List[int] : List of candidates\' strengths - k: int : Number of candidates per team Returns: - int : Maximum sum of team strengths. # Sort the strengths in descending order strength.sort(reverse=True) # Calculate sum of the first (k*n) elements return sum(strength[:k])"},{"question":"Given a string `s` representing a Unix-style file path, simplify it to produce the canonical path. In a Unix-style file path: - A period `.` refers to the current directory. - A double period `..` moves up a directory. - Any multiple consecutive slashes are treated as a single slash `/`. The canonical path should: 1. Start with a single slash `/`. 2. Eliminate any empty directory names caused by multiple consecutive slashes. 3. Eliminate any period `.` components. 4. Eliminate any directory components that are `..` and their corresponding upward movement in the directory structure. 5. Return the simplified canonical path. For example, given the input string `\\"/home/../usr//bin/./script\\"`, the canonical path would be `\\"/usr/bin/script\\"`.","solution":"def simplify_path(s): Simplifies the given Unix-style file path to its canonical form. :param s: str : Unix-style file path :return: str : Simplified canonical path components = s.split(\'/\') stack = [] for component in components: if component == \'\' or component == \'.\': continue elif component == \'..\': if stack: stack.pop() else: stack.append(component) return \'/\' + \'/\'.join(stack)"},{"question":"You are given a **0-indexed** integer array `nums` representing a list of non-negative integers. You are allowed to perform one operation of your choice to maximize the sum of the array. The operation consists of choosing a non-empty subarray, deleting it, and appending it to the end of the remaining array. Determine the maximum possible sum of the array after performing the operation. Return the maximum possible sum after one such operation.","solution":"def max_possible_sum(nums): Determines the maximum possible sum after one subarray deletion and append operation. Parameters: nums (List[int]): A list of non-negative integers. Returns: int: The maximum possible sum of the array after the operation. if not nums: return 0 return sum(nums)"},{"question":"You are given a rectangular matrix of integers `mat` with dimensions `m x n`. Each cell in the matrix has either a `0` or a `1` value. A cell is called a **special cell** if its value is `1` and it is the only `1` in its row and column. Return _the total number of special cells_ in the matrix.","solution":"def numSpecial(mat): Returns the number of special cells in the matrix \'mat\'. A cell is considered special if its value is `1` and it is the only `1` in its row and column. :param mat: List[List[int]] - 2D list representing a matrix with values 0 or 1. :return: int - number of special cells m = len(mat) n = len(mat[0]) row_counts = [sum(row) for row in mat] col_counts = [sum(col) for col in zip(*mat)] count_special = 0 for i in range(m): for j in range(n): if mat[i][j] == 1 and row_counts[i] == 1 and col_counts[j] == 1: count_special += 1 return count_special"},{"question":"You are given a binary string `s` of length `n`. A binary string is a string consisting only of characters \'0\' and \'1\'. You can select any single character from `s` and flip it (change \'0\' to \'1\' or \'1\' to \'0\'). Your task is to return the minimum number of flips required to make the string have no consecutive \'1\'s. In other words, you want to ensure that no two \'1\'s are adjacent after the flips.","solution":"def min_flips_to_avoid_consecutive_ones(s): Returns the minimum number of flips required to make the binary string have no consecutive \'1\'s. n = len(s) if n <= 1: return 0 # Count consecutive \'1\'s consecutive_ones_count = 0 for i in range(1, n): if s[i] == \'1\' and s[i-1] == \'1\': consecutive_ones_count += 1 # The result is the number of consecutive \'1\'s blocks found return consecutive_ones_count"},{"question":"You are given a **0-indexed** integer array `arr` containing `n` integers. The task is to find if there exists a subset of indices `S` such that the sum of elements at these indices is equal to the sum of the remaining elements in the array. If such a subset exists, return `true`. Otherwise, return `false`. Note that the empty subset is a valid subset. Implement the function `boolean canPartition(int[] arr)`.","solution":"def canPartition(arr): total_sum = sum(arr) # If the total sum is odd, it\'s not possible to partition into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(arr) # dp array to check if a sum is possible with the elements dp = [False] * (target + 1) dp[0] = True # There is always a subset with 0 sum - the empty subset for num in arr: for j in range(target, num-1, -1): dp[j] = dp[j] or dp[j-num] return dp[target]"},{"question":"You are given a string `s` consisting of lowercase English letters and/or digits. Write a function to perform the following operations on `s`: 1. Replace every digit in `s` with its corresponding English word (e.g., replace \'1\' with \\"one\\", \'2\' with \\"two\\", etc.). 2. Convert all letters in `s` to uppercase. Return the modified string after performing these operations.","solution":"def transform_string(s): Replaces every digit in `s` with its corresponding English word, and converts all letters in `s` to uppercase. digit_map = { \'0\': \'zero\', \'1\': \'one\', \'2\': \'two\', \'3\': \'three\', \'4\': \'four\', \'5\': \'five\', \'6\': \'six\', \'7\': \'seven\', \'8\': \'eight\', \'9\': \'nine\' } transformed = [] for char in s: if char.isdigit(): transformed.append(digit_map[char]) else: transformed.append(char.upper()) return \'\'.join(transformed)"},{"question":"You are given a list of integers `heights` representing the heights of buildings, where the width of each building is 1. It starts raining and water collects between the buildings. Write a function to compute how much water is trapped after it rains. Return the total amount of water that is trapped.","solution":"def trap(height): Computes the total amount of water that is trapped after raining. Parameters: height (List[int]): The heights of the buildings. Returns: int: Total amount of water trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"There is a **directed** acyclic graph with `n` vertices, where each vertex is labeled from `0` to `n - 1` (**inclusive**). The edges in the graph are represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]` denotes a directed edge from vertex `ui` to vertex `vi`. You are given a list of vertices `eventual_safe_nodes` which are originally all marked as unsafe. Determine the list of vertices that can be considered as \\"safe\\". A node is considered \\"safe\\" if every possible path starting from that node leads to a terminal node that eventually has no outgoing edges (a terminal node is either a dead-end or leads only to other terminal nodes). Return _a sorted list of safe nodes_ given the graph described by `edges`.","solution":"def eventual_safe_nodes(n, edges): from collections import defaultdict, deque # Create a graph and reverse graph representation graph = defaultdict(list) reverse_graph = defaultdict(list) outdegree = [0] * n # Out-degree of each node # Build the graph and reverse graph for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) outdegree[u] += 1 # Create a queue to store nodes with out-degree 0 (terminal nodes) queue = deque([i for i in range(n) if outdegree[i] == 0]) safe = [False] * n # Process the queue while queue: node = queue.popleft() safe[node] = True # Mark this node as safe for neigh in reverse_graph[node]: outdegree[neigh] -= 1 if outdegree[neigh] == 0: queue.append(neigh) # Collect all safe nodes and sort them safe_nodes = [i for i in range(n) if safe[i]] safe_nodes.sort() return safe_nodes"},{"question":"You are given a list of integers `arr` and an integer `threshold`. Your task is to split `arr` into `k` contiguous subarrays such that the sum of the maximum sums of each subarray is minimized and does not exceed the `threshold`. Return the integer `k` which represents the minimum number of subarrays needed to achieve this.","solution":"def split_array_min_subarrays(arr, threshold): def count_subarrays(max_sum): count = 1 current_sum = 0 for num in arr: if current_sum + num > max_sum: count += 1 current_sum = num else: current_sum += num return count left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if count_subarrays(mid) <= threshold: right = mid else: left = mid + 1 return left"},{"question":"You are given a string `s` that consists of lower case English letters and brackets. Reverse the strings in each pair of matching parentheses, starting from the innermost one. Your result should not contain any brackets. For example, if given the input `s = \\"(u(love)i)\\"`, the output should be `\\"iloveu\\"`. Make sure that the parentheses are balanced, i.e., every opening parenthesis has a corresponding closing parenthesis.","solution":"def reverse_parentheses(s): Reverses the strings in each pair of matching parentheses, starting from the innermost one. Parameters: s (str): The input string containing lowercase letters and parentheses. Returns: str: The modified string with reversed sections from parentheses. stack = [] for ch in s: if ch == \')\': temp = [] while stack and stack[-1] != \'(\': temp.append(stack.pop()) # pop the \'(\' from the stack stack.pop() # extend the stack with the reversed content from temp stack.extend(temp) else: stack.append(ch) return \'\'.join(stack)"},{"question":"You are given an array of integers `heights` representing the heights of buildings, where each integer `heights[i]` corresponds to the height of the `ith` building. Assume that you have a **water tank** which can potentially store water between the buildings, where the water can be trapped only if there are buildings on both the sides that are taller than the gap between them. Compute and return _the maximum amount of water that can be trapped between the buildings_. The input will guarantee that the array `heights` contains at least one building.","solution":"def trap(heights): Returns the maximum amount of water that can be trapped between buildings. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"You are given a `linked list` where each node contains a single `integer` value. The linked list has been **sorted** in **ascending order**, but a few of its `nodes` have been modified, and as a result, some values are now out of order. Your task is to restore the linked list to its original **sorted** order. You must achieve this in **constant** space. Return _the head node of the restored linked list._","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def sortLinkedList(head: ListNode) -> ListNode: if not head or not head.next: return head # Bubble Sort approach for linked list has_swapped = True while has_swapped: has_swapped = False current = head while current and current.next: if current.val > current.next.val: current.val, current.next.val = current.next.val, current.val has_swapped = True current = current.next return head"},{"question":"You are given a string `s` consisting of lowercase English characters. A **valid substring** is defined as a contiguous substring of `s` that contains an equal number of the characters \'a\', \'b\', and \'c\'. Return _the length of the **shortest** valid substring in_ `s`. If no such substring exists, return **-1**.","solution":"def shortest_valid_substring(s): n = len(s) min_length = float(\'inf\') for left in range(n): count = {\'a\': 0, \'b\': 0, \'c\': 0} for right in range(left, n): if s[right] in count: count[s[right]] += 1 if count[\'a\'] == count[\'b\'] == count[\'c\'] and count[\'a\'] > 0: min_length = min(min_length, right - left + 1) return min_length if min_length != float(\'inf\') else -1"},{"question":"Given an integer array `nums`, return _the length of the longest bitonic subarray_. A bitonic subarray is a subarray that is first increasing and then decreasing. A strictly increasing or strictly decreasing subarray is also considered bitonic.","solution":"def longest_bitonic_subarray(nums): n = len(nums) if n == 0: return 0 # Arrays to store the longest increasing and decreasing subarray lengths inc = [1] * n dec = [1] * n # Fill increasing subarray length array for i in range(1, n): if nums[i] > nums[i - 1]: inc[i] = inc[i - 1] + 1 # Fill decreasing subarray length array for j in range(n - 2, -1, -1): if nums[j] > nums[j + 1]: dec[j] = dec[j + 1] + 1 # Find the length of the maximum length bitonic subarray max_len = 0 for i in range(n): max_len = max(max_len, inc[i] + dec[i] - 1) return max_len"},{"question":"You are given two arrays `nums1` and `nums2` of the same length, containing non-negative integers. The task is to find the maximum length of any common subarray between `nums1` and `nums2`. A common subarray is defined as a contiguous portion of both arrays that have exactly the same elements in the same order. Return the length of this maximum common subarray.","solution":"def find_max_length_of_common_subarray(nums1, nums2): Finds the maximum length of any common subarray between nums1 and nums2. n = len(nums1) dp = [[0] * (n + 1) for _ in range(n + 1)] max_length = 0 for i in range(1, n + 1): for j in range(1, n + 1): if nums1[i - 1] == nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"A company is holding a coding competition with `n` participants. Each participant is assigned a unique participant ID from `1` to `n`. The competition proceeds in rounds. In each round, any two participants can compete against each other, and one of them is considered the winner. You are given a 2-dimensional list `results` where `results[i]` contains two integers `[winner, loser]`, indicating that participant `winner` defeated participant `loser` in that round. Using the given results, determine the number of participants who have taken part in at least one competition and have never lost any round. Return the list of participants\' IDs sorted in ascending order. If no such participants exist, return an empty list.","solution":"def find_participant_never_lost(n, results): Returns the list of participant IDs who never lost any round. Parameters: n (int): The number of participants. results (List[List[int]]): A list of lists where each sublist contains two integers [winner, loser], indicating that `winner` defeated `loser` in that round. Returns: List[int]: List of participant IDs in ascending order who have never lost any round. all_participants = set(range(1, n + 1)) losers = {loser for winner, loser in results} never_lost = all_participants - losers return sorted(list(never_lost))"},{"question":"Given a 2D integer array `matrix` of size `n x n` representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image **in-place**, which means you have to modify the input 2D array directly. **Do not** allocate another 2D array for the rotation. Return the rotated image as the final output.","solution":"def rotate_image(matrix): Rotates the given n x n 2D matrix 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"You are given a 1-indexed integer array `awards` where each element represents the number of points awarded to a participant in a competition. Your task is to determine the **minimum number of participants** that need to be combined into a **team** so that the total points of the team are at least a given target `points`. A team can consist of contiguous participants from the `awards` array. If it is not possible to form such a team, return `-1`.","solution":"def min_team_size(awards, points): Returns the minimum number of participants that need to be combined into a team so that the total points of the team are at least the given target points. Parameters: awards (list of int): 1-indexed integer array where each element represents points awarded to a participant. points (int): the target points that the team needs to reach. Returns: int: minimum number of participants required to form such a team or -1 if not possible. n = len(awards) # Use a sliding window approach min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += awards[end] while current_sum >= points: min_length = min(min_length, end - start + 1) current_sum -= awards[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"Given an integer array `arr` representing the height of buildings, and an integer `k`, you need to distribute `k` red flags on the buildings such that no two flags are on adjacent buildings. Return _the maximum number of red flags that can be placed on the buildings_.","solution":"def max_red_flags(arr, k): Returns the maximum number of red flags that can be placed on the buildings such that no two flags are on adjacent buildings. Parameters: arr (list of int): The heights of the buildings. k (int): The number of flags to distribute. Returns: int: The maximum number of red flags placed. # If there are no buildings or no flags, return 0 if not arr or k == 0: return 0 # Calculate the maximum number of flags by ensuring no two flags are adjacent. # We can place a flag at every other building starting from the first one. max_flags = 0 i = 0 while i < len(arr) and max_flags < k: max_flags += 1 i += 2 return max_flags"},{"question":"You are given a **0-indexed** integer array `arr` of length `n` and an integer `k`. You need to return the maximum sum of a subarray of length `k`. A subarray is a contiguous non-empty sequence of elements within an array. If the length of the array is less than `k`, return `-1`. The function signature should be: ```python def maxSumSubarray(arr: List[int], k: int) -> int: ```","solution":"from typing import List def maxSumSubarray(arr: List[int], k: int) -> int: Returns the maximum sum of a subarray of length k in arr. If the length of array is less than k, return -1. n = len(arr) if n < k: return -1 # Initial window sum current_sum = sum(arr[:k]) max_sum = current_sum # Slide the window for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an integer array `arr` consisting of `n` integers. A subsequence of `arr` is obtained by deleting some (possibly none) elements from `arr` without changing the order of the remaining elements. Find the length of the longest subsequence that consists of only unique elements. If all elements of `arr` are the same, return `1`.","solution":"def length_of_longest_unique_subsequence(arr): Returns the length of the longest subsequence that consists of only unique elements. if not arr: return 0 unique_elements = set(arr) return len(unique_elements)"},{"question":"You are given a circular array `nums` of length `n` and an integer `k`. The circular array means that the element after `nums[n-1]` is `nums[0]`. Your task is to rotate the array to the right by `k` steps, where `k` is non-negative. Implement a function that performs this rotation in-place and returns the modified array. For example, given `nums = [1, 2, 3, 4, 5, 6, 7]` and `k = 3`, the resultant array would be `[5, 6, 7, 1, 2, 3, 4]`.","solution":"def rotate(nums, k): Rotates the array to the right by k steps in-place. n = len(nums) k = k % n # In case k is larger than n nums[:] = nums[-k:] + nums[:-k] return nums"},{"question":"Given an array of integers `arr` of size `n`, an integer `k` and an integer `x`, find _the **maximum** possible sum of `k` **distinct** integers in `arr` that are **less than or equal to** `x`._ Return the maximum sum or `0` if it is not possible to choose `k` distinct integers satisfying the condition.","solution":"from typing import List def maximum_sum(arr: List[int], k: int, x: int) -> int: Returns the maximum possible sum of k distinct integers in arr that are less than or equal to x. Arguments: arr -- list of integers k -- number of distinct integers to be chosen x -- maximum value constraint for the chosen integers Returns: The maximum possible sum of k distinct integers less than or equal to x, or 0 if not possible. # Filter out the integers from arr that are less than or equal to x valid_integers = [num for num in arr if num <= x] # If the number of valid integers is less than k, return 0 if len(valid_integers) < k: return 0 # Sort the valid integers in descending order valid_integers.sort(reverse=True) # Sum the top k valid integers return sum(valid_integers[:k])"},{"question":"You are given an integer array `prices` representing the stock prices of a company in chronological order. You are allowed to complete **at most two transactions** to maximize your profit where each transaction consists of buying and selling one share of the stock. Note that you cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Implement a function that calculates and returns _the **maximum** profit you can achieve_ based on the given stock prices.","solution":"def max_profit_with_two_transactions(prices): if not prices: return 0 n = len(prices) max_profit = 0 # Initialize profit arrays profit_one_transaction = [0] * n profit_two_transactions = [0] * n # Max profit if only one transaction is allowed min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) profit_one_transaction[i] = max(profit_one_transaction[i-1], prices[i] - min_price) # Max profit with at most two transactions max_price = prices[-1] for i in range(n-2, -1, -1): max_price = max(max_price, prices[i]) profit_two_transactions[i] = max(profit_two_transactions[i+1], max_price - prices[i] + profit_one_transaction[i]) max_profit = max(profit_two_transactions) return max_profit"},{"question":"You are given a string `s` consisting of lowercase English letters. Your task is to determine the minimum number of adjacent swaps required to make `s` a palindrome. If it is impossible to form a palindrome, return `-1`. Write a function `minSwapsToPalindrome(s: str) -> int` to accomplish this.","solution":"def minSwapsToPalindrome(s: str) -> int: from collections import Counter def is_palindrome_possible(s: str) -> bool: counts = Counter(s) odd_count = sum(1 for count in counts.values() if count % 2 != 0) return odd_count <= 1 def min_swaps_to_make_palindrome(s: str) -> int: s = list(s) n = len(s) swaps = 0 for i in range(n // 2): left = i right = n - left - 1 while left < right: if s[left] == s[right]: break right -= 1 if left == right: s[left], s[left+1] = s[left+1], s[left] swaps += 1 left -= 1 continue for j in range(right, n-left-1): s[j], s[j+1] = s[j+1], s[j] swaps += 1 return swaps if not is_palindrome_possible(s): return -1 return min_swaps_to_make_palindrome(s)"},{"question":"You are given two strings, `s1` and `s2`, both of the same length. You want to transform `s1` into `s2` by swapping any two characters in `s1` any number of times. Return *True* if it is possible to transform `s1` into `s2`, and *False* otherwise. **Note** that: * You can swap the same pair of characters multiple times. * The order of characters in `s2` should be the same as you want in `s1` at the final transformation.","solution":"def can_transform(s1, s2): Returns True if it\'s possible to transform s1 into s2 by swapping any two characters in s1 any number of times. Returns False otherwise. # If the lengths of the strings are different, transformation is not possible. if len(s1) != len(s2): return False # We can swap any characters in s1, hence we only need to check if both strings have the same characters. return sorted(s1) == sorted(s2)"},{"question":"You are given a linked list where each node contains an integer value. Write a function to split the linked list into `k` consecutive linked list parts. The length of each part should be as equal as possible. No part should contain fewer nodes than any other part. If there are extra nodes, the earlier parts should have one more node than the later parts. Return a list containing the `k` parts in order. The input will be the head of the linked list and the integer `k`. The output should be a list containing the heads of the `k` parts. If the linked list has fewer than `k` nodes, some parts will be null. For example: - Given the linked list `1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10` and `k = 3`, return three linked list parts: `1 -> 2 -> 3 -> 4`, `5 -> 6 -> 7`, `8 -> 9 -> 10`. - Given the linked list `1 -> 2 -> 3` and `k = 5`, return five linked list parts: `1`, `2`, `3`, `null`, `null`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def splitListToParts(head, k): # First, find the length of the linked list length = 0 current = head while current: length += 1 current = current.next # Determine the size of each part and how many parts will have an extra node part_size = length // k extra_nodes = length % k parts = [] current = head for _ in range(k): part_head = current part_tail = None # Determine the size of this part current_part_size = part_size if extra_nodes > 0: current_part_size += 1 extra_nodes -= 1 # Split the linked list to form this part for _ in range(current_part_size): if current: part_tail = current current = current.next # If part_tail is not None, end this part if part_tail: part_tail.next = None # Add this part to the list of parts parts.append(part_head) return parts"},{"question":"You are given a string `s` containing only digits. You can perform the following operation any number of times: choose any two adjacent digits in the string and replace them with the product of those two digits. This operation reduces the length of the string by one each time it is performed. Your goal is to determine the minimum possible value of the string you can get after applying the operation any number of times. Return the minimum value as an integer. For example, given the string `\\"123\\"`, you can replace adjacent digits: - Replace `\\"1\\"` and `\\"2\\"` to get `\\"36\\"`. - Replace `\\"3\\"` and `\\"6\\"` to get `\\"18\\"`. Thus, the minimum value for the string `\\"123\\"` is `18`.","solution":"def min_string_value(s): Computes the minimum possible value by repeatedly multiplying adjacent digits. :param s: Input string composed of digits :return: Minimum possible value as an integer # If the string is already of length 1 if len(s) == 1: return int(s) # Convert the string to a list of integers numbers = list(map(int, s)) # Initialize result with the first number result = numbers[0] for num in numbers[1:]: result *= num return result"},{"question":"You are given an array of integers `nums`. Implement a data structure that supports the following operations: * `RangeSum(int[] nums)` Initializes the object with the given array `nums`. * `void update(int index, int val)` Updates the value of `nums` at the specified index to be `val`. * `int sumRange(int left, int right)` Returns the sum of the elements of `nums` between indices `left` and `right` inclusive (i.e., nums[left] + nums[left + 1] + ... + nums[right]).","solution":"class RangeSum: def __init__(self, nums): self.nums = nums self.n = len(nums) self.tree = [0] * (self.n + 1) for i in range(self.n): self.add(i + 1, nums[i]) def add(self, index, val): while index <= self.n: self.tree[index] += val index += index & -index def update(self, index, val): delta = val - self.nums[index] self.nums[index] = val self.add(index + 1, delta) def sumRange(self, left, right): return self.prefixSum(right + 1) - self.prefixSum(left) def prefixSum(self, index): sum_ = 0 while index > 0: sum_ += self.tree[index] index -= index & -index return sum_"},{"question":"You are given an array of integers `nums` and an integer `k`. Your task is to determine if there exists a continuous subarray whose sum is exactly `k`. The subarray must contain at least one integer. Return _True_ if such a subarray exists and _False_ otherwise.","solution":"def subarray_sum(nums, k): Determines if there exists a continuous subarray whose sum is exactly k. :param nums: List[int] - A list of integers. :param k: int - The target sum. :return: bool - True if such a subarray exists, False otherwise. current_sum = 0 sum_dict = {0: 1} for num in nums: current_sum += num if current_sum - k in sum_dict: return True if current_sum not in sum_dict: sum_dict[current_sum] = 1 else: sum_dict[current_sum] += 1 return False"},{"question":"You are given a linked list with nodes containing integer values. However, the linked list may contain a loop. Specifically, a loop is formed when a node\'s \\"next\\" pointer points to one of the previous nodes in the list, thus forming a cycle. Given the head of the linked list, return _the node where the cycle begins_. If there is no cycle, return `null`. Note that you should not modify the linked list while solving this problem.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detectCycle(head): This function detects the node where the cycle begins in a linked list. If there is no cycle, it returns None. if head is None or head.next is None: return None slow = fast = head # First, determine if there is a cycle. while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If there is no cycle, return None. if not fast or not fast.next: return None # Find the start of the cycle. slow = head while slow != fast: slow = slow.next fast = fast.next return slow # slow (or fast) points to the start of the cycle."},{"question":"You are given a list of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and end of the `i`-th interval. You need to insert a new interval `newInterval = [start, end]` into the list so that the list of intervals remains sorted in ascending order of their start times. After insertion, merge all overlapping intervals. Return _the resulting list of non-overlapping intervals_. Example: Input: intervals = [[1, 3], [6, 9]], newInterval = [2, 5] Output: [[1, 5], [6, 9]] Note that the new list of intervals should be merged and sorted appropriately.","solution":"def insert_and_merge_intervals(intervals, new_interval): Insert a new interval into the list of non-overlapping intervals and merge if necessary. :param intervals: List of non-overlapping intervals [start, end] :param new_interval: The new interval to insert [start, end] :return: List of merged non-overlapping intervals merged_intervals = [] i = 0 n = len(intervals) # Add all intervals before the new_interval while i < n and intervals[i][1] < new_interval[0]: merged_intervals.append(intervals[i]) i += 1 # Merge overlapping intervals with new_interval while i < n and intervals[i][0] <= new_interval[1]: new_interval[0] = min(new_interval[0], intervals[i][0]) new_interval[1] = max(new_interval[1], intervals[i][1]) i += 1 # Add the merged new_interval merged_intervals.append(new_interval) # Add all remaining intervals after the new_interval while i < n: merged_intervals.append(intervals[i]) i += 1 return merged_intervals"},{"question":"You are given an integer array `nums` and an integer `k`. Your task is to implement a method to find the `k` most frequent elements in the array. Return the answer in any order. You may assume that `k` is always valid: `1 ≤ k ≤ number of unique elements in the array`. Implement the following function: * `List<Integer> topKFrequent(int[] nums, int k)` Your code will be tested with the following pseudocode: initialize the array nums and the integer k call the function topKFrequent(nums, k) store the result and verify the output If the output matches the expected top `k` frequent elements, then your code will be judged as correct.","solution":"from typing import List from collections import Counter def topKFrequent(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements in the array nums. count = Counter(nums) return [item for item, freq in count.most_common(k)]"},{"question":"You are given a 2D grid of size `m x n` where each cell represents a plot of land that can be used to build a house. Each cell in the grid contains exactly one house, marked by a `1`, or an empty plot, marked by a `0`. A house can only be connected to another house through a direct edge (left, right, up, or down). We consider a group of houses connected in this way as a block. Your task is to return the number of distinct blocks present in the grid.","solution":"def numDistinctBlocks(grid): def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1: return grid[i][j] = -1 # Mark this house as visited dfs(grid, i+1, j) dfs(grid, i-1, j) dfs(grid, i, j+1) dfs(grid, i, j-1) if not grid: return 0 num_blocks = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: dfs(grid, i, j) num_blocks += 1 return num_blocks"},{"question":"Consider a **linked list** where each node contains an integer value. Write a function that, given the head of the linked list, will remove all nodes that have duplicate numbers, leaving only distinct numbers from the original list. The function should preserve the order of the original list while removing duplicates. The implementation should be efficient in both time and space complexity. For example, given the linked list: `1 -> 2 -> 3 -> 2 -> 4 -> 3 -> 5`, the function should return a modified linked list: `1 -> 4 -> 5`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): from collections import defaultdict if not head: return None freq = defaultdict(int) current = head # First pass to count frequencies while current: freq[current.val] += 1 current = current.next dummy = ListNode(0) current = dummy # Second pass to build new list with distinct elements while head: if freq[head.val] == 1: current.next = ListNode(head.val) current = current.next head = head.next return dummy.next"},{"question":"Write a function to find the longest substring of a given string `s` that contains at most `k` distinct characters. The function should return the length of this substring. What is the time complexity of your solution?","solution":"def longest_substring_with_k_distinct(s, k): Finds the length of the longest substring with at most k distinct characters. Parameters: s (str): the input string. k (int): the maximum number of distinct characters. Returns: int: length of the longest substring with at most k distinct characters. if k == 0 or not s: return 0 left = 0 right = 0 max_len = 0 char_map = {} while right < len(s): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len # Solution Time Complexity # The time complexity of this solution is O(n), where n is the length of the string `s`. # This is because each character is processed at most twice (once added to the window and once removed)."},{"question":"You are given a **0-indexed** integer array `height` representing the heights of buildings along a street from left to right. The goal is to find the maximum width of a rectangular subarray where each building has a height greater than or equal to a given threshold `h`. *Return the maximum width of such a subarray*. If no such subarray exists, return `0`. * For example, if `height = [1, 3, 2, 4, 3]` and `h = 3`, the maximum width of a subarray where all buildings have height greater than or equal to `3` is `2` (the subarray is `[3, 2, 4, 3]`).","solution":"def max_width_below_threshold(height, h): Returns the maximum width of a rectangular subarray in which each building has a height greater than or equal to h. max_width = 0 current_width = 0 for ht in height: if ht >= h: current_width += 1 max_width = max(max_width, current_width) else: current_width = 0 return max_width"},{"question":"You are developing an application that involves managing a dynamic list of strings. You need to implement a data structure that supports the following operations: - **insert(s)**: Insert the string `s` into the list. - **delete(s)**: Delete one occurrence of the string `s` from the list. If the string `s` is not in the list, do nothing. - **search(s)**: Return `true` if the string `s` is present in the list, otherwise return `false`. - **getRandom()**: Return a random string from the list. Each string in the list should have an equal probability of being returned. If the list is empty, return `null`. You should implement all these operations efficiently, particularly, `insert`, `delete`, and `search` should be in average O(1) time complexity. Design the data structure and implement its methods. Ensure that your implementation supports dynamically changing the list size by inserting and deleting strings.","solution":"import random class RandomizedStringCollection: def __init__(self): self.string_list = [] self.string_map = {} def insert(self, s): Insert the string `s` into the list. if s in self.string_map: return self.string_list.append(s) self.string_map[s] = len(self.string_list) - 1 def delete(self, s): Delete one occurrence of the string `s` from the list. If the string `s` is not in the list, do nothing. if s not in self.string_map: return index = self.string_map[s] last_string = self.string_list[-1] self.string_list[index] = last_string self.string_map[last_string] = index self.string_list.pop() del self.string_map[s] def search(self, s): Return `true` if the string `s` is present in the list, otherwise return `false`. return s in self.string_map def getRandom(self): Return a random string from the list. Each string in the list should have an equal probability of being returned. If the list is empty, return `null`. if not self.string_list: return None return random.choice(self.string_list)"},{"question":"You are given an array of integers `arr` and an integer `difference`. A **subsequence** is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. A subsequence `arr[i1], arr[i2], ..., arr[ik]` is called a **harmonious subsequence** if for every 1 ≤ j < k, arr[ij+1] - arr[ij] == `difference`. Return the length of the longest harmonious subsequence. If there are no such subsequences, return 0.","solution":"def longest_harmonious_subsequence(arr, difference): Returns the length of the longest harmonious subsequence with the given difference. :param arr: List[int] - Array of integers :param difference: int - The difference between consecutive elements in the subsequence :return: int - Length of the longest harmonious subsequence if not arr: return 0 dp = {} max_length = 0 for num in arr: prev_length = dp.get(num - difference, 0) dp[num] = prev_length + 1 max_length = max(max_length, dp[num]) return max_length"},{"question":"You are given an `n`-ary tree, a tree in which a node can have at most `n` children. Implement a function to serialize the tree into a single string representation and a function to deserialize this string back into the original `n`-ary tree. The serialization and deserialization should maintain the structure and values of the tree accurately. You may assume that all node values are unique integers and the tree does not contain any cycles. The tree class has already been defined as follows: ```python class Node: def __init__(self, val=None, children=[]): self.val = val self.children = children ``` Write functions `serialize(root: \'Node\') -> str` and `deserialize(data: str) -> \'Node\'` to perform the required operations.","solution":"class Node: def __init__(self, val=None, children=[]): self.val = val self.children = children def serialize(root: \'Node\') -> str: Serializes an n-ary tree to a single string. if not root: return \'\' res = [] def dfs(node): if node: res.append(str(node.val)) res.append(str(len(node.children))) for child in node.children: dfs(child) dfs(root) return \' \'.join(res) def deserialize(data: str) -> \'Node\': Deserializes a single string to an n-ary tree. if not data: return None tokens = iter(data.split()) def dfs(): val = int(next(tokens)) size = int(next(tokens)) node = Node(val, []) for _ in range(size): node.children.append(dfs()) return node return dfs()"},{"question":"You are given a list of words `dictionary` and a string `sentence`. The `sentence` consists of lowercase letters and spaces only. Each word in the `dictionary` is also made of lowercase letters. Your task is to replace every word in the `sentence` with the root form of that word if it exists in the `dictionary`. A root has to be the shortest prefix of a word in the `dictionary`, such that the root form can uniquely identify the word. Return the modified sentence after all replacements have been made. If a word in the sentence cannot be matched with any prefix in the `dictionary`, it should remain unchanged.","solution":"def replaceWords(dictionary, sentence): Replace words in a sentence with the shortest prefix found in the dictionary. Args: - dictionary (list of str): List containing prefix words. - sentence (str): Target sentence to process. Returns: - str: Modified sentence after processing replacements. def replace(word): for root in sorted(dictionary, key=len): if word.startswith(root): return root return word words = sentence.split() replaced_words = [replace(word) for word in words] return \' \'.join(replaced_words)"},{"question":"You are given a string `s` that contains only lowercase alphabetical characters. You need to find the longest substring that occurs at least twice within `s`. Return the length of this longest repeating substring. If no such substring exists, return `0`.","solution":"def longest_repeating_substring(s): Returns the length of the longest substring that occurs at least twice in the string `s`. def has_repeating_substring_of_length(length): seen = set() for i in range(len(s) - length + 1): substring = s[i:i + length] if substring in seen: return True seen.add(substring) return False left, right = 1, len(s) result = 0 while left <= right: mid = (left + right) // 2 if has_repeating_substring_of_length(mid): result = mid left = mid + 1 else: right = mid - 1 return result"},{"question":"Given two sorted singly linked lists `l1` and `l2`, merge them into one sorted linked list and return it. The merged linked list should be made by splicing together the nodes of the original two linked lists. You need to ensure the resulting linked list is still sorted in ascending order. Define a function `mergeTwoLists(self, l1, l2)` which takes in the heads of the two linked lists and returns the head of the merged linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1, l2): Merge two sorted linked lists and return it as a sorted linked list. The merged linked list should be made by splicing together the nodes of the original two linked lists. prehead = ListNode(-1) prev = prehead while l1 and l2: if l1.val <= l2.val: prev.next = l1 l1 = l1.next else: prev.next = l2 l2 = l2.next prev = prev.next prev.next = l1 if l1 is not None else l2 return prehead.next"},{"question":"Given a `WordDictionary` class, which facilitates adding new words and searching for a word in the dictionary that can include the dot character `\'.\'` to represent any one letter. Implement the `WordDictionary` class: * `WordDictionary()` Initializes the object. * `void addWord(String word)` Adds a word to the data structure. * `bool search(String word)` Returns true if there is any string in the data structure that matches word or false otherwise. A word could contain the dot character `\'.\'` to represent any one letter. You must implement the following functionalities: - `WordDictionary` class initialization - Addition of words - Search for words with or without dots.","solution":"class WordDictionary: def __init__(self): Initializes the object. self.words = [] def addWord(self, word): Adds a word to the data structure. self.words.append(word) def search(self, word): Returns true if there is any string in the data structure that matches word or false otherwise. A word could contain the dot character \'.\' to represent any one letter. import re pattern = re.compile(\\"^\\" + word.replace(\\".\\", \\"[a-z]\\") + \\"\\") for w in self.words: if pattern.match(w): return True return False"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` and an integer `target`. Each element in `nums` is either `0` or `1`. You are allowed to flip the value of at most one element in `nums` (i.e., change a `0` to `1` or a `1` to `0`). Return _the maximum length of a contiguous subarray that contains `target` ones after a single flip_.","solution":"def max_length_with_flip(nums, target): Returns the maximum length of a contiguous subarray that contains `target` ones after a single flip. n = len(nums) max_len = 0 left = 0 zeros_flipped = 0 for right in range(n): if nums[right] == 0: zeros_flipped += 1 while zeros_flipped > 1: if nums[left] == 0: zeros_flipped -= 1 left += 1 max_len = max(max_len, right - left + 1) return min(max_len, target)"},{"question":"Given an array of integers `arr`, you are allowed to remove one integer from the array such that the remaining array is in non-decreasing order. Return `true` if it is possible to make the array non-decreasing by removing exactly one integer, otherwise return `false`.","solution":"def can_be_non_decreasing_by_removing_one(arr): Given an array of integers `arr`, determines if it is possible to make the array non-decreasing by removing exactly one integer. def is_non_decreasing(a): return all(x <= y for x, y in zip(a, a[1:])) n = len(arr) for i in range(n): if is_non_decreasing(arr[:i] + arr[i+1:]): return True return False"},{"question":"Write a function that receives a string and returns the length of the longest substring without repeating characters. Implement the function as `int longestUniqueSubstr(String s)`. The function should efficiently handle cases where the string is very long or contains a mix of different types of characters, ensuring the solution runs in linear time.","solution":"def longestUniqueSubstr(s): Returns the length of the longest substring without repeating characters. Parameters: s (str): The input string. Returns: int: The length of the longest substring without repeating characters. n = len(s) char_index = {} max_length = 0 start = 0 for i in range(n): if s[i] in char_index and char_index[s[i]] >= start: start = char_index[s[i]] + 1 char_index[s[i]] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"Given a **0-indexed** integer array `chips` of length `n` where `chips[i]` denotes the number of potato chips at the `ith` table in a banquet hall. You are allowed to move chips from one table to another. The cost of moving a chip from table `i` to table `j` is `|i - j|` (the absolute distance between the tables). You want to make all tables have the same number of chips in the most cost-efficient way. Return _the minimum cost needed to equalize the number of chips across all tables._","solution":"def min_cost_equalize_chips(chips): Returns the minimum cost needed to equalize the number of chips across all tables. Args: chips: A list of integers where chips[i] denotes the number of potato chips at the ith table. Returns: int: The minimum cost needed to equalize the number of chips. n = len(chips) median = sorted(chips)[n // 2] cost = sum(abs(c - median) for c in chips) return cost"},{"question":"You are given a list of integers `nums` and an integer `k`. Return `true` if there exists a pair of distinct indices `(i, j)` in the list such that `nums[i]` + `nums[j]` is equal to `k`. Return `false` if no such pair exists. Additionally, ensure the solution has an average time complexity of (O(n)), where (n) is the length of the `nums` list.","solution":"def has_pair_with_sum(nums, k): Returns True if there exists a pair of distinct indices (i, j) in the list such that nums[i] + nums[j] is equal to k. Otherwise, returns False. seen = set() for num in nums: if k - num in seen: return True seen.add(num) return False"},{"question":"You are given an array `arr` consisting of `n` integers, where each element represents the height of a bar in a histogram. You are allowed to remove bars to create one or more continuous segments of continuous bars with increasing or decreasing heights. The height of each bar in a segment does not need to strictly increase or decrease but should be non-decreasing or non-increasing, respectively. Each time you remove bars, it counts as an operation. Return the minimum number of operations required to achieve this.","solution":"def min_operations(arr): Returns the minimum number of operations required to make the array non-decreasing or non-increasing segments. n = len(arr) # Edge cases if n <= 1: return 0 # Calculate the minimum number of operations to make the array non-decreasing def min_ops_non_decreasing(arr): ops = 0 for i in range(1, len(arr)): if arr[i] < arr[i - 1]: ops += 1 arr[i] = arr[i - 1] return ops # Calculate the minimum number of operations to make the array non-increasing def min_ops_non_increasing(arr): ops = 0 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: ops += 1 arr[i] = arr[i - 1] return ops # Take the minimum of non-decreasing and non-increasing operations non_decreasing_ops = min_ops_non_decreasing(arr[:]) non_increasing_ops = min_ops_non_increasing(arr[:]) return min(non_decreasing_ops, non_increasing_ops)"},{"question":"You are given a string `s` representing a mathematical expression containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', and you need to determine if the input string is valid. An input string is valid if: * Open brackets must be closed by the same type of brackets. * Open brackets must be closed in the correct order. A string containing just one type of bracket is considered valid if the brackets are balanced (for example, \\"()\\" is valid but \\"(\\" is not). Return `true` if the string is valid, and `false` otherwise.","solution":"def is_valid(s): Determines if the input string containing brackets is valid. stack = [] bracket_map = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"You are given an integer array `nums` and a target integer `target`. Your task is to find the **number of pairs** of indices `(i, j)` where `i < j` and `nums[i] + nums[j] == target`. The function should return the **count** of such pairs.","solution":"def count_pairs(nums, target): Returns the count of pairs (i, j) such that nums[i] + nums[j] == target and i < j. count = 0 n = len(nums) for i in range(n): for j in range(i + 1, n): if nums[i] + nums[j] == target: count += 1 return count"},{"question":"You are given a binary tree root. An operation on the tree involves inverting the order of nodes at every depth level of the tree. For example, if the tree consists of levels: 0: [1] 1: [2, 3] 2: [4, 5, 6, 7] after inverting it will be: 0: [1] 1: [3, 2] 2: [7, 6, 5, 4] Return the tree after applying the described operation. The tree nodes have integer values and the structure of the tree is given as input.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_levels(root): Inverts the order of nodes at every depth level of the binary tree. if not root: return None current_level = [root] while current_level: # Reverse values at the current level values = [node.val for node in current_level] for i, node in enumerate(current_level): node.val = values[~i] # Prepare for the next level next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level return root"},{"question":"Given an array `heights` representing the heights of blocks in a histogram where the width of each block is 1, return the area of the largest rectangle that can be formed using consecutive blocks in the histogram.","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle that can be formed using consecutive blocks in the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a matrix `grid` of `m` by `n` size consisting of non-negative integers, where `grid[i][j]` represents the height of a building located at cell `(i, j)`. You need to find the maximum height `h` (an integer) such that all buildings in the matrix can be maintained or increased to height `h` by only performing a series of increments on rows or columns. The increment operation on a row or column means that you can increase the height of every building in that row or column by 1. Return the maximum possible value of `h` that can be achieved without violating the initial height constraints of the buildings.","solution":"def max_height(grid): Returns the maximum height h such that all buildings in the matrix can be maintained or increased to height h by only performing increments on rows or columns. m, n = len(grid), len(grid[0]) row_max_values = [max(row) for row in grid] col_max_values = [max(grid[i][j] for i in range(m)) for j in range(n)] max_h = float(\'inf\') for i in range(m): for j in range(n): max_h = min(max_h, row_max_values[i], col_max_values[j]) return max_h"},{"question":"You are given two strings, `s` and `t`, consisting of only lowercase English letters. Your task is to determine if you can construct `t` by rearranging the letters of `s` and optionally appending any number (including zero) of additional letters to `s`. In other words, you need to check if `t` can be a substring of some permutation of `s`. Return `true` if it is possible, otherwise, return `false`.","solution":"def can_construct(s, t): Returns True if t can be constructed by rearranging the letters of s and optionally appending any number of additional letters to s. from collections import Counter counter_s = Counter(s) counter_t = Counter(t) for char in counter_t: if counter_t[char] > counter_s.get(char, 0): return False return True"},{"question":"You are given a string `s` containing only lowercase English letters and an integer `k`. You need to find the `k` most frequent characters in the string. If there are multiple characters with the same frequency, return them in lexicographical order. Return the resulting characters as a list.","solution":"from collections import Counter def top_k_frequent_characters(s, k): Finds the k most frequent characters in the string `s`. If there are multiple characters with the same frequency, returns them in lexicographical order. Args: s (str): The input string containing only lowercase English letters. k (int): The number of most frequent characters to return. Returns: List[str]: A list of the k most frequent characters. # Count the frequency of each character in the string frequency = Counter(s) # Get a list of characters sorted by frequency (descending) and then lexicographically sorted_characters = sorted(frequency, key=lambda x: (-frequency[x], x)) # Return the top k characters return sorted_characters[:k]"},{"question":"You are given a string `s` and an array of strings `words`. Your task is to implement a data structure `SubstringFinder` that can efficiently find out if any permutation of the strings in `words` can form a substring of `s`. Implement the `SubstringFinder` class: * `SubstringFinder(String s, String[] words)` initializes the object with the string `s` and the string array `words`. * `boolean containsPermutation(String target)` checks if any permutation of `target` is a substring of `s`. The function returns `true` if such a permutation exists, otherwise `false`. Maintain the requirement that `words` only contains unique strings, and `target` will always be a single string.","solution":"from collections import Counter class SubstringFinder: def __init__(self, s, words): Initializes the object with the string s and the string array words. self.s = s self.words = words self.words_counter = Counter(\'\'.join(words)) def containsPermutation(self, target): Checks if any permutation of target is a substring of s. target_counter = Counter(target) len_t, len_s = len(target), len(self.s) for i in range(len_s - len_t + 1): if target_counter == Counter(self.s[i:i + len_t]): return True return False"},{"question":"Given a list of integers `arr`, an \\"\\"mountain\\"\\" subarray is defined as a contiguous subarray that satisfies the following conditions: - The length of the subarray is at least `3`. - There exists some index `i` (with `0 < i < k-1` ) such that: - `arr[0] < arr[1] < ... < arr[i]` - `arr[i] > arr[i + 1] > ... > arr[k - 1]` Return the length of the longest mountain subarray in `arr`. If there is no mountain subarray, return `0`.","solution":"def longest_mountain(arr): Returns the length of the longest mountain subarray in the given list of integers. n = len(arr) if n < 3: return 0 # If array length is less than 3, no mountain can exist longest_mountain_length = 0 for i in range(1, n - 1): # Check if arr[i] is a peak if arr[i - 1] < arr[i] > arr[i + 1]: left = i - 1 right = i + 1 # Expand to the left of the peak while left > 0 and arr[left - 1] < arr[left]: left -= 1 # Expand to the right of the peak while right < n - 1 and arr[right] > arr[right + 1]: right += 1 # Calculate the length of mountain current_mountain_length = right - left + 1 longest_mountain_length = max(longest_mountain_length, current_mountain_length) return longest_mountain_length"},{"question":"You are given a string `s` and an array `t` consisting of equal-length strings. An element `t[i]` is a key if it matches a substring in `s` and does not overlap with another key. Return _the **maximum number**_ of keys that can be matched in `s`.","solution":"def max_non_overlapping_keys(s, t): max_keys = 0 substr_lens = len(t[0]) seen_indices = set() for key in t: start = 0 while start <= len(s) - substr_lens: idx = s.find(key, start) if idx == -1: break if all(i not in seen_indices for i in range(idx, idx + substr_lens)): max_keys += 1 seen_indices.update(range(idx, idx + substr_lens)) start = idx + substr_lens else: start = idx + 1 return max_keys"},{"question":"Given a **0-indexed** array of integers `nums` and an integer `value`, find the **index** of the **first occurrence** of `value` in the array `nums`. If the value is not found, return `-1`. Assume the array can be of any length. * For example, if `nums = [1, 3, 7, 8, 7]` and `value = 7`, then the output should be `2` since `7` first appears at index `2`. If `nums = [1, 3, 7, 8, 7]` and `value = 10`, the output should be `-1` as `10` is not present in the array. Return _the index of the first occurrence of `value`_.","solution":"def find_first_occurrence(nums, value): Finds the index of the first occurrence of value in nums. Returns -1 if value is not found. try: return nums.index(value) except ValueError: return -1"},{"question":"You are given two strings, `s1` and `s2`, consisting of lowercase English letters. You need to determine if `s2` is a scrambled string of `s1`. To scramble a string `s` you can use the following steps: 1. Divide a string `s` into two non-empty substrings at a random index and swap these substrings. For example, if `s = \\"abcd\\"`, we can divide it at index 1, making it `(\\"a\\", \\"bcd\\")`, and swap to get `(\\"bcd\\", \\"a\\")`, resulting in `bcda`. 2. Once divided, you can recursively scramble each of the two substrings. Given this definition of scrambling, return _True if `s2` is a scrambled string of `s1`, otherwise return False_.","solution":"def is_scramble(s1, s2): Determines if s2 is a scrambled string of s1. if len(s1) != len(s2): return False if s1 == s2: return True if sorted(s1) != sorted(s2): return False n = len(s1) for i in range(1, n): if (is_scramble(s1[:i], s2[:i]) and is_scramble(s1[i:], s2[i:])) or (is_scramble(s1[:i], s2[-i:]) and is_scramble(s1[i:], s2[:-i])): return True return False"},{"question":"A palindrome is a string that reads the same forward and backward. Given a string `s`, return _the longest palindromic prefix_ of `s`. If there are multiple palindromic prefixes of the same maximum length, return the one that appears first. If no palindromic prefix exists, return an empty string.","solution":"def longest_palindromic_prefix(s): Returns the longest palindromic prefix of s. If multiple palindromic prefixes exist, returns the one that appears first. If no palindromic prefix exists, returns an empty string. def is_palindrome(sub_str): return sub_str == sub_str[::-1] for i in range(len(s), 0, -1): if is_palindrome(s[:i]): return s[:i] return \\"\\""},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` elements, where `n` is an even number. You need to pair up the elements into `n/2` pairs. Every pair consists of two consecutive elements from the array. Create a new array `pairSums` where each element is the sum of one pair. After forming this new array, you need to find the maximum value among these sums. Return _the maximum sum from the_ `pairSums` _array_.","solution":"def max_pair_sum(nums): Returns the maximum pair sum from an array where each pair consists of two consecutive elements from the array. pair_sums = [nums[i] + nums[i + 1] for i in range(0, len(nums), 2)] return max(pair_sums)"},{"question":"You are given a 2D integer array `events` where `events[i] = [start_i, end_i]` represents the start and end times of the `i-th` event. Each event requires a unique room with no overlap in schedule. Return the minimum number of rooms required to accommodate all events.","solution":"def minMeetingRooms(events): Returns the minimum number of rooms required to accommodate all events. :param events: List of [start, end] time intervals :type events: List[List[int]] :return: Minimum number of rooms required :rtype: int if not events: return 0 events.sort(key=lambda x: x[0]) end_times = [] for event in events: # Remove rooms that have been freed up end_times = [end for end in end_times if end > event[0]] end_times.append(event[1]) # Ensure the end times are sorted end_times.sort() return len(end_times)"},{"question":"You are given two strings `s1` and `s2` representing two version numbers. A version number is composed of one or more numbers separated by dots `.`. Each number is an integer representing a part of the version number. Compare the two version numbers `s1` and `s2`. If `s1` is greater than `s2`, return `1`. If `s1` is less than `s2`, return `-1`. Otherwise, return `0`. Note that the version strings may only contain digits and the dot `.` character. The given input strings will be non-empty and contain at least one number.","solution":"def compare_version(s1, s2): Compare two version numbers given as strings s1 and s2. Args: s1: A string representing the first version number. s2: A string representing the second version number. Returns: 1 if s1 is greater than s2, -1 if s1 is less than s2, and 0 if they are equal. parts1 = list(map(int, s1.split(\'.\'))) parts2 = list(map(int, s2.split(\'.\'))) # Compare each part length = max(len(parts1), len(parts2)) for i in range(length): part1 = parts1[i] if i < len(parts1) else 0 part2 = parts2[i] if i < len(parts2) else 0 if part1 > part2: return 1 elif part1 < part2: return -1 return 0"},{"question":"You are given an array of integers `arr` and an integer `d`. An element in the array is said to be \\"lonely\\" if it does not have another element within a distance of `d` units to its left or right. For example, if `d = 2`, element `arr[i]` is considered \\"lonely\\" if for any `j` such that `|i - j| <= d` and `i != j`, `arr[j]` does not exist or is different from `arr[i]`. Return the count of such \\"lonely\\" elements in the array.","solution":"def count_lonely_elements(arr, d): Returns the count of \\"lonely\\" elements in the array \'arr\' with respect to distance \'d\'. An element is lonely if there aren\'t elements of the same value within distance \'d\'. Parameters: arr (list): List of integers. d (int): Distance parameter. Returns: int: Count of lonely elements. n = len(arr) lonely_count = 0 for i in range(n): lonely = True for j in range(max(0, i - d), min(n, i + d + 1)): if i != j and arr[i] == arr[j]: lonely = False break if lonely: lonely_count += 1 return lonely_count"},{"question":"You are given a string `s` representing a series of tasks where each character represents a different task. Tasks are done in a strict order from left to right. You are also provided with a positive integer `k` representing the time after which the same task can be performed again. Each task takes 1 unit of time to complete. However, as no two identical tasks can be performed in less than `k` units of time, you may need to schedule some idle time between two identical tasks. Return the minimum time required to complete all tasks in the given order, including any necessary idle time.","solution":"def min_time_to_complete_tasks(s: str, k: int) -> int: Returns the minimum time required to complete all tasks in the given order, including any necessary idle time. :param s: string representing a series of tasks :param k: positive integer representing the cool down period for identical tasks :return: minimum time required to complete all tasks last_occurrence = {} time = 0 for task in s: if task in last_occurrence and time - last_occurrence[task] <= k: time = last_occurrence[task] + k + 1 else: time += 1 last_occurrence[task] = time return time"},{"question":"Given a string `s` and a character `c`, find the shortest distance from each character in the string to the character `c`. Return an array of integers where each element represents the shortest distance to the character `c` from that position in the string. For example, given the string `s = \\"helloworld\\"` and the character `c = \'l\'`, the return array should be `[2, 1, 0, 0, 1, 2, 2, 1, 0, 1]`. Note: You can assume that the character `c` will appear in the string `s` at least once.","solution":"def shortest_distance(s, c): Given a string s and a character c, find the shortest distance from each character in the string to the character c. :param s: str - input string :param c: str - character to find :return: list - list of shortest distances n = len(s) answer = [0] * n # Initialize distance with a large number prev_position = float(\'-inf\') # Left to right pass for i in range(n): if s[i] == c: prev_position = i answer[i] = i - prev_position # Right to left pass prev_position = float(\'inf\') for i in range(n-1, -1, -1): if s[i] == c: prev_position = i answer[i] = min(answer[i], prev_position - i) return answer"},{"question":"Given a **2D grid** of size `m x n` representing a **park**, where `0` represents an empty cell and `1` represents a tree, determine whether there is a path for a person to walk from the top-left corner of the grid `(0, 0)` to the bottom-right corner `(m-1, n-1)` without stepping on any trees. The person can only move either down or right at any point in time. Return `true` if such a path exists, otherwise return `false`.","solution":"def is_path_possible(grid): Determine if there is a path from (0, 0) to (m-1, n-1) without stepping on any trees. :param grid: List[List[int]] - the 2D grid representing the park :return: bool - True if path exists, False otherwise if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False m, n = len(grid), len(grid[0]) visited = [[False]*n for _ in range(m)] def dfs(x, y): if x == m - 1 and y == n - 1: return True if x < 0 or y < 0 or x >= m or y >= n or grid[x][y] == 1 or visited[x][y]: return False visited[x][y] = True return dfs(x+1, y) or dfs(x, y+1) return dfs(0, 0)"},{"question":"Given an array of integers, each integer appears either twice or three times except for one integer which appears exactly once. Write a function to find _the single integer that appears only once_. Your solution should have a linear runtime complexity `O(n)` and use only constant extra space `O(1)`.","solution":"def single_number(nums): Find the single integer that appears only once in the list where every other integer appears either twice or three times. Arguments: nums -- a list of integers Returns: The single integer that appears only once. ones, twos = 0, 0 for num in nums: twos |= ones & num ones ^= num common_bits = ~(ones & twos) ones &= common_bits twos &= common_bits return ones"},{"question":"**Question 4**: You are given two integer arrays, `nums1` and `nums2`, where `nums2` is a permutation of `nums1`. You need to find an index mapping `mapping` such that `mapping[i] = j` which means the `i-th` element in `nums1` appears in `nums2` at index `j`. Return the array `mapping`. For example, if `nums1 = [12, 28, 46, 32, 50]` and `nums2 = [50, 12, 32, 46, 28]`, the function should return `[1, 4, 3, 2, 0]`.","solution":"def index_mapping(nums1, nums2): Returns an index mapping array such that the ith element in nums1 appears in nums2 at index j. :param nums1: List[int] - First list of integers :param nums2: List[int] - Second list of integers which is a permutation of nums1 :return: List[int] - Index mapping array position_map = {num: idx for idx, num in enumerate(nums2)} mapping = [position_map[num] for num in nums1] return mapping"},{"question":"You are given an array of integers `heights` representing the heights of students in a lineup from left to right. Return the minimum number of students that must be removed so that the remaining students are standing in non-decreasing order of height.","solution":"def min_students_to_remove(heights): Returns the minimum number of students that must be removed so that the remaining students are standing in non-decreasing order of height. n = len(heights) # Let\'s use dynamic programming to find the length of the longest increasing subsequence (LIS) if n == 0: return 0 # DP array to store the length of the longest increasing subsequence ending at each element dp = [1] * n # Every element is an LIS of length 1 by itself # Calculate the length of the LIS for each element for i in range(1, n): for j in range(i): if heights[i] >= heights[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 # The length of the LIS is the maximum value in the dp array lis_length = max(dp) # The minimum number of students to remove return n - lis_length"},{"question":"You are given a list of `n` songs where each song is represented by a distinct integer in the range 1 to `n`. You need to create a playlist of `k` songs from the given list with the constraint that no song can be repeated within `d` songs from its last occurrence in the playlist. Return the number of possible ways to create such a playlist modulo `10^9 + 7`. For instance, consider if the addition of a song would create an invalid playlist due to recent repetition, reordering or reselecting is necessary to adhere to the constraints provided.","solution":"MOD = 10**9 + 7 def numMusicPlaylists(n, k, d): dp = [[0] * (n + 1) for _ in range(k + 1)] dp[0][0] = 1 for i in range(1, k + 1): for j in range(1, n + 1): dp[i][j] = dp[i - 1][j - 1] * (n - (j - 1)) % MOD if j > d: dp[i][j] = (dp[i][j] + dp[i - 1][j] * (j - d) % MOD) % MOD return dp[k][n]"},{"question":"You are given a `2D` grid of size `m x n` representing an island, where `1` represents land and `0` represents water. The **perimeter** of the island is the total length of the outer boundary of the island. The island does not have any lakes (water inside that isn\'t connected to the water around the island). Each cell is square-shaped and the lengths of the sides of each cell are all `1`. Return _the perimeter of the island_.","solution":"def island_perimeter(grid): Calculate the perimeter of the island in the given grid. :param grid: List[List[int]]: 2D grid representing the island, where 1 is land and 0 is water. :return: int: the perimeter of the island. m, n = len(grid), len(grid[0]) perimeter = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: # add 4 for the current land cell perimeter += 4 # subtract 2 for each adjacent land cell (below and to the right) if i > 0 and grid[i-1][j] == 1: perimeter -= 2 if j > 0 and grid[i][j-1] == 1: perimeter -= 2 return perimeter"},{"question":"You are given two sorted arrays `arr1` and `arr2` of length `m` and `n` respectively, and an integer `k`. Merge these two arrays into a single sorted array and return the `k-th` smallest element of the merged array. If `k` is greater than the total number of elements in the merged array, return `-1`. - For example, if `arr1 = [1, 3, 5]`, `arr2 = [2, 4, 6, 7]` and `k = 5`, the merged array would be `[1, 2, 3, 4, 5, 6, 7]` and the `5-th` smallest element is `5`. If `k = 10`, the function should return `-1` as there are not enough elements.","solution":"def find_kth_element(arr1, arr2, k): Returns the k-th smallest element in the merged sorted array of arr1 and arr2. If k is greater than the total number of elements, return -1. # Merging the two sorted arrays merged_array = [] i = 0 j = 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Append remaining elements (if any) while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 # Check if k is within the bounds of the array if k > len(merged_array) or k <= 0: return -1 # The k-th element means index k-1 (0-based indexing) return merged_array[k-1]"},{"question":"You are given a list of strings `words` and a string `order` representing the alphabetical order of an alien language. The `order` string is a permutation of the 26 lowercase English letters. Write a function to determine if the given list of `words` is sorted lexicographically according to the provided `order`. If they are sorted, return `true`; otherwise, return `false`. Note that the list of words can have a variable length and each word can also have a variable length.","solution":"def is_alien_sorted(words, order): Determines if the given list of words is sorted lexicographically according to the provided alien order. :param words: List of strings representing the words. :param order: String representing the alphabetical order in an alien language. :return: True if the list of words is sorted according to the alien order, False otherwise. order_index = {char: index for index, char in enumerate(order)} def compare_words(word1, word2): for c1, c2 in zip(word1, word2): if order_index[c1] < order_index[c2]: return True elif order_index[c1] > order_index[c2]: return False return len(word1) <= len(word2) for i in range(len(words) - 1): if not compare_words(words[i], words[i + 1]): return False return True"},{"question":"You are given a binary tree where each node contains a value. Design an algorithm to return the **inorder traversal** of the binary tree values in an array. The binary tree is defined as follows: - Each node has a value `val`, a left child `left`, and a right child `right`. - The left and right child nodes can either be `null` or another node with a value. # Example: ``` Input: root = [1,null,2,3] Output: [1, 3, 2] ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Perform an inorder traversal of the binary tree and return the values as a list. result = [] def traverse(node): if node: traverse(node.left) result.append(node.val) traverse(node.right) traverse(root) return result"},{"question":"You are given an integer array `arr` and an integer `k`. You can reverse one subarray of `arr` starting at index `i` and ending at index `j` such that the sum of all elements in the subarray after reversing is equal to `k`. The subarray must have at least two elements. Return `true` if such a subarray exists, and `false` otherwise.","solution":"def can_reverse_subarray_to_sum_k(arr, k): Returns true if there is a subarray in arr which, when reversed, has a sum equal to k. n = len(arr) for i in range(n - 1): subarray_sum = 0 for j in range(i, n): subarray_sum += arr[j] if subarray_sum == k and (j - i + 1) >= 2: return True return False"},{"question":"You are given an array of integers `heights` representing the heights of a group of people. Write a function to determine the minimum number of moves required to make all the elements of the array equal. In one move, you can increment or decrement any element of the array by 1. The final array should have the same value across all elements while minimizing the total number of moves. Return the minimum number of moves needed.","solution":"def min_moves_to_equal_elements(heights): Function to determine the minimum number of moves required to make all elements of the array equal by incrementing or decrementing any element by 1. if not heights: return 0 median = sorted(heights)[len(heights)//2] return sum(abs(h - median) for h in heights)"},{"question":"You are given a list of `n` projects represented by a 2D integer array `projects` where `projects[i] = [projectId_i, deadline_i]` denotes that project `i` has a unique project identifier `projectId_i` and an integer `deadline_i` indicating its deadline in days. You are also given an integer `d`, the total number of days available. In one day, you can work on at most one project and complete it. Each project takes exactly one day to complete. Return _the maximum number of distinct projects you can complete without exceeding the total number of available days `d`_. If you cannot complete any project, return 0.","solution":"def max_projects(projects, d): Returns the maximum number of distinct projects that can be completed within given days. Parameters: projects (List[List[int]]): List of projects where each project is represented as [projectId, deadline] d (int): Total number of available days Returns: int: Maximum number of distinct projects that can be completed # Sort the projects by their deadline projects.sort(key=lambda x: x[1]) count = 0 days_used = 0 # Iterate through the sorted projects for project in projects: if days_used < d: count += 1 days_used += 1 else: break return count"},{"question":"You are given two strings, `s1` and `s2`, which represent two non-negative integers. Write a function to find their sum and return it as a string. The input strings may contain leading zeros, and the result should not contain leading zeros unless the result is zero. For example, if you are given `s1 = \\"123\\"` and `s2 = \\"456\\"`, the result should be `\\"579\\"`. Similarly, if you are given `s1 = \\"0012\\"` and `s2 = \\"003\\"`, the result should be `\\"15\\"`. Implement the function `string_addition(s1: str, s2: str) -> str` to perform the addition of the two string numbers and return the result as a string.","solution":"def string_addition(s1: str, s2: str) -> str: Returns the sum of two non-negative integers represented as strings, without leading zeros. # convert the strings to integers, add them, and then convert the result back to a string result = str(int(s1) + int(s2)) return result"},{"question":"You are given an `n x n` grid containing only integers `0`, `1`, and `2`, where: - `0` represents water, - `1` represents land, and - `2` represents a building. The distance between two cells `(r1, c1)` and `(r2, c2)` is defined as `|r1 - r2| + |c1 - c2|`, where `|x|` denotes the absolute value of `x`. The goal is to find the shortest distance from any building to the nearest land. If there is no such land, return `-1`. Given the grid, return the length of the shortest path from any building to the nearest land.","solution":"from collections import deque def shortest_distance_to_land(grid): Returns the shortest distance from any building to the nearest land. If there is no land, returns -1. n = len(grid) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def bfs(start): queue = deque([start]) visited = [[False] * n for _ in range(n)] visited[start[0]][start[1]] = True distance = 0 while queue: level_size = len(queue) distance += 1 for _ in range(level_size): r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < n and not visited[nr][nc]: if grid[nr][nc] == 1: return distance if grid[nr][nc] == 0: queue.append((nr, nc)) visited[nr][nc] = True return -1 shortest = float(\'inf\') for r in range(n): for c in range(n): if grid[r][c] == 2: dist = bfs((r, c)) if dist != -1: shortest = min(shortest, dist) return shortest if shortest != float(\'inf\') else -1"},{"question":"You are given a list of `n` integers, `nums`, that is initially unsorted. Write a function that partitions the list into **two subsets** such that the differences between the sums of the subsets are minimized. The function should return the minimum possible difference. Implement the `minSubsetSumDifference()` function that takes in the integer list `nums` as its parameter.","solution":"def minSubsetSumDifference(nums): Given a list of integers, partition the list into two subsets such that the difference between the sums of the subsets is minimized, and return the minimum possible difference. total_sum = sum(nums) n = len(nums) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] for i in range(target, -1, -1): if dp[i]: subset_sum1 = i break subset_sum2 = total_sum - subset_sum1 return abs(subset_sum2 - subset_sum1)"},{"question":"Given a list of non-negative integers `nums` representing the amount of money of each house on a street, return _the maximum amount of money you can rob tonight **without alerting the police**_, such that you cannot rob two directly adjacent houses. Each house has an alarm system that will automatically contact the police if two adjacent houses were broken into on the same night. For example, if `nums = [2, 7, 9, 3, 1]`, you can rob up to `12` by robbing houses at positions `0`, `2`, and `4` (2 + 9 + 1 = 12).","solution":"def rob(nums): Returns the maximum amount of money you can rob without alerting the police. You cannot rob two directly adjacent houses. if not nums: return 0 if len(nums) == 1: return nums[0] previous = 0 current = 0 for amount in nums: new_current = max(current, previous + amount) previous = current current = new_current return current"},{"question":"Given an array of integers `nums` and an integer `m`, partition the array into `m` non-empty continuous subarrays such that the maximum sum of the subarrays is minimized. Return _the minimized maximum sum of the partitioned subarrays_.","solution":"def splitArray(nums, m): def can_split(nums, m, max_sum): current_sum = 0 count = 1 for num in nums: if current_sum + num > max_sum: current_sum = num count += 1 if count > m: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, m, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a matrix `matrix` of `m` x `n` size consisting of non-negative integers, where `matrix[i][j]` represents the height of the terrain at position `(i, j)`. Imagine you have an unlimited supply of water and you can pour it onto any cell of the matrix. Water will flow to neighboring cells with lower or equal height. The goal is to determine the number of cells that can reach both the Pacific and Atlantic oceans. The Pacific Ocean touches the left and top edges of the matrix, whereas the Atlantic Ocean touches the right and bottom edges. Return an array of coordinates representing the cells that can flow water to both oceans.","solution":"def pacific_atlantic(matrix): if not matrix: return [] def dfs(matrix, visited, i, j): visited[i][j] = True for di, dj in ((0, 1), (1, 0), (0, -1), (-1, 0)): ni, nj = i + di, j + dj if 0 <= ni < len(matrix) and 0 <= nj < len(matrix[0]) and not visited[ni][nj] and matrix[ni][nj] >= matrix[i][j]: dfs(matrix, visited, ni, nj) m, n = len(matrix), len(matrix[0]) p_visited = [[False] * n for _ in range(m)] a_visited = [[False] * n for _ in range(m)] for i in range(m): dfs(matrix, p_visited, i, 0) dfs(matrix, a_visited, i, n - 1) for j in range(n): dfs(matrix, p_visited, 0, j) dfs(matrix, a_visited, m - 1, j) result = [] for i in range(m): for j in range(n): if p_visited[i][j] and a_visited[i][j]: result.append([i, j]) return result"},{"question":"Write a function that takes two integers n and k and returns the k-th integer in lexicographical order among all integers from 1 to n. For example, given n = 13 and k = 2, the k-th integer in lexicographical order is 10 because the lexicographical sequence up to 13 is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]. Implement the `findKthNumber` function: * `int findKthNumber(int n, int k)` Returns the k-th integer in lexicographical order among all integers from 1 to n.","solution":"def findKthNumber(n, k): def count_steps(curr, n): steps = 0 first = curr last = curr + 1 while first <= n: steps += min(last, n + 1) - first first *= 10 last *= 10 return steps curr = 1 k -= 1 while k: steps = count_steps(curr, n) if steps <= k: k -= steps curr += 1 else: curr *= 10 k -= 1 return curr"},{"question":"You are given an integer array `arr` and an integer `k`. You need to ensure that the array follows the following conditions after performing certain operations: 1. The array must have all elements placed in non-increasing order. 2. You can increment any element of the array by 1, at most `k` times. Return _the maximum element of the array possible after fulfilling the conditions and performing at most `k` increments_.","solution":"def max_element_after_operations(arr, k): Returns the maximum possible element of the array after performing at most k increments and ordering it in non-increasing order. arr.sort(reverse=True) max_possible = arr[0] + k return max_possible"},{"question":"Given an integer array `nums` representing a list of integers, each of which appears exactly twice except for one integer which appears exactly once, write a function to find that single integer. The function should have a linear runtime complexity and use only constant extra space. Return the single integer.","solution":"def single_number(nums): Finds the single integer in the list that appears only once. All other integers appear exactly twice. Args: nums (list): A list of integers Returns: int: The single integer that appears only once result = 0 for num in nums: result ^= num return result"},{"question":"A **binary search tree (BST)** is a tree in which all the nodes follow the below-mentioned properties: - The value of the key of the left subtree is less than or equal to the value of its parent node\'s key. - The value of the key of the right subtree is greater than the value of its parent node\'s key. - The left and right subtree each must also be a binary search tree. Given the `root` of a binary search tree and a key, implement a function `searchBST` to search for the node in the BST that contains the key. If the node exists, return the node. Otherwise, return `null`. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def searchBST(root: TreeNode, val: int) -> TreeNode: # Your code here ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def searchBST(root: TreeNode, val: int) -> TreeNode: Search for a node with the given value in a binary search tree. Args: root (TreeNode): The root node of the BST. val (int): The value to search for. Returns: TreeNode: The node containing the value, or None if the value is not present. if not root: return None if root.val == val: return root elif val < root.val: return searchBST(root.left, val) else: return searchBST(root.right, val)"},{"question":"Given a **0-indexed** integer array `nums` that represents the amount of rainfall collected in each container, and an integer `k` representing the length of the window, you are to find the **k-length** subarray that contains the maximum total rainfall. Return the maximum total rainfall possible for such a subarray. If the length of `nums` is less than `k`, return `0`.","solution":"def max_rainfall(nums, k): Finds the k-length subarray that contains the maximum total rainfall. Returns the maximum total rainfall possible for such a subarray. If the length of nums is less than k, returns 0. if len(nums) < k: return 0 max_sum = current_sum = sum(nums[:k]) for i in range(k, len(nums)): current_sum = current_sum - nums[i - k] + nums[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an array of integers `arr`, consider all contiguous subarrays of length 3. Find the maximum possible sum of the median elements from all these subarrays. Return that maximum sum. A median is the middle element in an ascending order sorted list. For example, the median of `[1, 3, 2]` (sorted to `[1, 2, 3]`) is `2`.","solution":"def max_median_sum(arr): Returns the maximum possible sum of the median elements from all contiguous subarrays of length 3. :param arr: List[int] :return: int n = len(arr) if n < 3: return 0 # There cannot be any subarrays of length 3 if the size of the array is less than 3 max_sum = float(\'-inf\') for i in range(n - 2): # Take the current 3 elements subarray = arr[i:i+3] # Sort the subarray to find the median subarray.sort() # The middle element is the median in a sorted array of length 3 median = subarray[1] # Update the maximum sum if the current median is greater current_sum = median if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You are given a string `s` consisting of lowercase English letters, and a list of words. Your task is to determine if all the words can be formed using consecutive characters in `s` without rearranging the characters. Each word must be formed from a distinct substring of `s`, but substrings used by different words in the list must not overlap. Return `true` if it is possible to form all the words using substrings of `s`, and `false` otherwise.","solution":"def can_form_words(s, words): Determines if all words can be formed using consecutive characters in `s` without rearranging the characters. Parameters: s (str): The string consisting of lowercase English letters. words (list): The list of words to be formed from `s`. Returns: bool: True if possible to form all the words using substrings of s, otherwise False. current_index = 0 for word in words: index = s.find(word, current_index) if index == -1: return False current_index = index + len(word) return True"},{"question":"You are given a string `s` and a string `t`. You need to transform string `s` into string `t` by removing some (possibly zero) characters from `s` without changing the order of the remaining characters. Determine the minimum number of deletions required from `s` to make it a subsequence of `t`. If it is not possible to transform `s` into `t`, return `-1`. The input strings contain only lowercase English letters. Return the minimum number of deletions or `-1` if `s` cannot be transformed into `t`.","solution":"def min_deletions_to_transform(s, t): m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_len = dp[m][n] if lcs_len != n: return -1 return m - n"},{"question":"You are given a binary tree represented as a sequence of node values in level-order traversal format, where `null` signifies a missing node. Your task is to determine whether this binary tree is height-balanced. A binary tree is height-balanced if, for every node in the tree, the depth of the left and right subtrees of that node differ by at most 1. Given `root`, the root of the binary tree, return `true` _if the tree is height-balanced, otherwise return_ `false`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Returns True if the tree is height-balanced, False otherwise. def check_height(node): if not node: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) if not left_balanced or not right_balanced: return 0, False if abs(left_height - right_height) > 1: return 0, False return max(left_height, right_height) + 1, True _, balanced = check_height(root) return balanced def build_tree_from_level_order(values): Helper function to build a tree from level-order traversal values. if not values: return None from collections import deque iter_values = iter(values) root = TreeNode(next(iter_values)) queue = deque([root]) while queue: node = queue.popleft() try: left_val = next(iter_values) if left_val is not None: node.left = TreeNode(left_val) queue.append(node.left) right_val = next(iter_values) if right_val is not None: node.right = TreeNode(right_val) queue.append(node.right) except StopIteration: break return root"},{"question":"Given a `matrix` of `m x n` size, where each cell contains an integer, return the minimum sum of a path from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. The matrix contains both positive and negative integers. To get out of the matrix, the value in the bottom-right needs to be positive. If it\'s impossible to have such a path, return -1.","solution":"def min_path_sum(matrix): Returns the minimum sum of a path from the top-left corner to the bottom-right corner, moving only down or right. If it\'s impossible to have a path that ends with a positive value in the bottom-right cell, return -1. if not matrix or not matrix[0] or matrix[-1][-1] <= 0: return -1 m, n = len(matrix), len(matrix[0]) dp = [[float(\'inf\')] * n for _ in range(m)] dp[0][0] = matrix[0][0] for i in range(m): for j in range(n): if i > 0: dp[i][j] = min(dp[i][j], dp[i-1][j] + matrix[i][j]) if j > 0: dp[i][j] = min(dp[i][j], dp[i][j-1] + matrix[i][j]) result = dp[-1][-1] return result if result > 0 else -1"},{"question":"You are given a `rows x cols` binary matrix `matrix` representing a grid where `0` represents an empty cell and `1` represents an obstacle. You can move up, down, left, or right from one empty cell `0` to another empty cell `0`. Find the number of distinct groups of connected empty cells in the grid. A group is defined as a maximal set of empty cells where each cell is directly or indirectly connected to every other cell in the group. Return _the number of distinct groups of connected empty cells in the grid_.","solution":"def count_groups(matrix): Returns the number of distinct groups of connected empty cells in the given binary matrix. rows = len(matrix) if rows == 0: return 0 cols = len(matrix[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or matrix[r][c] == 1 or visited[r][c]: return visited[r][c] = True direction_vectors = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dv in direction_vectors: dfs(r + dv[0], c + dv[1]) count = 0 for r in range(rows): for c in range(cols): if matrix[r][c] == 0 and not visited[r][c]: dfs(r, c) count += 1 return count"},{"question":"There is a list of non-negative integers representing the amount of water trapped after raining, where each element represents a unit height of the terrain at that position. Determine the total amount of water that can be trapped. For example, given `height = [0,1,0,2,1,0,1,3,2,1,2,1]`, the total water trapped would be `6`. Return the amount of water trapped.","solution":"def trap(height): Returns the total amount of water that can be trapped after raining. :param height: List[int] - A list of non-negative integers representing the height of the terrain. :return: int - The total amount of water trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - height[i] return total_water"},{"question":"[Question] 4: Given a **m x n** integer `matrix`, if an element is `0`, set its entire row and column to `0`. Do it in place.","solution":"def set_zeroes(matrix): If an element is 0, set its entire row and column to 0. Modifies the matrix in place. rows, cols = len(matrix), len(matrix[0]) row_zero = False # Determine which rows and columns need to be zeroed for i in range(rows): for j in range(cols): if matrix[i][j] == 0: matrix[0][j] = 0 if i > 0: matrix[i][0] = 0 else: row_zero = True # Zero out cells based on flags set in the first row and column for i in range(1, rows): for j in range(1, cols): if matrix[i][0] == 0 or matrix[0][j] == 0: matrix[i][j] = 0 # Zero out first row if needed if row_zero: for j in range(cols): matrix[0][j] = 0 # Zero out first column if needed if matrix[0][0] == 0: for i in range(rows): matrix[i][0] = 0"},{"question":"You are given a string `s` and an integer `k`. Your task is to find the length of the longest substring of `s` that contains at most `k` distinct characters. If there are multiple such substrings, return the length of any one of them. Implement the following function: ```python def lengthOfLongestSubstringKDistinct(s: str, k: int) -> int: ``` Your implementation should efficiently find the solution, leveraging appropriate data structures to handle variable substrings and character counts. Use appropriate algorithms to maintain a sliding window or similar approach to solve the problem.","solution":"def lengthOfLongestSubstringKDistinct(s: str, k: int) -> int: Returns the length of the longest substring of \'s\' that contains at most \'k\' distinct characters. if k == 0: return 0 n = len(s) if n * k == 0: return 0 left = 0 right = 0 hashmap = {} max_len = 1 while right < n: hashmap[s[right]] = right right += 1 if len(hashmap) > k: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"You are given a **2D array** `grid` of size `m x n`, where each cell is either a `0` (representing water) or a `1` (representing land). An **island** is a maximal 4-directionally (horizontal or vertical) connected group of `1`s. The **perimeter** of an island is the total number of edges that are not shared with another `1` (land). Compute and return the perimeter of the island in `grid`. It is guaranteed that there is exactly one island in the `grid`.","solution":"def islandPerimeter(grid): Computes and returns the perimeter of the island in the grid. :param grid: List[List[int]] - 2D array representing the grid. :return: int - The perimeter of the island. rows, cols = len(grid), len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Set perimeter to 4 for this land (1) perimeter += 4 # Check the top cell if r > 0 and grid[r-1][c] == 1: perimeter -= 2 # Check the left cell if c > 0 and grid[r][c-1] == 1: perimeter -= 2 return perimeter"},{"question":"Given an integer array `arr` of size `n`, your task is to find a subarray such that the sum of its elements is exactly equal to a given integer `target`. If such a subarray exists, return the starting and ending indices (0-indexed) of any one subarray that meets the criteria. If there are multiple solutions, return any of them. If no such subarray exists, return `[-1, -1]`. * For example, given `arr = [1, 2, 3, 7, 5]` and `target = 12`, the subarray `[2, 3, 7]` sums up to 12, so you should return `[1, 3]`.","solution":"def find_subarray_with_target_sum(arr, target): Finds a subarray with a sum equal to the target value. Parameters: arr (list): List of integers. target (int): Target sum. Returns: list: Starting and ending indices of the subarray. If no such subarray exists, returns [-1, -1]. current_sum = 0 start_index = 0 sum_map = {} for end_index, num in enumerate(arr): current_sum += num if current_sum == target: return [start_index, end_index] if (current_sum - target) in sum_map: return [sum_map[current_sum - target] + 1, end_index] sum_map[current_sum] = end_index return [-1, -1]"},{"question":"You are given a binary tree where each node has an integer value. Define the **vertical order traversal** of a binary tree as follows: 1. For each node at position `(x, y)`, its children are at positions `(x - 1, y - 1)` for the left child and `(x + 1, y - 1)` for the right child. 2. The vertical order traversal should return the nodes\' values in the order of their x-coordinate (from smallest to largest). 3. Nodes with the same x-coordinate should be sorted by their y-coordinate (largest to smallest). 4. If multiple nodes have the same x and y coordinates, they should be ordered by their values in ascending order. Return a list of lists of integers representing the vertical order traversal of the binary tree. **Note:** The input is a tree\'s root node, and each output list contains the values of nodes appearing in the same vertical line from top to bottom.","solution":"from collections import defaultdict, deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def verticalOrderTraversal(root): if not root: return [] columns = defaultdict(list) min_x = max_x = 0 queue = deque([(root, 0, 0)]) while queue: node, x, y = queue.popleft() if node: columns[x].append((y, node.val)) min_x = min(min_x, x) max_x = max(max_x, x) queue.append((node.left, x - 1, y - 1)) queue.append((node.right, x + 1, y - 1)) result = [] for x in range(min_x, max_x + 1): columns[x].sort(key=lambda k: (-k[0], k[1])) result.append([val for y, val in columns[x]]) return result"},{"question":"You are a developer tasked with creating an application that models the spread of information within a social network. The social network is represented as a directed graph where each node corresponds to a person and each edge indicates a directed friendship. You are given a list of relationships in the network and an integer `start` representing the start node. When a person (node) receives information, they will immediately share it with all their friends (outgoing edges) at the same time. Your objective is to determine the minimum number of steps needed for the information to reach all nodes in the graph starting from the `start` node. If there are nodes that cannot be reached from the `start` node, return `-1`. Given the list of `edges`, where `edges[i] = [u, v]` means there is a directed edge from person `u` to person `v`, and the integer `start`, return the minimum number of steps required for the information to reach all nodes, or `-1` if it is impossible.","solution":"from collections import deque, defaultdict def min_steps_to_spread_info(edges, start): Returns the minimum number of steps required for information to reach all nodes in the network. If information cannot reach all nodes, returns -1. graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = set() queue = deque([(start, 0)]) visited.add(start) max_steps = 0 while queue: node, steps = queue.popleft() max_steps = max(max_steps, steps) for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, steps + 1)) # Check if all nodes are visited all_nodes = set(node for edge in edges for node in edge) all_nodes.add(start) if visited >= all_nodes: return max_steps else: return -1"},{"question":"You are given an array of integers `arr` and an integer `x`. Your task is to find the length of the smallest contiguous subarray of `arr` whose sum is greater than or equal to `x`. If there is no such subarray, return `0`. Function Signature: ```python def minSubArrayLen(arr: List[int], x: int) -> int: pass ``` **Example:** ```python arr = [2,3,1,2,4,3] x = 7 minSubArrayLen(arr, x) # Returns 2 because the subarray [4,3] has the smallest length with a sum ≥ 7. ``` **Notes:** * You should aim for an efficient solution with a time complexity better than O(n^2).","solution":"from typing import List def minSubArrayLen(arr: List[int], x: int) -> int: n = len(arr) min_len = float(\'inf\') start = 0 current_sum = 0 for end in range(n): current_sum += arr[end] while current_sum >= x: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len != float(\'inf\') else 0"},{"question":"Implement a class `CircularQueue` which represents a **circular queue** of fixed capacity. The class should support the following operations: * `CircularQueue(int k)`: Initializes the object with the size of the queue to be `k`. * `boolean enQueue(int value)`: Inserts an element into the circular queue. Return `true` if the operation is successful, otherwise return `false`. * `boolean deQueue()`: Deletes an element from the circular queue. Return `true` if the operation is successful, otherwise return `false`. * `int Front()`: Gets the front item from the queue. If the queue is empty, return `-1`. * `int Rear()`: Gets the last item from the queue. If the queue is empty, return `-1`. * `boolean isEmpty()`: Checks whether the circular queue is empty or not. * `boolean isFull()`: Checks whether the circular queue is full or not. The operations of `enQueue` and `deQueue` must run in `O(1)` average time complexity.","solution":"class CircularQueue: def __init__(self, k: int): self.queue = [0] * k self.size = k self.front = 0 self.rear = -1 self.count = 0 def enQueue(self, value: int) -> bool: if self.isFull(): return False self.rear = (self.rear + 1) % self.size self.queue[self.rear] = value self.count += 1 return True def deQueue(self) -> bool: if self.isEmpty(): return False self.front = (self.front + 1) % self.size self.count -= 1 return True def Front(self) -> int: return -1 if self.isEmpty() else self.queue[self.front] def Rear(self) -> int: return -1 if self.isEmpty() else self.queue[self.rear] def isEmpty(self) -> bool: return self.count == 0 def isFull(self) -> bool: return self.count == self.size"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to determine if it is possible to rearrange the characters in `s` such that every two adjacent characters are different. If it is possible, return the rearranged string, otherwise, return an empty string. The string may have multiple valid rearrangements; return any of them.","solution":"from collections import Counter from heapq import heappop, heappush, heapify def rearrange_string(s, k): if k == 0: return s # If k is 0, no need to rearrange # Count frequency of each character counter = Counter(s) # Create a max heap (negative count for max heap) max_heap = [(-count, char) for char, count in counter.items()] heapify(max_heap) result = [] wait_queue = [] while max_heap: count, char = heappop(max_heap) result.append(char) wait_queue.append((count + 1, char)) # increment count to mark usage if len(wait_queue) < k: continue # Re-enable the use of character once k distance is passed ready_count, ready_char = wait_queue.pop(0) if ready_count < 0: heappush(max_heap, (ready_count, ready_char)) return \\"\\".join(result) if len(result) == len(s) else \\"\\""},{"question":"You are given an n x n 2D matrix `matrix` representing an image, where each element of the matrix represents a pixel value between 0 and 255. You need to perform the following operation to rotate the image 90 degrees clockwise: - Transpose the matrix. - Reverse each row of the transposed matrix. After performing the above operations, return the modified matrix.","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given n x n matrix 90 degrees clockwise. Args: matrix (list of list of int): The n x n matrix to rotate. Returns: list of list of int: The rotated matrix. # Transpose the matrix transposed_matrix = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] # Reverse each row of the transposed matrix rotated_matrix = [row[::-1] for row in transposed_matrix] return rotated_matrix"},{"question":"You are given a 2D grid `board` representing a matrix of cells where each cell is either `0` (empty) or `1` (occupied). You are also given two points, `start` and `end`, representing the starting and ending cells, respectively, on the grid. You need to find the shortest path from `start` to `end` such that you can move in the four cardinal directions (north, south, east, west) from one cell to another, but you can only move to an empty cell (`0`). You cannot move diagonally or move outside the grid. Return _the length of the shortest path from `start` to `end`._ If no such path exists, return `-1`.","solution":"from collections import deque def shortest_path(board, start, end): Returns the length of the shortest path from start to end on a 2D grid board. Moves are only through empty cells (\'0\'). # Directions for moving in the four cardinal directions (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] rows, cols = len(board), len(board[0]) sr, sc = start er, ec = end if board[sr][sc] != 0 or board[er][ec] != 0: return -1 queue = deque([(sr, sc, 0)]) # (row, col, distance) visited = set() visited.add((sr, sc)) while queue: r, c, dist = queue.popleft() if (r, c) == (er, ec): return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and board[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"Given a binary tree, return the sum of the values of its deepest leaves. The deepest leaves are defined as the nodes that are at the maximum depth from the root of the tree. For example, in the tree `[1,2,3,4,5,null,6,7,null,null,null,null,8]`, the deepest leaves are `[7,8]`, and their sum is `15`. The structure of the binary tree is given in the level-order format where `null` represents missing nodes. Write a function that computes this sum given the root of the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): Returns the sum of the values of the deepest leaves in a binary tree. if not root: return 0 from collections import deque max_depth = 0 level_sum = 0 queue = deque([(root, 0)]) while queue: node, depth = queue.popleft() if depth > max_depth: max_depth = depth level_sum = node.val elif depth == max_depth: level_sum += node.val if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return level_sum"},{"question":"You are given a grid with `m` rows and `n` columns, represented by a matrix `grid` where each cell contains either a `0` (empty) or a `1` (land). A **region** of land is a group of `1`s connected vertically or horizontally (but not diagonally). The grid is completely surrounded by water except for the land cells in the grid. You need to find the **maximum area** of a region of `land` in the grid. The area is defined as the number of cells that make up the region. Return the _maximum area_ of a region in the grid.","solution":"def max_area_of_island(grid): This function finds and returns the maximum area of an island (connected region of land) in the grid. :param grid: List[List[int]] :return: int if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) max_area = 0 def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == 0: return 0 grid[r][c] = 0 # mark the cell as visited area = 1 area += dfs(r + 1, c) area += dfs(r - 1, c) area += dfs(r, c + 1) area += dfs(r, c - 1) return area for r in range(rows): for c in range(cols): if grid[r][c] == 1: max_area = max(max_area, dfs(r, c)) return max_area"},{"question":"Given a **0-indexed** integer array `nums` of size `n`, return _the length of the shortest supersequence_. A supersequence is a sequence where all elements of `nums` appear as a subsequence. The elements must be in the same order as they appear in `nums` but may include additional elements.","solution":"def shortest_supersequence_len(nums): Returns the length of the shortest supersequence such that all elements of nums appear as a subsequence. The shortest supersequence is essentially just the original array itself, because if you add any extra element, it will increase the length. return len(nums)"},{"question":"Given an integer array `nums`, move all `0\'s` to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. Try to achieve this with a time complexity of O(n) and space complexity of O(1). For example, given the input array `[0, 1, 0, 3, 12]`, the function should modify the array to `[1, 3, 12, 0, 0]`. Write a function to achieve the above task.","solution":"def move_zeroes(nums): Move all zeroes to the end of the array while maintaining the relative order of non-zero elements. This is done in-place and aims for O(n) time complexity with O(1) space complexity. # Position to place the next non-zero element last_non_zero_found_at = 0 # Move all non-zero elements to the front of the array for i in range(len(nums)): if nums[i] != 0: nums[last_non_zero_found_at] = nums[i] last_non_zero_found_at += 1 # Fill the remaining elements in the array with zeroes for i in range(last_non_zero_found_at, len(nums)): nums[i] = 0"},{"question":"Write an algorithm to find the shortest path that visits all the nodes in an undirected graph given as an adjacency list. Each node in the graph is labeled from `0` to `n-1`. The output should be the length of the shortest path that visits each node at least once. If no such path exists, return -1. You can start the traversal from any node. The graph is guaranteed to be connected, meaning there\'s a path between any pair of nodes.","solution":"from collections import deque def shortest_path_length(graph): Returns the length of the shortest path that visits all nodes in the graph. If no such path exists, return -1. Uses BFS for finding the shortest path. :param graph: List[List[int]], adjacency list of the graph :return: int, length of the shortest path visiting all nodes n = len(graph) if n == 1: return 0 # Final state when all nodes are visited final_state = (1 << n) - 1 # BFS components q = deque([(i, 1 << i, 0) for i in range(n)]) # (node, visited_state, path_length) seen = {(i, 1 << i) for i in range(n)} while q: node, visited_state, path_length = q.popleft() # Check if all nodes are visited if visited_state == final_state: return path_length # Visit all neighbors of the current node for neighbor in graph[node]: new_visited_state = visited_state | (1 << neighbor) if (neighbor, new_visited_state) not in seen: seen.add((neighbor, new_visited_state)) q.append((neighbor, new_visited_state, path_length + 1)) # If no path covers all nodes (shouldn\'t happen given the problem constraints) return -1"},{"question":"You are given an array of integers representing the heights of a series of buildings along a straight line, where the `i-th` building has a height `heights[i]`. A person standing on the roof of one building can move to the next building if and only if the height of the next building is less than or equal to the height of the current building. Return the **length of the longest** sequence of buildings such that the person can move from the first building of the sequence to the last by always moving to an adjacent building of equal or lesser height. For example, given the array `heights = [4, 3, 2, 3, 4]`, the person can move from building `4` to `3` to `2`, or from `3` to `2`, or directly `4` to `3`. The length of the longest sequence where movement conditions are satisfied is `3`.","solution":"def longest_movable_sequence(heights): Returns the length of the longest sequence of buildings that can be traversed where each subsequent building is of equal or lesser height than the previous one. if not heights: return 0 max_length = 1 current_length = 1 for i in range(1, len(heights)): if heights[i] <= heights[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"Design an algorithm that removes all elements from a linked list of integers that have a value greater than or equal to a given threshold. Implement the `LinkedListFilter` class: * `LinkedListFilter(ListNode head)`: Initializes the data structure with the head of the linked list. * `ListNode removeElements(int threshold)`: Removes all elements from the linked list that have a value greater than or equal to `threshold` and returns the head of the resulting list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class LinkedListFilter: def __init__(self, head): self.head = head def removeElements(self, threshold): # Dummy node to handle edge cases where the head itself needs to be removed dummy = ListNode(0) dummy.next = self.head current = dummy while current.next: if current.next.val >= threshold: current.next = current.next.next else: current = current.next return dummy.next"},{"question":"You are given a string `s` consisting of lowercase English letters, and an array `distance` of length 26 where each element `distance[i]` represents the minimum required distance between the two occurrences of the character `\'a\' + i` in the string. Return `true` _if the string `s` meets all the distance requirements_ described in the array `distance`, otherwise return `false`.","solution":"def check_distances(s, distance): Checks if the string `s` meets all the distance requirements described in the array `distance`. character_positions = {} for i, char in enumerate(s): if char in character_positions: required_distance = distance[ord(char) - ord(\'a\')] actual_distance = i - character_positions[char] - 1 if actual_distance != required_distance: return False character_positions[char] = i return True"},{"question":"Given two sorted linked lists `list1` and `list2`, merge them into one sorted linked list and return the merged list. The merged list should be made by splicing together the nodes of the two linked lists. Ensure that the relative order of the elements is preserved. Avoid directly using linked list library functions to solve the problem.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(list1, list2): dummy = ListNode() current = dummy while list1 and list2: if list1.val < list2.val: current.next = list1 list1 = list1.next else: current.next = list2 list2 = list2.next current = current.next if list1: current.next = list1 else: current.next = list2 return dummy.next"},{"question":"You are given an array of integers `nums` representing the values of a binary tree in level order traversal where `null` (represented by -1) signifies that there is no node in that position. Build the binary tree from this array and return its root. Note that a level order traversal array of a binary tree is an array where the first element is the root, the next two elements are the children of the root, the next four elements are the children of these two nodes, and so on. Write a function that takes the array `nums` as input and constructs the corresponding binary tree, then returns the root of this binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nums): Constructs a binary tree from a level order traversal array where -1 indicates null node. Returns the root of the binary tree. if not nums: return None root = TreeNode(nums[0]) queue = [root] i = 1 while i < len(nums): current = queue.pop(0) if current: if nums[i] != -1: current.left = TreeNode(nums[i]) queue.append(current.left) i += 1 if i < len(nums) and nums[i] != -1: current.right = TreeNode(nums[i]) queue.append(current.right) i += 1 return root"},{"question":"You are given a string `s`, which represents a mathematical expression in reverse Polish notation (RPN). The expression is valid, consisting of integers and operators (`+`, `-`, `*`, `/`). Implement a function to evaluate the expression and return its value. Note that division between two integers should truncate toward zero. It is guaranteed that the expression is valid and the division is non-zero. For example: - Input: `s = \\"4 13 5 / +\\"` Output: `6` - Input: `s = \\"2 1 + 3 *\\"` Output: `9`","solution":"def eval_rpn(s): Evaluates a mathematical expression in reverse Polish notation (RPN). tokens = s.split() stack = [] for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(int(a / b)) # Truncate towards zero else: stack.append(int(token)) return stack[0]"},{"question":"You are given an integer array `nums` of length `n`, where each element represents a position on a number line. There are also `m` carpets of the same length `len`. You can cover the positions on the number line with these carpets. Each carpet can be placed on any position but can only cover `len` consecutive positions on the number line. Return _the maximum number of unique positions that can be covered by the given carpets_.","solution":"def max_covered_positions(nums, m, length): Returns the maximum number of unique positions that can be covered by m carpets each with length. nums = sorted(set(nums)) # Remove duplicates and sort the positions n = len(nums) # The total number of unique positions after placing `i` carpets covering `len` each. dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for k in range(1, m + 1): j = i - 1 while j >= 0 and nums[j] >= nums[i - 1] - length + 1: j -= 1 dp[i][k] = max(dp[i - 1][k], dp[j + 1][k - 1] + i - j - 1) return dp[n][m]"},{"question":"You are given an array of integers `nums` representing the number of tasks each employee in a team has completed. You have to perform the following operations on the array: 1. **Increment** the number of tasks of any one employee by `1`. 2. **Calculate** the minimum number of operations needed to make every employee\'s completed tasks count the same. Return the minimum number of `increment` operations required to equalize the number of tasks completed by all employees in the team.","solution":"def min_operations_to_equalize(nums): Returns the minimum number of increment operations needed to equalize the number of tasks completed by all employees in the team. max_tasks = max(nums) operations = 0 for num in nums: operations += max_tasks - num return operations"},{"question":"Given two integers `n` and `target`, write a function to compute the number of ways to roll `n` six-sided dice so that the sum of the numbers on the dice is exactly `target`. Each die roll results in an integer between `1` and `6` (inclusive). The function should return the number of possible combinations that result in the target sum.","solution":"def num_rolls_to_target(n, target): Compute the number of ways to roll `n` six-sided dice so that the sum is exactly `target`. :param n: Number of dice :param target: Target sum :return: Number of ways to get the target sum with `n` dice # Initialize DP table where dp[i][j] represents the number of ways to get sum j with i dice dp = [[0] * (target + 1) for _ in range(n + 1)] # Base case: There\'s one way to get sum 0 with 0 dice, which is not rolling any dice. dp[0][0] = 1 # Fill DP table for i in range(1, n + 1): for j in range(1, target + 1): for face in range(1, 7): if j - face >= 0: dp[i][j] += dp[i - 1][j - face] return dp[n][target]"},{"question":"You are given an array `points` containing `n` elements where each element is a tuple representing the x and y coordinates of a point on a 2D plane. You are required to find the pair of points that forms the line segment with the maximum length. Return the coordinates of these two points. Note that the answer should be returned in the format `[point1, point2]` where `point1` and `point2` are the coordinate tuples of the two points forming the longest line segment.","solution":"import math def distance(point1, point2): Returns the Euclidean distance between two points. return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2) def max_length_line_segment(points): Returns the pair of points that form the line segment with the maximum length. Parameters: points (list of tuples): List of n points where each point is represented as a tuple (x, y). Returns: list of tuples: The pair of points that form the line segment with the maximum length. if not points or len(points) < 2: return [] max_length = 0 point1 = point2 = None n = len(points) for i in range(n): for j in range(i + 1, n): dist = distance(points[i], points[j]) if dist > max_length: max_length = dist point1, point2 = points[i], points[j] return [point1, point2]"},{"question":"You are given two integer arrays `arr1` and `arr2` with the same length. We want to make both arrays equal by reversing subarrays from `arr1`. In one operation, you can select a subarray from `arr1` and reverse it. Write a function to determine if it is possible to make `arr1` equal to `arr2` after any number of operations. Return `true` if it is possible, otherwise return `false`.","solution":"def can_be_equal(arr1, arr2): Check if it is possible to make arr1 equal to arr2 by reversing subarrays in arr1. Parameters: arr1 (list of int): The first array. arr2 (list of int): The second array. Returns: bool: True if it is possible to make arr1 equal to arr2, otherwise False. return sorted(arr1) == sorted(arr2)"},{"question":"[Question] 4: You are given a list of integers `arr` and a target integer `t`. Write a function that finds all unique quadruplets `[a, b, c, d]` in `arr` such that `a + b + c + d = t`. Return the list of all quadruplets in ascending order. Each quadruplet should be ordered in non-decreasing order within itself, and no two quadruplets should be identical. Note: This problem is similar to the three-sum problem but extended to four elements. Ensure your solution considers edge cases such as duplicate numbers in the array and handles large input sizes efficiently.","solution":"def four_sum(arr, target): Finds all unique quadruplets [a, b, c, d] in `arr` such that a + b + c + d = `target`. Returns the list of all quadruplets in ascending order. arr.sort() quadruplets = [] length = len(arr) # Function to add the quadruplet to the result list if it\'s unique def add_quadruplet_if_unique(quad): if not quadruplets or quadruplets[-1] != quad: quadruplets.append(quad) for i in range(length - 3): if i > 0 and arr[i] == arr[i - 1]: continue # skip duplicate \'a\' for j in range(i + 1, length - 2): if j > i + 1 and arr[j] == arr[j - 1]: continue # skip duplicate \'b\' left, right = j + 1, length - 1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == target: add_quadruplet_if_unique([arr[i], arr[j], arr[left], arr[right]]) left += 1 right -= 1 while left < right and arr[left] == arr[left - 1]: left += 1 # skip duplicate \'c\' while left < right and arr[right] == arr[right + 1]: right -= 1 # skip duplicate \'d\' elif total < target: left += 1 else: right -= 1 return quadruplets"},{"question":"You are given a 2D grid of size `m x n` composed of lowercase letters and an integer `len`. We call a path **valid** if the following conditions are met: * The path starts at the top-left cell of the grid. * Only rightward or downward movements are allowed at each step. * The path reaches the bottom-right cell of the grid. * The formed string along the path has a length of exactly `len`. Return the number of **distinct** valid paths through the grid that can be formed under these conditions. The grid constraints ensure that there is always at least one path of length `len` if a solution exists. The length `len` is calculated as `m + n - 1` for this problem.","solution":"def numDistinctPaths(grid): Returns the number of distinct valid paths through the grid. m = len(grid) n = len(grid[0]) len_required = m + n - 1 def dfs(x, y, path): if x == m - 1 and y == n - 1: if len(path) == len_required: distinct_paths.add(\\"\\".join(path)) return if x < m - 1: dfs(x + 1, y, path + [grid[x + 1][y]]) if y < n - 1: dfs(x, y + 1, path + [grid[x][y + 1]]) distinct_paths = set() dfs(0, 0, [grid[0][0]]) return len(distinct_paths)"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`. Initially, all elements in the array are considered **unmarked**. You must perform `n` operations where in each operation you mark exactly one element. The marking process involves selecting an element, `nums[i]`, and marking it along with all elements between `0` and `i-1` (inclusive) if they are not yet marked. After marking the elements, you are required to return the **smallest unmarked** element remaining in the array. If all elements are marked, return `-1`.","solution":"def smallest_unmarked(nums): Returns the smallest unmarked element after performing the marking operations on the nums array. n = len(nums) marked = [False] * n for i in range(n): for j in range(i + 1): marked[j] = True # Find the smallest unmarked element for i in range(n): if not marked[i]: return nums[i] # If all elements are marked, return -1 return -1"},{"question":"Given an array of integers `arr` and an integer `k`, return an array of the `k` largest elements from `arr` sorted in ascending order.","solution":"def k_largest_elements(arr, k): Returns an array of the k largest elements from arr, sorted in ascending order. Parameters: arr (list): List of integers. k (int): The number of largest elements to return. Returns: list: A list containing the k largest elements from arr in ascending order. if k <= 0: return [] # Sort the array in descending order and take the first k elements largest_elements = sorted(arr, reverse=True)[:k] # Sort the k largest elements in ascending order before returning return sorted(largest_elements)"},{"question":"You are given a string `s` representing an arithmetic expression containing only non-negative integers, \'+\', \'-\', \'*\', \'/\', and empty spaces. You need to implement a basic calculator to evaluate this expression. The expression should be evaluated following the standard operator precedence rules: multiplication and division have higher precedence than addition and subtraction. Note that division between two integers should truncate toward zero. Inside the expression, there can be spaces. Return the evaluated result as an integer.","solution":"def calculate(s): This function evaluates a basic arithmetic expression string `s` that may contain non-negative integers, \'+\', \'-\', \'*\', \'/\', and empty spaces. The function respects standard operator precedence and integer division truncates toward zero. :param s: String containing the arithmetic expression :return: Evaluated integer result of the expression def operate(op, b, a): if op == \'+\': return a + b elif op == \'-\': return a - b elif op == \'*\': return a * b elif op == \'/\': return int(a / b) # Ensure truncation towards zero num = 0 # Current number being processed stack = [] # Stack to keep numbers and intermediate results sign = \'+\' # Previous operation s = s.replace(\' \', \'\') # Remove spaces for i, char in enumerate(s): if char.isdigit(): num = num * 10 + int(char) if char in \'+-*/\' or i == len(s) - 1: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign in \'*/\': top = stack.pop() stack.append(operate(sign, num, top)) sign = char num = 0 return sum(stack)"},{"question":"Given a string containing only lowercase alphabets, return an integer representing the length of the longest substring with all unique characters.","solution":"def longest_unique_substring_length(s): Returns the length of the longest substring with all unique characters. :param s: A string containing only lowercase alphabets :return: An integer representing the length of the longest substring with all unique characters max_len = 0 start = 0 char_index_map = {} for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given an integer array `heights` representing the heights of buildings in a row. Every day a laser can reduce the height of any building by exactly `1` unit. The laser has limited battery power, and you want to use it in such a way that all the buildings are of the same height at the end, if possible. Return _the **minimum** number of days required to make all the buildings the same height_. If it is not possible to make all the buildings the same height, return `-1`.","solution":"def min_days_to_equal_height(heights): Returns the minimum number of days required to make all the buildings the same height if possible. If it is not possible to make all the buildings the same height, returns -1. if not heights: return 0 min_height = min(heights) total_days = sum(height - min_height for height in heights) return total_days"},{"question":"You are given a positive integer `n`. You need to generate an `n x n` matrix where each element is the sum of its row and column indices (0-indexed). Return the matrix as a 2D list.","solution":"def generate_matrix(n): Generates an n x n matrix where each element is the sum of its row and column indices (0-indexed). Parameters: n (int): The size of the matrix (n x n). Returns: List[List[int]]: The generated matrix. return [[i + j for j in range(n)] for i in range(n)]"},{"question":"Given a string `s`, implement a function to check if it is a palindrome considering only alphanumeric characters and ignoring cases. A palindrome is a word, phrase, or sequence that reads the same backward as forward (ignoring spaces, punctuation, and capitalization). For example, `\\"A man, a plan, a canal: Panama\\"` is a palindrome, while `\\"race a car\\"` is not. Your function should return `true` if `s` is a palindrome and `false` otherwise.","solution":"def is_palindrome(s): Check if the given string s is a palindrome considering only alphanumeric characters and ignoring cases. # Sanitize the input string: Remove non-alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the sanitized string is equal to its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"You are given an array of integers `arr`, where `arr[i]` represents the value at the `i-th` index. A jump array `jumps` is defined where `jumps[i]` is the maximum number of steps you can take forward from `i-th` index. You need to determine the minimum number of jumps required to reach the last index of the array. If it is not possible to reach the last index, return `-1`. For example, with `arr = [2, 3, 1, 1, 4]` and `jumps = [2, 3, 1, 1, 4]`, the minimum number of jumps required to reach the end is `2` (i.e., jump from index `0` to index `1`, then from index `1` to index `4`).","solution":"def min_jumps_to_end(arr, jumps): n = len(arr) if n == 0 or jumps[0] == 0: return -1 max_reach = 0 step = 0 end = 0 jumps_count = 0 for i in range(n): if i > max_reach: return -1 max_reach = max(max_reach, i + jumps[i]) if i == end: if i == n - 1: break end = max_reach jumps_count += 1 if end >= n - 1: break return jumps_count if max_reach >= n - 1 else -1"},{"question":"Given a string `s` and an integer `k`, your task is to determine the number of distinct substrings of `s` of length `k` that are palindromes. Recall that a string is a palindrome if it reads the same forward and backward. Return the count of such distinct substrings. Since the answer may be too large, return it modulo `10^9 + 7`.","solution":"def distinct_palindromic_substrings(s, k): Returns the number of distinct substrings of length k that are palindromes. MOD = 10**9 + 7 if len(s) < k: return 0 palindromic_substrings = set() for i in range(len(s) - k + 1): substring = s[i:i + k] if substring == substring[::-1]: # Check if the substring is a palindrome palindromic_substrings.add(substring) return len(palindromic_substrings) % MOD"},{"question":"You are given an integer array `heights` representing the heights of blocks arranged linearly. Your task is to determine the **maximum area** of water that can be trapped after a rain. The water is trapped between the blocks and the height of the water can be limited by the shorter block among the two sides. Return _the **maximum area** of water that can be trapped._","solution":"def max_water_trapped(heights): Returns the maximum amount of water that can be trapped between the blocks. if not heights or len(heights) < 2: return 0 left, right = 0, len(heights) - 1 max_area = 0 while left < right: height = min(heights[left], heights[right]) width = right - left current_area = height * width max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"You are given a **0-indexed** integer array `arr` of length `n` where `n >= 2`. Return the maximum difference between two elements if `arr[j]` is larger than `arr[i]` and `j > i`. If no such elements exist, return `-1`. Note that the elements `arr[i]` and `arr[j]` must satisfy the condition `j > i` for the difference to be considered.","solution":"def maximum_difference(arr): Returns the maximum difference between two elements such that arr[j] > arr[i] and j > i. If no such elements exist, returns -1. max_diff = -1 min_element = arr[0] for i in range(1, len(arr)): if arr[i] > min_element: max_diff = max(max_diff, arr[i] - min_element) min_element = min(min_element, arr[i]) return max_diff"},{"question":"Given a string `s` representing a shuffled sentence, reconstruct the original sentence. Each word is concatenated with a number at the end, representing the position the word should appear in the original sentence. The words in `s` are separated by spaces. Return the original sentence without the numbers attached to the words. The input string `s` will be non-empty and contain at least one word. Example: - Input: s = \\"is2 sentence4 This1 a3\\" - Output: \\"This is a sentence\\"","solution":"def reconstruct_sentence(s): Reconstructs the original sentence from the shuffled sentence where each word is concatenated with a number representing its position in the original sentence. Parameters: - s: str, shuffled sentence where each word has a number at the end. Returns: - str, the original sentence without the numbers. words = s.split() sorted_words = [\\"\\" for _ in range(len(words))] for word in words: position = int(word[-1]) - 1 # Get the position index (0-based) sorted_words[position] = word[:-1] # Remove the last character (number) return \\" \\".join(sorted_words)"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to find out if there exists a pair of distinct indices `i` and `j` (where `i` is not equal to `j`) in the array such that `nums[i] + nums[j] == target`. If such a pair exists, return the pair of indices as a tuple. If no such pair exists, return `null`.","solution":"def find_pair_with_sum(nums, target): Returns a tuple of indices (i, j) such that nums[i] + nums[j] == target, or None if no such pair exists. index_map = {} for i, num in enumerate(nums): diff = target - num if diff in index_map: return (index_map[diff], i) index_map[num] = i return None"},{"question":"Given a list of `n` integers, each integer being either `1` or `-1`, write a function that determines the maximum length of contiguous subarray with an equal number of `1`s and `-1`s. The array can be empty or contain elements that do not form any such subarray. Return _the length of the longest contiguous subarray with equal counts of_ `1`s _and_ `-1`s.","solution":"def max_length_equal_ones_negones(arr): Returns the maximum length of contiguous subarray with an equal number of 1s and -1s. if not arr: return 0 # Dictionary to store the first occurrence of cumulative sums sum_dict = {0: -1} max_length, cum_sum = 0, 0 for i, num in enumerate(arr): cum_sum += 1 if num == 1 else -1 if cum_sum in sum_dict: max_length = max(max_length, i - sum_dict[cum_sum]) else: sum_dict[cum_sum] = i return max_length"},{"question":"You are given an array of integers `nums` and an integer `target`. Your goal is to find the combination of elements from `nums` that add up exactly to `target`, where each element can be used multiple times. Return the number of such combinations that can be formed. If there are no such combinations, return 0. Note that the order of elements in the combination does not matter.","solution":"def combination_sum(nums, target): Return the number of combinations that sum up to target using elements from nums, where each element can be used multiple times. Parameters: nums (List[int]): List of integers. target (int): Target sum. Returns: int: Number of combinations that add up to target. dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if i >= num: dp[i] += dp[i - num] return dp[target]"},{"question":"You are given a 0-indexed integer array `nums` of length `n`. A continuous subarray is defined as a subarray that can be obtained by deleting some elements from the beginning and some elements from the end of `nums` without changing the order of the remaining elements. A **distinct** subarray is considered \\"smooth\\" if the difference between the maximum and minimum elements in the subarray is less than or equal to a given integer `k`. Return the number of **distinct** smooth subarrays modulo `10^9 + 7`.","solution":"def countSmoothSubarrays(nums, k): MOD = 10**9 + 7 n = len(nums) count = 0 distinct_subarrays = set() for i in range(n): min_elem = float(\'inf\') max_elem = float(\'-inf\') current_subarray = [] for j in range(i, n): min_elem = min(min_elem, nums[j]) max_elem = max(max_elem, nums[j]) current_subarray.append(nums[j]) if max_elem - min_elem <= k: distinct_subarrays.add(tuple(current_subarray)) else: break count = len(distinct_subarrays) return count % MOD"},{"question":"You are given a list of strings `sentences`, where each string consists of words separated by spaces. Each word consists of lowercase and uppercase letters only. Your task is to determine how many sentences can be formed by selecting words from the given list such that each sentence contains exactly `k` unique words. Note that the order of words in the sentences does not matter, and all sentences should be counted regardless of any resemblance in word positions. Return _the total number of such sentences as an integer_.","solution":"from itertools import combinations def count_sentences(sentences, k): Counts the number of sentences that can be formed with exactly `k` unique words. :param sentences: List of strings, each string is a sentence consisting of words separated by spaces :param k: Integer, number of unique words in each generated sentence :return: Integer, count of possible sentences with exactly `k` unique words # Extract all unique words from the sentences unique_words = set() for sentence in sentences: unique_words.update(sentence.split()) # Count the number of combinations of these words taken k at a time if k > len(unique_words): return 0 return len(list(combinations(unique_words, k)))"},{"question":"You are given a `string` s consisting of lowercase English letters and an integer array `count` of the same length. The value `count[i]` represents the number of occurrences the character `s[i]` can appear consecutively in any substring of `s`. You need to determine whether the given `string` s can be rearranged so that no character appears consecutively more than the number of times specified in the `count` array. If such a rearrangement is possible, return _one possible valid rearrangement_ of `s`. If it is not possible, return _an empty string_.","solution":"from collections import Counter import heapq def rearrangeString(s, count): if not s or not count or len(s) != len(count): return \\"\\" letter_count = Counter(s) max_heap = [] for char, cnt in letter_count.items(): if cnt > max(count): return \\"\\" heapq.heappush(max_heap, (-cnt, char)) prev_char, prev_cnt = None, 0 result = [] while max_heap: cnt, char = heapq.heappop(max_heap) result.append(char) if prev_cnt < 0: heapq.heappush(max_heap, (prev_cnt, prev_char)) prev_char = char prev_cnt = cnt + 1 return \'\'.join(result)"},{"question":"You are given a list of non-negative integers representing the heights of blocks where the width of each block is 1. Rainwater can be trapped between these blocks after it rains. Write a function to compute how much water it can trap after raining. The function should take an array of integers representing the height map and return the total amount of trapped water.","solution":"def trap(height): Returns the total amount of trapped water given the heights of the blocks. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given a string `s` and an integer `k`. Your task is to modify `s` such that it becomes a palindrome with at most `k` changes. A change here means replacing any single character with another character. Return `true` if it is possible to achieve this with no more than `k` changes, and `false` otherwise.","solution":"def can_be_palindrome_with_k_changes(s, k): Returns True if the string s can be modified to a palindrome with at most k changes, otherwise False. n = len(s) left = 0 right = n - 1 changes_needed = 0 # Count the number of changes required to make the string a palindrome while left < right: if s[left] != s[right]: changes_needed += 1 left += 1 right -= 1 # If the number of changes needed is less than or equal to k, return True return changes_needed <= k"},{"question":"You are given a list of integers `nums` representing a sequence of elements. Your task is to find the **longest subsequence** that is **bitonic**. A subsequence is considered bitonic if it is initially monotonically increasing and then monotonically decreasing. A purely increasing or purely decreasing subsequence is also considered bitonic. Return _the length of the longest bitonic subsequence_.","solution":"def longest_bitonic_subsequence(nums): if not nums: return 0 n = len(nums) # Increasing subsequence length ending at each index increase_seq = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: increase_seq[i] = max(increase_seq[i], increase_seq[j] + 1) # Decreasing subsequence length starting from each index decrease_seq = [1] * n for i in range(n-2, -1, -1): for j in range(i+1, n): if nums[i] > nums[j]: decrease_seq[i] = max(decrease_seq[i], decrease_seq[j] + 1) # Combine the results of increasing and decreasing subsequences max_length = 0 for i in range(n): max_length = max(max_length, increase_seq[i] + decrease_seq[i] - 1) return max_length"},{"question":"You are given a grid with `m` rows and `n` columns filled with non-negative integers, representing the height of each unit cell in a terrain. Whenever it rains heavily, water collects in the low-lying areas, provided they are not at the edges of the grid. Your task is to calculate the total amount of water that can be trapped after the rain. You may assume that the edges of the grid cannot hold water. Return _the total amount of trapped water._","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] heap = [] for i in range(m): heapq.heappush(heap, (heightMap[i][0], i, 0)) heapq.heappush(heap, (heightMap[i][n-1], i, n-1)) visited[i][0] = visited[i][n-1] = True for j in range(1, n-1): heapq.heappush(heap, (heightMap[0][j], 0, j)) heapq.heappush(heap, (heightMap[m-1][j], m-1, j)) visited[0][j] = visited[m-1][j] = True waterTrapped = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: waterTrapped += max(0, height - heightMap[nx][ny]) heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) visited[nx][ny] = True return waterTrapped"},{"question":"You are given a string `s` consisting of lowercase English letters and you need to rearrange the string such that the same characters are at least distance `d` from each other. If it is not possible to rearrange the string to satisfy this condition, return an empty string. If there are multiple valid arrangements, return any one of them. For example, given `s = \\"aabb\\"` and `d = 2`, a possible output is `\\"abab\\"`.","solution":"from collections import Counter import heapq def rearrange_string(s, d): Rearranges the string such that the same characters are at least distance d from each other. Returns an empty string if not possible. if d == 0: return s counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) result = [] wait_queue = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((count+1, char)) if len(wait_queue) < d: continue next_count, next_char = wait_queue.pop(0) if next_count < 0: heapq.heappush(max_heap, (next_count, next_char)) return \'\'.join(result) if len(result) == len(s) else \\"\\""},{"question":"Given a binary search tree (BST), write a function to find the sum of all nodes with a value between `L` and `R` (inclusive). The binary search tree is defined as follows: the left subtree of a node contains only nodes with keys less than the node\'s key, and the right subtree of a node contains only nodes with keys greater than the node\'s key. Each node has a unique key. Return the sum of the values of all nodes whose value falls in the range `[L, R]`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def range_sum_bst(root, L, R): Returns the sum of all nodes with a value between L and R (inclusive) in a binary search tree. if not root: return 0 sum = 0 if L <= root.val <= R: sum += root.val if root.val > L: sum += range_sum_bst(root.left, L, R) if root.val < R: sum += range_sum_bst(root.right, L, R) return sum"},{"question":"You are given a string `s` consisting of uppercase letters `A` and `B`. You can change any character in the string to the other character (i.e., `A` to `B` or `B` to `A`). You need to perform this operation until there are no consecutive characters that are the same. Return _the minimum number of changes required to achieve this_.","solution":"def min_changes_to_avoid_consecutive(s): Returns the minimum number of changes required to eliminate consecutive identical characters in the string `s`. n = len(s) if n < 2: return 0 changes = 0 for i in range(1, n): if s[i] == s[i-1]: changes += 1 s = s[:i] + (\'B\' if s[i] == \'A\' else \'A\') + s[i+1:] return changes"},{"question":"Given a list of `words` and a string `prefix`, return _a sorted list of all the words that start with the given prefix_. The comparison for sorting should be case-insensitive, and ensure that the returned list maintains case-sensitivity from the original list. If no words match the prefix, return an empty list.","solution":"def words_with_prefix(words, prefix): Returns a sorted list of all words starting with the given prefix. Args: words (list): List of words (strings). prefix (str): The prefix to match. Returns: list: Sorted list of words starting with the given prefix. prefix = prefix.lower() matching_words = [word for word in words if word.lower().startswith(prefix)] return sorted(matching_words, key=lambda w: w.lower())"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of a set of buildings standing in a row. A building `i` is considered visible if there are no buildings taller than or equal to it to its left. Return the total number of visible buildings. Implement the `CitySkyline` class: * `CitySkyline(int[] heights)` Initializes the object with the array `heights`. * `int countVisibleBuildings()` Returns the number of buildings that are visible in the skyline.","solution":"class CitySkyline: def __init__(self, heights): Initializes the object with the array heights. self.heights = heights def countVisibleBuildings(self): Returns the number of buildings that are visible in the skyline. if not self.heights: return 0 visible_count = 1 max_height = self.heights[0] for height in self.heights[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"You are given a 2D integer matrix `grid` where each cell contains either a `0` (representing water) or a `1` (representing land). An island is formed by connecting adjacent `1`s horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Given an initial number of `seconds` which equals `0`, each second, all water cells (`0`s) connected to an island (either directly or indirectly) are converted to land by being \\"flooded\\". Write a function to return the **minimum number of seconds required** to completely flood the grid, i.e., convert all cells in the grid to `1`. Return the minimum number of seconds needed to complete this process.","solution":"from collections import deque def min_seconds_to_flood(grid): Returns the minimum number of seconds required to flood the entire grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) queue = deque() directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Add all initial land cells to the queue for r in range(rows): for c in range(cols): if grid[r][c] == 1: queue.append((r, c)) # If there is no land or the whole grid is land already if not queue: return 0 if len(queue) == rows * cols: return 0 seconds = -1 while queue: num_current_cells = len(queue) for _ in range(num_current_cells): r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0: grid[nr][nc] = 1 queue.append((nr, nc)) seconds += 1 return seconds"},{"question":"You are given a `matrix` of integers where each row represents the stock prices of a different company over a span of days. Each element `matrix[i][j]` represents the price of the `i-th` company\'s stock on the `j-th` day. The performance of a company\'s stock is defined as the difference between its highest and lowest stock prices over all days. Return the identifier (row index) of the company with the best performance. If multiple companies have the same performance, return the one with the smallest identifier. For example, given the matrix: ``` matrix = [ [7, 1, 5, 3], [1, 2, 3, 4], [4, 1, 7, 6] ] ``` The performance differences for the companies are: - Company 0: 7 - 1 = 6 - Company 1: 4 - 1 = 3 - Company 2: 7 - 1 = 6 Here, the best performances are the same for Company 0 and Company 2, but since Company 0 has the smaller identifier, the function should return `0`. Return _the identifier of the company with the best performance_.","solution":"def best_performance(matrix): Returns the identifier (row index) of the company with the best performance. Performance is defined as the difference between the highest and lowest stock prices. best_row_index = None max_performance = float(\'-inf\') for i, row in enumerate(matrix): current_performance = max(row) - min(row) if current_performance > max_performance: max_performance = current_performance best_row_index = i elif current_performance == max_performance: best_row_index = min(best_row_index, i) return best_row_index"},{"question":"You are given a `0-indexed` integer array `scores`, where every element represents the score of a student in an exam. You are also given two integers `k` and `threshold`. A subarray is considered **qualifying** if its length is exactly `k` and the average of its scores is greater than or equal to `threshold`. Return _the number of **qualifying subarrays** in the array_ `scores`. **Note**: The average of a subarray is the sum of its elements divided by its length.","solution":"def num_of_qualifying_subarrays(scores, k, threshold): Returns the number of qualifying subarrays in the array scores. n = len(scores) qualifying_count = 0 threshold_sum = k * threshold current_sum = sum(scores[:k]) if current_sum >= threshold_sum: qualifying_count += 1 for i in range(k, n): current_sum += scores[i] - scores[i - k] if current_sum >= threshold_sum: qualifying_count += 1 return qualifying_count"},{"question":"You are given an `m x n` integer matrix `grid` where `grid[i][j]` represents the number of apples in the cell located at row `i` and column `j`. A robot wants to collect as many apples as possible by starting at the top-left corner of the matrix (cell `(0, 0)`) and moving to the bottom-right corner (cell `(m-1, n-1)`). The robot can only move **down** or **right** at any point in time. Return _the maximum number of apples the robot can collect._","solution":"def max_apples(grid): Return the maximum number of apples the robot can collect while moving only down or right. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a dp table to store the maximum apples collected till each cell dp = [[0] * n for _ in range(m)] # Initialize the starting position dp[0][0] = grid[0][0] # Fill in the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill in the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"You are given a string `s` containing only lowercase alphabet characters and a pattern `p` containing only lowercase alphabet characters and wildcard characters `\'?\'` and `\'*\'`. The wildcard character `\'?\'` can match with any single character, while the wildcard character `\'*\'` can match with any sequence of characters (including an empty sequence). Implement a function `bool isMatch(string s, string p)` that returns `true` if the input string `s` can be matched with the pattern `p`, otherwise return `false`. Make sure your solution works efficiently even for longer strings.","solution":"def isMatch(s, p): Returns true if the input string s matches the pattern p. \'?\' matches any single character. \'*\' matches any sequence of characters (including an empty sequence). # Initialize the DP table dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Handle patterns with \'*\' at the beginning for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] # Fill the table for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[i][j] = dp[i - 1][j] or dp[i][j - 1] elif p[j - 1] == \'?\' or s[i - 1] == p[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[len(s)][len(p)]"},{"question":"You are given a string `s` which consists of lowercase letters. You need to implement a function that returns the length of the longest substring without repeating characters. The function should have the following signature: `int lengthOfLongestSubstring(String s)`. Your implementation should aim to use a sliding window approach to achieve the desired result in linear time. Consider edge cases where the string might be empty or consist solely of repeating characters.","solution":"def lengthOfLongestSubstring(s: str) -> int: Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right, char in enumerate(s): if char in char_map and char_map[char] >= left: left = char_map[char] + 1 char_map[char] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an integer array `nums` and an integer `k`. An operation involves picking two indices `i` and `j` such that `i < j` and `nums[i] + nums[j]` **divisible by** `k`, then removing the corresponding elements `nums[i]` and `nums[j]`. Return the maximum number of operations you can perform on the array.","solution":"def max_operations(nums, k): from collections import Counter count = Counter(nums) operations = 0 for num in list(count.keys()): target = k - num if target in count: if num == target: operations += count[num] // 2 else: min_count = min(count[num], count[target]) operations += min_count count[num] -= min_count count[target] -= min_count return operations"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `x`. In one operation, you can either remove the leftmost or the rightmost element of the array `nums` exactly `x` times. Return _the minimum sum of the remaining elements after performing exactly `x` operations_, or `-1` if it is not possible to remove exactly `x` elements.","solution":"def min_remaining_sum(nums, x): n = len(nums) if x > n: return -1 # Calculate the initial sum of the array total_sum = sum(nums) # Calculate the sum of the first x elements left_sum = sum(nums[:x]) min_sum = total_sum - left_sum # Calculate the sum of the last x elements right_sum = 0 for i in range(x): left_sum -= nums[x-i-1] right_sum += nums[n-i-1] min_sum = min(min_sum, total_sum - left_sum - right_sum) return min_sum"},{"question":"Given a string `num` that contains only digits \'0\' through \'9\' and a target value `target`, return all possible ways to add the binary operators `\'+\'`, `\'-\'`, or `\'*\'` between the digits of `num` so that the resultant expression evaluates to the `target` value. Note that the order of digits in `num` should not be changed and no digits should be removed. For example, if `num = \\"123\\"`, you can add a `\'+\'` between `1`, `2`, and `3` to get the expression `\\"1+2+3\\"`, which evaluates to `6`. Return all the possible expressions that evaluate to the `target`.","solution":"def add_operators(num, target): def backtrack(index, path, value, last): if index == len(num): if value == target: results.append(path) return for i in range(index, len(num)): if i != index and num[index] == \'0\': # skip leading zeroes break current_str = num[index:i + 1] current_num = int(current_str) if index == 0: backtrack(i + 1, current_str, current_num, current_num) else: backtrack(i + 1, path + \\"+\\" + current_str, value + current_num, current_num) backtrack(i + 1, path + \\"-\\" + current_str, value - current_num, -current_num) backtrack(i + 1, path + \\"*\\" + current_str, value - last + last * current_num, last * current_num) results = [] backtrack(0, \\"\\", 0, 0) return results"},{"question":"Given a string `s`, determine if the string can be rearranged to form a palindrome. A palindrome is a word that reads the same forward and backward. For example, \\"radar\\" is a palindrome, but \\"apple\\" is not. You should write a function `boolean canFormPalindrome(String s)` that returns `true` if it is possible to rearrange the characters in `s` to form a palindrome and `false` otherwise. For instance, given the string \\"carrace\\", your function should return `true` since the string can be rearranged to form \\"racecar\\", which is a palindrome. Given the string \\"hello\\", your function should return `false` because there is no way to rearrange the characters to form a palindrome.","solution":"def canFormPalindrome(s): Determines if the string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd count. This is because in a palindrome, most characters must occur an even number of times (to balance out on either side of the center). from collections import Counter count = Counter(s) odd_count = sum(1 for c in count.values() if c % 2 != 0) return odd_count <= 1"},{"question":"Given an integer array `arr`, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. A word is defined as a sequence of non-space characters. The input will be a single string `s` representing the sentence, and you should return _the modified sentence as a string_ with the reversed characters in each word. **Example:** Input: `s = \\"Let\'s take LeetCode contest\\"` Output: `s = \\"s\'teL ekat edoCteeL tsetnoc\\"`","solution":"def reverse_words(s): Reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. :param s: A string input representing a sentence :return: A string with each word\'s characters reversed return \' \'.join(word[::-1] for word in s.split(\' \'))"},{"question":"You are given an array of integers and an integer `k`. Write a function to rotate the array to the right by `k` steps, where `k` is non-negative. For example, for an array `[1, 2, 3, 4, 5, 6, 7]` and `k = 3`, the output should be `[5, 6, 7, 1, 2, 3, 4]`. Implement an efficient solution.","solution":"def rotate_array(nums, k): Rotates the array to the right by k steps. Parameters: nums (list): The list of integers to be rotated. k (int): The number of steps to rotate the array. Returns: list: The rotated list. if not nums or k <= 0: return nums n = len(nums) k = k % n # In case k is greater than the length of nums # Reverse the entire array nums.reverse() # Reverse the first k elements nums[:k] = reversed(nums[:k]) # Reverse the remaining elements nums[k:] = reversed(nums[k:]) return nums"},{"question":"You are given two strings `s1` and `s2` of the same length, consisting only of lowercase English characters. Consider an operation where you can swap the characters at any two positions within `s1`. Determine if it is possible to make `s1` equal to `s2` using some number of swap operations. If it is possible, return the minimum number of swaps required. If it is not possible, return `-1`. **Note:** You can assume that the lengths of `s1` and `s2` are both less than or equal to 10^5.","solution":"from collections import Counter def min_swaps_to_equal(s1, s2): Check if s1 can be converted to s2 by swapping characters and determine the minimum number of swaps required. If not possible, return -1. if len(s1) != len(s2): return -1 if Counter(s1) != Counter(s2): return -1 # Character frequency match, proceed with Minimum Swaps calculation swaps = 0 s1_list = list(s1) for i in range(len(s1)): if s1_list[i] != s2[i]: # Find correct character from the remaining part of the list for j in range(i + 1, len(s1)): if s1_list[j] == s2[i]: s1_list[i], s1_list[j] = s1_list[j], s1_list[i] swaps += 1 break return swaps"},{"question":"Write a function that takes a list of strings `words` and a string `target`. This function should determine if `target` can be formed by concatenating any permutation of strings in `words`. A word may be used multiple times. Return `True` if `target` can be formed, and `False` otherwise.","solution":"def can_form_target(words, target): Determines if the target string can be formed by concatenating any permutation of strings in the words list. A word may be used multiple times. Args: words (list of str): List of strings. target (str): The target string to form. Returns: bool: True if the target can be formed, False otherwise. from collections import Counter def can_form_recursively(tgt, counter): if tgt == \\"\\": return True for word in counter: if tgt.startswith(word) and counter[word] > 0: counter[word] -= 1 if can_form_recursively(tgt[len(word):], counter): return True counter[word] += 1 return False word_counter = Counter(words) return can_form_recursively(target, word_counter)"},{"question":"You are given a list of integers `nums` representing the size of a group of people in a line. The group wants to split into smaller sub-groups for an activity. You need to minimize the number of sub-groups formed. Each sub-group can only have people of the same size, and the size of the sub-group should be the same as any person\'s group size in it (i.e., each person\'s group size in `nums` tells how many people should be in their sub-group). Return the minimum number of sub-groups formed.","solution":"from collections import Counter def min_groups(nums): Returns the minimum number of sub-groups formed such that each sub-group can only have people of the same size. :param nums: List of integers representing the size of a group of people in a line. :return: The minimum number of sub-groups formed. size_count = Counter(nums) min_sub_groups = 0 for size, count in size_count.items(): groups_needed = (count + size - 1) // size # equivalent to math.ceil(count / size) min_sub_groups += groups_needed return min_sub_groups"},{"question":"You have a list of integers `nums` and an integer `k`. You need to determine if there are two distinct indices `i` and `j` in the list such that `nums[i] == nums[j]` and the absolute difference between `i` and `j` is at most `k`. Return _a boolean value indicating whether such a pair exists_.","solution":"def contains_nearby_duplicate(nums, k): Determine if there are any two distinct indices i and j in the list such that nums[i] == nums[j] and the absolute difference between i and j is at most k. Parameters: nums (list of int): List of integers. k (int): The maximum allowed index difference. Returns: bool: True if such a pair exists, False otherwise. index_map = {} for i, value in enumerate(nums): if value in index_map and i - index_map[value] <= k: return True index_map[value] = i return False"},{"question":"A university maintains a record of students\' scores in various courses. The records are stored in a dictionary where keys are the course names and values are lists of students\' scores for that course. Implement the `UniversityRecords` class: * `UniversityRecords()` Initializes the object with an empty records dictionary. * `void addScore(String course, int score)` Adds a student\'s score to the specified course. * `int getAverageScore(String course)` Returns the average score of the specified course. If no scores are present, return `0`. * `List<String> getCoursesAboveThreshold(int threshold)` Returns a list of course names where the average score is above the specified threshold. Here\'s a basic implementation outline to get started: ```python class UniversityRecords: def __init__(self): # Initialize the records dictionary pass def addScore(self, course, score): # Add the score to the course\'s list of scores pass def getAverageScore(self, course): # Return the average score of the specified course pass def getCoursesAboveThreshold(self, threshold): # Return a list of courses with an average score above the threshold pass ``` **Note:** Ensure your implementation maintains the time complexity constraints for each method. ModelState your intermediate calculations efficiently to handle possibly large volumes of data.","solution":"class UniversityRecords: def __init__(self): # Initialize the records dictionary self.records = {} def addScore(self, course, score): # Add the score to the course\'s list of scores if course not in self.records: self.records[course] = [] self.records[course].append(score) def getAverageScore(self, course): # Return the average score of the specified course if course not in self.records or len(self.records[course]) == 0: return 0 return sum(self.records[course]) / len(self.records[course]) def getCoursesAboveThreshold(self, threshold): # Return a list of courses with an average score above the threshold result = [] for course in self.records: if len(self.records[course]) > 0 and self.getAverageScore(course) > threshold: result.append(course) return result"},{"question":"You are given a list of `n` integers, where each element represents a day and the value at each element represents the amount of money you can make on that day. Each day you can choose to either work or skip. However, if you choose to work on day `i`, you must skip the next day, `i+1`, and can continue working on day `i+2`. Your goal is to find the maximum amount of money you can make by choosing the optimal days to work. Return an integer representing the maximum money you can earn given these conditions.","solution":"def max_money(days): Returns the maximum money that can be earned within given conditions. Args: days (list): List of integers where each value represents money you can earn on that day. Returns: int: Maximum amount of money that can be earned. if not days: return 0 n = len(days) if n == 1: return days[0] dp = [0] * n dp[0] = days[0] if n >= 2: dp[1] = max(days[0], days[1]) for i in range(2, n): dp[i] = max(dp[i-1], days[i] + dp[i-2]) return dp[-1] # Example usage: # days = [3, 2, 5, 10, 7] # Output would be 15, because the optimal days to work are days 1, 3, and 5."},{"question":"Given a string `s`, consider all its substrings of length `k`. Return the number of substrings that contain at least one vowel (a, e, i, o, u). If `k` is greater than the length of `s`, return `0`. Example 1: - Input: s = \\"abcdef\\", k = 2 - Output: 3 Explanation: The substrings of length 2 are \\"ab\\", \\"bc\\", \\"cd\\", \\"de\\", \\"ef\\". Substrings \\"ab\\", \\"cd\\" and \\"ef\\" contain at least one vowel. Example 2: - Input: s = \\"xyz\\", k = 1 - Output: 0 Explanation: The substrings of length 1 are \\"x\\", \\"y\\", \\"z\\". None of them contains a vowel.","solution":"def count_vowel_substrings(s, k): Returns the number of substrings of length k that contain at least one vowel. if k > len(s): return 0 vowels = set(\\"aeiou\\") count = 0 for i in range(len(s) - k + 1): substring = s[i:i+k] if any(char in vowels for char in substring): count += 1 return count"},{"question":"You are given a list of `n` integers representing the number of pages in `n` consecutive books. You need to allocate these books to `k` students in such a way that each student gets at least one book, and the maximum number of pages assigned to any student is minimized. Return _the minimized maximum number of pages assigned to a student_.","solution":"def is_valid_distribution(books, n, k, max_pages): count_students = 1 pages_assigned = 0 for i in range(n): if pages_assigned + books[i] > max_pages: count_students += 1 pages_assigned = books[i] if count_students > k: return False else: pages_assigned += books[i] return True def find_minimum_pages(books, n, k): if n < k: return -1 low, high = max(books), sum(books) result = high while low <= high: mid = (low + high) // 2 if is_valid_distribution(books, n, k, mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"You are given an integer array `heights` representing the heights of buildings from left to right. The array is indexed from left to right, starting at 0. The buildings form a skyline, and you need to determine if you can add one more building of a given height `newHeight` to the skyline without disrupting the overall skyline silhouette. A skyline silhouette is defined as a series of one or more contiguous buildings of the same height. To avoid disrupting the skyline, the new building can only be placed between two existing buildings of the same height or at either end of the array if it maintains the silhouette. Return _true_ if you can add the building without disrupting the silhouette and _false_ otherwise.","solution":"def can_add_building(heights, newHeight): Determines if a new building of `newHeight` can be added to the skyline without disrupting the silhouette. :param heights: List[int] - List of building heights. :param newHeight: int - Height of the new building to be added. :return: bool - True if the building can be added without disrupting the silhouette, False otherwise. n = len(heights) # Check if can place the new building at the start or end to maintain silhouette if (n == 0) or (newHeight == heights[0]) or (newHeight == heights[-1]): return True # Check for placing the new building between two heights of the same value for i in range(1, n): if heights[i] == newHeight and heights[i-1] == newHeight: return True return False"},{"question":"You are given a list of unique integers, `heights`, representing the heights of consecutive buildings in a street. You have the ability to place a ball on any building, and the ball will roll to the right, falling to the next building if it is shorter than the previous one. The ball stops if it encounters a building taller than the current one or reaches the end of the list. Write a function to determine the maximum distance the ball can travel when placed on any building. The distance is defined as the number of buildings the ball travels through, including the building it starts on. Return _an integer representing the maximum distance the ball can travel_.","solution":"def max_distance(heights): Returns the maximum distance the ball can travel when placed on any building. max_dist = 1 # At least one building is always there for i in range(len(heights)): dist = 1 for j in range(i + 1, len(heights)): if heights[j] < heights[j - 1]: dist += 1 else: break max_dist = max(max_dist, dist) return max_dist"},{"question":"Given a string `s` consisting of lowercase English letters, you need to perform a series of operations to transform it into a new string. In one operation, you can select any character and place it at the end of the string. Determine the lexicographically smallest string that can be obtained after performing any number of operations. Return _the lexicographically smallest string_ that can be achieved.","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by performing operations where any character can be moved to the end. # We create a sorted list of characters from the string sorted_chars = sorted(s) # We join the sorted characters back into a string return \'\'.join(sorted_chars)"},{"question":"You are provided with a list of `n` unique integers, `arr`, and a target integer `k`. Your task is to find out if there exists a pair of distinct elements in the array whose sum is exactly equal to `k`. If such a pair exists, return `True`. Otherwise, return `False`. Assume that the elements in the array and the target integer `k` are within the range of -10^6 to 10^6. Write a function `pair_sum_exists(arr, k)` which takes in the list of integers `arr` and the integer `k`, and returns a boolean indicating whether there exists a pair whose sum is equal to `k`.","solution":"def pair_sum_exists(arr, k): Determines if there exists a pair of distinct elements in `arr` whose sum equals `k`. Parameters: arr (list of int): List of unique integers. k (int): Target sum. Returns: bool: True if there\'s a pair with sum equal to `k`, False otherwise. seen = set() for num in arr: if k - num in seen: return True seen.add(num) return False"},{"question":"Given a **0-indexed** integer array `heights` representing the heights of buildings in a city, find the array `increase` where `increase[i]` is the number of buildings that are shorter than the building at index `i` for `0 <= i < heights.length`. Return _the array_ `increase`.","solution":"def calculate_increase(heights): Finds the number of buildings that are shorter than the building at each index. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: list: A list where the value at each index is the number of buildings that are shorter than the building at that index. increase = [] for i in range(len(heights)): count = sum(1 for h in heights if h < heights[i]) increase.append(count) return increase"},{"question":"Given an array of integers `arr` of length `n`, you need to determine if by changing **at most one element** in the array, you can make the array **non-decreasing**. A non-decreasing array is an array where `arr[i] <= arr[i + 1]` for every `0 <= i < n - 1`. Return `true` if it\'s possible to make the array non-decreasing by modifying at most one element, otherwise return `false`.","solution":"def check_possibility(arr): n = len(arr) if n <= 1: return True count = 0 for i in range(1, n): if arr[i] < arr[i - 1]: if count == 1: return False count += 1 if i == 1 or arr[i] >= arr[i - 2]: arr[i - 1] = arr[i] else: arr[i] = arr[i - 1] return count <= 1"},{"question":"Given a list of `n` strings, you need to group the anagrams together. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. For example, the words \'listen\' and \'silent\' are anagrams of each other, as are \'elbow\' and \'below\'. Write a function that takes in a list of strings and returns a list of lists of strings, where each inner list contains anagrams grouped together. Example: Input: [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] Output: [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]]","solution":"from collections import defaultdict def group_anagrams(strs): Groups anagrams together from the input list of strings. Parameters: strs (list): List of strings. Returns: list: A list of lists of strings, where each sublist contains anagrams. anagrams = defaultdict(list) for word in strs: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"You are given two integers, `n` and `k`. Your task is to construct an `n`-length string `s` consisting of only lowercase English letters such that there are exactly `k` distinct characters in `s`. If there are multiple solutions, return any of them. If it is impossible to construct such a string, return an empty string.","solution":"def construct_string(n, k): Constructs an n-length string consisting of exactly k distinct lowercase English letters. Parameters: n (int): Length of the string to be constructed. k (int): Number of distinct characters in the constructed string. Returns: str: Constructed string with exactly k distinct characters if possible, otherwise empty string. if k > 26 or k > n: return \\"\\" # Impossible to construct such a string characters = \'abcdefghijklmnopqrstuvwxyz\' result = [] for i in range(n): result.append(characters[i % k]) return \'\'.join(result)"},{"question":"You are given an **unsorted** array `arr` of size `n` containing **distinct integers**. Write a function that returns the array of the same integers sorted in **non-decreasing** order. Your solution should aim to implement the sorting algorithm manually rather than using built-in sorting functions. For instance, if `arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]`, the function should return `[1, 2, 3, 4, 5, 6, 9]` after removing duplicates and sorting the integers.","solution":"def manual_sort_and_deduplicate(arr): Sorts an input list of distinct integers in non-decreasing order and removes any duplicates. # Remove duplicates by converting the list to a set unique_elems = list(set(arr)) # Implementing a simple sorting algorithm: Bubble Sort n = len(unique_elems) for i in range(n): for j in range(0, n-i-1): if unique_elems[j] > unique_elems[j+1]: unique_elems[j], unique_elems[j+1] = unique_elems[j+1], unique_elems[j] return unique_elems"},{"question":"Given an `m x n` matrix `heights` representing the height map of a terrain, where `heights[row][col]` is the height of the cell at coordinates `(row, col)`, return _the list of coordinates of **all** cells where water can flow to both the Pacific and Atlantic oceans._ Water can flow from a cell to neighboring cells, up, down, left, or right, with equal or lower height. Cells adjacent to the Pacific Ocean are located on the left and top borders, and cells adjacent to the Atlantic Ocean are located on the bottom and right borders.","solution":"def pacific_atlantic(heights): if not heights or not heights[0]: return [] m, n = len(heights), len(heights[0]) pacific_reachable = [[False for _ in range(n)] for _ in range(m)] atlantic_reachable = [[False for _ in range(n)] for _ in range(m)] def dfs(matrix, reachable, x, y): reachable[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if not reachable[nx][ny] and matrix[nx][ny] >= matrix[x][y]: dfs(matrix, reachable, nx, ny) for i in range(m): dfs(heights, pacific_reachable, i, 0) dfs(heights, atlantic_reachable, i, n - 1) for j in range(n): dfs(heights, pacific_reachable, 0, j) dfs(heights, atlantic_reachable, m - 1, j) result = [] for i in range(m): for j in range(n): if pacific_reachable[i][j] and atlantic_reachable[i][j]: result.append([i, j]) return result"},{"question":"You are given an integer array `nums`, and you need to find if there exists a **triangular triplet** in the array. A **triangular triplet** is defined as three indices `i`, `j`, `k` such that `0 <= i < j < k < nums.length` and the following conditions are satisfied: * `nums[i] + nums[j] > nums[k]` * `nums[j] + nums[k] > nums[i]` * `nums[k] + nums[i] > nums[j]` Return `true` if there exists a triangular triplet in the array, otherwise, return `false`.","solution":"def is_triangular_triplet(nums): Determines if there exists a triangular triplet in the array nums. A triangular triplet satisfies: nums[i] + nums[j] > nums[k] nums[j] + nums[k] > nums[i] nums[k] + nums[i] > nums[j] Args: nums (List[int]): The input list of integers. Returns: bool: True if a triangular triplet exists, False otherwise. nums.sort() n = len(nums) for i in range(n-2): if nums[i] + nums[i+1] > nums[i+2]: return True return False"},{"question":"Given a string `s` which consists of lowercase letters, you need to create a new string `t` such that each character in `t` appears exactly once and the length of `t` is as short as possible. The relative order of characters in `s` should be preserved in `t`. Implement a function `String shortestUniqueSubsequence(String s)` that returns the string `t`.","solution":"def shortestUniqueSubsequence(s): Returns the shortest unique subsequence of s with each character appearing exactly once while preserving the relative order of characters in s. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are given an array of integers `nums` and an integer `target`. Implement the `SubsetSum` class with the following methods: - `SubsetSum(int[] nums, int target)` Initializes the `SubsetSum` with the array `nums` and the integer `target`. - `boolean canFormSubset()` Returns `true` if there exists a subset of `nums` that sums up to `target`, otherwise returns `false`. For example: - `SubsetSum([1, 2, 3, 4], 6).canFormSubset()` should return `true` because the subset `[2, 4]` or `[1, 2, 3]` sums up to 6. - `SubsetSum([1, 2, 5], 10).canFormSubset()` should return `false` because no subset sums up to 10.","solution":"class SubsetSum: def __init__(self, nums, target): Initializes the SubsetSum with the array nums and the integer target. self.nums = nums self.target = target def canFormSubset(self): Returns true if there exists a subset of nums that sums up to target, otherwise returns false. n = len(self.nums) dp = [[False] * (self.target + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, self.target + 1): if j >= self.nums[i - 1]: dp[i][j] = dp[i-1][j] or dp[i-1][j - self.nums[i - 1]] else: dp[i][j] = dp[i-1][j] return dp[n][self.target]"},{"question":"Given a 2D integer grid `grid` of size `m x n`, where each cell represents the height of the terrain at that point, a ball can start at any cell in the first row. Each ball can only move to the cell directly below it, directly to the left of its current position, or directly to the right of its current position, provided the new cell is within the grid boundaries and the height of the terrain at the new cell does not exceed the height of the current cell. The ball stops when it reaches the last row. Calculate the maximum height the ball can have at its stopping point in the last row. Return _the maximum height_ as an integer.","solution":"def getMaxHeight(grid): Given a 2D grid representing heights, calculate the maximum height the ball can have at its stopping point in the last row of the grid. Parameters: grid (list of list of int): A 2D list with integer heights. Returns: int: The maximum height in the last row the ball can achieve following the rules. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize DP table with the first row heights dp = grid[0] # Process each row from the second to the last for i in range(1, m): new_dp = [0] * n for j in range(n): # Start with a large negative value since we are looking for max max_height = float(\'-inf\') # Check top if dp[j] >= grid[i][j]: max_height = max(max_height, dp[j]) # Check top-left if within bounds if j > 0 and dp[j-1] >= grid[i][j]: max_height = max(max_height, dp[j-1]) # Check top-right if within bounds if j < n-1 and dp[j+1] >= grid[i][j]: max_height = max(max_height, dp[j+1]) new_dp[j] = max_height if max_height != float(\'-inf\') else grid[i][j] dp = new_dp return max(dp)"},{"question":"You are given a 2D grid of size `m x n` representing a maze with the following properties: - Each cell can either be an empty cell (represented by `0`) or a wall (represented by `1`). - You start at the top-left corner of the maze (at cell `grid[0][0]`) and your goal is to reach the bottom-right corner (at cell `grid[m-1][n-1]`). You can only move up, down, left, or right. Find out if there is a path from the start to the end by only moving through empty cells. Return _true_ if such a path exists, otherwise return _false_. Implement the function `bool isPathExist(vector<vector<int>>& grid)`.","solution":"from collections import deque def isPathExist(grid): This function checks if there is a path from the top-left corner to the bottom-right corner in a maze represented by a 2D grid. Parameters: grid (list of list of int): The 2D grid representing the maze, where 0 signifies an empty cell and 1 signifies a wall. Returns: bool: Returns True if there is a path from [0][0] to [m-1][n-1], else False. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) grid[0][0] = 1 # Mark as visited while queue: x, y = queue.popleft() if x == m - 1 and y == n - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0: queue.append((nx, ny)) grid[nx][ny] = 1 # Mark as visited return False"},{"question":"You are given a list of integers `nums` representing a binary tree in level-order traversal where: - The binary tree may contain multiple levels. - `-1` represents a null node. Write a function to construct the binary tree from `nums` and return the root node. Additionally, write a function that calculates and returns the sum of all the values of the deepest leaves in this binary tree. Note: - The level-order traversal means that the binary tree nodes are given in order from the topmost level to the lowest level from left to right. - A binary tree node is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def construct_tree(nums): if not nums or nums[0] == -1: return None from collections import deque root = TreeNode(nums[0]) queue = deque([root]) index = 1 while queue: node = queue.popleft() if index < len(nums) and nums[index] != -1: node.left = TreeNode(nums[index]) queue.append(node.left) index += 1 if index < len(nums) and nums[index] != -1: node.right = TreeNode(nums[index]) queue.append(node.right) index += 1 return root def deepest_leaves_sum(root): if not root: return 0 from collections import deque queue = deque([root]) current_level_sum = 0 while queue: current_level_sum = 0 level_length = len(queue) for _ in range(level_length): node = queue.popleft() current_level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return current_level_sum"},{"question":"A **balanced parentheses string** is a string that consists only of characters \'(\' and \')\' and is properly balanced. More formally, a parentheses string is balanced if: - It is an empty string `\\"\\"`, or - It can be written as `AB` where `A` and `B` are balanced parentheses strings, or - It can be written as `(A)` where `A` is a balanced parentheses string. Given an integer `n`, generate _all combinations of balanced parentheses strings of length `2n`_ sorted in lexicographical order. Return the list of all such balanced combinations as strings.","solution":"def generate_parentheses(n): Generates all combinations of balanced parentheses strings of length 2n sorted in lexicographical order. Args: n (int): the number of pairs of parentheses. Returns: List of strings: all combinations of balanced parentheses strings. def backtrack(s=\'\', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + \'(\', left + 1, right) if right < left: backtrack(s + \')\', left, right + 1) result = [] backtrack() return result"},{"question":"You are given an integer array `arr`, where each element represents the cost of a step. You start at the first step or the second step and aim to reach the last step. You can move from step `i` to step `i+1` or step `i+2` and each move costs `arr[i]`. Your task is to find the minimum cost to reach the last step. Return the minimum cost to reach the last step.","solution":"def minCostClimbingStairs(cost): Given an array of integers \'cost\' where cost[i] is the cost of step i, this function returns the minimum cost to reach the last step. n = len(cost) if n == 0: return 0 if n == 1: return cost[0] dp = [0] * (n+1) dp[0] = 0 dp[1] = 0 # Starting at step 0 or 1 incurs no initial cost for i in range(2, n+1): dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]) return dp[n]"},{"question":"Given an integer array `nums`, return _a new array such that each element at index `i` of the new array is the product of all the numbers in the original array except the one at `i`_. Implement an algorithm that runs in `O(n)` time and uses `O(1)` extra space (excluding the output array). Note that the output array does not count as extra space for the purpose of space complexity analysis.","solution":"def productExceptSelf(nums): Given an array nums, this function returns a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i. length = len(nums) # Initialize the result array with 1s result = [1] * length # Calculate left products left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] # Calculate right products and multiply with the left product right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"You are given a list of integers `nums` and an integer `k`. Your task is to split the list into exactly `k` non-empty consecutive subarrays. The **score** of a split is the sum of the maximum values from each of the `k` subarrays. Return _the minimum possible score_ obtained from any valid split. For example, given `nums = [1, 3, 5, 2, 8, 7]` and `k = 3`, you can split the list as follows: `[[1, 3], [5, 2], [8, 7]]` with the score being `3 + 5 + 8 = 16`. Another possible split might be `[[1, 3, 5], [2, 8], [7]]` with the score being `5 + 8 + 7 = 20`. The minimum possible score among all valid splits is the one you need to return.","solution":"def min_split_score(nums, k): def can_split(max_sum): count = 1 current_sum = 0 for num in nums: current_sum += num if current_sum > max_sum: count += 1 current_sum = num if count > k: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. In one operation, you can choose any subarray of length `k` from `nums` and reverse its elements. You can apply this operation any number of times. Return _the **minimum** number of operations needed to sort the entire array `nums` in non-decreasing order_.","solution":"def min_operations_to_sort(nums, k): Returns the minimum number of operations needed to sort the entire array nums in non-decreasing order by reversing any subarray of length k. n = len(nums) sorted_nums = sorted(nums) # Edge case: if array is already sorted if nums == sorted_nums: return 0 # Special cases if k == 1: return -1 # Impossible to sort (only individual elements can be swapped) if k == n: return 1 if nums != sorted_nums else 0 # One operation is sufficient if it sorts the array entirely # To keep track of contiguous blocks of increasing elements increasing_blocks = 1 for i in range(1, n): if nums[i] < nums[i - 1]: increasing_blocks += 1 return (increasing_blocks + (k - 1)) // k # Number of operations needed"},{"question":"You are given a list of integers representing the stock prices of a company in chronological order. You are allowed to complete at most two transactions to maximize your profit (i.e., buy one and sell one share of the stock, then buy and sell another share later). Design an algorithm to find the maximum profit you can achieve under these constraints. Note that you cannot engage in multiple transactions simultaneously (you must sell the stock before you buy again). **Example 1:** **Input:** prices = [3,3,5,0,0,3,1,4] **Output:** 6 **Explanation:** Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. **Example 2:** **Input:** prices = [1,2,3,4,5] **Output:** 4 **Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy multiple times as you cannot engage in multiple transactions simultaneously. **Example 3:** **Input:** prices = [7,6,4,3,1] **Output:** 0 **Explanation:** In this case, no transaction is done, i.e., the maximum profit = 0. **Example 4:** **Input:** prices = [1,2,4,2,5,7,2,4,9,0] **Output:** 13 **Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 7), profit = 6-1 = 6. Then buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 7-2 = 7. **Constraints:** - `1 <= prices.length <= 10^5` - `0 <= prices[i] <= 10^5`","solution":"def maxProfit(prices): if not prices: return 0 # Initialize the variables t1_cost, t2_cost = float(\'inf\'), float(\'inf\') t1_profit, t2_profit = 0, 0 for price in prices: # The maximum profit achievable after the first buy t1_cost = min(t1_cost, price) t1_profit = max(t1_profit, price - t1_cost) # Reinvest the profit gained from the first transaction into the second transaction t2_cost = min(t2_cost, price - t1_profit) t2_profit = max(t2_profit, price - t2_cost) return t2_profit"},{"question":"You are given a **0-indexed** array of integers `arr` of length `n` and an integer `k`. Your task is to split the array into `k` contiguous subarrays such that the sum of the maximum sums of these subarrays is minimized. Implement the function `minimizeMaxSum(int[] arr, int k)` that returns the minimized maximum sum of the subarrays. **Example:** ``` Input: arr = [1, 2, 3, 4, 5], k = 2 Output: 9 Explanation: The optimal way to split the array is [1, 2, 3] and [4, 5], which gives us a maximum sum of 1+2+3 = 6 from the first subarray, and 4+5 = 9 from the second subarray. Since we are interested in minimizing the maximum sum of these subarrays, the output is 9. ``` **Constraints:** - The length of the array `arr` can be up to 1000. - Each element in the array can be between -10^6 and 10^6. - `k` is an integer such that 1 ≤ k ≤ n.","solution":"def minimizeMaxSum(arr, k): def is_valid(mid): current_sum = 0 count = 1 for num in arr: if current_sum + num > mid: count += 1 current_sum = num if count > k: return False else: current_sum += num return True left, right = max(arr), sum(arr) result = right while left <= right: mid = (left + right) // 2 if is_valid(mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"You are given a list of distinct integers `nums` representing cities and an integer array `routes` where `routes[i] = [ai, bi]` represents a direct route between cities `ai` and `bi`. Each city `ai` or `bi` has a maximum capacity `capacity[i]` which is the number of travelers it can accommodate simultaneously. You need to determine the minimum number of travelers required to maximize the usage of these capacities across all cities. Your task is to write a function that returns the minimum number of travelers. The result should be a single integer representing this minimum number.","solution":"from collections import defaultdict from math import ceil def minimum_travelers(nums, routes, capacity): Determines the minimum number of travelers required to maximize the usage of city capacities across all cities. :param nums: List of distinct integers representing cities. :param routes: List of pairs representing direct routes between cities. :param capacity: List of integers representing the maximum capacity of each city. :return: Integer representing the minimum number of travelers. # Step 1: Create graph representation of cities and their connected routes graph = defaultdict(list) for a, b in routes: graph[a].append(b) graph[b].append(a) # Step 2: Determine the required number of travelers max_capacity = max(capacity) return max_capacity"},{"question":"You are given a list of `tasks` that need to be run, each represented by a character. Each task can be completed in one unit of time. Some of the tasks could be the same, which means they need to be executed multiple times. You are also given an integer `n` that represents the cooldown period between the same tasks (i.e., the minimum units of time that must pass before a task can be executed again). Return the least number of units of times that the task scheduler will take to finish all the tasks. Implement the function: ```python def leastInterval(tasks: List[str], n: int) -> int: ``` **Example:** ``` Input: tasks = [\'A\', \'A\', \'A\', \'B\', \'B\', \'B\'], n = 2 Output: 8 Explanation: A -> B -> idle -> A -> B -> idle -> A -> B ``` **Constraints:** * The number of tasks is in the range [1, 10000]. * The cooling period `n` is in the range [0, 100].","solution":"from collections import Counter def leastInterval(tasks, n): Calculate the least number of units of times that the task scheduler will take to finish all the tasks. task_counts = Counter(tasks) max_count = max(task_counts.values()) # Number of tasks that have the highest frequency max_count_tasks = list(task_counts.values()).count(max_count) # Calculate the minimum intervals required intervals = (max_count - 1) * (n + 1) + max_count_tasks return max(intervals, len(tasks))"},{"question":"You are given a list of integers `arr` and an integer `k`. A **subarray** is defined as a contiguous segment of `arr`. A subarray is **beautiful** if it contains at most `k` distinct integers. Write a function to return the length of the longest beautiful subarray.","solution":"def longest_beautiful_subarray(arr, k): Returns the length of the longest beautiful subarray which contains at most k distinct integers. n = len(arr) if n == 0 or k == 0: return 0 left = 0 right = 0 max_length = 0 frequency = {} while right < n: if arr[right] in frequency: frequency[arr[right]] += 1 else: frequency[arr[right]] = 1 while len(frequency) > k: frequency[arr[left]] -= 1 if frequency[arr[left]] == 0: del frequency[arr[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"You are given a binary tree where each node contains an integer value. Implement a function `int maxSumLeafToLeaf(TreeNode root)`, which computes the maximum sum of values along any path from one leaf node to another leaf node. The path may or may not pass through the root. Return `0` if the tree does not contain at least two leaf nodes. A binary tree node is represented as: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxSumLeafToLeaf(root): def helper(node): if not node: return (float(\'-inf\'), float(\'-inf\')) if not node.left and not node.right: return (node.val, float(\'-inf\')) left_single_path, left_max = helper(node.left) right_single_path, right_max = helper(node.right) if node.left and node.right: max_sum = max(left_max, right_max, left_single_path + right_single_path + node.val) return (max(left_single_path, right_single_path) + node.val, max_sum) elif node.left: return (left_single_path + node.val, left_max) else: return (right_single_path + node.val, right_max) result = helper(root) return result[1] if result[1] != float(\'-inf\') else 0"},{"question":"You are given a list of integers `numbers` where each element represents the score a player achieved in a series of games. A player’s performance is considered consistent if, in any subarray of their scores, there are no more than 2 distinct values differing by more than 1. Your task is to determine whether the player’s performance is consistent across the entire list. Return `true` if the player’s performance is consistent, or `false` otherwise.","solution":"def is_performance_consistent(numbers): Determines if the player\'s performance is consistent. Parameters: numbers (list of int): A list of integers representing a player\'s scores. Returns: bool: True if the player\'s performance is consistent, False otherwise. if not numbers: return True for i in range(len(numbers) - 2): if abs(numbers[i] - numbers[i+1]) > 1 and abs(numbers[i+1] - numbers[i+2]) > 1: return False return True"},{"question":"Given an integer matrix `mat`, your task is to find the largest rectangle containing only `1`s and return its area. The `matrix` will be represented as a 2D array of integers where each element is either `0` or `1`. The rectangle must be aligned with the matrix, meaning its sides are parallel to the rows and columns of the matrix. The dimensions of the matrix are `m x n`, where `m` is the number of rows and `n` is the number of columns.","solution":"def maximalRectangle(matrix): if not matrix or not matrix[0]: return 0 def largestRectangleArea(heights): stack = [] max_area = 0 heights.append(0) # Add a zero-height to ensure we process all buildings for i in range(len(heights)): while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area max_rectangle = 0 heights = [0] * len(matrix[0]) for row in matrix: for i in range(len(row)): if row[i] == 0: heights[i] = 0 else: heights[i] += row[i] max_rectangle = max(max_rectangle, largestRectangleArea(heights)) return max_rectangle"},{"question":"Given an array of integers `heights` representing the heights of buildings, return the maximum area of a rectangle formed by two buildings and the water line. You must place the water line horizontally between two buildings, such that the rectangle\'s width is the horizontal distance between the buildings, and the height is the smaller height of the two buildings.","solution":"def max_area(heights): Returns the maximum area of a rectangle formed between two buildings. :param heights: A list of integers representing the heights of buildings. :return: An integer representing the maximum rectangle area. max_area = 0 left = 0 right = len(heights) - 1 while left < right: # Calculate the height of the container height = min(heights[left], heights[right]) # Calculate the width of the container width = right - left # Calculate the area of the container current_area = height * width # Update the maximum area max_area = max(max_area, current_area) # Move the pointers to find a potentially larger area if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"Write a function `isPalindrome` that checks whether a given integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. For example, 121 is a palindrome while 123 is not. The function should follow this signature: ```python def isPalindrome(x: int) -> bool: ``` **Examples:** 1. Input: `121` Output: `True` 2. Input: `-121` Output: `False` 3. Input: `10` Output: `False` **Note:** - Negative numbers cannot be palindromes because of the leading negative sign when reversed. - You are not allowed to convert the integer to a string or use any string manipulation functions.","solution":"def isPalindrome(x: int) -> bool: if x < 0: return False original = x reversed_number = 0 while x > 0: digit = x % 10 reversed_number = reversed_number * 10 + digit x = x // 10 return original == reversed_number"},{"question":"You are given a list of `projects` where each project has its `start` time, `end` time, and `value` associated with it. You are also given a time limit `T`. Your task is to find the maximum value of projects that can be completed within the time limit `T`, provided that no two projects overlap. If you pick a project that ends at time `X`, you can start another project that starts at time `X`. Return the maximum value that can be achieved within the given time constraint.","solution":"def max_profit(projects, T): projects.sort(key=lambda x: x[1]) dp = [0] * (T + 1) for start, end, value in projects: if end <= T: dp[end] = max(dp[end], max(dp[:start+1]) + value) return max(dp)"},{"question":"Given a binary tree, imagine yourself standing on the right side of it; return the values of the nodes you can see ordered from top to bottom. The binary tree is represented by its root node, and each node has a unique value.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the values of nodes visible from the right side of the binary tree. :param root: TreeNode, root of the binary tree :return: list of int, values of visible nodes from the right side from collections import deque result = [] if not root: return result queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() if i == level_length - 1: # the last node in the current level result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"**[Question 4]**: You are given an integer array `arr` and an integer `k`. Write a function to rearrange the array such that it\'s split into `k` non-empty subsets with equal sums. Return `true` if such an arrangement is possible, otherwise return `false`. Implement the following method: * `boolean canPartitionKSubsets(int[] arr, int k)` - Returns true if the array can be partitioned into `k` subsets with equal sum, otherwise returns false.","solution":"def canPartitionKSubsets(arr, k): def can_partition(start, k, current_sum, subset_sum, used): if k == 0: return True if current_sum == subset_sum: return can_partition(0, k - 1, 0, subset_sum, used) for i in range(start, len(arr)): if not used[i] and current_sum + arr[i] <= subset_sum: used[i] = True if can_partition(i + 1, k, current_sum + arr[i], subset_sum, used): return True used[i] = False return False total_sum = sum(arr) if total_sum % k != 0: return False subset_sum = total_sum // k used = [False] * len(arr) arr.sort(reverse=True) # optimization step to try larger numbers first return can_partition(0, k, 0, subset_sum, used)"},{"question":"You are given a string `s` and an integer `k`. You can choose any substring of `s` and replace it with any other substring of the same length made up of lowercase English letters. Return the minimum number of such replacements needed to create `k` distinct characters in the final string. For example, given `s = \\"aabbcc\\"` and `k = 2`, one optimal solution is to replace \\"cc\\" with \\"dd\\" to obtain \\"aabbdd\\", resulting in 2 distinct characters (\'a\' and \'b\'), thus requiring 1 replacement.","solution":"def min_replacements_to_k_distinct(s: str, k: int) -> int: Given a string s and an integer k, this function returns the minimum number of replacements needed to create k distinct characters in the final string. if k <= 0: return 0 distinct_chars = set(s) if len(distinct_chars) >= k: return 0 return k - len(distinct_chars)"},{"question":"Given a string `s` which represents a valid excel column title, return its corresponding column number. The title uses the English alphabet as column labels: A -> 1, B -> 2, ..., Z -> 26, AA -> 27, AB -> 28, etc. The input string is always in uppercase and consists of only English letters. For example, if the input is `s = \\"ZY\\"`, the output should be `701`.","solution":"def excel_column_number(s): Given a string `s` which represents a valid excel column title, return its corresponding column number. For example, \'A\' -> 1, \'B\' -> 2, ..., \'Z\' -> 26, \'AA\' -> 27, \'AB\' -> 28, etc. column_number = 0 for i, char in enumerate(s): column_number = column_number * 26 + (ord(char) - ord(\'A\') + 1) return column_number"},{"question":"Given a binary tree, implement the function `findDeepestLeftLeaf` to find the value of the deepest left leaf node in that binary tree. A node is considered a left leaf node if it is the left child of its parent and it has no children. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findDeepestLeftLeaf(root: TreeNode) -> int: # Implementation here ``` Note: - If there are multiple deepest left leaf nodes, return the value of any one of them. - If there is no left leaf node, return `None`. Example: ``` Input: [3,9,20,null,null,15,7] Output: 15 Input: [1,2,3,4,null,5,6,null,7] Output: 7 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findDeepestLeftLeaf(root: TreeNode) -> int: if not root: return None from collections import deque queue = deque([(root, False, 0)]) # (node, is_left, depth) deepest_left_leaf = None max_depth = -1 while queue: node, is_left, depth = queue.popleft() # Check if this is a left leaf node if is_left and not node.left and not node.right: if depth > max_depth: deepest_left_leaf = node.val max_depth = depth # Add children to the queue along with depth and if they are left child or not if node.left: queue.append((node.left, True, depth + 1)) if node.right: queue.append((node.right, False, depth + 1)) return deepest_left_leaf"},{"question":"You are given a binary tree where each node has an integer value. Find a path in the tree such that the sum of the values along the path is equal to a given target sum. The path must start at any node and end at any node. The path does not need to follow parent-child relationships, but each node can only be used once. Return _the list of node values along the path_, or _an empty list if no such path exists_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_path_with_sum(root, target_sum): Finds a path in the tree where the sum of node values equals target_sum. def dfs(node, current_path): if not node: return None current_path.append(node.val) current_sum = sum(current_path) if current_sum == target_sum: return current_path[:] # Continue search in both directions left_result = dfs(node.left, current_path) if left_result: return left_result right_result = dfs(node.right, current_path) if right_result: return right_result current_path.pop() return None if not root: return [] potential_paths = [] stack = [root] while stack: node = stack.pop() path = dfs(node, []) if path: potential_paths.append(path) if node.left: stack.append(node.left) if node.right: stack.append(node.right) if not potential_paths: return [] longest_path = max(potential_paths, key=len) return longest_path"},{"question":"Given an array of integers `arr`, find the length of the longest contiguous subarray such that every element in the subarray is strictly greater than the previous element. If there are multiple such subarrays with the same length, return the length of any of them. If there is no such subarray, return `-1`.","solution":"def longest_increasing_subarray(arr): Finds the length of the longest contiguous subarray such that every element in the subarray is strictly greater than the previous element. if not arr: return -1 max_length = 0 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 max_length = max(max_length, current_length) return max_length if max_length > 1 else -1"},{"question":"Implement a function to determine if a given integer `x` is a palindrome. An integer is a palindrome when it reads the same backward as forward. For instance, 121 is a palindrome while 123 is not. Return `true` if `x` is a palindrome integer, otherwise return `false`.","solution":"def is_palindrome(x): Determines if a given integer x is a palindrome. :param x: Integer to be checked :return: True if x is a palindrome, False otherwise # Convert integer to string str_x = str(x) # Compare the string with its reverse return str_x == str_x[::-1]"},{"question":"You are given an array of integers `nums` of size `n` and an integer `target`. Your task is to find whether there exist three distinct elements in `nums` whose sum is equal to `target`. Return `true` if such elements exist and `false` otherwise. For example, given the array `nums = [1, 2, 4, 6, 10]` and `target = 16`, the output should be `true` because the three elements `4`, `6`, and `6` sum up to `16`.","solution":"def three_sum(nums, target): Given an array of integers nums and an integer target, returns True if there exist three distinct elements in nums whose sum is equal to target, otherwise returns False. nums.sort() n = len(nums) for i in range(n-2): left, right = i+1, n-1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given a string `s` containing digits from \'2\' to \'9\' inclusive. Each digit maps to a set of letters as on the telephone buttons: 2 -> \\"abc\\" 3 -> \\"def\\" 4 -> \\"ghi\\" 5 -> \\"jkl\\" 6 -> \\"mno\\" 7 -> \\"pqrs\\" 8 -> \\"tuv\\" 9 -> \\"wxyz\\" Return _an array of all possible letter combinations that the number could represent_. The output array should be returned in **lexicographical order**.","solution":"from itertools import product def letter_combinations(digits): Returns all possible letter combinations the number could represent, in lexicographical order. if not digits: return [] # Mapping of digits to letters digit_to_letter = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } # Generating the possible letters for each digit in digits letters = [digit_to_letter[d] for d in digits] # Producing all possible combinations combinations = [\'\'.join(p) for p in product(*letters)] return sorted(combinations)"},{"question":"You are given a string `s` consisting of only lowercase English letters and a list of indices `indices`. You need to shuffle the characters in the string based on the given list. Specifically, the character at the `i`-th position in the list `indices` should move to the `i`-th position in the string `s`. Return the new reordered string after performing the shuffle based on `indices`.","solution":"def shuffle_string(s, indices): Reorders the characters in the string s based on the given list indices. :param s: A string consisting of only lowercase English letters. :param indices: A list of integers indicating the new positions for each character in s. :return: A new reordered string after shuffling based on indices. shuffled = [\'\'] * len(s) for i, index in enumerate(indices): shuffled[index] = s[i] return \'\'.join(shuffled)"},{"question":"Given a string `s` and an integer `k`, split the string into `k` contiguous substrings such that the maximum length of these substrings is minimized. Return _the minimized maximum length._ If it is not possible to split the string according to the given `k`, return `-1`.","solution":"def split_string_into_k_parts(s, k): if len(s) < k: return -1 # Not possible to split into more parts than the length of the string def can_split_with_max_len(max_len): parts, current_part_len = 1, 0 for char in s: if current_part_len + 1 > max_len: parts += 1 current_part_len = 0 if parts > k: return False current_part_len += 1 return True low, high = 1, len(s) while low < high: mid = (low + high) // 2 if can_split_with_max_len(mid): high = mid else: low = mid + 1 return low"},{"question":"You are given an array `arr` of unique positive integers and a target integer `x`. Your task is to find _two distinct indices_ such that the elements at these indices add up to `x`. If no such pair of indices exists, return an empty array. Return the indices as an array of the form `[index1, index2]` sorted in ascending order. If multiple pairs are possible, you may return any _one_ of them.","solution":"def find_two_sum_indices(arr, x): Finds two distinct indices such that the elements at these indices add up to x. Parameters: arr (list): List of unique positive integers. x (int): Target integer. Returns: list: List containing the two indices. Returns an empty list if no such pair exists. index_map = {} for i, num in enumerate(arr): complement = x - num if complement in index_map: return sorted([index_map[complement], i]) index_map[num] = i return []"},{"question":"You are given an array of integers `nums` and an integer `k`. Return the maximum number of distinct integers you can have in the array after performing exactly `k` operations. In one operation, you can replace any element in the array with any integer. The length of the array and `k` will not exceed 10^5.","solution":"from collections import Counter def max_distinct_elements_after_k_operations(nums, k): Returns the maximum number of distinct integers in the array after performing exactly k operations. :param nums: List[int], an array of integers :param k: int, the number of operations allowed :return: int, the maximum number of distinct integers after k operations freq = Counter(nums) unique_elements = len(freq) duplicates = len(nums) - unique_elements if k <= duplicates: return unique_elements # We can only remove \'k\' duplicates at most, but all unique elements remain else: new_elements = k - duplicates # We use remaining \'k\' to add new elements to reach maximum distinct return unique_elements + new_elements"},{"question":"You are given a binary tree where each node contains a value of 0 or 1. Each root-to-leaf path represents a binary number with the most significant bit at the root. For example, if the path is 0 -> 1 -> 1 -> 0, it represents the binary number 0110, which is 6 in decimal. Write a function to sum all root-to-leaf binary numbers. The answer should be returned as an integer representing the total sum of all root-to-leaf binary numbers in the tree. You may assume that the tree has at least one node.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root): def dfs(node, current_num): if not node: return 0 current_num = (current_num << 1) | node.val if not node.left and not node.right: return current_num return dfs(node.left, current_num) + dfs(node.right, current_num) return dfs(root, 0)"},{"question":"Given an array of integers `nums` and an integer `k`, return the maximum number of consecutive 1s in the array if you can flip at most `k` 0s. A flip operation includes changing a 0 in the array to a 1. The array contains only 0s and 1s. Note: Your solution should have a time complexity of O(n).","solution":"def maxConsecutiveOnes(nums, k): Returns the maximum number of consecutive 1s in the array if you can flip at most k 0s. left = 0 max_ones = 0 zero_count = 0 for right in range(len(nums)): if nums[right] == 0: zero_count += 1 while zero_count > k: if nums[left] == 0: zero_count -= 1 left += 1 max_ones = max(max_ones, right - left + 1) return max_ones"},{"question":"You have been tasked with designing a simple **RateLimiter** which ensures that no more than `k` events are allowed within a given time interval of `n` seconds. Your system should accept an event timestamp parameter (**in seconds** granularity), and you may assume that calls are being made to the system in chronological order (i.e., timestamps are monotonically increasing). Implement the `RateLimiter` class: * `RateLimiter(int k, int n)` Initializes the RateLimiter with the maximum number of `k` allowed events within a time frame of `n` seconds. * `boolean shouldAllowEvent(int timestamp)` A method that checks whether an event at the given `timestamp` should be allowed. If the event is allowed, it records the event and returns `true`. Otherwise, it returns `false`. For instance, given `k = 3` and `n = 5`, the RateLimiter should only allow at most **3** events during any `5` seconds window.","solution":"from collections import deque class RateLimiter: def __init__(self, k, n): Initializes the RateLimiter with the maximum number of `k` allowed events within a time frame of `n` seconds. self.k = k self.n = n self.events = deque() # to store timestamps of allowed events def shouldAllowEvent(self, timestamp): Checks whether an event at the given `timestamp` should be allowed. If the event is allowed, it records the event and returns `True`. Otherwise, it returns `False`. # Remove events that are outside the n-second window while self.events and self.events[0] <= timestamp - self.n: self.events.popleft() if len(self.events) < self.k: self.events.append(timestamp) return True else: return False"},{"question":"You are given an array of integers `nums` and an integer `k`. An **interesting subarray** is defined as a contiguous subarray that contains exactly `k` distinct integers. Your task is to return the total number of interesting subarrays in the given array `nums`. If there are no interesting subarrays, return `0`.","solution":"def count_interesting_subarrays(nums, k): Returns the total number of interesting subarrays with exactly k distinct integers. from collections import defaultdict def at_most_k(nums, k): counter = defaultdict(int) left = 0 total = 0 for right in range(len(nums)): counter[nums[right]] += 1 while len(counter) > k: counter[nums[left]] -= 1 if counter[nums[left]] == 0: del counter[nums[left]] left += 1 total += right - left + 1 return total # Number of subarrays with at most k distinct integers # minus number of subarrays with at most (k-1) distinct integers return at_most_k(nums, k) - at_most_k(nums, k - 1)"},{"question":"An airline has a list of flights between cities in the form of a 2D array `flights` where `flights[i] = [u, v, w]` indicates there is a flight from city `u` to city `v` with a travel cost of `w`. You are given `n`, the number of cities numbered from `0` to `n-1`, an integer `src` representing your starting city, and an integer `dst` representing your destination city. You are also given an integer `k` which represents the maximum number of stops you are allowed to make. Find the minimum travel cost from `src` to `dst` with at most `k` stops. If there is no such route, return `-1`.","solution":"import heapq from collections import defaultdict, deque def find_cheapest_price(n, flights, src, dst, k): Finds the minimum travel cost from `src` to `dst` with at most `k` stops. :param n: int, number of cities numbered from 0 to n-1 :param flights: List[List[int]], list of flights where each flight is represented as [u, v, w] :param src: int, starting city :param dst: int, destination city :param k: int, maximum number of stops allowed :return: int, the minimum travel cost from `src` to `dst` with at most `k` stops. If there is no such route, return -1. graph = defaultdict(list) for u, v, w in flights: graph[u].append((v, w)) # (cost, current_city, stops) heap = [(0, src, 0)] while heap: cost, current_city, stops = heapq.heappop(heap) if current_city == dst: return cost if stops <= k: for neighbor, weight in graph[current_city]: heapq.heappush(heap, (cost + weight, neighbor, stops + 1)) return -1"},{"question":"Given an array of integers `heights`, where `heights[i]` represents the height of a person standing in a queue, rearrange the queue such that people are sorted in descending order of their height. If two people have the same height, the person with the smaller index in the original array should stand in front of the other person. Return the new arrangement of heights.","solution":"def rearrange_queue(heights): Rearranges the queue such that people are sorted in descending order of their height. If two people have the same height, the person with the smaller index in the original array stands in front. Parameters: heights (list of int): List representing the heights of people in a queue. Returns: list of int: Rearranged heights. indexed_heights = list(enumerate(heights)) indexed_heights.sort(key=lambda x: (-x[1], x[0])) return [height for index, height in indexed_heights]"},{"question":"You are given a list of integers `nums` where each integer occurs either once or twice. Write an algorithm to return a list of all integers that occur exactly once. Each element in your result should appear in ascending order. *For example, if `nums = [4, 3, 2, 7, 8, 2, 3, 1]`, your output should be `[1, 4, 7, 8]`*.","solution":"def find_unique_numbers(nums): Returns a list of integers that occur exactly once in the input list, sorted in ascending order. from collections import Counter count = Counter(nums) return sorted([num for num in count if count[num] == 1])"},{"question":"Given a list of non-negative integers representing the amount of time each task takes, and an integer `k` representing the maximum number of parallel tasks that can be performed at any time, return the minimum amount of time required to complete all tasks. Each task must be assigned to one of the `k` workers and a worker can only work on one task at a time.","solution":"def min_time_to_complete_tasks(tasks, k): Finds the minimum amount of time required to complete all tasks when we have k workers available. :param tasks: List of integers where each integer represents the time required to complete a task. :param k: Integer representing the number of available workers. :return: Minimum amount of time to complete all tasks. if not tasks: return 0 # Using a greedy approach with a priority queue (min-heap) to always assign tasks # to the worker that gets free the earliest. from heapq import heappush, heappop # Initialize the heap with k workers, all starting at time 0 heap = [0] * k for time in tasks: # Pop the worker who will be free the earliest earliest_worker = heappop(heap) # Assign the current task to this worker and push back the new free time heappush(heap, earliest_worker + time) # The minimum time to complete all tasks will be the maximum value in the heap return max(heap)"},{"question":"You are given a list of strings `words` and a target string `target`. Each string in `words` can be rearranged to form another string. Find and return the minimum number of strings from `words` needed to be concatenated and reordered to form the target string. If it is not possible to form the target string using any combination of strings from `words`, return -1.","solution":"from collections import Counter def min_concatenation_to_form_target(words, target): Finds the minimum number of strings from `words` needed to be concatenated and reordered to form `target`. If not possible, returns -1. target_counter = Counter(target) def can_form(word, counter): word_counter = Counter(word) for char in word_counter: if counter[char] < word_counter[char]: return False return True def helper(counter): if not counter: return 0 min_count = float(\'inf\') for word in words: if can_form(word, counter): new_counter = counter - Counter(word) min_count = min(min_count, 1 + helper(new_counter)) return min_count result = helper(target_counter) return result if result != float(\'inf\') else -1"},{"question":"Given a string `s` which represents an expression containing digits and the operators `+`, `-`, `*`, and `/`, implement a function that evaluates the expression and returns the result as an integer. The given expression is assumed to be a valid arithmetic expression and does not contain any parentheses. Note that integer division should truncate toward zero.","solution":"def evaluate_expression(s): Evaluates a given arithmetic expression with digits and operations +, -, *, /. Args: s (str): The arithmetic expression as a string. Returns: int: The evaluated result of the expression. def apply_op(op, a, b): if op == \'+\': return a + b elif op == \'-\': return a - b elif op == \'*\': return a * b elif op == \'/\': # The integer division that truncates toward zero return int(a / b) num_stack = [] op_stack = [] i = 0 while i < len(s): if s[i] == \' \': i += 1 continue if s[i].isdigit(): num = 0 while i < len(s) and s[i].isdigit(): num = num * 10 + int(s[i]) i += 1 num_stack.append(num) continue while (op_stack and (op_stack[-1] in \\"*/\\" or (op_stack[-1] in \\"+-\\" and s[i] in \\"+-\\"))): op = op_stack.pop() b = num_stack.pop() a = num_stack.pop() num_stack.append(apply_op(op, a, b)) op_stack.append(s[i]) i += 1 while op_stack: op = op_stack.pop() b = num_stack.pop() a = num_stack.pop() num_stack.append(apply_op(op, a, b)) return num_stack[-1]"},{"question":"Given a list of integers `arr`, return the length of the longest increasing subsequence such that all elements of this subsequence are sorted in strictly increasing order. If more than one subsequence of the same maximum length exists, return the length of any of them.","solution":"def length_of_LIS(arr): Returns the length of the longest increasing subsequence in arr. if not arr: return 0 # Initialize an array to store the length of the longest increasing subsequence ending at each index dp = [1] * len(arr) # Fill the dp array for i in range(1, len(arr)): for j in range(0, i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given two integers, `n` and `k`. Your task is to construct an array `arr` of length `n` that contains no more than `k` distinct integers and satisfies the following conditions: 1. Each integer in the array must be between 1 and n (inclusive). 2. The elements of the array must be arranged such that the number of distinct integers between any two occurrences of the same integer is minimized. Return the lexicographically smallest array `arr` that fulfills the above constraints. If there is no such array, return an empty array. Note: - An array `arr1` is lexicographically smaller than an array `arr2` of the same length if in the first position where `arr1` and `arr2` differ, the element in `arr1` is smaller than the corresponding element in `arr2`.","solution":"def construct_array(n, k): Construct an array of length n with no more than k distinct integers, such that the number of distinct integers between any two occurrences of the same integer is minimized and the array is lexicographically smallest. if k > n: return [] result = [] for i in range(n): result.append((i % k) + 1) return result"},{"question":"Given an array of unique positive integers `arr`, write a function that finds the length of the longest subarray where the absolute difference between any two elements is less than or equal to `1`. For example, given `arr = [1, 3, 2, 2, 5, 2, 3, 7]`, the function should return `5` for the subarray `[3, 2, 2, 2, 3]`. The function signature should be: `def longest_subarray(arr: List[int]) -> int:`","solution":"from typing import List from collections import Counter def longest_subarray(arr: List[int]) -> int: if not arr: return 0 freq = Counter(arr) max_len = 0 for num in freq: current_len = freq[num] if num + 1 in freq: current_len += freq[num + 1] max_len = max(max_len, current_len) max_len = max(max_len, freq[num]) return max_len"},{"question":"You are provided with an array of integers `nums` and an integer `target`. Your task is to determine two distinct indices `i` and `j` in the array such that `nums[i] + nums[j] = target`. If such indices exist, return them in the form of a list `[i, j]`. If there are multiple solutions, you may return any of them. If no such indices exist, return an empty array. You must solve the problem in `O(n)` time complexity and `O(n)` space complexity.","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the given list that add up to the target. Parameters: nums (List[int]): List of integers. target (int): The target integer. Returns: List[int]: Indices of the two numbers that add up to the target or an empty list if no such numbers exist. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"You are given a string `s` consisting of characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. Write a function that determines if the string representing brackets is **balanced**. A string of brackets is considered balanced if: 1. Every opening bracket has a corresponding closing bracket of the same type. 2. Opening brackets are closed in the correct order. Return _true if the string is balanced, and _false_ otherwise_.","solution":"def is_balanced(s): Determines if the string of brackets is balanced. Args: s (str): The string of brackets to be checked. Returns: bool: True if the string is balanced, False otherwise. stack = [] bracket_pairs = { \')\': \'(\', \'}\': \'{\', \']\': \'[\' } for char in s: if char in bracket_pairs.values(): stack.append(char) elif char in bracket_pairs.keys(): if stack == [] or stack.pop() != bracket_pairs[char]: return False else: return False return stack == []"},{"question":"You are given a `n x n` 2D matrix `grid` representing an island map where `1` represents land and `0` represents water. You may assume that all four edges of the grid are entirely surrounded by water. You want to find the smallest perimeter of the land present in the grid. The perimeter of the land is calculated by counting the number of edges that are adjacent to water either inside or outside the boundaries of the grid. Implement the `Solution` class: * `Solution(int[][] grid)` Initializes the object with the given `grid` representing the island map. * `int minPerimeter()` Returns the smallest possible perimeter of the land in the grid.","solution":"class Solution: def __init__(self, grid): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) if self.rows > 0 else 0 def minPerimeter(self): def getCellPerimeter(i, j): perimeter = 0 # Check top if i == 0 or self.grid[i-1][j] == 0: perimeter += 1 # Check bottom if i == self.rows - 1 or self.grid[i+1][j] == 0: perimeter += 1 # Check left if j == 0 or self.grid[i][j-1] == 0: perimeter += 1 # Check right if j == self.cols - 1 or self.grid[i][j+1] == 0: perimeter += 1 return perimeter min_perimeter = float(\'inf\') for i in range(self.rows): for j in range(self.cols): if self.grid[i][j] == 1: min_perimeter = min(min_perimeter, getCellPerimeter(i, j)) return min_perimeter"},{"question":"You are given a `List` of `List`s where `paths[i] = [a, b]` signifies there is a directed edge from node `a` to node `b`. Given that the graph contains exactly one node with no incoming edges (the **source**) and exactly one node with no outgoing edges (the **destination**), your task is to return the source node. Implement the function `public int findSourceNode(List<List<Integer>> paths)` which returns the source node of the directed graph. This node can be determined by analyzing the direction of the edges and identifying the unique node from which no edges are pointing towards it. Each path entry is unique and the graph is guaranteed to be a Directed Acyclic Graph (DAG).","solution":"def findSourceNode(paths): Returns the source node of the directed graph. :param paths: List of List of Integers where each sublist [a, b] indicates a directed edge from node a to node b :return: Integer representing the source node # Using a set to track nodes that have incoming edges nodes_with_incoming_edges = set() # Adding the destination nodes in the paths to the set for path in paths: # path[1] is the node with an incoming edge from path[0] nodes_with_incoming_edges.add(path[1]) # We now need to find a node that is not in \'nodes_with_incoming_edges\' for path in paths: # path[0] is the source node in this particular edge if path[0] not in nodes_with_incoming_edges: return path[0]"},{"question":"You are given an array of integers `elements` where each element represents the ID of a particle. Some particles can annihilate each other. Two particles annihilate if the sum of their IDs is equal to a given target integer `target_sum`. Write a function to determine the maximum number of particles that can be annihilated. Implement a function that returns the maximum number of particles that can be annihilated given the list `elements` and the integer `target_sum`.","solution":"from collections import Counter def max_particles_annihilated(elements, target_sum): Returns the maximum number of particles that can be annihilated given the list of particle IDs and the target sum for annihilation. counts = Counter(elements) max_annihilations = 0 for element in list(counts.keys()): complement = target_sum - element if complement in counts: if element == complement: # Special case where the element and its complement are the same pairs = counts[element] // 2 else: pairs = min(counts[element], counts[complement]) max_annihilations += pairs counts[element] -= pairs counts[complement] -= pairs # Remove elements with zero count to avoid redundant checks if counts[element] == 0: del counts[element] if counts[complement] == 0: del counts[complement] return max_annihilations * 2"},{"question":"You are given a directed graph with `n` nodes labeled from `0` to `n-1` and an integer `k`. The graph is represented by a list of edges, where `edges[i] = [u, v]` indicates there is a directed edge from node `u` to node `v`. Your task is to **detect all nodes that are reachable from a given starting node `start` within exactly `k` steps.** Return a list of all such nodes sorted in ascending order.","solution":"def reachable_nodes_within_k_steps(n, edges, start, k): Returns a list of nodes that are reachable from `start` within exactly `k` steps. The nodes in the returned list are sorted in ascending order. from collections import defaultdict, deque # Create adjacency list representation of the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Use a queue to perform BFS queue = deque([(start, 0)]) reachable_nodes = set() while queue: node, steps = queue.popleft() if steps == k: reachable_nodes.add(node) elif steps < k: for neighbor in graph[node]: queue.append((neighbor, steps + 1)) return sorted(reachable_nodes)"},{"question":"You are given a string `expression` representing a mathematical expression containing just positive integers, \'+\', and \'*\' operators. Your task is to compute the different possible results from evaluating all the possible ways to group the numbers and operators. The possible outcomes should be returned in an array and it is guaranteed that all results will be unique. For example, given the input `expression = \\"2*3+4\\"`, - By evaluating `(2*3)+4`, you get `10`. - By evaluating `2*(3+4)`, you get `14`. Return all the possible results in any order.","solution":"from typing import List def diff_ways_to_evaluate_expression(expression: str) -> List[int]: def ways(expr): if expr.isdigit(): return [int(expr)] result = [] for index in range(len(expr)): if expr[index] in \'+*\': left_ways = ways(expr[:index]) right_ways = ways(expr[index + 1:]) for left in left_ways: for right in right_ways: if expr[index] == \'+\': result.append(left + right) elif expr[index] == \'*\': result.append(left * right) return result return list(set(ways(expression)))"},{"question":"A **modern library system** keeps track of books and their respective availability using an online catalog. Each book can have a certain number of copies, and the library allows book loans for a specific period. Design a class `LibraryCatalog` with the following functionalities: * `LibraryCatalog(List<Book> books)`: Initializes the catalog with a list of books. Each `Book` contains a title, author, and the number of available copies. * `boolean loanBook(String title, int userId)`: Loans out a copy of the book with the given title to the user with `userId`. Returns `true` if the loan is successful (a copy is available), otherwise `false`. * `boolean returnBook(String title, int userId)`: Returns a copy of the book with the given title from the user with `userId`. Returns `true` if the return is successful, otherwise `false` (e.g., if no such loan exists). * `int availableCopies(String title)`: Returns the number of available copies of the book with the given title.","solution":"class Book: def __init__(self, title, author, copies): self.title = title self.author = author self.copies = copies self.loans = {} class LibraryCatalog: def __init__(self, books): self.books = {book.title: book for book in books} def loanBook(self, title, userId): if title in self.books and self.books[title].copies > 0: if userId not in self.books[title].loans: self.books[title].loans[userId] = 0 self.books[title].loans[userId] += 1 self.books[title].copies -= 1 return True return False def returnBook(self, title, userId): if title in self.books and userId in self.books[title].loans and self.books[title].loans[userId] > 0: self.books[title].copies += 1 self.books[title].loans[userId] -= 1 if self.books[title].loans[userId] == 0: del self.books[title].loans[userId] return True return False def availableCopies(self, title): if title in self.books: return self.books[title].copies return 0 # Example usage books = [Book(\\"Book A\\", \\"Author A\\", 3), Book(\\"Book B\\", \\"Author B\\", 2)] catalog = LibraryCatalog(books)"},{"question":"You are given a list of integers `nums`. A **decompression** transformation is defined as taking a pair `[x, y]` from the list, where `x` represents the frequency of occurrence and `y` is the value to be repeated. Construct an array that contains each pair\'s value `y` repeated `x` times in the order they appear in the input list. Return the decompressed version of the list.","solution":"def decompress_list(nums): Decompresses a list according to the given transformation rule, where each pair [x, y] means value y occurs x times in the list. The function returns the decompressed list. Parameters: nums (list): The input list of integers, where pairs of [x, y] represent the frequency and value. Returns: list: The decompressed list. decompressed = [] for i in range(0, len(nums), 2): x = nums[i] y = nums[i + 1] decompressed.extend([y] * x) return decompressed"},{"question":"Given a string `s` consisting of only characters \'a\' and \'b\', you can delete any number of characters in the string. After deleting some characters, you can rearrange the rest of the characters in any order. Determine the minimum number of deletions required so that there are no two consecutive \'a\'s and no two consecutive \'b\'s in the resulting string. Return the minimum number of deletions required.","solution":"def min_deletions_to_avoid_consecutive_chars(s): Given a string s consisting of only characters \'a\' and \'b\', determine the minimum number of deletions required so that there are no two consecutive \'a\'s and no two consecutive \'b\'s in the resulting string. Parameters: s (str): Input string consisting of only \'a\' and \'b\' Returns: int: Minimum number of deletions required if not s: return 0 deletions = 0 prev_char = s[0] for i in range(1, len(s)): if s[i] == prev_char: deletions += 1 else: prev_char = s[i] return deletions"},{"question":"You are given an array of integers `arr` and an integer `x`. You need to find all unique triplets in the array which gives the sum of `x`. Implement a function `List<List<Integer>> findTriplets(int[] arr, int x)` that returns a list of all such triplets. Note that the solution set must not contain duplicate triplets.","solution":"def find_triplets(arr, x): Finds all unique triplets in the array which sum up to x. Args: arr: List of integers. x: Integer target sum. Returns: A list of lists, where each list contains three integers that sum up to x. arr.sort() triplets = [] n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue # Skip duplicate values to avoid duplicate triplets left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == x: triplets.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 # Skip duplicate values while left < right and arr[right] == arr[right - 1]: right -= 1 # Skip duplicate values left += 1 right -= 1 elif current_sum < x: left += 1 else: right -= 1 return triplets"},{"question":"You are given an array `intervals` where `intervals[i] = [starti, endi]` represents the start and end times of the `i`th meeting. All the meetings are such that they do not overlap with each other. Given a new meeting interval `[newStart, newEnd]`, insert the new meeting into the appropriate position in the `intervals` array and return the updated array of intervals such that all the intervals are still sorted by their `start` time. # Example ```python Input: intervals = [[1, 3], [6, 9]], newInterval = [2, 5] Output: [[1, 5], [6, 9]] Input: intervals = [[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]], newInterval = [4, 8] Output: [[1, 2], [3, 10], [12, 16]] ```","solution":"def insert_interval(intervals, newInterval): Given a list of non-overlapping intervals sorted by their start time, insert a new interval and ensure the list remains sorted and non-overlapping. :param intervals: List[List[int]] - a list of intervals :param newInterval: List[int] - a new interval to insert :return: List[List[int]] - the updated list of intervals merged_intervals = [] i = 0 n = len(intervals) # Add all intervals ending before newInterval starts while i < n and intervals[i][1] < newInterval[0]: merged_intervals.append(intervals[i]) i += 1 # Merge all overlapping intervals while i < n and intervals[i][0] <= newInterval[1]: newInterval[0] = min(newInterval[0], intervals[i][0]) newInterval[1] = max(newInterval[1], intervals[i][1]) i += 1 merged_intervals.append(newInterval) # Add remaining intervals while i < n: merged_intervals.append(intervals[i]) i += 1 return merged_intervals"},{"question":"Design and implement a class `MedianFinder` that supports the following operations: * `void addNum(int num)` - Adds an integer number from the data stream to the data structure. * `double findMedian()` - Returns the median of all elements so far. If the number of elements is odd, return the middle element; if the number of elements is even, return the average of the two middle elements. ```python class MedianFinder: def __init__(self): Initialize your data structure here. def addNum(self, num: int) -> None: Adds an integer number from the data stream to the data structure. def findMedian(self) -> float: Returns the median of all elements so far. ``` Provide the implementation of the `MedianFinder` class with efficient time and space complexity for the operations specified.","solution":"import heapq class MedianFinder: def __init__(self): Initialize your data structure here using two heaps. One max-heap for the lower half and one min-heap for the upper half. self.lower_half = [] # max-heap (inverted min-heap) self.upper_half = [] # min-heap def addNum(self, num: int) -> None: Adds an integer number from the data stream to the data structure. # Add to max heap (lower_half) heapq.heappush(self.lower_half, -num) # Ensure the max-heap property and min-heap property if (self.lower_half and self.upper_half and (-self.lower_half[0] > self.upper_half[0])): heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) # Balance the sizes if len(self.lower_half) > len(self.upper_half) + 1: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) if len(self.upper_half) > len(self.lower_half): heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half)) def findMedian(self) -> float: Returns the median of all elements so far. If the number of elements is odd, return the middle element; if the number of elements is even, return the average of the two middle elements. # Handle the case where the number of elements is odd if len(self.lower_half) > len(self.upper_half): return -self.lower_half[0] return (-self.lower_half[0] + self.upper_half[0]) / 2"},{"question":"You are given a binary tree with `n` nodes where each node has a unique value from `1` to `n`. Each node also has an additional pointer `random` which can point to any node in the tree or be null. Create a deep copy of the tree such that all the `random` pointers in the new tree point to the corresponding nodes as in the original tree. Write a function that takes the root of the original binary tree and returns the root of the deep copied tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None, random=None): self.val = val self.left = left self.right = right self.random = random def deepcopy_tree(root): if not root: return None oldToNew = {} def copyNode(node): if not node: return None if node in oldToNew: return oldToNew[node] copy = TreeNode(node.val) oldToNew[node] = copy copy.left = copyNode(node.left) copy.right = copyNode(node.right) copy.random = copyNode(node.random) return copy return copyNode(root)"},{"question":"Given a collection of numbers, design a data structure that supports the following operations: 1. `insert(val)` - Inserts a value into the collection. 2. `remove(val)` - Removes a value from the collection if it exists. If multiple instances of the value exist, remove just one. 3. `getRandom()` - Returns a random element from the collection. Each element must have the same probability of being returned. Implement the data structure. If the collection is empty, the `getRandom` operation should return `None`. Each `insert`, `remove`, and `getRandom` operation should run in average `O(1)` time.","solution":"import random class RandomizedCollection: def __init__(self): Initialize the data structure here. self.data = [] self.val_index_map = {} def insert(self, val: int) -> None: Inserts a value into the collection. self.data.append(val) if val in self.val_index_map: self.val_index_map[val].append(len(self.data) - 1) else: self.val_index_map[val] = [len(self.data) - 1] def remove(self, val: int) -> bool: Removes a value from the collection if it exists. If multiple instances of the value exist, remove just one. Returns true if the collection contained the specified element, false otherwise. if val not in self.val_index_map or not self.val_index_map[val]: return False remove_idx = self.val_index_map[val].pop() last_val = self.data[-1] self.data[remove_idx] = last_val if self.val_index_map[last_val]: self.val_index_map[last_val].remove(len(self.data) - 1) self.val_index_map[last_val].append(remove_idx) self.data.pop() if not self.val_index_map[val]: del self.val_index_map[val] return True def getRandom(self) -> int: Get a random element from the collection. if not self.data: return None return random.choice(self.data)"},{"question":"You are given an array of integers `arr` and an integer `d`. You can perform the following operation on the array any number of times (including zero): choose an element of the array and decrement it by `d`. Your task is to determine if it\'s possible to make all the elements of the array equal by performing the operation any number of times. Return `true` if it is possible, otherwise return `false`.","solution":"def can_make_all_elements_equal(arr, d): Determines if it\'s possible to make all elements of the array equal by decrementing any element by d any number of times. :param arr: List[int] - The input array of integers. :param d: int - The decrement value. :return: boolean - True if it\'s possible to make all elements equal, else False. remainder_set = set() for num in arr: remainder_set.add(num % d) # If all remainders are the same, then it\'s possible to make all elements equal return len(remainder_set) == 1"},{"question":"You are given an array of strings `words` representing a list of words. You need to find and return _the length of the **longest** word in the list that can be formed by concatenating other words in the list_ (including itself multiple times). If no such word exists, return `0`. All words are unique and each given word is a concatenation of words in the list.","solution":"def longest_concatenated_word(words): def can_form(word, word_set): if word in memo: return memo[word] for i in range(1, len(word)): prefix = word[:i] suffix = word[i:] if prefix in word_set and (suffix in word_set or can_form(suffix, word_set)): memo[word] = True return True memo[word] = False return False words = set(words) longest = 0 memo = {} for word in words: if can_form(word, words): longest = max(longest, len(word)) return longest"},{"question":"Given an array of integers `nums` and an integer `k`, your task is to perform the following operations exactly `k` times: - **Pick** any subarray from the array `nums`. - **Reverse** the order of the elements in the picked subarray. Determine _if it is possible to sort the array `nums` in non-decreasing order after exactly `k` such operations_. Return `true` if it is possible, otherwise return `false`.","solution":"def can_sort_by_reversals(nums, k): Determines if it\'s possible to sort the array `nums` in non-decreasing order after exactly `k` reversals on subarrays. Args: nums (List[int]): The input array of integers. k (int): The number of reversals that must be performed. Returns: bool: True if the array can be sorted after exactly `k` reversals, False otherwise. # If the array is already sorted and k is 0, it\'s trivially possible. if sorted(nums) == nums and k == 0: return True # If k >= 1, we can choose arbitrary subarrays and sort the array. if k >= 1: return True # Otherwise, if k == 0 and array is not sorted, we can\'t sort it. return False"},{"question":"You are given a string `s` and a string `t`. In one operation, you can choose any character of `t` and replace it with another character. Return _the minimum number of operations needed to make `t` a subsequence of `s`_. A string `t` is considered a subsequence of `s` if it can be derived from `s` by deleting some characters without changing the order of the remaining characters.","solution":"def min_operations_to_subsequence(s, t): Returns the minimum number of operations needed to make `t` a subsequence of `s`. In one operation, you can choose any character of `t` and replace it with another character. m, n = len(s), len(t) # If t is already empty, zero operations are needed if n == 0: return 0 # dp[i][j] will be True if t[0:j] is a subsequence of s[0:i] dp = [[False] * (n + 1) for _ in range(m + 1)] # An empty t is a subsequence of any prefix of s for i in range(m + 1): dp[i][0] = True # Fill dp array for i in range(1, m + 1): for j in range(1, n + 1): # Carry forward the result from previous row dp[i][j] = dp[i - 1][j] # If chars match, check for shorter subsequences if s[i - 1] == t[j - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j - 1] # Find the length of the longest valid subsequence t\' that can be part of s max_len = 0 for j in range(n + 1): if dp[m][j]: max_len = j # The minimum number of operations is the number of changes required return n - max_len"},{"question":"Given a **0-indexed** integer array `heights` representing the height of trees in a row. If you remove one tree, you are tasked to return the maximum possible difference between the heights of any two remaining trees. Write a function that returns this maximum difference after removing only one tree from the array `heights`. Ensure your solution is optimized to handle large inputs efficiently.","solution":"def max_difference_after_remove(heights): Returns the maximum possible difference between the heights of any two remaining trees after removing exactly one tree from the list. n = len(heights) if n <= 2: # If there are only two or fewer trees, removing one leaves us with too few trees to calculate a difference. return 0 max_diff = max(heights) - min(heights) if n == 3: return max_diff # To find the max possible difference: max1 = max(heights[1:]) # max excluding the first tree min1 = min(heights[1:]) # min excluding the first tree max2 = max(heights[:-1]) # max excluding the last tree min2 = min(heights[:-1]) # min excluding the last tree # Intermediary calculation of potential max differences: # Case 1: Removing first tree. diff1 = max1 - min1 # Case 2: Removing last tree. diff2 = max2 - min2 return max(max_diff, diff1, diff2)"},{"question":"You have a list of course prerequisites represented by a 2D vector `prerequisites`, where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` before you can take course `ai`. Given the total number of courses, `numCourses`, your task is to determine if it is possible to finish all courses. That is, return `true` if you can take all courses without any prerequisites conflicts, and `false` otherwise.","solution":"from collections import defaultdict, deque def canFinish(numCourses, prerequisites): # Initialize the adjacency list and the indegree array adjacency_list = defaultdict(list) indegree = [0] * numCourses # Populate the adjacency list and indegree array based on the prerequisites for course, prereq in prerequisites: adjacency_list[prereq].append(course) indegree[course] += 1 # Initialize the queue with courses that have no prerequisites (indegree 0) zero_indegree_queue = deque([i for i in range(numCourses) if indegree[i] == 0]) # Initialize a count of visited nodes visited_count = 0 # Process nodes in the queue while zero_indegree_queue: current_course = zero_indegree_queue.popleft() visited_count += 1 # Reduce the indegree of the neighboring nodes by 1 for neighbor in adjacency_list[current_course]: indegree[neighbor] -= 1 # If indegree of neighbor becomes 0, add it to the queue if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) # If visited_count equals numCourses, return True, else return False return visited_count == numCourses"},{"question":"Given a binary tree, return _a list of lists_, where each list represents the values of the nodes at each level of the tree in **zigzag level order** (i.e., first level from left to right, second level from right to left, and so on).","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def zigzagLevelOrder(root): Given the root of a binary tree, return the zigzag level order traversal of its nodes\' values. (i.e., from left to right, then right to left for the next level and alternate between). if not root: return [] results = [] current_level = deque([root]) left_to_right = True while current_level: level_result = [] next_level = deque() while current_level: node = current_level.popleft() level_result.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) if not left_to_right: level_result.reverse() results.append(level_result) current_level = next_level left_to_right = not left_to_right return results"},{"question":"An e-commerce company is analyzing the sequences of products viewed by a user during a session to better understand customer behavior. Given a list of product IDs that a user viewed in sequence represented by the integer array `views` (which may contain duplicates), write a function to determine and return the length of the **longest contiguous subarray** that contains **only distinct elements**. For example, given the input array `[2, 3, 5, 2, 3, 4, 5]`, the output should be `4`, which corresponds to the subarray `[2, 3, 4, 5]`.","solution":"def longest_distinct_subarray(views): Returns the length of the longest contiguous subarray that contains only distinct elements. start = 0 max_length = 0 seen = {} for end in range(len(views)): if views[end] in seen: start = max(start, seen[views[end]] + 1) seen[views[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given an integer array `arr` of size `n` and a positive integer `k`, return all the unique subarrays of size `k` that have distinct elements. You need to return the subarrays in the order they appear in the array. A subarray is a contiguous portion of the array.","solution":"def unique_subarrays(arr, k): Returns all the unique subarrays of size k that have distinct elements. Parameters: arr (list of int): An input array. k (int): Size of the subarray. Returns: list of list of int: List of unique subarrays of size k with distinct elements. n = len(arr) if k > n: return [] result = [] for start in range(n - k + 1): subarray = arr[start:start + k] if len(set(subarray)) == k: result.append(subarray) return result"},{"question":"You are given an `n x n` 2D matrix representing an image, rotate the image by 90 degrees (clockwise). Implement a function `rotate(matrix: List[List[int]]) -> None:` with the following requirements: - The rotation should be done in-place, meaning you have to modify the input 2D matrix directly. - Do not return anything from your function. Note: - You can assume `n == matrix.length == matrix[i].length` and `1 <= n <= 20`.","solution":"from typing import List def rotate(matrix: List[List[int]]) -> None: Rotates the given n x n 2D matrix by 90 degrees clockwise in-place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"Given the root of a binary tree, return an array representing the level order traversal of the binary tree\'s nodes\' values. In level order traversal, nodes are visited level by level from left to right. The binary tree is represented using TreeNode where TreeNode contains a value, a left child (could be None), and a right child (could be None). For example, for the binary tree represented as: ``` 3 / 9 20 / 15 7 ``` The output should be: ``` [3, 9, 20, 15, 7] ```","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Returns the level order traversal of a binary tree\'s nodes\' values. :param root: TreeNode, the root of the binary tree :return: List of integers representing the level order traversal if not root: return [] queue = deque([root]) result = [] while queue: node = queue.popleft() result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"You are given a string `s` of length `n`, consisting of only lowercase alphabetical characters. You need to modify `s` such that no two adjacent characters are the same. You can achieve this by replacing characters in the string with any other lowercase alphabetical character. Your task is to return the minimum number of character replacements needed to make the string valid according to the rule that no two adjacent characters should be the same.","solution":"def min_replacements_to_avoid_repeats(s): Returns the minimum number of character replacements needed to make sure no two adjacent characters are the same in the given string `s`. n = len(s) if n < 2: return 0 replacements = 0 # Iterate through the string and check for adjacent characters that are the same for i in range(1, n): if s[i] == s[i-1]: replacements += 1 # Choose a character different from the previous and the next characters for c in \'abcdefghijklmnopqrstuvwxyz\': if (i+1 < n and c != s[i+1]) and c != s[i-1]: s = s[:i] + c + s[i+1:] break return replacements"},{"question":"You are given two strings `s` and `t`, and an integer `k`. The string `s` represents an initial state, and you can convert it to string `t` by making exactly `k` operations. In one operation, you can select any character in string `s` and change it to any other character. Return `true` if you can convert `s` to `t` using exactly `k` operations. Otherwise, return `false`.","solution":"def can_convert(s, t, k): Returns True if you can convert string s to string t using exactly k operations, otherwise False. if len(s) != len(t): return False # Calculate the number of differing characters between s and t differing_chars = sum(1 for a, b in zip(s, t) if a != b) # We need exactly k operations: they need to either exactly match the differing characters, or there should be enough additional operations to allow extra changes back and forth return differing_chars <= k and (k - differing_chars) % 2 == 0"},{"question":"You are given two integer arrays `fullness` and `capacity`, both of length `n`, where `fullness[i]` and `capacity[i]` represent the current amount of liquid and the total capacity, respectively, of the `ith` container in a line of containers. You have a pipe connected to the first container and can transfer liquid forward from one container to the next, but not backward. Your goal is to determine the maximum amount of liquid that can be transferred to the last container, given the constraints that you cannot exceed the capacity of any container during the transfer process. Return _the maximum amount of liquid that can be transferred to the last container_.","solution":"def max_liquid_transfer(fullness, capacity): Returns the maximum amount of liquid that can be transferred to the last container. n = len(fullness) max_last_container = fullness[-1] for i in range(n - 2, -1, -1): # Transfer all possible liquid from fullness[i] considering the capacity of the next container transfer = min(fullness[i], capacity[i + 1] - fullness[i + 1]) fullness[i + 1] += transfer fullness[i] -= transfer # Update the max liquid in the last container max_last_container = fullness[-1] return max_last_container"},{"question":"Given an array `nums` of n integers, where each integer is between 1 and n, inclusive, compute the smallest missing positive integer. Write a function `findSmallestMissingPositive` that returns this integer. Your algorithm should run in O(n) time and use O(1) extra space.","solution":"def findSmallestMissingPositive(nums): n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"Given a binary array `nums`, find the maximum number of consecutive `1`s in the array if you can flip at most one `0` to a `1`. A binary array is an array of only `0`s and `1`s. This problem tests your ability to use a sliding window approach to efficiently find the result without iterating through the array multiple times. Implement the following function: ```python def longest_ones(nums: List[int]) -> int: # Your code here ```","solution":"from typing import List def longest_ones(nums: List[int]) -> int: left = 0 max_ones = 0 zero_count = 0 for right in range(len(nums)): if nums[right] == 0: zero_count += 1 while zero_count > 1: if nums[left] == 0: zero_count -= 1 left += 1 max_ones = max(max_ones, right - left + 1) return max_ones"},{"question":"You are given a list of `n` integers and an integer `k`. A **subarray** of the list is any contiguous segment of the list. Return the number of subarrays whose elements sum up to `k`. Note that there could be multiple subarrays with the same elements summing up to `k`, and you should count each occurrence separately. For instance, for the list `[1, 2, 3]` and `k = 3`, the subarrays `[1, 2]` and `[3]` both sum up to `k`.","solution":"def subarray_sum(nums, k): Returns the number of subarrays whose sum is equal to k. Args: nums (list of int): List of integers. k (int): The target sum. Returns: int: Number of subarrays whose sum is k. count = 0 current_sum = 0 prefix_sums = {0: 1} # Initialize with 0 sum having one occurrence. for num in nums: current_sum += num if (current_sum - k) in prefix_sums: count += prefix_sums[current_sum - k] # Add the number of times the (current_sum - k) has occurred. if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"You are given a string `s` consisting of only lowercase letters and an integer `n`. You need to transform the string by moving each letter to a new position dictated by the given integer `n`. When transforming, the new position of each character is determined by moving to the right by `n` places in the alphabetical order, wrapping around to the start if necessary (i.e., after \'z\' comes \'a\'). Return the transformed string. Note that `n` can be positive or negative.","solution":"def shift_character(c, n): Shifts a character c by n positions in alphabetical order, wrapping around if necessary. return chr((ord(c) - ord(\'a\') + n) % 26 + ord(\'a\')) def transform_string(s, n): Transforms the string s by moving each letter to a new position dictated by the given integer n. return \'\'.join(shift_character(char, n) for char in s)"},{"question":"You are given an array of integers `nums` where each integer occurs an even number of times except for one integer which occurs an odd number of times. You need to find the integer that occurs an odd number of times. Return the integer that occurs an odd number of times.","solution":"def find_odd_occurrence(nums): Returns the integer that occurs an odd number of times in the list. :param nums: List of integers where all but one integer have even occurrences. :return: The integer that occurs an odd number of times. result = 0 for num in nums: result ^= num return result"},{"question":"You are given a list of routes where each route is represented as a list of stops. Each stop is represented as an integer. The task is to find the minimum number of buses you need to take to travel from a start stop to an end stop. If it is not possible to travel from the start stop to the end stop using the given routes, return -1. You can assume that there will be no duplicate stops in each route and that the routes will not be circular.","solution":"from collections import deque, defaultdict def num_buses_to_destination(routes, start, end): Returns the minimum number of buses required to travel from start to end stop using the given routes. If it is not possible, returns -1. if start == end: return 0 # Map each stop to the routes that pass through it stop_to_routes = defaultdict(set) for route_id, route in enumerate(routes): for stop in route: stop_to_routes[stop].add(route_id) # BFS initialization visited_stops = set() visited_routes = set() queue = deque([(start, 0)]) # (current stop, buses taken) visited_stops.add(start) while queue: current_stop, buses_taken = queue.popleft() for route_id in stop_to_routes[current_stop]: if route_id in visited_routes: continue visited_routes.add(route_id) for stop in routes[route_id]: if stop == end: return buses_taken + 1 if stop not in visited_stops: visited_stops.add(stop) queue.append((stop, buses_taken + 1)) return -1"},{"question":"You are given an array of integers `arr` and an integer `targetSum`. Write a function that returns all the unique combinations of numbers from the array that sum up to `targetSum`. Each number in `arr` can be used multiple times in any combination. The combinations should be returned as a list of lists, and the combinations can be returned in any order. Ensure that no combination includes the same set of numbers in a different order. Implement the function `getCombinations(arr, targetSum)`: * `getCombinations(arr: List[int], targetSum: int) -> List[List[int]]`: A function that returns a list of lists, where each list is a unique combination of numbers that add up to `targetSum`.","solution":"def getCombinations(arr, targetSum): Returns all unique combinations of numbers from arr that sum up to targetSum. Each number in arr can be used multiple times in any combination. Combinations are returned as a list of lists. def backtrack(start, target, path, result): if target == 0: result.append(list(path)) return if target < 0: return for i in range(start, len(arr)): path.append(arr[i]) backtrack(i, target - arr[i], path, result) path.pop() result = [] arr.sort() backtrack(0, targetSum, [], result) return result"},{"question":"You are given a **0-indexed** string array `words` and a **0-indexed** list of integer pairs `pairs` where each pair `(i, j)` represents an interchangeable character swap. An interchangeable character swap allows you to swap characters `words[i][k]` and `words[j][l]` (the k-th character of the i-th word with the l-th character of the j-th word). You need to determine if there exists a permutation of `pairs` that allows you to make both `words[i]` and `words[j]` equal for all `(i, j)` pairs in `pairs`. Return `true` if it’s possible to make all the pairs equal, otherwise return `false`.","solution":"def can_make_equal(words, pairs): Determines if there exists a permutation of pairs that allows making both words[i] and words[j] equal for all pairs (i, j) in pairs. :param words: List of 0-indexed string words. :param pairs: List of 0-indexed integer pairs. :return: True if it’s possible to make all the pairs equal, otherwise False. def can_swap(word1, word2): Determine if two words can swap characters to be equal. if sorted(word1) == sorted(word2): return True else: return False for i, j in pairs: if len(words[i]) != len(words[j]): return False if not can_swap(words[i], words[j]): return False return True"},{"question":"Given a list of `n` strings `words`, each string represents a student\'s score report in the format \\"student_id:score\\". Write a function to calculate the average score for each student and return a list of results in the format \\"student_id:average_score\\". The results should be sorted by the student_id in ascending order. Each student_id and average_score should be separated by a colon. Note: The `student_id` is a unique alphanumeric string, and `score` is an integer. The average score should be a **floating-point number** rounded to two decimal places. Example: Input: `words = [\\"abc:80\\", \\"xyz:90\\", \\"abc:85\\", \\"xyz:95\\", \\"lmn:75\\"]` Output: `[\\"abc:82.50\\", \\"lmn:75.00\\", \\"xyz:92.50\\"]`","solution":"def calculate_average_scores(words): Calculate the average score for each student and returns a list of results in the format \\"student_id:average_score\\" sorted by student_id in ascending order. student_scores = {} for word in words: student_id, score = word.split(\':\') score = int(score) if student_id not in student_scores: student_scores[student_id] = [] student_scores[student_id].append(score) result = [] for student_id in sorted(student_scores.keys()): avg_score = sum(student_scores[student_id]) / len(student_scores[student_id]) avg_score = round(avg_score, 2) result.append(f\\"{student_id}:{avg_score:.2f}\\") return result"},{"question":"You are given a list of strings `words` and a single string `chars`. A string is considered **formable** if it can be formed by characters from `chars`, using each character at most once. Return the sum of lengths of all **formable** strings in `words`. For example, if the input `words` is `[\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"]` and `chars` is `\\"atach\\"`, the **formable** words are `\\"cat\\"` and `\\"hat\\"`, and the output should be `6` because the lengths of `\\"cat\\"` and `\\"hat\\"` sum up to `6`.","solution":"def count_chars(words, chars): Returns the sum of lengths of all formable strings in words. A string is considered formable if it can be formed by characters from chars, using each character at most once. from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[char] <= chars_count[char] for char in word_count): total_length += len(word) return total_length"},{"question":"You are given an `n x n` 2D matrix `grid` representing a map where `1` represents land and `0` represents water. An **island** is a group of `1`s (land) connected 4-directionally (vertical or horizontal). You may assume all four edges of the grid are surrounded by water. Implement a function that returns the perimeter of the island in the `grid`. The island will have exactly one component, meaning there will be exactly one island. For example, consider the following `grid`: ``` [ [0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0] ] ``` The perimeter of the island is `16` as the island takes up a contiguous block and touches the water on all non-connected sides.","solution":"def islandPerimeter(grid): Calculates the perimeter of the island in the grid. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: perimeter += 4 # start with 4 sides per land cell # check for adjacent land cells to subtract shared borders if r > 0 and grid[r-1][c] == 1: perimeter -= 2 # subtract 2 for shared border with upper cell if c > 0 and grid[r][c-1] == 1: perimeter -= 2 # subtract 2 for shared border with left cell return perimeter"},{"question":"You are given an array `intervals` where `intervals[i] = [start_i, end_i]` represents the `i`-th interval. An interval `[a, b]` is covered by an interval `[c, d]` if and only if `c <= a` and `b <= d`. Return _the number of intervals that are not covered by any other interval in the array._","solution":"def remove_covered_intervals(intervals): Returns the number of intervals that are not covered by any other interval. # Sort intervals by the start points, and in case of tie by the end points in reversed order intervals.sort(key=lambda x: (x[0], -x[1])) num_non_covered_intervals = 0 last_end = 0 for start, end in intervals: # If the current interval is not covered by the previous one if end > last_end: num_non_covered_intervals += 1 last_end = end return num_non_covered_intervals"},{"question":"You are given a linked list where each node contains a single digit. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Write a function `ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)` that takes the heads of two linked lists `l1` and `l2` and returns the head of a new linked list representing their sum. Remember, the digits are stored in reverse order, so you must traverse from the head node for the least significant digit.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): Adds two numbers represented by linked lists. :param l1: ListNode, linked list representing the first number. :param l2: ListNode, linked list representing the second number. :return: ListNode, linked list representing the sum. dummy_head = ListNode(0) current = dummy_head carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 total = val1 + val2 + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy_head.next"},{"question":"Given a string `s` consisting of lowercase English letters, you need to perform operations to delete characters in the string. Each operation consists of choosing a character `c` from the string and deleting all occurrences of `c`. The goal is to minimize the number of operations required to delete all characters from the string. Return _the minimum number of operations_ required to delete all characters from the string `s`.","solution":"def min_deletions(s): Returns the minimum number of operations required to delete all characters from the string. Each operation consists of choosing a character from the string and deleting all occurrences of it. Parameters: s (str): The input string containing only lowercase English letters. Returns: int: The minimum number of operations required. # Convert the string into a set to count the unique characters unique_characters = set(s) # The number of unique characters is the minimum number of operations required return len(unique_characters)"},{"question":"Given an array of integers `nums`, you are tasked with rearranging the array so that the sum of the absolute differences between every two consecutive elements is minimized. In other words, we want to rearrange `nums` such that the value of `|nums[0] - nums[1]| + |nums[1] - nums[2]| + ... + |nums[n-2] - nums[n-1]|` is as small as possible. Return _the rearranged array_. Note: The output array must be a permutation of the input array. In case of multiple valid permutations, return any one of them.","solution":"def minimize_absolute_differences(nums): Rearranges the array \'nums\' such that the sum of the absolute differences between every two consecutive elements is minimized. nums.sort() n = len(nums) result = [] for i in range(n // 2): result.append(nums[n-1-i]) result.append(nums[i]) if n % 2 != 0: result.append(nums[n//2]) return result if len(result) == n else result[::-1] # handle even lengths reversal"},{"question":"Given a list of `heights` representing the height of each student standing in a line, return a list of integers where each integer denotes the number of students in front of that student who are shorter than them. The list of integers should be returned in the same order as the initial list of `heights`. For example, if `heights = [5, 3, 4, 6, 2]`, the resulting list would be `[0, 0, 1, 3, 0]`.","solution":"def count_shorter_students(heights): Returns a list of integers where each integer denotes the number of students in front of that student who are shorter than them. :param heights: List[int] :return: List[int] result = [] for i in range(len(heights)): count = 0 for j in range(0, i): if heights[j] < heights[i]: count += 1 result.append(count) return result"},{"question":"There is a garden with `n` flowerbeds arrayed in a line. Each flowerbed is represented by an interval `[start, end]`, which indicates the time the flowerbed will bloom fully. You\'re given a 2D integer array `flower_intervals` where `flower_intervals[i] = [start_i, end_i]` describes the flowering interval of the i-th flowerbed. A gardener wants to know the maximum number of flowerbeds that will bloom concurrently at any given time. Return _the **maximum number** of flowerbeds that are fully blooming concurrently._","solution":"def maxConcurrentFlowers(flower_intervals): Return the maximum number of flowerbeds that are fully blooming concurrently. :param flower_intervals: List[List[int]], 2D list where each inner list is [start, end] time for each flowerbed. :return: int, maximum number of flowerbeds blooming concurrently. events = [] for start, end in flower_intervals: events.append((start, 1)) events.append((end + 1, -1)) events.sort() max_flowers = 0 current_flowers = 0 for time, count in events: current_flowers += count max_flowers = max(max_flowers, current_flowers) return max_flowers"},{"question":"Given a string `s` representing a valid arithmetic expression consisting of non-negative integers and the operators `+`, `-`, `*`, and `/`, return the result of the expression. Note that integer division should truncate toward zero. Implement the `calculate` function with the following signature: ```python def calculate(s: str) -> int: # your code here ``` **Example:** ```python assert calculate(\\"3+2*2\\") == 7 assert calculate(\\" 3/2 \\") == 1 assert calculate(\\" 3+5 / 2 \\") == 5 ```","solution":"def calculate(s: str) -> int: Evaluate the arithmetic expression given in string form and return the result as an integer. s = s.replace(\' \', \'\') def evaluate(tokens): stack = [] num = 0 sign = \'+\' for i, token in enumerate(tokens): if token.isdigit(): num = num * 10 + int(token) if token in \'+-*/\' or i == len(tokens) - 1: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack.append(stack.pop() * num) elif sign == \'/\': stack.append(int(stack.pop() / num)) # use int() to truncate toward zero sign = token num = 0 return sum(stack) return evaluate(s)"},{"question":"You are given a string `s` consisting of lowercase English letters and a pattern `p` also consisting of lowercase English letters. You need to determine if `s` contains a substring that is an anagram of `p`. In other words, you need to find out if there is a permutation of `p` that appears in `s` as a substring. Return _true_ if such a substring exists in `s`, and _false_ otherwise. For example, given `s = \\"cbaebabacd\\"` and `p = \\"abc\\"`, the function should return _true_ because `s` contains the substring \\"cba\\", which is an anagram of `p`.","solution":"from collections import Counter def check_inclusion(s, p): Check if any permutation of p is a substring in s. len_s, len_p = len(s), len(p) if len_p > len_s: return False p_counter = Counter(p) s_counter = Counter(s[:len_p]) if s_counter == p_counter: return True for i in range(len_p, len_s): s_counter[s[i]] += 1 start_char = s[i - len_p] s_counter[start_char] -= 1 if s_counter[start_char] == 0: del s_counter[start_char] if s_counter == p_counter: return True return False"},{"question":"Given a string `s` containing only characters `\'+\'` and `\'-\'`, and an integer `k`, you need to determine if it is possible to flip exactly `k` characters in the string to make all characters the same. A **flip** changes a `\'+\'` to `\'-\'` or vice versa. Return _the minimum number of flips required_ if it is possible to make all characters the same by flipping exactly `k` characters, and if it is not possible, return `-1`.","solution":"def min_flips(s, k): Determine the minimum number of flips required to make all characters the same by flipping exactly k characters. If not possible, return -1. n = len(s) if k > n: return -1 # can\'t flip more chars than the length of the string plus_count = s.count(\'+\') minus_count = s.count(\'-\') if plus_count == n or minus_count == n: return 0 # already all same min_flips_needed = min(plus_count, minus_count) # minimum number of flips needed to make all chars same if k < min_flips_needed * 2: return -1 # not enough flips to make all same return min_flips_needed"},{"question":"You are given a list of `n` integers `nums` and a list of `m` queries `queries` where each query is a pair of integers representing the start and end indices `[l, r]` (inclusive). For each query, determine the most frequent number in the subarray `nums[l:r+1]`. If there are multiple numbers with the same highest frequency, return the smallest number among them. Return a list of integers where each integer corresponds to the answer of the respective query.","solution":"from collections import Counter def most_frequent_number(nums, queries): Determines the most frequent number in subarrays defined by queries. If multiple numbers have the same highest frequency, the smallest number among them is returned. Parameters: nums (List[int]): List of integers. queries (List[Tuple[int, int]]): List of queries where each query is a pair [l, r]. Returns: List[int]: Result for each query. results = [] for l, r in queries: subarray = nums[l:r+1] counter = Counter(subarray) max_frequency = max(counter.values()) most_frequent = [num for num in counter if counter[num] == max_frequency] results.append(min(most_frequent)) return results"},{"question":"You are given an array of `n` integers `arr` representing the stock prices of a company in chronological order. You need to determine the maximum profit you can achieve by buying and selling the stock only once. Remember that you can only buy on one day and sell on a different day. If no profit can be achieved, return 0. Write a function to compute the maximum profit.","solution":"def max_profit(arr): Returns the maximum profit that can be achieved by buying and selling the stock only once. if not arr or len(arr) < 2: return 0 min_price = arr[0] max_profit = 0 for price in arr[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"Given the `head` of a linked list, write a function to _remove the `nth` node from the end of the list_ and return its head.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head, n): Removes the nth node from the end of the list. dummy = ListNode(0, head) first = dummy second = dummy # Move first n+1 steps ahead for _ in range(n + 1): first = first.next # Move both first and second until first reaches the end while first is not None: first = first.next second = second.next # Remove the nth node from end second.next = second.next.next return dummy.next"},{"question":"You are given `n` strings, each string representing a binary number. You need to find the maximum XOR value between any two of the given binary numbers. Return _the maximum XOR value that can be obtained by selecting exactly two of the given binary numbers_.","solution":"def binary_to_int(binary_str): Convert a binary string to an integer. return int(binary_str, 2) def max_xor_of_two_binaries(binaries): Finds the maximum XOR value between any two binary numbers from the list. max_xor = 0 num_ints = [binary_to_int(b) for b in binaries] for i in range(len(num_ints)): for j in range(i + 1, len(num_ints)): current_xor = num_ints[i] ^ num_ints[j] if current_xor > max_xor: max_xor = current_xor return max_xor"},{"question":"Given a matrix `grid` of size `n x m` where each cell contains an integer representing the height at that point, determine the maximum height a water drop can reach before moving to a lower height. A water drop can move from one cell to an adjacent cell (up, down, left, right) if and only if the height of the adjacent cell is lower than the current cell. The objective is to find the starting cell where the water drop can reach the highest possible height. Return _the coordinates of the starting cell (i, j)_ where the water drop can achieve the maximum height, sorted by row and then by column in case of ties.","solution":"def maximum_water_drop_height(grid): Returns the coordinates of the starting cell (i, j) where the water drop can achieve the maximum height. n = len(grid) m = len(grid[0]) def dfs(x, y, visited): if (x, y) in visited: return grid[x][y] visited.add((x, y)) max_height = grid[x][y] for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] < grid[x][y]: max_height = max(max_height, dfs(nx, ny, visited)) return max_height max_height_coord = None max_height = -1 for i in range(n): for j in range(m): visited = set() height = dfs(i, j, visited) if height > max_height or (height == max_height and (max_height_coord is None or (i, j) < max_height_coord)): max_height = height max_height_coord = (i, j) return max_height_coord"},{"question":"You are given a string `s` which contains only lowercase letters. Your task is to determine if you can **reorder** the characters in `s` to form a string where no two adjacent characters are the same. If possible, return the new reorganized string. If not possible, return an empty string. For example: - Given `s = \\"aab\\"`, one possible solution is `\\"aba\\"`. - Given `s = \\"aaab\\"`, return an empty string as it is not possible to reorder such that no two adjacent characters are the same.","solution":"from collections import Counter import heapq def reorganize_string(s): Determine if you can reorder the characters in `s` to form a string where no two adjacent characters are the same. If possible, return the new reorganized string. If not possible, return an empty string. # Step 1: Count the frequency of each character char_count = Counter(s) # Step 2: Create a max heap based on the character frequency max_heap = [(-freq, char) for char, freq in char_count.items()] heapq.heapify(max_heap) # Step 3: Try to build the result string result = [] prev_freq, prev_char = 0, \'\' while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If there was a previous character, add it back if it still has a remaining count if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update prev_freq and prev_char for the next round prev_freq, prev_char = freq + 1, char result_str = \'\'.join(result) # If the reorganized string length is equal to the original string length, return it if len(result_str) == len(s): return result_str else: return \\"\\""},{"question":"Given a binary tree, where each node contains an integer, implement an iterator class `BinaryTreeIterator` that iterates through the tree nodes in an in-order traversal. The class should support the following operations: - `BinaryTreeIterator(TreeNode root)` Initializes the iterator with the root of the binary tree. - `int next()` Returns the next smallest number in the tree. - `boolean hasNext()` Returns true if there are still nodes to traverse, otherwise returns false. Assume that: - The binary tree is defined with the class `TreeNode` as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - The `BinaryTreeIterator` should use `O(h)` memory, where `h` is the height of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreeIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def next(self) -> int: # Pop the top element from the stack topmost_node = self.stack.pop() # If the node has a right child, we push all the nodes from the right child\'s left subtree onto the stack if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self) -> bool: return len(self.stack) > 0"},{"question":"You are given an integer array `nums` containing `n` elements where `n` is even. Your task is to partition the array into two subsets `A` and `B` such that the sum of the elements in subset `A` is equal to the sum of the elements in subset `B`. Return `true` if such a partition is possible, and `false` otherwise. Note that each element in the array must be included in exactly one of the subsets.","solution":"def can_partition(nums): Determines if the array can be partitioned into two subsets with equal sum. Args: nums: List[int] - A list of integers Returns: bool - True if the partition is possible, False otherwise total_sum = sum(nums) # If the total sum is odd, it cannot be divided into two equal subsets if total_sum % 2 != 0: return False subset_sum = total_sum // 2 n = len(nums) # Create a dp table where dp[i] is True if a subset sum of i can be achieved dp = [False] * (subset_sum + 1) dp[0] = True # A subset with sum 0 is always possible for num in nums: # Traverse dp array from right to left to update the possible subset sums for i in range(subset_sum, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[subset_sum]"},{"question":"You are given an `m x n` integer matrix `matrix` with the following two properties: 1. Each row is sorted in non-decreasing order. 2. The first integer of each row is greater than the last integer of the previous row. Given an integer `target`, write an efficient algorithm to determine if `target` is in `matrix`. The algorithm should run in `O(log(m * n))` time complexity. Return a boolean value indicating whether the `target` exists in the matrix.","solution":"def search_matrix(matrix, target): Determines if the target is present in the given matrix. :param matrix: List[List[int]] - 2D matrix of integers :param target: int - the target number to search for :return: bool - True if target is found, False otherwise if not matrix or not matrix[0]: return False m, n = len(matrix), len(matrix[0]) left, right = 0, m * n - 1 while left <= right: mid = (left + right) // 2 mid_value = matrix[mid // n][mid % n] if mid_value == target: return True elif mid_value < target: left = mid + 1 else: right = mid - 1 return False"},{"question":"Given a string `s` representing a code snippet, decide if it contains valid usage of parentheses, brackets, and braces. For the string to be valid: - Open brackets must be closed in the correct order. - Each close bracket must match the type of the most recent unmatched open bracket of the same type. Return `true` if the string contains valid bracket usage and `false` otherwise. Note that an empty string is considered valid.","solution":"def is_valid_code_snippet(s): Checks if the given code snippet (string) has valid usage of parentheses, brackets, and braces. Args: s (str): Code snippet to check. Returns: bool: True if the code snippet is valid, False otherwise. stack = [] matching_brackets = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in matching_brackets.values(): stack.append(char) elif char in matching_brackets.keys(): if stack == [] or matching_brackets[char] != stack.pop(): return False return stack == []"},{"question":"You are given `numCourses` which represent a total of `numCourses` courses you have to take, labeled from `0` to `numCourses-1`. You are also given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must first take course `bi` before taking course `ai`. Return _the ordering of courses you should take to finish all courses._ If it is impossible to finish all courses, return an empty array.","solution":"from collections import defaultdict, deque def findOrder(numCourses, prerequisites): Returns the ordering of courses you should take to finish all courses. If it is impossible to finish all courses, return an empty array. # Create a graph and a degree array graph = defaultdict(list) indegree = [0] * numCourses # Build the graph and populate the indegree array for dest, src in prerequisites: graph[src].append(dest) indegree[dest] += 1 # Find all the starting nodes with no dependencies (indegree 0) queue = deque([i for i in range(numCourses) if indegree[i] == 0]) topo_order = [] # Process the nodes while queue: node = queue.popleft() topo_order.append(node) # Decrease the indegree of each neighbor for neighbor in graph[node]: indegree[neighbor] -= 1 # If the indegree becomes 0, add it to the queue if indegree[neighbor] == 0: queue.append(neighbor) # If topological order contains all the courses, return it if len(topo_order) == numCourses: return topo_order else: return []"},{"question":"Given an integer array `arr` and an integer `sum`, find the total number of continuous subarrays whose elements sum up to `sum`. A subarray is a contiguous non-empty sequence of elements within an array. Return the count of such subarrays.","solution":"def subarray_sum(arr, target): Finds the total number of continuous subarrays whose elements sum up to target. :param arr: List[int] - The input array of integers :param target: int - The target sum for the subarrays :return: int - The count of continuous subarrays summing up to target count = 0 current_sum = 0 prefix_sum = {0: 1} # Prefix sum dictionary to store sum frequencies for num in arr: current_sum += num if (current_sum - target) in prefix_sum: count += prefix_sum[current_sum - target] if current_sum in prefix_sum: prefix_sum[current_sum] += 1 else: prefix_sum[current_sum] = 1 return count"},{"question":"You are given a list of non-negative integers `nums` representing the amount of money of each house in a row. Each house is positioned linearly and adjacent houses cannot be robbed on the same night. Implement a function that returns the maximum amount of money you can rob without robbing two adjacent houses.","solution":"def rob(nums): Returns the maximum amount of money you can rob without robbing two adjacent houses. :param nums: List of non-negative integers representing the amount of money of each house in a row. :return: The maximum amount of money you can rob. if not nums: return 0 n = len(nums) if n == 1: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"You are given a list of `n` integers representing the heights of students standing in a row. Find and return the minimum number of students who need to be removed so that the remaining students\' heights form a non-decreasing sequence. A sequence is non-decreasing if `a[i] <= a[i+1]` for all `0 <= i < n-1`.","solution":"def min_removals_to_non_decreasing_heights(heights): Returns the minimum number of students who need to be removed so that the remaining students\' heights form a non-decreasing sequence. Args: heights (list of int): List of students\' heights. Returns: int: Minimum number of removals required. if not heights: return 0 n = len(heights) # Length of the longest increasing subsequence (LIS) lis = [1] * n for i in range(1, n): for j in range(0, i): if heights[i] >= heights[j]: lis[i] = max(lis[i], lis[j] + 1) # The minimum removals needed is the total number of students minus # the length of the longest increasing subsequence return n - max(lis)"},{"question":"Given a linked list, reverse the linked list in groups of `k` and return the modified list. `k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes in the last group is less than `k`, leave them as it is. For example, given the linked list `1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8` and `k = 3`, the linked list should be modified to `3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverseLinkedList(head, k): new_head, ptr = None, head while k > 0: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head count = 0 ptr = head while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversed_head = reverseLinkedList(head, k) head.next = reverseKGroup(ptr, k) return reversed_head return head"},{"question":"You are given an integer array `arr` of length `n`. A subarray of `arr` is defined as a **segment** of consecutive elements. A subarray is called **palindromic** if it reads the same forward and backward. Write a function that returns the length of the **longest palindromic subarray** in the given array `arr`. If there are multiple palindromic subarrays of the same maximum length, return the length of the first one that appears. For example, given the array `arr = [1, 2, 3, 2, 1, 6, 7, 6]`, the function should return `5` because the longest palindromic subarray is `[1, 2, 3, 2, 1]`.","solution":"def longest_palindromic_subarray_length(arr): Returns the length of the longest palindromic subarray. n = len(arr) if n == 0: return 0 max_length = 1 # Minimum length of a palindrome subarray is 1 (single element) start = 0 for i in range(n): # Odd length palindromes centered at arr[i] low, high = i, i while low >= 0 and high < n and arr[low] == arr[high]: current_length = high - low + 1 if current_length > max_length: max_length = current_length start = low low -= 1 high += 1 # Even length palindromes centered at arr[i] and arr[i+1] low, high = i, i + 1 while low >= 0 and high < n and arr[low] == arr[high]: current_length = high - low + 1 if current_length > max_length: max_length = current_length start = low low -= 1 high += 1 return max_length"},{"question":"Given a binary tree where each node contains a single digit (0-9), find the sum of all numbers formed by root-to-leaf paths. A root-to-leaf path is defined as a sequence of nodes starting from the root node and ending at any leaf node. Each path represents a number formed by concatenating the digits of the nodes along the path. Implement the `TreeSum` class with the following methods: - `TreeSum(Node root)` Initializes the `TreeSum` object with the root of the binary tree. - `int sumNumbers()` Returns the total sum of all numbers formed by root-to-leaf paths. Note: - The provided class `Node` should be assumed to exist and it represents a node in the binary tree with: - `int val` (the digit value of the node), - `Node left` (the left child of the node), - `Node right` (the right child of the node).","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class TreeSum: def __init__(self, root=None): self.root = root def sumNumbers(self): def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val if not node.left and not node.right: return current_number left_sum = dfs(node.left, current_number) right_sum = dfs(node.right, current_number) return left_sum + right_sum return dfs(self.root, 0)"},{"question":"Write a function `rotateString` that takes two strings `s` and `goal` and returns `true` if and only if `s` can become `goal` after some number of shifts on `s`. A shift on `s` consists of moving the leftmost character of `s` to the rightmost position. For example, if `s = \\"abcde\\"`, then it will be `bcdea` after one shift, and `cdeab` after two shifts.","solution":"def rotateString(s, goal): Returns True if and only if `s` can become `goal` after some number of shifts on `s`. return len(s) == len(goal) and goal in (s + s)"},{"question":"You are given an **m x n** integer matrix `grid`. Each element, `grid[i][j]`, represents the altitude at point `(i, j)`. You are also given an integer `effort`, which specifies the maximum allowed absolute difference in altitude between two consecutive points in any path. A path is defined as a sequence of points such that from each point `(i, j)`, you can move to any of the four cardinal directions (up, down, left, right), and you must remain within the boundaries of the matrix. Return _the minimum effort path from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)`, where the **maximum absolute difference** in altitude between two consecutive points in the path is minimized_. You can assume that there is at least one valid path in the given grid. Your task is to implement a function that follows this definition and meets the criteria to navigate from the start to the end point with the minimum effort required.","solution":"from heapq import heappush, heappop def minimum_effort_path(grid): Returns the minimum effort required to navigate from the top-left to the bottom-right corner of the grid ensuring the maximum allowed absolute difference in altitude between two consecutive points in the path is minimized. rows, cols = len(grid), len(grid[0]) efforts = [[float(\'inf\')] * cols for _ in range(rows)] efforts[0][0] = 0 min_heap = [(0, 0, 0)] # (effort, x, y) # Directions for right, down, left, and up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while min_heap: current_effort, x, y = heappop(min_heap) if x == rows - 1 and y == cols - 1: return current_effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols: new_effort = max(current_effort, abs(grid[nx][ny] - grid[x][y])) if new_effort < efforts[nx][ny]: efforts[nx][ny] = new_effort heappush(min_heap, (new_effort, nx, ny))"},{"question":"Given an array of integers representing the height of rainwater bars, calculate the maximum amount of water that can be trapped after raining. The array\'s elements represent the height of the bars. Water can only be trapped between bars, and each bar must be able to hold water on top of it. The amount of water trapped between the bars is determined by the smaller of the two heights on either side of the bar, minus the height of the bar itself. Return _the maximum amount of water that can be trapped among the bars_.","solution":"def trap(height): Given an array of integers representing the height of rainwater bars, calculate the maximum amount of water that can be trapped after raining. :param height: List[int], array of non-negative integers representing the heights of the bars. :return: int, the maximum amount of water that can be trapped. if not height or len(height) < 3: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] trapped_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) trapped_water += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) trapped_water += max(0, right_max - height[right]) return trapped_water"},{"question":"You are given an integer array `costs` where `costs[i]` is the cost of the ith item in a store, and an integer `coins` which represents the total coins you have. You can buy the items in any order. Compute the maximum number of distinct items you can buy without exceeding the given amount of coins. Return the number of items you can fully purchase.","solution":"def max_items(costs, coins): Returns the maximum number of distinct items that can be purchased without exceeding the given number of coins. :param costs: List of integers representing the cost of each item :param coins: Integer representing the total coins available :return: Integer representing the maximum number of distinct items that can be purchased costs.sort() items_bought = 0 for cost in costs: if coins >= cost: coins -= cost items_bought += 1 else: break return items_bought"},{"question":"You are given a list of `n` integers, where each integer represents the height of a candle. Alvin wants to celebrate his birthday by blowing out the tallest candles. Write a function that returns the number of candles that are the tallest among the given list. If there are multiple tallest candles, your function should return the count of all such candles. For example, given the list `[4, 4, 1, 3]`, the function should return `2` because there are two candles of height `4`, which is the tallest.","solution":"def tallest_candles(candles): Returns the number of the tallest candles. if not candles: return 0 tallest_height = max(candles) tallest_count = candles.count(tallest_height) return tallest_count"},{"question":"You are given an array of integers `nums` where each element is a positive integer. Your task is to find the smallest positive integer that does not appear in `nums`. The solution must be efficient in terms of time and space complexity. Return the smallest positive integer that is missing from the array.","solution":"def first_missing_positive(nums): Returns the smallest positive integer that does not appear in the array nums. n = len(nums) # Place each number in its right place if possible for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Find the first place where the index doesn\'t match the value for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"Write a function that takes a list of integers `coins` and an integer `amount` representing the total amount of money. Your task is to determine the minimum number of coins required to make up that amount. If it is not possible to make up the amount using the given coins, return `-1`. You may assume that you have an infinite number of each type of coin. Implement the function `minCoins(coins, amount)` that returns the minimum number of coins needed to make up the given amount.","solution":"def minCoins(coins, amount): Returns the minimum number of coins required to make up the given amount. If it\'s not possible to make up the amount with the given coins, returns -1. # Initialize the DP array with amount + 1 (a value impossible to reach) dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 # Update the DP array based on the coins available for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # If dp[amount] has not been updated, return -1 return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"You are given a list of non-negative integers `nums` and an integer `target`. Write a function to find the number of distinct continuous subarrays within `nums` where the sum of the subarray is less than `target`. Return _the total number of such subarrays_. A subarray is a contiguous **non-empty** sequence of elements within an array.","solution":"def count_subarrays(nums, target): Returns the number of distinct continuous subarrays where the sum of the subarrays is less than the target. n = len(nums) subarray_count = 0 for start in range(n): current_sum = 0 for end in range(start, n): current_sum += nums[end] if current_sum < target: subarray_count += 1 else: break return subarray_count"},{"question":"You are given an m x n matrix `grid` consisting of integers. Each integer represents the elevation at that point. The `grid` represents a landscape where water can flow from a cell to its four adjacent cells (north, south, east, west) if and only if the elevation of the flowing cell is greater than or equal to the elevation of the adjacent cell. Water can flow from any cell to the Pacific Ocean on the left and top edges of the grid, and to the Atlantic Ocean on the right and bottom edges of the grid. Return a list of grid coordinates where water can flow to both the Pacific and Atlantic Oceans. Implement a function `def pacificAtlantic(self, grid: List[List[int]]) -> List[List[int]]:` that returns the list of grid coordinates.","solution":"from typing import List def pacificAtlantic(grid: List[List[int]]) -> List[List[int]]: if not grid or not grid[0]: return [] m, n = len(grid), len(grid[0]) pacific_reachable = [[False] * n for _ in range(m)] atlantic_reachable = [[False] * n for _ in range(m)] def dfs(x: int, y: int, reachable: List[List[bool]]): reachable[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not reachable[nx][ny] and grid[nx][ny] >= grid[x][y]: dfs(nx, ny, reachable) for i in range(m): dfs(i, 0, pacific_reachable) dfs(i, n - 1, atlantic_reachable) for j in range(n): dfs(0, j, pacific_reachable) dfs(m - 1, j, atlantic_reachable) result = [] for i in range(m): for j in range(n): if pacific_reachable[i][j] and atlantic_reachable[i][j]: result.append([i, j]) return result"},{"question":"You have an array `weights` containing the weights of `n` stones. Each stone can be represented as an integer weight. You aim to perform the following operation to reduce the number of stones: 1. Select the two heaviest stones and smash them together. 2. If they have equal weight, both stones are destroyed. 3. If they have different weights, the stone with the larger weight is destroyed, and the stone with the smaller weight\'s integer weight becomes the difference of the two. Return _the weight of the last remaining stone (if any), otherwise return 0_.","solution":"import heapq def last_stone_weight(weights): This function computes the weight of the last remaining stone after smashing the two heaviest stones repeatedly until one or zero stones are left. Args: weights : List[int] : A list containing the weight of the stones. Returns: int : The weight of the last remaining stone or 0 if no stones are left. # Convert all weights to negative to use the min heap property of heapq as max heap. max_heap = [-weight for weight in weights] heapq.heapify(max_heap) while len(max_heap) > 1: # Take out the two largest stones first = -heapq.heappop(max_heap) second = -heapq.heappop(max_heap) if first != second: # If they are not the same, push the difference back into the heap heapq.heappush(max_heap, -(first - second)) return -max_heap[0] if max_heap else 0"},{"question":"You are given two strings `s` and `t` of equal length. You can change `s` to `t` by changing characters one by one. The set of allowed character changes is specified by a given 2D array `allowedChanges`, where `allowedChanges[i] = [a, b]` means you can change character `a` to character `b`. Return whether you can transform `s` into `t` using the allowed character changes. If it is possible, return `true`; otherwise, return `false`.","solution":"def canTransform(s, t, allowedChanges): Determines if string s can be transformed into string t using the allowed character changes. :param s: Initial string to be transformed :param t: Target string after transformation :param allowedChanges: 2D list of allowed character changes :return: True if s can be transformed into t, else False # Convert allowedChanges to a dictionary for quick lookup allowed_dict = {} for a, b in allowedChanges: if a not in allowed_dict: allowed_dict[a] = set() allowed_dict[a].add(b) # Check each character in s can be transformed to the corresponding character in t for sc, tc in zip(s, t): if sc != tc and (sc not in allowed_dict or tc not in allowed_dict[sc]): return False return True"},{"question":"You are given an integer array `nums` and an integer `target`. Each element in the `nums` array can be used multiple times to form different combinations. Return _the total number of **unique** combinations_ that add up to `target`. Note that different orders of the same combination are considered the same. For example, if `nums = [2, 3, 6, 7]` and `target = 7`, the possible combinations are: - `[7]` - `[2, 2, 3]` Thus, the output should be `2`.","solution":"def combinationSum(nums, target): Returns the total number of unique combinations from the given list that add up to the target. def backtrack(start, remaining): if remaining == 0: return 1 if remaining < 0: return 0 total_combinations = 0 for i in range(start, len(nums)): total_combinations += backtrack(i, remaining - nums[i]) return total_combinations nums.sort() # Sort the numbers to handle duplicates return backtrack(0, target)"},{"question":"A **subarray** is defined as a contiguous non-empty sequence of elements within an array. An array `arr` of length `n` is given. You are tasked with finding the length of the longest subarray whose elements can be rearranged to form a **palindrome**. A palindrome is a sequence that reads the same backward as forward. Return _an integer representing the length of the longest subarray that can be rearranged to form a palindrome_.","solution":"def longest_palindromic_subarray_length(arr): from collections import Counter def can_form_palindrome(counter): odd_count = sum(1 for x in counter.values() if x % 2 != 0) return odd_count <= 1 def subarray_length(start, end): subarray = arr[start:end+1] counter = Counter(subarray) if can_form_palindrome(counter): return end - start + 1 return 0 max_length = 0 n = len(arr) for i in range(n): for j in range(i, n): max_length = max(max_length, subarray_length(i, j)) return max_length"},{"question":"Given a string `s` consisting of lowercase letters and the `target` length `n`, return the number of substrings of `s` that have exactly `n` unique characters. If there are no such substrings, return `0`.","solution":"def count_substrings_with_n_unique_chars(s, n): Returns the number of substrings of `s` that have exactly `n` unique characters. :param s: str: Input string consisting of lowercase letters :param n: int: Target number of unique characters in substrings :return: int: Number of substrings with exactly `n` unique characters from collections import defaultdict def unique_char_count_in_window(window): return len(set(window)) total_substrings = 0 for start in range(len(s)): char_count = defaultdict(int) unique_chars = 0 for end in range(start, len(s)): char = s[end] if char_count[char] == 0: unique_chars += 1 char_count[char] += 1 if unique_chars == n: total_substrings += 1 elif unique_chars > n: break return total_substrings"},{"question":"You are given an array of `n` integers representing the heights of a series of towers. Each tower is made of identical blocks stacked one on top of the other. Also, you are given an integer `k` representing the height of blocks you can remove each time. Your task is to determine the maximum number of complete towers that remain after removing a total of `m` height units from the towers. Note that you can remove blocks from any of the towers, but each removal reduces the height of a tower by exactly `k` units. Return the maximum number of complete towers remaining after removing `m` height units from the towers.","solution":"def max_complete_towers(heights, k, m): Determine the maximum number of complete towers that remain after removing a total of `m` height units from the towers. Each removal reduces the height of a tower by `k` units. Parameters: heights (list of ints): Heights of the towers. k (int): Height of blocks that can be removed each time. m (int): Total height units to remove. Returns: int: The maximum number of complete towers remaining. heights.sort(reverse=True) # Sorting to maximize the number of full towers kept for i in range(len(heights)): while m >= k and heights[i] >= k: heights[i] -= k m -= k return sum(1 for height in heights if height > 0)"},{"question":"You are given a string `wall` representing a wall containing a mixture of bricks and spaces. The string consists of characters \'B\' representing a brick, and \'.\' representing an empty space. You also have an integer `k` which denotes the length of a perfectly aligned brick pattern we need to fit into the wall. A brick pattern of length `k` consists of exactly `k` consecutive \'B\' characters. Determine the maximum number of such perfectly aligned brick patterns that can fit into the wall without overlapping the patterns. If there are any spaces (\'.\') within length `k`, it means the pattern cannot fit in that spot. Return the maximum number of non-overlapping perfectly aligned brick patterns that can be identified in the wall.","solution":"def count_brick_patterns(wall, k): Returns the maximum number of non-overlapping perfectly aligned brick patterns of length `k` that can fit into the wall string. Parameters: wall (str): A string consisting of \'B\' and \'.\'. k (int): The length of the brick pattern. Returns: int: Maximum number of non-overlapping brick patterns of length `k`. count = 0 i = 0 while i <= len(wall) - k: if wall[i:i+k] == \'B\' * k: count += 1 i += k # Skip past this pattern to avoid overlap else: i += 1 return count"},{"question":"You are given a string `s` and an integer `k`. You may choose any substring of `s` and repeat it exactly `k` times. Return the lexicographically smallest string that can be obtained after performing the above operation. For example, given the string `s = \\"abcd\\"` and `k = 3`, the possible strings formed after repeating any substring exactly `k` times are: `\\"aaab\\"` by repeating \\"a\\" 3 times. `\\"bbbc\\"` by repeating \\"b\\" 3 times. `\\"ccc\\"` by repeating \\"c\\" 3 times. `\\"dd\\"` by repeating \\"d\\" 3 times. `\\"aa\\"` by repeating \\"a\\" 2 times. `\\"bb\\"` by repeating \\"b\\" 2 times. `\\"cc\\"` by repeating \\"c\\" 2 times. `\\"dd\\"` by repeating \\"d\\" 1 time. Thus, the lexicographically smallest string is `\\"aa\\".`","solution":"def get_lexicographically_smallest_string(s, k): Returns the lexicographically smallest string obtainable by repeating a substring exactly k times. :param s: The input string. :param k: The number of times to repeat a substring. :return: The lexicographically smallest string. smallest_string = min(s[i] * k for i in range(len(s))) return smallest_string"},{"question":"You are given a list of integers `nums`. A \\"peak\\" element is an element that is strictly greater than its neighbors. For a list with multiple peak elements, return the index of any one of the peak elements. You can assume the list does not contain duplicate elements. Also note that `nums[-1]` and `nums[n]` are considered to be negative infinity (`-∞`). Return the index of any peak element. You may write a function that runs in O(log n) time.","solution":"def find_peak_element(nums): Finds the index of a peak element in the list nums. A peak element is an element that is strictly greater than its neighbors. This function runs in O(log n) time. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"You are given an array of positive integers representing the number of coins in each pile. Every turn, you must choose two piles with the largest number of coins and remove one coin from each of these piles. The game stops when there are fewer than two piles with coins left. Write a function to return the count of turns taken to remove coins until the game stops.","solution":"import heapq def count_turns_to_remove_coins(piles): Return the number of turns taken to remove coins until the game stops. # Convert the piles to a max heap (invert values to use heapq as max-heap) max_heap = [-pile for pile in piles if pile > 0] heapq.heapify(max_heap) turns = 0 while len(max_heap) > 1: # Pop two largest piles largest = -heapq.heappop(max_heap) second_largest = -heapq.heappop(max_heap) # Remove one coin from each largest -= 1 second_largest -= 1 # Add back to heap if they still have coins if largest > 0: heapq.heappush(max_heap, -largest) if second_largest > 0: heapq.heappush(max_heap, -second_largest) turns += 1 return turns"},{"question":"Given the head of a linked list, remove the nth node from the end of the list and return its head. Try to do this in one pass through the list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head: ListNode, n: int) -> ListNode: # Create a dummy node to handle edge cases dummy = ListNode(0, head) first = second = dummy # Move first pointer so that it maintains a gap of n+1 nodes with the second for _ in range(n + 1): if first: first = first.next # Move first to the end, maintaining the gap while first: first = first.next second = second.next # Skip the desired node second.next = second.next.next return dummy.next"},{"question":"A company has `n` projects numbered from `1` to `n`. Each project `i` takes `days[i]` days to complete. The projects can be worked on by one employee at a time and they cannot be split among multiple employees. However, employees can work on the projects in any order. Given an integer `k` representing the number of employees, return _the minimum number of days required to finish all the projects_. Please output your response in the form: ```python def min_days_to_complete_projects(days, k): pass # Example usage: # days = [4, 2, 3, 5] # k = 2 # min_days_to_complete_projects(days, k) should return 6 ```","solution":"def min_days_to_complete_projects(days, k): Returns the minimum number of days required to finish all the projects given the number of employees. def can_complete_in_days(days, k, limit): employees_required = 1 current_load = 0 for day in days: if current_load + day > limit: employees_required += 1 current_load = day if employees_required > k: return False else: current_load += day return True if k >= len(days): return max(days) left, right = max(days), sum(days) while left < right: mid = (left + right) // 2 if can_complete_in_days(days, k, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given two strings `s` and `t`. You need to determine if `s` can be transformed into `t` by deleting some (possibly zero) characters from `s` without changing the order of the remaining characters. Return _true_ if it is possible to transform `s` into `t`, otherwise return _false_. For example, given `s = \\"ace\\"` and `t = \\"abcde\\"`, the function should return `true` because you can delete the characters \'b\' and \'d\' from `t` to form `s`. But if `s = \\"aec\\"` and `t = \\"abcde\\"`, the function should return `false` because there is no way to delete characters from `t` to form `s`.","solution":"def is_subsequence(s, t): Determine if s can be transformed into t by deleting some (possibly zero) characters from t without changing the order of the remaining characters. Parameters: s (str): The target string to be formed. t (str): The source string from which characters can be deleted. Returns: bool: True if s can be transformed into t, otherwise False. it = iter(t) return all(char in it for char in s)"},{"question":"You are given a string `s` consisting of lowercase English letters. You can convert `s` to a new string by rearranging its characters. Return the lexicographically smallest string achievable by making at most `k` swaps between any pair of characters in `s`. If multiple optimal strings are possible, return any of them.","solution":"def smallest_string_with_k_swaps(s, k): Returns the lexicographically smallest string possible by making at most k swaps between any pair of characters in s. sorted_s = sorted(s) return \'\'.join(sorted_s)"},{"question":"You are given a `0-indexed` array of positive integers `nums`. Each integer in the array represents a weighted stone. You need to combine some or all of these stones by repeatedly performing the following operation: Select any two stones and combine them into a new stone with a weight equal to the sum of the weights of the selected stones. The new stone replaces the two selected stones. This process continues until only one stone remains in the array, which has the accumulated weight of all previously combined stones. Return _the minimum possible weight of the final stone_.","solution":"def min_final_stone_weight(nums): Returns the minimum possible weight of the final stone by summing all weights. return sum(nums)"},{"question":"Given a non-empty array of integers `nums` representing the number of units of gold in different gold mines, and an integer `k`, find the maximum sum of gold you can acquire by visiting exactly `k` mines. Each visit allows you to collect gold from a contiguous subarray of length up to `k`. Return _the maximum sum of gold you can collect_. Note that you must choose a subarray exactly `k` elements long, and the subarray can start from any position in the given array.","solution":"def max_gold(nums, k): Returns the maximum sum of gold collected from exactly k mines. Parameters: nums (List[int]): List of integers representing the amount of gold in each mine. k (int): The number of contiguous mines to visit. Returns: int: The maximum sum of gold collected from exactly k mines. n = len(nums) if n < k: return 0 # Compute sum of the first k elements max_sum = current_sum = sum(nums[:k]) # Use sliding window technique to find the maximum sum of any k contiguous elements for i in range(k, n): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given a string `s` which represents an encoded message where each group of digits corresponds to a letter with \'1\' -> \'A\', \'2\' -> \'B\', ..., \'26\' -> \'Z\', return _the total number of ways to decode the message_. You can assume that the input string contains only numeric characters and is a valid encoding without leading zeros.","solution":"def num_decodings(s): Returns the number of ways to decode the given encoded message. :param s: A string representing the encoded message :return: An integer representing the total number of ways to decode the message if not s: return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != \'0\': dp[i] += dp[i - 1] if i > 1 and \'10\' <= s[i - 2:i] <= \'26\': dp[i] += dp[i - 2] return dp[n]"},{"question":"Given an integer array `arr` where each element appears exactly twice, except for one element which appears exactly once. Return _the element that appears only once_. Implement the function `int findUnique(int[] arr)` that performs this task.","solution":"def findUnique(arr): Returns the element that appears only once in the array. Args: arr (list): List of integers where every element appears twice except one element which appears once. Returns: int: The unique element. # Utilizing XOR property: n ^ n = 0 and n ^ 0 = n unique = 0 for num in arr: unique ^= num return unique"},{"question":"You are given an integer array `height` representing the heights of buildings in a city where `height[i]` represents the height of the `i-th` building. A building `i` can see another building `j` if and only if the height from building `i` to `j` does not decrease and building `j` is taller than building `i`. Return _a list of lists_ where the `i-th` list contains the indices of all buildings that `i-th` building can see, ordered by distance from building `i` (from nearest to farthest).","solution":"def visible_buildings(height): Returns a list of lists where the i-th list contains the indices of all buildings that the i-th building can see, ordered by distance from the i-th building. result = [] n = len(height) for i in range(n): can_see = [] max_height = -1 for j in range(i + 1, n): if height[j] > height[i] and height[j] > max_height: can_see.append(j) max_height = height[j] result.append(can_see) return result"},{"question":"You are given a string `s` which consists of lowercase English letters. You are allowed to perform the following operation any number of times: - Choose any two adjacent characters in the string and replace them with their \\"sorted\\" version, meaning the lexicographically smaller character comes first. Return the lexicographically smallest string that can be obtained by applying the above operation any number of times. For example, for the input string `\\"cbad\\"`, you can perform the following operations to get the lexicographically smallest string: 1. Swap \\"cb\\" to get `\\"bcad\\"`. 2. Swap \\"ba\\" to get `\\"abdc\\"`. 3. Swap \\"bd\\" to get `\\"abdc\\"` (no change as \\"bd\\" is already sorted). 4. Swap \\"dc\\" to get `\\"abcd\\"`. Hence, the final answer for `\\"cbad\\"` is `\\"abcd\\"`.","solution":"def smallest_lexicographical_string(s): Returns the lexicographically smallest string that can be obtained by sorting adjacent characters. return \'\'.join(sorted(s))"},{"question":"You are given a string `str` containing only lowercase letters. You are also given an integer `x` such that `1 ≤ x ≤ length of str`. We define a valid substring as one that contains at least `x` distinct characters. Return the length of the smallest valid substring. If no valid substring exists, return `-1`.","solution":"def smallest_valid_substring(s, x): Returns the length of the smallest valid substring that contains at least x distinct characters. If no valid substring exists, return -1. if x > len(s): return -1 n = len(s) min_length = float(\'inf\') for i in range(n): distinct_chars = set() for j in range(i, n): distinct_chars.add(s[j]) if len(distinct_chars) >= x: min_length = min(min_length, j - i + 1) break return -1 if min_length == float(\'inf\') else min_length"},{"question":"Given the `root` of a binary tree, return a list of lists where each inner list represents a level in the tree with the values of nodes at that level from left to right. Ensure the list is ordered from the root level to the lowest level. Implement a `levelOrder` function that performs this task.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root): Returns a list of levels with values of nodes at each level from left to right. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"You are given a list of integers `nums` and an integer `k`. Your task is to split the list into `k` consecutive subarrays such that the difference between the maximum sum of any subarray and the minimum sum of any subarray is minimized. Return the minimum possible difference. For example, given `nums = [1, 2, 3, 4, 5]` and `k = 2`, you could split them into `[1, 2, 3]` and `[4, 5]` or `[1, 2]` and `[3, 4, 5]`, and the difference between the sums of these subarrays should be minimized.","solution":"def split_array_min_diff(nums, k): from itertools import accumulate import math def can_split(max_sum): subarray_count, current_sum = 1, 0 for num in nums: if current_sum + num > max_sum: subarray_count += 1 current_sum = num if subarray_count > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) result = right while left <= right: mid = (left + right) // 2 if can_split(mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"You are given a list of words and a number `k`. Your task is to find the `k` most frequent words in the list. If multiple words have the same frequency, return them in lexicographical order. Return the list of `k` most frequent words in descending order of their frequencies.","solution":"from collections import Counter def k_most_frequent_words(words, k): Returns the k most frequent words in descending order of frequency. If multiple words have the same frequency, returns them in lexicographical order. :param words: List of words :param k: Number of most frequent words to return :return: List of k most frequent words count = Counter(words) sorted_words = sorted(count.items(), key=lambda item: (-item[1], item[0])) return [word for word, freq in sorted_words[:k]]"},{"question":"Given a matrix `grid` containing only 0s and 1s, where `0` represents an empty cell and `1` represents a blocked cell, return _the length of the shortest path from the top-left corner to the bottom-right corner_, moving only up, down, left, or right. If no such path exists, return -1. The top-left corner is at `(0, 0)` and the bottom-right corner is at `(m-1, n-1)`, where `m` and `n` are the number of rows and columns in `grid`, respectively.","solution":"from collections import deque def shortestPathBinaryMatrix(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner in a binary matrix. if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # Using a queue to perform BFS queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, distance = queue.popleft() if x == m - 1 and y == n - 1: return distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, distance + 1)) return -1"},{"question":"Given a string `expression` containing only characters `+`, `-`, `(`, `)`, and digits `0-9`, return `true` if the parentheses are **balanced** in the mathematical expression, and `false` otherwise. A string is considered balanced if for every opening parenthesis `(` there is a corresponding closing parenthesis `)`, and the pairs of parentheses are well-nested.","solution":"def is_balanced(expression): Checks if the parentheses in the given expression are balanced. Parameters: expression (str): The input string containing mathematical expressions with parentheses. Returns: bool: True if the parentheses are balanced, False otherwise. stack = [] for char in expression: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"You are given an array of integers `nums` and a **positive** integer `m`. Your task is to find a subarray of `nums` that contains **at most** `m` distinct integers and has the maximum sum among all such subarrays. Return _the sum of this subarray_. A **subarray** is a contiguous part of an array formed by deleting neither elements from the beginning nor from the end of the array.","solution":"def max_sum_subarray_with_m_distinct(nums, m): Finds the maximum sum of a subarray that contains at most \'m\' distinct integers. if not nums or m <= 0: return 0 left = 0 current_sum = 0 max_sum = 0 distinct_count = {} for right, num in enumerate(nums): current_sum += num if num in distinct_count: distinct_count[num] += 1 else: distinct_count[num] = 1 while len(distinct_count) > m: current_sum -= nums[left] distinct_count[nums[left]] -= 1 if distinct_count[nums[left]] == 0: del distinct_count[nums[left]] left += 1 max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given a **binary tree**, implement an algorithm to find the maximum value at each level of the tree. The binary tree is represented using a `TreeNode` class, where each node contains a value and references to its left and right children. Return the result as an array of integers, where the ith element is the maximum value at the ith level of the binary tree.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_max_at_each_level(root): Find the maximum value at each level of the binary tree. :param root: TreeNode, the root of the binary tree :return: List[int], a list of maximum values at each level if not root: return [] queue = deque([root]) result = [] while queue: level_size = len(queue) max_value = float(\'-inf\') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"You are given an integer array `arr` of length `n` and an integer `k`. Split the integer array into exactly `k` non-empty subsets such that the maximum sum of any subset is as small as possible. Return the minimum possible value of the maximum sum of the `k` subsets.","solution":"def can_partition(nums, k, max_sum): subset_sums = [0] * k return backtrack(0, nums, subset_sums, k, max_sum) def backtrack(index, nums, subset_sums, k, max_sum): if index == len(nums): return True for i in range(k): if subset_sums[i] + nums[index] <= max_sum: subset_sums[i] += nums[index] if backtrack(index + 1, nums, subset_sums, k, max_sum): return True subset_sums[i] -= nums[index] if subset_sums[i] == 0: break return False def split_array_into_subsets(arr, k): left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_partition(arr, k, mid): right = mid else: left = mid + 1 return left"},{"question":"Given an integer array `nums` and an integer `k`, where `1 <= k <= len(nums)`, find the `k`th largest element in the array. The `k`th largest element in an array is the `k`th largest element when the array is sorted in non-increasing order. Return _the `k`th largest element in the array_. Implement your solution to have a time complexity better than `O(n log n)`.","solution":"import heapq def findKthLargest(nums, k): Returns the k-th largest element in the array nums. Parameters: nums (List[int]): The array of integers. k (int): The k-th position to find in the sorted order. Returns: int: The k-th largest element in the array. # Use a min-heap of size k to find the k-th largest element min_heap = nums[:k] heapq.heapify(min_heap) # Converts the list to a heap in O(k) time. for num in nums[k:]: if num > min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, num) return min_heap[0]"},{"question":"Given a binary string `s`, return the **minimum number of flips** needed to make the string monotonically increasing. A binary string is monotonically increasing if it consists of some number of \'0\'s (possibly none), followed by some number of \'1\'s (also possibly none). In one flip, you can change a \'0\' to a \'1\' or vice versa.","solution":"def min_flips_mono_incr(s: str) -> int: Returns the minimum number of flips needed to make the binary string monotone increasing. n = len(s) ones_count = [0] * (n + 1) # Compute the number of ones up to each position for i in range(1, n + 1): ones_count[i] = ones_count[i - 1] + (1 if s[i - 1] == \'1\' else 0) min_flips = float(\'inf\') # Try every possible point to split the string into all 0s and all 1s for j in range(n + 1): # flips to make the first j chars all 0s + flips to make the rest chars all 1s flips = ones_count[j] + (n - j - (ones_count[n] - ones_count[j])) min_flips = min(min_flips, flips) return min_flips"},{"question":"You are given an array `arr` of positive integers. An integer `m` is called a **mountain peak** if `arr[m - 1] < arr[m] > arr[m + 1]`. Your task is to find the length of the longest subarray which forms a **mountain sequence**. A **mountain sequence** is defined as a subarray that has at least one mountain peak and strictly increases until the peak and then strictly decreases. If there is no mountain sequence in the array, return 0.","solution":"def longest_mountain(arr): Returns the length of the longest subarray that forms a mountain sequence. A mountain sequence has at least one peak such that it strictly increases until the peak and then strictly decreases. :param arr: List of positive integers. :return: Length of the longest mountain sequence. If there is no mountain sequence, return 0. n = len(arr) if n < 3: return 0 max_length = 0 for i in range(1, n - 1): if arr[i - 1] < arr[i] > arr[i + 1]: # Found a mountain peak left = i - 1 right = i + 1 # Expand to the left while left > 0 and arr[left - 1] < arr[left]: left -= 1 # Expand to the right while right < n - 1 and arr[right + 1] < arr[right]: right += 1 # Calculate current mountain length current_length = right - left + 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given a 2D integer array `intervals` where each `intervals[i] = [start_i, end_i]` represents the start and end of the `ith` interval. The intervals are non-overlapping. Insert a new interval `newInterval = [start_n, end_n]` into `intervals` such that the list of intervals remains non-overlapping and sorted in ascending order by start time. Merge overlapping intervals if necessary. Return the updated list of non-overlapping intervals after inserting and merging the new interval.","solution":"def insert_and_merge(intervals, new_interval): Inserts a new interval into a list of non-overlapping intervals and merges if necessary. Parameters: intervals (List[List[int]]): The original list of non-overlapping intervals. new_interval (List[int]): The new interval to insert. Returns: List[List[int]]: The updated list of non-overlapping intervals. merged = [] i = 0 n = len(intervals) # Add all the intervals ending before new_interval starts while i < n and intervals[i][1] < new_interval[0]: merged.append(intervals[i]) i += 1 # Merge all overlapping intervals to one considering new_interval while i < n and intervals[i][0] <= new_interval[1]: new_interval[0] = min(new_interval[0], intervals[i][0]) new_interval[1] = max(new_interval[1], intervals[i][1]) i += 1 merged.append(new_interval) # Add all the remaining intervals while i < n: merged.append(intervals[i]) i += 1 return merged"},{"question":"You are given an array of integers `heights` representing the height of buildings standing in a street. The distance between adjacent buildings is always 1 unit. You are standing at the rightmost end of the street and you can \'see\' a building if there is no building higher than or equal to it between your current position and that building. Return an integer array containing the indices of the buildings you can see in the order you see them while scanning from the rightmost end to the leftmost end. The indices should be 0-based.","solution":"def can_see_buildings(heights): Returns the indices of buildings that can be seen from the rightmost end of the street. Args: heights (list of int): A list of integers representing the heights of buildings. Returns: list of int: A list of indices of buildings that can be seen from rightmost to leftmost. if not heights: return [] visible_indices = [] max_height_so_far = -1 for i in range(len(heights) - 1, -1, -1): if heights[i] > max_height_so_far: visible_indices.append(i) max_height_so_far = heights[i] return visible_indices[::-1]"},{"question":"You are given a string `s` consisting of characters \'a\', \'b\', and \'?\' where \'?\' can be replaced by either \'a\' or \'b\'. Your task is to determine if it is possible to replace all the \'?\' characters in such a way that the resulting string does not contain the substring \\"aba\\". Return `True` if it is possible and `False` otherwise.","solution":"def can_avoid_aba(s): Determines if it is possible to replace \'?\' in such a way that the resulting string does not contain the substring \'aba\'. s = list(s) # Convert the string to a list for easier manipulation for i in range(len(s)): if s[i] == \'?\': if (i > 1 and s[i-2:i] == [\'a\', \'b\']): s[i] = \'b\' # Avoid forming \'aba\' else: s[i] = \'a\' # Check if the final string contains \'aba\' final_string = \'\'.join(s) return \'aba\' not in final_string"},{"question":"You are given a matrix `grid` of size `m x n` consisting of non-negative integers. You can perform the following operation: choose any cell and reduce its value to any non-negative integer. An operation is defined as modifying the value of one cell. Your task is to minimize the total number of operations required so that each path from the top-left cell `(0, 0)` to the bottom-right cell `(m-1, n-1)` has the same sum of values. A path is defined as a sequence of cells where you can only move right or down at each step. Return the minimum number of operations needed to achieve this condition.","solution":"from collections import defaultdict from itertools import combinations def min_operations_to_equalize_path_sums(grid): Calculate the minimum number of operations required to make all (0, 0) -> (m-1, n-1) paths in the grid have the same sum. m, n = len(grid), len(grid[0]) path_sums = defaultdict(list) def dfs(x, y, current_sum): Depth-first search to find all path sums. if x == m - 1 and y == n - 1: path_sums[current_sum].append((x, y)) return if x + 1 < m: dfs(x + 1, y, current_sum + grid[x + 1][y]) if y + 1 < n: dfs(x, y + 1, current_sum + grid[x][y + 1]) dfs(0, 0, grid[0][0]) min_operations = float(\'inf\') for sum1, sum2 in combinations(path_sums.keys(), 2): operation_count = 0 for path1 in path_sums[sum1]: for path2 in path_sums[sum2]: if path1 != path2: operation_count += abs(sum1 - sum2) min_operations = min(min_operations, operation_count) return min_operations if min_operations != float(\'inf\') else 0"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` integers. Your task is to find the **smallest positive integer** that is **missing** from the array. You must complete this task with a time complexity of O(n) and without using extra space beyond the input array itself. Return the smallest positive integer that is missing from the array.","solution":"def first_missing_positive(nums): Finds the smallest positive integer that is missing from the array. Parameters: - nums (list): The list of integers. Returns: - int: The smallest positive missing integer. n = len(nums) # First pass to mark numbers (those which are outside the range) and # replace them with a number outside the range of interest (e.g., n+1) for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Mark indices as negative to show which positive numbers are present for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # The first index which is not negative represents the missing positive number for i in range(n): if nums[i] > 0: return i + 1 # All numbers from 1 to n are present return n + 1"},{"question":"You are given an integer array `heights` representing the heights of buildings in a city from left to right. A building can see the sunset if it is not blocked by a taller or equal height building to its right. Write a function that returns an array `answer` where `answer[i]` is `true` if the building at index `i` can see the sunset, and `false` otherwise.","solution":"def can_see_sunset(heights): Determines which buildings can see the sunset. Args: heights (list of int): List of building heights. Returns: list of bool: List indicating if the building at each index can see the sunset. n = len(heights) answer = [False] * n max_height = 0 # Traverse from right to left for i in range(n-1, -1, -1): if heights[i] > max_height: answer[i] = True max_height = heights[i] return answer"},{"question":"Given a list of `n` integers `arr`, and an integer `k`, your task is to determine whether the array can be re-ordered such that the difference between adjacent elements is at most `k`. If it is possible, return `true`; otherwise, return `false`. For example, if `arr = [1, 5, 9, 12]` and `k = 4`, then the array can be re-ordered to `[1, 5, 9, 12]` because the differences between adjacent elements (4, 4, and 3) are all less than or equal to `k`. However, if `k` were `2`, it would not be possible because at least one of the differences would exceed `k`.","solution":"def can_reorder_with_difference(arr, k): Determines if the array can be reordered such that the difference between adjacent elements is at most `k`. Parameters: arr (list): A list of integers. k (int): The allowed maximum difference between adjacent elements. Returns: bool: True if the array can be reordered, False otherwise. if not arr: return True arr.sort() for i in range(len(arr) - 1): if arr[i + 1] - arr[i] > k: return False return True"},{"question":"Given a list of non-negative integers, arrange them such that they form the largest possible number. Return the largest number you can form as a string. You should solve this problem by defining a custom sort order. Note that the result may be very large, so you need to return a string instead of an integer.","solution":"from functools import cmp_to_key def largest_number(nums): Arrange a list of non-negative integers such that they form the largest possible number. Args: nums (list): List of non-negative integers. Returns: str: The largest number formed by the integers in the list. if not nums: return \\"\\" # Custom comparator to decide which concatenated pair is greater. def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert integers to strings for easy comparison. nums = list(map(str, nums)) # Sort array with custom comparator. nums.sort(key=cmp_to_key(compare)) # Join sorted numbers into a single string. result = \'\'.join(nums) # Edge case to handle leading zeros. if result[0] == \'0\': return \'0\' else: return result"},{"question":"You are given a list of integers `nums` representing values at each position in a circular sequence. You can perform a series of operations where, in each operation, you choose any two adjacent numbers and merge them into a single number by taking their sum. This merged number replaces the two original numbers, and the sequence becomes shorter by one number as a result. The cost of merging two numbers is the value of the merged number. Perform the operations until only one number remains. Your objective is to minimize the total cost of all merge operations. Return the minimum cost to merge all numbers in the circular sequence into a single number.","solution":"from queue import PriorityQueue def min_cost_to_merge(nums): if not nums: return 0 elif len(nums) == 1: return 0 # Create a priority queue pq = PriorityQueue() # Add all numbers into the priority queue for num in nums: pq.put(num) total_cost = 0 while pq.qsize() > 1: # Take the two smallest elements first = pq.get() second = pq.get() merged = first + second # Add the cost of this merge total_cost += merged # Put the merged element back into the PQ pq.put(merged) return total_cost"},{"question":"Given a grid containing an `m x n` matrix with integers, where each integer represents the height of a terrain, calculate the amount of trapped rainwater after it rains. The water is trapped according to the following criteria: - Water can only be trapped if there are non-zero heights around a particular cell. - The water trapped in a cell is determined by the height of the lowest boundary that surrounds that cell. - You cannot trap water at the edges of the grid. Write a function that takes the grid as input and returns the total amount of trapped rainwater. Here is the function signature: `def trapRainWater(grid: List[List[int]]) -> int:`","solution":"from heapq import heappush, heappop def trapRainWater(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] heap = [] # Push all the boundary cells into the heap and mark them as visited for i in range(m): for j in range(n): if i == 0 or i == m-1 or j == 0 or j == n-1: heappush(heap, (grid[i][j], i, j)) visited[i][j] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] water_trapped = 0 while heap: current_height, x, y = heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: water_trapped += max(0, current_height - grid[nx][ny]) heappush(heap, (max(current_height, grid[nx][ny]), nx, ny)) visited[nx][ny] = True return water_trapped"},{"question":"You are given a string `s` and an array `pairs` where `pairs[i] = [a, b]` indicates that you can swap the characters at index `a` and index `b` of the string `s`. You can swap characters any number of times. Return _the lexicographically smallest string that_ `s` _can be changed to after using the swaps_. Note that a string `a` is lexicographically smaller than a string `b` if at the first position where `a` and `b` differ, string `a` has a character strictly smaller than the corresponding character in `b`. For example, \\"apple\\" is lexicographically smaller than \\"banana\\" because \'a\' is smaller than \'b\' at the first position they differ.","solution":"def smallestStringWithSwaps(s, pairs): from collections import defaultdict import heapq n = len(s) # Create adjacency list for the graph graph = defaultdict(list) for a, b in pairs: graph[a].append(b) graph[b].append(a) # DFS to find all connected components visited = [False] * n def dfs(node): stack = [node] component = [] while stack: curr = stack.pop() if not visited[curr]: visited[curr] = True component.append(curr) for neighbor in graph[curr]: if not visited[neighbor]: stack.append(neighbor) return component # Find all components components = [] for i in range(n): if not visited[i]: components.append(dfs(i)) # Create the smallest string s = list(s) for component in components: # Extract the characters from the component chars = [s[i] for i in component] # Sort the characters chars.sort() # Put the sorted characters back in their respective positions for i, char in zip(sorted(component), chars): s[i] = char return \'\'.join(s)"},{"question":"You are given a circular track of length `n` and two racers starting at different positions on the track. The positions are represented by integers `startA` and `startB` (0-indexed). Each racer can run `k` steps per second, and the race occurs simultaneously in discrete time steps. The track wraps around after reaching the end, meaning that after position `n-1`, the next position is `0`. Implement a function `timeToMeet(n, startA, startB, k)` that returns the minimum time (in seconds) it takes for both racers to land on the same position on the track. If they cannot meet, return `-1`.","solution":"def timeToMeet(n, startA, startB, k): Returns the minimum time in seconds for two racers to meet on a circular track, or -1 if they cannot meet. Parameters: n (int): The length of the circular track startA (int): The starting position of the first racer (0-indexed) startB (int): The starting position of the second racer (0-indexed) k (int): The number of steps each racer takes per second Returns: int: The minimum time in seconds for both racers to meet, or -1 if they cannot meet # If the distance between their starting positions is not a multiple of their speed, they cannot meet if (startB - startA) % k != 0: return -1 # Calculate the number of seconds it will take for their meeting point distance = (startB - startA) % n return distance // k"},{"question":"You are given a **0-indexed** integer array `nums` which represents the cost of performing various tasks. You are also given an integer `time` which represents the total available time you have to complete these tasks. You can only perform a task if you have enough time remaining. Return the _maximum number of tasks you can complete within the given time_.","solution":"def max_tasks(nums, time): Returns the maximum number of tasks that can be completed within the given time. nums.sort() count = 0 total_time = 0 for cost in nums: if total_time + cost <= time: total_time += cost count += 1 else: break return count"},{"question":"You are given an array of `n` integers. Your task is to determine if it is possible to partition the array into two subsets such that the sum of the elements in both subsets is the same. Return _`true` if such a partition is possible, otherwise return `false`_.","solution":"def can_partition(nums): Determines if it is possible to partition the array into two subsets such that the sum of the elements in both subsets is the same. total_sum = sum(nums) # If total sum is odd, it cannot be partitioned into two equal subsets if total_sum % 2 != 0: return False # Target sum for each subset target = total_sum // 2 n = len(nums) # dp[i] will be True if a subset with sum i can be formed with the elements in the array dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"Given an array of integers `heights` representing the height of people standing in a line (not necessarily in sorted order), sort the array so that all the people of the same height are grouped together, but their relative order from the original array is preserved within each group. Return the sorted array.","solution":"from collections import defaultdict from itertools import chain def sort_by_heights(heights): Sorts the array so that people of the same height are grouped together while preserving their relative order from the original array within each group. :param heights: List[int], an array of integers representing heights. :return: List[int], sorted array as per the described requirements. height_map = defaultdict(list) # collect heights maintaining their relative order for height in heights: height_map[height].append(height) # create a list of lists grouped by height and preserving order within each group, # and then flatten the list of lists to get the final output sorted_heights = list(chain.from_iterable(height_map[height] for height in sorted(height_map.keys()))) return sorted_heights"},{"question":"You are given an integer array `arr` of size `n` containing elements such that each element in the array is either a `1` (representing land) or a `0` (representing water). An island is defined as a group of `1`s connected horizontally or vertically (you are not allowed to move diagonally). There may be multiple islands. Find and return the maximum area of an island in the given array. The area of an island is the number of `1`s in that island.","solution":"def max_area_of_island(arr): This function returns the maximum area of an island in the given binary grid. An island is formed by connecting adjacent 1s horizontally or vertically. :param arr: List[List[int]]: 2D list representing the binary grid :return: int: Maximum area of an island if not arr: return 0 n = len(arr) m = len(arr[0]) def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or arr[x][y] == 0: return 0 arr[x][y] = 0 # Mark the cell as visited area = 1 # Current cell # Explore the four possible directions area += dfs(x + 1, y) area += dfs(x - 1, y) area += dfs(x, y + 1) area += dfs(x, y - 1) return area max_area = 0 for i in range(n): for j in range(m): if arr[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"You are given a list of `n` integers representing the prices of cars sold on different days. You want to determine the maximum profit you can achieve by buying and then selling one car within this list of days. However, you must buy the car before you can sell it (i.e., the purchase must be on a day that comes before the sale). Write a function that takes an array of integers `prices` where `prices[i]` represents the price of a car on the `i-th` day and returns the maximum profit you can achieve from this transaction. If no profit is possible, return 0.","solution":"def max_profit(prices): Returns the maximum profit that can be achieved by buying and then selling one car. If no profit is possible, returns 0. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"Write a function that takes an integer array `nums` and an integer `k`, and returns _the k most frequent elements_. You may return the answer in **any order**. In the case of a tie, any of the k elements having the highest frequency can be included. The solution needs to have a time complexity better than O(n log n) where `n` is the length of the array `nums`.","solution":"from collections import Counter import heapq def top_k_frequent(nums, k): Returns the k most frequent elements from the integer array nums. # Step 1: Count the frequencies of each number in nums count = Counter(nums) # Step 2: Use a heap to find the k most frequent elements # Since heapq by default is a min-heap, we use negative counts to simulate a max-heap return heapq.nlargest(k, count.keys(), key=count.get)"},{"question":"You are given a list of integers `nums` and an integer `k`. Find the length of the longest subsequence of `nums` such that the difference between the minimum and maximum values in the subsequence is at most `k`. Return the _length of the longest subsequence_.","solution":"def longest_subsequence(nums, k): Returns the length of the longest subsequence where the difference between the minimum and maximum values in the subsequence is at most k. if not nums: return 0 nums.sort() left = 0 max_len = 0 for right in range(len(nums)): while nums[right] - nums[left] > k: left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given an `m x n` binary matrix `mat`, determine if the matrix contains exactly one square submatrix of 1\'s. A square submatrix is a contiguous block of 1\'s arranged in a perfect square. Return `true` if such a submatrix exists and `false` otherwise. For example, given the matrix: ``` [ [1, 0, 0, 1], [1, 1, 0, 1], [0, 1, 1, 1], [1, 0, 1, 1] ] ``` The function should return `true` because there is exactly one square submatrix of 1\'s. If there were no square submatrices or more than one, the function would return `false`.","solution":"def has_exactly_one_square_submatrix(mat): Determines if the matrix contains exactly one square submatrix of 1\'s. :param mat: List[List[int]] - a binary matrix :return: bool - True if there is exactly one square submatrix of 1\'s, False otherwise if not mat or not mat[0]: return False m, n = len(mat), len(mat[0]) dp = [[0] * n for _ in range(m)] count = 0 for i in range(m): for j in range(n): if mat[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 if dp[i][j] > 1: count += 1 if count > 1: return False return count == 1"},{"question":"You are given two strings `s` and `t`, both of which consist of lowercase letters. You need to determine if `s` can be transformed into `t` by performing the following operation any number of times: choose any character in `s` and replace it with a character that is adjacent to it in the alphabet. For example, ‘a’ can be replaced with ‘b’, ‘j’ can be replaced with ‘i’ or ‘k’, and so on. Return `true` if `s` can be transformed into `t`, and `false` otherwise.","solution":"def can_transform(s, t): Determines if string s can be transformed into string t by replacing any character in s with its adjacent characters in the alphabet any number of times. Args: - s (str): The original string. - t (str): The target string. Returns: - bool: True if s can be transformed into t, False otherwise. if len(s) != len(t): return False for cs, ct in zip(s, t): if cs != ct and (ord(cs) + 1 != ord(ct) and ord(cs) - 1 != ord(ct)): return False return True"},{"question":"You are given two arrays of integers, `arrival` and `departure`, where `arrival[i]` and `departure[i]` represent the arrival and departure times of the someone meeting at time interval `i` on the timeline. Each time interval `[arrival[i], departure[i]]` is closed inclusive. Your task is to determine the **minimum number of rooms** required to accommodate all the meetings simultaneously.","solution":"def min_meeting_rooms(arrival, departure): Returns the minimum number of rooms required to accommodate all meetings. Parameters: arrival (list of int): List of arrival times. departure (list of int): List of departure times. Returns: int: Minimum number of rooms required. if not arrival or not departure or len(arrival) != len(departure): return 0 events = [] for i in range(len(arrival)): events.append((arrival[i], \'arr\')) events.append((departure[i], \'dep\')) events.sort(key=lambda x: (x[0], x[1])) max_rooms = 0 current_rooms = 0 for event in events: if event[1] == \'arr\': current_rooms += 1 max_rooms = max(max_rooms, current_rooms) else: current_rooms -= 1 return max_rooms"},{"question":"Given a list of integers `arr`, you need to find two non-overlapping subarrays, each of which has the maximum possible sum. Return an array of these two sums in any order. If there are multiple pairs with the same sum, any one of them can be returned. A subarray is a contiguous part of an array and may contain one or more elements.","solution":"def max_two_non_overlapping_subarrays(arr): Finds two non-overlapping subarrays with the maximum possible sum. Args: arr (list): List of integers. Returns: list: List of two integers representing the sums of the two subarrays. n = len(arr) # Corner case: if the list contains less than 2 elements, return empty list if n < 2: return [] # Helper function to find the maximum subarray sum using Kadane\'s algorithm def max_subarray_sum(arr): max_sum = curr_sum = arr[0] for num in arr[1:]: curr_sum = max(num, curr_sum + num) max_sum = max(max_sum, curr_sum) return max_sum # First, find the maximum sum from 0 to i max_end_here = [0] * n curr_sum = max_end_here[0] = arr[0] for i in range(1, n): curr_sum = max(arr[i], curr_sum + arr[i]) max_end_here[i] = max(max_end_here[i-1], curr_sum) # Second, find the maximum sum from i to n-1 max_start_here = [0] * n curr_sum = max_start_here[-1] = arr[-1] for i in range(n-2, -1, -1): curr_sum = max(arr[i], curr_sum + arr[i]) max_start_here[i] = max(max_start_here[i+1], curr_sum) max_sum = float(\'-inf\') for i in range(n-1): max_sum = max(max_sum, max_end_here[i] + max_start_here[i+1]) results = [0, 0] for i in range(n-1): if max_end_here[i] + max_start_here[i+1] == max_sum: results[0] = max_end_here[i] results[1] = max_start_here[i+1] break return results"},{"question":"You are given an array `arr` of integers where each integer represents a vote for a particular movie. Return _a list of integers representing the IDs of the movies that have received more than 25% of the total votes_. The list should be sorted in ascending order. If no movie meets the criteria, return an empty list.","solution":"def movies_with_more_than_25_percent_votes(arr): from collections import Counter n = len(arr) vote_threshold = n // 4 movie_votes = Counter(arr) result = [movie for movie, votes in movie_votes.items() if votes > vote_threshold] return sorted(result)"},{"question":"A delivery company uses a fleet of drones to deliver packages. Each drone has a maximum weight capacity, and each package has a specific weight. Given an array `packages` where `packages[i]` denotes the weight of the i-th package, and an integer `capacity` that denotes the weight limit for each drone, return the minimum number of drones required to deliver all the packages. Each drone can carry multiple packages as long as the total weight does not exceed its capacity.","solution":"def min_drones(packages, capacity): Returns the minimum number of drones required to deliver all packages. :param packages: List of integers where each integer denotes the weight of a package. :param capacity: Integer denoting the weight capacity of each drone. :return: Integer denoting the minimum number of drones required. packages.sort(reverse=True) drones = [] for package in packages: placed = False for i in range(len(drones)): if drones[i] + package <= capacity: drones[i] += package placed = True break if not placed: drones.append(package) return len(drones)"},{"question":"You are given a list of non-negative integers `nums` and an integer `target`. Find if there exists a subarray (contiguous elements) in `nums` whose sum equals `target`. Return `true` if such a subarray exists, and `false` otherwise.","solution":"def has_subarray_with_sum(nums, target): Returns True if there exists a subarray in nums whose sum equals target, otherwise returns False. current_sum = 0 prefix_sums = {0} # Set to keep track of prefix sums for num in nums: current_sum += num if (current_sum - target) in prefix_sums: return True prefix_sums.add(current_sum) return False"},{"question":"Given a balanced binary search tree (BST) with `n` nodes, each node contains a unique integer value. You are provided an integer array `values` of length `n` where `values[i]` represents the value of the ith node in the level-order traversal of the BST. Write a function to determine the leftmost leaf node\'s value in this BST. Return the value of the leftmost leaf node.","solution":"def leftmost_leaf_value(values): Determine the leftmost leaf node\'s value in a balanced BST. :param values: List[int] representing the level-order traversal of the BST. :return: int value of the leftmost leaf node. if not values: return None # To find the leftmost leaf we need to traverse to the leftmost position i = 0 n = len(values) while 2 * i + 1 < n: i = 2 * i + 1 return values[i]"},{"question":"You are given an unsorted array of integers `nums`. You need to reorder the array such that all even numbers precede all odd numbers. The relative order of the even and odd numbers should be maintained. Return _the reordered array_.","solution":"def reorder_even_before_odd(nums): Reorders the given list such that all even numbers precede all odd numbers. The relative order of the even and odd numbers should be maintained. Parameters: nums (list of int): List of integers to be reordered. Returns: list of int: Reordered list with all even numbers preceding odd numbers. even_numbers = [num for num in nums if num % 2 == 0] odd_numbers = [num for num in nums if num % 2 != 0] return even_numbers + odd_numbers"},{"question":"You are given an integer array `envelopes` where `envelopes[i]` represents the dimensions of the `i-th` envelope represented as a pair of integers ([w_i, h_i]) where ( w_i ) is the width and ( h_i ) is the height. One envelope can fit into another if and only if both the width and height of one envelope are strictly greater than the width and height of the other envelope. Find the maximum number of envelopes you can Russian doll (i.e., put one inside the other). Note: You cannot rotate an envelope. Return the maximum number of envelopes you can Russian doll.","solution":"def maxEnvelopes(envelopes): from bisect import bisect_left # Sort the envelopes first by width (ascending) and then by height (descending) envelopes.sort(key=lambda x: (x[0], -x[1])) heights = [envelope[1] for envelope in envelopes] # This list will store the longest increasing subsequence of heights dp = [] for h in heights: # Find the position to replace or extend the subsequence pos = bisect_left(dp, h) if pos < len(dp): dp[pos] = h else: dp.append(h) return len(dp)"},{"question":"You are given a list of unique integers `nums` and an integer `target`. Your task is to return the list of all unique pairs `[a, b]` from the given `nums` such that `a + b = target`. Each pair `[a, b]` should be sorted such that `a <= b` and the list of pairs should be sorted in ascending order based on the first element of each pair. If no such pairs exist, return an empty list.","solution":"def find_pairs(nums, target): Returns a list of unique pairs [a, b] from the given nums such that a + b = target. Each pair [a, b] is sorted such that a <= b, and the list of pairs is sorted in ascending order based on the first element of each pair. nums.sort() pairs = [] seen = set() for num in nums: complement = target - num if complement in seen: pair = sorted([num, complement]) if pair not in pairs: pairs.append(pair) seen.add(num) pairs.sort() return pairs"},{"question":"Given a 2D grid of integers representing heights, determine the length of the longest increasing path from any cell to any other cell. You can move in four possible directions - up, down, left, or right. Each move must result in an increase in the value from the current cell to the target cell. Return the length of the longest path.","solution":"def longest_increasing_path(matrix): if not matrix: return 0 rows, cols = len(matrix), len(matrix[0]) memo = [[-1 for _ in range(cols)] for _ in range(rows)] def dfs(row, col): if memo[row][col] != -1: return memo[row][col] moves = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_path = 1 for move in moves: new_row, new_col = row + move[0], col + move[1] if 0 <= new_row < rows and 0 <= new_col < cols and matrix[new_row][new_col] > matrix[row][col]: max_path = max(max_path, 1 + dfs(new_row, new_col)) memo[row][col] = max_path return memo[row][col] longest_path = 0 for row in range(rows): for col in range(cols): longest_path = max(longest_path, dfs(row, col)) return longest_path"},{"question":"Given a list of integers `arr` representing a **mountain array**, return the **index** `i` such that `arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`. You must solve it in `O(log(n))` time complexity. A mountain array is defined as an array that has at least 3 elements where there exists some index `i` with `0 < i < arr.length - 1` such that: - `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]` - `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]` Return the index `i` as per the definition above.","solution":"def peak_index_in_mountain_array(arr): Returns the index of the peak element in a mountain array. Uses binary search to achieve O(log(n)) time complexity. left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] < arr[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"Given an array of non-negative integers `arr` and an integer `k`, find the `k` largest elements in the array and return them in ascending order. You can assume that `k` is always less than or equal to the length of the array. For example, if `arr = [3, 2, 1, 5, 6, 4]` and `k = 2`, the output should be `[5, 6]`, as 5 and 6 are the two largest elements in the array. Consider optimizing your solution to run in O(n log k) time complexity.","solution":"import heapq def k_largest_elements(arr, k): Returns the k largest elements in the array in ascending order. Parameters: arr (list of int): List of non-negative integers. k (int): Number of largest elements to return. Returns: list of int: k largest elements in ascending order. if k <= 0 or not arr: return [] # Use a min-heap of size k min_heap = arr[:k] heapq.heapify(min_heap) for num in arr[k:]: if num > min_heap[0]: heapq.heapreplace(min_heap, num) # The heap contains the k largest elements, sort them before returning return sorted(min_heap)"},{"question":"Implement a class `MatrixManipulator` that allows for specific operations on a given 2D matrix of integers. The class should support the following operations: * `MatrixManipulator(int[][] matrix)` - Initializes the object with a **2D** integer matrix `matrix`. * `void incrementSubmatrix(int row1, int col1, int row2, int col2, int value)` - Increments each element within the submatrix defined by its top-left corner `(row1, col1)` and bottom-right corner `(row2, col2)` (both inclusive) by `value`. * `int getElement(int row, int col)` - Returns the element at the position `(row, col)` of the matrix. Your class should efficiently handle multiple such operations.","solution":"class MatrixManipulator: def __init__(self, matrix): self.matrix = matrix def incrementSubmatrix(self, row1, col1, row2, col2, value): for i in range(row1, row2 + 1): for j in range(col1, col2 + 1): self.matrix[i][j] += value def getElement(self, row, col): return self.matrix[row][col]"},{"question":"You are given an integer array `weights` where `weights[i]` represents the weight of the `i-th` item. You are also given an integer `capacity` representing the maximum weight that a bag can carry. Determine the maximum number of items that can be included in the bag without exceeding the `capacity`. If no items can be included, return `0`.","solution":"def max_items_in_bag(weights, capacity): Determines the maximum number of items that can be included in the bag without exceeding the capacity. Parameters: weights (list): List of weights of the items. capacity (int): Maximum weight the bag can carry. Returns: int: Maximum number of items that can be included in the bag. weights.sort() total_weight = 0 item_count = 0 for weight in weights: if total_weight + weight <= capacity: total_weight += weight item_count += 1 else: break return item_count"},{"question":"A software development team needs to optimize the deployment process of an application. They are given an array `deployTimes` where `deployTimes[i]` represents the time (in minutes) required to deploy the `i-th` feature. The team wants to minimize the maximum deployment time by dividing the features into `k` non-empty contiguous subarrays. Return _the minimum possible value of the maximum deployment time among the `k` subarrays_.","solution":"def min_max_deploy_time(deployTimes, k): def can_split(max_time): current_sum = 0 needed_splits = 1 for time in deployTimes: if current_sum + time > max_time: current_sum = time needed_splits += 1 if needed_splits > k: return False else: current_sum += time return True left, right = max(deployTimes), sum(deployTimes) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a list of `n` integers representing the height of towers arranged in sequence. Each tower can catch water in the gap between it and the next tower if the next tower is shorter. The amount of water that can be caught between two towers is the difference in their heights. You need to determine the **maximum** amount of water that can be caught between any two towers in the sequence. Return the maximum amount of water that can be caught. If no water can be caught, return `0`.","solution":"def max_water_caught(heights): Returns the maximum amount of water that can be caught between any two towers. Parameters: heights (list): A list of integers representing the height of towers. Returns: int: The maximum amount of water that can be caught between any two towers. max_water = 0 for i in range(len(heights) - 1): diff = heights[i] - heights[i + 1] if diff > 0: max_water = max(max_water, diff) return max_water"},{"question":"You are given an integer array `nums` and an integer `k`. You need to find the length of the longest subsequence of `nums` such that the absolute difference between any two elements in this subsequence is exactly `k`. A subsequence is a sequence derived by deleting some or no elements from the array without changing the order of the remaining elements. Return the length of the longest such subsequence. **Note**: - The absolute difference between two integers `a` and `b` is given by `|a - b|`.","solution":"def longest_subsequence_with_diff(nums, k): from collections import defaultdict subseq_len = defaultdict(int) longest_length = 0 for num in nums: subseq_len_up = subseq_len[num - k] + 1 subseq_len_down = subseq_len[num + k] + 1 subseq_len[num] = max(subseq_len[num], subseq_len_up, subseq_len_down) longest_length = max(longest_length, subseq_len[num]) return longest_length"},{"question":"Given an m x n binary matrix `grid`, find the largest square containing only 1\'s and return its area. The matrix consists of only \'0\' and \'1\'s. A square in the matrix is defined to be formed by the `1\'s` such that it has equal width and height. For example, consider the binary matrix below: ``` [ [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"1\\",\\"0\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"0\\",\\"0\\",\\"1\\",\\"0\\"] ] ``` The largest square containing only 1\'s has an area of `4`, and its side length is `2`. Inputs: - A 2D list `grid` where `grid[i][j]` is either \'0\' or \'1\'. Output: - Return an integer representing the area of the largest square containing only 1\'s.","solution":"def maximalSquare(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * (n + 1) for _ in range(m + 1)] max_side = 0 for i in range(1, m + 1): for j in range(1, n + 1): if grid[i-1][j-1] == \'1\': dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"Given a list of `n` integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining. Each integer represents the elevation at that point. Your task is to write a function that takes this list of integers and returns the total amount of trapped rainwater. For example, given the list `[0,1,0,2,1,0,1,3,2,1,2,1]`, it should return `6` since the elevation map can trap `6` units of rainwater. Implement the function with the following signature: ```python def trap(height: List[int]) -> int: ```","solution":"from typing import List def trap(height: List[int]) -> int: Computes the total amount of trapped rainwater given a list of heights. :param height: List of integers representing elevation map where the width of each bar is 1. :return: The total amount of trapped rainwater. if not height: return 0 left_max = [0] * len(height) right_max = [0] * len(height) left_max[0] = height[0] for i in range(1, len(height)): left_max[i] = max(left_max[i - 1], height[i]) right_max[len(height) - 1] = height[len(height) - 1] for i in range(len(height) - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(len(height)): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"**You are given a 2D integer array `matrix` of size `m x n` and an integer `k`. Return the `k-th` smallest element in the sorted order of all the elements in `matrix`. This array is sorted in non-decreasing row-wise and column-wise order.** Example: Input: `matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ]`, `k = 8` Output: `13` Explanation: The elements of the matrix in sorted order are `[1, 5, 9, 10, 11, 12, 13, 13, 15]`, and the 8th smallest element is `13`.","solution":"import heapq def kthSmallest(matrix, k): Returns the k-th smallest element in the sorted order of all elements in the matrix. :param matrix: List[List[int]] - 2D list of integers :param k: int - the k-th position to find the smallest element :return: int - k-th smallest element n = len(matrix) min_heap = [] # Add the first element of each row to the min heap for r in range(min(n, k)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract the elements from the min heap count = 0 while min_heap: element, r, c = heapq.heappop(min_heap) count += 1 if count == k: return element if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))"},{"question":"Given a string `str` consisting of lowercase alphabetic characters, create a function to determine whether there exists a permutation of `str` that forms a palindrome. A string is a palindrome if it reads the same backward as forward. The function should return `True` if such a permutation exists and `False` otherwise. Note: You may assume the input string has a length of at most 1000 characters.","solution":"def can_form_palindrome(s): Determines if there exists a permutation of the string that forms a palindrome. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can form a palindrome if it has at most one character with an odd frequency return odd_count <= 1"},{"question":"Given an array of integers `a`, return all _the possible permutations_ in **lexicographic** order. The array may contain **duplicate** integers, and the solution must handle the **duplicates** such that the resulting permutations do not have any duplicate entries in the final output.","solution":"from itertools import permutations def unique_permutations(a): Returns all unique permutations of the array `a` in lexicographic order. Parameters: a (list): A list of integers which may contain duplicates. Returns: list: A list of lists, where each sublist is a unique permutation of `a` sorted in lexicographic order. return sorted(set(permutations(a)))"},{"question":"You are given a binary tree with `n` nodes, where each node is uniquely numbered from `0` to `n-1`. The tree is represented as a 2D integer array `edges`, where `edges[i] = [parent, child]` indicates that the node `child` is a direct descendant of `parent`. You are also provided with an integer `k`. Your task is to determine if there exists a path from the root to any leaf that contains exactly `k` nodes. A path is defined as a sequence of nodes starting from the root and ending at a leaf, where each node is the parent of the next node in the sequence. Return `true` if such a path exists, and `false` otherwise.","solution":"def exists_path_with_k_nodes(edges, n, k): from collections import defaultdict # Build the adjacency list representation of the tree tree = defaultdict(list) for parent, child in edges: tree[parent].append(child) # Function to find the depth of the tree using DFS def dfs(node, depth): # If the node is a leaf node and depth equals k, return True if not tree[node]: return depth == k # Recur for all the children for child in tree[node]: if dfs(child, depth + 1): return True return False # Start DFS from the root node (0) with initial depth 1 return dfs(0, 1)"},{"question":"You are given an array of integers `nums` of length `n` representing a sequence of numbers. You need to find a subsequence in the array such that the subsequence\'s sum is at least half of the total sum of the array, and the number of elements in the subsequence is minimized. Return _an array_ `result` _that contains the elements of the subsequence in ascending order_. If there are multiple possible subsequences, return the one that appears first in sorted order.","solution":"def min_subsequence(nums): Returns a subsequence such that its sum is at least half of the total sum of the array nums with the minimum number of elements, sorted in ascending order. Args: nums: List[int] - The array of integers Returns: List[int] - The resulting subsequence in ascending order # Find the total sum of the array total_sum = sum(nums) # Sort the array in descending order to pick larger elements first nums.sort(reverse=True) subsequence = [] subseq_sum = 0 # Collect elements to form the subsequence for num in nums: subsequence.append(num) subseq_sum += num if subseq_sum >= total_sum / 2: break # Return the subsequence sorted in ascending order return sorted(subsequence)"},{"question":"You are given a list of `n` projects, each with a specific start and end time represented by a pair of integers `[start, end]`. You need to determine if it is possible to attend all the projects without any overlap. Assume a project `[start, end]` signifies that the project starts at time `start` and ends just before time `end`. Implement a function `bool canAttendAllProjects(List<List<int>> projects)` which returns `true` if it is possible to attend all projects without any overlap, and `false` otherwise.","solution":"def can_attend_all_projects(projects): Determines if it is possible to attend all projects without any overlap. Arguments: projects -- list of lists, where each inner list contains two integers representing the start and end time of a project. Returns: boolean -- True if it\'s possible to attend all projects without overlap, False otherwise. # Sort the projects by their start times projects.sort(key=lambda x: x[0]) for i in range(1, len(projects)): # If the current project starts before the previous one ends, return False if projects[i][0] < projects[i - 1][1]: return False return True"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to implement a data structure to answer the following query efficiently: Determine the first non-repeating character in the string `s` at any given time. If all characters are repeating, return `\'#\'`. Implement the `FirstNonRepeatingChar` class: * `FirstNonRepeatingChar(String s)` Initializes the **FirstNonRepeatingChar** object with the string `s`. * `char queryFirstNonRepeating()` Returns the first non-repeating character at the current state of the string `s`. If all characters are repeating, return `\'#\'`. * `void addCharacter(char c)` Adds a new character `c` to the current state of the string `s`.","solution":"from collections import defaultdict, deque class FirstNonRepeatingChar: def __init__(self, s): self.s = s self.queue = deque() self.count = defaultdict(int) for c in s: self.addCharacter(c) def queryFirstNonRepeating(self): while self.queue and self.count[self.queue[0]] > 1: self.queue.popleft() if self.queue: return self.queue[0] else: return \'#\' def addCharacter(self, c): self.s += c self.count[c] += 1 if self.count[c] == 1: self.queue.append(c)"},{"question":"Given a string `s` consisting of lowercase letters, you need to partition the string into as few parts as possible so that each letter appears in at most one part. Return the corresponding list of lengths of each part. Note that: - Each part represents a contiguous substring of the original string. - After partitioning, every letter in the substring appears only in that substring and nowhere else in the original string.","solution":"def partition_labels(s): Partitions the input string into as few parts as possible so that each letter appears in at most one part, and returns the lengths of each part. # Track the last occurrence of each character last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start, end = 0, 0 for idx, char in enumerate(s): end = max(end, last_occurrence[char]) if idx == end: partitions.append(end - start + 1) start = idx + 1 return partitions"},{"question":"A software engineering team at a company works with a server that tracks and records user activity logs. Each log is a string with format \\"user_id timestamp activity\\", where `user_id` is a unique integer for each user, `timestamp` is a string representing the time in format \\"YYYY-MM-DD hh:mm:ss\\", and `activity` is a string describing the activity. Given a list of such logs `logs`, implement a function `most_active_user(logs)` that returns the `user_id` of the user with the highest number of activities. If there are multiple users with the same maximum number of activities, return the `user_id` that comes first in alphabetical order. **Example:** Input: ``` logs = [ \\"101 2023-08-15 09:00:00 login\\", \\"102 2023-08-15 09:05:00 view_profile\\", \\"101 2023-08-15 09:10:00 logout\\", \\"103 2023-08-15 09:15:00 login\\", \\"102 2023-08-15 09:20:00 logout\\", \\"103 2023-08-15 09:25:00 logout\\", \\"101 2023-08-15 10:00:00 login\\" ] ``` Output: ``` \\"101\\" ``` Note: - You may assume `logs` are well-formed and in valid format. - Each log entry is unique.","solution":"def most_active_user(logs): from collections import defaultdict user_activity_count = defaultdict(int) for log in logs: user_id = log.split()[0] user_activity_count[user_id] += 1 most_active_user_id = min(user_activity_count, key=lambda k: (-user_activity_count[k], k)) return most_active_user_id"},{"question":"You are given a `word` and an integer `k`. Your task is to rotate the string to the right `k` times. For example, if the input `word` is \\"coding\\" and `k` is 2, the output should be \\"ngcodi\\". If rotating the word `k` times exceeds its length, wrap around using modulo operation to find the effective number of rotations. Return the final rotated string.","solution":"def rotate_string(word, k): Rotates the given string `word` to the right `k` times. Parameters: word (str): The string to be rotated. k (int): The number of times to rotate the string to the right. Returns: str: The rotated string. if not word: return word k = k % len(word) return word[-k:] + word[:-k] # Example: # word = \\"coding\\", k = 2 # Output: \\"ngcodi\\""},{"question":"You are given an array of integers representing a **price list** for a series of items in a store. Each item has a certain price represented by the elements in the array. Your task is to determine the **maximum profit** that can be made by buying one item and then selling another item afterwards. In other words, you must find two different indices `i` and `j` such that `i < j` and `prices[j] - prices[i]` is the maximum possible. Return this maximum profit. If no profit can be made, return 0.","solution":"def max_profit(prices): Returns the maximum profit possible from buying one item and selling another item later from the prices list. :param prices: List of integers representing prices. :return: Integer representing the maximum profit or 0 if no profit can be made. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices: min_price = min(min_price, price) profit = price - min_price max_profit = max(max_profit, profit) return max_profit"},{"question":"Given an integer array `arr` of length `n`, determine if it is possible to select exactly `k` distinct indices `(i, j)` with `i != j` such that the sum of `arr[i]` and `arr[j]` for each pair is equal to a given integer `s`. Return `true` if such a selection is possible or `false` otherwise.","solution":"def can_select_pairs_with_sum(arr, k, s): Determine if it is possible to select exactly k distinct pairs (i, j) with i != j such that the sum of arr[i] and arr[j] for each pair is equal to s. :param arr: List of integers :param k: The number of pairs to select :param s: The target sum for each pair :return: True if such a selection is possible, False otherwise # Handle edge cases n = len(arr) if n < 2 or k <= 0: return False # Dictionary to count occurrences of complements complement_count = {} for num in arr: complement = s - num if complement in complement_count and complement_count[complement] > 0: complement_count[complement] -= 1 k -= 1 else: complement_count[num] = complement_count.get(num, 0) + 1 if k == 0: return True return False"},{"question":"You are given a **2D** integer array `matrix` of size `n x n` representing a square matrix. Your task is to rotate the matrix **90 degrees clockwise**. Return the matrix after rotation. Ensure that you do not use any extra space for a new matrix and perform the rotation in-place.","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. Parameters: matrix (List[List[int]]): A 2D list representing the square matrix. Returns: List[List[int]]: The matrix, rotated in-place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"You are given a string `s` consisting of lowercase alphabetic characters only. An operation is defined as selecting a character in the string and removing all occurrences of that character. You need to perform this operation repeatedly until the string becomes empty. Return the **minimum number** of operations needed to empty the string.","solution":"def min_operations_to_empty_string(s): Returns the minimum number of operations needed to empty the string `s`. An operation is defined as removing all occurrences of a particular character. return len(set(s))"},{"question":"Given a 2D matrix `mat` of integers, return the matrix’s **diagonal** traversal as a flattened array. The diagonal traversal of the matrix means to traverse the matrix’s diagonals sequentially. For each diagonal, start from the top-most element and continue to the bottom-most element. For example, from a matrix of size 3x3: ``` mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The diagonal traversal will be `[1, 4, 2, 7, 5, 3, 8, 6, 9]`.","solution":"def diagonal_traversal(mat): Returns the diagonal traversal as a flattened array. Args: mat (list of list of int): 2D matrix of integers Returns: list of int: Diagonal traversal of the matrix if not mat: return [] rows, cols = len(mat), len(mat[0]) result = [] for diag in range(rows + cols - 1): row = min(diag, rows - 1) # start from the row closest to bottom col = max(0, diag - rows + 1) # start from the col closest to left while row >= 0 and col < cols: result.append(mat[row][col]) row -= 1 col += 1 return result"},{"question":"You are given a matrix `mat` with `m` rows and `n` columns, where each cell contains a non-negative integer. Your goal is to find a path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1). You can only move either down or right at any point in time. The minimum cost path is the path which minimizes the sum of all the values along the path. Return the minimum sum of the values along the path.","solution":"def min_path_sum(mat): Finds the minimum sum of the path from the top-left to the bottom-right corner of the matrix moving only down or right. Parameters: mat (list of list of int): The input matrix containing non-negative integers. Returns: int: The minimum sum of the values along the path. if not mat or not mat[0]: return 0 m, n = len(mat), len(mat[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = mat[0][0] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + mat[i][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + mat[0][j] # Populate the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + mat[i][j] return dp[m-1][n-1]"},{"question":"Given a list of `n` integers representing the heights of buildings, find the maximum amount of water that can be trapped between the buildings after rainfall. Each building\'s width is 1 unit. Return an integer representing the maximum water that can be trapped. Example: - Input: `heights = [4,2,0,3,2,5]` - Output: `9` Explanation: Consider the heights `[4, 2, 0, 3, 2, 5]`, the amount of trapped water is as follows: - Between building 1 (height 4) and building 6 (height 5), we can trap: - between building 1 and 2: 0 (height difference between building 1 and 2) - between building 2 and 5: 2 - between building 3 and 5: 3 - between building 4 and 5: 2 - between building 5 and 6: 0 - Total trapped water: `2 + 3 + 2 + 0 + 2 = 9`. The task is to implement the function `int trap(int[] heights)` that takes an array of integers as its input and returns the maximum amount of water trapped.","solution":"def trap(heights): Calculate the total amount of water that can be trapped between the buildings. :param heights: List of integers representing the heights of the buildings :type heights: list[int] :return: Maximum amount of trapped water :rtype: int if not heights: return 0 n = len(heights) left, right = 0, n - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if heights[left] < heights[right]: if heights[left] >= left_max: left_max = heights[left] else: water_trapped += left_max - heights[left] left += 1 else: if heights[right] >= right_max: right_max = heights[right] else: water_trapped += right_max - heights[right] right -= 1 return water_trapped"},{"question":"You are given a string `s` consisting only of lowercase English letters. A **repetition** is defined as a substring consisting of at least two contiguous occurrences of the same character. For example, in the string `\\"aabbcc\\"`, `\\"aa\\"`, `\\"bb\\"`, and `\\"cc\\"` are repetitions. Write a function that finds and returns the **longest repetition** in the string. If there are multiple repetitions of the same length, return the first one that appears in the string. If no repetition exists, return an empty string.","solution":"def longest_repetition(s): Finds and returns the longest repetition in the string. If there are multiple repetitions of the same length, returns the first one that appears. If no repetition exists, returns an empty string. n = len(s) if n < 2: return \\"\\" max_length = 0 longest_seq = \\"\\" current_length = 1 for i in range(1, n): if s[i] == s[i - 1]: current_length += 1 else: if current_length > 1 and current_length > max_length: max_length = current_length longest_seq = s[i - 1] * current_length current_length = 1 # Check the last sequence if current_length > 1 and current_length > max_length: longest_seq = s[-1] * current_length return longest_seq"},{"question":"You are given two arrays `nums1` and `nums2` of integers with length `n` and `m` respectively. Write a function to find the **intersection** of these two arrays. Each element in the result must be unique, and you can return the result in any order. Return _the intersection of_ `nums1` _and_ `nums2` _as a new array._","solution":"def intersection(nums1, nums2): Returns the intersection of nums1 and nums2 arrays. Each element in the result is unique, and the order does not matter. set1 = set(nums1) set2 = set(nums2) return list(set1 & set2)"},{"question":"You are given a list of strings `words` and another string `target`. Your task is to determine the minimum number of words from the list `words` that can be concatenated to form the `target` string. If the `target` cannot be formed by any possible combination of words from the list, return -1. Each word from the list can be used multiple times. Example: ```python words = [\\"cat\\", \\"dog\\", \\"mouse\\"] target = \\"catcatdog\\" min_words_to_form_target(words, target) # Output: 3 (\\"cat\\" + \\"cat\\" + \\"dog\\" = \\"catcatdog\\") ```","solution":"def min_words_to_form_target(words, target): Determine the minimum number of words from the list `words` that can be concatenated to form the `target` string. :param words: List of strings :param target: Target string :return: Minimum number of words to form the target, or -1 if not possible from collections import defaultdict, deque word_set = set(words) # Convert list to set for O(1) lookups dp = defaultdict(lambda: float(\'inf\')) # Store minimum number of words to form each substring dp[\'\'] = 0 # Base case: It takes 0 words to form an empty substring queue = deque([\'\']) # Start BFS from the empty substring while queue: current = queue.popleft() if current == target: return dp[current] for word in words: next_substring = current + word if target.startswith(next_substring) and dp[next_substring] > dp[current] + 1: dp[next_substring] = dp[current] + 1 queue.append(next_substring) return -1 if dp[target] == float(\'inf\') else dp[target]"},{"question":"You are given an integer array `heights` representing the heights of people standing in a queue, and an integer `k`. You can perform up to `k` swaps, where in each swap, you can choose any two people in the queue and swap their positions. Your task is to arrange the people in the queue in non-decreasing order by height using at most `k` swaps. Return the resulting array after performing the swaps.","solution":"def min_swaps_to_sort(heights, k): Returns the array sorted in non-decreasing order using at most k swaps. heights: List[int] - The list of heights of the people in the queue k: int - The maximum number of swaps allowed return: List[int] - The array sorted in non-decreasing order n = len(heights) if n <= 1: return heights # Create a list of the original indices of the elements indexed_heights = list(enumerate(heights)) # Sort the list based on heights indexed_heights.sort(key=lambda x: x[1]) # Create a boolean array to keep track of visited elements visited = [False] * n swaps = 0 for i in range(n): # If element is already visited or is already at the correct position, skip if visited[i] or indexed_heights[i][0] == i: continue # Calculate the number of nodes in this cycle cycle_length = 0 j = i while not visited[j]: visited[j] = True j = indexed_heights[j][0] cycle_length += 1 # Add the number of swaps needed for this cycle if cycle_length > 0: swaps += (cycle_length - 1) # If the number of swaps exceeds k, return original array if swaps > k: return heights # Result array after potentially swapping result = [0] * n for i, (orig_idx, height) in enumerate(indexed_heights): result[i] = height return result"},{"question":"Given a binary tree where each node contains an integer value, implement a function to determine if there exists a root-to-leaf path such that adding up all the values along the path equals a given sum. A leaf is a node with no children. For example, given the tree: ``` 5 / 4 8 / / 11 13 4 / 7 2 1 ``` And the sum = 22, the path 5→4→11→2 equals 22, so return `true`. The function should return `false` if no such path can be found. Implement a function with the following signature: ```python def hasPathSum(root: TreeNode, sum: int) -> bool: # Your code here ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root: TreeNode, sum: int) -> bool: if not root: return False sum -= root.val if not root.left and not root.right: return sum == 0 return hasPathSum(root.left, sum) or hasPathSum(root.right, sum)"},{"question":"You are given a **0-indexed** integer array `heights` of size `n` representing the heights of buildings in a line. You have a ladder and a certain number of bricks. You can use the ladder to climb any building regardless of the height, but you can only use the bricks to climb the difference in height between two consecutive buildings (you don\'t need bricks if the next building is shorter or of the same height). Write a function to return the farthest building index (0-based) you can reach if you start at building 0.","solution":"import heapq def furthest_building(heights, bricks, ladders): max_heap = [] n = len(heights) for i in range(n - 1): diff = heights[i + 1] - heights[i] if diff > 0: heapq.heappush(max_heap, diff) if len(max_heap) > ladders: bricks -= heapq.heappop(max_heap) if bricks < 0: return i return n - 1"},{"question":"A parking lot is represented as a grid of size `n x m`, where each cell can be either empty (`0`) or occupied by a car (`1`). You need to count the number of isolated cars in the parking lot. A car is considered isolated if it is not adjacent to any other car. Adjacent means horizontally or vertically (not diagonally). Given the `n x m` grid representing the parking lot, return the number of isolated cars. ```python def count_isolated_cars(parking_lot): # Your code here ```","solution":"def count_isolated_cars(parking_lot): Counts the number of isolated cars in the parking lot grid. An isolated car is one that is not adjacent to any other car. :param parking_lot: List of lists where each element is 0 (empty) or 1 (occupied). :return: Integer count of isolated cars. n = len(parking_lot) m = len(parking_lot[0]) if n > 0 else 0 isolated_cars = 0 for i in range(n): for j in range(m): if parking_lot[i][j] == 1: # Check adjacent cells if (i > 0 and parking_lot[i-1][j] == 1) or (i < n-1 and parking_lot[i+1][j] == 1) or (j > 0 and parking_lot[i][j-1] == 1) or (j < m-1 and parking_lot[i][j+1] == 1): continue isolated_cars += 1 return isolated_cars"},{"question":"Suppose you are given a 2D matrix filled with integers, where each row is sorted in ascending order from left to right, and each column is sorted in ascending order from top to bottom. Write a function that takes this matrix and a target integer as inputs and returns a boolean indicating whether the target integer exists in the matrix. Optimize your algorithm to run in O(m + n) time complexity, where m is the number of rows and n is the number of columns. Implement the `Solution` class: * `Solution(int[][] matrix, int target)` Initializes the object with the 2D matrix and the target integer. * `boolean searchTarget()` Returns `true` if the target integer is in the matrix, and `false` otherwise.","solution":"class Solution: def __init__(self, matrix, target): self.matrix = matrix self.target = target def searchTarget(self): if not self.matrix or not self.matrix[0]: return False rows = len(self.matrix) cols = len(self.matrix[0]) # Start from the top-right corner row = 0 col = cols - 1 while row < rows and col >= 0: if self.matrix[row][col] == self.target: return True elif self.matrix[row][col] < self.target: row += 1 else: col -= 1 return False"},{"question":"You are given a list of movies, where each movie is represented by its start and end times. You need to schedule the maximum number of non-overlapping movies to watch completely. A movie [start, end] includes its start time and ends exactly at its end time. Implement the function `maxMovies(movies)` that takes a list of movies and returns the maximum number of non-overlapping movies that can be watched. For example, given the list of movies `[[1, 4], [2, 5], [3, 6], [7, 9], [8, 10]]`, the maximum number of non-overlapping movies you can watch is 2 (i.e., the movies [1, 4] and [7, 9]).","solution":"def maxMovies(movies): # First, sort movies by their end times movies.sort(key=lambda x: x[1]) end_time = float(\'-inf\') count = 0 for movie in movies: if movie[0] >= end_time: count += 1 end_time = movie[1] return count"},{"question":"You are given a list of `n` integers, `arr`, and an integer `k`. Write a function to find the `k-th` largest element in the list without sorting it. Implement the function using a min-heap to achieve an optimal time complexity. The function signature should be `def find_kth_largest(arr: List[int], k: int) -> int`. The function should return an integer representing the `k-th` largest element in the list.","solution":"from typing import List import heapq def find_kth_largest(arr: List[int], k: int) -> int: Finds and returns the k-th largest element in the list using a min-heap. if not arr or k <= 0 or k > len(arr): raise ValueError(\\"Invalid input parameters\\") # Initialize a min-heap with the first k elements of the list min_heap = arr[:k] heapq.heapify(min_heap) # O(k) # Traverse through the remaining elements for num in arr[k:]: if num > min_heap[0]: # Compare with the smallest element in the min-heap heapq.heapreplace(min_heap, num) # O(log k) # The root of the heap is the k-th largest element return min_heap[0]"},{"question":"There are `n` gas stations along a circular route. You are given two integer arrays `gas` and `cost` of length `n`, where `gas[i]` represents the amount of fuel at the `ith` gas station and `cost[i]` represents the fuel needed to travel from the `ith` gas station to the next one. You have a car with an unlimited gas tank and good mileage, but you start with an empty tank. Return the starting gas station\'s index if you can travel around the circuit once in the clockwise direction. If there\'s no solution, return `-1`. If there are multiple solutions, return any one of them.","solution":"def can_complete_circuit(gas, cost): Returns the starting gas station index if a circular trip is possible. If no such trip is possible, returns -1. :param gas: List[int] - Amount of fuel at each gas station. :param cost: List[int] - Fuel needed to travel to the next station. :return: int - Index of the starting gas station, or -1 if no such index exists. total_tank, curr_tank = 0, 0 start_station = 0 for i in range(len(gas)): total_tank += gas[i] - cost[i] curr_tank += gas[i] - cost[i] # If one cannot start from start_station to current i if curr_tank < 0: start_station = i + 1 curr_tank = 0 return start_station if total_tank >= 0 else -1"},{"question":"Given an integer array `difficulty` where `difficulty[i]` represents the difficulty level of the `i-th` task, and a 2D integer array `worker` where `worker[i][0]` represents the skill level of the `i-th` worker and `worker[i][1]` represents the stamina level of the `i-th` worker. You need to implement a function `assignTasks` that returns the maximum number of tasks that can be assigned to the workers. A worker can only be assigned to a task if the worker\'s skill level is greater than or equal to the task\'s difficulty and the worker\'s stamina level is greater than or equal to the task\'s difficulty. Each worker can be assigned to at most one task, and each task can be assigned to at most one worker.","solution":"def assignTasks(difficulty, worker): Given the difficulty of tasks and the skill and stamina level of workers, returns the maximum number of tasks that can be assigned to the workers. Parameters: difficulty (List[int]): A list of integers representing the difficulty levels of tasks. worker (List[List[int]]): A list of lists representing the workers, where each worker is represented by a pair [skill, stamina]. Returns: int: The maximum number of tasks that can be assigned to the workers. # Sort tasks and workers by their respective difficulty and skill+stamina levels. difficulty.sort() workers = sorted(worker, key=lambda x: (x[0], x[1])) # Start assigning tasks to the workers from the least to most difficult task_idx, worker_idx = 0, 0 task_count = 0 while task_idx < len(difficulty) and worker_idx < len(workers): if workers[worker_idx][0] >= difficulty[task_idx] and workers[worker_idx][1] >= difficulty[task_idx]: # Assign task to worker if the worker\'s skill and stamina levels are sufficient task_count += 1 task_idx += 1 worker_idx += 1 else: # Move to the next worker if the current worker can\'t handle the current task worker_idx += 1 return task_count"},{"question":"You are given a linked list where each node contains an integer value. Also given are two integers `left` and `right` which represent the positions (1-indexed) of the nodes in the linked list that need to be reversed. Reverse the nodes from position `left` to `right` and return the modified linked list. The constraint is that you must reverse the sublist in-place without using extra space for list nodes.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_between(head, left, right): if not head or left == right: return head dummy = ListNode(0, head) prev = dummy for _ in range(left - 1): prev = prev.next curr = prev.next next = None for _ in range(right - left): next = curr.next curr.next = next.next next.next = prev.next prev.next = next return dummy.next"},{"question":"You are given a binary tree with `n` nodes where each node has a unique value from `1 to n`. The root of the tree is `root`. Implement the `BinaryTree` class: - `BinaryTree(int[][] edges, int root)` Initializes the object with the `edges` array representing the connections between nodes and the `root` value specifying the root of the tree. - `int findLCA(int node1, int node2)` Returns the lowest common ancestor (LCA) of the two nodes `node1` and `node2`. The LCA of two nodes `node1` and `node2` is the lowest node that has both `node1` and `node2` as descendants (where we allow a node to be a descendant of itself). For example, given the edges `[[1, 2], [1, 3], [2, 4], [2, 5]]` and the root `1`, a call to `findLCA(4, 5)` should return `2`, and a call to `findLCA(4, 3)` should return `1`.","solution":"class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None class BinaryTree: def __init__(self, edges, root): self.nodes = {} for edge in edges: parent, child = edge if parent not in self.nodes: self.nodes[parent] = TreeNode(parent) if child not in self.nodes: self.nodes[child] = TreeNode(child) self.add_child(self.nodes[parent], self.nodes[child]) self.root = self.nodes[root] def add_child(self, parent, child): if not parent.left: parent.left = child else: parent.right = child def findLCAUtil(self, root, node1, node2): if root is None: return None if root.val == node1 or root.val == node2: return root left_lca = self.findLCAUtil(root.left, node1, node2) right_lca = self.findLCAUtil(root.right, node1, node2) if left_lca and right_lca: return root return left_lca if left_lca else right_lca def findLCA(self, node1, node2): lca = self.findLCAUtil(self.root, node1, node2) return lca.val if lca else -1"},{"question":"A company has `n` employees, each assigned to one of several projects. The employees work in teams, and each team is associated with exactly one project. You are given an array `projects` where `projects[i] = pi` indicates the project to which the `i-th` employee is assigned. To ensure proper management and oversight, each project\'s team should have enough team leads. The company defines a team as balanced if each project\'s team size is strictly greater than a given number `k`. Write a function that checks if all project teams are balanced according to this rule. Return `true` if all project teams are balanced and `false` otherwise.","solution":"def are_projects_balanced(projects, k): Checks if all project teams are balanced. :param projects: List of integers where projects[i] = pi indicates the project to which the i-th employee is assigned. :param k: Integer representing the minimum required team size. :return: True if all project teams are balanced, False otherwise. from collections import Counter project_counts = Counter(projects) for count in project_counts.values(): if count <= k: return False return True"},{"question":"Given a string `s` and an integer `k`, you need to implement a function that determines if it is possible to rearrange the characters in the string such that no two adjacent characters are the same. If possible, return one possible rearranged string. Otherwise, return an empty string. Note: You can assume that the input string only consists of lowercase English letters.","solution":"from collections import Counter import heapq def rearrange_string(s, k): Rearrange the characters of the string such that no two adjacent characters are the same. If not possible, return an empty string. if k == 0: return s count = Counter(s) max_heap = [(-val, key) for key, val in count.items()] heapq.heapify(max_heap) result = [] wait_queue = [] while max_heap: current_count, current_char = heapq.heappop(max_heap) result.append(current_char) wait_queue.append((current_count + 1, current_char)) if len(wait_queue) < k: continue next_count, next_char = wait_queue.pop(0) if next_count < 0: heapq.heappush(max_heap, (next_count, next_char)) if len(result) != len(s): return \\"\\" return \'\'.join(result)"},{"question":"You are given a list of `numbers` representing the values of cards in a card game. Each player makes a move by selecting two different cards, `numbers[i]` and `numbers[j]`, and replaces them with a single new card whose value is the sum of `numbers[i]` and `numbers[j]`. The players continue this process until only one card remains in the game. The final card\'s value is the score of the game. Write a function that, given an integer array `numbers` of length `n`, returns the maximum possible score for the final card\'s value if the players choose optimally to maximize it.","solution":"def max_final_card_value(numbers): Returns the maximum possible score for the final card\'s value if the players choose optimally to maximize it by summing pairs of card values. total_score = sum(numbers) return total_score"},{"question":"You are given a binary tree where each node contains a value, and each value is an integer. The **zigzag level order traversal** of a binary tree is defined as follows: for the first level, traverse from left to right, for the second level, traverse from right to left, and continue this zigzag pattern for subsequent levels. Return the zigzag level order traversal of the binary tree as a list of lists, where each list represents one level of the tree.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): Returns the zigzag level order traversal of a binary tree. Args: root (TreeNode): The root of the binary tree. Returns: List[List[int]]: The zigzag level order traversal of the tree. if not root: return [] result = [] current_level = deque([root]) left_to_right = True while current_level: level_size = len(current_level) current_vals = deque() for _ in range(level_size): node = current_level.popleft() if left_to_right: current_vals.append(node.val) else: current_vals.appendleft(node.val) if node.left: current_level.append(node.left) if node.right: current_level.append(node.right) result.append(list(current_vals)) left_to_right = not left_to_right return result"},{"question":"You are given a **0-indexed** integer array `nums`. You are allowed to perform the following operation any number of times: Choose an element `nums[i]` and set `nums[i]` to `nums[i] + 1` or `nums[i] - 1`. The cost of each operation is `1`. Find the **minimum** cost to make all elements in the array equal. Return _an integer representing the minimum cost to make all elements equal._","solution":"def min_cost_to_make_equal(nums): Given a list of integers, return the minimum cost to make all elements equal. The cost of changing any element by ±1 is 1. nums.sort() median = nums[len(nums)//2] return sum(abs(num - median) for num in nums)"},{"question":"Given a set of `n` unique positive integers, determine if there exists a subset whose sum is equal to a given target number `targetSum`. If such a subset exists, return _a list of integers that represent a valid subset_. If no valid subset exists, return _an **empty** list_. You may return the integers in **any** order.","solution":"def subset_sum(nums, targetSum): Determine if there exists a subset of the list of unique positive integers `nums` whose sum is equal to `targetSum`. If such a subset exists, return a list containing the subset\'s integers. Otherwise, return an empty list. def dfs(index, current_sum, path): if current_sum == targetSum: return path if index >= len(nums) or current_sum > targetSum: return [] # Explore the path including nums[index] include_result = dfs(index + 1, current_sum + nums[index], path + [nums[index]]) if include_result: return include_result # Explore the path excluding nums[index] exclude_result = dfs(index + 1, current_sum, path) return exclude_result return dfs(0, 0, [])"},{"question":"You are given an array of integers `arr` and an integer `x`. Your task is to determine whether there exists a continuous subarray of `arr` whose sum is equal to `x`. If such a subarray exists, return `true`; otherwise, return `false`. The subarray should contain at least one element. For example, given `arr = [1, 2, 3, 7, 5]` and `x = 12`, there is a subarray `[5, 7]` which sums up to `12`. If `x = 15`, then the subarray `[1, 2, 3, 7, 5]` sums up to `15`.","solution":"def has_subarray_with_sum(arr, x): Determines if there is a continuous subarray in `arr` whose sum is equal to `x`. Parameters: arr (list of int): The array to check. x (int): The target sum. Returns: bool: True if such subarray exists, False otherwise. current_sum = 0 sums_dict = {} for i, num in enumerate(arr): current_sum += num if current_sum == x: return True if (current_sum - x) in sums_dict: return True sums_dict[current_sum] = i return False"},{"question":"You are given an array of strings `products` and a string `searchWord`. Design a system that suggests the top three product names from `products` after each character of `searchWord` is typed. Suggested products should have common prefix with the searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products. Return a list of lists of the suggested products after each character of `searchWord` is typed.","solution":"def suggested_products(products, searchWord): Returns a list of lists of the suggested products after each character of searchWord is typed. products.sort() result = [] prefix = \\"\\" for char in searchWord: prefix += char suggestions = [] for product in products: if product.startswith(prefix): suggestions.append(product) if len(suggestions) == 3: break result.append(suggestions) return result"},{"question":"Given an integer array `nums` which represents the earnings from each user per day, define a function `max_consecutive_sum` to find the maximum sum of any contiguous subarray of `nums`, where the length of the subarray is at least one. Implement the function as follows: ```python def max_consecutive_sum(nums: List[int]) -> int: # your code here ``` The function should return an integer representing the maximum sum of the contiguous subarray.","solution":"from typing import List def max_consecutive_sum(nums: List[int]) -> int: Returns the maximum sum of any contiguous subarray of nums. :param nums: List[int] - List of integers representing daily earnings. :return: int - The maximum sum of any contiguous subarray. if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an integer array `nums`. You need to find the **maximum product** of any three numbers in the array. Return the _maximum product_ of any three numbers from the given list. def maximumProduct(nums: List[int]) -> int:","solution":"from typing import List def maximumProduct(nums: List[int]) -> int: Returns the maximum product of any three numbers in the given list `nums`. nums.sort() # The maximum product of any three numbers could be either from # the last three numbers (max1) or the product of the two smallest # and the largest number (max2) max1 = nums[-1] * nums[-2] * nums[-3] max2 = nums[0] * nums[1] * nums[-1] return max(max1, max2)"},{"question":"You are given a list of integers `nums` where each integer represents the number of votes a candidate received in an election. The list contains `n` integers, where `n` is the total number of candidates. Your task is to find the candidate(s) who received the maximum number of votes. Return a list of all candidates (indices of the `nums` list) who received the maximum number of votes. If multiple candidates have the maximum number of votes, return their indices in ascending order.","solution":"def find_max_votes_candidates(nums): Finds candidate(s) who received the maximum number of votes. :param nums: List of integers representing votes. :return: List of indices of candidates with the maximum number of votes in ascending order. if not nums: return [] max_votes = max(nums) return [index for index, votes in enumerate(nums) if votes == max_votes]"},{"question":"Given a string `s` consisting of lowercase alphabets, you need to find the length of the longest substring with all distinct characters. Return the length of such a substring. If multiple valid substrings exist, their length will be the same, so return any one of them. The solution should be able to handle inputs up to length `10^4`.","solution":"def longest_substring_with_distinct_chars(s): Returns the length of the longest substring with all distinct characters. n = len(s) char_index = {} max_len = 0 start = 0 for end in range(n): if s[end] in char_index: start = max(start, char_index[s[end]] + 1) char_index[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"Given an array of integers `arr`, find the length of the longest subarray such that the difference between any two elements in this subarray is at most `limit`. Return the length of this subarray. You may assume that the array and `limit` are provided.","solution":"from collections import deque def longest_subarray(arr, limit): min_deque = deque() # To store the minimum values max_deque = deque() # To store the maximum values left = 0 result = 0 for right in range(len(arr)): # Ensuring max_deque stores decreasing elements while max_deque and arr[max_deque[-1]] <= arr[right]: max_deque.pop() max_deque.append(right) # Ensuring min_deque stores increasing elements while min_deque and arr[min_deque[-1]] >= arr[right]: min_deque.pop() min_deque.append(right) # If the current window is invalid, move the left pointer while arr[max_deque[0]] - arr[min_deque[0]] > limit: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() result = max(result, right - left + 1) return result"},{"question":"Given a string `s` and an integer `k`, determine the minimum number of characters you need to delete to obtain a string in which every character occurs at most `k` times. Return the minimum number of deletions required.","solution":"from collections import Counter def min_deletions(s, k): Determine the minimum number of deletions required so that every character in the string s occurs at most k times. :param s: A string of lowercase English letters :param k: An integer :return: Minimum number of deletions frequency = Counter(s) deletions = 0 for char, freq in frequency.items(): if freq > k: deletions += freq - k return deletions"},{"question":"You are given an integer array `prices` where `prices[i]` is the price of the `i-th` item in a shop. You are also given a binary array `can_buy` where `can_buy[i]` is `1` if you are allowed to buy the `i-th` item and `0` otherwise. You have a budget `budget`. Return _the maximum number of items you can buy without exceeding the given budget_.","solution":"def max_items(prices, can_buy, budget): Returns the maximum number of items that can be bought without exceeding the given budget. Parameters: prices (List[int]): Array of prices of the items. can_buy (List[int]): Binary array indicating if the item can be bought. budget (int): Available budget. Returns: int: Maximum number of items that can be bought. # Filter the items that can be bought and their corresponding prices buyable_items = [prices[i] for i in range(len(prices)) if can_buy[i] == 1] # Sort the prices of buyable items in ascending order buyable_items.sort() # Initialize count of items that can be bought and the total current cost item_count = 0 current_cost = 0 # Iterate through the sorted prices of buyable items and calculate the total cost for price in buyable_items: if current_cost + price <= budget: current_cost += price item_count += 1 else: break return item_count"},{"question":"Given a list of integer intervals `intervals`, where each interval `intervals[i] = [starti, endi]` represents a range of integers from `starti` to `endi` (inclusive), determine the maximum number of non-overlapping intervals from the list. An interval is non-overlapping if it does not share any numbers with another interval in the selected subset. Return the maximum number of non-overlapping intervals that can be selected.","solution":"def max_non_overlapping_intervals(intervals): Returns the maximum number of non-overlapping intervals. :param intervals: List[List[int]], a list of integer intervals :return: int, the maximum number of non-overlapping intervals if not intervals: return 0 # Sort intervals by their ending times intervals.sort(key=lambda x: x[1]) max_count = 0 end_time = float(\'-inf\') for interval in intervals: if interval[0] > end_time: max_count += 1 end_time = interval[1] return max_count"},{"question":"Given a list of strings `words`, you need to arrange them in such a way that no two adjacent strings have the same length. If it is not possible to arrange the strings to meet this condition, return an empty list. Otherwise, return a list of rearranged strings. For example, if the input is `words = [\\"apple\\", \\"bat\\", \\"at\\", \\"dog\\", \\"fish\\"]`, one possible rearrangement is `[\\"bat\\", \\"apple\\", \\"at\\", \\"dog\\", \\"fish\\"]`.","solution":"from collections import defaultdict def rearrange_words(words): Rearranges the words such that no two adjacent words have the same length. Returns an empty list if not possible. length_dict = defaultdict(list) # Group words by their length for word in words: length_dict[len(word)].append(word) # Sort the lengths sorted_lengths = sorted(length_dict.keys()) # Try to rearrange the words by alternating lengths rearranged_words = [] while sorted_lengths: cycle = sorted_lengths.copy() for length in cycle: if length_dict[length]: rearranged_words.append(length_dict[length].pop()) if not length_dict[length]: sorted_lengths.remove(length) # Check if the arrangement is valid for i in range(1, len(rearranged_words)): if len(rearranged_words[i]) == len(rearranged_words[i-1]): return [] return rearranged_words"},{"question":"You are given a 2D integer array `matrix` of size `m x n` representing a labyrinth where `matrix[i][j] == 0` represents an open path and `matrix[i][j] == 1` represents a blocked path. Two cells are considered connected if they are adjacent horizontally or vertically, but not diagonally. Starting from the top-left cell (`0, 0`), determine if there is a way to reach the bottom-right cell (`m - 1, n - 1`) while only moving through cells with `0`. Return `true` if such a path exists, otherwise return `false`. Implement the `LabyrinthPathFinder` class: * `LabyrinthPathFinder(int[][] matrix)` Initializes the object with a 2D matrix representing the labyrinth. * `boolean isPathPossible()` Returns `true` if there is a path from the top-left cell to the bottom-right cell, otherwise returns `false`.","solution":"class LabyrinthPathFinder: def __init__(self, matrix): self.matrix = matrix self.m = len(matrix) self.n = len(matrix[0]) self.visited = [[False for _ in range(self.n)] for _ in range(self.m)] def isPathPossible(self): if self.matrix[0][0] == 1 or self.matrix[self.m - 1][self.n - 1] == 1: return False return self.dfs(0, 0) def dfs(self, x, y): if x == self.m - 1 and y == self.n - 1: return True self.visited[x][y] = True directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < self.m and 0 <= ny < self.n and not self.visited[nx][ny] and self.matrix[nx][ny] == 0: if self.dfs(nx, ny): return True return False"},{"question":"Given a string, return the length of the longest substring with all distinct characters. If all characters are unique in the string, this will be the length of the string itself. If the string is empty, return 0.","solution":"def longest_unique_substring_length(s): Returns the length of the longest substring with all distinct characters. char_index_map = {} max_length = 0 start = 0 for end, char in enumerate(s): if char in char_index_map: start = max(start, char_index_map[char] + 1) char_index_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given an array of integers `arr`. Your task is to find the length of the longest subsequence in `arr` such that all elements of the subsequence are sorted in a strictly increasing order. Return the length of the longest subsequence.","solution":"def length_of_lis(arr): Returns the length of the longest strictly increasing subsequence. if not arr: return 0 # dp[i] will hold the length of the longest increasing subsequence # that ends with arr[i] dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(0, i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence will be the max value in dp return max(dp)"},{"question":"Given a list of `logs` where each log entry is a string in the format `\\"id timestamp event\\"`, implement a function to retrieve the logs within a specified time range. The `timestamp` is an integer representing seconds from the start of the day, so it ranges from `0` to `86399`. Implement the function `filterLogs(logs, start, end)` that returns a list of logs whose timestamps are within the specified `start` and `end` range (inclusive). The returned list of logs should be in the same order as they appear in the input list. `start` and `end` are both integers denoting the starting and ending timestamps, respectively.","solution":"def filterLogs(logs, start, end): Filters the logs to only include those within the specified time range. Parameters: logs (list): List of log entries where each log is a string in the format \\"id timestamp event\\". start (int): Start of the time range (inclusive). end (int): End of the time range (inclusive). Returns: list: List of logs within the specified time range. filtered_logs = [] for log in logs: parts = log.split() timestamp = int(parts[1]) if start <= timestamp <= end: filtered_logs.append(log) return filtered_logs"},{"question":"You are given an array of `n` positive integers `nums`, representing the amount of money of each house. Assume all houses are arranged in a circle. To maximize the amount of money stolen, you cannot steal from two adjacent houses, including the first and last house since they are adjacent in a circular arrangement. Return _the maximum amount of money you can rob without robbing two adjacent houses._ **Example:** ```plaintext Input: nums = [2, 3, 2] Output: 3 Explanation: You cannot rob house 1 (money 2) and then rob house 3 (money 2), as they are adjacent in a circle. The maximum amount you can rob is either house 2 (money 3) or house 1 (money 2) + house 3 (money 2). ``` ```plaintext Input: nums = [1, 2, 3, 1] Output: 4 Explanation: Rob house 1 (money 1) and then rob house 3 (money 3). The total amount is 1 + 3 = 4. ```","solution":"def rob(nums): Returns the maximum amount of money that can be robbed from houses arranged in a circle. if not nums: return 0 if len(nums) == 1: return nums[0] # Helper function to rob a range of houses (non-circular) def rob_linear(nums): prev = curr = 0 for num in nums: prev, curr = curr, max(curr, prev + num) return curr # Rob excluding the first house or excluding the last house return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"You are designing a system that manages a collection of events happening in a calendar. Each event has a start time and an end time, and events may overlap. Implement a data structure that can: * Add a new event to the calendar, ensuring no two events with overlapping times are allowed. * Return `true` if the event is successfully added, and `false` if it cannot be added due to a conflict with an existing event. The `MyCalendar` class should be implemented as follows: * `MyCalendar()` Initializes the calendar object. * `boolean book(int start, int end)` Attempts to add an event with a given `start` and `end` time to the calendar. Returns `true` if the event can be added without any overlaps and `false` otherwise.","solution":"class MyCalendar: def __init__(self): self.events = [] def book(self, start, end): Attempts to add an event with a given start and end times. Returns True if the event can be added without any overlaps, False otherwise. for event_start, event_end in self.events: if not (end <= event_start or start >= event_end): return False self.events.append((start, end)) return True"},{"question":"You have a list of strings `words` and you want to group the anagrams together. Write a function that returns a list of lists of anagrams that are grouped together. Each list of anagrams must be sorted in lexicographical order and the list of lists should be sorted in ascending order based on the first string of each group. For example, given the list `words = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]`, the function should return `[[\\"ate\\", \\"eat\\", \\"tea\\"], [\\"bat\\"], [\\"nat\\", \\"tan\\"]]`. Write a function that implements this behavior.","solution":"def group_anagrams(words): from collections import defaultdict anagrams = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) result = [] for key in anagrams: result.append(sorted(anagrams[key])) return sorted(result, key=lambda x: x[0])"},{"question":"You are given a matrix of `m x n` size, filled with non-negative integers, representing different heights on a topographic map. The **Pacific ocean** touches the left and top edges of the matrix and the **Atlantic ocean** touches the right and bottom edges. Each cell in the matrix can flow water to neighboring cells directly north, south, east, or west if the neighboring cell\'s height is less than or equal to the current cell\'s height. Find all cells from which water can flow to both the Pacific and Atlantic oceans. Return the list of grid coordinates (i.e., 2D list) _`result`_, where `result[i] = [ri, ci]` denotes that water can flow from cell `(ri, ci)` to both oceans.","solution":"def pacific_atlantic(matrix): if not matrix: return [] def dfs(matrix, visited, i, j): visited[i][j] = True for direction in directions: x, y = i + direction[0], j + direction[1] if 0 <= x < m and 0 <= y < n and not visited[x][y] and matrix[x][y] >= matrix[i][j]: dfs(matrix, visited, x, y) m, n = len(matrix), len(matrix[0]) pacific_reachable = [[False] * n for _ in range(m)] atlantic_reachable = [[False] * n for _ in range(m)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for i in range(m): dfs(matrix, pacific_reachable, i, 0) dfs(matrix, atlantic_reachable, i, n-1) for j in range(n): dfs(matrix, pacific_reachable, 0, j) dfs(matrix, atlantic_reachable, m-1, j) result = [] for i in range(m): for j in range(n): if pacific_reachable[i][j] and atlantic_reachable[i][j]: result.append([i, j]) return result"},{"question":"You are given the root of a binary search tree (BST) and an integer `k`. Implement a function to find the `k-th` smallest element in the BST. You may assume that the tree has at least `k` elements. The function should have the following signature: ```python def kthSmallest(root: Optional[TreeNode], k: int) -> int: # Your code here ``` Where `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Ensure your solution is efficient and leverages the properties of binary search trees.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kthSmallest(root: Optional[TreeNode], k: int) -> int: # In-order traversal of BST yields elements in a sorted order stack = [] current = root count = 0 while True: while current: stack.append(current) current = current.left current = stack.pop() count += 1 if count == k: return current.val current = current.right"},{"question":"You are given an m x n grid `grid` where each cell may contain a non-negative integer representing the amount of gold in that cell. You can start and stop collecting gold from any cell in the grid that contains gold. From a cell, you can move to any of the four directions: left, right, up, or down to another cell that contains gold. However, to avoid collecting gold from the same cell more than once, you have to stop collecting gold and move out from that cell after collecting the gold from it. The task is to find the maximum amount of gold you can collect starting from any cell in the grid. Implement the function `int getMaximumGold(int[][] grid)` that returns the maximum amount of gold you can collect. # Example: ``` Input: grid = [[0,6,0],[5,8,7],[0,9,0]] Output: 24 Explanation: 0 6 0 5 8 7 0 9 0 The path to the maximum amount of gold is 9 -> 8 -> 7. ``` # Constraints: - `0 <= m, n <= 15` - `0 <= grid[i][j] <= 100` - There are at most 25 cells containing gold.","solution":"def getMaximumGold(grid): def dfs(x, y, current_gold): current_gold += grid[x][y] max_gold = current_gold temp = grid[x][y] grid[x][y] = 0 # Mark the cell as visited by setting it to 0 # Explore all four possible directions for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] > 0: max_gold = max(max_gold, dfs(nx, ny, current_gold)) grid[x][y] = temp # Unmark the cell return max_gold max_gold_collected = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] > 0: max_gold_collected = max(max_gold_collected, dfs(i, j, 0)) return max_gold_collected"},{"question":"You are given an integer array `arr` and a pivot integer `pivot`. Rearrange the elements of `arr` so that all elements less than `pivot` appear before all elements equal to `pivot`, and those should appear before all elements greater than `pivot`. After rearranging, the relative order of the elements in each of the three partitions should be preserved. For instance, given `arr` = [7, 4, 3, 9, 3, 5, 1] and `pivot` = 4, the result should be [3, 3, 1, 4, 7, 9, 5]. Return the array after rearranging it according to the described rules.","solution":"def rearrange_array(arr, pivot): Rearranges the array such that: - All elements less than the pivot appear before all elements equal to the pivot, - All elements equal to the pivot appear before all elements greater than the pivot. The relative order of the elements in each of the three partitions is preserved. Parameters: arr (list of int): The list of integers to be rearranged. pivot (int): The pivot integer. Returns: list of int: The rearranged list. less_than_pivot = [] equal_to_pivot = [] greater_than_pivot = [] for num in arr: if num < pivot: less_than_pivot.append(num) elif num == pivot: equal_to_pivot.append(num) else: greater_than_pivot.append(num) return less_than_pivot + equal_to_pivot + greater_than_pivot"},{"question":"Write a function that takes a list of integers and returns the list of sums of all unique subsets of the given list. Each subset should contain at least one element, and subsets that have the same sum should only be included once in the result. The result list should be sorted in ascending order. For example, given the list `[1, 2, 2]`, the function should return `[1, 2, 3, 4, 5]` because the unique subsets and their sums are: `[1] -> 1`, `[2] -> 2`, `[1, 2] -> 3`, `[2, 2] -> 4`, `[1, 2, 2] -> 5`.","solution":"from itertools import combinations def unique_subset_sums(nums): Returns the list of sums of all unique subsets of the given list where each subset has at least one element. Each subset\'s sum should be unique and the result list should be sorted in ascending order. Parameters: nums (list): List of integers. Returns: list: Sorted list of unique sums of all subsets of nums. unique_sums = set() n = len(nums) # Iterate over all possible subset lengths from 1 to n inclusive for r in range(1, n + 1): for subset in combinations(nums, r): unique_sums.add(sum(subset)) return sorted(unique_sums)"},{"question":"Given a string `s` consisting of lowercase letters, you need to replace some characters in `s` to make it a palindrome. Return the minimum number of characters you need to replace to make `s` a palindrome. A palindrome is a string that reads the same backward as forward.","solution":"def min_replacements_to_palindrome(s): Returns the minimum number of characters required to replace to make the string a palindrome. n = len(s) replacements = 0 # Compare characters from the beginning and the end of the string moving towards the center for i in range(n // 2): if s[i] != s[n - i - 1]: replacements += 1 return replacements"},{"question":"You are given a **0-indexed** integer array `coins` where `coins[i]` represents the number of coins in the `ith` pile. A game is played according to the following rules: * You can pick any pile of coins from the array. * Each time you pick a pile, you must take at least one coin but not more than half of the coins in that pile. * You should take coins in such a way that the sum of the coins picked is maximized. Return _the **maximum** number of coins you can pick following the rules of the game_.","solution":"def max_coins(coins): Returns the maximum number of coins that can be picked following the game rules. :param coins: List[int], list of piles with coins. :return: int, maximum number of coins that can be picked. total_coins = 0 for pile in sorted(coins, reverse=True): total_coins += pile // 2 return total_coins"},{"question":"You are given a list of strings `words` and a string `pattern`. Each string in `words` can be transformed into the `pattern` by changing each letter in the string `words[i]` to any letter, preserving the order of characters, but different letters must map to different letters. For example, \\"abc\\" can be transformed to \\"mno\\" but not to \\"mmo\\". Return _a list of all the strings in `words` that match the given pattern_.","solution":"def find_and_replace_pattern(words, pattern): def is_match(word, pattern): if len(word) != len(pattern): return False w_to_p = {} p_to_w = {} for w, p in zip(word, pattern): if w in w_to_p and w_to_p[w] != p: return False if p in p_to_w and p_to_w[p] != w: return False w_to_p[w] = p p_to_w[p] = w return True return [word for word in words if is_match(word, pattern)]"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a city. A building is defined as good if its height is greater than or equal to all buildings to its left, including itself. Return the number of good buildings in the array. Consider the following example: Example: For `heights = [3, 1, 4, 5, 2]`, the output should be `3` because the buildings with heights 3, 4, and 5 are good.","solution":"def count_good_buildings(heights): Returns the number of good buildings in the array heights. A building is considered good if its height is greater than or equal to all buildings to its left, including itself. :param heights: List[int] - list of building heights :return: int - number of good buildings in the heights array if not heights: return 0 max_height = heights[0] good_count = 1 # First building is always considered good for height in heights[1:]: if height >= max_height: good_count += 1 max_height = height return good_count"},{"question":"You are given a non-empty array of integers `nums` representing the amount of money of each house arranged in a line. Return the maximum amount of money you can rob tonight without alerting the police. The constraint on alerting the police is that you cannot rob two adjacent houses. Implement a function `rob(nums: List[int]) -> int` that solves this problem. **Example:** ``` Input: nums = [1, 2, 3, 1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. ``` **Note:** * 1 <= nums.length <= 100. * 0 <= nums[i] <= 400.","solution":"from typing import List def rob(nums: List[int]) -> int: Returns the maximum amount of money you can rob tonight without alerting the police. You cannot rob two adjacent houses. if not nums: return 0 if len(nums) == 1: return nums[0] rob1, rob2 = 0, 0 for n in nums: new_rob = max(rob1 + n, rob2) rob1 = rob2 rob2 = new_rob return rob2"},{"question":"You are given a list of `courses` where each course is represented as a tuple – its name (string) and its difficulty level (integer). A course schedule needs to be designed based on the following criteria: * Courses are sorted primarily by difficulty level in ascending order. * When two courses have the same difficulty level, they are further sorted lexicographically by their names. Write a function that takes in the list of `courses` and returns the sorted course schedule. Implement the function `sort_courses(courses: List[Tuple[str, int]]) -> List[Tuple[str, int]]`.","solution":"from typing import List, Tuple def sort_courses(courses: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts courses primarily by difficulty level in ascending order. When two courses have the same difficulty level, they are further sorted lexicographically by their names. Parameters: courses (List[Tuple[str, int]]): A list of tuples where each tuple contains the course name and its difficulty level. Returns: List[Tuple[str, int]]: A list of sorted courses based on the specified criteria. return sorted(courses, key=lambda course: (course[1], course[0]))"},{"question":"Given two non-negative integers `a` and `b`, find the **minimum number of operations** required to make `a` equal to `b`. In one operation, you can either **increment** `a` by 1, **decrement** `a` by 1, or **double** the value of `a`. Return the minimum number of operations needed to transform `a` to `b`.","solution":"from collections import deque def min_operations(a, b): Returns the minimum number of operations to transform a into b. if a == b: return 0 # Use a queue for BFS queue = deque([(a, 0)]) # each element is a tuple (current_value, steps) visited = set([a]) while queue: current, steps = queue.popleft() # Possible operations: increment, decrement, double next_values = [current + 1, current - 1, current * 2] for next_value in next_values: if next_value == b: return steps + 1 if next_value not in visited and next_value >= 0: visited.add(next_value) queue.append((next_value, steps + 1)) return -1 # Should never reach here as b is eventually reachable"},{"question":"You are given two strings `s1` and `s2` of equal length, consisting of lowercase English letters. Your task is to determine if it is possible to make these two strings equal by swapping the letters of `s1` within the same string any number of times. Formally, you should check if `s1` can be rearranged to match `s2`. Return `true` if it is possible, otherwise return `false`. *For example*, given `s1 = \\"abc\\"` and `s2 = \\"bca\\"`, the result would be `true` as `s1` can be rearranged to form `s2`. For `s1 = \\"aab\\"` and `s2 = \\"abc\\"`, the result would be `false`.","solution":"def can_rearrange_to_match(s1, s2): Returns True if s1 can be rearranged to match s2, otherwise False. return sorted(s1) == sorted(s2)"},{"question":"You are given a string `s` that consists of only lowercase English letters. A **rearrangement** of a string means that the characters can be arranged in any order. Determine if a permutation of the string can form a palindrome. Return `true` if it\'s possible to rearrange the string `s` to form a palindrome, otherwise return `false`.","solution":"def can_form_palindrome(s): Determine if a permutation of the string can form a palindrome. Args: s (str): The input string. Returns: bool: True if a permutation of the string can form a palindrome, else False. from collections import Counter # Count frequency of each character in the string char_count = Counter(s) # A string can be rearranged into a palindrome if at most one character has an odd count odd_count = sum(count % 2 for count in char_count.values()) return odd_count <= 1"},{"question":"Given a directed graph with `n` nodes labeled from `0` to `n-1`, you are given a list of directed edges where `edges[i] = [a, b]` represents a directed edge from node `a` to node `b`. Write a function to determine if all nodes can be visited starting from node `0`. Return `true` if all nodes are reachable from node `0`, otherwise return `false`.","solution":"def can_visit_all_nodes(n, edges): Determines if all nodes can be visited starting from node 0. Parameters: n (int): Number of nodes. edges (List[List[int]]): Directed edges of the graph. Returns: bool: True if all nodes are reachable from node 0, otherwise False. from collections import defaultdict, deque graph = defaultdict(list) for a, b in edges: graph[a].append(b) visited = set() def bfs(start): queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: queue.append(neighbor) bfs(0) return len(visited) == n"},{"question":"You are given a list of integers `nums` representing the heights of different buildings. A building `i` can see the ocean if all the buildings to its right have height less than or equal to `nums[i]`. Return a list of indices of buildings that can see the ocean, in ascending order. **Example:** * Given `nums = [4, 2, 3, 1]`, buildings at indices `[0, 2, 3]` can see the ocean. * Given `nums = [4, 3, 2, 1]`, only the building at index `[0]` can see the ocean.","solution":"def find_buildings_with_ocean_view(nums): Returns the list of indices of buildings that can see the ocean. n = len(nums) ocean_view_indices = [] max_height_so_far = -1 for i in range(n - 1, -1, -1): if nums[i] > max_height_so_far: ocean_view_indices.append(i) max_height_so_far = nums[i] return sorted(ocean_view_indices)"},{"question":"You are given a string `s` consisting of only lowercase English letters. You are allowed to choose any letter from `s` and replace it with any other lowercase English letter. You want to make `s` consist of a single repeated character but want to minimize the number of replacements needed to achieve this. Return _the minimum number of replacements needed to make the string consist of a single repeated character._","solution":"def min_replacements_to_uniform_string(s): Returns the minimum number of replacements needed to make the string `s` consist of a single repeated character. :param s: A string consisting of lowercase English letters :return: The minimum number of replacements needed from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Find the most frequent character\'s count max_freq = max(freq.values()) # The minimum replacements needed will be the length of the string minus the count of the most frequent character return len(s) - max_freq"},{"question":"You are given a string `s` which represents a license key. The string consists of alphanumeric characters and dashes (`-`). The dashes split the string into groups of characters. You are also given an integer `k`. Your task is to format the string such that each group contains exactly `k` characters, except for the first group which can be shorter. To do so, the first group can contain exactly any number of characters less than or equal to `k`, but the following groups must all contain exactly `k` characters. Additionally, all letters should be converted to uppercase and the dashes should be removed in the final formatted string. Return _the reformatted license key as a string_.","solution":"def license_key_formatting(s, k): Formats the license key string according to the specified rule. Parameters: s (str): The string representing the license key. k (int): The number of characters each group should have. Returns: str: The formatted license key. # Remove all dashes and convert to upper case s = s.replace(\'-\', \'\').upper() # Calculate the length of the first group remainder = len(s) % k # Create a list to collect formatted groups formatted_parts = [] # Add the first group if there are extra characters if remainder: formatted_parts.append(s[:remainder]) # Add subsequent k-length parts for i in range(remainder, len(s), k): formatted_parts.append(s[i:i+k]) # Return the joined parts with dashes return \'-\'.join(formatted_parts)"},{"question":"Given a list of `strings` where each string represents a log entry from a system, each entry can be one of two types: 1. **Letter-log**: composed of an identifier and words, separated by spaces (e.g., `\\"a1 act car\\"`). 2. **Digit-log**: composed of an identifier and digits, separated by spaces (e.g., `\\"a2 3 6\\"`). The task is to reorder the logs such that: 1. The letter-logs come before all digit-logs. 2. The letter-logs are sorted lexicographically by their content. If their contents are identical, sort them by their identifiers. 3. The digit-logs remain in the same order in which they were received. Return the result as a list of log entries. **Example:** ``` Input: logs = [\\"a1 9 2 3 1\\", \\"g1 act car\\", \\"zo4 4 7\\", \\"ab1 off key dog\\", \\"a8 act zoo\\"] Output: [\\"g1 act car\\", \\"a8 act zoo\\", \\"ab1 off key dog\\", \\"a1 9 2 3 1\\", \\"zo4 4 7\\"] ```","solution":"def reorder_logs(logs): Reorders the logs such that the letter-logs come before all digit-logs. The letter-logs are sorted lexicographically by their content. If their contents are identical, sort them by their identifiers. The digit-logs remain in the same order in which they were received. def get_key(log): id_, rest = log.split(\\" \\", 1) return (0, rest, id_) if rest[0].isalpha() else (1,) return sorted(logs, key=get_key)"},{"question":"You are given a string `s` containing only lowercase and uppercase English letters. A **balanced string** is a string that has the same number of uppercase and lowercase letters. Your task is to split the string `s` into the maximum number of balanced strings. Return _the maximum number of balanced strings you can obtain_.","solution":"def balancedStringSplit(s): Returns the maximum number of balanced strings that can be obtained from the given string. balance_count = 0 max_balanced_strings = 0 for char in s: if char.isupper(): balance_count += 1 else: balance_count -= 1 if balance_count == 0: max_balanced_strings += 1 return max_balanced_strings"},{"question":"Given an integer `n`, generate all structurally unique **BSTs** (binary search trees) that store values `1 ... n`. Return _a list of all possible BSTs_. Each BST should be represented by its root node. You don\'t need to worry about the exact order of the returned list of trees.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generateTrees(n: int) -> List[Optional[TreeNode]]: if n == 0: return [] def generate(start, end): if start > end: return [None] all_trees = [] for i in range(start, end + 1): # Generate all left subtrees left_trees = generate(start, i - 1) # Generate all right subtrees right_trees = generate(i + 1, end) # Connect left and right subtrees to the root i for l in left_trees: for r in right_trees: current_tree = TreeNode(i) current_tree.left = l current_tree.right = r all_trees.append(current_tree) return all_trees return generate(1, n)"},{"question":"You are developing a social media platform, and you need to implement a notification system to alert users when their friends post new content. To achieve this, create a class `NotificationSystem` that supports the following operations: * `void addFriend(int user1, int user2)` - Establish a friendship between `user1` and `user2`. * `void post(int user, string content)` - User `user` posts `content`, alerting all friends. * `List<string> getNotifications(int user)` - Retrieve a list of notifications for `user`, in the order they were received. Users are identified by unique integer IDs. Notifications should contain the format \\"User {user} posted: {content}\\". Assume operations are called in chronological order.","solution":"class NotificationSystem: def __init__(self): self.friends = {} self.posts = {} def addFriend(self, user1, user2): if user1 not in self.friends: self.friends[user1] = set() if user2 not in self.friends: self.friends[user2] = set() self.friends[user1].add(user2) self.friends[user2].add(user1) def post(self, user, content): notification = f\\"User {user} posted: {content}\\" if user in self.friends: for friend in self.friends[user]: if friend not in self.posts: self.posts[friend] = [] self.posts[friend].append(notification) def getNotifications(self, user): if user not in self.posts: return [] return self.posts[user]"},{"question":"You are given an `m x n` integer matrix `grid` where each cell represents a height at that point. An ocean is located to the left of the matrix (first column) and another ocean is located to the top of the matrix (first row). Water can only flow from a cell to an adjacent one in all four directions if the adjacent cell\'s height is less than or equal to the current cell\'s height. Determine the set of all grid cells where water can flow to both the left and top oceans. Return _a 2D list containing all the coordinates of such cells in arbitrary order_.","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] def dfs(matrix, visited, height, x, y): m, n = len(matrix), len(matrix[0]) if (x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or matrix[x][y] < height): return visited[x][y] = True for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]: dfs(matrix, visited, matrix[x][y], x+dx, y+dy) m, n = len(matrix), len(matrix[0]) pacific_visited = [[False]*n for _ in range(m)] atlantic_visited = [[False]*n for _ in range(m)] for i in range(m): dfs(matrix, pacific_visited, float(\'-inf\'), i, 0) dfs(matrix, atlantic_visited, float(\'-inf\'), i, n-1) for j in range(n): dfs(matrix, pacific_visited, float(\'-inf\'), 0, j) dfs(matrix, atlantic_visited, float(\'-inf\'), m-1, j) result = [] for i in range(m): for j in range(n): if pacific_visited[i][j] and atlantic_visited[i][j]: result.append([i, j]) return result"},{"question":"A city\'s water supply system is represented as a directed graph with `n` nodes (numbered `1` through `n`) and `m` edges. Each node represents a junction, and each directed edge from node `u` to node `v` with a capacity `c` represents a pipe that can transport up to `c` liters of water per minute. You need to determine the **maximum** amount of water that can be transported from a given source junction `s` to a target junction `t`. Given integers `n`, `m`, `s`, and `t`, and a list of edges where each edge is represented as `(u, v, c)`, return the **maximum flow** from node `s` to node `t`. If there is no possible flow, return `0`. **Note:** - Each edge in the list of edges appears only once and represents a unique directed pipe with its specified capacity. - Ensure to apply an appropriate algorithm for finding the maximum flow in the network.","solution":"from collections import deque class MaxFlow: def __init__(self, n): self.size = n self.capacities = [[0] * n for _ in range(n)] self.flow_passed = [[0] * n for _ in range(n)] self.graph = [[] for _ in range(n)] self.parents = [-1] * n def add_edge(self, u, v, capacity): self.capacities[u][v] = capacity self.graph[u].append(v) self.graph[v].append(u) # Add backward edge for residual graph def bfs(self, source, sink): queue = deque([source]) self.parents = [-1] * self.size self.parents[source] = -2 # Marking the source node as visited path_flow = [0] * self.size path_flow[source] = float(\'Inf\') while queue: current_node = queue.popleft() for next_node in self.graph[current_node]: if self.parents[next_node] == -1 and self.capacities[current_node][next_node] - self.flow_passed[current_node][next_node] > 0: self.parents[next_node] = current_node path_flow[next_node] = min(path_flow[current_node], self.capacities[current_node][next_node] - self.flow_passed[current_node][next_node]) if next_node == sink: return path_flow[sink] queue.append(next_node) return 0 def edmonds_karp(self, source, sink): max_flow = 0 while True: path_flow = self.bfs(source, sink) if path_flow == 0: break max_flow += path_flow current = sink while current != source: prev = self.parents[current] self.flow_passed[prev][current] += path_flow self.flow_passed[current][prev] -= path_flow current = prev return max_flow def max_water_flow(n, m, s, t, edges): max_flow_graph = MaxFlow(n) for u, v, c in edges: max_flow_graph.add_edge(u - 1, v - 1, c) # Map 1-based to 0-based index return max_flow_graph.edmonds_karp(s - 1, t - 1) # Map 1-based to 0-based index"},{"question":"You are given an array of integers `nums` and an integer `k`. Rearrange the array such that the difference between the consecutive elements is minimized, and no element is moved more than `k` positions away from its original position. Return the rearranged array.","solution":"import heapq def rearrange_array(nums, k): Rearranges the array such that the difference between consecutive elements is minimized, and no element is moved more than k positions away from its original position. # Use a min-heap to keep track of the smallest elements within the window of size min(len(nums), k+1) if k == 0: return nums n = len(nums) result = [] min_heap = [] for i in range(n): heapq.heappush(min_heap, nums[i]) if i >= k: result.append(heapq.heappop(min_heap)) if i == n - 1: while min_heap: result.append(heapq.heappop(min_heap)) return result"},{"question":"Given a binary tree, return _all root-to-leaf paths_ represented as a list of strings. Each path should be formatted as a string with the following format: \\"root->node1->node2->...->leaf\\".","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def binary_tree_paths(root): Returns all root-to-leaf paths in a binary tree. def construct_paths(node, path): if node: path += str(node.value) if not node.left and not node.right: # if reach a leaf paths.append(path) # update paths else: path += \'->\' # extend the current path construct_paths(node.left, path) construct_paths(node.right, path) paths = [] construct_paths(root, \'\') return paths"},{"question":"You are given a **0-indexed** integer array `heights` where `heights[i]` represents the height of the `i-th` building in a row of buildings. The buildings have different heights but you can merge two adjacent buildings into a single building by removing the smaller building. After merging, the height of the new building will be the height of the taller building. You can perform this operation an unlimited number of times. Return the **minimum** number of buildings that remains after merging all possible buildings.","solution":"def minimum_number_of_buildings(heights): Returns the minimum number of buildings that remains after merging all possible buildings. if not heights: return 0 n = len(heights) min_buildings = 1 for i in range(1, n): if heights[i] > heights[i - 1]: min_buildings += 1 return min_buildings"},{"question":"Given an array of integers `arr`, you need to determine if the array can be sorted in non-decreasing order by performing at most one swap of two distinct elements in the array. If the array can be sorted by performing at most one swap, return `true`; otherwise, return `false`.","solution":"def can_be_sorted_with_one_swap(arr): Determines if the array can be sorted in non-decreasing order by performing at most one swap. Parameters: arr (list): A list of integers. Returns: bool: True if the array can be sorted with at most one swap, otherwise False. n = len(arr) original = arr[:] sorted_arr = sorted(arr) # Count the number of positions where the elements are different in original and sorted array diff = [i for i in range(n) if original[i] != sorted_arr[i]] # If no swap or already sorted if len(diff) == 0: return True # Check if we can swap only two elements to sort the array if len(diff) == 2: # Swap the elements original[diff[0]], original[diff[1]] = original[diff[1]], original[diff[0]] return original == sorted_arr return False"},{"question":"You are given an array of integers `arr`. Your task is to rearrange the elements in such a way that the difference between every consecutive pair of elements is not the same throughout the array. For example, given the input `[3, 1, 4, 1]`, a possible valid rearrangement could be `[1, 4, 1, 3]`. If such a rearrangement is not possible, return the string \\"Not possible\\". Write a function `rearrangeArray(arr)` that performs this rearrangement.","solution":"def rearrangeArray(arr): def has_equal_differences(arr): if len(arr) < 3: return False diffs = set() for i in range(1, len(arr)): diffs.add(arr[i] - arr[i - 1]) return len(diffs) == 1 arr.sort() # Try to create a non-arithmetic progression arrangement # by starting from ends, taking from the start one time, then from the end. n = len(arr) res = [] left, right = 0, n - 1 while left <= right: if left != right: res.append(arr[left]) res.append(arr[right]) else: res.append(arr[left]) left += 1 right -= 1 if has_equal_differences(res): return \\"Not possible\\" return res"},{"question":"**Given a rectangular cake with height `h` and width `w`, and two arrays of integers `horizontalCuts` and `verticalCuts` where `horizontalCuts[i]` represents the distance from the top of the rectangular cake to the `i-th` horizontal cut and `verticalCuts[j]` represents the distance from the left of the rectangular cake to the `j-th` vertical cut, return the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays.**","solution":"def max_area_after_cuts(h, w, horizontalCuts, verticalCuts): Returns the maximum area of a piece of cake after making cuts provided in horizontalCuts and verticalCuts arrays. # Append edges of the cake to the cuts horizontalCuts = sorted(horizontalCuts + [0, h]) verticalCuts = sorted(verticalCuts + [0, w]) # Find the maximum consecutive distances in horizontal cuts max_h_gap = max(horizontalCuts[i+1] - horizontalCuts[i] for i in range(len(horizontalCuts)-1)) # Find the maximum consecutive distances in vertical cuts max_w_gap = max(verticalCuts[i+1] - verticalCuts[i] for i in range(len(verticalCuts)-1)) # Maximum area will be the product of maximum gaps return max_h_gap * max_w_gap"},{"question":"[Question] 4: Given a string `s` consisting of lowercase English letters, return _the length of the longest substring with all distinct characters_. Example: ``` Input: s = \\"abcabcbb\\" Output: 3 Explanation: The answer is \\"abc\\", with the length of 3. ``` Note: You may assume that `s` contains only lowercase English letters and is non-empty.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all distinct characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"Write a function `findLongestSubstring(s)` that takes a string `s` as input and returns the length of the longest substring of `s` that contains at most two distinct characters. For example, if `s = \\"eceba\\"`, then the longest substring with at most two distinct characters is `\\"ece\\"` with a length of `3`. If `s = \\"ccaabbb\\"`, the longest substring is `\\"aabbb\\"` with a length of `5`.","solution":"def findLongestSubstring(s): Returns the length of the longest substring of `s` that contains at most two distinct characters. n = len(s) if n <= 2: return n left = 0 max_len = 0 char_count = {} for right in range(n): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given a matrix `mat` of size `n x n`, where each cell contains either a `0` or a `1`, the matrix represents a grid where `1` indicates a blocked cell and `0` indicates an open cell. You need to find the minimum number of steps required to move from the top-left corner of the grid `(0, 0)` to the bottom-right corner of the grid `(n-1, n-1)`. You can only move up, down, left, or right, and you cannot move into a blocked cell or out of the grid\'s bounds. If there is no valid path from `(0, 0)` to `(n-1, n-1)`, return `-1`. Implement the `GridPath` class: - `GridPath(int[][] mat)`: Initializes the grid with the given matrix `mat`. - `int minPath()`: Returns the minimum number of steps to reach `(n-1, n-1)` from `(0, 0)`, or `-1` if no such path exists. Example usage: ```python grid = [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ] gp = GridPath(grid) print(gp.minPath()) # Output: 4 ``` Explanation: The shortest path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) with 4 steps.","solution":"from collections import deque class GridPath: def __init__(self, mat): self.mat = mat self.n = len(mat) self.directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] def is_valid(self, x, y): return 0 <= x < self.n and 0 <= y < self.n and self.mat[x][y] == 0 def minPath(self): if self.mat[0][0] == 1 or self.mat[self.n-1][self.n-1] == 1: return -1 queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == self.n - 1 and y == self.n - 1: return steps for dx, dy in self.directions: nx, ny = x + dx, y + dy if self.is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"You are given a string `s` representing a mathematical expression in infix notation. Your task is to convert this expression to its equivalent postfix notation. The expression may contain the following operators: `+`, `-`, `*`, `/`, `^` (exponentiation), and parentheses to denote precedence. Return the resulting postfix expression as a string. Make sure to handle operator precedence and associativity correctly.","solution":"def infix_to_postfix(s): Converts an infix expression to its equivalent postfix expression. precedence = { \'^\': 3, \'*\': 2, \'/\': 2, \'+\': 1, \'-\': 1 } associativity = { \'^\': \'R\', \'*\': \'L\', \'/\': \'L\', \'+\': \'L\', \'-\': \'L\' } def has_higher_precedence(op1, op2): if precedence[op1] > precedence[op2]: return True elif precedence[op1] < precedence[op2]: return False else: return associativity[op1] == \'L\' output = [] stack = [] for char in s: if char.isalnum(): output.append(char) elif char in precedence: while stack and stack[-1] != \'(\' and has_higher_precedence(stack[-1], char): output.append(stack.pop()) stack.append(char) elif char == \'(\': stack.append(char) elif char == \')\': while stack and stack[-1] != \'(\': output.append(stack.pop()) stack.pop() # pop \'(\' while stack: output.append(stack.pop()) return \'\'.join(output)"},{"question":"Given a list of non-negative integers representing the amount of work at each task, and an integer `k` representing the number of workers, distribute the tasks among the workers such that the maximum work any single worker has to do is minimized. Return this minimum possible maximum work.","solution":"def canDistribute(tasks, workers, maxLoad): currentWorker = 1 currentSum = 0 for task in tasks: currentSum += task if currentSum > maxLoad: currentWorker += 1 currentSum = task if currentWorker > workers: return False return True def minMaxWorkLoad(tasks, k): if not tasks: return 0 # The lower bound of our binary search is max(tasks) # because no single worker can take up more work than the max task. low = max(tasks) # The upper bound is sum(tasks) because in the worst case, one worker does all the work. high = sum(tasks) while low < high: mid = (low + high) // 2 if canDistribute(tasks, k, mid): high = mid else: low = mid + 1 return low"},{"question":"Given a list of integers `nums`, return _the length of the longest contiguous subarray containing only_ **unique** _elements_.","solution":"def longest_unique_subarray_length(nums): Returns the length of the longest contiguous subarray containing only unique elements. :param nums: List[int] - The input list of integers. :return: int - The length of the longest subarray with all unique elements. max_length = 0 start = 0 seen = {} for end, value in enumerate(nums): if value in seen and seen[value] >= start: start = seen[value] + 1 seen[value] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given two sequences of integers represented as arrays `arr1` and `arr2` of length `m` and `n` respectively, and an integer `k`. You need to merge these two sequences into a single sorted sequence and then find the `k`-th smallest element in this merged sorted sequence. If `k` is greater than the length of the merged sequence, return `-1`. Both input arrays are sorted in non-decreasing order. Write a function to achieve this.","solution":"def kth_smallest_element(arr1, arr2, k): Returns the k-th smallest element in the merged sorted sequence of arr1 and arr2. If k is greater than the length of the merged sequence, returns -1. # Merge the two sorted arrays merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 # Append remaining elements of arr1 while i < len(arr1): merged.append(arr1[i]) i += 1 # Append remaining elements of arr2 while j < len(arr2): merged.append(arr2[j]) j += 1 # If k is greater than the length of the merged array, return -1 if k > len(merged) or k <= 0: return -1 # Return the k-th smallest element (1-based index) return merged[k-1]"},{"question":"You are given an array of integers `time` where `time[i]` represents the duration taken by the `i-th` task. A worker can perform **at most** two tasks each day provided that the total duration of the tasks does not exceed a given number `limit`. Two tasks are considered a valid pair if the sum of their durations is less than or equal to `limit`. Determine the **maximum number** of days the worker can work if each day must consist of exactly one valid pair of tasks. If there are leftover tasks that cannot fit into any valid pair, those tasks should be disregarded. Return _the **maximum number** of valid days the worker can work_.","solution":"def max_number_of_days(time, limit): Returns the maximum number of valid days the worker can work with valid pairs of tasks. A valid pair is defined as two tasks whose durations sum up to less than or equal to `limit`. time.sort() left, right = 0, len(time) - 1 days = 0 while left < right: if time[left] + time[right] <= limit: days += 1 left += 1 right -= 1 else: right -= 1 return days"},{"question":"Write a function that takes a non-negative integer `x` and converts it to its hexadecimal representation. The hexadecimal representation should be in lowercase letters (`a` to `f`). The function should not use any built-in library functions for the conversion (e.g., `hex()` in Python). Instead, use string manipulation and mathematical operations to achieve the result. Return the hexadecimal representation as a string.","solution":"def to_hex(x): Convert a non-negative integer x to its hexadecimal representation. The hexadecimal representation should be in lowercase letters. if x == 0: return \\"0\\" hex_digits = \\"0123456789abcdef\\" hex_string = \\"\\" while x > 0: remainder = x % 16 hex_string = hex_digits[remainder] + hex_string x //= 16 return hex_string"},{"question":"You are given an array of `n` integers, where the `i-th` integer represents the height of a tree in a garden. Every day, you can either increase the height of one specific tree by `1` unit or decrease the height of one specific tree by `1` unit. You want all trees to have the same height as quickly as possible. Return the minimum number of operations needed to make all the trees the same height.","solution":"def min_operations_to_equal_height(trees): Returns the minimum number of operations needed to make all trees the same height. Args: trees (list of int): list of heights of trees. Returns: int: minimum number of operations. if not trees: return 0 target_height = round(sum(trees) / len(trees)) operations = 0 for height in trees: operations += abs(height - target_height) return operations"},{"question":"You are given an **m x n** integer grid `maze` representing a maze, where `maze[i][j] = 0` represents an empty cell and `maze[i][j] = 1` represents a wall. You are also given the starting coordinates `start` and the destination coordinates `destination`, both of which are empty cells. The task is to find if there is a path from `start` to `destination` such that you only move in 4 possible directions (up, down, left, right) and you cannot cross the walls. Return `true` if there is a path to the `destination`, or `false` otherwise.","solution":"from collections import deque def hasPath(maze, start, destination): Determines if there is a path from start to destination in the given maze. Maze is represented as a 2D list where 0 indicates open spaces and 1 indicates walls. Start and destination are 2-element lists indicating the coordinates [x, y]. Args: maze: List[List[int]] - The maze grid. start: List[int] - The starting cell [x, y]. destination: List[int] - The destination cell [x, y]. Returns: bool - True if there is a path from start to destination, False otherwise. if not maze: return False m, n = len(maze), len(maze[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right visited = [[False] * n for _ in range(m)] def go_to_end(x, y, dx, dy): while 0 <= x + dx < m and 0 <= y + dy < n and maze[x+dx][y+dy] == 0: x += dx y += dy return x, y q = deque([start]) visited[start[0]][start[1]] = True while q: x, y = q.popleft() if [x, y] == destination: return True for dx, dy in directions: nx, ny = go_to_end(x, y, dx, dy) if not visited[nx][ny]: visited[nx][ny] = True q.append((nx, ny)) return False"},{"question":"You are given the `root` of a binary tree where each node contains an integer value. Design an algorithm to perform zigzag level order traversal of the tree. The zigzag level order traversal is defined as follows: * For every even-numbered level, traverse the nodes from left to right. * For every odd-numbered level, traverse the nodes from right to left. Return _a list of lists of integers representing the zigzag level order traversal of the given binary tree._","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): Perform zigzag level order traversal on the binary tree. Args: root (TreeNode): Root of the binary tree. Returns: list[list[int]]: Zigzag level order traversal of the binary tree. if not root: return [] result = [] queue = deque([root]) left_to_right = True while queue: level_size = len(queue) level_nodes = deque() for _ in range(level_size): node = queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.appendleft(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(list(level_nodes)) left_to_right = not left_to_right return result"},{"question":"A company wants to optimize the time employees spend on tasks. Each employee is assigned a list of tasks, where each task has a certain duration. The goal is to minimize the maximum duration any one employee spends on their tasks. Given an array of integers `tasks`, where `tasks[i]` represents the duration of the `i-th` task, and an integer `k` representing the number of employees, return the minimum possible maximum duration any one employee spends on their tasks after distributing the tasks optimally among the employees. For example, given `tasks = [7, 2, 5, 10, 8]` and `k = 2`, the optimal distribution would be `[7, 2, 5]` and `[10, 8]`, resulting in a maximum duration of 18.","solution":"def is_valid_distribution(tasks, k, max_task_time): current_sum = 0 required_employees = 1 for task in tasks: if current_sum + task <= max_task_time: current_sum += task else: required_employees += 1 current_sum = task if required_employees > k: return False return True def min_max_task_time(tasks, k): left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if is_valid_distribution(tasks, k, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to determine if there are three distinct integers in `nums` whose sum is closest to `target`. Return the sum of the three integers. If there are multiple sums that are equally close to the target, return any of them. For example, given `nums = [-1, 2, 1, -4]` and `target = 1`, the sum that is closest to the target is `2` (`-1 + 2 + 1 = 2`). Return _the sum of the three integers that is closest to_ `target`.","solution":"def three_sum_closest(nums, target): Returns the sum of the three integers closest to the target. nums.sort() closest_sum = float(\'inf\') for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return current_sum return closest_sum"},{"question":"You are given an unsorted array of integers and a target integer `k`. Write a function to find all unique quadruplets in the array that sum up to `k`. The function should return these unique quadruplets as a list of lists. Note that each quadruplet should be in non-descending order and no two quadruplets should be identical in terms of their four integer values.","solution":"def four_sum(nums, target): def find_n_sum(nums, target, N, result, results): if len(nums) < N or N < 2: return # Base case for 2-Sum if N == 2: l, r = 0, len(nums) - 1 while l < r: s = nums[l] + nums[r] if s == target: results.append(result + [nums[l], nums[r]]) l += 1 r -= 1 while l < r and nums[l] == nums[l - 1]: l += 1 while l < r and nums[r] == nums[r + 1]: r -= 1 elif s < target: l += 1 else: r -= 1 else: for i in range(len(nums) - N + 1): if i == 0 or (i > 0 and nums[i] != nums[i - 1]): find_n_sum(nums[i + 1:], target - nums[i], N - 1, result + [nums[i]], results) nums.sort() results = [] find_n_sum(nums, target, 4, [], results) return results"},{"question":"You are given a set of strings `words` where each string in `words` is composed of lowercase English letters. You need to find the shortest string in `words` that contains all the strings in `words` as subsequences. If there are multiple strings of the same shortest length, return the lexicographically smallest one. A string `s` is a **subsequence** of string `t` if deleting some number of characters from `t` (possibly zero) results in the string `s`.","solution":"def is_subsequence(s, t): it = iter(t) return all(char in it for char in s) def find_shortest_supersequence(words): from itertools import permutations min_length = float(\'inf\') best_supersequence = None for perm in permutations(words): supersequence_candidate = perm[0] for next_word in perm[1:]: # Merge supersequence_candidate with next_word merged = \\"\\" it = iter(supersequence_candidate) for char in next_word: if char in it: merged += char else: break supersequence_candidate += next_word[len(merged):] if len(supersequence_candidate) < min_length or (len(supersequence_candidate) == min_length and supersequence_candidate < best_supersequence): min_length = len(supersequence_candidate) best_supersequence = supersequence_candidate return best_supersequence"},{"question":"You are given a list of positive integers `tasks`, where each integer represents the processing time of a single task, and an integer `sessionTime` which represents the maximum duration of a work session. You want to find the **minimum number of work sessions** required to finish all the tasks such that the sum of the processing times of tasks assigned to each session does not exceed `sessionTime`. If a task cannot be assigned to any of the current sessions without exceeding the `sessionTime`, a new session is started. Return _the **minimum** number of work sessions_ required to complete all the tasks.","solution":"def min_sessions(tasks, sessionTime): tasks.sort(reverse=True) sessions = [] for task in tasks: placed = False for i in range(len(sessions)): if sessions[i] + task <= sessionTime: sessions[i] += task placed = True break if not placed: sessions.append(task) return len(sessions)"},{"question":"Given a list of directed edges in a graph, where each edge is represented as a pair `[u, v]` indicating there is a directed edge from node `u` to node `v`, and a starting node `start`, determine if all nodes in the graph are reachable from the starting node. Implement a function `boolean allNodesReachable(List<int[]> edges, int start, int n)` where `edges` is the list of directed edges, `start` is the starting node, and `n` is the total number of nodes in the graph (labeled `0` to `n-1`). Return `true` if all nodes are reachable from the starting node, otherwise return `false`. **Note:** The graph might contain cycles and disconnected components.","solution":"from collections import defaultdict, deque def allNodesReachable(edges, start, n): Determine if all nodes are reachable from the starting node in a directed graph. :param edges: List of directed edges in the graph represented as pairs [u, v]. :param start: The starting node. :param n: Total number of nodes in the graph. :return: True if all nodes are reachable from the starting node, otherwise False. # Create an adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Perform BFS/DFS to check reachability of all nodes from the starting node visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) # All nodes are reachable if visited set contains all nodes [0, n-1] return len(visited) == n"},{"question":"You are given an integer array `A` of length `n` where `A[i]` represents the number of apples in the `i`-th basket. You can perform the following operation any number of times: choose any basket and add exactly one apple to it. What is the **minimum** number of operations required to make the number of apples in each basket equal? Return the minimum number of operations required.","solution":"def min_operations_to_equal_apples(A): Returns the minimum number of operations required to make the number of apples in each basket equal. max_apples = max(A) operations = sum(max_apples - apples for apples in A) return operations"},{"question":"You are given an integer array `heights` representing the heights of buildings in a city. The array is sorted in **non-decreasing** order. In one step, you can increase the height of any building by 1. Return _the minimum number of steps required to ensure that the difference between the heights of the tallest and shortest buildings is less than or equal to `k`._ If it is not possible, return `-1`.","solution":"def min_steps_to_limit_difference(heights, k): Returns the minimum number of steps required to ensure that the difference between the heights of the tallest and shortest buildings is less than or equal to k. If it is not possible, return -1. Parameters: heights (list of int): Heights of buildings in non-decreasing order. k (int): Maximum allowed difference between tallest and shortest building. Returns: int: Minimum number of steps required or -1 if not possible. if not heights: return 0 min_height = heights[0] max_height = heights[-1] current_difference = max_height - min_height if current_difference <= k: return 0 steps = current_difference - k return steps if steps >= 0 else -1"},{"question":"You are given an integer array `nums` of length `n` representing the scores of `n` players in a game. Each player can either gain or lose their score points to form a total score. Your goal is to determine whether it is possible to partition these `n` players into two groups such that the sum of the total scores of the players in each group is equal. Return `true` if such a partition is possible, otherwise return `false`.","solution":"def can_partition(nums): Determine if the given array can be partitioned into two subsets with equal sum. total_sum = sum(nums) # If the total sum is odd, it\'s not possible to partition it into equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # DP array to store whether a specific sum can be formed with available elements dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"Given a binary string `s`, a binary string is made up of only characters \'0\' and \'1\'. Count and return the number of substrings of `s` that contain exactly an equal number of 0s and 1s and all the 0s and 1s in these substrings are grouped consecutively. In other words, find the number of substrings that are of the form \'000..111\' or \'111..000\'. The substrings should not overlap.","solution":"def count_binary_substrings(s): Returns the number of substrings that contain an equal number of 0s and 1s grouped consecutively. if not s: return 0 counts = [] count = 1 # Build counts list with consecutive counts of 1s and 0s for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: counts.append(count) count = 1 counts.append(count) # Append the last count # Count the amount of valid substrings result = 0 for i in range(1, len(counts)): result += min(counts[i - 1], counts[i]) return result"},{"question":"Given an integer matrix `matrix`, find the length of the longest increasing path in the matrix. From each cell, you can either move to four possible directions – left, right, up, or down and you may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed). Two cells are said to be connected if and only if they contain values which increase sequentially from one cell to another. Return the length of the longest increasing path in the matrix.","solution":"def longestIncreasingPath(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) cache = [[-1] * cols for _ in range(rows)] def dfs(x, y): if cache[x][y] != -1: return cache[x][y] max_path = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and matrix[nx][ny] > matrix[x][y]: max_path = max(max_path, 1 + dfs(nx, ny)) cache[x][y] = max_path return max_path longest_path = 0 for i in range(rows): for j in range(cols): longest_path = max(longest_path, dfs(i, j)) return longest_path"},{"question":"Given a string s which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero. The expression string may contain open `(` and closing parentheses `)`, the plus `+` or minus sign `-`, non-negative integers and empty spaces ` `. You may assume that the given expression is always valid. All intermediate results will be in the range of [-2^31, 2^31 - 1]. The division operator `/` should be used assuming integer division. Implement the function `int calculate(String s)`, which takes a string s as input and returns an integer representing the result of the expression.","solution":"def calculate(s: str) -> int: def helper(it): stack = [] num = 0 sign = 1 for char in it: if char.isdigit(): num = num * 10 + int(char) elif char in \'+-\': stack.append(sign * num) num = 0 sign = 1 if char == \'+\' else -1 elif char == \'(\': num = helper(it) elif char == \')\': break stack.append(sign * num) return sum(stack) return helper(iter(s))"},{"question":"You are provided with an array of integers `nums` and an integer `threshold`. We define the weight of an array as the sum of the absolute differences between consecutive elements in the array. More formally, the weight of an array `nums` of size `n` is calculated as: [ text{weight} = sum_{i=1}^{n-1} |nums_i - nums_{i+1}| ] You are allowed to rearrange the elements of `nums` in any order you wish. Return the minimum possible weight of the rearranged array that is less than or equal to the given `threshold`. If it is not possible to achieve a weight less than or equal to the `threshold`, return `-1`.","solution":"def minimum_weight_within_threshold(nums, threshold): Returns the minimum possible weight of the rearranged array that is less than or equal to the threshold. If not possible, returns -1. nums.sort() current_weight = sum(abs(nums[i] - nums[i+1]) for i in range(len(nums)-1)) if current_weight <= threshold: return current_weight else: return -1"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` elements. You want to determine if it is possible to make all the elements of `nums` unique by modifying at most one element. In one modification, you can change any element of `nums` to any integer value. Return `true` if it is possible to make all elements of `nums` unique by modifying at most one element, otherwise return `false`.","solution":"def can_make_unique(nums): from collections import Counter count = Counter(nums) duplicates = [k for k,v in count.items() if v > 1] if len(duplicates) == 0: return True if len(duplicates) == 1 and count[duplicates[0]] == 2: return True return False"},{"question":"Given an array of integers `nums` and an integer `k`, reverse the order of the elements in each group of `k` consecutive elements. If at any point there are less than `k` elements remaining, reverse all of them. Assume `1 <= k <= nums.length`. Write a function that returns the modified array. Do not use any extra space for another array, and you must modify the input array in-place with `O(1)` extra memory.","solution":"def reverse_k_group(nums, k): Reverse the order of the elements in each group of `k` consecutive elements of the list `nums`. If at any point there are less than `k` elements remaining, reverse all of them. This function modifies `nums` in-place and returns the modified list. :param nums: List[int] - The list of integers to reverse :param k: int - The size of each group to reverse :return: List[int] - The modified list with each group of `k` elements reversed n = len(nums) for i in range(0, n, k): left = i right = min(i + k - 1, n - 1) while left < right: nums[left], nums[right] = nums[right], nums[left] left += 1 right -= 1 return nums"},{"question":"You are given an array `heights` representing the heights of a series of buildings arranged from left to right. You need to find out how many blocks of buildings can be completely covered by water if it rains. Water can be trapped between buildings if there are at least two taller buildings on either side and enough space between the buildings for water to accumulate. For each building, the amount of water trapped above it is determined by the height of the shorter of the two tallest buildings surrounding it minus the height of the building itself. Return _the total amount of water trapped_.","solution":"def trap(height): Returns the total amount of water trapped after raining given the heights of buildings. :param height: List[int] - an array of non-negative integers representing the heights of buildings. :return: int - total units of water trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":": You are given a string `s` consisting only of the characters \'a\', \'b\', and \'*\'. Your task is to replace each \'*\' in the string with either \'a\' or \'b\' such that the resulting string does not contain any consecutive identical characters. If there are multiple solutions, return any of them. If it is not possible to replace all \'*\' to meet the requirements, return an empty string.","solution":"def replace_asterisks(s): Replace \'*\' in the string with \'a\' or \'b\' such that there are no consecutive identical characters. Return any such valid string or an empty string if not possible. s = list(s) # Convert string to list for mutability for i in range(len(s)): if s[i] == \'*\': for char in \'ab\': if (i == 0 or s[i - 1] != char) and (i == len(s) - 1 or s[i + 1] != char): s[i] = char break # Checking if we successfully replaced all \'*\' s = \'\'.join(s) for i in range(len(s) - 1): if s[i] == s[i + 1]: return \\"\\" return s"},{"question":"Given a list of `points` in a 2D plane, each represented as an array `[x, y]`, find the equation of the straight line (if any) that passes through the most number of points. Assume there are no vertical lines in the input set. The answer should be in the format `y = mx + b`, where `m` is the slope and `b` is the y-intercept. Return the coefficients `m` and `b` as an array `[m, b]`. If there are multiple lines with the highest number of points, you may return any one of them.","solution":"from collections import defaultdict from fractions import Fraction from itertools import combinations def find_line_with_most_points(points): def get_line_parameters(p1, p2): if p1[0] == p2[0]: raise ValueError(\\"Vertical lines not allowed\\") # Calculate the slope (m) and intercept (b) m = Fraction(p2[1] - p1[1], p2[0] - p1[0]) b = Fraction(p1[1]) - m * p1[0] return m, b lines = defaultdict(int) # Dictionary to count occurrences of each line max_points = 0 best_line = (0, 0) for p1, p2 in combinations(points, 2): try: m, b = get_line_parameters(p1, p2) lines[(m, b)] += 1 if lines[(m, b)] > max_points: max_points = lines[(m, b)] best_line = (m, b) except ValueError: pass # Skip vertical lines return [float(best_line[0]), float(best_line[1])]"},{"question":"Given an array of integers `arr`, return the length of the longest subarray that forms a contiguous arithmetic progression. An arithmetic progression is defined as a sequence of numbers in which the difference between consecutive elements is constant. You need to solve the problem in `O(n)` time complexity.","solution":"def longest_arith_seq_length(arr): if len(arr) < 2: return len(arr) max_length = 1 current_length = 1 current_diff = None for i in range(1, len(arr)): diff = arr[i] - arr[i - 1] if diff == current_diff: current_length += 1 else: current_diff = diff current_length = 2 max_length = max(max_length, current_length) return max_length"},{"question":"Given a directed graph represented as an adjacency list, determine if there is a path between two given nodes `start` and `end`. You must return `true` if a path exists and `false` otherwise. The graph does not contain any negative weight edges, and there are no self-loops. Each node in the graph is represented by an integer.","solution":"def has_path(graph, start, end): Determines if there is a path between the start and end nodes in the graph. :param graph: Dict, where keys are node integers and values are lists of adjacent nodes :param start: Int, starting node :param end: Int, ending node :return: Boolean, True if a path exists from start to end, else False visited = set() def dfs(node): if node == end: return True visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor): return True return False return dfs(start)"},{"question":"You are given a list of integers `arr` representing the heights of students standing in a line. The students are asked to shuffle such that every student\'s height is not exceeded by the height of the student immediately in front of them. Implement an algorithm that determines the minimum number of swaps required to achieve this arrangement. Return _the minimum number of swaps needed to sort the list in non-decreasing order_.","solution":"def minimum_swaps(arr): Returns the minimum number of swaps required to sort the list in non-decreasing order. n = len(arr) arr_pos = [(value, index) for index, value in enumerate(arr)] arr_pos.sort(key=lambda it: it[0]) visited = [False] * n swaps = 0 for i in range(n): if visited[i] or arr_pos[i][1] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arr_pos[j][1] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"A robot is located at the top-left corner of a `m x n` grid (marked \'Start\' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \'Finish\' in the diagram below). How many possible unique paths are there? The grid is represented as a 2D array where the number of rows is `m` and the number of columns is `n`. Note: The dimensions `m` and `n` are at least 1. For example, consider a `3 x 3` grid: ``` [ [Start, , ] [ , , ] [ , , Finish] ] ``` In this case, the robot has `6` possible unique paths to reach the bottom-right corner. Return the total number of unique paths the robot can take.","solution":"def unique_paths(m, n): Calculate the number of unique paths from the top-left to the bottom-right of an m x n grid. The robot can only move either down or right at any point in time. # Create a 2D array dp where dp[i][j] represents the number of unique paths to reach cell (i, j) dp = [[1] * n for _ in range(m)] # Fill the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"You are given a binary tree represented by an array `tree`. Each element in the array represents a node, where the value is the key of the node, and `null` signifies an absent node. The root of the tree is at index `0`, and for any node at index `i`, the left child is at index `2*i + 1` and the right child is at index `2*i + 2`. Write an algorithm to return the maximum depth of the binary tree. *Note: The depth of a tree is the number of edges in the longest path from the root node to a leaf node.*","solution":"def max_depth_binary_tree(tree): Returns the maximum depth of the binary tree represented by the array `tree`. def dfs(index): if index >= len(tree) or tree[index] is None: return -1 # Returning -1 because we\'re counting edges, not nodes left_depth = dfs(2 * index + 1) right_depth = dfs(2 * index + 2) return max(left_depth, right_depth) + 1 return dfs(0)"},{"question":"You are given an array of positive integers `barrels`, where each element represents the amount of water in a barrel. Each day, you can perform one of two actions: 1. Remove water from a single barrel entirely, or 2. Redistribute the water in one barrel into any number of other barrels (including the possibility of redistributing it into empty barrels). Your goal is to ensure that each barrel contains at most a certain maximum amount of water, `max_capacity`. Return the minimum number of days required to achieve this goal.","solution":"def min_days_to_empty_barrels(barrels, max_capacity): Returns the minimum number of days required to ensure each barrel contains at most max_capacity water. Parameters: barrels (list): A list of positive integers representing the amount of water in each barrel. max_capacity (int): The maximum capacity of water a barrel can hold. Returns: int: The minimum number of days required. days = 0 for water in barrels: if water > max_capacity: # Compute the minimum days needed for this barrel days += water // max_capacity if water % max_capacity != 0: days += 1 else: days += 1 return days"},{"question":"You are given a directed acyclic graph (DAG) represented as a list of edges where `edges[i] = [from_i, to_i]` indicates a direct edge from node `from_i` to node `to_i`. Write a function that returns all possible topological orderings of the graph. Each topological ordering must be a list of nodes where for every directed edge `uv` from node `u` to node `v`, `u` comes before `v` in the list.","solution":"from collections import defaultdict, deque def findAllTopologicalOrders(edges): Returns all possible topological orderings of the directed acyclic graph represented by a list of edges. :param edges: List of edges where edges[i] = [from_i, to_i] :return: List of all topological orderings # Build graph and in-degrees of nodes graph = defaultdict(list) in_degree = defaultdict(int) nodes = set() for u, v in edges: graph[u].append(v) in_degree[v] += 1 nodes.add(u) nodes.add(v) # Identify nodes with no incoming edges zero_in_degree = deque([node for node in nodes if in_degree[node] == 0]) def backtrack(path, visited_nodes): if len(path) == len(nodes): result.append(path[:]) return for node in list(zero_in_degree): zero_in_degree.remove(node) path.append(node) visited_nodes.add(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree.append(neighbor) backtrack(path, visited_nodes) for neighbor in graph[node]: if in_degree[neighbor] == 0: zero_in_degree.pop() in_degree[neighbor] += 1 visited_nodes.remove(node) path.pop() zero_in_degree.appendleft(node) result = [] backtrack([], set()) return result"},{"question":"You are given an integer array `heights` representing the heights of students standing in a line in the order they are standing. Each student heights[i] is unique. A group photo needs to be taken, and you want the students to be ordered by their heights in a non-decreasing order to form the line. However, you are only allowed to perform **k adjacent swaps** within the line. Return _the minimum number of swaps needed to make the array sorted in non-decreasing order_. If it is not possible to sort the array with at most `k` adjacent swaps, return -1.","solution":"def is_possible_sort_within_k_swaps(heights, k): Determine if the array can be sorted within k adjacent swaps. # Calculate the minimum number of adjacent swaps needed using bubble sort concept n = len(heights) swaps_needed = 0 aux_list = heights[:] for i in range(n): for j in range(n-1-i): if aux_list[j] > aux_list[j+1]: # swap elements aux_list[j], aux_list[j+1] = aux_list[j+1], aux_list[j] swaps_needed += 1 # If the swaps needed exceed k, return -1, else return swaps_needed return swaps_needed if swaps_needed <= k else -1"},{"question":"Given a list of integers `arr`, return the **most frequent** element. If there is a tie for the most frequent element, return the **smallest** element among them. The input list will always have at least one integer.","solution":"def most_frequent_element(arr): Returns the most frequent element in the list `arr`. If there is a tie, returns the smallest element among the most frequent ones. from collections import Counter counter = Counter(arr) max_freq = max(counter.values()) most_frequent = [key for key, value in counter.items() if value == max_freq] return min(most_frequent)"},{"question":"Design a library management system. You are given a list of books in the library, each book identified by a unique number and containing details such as title, author, and total copies available. The system should be able to perform the following operations: - **Add a new book** to the collection. - **Borrow a book** if it\'s available (i.e., at least one copy is in the library). - **Return a book** that was borrowed. - **Search for books** by title keyword or author. The system should ensure correct handling and tracking of the number of each book available for borrowing and returning. Design the `LibrarySystem` class: - `LibrarySystem()` Initializes the object. - `void addBook(int id, String title, String author, int copies)` Adds a new book to the library\'s collection. - `bool borrowBook(int id)` Borrows a book from the library if available. Returns `true` if the operation is successful, otherwise returns `false`. - `void returnBook(int id)` Returns a borrowed book to the library. - `List search(String keyword)` Searches for books by the keyword in either title or author. Returns a list of book IDs that match the keyword search. The search is case insensitive.","solution":"class LibrarySystem: def __init__(self): self.books = {} def addBook(self, id, title, author, copies): self.books[id] = { \'title\': title, \'author\': author, \'total_copies\': copies, \'available_copies\': copies } def borrowBook(self, id): if id in self.books and self.books[id][\'available_copies\'] > 0: self.books[id][\'available_copies\'] -= 1 return True return False def returnBook(self, id): if id in self.books: if self.books[id][\'available_copies\'] < self.books[id][\'total_copies\']: self.books[id][\'available_copies\'] += 1 def search(self, keyword): keyword = keyword.lower() result = [] for book_id, details in self.books.items(): if keyword in details[\'title\'].lower() or keyword in details[\'author\'].lower(): result.append(book_id) return result"},{"question":"Given an array `arr` of integers, create a function that finds the length of the longest subarray where the difference between any two elements in the subarray is less than or equal to a given integer `k`. Example: - Input: `arr = [1, 5, 6, 7, 8, 10, 12, 14]`, `k = 3` - Output: `4` Explanation: The longest subarray where the difference between any two elements is less than or equal to 3 is `[5, 6, 7, 8]` with a length of 4. Therefore, the function should return 4.","solution":"def longest_subarray(arr, k): Finds the length of the longest subarray where the difference between any two elements is less than or equal to a given integer k. Parameters: arr (list of int): The input array of integers. k (int): The maximum allowable difference between any two elements in the subarray. Returns: int: The length of the longest subarray that meets the condition. if not arr: return 0 arr.sort() # Sorting the array to make sure differences between consecutive elements are minimal left = 0 max_length = 1 for right in range(1, len(arr)): # While the difference between the current right max and left min element is more than k, move left pointer while arr[right] - arr[left] > k: left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an array of integers `sessions` where each element represents the duration of a training session. Your task is to find the maximum number of non-overlapping sessions that you can attend. You can only attend one session at a time, and a session `A` is considered non-overlapping with a session `B` if the ending time of session `A` is less than the starting time of session `B`. Return the maximum number of non-overlapping sessions you can attend.","solution":"def max_non_overlapping_sessions(sessions): Returns the maximum number of non-overlapping sessions that can be attended. Parameters: sessions (list of tuples): A list where each tuple represents the start and end time of a session. Returns: int: The maximum number of non-overlapping sessions. # Sort the sessions based on their end time sessions.sort(key=lambda x: x[1]) max_sessions = 0 last_end_time = float(\'-inf\') for start, end in sessions: if start >= last_end_time: max_sessions += 1 last_end_time = end return max_sessions"},{"question":"You are given an array of integers `arr` where each integer represents the number of points you can earn. You have a choice to pick the elements from the array, but you cannot pick two adjacent elements. Your task is to determine the maximum points you can earn. For example, if you pick `arr[i]`, you cannot pick `arr[i-1]` or `arr[i+1]`. Return _the maximum points you can achieve_ following this rule.","solution":"def max_points(arr): Returns the maximum points that can be earned by picking non-adjacent elements from arr. if not arr: return 0 if len(arr) == 1: return arr[0] # Using dynamic programming to keep track of the max points at each step dp = [0] * len(arr) dp[0] = arr[0] dp[1] = max(arr[0], arr[1]) for i in range(2, len(arr)): dp[i] = max(dp[i-1], dp[i-2] + arr[i]) return dp[-1]"},{"question":"You are given an array of integers `nums` and an integer `k`. A continuous subarray is defined as an array that can be derived by deleting some elements (possibly none) from the start and the end of the array, without changing the order of the remaining elements. Determine if there exists a continuous subarray of size at least 2 that sums up to a multiple of `k`. If `k` is zero, you need to check if there exists a subarray of size at least 2 whose sum is zero. Return `true` if such a subarray exists, and `false` otherwise.","solution":"def check_subarray_sum(nums, k): Check if there exists a continuous subarray of size at least 2 that sums up to a multiple of k. if k == 0: # Special case when k is zero for i in range(len(nums) - 1): if nums[i] == 0 and nums[i + 1] == 0: return True return False prefix_sum = 0 prefix_sums = {0: -1} # Store prefix sums and their indices for i, num in enumerate(nums): prefix_sum += num if k != 0: prefix_sum %= k if prefix_sum in prefix_sums: if i - prefix_sums[prefix_sum] > 1: return True else: prefix_sums[prefix_sum] = i return False"},{"question":"Given a directed acyclic graph (DAG) with `n` nodes labeled from `0` to `n - 1` and an array `edges` where `edges[i] = [u, v]` represents a directed edge from node `u` to node `v`, return an array containing all nodes with no incoming edges (i.e., nodes with in-degree of zero). Implement your solution with a time complexity of O(n + m), where `n` is the number of nodes and `m` is the number of edges in the graph.","solution":"def find_nodes_with_no_incoming_edges(n, edges): Returns an array containing all nodes with no incoming edges. Parameters: n (int) - number of nodes edges (List[List[int]]) - array of edges where each edge is represented by [u, v] Returns: List[int] - array of nodes with no incoming edges in_degree = [0] * n for u, v in edges: in_degree[v] += 1 return [node for node in range(n) if in_degree[node] == 0]"},{"question":"You are given a 2D grid of size `m x n` representing a map where `1` represents land and `0` represents water. An island is a group of `1`s (land) connected **4-directionally** (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. You are also given an integer `k`. Your task is to make at most `k` flips, where you can change a `0` (water) into a `1` (land) and vice versa. Return the largest number of islands you can have after making at most `k` flips. Here, a flip means changing a cell\'s value from `0` to `1` or from `1` to `0`. Input: * `grid` - 2D list of integers representing the map * `k` - integer representing the maximum number of flips allowed Output: * Integer representing the maximum number of islands after making at most `k` flips.","solution":"def maxNumberOfIslands(grid, k): Finds the maximum number of islands after making at most k flips. :param grid: List[List[int]], 2D list of integers representing the map :param k: int, maximum number of flips allowed :return: int, maximum number of islands from collections import deque def get_islands(grid): Helper function to count the number of islands in the given grid. m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def bfs(x, y): Breadth-First Search to traverse the island queue = deque([(x, y)]) visited[x][y] = True while queue: i, j = queue.popleft() for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj] and grid[ni][nj] == 1: visited[ni][nj] = True queue.append((ni, nj)) islands = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: islands += 1 bfs(i, j) return islands def flip_and_count(x, y): Flip the cell (x, y), calculate the number of islands, and revert the flip. grid[x][y] = 1 - grid[x][y] # Flip num_islands = get_islands(grid) grid[x][y] = 1 - grid[x][y] # Revert flip return num_islands m, n = len(grid), len(grid[0]) max_islands = get_islands(grid) for i in range(m): for j in range(n): if k > 0: max_islands = max(max_islands, flip_and_count(i, j)) k -= 1 return max_islands"},{"question":"You are given a linked list where each node contains a single digit. The digits are stored in reverse order, and each of their non-empty links represents a non-negative integer. Add two such numbers and return the resulting linked list in the same reverse order. The function signature you are expected to implement is `ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)`. Here, `ListNode` is a predefined structure for list nodes in your programming language. Return _the resulting linked list representing the sum of the given two numbers_.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): Adds two numbers represented as linked lists in reverse order and returns the sum as a linked list in reverse order. dummy_head = ListNode(0) current = dummy_head carry = 0 while l1 is not None or l2 is not None: x = l1.val if l1 is not None else 0 y = l2.val if l2 is not None else 0 total = carry + x + y carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1 is not None: l1 = l1.next if l2 is not None: l2 = l2.next if carry > 0: current.next = ListNode(carry) return dummy_head.next"},{"question":"A **valid parentheses string** is either an empty string, or a string that can be written as `AB` (where `A` and `B` are valid parentheses strings) or `(A)` (where `A` is a valid parentheses string). Given a string `s` consisting of `(`, `)`, `{`, `}`, `[` and `]`, determine if `s` is a **valid parentheses** string. Return `true` if `s` is valid, and `false` otherwise. A parentheses string is considered valid if: 1. Any open parenthesis must have a corresponding close parenthesis of the same type. 2. Any open parenthesis must be closed in the correct order. For example: - `\\"()[]{}\\"` is a valid parentheses string. - `\\"(]\\"` is not a valid parentheses string. - `\\"([{}])\\"` is a valid parentheses string.","solution":"def is_valid_parentheses(s): Determine if the input string s is a valid parentheses string. stack = [] matching_parentheses = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in s: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses.keys(): if stack == [] or matching_parentheses[char] != stack.pop(): return False else: return False return stack == []"},{"question":"Determine if a given string `s` can be split into two or more non-empty substrings such that each substring is a palindrome. Return _true_ if it is possible, otherwise return _false_. A string is a palindrome if it reads the same backward as forward. For example: ``` Input: s = \\"aab\\" Output: true Explanation: The string can be split into \\"aa\\" and \\"b\\", both of which are palindromes. ``` ``` Input: s = \\"abc\\" Output: false Explanation: The string cannot be split into palindromes. ```","solution":"def can_split_into_palindromes(s): Determines if the given string can be split into two or more non-empty substrings where each substring is a palindrome. :param s: Input string :return: True if possible, otherwise False def is_palindrome(sub): return sub == sub[::-1] n = len(s) if n < 2: return False for i in range(1, n): if is_palindrome(s[:i]) and is_palindrome(s[i:]): return True return False"},{"question":"You are given an array of `n` integers, `heights`, where `heights[i]` represents the height of a building at position `i`. This array forms a skyline silhouette viewed from a distance. Each building has a width of `1`. Determine the maximum amount of water that can be trapped between the buildings after rainfall. The water is trapped between the buildings that run from left to right (from index `0` to index `n-1`). Return _an integer_ _indicating the total volume of trapped water_.","solution":"def trap(heights): Determine the total volume of water that can be trapped between the buildings. if not heights: return 0 left, right = 0, len(heights) - 1 max_left, max_right = heights[left], heights[right] volume = 0 while left < right: if max_left < max_right: left += 1 max_left = max(max_left, heights[left]) volume += max(0, max_left - heights[left]) else: right -= 1 max_right = max(max_right, heights[right]) volume += max(0, max_right - heights[right]) return volume"},{"question":"You are given a **directed weighted graph** with `n` nodes labeled from `0` to `n-1` and a 2D integer array `edges` where `edges[i] = [fromi, toi, weighti]` represents a directed edge from node `fromi` to node `toi` with a given weight `weighti`. Determine the shortest path from a given source node `src` to a target node `dst`. If there is no path from `src` to `dst`, return `-1`. The graph contains **no negative weight cycles**.","solution":"import heapq def shortest_path(n, edges, src, dst): Returns the shortest path distance from source node `src` to target node `dst` in a directed weighted graph. If there is no path, return -1. # Create adjacency list graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) # Priority queue to hold (distance, node) tuples pq = [(0, src)] # Distance array initialized with infinity dist = {i: float(\'inf\') for i in range(n)} dist[src] = 0 while pq: current_dist, current_node = heapq.heappop(pq) if current_node == dst: return current_dist if current_dist > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 if dist[dst] == float(\'inf\') else dist[dst]"},{"question":"You are given a `m` x `n` matrix filled with non-negative integers that represents the height of each unit cell in a continent. The **Pacific** and **Atlantic** oceans surround the continent on the left and right edges, respectively, while the top and bottom edges are adjacent to the oceans. Water can flow from any cell to any of its four neighboring cells if and only if the neighboring cell\'s height is less than or equal to the current cell\'s height. Water can only flow out of the cells that are directly adjacent to the Pacific or Atlantic ocean (not both simultaneously). Return a list of grid coordinates where water can flow to both the Pacific and Atlantic oceans.","solution":"def pacificAtlantic(matrix): if not matrix or not matrix[0]: return [] def dfs(x, y, visited, prev_height): if (x, y) in visited or x < 0 or y < 0 or x >= m or y >= n or matrix[x][y] < prev_height: return visited.add((x, y)) for direction in directions: new_x, new_y = x + direction[0], y + direction[1] dfs(new_x, new_y, visited, matrix[x][y]) m, n = len(matrix), len(matrix[0]) pacific_visited = set() atlantic_visited = set() directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for i in range(m): dfs(i, 0, pacific_visited, matrix[i][0]) dfs(i, n - 1, atlantic_visited, matrix[i][n - 1]) for j in range(n): dfs(0, j, pacific_visited, matrix[0][j]) dfs(m - 1, j, atlantic_visited, matrix[m - 1][j]) return list(pacific_visited & atlantic_visited)"},{"question":"Given a string `s` consisting of lowercase alphabets, remove the minimum number of characters from it so that all the remaining characters in `s` are unique. Return the resulting string with all distinct characters in their original order. If there are multiple possible results, return any of them.","solution":"def remove_min_chars_to_unique(s): Remove the minimum number of characters from the string s so that all the remaining characters are unique. Returns a resulting string with all distinct characters in their original order. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are given an array of `words` where each word consists of lowercase English letters and is sorted in non-decreasing order. Implement a function that returns the length of the longest chain of words where each word in the chain can be formed by removing exactly one letter from the previous word in the chain (and optionally rearranging the characters). Each subsequent word must also be a valid word present in the array `words`. For example, if `words = [\\"a\\", \\"b\\", \\"ba\\", \\"bca\\", \\"bda\\", \\"bdca\\"]`, the longest chain would be `[\\"a\\", \\"ba\\", \\"bda\\", \\"bdca\\"]`, and the function should return `4`. Note that the order in which the words are listed in the input array does not determine the order of the chain. Return the length of the longest chain you can form, or `0` if no such chain exists.","solution":"def longestStrChain(words): Given an array of words sorted lexicographically, find the length of the longest possible word chain. words.sort(key=len) longest_chain = {} max_length = 0 for word in words: current_length = 1 for i in range(len(word)): predecessor = word[:i] + word[i+1:] if predecessor in longest_chain: current_length = max(current_length, longest_chain[predecessor] + 1) longest_chain[word] = current_length max_length = max(max_length, current_length) return max_length"},{"question":"Given an array of integers `arr` of size `n` where `1 <= n <= 10^5` and `1 <= arr[i] <= 10^9`, return the length of the **longest** subarray with a difference between the maximum and minimum elements being at most `k`, where `0 <= k <= 10^9`.","solution":"from collections import deque def longest_subarray_with_limit(arr, k): Given an array of integers arr and an integer k, return the length of the longest subarray with a difference between the maximum and minimum elements being at most k. if not arr: return 0 min_deque = deque() # will store the indices of elements in increasing order max_deque = deque() # will store the indices of elements in decreasing order left = 0 result = 0 for right in range(len(arr)): # Maintain the min_deque while min_deque and arr[min_deque[-1]] > arr[right]: min_deque.pop() min_deque.append(right) # Maintain the max_deque while max_deque and arr[max_deque[-1]] < arr[right]: max_deque.pop() max_deque.append(right) # Check the condition for the current window while arr[max_deque[0]] - arr[min_deque[0]] > k: # slide the window by incrementing left left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() result = max(result, right - left + 1) return result"},{"question":"A data structure `TimeMap` is implemented that supports two operations: `set` and `get`. - `TimeMap.set(string key, string value, int timestamp)` stores the key and value, along with the timestamp. - `TimeMap.get(string key, int timestamp)` returns a value such that `set` was called previously, with `timestamp_prev` <= `timestamp`, and `timestamp_prev` is the largest such timestamp. If there are no values, it returns an empty string. Implement the `TimeMap` data structure and its methods. Use this class in the following manner: ``` TimeMap kv = new TimeMap(); kv.set(\\"foo\\", \\"bar\\", 1); // store the key \\"foo\\" and value \\"bar\\" along with timestamp = 1 kv.get(\\"foo\\", 1); // return \\"bar\\" kv.get(\\"foo\\", 3); // return \\"bar\\" since there is no value corresponding to \\"foo\\" at timestamp 3 and timestamp 1 is the largest smaller or equal to 3 kv.set(\\"foo\\", \\"bar2\\", 4); // store the key \\"foo\\" and value \\"bar2\\" along with timestamp = 4 kv.get(\\"foo\\", 4); // return \\"bar2\\" kv.get(\\"foo\\", 5); // return \\"bar2\\" ``` Note: - All key/value strings are of lowercase letters.","solution":"class TimeMap: def __init__(self): Initialize the data structure. self.store = {} def set(self, key: str, value: str, timestamp: int) -> None: Store the key with the value along with the timestamp. if key not in self.store: self.store[key] = [] self.store[key].append((timestamp, value)) def get(self, key: str, timestamp: int) -> str: Get the largest value such that it was set at some earlier time <= timestamp. If no earlier time is found, return an empty string. if key not in self.store or not self.store[key]: return \\"\\" values = self.store[key] i = self._search(values, timestamp) return values[i][1] if i != -1 else \\"\\" def _search(self, values, timestamp): Binary search to find the right most value less than or equal to the given timestamp. low, high = 0, len(values) - 1 result = -1 while low <= high: mid = (low + high) // 2 if values[mid][0] <= timestamp: result = mid low = mid + 1 else: high = mid - 1 return result"},{"question":"You are given a list of non-negative integers, `nums`, and an integer `target`. Your task is to determine if there exists a continuous subarray of `nums` that sums up to `target`. The subarray must contain at least two elements. Implement the `SubarrayFinder` class: * `SubarrayFinder(List<int> nums, int target)` Initializes the object with the list of integers and the target sum. * `bool hasSubarrayWithSum()` Returns `true` if there exists a contiguous subarray within `nums` whose sum equals `target` and contains at least two elements, otherwise it returns `false`. For example, given `nums = [1, 2, 3, 4, 5]` and `target = 9`, the method `hasSubarrayWithSum()` would return `true` because the subarray `[2, 3, 4]` sums to 9.","solution":"from typing import List class SubarrayFinder: def __init__(self, nums: List[int], target: int): self.nums = nums self.target = target def hasSubarrayWithSum(self) -> bool: n = len(self.nums) if n < 2: return False for start in range(n): current_sum = self.nums[start] for end in range(start + 1, n): current_sum += self.nums[end] if current_sum == self.target: return True return False"},{"question":"Given an array of integers `nums`, return the length of the longest subsequence that can be derived from `nums` such that every pair of consecutive elements in the subsequence has a difference of exactly 1.","solution":"def longest_consecutive_subsequence(nums): Returns the length of the longest subsequence where the difference between every pair of consecutive elements is exactly 1. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: if (num - 1) not in nums_set: # starting a new sequence current_num = num current_streak = 1 while (current_num + 1) in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"Given two integer arrays `arr1` and `arr2`, return the maximum length of a subarray that appears in both arrays. A subarray is a contiguous segment of an array. [Question 4]:","solution":"def findLength(arr1, arr2): Returns the maximum length of a subarray that appears in both arr1 and arr2. len1, len2 = len(arr1), len(arr2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] max_len = 0 for i in range(len1): for j in range(len2): if arr1[i] == arr2[j]: dp[i + 1][j + 1] = dp[i][j] + 1 max_len = max(max_len, dp[i + 1][j + 1]) return max_len"},{"question":"Design a class `FileSystem` to simulate a simple hierarchical file system where operations like creating paths, adding content to files, reading from files, and listing directories can be performed. Implement the `FileSystem` class: * `FileSystem()`: Initializes the file system. * `bool createPath(string path, string value)`: Creates a new path with the given `value` in the file system. If the parent path does not exist or the path already exists, returns `false`. Returns `true` if the path was successfully created. * `string getValue(string path)`: Returns the value associated with the given `path`. If the path does not exist, returns an empty string. * `bool updateValue(string path, string value)`: Updates an existing path with the new `value` in the file system. If the path does not exist, returns `false`. Returns `true` if the value was successfully updated. * `list<string> listDirectory(string path)`: Lists all the names of files and directories in the given `path` sorted in lexicographical order. If the path does not exist, returns an empty list.","solution":"class FileSystem: def __init__(self): self.paths = {} def createPath(self, path, value): if not path or path == \\"/\\" or path in self.paths or \\"/\\" not in path: return False parent = path[:path.rfind(\\"/\\")] if parent and parent not in self.paths: return False self.paths[path] = value return True def getValue(self, path): return self.paths.get(path, \\"\\") def updateValue(self, path, value): if path not in self.paths: return False self.paths[path] = value return True def listDirectory(self, path): if path not in self.paths and path != \\"/\\": return [] directory = set() for p in self.paths: if path == \\"/\\": if \\"/\\" not in p[1:]: directory.add(p[1:]) elif p.startswith(path) and p[len(path):].count(\\"/\\") <= 1: subpath = p[len(path):].strip(\\"/\\") if subpath: directory.add(subpath) return sorted(directory)"},{"question":"Given an array of `n` integers and an integer `target`, you need to determine if there exist three integers in the array whose sum is closest to the `target`. Return the sum of these three integers. You can assume that each input would have exactly one solution. Use the absolute difference between the sum of the integers and the `target` to measure closeness.","solution":"def three_sum_closest(nums, target): Finds three integers in nums whose sum is closest to target. Returns the sum of these three integers. nums.sort() n = len(nums) closest_sum = float(\'inf\') for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return closest_sum return closest_sum"},{"question":"Given a binary tree, return the maximum width of the tree. The **width** of a tree is defined as the maximum number of nodes present in any level of the tree. The binary tree node structure is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` *Example:* Input: ``` 1 / 3 2 / 5 3 9 ``` Output: `4` Note: In the provided example, level 3 contains `4 nodes` (5, 3, null, 9), which is the maximum width of this tree.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maximum_width_of_binary_tree(root): Returns the maximum width of the binary tree. if not root: return 0 max_width = 0 queue = deque([(root, 0)]) # Tuple of node and its position index while queue: level_length = len(queue) _, first_index = queue[0] for i in range(level_length): node, index = queue.popleft() if node.left: queue.append((node.left, 2 * index)) if node.right: queue.append((node.right, 2 * index + 1)) _, last_index = node, index max_width = max(max_width, last_index - first_index + 1) return max_width"},{"question":"Design an algorithm to efficiently manage a bank transaction system. Implement the `Bank` class with the following methods: * `Bank(int[] balance)` Initializes the bank system with an initial balance for each account. `balance[i-1]` represents the initial balance for account `i`. * `boolean transfer(int account1, int account2, long money)` Transfers `money` from `account1` to `account2`. If the transfer is successful, return `true`; otherwise, return `false`. * `boolean deposit(int account, long money)` Deposits `money` into `account`. If the deposit is successful, return `true`; otherwise, return `false`. * `boolean withdraw(int account, long money)` Withdraws `money` from `account`. If the withdrawal is successful, return `true`; otherwise, return `false`. Assume: - The number of accounts is between `1` and `10^5`. - The balance of each account is between `0` and `10^9`. - The number of operations (transfer, deposit, withdraw) is between `1` and `10^4`. Return appropriate errors and follow proper error handling where applicable.","solution":"class Bank: def __init__(self, balance): self.balance = balance def transfer(self, account1, account2, money): if not (1 <= account1 <= len(self.balance)) or not (1 <= account2 <= len(self.balance)): return False if self.balance[account1 - 1] < money: return False self.balance[account1 - 1] -= money self.balance[account2 - 1] += money return True def deposit(self, account, money): if not (1 <= account <= len(self.balance)): return False self.balance[account - 1] += money return True def withdraw(self, account, money): if not (1 <= account <= len(self.balance)): return False if self.balance[account - 1] < money: return False self.balance[account - 1] -= money return True"},{"question":"Write another question here, following the style and structure described above. [Question 4]: Given two strings `s` and `t`, return the number of distinct subsequences of `s` which equal `t`. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \\"ACE\\" is a subsequence of \\"ABCDE\\" while \\"AEC\\" is not).","solution":"def num_distinct(s, t): Returns the number of distinct subsequences of s which equals t. m, n = len(s), len(t) # If t is an empty string, there is exactly one subsequence of s which is \\"\\" if n == 0: return 1 # If s is an empty string but t is not, there can be no subsequences leading to t if m == 0: return 0 # dp[i][j] will store the number of subsequences of s[:i] which equals t[:j] dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): dp[i][0] = 1 # An empty t can always be matched by selecting no characters from s for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] return dp[m][n]"},{"question":"You are given a list of non-negative integers `nums` which represents the amount of rainwater trapped at each elevation map where the width of each bar is 1. Compute how much water it can trap after raining. For example: Given `nums = [0,1,0,2,1,0,1,3,2,1,2,1]`, return `6`. Note: * It is guaranteed that `nums` will have at least one element and each element will be a non-negative integer.","solution":"def trap_rainwater(nums): Computes the amount of trapped rainwater. :param nums: List[int] :return: int if len(nums) <= 2: return 0 left_max = [0] * len(nums) right_max = [0] * len(nums) water_trapped = 0 left_max[0] = nums[0] for i in range(1, len(nums)): left_max[i] = max(left_max[i-1], nums[i]) right_max[-1] = nums[-1] for i in range(len(nums) - 2, -1, -1): right_max[i] = max(right_max[i+1], nums[i]) for i in range(len(nums)): water_trapped += min(left_max[i], right_max[i]) - nums[i] return water_trapped"},{"question":"You are given a list of unique user IDs and a series of friendship connections between them. Each friendship connection consists of a pair of user IDs that are friends. Your task is to determine the largest group of users who are all directly or indirectly friends with each other, effectively finding the largest connected component in the graph formed by the user IDs and their friendships. Return the size of this largest group.","solution":"def largest_friend_group(user_ids, friendships): Returns the size of the largest group of users who are all directly or indirectly friends with each other. from collections import defaultdict def dfs(user, visited, adj_list): stack = [user] count = 0 while stack: current = stack.pop() if not visited[current]: visited[current] = True count += 1 for neighbor in adj_list[current]: if not visited[neighbor]: stack.append(neighbor) return count adj_list = defaultdict(list) for u, v in friendships: adj_list[u].append(v) adj_list[v].append(u) visited = {user: False for user in user_ids} largest_group_size = 0 for user in user_ids: if not visited[user]: group_size = dfs(user, visited, adj_list) largest_group_size = max(largest_group_size, group_size) return largest_group_size"},{"question":"A company\'s internal server records `m` logs of transactions. Each transaction log contains a string `log` representing the transaction details. A transaction log is added to the server in chronological order and each log may include unique transaction IDs. The company wants to identify any fraudulent behavior by checking for repetition of transaction IDs within a specific time window. You are given an **integer** `k`, which represents the maximum allowed time window (in number of logs). Your task is to implement the `MonitorTransactions` class to detect any repeated transaction IDs within the given window size `k`. Implement the following methods: * `MonitorTransactions(int k)` Initializes the monitor object with the given time window size `k`. * `void addLog(String log)` Records a new transaction log. * `boolean hasFraud()` Returns `true` if any transaction ID has been duplicated within the last `k` logs, otherwise returns `false`. The transaction ID within each `log` string is represented as a substring that starts with the prefix `\\"ID:\\"` followed by a sequence of alphanumeric characters. For example, in the log `\\"Timestamp:2023-04-01T10:00:00 ID:abc123 Details:Purchase\\"`, the transaction ID is `\\"abc123\\"`.","solution":"class MonitorTransactions: def __init__(self, k): self.k = k self.logs = [] self.transaction_ids = {} def addLog(self, log): self.logs.append(log) transaction_id = self.extract_transaction_id(log) if transaction_id in self.transaction_ids: self.transaction_ids[transaction_id] += 1 else: self.transaction_ids[transaction_id] = 1 if len(self.logs) > self.k: old_log = self.logs.pop(0) old_transaction_id = self.extract_transaction_id(old_log) if self.transaction_ids[old_transaction_id] == 1: del self.transaction_ids[old_transaction_id] else: self.transaction_ids[old_transaction_id] -= 1 def hasFraud(self): for count in self.transaction_ids.values(): if count > 1: return True return False def extract_transaction_id(self, log): id_index = log.find(\\"ID:\\") + 3 id_end = log.find(\\" \\", id_index) if id_end == -1: id_end = len(log) transaction_id = log[id_index:id_end] return transaction_id"},{"question":"You are given an integer array `heights` representing the heights of buildings along a street, viewed from left to right. A building\'s height is considered to be \\"blocked\\" from view if there is a building of greater or equal height to its left. Return _the number of buildings that are **not** blocked from view_.","solution":"def number_of_unblocked_buildings(heights): Given an array of building heights, return the number of buildings that are not blocked from view when looking from left to right. if not heights: return 0 unblocked_count = 1 # the first building is always unblocked max_height = heights[0] for height in heights[1:]: if height > max_height: unblocked_count += 1 max_height = height return unblocked_count"},{"question":"You are given a list of `events`, where each `event` is represented as a tuple `event = (start_day, end_day)` with both `start_day` and `end_day` as integers. An event is considered **active** on all days from `start_day` to `end_day` (inclusive). You are also given an integer `query_day`. Your task is to return the number of events that are active on the `query_day`.","solution":"def count_active_events_on_day(events, query_day): Returns the number of events that are active on the given query_day. count = 0 for start_day, end_day in events: if start_day <= query_day <= end_day: count += 1 return count"},{"question":"A city is planning to build a new network of `m` roads to connect `n` buildings, where the buildings are numbered from `0` to `n - 1`. Each road can only connect two different buildings and has a certain length. The goal is to minimize the total length of the roads built while ensuring that there is a path between any pair of buildings. Given a list of road connections where each connection is represented as a tuple `(u, v, length)`, return _the **minimum** total length of the roads required to connect all buildings_. Note: It is guaranteed that a solution always exists and all buildings can be connected.","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def minimum_road_length(n, roads): Function to compute the minimum total length of roads required to connect all buildings. :param n: int - Number of buildings :param roads: List[Tuple[int, int, int]] - List of tuple (u, v, length) representing roads :return: int - Minimum total length of roads required to connect all buildings # Step 1: Initialize all buildings as their own parent (for union-find) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) # Step 2: Sort roads based on length (Kruskal\'s algorithm) roads = sorted(roads, key=lambda item: item[2]) result = [] # This will store the resultant MST (minimum spanning tree) # Step 3: Number of edges to be taken is equal to n-1 i = 0 # Initial index of sorted edges e = 0 # Initial index of result[] while e < n - 1: # Step 3.a: Pick the smallest edge and increment the index for next iteration u, v, weight = roads[i] i += 1 x = find(parent, u) y = find(parent, v) # If including this edge does not cause a cycle (if x != y), include it in the result # and increment the index of result for next edge if x != y: e += 1 result.append((u, v, weight)) union(parent, rank, x, y) # Step 4: Sum the weights of the edges in the result (the MST) minimum_cost = 0 for u, v, weight in result: minimum_cost += weight return minimum_cost"},{"question":"Write a function that takes a string of words separated by spaces and returns a new string where each word is replaced by its length. For example, given the input string \\"hello world\\", the function should return \\"5 5\\". Ensure that the function maintains the original spaces between the words and handles multiple spaces correctly.","solution":"def replace_words_with_lengths(s): Takes a string of words separated by spaces and returns a new string where each word is replaced by its length. Maintains original spaces and handles multiple spaces correctly. # Split the string by spaces to get all parts, including empty strings for multiple spaces parts = s.split(\' \') # Replace each word with its length, keep empty strings for spaces lengths = [str(len(word)) if word else \'\' for word in parts] # Join the parts back together with spaces return \' \'.join(lengths)"},{"question":"You are given an array of non-negative integers `nums` and an integer `k`. A subarray is called **ideal** if it contains exactly `k` distinct elements. Return the length of the longest **ideal** subarray. If no such subarray exists, return `0`.","solution":"def longestIdealSubarray(nums, k): Returns the length of the longest subarray containing exactly k distinct elements. If no such subarray exists, returns 0. from collections import defaultdict start = 0 max_length = 0 freq_map = defaultdict(int) for end, num in enumerate(nums): freq_map[num] += 1 while len(freq_map) > k: freq_map[nums[start]] -= 1 if freq_map[nums[start]] == 0: del freq_map[nums[start]] start += 1 if len(freq_map) == k: max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given an integer array `nums` where each integer represents a color, and it can range from `1` to `n` (inclusive). Each color number appears at least once in the array, but some colors may appear more than others. Write an algorithm that rearranges the elements of the array such that the same colors are grouped together and the relative order of different colors is maintained. Implement the function `void groupColors(int[] nums)` that modifies the input array `nums` in place to achieve the desired arrangement of colors. You must write an algorithm with a time complexity of `O(n)` and use only constant extra space.","solution":"def groupColors(nums): Rearranges the elements of the array nums such that the same colors are grouped together while maintaining the relative order of different colors. color_counts = {} for num in nums: if num in color_counts: color_counts[num] += 1 else: color_counts[num] = 1 index = 0 for color in sorted(color_counts.keys()): count = color_counts[color] for _ in range(count): nums[index] = color index += 1 return nums # added return for testing purpose"},{"question":"You are given a string `s` and need to check if it can be rearranged to form a palindrome. A palindrome is a word or sequence of characters that reads the same backward as forward. For the string to be rearranged into a palindrome, every character’s frequency must be even, with at most one character having an odd frequency (in case of strings with odd length). Write an algorithm that determines whether the string `s` can be rearranged to form a palindrome. Return `True` if it is possible to rearrange the characters of `s` to form a palindrome, otherwise return `False`.","solution":"def can_form_palindrome(s): Determines whether the string can be rearranged to form a palindrome. :param s: Input string :return: True if the string can be rearranged to form a palindrome, otherwise False. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count the number of characters with odd frequencies odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # If more than one character has an odd count, it can\'t form a palindrome if odd_count > 1: return False return True"},{"question":"In an e-commerce platform, there is a need to monitor the review ratings of various products. You are given an array `ratings` where `ratings[i]` represents the rating of the `i-th` product (1 to 5 stars). A **good subset** of ratings is one where the product ratings in the subset are ordered such that for any two ratings `a` and `b` (where `a` comes before `b` in the subset), `a <= b`. The subset can be empty but it must be chosen from contiguous elements of the array. Return the number of distinct **good subsets** in the given `ratings` array. Since the answer may be very large, return it **modulo** `109 + 7`.","solution":"MOD = 10**9 + 7 def count_good_subsets(ratings): n = len(ratings) dp = [0] * (n + 1) dp[0] = 1 # There\'s one empty subset for i in range(1, n + 1): for j in range(i - 1, -1, -1): if j == 0 or ratings[j - 1] <= ratings[i - 1]: dp[i] = (dp[i] + dp[j]) % MOD total_good_subsets = sum(dp) % MOD return (total_good_subsets - 1) % MOD # subtracting the empty subset"},{"question":"You are given a collection of `n` ropes, each with a positive integer length. Your goal is to connect the ropes into one single rope in such a way that the total cost of the connecting process is minimized. The cost of connecting two ropes is equal to the sum of their lengths. You need to find the minimum cost to connect all the ropes. Write a function `minCost(ropes)` that takes an array `ropes` representing the lengths of the ropes and returns an integer representing the minimum cost to connect all the ropes into one single rope. Use the following function signature: ```python def minCost(ropes: List[int]) -> int: ``` **Example:** ```plaintext Input: ropes = [1, 2, 3, 4, 5] Output: 33 Explanation: The optimal way to connect the ropes is as follows: 1. Connect ropes of lengths 1 and 2. Cost: 1 + 2 = 3. 2. Connect the resulting rope of length 3 with the rope of length 3. Cost: 3 + 3 = 6. 3. Connect the resulting rope of length 6 with the rope of length 4. Cost: 6 + 4 = 10. 4. Finally, connect the resulting rope of length 10 with the rope of length 5. Cost: 10 + 5 = 15. Total cost: 3 + 6 + 10 + 15 = 33. ```","solution":"def minCost(ropes): Returns the minimum cost to connect all ropes into one single rope. import heapq # Create a min-heap from the list of rope lengths heapq.heapify(ropes) total_cost = 0 # While there is more than one rope to connect while len(ropes) > 1: # Extract the two smallest ropes first = heapq.heappop(ropes) second = heapq.heappop(ropes) # Connect them cost = first + second total_cost += cost # Push the connected rope back into the min-heap heapq.heappush(ropes, cost) return total_cost"},{"question":"You are given a 2D grid of size `m x n` representing a maze, where each cell can either be a wall (`1`) or an open space (`0`). The maze has exactly one entrance and one exit located on the border of the grid. You need to find the shortest path from the entrance to the exit. However, you are allowed to break at most one wall in the grid to create a path. A path means moving from one adjacent cell to another without diagonal moves. If it is impossible to reach the exit, return -1. Provide an algorithm that determines the minimum number of steps required to reach the exit from the entrance considering the rule of breaking at most one wall, or -1 if no such path exists.","solution":"from collections import deque def shortest_path_with_wall_break(maze, entrance, exit): Find the shortest path from entrance to exit in a maze, with at most one wall break. Params: maze: List[List[int]] - 2D grid representing the maze entrance: Tuple[int, int] - coordinate of the entrance (row, column) exit: Tuple[int, int] - coordinate of the exit (row, column) Returns: int: Minimum number of steps to reach the exit, or -1 if not possible. m, n = len(maze), len(maze[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS queue: (current_row, current_col, steps, wall_broken) queue = deque([(entrance[0], entrance[1], 0, False)]) # Visited sets: visited_without_break and visited_with_break visited = [[[False, False] for _ in range(n)] for _ in range(m)] visited[entrance[0]][entrance[1]][0] = True while queue: x, y, steps, wall_broken = queue.popleft() if (x, y) == exit: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if maze[nx][ny] == 0 and not visited[nx][ny][wall_broken]: queue.append((nx, ny, steps + 1, wall_broken)) visited[nx][ny][wall_broken] = True elif maze[nx][ny] == 1 and not wall_broken and not visited[nx][ny][1]: queue.append((nx, ny, steps + 1, True)) visited[nx][ny][1] = True return -1"},{"question":"Given a string `s`, return the minimum number of steps to make the string palindrome. In one step, you are allowed to remove one character from the string. A **palindrome** is a string that reads the same backward as forward.","solution":"def min_steps_to_palindrome(s): Returns the minimum number of steps to make the string s a palindrome by removing characters. def longest_common_subsequence(x, y): n, m = len(x), len(y) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if x[i - 1] == y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m] n = len(s) reversed_s = s[::-1] lcs_length = longest_common_subsequence(s, reversed_s) return n - lcs_length"},{"question":"A company is organizing a coding contest with `n` participants and needs to assign each participant one or more practice problems. Each problem has a unique difficulty level denoted by an integer. The organizer wants to ensure that every participant receives at least one problem and no two participants receive the same set of problems to avoid any unfair advantage. An assignment is represented by an array `problems`, where `problems[i]` is the set of problems assigned to the `i`-th participant. Given `m` problems numbered `1` to `m`, determine _the **minimum** number of problems needed to ensure that each participant receives a unique set of problems._ Return _the **minimum** number of problems required._","solution":"from math import comb def minimum_problems(n): Determine the minimum number of problems required to ensure each participant receives a unique set of problems. :param n: The number of participants. :type n: int :return: The minimum number of problems. :rtype: int problems = 1 while True: total_combinations = sum(comb(problems, i) for i in range(1, problems + 1)) if total_combinations >= n: return problems problems += 1"},{"question":"You are given a list of `n` positive integers and an integer `k`. You need to pick exactly `k` integers from the list such that the sum of these `k` integers is maximized while no two chosen integers are adjacent in the original list. Return the maximum possible sum you can obtain by choosing `k` integers under this condition. For example: If the list is `[3, 2, 5, 10, 7]` and `k = 2`, the possible sums are `3 + 5 = 8`, `3 + 10 = 13`, `2 + 10 = 12`, `2 + 7 = 9`, and `5 + 7 = 12`. The maximum sum is `13`.","solution":"def max_sum_no_adjacent(nums, k): def helper(nums, k, start, cache): if k == 0: return 0 if start >= len(nums): return float(\'-inf\') if (start, k) in cache: return cache[(start, k)] include = nums[start] + helper(nums, k - 1, start + 2, cache) exclude = helper(nums, k, start + 1, cache) cache[(start, k)] = max(include, exclude) return cache[(start, k)] cache = {} result = helper(nums, k, 0, cache) return result if result != float(\'-inf\') else 0"},{"question":"You are given a 2D grid `grid` of size `m x n` where each cell contains a non-negative integer representing the height of a building. You need to compute the skyline when viewed from all four directions: top, bottom, left, and right. The skyline is defined as the silhouette formed by the buildings when viewed from a distance. Write a function that takes `grid` as input and performs the following tasks: 1. Calculate the skyline when viewed from the top, which is the maximum height in each column. 2. Calculate the skyline when viewed from the left, which is the maximum height in each row. 3. Calculate the skyline when viewed from the bottom, which is the same as the top skyline. 4. Calculate the skyline when viewed from the right, which is the same as the left skyline. 5. Return an array consisting of all four skylines in the following order: [top, left, bottom, right]. For example, given `grid = [[3, 0, 8, 4], [2, 4, 5, 7], [9, 2, 6, 3], [0, 3, 1, 0]]`, the output should be `[[9, 4, 8, 7], [8, 7, 9, 3], [9, 4, 8, 7], [8, 7, 9, 3]]`.","solution":"def calculate_skyline(grid): if not grid or not grid[0]: return [[], [], [], []] m, n = len(grid), len(grid[0]) # Calculate the skyline from the top (maximum in each column) top_skyline = [max(row[j] for row in grid) for j in range(n)] # Calculate the skyline from the left (maximum in each row) left_skyline = [max(row) for row in grid] # Calculate the skyline from the bottom (maximum in each column, same as top) bottom_skyline = top_skyline[:] # Calculate the skyline from the right (maximum in each row, same as left) right_skyline = left_skyline[:] return [top_skyline, left_skyline, bottom_skyline, right_skyline]"},{"question":"Implement a function `findLongestSubstring(s: str, k: int) -> int` that takes a string `s` and an integer `k`, and returns the length of the longest substring of `s` such that the frequency of each character in this substring is at least `k`. If no such substring exists, return 0. The function should have an average time complexity of `O(n)`.","solution":"def findLongestSubstring(s: str, k: int) -> int: def longestSubstringUtil(start, end): if end - start < k: # If length of substring is less than k, not possible return 0 # Frequency table count = {} for i in range(start, end): count[s[i]] = count.get(s[i], 0) + 1 for mid in range(start, end): if count[s[mid]] >= k: continue midNext = mid + 1 while midNext < end and count[s[midNext]] < k: midNext += 1 return max(longestSubstringUtil(start, mid), longestSubstringUtil(midNext, end)) return end - start # Whole substring valid return longestSubstringUtil(0, len(s))"},{"question":"Given an array of integers, `arr`, where some elements appear twice and others appear once, return _an array of all the integers that appear twice_. You must write an algorithm that runs in `O(n)` time and uses only constant extra space.","solution":"def find_duplicates(arr): Given an array of integers where some elements appear twice and others appear once, return an array of all the integers that appear twice. The solution runs in O(n) time and uses only constant extra space. duplicates = [] for i in range(len(arr)): index = abs(arr[i]) - 1 if arr[index] < 0: duplicates.append(abs(arr[i])) else: arr[index] = -arr[index] # Restore the array (optional, depends on whether we need to maintain the original array state) for i in range(len(arr)): arr[i] = abs(arr[i]) return duplicates"},{"question":"You are given an array of integers `nums` and an integer `k`. You need to split the array into `k` non-empty continuous subarrays. The score of a split is the sum of the maximum elements of these `k` subarrays. Return the minimum possible score.","solution":"def minMaxSplitScore(nums, k): def canSplit(maxSum): current_sum = 0 parts = 1 for num in nums: if current_sum + num > maxSum: parts += 1 current_sum = num if parts > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if canSplit(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to perform a transformation operation on `s` exactly `k` times. In one transformation, you can choose any substring of `s` and move it to the beginning of the string. Your goal is to determine the lexicographically smallest string that can be obtained after performing exactly `k` transformations. Return _the lexicographically smallest string_ that can be achieved after exactly `k` transformations.","solution":"def lexicographically_smallest_string(s: str, k: int) -> str: Returns the lexicographically smallest string that can be obtained after exactly k transformations, where each transformation consists of choosing any substring and moving it to the beginning. if k == 1: # Find the smallest rotation by trying all rotations smallest = s for i in range(len(s)): rotated = s[i:] + s[:i] if rotated < smallest: smallest = rotated return smallest else: # If k >= 2, we can use sorting to get the smallest string return \'\'.join(sorted(s))"},{"question":"Given a string `s` consisting of lowercase and uppercase alphabets, return the length of the longest substring that contains at least one character from each of the alphabets present in the string `s` exactly once. For example, if the string `s` is \\"aAbBcC\\", the longest substring containing at least one of each character exactly once is \\"aAbBcC\\" with a length of 6.","solution":"def longest_unique_substring(s): Returns the length of the longest substring that contains at least one character from each of the alphabets present in the string `s` exactly once. unique_chars = set(s) required_char_count = len(unique_chars) n = len(s) char_count = {} left = 0 max_len = 0 for right in range(n): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) == required_char_count: max_len = max(max_len, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 return max_len"},{"question":"You are given an integer array `nums` sorted in non-decreasing order. Write a function to remove duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same, and after removing the duplicates, fill the remaining indices at the end of the array with `-1` to maintain the original length of the array. Return the new length of the array after duplicates have been removed. For example, given `nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]`, your function should return `5`, and `nums` should be modified to `[0, 1, 2, 3, 4, -1, -1, -1, -1, -1]`.","solution":"def remove_duplicates(nums): Removes duplicates from the sorted array nums and fills the remaining elements with -1. Returns the new length of the array after duplicates have been removed. if not nums: return 0 write_index = 1 # Index to write new unique values for read_index in range(1, len(nums)): if nums[read_index] != nums[read_index - 1]: nums[write_index] = nums[read_index] write_index += 1 # Fill the remaining indices with -1 for i in range(write_index, len(nums)): nums[i] = -1 return write_index"},{"question":"You are given an array of `n` integers, where each element represents a different vote for a candidate in an election. Each integer corresponds to a candidate ID. Return the ID of the candidate who received more than half of the votes. If no such candidate exists, return `-1`. The function signature is as follows: `int majorityElement(vector<int>& votes)`. Assumptions: - There are `n` votes, where `n` is always a non-negative integer. - If no candidate has more than half of the votes, the function should return `-1`.","solution":"def majorityElement(votes): This function returns the candidate ID that received more than half of the votes. If no such candidate exists, it returns -1. :param votes: List[int] - List of votes where each element is a candidate ID :return: int - Candidate ID who received more than half the votes, or -1 if no such candidate exists. candidate_count = {} n = len(votes) for vote in votes: if vote in candidate_count: candidate_count[vote] += 1 else: candidate_count[vote] = 1 if candidate_count[vote] > n / 2: return vote return -1"},{"question":"Given an array of integers `arr` and an integer `k`, your task is to determine the maximum possible sum of a subarray of length `k` that can be obtained by making at most one swap between any two elements (not necessarily in the subarray). Return the maximum possible sum of the subarray after the swap.","solution":"def max_sum_after_single_swap(arr, k): n = len(arr) if n < k: return None # Not enough elements to form a subarray of length k max_sum = -float(\'inf\') current_sum = sum(arr[:k]) for i in range(n - k + 1): current_sum = sum(arr[i:i + k]) max_sum = max(max_sum, current_sum) for i in range(n): for j in range(i + 1, n): arr[i], arr[j] = arr[j], arr[i] for start in range(n - k + 1): current_sum = sum(arr[start:start + k]) max_sum = max(max_sum, current_sum) arr[i], arr[j] = arr[j], arr[i] return max_sum"},{"question":"Given an unsorted list of integers `arr`, find the length of the longest consecutive elements sequence. The consecutive elements sequence can be in any order within the list, but must be consecutive integers. For example, in the list `[100, 4, 200, 1, 3, 2]`, the longest consecutive elements sequence is `[1, 2, 3, 4]`, and thus the length is 4. Return the length of the longest consecutive elements sequence.","solution":"def longest_consecutive_sequence(arr): Finds the length of the longest consecutive elements sequence in an unsorted list of integers. if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # Check if it\'s the start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given a **0-indexed** string `s` of length `n` consisting of lowercase English letters. Your task is to find the length of the longest substring `t` of `s` such that every character in `t` appears at least `k` times. Return _the length of the longest such substring_.","solution":"def longest_substring_with_k_repeats(s, k): Returns the length of the longest substring such that every character in the substring appears at least k times. def helper(sub_s, k): if not sub_s or k > len(sub_s): return 0 char_count = {c: sub_s.count(c) for c in set(sub_s)} for idx, ch in enumerate(sub_s): if char_count[ch] < k: return max(helper(sub_s[:idx], k), helper(sub_s[idx + 1:], k)) return len(sub_s) return helper(s, k)"},{"question":"Given a list of integers `nums` and a target integer `k`, return the number of unique pairs `(a, b)` where `a` and `b` are elements of `nums` and `a + b = k`. A unique pair is considered the same regardless of the order of the elements (i.e., `(a, b)` and `(b, a)` are considered the same pair). Each element in the list can only be used once in a pair.","solution":"def unique_pairs(nums, k): Returns the number of unique pairs (a, b) where a + b = k. Each pair is considered the same regardless of order and each element can only be used once. nums.sort() seen = set() results = set() for num in nums: target = k - num if target in seen: pair = tuple(sorted((num, target))) results.add(pair) seen.add(num) return len(results)"},{"question":"You are given a binary tree where each node contains an integer value. Identify and return the value of the **deepest** node in the tree, i.e., the node that is furthest from the root. If there is a tie (multiple nodes with the same depth), return the smallest value among those nodes.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_deepest_node(root): if not root: return None queue = deque([(root, 0)]) # store node, depth current_depth = -1 smallest_value_at_deepest = float(\'inf\') while queue: node, depth = queue.popleft() if depth > current_depth: current_depth = depth smallest_value_at_deepest = node.value elif depth == current_depth: smallest_value_at_deepest = min(smallest_value_at_deepest, node.value) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return smallest_value_at_deepest"},{"question":"A **valid path** in a grid is one that begins at the top-left cell (0,0) and ends at the bottom-right cell (m-1,n-1), where m is the number of rows and n is the number of columns. A path can only move either down or right from a cell, and some cells may contain obstacles that cannot be passed through. Given a 2D list grid representing the grid, where 1 represents an obstacle and 0 represents a free cell, return `true` if there is a valid path from the top-left to the bottom-right cell, otherwise return `false`.","solution":"def is_valid_path(grid): Returns \'true\' if there is a valid path from the top-left corner to the bottom-right corner of the grid. Returns \'false\' otherwise. def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 1: return False if x == len(grid) - 1 and y == len(grid[0]) - 1: return True # Mark this cell as visited grid[x][y] = 1 # Move right or down if dfs(x + 1, y) or dfs(x, y + 1): return True return False if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False return dfs(0, 0)"},{"question":"Given a string `s` consisting of small English letters, you need to find the length of the longest substring without repeating characters. Return an integer denoting the length of the longest substring without repeating characters.","solution":"def longest_substring_without_repeating_characters(s): Returns the length of the longest substring without repeating characters. char_index_map = {} max_length = start = 0 for i, char in enumerate(s): if char in char_index_map and start <= char_index_map[char]: start = char_index_map[char] + 1 else: max_length = max(max_length, i - start + 1) char_index_map[char] = i return max_length"},{"question":"Given an m x n grid of characters `board` and a string `word`, return _true_ if `word` exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. The input `board` consists of lowercase and uppercase English letters. The word to be searched is composed entirely of lowercase English letters. You must write the function to check the presence of the word in the grid considering all the constraints mentioned.","solution":"def exist(board, word): def backtrack(r, c, word): if len(word) == 0: # All characters are checked return True if r < 0 or r >= len(board) or c < 0 or c >= len(board[0]) or board[r][c] != word[0]: return False ret = False board[r][c] = \'#\' # mark the cell as visited for row_offset, col_offset in [(0, 1), (1, 0), (0, -1), (-1, 0)]: ret = backtrack(r + row_offset, c + col_offset, word[1:]) if ret: break board[r][c] = word[0] # unmark the cell return ret for r in range(len(board)): for c in range(len(board[0])): if backtrack(r, c, word): return True return False"},{"question":"You are given a 2D grid of integers `grid` where each cell represents an elevation at that point. Implement a function that finds the minimum number of moves required to traverse from the top-left corner of the grid to the bottom-right corner. The allowed moves are to an adjacent cell (up, down, left, or right), but you can only move to a cell with height equal to or less than the current cell\'s height. Additionally, ascending to a cell with a height difference of more than 1 is not allowed. Return the minimum number of moves, or -1 if it is not possible to reach the bottom-right corner from the top-left corner.","solution":"from collections import deque def min_moves(grid): Finds the minimum number of moves required to traverse from the top-left corner of the grid to the bottom-right corner with given movement constraints. if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] start = (0, 0) end = (rows - 1, cols - 1) if start == end: return 0 queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: row, col, dist = queue.popleft() for dr, dc in directions: nr, nc = row + dr, col + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited: if grid[nr][nc] <= grid[row][col] + 1: if (nr, nc) == end: return dist + 1 queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"You are given an array of integers `nums` and an integer `k`. A continuous subarray is defined as a subarray of `nums` that contains at least one element. The sum of the elements in the subarray must be divisible by `k`. Return `true` if `nums` has a continuous subarray of size at least `2` whose sum is divisible by `k`, otherwise, return `false`.","solution":"def check_subarray_sum(nums, k): Returns `True` if there is a continuous subarray of size at least 2 whose sum is divisible by `k`, otherwise returns `False`. :param nums: List of integers. :param k: Integer by which the sum of subarray should be divisible. :return: Boolean # Dictionary to store the modulus and corresponding index mod_map = {0: -1} current_sum = 0 for i, num in enumerate(nums): current_sum += num if k != 0: current_sum %= k if current_sum in mod_map: if i - mod_map[current_sum] > 1: return True else: mod_map[current_sum] = i return False"},{"question":"You are given a matrix `mat` of integers where each row is sorted in ascending order from left to right, and each column is sorted in ascending order from top to bottom. Write a function that takes the matrix `mat` and an integer `target` as input and returns _true if `target` is present in the matrix_ and _false otherwise_. Your solution should have a runtime complexity of O(m + n), where `m` is the number of rows and `n` is the number of columns.","solution":"def search_matrix(mat, target): Searches for a target value in a sorted matrix. Parameters: mat (List[List[int]]): 2D matrix where each row and each column is sorted in ascending order. target (int): The target value to search for. Returns: bool: True if the target is found, otherwise False. if not mat: return False rows = len(mat) cols = len(mat[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if mat[row][col] == target: return True elif mat[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"You are given a 2D binary matrix `grid` where `0` represents a cell you can walk through, and `1` represents a wall that cannot be walked through. You are also given a starting cell `(startRow, startCol)` and a target cell `(endRow, endCol)`. You can move up, down, left, or right, and you cannot move outside the boundary of the grid. Your task is to determine the length of the shortest path from the starting cell to the target cell, avoiding the walls. If there is no such path, return `-1`. Return _the length of the shortest path from _(startRow, startCol)_ to _(endRow, endCol)_.","solution":"from collections import deque def shortest_path_binary_matrix(grid, startRow, startCol, endRow, endCol): Returns the length of the shortest path in a binary maze from start to end, avoiding walls. Returns -1 if no path exists. if grid[startRow][startCol] == 1 or grid[endRow][endCol] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # four possible movements queue = deque([(startRow, startCol, 0)]) visited = set() visited.add((startRow, startCol)) while queue: row, col, distance = queue.popleft() if (row, col) == (endRow, endCol): return distance for dr, dc in directions: newRow, newCol = row + dr, col + dc if 0 <= newRow < rows and 0 <= newCol < cols and grid[newRow][newCol] == 0 and (newRow, newCol) not in visited: queue.append((newRow, newCol, distance + 1)) visited.add((newRow, newCol)) return -1"},{"question":"You are given two strings `s` and `t` consisting only of lowercase letters. A string is called **scrambled** if it can be formed by **rearranging** the characters of another string. Additionally, a string can become another string by performing a series of **swap** operations. Each swap operation allows you to select two characters of the string and swap them. Your task is to determine if string `t` can be formed by performing these swap operations on string `s`. Return `true` if `t` can be obtained by rearranging the characters of `s`, otherwise, return `false`.","solution":"def is_scrambled(s, t): Determines if string t can be formed by rearranging the characters of string s. Args: s (str): The source string. t (str): The target string. Returns: bool: True if t can be obtained by rearranging s, False otherwise. if len(s) != len(t): return False return sorted(s) == sorted(t)"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to return the **k**-th largest element in the array after removing all elements that occur more than once. If there are fewer than **k** unique elements remaining, return `\\"Not enough unique elements\\"`.","solution":"def kth_largest_unique(arr, k): Returns the k-th largest element in the array after removing all elements that occur more than once. If there are fewer than k unique elements remaining, returns \\"Not enough unique elements\\". from collections import Counter # Count the occurrences of each element count = Counter(arr) # Filter elements with exactly one occurrence unique_elements = [num for num in arr if count[num] == 1] # If there are fewer than k unique elements, return the error message if len(unique_elements) < k: return \\"Not enough unique elements\\" # Sort unique elements in descending order unique_elements.sort(reverse=True) # Return the k-th largest element return unique_elements[k - 1]"},{"question":"You are given a binary tree with `n` nodes, where each node is labeled from `1` to `n`. The tree is represented as a list of `n-1` pairs of integers, where each pair `(u, v)` denotes an edge between nodes `u` and `v`. Implement a function to determine whether the binary tree is balanced. A binary tree is defined to be balanced if, for any node, the height difference between its left and right subtrees is at most `1`. Return `true` if the tree is balanced; otherwise, return `false`.","solution":"from collections import defaultdict class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def build_tree(edges, n): if n == 0: return None nodes = {i: TreeNode(i) for i in range(1, n + 1)} children = defaultdict(list) for u, v in edges: children[u].append(v) children[v].append(u) def assign_children(node_val, parent_val): node = nodes[node_val] child_nodes = [ch for ch in children[node_val] if ch != parent_val] if child_nodes: node.left = nodes[child_nodes[0]] assign_children(child_nodes[0], node_val) if len(child_nodes) > 1: node.right = nodes[child_nodes[1]] assign_children(child_nodes[1], node_val) root_val = 1 assign_children(root_val, None) return nodes[root_val] def is_balanced_tree(root): def check_balance(node): if not node: return True, 0 is_left_balanced, left_height = check_balance(node.left) is_right_balanced, right_height = check_balance(node.right) if not is_left_balanced or not is_right_balanced: return False, 0 if abs(left_height - right_height) > 1: return False, 0 return True, max(left_height, right_height) + 1 balanced, _ = check_balance(root) return balanced def is_balanced(edges, n): root = build_tree(edges, n) return is_balanced_tree(root)"},{"question":"Given a string `s`, return the longest prefix of `s`, which is also a suffix of `s`. The prefix and suffix must not overlap. If no such prefix exists, return an empty string.","solution":"def longest_prefix_suffix(s): Returns the longest prefix of s which is also a suffix of s. The prefix and suffix must not overlap. n = len(s) for length in range(n//2, 0, -1): if s[:length] == s[-length:]: return s[:length] return \\"\\""},{"question":"You are given an array of `n` integers, where each integer represents the height of a building in a row of buildings. The buildings are viewed from the left side. Implement an algorithm to find the `index` of the building which would be the first to become invisible as you move to the right. A building is considered invisible if there is a taller building before or at the same height. Return the `index` of the first such building. If no building becomes invisible when viewed from the left, return `-1`.","solution":"def first_invisible_building(heights): Returns the index of the first building that will become invisible when viewed from the left due to a taller or equally tall building before it. Parameters: heights (list of int): List of building heights. Returns: int: The index of the first invisible building, or -1 if none. if not heights: return -1 max_height = heights[0] for i in range(1, len(heights)): if heights[i] <= max_height: return i max_height = max(max_height, heights[i]) return -1"},{"question":"Given an integer array `nums`, return _the **minimum** number of steps to make every element in `nums` the same_. In one step, you can select any two **different** elements and replace one of them with the other. If the array is empty or has only one unique element, return `0`.","solution":"def min_steps_to_make_elements_equal(nums): Returns the minimum number of steps to make every element in `nums` the same. if not nums: return 0 unique_elements = set(nums) return len(unique_elements) - 1 if len(unique_elements) > 1 else 0"},{"question":"You are given an array of integers `arr` and an integer `d`. In one operation, you can pick any element of the array and either increase or decrease it by `d`. Determine _the minimum number of operations required to make all elements of the array equal_. If it is not possible to make all elements equal, return `-1`.","solution":"def min_operations_to_make_equal(arr, d): Returns the minimum number of operations required to make all elements of the array equal, or -1 if it is not possible. min_elem = min(arr) max_elem = max(arr) # Check if it\'s possible to make all elements equal for num in arr: if (num - min_elem) % d != 0 or (max_elem - num) % d != 0: return -1 # Find a target value which minimizes the number of operations def total_operations(target): total_ops = 0 for num in arr: total_ops += abs(num - target) // d return total_ops target = min_elem + d * ((max_elem - min_elem) // d // 2) return total_operations(target)"},{"question":"Given an array of non-negative integers `tasks`, where `tasks[i]` represents the amount of time required to complete the `i`th task, and an integer `n` representing the number of identical machines available to process these tasks, devise a strategy to assign all tasks such that the total time to complete all tasks is minimized. Each machine can process only one task at a time. _Return the minimum total time required to complete all tasks._","solution":"def can_complete(tasks, machines, max_time): current_machines = 1 current_load = 0 for task in tasks: if current_load + task <= max_time: current_load += task else: current_machines += 1 if current_machines > machines: return False current_load = task return True def minimum_total_time(tasks, machines): if machines >= len(tasks): return max(tasks) left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if can_complete(tasks, machines, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given two strings `s1` and `s2`. Write a function that determines if `s2` is an anagram of `s1`. An anagram of a string is another string that contains the same characters, each with the same frequency. Return `true` if `s2` is an anagram of `s1`, and `false` otherwise.","solution":"def is_anagram(s1, s2): Determines if s2 is an anagram of s1. :param s1: First string :param s2: Second string :return: True if s2 is an anagram of s1, False otherwise # Early termination if the lengths are not equal if len(s1) != len(s2): return False # Use a dictionary to count the frequency of each character in s1 char_count = {} for char in s1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Decrease the frequency while iterating through s2 for char in s2: if char in char_count: char_count[char] -= 1 if char_count[char] < 0: return False else: return False return True"},{"question":"You are given an unsorted integer array `nums` and an integer `k`. Return _the **k** largest elements from the given array_. The returned array should be sorted in **ascending** order. Does not modify the original array `nums`. **Note**: You may assume `k` is a positive integer and it is always less than or equal to the length of `nums`.","solution":"import heapq def k_largest_elements(nums, k): Returns the k largest elements from the given array in ascending order. if k == 0: return [] # Use a min-heap of size k to find the k largest elements min_heap = heapq.nlargest(k, nums) return sorted(min_heap)"},{"question":"Given a string `s` consisting of lowercase letters, you need to remove the minimum number of characters from `s` so that every letter that remains appears an even number of times. Return _a string_ `result` _which is the lexicographically smallest string that can be obtained_ after removing the minimum number of characters. If there are multiple valid results with the same length, return the one that comes first in lexicographical order.","solution":"def make_even_string(s): Given a string `s` consisting of lowercase letters, this function returns the lexicographically smallest string after removing the minimum number of characters so that every letter that remains appears an even number of times. from collections import Counter # Count the occurrences of each character char_count = Counter(s) # Find characters that need to be removed to_remove = {ch for ch, count in char_count.items() if count % 2 != 0} # Create the result string without the characters to be removed result = \'\'.join(sorted(ch * (count - count % 2) for ch, count in char_count.items())) return result"},{"question":"Given a string `s` and a dictionary of strings `wordDict`, return _all possible sentences that can be formed by breaking `s` into a sequence of one or more dictionary words_. You may assume that the dictionary contains all words required for the solution. The order of words in the resulting sentences must be maintained as they appear in the original string `s`.","solution":"def wordBreak(s, wordDict): Given a string s and a list of words wordDict, return all possible sentences that can be formed by breaking s into a sequence of one or more dictionary words. :param s: The input string to be segmented. :param wordDict: The list of valid words. :return: A list of all possible sentences. def backtrack(index, path): if index == len(s): result.append(\' \'.join(path)) return for end in range(index + 1, len(s) + 1): word = s[index:end] if word in wordDict: path.append(word) backtrack(end, path) path.pop() result = [] backtrack(0, []) return result"},{"question":"You are given a directed graph represented by an integer `n`, the number of nodes, and a 2D integer array `edges` where each `edges[i] = [ui, vi]` represents a directed edge from node `ui` to node `vi`. The graph may contain cycles. Return _an array of integers_ `result` _of length_ `n` _where_ `result[i]` _is the **number of nodes** reachable from node_ `i` _including itself_. If a node does not have any outgoing edges, it can only reach itself.","solution":"def reachableNodes(n, edges): from collections import defaultdict, deque # Create a graph representation using adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) def bfs(start_node): # Perform a breadth-first search to find all reachable nodes from start_node reachable = set() queue = deque([start_node]) while queue: node = queue.popleft() if node not in reachable: reachable.add(node) for neighbor in graph[node]: if neighbor not in reachable: queue.append(neighbor) return len(reachable) result = [] for i in range(n): result.append(bfs(i)) return result"},{"question":"Given a list of integers representing the prices of different items in a store, and an integer budget, determine if there exists a subset of items whose total price is exactly equal to the budget. Return `true` if such a subset exists, otherwise return `false`.","solution":"def subset_sum(prices, budget): Returns True if there exists a subset of prices that sum up to the budget, otherwise False. n = len(prices) dp = [False] * (budget + 1) dp[0] = True # There\'s always a subset with sum 0 for price in prices: for i in range(budget, price-1, -1): if dp[i - price]: dp[i] = True return dp[budget]"},{"question":"You are given an array `arr` of integers and an integer `target`. Your task is to find two distinct integers in the array such that their sum is closest to the given `target`. Return _the indices of the two integers in a tuple_. You may assume that each input would have exactly one solution and you may not use the same element twice.","solution":"def two_sum_closest(arr, target): Finds two distinct integers in the array such that their sum is closest to the given target. :param arr: List of integers. :param target: The target integer. :return: A tuple of the indices of the two integers. n = len(arr) if n < 2: raise ValueError(\\"Array must contain at least two elements.\\") # Sorting the array while keeping track of original indices indexed_arr = list(enumerate(arr)) indexed_arr.sort(key=lambda x: x[1]) i, j = 0, len(arr) - 1 closest_sum = float(\'inf\') best_pair = (None, None) while i < j: idx1, val1 = indexed_arr[i] idx2, val2 = indexed_arr[j] current_sum = val1 + val2 if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum best_pair = (idx1, idx2) if current_sum < target: i += 1 else: j -= 1 return best_pair"},{"question":"You are given an array `colors` where `colors[i]` is the color of the `i-th` house. There are `m` colors labeled `0` to `m-1`. The array is circular, meaning the last house is adjacent to the first house. You must paint each house such that no two adjacent houses, including the first and the last house, have the same color, and you want to minimize the number of repaints needed. Return _the minimum number of repaints required to achieve this condition_.","solution":"def min_repaints(colors): Returns the minimum number of repaints needed such that no two adjacent houses have the same color. The array is circular, meaning the last house is adjacent to the first house. n = len(colors) if n == 0: return 0 # Function to count repaints for start color configuration (start_with) def count_repaints(start_with): cnt = 0 # This variable holds the expected color based on the start color expected_color = start_with for i in range(n): if colors[i] != expected_color: cnt += 1 expected_color = 1 - expected_color # Alternate colors between 0 and 1 return cnt # There are only two ways of alternating colors starting with \\"0\\" or \\"1\\" repaints_0 = count_repaints(0) repaints_1 = count_repaints(1) return min(repaints_0, repaints_1)"},{"question":"You are given an integer array `heights` representing the heights of a series of buildings. The goal is to collect rainwater trapped between the buildings. The array `heights` represents the elevation map where the width of each bar is `1`. Calculate the total amount of rainwater that can be trapped after it rains. Return the total trapped rainwater.","solution":"def trap(heights): Calculate total trapped rainwater based on the given heights. Parameters: heights (list[int]): A list of integer heights representing the buildings. Returns: int: The total amount of trapped rainwater. if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) water_trapped += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += right_max - heights[right] return water_trapped"},{"question":"Given an integer array `arr` and an integer `target`, you need to find a contiguous subarray whose product of elements equals the `target`. Return the positions of the first and last element of this subarray in the form of a tuple. If no such subarray exists, return `(-1, -1)`. The solution should be efficient, aiming for a time complexity of `O(n)`.","solution":"def find_subarray_with_product(arr, target): This function finds the starting and ending indices of a contiguous subarray whose product of elements equals the target. If no such subarray exists, it returns (-1, -1). product = 1 start = 0 for end in range(len(arr)): product *= arr[end] while product > target and start <= end: product //= arr[start] start += 1 if product == target: return (start, end) return (-1, -1)"},{"question":"Given a `2D` grid of integers where each row and each column are sorted in ascending order, write a function that searches for a given `target` value in the grid. Your function should return `true` if the `target` is found, and `false` otherwise. Design your solution to be as efficient as possible.","solution":"def search_matrix(matrix, target): Searches for a target value in a 2D grid of integers where each row and each column are sorted in ascending order. Returns True if the target is found, and False otherwise. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 # Start from the top-right corner while row < rows and col >= 0: if matrix[row][col] == target: return True elif target < matrix[row][col]: col -= 1 # Move left else: row += 1 # Move down return False"},{"question":"You are given a list of meetings represented as arrays where each meeting consists of a start time and an end time `[start, end]`. Find the minimum number of meeting rooms required to accommodate all the meetings. A meeting room can only be used by one meeting at a time, and meetings may overlap in time. Example: ``` Input: meetings = [[0, 30], [5, 10], [15, 20]] Output: 2 ``` Explanation: - The first meeting starts at 0 and ends at 30. It occupies a room. - The second meeting starts at 5 and ends at 10. It overlaps with the first meeting and requires a second room. - The third meeting starts at 15 and ends at 20. It does not overlap with any currently meeting, so no additional room is required.","solution":"def min_meeting_rooms(meetings): Finds the minimum number of meeting rooms required to accommodate all the given meetings. Parameters: meetings (list of lists): A list of meetings where each meeting is represented by [start, end]. Returns: int: The minimum number of meeting rooms required. if not meetings: return 0 # Sort meetings by start time meetings.sort(key=lambda x: x[0]) # Use a min heap to keep track of end times of ongoing meetings import heapq end_times = [] # Push the end time of the first meeting heapq.heappush(end_times, meetings[0][1]) # For all the other meetings for i in range(1, len(meetings)): # If the meeting can start after the earliest ending meeting if meetings[i][0] >= end_times[0]: # Reuse the room, remove the earliest ending meeting heapq.heappop(end_times) # Push the end time of the current meeting to the heap heapq.heappush(end_times, meetings[i][1]) # The size of the heap is the number of meeting rooms required return len(end_times)"},{"question":"You are given a binary tree in which each node has a random integer value. Your task is to find the largest value in each row of the tree and return it as an array. Implement a function that, given the root of the binary tree, returns an array of the largest values in each respective row of the tree. The tree has at most 10^4 nodes and values can range from -10^9 to 10^9. Your solution should efficiently handle the input size.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_values_in_each_row(root): if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) max_value = -float(\'inf\') for _ in range(level_length): node = queue.popleft() max_value = max(max_value, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"You are given an array of `n` integers and a target sum `x`. Write a function that determines if there exist two distinct elements in the array such that their sum is equal to `x`. Return `true` if such a pair exists and `false` otherwise. The function should have a time complexity better than O(n^2).","solution":"def has_pair_with_sum(arr, x): Determines if there exist two distinct elements in the array such that their sum is equal to x. Parameters: arr (list of int): List of integers. x (int): Target sum. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in arr: if x - num in seen: return True seen.add(num) return False"},{"question":"Given a string `s` containing lowercase letters, you need to perform operations on the string so that all of its substrings are composed of distinct characters. To achieve this, you can repeatedly choose a substring of `s` with duplicate characters and remove one character from it. Return the minimum number of such operations required to ensure all substrings have distinct characters.","solution":"def min_operations_to_unique_substrings(s): Given a string s, return the minimum number of operations needed to make all substrings of s composed of distinct characters. if not s: return 0 # Create a frequency dictionary for the characters in the string char_freq = {} for char in s: if char in char_freq: char_freq[char] += 1 else: char_freq[char] = 1 # The number of operations is the number of characters that appear more than once operations = 0 for freq in char_freq.values(): if freq > 1: operations += freq - 1 return operations"},{"question":"Given a string `time` representing the current time in the HH:MM 24-hour format, return the next closest time that can be generated by reusing the digits currently present in `time`. The result should also be in the HH:MM format. You must use the digits as they appear in `time` and cannot introduce new digits.","solution":"def nextClosestTime(time: str) -> str: Given a string time representing the current time in the HH:MM 24-hour format, returns the next closest time that can be generated by reusing the digits currently present in time hours, minutes = map(int, time.split(\':\')) digits = sorted(set(time.replace(\':\', \'\'))) while True: if minutes < 59: minutes += 1 else: minutes = 0 if hours < 23: hours += 1 else: hours = 0 next_time = f\\"{hours:02}:{minutes:02}\\" if all(char in digits for char in next_time.replace(\':\', \'\')): return next_time"},{"question":"You are given a **0-indexed** integer array `nums` containing `n` integers. Your task is to find the **k-th smallest unique** integer in the array. If the k-th smallest unique integer does not exist, return `-1`. For example, given `nums = [4, 3, 1, 1, 2, 5, 4, 3]` and `k = 3`, the unique integers in sorted order are `[2, 5]`, so the answer is `-1` because there are not enough unique integers. Return _the **k-th smallest unique** integer in the array_, or `-1` if it does not exist.","solution":"def kth_smallest_unique(nums, k): Return the k-th smallest unique integer in the array, or -1 if it does not exist. from collections import Counter count = Counter(nums) unique_nums = sorted(num for num, freq in count.items() if freq == 1) if k <= len(unique_nums): return unique_nums[k-1] else: return -1"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. You need to determine the minimum number of moves required to make all the characters in the string appear at least `k` times. In one move, you can choose any character and replace it with another character. Return the minimum number of moves required to satisfy the condition.","solution":"def min_moves_to_k_frequencies(s, k): from collections import Counter char_count = Counter(s) moves = 0 for count in char_count.values(): if count < k: moves += (k - count) return moves"},{"question":"A warehouse management system needs to track inventories and process orders efficiently. Implement the `InventoryManager` class with the following methods: * `InventoryManager()` Initializes the inventory manager with an empty inventory. * `addItem(itemName, quantity)` Adds `quantity` of `itemName` to the inventory. If `itemName` already exists, increase its quantity by the given amount. * `removeItem(itemName, quantity)` Removes `quantity` of `itemName` from the inventory. If the remaining quantity of `itemName` becomes zero or negative, remove `itemName` from the inventory. * `checkStock(itemName)` Returns the current quantity of `itemName` in the inventory. If `itemName` does not exist, return `0`.","solution":"class InventoryManager: def __init__(self): self.inventory = {} def addItem(self, itemName, quantity): if itemName in self.inventory: self.inventory[itemName] += quantity else: self.inventory[itemName] = quantity def removeItem(self, itemName, quantity): if itemName in self.inventory: self.inventory[itemName] -= quantity if self.inventory[itemName] <= 0: del self.inventory[itemName] def checkStock(self, itemName): return self.inventory.get(itemName, 0)"},{"question":"You are given two integer arrays `nums1` and `nums2` sorted in ascending order and an integer `k`. Define a pair `(u, v)` which consists of one element from the first array and one element from the second array. Return _the_ `kth` _smallest sum of pairs (`u + v`)_.","solution":"import heapq def kthSmallestPairSum(nums1, nums2, k): Returns the kth smallest sum of pairs formed by taking one element from nums1 and one element from nums2. min_heap = [] for i in range(len(nums1)): heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0)) count = 0 while min_heap: sum_val, i, j = heapq.heappop(min_heap) count += 1 if count == k: return sum_val if j + 1 < len(nums2): heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))"},{"question":"Implement a basic calculator to evaluate a simple expression string containing non-negative integers, `+`, `-`, `(`, `)`, and empty spaces. The expression string represents a valid arithmetic expression that can be understood and computed by a calculator. The calculator should support the following operations: - Addition and subtraction of integers. - Handling of whitespace characters. - Evaluation of parentheses to determine operation precedence. Write a function `int calculate(String s)` that takes a string `s` representing the arithmetic expression and returns the computed integer result of the expression.","solution":"def calculate(s: str) -> int: def helper(s: list) -> int: stack = [] num = 0 sign = 1 while len(s) > 0: c = s.pop(0) if c.isdigit(): num = num * 10 + int(c) elif c == \'+\': stack.append(sign * num) num = 0 sign = 1 elif c == \'-\': stack.append(sign * num) num = 0 sign = -1 elif c == \'(\': num = helper(s) elif c == \')\': stack.append(sign * num) return sum(stack) stack.append(sign * num) return sum(stack) # Convert the input string into a list of characters for easy manipulation return helper(list(s))"},{"question":"You are given an array `points` containing the coordinates of some points on a 2D plane, where points[i] = [xi, yi]. The points form a simple polygon when joined sequentially by straight lines. You are also given an integer `k`. Your task is to find the k-th smallest distance from a point to its nearest neighbor in this polygon. If it is not possible to find such a distance, return **-1**. The distances should be Euclidean, and points are guaranteed to not be collinear. Return the distance rounded to 4 decimal places.","solution":"import math def euclidean_distance(p1, p2): Calculate the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def k_th_smallest_distance(points, k): Find the k-th smallest distance from a point to its nearest neighbor in the polygon. n = len(points) if k > n: return -1 distances = [] for i in range(n): next_i = (i + 1) % n distance = euclidean_distance(points[i], points[next_i]) distances.append(distance) distances.sort() return round(distances[k-1], 4)"},{"question":"Given a linked list where each node contains an integer value, define a method to partition the linked list around a value `x`, such that all nodes less than `x` come before all nodes greater than or equal to `x`. The original relative order of the nodes in each of the two partitions should be preserved. Implement the function `partitionList(ListNode head, int x)` which takes in the head of the linked list and the integer `x`, and returns the head of the modified linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partitionList(head, x): Partitions the linked list around value x. :param head: ListNode, the head of the input linked list :param x: int, the partition value :return: ListNode, the head of the partitioned linked list if not head: return None less_head = ListNode(0) # dummy head for less than partition greater_head = ListNode(0) # dummy head for greater than or equal partition less = less_head greater = greater_head current = head while current: if current.val < x: less.next = current less = less.next else: greater.next = current greater = greater.next current = current.next greater.next = None # finalize greater partition less.next = greater_head.next # combine partitions return less_head.next"},{"question":"You are given a list of integers `nums` which represents a binary search tree (BST) traversed in preorder. Your task is to reconstruct the BST from `nums` and return its root node. A **binary search tree** is a binary tree in which for each node: the nodes in the left subtree contain only values less than the node\'s value, and the nodes in the right subtree contain only values greater than the node\'s value. In a **preorder** traversal, each node is visited before its child nodes (root-left-right). Return the root node of the reconstructed tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstFromPreorder(preorder): Given a list of integers representing a BST\'s preorder traversal, reconstruct the BST and return its root node. if not preorder: return None # Construct the root node root = TreeNode(preorder[0]) stack = [root] for value in preorder[1:]: if value < stack[-1].val: # Make this node as the left child of the last node stack[-1].left = TreeNode(value) stack.append(stack[-1].left) else: # Make this node as the right child of the last popped node. while stack and stack[-1].val < value: last = stack.pop() last.right = TreeNode(value) stack.append(last.right) return root"},{"question":"You are given a list of integers `nums` representing an arithmetic progression with one term missing. An arithmetic progression is a sequence of numbers in which the difference between consecutive terms is constant. Write a function that identifies and returns the missing term in the sequence. If there are multiple solutions, return the *smallest* missing term. The list will have at least two numbers and the difference will be non-zero. `Example:` ```python # Given nums = [5, 7, 9, 11, 15], the function should return 13 because that maintains the consistent difference of 2 between terms. # Given nums = [20, 16, 12, 8, 0], the function should return 4 as that fits with the consistent difference of -4. ```","solution":"def find_missing_term(nums): Finds the missing term in an arithmetic progression. n = len(nums) if n < 2: return None # Calculate the expected common difference total_diff = nums[-1] - nums[0] diff = total_diff // n for i in range(1, n): expected_value = nums[0] + i * diff if nums[i] != expected_value: return expected_value return None # This should never be reached if there is indeed one missing term in nums # Examples: # print(find_missing_term([5, 7, 9, 11, 15])) # should return 13 # print(find_missing_term([20, 16, 12, 8, 0])) # should return 4"},{"question":"Given an array of integers `arr`, and an integer `sum`, return the count of pairs of elements in the array that add up to `sum`. Each pair should be counted only once, regardless of the order of the elements in the pair. If there are no such pairs, return `0`.","solution":"def count_pairs_with_sum(arr, sum): Returns the count of pairs of elements in the array that add up to the given sum. Each pair is counted only once. seen = set() pairs = set() for number in arr: target = sum - number if target in seen: pairs.add((min(target, number), max(target, number))) seen.add(number) return len(pairs)"},{"question":"Given a linked list `head`, each node containing a unique integer value, design an algorithm to find and return _the longest increasing subsequence (LIS)_ within the linked list. A subsequence is defined as a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. The longest increasing subsequence is defined as the longest sequence of nodes such that each subsequent node has a greater value than the preceding one. Return the LIS as a list of node values in increasing order.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def longest_increasing_subsequence(head): Find the longest increasing subsequence in a linked list and return it as a list of node values. if not head: return [] # Transform linked list to an array to simplify LIS finding arr = [] current = head while current: arr.append(current.value) current = current.next if not arr: return [] # Array to store our increasing subsequence lis, backtrack = [], [] for i in range(len(arr)): lis.append(1) backtrack.append(None) for j in range(i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 backtrack[i] = j # Find the index of the max LIS max_index = 0 for i in range(1, len(lis)): if lis[i] > lis[max_index]: max_index = i # Reconstruct LIS from backtrack table sequence = [] i = max_index while i is not None: sequence.append(arr[i]) i = backtrack[i] return sequence[::-1] # reverse to get the correct order"},{"question":"Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return _a new sorted array that contains all the elements of `nums1` and `nums2`_.","solution":"def merge_sorted_arrays(nums1, nums2): Merge two sorted arrays into a new sorted array. Args: nums1 (List[int]): First sorted array. nums2 (List[int]): Second sorted array. Returns: List[int]: A new sorted array. i, j = 0, 0 merged_array = [] while i < len(nums1) and j < len(nums2): if nums1[i] < nums2[j]: merged_array.append(nums1[i]) i += 1 else: merged_array.append(nums2[j]) j += 1 while i < len(nums1): merged_array.append(nums1[i]) i += 1 while j < len(nums2): merged_array.append(nums2[j]) j += 1 return merged_array"},{"question":"Implement a function to calculate the maximum profit you can achieve given an integer array `prices`, where `prices[i]` is the price of a given stock on the ith day. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times), but you must sell the stock before you buy it again. Return the maximum profit you can achieve from these transactions.","solution":"def maxProfit(prices): Returns the maximum profit achievable with as many transactions as needed. :param prices: List[int] where prices[i] is the price of a given stock on the ith day. :return: int - Maximum profit. max_profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"There are `n` houses evenly lined up along a street, and each house needs to be painted. You are given an array `costs` where `costs[i][j]` represents the cost of painting the `i-th` house with color `j`. Each house can be painted with one of three colors: red, blue, or green, denoted by `0`, `1`, and `2`, respectively. You need to paint all the houses such that no two adjacent houses have the same color. Find the minimum cost to paint all the houses. Return _the minimum cost to paint all the houses_.","solution":"def min_cost_to_paint_houses(costs): Given a costs matrix where costs[i][j] is the cost of painting the i-th house with color j, returns the minimum cost to paint all the houses such that no two adjacent houses have the same color. if not costs: return 0 n = len(costs) dp = costs[0][:] for i in range(1, n): previous_dp = dp[:] dp[0] = costs[i][0] + min(previous_dp[1], previous_dp[2]) dp[1] = costs[i][1] + min(previous_dp[0], previous_dp[2]) dp[2] = costs[i][2] + min(previous_dp[0], previous_dp[1]) return min(dp) # Example usage: # costs = [ # [17, 2, 17], # [16, 16, 5], # [14, 3, 19] # ] # print(min_cost_to_paint_houses(costs)) # Output: 10"},{"question":"Given a binary tree, return the **depth** of the tree. A binary tree\'s depth is the maximum number of layers of nodes from the root node down to the furthest leaf node. Each node in the binary tree has the following attributes: * `TreeNode.val` (the value of the node, an integer) * `TreeNode.left` (the left child node, or `null` if there is no left child) * `TreeNode.right` (the right child node, or `null` if there is no right child) Write a function `int maxDepth(TreeNode root)` that takes the root node of a binary tree as input and returns an integer representing the depth of the tree. If the tree is empty (i.e., `root` is `null`), the depth is 0.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root): Returns the maximum depth of the binary tree. if root is None: return 0 else: left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"Given an array of integers `arr`, write a function to determine if all the elements are unique. If all the elements are unique, return `true`. Otherwise, return `false`. The function should have a time complexity of O(n), where `n` is the number of elements in the array.","solution":"def are_all_elements_unique(arr): Returns True if all elements in the array are unique, otherwise False. seen_elements = set() for element in arr: if element in seen_elements: return False seen_elements.add(element) return True"},{"question":"You are given a list of integers `arr` and an integer `d`. An increasing subsequence of length `t` is a subsequence that consists of elements in increasing order and has exactly `t` elements. Find the length of the longest increasing subsequence in `arr` such that the absolute difference between any two consecutive elements in the subsequence is less than or equal to `d`. If no such subsequence exists, return 0.","solution":"def longest_increasing_subsequence_with_max_difference(arr, d): n = len(arr) if n == 0: return 0 # dp[i] will store the length of the longest increasing subsequence ending with arr[i] dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j] and arr[i] - arr[j] <= d: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"}]'),A={name:"App",components:{PoemCard:I},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},N={class:"search-container"},C={class:"card-container"},L={key:0,class:"empty-state"},z=["disabled"],S={key:0},D={key:1};function E(i,e,u,c,s,a){const f=p("PoemCard");return n(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",N,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[b,s.searchQuery]]),s.searchQuery?(n(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):l("",!0)]),t("div",C,[(n(!0),r(y,null,w(a.displayedPoems,(o,g)=>(n(),v(f,{key:g,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),r("div",L,' No results found for "'+h(s.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(n(),r("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),r("span",D,"Loading...")):(n(),r("span",S,"See more"))],8,z)):l("",!0)])}const G=m(A,[["render",E],["__scopeId","data-v-66f1e2b3"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/2.md","filePath":"library/2.md"}'),P={name:"library/2.md"},W=Object.assign(P,{setup(i){return(e,u)=>(n(),r("div",null,[x(G)]))}});export{O as __pageData,W as default};
