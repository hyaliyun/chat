import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},A={class:"review-content"};function N(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",A,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const E=c(k,[["render",N],["__scopeId","data-v-924e77a8"]]),O=JSON.parse('[{"question":"# Coding Challenge: Improved Heap Sort with Simulation Heap Sort is a popular sorting algorithm that can be implemented using either a Max Heap or a Min Heap. The provided code snippets show two variations of Heap Sort: one using a Max Heap (`max_heap_sort`) and the other using a Min Heap (`min_heap_sort`). Your task is to **implement a more versatile and efficient version** of the Heap Sort algorithm. This improved version should handle both Ascending and Descending order based on function parameters and optionally simulate the sorting process by printing the array at each significant iteration. # Function Signature ```python def versatile_heap_sort(arr, ascending=True, simulation=False): Sorts an array using an optimized heap sort algorithm. Parameters: arr (List[int]): The array to be sorted. ascending (bool): If True, sort in ascending order, otherwise sort in descending order. simulation (bool): If True, print the array at each significant step for visualization. Returns: List[int]: The sorted array. ``` # Input * `arr` (List[int]): A list of integers to be sorted. * `ascending` (bool): If `True`, sort the array in ascending order (default). If `False`, sort the array in descending order. * `simulation` (bool): If `True`, print the array at each significant step. # Output * A sorted list of integers as per the sorting order specified. # Constraints * The array can have up to `10^5` elements. * Elements can be negative or positive integers. * Your solution should be efficient and handle edge cases appropriately. # Requirements 1. **Optimize the Heapify Process**: Improve the internal heapify process to reduce unnecessary iterations. 2. **Accommodate Both Heaps**: Depending on the `ascending` parameter, dynamically switch between Max Heap and Min Heap sorting logic. 3. **Simulation Mode**: If `simulation` is set to `True`, print the state of the array at each step where a significant change occurs (e.g., after each full heapify operation or each swap). # Example ```python # Example 1: Ascending Sort arr = [4, 10, 3, 5, 1] result = versatile_heap_sort(arr, ascending=True) # Expected Output: [1, 3, 4, 5, 10] # Example 2: Descending Sort with Simulation arr = [4, 10, 3, 5, 1] result = versatile_heap_sort(arr, ascending=False, simulation=True) # Expected Output (simulation steps printed and final result): # iteration 1: ... # iteration 2: ... # ... # Final Result: [10, 5, 4, 3, 1] ``` # Notes * Your implementation should account for edge cases, such as arrays with all identical elements or arrays that are already sorted. * Make sure your function is efficient and can handle large inputs within acceptable time limits.","solution":"def versatile_heap_sort(arr, ascending=True, simulation=False): Sorts an array using an optimized heap sort algorithm. Parameters: arr (List[int]): The array to be sorted. ascending (bool): If True, sort in ascending order, otherwise sort in descending order. simulation (bool): If True, print the array at each significant step for visualization. Returns: List[int]: The sorted array. def heapify(arr, n, i, ascending): largest_or_smallest = i left = 2 * i + 1 right = 2 * i + 2 if ascending: # If left child exists and is greater than root if left < n and arr[left] > arr[largest_or_smallest]: largest_or_smallest = left # If right child exists and is greater than largest so far if right < n and arr[right] > arr[largest_or_smallest]: largest_or_smallest = right else: # If left child exists and is less than root if left < n and arr[left] < arr[largest_or_smallest]: largest_or_smallest = left # If right child exists and is less than largest so far if right < n and arr[right] < arr[largest_or_smallest]: largest_or_smallest = right # If largest or smallest is not root if largest_or_smallest != i: arr[i], arr[largest_or_smallest] = arr[largest_or_smallest], arr[i] # swap if simulation: print(f\\"heapify swap: {arr}\\") heapify(arr, n, largest_or_smallest, ascending) # Build a maxheap/minheap n = len(arr) for i in range(n//2 - 1, -1, -1): heapify(arr, n, i, ascending) if simulation: print(f\\"buildheap: {arr}\\") # One by one extract elements for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap if simulation: print(f\\"extract swap: {arr}\\") heapify(arr, i, 0, ascending) if simulation: print(f\\"post-extract heapify: {arr}\\") return arr"},{"question":"# Sliding Window Maximum Problem You are given an array of integers and a number `k`. Your task is to implement a function that finds the maximum elements of each sub-array (or sliding window) of length `k`. Function Signature ```python def max_sliding_window(arr: List[int], k: int) -> List[int]: ``` Input - `arr`: A list of integers representing the array. (1 ≤ len(arr) ≤ 10^5) - `k`: An integer representing the size of the sub-array (window). (1 ≤ k ≤ len(arr)) Output - Returns a list of integers representing the maximum value of each sub-array of length `k`. Constraints - The input array can contain both positive and negative integers. - Window size `k` will always be a valid size less than or equal to the length of the array. Scenario Imagine you are managing a dashboard that displays the maximum stock price in real-time over a rolling window of past `k` days. Implement this function so that data streaming into your system can be processed and queried for maximum values fast. Requirements 1. Your implementation must use a deque to ensure the sliding window operation is efficient. 2. Optimize for both time and space complexity as much as possible. 3. Handle edge cases where the array has fewer elements than the window size effectively. 4. Ensure accurate handling of array indices to avoid errors. Example ```python print(max_sliding_window([1,3,-1,-3,5,3,6,7], 3)) # Output: [3, 3, 5, 5, 6, 7] print(max_sliding_window([9,11,8,5,7,10], 2)) # Output: [11, 11, 8, 7, 10] print(max_sliding_window([1,-1], 1)) # Output: [1, -1] ``` Additional Notes - This is a classical problem suited for understanding and evaluating the efficient use of data structures to maintain real-time computations over a sliding window. Complete the function `max_sliding_window` based on the given signature and ensure it adheres to the provided constraints and requirements.","solution":"from collections import deque from typing import List def max_sliding_window(arr: List[int], k: int) -> List[int]: Finds the maximum element in each sub-array (or sliding window) of size k. if not arr or k == 0: return [] deq = deque() result = [] for i in range(len(arr)): # Remove elements not part of the window if deq and deq[0] == i - k: deq.popleft() # Remove elements smaller than the current element from the deque while deq and arr[deq[-1]] < arr[i]: deq.pop() deq.append(i) # Append the current max to the result list if i >= k - 1: result.append(arr[deq[0]]) return result"},{"question":"# Merging k Sorted Linked Lists Imagine you work for a company that logs errors from multiple servers. Each server sends logs in a sorted order based on the time the errors occurred. Your task is to merge these logs into a single sorted list. Function Signature: ```python def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: ``` Input: * `lists` - A list of k linked lists, each linked list is sorted in ascending order. Output: * A single sorted linked list that merges all the k input linked lists. Constraints: 1. The total number of elements across all the linked lists will not exceed 10^6. 2. Each linked list will have at most 10^5 elements. 3. The linked lists will only contain integer values. Requirements: * Ensure your function handles edge cases gracefully (e.g., one or more lists being empty). * Aim for an efficient solution: aim for O(n log k) time complexity and O(k) space complexity. Example: ```python # Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None # Example usage def print_list(node): while node: print(node.val, end=\\" -> \\") node = node.next print(\\"None\\") # Merging example lists a = ListNode(1) a.next = ListNode(4) a.next.next = ListNode(5) b = ListNode(1) b.next = ListNode(3) b.next.next = ListNode(4) c = ListNode(2) c.next = ListNode(6) lists = [a, b, c] result = merge_k_lists(lists) print_list(result) # Output should be 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 -> None ``` Tips: * You may utilize Python\'s `heapq` module to manage the heap (priority queue) effectively. * Pay attention to memory usage, especially if some lists are much longer than others. Now, implement the function `merge_k_lists` based on the provided specification.","solution":"from typing import List, Optional import heapq # Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: Merge k sorted linked lists and return it as one sorted list. :param lists: List[Optional[ListNode]] - A list of k sorted linked lists :return: Optional[ListNode] - A single merged sorted linked list if not lists or all(lst is None for lst in lists): return None min_heap = [] # Initialize the heap with the head nodes of each list for i, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, i, node)) dummy = ListNode(0) current = dummy while min_heap: val, idx, node = heapq.heappop(min_heap) current.next = node current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, idx, node.next)) return dummy.next"},{"question":"# Question You are given an array of integers and two optional boundaries, min_lim and max_lim. Your task is to implement a function that filters out values from the array which do not fall within these boundaries (inclusive). If min_lim or max_lim is not provided, treat them as unbounded in the respective direction. Function Signature ```python def limit_array(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: pass ``` Input - `arr`: A list of integers (1 <= len(arr) <= 10^6). - `min_lim`: Optional; an integer representing the lower boundary. - `max_lim`: Optional; an integer representing the upper boundary. Output - Returns a list of integers that fall within the specified boundaries. Constraints - If `min_lim` is None, treat it as no lower bound. - If `max_lim` is None, treat it as no upper bound. - The function should maintain O(n) time complexity and handle large input sizes efficiently. Examples ```python assert limit_array([1, 2, 3, 4, 5], 2, 4) == [2, 3, 4] assert limit_array([10, 20, 30, 40, 50], None, 30) == [10, 20, 30] assert limit_array([5, 15, 25, 35, 45], 20, None) == [25, 35, 45] assert limit_array([100, 200, 300, 400, 500], 250, 450) == [300, 400] assert limit_array([50, 40, 30, 20, 10], None, None) == [50, 40, 30, 20, 10] ``` Notes - You need to handle edge cases such as an empty array, and when min_lim is greater than max_lim. - Ensure the function is robust to handle large lists efficiently.","solution":"from typing import List, Optional def limit_array(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: Returns a list of integers that fall within the specified boundaries. If min_lim or max_lim is None, it treats them as unbounded. if min_lim is None: min_lim = float(\'-inf\') if max_lim is None: max_lim = float(\'inf\') return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Question: You are given the task to enhance the existing pathfinding algorithms to handle weighted graphs efficiently. Implement a function `find_weighted_shortest_path(graph, start, end)` using Dijkstra\'s algorithm. This function should find the shortest path between two nodes in a graph where each edge has a weight. Input: * `graph`: A dictionary where keys are node identifiers and values are lists of tuples (neighbor, weight) representing an edge and its weight. * `start`: The starting node for the path. * `end`: The destination node for the path. Output: * A list of nodes representing the shortest path from `start` to `end`. * Return `None` if no path exists. Constraints: * Weights are non-negative. * Nodes are represented by unique integer or string identifiers. Example: ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } start = \'A\' end = \'D\' # Expected output: [\'A\', \'B\', \'C\', \'D\'] print(find_weighted_shortest_path(graph, start, end)) ``` # Code: ```python import heapq def find_weighted_shortest_path(graph, start, end): Find the shortest path in a weighted graph using Dijkstra\'s algorithm. # Priority queue to store (cost, node, path) pq = [(0, start, [])] visited = set() while pq: cost, node, path = heapq.heappop(pq) if node in visited: continue path = path + [node] visited.add(node) if node == end: return path for neighbor, weight in graph.get(node, []): if neighbor not in visited: heapq.heappush(pq, (cost + weight, neighbor, path)) return None # Example usage: graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } start = \'A\' end = \'D\' print(find_weighted_shortest_path(graph, start, end)) # Output: [\'A\', \'B\', \'C\', \'D\'] ```","solution":"import heapq def find_weighted_shortest_path(graph, start, end): Find the shortest path in a weighted graph using Dijkstra\'s algorithm. # Priority queue to store (cost, node, path) pq = [(0, start, [])] visited = set() while pq: cost, node, path = heapq.heappop(pq) if node in visited: continue path = path + [node] visited.add(node) if node == end: return path for neighbor, weight in graph.get(node, []): if neighbor not in visited: heapq.heappush(pq, (cost + weight, neighbor, path)) return None # Example usage: graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } start = \'A\' end = \'D\' print(find_weighted_shortest_path(graph, start, end)) # Output: [\'A\', \'B\', \'C\', \'D\']"},{"question":"# KMP Algorithm: Detect Substring Occurrences Objective Implement and optimize the KMP algorithm to search for all occurrences of a pattern within a given text. Your implementation should be efficient and correctly handle various edge cases. Function Signature ```python def knuth_morris_pratt(text: str, pattern: str) -> List[int]: Given two strings \'text\' and \'pattern\', return a list of starting indices in \'text\' where \'pattern\' is found. Args: text : str : the text to search within pattern : str : the pattern to search for within the text Returns: List[int] : list of starting indices of \'pattern\' in \'text\' Constraints: - The length of \'text\' (N) ranges from 0 to 10^5. - The length of \'pattern\' (M) ranges from 0 to 10^4. - Strings \'text\' and \'pattern\' contain only lowercase English letters. Example: >>> knuth_morris_pratt(\'hello there hero!\', \'he\') [0, 7, 12] >>> knuth_morris_pratt(\'abcabcabcabc\', \'abc\') [0, 3, 6, 9] >>> knuth_morris_pratt(\'aaaaa\', \'aa\') [0, 1, 2, 3] >>> knuth_morris_pratt(\'abcd\', \'\') [] pass ``` Problem Statement - Implement the KMP algorithm to find and return all starting indices of the pattern in the given text. - Create the partial match table (pi table) for the pattern to use during the search. - Ensure that the function handles edge cases gracefully, such as when the pattern or text is empty, or when no matches are found. - Optimize the function such that it operates within the time complexity of O(N+M). Requirements - The function must be implemented from scratch without using built-in search functions. - Adequate documentation within the code is required to explain key steps. - Ensure that the function runs efficiently within the provided constraints.","solution":"from typing import List def build_pi_table(pattern: str) -> List[int]: Builds the partial match (pi) table for KMP algorithm. m = len(pattern) pi = [0] * m j = 0 for i in range(1, m): while j > 0 and pattern[i] != pattern[j]: j = pi[j - 1] if pattern[i] == pattern[j]: j += 1 pi[i] = j else: pi[i] = 0 return pi def knuth_morris_pratt(text: str, pattern: str) -> List[int]: Given two strings \'text\' and \'pattern\', return a list of starting indices in \'text\' where \'pattern\' is found. n = len(text) m = len(pattern) if m == 0 or n == 0 or m > n: return [] pi = build_pi_table(pattern) indices = [] j = 0 for i in range(n): while j > 0 and text[i] != pattern[j]: j = pi[j - 1] if text[i] == pattern[j]: if j == m - 1: indices.append(i - m + 1) j = pi[j] else: j += 1 return indices"},{"question":"# Exchange Sort Optimization Task You are tasked with optimizing a sorting algorithm for better performance on larger datasets. Your task is to implement an enhanced version of the exchange sort algorithm by reducing the number of unnecessary comparisons and swaps. Specifically, implement the Bubble Sort algorithm which performs similarly but more efficiently by moving the largest unsorted element to its correct position in each pass. Function Signature ```python def bubble_sort(arr: List[int]) -> List[int]: Sorts the input list using the optimized Bubble Sort algorithm. Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: The sorted list. ``` Input - A list of integers `arr` where `0 <= len(arr) <= 1000` and `-10^5 <= arr[i] <= 10^5`. Output - A sorted list of integers in ascending order. Constraints - Optimize for better performance than the provided `exchange_sort`. - Consider edge cases such as an empty list or a single-element list. - The sort should be in-place, modifying the input list directly without needing additional storage space. Performance Requirements - The implemented solution should aim for O(n^2) time complexity in the worst case but should reduce unnecessary operations compared to `exchange_sort`. Example ```python assert bubble_sort([]) == [] assert bubble_sort([1]) == [1] assert bubble_sort([3, 2, 1]) == [1, 2, 3] assert bubble_sort([5, -2, 4, 8, 7, -5]) == [-5, -2, 4, 5, 7, 8] ``` Scenario You are working as a software engineer, and you need to implement a more efficient version of a simple sorting algorithm for a small embedded system with limited resources. Your main objective is to reduce unnecessary operations to ensure the sorting is as fast as possible on this constrained device. Good luck and happy coding!","solution":"from typing import List def bubble_sort(arr: List[int]) -> List[int]: Sorts the input list using the optimized Bubble Sort algorithm. Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: The sorted list. n = len(arr) for i in range(n): swapped = False for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if not swapped: break return arr"},{"question":"Enhanced Anagram Checker You are tasked with designing a function to check if two given strings are anagrams of each other. Unlike the basic implementation, your function should be case-insensitive and handle a broader range of characters, including Unicode characters. Input - Two strings `s1` and `s2`. Output - Return a boolean value `True` if the strings are anagrams, `False` otherwise. Constraints - The strings can contain any Unicode characters. - The comparison should be case-insensitive. Performance Requirements - Aim for a time complexity of O(n), where n is the length of the strings. - The solution should handle very large strings efficiently. Example: ```python assert are_anagrams(\\"apple\\", \\"pElpa\\") == True assert are_anagrams(\\"apple\\", \\"cherry\\") == False assert are_anagrams(\\"rat\\", \\"car\\") == False assert are_anagrams(\\"Déjà vu\\", \\"vu déjà\\") == True ``` Implementation Challenge: - Consider edge cases such as strings with spaces and different capitalizations. - Optimize the space usage while ensuring that wide character ranges are supported.","solution":"def are_anagrams(s1, s2): Check if two strings are anagrams, considering case insensitivity and Unicode characters. # Normalize the strings by converting to lower case and sorting the characters s1_normalized = sorted(s1.lower()) s2_normalized = sorted(s2.lower()) return s1_normalized == s2_normalized"},{"question":"# Question: Optimized Prime Finder Given a positive integer n, write a function `get_primes_less_than(n)` that returns a list containing all prime numbers less than n. Your function should use a modified version of the Sieve of Eratosthenes algorithm that excludes all even numbers to optimize space and time. Specifically, the function should directly mark 2 as prime and then consider only odd numbers as potential primes. Function Signature ```python def get_primes_less_than(n: int) -> List[int]: ``` Input - A single integer `n` (1 <= n <= 10^6) Output - A list of integers, where each integer is a prime number less than `n`. The output list should be sorted in ascending order. # Constraints - You must optimize both time and space complexity by excluding even numbers and only considering odd candidates for primes after marking 2 as prime. - The function should validate that the input is a positive integer and raise a ValueError if it\'s not. Example Usage ```python print(get_primes_less_than(10)) # Expected output: [2, 3, 5, 7] print(get_primes_less_than(20)) # Expected output: [2, 3, 5, 7, 11, 13, 17, 19] print(get_primes_less_than(2)) # Expected output: [] ``` Points to Consider - Ensure that your implementation efficiently handles large values of `n` up to 10^6. - Think about how skipping even numbers impacts the sieve array and indexing. Performance Requirements - Aim for O(n log log n) time complexity. - Aim for O(n/2) space complexity, excluding the output list. Error Handling - If `n` is not a positive integer, the function should raise a `ValueError` with the message: \\"\'n\' must be a positive integer.\\" Write your implementation of the function `get_primes_less_than(n)` below:","solution":"from typing import List def get_primes_less_than(n: int) -> List[int]: if not isinstance(n, int) or n <= 0: raise ValueError(\\"\'n\' must be a positive integer.\\") if n <= 2: return [] sieve = [True] * (n // 2) sieve[0] = False # 1 is not a prime number for i in range(1, int(n**0.5)//2 + 1): if sieve[i]: prime = 2 * i + 1 for j in range(prime * prime // 2, n // 2, prime): sieve[j] = False primes = [2] + [2 * i + 1 for i in range(1, n // 2) if sieve[i]] return primes"},{"question":"# Graph Cloning Challenge You have been provided with a class for an undirected graph node and three approaches to clone an undirected graph using BFS and DFS. Your task is to implement a new function, `verify_clone(original, clone)`, which verifies if two graph instances are identical clones. Function Signature ```python def verify_clone(original: UndirectedGraphNode, clone: UndirectedGraphNode) -> bool: ``` Input Format - Two inputs, `original` and `clone`, which are instances of `UndirectedGraphNode`. Output Format - Return a boolean value: - `True` if all nodes and their connections in `clone` accurately replicate the structure and labels of `original`. - `False` otherwise. Constraints - Both `original` and `clone` graphs are well-formed. - The number of nodes in the graph is no more than 1000. - Each node\'s label is a unique integer. # Requirements 1. Traverse through both the original and cloned graphs. 2. Ensure each node and its neighbors in the clone match precisely to those in the original graph. 3. Handle cyclic graphs and self-loops appropriately. 4. Check for the absence of extraneous nodes or connections in the clone. Examples Example 1: ``` Input: Original graph: 1 / / 0 --- 2 / _/ Clone graph: 1 / / 0 --- 2 / _/ Output: True ``` Example 2: ``` Input: Original graph: 1 / / 0 --- 2 / _/ Clone graph with extra node: 1 / / 0 --- 2 --- 3 / _/ Output: False ```","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def verify_clone(original: UndirectedGraphNode, clone: UndirectedGraphNode) -> bool: def BFS(node): visited = {} queue = [node] visited[node.label] = node while queue: current = queue.pop(0) for neighbor in current.neighbors: if neighbor.label not in visited: visited[neighbor.label] = neighbor queue.append(neighbor) return visited original_visited = BFS(original) clone_visited = BFS(clone) if len(original_visited) != len(clone_visited): return False for label in original_visited: if label not in clone_visited: return False original_node = original_visited[label] clone_node = clone_visited[label] if original_node.label != clone_node.label: return False original_neighbors = sorted([neighbor.label for neighbor in original_node.neighbors]) clone_neighbors = sorted([neighbor.label for neighbor in clone_node.neighbors]) if original_neighbors != clone_neighbors: return False return True"},{"question":"Context: You are tasked with developing an algorithm that finds all unique combinations of factors (each greater than 1) that multiply together to give a specific number `n`. This problem is essential in number theory and has applications in cryptography and other advanced fields. Problem Statement: Write a Python function `factor_combinations(n: int) -> List[List[int]]` that returns all possible combinations of its factors. Input: * An integer `n` such that `1 <= n <= 10^8`. Output: * A list of lists, where each list contains a combination of factors that multiply together to give `n`. * Each factor in the list must be greater than 1 and less than `n`. Constraints: 1. The input number `n` is always guaranteed to be positive. Example: ```python assert factor_combinations(1) == [] assert factor_combinations(37) == [] assert factor_combinations(12) == [ [2, 6], [2, 2, 3], [3, 4] ] assert factor_combinations(32) == [ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8] ] ``` Implementation Requirements: 1. Implement the function using both iterative and recursive approaches. 2. The solution must handle edge cases efficiently. 3. Ensure that the time complexity does not exceed O(n^log(n)). Additional Notes: * Think about the optimization strategies mentioned in the analysis for better performance. * Handle edge cases such as numbers with minimal factors gracefully. ```python def factor_combinations(n: int) -> List[List[int]]: # Your iterative implementation here. pass def recursive_factor_combinations(n: int) -> List[List[int]]: # Your recursive implementation here. pass ```","solution":"from typing import List def factor_combinations(n: int) -> List[List[int]]: def dfs(start, target, path, result): while start * start <= target: if target % start == 0: result.append(path + [start, target // start]) dfs(start, target // start, path + [start], result) start += 1 result = [] dfs(2, n, [], result) return result def recursive_factor_combinations(n: int) -> List[List[int]]: def helper(target): res = [] for i in range(2, int(target**0.5) + 1): if target % i == 0: sublist = helper(target // i) res.append([i, target // i]) for sub in sublist: if i <= sub[0]: res.append([i] + sub) return res if n <= 1: return [] return helper(n)"},{"question":"# Cycle Sort Implementation Question **Scenario**: You work as a software developer at a company dealing with embedded systems where the number of write cycles to the memory is restricted. Your task is to implement a Cycle Sort algorithm to minimize the number of write operations. **Task**: Implement the `cycle_sort` function that sorts an array of integers using Cycle Sort. **Function Signature**: ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` **Input**: - `arr`: A list of integers. (1 ≤ length of the list ≤ 10^4, -10^9 ≤ integer in the list ≤ 10^9) **Output**: - Returns a sorted list of integers. **Constraints**: - The algorithm should perform in-place sorting (i.e., use only O(1) extra space). - Minimize the number of write operations. - Handle negative numbers and duplicates efficiently. **Performance Requirements**: - Aim for optimal number of write operations. - Ensure the solution works efficiently for various edge cases, including arrays with duplicates and already sorted arrays. **Examples**: ```python assert cycle_sort([3, 1, 2, 4, 3]) == [1, 2, 3, 3, 4] assert cycle_sort([5, -1, 3, 2]) == [-1, 2, 3, 5] assert cycle_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] ``` Describe your approach and thought process. Clearly outline any edge cases you considered and how you handled them. Ensure your solution is efficient and well-documented.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: Sorts an array using Cycle Sort to minimize the number of write operations. n = len(arr) # Traverse the array and place each element to its correct position for start in range(n - 1): item = arr[start] # Find the position where we put the element pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == start: continue # Otherwise place the item where it needs to be while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != start: pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Linked List Duplicate Removal In this problem, you will implement a function to remove duplicates from an unsorted linked list. You must use a linked list where each node points to the next node. The provided code contains two implementations of removing duplicates, one using an additional data structure (a hash set) and another using two nested loops. Your task is to write a function that removes duplicates from a singly linked list without using any additional data structures. The function signature is: ```python def remove_duplicates_without_extra_space(head: Node) -> None: pass ``` # Input - A singly linked list `head` where `head` is the first node of the list. - Each `Node` object has an attribute `val` representing its value and `next` pointing to the following node. # Output - Your function should modify the linked list in place, removing all duplicate values. - It should not return anything. # Constraints - Do not use any external data structures like sets or dictionaries. - Time complexity should be considered and should not exceed acceptable limits for nested iterations within linked lists. # Example Consider the linked list: `A -> A -> B -> C -> D -> C -> F -> G` After calling `remove_duplicates_without_extra_space(head)`, the linked list should be modified to: `A -> B -> C -> D -> F -> G` # Edge Cases - If the list is empty, the function should handle it without errors. - If there are no duplicates, the list should remain unchanged post-function execution.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates_without_extra_space(head: Node) -> None: current = head while current is not None: runner = current while runner.next is not None: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm**: Isomorphic Strings Check * **Type**: String manipulation / Mapping * **Main Purpose**: Determine if two strings are isomorphic, meaning that there is a one-to-one character mapping from one string to the other. Complexity * **Time Complexity**: O(n), where n is the length of the strings. The algorithm iterates once through both strings. * **Space Complexity**: O(n) for storing the character mappings and sets. Principles * The algorithm iteratively checks each character pair (from corresponding positions in the two input strings) and maintains a mapping from characters in the first string to characters in the second string. * It ensures that no two characters from the first string map to the same character in the second string. * The mapping and a set of already mapped characters are updated as the algorithm progresses through the strings. Characteristics & Applications * **Properties**: It preserves character order and uniqueness in mapping directly, ensuring the one-to-one relationship is maintained. * **Common Use Cases**: Commonly used in problems involving pattern recognition, data encoding, and language translation where maintaining consistent transformation rules is vital. * **Strengths/Limitations**: * **Strengths**: Simple and efficient due to linear time complexity. * **Limitations**: Only supports standard character mappings, may need modifications for more complex transformations. Implementation Challenges * **Edge Cases**: * Strings of different lengths directly result in a false output. * Characters that appear in one string but not in a consistently mapped position in the other string. * Cases where multiple characters would try to map to the same character. * **Performance Bottlenecks**: Mainly involves dictionary and set operations which are efficient, so only very large strings might challenge usual performance. * **Error Scenarios**: Incorrect results if mappings or sets are not correctly maintained. * **Optimization Points**: Algorithm is quite optimized; slight improvements may be made through more efficient character lookups. <|Analysis End|> <|Question Begin|> # Isomorphic Strings Challenge Given two strings `s` and `t`, determine if they are isomorphic. Two strings are isomorphic if the characters in `s` can be replaced to get `t`. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. # Input * Two strings `s` and `t` (1 ≤ |s|, |t| ≤ 10^4). Both strings are of equal length and contain only lowercase ASCII characters. # Output * Return `True` if `s` and `t` are isomorphic, and `False` otherwise. # Constraints * Both strings will always be of the same length. # Example ```python # Example1: # Input: s = \\"egg\\", t = \\"add\\" # Output: True # Example 2: # Input: s = \\"foo\\", t = \\"bar\\" # Output: False # Example 3: # Input: s = \\"paper\\", t = \\"title\\" # Output: True ``` # Implementation Implement the function `is_isomorphic(s: str, t: str) -> bool` that follows the given specifications: ```python def is_isomorphic(s, t): :type s: str :type t: str :rtype: bool if len(s) != len(t): return False mapping_s_to_t = {} mapped_characters_in_t = set() for char_s, char_t in zip(s, t): if char_s not in mapping_s_to_t: if char_t in mapped_characters_in_t: return False mapping_s_to_t[char_s] = char_t mapped_characters_in_t.add(char_t) elif mapping_s_to_t[char_s] != char_t: return False return True ``` Your task is to verify the correctness of this function through comprehensive test cases, considering edge cases and performance bounds.","solution":"def is_isomorphic(s, t): Determines if two strings s and t are isomorphic. :param s: First string :param t: Second string :return: True if s and t are isomorphic, otherwise False if len(s) != len(t): return False mapping_s_to_t = {} mapped_characters_in_t = set() for char_s, char_t in zip(s, t): if char_s not in mapping_s_to_t: if char_t in mapped_characters_in_t: return False mapping_s_to_t[char_s] = char_t mapped_characters_in_t.add(char_t) elif mapping_s_to_t[char_s] != char_t: return False return True"},{"question":"# Combination Computation Challenge In combinatorial mathematics, calculating the number of ways to choose `r` items from `n` items (denoted as `nCr`) is a fundamental problem. You are required to implement this computation efficiently. Task Implement a function that calculates `nCr` using memoization to ensure efficient computation even for larger values of `n`. Function Signature ```python def combination(n: int, r: int) -> int: pass ``` Input - Two integers, `n` and `r` where: - `0 <= r <= n <= 1000` Output - An integer indicating the number of ways to choose `r` items from `n` items. Constraints - You must use memoization to optimize the recursive calculation. - Ensure your solution handles the edge cases efficiently. Example ```python assert combination(5, 2) == 10 assert combination(6, 0) == 1 assert combination(6, 6) == 1 assert combination(6, 3) == 20 ``` Explanation - `combination(5, 2)` should return `10`. There are 10 ways to choose 2 items from a set of 5. - `combination(6, 0)` should return `1`. There is exactly 1 way to choose 0 items from a set of 6 (by choosing none). - `combination(6, 6)` should return `1`. There is exactly 1 way to choose all 6 items from a set of 6. - `combination(6, 3)` should return `20`. There are 20 ways to choose 3 items from a set of 6.","solution":"def combination(n: int, r: int) -> int: Calculate the number of ways to choose r items from n items using memoization. # Memoization storage memo = {} def nCr(n, r): # Base cases if r == 0 or r == n: return 1 if r == 1: return n # Check if value is already computed if (n, r) in memo: return memo[(n, r)] # Recursive calculation with memoization result = nCr(n - 1, r - 1) + nCr(n - 1, r) memo[(n, r)] = result return result return nCr(n, r)"},{"question":"You are assigned the task of sorting a list of integers using a combination of sorting techniques. The initial sorting will use Comb Sort, particularly effective for large lists, and conclude with an efficient fine-tuning step for the final pass of smaller gaps. **Function Signature** ```python def hybrid_comb_sort(arr: List[int]) -> List[int]: ``` # Input * `arr` (List[int]): An unsorted list of integers. The length of the list can be up to 10^5. # Output * The function should return a new list of integers sorted in non-decreasing order. # Constraints * The input list can have up to 100,000 integers. * The values in the input list will range from -10^6 to 10^6. # Performance Requirements * Your solution should aim to be more efficient than O(n^2) for average and worst cases. * Utilize the concept of Comb Sort and optimize with an additional sort for the final pass to achieve the optimal performance. # Example ```python # Example input input_list = [8, 4, 1, -3, 9, 6, 10, 3] # Example output output = [-3, 1, 3, 4, 6, 8, 9, 10] ``` # Detailed Prompt 1. Implement the `hybrid_comb_sort` function that initially uses Comb Sort to reorder elements with shrinking gaps. 2. After gap has reached 1 and a final comb pass is conducted, switch to another efficient sorting technique (e.g., insertion sort) for the small number of remaining unordered elements. # Instructions - Do not use built-in sorting functions such as `sort()` or `sorted()`. - Ensure your implementation is efficient and works within the problem constraints. - Consider edge cases such as empty list, single element list, all elements being the same, and already sorted lists.","solution":"from typing import List def hybrid_comb_sort(arr: List[int]) -> List[int]: Performs a hybrid sort combining Comb Sort with another efficient sorting technique for the final tuning phase. def comb_sort(input_list: List[int]) -> None: gap = len(input_list) shrink_factor = 1.3 sorted = False while gap > 1 or not sorted: # Update the gap value for next comb gap = int(gap // shrink_factor) if gap < 1: gap = 1 sorted = True i = 0 while i + gap < len(input_list): if input_list[i] > input_list[i + gap]: # Swap the elements input_list[i], input_list[i + gap] = input_list[i + gap], input_list[i] sorted = False i += 1 def insertion_sort(input_list: List[int]) -> None: for i in range(1, len(input_list)): key = input_list[i] j = i - 1 while j >= 0 and key < input_list[j]: input_list[j + 1] = input_list[j] j -= 1 input_list[j + 1] = key # Perform the comb sort comb_sort(arr) # Fine-tune using insertion sort insertion_sort(arr) return arr"},{"question":"You are required to write a function that generates all strobogrammatic numbers of a specified length and returns them in ascending lexicographic order. # Task: Implement the function `find_strobogrammatic_numbers(n)` which generates an array of all strobogrammatic numbers of length `n` in ascending order. # Constraints: 1. The number `1 <= n <= 10`, ensuring practical operation within given bounds. 2. Return the results as a list of strings, e.g., for `n = 2` -> `[\\"11\\", \\"69\\", \\"88\\", \\"96\\"]`. # Input: - An integer `n` representing the length of the strobogrammatic numbers to generate. # Output: - A list of strobogrammatic number strings of length `n`, sorted in lexicographic order. # Example: ```python def find_strobogrammatic_numbers(n): # Implement your solution here pass # Example usage: n = 2 output = find_strobogrammatic_numbers(n) print(output) # should return [\'11\', \'69\', \'88\', \'96\'] ``` **Note**: - Numerical comparison for strings and order of lexicographic sorting should inherently follow Python\'s built-in `sort()` function for lists. (Remember to handle edge cases like empty or exceedingly large values gracefully internally.)","solution":"def find_strobogrammatic_numbers(n): pairs = [(\'0\', \'0\'), (\'1\', \'1\'), (\'6\', \'9\'), (\'8\', \'8\'), (\'9\', \'6\')] def recurse(n, total_length): if n == 0: return [\\"\\"] # Base case for even length if n == 1: return [\\"0\\", \\"1\\", \\"8\\"] # Base case for odd length middles = recurse(n - 2, total_length) results = [] for middle in middles: for a, b in pairs: # To prevent adding numbers with leading zero, skip them if n != total_length or a != \'0\': results.append(a + middle + b) return results return sorted(recurse(n, n))"},{"question":"# License Key Formatting You are given a string `S` which represents a software license key and an integer `K`. The string `S` consists of alphanumeric characters and dashes. The dashes split the alphanumeric characters into groups. Your task is to reformat the string `S` such that: 1. All dashes are removed. 2. The remaining alphanumeric characters are grouped into groups of size `K`, and groups are separated by dashes. 3. The first group may be shorter than `K` characters, but all other groups should be exactly `K` characters. Write a function `format_license_key(S: str, K: int) -> str` that returns the reformatted license key. **Input:** * S: A string consisting of alphanumeric characters and dashes. * K: An integer such that 1 ≤ K ≤ len(S). **Output:** * A string representing the license key formatted as described. **Examples:** ``` 1. format_license_key(\\"2-5g-3-J\\", 2) -> \\"2-5G-3J\\" 2. format_license_key(\\"2-4A0r7-4k\\", 3) -> \\"24-A0R-74K\\" ``` **Constraints:** * The input string `S` will contain only alphanumeric characters and dashes. * The integer `K` will be a positive integer not greater than the length of the string, not including dashes.","solution":"def format_license_key(S: str, K: int) -> str: Reformats the license key by removing all dashes, converting all characters to uppercase, and grouping the characters into groups of size K, separated by dashes. # Remove all dashes and convert to uppercase cleaned = S.replace(\'-\', \'\').upper() # Initialize a list to hold the parts of the formatted license key parts = [] # Process the cleaned string from end to start to handle the grouping while len(cleaned) > K: parts.append(cleaned[-K:]) cleaned = cleaned[:-K] # Add the remaining part of the cleaned string to the parts list parts.append(cleaned) # Join all the parts with dashes return \'-\'.join(reversed(parts))"},{"question":"**Context**: You are working to enhance a text-processing system that involves repeated patterns detection. One of your tasks is to determine whether a given string ( B ) can be found as a substring within a repeated sequence of another string ( A ). **Problem Statement**: Implement a function `repeat_string(A: str, B: str) -> int` that computes the minimum number of times string ( A ) needs to be repeated so that ( B ) becomes a substring of the repeated string. If ( B ) cannot be a substring of any repeated version of ( A ), return -1. **Function Signature**: ```python def repeat_string(A: str, B: str) -> int: pass ``` **Input**: * `A` (1 ≤ |A| ≤ 10000) - a non-empty string. * `B` (1 ≤ |B| ≤ 10000) - a non-empty string. **Output**: * An integer representing the minimum number of repeats required, or -1 if ( B ) cannot be a substring of repeated ( A ). **Constraints**: * The solution should be optimized within the given input constraints. * Aim for an effective balance between time and space complexity. **Example**: ```python assert(repeat_string(\\"abcd\\", \\"cdabcdab\\") == 3) assert(repeat_string(\\"a\\", \\"aa\\") == 2) assert(repeat_string(\\"abc\\", \\"d\\") == -1) ``` # Guidelines * You should account for edge cases such as ( A ) being already longer than or equal to ( B ), or ( A ) and ( B ) being of equal length. * Avoid unnecessary concatenation and utilize efficient string searching techniques for optimal performance.","solution":"def repeat_string(A: str, B: str) -> int: Determines the minimum number of times string A needs to be repeated so that B becomes a substring of the repeated string. Parameters: A (str): The base string which will be repeated. B (str): The target substring to find within the repeated A. Returns: int: The minimum number of repetitions required or -1 if not possible. # We need to repeat A enough times to cover the length of B repeat_count = -(-len(B) // len(A)) # Equivalent to ceil(len(B) / len(A)) # Check if B is a substring of A repeated (repeat_count) times or (repeat_count + 1) times. for i in range(2): repeated_a = A * (repeat_count + i) if B in repeated_a: return repeat_count + i return -1"},{"question":"# Coding Problem: Radix Sort for Strings **Context**: Consider a scenario where you need to sort a large list of strings consisting of lowercase letters only. String sorting algorithms often face challenges due to variable lengths and the lexicographical order. Leveraging the principles of Radix Sort could be beneficial in this context because it can handle fixed-length inputs efficiently. **Task**: Given a list of strings where each string is exactly `k` characters long, implement the Radix Sort algorithm to sort the strings in lexicographical order. You should handle the string character-wise from the least significant character (rightmost) to the most significant character (leftmost). # Function Signature ```python def radix_sort_strings(arr: List[str], k: int) -> List[str]: pass ``` # Input * `arr` (List[str]): A list of strings to be sorted, all of which are of length `k`. * `k` (int): The fixed length of each string in the list (1 ≤ k ≤ 20). # Output * Returns a list of sorted strings in lexicographical order. # Example ```python input_strings = [\\"bca\\", \\"acb\\", \\"abc\\", \\"cab\\", \\"bac\\"] k = 3 print(radix_sort_strings(input_strings, k)) # Expected Output: [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\'] ``` # Constraints - All strings contain only lowercase English letters (\'a\' to \'z\'). - The list size `n` is at most 10^6. - The length of each string `k` will be the same and not exceed 20. # Requirements - Your solution should be efficient in terms of time and space complexity, keeping in mind the constraints. - Focus on stable sorting to preserve relative order for duplicate strings.","solution":"from typing import List def counting_sort(arr: List[str], index: int) -> List[str]: A helper function for radix_sort_strings to perform a stable counting sort based on characters at a specific index. # Create a count array for 26 lowercase letters count = [0] * 26 output = [\\"\\" for _ in range(len(arr))] # Calculate the count of each character at index for string in arr: count[ord(string[index]) - ord(\'a\')] += 1 # Change count[i] so it contains the position of this character in output for i in range(1, 26): count[i] += count[i - 1] # Build the output array by placing strings in correct position for string in reversed(arr): char_index = ord(string[index]) - ord(\'a\') count[char_index] -= 1 output[count[char_index]] = string return output def radix_sort_strings(arr: List[str], k: int) -> List[str]: Sorts an array of strings using radix sort. # Sort the array based on each character from right to left for index in range(k - 1, -1, -1): arr = counting_sort(arr, index) return arr"},{"question":"**Objective**: Demonstrate understanding of movement-tracking algorithms and effective dictionary use. Scenario: A warehouse robot navigates on a two-dimensional grid. Starting at position (0, 0), it moves according to a sequence of commands. Each command is one character: \'U\' (up), \'D\' (down), \'L\' (left), and \'R\' (right). Your task is to determine if the robot returns to its starting position after executing all the commands. Problem Statement: Write a function `check_robot_circle(moves)` that takes a string `moves` containing a sequence of characters representing movements of a robot. The function returns `True` if the robot returns to the starting position (0, 0) after executing all the moves, and `False` otherwise. Function Signature: ```python def check_robot_circle(moves: str) -> bool: ``` Input: - `moves` (1 ≤ len(moves) ≤ 10^4): A string representing the robot\'s movement sequence consisting of characters \'U\', \'D\', \'L\', \'R\'. Output: - A boolean value: `True` if the robot returns to the origin, `False` otherwise. Constraints: - The string `moves` only contains characters \'U\', \'D\', \'L\', \'R\'. - Handle edge cases like an empty sequence which should result in `True`. Examples: 1. Input: `\\"UD\\"` Output: `True` 2. Input: `\\"LL\\"` Output: `False` Performance Requirements: - The function should run efficiently within the given constraints. Hints: - Consider how you can utilize a dictionary to count movements in each direction. - Think about how the counts in dictionary can be used to determine the result. ```python def check_robot_circle(moves: str) -> bool: ... # Your implementation goes here ```","solution":"def check_robot_circle(moves: str) -> bool: Determines if the robot returns to the starting position after executing all the given moves. # Initialize the position of the robot x, y = 0, 0 # Move the robot according to the commands for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 # Check if the robot is at the starting position return x == 0 and y == 0"},{"question":"You are given two strings, `text` and `word`. Implement a function `find_occurrences(text: str, word: str) -> List[int]` that uses the Rabin-Karp algorithm to find all starting indices of `word`\'s occurrences in `text`. # Function Signature ```python def find_occurrences(text: str, word: str) -> List[int]: ``` # Input * `text` (0 <= len(text) <= 10^6): A string in which we search for the pattern. * `word` (0 <= len(word) <= 10^3): A string pattern to search for in the `text`. # Output * A list of integers containing all starting indices of `word`\'s occurrences in `text`. If `word` is not found in `text`, return an empty list. # Constraints * Consider only lowercase `a-z` letters in the `text` and `word`. # Example ```python # Example 1: text = \\"ababcabcabc\\" word = \\"abc\\" output = find_occurrences(text, word) print(output) # Expected Output: [2, 5, 8] # Example 2: text = \\"aaaa\\" word = \\"aa\\" output = find_occurrences(text, word) print(output) # Expected Output: [0, 1, 2] # Example 3: text = \\"hello world\\" word = \\"ow\\" output = find_occurrences(text, word) print(output) # Expected Output: [] ``` # Explanation: * The function calculates the rolling hash of the current window in the text and compares it with the hash of the word. If the hashes match, it further confirms by directly comparing the substrings due to possible hash collisions. * The result should be all positions where the substring is found.","solution":"from typing import List def find_occurrences(text: str, word: str) -> List[int]: if len(word) == 0 or len(text) == 0 or len(word) > len(text): return [] # Base parameters for Rabin-Karp algorithm base = 256 # number of characters in the input alphabet prime = 101 # A prime number word_len = len(word) text_len = len(text) word_hash = 0 # hash value for pattern text_hash = 0 # hash value for text high_order = 1 # The value of high_order would be \\"pow(base, word_len-1) % prime\\" for i in range(word_len-1): high_order = (high_order * base) % prime # Calculate the hash value of the word and first window of text for i in range(word_len): word_hash = (base * word_hash + ord(word[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime # Slide the pattern over text one by one occurrences = [] for i in range(text_len - word_len + 1): # Check the hash values of current window of text and word if word_hash == text_hash: # If the hash values match then only check for characters one by one if text[i:i+word_len] == word: occurrences.append(i) # Calculate hash value for next window of text: Remove leading digit, add trailing digit if i < text_len - word_len: text_hash = (text_hash - ord(text[i]) * high_order) % prime text_hash = (text_hash * base + ord(text[i + word_len])) % prime text_hash = (text_hash + prime) % prime # We might get negative value of text_hash, converting it to positive return occurrences"},{"question":"# Problem Description You are tasked with implementing the Counting Sort algorithm. Your implementation should handle arrays containing both positive and negative integers. The goal is to sort the input array in non-decreasing order. # Function Signature ```python def counting_sort(arr: List[int]) -> List[int]: ``` # Input * A list of integers `arr` where: * The length of the list is between 1 and `10^6`. * The integers in the list can range from `-10^6` to `10^6`. # Output * A list of integers sorted in non-decreasing order. # Constraints * Aim for a time complexity of O(n + k), where n is the number of elements in the list, and k is the range of the input values. * Use additional space proportional to the range of input values plus the size of the input list. # Example Given the list: ```python [4, -1, 2, -4, 3, -2, 0, 1] ``` Your function should return: ```python [-4, -2, -1, 0, 1, 2, 3, 4] ``` # Notes 1. Make sure to handle both positive and negative numbers. 2. The algorithm should be implemented efficiently to handle large input sizes within a reasonable execution time.","solution":"def counting_sort(arr): if not arr: return [] min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 count_array = [0] * range_of_elements output_array = [0] * len(arr) for num in arr: count_array[num - min_val] += 1 for i in range(1, len(count_array)): count_array[i] += count_array[i - 1] for num in reversed(arr): output_array[count_array[num - min_val] - 1] = num count_array[num - min_val] -= 1 return output_array"},{"question":"# Reversing Words in a String Problem Statement Given a string containing multiple words separated by spaces, write a function `reverse_words_within_bounds` that reverses the order of the words within specified bounds. Detailed Description - Your function should take three arguments: * A string `s` containing words separated by spaces. * Two integers `start` and `end` which specify the boundaries (by word index) within which to reverse the words. - The indices `start` and `end` are zero-based, and the bounds are inclusive. - The function should handle leading and trailing spaces and reduce multiple spaces between words to a single space in the final output. - If `start` or `end` is out of range, or if `end` is less than `start`, the function should return the original string unmodified. Input Format: * The function will accept: * `s`: a string of length 1 ≤ |s| ≤ 10^5. * `start`: an integer where 0 ≤ start ≤ total number of words in `s`. * `end`: an integer where start ≤ end < total number of words in `s`. Output Format: * The function should return the new string with words reversed within the specified bounds. Example: ```python def reverse_words_within_bounds(s, start, end): # Your implementation here # Test case examples: print(reverse_words_within_bounds(\\" the quick brown fox jumps \\", 1, 3)) # Output: \\"the fox brown quick jumps\\" print(reverse_words_within_bounds(\\" hello world \\", 0, 1)) # Output: \\"world hello\\" print(reverse_words_within_bounds(\\"a good example\\", 0, 2)) # Output: \\"example good a\\" ``` *Explanation*: 1. \\" the quick brown fox jumps \\", start = 1, end = 3 * Split: [\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\", \\"jumps\\"] * Reverse: [\\"the\\", \\"fox\\", \\"brown\\", \\"quick\\", \\"jumps\\"] * Join: \\"the fox brown quick jumps\\" 2. \\" hello world \\", start = 0, end = 1 * Split: [\\"hello\\", \\"world\\"] * Reverse: [\\"world\\", \\"hello\\"] * Join: \\"world hello\\" 3. \\"a good example\\", start = 0, end = 2 * Split: [\\"a\\", \\"good\\", \\"example\\"] * Reverse: [\\"example\\", \\"good\\", \\"a\\"] * Join: \\"example good a\\" Note: Handle leading, trailing, and multiple spaces appropriately while joining the words back.","solution":"def reverse_words_within_bounds(s, start, end): words = s.split() # Split the string by spaces into words number_of_words = len(words) if start < 0 or end >= number_of_words or start > end: return s.strip() # Return original string with trimmed spaces if indices are out of range to_reverse = words[start:end+1] words[start:end+1] = to_reverse[::-1] # Reverse the specified slice return \\" \\".join(words) # Join words into a single string separated by a single space"},{"question":"**Context:** You are tasked with implementing a system to manage a sequence of actions in a text editor. The system should support inserting, deleting, and navigating actions efficiently. Given the dynamic nature of text editing operations, using a linked list would be ideal due to its efficient insertions and deletions. # Task Implement a `DoublyLinkedList` class and a `TextEditor` class that uses this data structure to manage actions. The `TextEditor` class should support the following operations: - `insertAction(action)`: Insert an action at the current position. - `deleteAction()`: Delete the current action. - `moveNext()`: Move to the next action. - `movePrev()`: Move to the previous action. - `getCurrentAction()`: Return the current action. # Constraints 1. The list should support dynamic growth. 2. Insertions and deletions should be performed in constant time. 3. Navigations to the next and previous actions should be performed in constant time. # Input/Output - The `insertAction(action)` method takes a string `action` and inserts it at the current position. - The `deleteAction()` method removes the current action if it exists. - The `moveNext()` method moves the pointer to the next action if it exists. - The `movePrev()` method moves the pointer to the previous action if it exists. - The `getCurrentAction()` method returns the current action or `None` if there is no current action. # Example ```python editor = TextEditor() editor.insertAction(\\"Type \'Hello\'\\") editor.insertAction(\\"Type \'World\'\\") print(editor.getCurrentAction()) # Output: \\"Type \'World\'\\" editor.movePrev() print(editor.getCurrentAction()) # Output: \\"Type \'Hello\'\\" editor.deleteAction() print(editor.getCurrentAction()) # Output: \\"Type \'World\'\\" ``` # Note - Handle edge cases such as attempting to delete from an empty list or navigating beyond the list boundaries. Implement the `DoublyLinkedList` and `TextEditor` classes: ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None self.current = None class TextEditor: def __init__(self): self.actions = DoublyLinkedList() def insertAction(self, action: str): # Your implementation here def deleteAction(self): # Your implementation here def moveNext(self): # Your implementation here def movePrev(self): # Your implementation here def getCurrentAction(self) -> str: # Your implementation here ```","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None self.current = None def insert(self, value): new_node = DoublyLinkedListNode(value) if not self.head: self.head = self.tail = new_node elif not self.current: new_node.next = self.head self.head.prev = new_node self.head = new_node else: new_node.next = self.current.next if self.current.next: self.current.next.prev = new_node if self.current == self.tail: self.tail = new_node self.current.next = new_node new_node.prev = self.current self.current = new_node def delete(self): if not self.current: return if self.current == self.head and self.current == self.tail: self.head = self.tail = None elif self.current == self.head: self.head = self.current.next self.head.prev = None elif self.current == self.tail: self.tail = self.current.prev self.tail.next = None else: self.current.prev.next = self.current.next self.current.next.prev = self.current.prev self.current = self.current.next if self.current.next else self.current.prev def move_next(self): if self.current and self.current.next: self.current = self.current.next def move_prev(self): if self.current and self.current.prev: self.current = self.current.prev def get_current(self): if self.current: return self.current.value return None class TextEditor: def __init__(self): self.actions = DoublyLinkedList() def insertAction(self, action: str): self.actions.insert(action) def deleteAction(self): self.actions.delete() def moveNext(self): self.actions.move_next() def movePrev(self): self.actions.move_prev() def getCurrentAction(self) -> str: return self.actions.get_current()"},{"question":"Objective Write a function that calculates the minimum number of delete operations required to make two given words identical. Requirements Implement the following function: ```python def min_delete_operations(word1: str, word2: str) -> int: :type word1: str :type word2: str :rtype: int ``` Constraints * `0 <= len(word1), len(word2) <= 500` Input * `word1` - A non-empty string containing lowercase letters. * `word2` - A non-empty string containing lowercase letters. Output * An integer representing the number of delete operations required to make the two words identical. Example # Example 1 ```python word1 = \\"sea\\" word2 = \\"eat\\" # Output: 2 ``` *Explanation*: You need one step to make \\"sea\\" to \\"ea\\" and another step to make \\"eat\\" to \\"ea\\". # Example 2 ```python word1 = \\"leetcode\\" word2 = \\"etco\\" # Output: 4 ``` *Explanation*: You need to delete characters \'l\', \'e\', \'c\', \'d\' to make both words \\"eto\\". Guidelines * Ensure your solution efficiently handles edge cases and large inputs within the provided constraints. * Aim to maintain both time and space complexity manageable in line with the problem\'s constraints. * Check thoroughly for off-by-one errors while accessing elements in the matrix.","solution":"def min_delete_operations(word1: str, word2: str) -> int: Returns the minimum number of delete operations required to make the two given words identical. :type word1: str :type word2: str :rtype: int m, n = len(word1), len(word2) # dp[i][j] will be the length of the longest common subsequence of word1[0...i-1] and word2[0...j-1] dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Length of the longest common subsequence lcs_length = dp[m][n] # Minimum deletions needed to make the two strings identical return (m + n) - 2 * lcs_length"},{"question":"# Context: You are tasked with extending the implementation of a Red-Black Tree by adding an additional feature that performs a level order traversal, returning the values and color of the nodes. # Problem: Write a function `level_order` in the `RBTree` class which returns the level order traversal of the Red-Black Tree as a list of dictionaries, with each dictionary containing `val` and `color` keys representing the value and color of the node respectively. # Input: - The function does not take any input. # Output: - The function should return a list of dictionaries where each dictionary has two keys: `val` (node value) and `color` (0 for black, 1 for red). # Constraints: - The Red-Black Tree is implemented and can have any number of nodes. - Node values are unique integers in the context of this problem. # Example: Assume the tree after multiple insertion operations is as follows: ``` 11(B) / 2(R) 14(B) / 1(B) 7(B) 15(R) / 5(R) 8(R) / 4(B) ``` The function should output: ``` [{\'val\': 11, \'color\': 0}, {\'val\': 2, \'color\': 1}, {\'val\': 14, \'color\': 0}, {\'val\': 1, \'color\': 0}, {\'val\': 7, \'color\': 0}, {\'val\': 15, \'color\': 1}, {\'val\': 5, \'color\': 1}, {\'val\': 8, \'color\': 1}, {\'val\': 4, \'color\': 0}] ``` # Implementation: Implement your solution by adding the following method to the `RBTree` class. ```python def level_order(self): if not self.root: return [] result = [] queue = [self.root] while queue: current = queue.pop(0) result.append({\'val\': current.val, \'color\': current.color}) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return result ``` **Notes:** 1. Ensure the method gracefully handles an empty tree by returning an empty list. 2. The provided method must perform a level order traversal of the Red-Black tree.","solution":"class Node: def __init__(self, val, color, left=None, right=None): self.val = val self.color = color # 0 for black, 1 for red self.left = left self.right = right class RBTree: def __init__(self): self.root = None def level_order(self): if not self.root: return [] result = [] queue = [self.root] while queue: current = queue.pop(0) result.append({\'val\': current.val, \'color\': current.color}) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return result"},{"question":"Permutations Summing to a Target You are given an array of unique positive integers `nums` and a positive integer `target`. Your task is to write two functions to find the number of possible combinations that add up to the target. Functions to Implement: 1. **combination_sum_topdown(nums: List[int], target: int) -> int** - This function implements a top-down (recursive memoization) approach to solve the problem. 2. **combination_sum_bottom_up(nums: List[int], target: int) -> int** - This function implements a bottom-up (iterative) approach to solve the problem. # Input Format - `nums`: A list of unique positive integers. - `target`: A positive integer. # Output Format - Return the number of possible combinations that add up to the target. # Constraints - All the integers in `nums` and the `target` are positive integers. - Different sequences of the same combination should be counted separately. # Example ```python nums = [1, 2, 3] target = 4 Output: combination_sum_topdown(nums, target) -> 7 combination_sum_bottom_up(nums, target) -> 7 Explanation: The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) Total combinations summing to 4: 7. ``` # Follow-up Question What if negative numbers are allowed in the given array? How does it change the problem? What limitation would need to be added to the question to allow negative numbers?","solution":"from typing import List def combination_sum_topdown(nums: List[int], target: int) -> int: memo = {} def helper(remaining: int) -> int: if remaining in memo: return memo[remaining] if remaining == 0: return 1 if remaining < 0: return 0 result = 0 for num in nums: result += helper(remaining - num) memo[remaining] = result return result return helper(target) def combination_sum_bottom_up(nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target]"},{"question":"You are given an array of integers `lst` and an integer `N`. Write a function `delete_nth` that returns a new array that contains each number in `lst` at most `N` times, while preserving the original order of appearance. # Input Format * `lst`: A list of integers. The list can be empty. * `N`: A non-negative integer representing the maximum number of times each element can appear in the resulting list. # Output Format * Return a new list that adheres to the constraints mentioned above. # Function Signature ```python def delete_nth(lst: List[int], N: int) -> List[int]: ``` # Constraints * The length of `lst` will not exceed (10^6). * (0 le N le 10^6). # Examples 1. ```python delete_nth([1,2,3,1,2,1,2,3], 2) ``` Output: `[1, 2, 3, 1, 2, 3]` 2. ```python delete_nth([1,1,1,1], 2) ``` Output: `[1, 1]` 3. ```python delete_nth([], 3) ``` Output: `[]` # Notes * Ensure the function handles edge cases such as an empty list or (N = 0). * Your implementation should aim for (O(n)) time complexity for efficiency.","solution":"from typing import List def delete_nth(lst: List[int], N: int) -> List[int]: Return a new list that contains each number in lst at most N times, while preserving the original order of appearance. if N == 0: return [] result = [] counts = {} for item in lst: if counts.get(item, 0) < N: result.append(item) counts[item] = counts.get(item, 0) + 1 return result"},{"question":"# Objective: Create a function `find_difference` that identifies the character differing between two strings, where the second string is a shuffled version of the first string with one additional character. Input and Output: - **Input**: - `s` (string): A non-empty string consisting of lowercase letters. - `t` (string): Another string formed by shuffling `s` and adding one additional lowercase letter. - **Output**: A single character (string) that indicates the additional character in `t`. Constraints: 1. The strings `s` and `t` consist of only lowercase English letters. 2. Length of `t` is `len(s) + 1`. Example: 1. **Example 1**: - Input: `s = \\"abcd\\"`, `t = \\"abecd\\"` - Output: `\\"e\\"` - Explanation: `\\"e\\"` is the letter that was added. 2. **Example 2**: - Input: `s = \\"a\\"`, `t = \\"aa\\"` - Output: `\\"a\\"` - Explanation: `\\"a\\"` is the additional letter in `t`. Task: Implement the function `find_difference(s: str, t: str) -> str`: # Function Signature: ```python def find_difference(s: str, t: str) -> str: ``` Scenario: Assume you\'re developing an e-commerce application where users can manipulate their wishlists. Occasionally, after various random additions and deletions by users, you need to identify any single item added to the wishlist from a prior state for data integrity validation. Your task is to verify and identify this single added item efficiently.","solution":"def find_difference(s: str, t: str) -> str: Identify the character differing between two strings where the second string is a shuffled version of the first string with one additional character. Args: s (str): A non-empty string consisting of lowercase letters. t (str): Another string formed by shuffling `s` and adding one additional lowercase letter. Returns: str: The additional character in `t`. char_counts = {} # Count characters in string `s` for char in s: if char in char_counts: char_counts[char] += 1 else: char_counts[char] = 1 # Subtract counts based on string `t` for char in t: if char not in char_counts or char_counts[char] == 0: return char char_counts[char] -= 1"},{"question":"**Context**: You work for a tech company that is developing a predictive text feature for a messaging app. To accurately predict the next word a user will type, you need to model the typing behavior using a Markov chain. You have a record of user behavior which reveals the probabilities of transitioning between words. **Task**: Write a Python function to implement a Markov chain generator. This function should take an initial state and produce the next state based on transition probabilities defined in the chain. Additionally, create a function that produces a finite sequence of states. # Function Signatures: ```python def next_state(chain: dict, current_state: str) -> str: Returns the next state given the current state based on the Markov chain transition probabilities. Parameters: - chain: Dictionary representing the Markov chain. - current_state: String representing the current state. Returns: - String representing the next state. ``` ```python def generate_sequence(chain: dict, initial_state: str, num_steps: int) -> list: Generates a sequence of states from the Markov chain given an initial state and number of iterations. Parameters: - chain: Dictionary representing the Markov chain. - initial_state: String representing the initial state. - num_steps: Integer representing the number of steps to generate the sequence. Returns: - List of strings representing the sequence of states. ``` # Constraints: 1. Transitions probabilities for each state in the chain sum up to 1. 2. The initial state will always be a valid state present in the chain. 3. Function `generate_sequence` must return a list of states with length `num_steps`. # Example: Input: ```python chain = { \'start\': {\'call\': 0.5, \'meet\': 0.5}, \'call\': {\'end\': 1.0}, \'meet\': {\'talk\': 0.8, \'end\': 0.2}, \'talk\': {\'end\': 1.0}, \'end\': {} } initial_state = \'start\' num_steps = 5 ``` Output: ```python [\'call\', \'end\', \'end\', \'end\', \'end\'] # Note: Actual output may vary due to randomness. ``` Explanation: The function `generate_sequence` generates a sequence of states starting from \'start\' and following the probabilities defined in the `chain` for the given number of steps, simulating the typing behavior prediction. # Notes: - Ensure the `generate_sequence` function handles the randomness properly. - State transitions should always adhere to the probability rules defined. - Use `random.seed()` for reproducibility during testing if necessary.","solution":"import random def next_state(chain: dict, current_state: str) -> str: Returns the next state given the current state based on the Markov chain transition probabilities. Parameters: - chain: Dictionary representing the Markov chain. - current_state: String representing the current state. Returns: - String representing the next state. transitions = chain.get(current_state, {}) if not transitions: return current_state next_states = list(transitions.keys()) probabilities = list(transitions.values()) return random.choices(next_states, probabilities)[0] def generate_sequence(chain: dict, initial_state: str, num_steps: int) -> list: Generates a sequence of states from the Markov chain given an initial state and number of iterations. Parameters: - chain: Dictionary representing the Markov chain. - initial_state: String representing the initial state. - num_steps: Integer representing the number of steps to generate the sequence. Returns: - List of strings representing the sequence of states. sequence = [initial_state] current_state = initial_state for _ in range(num_steps - 1): current_state = next_state(chain, current_state) sequence.append(current_state) return sequence"},{"question":"# Programming Problem: Implement an Optimized Bucket Sort Background Bucket sort is a sorting algorithm that distributes elements into several \'buckets\' and then sorts each bucket individually, often using another sorting algorithm. The final sorted array is obtained by concatenating these sorted buckets. This makes it highly efficient for uniformly distributed data. Problem Statement Given an array of integers, implement an optimized bucket sort algorithm. Your implementation should include a function `optimized_bucket_sort` that takes in a list of integers and returns the sorted list. Your task is to refine the given bucket sort algorithm and handle edge cases such as negative numbers efficiently. Constraints 1. Optimize the distribution and sorting phase to handle edge cases like negative values and large ranges. 2. You are allowed to use any sorting algorithm for sorting the individual buckets rather than using insertion sort. 3. Aim to minimize the time complexity while ensuring stable performance across varied datasets. Function Signature ```python def optimized_bucket_sort(arr: List[int]) -> List[int]: pass ``` Input Format - A list `arr` of integers where `1 <= len(arr) <= 10^6` and `-10^6 <= arr[i] <= 10^6`. Output Format - Returns the sorted list of integers. Example ```python # Example 1 input = [4, 1, 3, -1, 0, 2, 10, -19] # Output: [-19, -1, 0, 1, 2, 3, 4, 10] # Example 2 input = [0, 0, 0, 0] # Output: [0, 0, 0, 0] # Example 3 input = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ``` Notes - Ensure that your bucket index calculation logic is correct, especially for handling negative numbers. - Choose an efficient sorting algorithm for sorting individual buckets to handle worst-case scenarios effectively.","solution":"def optimized_bucket_sort(arr): if len(arr) == 0: return arr # Find the maximum and minimum value in the array min_val, max_val = min(arr), max(arr) # Calculate the range and the number of buckets bucket_range = (max_val - min_val) / len(arr) + 1 buckets = [[] for _ in range(len(arr))] # Distribute elements into buckets for num in arr: index = int((num - min_val) / bucket_range) buckets[index].append(num) # Sort each bucket and concatenate the results sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"# Subset Generation Problem Scenario: You are tasked with developing a feature for a combinatorial algorithm library that includes a function for generating all possible subsets of a given set of distinct integers. Problem Statement: Implement the function `generate_subsets(nums)` that takes a list of distinct integers `nums` and returns a set of tuples representing all possible subsets of `nums`. The subsets must be in any order, and duplicate subsets should not be included. Function Signature: ```python def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: pass ``` Input: * `nums`: A list of distinct integers. `0 <= len(nums) <= 15`, and the integers are within the range `-10 <= nums[i] <= 10`. Output: * Returns a set of tuples representing all possible subsets. Examples: ```python # Example 1 nums = [1,2,3] print(generate_subsets(nums)) # Output: {(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)} # Example 2 nums = [] print(generate_subsets(nums)) # Output: {()} # Example 3 nums = [5] print(generate_subsets(nums)) # Output: {(), (5,)} # Example 4 nums = [1, 2, 3, 4] print(generate_subsets(nums)) # Output: {(), (1,), (2,), (3,), (4,), (1, 2), (1, 3), (1, 4), (2, 3), # (2, 4), (3, 4), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4), # (1, 2, 3, 4)} ``` Constraints: * Ensure your solution runs efficiently within the time and space complexity requirements. * Pay attention to corner cases and handle them appropriately. Notes: * The order of elements within each subset tuple does not matter. * The solution should handle edge cases gracefully, returning the correct results.","solution":"from typing import List, Set, Tuple def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: def backtrack(start: int, path: List[int]): result.add(tuple(path)) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() result = set() backtrack(0, []) return result"},{"question":"# Scenario: You are working as a software engineer in a company that manages a large dataset of user information. To efficiently handle user queries based on their ID, you decide to implement a Binary Search Tree (BST). Your task is to write a set of functions to support BST operations, specifically for inserting, searching, and deleting user IDs from the tree. # Question: Implement a class `BinarySearchTree` with the following methods: 1. **`insert(self, val: int) -> None`** - Inserts a value into the BST. - If the value already exists, do not insert it again. 2. **`search(self, val: int) -> bool`** - Returns `True` if the value exists in the BST, `False` otherwise. 3. **`delete(self, val: int) -> None`** - Deletes a value from the BST. - If the value does not exist, do nothing. 4. **`in_order_traversal(self) -> List[int]`** - Returns the values of the BST in in-order traversal order. # Constraints: - Assume all values are unique for simplicity. - All integer inputs are within the range -10^5 to 10^5. - The BST will contain at most 10^4 nodes. # Example: ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) print(bst.search(3)) # Output: True print(bst.search(6)) # Output: False bst.insert(6) bst.delete(7) print(bst.in_order_traversal()) # Output: [3, 5, 6] ``` # Implementation Skeleton: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: # Implement insertion logic here pass def search(self, val: int) -> bool: # Implement search logic here pass def delete(self, val: int) -> None: # Implement deletion logic here pass def in_order_traversal(self) -> List[int]: # Implement in-order traversal logic here pass ```","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: if not self.root: self.root = TreeNode(val) return def _insert(node, val): if val < node.val: if not node.left: node.left = TreeNode(val) else: _insert(node.left, val) elif val > node.val: if not node.right: node.right = TreeNode(val) else: _insert(node.right, val) _insert(self.root, val) def search(self, val: int) -> bool: def _search(node, val): if not node: return False if node.val == val: return True elif val < node.val: return _search(node.left, val) else: return _search(node.right, val) return _search(self.root, val) def delete(self, val: int) -> None: def _delete(node, val): if not node: return node if val < node.val: node.left = _delete(node.left, val) elif val > node.val: node.right = _delete(node.right, val) else: # Node with only one child or no child if not node.left: return node.right elif not node.right: return node.left # Node with two children min_larger_node = self._find_min(node.right) node.val = min_larger_node.val node.right = _delete(node.right, node.val) return node self.root = _delete(self.root, val) def _find_min(self, node): current = node while current.left: current = current.left return current def in_order_traversal(self): result = [] def _in_order_traversal(node): if not node: return _in_order_traversal(node.left) result.append(node.val) _in_order_traversal(node.right) _in_order_traversal(self.root) return result"},{"question":"**Problem Statement**: You are tasked with enhancing a B-Tree implementation by adding a method that finds the k-th smallest element in the B-Tree. **Function Specification**: - Implement a function `kth_smallest(self, k: int) -> int` within the `BTree` class. - This function should return the k-th smallest element in the B-Tree, where k is a 1-based index. - If k is out of bounds, return `None`. **Input**: - An integer `k` where 1 ≤ k ≤ n, and n is the number of elements in the tree. **Output**: - The k-th smallest element in the B-Tree or `None` if k is out of bounds. **Constraints**: - The degree of the B-Tree (t) is a positive integer greater than 1. - The B-Tree will not be empty when the function is invoked. - The elements in the B-Tree are unique. **Performance Requirements**: - The solution should have time complexity O(log n) for search operations as it leverages the properties of the B-Tree. **Example**: ```python btree = BTree(t_val=3) keys = [20, 5, 15, 25, 10, 35, 30] for key in keys: btree.insert_key(key) assert btree.kth_smallest(3) == 15 assert btree.kth_smallest(1) == 5 assert btree.kth_smallest(5) == 25 assert btree.kth_smallest(0) == None ``` **Notes**: - Make sure to handle edge cases, such as when k is out of the range of existing elements. - Use helper methods if necessary for organizing the traversal and counting of the elements.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] def traverse(self): elements = [] for i in range(len(self.keys)): if not self.leaf: elements.extend(self.children[i].traverse()) elements.append(self.keys[i]) if not self.leaf: elements.extend(self.children[len(self.keys)].traverse()) return elements def insert_non_full(self, key): if self.leaf: self.keys.append(key) self.keys.sort() else: i = len(self.keys) - 1 while i >= 0 and key < self.keys[i]: i -= 1 i += 1 if len(self.children[i].keys) == 2 * self.t - 1: self.split_child(i, self.children[i]) if key > self.keys[i]: i += 1 self.children[i].insert_non_full(key) def split_child(self, i, y): t = self.t z = BTreeNode(t, y.leaf) self.children.insert(i + 1, z) self.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t - 1)] y.keys = y.keys[:t - 1] if not y.leaf: z.children = y.children[t:(2 * t)] y.children = y.children[:t] class BTree: def __init__(self, t_val): self.root = BTreeNode(t_val, True) self.t = t_val def insert_key(self, key): root = self.root if len(root.keys) == 2 * self.t - 1: s = BTreeNode(self.t) self.root = s s.children.append(root) s.split_child(0, root) s.insert_non_full(key) else: root.insert_non_full(key) def kth_smallest(self, k): elements = self.root.traverse() if 1 <= k <= len(elements): return elements[k - 1] return None"},{"question":"Dijkstra\'s Algorithm for Sparse Graphs Context You are working as a software engineer for a tech company developing an application that requires efficient route finding in a large road network. The network is modeled as a sparse graph, where most cities (vertices) are directly connected to only a few other cities. To ensure the efficiency of your route-finding feature, you need to improve the existing Dijkstra\'s algorithm to handle large, sparse graphs efficiently. Problem Statement Modify the provided Dijkstra\'s algorithm implementation to handle sparse graphs more efficiently by using a priority queue (min-heap) instead of a 2D array (adjacency matrix). Function Signature ```python def dijkstra(graph, src): Calculate the shortest paths from the source vertex to all other vertices in a weighted, directed graph. Parameters: graph (Dict[int, List[Tuple[int, int]]]): Adjacency list representation of the graph, where key is a vertex and value is a list of tuples representing the connected vertices and edge weights. src (int): The source vertex. Returns: List[int]: The list of shortest path distances from src to each vertex. pass ``` Input * `graph`: Dictionary containing the adjacency list of the graph. Each key is a vertex and its value is a list of tuples, where each tuple contains a connected vertex and the edge weight. * `src`: An integer representing the source vertex. Output * A list of integers where the i-th value represents the shortest distance from the source vertex to the i-th vertex. * If a vertex is not reachable from the source, the corresponding value should be `float(\\"inf\\")`. Constraints * The input graph is guaranteed to be a directed graph with non-negative weights. * The number of vertices (V) will be at most 100,000. * The graph will be sparse, implying that the number of edges (E) will be much less than V^2. Example ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } src = 0 # Expected Output: [0, 3, 1, 4] print(dijkstra(graph, src)) ``` Performance Requirements * The algorithm should run efficiently even for the upper limits of V and E, with time complexity close to O(E log V). Additional Notes * It is crucial to use a priority queue (min-heap) for selecting the minimum distance vertex efficiently. * Consider importing the `heapq` module for the priority queue implementation.","solution":"import heapq def dijkstra(graph, src): Calculate the shortest paths from the source vertex to all other vertices in a weighted, directed graph. Parameters: graph (Dict[int, List[Tuple[int, int]]]): Adjacency list representation of the graph, where key is a vertex and value is a list of tuples representing the connected vertices and edge weights. src (int): The source vertex. Returns: List[int]: The list of shortest path distances from src to each vertex. # The number of vertices is the max key+1 in the dictionary num_vertices = max(graph.keys()) + 1 # Initialize distances as infinity for all vertices except the source distances = [float(\'inf\')] * num_vertices distances[src] = 0 # Priority queue for tracking the minimum distance vertices priority_queue = [(0, src)] # (distance, vertex) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # If the popped vertex distance is greater than the recorded distance, continue if current_distance > distances[current_vertex]: continue for neighbor, weight in graph.get(current_vertex, []): distance = current_distance + weight # If found shorter path to neighbor if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Question You are given a string containing a sentence where words are separated by single spaces. Write a function `reverse_words` that takes in a string and returns a new string with the words in reverse order. Implement the function `reverse_words(s: str) -> str` as per the following specification: Input Format * A single string `s` (0 <= len(s) <= 1000) containing words separated by single spaces. There may be leading or trailing spaces which should be ignored. Output Format * A single string with the order of words reversed. Ensure no leading/trailing spaces in the result. Constraints * The function should handle edge cases such as empty input, single-word inputs, and multiple consecutive spaces between words elegantly. * The implementation should aim for an O(n) time complexity. # Example ```python def reverse_words(s: str) -> str: def reverse(array, i, j): while i < j: array[i], array[j] = array[j], array[i] i += 1 j -= 1 arr = s.strip().split() reverse(arr, 0, len(arr) - 1) return \\" \\".join(arr) # Test cases assert reverse_words(\\"I am keon kim and I like pizza\\") == \\"pizza like I and kim keon am I\\" assert reverse_words(\\" Hello world! \\") == \\"world! Hello\\" assert reverse_words(\\"singleword\\") == \\"singleword\\" assert reverse_words(\\"\\") == \\"\\" assert reverse_words(\\" \\") == \\"\\" print(\\"All test cases passed!\\") ``` You should provide the test cases to validate your function. It is essential to test the function with various edge cases, including inputs with multiple spaces, punctuation marks, or a single word to ensure robustness.","solution":"def reverse_words(s: str) -> str: Takes a string containing a sentence where words are separated by single spaces, and returns a new string with the words in reverse order, ensuring no leading or trailing spaces. # Split the string into words, removing any extra leading or trailing spaces. words = s.strip().split() # Reverse the list of words. reversed_words = words[::-1] # Join the reversed list into a single string separated by spaces. return \' \'.join(reversed_words)"},{"question":"# Unique BST Counter Implement a function `num_trees(n)` that calculates the number of structurally unique binary search trees (BSTs) which can store values 1 to `n`. Your solution must use dynamic programming to accomplish this task. Input - An integer `n` where `0 <= n <= 20`. Output - An integer representing the number of structurally unique BSTs that store values from 1 to `n`. Example ```python num_trees(3) # returns 5 num_trees(4) # returns 14 ``` Constraints - The input `n` will be a non-negative integer and will not exceed 20, ensuring that the algorithm should perform efficiently within this range. Detailed Requirements 1. **Edge Cases**: - The function should handle `n = 0` and return 1 as per the problem definition. - Verify the function works correctly for small values of `n`. 2. **Performance Requirements**: - The solution should be implemented using dynamic programming with a time complexity of O(n^2) and a space complexity of O(n). 3. **Error Handling**: - Your program should assume the input is correctly formatted and within the given constraints. Implement the function `num_trees(n)` following these guidelines to ensure proper functionality and efficiency. ```python def num_trees(n): dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): for j in range(i): dp[i] += dp[j] * dp[i - j - 1] return dp[n] # Example usage: print(num_trees(3)) # should output 5 print(num_trees(4)) # should output 14 ```","solution":"def num_trees(n): Returns the number of structurally unique BSTs that can be formed using numbers from 1 to n. if n == 0: return 1 dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): for j in range(i): dp[i] += dp[j] * dp[i - j - 1] return dp[n]"},{"question":"# Scenario You are given a matrix `mat` of size `m x n` filled with integers. Your task is to re-arrange the numbers in each diagonal of the matrix such that the numbers in each diagonal are sorted in ascending order. # Problem Statement Write a function `sort_diagonally(mat: List[List[int]]) -> List[List[int]]` that takes an `m x n` matrix `mat` and returns a new matrix with each diagonal sorted in ascending order. # Input * `mat`: A 2D list of integers of size `m x n` (1 ≤ m, n ≤ 100). - Each cell contains an integer in the range `-1000` to `1000`. # Output * A 2D list of integers where each diagonal from the top-left to the bottom-right is sorted in ascending order. # Constraints 1. The function should handle matrices with different sizes and values. 2. The diagonals should be processed independently and sorted in ascending order. # Example ```python mat = [ [3, 3, 1, 1], [2, 2, 1, 2], [1, 1, 1, 2] ] sort_diagonally(mat) # Output: # [ # [1, 1, 1, 1], # [1, 2, 2, 2], # [1, 2, 3, 3] # ] ``` # Explanation For the given example: - Diagonal starting at (0,0) with elements [3, 2, 1] is sorted to [1, 2, 3]. - Diagonal starting at (0,1) with elements [3, 1, 2] is sorted to [1, 2, 3], and so on.","solution":"from typing import List from collections import defaultdict def sort_diagonally(mat: List[List[int]]) -> List[List[int]]: This function sorts each diagonal of the matrix in ascending order. # Dictionary to hold the diagonals diagonals = defaultdict(list) # Traverse the matrix to collect all elements of each diagonal for i in range(len(mat)): for j in range(len(mat[0])): diagonals[i - j].append(mat[i][j]) # Sort each diagonal for diagonal in diagonals.values(): diagonal.sort() # Put back the sorted elements into the matrix for i in range(len(mat)): for j in range(len(mat[0])): mat[i][j] = diagonals[i - j].pop(0) return mat"},{"question":"# Scenario You are responsible for optimizing the data transfer efficiency within a company\'s network. Each node within the network has a specific capacity that limits data flow, except for the source and sink nodes, where the goal is to maximize the data transferred from the source to the sink. # Task 1. **Function Implementation**: - Implement a function `find_maximum_flow(graph: List[List[int]]) -> int:` to calculate the maximum data flow from the source node to the sink node using the provided Ford-Fulkerson method with DFS. 2. **Input Format**: - A list of list of integers `graph` representing an adjacency matrix where `graph[i][j]` denotes the capacity of the edge from node `i` to node `j`. - The source node is always `graph[0]` and the sink node is always `graph[n-1]`. 3. **Output Format**: - Return an integer representing the maximum flow possible from the source to the sink. 4. **Constraints**: - All capacities are non-negative integers. - The number of nodes `n`, where `2 <= n <= 100`. - There is always a path from source to sink if the input graph is valid. # Example ```python # Example input graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] # Example output max_flow = find_maximum_flow(graph) print(max_flow) # Output should be 23 ``` # Requirements: 1. Your implementation should efficiently handle the given constraints. 2. Consider edge cases such as disconnected nodes and zero capacity edges. 3. Use appropriate data structures to maintain accessible and modifiable residual capacities. **Further Thought**: Explore how the performance and complexity of the algorithm would change using a different search approach (like BFS) or advanced methods like capacity scaling.","solution":"from typing import List, Tuple def find_maximum_flow(graph: List[List[int]]) -> int: def depth_first_search(rGraph, source, sink, parent): visited = [False] * len(rGraph) stack = [source] # Stack for DFS visited[source] = True while stack: u = stack.pop() for v, capacity in enumerate(rGraph[u]): if not visited[v] and capacity > 0: stack.append(v) visited[v] = True parent[v] = u if v == sink: return True return False source = 0 sink = len(graph) - 1 parent = [-1] * len(graph) max_flow = 0 # Residual graph where residual capacities are added. rGraph = [row[:] for row in graph] while depth_first_search(rGraph, source, sink, parent): path_flow = float(\'Inf\') s = sink # Find the maximum flow through the path found in the residual graph while s != source: path_flow = min(path_flow, rGraph[parent[s]][s]) s = parent[s] # update residual capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] rGraph[u][v] -= path_flow rGraph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Question: Implement a Tree Structure with Advanced Print Function Context: You are working on a software project that involves displaying hierarchical information, such as an organization chart or a nested file directory. For this purpose, you need to design a tree structure in Python and implement a function that prints the tree in a readable format. The tree will store nodes in a dictionary, with lists representing nested elements within each node. Requirements: 1. Implement a class `Tree` that allows adding elements, both as root nodes and as nested sub-elements. 2. Create a method `add_node(self, key, sub_elements)` in the class to add nodes to the tree. Here, `key` is a string, and `sub_elements` is a list that can contain strings and integers. 3. Implement a method `print_tree(self)` that prints the tree in a hierarchical and readable format, similar to the provided code snippet but optimized for efficiency and clarity. 4. Handle edge cases such as empty nodes, mixed data types, and deeply nested structures gracefully in the print function. Constraints: 1. The implementation should optimize dictionary access and minimize nested lookups. 2. The tree\'s size (number of nodes) can be up to 1000, and each list within a node can have up to 100 elements. 3. The print function should produce output in a structured manner, making it easy to read and understand the hierarchy. Function Specification: 1. `add_node(key: str, sub_elements: list) -> None` 2. `print_tree() -> None` Example Usage: ```python # Example structure similar to the provided snippet tree = Tree() tree.add_node(\'a\', [\'Adam\', \'Book\', 4]) tree.add_node(\'b\', [\'Bill\', \'Computer\', 5, \'TV\', 6]) tree.add_node(\'b\', [\'Jill\', \'Sports\', 1]) # Note: adding to an existing key tree.add_node(\'c\', [\'Bill\', \'Sports\', 3]) tree.add_node(\'d\', [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3]) tree.add_node(\'e\', [\'Quin\', \'Book\', 5, \'TV\', 2]) tree.add_node(\'f\', [\'Adam\', \'Computer\', 7]) # Print the tree tree.print_tree() # Expected output (formatted for readability): # a -> Adam -> Book -> 4 # b -> Bill -> Computer -> 5 -> TV -> 6 # -> Jill -> Sports -> 1 # c -> Bill -> Sports -> 3 # d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 # e -> Quin -> Book -> 5 -> TV -> 2 # f -> Adam -> Computer -> 7 ```","solution":"class Tree: def __init__(self): self.tree = {} def add_node(self, key, sub_elements): if key not in self.tree: self.tree[key] = [] self.tree[key].extend(sub_elements) def _print_sub_elements(self, sub_elements, indent): if isinstance(sub_elements, list): for elem in sub_elements: if isinstance(elem, (list, dict)): self._print_sub_elements(elem, indent + \\" \\") else: print(f\\"{indent}{elem}\\") def print_tree(self): for key in self.tree: print(f\\"{key} -> \\", end=\\"\\") first = True for sub_element in self.tree[key]: if not first: print(\\"-> \\", end=\\"\\") if isinstance(sub_element, list): print() self._print_sub_elements(sub_element, \\" \\") else: print(sub_element, end=\\" \\") first = False print()"},{"question":"# Task: Implement Ternary Search with Additional Features You are given an array of `n` integers sorted in ascending order. Implement a function `ternary_search_with_counts` that performs a ternary search for a given key and additionally returns the number of comparisons made during the search process. Function Signature ```python def ternary_search_with_counts(arr, left, right, key) -> Tuple[int, int]: Search for the key in the array. Parameters: arr (List[int]): A list of integers sorted in ascending order. left (int): The starting index of the search interval. right (int): The ending index of the search interval (inclusive). key (int): The value to search for. Returns: (int, int): A tuple containing: - The index of the found key in the array or -1 if the key is not found. - The number of comparisons made during the search. ``` Input - An array of integers `arr` sorted in ascending order. - Two integers `left` and `right` representing the search interval. - An integer `key` to search for. Output - A tuple `(index, comparison_count)` where: - `index` represents the index of the key in the array or -1 if the key is not found. - `comparison_count` represents the total number of comparisons made to find the key. Constraints - `left` and `right` will always be within the bounds of the array indices. - `1 <= len(arr) <= 10^5` - `-10^9 <= key, arr[i] <= 10^9` Example ```python arr = [1, 3, 5, 7, 9, 11, 13, 15] key = 7 left = 0 right = len(arr) - 1 print(ternary_search_with_counts(arr, left, right, key)) # Output: (3, 5) ``` Explanation In this example, the search finds the key `7` at index `3` after making `5` comparisons. Ensure your implementation handles edge cases and optimally performs the search.","solution":"from typing import List, Tuple def ternary_search_with_counts(arr: List[int], left: int, right: int, key: int) -> Tuple[int, int]: Search for the key in the array. Parameters: arr (List[int]): A list of integers sorted in ascending order. left (int): The starting index of the search interval. right (int): The ending index of the search interval (inclusive). key (int): The value to search for. Returns: (int, int): A tuple containing: - The index of the found key in the array or -1 if the key is not found. - The number of comparisons made during the search. comparisons = 0 while left <= right: comparisons += 1 third = (right - left) // 3 mid1 = left + third mid2 = right - third comparisons += 2 if arr[mid1] == key: return mid1, comparisons if arr[mid2] == key: return mid2, comparisons comparisons += 2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1, comparisons"},{"question":"# Queue Implementation and Usage You are working on a task scheduling system where jobs are added in the order they arrive, and the oldest job needs to be processed first. You need to implement and use a queue system to manage these jobs efficiently. # Task: 1. Implement a PriorityQueue class in Python. 2. The class should extend the AbstractQueue provided in the snippet above. 3. Implement the following methods: - `enqueue(item, priority)`: Adds a new item with a given priority. The priority is an integer where a lower number indicates higher priority. - `dequeue()`: Removes and returns the item with the highest priority (lowest priority number). If multiple elements have the same priority, remove the earliest added element. - `peek()`: Returns the item with the highest priority without removing it. 4. Integrate this class into a system for managing jobs and demonstrate it with a simple example. Method Specifications: - `enqueue(item, priority)`: Insert `item` into the queue with a specified `priority`. - Input: item (Any type), priority (int) - Output: None - `dequeue()`: Remove and return the highest priority item. - Input: None - Output: The item with the highest priority - Raises `IndexError` if the queue is empty. - `peek()`: Return the highest priority item without removing it. - Input: None - Output: The item with the highest priority - Raises `IndexError` if the queue is empty. Constraints: - The PriorityQueue should perform enqueue and dequeue operations efficiently. - Consider the possibility of having multiple items with the same priority. - Provide at least one example that demonstrates the use of the queue implementation in a task scheduler scenario. ```python # Begin your implementation here class Node: def __init__(self, value, priority): self.value = value self.priority = priority self.next = None class PriorityQueue(AbstractQueue): def __init__(self): super().__init__() self._front = None def __iter__(self): current = self._front while current: yield current.value current = current.next def enqueue(self, value, priority): new_node = Node(value, priority) if self._front is None or self._front.priority > priority: new_node.next = self._front self._front = new_node else: current = self._front while current.next and current.next.priority <= priority: current = current.next new_node.next = current.next current.next = new_node self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._front.value self._front = self._front.next self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._front.value # Example Demonstration if __name__ == \\"__main__\\": job_queue = PriorityQueue() job_queue.enqueue(\\"Job1\\", 2) job_queue.enqueue(\\"Job2\\", 1) # Higher priority because 1 < 2 job_queue.enqueue(\\"Job3\\", 3) print(\\"Next job to process:\\", job_queue.peek()) # Should output: Job2 print(\\"Processing job:\\", job_queue.dequeue()) # Should output: Job2 print(\\"Next job to process:\\", job_queue.peek()) # Should output: Job1 print(\\"Processing job:\\", job_queue.dequeue()) # Should output: Job1 print(\\"Processing job:\\", job_queue.dequeue()) # Should output: Job3 ```","solution":"import heapq class PriorityQueue: def __init__(self): self._heap = [] self._counter = 0 # This will help to maintain the order of insertion def enqueue(self, item, priority): heapq.heappush(self._heap, (priority, self._counter, item)) self._counter += 1 def dequeue(self): if not self._heap: raise IndexError(\\"Queue is empty\\") return heapq.heappop(self._heap)[2] def peek(self): if not self._heap: raise IndexError(\\"Queue is empty\\") return self._heap[0][2]"},{"question":"**Objective**: Implement an algorithm to delete a node from a Binary Search Tree (BST). Problem Statement: You are given the root node of a BST and an integer key. Your task is to delete the node with the given key from the BST and return the updated root node of the BST. The deletion must maintain the properties of a BST. Input: * `root`: The root node of the BST. A node is defined by a class with properties `val`, `left`, and `right`. * `key`: An integer value representing the value of the node that needs to be deleted. Output: * Return the root node of the BST after deleting the node with the specified key. If the key does not exist in the tree, return the original tree. Constraints: * The number of nodes in the tree can be any reasonable size. * Node values are integers and unique within the tree. Performance Requirements: * Time complexity should be O(h), where h is the height of the tree. * Space complexity should be O(h) due to recursive stack usage. # Examples: 1. **Input**: ``` root = [5,3,6,2,4,null,7], key = 3 ``` **Output**: ``` [5,4,6,2,null,null,7] ``` Explanation: ``` 5 / 3 6 / 2 4 7 After deleting node with key 3: 5 / 4 6 / 2 7 ``` 2. **Input**: ``` root = [5,3,6,2,4,null,7], key = 5 ``` **Output**: ``` [6,3,null,2,4,null,7] ``` Explanation: ``` 5 / 3 6 / 2 4 7 After deleting node with key 5: 6 / 3 null / 2 4 7 ``` # Function Signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BST: def delete_node(self, root: TreeNode, key: int) -> TreeNode: # Implement the function here ``` **Note**: - Remember to include edge cases such as deleting the root node, nodes with one child, and the scenario where the key does not exist in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BST: def delete_node(self, root: TreeNode, key: int) -> TreeNode: if not root: return root # Find the node to be deleted if key < root.val: root.left = self.delete_node(root.left, key) elif key > root.val: root.right = self.delete_node(root.right, key) else: # Node with only one child or no child if not root.left: return root.right elif not root.right: return root.left # Node with two children: Get the inorder successor temp = self.min_value_node(root.right) root.val = temp.val root.right = self.delete_node(root.right, temp.val) return root def min_value_node(self, node): current = node while current.left: current = current.left return current"},{"question":"# Problem Description You are required to implement an algorithm to find the next higher number that can be formed with the exact same set of digits as the given number. If no such number exists, return `-1`. # Detailed Steps 1. Identify the rightmost pair of consecutive digits where the first digit is smaller than the second. 2. If no such pair exists, it means the digits are sorted in a non-increasing order which means no higher permutation is possible. Return `-1` in this case. 3. From the rightmost end, find the smallest digit that is larger than the identified smaller digit in step 1. 4. Swap these two digits. 5. Reverse the order of all digits to the right of the initially identified digit. Implement this algorithm as the function `next_bigger(num)` in Python. # Function Signature ```python def next_bigger(num: int) -> int: pass ``` # Input - `num`: A non-negative integer representing the input number. # Output - Return the next higher number with the exact same set of digits. If no such pnumber exists, return `-1`. # Constraints - `0 <= num <= 10^9` # Examples 1. `next_bigger(38276)` should return `38627`. 2. `next_bigger(12345)` should return `12354`. 3. `next_bigger(1528452)` should return `1528524`. 4. `next_bigger(138654)` should return `143568`. 5. `next_bigger(54321)` should return `-1`. 6. `next_bigger(999)` should return `-1`. 7. `next_bigger(5)` should return `-1`. # Constraints Ensure your solution runs efficiently even for the largest permissible inputs. Test your code across various edge cases, including single-digit numbers and numbers with all digits the same.","solution":"def next_bigger(num: int) -> int: Returns the next higher number with the exact same set of digits as the given number. If no such number exists, returns -1. num_list = list(str(num)) n = len(num_list) # Step 1: Find the rightmost pair of consecutive digits where the first digit is smaller than the second i = n - 2 while i >= 0 and num_list[i] >= num_list[i + 1]: i -= 1 if i == -1: return -1 # Step 2: From the rightmost end, find the smallest digit that is larger than the identified smaller digit j = n - 1 while num_list[j] <= num_list[i]: j -= 1 # Step 3: Swap these two digits num_list[i], num_list[j] = num_list[j], num_list[i] # Step 4: Reverse the order of all digits to the right of the initially identified digit num_list = num_list[:i + 1] + num_list[i + 1:][::-1] return int(\'\'.join(num_list))"},{"question":"Scenario You are given an unsorted array of integers, and you need to find the first occurrence of a target integer within it. If the target integer is not present, you need to return -1. This task will test your understanding of the linear search algorithm and your ability to handle edge cases effectively. Function Requirements * **Function Signature**: `def find_target_index(arr: List[int], target: int) -> int` * **Input Format**: - A List of integers `arr` where `1 <= len(arr) <= 10^3` and `-10^4 <= arr[i] <= 10^4`. - An integer `target` where `-10^4 <= target <= 10^4`. * **Output Format**: - Return an integer indicating the index of the first occurrence of the `target` integer in the array. If the target is not found, return -1. Constraints * Array length does not exceed 1000 elements. * The function should run within a reasonable time frame for the given constraints. Example ```python assert find_target_index([1, 5, 3, 7, 3, 8], 3) == 2 assert find_target_index([10, 15, 20, 25], 15) == 1 assert find_target_index([5, 8, 12, 20, 50], 1) == -1 ``` Explanation Test your function with different cases, including: - When `target` is at the beginning, middle, and end of the array. - When `target` does not exist in the array. - When the array is very small (1 element) or at its maximum allowed length (1000 elements).","solution":"from typing import List def find_target_index(arr: List[int], target: int) -> int: Returns the index of the first occurrence of the target integer in the array. If the target integer is not present, returns -1. for index, value in enumerate(arr): if value == target: return index return -1"},{"question":"First Non-Repeating Character Index **Context**: In text processing and analysis, it is often valuable to identify characters that are unique within a string. This task can help in various applications, from data cleaning to error detection and correction. **Problem Statement**: Given a string `s`, write a function `first_unique_char(s)` that finds the first non-repeating character and returns its index. If it doesn\'t exist, return -1. **Input Format**: * A single string `s` of length n (1 <= n <= 10^5), consisting of lowercase English letters. **Output Format**: * An integer indicating the index of the first non-repeating character. If no such character exists, return -1. **Constraints**: * The function should have a time complexity of O(n). * The function must be optimized to handle large input efficiently. **Function Signature**: ```python def first_unique_char(s: str) -> int: pass ``` **Examples**: 1. Input: `s = \\"leetcode\\"` Output: `0` 2. Input: `s = \\"loveleetcode\\"` Output: `2` 3. Input: `s = \\"aabb\\"` Output: `-1` **Guidelines**: * Consider using a hash map to store character frequencies. * Iterate through the string twice. Once to build the frequency map and once to find the first unique character. **Edge cases to consider**: * An input consisting of a single character. * An input where no characters are unique. * Large input strings up to the constraint limit.","solution":"def first_unique_char(s: str) -> int: Returns the index of the first non-repeating character in the string s. If no such character exists, returns -1. from collections import Counter # Step 1: Build the frequency map frequency = Counter(s) # Step 2: Find the first unique character for index, char in enumerate(s): if frequency[char] == 1: return index return -1"},{"question":"You are tasked with designing an optimized function to preprocess strings. Given an input string, your goal is to remove all recurrent characters, keeping only the first occurrence of each character, while retaining the original order of characters. Problem Statement Write a function named `remove_reoccurring_characters` that processes a given input string and removes any recurrent characters. Input * A single string `s` (0 <= length of s <= 10^6). Output * Return a new string that includes only the first occurrences of each character from the input string `s`. Constraints * The function should be optimized to handle large input strings efficiently. * Consider optimizing the string concatenation process. Examples 1. **Input**: `\\"google\\"` **Output**: `\\"gole\\"` 2. **Input**: `\\"programming\\"` **Output**: `\\"progamin\\"` 3. **Input**: `\\"\\"` **Output**: `\\"\\"` Performance Requirements * The solution should have a time complexity of O(n), where n is the length of the input string. * Aim for an efficient approach to managing the output string. Scenario You are developing a text processing tool that needs to clean up data by removing redundant characters from input strings while retaining their order of first appearance. This is crucial in situations such as creating unique user identifiers from user input names in a user registration system. Task Implement the function `remove_reoccurring_characters`.","solution":"def remove_reoccurring_characters(s): Processes a given input string and removes any recurrent characters. Only the first occurrence of each character is kept in the original order. Parameters: s (str): Input string Returns: str: New string with only the first occurrences of each character seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Permutation Generation: Implementing and Optimizing Problem Description You are tasked with designing a function to generate all possible permutations of a given list of distinct integers. Given the nature of permutations, the number of permutations grows factorially with the size of the input list. To gauge your understanding of algorithm efficiency and backtracking mechanisms, you need to implement a function `advanced_permutations` that adheres to the following requirements: **Function Signature:** ```python def advanced_permutations(elements: List[int]) -> List[List[int]]: pass ``` Input - `elements` (List[int]): A list of distinct integers where 1 ≤ len(elements) ≤ 8. Output - A list of lists, where each sublist is a unique permutation of the input list. Constraints - The function should efficiently handle the upper limit of the input size. Performance Requirements - You must implement a solution that effectively balances memory usage and computational efficiency. - Avoid naive approaches that do not take advantage of recursion backtracking or iterative yielding mechanisms. Example ```python assert advanced_permutations([1, 2, 3]) == [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] assert advanced_permutations([0, 1]) == [ [0, 1], [1, 0] ] assert advanced_permutations([1]) == [ [1] ] ``` Special Instructions - Handle edge cases appropriately. - Avoid brute-force, memory-inefficient solutions. - Be cautious of the high space complexity; consider using generators if applicable. - Provide an analysis of the time and space complexity of your solution.","solution":"from typing import List def advanced_permutations(elements: List[int]) -> List[List[int]]: def backtrack(start=0): if start == len(elements): # Append a copy of the current permutation result.append(elements[:]) for i in range(start, len(elements)): # Swap the current element with the element at the start position elements[start], elements[i] = elements[i], elements[start] # Continue generating permutations with the next element backtrack(start + 1) # Backtrack: undo the swap elements[start], elements[i] = elements[i], elements[start] result = [] backtrack() return result"},{"question":"You are given a directed graph represented as an adjacency list. Your task is to write a function that determines if the graph contains a cycle. # Function Signature ```python def contains_cycle(graph: Dict[str, List[str]]) -> bool: ``` # Input * `graph`: A dictionary representation of the graph where the keys are vertex identifiers (strings) and the values are lists of vertices (strings) that are direct neighbors to the key vertex. # Output * Returns `True` if the graph contains a cycle, otherwise returns `False`. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(contains_cycle(graph)) # Output: True graph2 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] } print(contains_cycle(graph2)) # Output: False ``` # Constraints * The number of vertices in the graph should not exceed 10^3. * Edge and vertex identifiers will be non-empty strings. * Vertices will have unique identifiers. * The graph may be disconnected. # Notes * The function should handle graphs with no vertices (empty dictionary) by returning `False`. * Deadlocks in concurrent systems can be modeled using this algorithm where each process is represented as a vertex and dependency as edges.","solution":"def contains_cycle(graph): Returns True if the graph contains a cycle, otherwise False. visited = set() stack = set() def visit(node): if node in stack: return True if node in visited: return False visited.add(node) stack.add(node) for neighbor in graph.get(node, []): if visit(neighbor): return True stack.remove(node) return False for node in graph: if visit(node): return True return False"},{"question":"Context You are tasked with designing a function for a configurable code generator that needs to ensure all code blocks contain well-formed, balanced parentheses. Problem Statement Given `n` pairs of parentheses, write a function `generate_parenthesis(n)` to generate all combinations of well-formed parentheses. Requirements * Implement the function `generate_parenthesis(n)`. * **Input**: An integer `n` where 1 <= n <= 8. * **Output**: A list of strings, where each string represents a valid combination of `n` pairs of well-formed parentheses. Constraints * Each combination should contain exactly `n` pairs of parentheses. * The order of the combinations in the final list can differ, but it must contain all possible combinations. * Performance constraint: The function should handle inputs up to `n = 8` efficiently. Example ```python # Example 1 generate_parenthesis(2) # Expected output: [\\"(())\\", \\"()()\\"] # Example 2 generate_parenthesis(3) # Expected output: [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] ``` Notes * Ensure your solution properly handles the well-formedness of parentheses. * Consider edge cases such as when `n = 1` or `n = 0`.","solution":"def generate_parenthesis(n): Generate all combinations of well-formed parentheses with n pairs. :param n: int - number of pairs of parentheses :return: list[str] - all combinations of well-formed parentheses of length 2*n def backtrack(s, left, right): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + \'(\', left + 1, right) if right < left: backtrack(s + \')\', left, right + 1) result = [] backtrack(\'\', 0, 0) return result"},{"question":"# Set Cover Problem You are provided with an algorithm that solves the Set Cover problem, both optimally and approximately using a greedy approach. Your goal is to implement a function that computes the approximate minimum-cost cover using a hybrid approach. Scenario A broadcast station wants to ensure every city in a country receives their broadcast. Each station covers a subset of the cities and has a certain cost of operation. Your job is to determine which subset of stations to activate such that every city is covered at the minimum cost possible. Function Signature ```python def hybrid_set_cover(universe: set, subsets: dict, costs: dict) -> list: Args: universe (set): A set of elements representing all cities. subsets (dict): A dictionary where keys are subset identifiers (e.g., S1, S2) and values are sets representing cities covered by each subset. costs (dict): A dictionary where keys correspond to subset identifiers and values are integers representing the cost of each subset. Returns: list: A list of selected subset identifiers representing the minimum-cost set cover. pass ``` Input * **universe**: A set of integers representing all cities. * **subsets**: A dictionary where each key represents a subset identifier and value is a set of cities it covers. * **costs**: A dictionary where each key is a subset identifier and value is an integer representing the subset\'s cost. Output * **selected_subsets**: A list of selected subset identifiers to form the minimum-cost set cover. Constraints * The input `universe` will always be a non-empty set. * For dynamic input sizes, ensure your solution handles both small (optimal cover) and large (greedy cover) efficiently. Example ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} assert hybrid_set_cover(universe, subsets, costs) == [\'S3\', \'S2\'] ``` Performance Requirements * Aim for implementation efficiency while balancing the coverage and cost. The hybrid algorithm should leverage both optimal and greedy methods as applicable.","solution":"def hybrid_set_cover(universe: set, subsets: dict, costs: dict) -> list: Args: universe (set): A set of elements representing all cities. subsets (dict): A dictionary where keys are subset identifiers (e.g., S1, S2) and values are sets representing cities covered by each subset. costs (dict): A dictionary where keys correspond to subset identifiers and values are integers representing the cost of each subset. Returns: list: A list of selected subset identifiers representing the minimum-cost set cover. selected_subsets = [] covered = set() while covered != universe: best_subset = None best_cost_effectiveness = float(\'inf\') for subset, cities in subsets.items(): new_cities = cities - covered if new_cities: cost_effectiveness = costs[subset] / len(new_cities) if cost_effectiveness < best_cost_effectiveness: best_cost_effectiveness = cost_effectiveness best_subset = subset selected_subsets.append(best_subset) covered.update(subsets[best_subset]) return selected_subsets"},{"question":"Skyline Problem You are given the geometric information of several buildings in a cityscape, represented as a list of triplets `[Li, Ri, Hi]` where: * `Li`: the x-coordinate of the left edge. * `Ri`: the x-coordinate of the right edge. * `Hi`: the height. The buildings are perfect rectangles grounded on a flat surface at height 0. Write a function that returns the skyline formed by these buildings as a list of keypoints `[xi, yi]`. Function Signature: ```python def get_skyline(buildings: List[List[int]]) -> List[List[int]]: pass ``` Input: - `buildings`: A list of `[Li, Ri, Hi]` triplets representing the buildings with: - `0 ≤ Li, Ri ≤ INT_MAX` - `0 < Hi ≤ INT_MAX` - `Ri - Li > 0` Output: - A list of key points `[xi, yi]` that represent the skyline in the format: - Sorted by `xi` in ascending order. - No consecutive points should share the same height `yi`. Constraints: - The number of buildings is guaranteed to be in the range `[0, 10000]`. - The input list is already sorted by the left x-coordinate `Li`. # Example: ```python buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]] # The expected output is: [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]] print(get_skyline(buildings)) ``` Notes: - Ensure the output list is sorted in ascending order based on the x coordinates. - Any ground between two adjacent buildings should also be considered part of the skyline.","solution":"import heapq from typing import List def get_skyline(buildings: List[List[int]]) -> List[List[int]]: # Edge events array (start and end of each building) events = [(L, -H, R) for L, R, H in buildings] + [(R, 0, 0) for _, R, _ in buildings] # Sort events, with rules considering the start event before end event if at same position events.sort() # Resultant key points and a max heap for heights to track current heights result = [[0, 0]] live = [(0, float(\\"inf\\"))] for pos, negH, R in events: while live[0][1] <= pos: heapq.heappop(live) if negH: heapq.heappush(live, (negH, R)) if result[-1][1] != -live[0][0]: result.append([pos, -live[0][0]]) return result[1:]"},{"question":"# Run-Length Encoding and Decoding **Scenario**: You have been given a simple text compression algorithm called Run-Length Encoding (RLE). Your task is to encode and decode strings using this method. This algorithm compresses a string by replacing sequences of consecutive repeated characters with a single character followed by the count of repetitions. **Problem**: 1. **Implement the Compression Function** Write a function `encode_rle(input: str) -> str`: * **Input**: A string `input`. * **Output**: A run-length encoded string. * **Constraints**: - The input string can contain uppercase and lowercase characters. - The length of the input string is between 1 and 10^5 characters. 2. **Implement the Decompression Function** Write a function `decode_rle(input: str) -> str`: * **Input**: A run-length encoded string `input`. * **Output**: The original uncompressed string. * **Constraints**: - The encoded string will be correctly formed per the run-length encoding format. - The length of the encoded string is up to 10^5 characters. **Function Signatures**: ```python def encode_rle(input: str) -> str: pass def decode_rle(input: str) -> str: pass ``` **Example**: ```python assert encode_rle(\\"aaabbbcccc\\") == \\"3a3b4c\\" assert decode_rle(\\"3a3b4c\\") == \\"aaabbbcccc\\" assert encode_rle(\\"hello\\") == \\"1h1e2l1o\\" assert decode_rle(\\"1h1e2l1o\\") == \\"hello\\" ``` Your implementation should be efficient with respect to both time and space, and handle edge cases properly.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded_str = \\"\\" count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded_str += f\\"{count}{input[i - 1]}\\" count = 1 encoded_str += f\\"{count}{input[-1]}\\" return encoded_str def decode_rle(input: str) -> str: if not input: return \\"\\" decoded_str = \\"\\" i = 0 while i < len(input): j = i # Extract the number part while j < len(input) and input[j].isdigit(): j += 1 count = int(input[i:j]) char = input[j] decoded_str += char * count i = j + 1 return decoded_str"},{"question":"You are given an m x n 2D matrix representing a map of a city where each element represents a distinct block. To efficiently monitor the blocks, you need to set up a patrol route that covers each block in a spiral order starting from the top-left corner. **Your task is to write a function `spiral_order(matrix: List[List[int]]) -> List[int]` that takes this matrix as input and returns a list containing the elements of the matrix in a spiral order.** # Input: * matrix: A list of lists of integers representing a 2D matrix where 1 ≤ len(matrix), len(matrix[0]) ≤ 100. # Output: * A list of integers representing the elements of the matrix in spiral order. # Constraints: * The input matrix will always contain positive integers only. # Example: **Example 1:** ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] spiral_order(matrix) # Should return: [1, 2, 3, 6, 9, 8, 7, 4, 5] ``` **Example 2:** ```python matrix = [ [1, 2], [3, 4], [5, 6] ] spiral_order(matrix) # Should return: [1, 2, 4, 6, 5, 3] ``` **Example 3:** ```python matrix = [[1]] spiral_order(matrix) # Should return: [1] ``` # Notes: * Focus on producing an efficient and readable solution. * Consider edge cases such as empty matrices or matrices with only one row or one column. * Ensure that your solution has a time complexity of O(m * n) and space complexity of O(1), not considering the space used for the output.","solution":"from typing import List def spiral_order(matrix: List[List[int]]) -> List[int]: if not matrix or not matrix[0]: return [] result = [] top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right along the top row for col in range(left, right + 1): result.append(matrix[top][col]) top += 1 # Traverse from top to bottom along the right column for row in range(top, bottom + 1): result.append(matrix[row][right]) right -= 1 if top <= bottom: # Traverse from right to left along the bottom row for col in range(right, left - 1, -1): result.append(matrix[bottom][col]) bottom -= 1 if left <= right: # Traverse from bottom to top along the left column for row in range(bottom, top - 1, -1): result.append(matrix[row][left]) left += 1 return result"},{"question":"Given a collection of distinct numbers, write a function that generates all possible permutations of these numbers. Your function should be efficient and handle edge cases appropriately. You are given three implementations as examples: recursive, iterative generator, and a DFS-based recursive approach. Now, it\'s your turn to implement one of your own. # Requirements: - **Function Name**: `generate_permutations` - **Input**: A list of distinct integers, `elements` (1 ≤ |elements| ≤ 10) - **Output**: A list of lists, where each inner list is a unique permutation of the input elements. # Constraints: - The list will contain distinct integers. - Performance should be considered, but focus primarily on correctness. # Example: ```python Input: [1, 2, 3] Output: [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] ``` # Task: Write the function `generate_permutations` from scratch without using the provided code snippets directly. Aim to show your understanding of recursion or iteration by developing a clear, maintainable solution. # Edge Cases: - Input: `[]` - Output: `[]` - Input: `[1]` - Output: `[[1]]` # Bonus Points: - Include appropriate comments explaining the logic and any edge case handling. - If optimizing the solution, briefly explain your approach and the benefits seen.","solution":"def generate_permutations(elements): Generates all possible permutations of the given list of distinct integers. Parameters: elements (list): A list of distinct integers. Returns: list: A list of lists, where each inner list is a unique permutation of the input elements. if len(elements) == 0: return [] def backtrack(start=0): # When we\'ve reached the end of the list, record the permutation. if start == len(elements): permutations.append(elements[:]) for i in range(start, len(elements)): # Swap the current index with the start index. elements[start], elements[i] = elements[i], elements[start] # Move onto the next element. backtrack(start + 1) # Swap back to backtrack and restore the original list state. elements[start], elements[i] = elements[i], elements[start] permutations = [] backtrack() return permutations"},{"question":"Context: You have been provided with the implementation for matrix inversion. Your task is to extend this functionality to handle different scenarios and ensure robustness. This function is critical for applications like solving linear equations, computer graphics, and systems modeling. Task: Implement a function `invertible_matrix_check` that enhances the matrix inversion process by validating if a given matrix can be validly inverted according to specific criteria. Function Signature: ```python def invertible_matrix_check(matrix: List[List[float]]) -> List[List[float]]: pass ``` Input: * A 2D list `matrix` of size (n times n). Output: * If the matrix can be successfully inverted, the output should be the inverse matrix. * If the matrix is not invertible or has any error conditions, the function should return a descriptive string message indicating the specific issue. Error Conditions: 1. Return \\"Invalid matrix: not a 2D matrix\\" if the input is not a 2D list. 2. Return \\"Invalid matrix: matrix is not square\\" if the matrix is not square. 3. Return \\"Invalid matrix: matrix is too small\\" for 0x0 or 1x1 matrices. 4. Return \\"Invalid matrix: singular matrix\\" if the matrix determinant is zero. Constraints: - The matrix elements are real numbers. - Assume a reasonable size limit for computation, e.g., n <= 20. Example: ```python matrix = [ [4, 7], [2, 6] ] print(invertible_matrix_check(matrix)) # Expected output: [[0.6, -0.7], [-0.2, 0.4]] invalid_matrix = [ [1, 2], [2, 4] ] print(invertible_matrix_check(invalid_matrix)) # Expected output: \\"Invalid matrix: singular matrix\\" ``` Guidelines: 1. Reuse the existing helper functions for calculating determinants, minors, etc. 2. Ensure the implementation is efficient and handles all specified error cases. 3. Pay special attention to edge cases and properly validate the input matrix.","solution":"from typing import List, Union def determinant(matrix: List[List[float]]) -> float: n = len(matrix) if n == 1: return matrix[0][0] if n == 2: return matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0] det = 0 for c in range(n): det += ((-1)**c) * matrix[0][c] * determinant(minor(matrix, 0, c)) return det def minor(matrix: List[List[float]], i: int, j: int) -> List[List[float]]: return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def transpose(matrix: List[List[float]]) -> List[List[float]]: return list(map(list, zip(*matrix))) def inverse(matrix: List[List[float]]) -> List[List[float]]: det = determinant(matrix) n = len(matrix) if det == 0: raise ValueError(\\"Singular matrix\\") # Find the matrix of cofactors cofactors = [] for r in range(n): cofactor_row = [] for c in range(n): minor_det = determinant(minor(matrix, r, c)) cofactor_row.append(((-1) ** (r + c)) * minor_det) cofactors.append(cofactor_row) # Transpose the matrix of cofactors cofactors = transpose(cofactors) # Divide each element of the cofactor matrix by the determinant for r in range(n): for c in range(n): cofactors[r][c] = cofactors[r][c] / det return cofactors def invertible_matrix_check(matrix: List[List[float]]) -> Union[List[List[float]], str]: if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return \\"Invalid matrix: not a 2D matrix\\" n = len(matrix) if n == 0 or not all(len(row) == n for row in matrix): return \\"Invalid matrix: matrix is not square\\" if n == 1: return \\"Invalid matrix: matrix is too small\\" try: return inverse(matrix) except ValueError: return \\"Invalid matrix: singular matrix\\""},{"question":"Context: You are tasked to implement a sorting algorithm for a large dataset of floating-point numbers that mostly lie within a certain range. To achieve efficient sorting, we will use the Bucket Sort algorithm. However, the current implementation uses Insertion Sort within each bucket, leading to potential inefficiencies. Your objective is to write a function that maintains the essence of Bucket Sort but optimizes sorting within buckets for better performance. Task: Implement a function `optimized_bucket_sort` for sorting an array of floating-point numbers using Bucket Sort. This function should optimize the sorting done within buckets. # Requirements: 1. **Input**: A list of floating-point numbers `arr` where the length `1 <= len(arr) <= 10^6` and each element `0 <= arr[i] <= 1`. 2. **Output**: Return a list of numbers sorted in non-decreasing order. 3. **Constraints**: You need to use a more efficient sorting algorithm within each bucket compared to Insertion Sort. 4. **Performance**: The overall time complexity should aim to be better than O(n^2). # Function Signature: ```python def optimized_bucket_sort(arr: [float]) -> [float]: ``` # Example: ```python # Example 1 Input: [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68] Output: [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94] # Example 2 Input: [0.42, 0.32, 0.52, 0.62, 0.72] Output: [0.32, 0.42, 0.52, 0.62, 0.72] ``` Note: * Ensure your implementation handles all edge cases efficiently. * You can assume the input numbers are uniformly distributed in the range [0, 1].","solution":"def optimized_bucket_sort(arr): Sorts an array of floating-point numbers using Bucket Sort with an optimized sorting algorithm for each bucket. import math def quicksort(arr): Helper function to perform quicksort on an array. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right) if len(arr) == 0: return [] # Create n empty buckets where n is the length of the input array n = len(arr) buckets = [[] for _ in range(n)] # Put array elements into different buckets for num in arr: index = math.floor(num * n) buckets[index].append(num) # Sort individual buckets using quicksort sorted_array = [] for bucket in buckets: sorted_bucket = quicksort(bucket) sorted_array.extend(sorted_bucket) return sorted_array"},{"question":"You are given a 3x3 grid initially filled with water. Adding land to this grid forms islands (connected land cells). Each cell can be land (represented by 1) or water (represented by 0). You are to implement functionality that, given a sequence of positions to turn water into land, returns the number of islands after each operation. Two pieces of lands are considered connected if they are horizontally or vertically adjacent. Implement the function: ```python def num_islands(positions: List[List[int]]) -> List[int]: ``` # Input * `positions`: A list of lists, where each inner list contains two integers `[row, col]` representing the position in the grid to convert from water to land. # Output * Returns a list of integers where each integer represents the number of islands after each addLand operation. # Constraints 1. `0 <= row, col < 3` 2. Each position is unique and is operated one at a time. # Example ```python positions = [[0,0], [0,1], [1,2], [2,1]] print(num_islands(positions)) >>> [1, 1, 2, 3] ``` # Explanation - Initially, the grid is filled with water: ``` 0 0 0 0 0 0 0 0 0 ``` - After turning (0,0) into land: ``` 1 0 0 0 0 0 0 0 0 ``` Number of islands = 1 - After turning (0,1) into land: ``` 1 1 0 0 0 0 0 0 0 ``` Number of islands = 1 - After turning (1,2) into land: ``` 1 1 0 0 0 1 0 0 0 ``` Number of islands = 2 - After turning (2,1) into land: ``` 1 1 0 0 0 1 0 1 0 ``` Number of islands = 3 # Notes * The grid size and constraints ensure that a Union-Find structure is optimal for gaining the required efficiency. * Implement the Union-Find data structure as a helper class inside your primary function to manage the union and find operations effectively.","solution":"from typing import List class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size self.count = 0 # Initially, there are no islands def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def setParent(self, x): if self.parent[x] == x: self.count += 1 def num_islands(positions: List[List[int]]) -> List[int]: rows, cols = 3, 3 uf = UnionFind(rows * cols) grid = [[0] * cols for _ in range(rows)] results = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for pos in positions: r, c = pos if grid[r][c] == 1: results.append(uf.count) continue grid[r][c] = 1 index = r * cols + c uf.setParent(index) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1: uf.union(index, nr * cols + nc) results.append(uf.count) return results"},{"question":"# Scenario You are given two n-ary trees and need to determine if they are structurally identical and contain identical values in corresponding nodes. An n-ary tree is a tree where each node can have zero or more children. This expands the problem from the binary tree comparison you\'ve previously learned to a more generalized form. # Problem Statement Write a function `is_same_nary_tree` that takes two n-ary tree nodes and determines if the two trees are identical. # Function Signature ```python def is_same_nary_tree(node1: Optional[NaryTreeNode], node2: Optional[NaryTreeNode]) -> bool: ``` # Input - `node1`, `node2`: The roots of the two n-ary trees. If a tree node does not exist, its value is `None`. # Output - Return `True` if both trees are identical in structure and node values, otherwise, return `False`. # Constraints - Each tree node contains an integer value. - Each node has an arbitrary number of children (array of nodes). - Nodes values can be positive or negative integers or zero. - The height of trees may potentially be large. # Example ```python # Example Node Class Definition class NaryTreeNode: def __init__(self, val: int, children: List[NaryTreeNode] = None): self.val = val self.children = children if children else [] # Example Trees # Tree 1: Tree 2: # 1 1 # / | / | # 2 3 4 2 3 4 # / / # 5 5 # Creating nodes for Tree 1 node1_5 = NaryTreeNode(5) node1_2 = NaryTreeNode(2, [node1_5]) node1_3 = NaryTreeNode(3) node1_4 = NaryTreeNode(4) root1 = NaryTreeNode(1, [node1_2, node1_3, node1_4]) # Creating nodes for Tree 2 node2_5 = NaryTreeNode(5) node2_2 = NaryTreeNode(2, [node2_5]) node2_3 = NaryTreeNode(3) node2_4 = NaryTreeNode(4) root2 = NaryTreeNode(1, [node2_2, node2_3, node2_4]) assert is_same_nary_tree(root1, root2) == True ``` # Notes - The function should consider running time and memory usage, especially for large trees (height could be large). - Handle edge cases judiciously (e.g., both trees being null, one being null, trees having varied numbers of children).","solution":"class NaryTreeNode: def __init__(self, val: int, children=None): if children is None: children = [] self.val = val self.children = children def is_same_nary_tree(node1, node2): Determine if two n-ary trees are structurally identical and contain identical values in corresponding nodes. if not node1 and not node2: return True if not node1 or not node2: return False if node1.val != node2.val: return False if len(node1.children) != len(node2.children): return False for c1, c2 in zip(node1.children, node2.children): if not is_same_nary_tree(c1, c2): return False return True"},{"question":"# Scenario: You are tasked with implementing matrix operations as part of a larger scientific computing library. As a first step, you need to verify your understanding of matrix exponentiation using the provided matrix multiplication and identity matrix functions. # Problem: Given a square matrix `mat` of dimension `d` and an integer `n`, implement the function `matrix_exponentiation_optimized(mat: list, n: int) -> list` which computes the `n`-th power of the matrix using matrix exponentiation by repeated squaring. # Input: * A square matrix `mat` (a list of lists, where each sublist represents a row of the matrix) of dimension `d x d`, where `1 <= d <= 10`. * An integer `n`, where `0 <= n <= 10^9`. # Output: * A square matrix of dimension `d x d`, which is the `n`-th power of the input matrix `mat`. # Constraints: * The input matrix will contain integer values between `-10^3` and `10^3`. * The function should be optimized for large values of `n`. # Example: ```python mat = [ [2, 0], [0, 2] ] n = 3 matrix_exponentiation_optimized(mat, n) # Output: [[8, 0], [0, 8]] ``` # Notes: * You must use the provided `multiply` and `identity` functions. * Handle edge cases such as `n = 0` and large values of `n`. # Implementation: Provide the function `matrix_exponentiation_optimized` below: ```python def matrix_exponentiation_optimized(mat: list, n: int) -> list: # Implement the function using matrix exponentiation by repeated squaring pass ```","solution":"def identity(d: int) -> list: Returns the identity matrix of dimension d x d. return [[1 if i == j else 0 for j in range(d)] for i in range(d)] def multiply(mat1: list, mat2: list) -> list: Multiplies two matrices mat1 and mat2. Returns the resulting matrix. d = len(mat1) result = [[0] * d for _ in range(d)] for i in range(d): for j in range(d): for k in range(d): result[i][j] += mat1[i][k] * mat2[k][j] return result def matrix_exponentiation_optimized(mat: list, n: int) -> list: Returns the n-th power of matrix mat using matrix exponentiation by repeated squaring. d = len(mat) result = identity(d) while n > 0: if n % 2 == 1: result = multiply(result, mat) mat = multiply(mat, mat) n //= 2 return result"},{"question":"# Matrix Chain Multiplication Optimization Problem Description You are given a sequence of matrices, and you need to find the most efficient way to multiply these matrices together. The task is to determine the order in which to multiply the matrices to minimize the number of scalar multiplications. Your task is to write a function `find_optimal_order` that takes a list `array` where the ith matrix has dimensions `array[i-1]xarray[i]`. You need to return the minimum number of scalar multiplications required to multiply the sequence of matrices. Function Signature ```python def find_optimal_order(array: List[int]) -> int: ``` Input - `array` (List[int]): A list with length `n+1`, representing the dimensions of the matrices. Output - `int`: The minimum number of scalar multiplications required. Example ```python array = [30, 35, 15, 5, 10, 20, 25] print(find_optimal_order(array)) # Output: 15125 ``` # Constraints - The input list `array` will have at least two elements. - The dimensions in the list can be large, up to 1000. # Notes 1. Remember to handle edge cases, such as when there is only one matrix. 2. Consider optimizing your solution for performance, given the potential size of input. Good luck!","solution":"from typing import List def find_optimal_order(array: List[int]) -> int: n = len(array) - 1 # Initialize the dp table with infinity dp = [[float(\'inf\')] * n for _ in range(n)] # Base case: single matrix chains, cost is 0 for i in range(n): dp[i][i] = 0 # L is chain length for L in range(2, n+1): for i in range(n - L + 1): j = i + L - 1 dp[i][j] = float(\'inf\') # Try different places to split the product for k in range(i, j): q = dp[i][k] + dp[k + 1][j] + array[i] * array[k + 1] * array[j + 1] if q < dp[i][j]: dp[i][j] = q return dp[0][n-1]"},{"question":"You are provided with a basic version of Run-Length Encoding and Decoding algorithm, which is a simple form of lossless data compression. Your task is to enhance these algorithms with additional functionalities, making the implementation more robust, efficient, and user-friendly. # Task 1. **Enhanced Encode Functionality**: Write an enhanced version of the `encode_rle` function with support for: * Handling special cases such as single-character strings. * Efficient processing for large strings. * Verification and handling of numeric characters within the input string. 2. **Enhanced Decode Functionality**: Write an enhanced version of the `decode_rle` function with support for: * Validation and error reporting for malformed encoded strings. * Handling cases where the encoded string contains non-numeric characters improperly. # Input and Output Format * The `encode_rle` function should take a string `input` and return the encoded string. * Example: * Input: `\\"aaabbbccddd\\"` * Output: `\\"3a3b2c3d\\"` * The `decode_rle` function should take an encoded string `input` and return the decoded string. * Example: * Input: `\\"3a3b2c3d\\"` * Output: `\\"aaabbbccddd\\"` # Constraints * The input strings for encoding and decoding will have a maximum length of 1000 characters. * The encoded strings will only contain valid Run-Length Encoded patterns. # Performance Requirements * Your solution should handle the worst-case scenario within a reasonable time frame and memory footprint. # Scenario Run-Length Encoding is commonly used in bitmap image compression. Imagine you are tasked with enhancing an image compression library using RLE to ensure it can handle large images efficiently and deal with possible edge cases in user input data. # Function Signatures ```python def encode_rle(input: str) -> str: # Your enhanced encoding implementation here def decode_rle(input: str) -> str: # Your enhanced decoding implementation here ``` # Examples Encoding Example: ```python print(encode_rle(\\"aaa\\")) # Output: \\"3a\\" print(encode_rle(\\"abc\\")) # Output: \\"1a1b1c\\" ``` Decoding Example: ```python print(decode_rle(\\"3a2b1c\\")) # Output: \\"aaabbc\\" print(decode_rle(\\"1a1b1c\\")) # Output: \\"abc\\" ```","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" if len(input) == 1: return f\\"1{input}\\" count = 1 result = [] for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: result.append(f\\"{count}{input[i - 1]}\\") count = 1 result.append(f\\"{count}{input[-1]}\\") return \'\'.join(result) def decode_rle(input: str) -> str: if not input: return \\"\\" result = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: if count == 0: raise ValueError(\\"Invalid RLE encoding\\") result.append(char * count) count = 0 if count != 0: raise ValueError(\\"Invalid RLE encoding\\") return \'\'.join(result)"},{"question":"# Question: Implement a Max Binary Heap You are required to implement a Max Binary Heap. A max-heap is a complete binary tree where the value of each node is greater than or equal to the values of its children. The root node will always contain the maximum value. You will use an array-based approach to implement the following methods: 1. `insert(val)`: Insert an element into the heap. 2. `remove_max()`: Remove and return the maximum element from the heap. 3. `perc_up(i)`: Helper method to move a node up in the tree to restore the heap property. 4. `perc_down(i)`: Helper method to move a node down in the tree to restore the heap property. 5. `max_child(i)`: Helper method to find the index of the maximum child. # Specifications * **Input**: Methods will receive a single integer input as arguments for `insert`, and no arguments for `remove_max`. * **Output**: The `remove_max` method will return the maximum element after removing it from the heap. * **Constraints**: All operations should be O(log N). # Example ```python heap = MaxBinaryHeap() heap.insert(10) heap.insert(20) heap.insert(15) print(heap.remove_max()) # Output: 20 heap.insert(30) print(heap.remove_max()) # Output: 30 ``` # Requirements 1. Ensure your implementation is efficient and adheres to the complexity constraints. 2. Handle edge cases such as removing from an empty heap. 3. Preserve the max heap properties after each insertion or removal operation. # Initialization ```python class MaxBinaryHeap: def __init__(self): # Initialize with a heap containing a single element self.heap = [0] self.current_size = 0 def perc_up(self, i): Helper method to percolate a node up to restore heap property. pass def insert(self, val): Insert a new element into the heap. pass def max_child(self, i): Helper method to find the index of the maximum child for node i. pass def perc_down(self, i): Helper method to percolate a node down to restore heap property. pass def remove_max(self): Remove and return the maximum element from the heap. pass ``` Complete the `MaxBinaryHeap` class by implementing the required methods.","solution":"class MaxBinaryHeap: def __init__(self): # Initialize with an empty heap self.heap = [0] self.current_size = 0 def perc_up(self, i): Helper method to percolate a node up to restore heap property. while i // 2 > 0: if self.heap[i] > self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): Insert a new element into the heap. self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def max_child(self, i): Helper method to find the index of the maximum child for node i. if i * 2 + 1 > self.current_size: return i * 2 else: if self.heap[i * 2] > self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def perc_down(self, i): Helper method to percolate a node down to restore heap property. while (i * 2) <= self.current_size: mc = self.max_child(i) if self.heap[i] < self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def remove_max(self): Remove and return the maximum element from the heap. if self.current_size == 0: raise IndexError(\\"remove_max(): empty heap\\") max_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return max_val"},{"question":"Given a singly-linked list, rotate the list to the right by `k` positions. You are required to implement the rotation operation effectively for potential use in a memory-constrained environment. # Function Signature ```python def rotate_right(head, k): :type head: ListNode :type k: int :rtype: ListNode ``` # Input * `head` (ListNode): The head of the singly-linked list. * `k` (int): A non-negative integer representing the number of rotations to the right. # Output * (ListNode): The head of the rotated linked list. # Constraints * The number of nodes in the list is in the range `[0, 10^5]`. * `0 <= k <= 10^9` # Requirements * Handle edge cases where the list is empty or has only one node. * Ensure the function runs efficiently with a linear time complexity and constant space complexity. # Examples * Example 1: ```python # Input: 1 -> 2 -> 3 -> 4 -> 5 -> NULL, k = 2 # Output: 4 -> 5 -> 1 -> 2 -> 3 -> NULL ``` * Example 2: ```python # Input: 0 -> 1 -> 2 -> NULL, k = 4 # Output: 2 -> 0 -> 1 -> NULL ``` # Notes * If k is 0, the list should remain unchanged. * If k is a multiple of the length of the list, the list should remain unchanged. * Consider optimizing the list traversal for verifying and adjusting pointer steps.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_right(head, k): if not head or not head.next or k == 0: return head # Compute the length of the list and make it a circular linked list old_tail = head length = 1 while old_tail.next: old_tail = old_tail.next length += 1 # Connect the tail to the head to make it circular old_tail.next = head # New tail will be at (length - k % length - 1) # and new head will be at (length - k % length) k = k % length new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next new_head = new_tail.next # Break the circle new_tail.next = None return new_head"},{"question":"# Question: Linked List Partitioning Implement a function called `partition_linked_list` that partitions a given singly linked list around a value `x`. All nodes with values less than `x` should come before nodes with values greater than or equal to `x`. If `x` is contained within the list, the values of `x` only need to be after the elements less than `x`. The list should be parted in place without using extra space for new nodes. Function Signature ```python def partition_linked_list(head: Node, x: int) -> Node: ``` Input - `head`: The head node of the initial linked list, which may be `None`. - `x`: An integer value used as the pivot for partitioning. Output - Returns the head node of the modified linked list after partitioning. Constraints - You should not allocate extra space for new nodes; only rearrange existing nodes. - Nodes with values equal to `x` can appear anywhere in the \\"right partition\\". Example ```python # Define the linked list a = Node(3) b = Node(5) c = Node(8) d = Node(5) e = Node(10) f = Node(2) g = Node(1) a.next = b b.next = c c.next = d d.next = e e.next = f f.next = g # Function call new_head = partition_linked_list(a, 5) # Upon printing the new linked list using a helper function, the output list should be similar to: # 3 -> 2 -> 1 -> 5 -> 8 -> 5 -> 10 or any other order that respects the partitioning rule. print_linked_list(new_head) ``` Assumptions - The linked list nodes contain integer values. - The head may be `None` or a valid `Node`. Implementing this function will showcase your ability to manage linked list pointer manipulations and understand partitioning algorithms. Ensure your implementation handles edge cases and maintains efficiency.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def partition_linked_list(head: Node, x: int) -> Node: if head is None: return None less_head = less_tail = None greater_head = greater_tail = None current = head while current is not None: next_node = current.next current.next = None if current.value < x: if less_head is None: less_head = less_tail = current else: less_tail.next = current less_tail = current else: if greater_head is None: greater_head = greater_tail = current else: greater_tail.next = current greater_tail = current current = next_node if less_tail is not None: less_tail.next = greater_head return less_head if less_head is not None else greater_head"},{"question":"Problem Statement You are given two singly linked lists representing two non-negative numbers. The lists do not contain any cycles and are terminated with `None`. Each node contains a single digit number stored in a `Node` class with two attributes: `val` (the value) and `next` (the reference to the next node). Your task is to determine the node at which the two linked lists intersect and return it. If there is no intersection, return `None`. The intersection of two linked lists means that they share the same node in the memory (not just the same value). # Example Consider the following linked lists: ``` 1 -> 3 -> 5 7 -> 9 -> 11 / 2 -> 4 -> 6 ``` In the above example, the function should return the node with value 7. # Constraints * The linked lists do not contain cycles. * The linked lists may be of different lengths. # Function Signature ```python class Node: def __init__(self, val=None): self.val = val self.next = None def intersection(h1: Node, h2: Node) -> Node: # Your code here ``` # Input * `h1`: The head node of the first linked list. * `h2`: The head node of the second linked list. # Output * The node at which the two linked lists intersect. Return `None` if they do not intersect. # Example Test Case ```python def test_intersection(): # create linked list as: # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f assert intersection(a1, a2).val == 7 test_intersection() ``` Implement the function `intersection` to solve the problem.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def intersection(h1: Node, h2: Node) -> Node: def get_length(head: Node) -> int: length = 0 current = head while current: length += 1 current = current.next return length length1 = get_length(h1) length2 = get_length(h2) # Adjust starting points so both lists are at the same distance from the end if length1 > length2: for _ in range(length1 - length2): h1 = h1.next else: for _ in range(length2 - length1): h2 = h2.next while h1 and h2: if h1 == h2: return h1 h1 = h1.next h2 = h2.next return None"},{"question":"# String Rotation Check You are tasked with writing a function to check if one string is a rotation of another. For example, the string \\"waterbottle\\" is a rotation of \\"erbottlewat\\". Function Signature ```python def is_rotation(s1: str, s2: str) -> bool: ... ``` Input - `s1`: A string of length `n`, where n is between 0 and 10^5. - `s2`: A string of length `n`. Output - A boolean value indicating whether `s2` is a rotation of `s1`. Constraints - Time complexity should be O(n). - Space complexity should be O(n). Example ```python assert is_rotation(\\"waterbottle\\", \\"erbottlewat\\") == True assert is_rotation(\\"abcde\\", \\"abced\\") == False assert is_rotation(\\"rotation\\", \\"tationro\\") == True assert is_rotation(\\"\\", \\"\\") == True assert is_rotation(\\"x\\", \\"x\\") == True assert is_rotation(\\"x\\", \\"y\\") == False ``` # Explanation - Concatenating the string `s1` with itself, creating a new string `s1s1`, would encompass all possible rotations as its substrings. - Hence, if `s2` is a rotation of `s1`, it will appear as a substring of `s1s1`. Write your implementation of the `is_rotation` function to efficiently check the rotation condition.","solution":"def is_rotation(s1: str, s2: str) -> bool: Checks if s2 is a rotation of s1. Args: s1 (str): The original string. s2 (str): The string to check if it\'s a rotation of s1. Returns: bool: True if s2 is a rotation of s1, False otherwise. if len(s1) != len(s2): return False return s2 in s1 + s1"},{"question":"# Task: Implement Last Occurrence Search in Sorted Array Context: You are working on a system that logs events in increasing chronological order and stores them in an array. Each event is assigned a unique identifier (ID). You are tasked with developing a function that can quickly find the last occurrence of a particular event ID in this sorted array. This capability is crucial for quickly locating the most recent instance of any given event. Requirements: Implement a function called `find_last_occurrence` that takes a sorted array of event IDs and a target event ID as input. The function should return the index of the last occurrence of the target event ID. If the target event ID is not present in the array, return -1. # Function Signature: ```python def find_last_occurrence(array: List[int], target: int) -> int: # Your code here ``` # Input: - `array`: A list of integers in increasing order, representing event IDs. - `target`: An integer, representing the event ID to find. # Output: - An integer, representing the index of the last occurrence of the target event ID. If the target is not present, return -1. # Example: ```python # Example 1: array = [1, 2, 2, 3, 3, 3, 4, 5] target = 3 print(find_last_occurrence(array, target)) # Output: 5 # Example 2: array = [1, 3, 3, 5, 6] target = 2 print(find_last_occurrence(array, target)) # Output: -1 ``` # Constraints: - The input array is non-empty and sorted in increasing order. - The function should run in O(log n) time complexity. # Note: Consider edge cases like: - When the array is empty, return -1. - The typical situations where the target is at the beginning, middle, or end of the array. - Arrays with various lengths and compositions to ensure robustness.","solution":"from typing import List def find_last_occurrence(array: List[int], target: int) -> int: Finds the index of the last occurrence of the target in a sorted array. Returns -1 if the target is not present in the array. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == target: result = mid left = mid + 1 # Continue to search to the right elif array[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"You are given three different implementations of a function to compute the n-th Fibonacci number: a recursive implementation, a dynamic programming implementation, and an iterative implementation. While these implementations correctly compute Fibonacci numbers, each has its own performance characteristics and constraints. Your task is to write a new Fibonacci function, `optimized_fibonacci(n)`, which efficiently computes the n-th Fibonacci number and has the following properties: * Efficient Time Complexity: O(n) * Efficient Space Complexity: O(1) # Requirements Input * `n` (integer): The position in the Fibonacci sequence. 0 ≤ n ≤ 10^6. Output * Returns the n-th Fibonacci number as an integer. Constraints * For the given range of n (up to 10^6), your solution must be efficient in both time and space. * You should not use additional data structures such as lists to store intermediate results for large sequences. * Handle the edge cases where `n` is 0 or 1. # Example ```python assert optimized_fibonacci(0) == 0 assert optimized_fibonacci(1) == 1 assert optimized_fibonacci(10) == 55 assert optimized_fibonacci(50) == 12586269025 ``` # Notes * You can leverage the properties of the previous iterative approach to achieve efficient use. * Consider updating only the last two Fibonacci values iteratively.","solution":"def optimized_fibonacci(n): Computes the n-th Fibonacci number using an iterative approach with O(n) time complexity and O(1) space complexity. Arguments: n -- the position in the Fibonacci sequence (0-based) Returns: The n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 prev, curr = 0, 1 for _ in range(2, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"You are tasked with creating a new version of the ZigZag Iterator that can handle an arbitrary number of lists. The iterator should cycle through the elements of the given lists in a round-robin fashion (zigzag through all lists) until all elements from all lists have been exhausted. # Requirements 1. Write a class `ZigZagIterator` with the following: - **Constructor**: Accept a list of lists (each containing integers). - **`next` Method**: Returns the next element in the zigzag traversal. - **`has_next` Method**: Returns `True` if there are more elements to traverse, else `False`. # Input and Output - You will be provided with a list of `k` lists. - Methods: - `ZigZagIterator(lists: List[List[int]])` initializes the iterator. - `next() -> int` returns the next element in the sequence. - `has_next() -> bool` returns whether there are more elements. # Constraints - The number of lists `k` will be in the range [1, 1000]. - The total number of elements across all lists will not exceed 10^5. - Each element `list[i][j]` will be an integer. # Example ```python lists = [ [1, 2, 3], [4, 5, 6, 7], [8, 9] ] it = ZigZagIterator(lists) result = [] while it.has_next(): result.append(it.next()) # expected result: [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` # Explanation 1. The first element is taken from the first list, then the first element from the second list, and then the first element from the third list. 2. The process repeats with the second elements of each list, continuing in a round-robin fashion. 3. Once a list is exhausted, continue traversal with the remaining lists until all elements are returned. # Performance Requirements - Ensure that `next` and `has_next` operations are efficient. - Optimize for minimal memory usage and maximum speed.","solution":"from collections import deque class ZigZagIterator: def __init__(self, lists): Initialize the ZigZagIterator with an arbitrary number of lists. self.queue = deque([(i, 0) for i, lst in enumerate(lists) if lst]) self.lists = lists def next(self): Return the next element in the zigzag order. if not self.has_next(): return None i, j = self.queue.popleft() next_val = self.lists[i][j] if j + 1 < len(self.lists[i]): self.queue.append((i, j + 1)) return next_val def has_next(self): Return True if there are more elements to traverse, else False. return bool(self.queue)"},{"question":"# HTML5 Validation - Form File Path Resolver Context In a new web-based application, you need to ensure that any file paths submitted through forms are correctly resolved to their absolute forms before processing them. The requirement is particularly important because users may provide relative paths or use the tilde (`~`) to refer to their home directories. Task Write a function `validate_file_path` that will take a relative or user-relative file path and return its absolute path. Additionally, the function should return `None` if the input is not a valid string. # Requirements * Input - A single string representing the file path. * Output - A string representing the absolute file path or `None` if the input is invalid. # Constraints 1. If the function is passed an empty string or non-string input, it should return `None`. 2. Use Python\'s standard library functions `os.path.expanduser` and `os.path.abspath` for resolving paths. 3. Assume the validity and existence of the user\'s home directory. # Example ```python assert validate_file_path(\\"~/documents/myfile.txt\\") == \\"/home/user/documents/myfile.txt\\" # Example absolute path assert validate_file_path(\\"src/../README.md\\") == \\"/full/path/to/current/dir/README.md\\" assert validate_file_path(\\"\\") == None assert validate_file_path(12345) == None ``` Your implementation helps ensure robust handling of user-submitted file paths in a consistent manner.","solution":"import os def validate_file_path(path): Takes a relative or user-relative file path and returns its absolute path. Returns None if the input is not a valid string. :param path: str - The file path to resolve :return: str or None - The absolute file path or None if input is invalid if not isinstance(path, str) or path == \\"\\": return None return os.path.abspath(os.path.expanduser(path))"},{"question":"# Coding Exercise: Reverse Words in a String Objective Implement a function that takes a string as input and returns the string with the order of the words reversed. Description You need to write a function `reverse_sentence(sentence: str) -> str` that reverses the order of the words in the given sentence. Words are defined as sequences of non-space characters separated by spaces. Input * A single string `sentence` (1 <= len(sentence) <= 10^4) which may contain letters (both uppercase and lowercase) and spaces. Leading and trailing spaces should be ignored. Words will be separated by single spaces. Output * A single string with the words reversed while maintaining the single space between the words. Constraints * You must not use built-in functions that directly reverse the order of elements. * Your solution should handle edge cases gracefully and maintain efficiency in both time and space. Example ```python def reverse_sentence(sentence: str) -> str: # Your implementation here # Example 1: # Input: \\"The sky is blue\\" # Output: \\"blue is sky The\\" # Example 2: # Input: \\" hello world \\" # Output: \\"world hello\\" # Example 3: # Input: \\"a good example\\" # Output: \\"example good a\\" if __name__ == \\"__main__\\": test1 = \\"The sky is blue\\" print(reverse_sentence(test1)) # Output: \\"blue is sky The\\" test2 = \\" hello world \\" print(reverse_sentence(test2)) # Output: \\"world hello\\" test3 = \\"a good example\\" print(reverse_sentence(test3)) # Output: \\"example good a\\" ``` Consider fundamental and advanced parts of coding to ensure efficiency and correct handling of edge cases in your implementation. Analyze the complexity of your solution to ensure it adheres to the given constraints.","solution":"def reverse_sentence(sentence: str) -> str: Reverses the order of words in a given sentence. # Split the sentence into words words = sentence.strip().split() # Reverse the list of words reversed_words = [] for word in words: reversed_words.insert(0, word) # Join the reversed words into a single string reversed_sentence = \' \'.join(reversed_words) return reversed_sentence"},{"question":"You are required to implement a function `limit` that filters the elements of a given list to remain within the specified inclusive range [min_lim, max_lim]. The function signature is: ```python def limit(arr: list[int], min_lim: int = None, max_lim: int = None) -> list[int]: ``` # Input * `arr` is a list of integers. * `min_lim` (Optional) is an integer or None. If None, `min_lim` defaults to the minimum value in `arr`. * `max_lim` (Optional) is an integer or None. If None, `max_lim` defaults to the maximum value in `arr`. # Output * The function should return a list of integers that only contains values between `min_lim` and `max_lim` inclusive. # Constraints * The input list `arr` has a size of at most 10^6. * Values in `arr` are between -10^6 and 10^6. * `min_lim` and `max_lim`, if provided, will lie within the same range as `arr`. # Example ```python # Example 1: arr = [1, 2, 3, 4, 5] min_lim = None max_lim = 3 # Should return [1, 2, 3] print(limit(arr, min_lim, max_lim)) # Example 2: arr = [7, 8, 5, 10, 12] min_lim = 6 max_lim = None # Should return [7, 8, 10, 12] print(limit(arr, min_lim, max_lim)) # Example 3: arr = [5, 15, 25, 35, 45] min_lim = 20 max_lim = 40 # Should return [25, 35] print(limit(arr, min_lim, max_lim)) ``` # Notes * Handle edge cases such as empty input arrays by returning an empty list. * Ensure your function has a time complexity of O(n).","solution":"def limit(arr: list[int], min_lim: int = None, max_lim: int = None) -> list[int]: Filters the elements of a given list to remain within the specified inclusive range [min_lim, max_lim]. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"Reverse Words in a Sentence Context: You are developing a text processing tool that needs to perform various string manipulations. One of the functionalities required is to reverse each word in a sentence while retaining the original word order. To better understand different approaches and their efficiencies, you will implement several string reversal algorithms. Question: Write a function `reverse_words(sentence)` that accepts a string `sentence` and returns a new string where each word in the `sentence` is reversed, but the order of the words remains the same. Each word is defined as a sequence of non-space characters, while words are separated by one or more spaces. Input: - `sentence` (string): A sentence containing words separated by spaces. The length of `sentence` is between 0 and 10^4. Output: - (string): A string where each word is reversed but the word order is unchanged. Constraints: - You must implement string reversal using an iterative approach. Example: ```python Input: \\"Hello world\\" Output: \\"olleH dlrow\\" Input: \\"This is an example\\" Output: \\"sihT si na elpmaxe\\" Input: \\"foo bar\\" Output: \\"oof rab\\" Input: \\" \\" Output: \\" \\" ``` Additional Notes: - Consider edge cases such as empty strings, single character words, and multiple spaces between words. - Optimize your solution for both time and space complexity. - You are only allowed to use built-in string methods for basic operations like slicing, but not for direct reversal. ```python def reverse_words(sentence): # Your code here ```","solution":"def reverse_words(sentence): Reverses each word in the sentence while keeping the word order the same. Args: - sentence (str): The sentence to process. Returns: - str: A new string with each word reversed. words = sentence.split(\' \') reversed_words = [\'\'.join(reversed(word)) for word in words] return \' \'.join(reversed_words)"},{"question":"# Merge Two Sorted Linked Lists You are given two sorted linked lists. Write a function to merge these two lists into one sorted linked list and return the head of the new list. Input * `l1`: The head node of the first sorted linked list. * `l2`: The head node of the second sorted linked list. Output * The head of the merged sorted linked list. Constraints * Each linked list can have between 0 and 1000 nodes. * Each node\'s value is an integer between -10^5 and 10^5. * The list is sorted in non-decreasing order. Performance Requirements * Aim to complete the task in O(n + m) time complexity. * Minimize extra space usage. Example **Input:** ``` List 1: 1 -> 2 -> 4 List 2: 1 -> 3 -> 4 ``` **Output:** ``` Merged List: 1 -> 1 -> 2 -> 3 -> 4 -> 4 ``` Note: Ensure to handle edge cases where one or both of the linked lists are empty.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1, l2): # Create a dummy node to help with the merge process dummy = ListNode(-1) current = dummy # While both linked lists have nodes left to compare while l1 and l2: if l1.val <= l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # If there are remaining nodes in either list, append them current.next = l1 if l1 else l2 # Return the merged list (skipping the dummy node) return dummy.next"},{"question":"# Question: You are given an array of integers which may contain duplicate elements. Your task is to implement the `cycle_sort` function that sorts the array in place with minimal write operations, leveraging the principles of the Cycle Sort algorithm. **Function Signature**: ```python def cycle_sort(arr: List[int]) -> List[int]: ``` # Input: * `arr`: A list of integers (Array) where (1 leq len(arr) leq 10^5) * The elements in the array can be negative, positive, and include zero. # Output: * The function should return the sorted array. # Constraints: * You must minimize the number of write operations to the array. * Time complexity should be (O(N^2)) in the average and worst case. * The sorting must be done in place with (O(1)) auxiliary space. # Example: ```python arr = [3, 1, 4, 1, 5] print(cycle_sort(arr)) # Output: [1, 1, 3, 4, 5] ``` # Notes: * You must handle duplicates correctly and ensure they are placed adjacently in the sorted order. * Pay close attention to writing only when necessary to adhere to the Cycle Sort principles. * Consider edge cases such as arrays that are already sorted or contain all duplicates. # Assessment Criteria: 1. Correctness: The returned array must be sorted correctly. 2. Efficiency: The implementation should maintain (O(N^2)) time complexity and (O(1)) space complexity. 3. Code Quality: The code should be well-documented, readable, and follow good programming practices.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: n = len(arr) # Loop through the array to find cycles to rotate. for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find where to place the item. pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position, continue. if pos == cycle_start: continue # Skip all duplicate elements while item == arr[pos]: pos += 1 # Place the item to the correct position if pos != cycle_start: arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 if item != arr[pos]: arr[pos], item = item, arr[pos] return arr"},{"question":"# Question: Implement an Efficient Sorting Algorithm with Random Appearance Given the structure of Bogo Sort, your task is to implement a more efficient sorting algorithm that preserves the playful spirit of randomness but achieves a much better time complexity. You need to implement a sorting function using the Quick Sort algorithm, but with a twist: you should always pivot around a randomly selected element. Requirements: - Implement the Quick Sort algorithm. - Use a randomly chosen pivot element at each step. - Ensure the algorithm sorts the array in ascending order. - The input will be a list of integers. - The output should be a sorted list of those integers. Input/Output Format: - **Input**: A list of integers, e.g., `[3, 6, 1, 2, 9]` - **Output**: A sorted list of integers, e.g., `[1, 2, 3, 6, 9]` Constraints: - You can assume the list will always contain integers. - The list size `n` will be such that (0 leq n leq 10^5). Performance Requirements: - Aim for an average-case time complexity of (O(n log n)). Edge Cases: - Consider an already sorted array. - Handle cases where the array contains duplicate values. - Handle an empty array. Function Signature: ```python def random_pivot_quick_sort(arr: list) -> list: pass ```","solution":"import random def random_pivot_quick_sort(arr): Sorts an array of integers using the Quick Sort algorithm with a randomly selected pivot. Parameters: arr (list): A list of integers to be sorted. Returns: list: A sorted list of integers. if len(arr) <= 1: return arr pivot_index = random.randint(0, len(arr) - 1) pivot = arr[pivot_index] less_than_pivot = [x for x in arr if x < pivot] equal_to_pivot = [x for x in arr if x == pivot] greater_than_pivot = [x for x in arr if x > pivot] return random_pivot_quick_sort(less_than_pivot) + equal_to_pivot + random_pivot_quick_sort(greater_than_pivot)"},{"question":"Context You are a developer working on image processing software. The software uses a feature where colors are represented by certain values in an array. Your task is to ensure that the colors are sorted and grouped efficiently for better processing. Task Write a function named `sort_colors` that takes an unsorted list `nums` containing integers 0, 1, and 2, and sorts the list in-place so that all 0s come first, all 1s come next, and all 2s come last. Function Signature ```python def sort_colors(nums: List[int]) -> None: Modify the list nums in-place to sort the elements. ``` Input - `nums` (List[int]): A list of integers where each integer is either 0, 1, or 2. Output - The function modifies the list `nums` in-place to be sorted. It does not return any value. Constraints - The length of the list `nums` will be in the range [1, 300]. - The values in the list `nums` will be either 0, 1, or 2. Examples 1. **Example 1** - Input: `nums = [2, 0, 2, 1, 1, 0]` - Output: `[0, 0, 1, 1, 2, 2]` 2. **Example 2** - Input: `nums = [2, 0, 1]` - Output: `[0, 1, 2]` 3. **Example 3** - Input: `nums = [0]` - Output: `[0]` Notes - You are not supposed to use the library\'s sort function for this problem. - Ensure your solution maintains O(n) time complexity and uses O(1) extra space.","solution":"def sort_colors(nums): Modify the list nums in-place to sort the elements. low = 0 high = len(nums) - 1 current = 0 while current <= high: if nums[current] == 0: nums[low], nums[current] = nums[current], nums[low] low += 1 current += 1 elif nums[current] == 2: nums[high], nums[current] = nums[current], nums[high] high -= 1 else: current += 1"},{"question":"# Palindrome Doubly Linked List Given a doubly linked list, your task is to implement a function `is_palindrome_doubly(head)` that determines if the list is a palindrome. In a doubly linked list, each node has a reference to both the next and the previous node. This provides flexibility to traverse the list from both ends. Input * A `ListNode` representing the head of a doubly linked list. Each `ListNode` has `val`, `next`, and `prev` attributes. Output * Return `True` if the list is a palindrome, `False` otherwise. Constraints * You must solve this problem in O(n) time complexity. * Do not use any additional data structures that take O(n) extra space. * Ensure to properly handle edge cases such as empty lists, single-node lists, and lists with repeated values. Example ```python class ListNode: def __init__(self, x): self.val = x self.next = None self.prev = None # Example linked list: 1 <-> 2 <-> 3 <-> 2 <-> 1 head = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(2) node5 = ListNode(1) head.next = node2 node2.prev = head node2.next = node3 node3.prev = node2 node3.next = node4 node4.prev = node3 node4.next = node5 node5.prev = node4 assert is_palindrome_doubly(head) == True node6 = ListNode(4) node5.next = node6 node6.prev = node5 assert is_palindrome_doubly(head) == False ```","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None self.prev = None def is_palindrome_doubly(head): Determine if the doubly linked list is a palindrome. :param head: The head of the doubly linked list. :return: True if the list is a palindrome, False otherwise. if not head: return True # Find the tail of the doubly linked list tail = head while tail.next: tail = tail.next # Use two pointers to compare values from head and tail while head != tail and head.prev != tail: if head.val != tail.val: return False head = head.next tail = tail.prev return True"},{"question":"Implement a class `Polynomial` that models mathematical polynomial expressions. The class should support: - Creating a polynomial from a list of monomials. - Adding, subtracting, multiplying, and dividing two polynomials or a polynomial by a monomial/scalar. - Evaluating the polynomial for given substitutions of its variables. # Requirements - The class should allow initialization with an iterable of monomials. A monomial is represented as a dictionary with variable indices mapped to their integer exponents and a scalar coefficient. - Implement the following methods: - `__init__(self, monomials)` - `__add__(self, other)` - `__sub__(self, other)` - `__mul__(self, other)` - `__truediv__(self, other)` - `subs(self, substitutions)` - `__eq__(self, other)` - `__str__(self)` # Constraints - Monomials and scalars in arithmetic operations are limited to integers, floating-point numbers, or fractions. - You need to handle addition, subtraction, multiplication, and division with careful consideration for compatibility of monomials. - Represent a zero polynomial appropriately with no monomials. # Example Given the initial set of monomials: `[{1:1, 2:2}, {2:3}]` The polynomial `\\"P\\"` would be: `\\"(a_1)(a_2)^2 + (a_2)^3\\"` Evaluation Example: - Variables and substitutions: - `a_1=2, a_2=3` - Evaluating `P` would result in: - `2*(3**2) + (3**3) = 18 + 27 = 45` Use the provided `Monomial` class as demonstrated in the snippet as a base for implementing your `Polynomial` class. # Task Implement the `Polynomial` class in Python adhering to the above requirements, constraints, and examples. Ensure to test the class with some sample polynomials and operations.","solution":"from collections import defaultdict from functools import reduce from operator import mul class Polynomial: def __init__(self, monomials): Initializes a polynomial. :param monomials: A list of monomials which are dictionaries where keys are variable indices and values are their respective exponents. self.monomials = monomials def __add__(self, other): if not isinstance(other, Polynomial): raise TypeError(\\"Can only add Polynomial with another Polynomial\\") return Polynomial(self.monomials + other.monomials) def __sub__(self, other): if not isinstance(other, Polynomial): raise TypeError(\\"Can only subtract Polynomial with another Polynomial\\") negated_monomials = [{k: v for k, v in mono.items()} for mono in other.monomials] for n_mono in negated_monomials: n_mono[\'coef\'] = -n_mono[\'coef\'] return Polynomial(self.monomials + negated_monomials) def __mul__(self, other): if isinstance(other, (int, float)): new_monomials = [{k: v for k, v in mono.items()} for mono in self.monomials] for n_mono in new_monomials: n_mono[\'coef\'] *= other return Polynomial(new_monomials) elif isinstance(other, Polynomial): new_monomials = [] for self_mono in self.monomials: for other_mono in other.monomials: new_mono = defaultdict(int) new_mono[\'coef\'] = self_mono[\'coef\'] * other_mono[\'coef\'] for var, exp in self_mono.items(): if var != \'coef\': new_mono[var] += exp for var, exp in other_mono.items(): if var != \'coef\': new_mono[var] += exp new_monomials.append(new_mono) return Polynomial(new_monomials) else: raise TypeError(\\"Unsupported type for multiplication\\") def __truediv__(self, other): if not isinstance(other, (int, float)): raise TypeError(\\"Can only divide Polynomial by scalar (int or float)\\") new_monomials = [{k: v for k, v in mono.items()} for mono in self.monomials] for n_mono in new_monomials: n_mono[\'coef\'] /= other return Polynomial(new_monomials) def subs(self, substitutions): total = 0 for mono in self.monomials: value = mono[\'coef\'] for var, exp in mono.items(): if var != \'coef\': value *= substitutions[var] ** exp total += value return total def __eq__(self, other): if not isinstance(other, Polynomial): return False return self.monomials == other.monomials def __str__(self): parts = [] for mono in self.monomials: term = [f\\"{mono[\'coef\']}\\"] for var, exp in mono.items(): if var != \'coef\': term.append(f\\"a_{var}^{exp}\\") parts.append(\'*\'.join(term)) return \' + \'.join(parts) # Example: # [{1:1, 2:2, \'coef\':1}, {2:3, \'coef\':1}] # Would represent P: a_1^1*a_2^2 + a_2^3"},{"question":"# Question: Implement a Custom String Reversal Function You are part of a development team creating a library for various string manipulations. Your task is to implement a function that reverses a given string without using Python\'s built-in slicing or `reversed()` functions. You should not use recursion to avoid high memory usage for long strings. **Objective**: Implement a function using an iterative approach. Function Signature ```python def reverse_string(s: str) -> str: pass ``` Input * A string `s` (1 ≤ |s| ≤ 10^7): the string to reverse. Output * A string that is the reverse of `s`. Example ```python assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"\\") == \\"\\" assert reverse_string(\\"a\\") == \\"a\\" assert reverse_string(\\"abcde\\") == \\"edcba\\" assert reverse_string(\\"racecar\\") == \\"racecar\\" ``` Constraints * Do not use built-in slicing (`s[::-1]`), `reversed()` or recursion. * Your solution should handle strings up to 10^7 characters efficiently. Notes * Consider potential edge cases such as empty strings, single-character strings, and very large strings. * Focus on an iterative approach that runs in linear time (O(n)) and uses constant additional space (O(1)).","solution":"def reverse_string(s: str) -> str: Reverses the given string without using built-in slicing or reversed() functions, and without recursion. # Initialize an empty list to hold the reversed characters reversed_str = [] # Iterate over the characters in the string from end to start for char in reversed(s): reversed_str.append(char) # Join the list back into a string and return return \'\'.join(reversed_str)"},{"question":"Enhance Cocktail Shaker Sort with Improved Efficiency Given an array of integers, you need to implement a modified version of the Cocktail Shaker Sort algorithm that stops early if the array is already sorted during any complete pass. Function Signature: ```python def efficient_cocktail_shaker_sort(arr: List[int]) -> List[int]: pass ``` Input: - A list of integers `arr` with up to (10^4) elements. Output: - A list of integers that is sorted in ascending order. Performance Requirements: - Best possible time complexity: O(N) when the array is already sorted or nearly sorted. - Average case: O(N^2). Constraints: - Elements of the array can range from (-10^4) to (10^4). # Example: ```python assert efficient_cocktail_shaker_sort([3, 2, 1, 5, 4]) == [1, 2, 3, 4, 5] assert efficient_cocktail_shaker_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert efficient_cocktail_shaker_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert efficient_cocktail_shaker_sort([5, 5, 5, 5, 5]) == [5, 5, 5, 5, 5] ``` # Detailed Context: Cocktail Shaker Sort, sometimes known as bidirectional bubble sort, is an enhancement over the standard bubble sort. Although it has similar O(N^2) complexity, it can outperform bubble sort by stopping early on partially sorted arrays. Your task is to demonstrate understanding and improve the provided algorithm by implementing an early exit strategy. The function should exit the loop when no swaps occur in a complete forward and backward pass, thus optimizing the sorting process. **Note**: You are not required to use any library functions. Implement the algorithm from scratch.","solution":"from typing import List def efficient_cocktail_shaker_sort(arr: List[int]) -> List[int]: A modified version of the Cocktail Shaker Sort that stops early if the array is already sorted during any complete pass. n = len(arr) start = 0 end = n - 1 while start < end: swapped = False # Traverse the array from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If no elements were swapped in this traversal, the array is sorted if not swapped: break # Update end pointer, last element is in correct position end -= 1 swapped = False # Traverse the array from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True # If no elements were swapped in this traversal, the array is sorted if not swapped: break # Update start pointer, first element is in correct position start += 1 return arr"},{"question":"You are required to implement a function `in_order_traversal_with_colors` that performs an in-order traversal of a Red-Black Tree and returns the node values along with their colors in a specific format. This will help in verifying the tree structure and ensuring that the Red-Black properties are maintained. # Function Signature ```python def in_order_traversal_with_colors(tree: RBTree) -> List[Dict[str, int]]: pass ``` # Input - `tree`: An instance of the `RBTree` class representing the Red-Black Tree. # Output - Return a list of dictionaries, each representing a node. Each dictionary has keys: - `val`: The value of the node. - `color`: The color of the node (0 for black, 1 for red). # Constraints - The tree will have at least one node and no more than (10^5) nodes. - The color values will always be either 0 or 1. - The input tree will always be a valid Red-Black Tree. # Example Input: ```python rb = RBTree() children = [10, 5, 20, 3, 7, 15, 25] for child in children: node = RBNode(child, 1) rb.insert(node) ``` Call: ```python result = in_order_traversal_with_colors(rb) ``` Output: ```python [ {\'val\': 3, \'color\': 0}, {\'val\': 5, \'color\': 1}, {\'val\': 7, \'color\': 0}, {\'val\': 10, \'color\': 0}, {\'val\': 15, \'color\': 1}, {\'val\': 20, \'color\': 0}, {\'val\': 25, \'color\': 1} ] ``` (Note: The specific coloring may vary depending on the sequence of insertions and the self-balancing operations.) # Explanation Given a Red-Black Tree, the function performs an in-order traversal to return each node\'s value and color, allowing for easy verification of the tree\'s properties.","solution":"from typing import List, Dict class RBNode: def __init__(self, val, color, left=None, right=None): self.val = val self.color = color # 0 for black, 1 for red self.left = left self.right = right class RBTree: def __init__(self): self.root = None def insert(self, node: RBNode): if not self.root: self.root = node # Always make the root black self.root.color = 0 else: self._insert(self.root, node) self.root.color = 0 def _insert(self, current, node): if node.val < current.val: if current.left: self._insert(current.left, node) else: current.left = node else: if current.right: self._insert(current.right, node) else: current.right = node # Here we would have logic for fixing the tree to maintain RBT properties, # but this is omitted for brevity as it is not needed for the traversal function. def in_order_traversal_with_colors(tree: RBTree) -> List[Dict[str, int]]: def in_order_traversal(node): if node: in_order_traversal(node.left) result.append({\\"val\\": node.val, \\"color\\": node.color}) in_order_traversal(node.right) result = [] in_order_traversal(tree.root) return result"},{"question":"Implement an extendable circular buffer using the principles of the given hash table. A circular buffer (also ring buffer) is a fixed-size data structure that uses a single, fixed-size buffer as if it were connected end-to-end. Instructions: 1. **Initialize**: Your circular buffer should start with a given size. 2. **Put**: Implement a method to add an item into the buffer. If the buffer is full, the oldest item should be overwritten. 3. **Get**: Implement a method to retrieve an item by its index. 4. **Size**: Implement a method to get the current number of items in the buffer. 5. **Full**: Implement a method to check if the buffer is full. 6. **Empty**: Implement a method to check if the buffer is empty. Expected Function Signatures: ```python class CircularBuffer: def __init__(self, size: int): Initializes the CircularBuffer with given size. # Your code here def put(self, item): Add an item into the buffer. If the buffer is full, overwrite the oldest item. # Your code here def get(self, index: int): Get the item by its index. # Your code here def size(self) -> int: Return the current number of items in the buffer. # Your code here def full(self) -> bool: Return True if the buffer is full, False otherwise. # Your code here def empty(self) -> bool: Return True if the buffer is empty, False otherwise. # Your code here ``` Example Usage: ```python cb = CircularBuffer(3) cb.put(1) cb.put(2) cb.put(3) print(cb.get(0)) # Output: 1 print(cb.size()) # Output: 3 cb.put(4) print(cb.get(0)) # Output: 4 // Since 1 is overwritten by 4 print(cb.full()) # Output: True print(cb.empty()) # Output: False ``` Your implementation should be efficient in terms of both time and space.","solution":"class CircularBuffer: def __init__(self, size: int): Initializes the CircularBuffer with given size. self.buffer = [None] * size self.size_limit = size self.start = 0 self.end = 0 self.count = 0 def put(self, item): Add an item into the buffer. If the buffer is full, overwrite the oldest item. self.buffer[self.end] = item self.end = (self.end + 1) % self.size_limit if self.count < self.size_limit: self.count += 1 else: self.start = (self.start + 1) % self.size_limit def get(self, index: int): Get the item by its index. if index < 0 or index >= self.count: raise IndexError(\\"Index out of bounds\\") return self.buffer[(self.start + index) % self.size_limit] def size(self) -> int: Return the current number of items in the buffer. return self.count def full(self) -> bool: Return True if the buffer is full, False otherwise. return self.count == self.size_limit def empty(self) -> bool: Return True if the buffer is empty, False otherwise. return self.count == 0"},{"question":"You are setting up a lab experiment with a particular type of scientific egg, where you can drop the egg from any floor of a building to test its fragility. There are `N` floors in the building and `K` identical eggs available for the experiments. The goal is to find out the highest floor from which an egg can be dropped without breaking, with certainty and in the minimum number of moves. Requirements Write a function `min_moves` that takes two integers, `N` (number of floors) and `K` (number of eggs), and returns the minimum number of moves needed in the worst-case scenario to determine the critical floor. # Function Signature ```python def min_moves(N: int, K: int) -> int: pass ``` Input * `N` - an integer (1 ≤ N ≤ 10^3), representing the number of floors. * `K` - an integer (1 ≤ K ≤ 10^2), representing the number of eggs. Output * An integer representing the minimum number of moves required to find the critical floor with certainty. Example: ```python print(min_moves(2, 1)) # Output: 2 print(min_moves(10, 2)) # Output: 4 ``` Constraints: * You may use a 2D DP table/extra space to store intermediate results. * You must complete the function within a time complexity of O(N * K^2) or better. Detailed Explanation: 1. Start by creating a 2D table `egg_floor` where `egg_floor[i][j]` represents the minimum number of moves needed for `i` eggs and `j` floors. 2. Initialize the base cases for one egg and zero floors. 3. Use nested loops to fill in the table by solving smaller subproblems. 4. In each iteration, compute moves by considering dropping an egg from each floor separately and use the results from already computed subproblems. 5. Return the minimum number of moves required from the filled table. Develop an efficient solution, considering edge cases and performance constraints.","solution":"def min_moves(N: int, K: int) -> int: # Create a table to store the results of subproblems egg_floor = [[0 for x in range(N + 1)] for x in range(K + 1)] # Base case: With one egg, we need i trials at worst-case for i floors for i in range(1, N + 1): egg_floor[1][i] = i for e in range(2, K + 1): for f in range(1, N + 1): egg_floor[e][f] = float(\'inf\') for x in range(1, f + 1): res = 1 + max(egg_floor[e - 1][x - 1], egg_floor[e][f - x]) if res < egg_floor[e][f]: egg_floor[e][f] = res return egg_floor[K][N]"},{"question":"You are tasked with implementing a pair of functions to serialize and deserialize a binary tree. Serialization is the process of converting a tree into a string representation, while deserialization is the inverse process of converting the string back into the tree. Function Definitions 1. **serialize(root: TreeNode) -> str**: This function takes the root of a binary tree and converts it into a string representation using pre-order traversal. 2. **deserialize(data: str) -> TreeNode**: This function takes a string representation of a tree and reconstructs the original binary tree. Input and Output Formats - **serialize(root)**: - **Input**: A binary tree root node (`TreeNode`). - **Output**: A string representing the serialized tree. - **deserialize(data)**: - **Input**: A string representing the serialized tree. - **Output**: The root of the binary tree (`TreeNode`). Constraints - Values of the TreeNode are integers. - The serialized string will not exceed 10^4 characters. - You may assume that the deserialization input is properly formatted. Example Suppose the following binary tree is given: ``` 1 / 2 3 / 4 5 ``` **serialize(root)** should return: `\\"1 2 # # 3 4 # # 5 # #\\"`. **deserialize(\\"1 2 # # 3 4 # # 5 # #\\")** should reconstruct the original tree. **Edge Case**: - Serializing an empty tree should return `\\"#\\"`. - Deserialization should handle the string `\\"#\\"` properly by returning `None`. Implement both functions, ensuring they handle edge cases and maintain the correct relationships between tree nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root: TreeNode) -> str: Encodes a tree to a single string. def preorder(node): if node: result.append(str(node.val)) preorder(node.left) preorder(node.right) else: result.append(\\"#\\") result = [] preorder(root) return \' \'.join(result) def deserialize(data: str) -> TreeNode: Decodes your encoded data to tree. def preorder(): val = next(values) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = preorder() node.right = preorder() return node values = iter(data.split()) return preorder()"},{"question":"# Hash Table with Separate Chaining You are tasked with implementing a hash table using separate chaining to handle collisions with linked lists. Your implementation should support the following operations: 1. Inserting a key-value pair. 2. Fetching a value by key. 3. Deleting a key-value pair by key. 4. Checking the number of elements stored in the hash table. 5. Support dynamic resizing to maintain performance under high load. # Requirements 1. **Class Name:** `SeparateChainingHashTable` 2. **Main Methods:** - `put(key, value)`: Inserts or updates a key-value pair. - `get(key)`: Retrieves value associated with the key, or `None` if the key doesn\'t exist. - `del_(key)`: Deletes the key-value pair by key. Does nothing if the key is not found. - `__len__()`: Returns the number of key-value pairs in the hash table. - `resize(new_size)`: Resizes the underlying array to `new_size`, rehashing all keys. # Input/Output Examples ```python # Example usage: table = SeparateChainingHashTable() table.put(\'one\', 1) table.put(\'two\', 2) print(table.get(\'one\')) # Output: 1 print(len(table)) # Output: 2 table.del_(\'one\') print(table.get(\'one\')) # Output: None print(len(table)) # Output: 1 ``` # Constraints 1. All keys are assumed to be strings and values can be of any type. 2. Initially, the hash table should have a fixed number of buckets (suggested: 11). 3. The hash table should resize dynamically when the load factor exceeds a certain threshold (suggested: 0.75). # Performance Requirements - Ensure average-case time complexity for insertion, retrieval, and deletion remains O(1). - Handle collisions effectively using separate chaining. - Upon resizing, all keys must be rehashed correctly. Implement this class and ensure it passes the provided unit tests.","solution":"class SeparateChainingHashTable: def __init__(self, initial_capacity=11, load_factor_threshold=0.75): self.buckets = [[] for _ in range(initial_capacity)] self.size = 0 self.load_factor_threshold = load_factor_threshold def _hash(self, key): return hash(key) % len(self.buckets) def put(self, key, value): index = self._hash(key) bucket = self.buckets[index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.size += 1 if self.size / len(self.buckets) > self.load_factor_threshold: self.resize(len(self.buckets) * 2) def get(self, key): index = self._hash(key) bucket = self.buckets[index] for k, v in bucket: if k == key: return v return None def del_(self, key): index = self._hash(key) bucket = self.buckets[index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.size -= 1 return def __len__(self): return self.size def resize(self, new_size): old_buckets = self.buckets self.buckets = [[] for _ in range(new_size)] self.size = 0 for bucket in old_buckets: for key, value in bucket: self.put(key, value)"},{"question":"The task is to implement a function that limits the occurrences of each element in a given list to at most N times while preserving the original order of elements. Function Signature ```python def limit_occurrences(lst: list, n: int) -> list: ``` # Input: * A list of integers `lst`. * An integer `n` (0 ≤ n ≤ 1000) representing the maximum number of times any element can appear in the resulting list. # Output: * A list of integers where each element from the input list appears at most N times and the order is preserved. # Constraints: * The list `lst` will have up to 100,000 elements. * The integers in `lst` can range from -1000 to 1000. # Performance Requirements The solution should efficiently handle lists with up to 100,000 elements, aiming for a time complexity of O(n). # Example: ```python assert limit_occurrences([1, 2, 3, 1, 2, 1, 2, 3], 2) == [1, 2, 3, 1, 2, 3] assert limit_occurrences([1, 2, 3, 1, 2, 1, 2, 3], 0) == [] assert limit_occurrences([1, 1, 1, 2, 2, 3, 3, 3], 1) == [1, 2, 3] assert limit_occurrences([], 1) == [] assert limit_occurrences([1], 2) == [1] ``` Write your function implementation below: ```python def limit_occurrences(lst, n): import collections result = [] counts = collections.defaultdict(int) for i in lst: if counts[i] < n: result.append(i) counts[i] += 1 return result ```","solution":"def limit_occurrences(lst, n): import collections result = [] counts = collections.defaultdict(int) for i in lst: if counts[i] < n: result.append(i) counts[i] += 1 return result"},{"question":"# Cycle Detection in Directed Graph **Objective:** Write a function to detect if a directed graph contains a cycle. Use Depth-First Search (DFS) and state enumeration to identify cycles. **Input Format:** * A directed graph represented as a dictionary where keys are node identifiers (strings) and values are lists of identifiers of neighboring nodes. **Output Format:** * Return `True` if the graph contains a cycle, otherwise return `False`. **Constraints:** * All node identifiers are unique. * No duplicate edges. * The graph follows proper directed graph properties. **Function Signature:** ```python def contains_cycle(graph): Determines if there is a cycle in the given directed graph. Parameters: graph (dict): A dictionary representing the graph where the keys are node identifiers and the values are lists of neighboring node identifiers. Returns: bool: True if there is a cycle in the graph, False otherwise. ``` **Example:** ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } assert contains_cycle(graph) == True graph_no_cycle = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [] } assert contains_cycle(graph_no_cycle) == False ``` **Scenario:** Imagine you are a system administrator and you need to check for potential deadlocks in your system\'s process graph. Each process is represented by a node and dependencies by directed edges. Writing a function to identify cycles can help you detect deadlocks, ensuring smooth operation without deadlock issues. Implement the required function to help identify these cycles.","solution":"def contains_cycle(graph): Determines if there is a cycle in the given directed graph. Parameters: graph (dict): A dictionary representing the graph where the keys are node identifiers and the values are lists of neighboring node identifiers. Returns: bool: True if there is a cycle in the graph, False otherwise. def dfs(node, visited, rec_stack): # mark the current node as visited and add it to the recursion stack visited.add(node) rec_stack.add(node) # check all neighbors for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True # remove the node from the recursion stack before exiting rec_stack.remove(node) return False visited = set() rec_stack = set() # check for cycles starting from each node for node in graph: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"You are tasked with implementing a more efficient priority queue by utilizing a binary heap instead of a linear array to improve the performance of the insertion operation. # Function Signature: ```python class BinaryHeapPriorityQueue: def __init__(self): # Initialize an empty priority queue self.heap = [] def push(self, item, priority): # Insert an element with a given priority pass def pop(self): # Remove and return the element with the highest priority pass def size(self): # Return the number of elements in the priority queue pass ``` # Input/Output Format: * **push() method:** * **Input**: `push(\\"task\\", 1)` where the first argument is the element to insert and the second argument is its priority. * **Output**: No output; the element should be added to the priority queue. * **pop() method:** * **Input**: `pop()` * **Output**: Returns the element with the highest priority. * **size() method:** * **Input**: `size()` * **Output**: Returns an integer value representing the number of elements in the priority queue. # Constraints: 1. The priority queue can hold a maximum of 10,000 elements. 2. All priorities will be positive integers. 3. No two elements will have the same priority. # Performance Requirements: * Insertion (push) should be performed in O(log n) time, where n is the number of elements in the priority queue. * Removal (pop) should also be performed in O(log n) time. # Example: ```python pq = BinaryHeapPriorityQueue() pq.push(\\"task1\\", 5) pq.push(\\"task2\\", 3) pq.push(\\"task3\\", 9) print(pq.size()) # Output: 3 print(pq.pop()) # Output: task3 print(pq.size()) # Output: 2 print(pq.pop()) # Output: task1 ``` You must use a binary heap to manage the underlying elements of the priority queue to ensure efficient operations as described.","solution":"import heapq class BinaryHeapPriorityQueue: def __init__(self): # Initialize an empty priority queue using a binary heap self.heap = [] def push(self, item, priority): # Insert an element with a given priority # priority is negated to use heapq as a max-heap heapq.heappush(self.heap, (-priority, item)) def pop(self): # Remove and return the element with the highest priority if self.size() == 0: return None return heapq.heappop(self.heap)[1] def size(self): # Return the number of elements in the priority queue return len(self.heap) # Example usage: # pq = BinaryHeapPriorityQueue() # pq.push(\\"task1\\", 5) # pq.push(\\"task2\\", 3) # pq.push(\\"task3\\", 9) # print(pq.size()) # Output: 3 # print(pq.pop()) # Output: task3 # print(pq.size()) # Output: 2 # print(pq.pop()) # Output: task1"},{"question":"# Coding Challenge Scenario You are developing a web application that needs to analyze URLs and extract their domain names. To test students\' understanding and implementation skills in string manipulation, write a function to parse and extract the domain name from given URLs. Question Implement a function `extract_domain(url: str) -> str` that, given a URL as a string, returns the domain name. Input - A single string `url` representing a URL. The URL can include protocols (`http`, `https`), `www`, and could be well-formed. Output - A string representing the domain name extracted from the URL. Constraints - The input URL will be a non-empty string. - The input URLs will be well-formed as assumed (they will not contain query strings, fragments, or authentication information). Examples ```python extract_domain(\\"http://github.com/SaadBenn\\") == \\"github\\" extract_domain(\\"http://www.zombie-bites.com\\") == \\"zombie-bites\\" extract_domain(\\"https://www.cnet.com\\") == \\"cnet\\" extract_domain(\\"www.example.com\\") == \\"example\\" extract_domain(\\"example.com\\") == \\"example\\" ``` Notes - Do not use libraries like `re` (regular expression) or `urlparse`. - Only use the `.split()` built-in function.","solution":"def extract_domain(url: str) -> str: Extract the domain name from a given URL. # Remove protocols if present if url.startswith(\\"http://\\"): url = url[7:] elif url.startswith(\\"https://\\"): url = url[8:] # Remove \'www.\' if present if url.startswith(\\"www.\\"): url = url[4:] # Extract the domain name domain = url.split(\'.\')[0] return domain"},{"question":"# Context: You have been hired as a software engineer at a startup working on an e-commerce platform. One of the tasks involves implementing an in-house sorting function for their product reviews system to dynamically sort user feedback based on review scores. # Problem Statement: Write a function `sorted_reviews` that takes an array of integers representing review scores and returns the array sorted in ascending order using Comb Sort. Comb Sort is chosen due to its simplicity and relatively better performance than Bubble Sort for moderately unordered data. You should implement the Comb Sort algorithm and understand the typical performance characteristics and edge case handling. **Function Signature**: ```python def sorted_reviews(reviews: List[int]) -> List[int]: ``` **Input**: - `reviews`: a list of integers where each integer represents a review score. The list can contain between 1 and 1000 review scores, ranging from -10 to 10. **Output**: - A list of integers containing the sorted review scores in ascending order. **Constraints**: - Focus on clarity and simplicity. Avoid using built-in sorting functions as the aim is to implement the Comb Sort. - You may assume that the input will always contain valid integers within the specified range. **Performance Considerations**: - Ensure your implementation handles the upper limit of input size efficiently. - Special attention should be given to how you handle the gap reduction and the swap mechanism. # Example: ```python # Example 1: input: reviews = [5, 3, -1, 0, 3] output: [-1, 0, 3, 3, 5] # Example 2: input: reviews = [10, -3, 7, -10, 0, 0, 5] output: [-10, -3, 0, 0, 5, 7, 10] ``` Develop a well-tested sorting function that accurately processes the input to meet the expected output criteria using the principles of Comb Sort.","solution":"from typing import List def sorted_reviews(reviews: List[int]) -> List[int]: Sorts a list of review scores in ascending order using the Comb Sort algorithm. def get_next_gap(gap): # Shrink gap by Shrink factor 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(reviews) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if reviews[i] > reviews[i + gap]: reviews[i], reviews[i + gap] = reviews[i + gap], reviews[i] swapped = True return reviews"},{"question":"# Problem: You are given a number and a confidence factor. Your goal is to implement the Rabin-Miller primality test algorithm to determine whether the number is probably prime. Recall that this test provides a probabilistic outcome meaning that the number may be declared composite with certainty or probably prime. Given: * An integer `n` where `n >= 2`. * An integer `k` representing the number of rounds for testing. Your task is to implement a function `is_prime(n, k)` that utilizes the Rabin-Miller test. Function Signature ```python def is_prime(n: int, k: int) -> bool: pass ``` Input: * `n` (int): The number to test. It satisfies `n >= 2`. * `k` (int): The iteration number for the test, which determines the accuracy. Greater k provides higher accuracy. Output: * `True` if `n` is probably prime with the given confidence factor. * `False` if `n` is guaranteed composite. Sample Test Cases: ```python Example 1: Input: n = 17, k = 5 Output: True Example 2: Input: n = 18, k = 5 Output: False Example 3: Input: n = 1, k = 5 Output: False Example 4: Input: n = 1013, k = 10 Output: True Example 5: Input: n = 1000000007, k = 3 Output: True ``` Constraints: 1. Ensure `n` is a positive integer and at least 2. 2. You may assume the computational environment supports large integer arithmetic typical of languages like Python. 3. Aim for an implementation that runs efficiently for reasonably large numbers. **Note**: Consider edge cases where large prime numbers are involved and ensure the solution handles high confidence factors adequately.","solution":"import random def is_prime(n: int, k: int) -> bool: if n <= 1: return False if n <= 3: return True def miller_rabin_test(a, d, n, s): # a^d % n x = pow(a, d, n) if x == 1 or x == n - 1: return True while s > 1: x = (x * x) % n if x == n - 1: return True s -= 1 return False # Find d such that n - 1 = 2^s * d (d is odd) s, d = 0, n - 1 while d % 2 == 0: d //= 2 s += 1 # Perform k rounds of the test for _ in range(k): a = random.randint(2, n - 2) if not miller_rabin_test(a, d, n, s): return False return True"},{"question":"Scenario You have recently been hired as a software engineer at a company that deals with large amounts of hierarchical data. One common task is to determine the maximum depth of various tree structures representing organizational structures, XML documents, or nested folder directories. Task Write a function `find_tree_depth(root)` that computes the maximum depth of a binary tree. Function Signature ```python from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_tree_depth(root: Optional[TreeNode]) -> int: # Your code here ``` Input - `root`: The root node of the binary tree (`TreeNode`), where `TreeNode` is a class with the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output - The maximum depth of the binary tree measured as the number of nodes along the longest path from the root node down to the farthest leaf node. Constraints - The number of nodes in the tree is in the range [0, 1000]. - The value of the nodes will be in the range [-10^4, 10^4]. Example ```python # Example Tree # 3 # / # 9 20 # / # 15 7 tree = TreeNode(3) tree.left = TreeNode(9) tree.right = TreeNode(20) tree.right.left = TreeNode(15) tree.right.right = TreeNode(7) depth = find_tree_depth(tree) print(depth) # Output: 3 ``` Performance Requirements - Your solution should handle trees with up to 1000 nodes efficiently, ensuring O(N) time complexity with respect to traversal and minimal space overhead.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_tree_depth(root: Optional[TreeNode]) -> int: if root is None: return 0 else: left_depth = find_tree_depth(root.left) right_depth = find_tree_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Matrix Transformation: Custom Rotation and Inversion Problem Statement Given a square matrix, your task is to write a function that can perform a custom rotation and inversion of the matrix in a single operation. The operation should include rotating the matrix 180 degrees and then performing an inversion along the main diagonal (top-left to bottom-right). Function Signature ```python def rotate_and_invert(matrix: List[List[int]]) -> List[List[int]]: ``` Input - A square matrix `matrix` of size `n x n`, where `1 <= n <= 10^3` and each element of the matrix is an integer between -1000 to 1000. Output - A new matrix that has been rotated 180 degrees and then inverted along the main diagonal. Constraints - You must not use any external libraries. - The solution should aim for a time complexity of O(n^2) and a space complexity of O(n^2). Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert rotate_and_invert(matrix) == [ [9, 6, 3], [8, 5, 2], [7, 4, 1] ] ``` Implementation Details 1. Rotate the matrix by 180 degrees. This step can be visualized as first reversing the matrix and then flipping each row. 2. Invert the rotated matrix along the main diagonal. 3. Return the resulting matrix.","solution":"def rotate_and_invert(matrix): Rotates the matrix by 180 degrees and then inverts it along the main diagonal. n = len(matrix) # Step 1: Rotate 180 degrees (reverse the matrix and then reverse each row) rotated_matrix = [] for row in matrix[::-1]: rotated_matrix.append(row[::-1]) # Step 2: Invert along the main diagonal inverted_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): inverted_matrix[j][i] = rotated_matrix[i][j] return inverted_matrix"},{"question":"# Scenario A software developer is working on formatting product license keys to improve their readability. The keys should be formatted such that characters are grouped in chunks of a specific length, with each group separated by hyphens. The developer needs a function that takes an unformatted license key and formats it according to these rules. # Problem Statement Implement a function `format_license_key(key: str, k: int) -> str` that formats the given license key string `key` with groups of size `k`. The input string `key` may contain alphanumeric characters and hyphens. Hyphens in the input should be ignored in the result, and all characters should be converted to uppercase. Groups should be separated by hyphens. Input - `key`: A string `key` with alphanumeric characters and possibly hyphens. - `k`: An integer `k` representing the group size. Output - A formatted string where characters are grouped in chunks of size `k`. Constraints - 1 <= len(key) <= 10^4 - 1 <= k <= len(key) - The input string `key` is guaranteed to have at least one alphanumeric character. Examples **Example 1:** ```plaintext Input: key = \\"2-5g-3-J\\", k = 2 Output: \\"2-5G-3J\\" ``` **Example 2:** ```plaintext Input: key = \\"2-4A0r7-4k\\", k = 4 Output: \\"24A0-R74K\\" ``` Notes - All alphabetical characters should be converted to uppercase. - The first group may contain fewer than `k` characters but all subsequent groups must have exactly `k` characters.","solution":"def format_license_key(key: str, k: int) -> str: Formats the given license key string `key` with groups of size `k`. Characters are grouped in chunks of size `k` and separated by hyphens. # Remove all hyphens and convert to upper case cleaned_key = key.replace(\\"-\\", \\"\\").upper() # Result string that will store chunks of characters result = [] # Iterate over the cleaned_key in reverse, taking chunks of size k for i in range(len(cleaned_key), 0, -k): result.append(cleaned_key[max(0, i - k):i]) # Join the result parts with hyphens in reverse order return \\"-\\".join(result[::-1])"},{"question":"Context and Scenario: You are developing a cashback system for an e-commerce website. Each user has a list of transactions, represented by their amounts. You need to identify if any two transactions can be combined to match a given cashback target amount. This is similar to identifying a two-number sum problem but tailored to fit the purpose of transaction processing. Problem Statement: Given a list of transaction amounts and a target amount to check if cashback can be redeemed, write a function `find_transactions` that returns the indices of the two transactions which add up to the target amount. Assume that each transaction pair is unique and each transaction can only be used once. Function Signature: ```python def find_transactions(transactions: List[int], target: int) -> Tuple[int, int]: ``` Input: * `transactions` (List[int]): A list of integers representing transaction amounts. * `target` (int): The target cashback amount to be matched. Output: * Returns a tuple of two integers representing the indices of the two transactions whose sums equal the target amount. * If no such indices exist, return `None`. Constraints: * Each input will have exactly one solution. * You cannot use the same element twice. * There will always be at least two transactions in the list. Examples: ```python # Example 1: transactions = [20, 50, 40, 30] target = 90 # Explanation: Transactions at indices 1 and 2 add up to the target amount (50 + 40 = 90). # Output: (1, 2) # Example 2: transactions = [10, 15, 3, 7] target = 17 # Explanation: Transactions at indices 0 and 3 add up to the target amount (10 + 7 = 17). # Output: (0, 3) ``` Notes: * Ensure that your solution is efficient, ideally with linear time complexity. Additional Information: * Performance and efficiency of your solution will be considered. * The input list will not have duplicate values. * Include error handling for any edge cases you might identify.","solution":"from typing import List, Tuple, Optional def find_transactions(transactions: List[int], target: int) -> Optional[Tuple[int, int]]: Given a list of transactions and a target cashback amount, return the indices of two transactions that add up to the target amount. Args: - transactions (List[int]): A list of integers representing transaction amounts. - target (int): The target cashback amount to be matched. Returns: - Tuple[int, int]: A tuple of two integers representing the indices of the two transactions whose sums equal the target amount. - Optional: Returns None if no such indices exist. seen = {} for index, amount in enumerate(transactions): complement = target - amount if complement in seen: return (seen[complement], index) seen[amount] = index return None"},{"question":"**Context**: Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand (i.e., [0, 1, 2, 4, 5, 6, 7] might become [4, 5, 6, 7, 0, 1, 2]). You are given a target value to search. Implement the function to find the index of the target in the array. **Function Specification:** ```python def find_target_in_rotated_array(array, target): Finds the index of the target value in a rotated sorted array. Parameters: array (list of int): The rotated sorted array. target (int): The value to search for. Returns: int: The index of the target, or -1 if the target does not exist in the array. pass ``` **Input:** - `array`: A list of integers representing the rotated sorted array. - `target`: An integer representing the value to be searched in the array. **Output:** - Return the index of the target value in the array if it is present, otherwise return -1. **Assumptions:** - No duplicates exist in the array. - The array was originally sorted in ascending order prior to rotation. **Examples:** ```python # Example 1: array = [4, 5, 6, 7, 0, 1, 2] target = 0 Output: 4 # target 0 is at index 4. # Example 2: array = [4, 5, 6, 7, 0, 1, 2] target = 3 Output: -1 # target 3 is not in the array. # Example 3: array = [1] target = 0 Output: -1 # target 0 is not in the array. # Example 4: array = [1] target = 1 Output: 0 # target 1 is at index 0. ``` **Constraints:** - The runtime complexity must be O(log n). - The array may contain 1 to 100,000 elements.","solution":"def find_target_in_rotated_array(array, target): Finds the index of the target value in a rotated sorted array. Parameters: array (list of int): The rotated sorted array. target (int): The value to search for. Returns: int: The index of the target, or -1 if the target does not exist in the array. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == target: return mid if array[left] <= array[mid]: if array[left] <= target < array[mid]: right = mid - 1 else: left = mid + 1 else: if array[mid] < target <= array[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Path and URL Joiner **Context**: You are developing a command-line utility to help with file management, and URL generation. Your task is to implement a function `smart_join(base, suffix)` that joins a base path or URL with a suffix ensuring exactly one slash is between them. This function should handle both paths and URLs correctly. Given input constraints: * Both `base` and `suffix` are non-empty strings. * `base` can be treated either as a file path or a URL. **Function Signature**: ```python def smart_join(base: str, suffix: str) -> str: ``` # Input * `base` (str): A base path or URL. * `suffix` (str): A path or URL suffix. # Output * `str`: A correctly joined path or URL as a single string. # Examples ```python assert smart_join(\\"path/to/dir\\", \\"file\\") == \\"path/to/dir/file\\" assert smart_join(\\"path/to/dir/\\", \\"file\\") == \\"path/to/dir/file\\" assert smart_join(\\"http://algorithms.com/\\", \\"part\\") == \\"http://algorithms.com/part\\" assert smart_join(\\"http://algorithms.com\\", \\"/part\\") == \\"http://algorithms.com/part\\" ``` # Requirements * The function should be efficient with a time complexity of O(n), where `n` is the length of the combined base and suffix. * Space complexity should be reasonable, avoiding unnecessary allocations. # Additional Constraints * Ensure your function handles unexpected formats and edge cases gracefully. * Document any assumptions or choices made during implementation. Good luck!","solution":"def smart_join(base, suffix): Joins a base path or URL with a suffix ensuring exactly one slash is between them. Args: - base (str): The base path or URL. - suffix (str): The suffix to be joined with the base. Returns: - str: The correctly joined path or URL. if base.endswith(\'/\') and suffix.startswith(\'/\'): return base.rstrip(\'/\') + suffix elif not base.endswith(\'/\') and not suffix.startswith(\'/\'): return base + \'/\' + suffix else: return base + suffix"},{"question":"# Question: Efficient Calculation of Combinations Scenario You are part of a team developing a feature for a new combinatorics tool that will be used by educators and students to explore combinations in mathematics. The tool allows users to input any two non-negative integers ( n ) and ( r ) and determines how many ways ( r ) items can be chosen from ( n ) items. Task Implement a function `efficient_combination(n, r)` that computes the same combination value using an iterative dynamic programming approach to avoid the pitfalls of recursion and improve performance. Function Signature ```python def efficient_combination(n: int, r: int) -> int: pass ``` Input Formats * `n`: a non-negative integer ((n geq 0)) * `r`: a non-negative integer ((r geq 0)) Output Format * An integer representing the number of ways to choose ( r ) items from ( n ) items. Constraints * ( n ) and ( r ) will be reasonably large, but you can assume ( n leq 10^3 ). Example ```python assert efficient_combination(5, 3) == 10 assert efficient_combination(10, 0) == 1 assert efficient_combination(10, 10) == 1 assert efficient_combination(6, 2) == 15 ``` Notes * Utilizing an iterative dynamic programming approach ensures efficient usage of time and space, and avoids the typical issues with deep recursion. * You need to create a 2D list (or dict) to store intermediate results of combinations.","solution":"def efficient_combination(n: int, r: int) -> int: # Create a 2D table to store results of subproblems dp = [[0 for _ in range(r + 1)] for _ in range(n + 1)] # Fill dp table using bottom-up approach for i in range(n + 1): for k in range(min(i, r) + 1): if k == 0 or k == i: dp[i][k] = 1 else: dp[i][k] = dp[i-1][k-1] + dp[i-1][k] return dp[n][r]"},{"question":"Implement Pancake Sort with Optimization Objective Students are required to write a modified version of the Pancake Sort algorithm with an additional optimization to minimize the number of flips performed. Problem Statement You are given an array of integers. Implement an optimized Pancake Sort algorithm to sort this array in ascending order. During sorting, reduce the number of flips by avoiding unnecessary flips when possible. Function Signature ```python def optimized_pancake_sort(arr: List[int]) -> List[int]: pass ``` Input * An array `arr` of `N` integers where (1 leq N leq 10^3). Output * Returns a list of integers sorted in ascending order. Constraints * Perform in-place sorting to maintain space complexity as O(1). * Aim to reduce the number of flips compared to the naive Pancake Sort implementation. Example ```python # Example 1: arr = [3, 6, 1, 8, 4, 7] print(optimized_pancake_sort(arr)) # Output: [1, 3, 4, 6, 7, 8] # Example 2: arr = [1, 2, 3, 4] print(optimized_pancake_sort(arr)) # Output: [1, 2, 3, 4] # Example 3: arr = [10, 9, 8, 7, 6] print(optimized_pancake_sort(arr)) # Output: [6, 7, 8, 9, 10] ``` Notes * The goal is to sort the array with a reduced number of flips compared to the original Pancake Sort implementation. * Analyze the array and skip redundant flips. * Your function will be assessed on correctness as well as the number of flips performed.","solution":"def optimized_pancake_sort(arr): Pancake sorting algorithm with optimization to reduce the number of flips. This function will sort the array in-place. def flip(sub_arr, k): sub_arr[:k] = reversed(sub_arr[:k]) n = len(arr) for i in range(n, 1, -1): # Find the index of the maximum number in the subarray arr[0:i] max_index = arr[:i].index(max(arr[:i])) # If max element is at its place already, no need to flip if max_index == i - 1: continue # Flip the max element to the front if it\'s not already at the front if max_index != 0: flip(arr, max_index + 1) # Move the max element to its correct place (end of the current unsorted part) flip(arr, i) return arr"},{"question":"You are required to implement the binomial coefficient calculation using an iterative approach to overcome the limitations of deep recursion. The binomial coefficient C(n, k) is calculated as the number of ways to choose k elements from a set of n elements without considering the order. # Specifications: * **Input**: * Two integers `n` and `k` such that 0 <= k <= n. * **Output**: * An integer representing the binomial coefficient C(n, k). # Constraints: * You must avoid using recursion. * Optimize the approach to minimize time and space complexity. * The solution should handle large values of n and k efficiently. # Example: 1. **Input**: `n = 5`, `k = 2` **Output**: `10` 2. **Input**: `n = 10`, `k = 3` **Output**: `120` # Edge Cases: 1. For k = 0 or k = n, the function should return 1. 2. If k > n, the function should raise a ValueError. # Your Task: Write a function `iterative_binomial_coefficient(n, k)` that takes two integers `n` and `k` and returns the binomial coefficient C(n, k). ```python def iterative_binomial_coefficient(n, k): if k > n: raise ValueError(\'Invalid Inputs, ensure that n >= k\') if k == 0 or n == k: return 1 if k > n // 2: k = n - k c = 1 for i in range(k): c = c * (n - i) // (i + 1) return c ``` You must ensure that your function handles the inputs efficiently and adheres to the problem constraints.","solution":"def iterative_binomial_coefficient(n, k): if k > n: raise ValueError(\'Invalid Inputs, ensure that n >= k\') if k == 0 or n == k: return 1 # Optimization: C(n, k) is the same as C(n, n\'k), so choose the smaller k k = min(k, n - k) c = 1 for i in range(k): c = c * (n - i) // (i + 1) return c"},{"question":"You are provided with a library\'s inventory system that maintains books in an array sorted in increasing order according to their ISBN numbers. Due to the uniform distribution of ISBNs, it is decided that interpolation search is the most efficient method to locate books quickly. Write a function `find_book(isbn_list: List[int], ISBN: int) -> int` that performs interpolation search to find the position of a given book\'s ISBN number in the sorted array. If the ISBN is found, return the index of the book; otherwise, return -1. # Input: * `isbn_list` - A sorted list of integers representing ISBN numbers of the books (1<= len(isbn_list) <= 10^5). * `ISBN` - An integer representing the ISBN number to be searched. # Output: * Return the index of the book\'s ISBN if found, else -1. # Constraints: * The elements in `isbn_list` are in strictly increasing order. * Probabilistically, the elements in the list are uniformly distributed. # Example: ```python print(find_book([1001, 1010, 1020, 1030, 1040, 1050], 1010)) # returns 1 print(find_book([1001, 1010, 1020, 1030, 1040, 1050], 1050)) # returns 5 print(find_book([1001, 1010, 1020, 1030, 1040, 1050], 1070)) # returns -1 ``` # Requirements: * Your function should accomplish the task in O(log log n) time complexity on average for large uniform distributions. * Analyze your implementation to handle possible edge cases and optimize for performance.","solution":"def find_book(isbn_list, ISBN): Perform interpolation search to find the given ISBN in the sorted list of ISBNs. Parameters: isbn_list (List[int]): Sorted list of ISBN numbers. ISBN (int): ISBN number to search. Returns: int: Index of the ISBN if found, else -1. low = 0 high = len(isbn_list) - 1 while low <= high and ISBN >= isbn_list[low] and ISBN <= isbn_list[high]: if low == high: if isbn_list[low] == ISBN: return low return -1 pos = low + ((high - low) // (isbn_list[high] - isbn_list[low]) * (ISBN - isbn_list[low])) if isbn_list[pos] == ISBN: return pos if isbn_list[pos] < ISBN: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# String Matching Challenge Objective Implement a function `find_first_occurrence(haystack, needle)` that determines the index of the first occurrence of the string `needle` in the string `haystack`. If the `needle` is not part of the `haystack`, the function should return -1. Input and Output Formats * **Input**: - `haystack`: A string of length n (1 ≤ n ≤ 10^5) - `needle`: A string of length m (0 ≤ m ≤ 10^4) * **Output**: - An integer representing the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not found. Function Signature ```python def find_first_occurrence(haystack: str, needle: str) -> int: pass ``` Constraints * The function should handle cases where `needle` is an empty string by returning 0. * If `needle` is longer than `haystack`, the function should return -1. * Consider the efficiency of your solution, i.e., implement an O(n * m) solution or better. Example 1. Input: haystack = \\"hello\\", needle = \\"ll\\" Output: 2 2. Input: haystack = \\"aaaaa\\", needle = \\"bba\\" Output: -1 3. Input: haystack = \\"edgecase\\", needle = \\"\\" Output: 0 Feel free to use the provided example cases and add additional cases to validate your implementation.","solution":"def find_first_occurrence(haystack: str, needle: str) -> int: Determines the index of the first occurrence of the string `needle` in the string `haystack`. If the `needle` is not part of the `haystack`, the function returns -1. Args: haystack (str): The string in which to find the `needle`. needle (str): The string to find in the `haystack`. Returns: int: The index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not found. if not needle: return 0 return haystack.find(needle)"},{"question":"# Prim\'s Algorithm for Minimum Spanning Tree Problem Statement You are given a connected, undirected graph represented as a dictionary. Each key in the dictionary is a node, and its value is a list of lists where each sublist contains the weight and the adjacent node. Your task is to implement Prim\'s algorithm to find the weight of the minimum spanning tree (MST) of the given graph. Function Signature ```python def prims_minimum_spanning(graph_used: Dict[Any, List[List[int]]]) -> int: pass ``` Input * A dictionary `graph_used` where: * **Keys** are nodes (could be integers, characters, etc.). * **Values** are lists of lists. Each sublist contains two elements: an integer representing the weight of the edge and the adjacent node. Output * An integer representing the weight of the minimum spanning tree. Constraints 1. The graph will always be connected. 2. The graph is undirected. 3. There will be no negative weights. 4. Nodes can be of any hashable type (integers, characters, etc.) Performance Requirement Your solution should be efficient, with a time complexity close to (O(E log V)), where (E) is the number of edges and (V) is the number of vertices. Example ```python graph = { \'a\': [[3, \'b\'], [8, \'c\']], \'b\': [[3, \'a\'], [5, \'d\']], \'c\': [[8, \'a\'], [2, \'d\'], [4, \'e\']], \'d\': [[5, \'b\'], [2, \'c\'], [6, \'e\']], \'e\': [[4, \'c\'], [6, \'d\']] } assert prims_minimum_spanning(graph) == 14 ``` In the above example: 1. The edges in the MST (with their weights) could be: (\'a\', \'b\', 3), (\'c\', \'d\', 2), (\'c\', \'e\', 4), (\'b\', \'d\', 5). 2. The total weight of the MST is 3 + 2 + 4 + 5 = 14. # Scenario Consider you are a network specialist tasked with designing a cost-effective network by connecting routers with the least total cabling cost. Use Prim\'s algorithm to determine the weight of the least-cost network connection.","solution":"from typing import Dict, List, Any import heapq def prims_minimum_spanning(graph_used: Dict[Any, List[List[int]]]) -> int: Given a graph with nodes and weighted edges, return the weight of the minimum spanning tree (MST) using Prim\'s Algorithm. Parameters: graph_used (Dict[Any, List[List[int]]]): A dictionary representing the graph where keys are nodes and values are lists of [weight, adjacent_node]. Returns: int: Total weight of the minimum spanning tree. if not graph_used: return 0 # Initialize variables total_weight = 0 starting_node = next(iter(graph_used)) visited = set() min_heap = [(0, starting_node)] while min_heap: weight, current_node = heapq.heappop(min_heap) if current_node in visited: continue visited.add(current_node) total_weight += weight for edge_weight, neighbor in graph_used[current_node]: if neighbor not in visited: heapq.heappush(min_heap, (edge_weight, neighbor)) return total_weight"},{"question":"# Calculate the Maximum Depth of a Binary Search Tree As an experienced programming student, you are tasked with computing the maximum depth (or height) of a binary search tree (BST). The depth of a tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node. Input - The tree\'s root node, defined as a class Node. - You can assume the structure of the binary search tree is already created. Output - An integer representing the maximum depth (height) of the binary search tree. Constraints - The tree contains unique values, or it may be empty (null). Example Consider the following tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` The tree has a maximum depth of 4. # Provided Code You are given the following code structure: ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key class bst: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: current_node = self.root while True: if key < current_node.val: if current_node.left: current_node = current_node.left else: current_node.left = Node(key) break elif key > current_node.val: if current_node.right: current_node = current_node.right else: current_node.right = Node(key) break ``` Task Implement the function `height(root)` that takes the root node of the BST and returns the height of the tree. Signature ```python def height(root: Node) -> int: ``` **Note**: Use the `unittest` framework to validate your solution with the provided test case: ```python import unittest class TestSuite(unittest.TestCase): def setUp(self): self.tree = bst() self.tree.insert(9) self.tree.insert(6) self.tree.insert(12) self.tree.insert(3) self.tree.insert(8) self.tree.insert(10) self.tree.insert(15) self.tree.insert(7) self.tree.insert(18) def test_height(self): self.assertEqual(4, height(self.tree.root)) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class bst: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: current_node = self.root while True: if key < current_node.val: if current_node.left: current_node = current_node.left else: current_node.left = Node(key) break elif key > current_node.val: if current_node.right: current_node = current_node.right else: current_node.right = Node(key) break def height(root: Node) -> int: if root is None: return 0 left_depth = height(root.left) right_depth = height(root.right) return max(left_depth, right_depth) + 1"},{"question":"You have been hired to work on a text-processing application. Your first task is to implement a function that checks whether a given string is a palindrome. The function should return `True` if the string is a palindrome and `False` otherwise, considering only alphanumeric characters and ignoring cases. # Input Format The function `check_palindrome` receives a single argument: - `s` (string): A string that may contain alphabetic characters, digits, spaces, and punctuation. # Output Format The function should return a boolean: - `True` if the input string is a palindrome. - `False` if the input string is not a palindrome. # Constraints - The length of the string is at most 100,000 characters. - String may contain leading or trailing spaces, non-alphanumeric characters, and mixed cases. # Performance Requirements - Time complexity should be O(n), where n is the length of the input string. - Space complexity should be kept at a minimum. # Example ```python assert check_palindrome(\\"A man, a plan, a canal: Panama\\") == True assert check_palindrome(\\"race a car\\") == False assert check_palindrome(\\"\\") == True assert check_palindrome(\\"Able was I, I saw Elba\\") == True assert check_palindrome(\\"@.!\\") == True assert check_palindrome(\\"123AbcBa321\\") == True assert check_palindrome(\\"No \'x\' in Nixon\\") == True assert check_palindrome(\\"This isn\'t a palindrome\\") == False ``` # Task Implement the function `check_palindrome(s)`.","solution":"def check_palindrome(s): Returns True if the string s is a palindrome, considering only alphanumeric characters and ignoring cases. Returns False otherwise. filtered_chars = [c.lower() for c in s if c.isalnum()] return filtered_chars == filtered_chars[::-1]"},{"question":"Graph Cycle Detection **Objective**: Write a function to detect if a directed graph has a cycle. **Problem Statement**: You are given a directed graph implemented as shown in the code snippets. Write a function `has_cycle(graph: DirectedGraph) -> bool` that determines whether the graph contains a cycle. A cycle in a directed graph is a path that starts from a node `N` and ends at the same node `N` consisting of at least one edge. **Input and Output**: * **Input**: A `DirectedGraph` object. * **Output**: `True` if the graph contains a cycle, `False` otherwise. **Constraints**: * The graph may have up to `10^3` nodes and `10^4` edges. * Nodes are uniquely identifiable by their name (string). **Performance Requirements**: * The solution should aim for an efficient traversal algorithm like Depth-First Search (DFS) using color-marking (white-gray-black) or recursion stack methods to achieve linear time complexity relative to the number of nodes and edges. **Example**: ```python # Example usage: graph_data = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"], \\"D\\": [\\"E\\"], } graph = DirectedGraph(graph_data) print(has_cycle(graph)) # Output: True graph_data = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\"], \\"D\\": [\\"E\\"], \\"E\\": [], \\"C\\": [\\"F\\"] } graph = DirectedGraph(graph_data) print(has_cycle(graph)) # Output: False ``` **Hint**: * Utilize Depth-First Search (DFS) and track visited nodes. * Consider employing a recursive stack or color-coding (white-gray-black) mechanism to identify back edges that indicate a cycle.","solution":"class DirectedGraph: def __init__(self, graph_data): self.graph = graph_data def get_adjacent_nodes(self, node): return self.graph.get(node, []) def has_cycle(graph: DirectedGraph) -> bool: def visit(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get_adjacent_nodes(node): if visit(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph.graph: if visit(node): return True return False"},{"question":"# Linked List Node Deletion You are given a node (not the tail node) in a singly linked list. Write a function to delete that node in the linked list. The given node will not be the tail node and will always be valid. The function signature should be: ```python def delete_node(node): pass ``` # Parameters: * `node` (Node): The node to be deleted from the linked list. # Returns: * This function does not return anything. # Example: If the given linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, after calling your function, the linked list should become 1 -> 2 -> 4. # Constraints: * The linked list must contain at least two elements. * The given node cannot be the tail node and will always be a valid node in the list. # Requirements: * Your solution should work in O(1) time complexity. * Handle erroneous inputs (e.g., null nodes or attempts to delete the tail node) by raising appropriate exceptions. # Testing: The provided `TestSuite` class includes unit tests for verifying the correctness of your implementation. Ensure that all tests pass without modifications: ```python import unittest class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node): if node is None or node.next is None: raise ValueError node.val = node.next.val node.next = node.next.next class TestSuite(unittest.TestCase): def test_delete_node(self): # make linkedlist 1 -> 2 -> 3 -> 4 head = Node(1) curr = head for i in range(2, 5): curr.next = Node(i) curr = curr.next # node3 = 3 node3 = head.next.next # after delete_node => 1 -> 2 -> 4 delete_node(node3) curr = head self.assertEqual(1, curr.val) curr = curr.next self.assertEqual(2, curr.val) curr = curr.next self.assertEqual(4, curr.val) tail = curr self.assertIsNone(tail.next) self.assertRaises(ValueError, delete_node, tail) self.assertRaises(ValueError, delete_node, tail.next) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node): if node is None or node.next is None: raise ValueError(\\"Node is invalid or it is the tail node.\\") node.val = node.next.val node.next = node.next.next"},{"question":"# Problem You are hired to develop a mobile game where a player climbs stairs to score points. The number of steps the player can climb at a time are constrained to either 1 or 2 steps. Each level in the game consists of a different number of steps, and you need to implement a function to calculate the number of distinct ways the player can reach the top of the stairs in each level. # Task Write a function `distinct_ways_to_climb(n)` that takes a positive integer `n` representing the number of steps in the staircase and returns the number of distinct ways the player can climb to the top. # Examples ```python assert distinct_ways_to_climb(2) == 2 assert distinct_ways_to_climb(3) == 3 assert distinct_ways_to_climb(5) == 8 ``` # Input * One single integer `n` such that (1 leq n leq 10^5). # Output * Return a single integer representing the number of distinct ways to climb to the top. # Constraints * Your solution should run efficiently for the given constraints. * Space Efficiency is important for large values of `n`. # Additional Information * The player can either take a single step or two steps at any given time to climb the staircase. * Ensure to handle edge cases where `n` is the smallest (1) or largest within the given limits.","solution":"def distinct_ways_to_climb(n): Returns the number of distinct ways to climb n steps. Uses dynamic programming to calculate the result. if n == 1: return 1 elif n == 2: return 2 first = 1 # ways to climb 1 step second = 2 # ways to climb 2 steps for i in range(3, n + 1): current = first + second first = second second = current return second"},{"question":"# Context You have newly joined a team of software engineers working on a project involving complex data structures and algorithm optimization. One crucial aspect of the project involves operating on binary trees - performing various traversals to maintain, update, and visualize tree structures. # Problem Statement Your task is to write a function that carries out a level order traversal of a binary tree. This function will receive the root node of the tree and return a list of lists, where each sublist contains the node values at each respective level from top to bottom. # Function Signature ```python def level_order_traversal(root): pass ``` # Input * The function will take a single argument `root`, which represents the root of a binary tree. * The tree node is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output * The function should return a list of lists. Each inner list represents the node values at a corresponding level, from top to bottom. # Constraints * The number of nodes in the tree will be in the range [0, 2000]. * Node values will be integers in the range [-1000, 1000]. # Example ```python # Example Tree: # 3 # / # 9 20 # / # 15 7 # Input: root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) # Output: # [ # [3], # [9,20], # [15,7] # ] print(level_order_traversal(root)) # Output: [[3], [9, 20], [15, 7]] ``` # Note * Handle edge cases such as an empty tree (return an empty list). * Ensure to manage memory efficiently to handle large trees within the given constraints.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): if not root: return [] from collections import deque result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"Implement dynamic resizing for the SeparateChainingHashTable to handle high load factors and maintain efficient operations. # Task: Extend the `SeparateChainingHashTable` class to support dynamic resizing. The table should resize (double the size) when the load factor exceeds 0.75. 1. Implement the resizing mechanism. 2. Ensure that all key-value pairs are rehashed and properly placed in the new table. 3. Maintain all existing functionality of the `SeparateChainingHashTable`. # Requirements: * **Input**: None directly (you handle resizing internally based on load factor). * **Output**: This is a modification of internal behavior, so no direct outputs. Ensure existing methods (`put`, `get`, and `del_`) work correctly post-resizing. # Constraints: 1. Initial size of the hash table is still 11. 2. Load factor threshold for resizing is 0.75. 3. Use separate chaining via linked lists for collision resolution. 4. Ensure all operations (insert, delete, search) function correctly after resizing. # Example Behavior: ```python table = SeparateChainingHashTable() # Insert multiple values for i in range(100): table.put(str(i), i) assert table.get(\\"50\\") == 50 # Ensure table resizes and items are accessible for i in range(100): assert table.get(str(i)) == i # Ensure size correctness assert len(table) == 100 ``` # Evaluation Criteria: * Correct implementation of resizing. * Proper rehashing of existing elements to the new array size. * Maintaining correctness of the `put`, `get`, and `del_` operations. * Efficient handling of collision post-resizing.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None class SeparateChainingHashTable: def __init__(self, initial_size=11): self.initial_size = initial_size self.size = 0 self.table = [None] * self.initial_size self.load_factor_threshold = 0.75 def _hash(self, key): return hash(key) % len(self.table) def put(self, key, value): if self.size / len(self.table) > self.load_factor_threshold: self._resize() index = self._hash(key) node = self.table[index] while node: if node.key == key: node.value = value return node = node.next new_node = Node(key, value) new_node.next = self.table[index] self.table[index] = new_node self.size += 1 def get(self, key): index = self._hash(key) node = self.table[index] while node: if node.key == key: return node.value node = node.next return None def del_(self, key): index = self._hash(key) node = self.table[index] prev = None while node: if node.key == key: if prev: prev.next = node.next else: self.table[index] = node.next self.size -= 1 return prev = node node = node.next def _resize(self): new_size = len(self.table) * 2 new_table = [None] * new_size old_table = self.table self.table = new_table self.size = 0 # reset size because put() will increment it for head in old_table: node = head while node: self.put(node.key, node.value) node = node.next def __len__(self): return self.size"},{"question":"# Linked Lists Intersection Given two singly linked lists, write a function to find their intersection node. An intersection node is defined as the first node that is common to both lists by reference, not by value. Your task is to implement the following function: ```python def intersection(head1: Node, head2: Node) -> Optional[Node]: Determine the node where two linked lists intersect. :param head1: The head of the first linked list :param head2: The head of the second linked list :return: The intersection node or None if there is no intersection ``` Input: * `head1`: The head node of the first linked list. * `head2`: The head node of the second linked list. Output: * Returns the first common node if an intersection exists, otherwise returns `None`. Constraints: * The number of nodes `N` and `M` in the linked lists are in the range `[0, 10^4]`. * Nodes may have any integer value, but node identity is determined by reference, not by value. Example: ```python # Test Case # Given lists: # 1 -> 3 -> 5 -> 7 -> 9 -> 11 # and: # 2 -> 4 -> 6 --------^ node1 = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(4) node5 = Node(5) node6 = Node(6) node7 = Node(7) node9 = Node(9) node11 = Node(11) node1.next = node3 node3.next = node5 node5.next = node7 node7.next = node9 node9.next = node11 node2.next = node4 node4.next = node6 node6.next = node7 assert intersection(node1, node2) == node7 # Should return the node with value 7 ``` Consider edge cases including: * One or both linked lists are empty. * The linked lists have no nodes in common. * The linked lists are of widely different lengths. # Notes: - Traversal should be optimized to run in linear time. - The function should use constant additional space. - The intersection should return the first common node by reference, not by value.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def intersection(head1: Node, head2: Node) -> Node: Determine the node where two linked lists intersect. :param head1: The head of the first linked list :param head2: The head of the second linked list :return: The intersection node or None if there is no intersection if head1 is None or head2 is None: return None # Get the lengths of both linked lists def get_length(head): length = 0 current = head while current: length += 1 current = current.next return length length1 = get_length(head1) length2 = get_length(head2) # Align both pointers to the start of the lists current1, current2 = head1, head2 # If one list is longer, advance its pointer to balance if length1 > length2: for _ in range(length1 - length2): current1 = current1.next elif length2 > length1: for _ in range(length2 - length1): current2 = current2.next # Traverse both lists together to find the intersection while current1 and current2: if current1 is current2: return current1 current1 = current1.next current2 = current2.next return None"},{"question":"Context: You\'ve been hired as a software engineer and tasked with implementing a sorting algorithm for a legacy system. The system requires a sorting function written from scratch, and it must be based on an exchange sort due to some peculiar business constraints. However, you identify performance problems with the exchange sort and want to improve its efficiency while sticking to the simplicity of the algorithm as much as possible. Objective: Write a Python function `improved_exchange_sort(arr)` that sorts an array in ascending order. The function should enhance the basic exchange sort by reducing unnecessary comparisons. Function Signature: ```python def improved_exchange_sort(arr: List[int]) -> List[int]: # Your code here ``` Input: * `arr` - A list of integers. (1 <= length of arr <= 10^3; -10^3 <= arr[i] <= 10^3) Output: * A list of integers sorted in ascending order. Constraints: * You should attempt to reduce the number of comparisons made compared to the basic exchange sort. Performance Requirements: * Although the basic exchange sort has O(n^2) time complexity, your improved version should show practical reductions in execution time for the average and best-case scenarios. Example: ```python # Input arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] # Output sorted_arr = [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` Hints: * Think about ways to avoid redundant comparisons after certain elements are already correctly placed.","solution":"def improved_exchange_sort(arr): Sorts an array of integers using an improved version of the exchange sort. n = len(arr) for i in range(n - 1): swapped = False for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] swapped = True if not swapped: break return arr"},{"question":"You are tasked with writing a function `strip_url_params(url: str, params_to_strip: Optional[List[str]] = None) -> str` that removes any duplicate query string parameters from the URL and removes any query string parameters specified in the second argument (an optional list). The function should: - Convert the URL into its components. - Remove duplicate query string parameters, ensuring only the first occurrence is retained. - Exclude any query string parameters specified in `params_to_strip`. - Return the sanitized URL. Input: - `url` (str): The URL to be processed. - `params_to_strip` (Optional[List[str]]): A list of query parameter keys to be removed (default is `None`). Output: - A new URL (str) with the specified parameters removed and no duplicate query parameters. Constraints: - The URL will be a well-formed HTTP/HTTPS URL. - Parameter keys will be alphanumeric. # Examples: 1. `strip_url_params(\'http://example.com?a=1&b=2&a=2\')` should return `\'http://example.com?a=1&b=2\'` 2. `strip_url_params(\'http://example.com?a=1&b=2&c=3&a=2\', [\'b\'])` should return `\'http://example.com?a=1&c=3\'` 3. `strip_url_params(\'http://example.com?a=1&b=2&c=3&a=3\', [\'b\', \'c\'])` should return `\'http://example.com?a=1\'` # Requirements: - Ensure the solution is efficient with a linear time complexity. - Handle cases with no query parameters or where all should be stripped off. - Incorporate clear and readable code, avoiding unnecessary complexity. Implement your solution using Python\'s powerful string and URL parsing libraries where applicable.","solution":"from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse from typing import List, Optional def strip_url_params(url: str, params_to_strip: Optional[List[str]] = None) -> str: # Parse the URL into components parsed_url = urlparse(url) query_params = parse_qsl(parsed_url.query) # Dictionary to hold the first occurrence of each parameter seen_params = {} # Iterate over the query parameters for key, value in query_params: if key not in seen_params: seen_params[key] = value # Remove unwanted params specified in params_to_strip if params_to_strip: for param in params_to_strip: if param in seen_params: del seen_params[param] # Reassemble the query string new_query = urlencode(seen_params) # Reassemble the full URL with the new query string new_url = urlunparse(( parsed_url.scheme, parsed_url.netloc, parsed_url.path, parsed_url.params, new_query, parsed_url.fragment )) return new_url"},{"question":"# Scenario You are tasked with implementing the Merge Sort algorithm for a list of integers. As part of the implementation, you also need to provide a detailed check for edge cases and optimize the helper functions as necessary. # Task Write a Python function `merge_sort(arr)` that sorts a list of integers using the Merge Sort algorithm. Assume that the input is a list `arr` of integers which may be empty or contain duplicates. # Requirements 1. **Input Format**: A list `arr` containing integers. 2. **Output Format**: A new list that is the sorted version of `arr`. 3. **Constraints**: * The input list can have up to (10^5) integers. * Each integer in the list can be between (-10^6, 10^6). # Performance Ensure that your solution: * Runs with an average time complexity of O(n log(n)). * Uses no more than O(n) additional space. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: # Your implementation here pass ``` # Example ```python assert merge_sort([4, 3, 5, 1, 2]) == [1, 2, 3, 4, 5] assert merge_sort([6, 5, 6, 2, 1]) == [1, 2, 5, 6, 6] assert merge_sort([]) == [] assert merge_sort([1]) == [1] assert merge_sort([3, 3, 3, 3]) == [3, 3, 3, 3] ``` # Additional Notes Ensure to handle edge cases effectively. Optimize the merge function to work better with in-place modification if possible while staying within the constraints.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Merge Sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted lists into one sorted list. sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 # Append remaining elements from left or right sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"# Sentence Segmentation Using a Dictionary **Objective**: Given a string and a dictionary of valid words, implement a function to count how many possible sentences can be formed from the string. Each word in the sentence must be contained in the dictionary. # Function Specification ```python def count_sentences(s: str, dictionary: set) -> int: # Your implementation here pass ``` # Input * `s`: A string containing the source text without spaces (1 ≤ |s| ≤ 50). * `dictionary`: A set containing valid dictionary words (0 ≤ |dictionary| ≤ 1000). # Output The function should return an integer representing the number of different possible sentences that can be formed. # Constraints * Each word in the resulting sentence must be in the given dictionary. * It\'s not guaranteed that all characters of the input string can be used to form valid sentences. # Examples 1. `s = \\"appletablet\\", dictionary = {\\"apple\\", \\"tablet\\", \\"applet\\", \\"apple\\", \\"table\\", \\"t\\"}` - Output: 4 (`\\"appletablet\\"`, `\\"apple table t\\"`, `\\"applet ablet\\"`, `\\"apple t able t\\"`) 2. `s = \\"thing\\", dictionary = {\\"thing\\"}` - Output: 1 (`\\"thing\\"`) # Requirements - Implement the function to traverse all possible segmentations of the given string. - Ensure that repeated computations are avoided through optimization strategies like memoization. # Scenario Imagine you are helping to develop an auto-correct feature that suggests ways to split a concatenated string into meaningful phrases based on a dictionary. Your solution will help in identifying and counting all possible meaningful sentences.","solution":"def count_sentences(s: str, dictionary: set) -> int: memo = {} def dfs(start): if start == len(s): return 1 if start in memo: return memo[start] count = 0 for end in range(start + 1, len(s) + 1): if s[start:end] in dictionary: count += dfs(end) memo[start] = count return count return dfs(0)"},{"question":"Problem Statement You are tasked with implementing a system that requires precise control over the byte-order manipulations of integers. Specifically, you must implement integer-to-byte conversions and vice versa for both big-endian and little-endian formats. # Task Implement four functions to handle these conversions: 1. `int_to_bytes_big_endian(num)`: Converts an integer `num` into a byte sequence using big-endian format. 2. `int_to_bytes_little_endian(num)`: Converts an integer `num` into a byte sequence using little-endian format. 3. `bytes_big_endian_to_int(bytestr)`: Converts a byte sequence in big-endian format back into the original integer. 4. `bytes_little_endian_to_int(bytestr)`: Converts a byte sequence in little-endian format back into the original integer. # Input/Output Specifications * **Input**: - `int_to_bytes_big_endian(num)`, `int_to_bytes_little_endian(num)`: - `num`: A non-negative integer. - `bytes_big_endian_to_int(bytestr)`, `bytes_little_endian_to_int(bytestr)`: - `bytestr`: A sequence of bytes (bytearray or bytes object). * **Output**: - `int_to_bytes_big_endian(num)`, `int_to_bytes_little_endian(num)`: - A bytes object representing the integer in the specified endianness. - `bytes_big_endian_to_int(bytestr)`, `bytes_little_endian_to_int(bytestr)`: - An integer that is represented by the given byte sequence. # Constraints * You may not use Python\'s built-in functions for big & little-endian conversion (e.g., `int.from_bytes()`, `int.to_bytes()`). * The input integer `num` will be in the range [0, 1 << 32 - 1]. * The input `bytestr` will correctly represent an integer in the appropriate endian format. # Example ```python # Example for Big Endian # Integer to Big Endian Byte Conversion num = 305419896 big_endian_bytes = int_to_bytes_big_endian(num) # Expected Output: b\'x12x34x56x78\' # Big Endian Byte to Integer Conversion original_num = bytes_big_endian_to_int(big_endian_bytes) # Expected Output: 305419896 # Example for Little Endian # Integer to Little Endian Byte Conversion little_endian_bytes = int_to_bytes_little_endian(num) # Expected Output: b\'x78x56x34x12\' # Little Endian Byte to Integer Conversion original_num = bytes_little_endian_to_int(little_endian_bytes) # Expected Output: 305419896 ```","solution":"def int_to_bytes_big_endian(num): Converts an integer into a byte sequence using big-endian format. bytestr = bytearray() for i in range(3, -1, -1): bytestr.append((num >> (i * 8)) & 0xFF) return bytes(bytestr) def int_to_bytes_little_endian(num): Converts an integer into a byte sequence using little-endian format. bytestr = bytearray() for i in range(0, 4): bytestr.append((num >> (i * 8)) & 0xFF) return bytes(bytestr) def bytes_big_endian_to_int(bytestr): Converts a byte sequence in big-endian format back into the original integer. num = 0 for byte in bytestr: num = (num << 8) | byte return num def bytes_little_endian_to_int(bytestr): Converts a byte sequence in little-endian format back into the original integer. num = 0 for i in range(len(bytestr)): num |= bytestr[i] << (i * 8) return num"},{"question":"You are tasked with implementing a palindrome checker. A palindrome is a string that reads the same backward as forward, disregarding non-alphanumeric characters and case differences. # Function Signature ```python def check_palindrome(s: str) -> bool: Determine if the input string s is a palindrome. Params: s (str): The input string to check. Returns: bool: True if s is a palindrome, False otherwise. ``` # Input * `s` (str): The input string containing alphanumeric characters, spaces, and punctuation. # Output * `bool`: Return `True` if the input string is a palindrome, otherwise `False`. # Constraints * The string `s` may be empty. * Only alphanumeric characters should be considered, and case should be ignored. * You should aim for a solution with O(n) time complexity and minimal space overhead. # Example ```python assert check_palindrome(\\"A man, a plan, a canal: Panama\\") == True assert check_palindrome(\\"race a car\\") == False assert check_palindrome(\\"\\") == True assert check_palindrome(\\"No \'x\' in Nixon\\") == True ``` Your task is to implement the function `check_palindrome`.","solution":"def check_palindrome(s: str) -> bool: Determine if the input string s is a palindrome. Params: s (str): The input string to check. Returns: bool: True if s is a palindrome, False otherwise. # Remove non-alphanumeric characters and convert to lowercase cleaned_s = \'\'.join(c.lower() for c in s if c.isalnum()) # Check if the cleaned string is equal to its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"Encode and Decode Strings **Background**: You are tasked with developing an algorithm for encoding a list of strings into a single string that can be efficiently transmitted over a network. Once transmitted, this encoded string needs to be decoded back into the original list of strings. The encoding process should ensure that no information is lost and that the original list can be perfectly reconstructed. **Objective**: Implement the `encode` and `decode` methods for the encoding and decoding process. **Functions to Implement**: ```python def encode(strs): Encodes a list of strings to a single string. :param strs: List of strings to encode. :type strs: List[str] :return: Encoded single string. :rtype: str pass def decode(s): Decodes a single string back into a list of strings. :param s: Encoded single string. :type s: str :return: List of original strings. :rtype: List[str] pass ``` **Input**: - `strs`: List of strings to be encoded. Each string can be of arbitrary length and may contain any character. - `s`: Encoded string that needs to be decoded back into the original list. **Output**: - For `encode`: A single encoded string. - For `decode`: A list of strings that matches the original list used in `encode`. **Constraints**: - The function should handle edge cases like empty strings and lists. - The encoded format should use a delimiter `:` to separate lengths and strings, ensuring no ambiguity. - You should ensure efficient execution for large sets of input strings. **Examples**: ```python # Example 1: input_strs = [\\"hello\\", \\"world\\"] encoded_str = encode(input_strs) # Example: \\"5:hello5:world\\" (actual format may vary) decoded_list = decode(encoded_str) # [\\"hello\\", \\"world\\"] # Example 2: input_strs = [\\"\\", \\"abc\\", \\":\\", \\"123\\"] encoded_str = encode(input_strs) # Example: \\"0:3:abc1::3:123\\" decoded_list = decode(encoded_str) # [\\"\\", \\"abc\\", \\":\\", \\"123\\"] ``` **Instructions**: - Implement the `encode` function to convert a list of strings into a single encoded string. - Implement the `decode` function to convert the encoded string back into the original list of strings. - Ensure your solution handles all specified constraints and edge cases efficiently.","solution":"def encode(strs): Encodes a list of strings to a single string. :param strs: List of strings to encode. :type strs: List[str] :return: Encoded single string. :rtype: str encoded_str = \'\' for s in strs: encoded_str += f\'{len(s)}:{s}\' return encoded_str def decode(s): Decodes a single string back into a list of strings. :param s: Encoded single string. :type s: str :return: List of original strings. :rtype: List[str] decoded_list = [] i = 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 decoded_list.append(s[i:i+length]) i += length return decoded_list"},{"question":"**Stack Sort Check** # Scenario You are working as a software engineer at a firm that processes extensive data. One of your current tasks involves verifying if certain sequences represented by stacks are sorted in ascending order. You need to implement a function that receives a stack and determines whether its elements are sorted from the bottom to the top. # Task Implement a function `is_sorted(stack)` that takes a stack of integers (represented by a list where the last element is the top of the stack) and returns `True` if the stack elements are sorted in ascending order from bottom to top, and `False` otherwise. # Function Signature ```python def is_sorted(stack: list) -> bool: # Your code here ``` # Input * `stack`: A list of integers representing a stack, with the element at index 0 being the bottom and the last element being the top of the stack. # Output * Returns `True` if the stack elements are sorted in ascending order from bottom to top, `False` otherwise. # Constraints * The stack list length will be between `0` and `10^4`. * Each integer in the stack list will lie between `-10^9` and `10^9`. # Examples ```python assert is_sorted([1, 2, 3, 4, 5, 6]) == True assert is_sorted([6, 5, 4, 3, 2, 1]) == False assert is_sorted([6, 3, 5, 1, 2, 4]) == False assert is_sorted([]) == True assert is_sorted([42]) == True ``` # Notes * Your implementation should not permanently alter the original stack. * Pay special attention to edge cases like an empty stack or a stack with a single element.","solution":"def is_sorted(stack): Determines if the elements in the stack are sorted in ascending order from bottom to top. :param stack: List of integers representing the stack. :return: Boolean indicating whether the stack is sorted in ascending order. n = len(stack) for i in range(n - 1): if stack[i] > stack[i + 1]: return False return True"},{"question":"# Question: Finding the Single Non-Repeating Element Scenario: You are given an array of integers where every element appears exactly three times, except for one element which appears exactly once. You need to find this single element. Your solution should be efficient, with a linear runtime complexity, and use constant extra space. Implement the following function: ```python def find_single_element(nums): Given an array of integers where every element appears three times except for one, find the element that appears exactly once. Parameters ---------- nums : List[int] A list of integers where every element appears three times except for one. Returns ------- int The single element that appears exactly once. # your code here ``` Input: - A list of integers `nums` where 1 <= len(nums) <= 3 * 10^4. Each integer in `nums` appears exactly three times except for one integer which appears exactly once. Output: - Output a single integer, the one that appears only once. Example: ```python >>> find_single_element([2, 2, 3, 2]) 3 >>> find_single_element([0, 1, 0, 1, 0, 1, 99]) 99 ``` Constraints: - The algorithm should run in O(n) time complexity. - The algorithm should use O(1) extra space. Good luck!","solution":"def find_single_element(nums): Given an array of integers where every element appears three times except for one, find the element that appears exactly once. Parameters ---------- nums : List[int] A list of integers where every element appears three times except for one. Returns ------- int The single element that appears exactly once. ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"Problem Statement You are asked to optimize and implement the Fibonacci sequence generator. Given a number `n`, return the nth Fibonacci number using three different methods: recursive with memoization, dynamic programming (using a list), and iterative. Each method must handle edge cases and should be optimized for performance. # Requirements 1. **Function Signature** ```python def fib_recursive_memo(n: int) -> int: def fib_list_dp(n: int) -> int: def fib_iterative(n: int) -> int: ``` 2. **Input** - An integer `n` where (0 leq n leq 10^5). 3. **Output** - An integer representing the nth Fibonacci number. 4. **Constraints** - Ensure the functions handle edge cases like `0` and `1`. - Functions should raise an assertion error for negative inputs. 5. **Performance Requirements** - The recursive function must be optimized (use memoization) to handle large n efficiently. - The dynamic programming function should use a list to store intermediate results. - The iterative function should use constant space. # Example ```python assert fib_recursive_memo(10) == 55 assert fib_list_dp(10) == 55 assert fib_iterative(10) == 55 ``` # Detailed Instructions 1. **Recursive with Memoization**: - Implement a recursive method using memoization to avoid redundant calculations. 2. **Dynamic Programming**: - Implement a method using a list to store intermediate results. 3. **Iterative Approach**: - Implement a method that iteratively calculates the nth Fibonacci number using constant space.","solution":"def fib_recursive_memo(n: int, memo={}) -> int: Returns the nth Fibonacci number using a recursive approach with memoization. assert n >= 0, \\"Input should be a non-negative integer\\" if n in memo: return memo[n] if n <= 1: return n memo[n] = fib_recursive_memo(n-1, memo) + fib_recursive_memo(n-2, memo) return memo[n] def fib_list_dp(n: int) -> int: Returns the nth Fibonacci number using a dynamic programming approach with a list. assert n >= 0, \\"Input should be a non-negative integer\\" if n <= 1: return n dp = [0, 1] for i in range(2, n + 1): dp.append(dp[i - 1] + dp[i - 2]) return dp[n] def fib_iterative(n: int) -> int: Returns the nth Fibonacci number using an iterative approach with constant space. assert n >= 0, \\"Input should be a non-negative integer\\" if n <= 1: return n a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"You are tasked with writing a function to find the longest common prefix among an array of strings. Implement this function using a selected algorithmic approach, ensuring to handle edge cases effectively. The function should efficiently determine the longest shared starting sequence in each string. # Function Signature ```python def find_longest_common_prefix(strings: List[str]) -> str: ``` # Input * `strings`: A list of strings (`List[str]`). The list can be empty, in that case, return an empty string. # Output * Returns a single string representing the longest common prefix shared among all strings in the input list. If no common prefix exists, return an empty string. # Constraints * 0 ≤ number of strings ≤ 200 * 0 ≤ length of any string ≤ 200 * Strings consist only of lowercase English letters. # Example ```python # Example 1 Input: [\\"flower\\", \\"flow\\", \\"flight\\"] Output: \\"fl\\" # Example 2 Input: [\\"dog\\", \\"racecar\\", \\"car\\"] Output: \\"\\" # Example 3 Input: [\\"interstellar\\", \\"internet\\", \\"internal\\"] Output: \\"inter\\" ``` # Performance Requirements * The solution should be optimized to handle the upper limits of input constraints efficiently. * The approach should consider minimal time and space complexity, adhering to best practices in algorithm optimization. # Scenario You are working on a trend analysis tool that suggests common tags for a set of articles. Given a list of tags, the function should help in finding the longest common term to use as a primary category, aiding in better organization and search capabilities. # Note * Pay attention to edge cases such as empty arrays and strings with varying lengths. * Ensure the function is robust against invalid indices and handles memory efficiently. * Comment your code to explain the chosen algorithm and any optimizations incorporated. # Hint Consider breaking down the problem using one of the following strategies: Horizontal Scanning, Vertical Scanning, or Divide & Conquer to arrive at the solution effectively.","solution":"from typing import List def find_longest_common_prefix(strings: List[str]) -> str: if not strings: return \\"\\" # Initialize to the first string since we need to compare others to it prefix = strings[0] for i in range(1, len(strings)): temp_prefix = \\"\\" for j in range(min(len(prefix), len(strings[i]))): if prefix[j] == strings[i][j]: temp_prefix += prefix[j] else: break prefix = temp_prefix # If at any point, the common prefix becomes empty, return immediately if prefix == \\"\\": return \\"\\" return prefix"},{"question":"# Problem Description You are tasked with developing a Python function to convert an IPv6 address from its colon-separated hexadecimal format to its binary representation. Each segment in the IPv6 address consists of 16-bit hexadecimal numbers separated by colons. # Function Signature ```python def ipv6_to_binary(ip: str) -> str: Convert a colon-separated hexadecimal IPv6 address to its binary representation. :param ip: IPv6 address in colon-separated hexadecimal format. :return: Colon-separated binary representation of the IPv6 address. pass ``` # Input Format * A single string, `ip`, representing the IPv6 address, e.g., \\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\\". # Output Format * A single string representing the binary format of the IPv6 address where each 16-bit segment is converted to its binary representation. # Constraints * The input string will always be a valid IPv6 address. * Each segment in the IPv6 address will be a valid 16-bit hexadecimal number. # Example * **Input**: \\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\\" * **Output**: \\"0010000000000001:0000110110111000:1000010110100011:0000000000000000:0000000000000000:1000101000101110:0000001101110000:0111001100110100\\" # Notes * The function should always return a binary string with 16-bit binary representations, even if leading zeroes are required. * Consider using Python’s built-in functions for converison from hexadecimal to binary to ensure accuracy and simplicity.","solution":"def ipv6_to_binary(ip: str) -> str: Convert a colon-separated hexadecimal IPv6 address to its binary representation. :param ip: IPv6 address in colon-separated hexadecimal format. :return: Colon-separated binary representation of the IPv6 address. # Split the IPv6 address into segments segments = ip.split(\':\') # Convert each segment to binary, ensuring each binary segment is 16 bits long binary_segments = [\'{0:016b}\'.format(int(segment, 16)) for segment in segments] # Join the binary segments with colons binary_ip = \':\'.join(binary_segments) return binary_ip"},{"question":"# Binary Search Tree (BST) Specification Given the partially implemented Binary Search Tree (BST), your task is to further extend its functionality by implementing the following operations: 1. **Delete**: Implement the delete operation to remove a node with a specified value from the BST. 2. **Height**: Write a method to compute the height of the BST. 3. **Find Min and Max**: Implement methods to find the minimum and maximum values stored in the BST. # Function Signatures ```python def delete(self, data): Deletes a node with the specified value from the BST. :param data: value to delete :return: True if the node was deleted, False if the value was not found def height(self): Computes the height of the BST. :return: integer representing the height of the tree def find_min(self): Finds the minimum value in the BST. :return: minimum value def find_max(self): Finds the maximum value in the BST. :return: maximum value ``` # Input and Output Format - **Delete** - Input: An integer `data` to be deleted. - Output: `True` if deletion was successful, `False` otherwise. - **Height** - Input: None. - Output: Integer height of the BST. - **Find Min and Max** - Input: None. - Output: Integer representing the minimum and maximum value respectively. # Performance Requirements 1. **Delete**: Expected average time complexity is O(log N). Ensure proper handling of three cases: - Node with no children (leaf node). - Node with one child. - Node with two children. 2. **Height**: Should be computed in O(N) time. 3. **Find Min and Max**: Should operate in O(log N) time. # Scenario Consider a BST initially populated with various integer elements. You will add functionalities to effectively manage and query the BST. These methods must be tested against various scenarios including empty tree, single-node tree, tree with multiple elements and balanced/unbalanced tree structures. # Testing Use the provided test framework to write comprehensive tests that validate the correctness and performance of your implementations.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = Node(data) else: self._insert(self.root, data) def _insert(self, node, data): if data < node.data: if node.left is None: node.left = Node(data) else: self._insert(node.left, data) else: if node.right is None: node.right = Node(data) else: self._insert(node.right, data) def delete(self, data): self.root, deleted = self._delete(self.root, data) return deleted def _delete(self, node, data): if node is None: return node, False if data < node.data: node.left, deleted = self._delete(node.left, data) elif data > node.data: node.right, deleted = self._delete(node.right, data) else: if node.left is None: return node.right, True elif node.right is None: return node.left, True min_larger_node = self._get_min(node.right) node.data = min_larger_node.data node.right, _ = self._delete(node.right, min_larger_node.data) return node, True return node, deleted def _get_min(self, node): current = node while current.left is not None: current = current.left return current def height(self): return self._height(self.root) def _height(self, node): if node is None: return 0 left_height = self._height(node.left) right_height = self._height(node.right) return max(left_height, right_height) + 1 def find_min(self): if self.root is None: return None return self._find_min(self.root).data def _find_min(self, node): current = node while current.left is not None: current = current.left return current def find_max(self): if self.root is None: return None return self._find_max(self.root).data def _find_max(self, node): current = node while current.right is not None: current = current.right return current"},{"question":"# Question: Implement a variant of Bucket Sort that distributes elements into buckets more evenly. Your task is to implement a sorting function `improved_bucket_sort` that improves upon the provided `bucket_sort` function by ensuring better distribution of elements across buckets, especially for larger datasets. Input * A list of non-negative integers `arr` where (1 leq text{len(arr)} leq 10^5). * Each integer in the list (0 leq text{arr[i]} leq 10^6). Output * Return the list sorted in non-decreasing order. Constraints 1. The numbers in `arr` are uniformly distributed within the range. 2. Aim to minimize the worst-case time complexity. Performance Requirements * Your solution should run efficiently for input list sizes upto (10^5). Example ```python input: [29, 25, 3, 49, 9, 37, 21, 43] output: [3, 9, 21, 25, 29, 37, 43, 49] ``` Note - Consider optimizing the bucket creation and assignment process to avoid the issue of all elements ending up in a few buckets. - You may choose a different method for sorting individual buckets if it improves performance.","solution":"def improved_bucket_sort(arr): if not arr: return arr max_value = max(arr) size = len(arr) bucket_count = max(1, size // 100) buckets = [[] for _ in range(bucket_count)] for num in arr: bucket_index = min(num * bucket_count // (max_value + 1), bucket_count - 1) buckets[bucket_index].append(num) sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"Given a sorted array in increasing order, write a function `last_occurrence(array, query)` that returns the index of the last occurrence of the given query number in the array. The array is guaranteed to be sorted in increasing order. # Function Signature ```python def last_occurrence(array: List[int], query: int) -> Optional[int]: ``` # Input * `array` - A list of integers sorted in increasing order. * `query` - An integer whose last occurrence needs to be found in the array. # Output * Returns the index of the last occurrence of `query` in the array if `query` is present, otherwise returns `None`. # Constraints * 1 <= len(array) <= 10^5 * -10^9 <= array[i], query <= 10^9 # Example ```python # Example 1 array = [1, 2, 2, 4, 5, 5, 5, 10] query = 5 # returns 6 because the last occurrence of 5 is at index 6. # Example 2 array = [1, 2, 3, 4, 5] query = 6 # returns None because 6 is not present in the array. # Example 3 array = [1, 3, 5, 7, 9, 9, 9] query = 9 # returns 6 because the last occurrence of 9 is at index 6. ``` # Notes * Implement the function using a binary search mechanism. * Consider and handle all possible edge cases such as the query number not being present in the array, the array containing a single element, etc. * Your implementation should be efficient to handle the given constraints.","solution":"from typing import List, Optional def last_occurrence(array: List[int], query: int) -> Optional[int]: Returns the index of the last occurrence of the given query number in the sorted array. left, right = 0, len(array) - 1 result = None while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid left = mid + 1 # Continue searching in the right half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Assessing Strongly Connected Components You are tasked with implementing a critical functionality for analyzing directed graphs. The objective is to write a Python function to identify all strongly connected components (SCCs) in the graph. You will implement Tarjan’s algorithm for this purpose. Function Signature ```python def find_strongly_connected_components(graph: Dict[int, List[int]]) -> List[List[int]]: pass ``` # Requirements 1. **Input**: - A dictionary representing the directed graph, where keys are node identifiers and values are lists of adjacent nodes. - Example Input: `{0: [1], 1: [2], 2: [0], 1: [3, 4], 3: [4], 4: []}` 2. **Output**: - A list of lists, where each sublist represents a strongly connected component. Nodes within each component should be listed in ascending order. - Example Output: `[[0, 1, 2], [3], [4]]` 3. **Constraints**: - All node identifiers will be non-negative integers. - The graph may contain up to 10^5 nodes and 2 * 10^5 edges. # Performance Requirements Your solution should run efficiently with the constraints provided: * Expected Time Complexity: O(V + E) * Expected Space Complexity: O(V) # Implementation Details * Use Tarjan’s algorithm and depth-first search (DFS) to identify strongly connected components. * Ensure all vertices and edges are handled correctly to form accurate SCCs. * Pay special attention to properly updating the `index` and `lowlink` values. # Example Consider a graph described by the following adjacency list: ```python graph = { 0: [1], 1: [2], 2: [0], 1: [3, 4], 3: [4], 4: [] } ``` Your implementation should return: ```python assert find_strongly_connected_components(graph) == [ [0, 1, 2], [3], [4] ] ``` Ensure that your function handles all edge cases and performs efficiently within the given constraints.","solution":"def find_strongly_connected_components(graph): index_counter = [0] stack = [] lowlink = {} index = {} result = [] def strongconnect(node): index[node] = index_counter[0] lowlink[node] = index_counter[0] index_counter[0] += 1 stack.append(node) for neighbor in graph.get(node, []): if neighbor not in lowlink: strongconnect(neighbor) lowlink[node] = min(lowlink[node], lowlink[neighbor]) elif neighbor in stack: lowlink[node] = min(lowlink[node], index[neighbor]) if lowlink[node] == index[node]: component = [] while True: w = stack.pop() component.append(w) if w == node: break component.sort() result.append(component) for node in graph.keys(): if node not in lowlink: strongconnect(node) result.sort(key=lambda x: x[0]) return result"},{"question":"Context You are provided with two functions to perform inorder traversal of a binary tree: iteratively and recursively. You must implement a balanced Binary Search Tree (BST) from a sorted array while using the inorder traversal functions provided to verify its correctness. Task Write a function `sortedArrayToBST` that converts a sorted array into a balanced BST. You must use the provided `inorder` function to verify that the constructed BST\'s inorder traversal matches the original sorted array. The following helper classes and functions are provided for your use: Helper Classes and Functions ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder(root): In order function res = [] if not root: return res stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() res.append(root.val) root = root.right return res ``` Function Signature ```python def sortedArrayToBST(nums: List[int]) -> Node: ``` Input * `nums` : A list of integers sorted in ascending order. Output * Returns the root node of the balanced binary search tree. Constraints 1. The length of `nums` will not exceed 10,000. 2. The elements of `nums` will be distinct integers. Example ```python nums = [-10, -3, 0, 5, 9] root = sortedArrayToBST(nums) assert inorder(root) == [-10, -3, 0, 5, 9] ``` Make sure to handle the edge cases where the input array is empty.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder(root): In order function res = [] if not root: return res stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() res.append(root.val) root = root.right return res def sortedArrayToBST(nums): Converts a sorted array into a balanced BST. if not nums: return None def helper(left, right): if left > right: return None mid = (left + right) // 2 node = Node(nums[mid]) node.left = helper(left, mid - 1) node.right = helper(mid + 1, right) return node return helper(0, len(nums) - 1)"},{"question":"# Programming Assessment Question Scenario You are part of a software engineering team tasked with analyzing communication networks within your company\'s system. Your job is to determine clusters of nodes that communicate to each other within the system without involving external nodes. These clusters are known as **strongly connected components (SCCs)** in a network graph. Problem Statement Given a directed graph, implement a function `find_strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> List[List[int]]` using Kosaraju\'s algorithm that returns all the strongly connected components in the graph. Each SCC should be represented as a list of vertices, and the result should be a list of these components. Input * `V`: Integer (V) (1 ≤ (V) ≤ 10^4), represents the number of vertices in the graph. * `edges`: List of tuples ((u, v)) where (u) and (v) (0 ≤ (u, v) < (V)), represents a directed edge from vertex (u) to vertex (v). Length of `edges` can be up to (5 times 10^4). Output * Return: A list of strongly connected components. Each SCC is a list of vertices contained in that component. Constraints * The graph can be disconnected, and should handle graphs up to the maximum constraints efficiently. * Each SCC should be in any order, but the vertices within each SCC in ascending order. Example ```python V = 6 edges = [(0, 2), (1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 4)] find_strongly_connected_components(V, edges) ``` Expected Output: ``` [[0, 1, 2, 3], [4, 5]] ``` Implementation ```python from typing import List, Tuple class Kosaraju: def __init__(self, V, adj): self.V = V self.adj = adj def dfs(self, i, visited, stk): visited[i] = True for neighbor in self.adj[i]: if not visited[neighbor]: self.dfs(neighbor, visited, stk) stk.append(i) def transpose(self): adjT = [[] for _ in range(self.V)] for v in range(self.V): for neighbor in self.adj[v]: adjT[neighbor].append(v) return adjT def find_scc(self): stack = [] visited = [False] * self.V for i in range(self.V): if not visited[i]: self.dfs(i, visited, stack) adjT = self.transpose() visited = [False] * self.V scc = [] while stack: v = stack.pop() if not visited[v]: component = [] self.dfs(v, visited, component) scc.append(sorted(component)) return scc def find_strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> List[List[int]]: adj = [[] for _ in range(V)] for u, v in edges: adj[u].append(v) kosaraju = Kosaraju(V, adj) return kosaraju.find_scc() ``` In the above code provided: - Instantiate by inputting number of vertices `V` and the list of directed edges. - Perform the two main depth-first searches as per Kosaraju’s algorithm. - Return all strongly connected components.","solution":"from typing import List, Tuple class Kosaraju: def __init__(self, V, adj): self.V = V self.adj = adj def dfs(self, i, visited, stk): visited[i] = True for neighbor in self.adj[i]: if not visited[neighbor]: self.dfs(neighbor, visited, stk) stk.append(i) def transpose(self): adjT = [[] for _ in range(self.V)] for v in range(self.V): for neighbor in self.adj[v]: adjT[neighbor].append(v) return adjT def find_scc(self): stack = [] visited = [False] * self.V for i in range(self.V): if not visited[i]: self.dfs(i, visited, stack) adjT = self.transpose() visited = [False] * self.V scc = [] for i in reversed(stack): if not visited[i]: component = [] self._dfs_transposed(adjT, i, visited, component) scc.append(sorted(component)) return scc def _dfs_transposed(self, adjT, v, visited, component): visited[v] = True component.append(v) for neighbor in adjT[v]: if not visited[neighbor]: self._dfs_transposed(adjT, neighbor, visited, component) def find_strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> List[List[int]]: adj = [[] for _ in range(V)] for u, v in edges: adj[u].append(v) kosaraju = Kosaraju(V, adj) return kosaraju.find_scc()"},{"question":"You are given a sorted array (in ascending order) of `n` integers and a `query` integer. Your task is to implement the Binary Search algorithm to determine the index of `query` in the array. If the `query` is not present, return `-1`. Implement both an iterative and a recursive version of Binary Search. # Function Signatures ```python def binary_search(array: List[int], query: int) -> int: pass def binary_search_recur(array: List[int], low: int, high: int, query: int) -> int: pass ``` # Input * The `array` parameter will contain `n` integers where `1 <= n <= 10^5`. * The `query` parameter will be an integer where `-10^9 <= query <= 10^9`. # Output * The iterative function `binary_search` must return the index of the `query` in the array, or `-1` if the `query` is not present. * The recursive function `binary_search_recur` must follow the same logic but use recursion. It should take the array and additional parameters `low` and `high` which denote the range within the array to search. # Constraints * You must use a Binary Search algorithm. * You must implement both iterative and recursive versions of the algorithm. * The solution should have O(log(n)) time complexity. # Examples 1. `binary_search([1, 3, 5, 7, 9], 5)` returns `2`. 2. `binary_search([1, 3, 5, 7, 9], 4)` returns `-1`. 3. `binary_search_recur([1, 3, 5, 7, 9], 0, 4, 7)` returns `3`. 4. `binary_search_recur([1, 3, 5, 7, 9], 0, 4, 10)` returns `-1`. # Additional Notes * Consider edge cases such as an empty array or a query that is out of the array\'s range. * Pay special attention to the calculation of the midpoint in large arrays to avoid overflow.","solution":"from typing import List def binary_search(array: List[int], query: int) -> int: Perform iterative binary search. Parameters: array (List[int]): Sorted list of integers in ascending order. query (int): The integer to search for in the array. Returns: int: The index of query if found; otherwise, -1. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == query: return mid elif array[mid] < query: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recur(array: List[int], low: int, high: int, query: int) -> int: Perform recursive binary search. Parameters: array (List[int]): Sorted list of integers in ascending order. low (int): The lower bound of the array section to search. high (int): The upper bound of the array section to search. query (int): The integer to search for in the array. Returns: int: The index of query if found; otherwise, -1. if low > high: return -1 mid = (low + high) // 2 if array[mid] == query: return mid elif array[mid] < query: return binary_search_recur(array, mid + 1, high, query) else: return binary_search_recur(array, low, mid - 1, query)"},{"question":"# Flatten Multidimensional Arrays Context Given an array that may contain nested arrays, the task is to produce a single resultant array containing all elements in a flat structure. You are required to implement this functionality using both an iterative generator approach and a recursive approach. Task You need to write two functions: 1. `flatten_list(input_arr: List[Any]) -> List[Any]`: This function should take a nested array and return a flat array containing all the elements. 2. `flatten_generator(input_arr: Iterable[Any]) -> Iterable[Any]`: This function should take a nested array and return an iterator that yields elements in a flattened manner. Inputs and Outputs - **Input**: A potentially nested array (e.g., `[1, [2, 3], [4, [5, 6]], 7]`). - **Output**: - `flatten_list`: A list containing all elements in a flat structure (e.g., `[1, 2, 3, 4, 5, 6, 7]`). - `flatten_generator`: An iterator that yields elements in a flattened manner. Constraints - Arrays can be nested to any level. - Elements can be of any type (e.g., integers, strings, other lists). - You may not use any external libraries except for basic built-in ones. - Consider deeply nested arrays and ensure your recursion depth can handle typical scenarios. Example ```python # Input array = [1, [2, 3], [4, [5, 6]], 7] # Expected Outputs print(flatten_list(array)) => [1, 2, 3, 4, 5, 6, 7] flattened = flatten_generator(array) print(list(flattened)) => [1, 2, 3, 4, 5, 6, 7] ``` Additional Notes Ensure your implementation handles edge cases such as empty arrays, arrays with single elements, and non-iterable objects correctly.","solution":"from typing import List, Any, Iterable def flatten_list(input_arr: List[Any]) -> List[Any]: Function to flatten a nested list recursively. flat_list = [] for item in input_arr: if isinstance(item, list): flat_list.extend(flatten_list(item)) else: flat_list.append(item) return flat_list def flatten_generator(input_arr: Iterable[Any]) -> Iterable[Any]: Function to flatten a nested list using a generator approach. for item in input_arr: if isinstance(item, list): yield from flatten_generator(item) else: yield item"},{"question":"You are given an array that may contain nested arrays of varying depths. Your task is to write a function that takes this array as an input and returns a new array where all the nested arrays are flattened into a single-level array. # Input and Output **Function Signature**: ```python def flatten_array(nested_list): # your code here ``` **Input**: - `nested_list`: A potentially nested list. It can contain integers, floats, strings, or another list. **Output**: - A flat list containing all the elements from the nested lists, maintaining the original order. # Constraints - You cannot use any libraries or built-in functions for flattening (like `itertools.chain`). - Strings should be treated as atomic elements and not split into individual characters. - The input list can be deeply nested, but you can assume no circular references. # Performance Requirements - The solution should have a time complexity of O(n), where n is the total number of elements including all nested elements. - The solution should achieve a space complexity of O(n) due to the storage requirement of the output list. # Example ```python # Example 1 nested_list = [1, [2, 3, [4, 5, [6, 7], 8], 9], 10] print(flatten_array(nested_list)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # Example 2 nested_list = [\'a\', [\'b\', \'c\', [\'d\', \'e\', [\'f\']]], \'g\'] print(flatten_array(nested_list)) # Output: [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\'] # Example 3 nested_list = [] print(flatten_array(nested_list)) # Output: [] # Example 4 nested_list = [[], [[[[]]]], []] print(flatten_array(nested_list)) # Output: [] ``` # Additional Requirements - Ensure the code handles empty nested lists correctly. - Strings should remain whole and not be split into characters.","solution":"def flatten_array(nested_list): Function to flatten a nested list into a single-level list. flat_list = [] def _flatten(element): if isinstance(element, list): for item in element: _flatten(item) else: flat_list.append(element) _flatten(nested_list) return flat_list"},{"question":"You are given a string containing only lowercase alphabets. Your task is to write a function that finds the length of the longest substring without repeating characters and also returns the longest substring itself. # Function Signature ```python def find_longest_substring(string: str) -> Tuple[int, str]: :param string: Input string with lowercase alphabets :return: A tuple with the length of the longest substring and the substring itself ``` # Input * A single string containing only lowercase alphabets (1 <= len(string) <= 10^5). # Output * Return a tuple containing: * An integer representing the length of the longest substring without repeating characters. * The longest substring itself. # Constraints - The input string can have up to 100,000 characters. - Only lowercase alphabetical characters are present in the input string. # Examples 1. Given input `\\"abcabcbb\\"`, the function should return `(3, \\"abc\\")`. 2. Given input `\\"bbbbb\\"`, the function should return `(1, \\"b\\")`. 3. Given input `\\"pwwkew\\"`, the function should return `(3, \\"wke\\")`. # Additional Notes * If there are multiple substrings of the same maximum length, return the one that appears first. * You are encouraged to think about edge cases such as all characters being the same or the input string being very short. # Evaluation Criteria Your solution will be evaluated on: 1. **Correctness**: The function should produce correct results for all possible cases. 2. **Efficiency**: The function should run efficiently within the given constraints. 3. **Code Quality**: The code should be clean, readable, and maintainable.","solution":"from typing import Tuple def find_longest_substring(string: str) -> Tuple[int, str]: Finds the length of the longest substring without repeating characters and the substring itself. :param string: Input string with lowercase alphabets :return: A tuple with the length of the longest substring and the substring itself if not string: return 0, \\"\\" # Dictionary to store the last positions of occurrence last_seen = {} start = 0 max_length = 0 max_substr = \\"\\" for i, char in enumerate(string): # If the character is seen and is within the current substring if char in last_seen and last_seen[char] >= start: start = last_seen[char] + 1 last_seen[char] = i substr_length = i - start + 1 if substr_length > max_length: max_length = substr_length max_substr = string[start:i+1] return max_length, max_substr"},{"question":"**Scenario**: You run a packaging company that arranges packages based on their weights. The packages need to be sorted so they are shipped in an optimal sequence. To streamline the process, you have decided to write a sorting function using the Cocktail Shaker Sort algorithm. **Task**: Implement the function `cocktail_shaker_sort(arr)` which takes a list of integers representing package weights and sorts them in ascending order. # Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` # Input * `arr` (List of integers): A list representing the weights of packages to be sorted. # Output * Returns a list of integers representing the weights in ascending order. # Constraints * The length of `arr` will be between 0 and 10^4. * Each weight will be a non-negative integer. # Performance Requirements * Consider a worst-case scenario and ensure your implementation performs efficiently for large inputs. # Example ```python assert cocktail_shaker_sort([3, 0, 2, 5, -1, 4, 1]) == [-1, 0, 1, 2, 3, 4, 5] assert cocktail_shaker_sort([10, 3, 7]) == [3, 7, 10] assert cocktail_shaker_sort([]) == [] ``` # Notes 1. Ensure your function handles edge cases such as empty lists or lists with one element. 2. The function must sort the list in-place and return the result.","solution":"def cocktail_shaker_sort(arr): Sorts a list of integers using the Cocktail Shaker Sort (bidirectional bubble sort) algorithm. if not arr: return arr n = len(arr) start = 0 end = n - 1 while start <= end: swapped = False # Traverse the list from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If no elements were swapped, then the array is sorted if not swapped: break # Otherwise, reset the swapped flag so it can be used in the next stage swapped = False end -= 1 # Traverse the list from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True # Increase the starting point start += 1 return arr"},{"question":"# Problem: Remove Duplicates from a List of Integers Given a list of integers, write a function `remove_duplicates` that deletes any reoccurring integer and returns a new list with unique integers in the order of their first appearance. Function Signature ```python def remove_duplicates(nums: List[int]) -> List[int]: ``` Input * A list of integers `nums` (0 ≤ len(nums) ≤ 10^5, -10^9 ≤ nums[i] ≤ 10^9). Output * A list containing unique integers in the order they appeared first in `nums`. Example ```python assert remove_duplicates([1, 2, 3, 1, 2, 3]) == [1, 2, 3] assert remove_duplicates([4, 4, 4, 4]) == [4] assert remove_duplicates([]) == [] assert remove_duplicates([10, 9, 8, 10, 9, 8, 8, 9, 10]) == [10, 9, 8] ``` Explanation 1. For the list `[1, 2, 3, 1, 2, 3]`, the function should return `[1, 2, 3]` as it removes all subsequent occurrences of `1`, `2`, and `3`. 2. For the list with all identical integers `[4, 4, 4, 4]`, the function should return `[4]`. 3. For an empty list `[]`, it should return an empty list `[]`. 4. For the list `[10, 9, 8, 10, 9, 8, 8, 9, 10]`, the function should return `[10, 9, 8]`, preserving the first occurrence of each integer. Implement the function ensuring optimal performance for large input sizes.","solution":"def remove_duplicates(nums): Removes duplicates from a list of integers while preserving the order of first appearance. seen = set() unique_nums = [] for num in nums: if num not in seen: unique_nums.append(num) seen.add(num) return unique_nums"},{"question":"# Question: Implement Enhanced Integer Base Conversion Functions Objective You are required to implement two functions for integer base conversion: one that converts an integer to a string representation in a specified base, and another that converts a string representation of a number in a specific base back to an integer. The functions must support all bases from 2 to 36. Function Signatures: 1. `enhanced_int_to_base(num: int, base: int) -> str` 2. `enhanced_base_to_int(str_number: str, base: int) -> int` Parameters: - `enhanced_int_to_base` - `num`: an integer to convert. - `base`: an integer specifying the base (between 2 and 36). - `enhanced_base_to_int` - `str_number`: a string representation of the number in the specified base. - `base`: an integer specifying the base (between 2 and 36). Output: - `enhanced_int_to_base` returns a string representing `num` in the given `base`. - `enhanced_base_to_int` returns the integer value represented by `str_number` in the given `base`. Constraints: - The base must be between 2 and 36, inclusive. - Both functions should handle negative numbers appropriately. - Both functions should properly handle edge cases, such as zero values. - Implement proper input validation and error handling. Example: ```python print(enhanced_int_to_base(5, 2)) # Output: \'101\' print(enhanced_base_to_int(\'101\', 2)) # Output: 5 print(enhanced_int_to_base(-255, 16)) # Output: \'-FF\' print(enhanced_base_to_int(\'-FF\', 16)) # Output: -255 ``` Note: You are not allowed to use the built-in `int()` function for the conversion from string to integer in `enhanced_base_to_int`. # Additional Task: Explain the time and space complexity of your implementations.","solution":"def enhanced_int_to_base(num, base): if not (2 <= base <= 36): raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" is_negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if is_negative: result.append(\'-\') return \'\'.join(result[::-1]) def enhanced_base_to_int(str_number, base): if not (2 <= base <= 36): raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" str_number = str_number.strip().upper() is_negative = str_number[0] == \'-\' if is_negative: str_number = str_number[1:] num = 0 for char in str_number: value = digits.index(char) if value >= base: raise ValueError(f\\"Digit \'{char}\' is not valid for base {base}\\") num = num * base + value return -num if is_negative else num"},{"question":"Problem Statement: The number 89 is the first integer with more than one digit whose digits, when raised to consecutive powers, give the same number. For example, 89 = 8^1 + 9^2 = 89. Another example is 135 = 1^1 + 3^2 + 5^3 = 135. Write a function, `sum_dig_pow`, that returns a list of such numbers within a given range `[low, high]`. Your solution should: 1. Accept two integers `low` and `high` as parameters. 2. Evaluate each number in the range `[low, high]` inclusively to see if it meets the described properties. 3. Return a list of all such numbers. Signature: ```python def sum_dig_pow(low: int, high: int) -> List[int]: ``` Input: * `low` (1 ≤ low ≤ high ≤ 10^6): An integer representing the lower boundary of the range. * `high` (1 ≤ low ≤ high ≤ 10^6): An integer representing the upper boundary of the range. Output: * A list of integers that satisfy the described property within the given range. Example: ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert sum_dig_pow(1, 150) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89, 135] ``` Constraints: - Ensure that your algorithm is efficient and can handle the upper limit of the input constraints without timing out. - Consider edge cases such as non-digit characters or out-of-bound ranges and ensure that your function handles them gracefully.","solution":"def sum_dig_pow(low, high): Returns a list of numbers in the given range [low, high] which satisfy the property that each digit raised to its position equals the number itself. def is_eureka_number(x): digits = list(map(int, str(x))) return x == sum(d ** (i + 1) for i, d in enumerate(digits)) return [x for x in range(low, high + 1) if is_eureka_number(x)]"},{"question":"# Question: Implement a Frequency Limited Sublist Generator Context You are given a list `lst` of integers, and an integer `N` which dictates the maximum number of times any integer should appear in the resultant list. Your task is to implement a function `generate_frequency_limited_list(lst, N)` that returns a new list containing each number from the original list at most `N` times without changing the order of elements. Function Signature ```python def generate_frequency_limited_list(lst: List[int], N: int) -> List[int]: pass ``` Input * `lst`: A list of integers. * `N`: An integer where ( N geq 0 ). Output * A list of integers where each integer from the input list appears at most `N` times, maintaining the original order. Constraints * The elements in `lst` are not sorted and may contain negative numbers. * The length of `lst` can be up to ( 10^5 ). Examples 1. **Input**: `lst = [1, 2, 3, 1, 2, 1, 2, 3]`, `N = 2` **Output**: `[1, 2, 3, 1, 2, 3]` 2. **Input**: `lst = [4, 5, 6, 6, 5, 4, 5, 6]`, `N = 1` **Output**: `[4, 5, 6]` 3. **Input**: `lst = [1, 1, 1, 1]`, `N = 0` **Output**: `[]` 4. **Input**: `lst = [9, 8, 7, 9, 8, 9, 8, 7]`, `N = 3` **Output**: `[9, 8, 7, 9, 8, 9, 8, 7]` Note Ensure that your solution efficiently handles large lists up to ( 10^5 ) elements and consider edge cases such as empty lists or `N` equals zero.","solution":"def generate_frequency_limited_list(lst, N): Generates a new list containing each number from the original list at most N times without changing the order of elements. from collections import defaultdict count = defaultdict(int) result = [] for num in lst: if count[num] < N: result.append(num) count[num] += 1 return result"},{"question":"# Question Write a function `fibonacci_matrix(n: int) -> int` that computes the nth Fibonacci number using matrix exponentiation. The nth Fibonacci number can be derived from the relation: [ F(n) = begin{bmatrix} 1 & 1 1 & 0 end{bmatrix}^n begin{bmatrix} 1 0 end{bmatrix} ] Your task is to: 1. Implement a function to compute the Fibonacci number using the given matrix exponentiation principles. 2. Ensure your function handle edge cases appropriately (e.g., n=0). # Input - An integer `n (0 <= n <= 10^9)` representing the index of the Fibonacci sequence to compute. # Output - An integer representing the `nth` Fibonacci number. # Example ```python assert fibonacci_matrix(0) == 0 assert fibonacci_matrix(1) == 1 assert fibonacci_matrix(10) == 55 ``` # Constraints 1. Your solution should handle up to `n = 10^9` efficiently in terms of both time and space. 2. Assume all intermediate and final results fit within standard integer limits of your programming language. # Notes - You can use the given `multiply` and `identity` functions. - Focus on creating an efficient implementation utilizing matrix exponentiation.","solution":"def matrix_multiply(A, B): Multiplies two 2x2 matrices A and B. return [[A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]]] def matrix_power(matrix, n): Raises the matrix to the power of n using exponentiation by squaring. result = [[1, 0], [0, 1]] # Identity matrix base = matrix while n > 0: if n % 2 == 1: result = matrix_multiply(result, base) base = matrix_multiply(base, base) n //= 2 return result def fibonacci_matrix(n): Computes the nth Fibonacci number using matrix exponentiation. if n == 0: return 0 if n == 1: return 1 matrix = [[1, 1], [1, 0]] result_matrix = matrix_power(matrix, n - 1) return result_matrix[0][0]"},{"question":"# Insertion Sort with Enhanced Visualization You are tasked with enhancing the insertion sort algorithm to better visualize the sorting process. In addition to sorting the array, the goal is to return a list of snapshots showing the array at each step of the sorting process. This will help in understanding how the algorithm processes and sorts the array over time. # Function Signature: ```python def insertion_sort_visualization(arr: List[int]) -> Tuple[List[int], List[List[int]]]: ``` # Parameters: - `arr` (List[int]): An array of integers that needs to be sorted. # Returns: - Tuple containing: - The sorted array (List[int]). - A list of snapshots (List[List[int]]) where each snapshot represents the state of the array at each step of the insertion sort process. # Constraints: - The length of the array (`n`) is between 0 and 1000. - Each element in the array is an integer between -10^6 and 10^6. # Example: ```python arr = [5, 2, 9, 1, 5, 6] sorted_arr, snapshots = insertion_sort_visualization(arr) print(f\\"Sorted Array: {sorted_arr}\\") print(f\\"Snapshots: {snapshots}\\") ``` # Explanation: For the given example, the function should output: ``` Sorted Array: [1, 2, 5, 5, 6, 9] Snapshots: [ [5, 2, 9, 1, 5, 6], [2, 5, 9, 1, 5, 6], [2, 5, 9, 1, 5, 6], [1, 2, 5, 9, 5, 6], [1, 2, 5, 5, 9, 6], [1, 2, 5, 5, 6, 9] ] ``` The `snapshots` list contains the state of the array after each complete insertion operation.","solution":"from typing import List, Tuple def insertion_sort_visualization(arr: List[int]) -> Tuple[List[int], List[List[int]]]: This function performs insertion sort and returns both the sorted array and a list of snapshots showing the array at each step of the sorting process. snapshots = [] snapshots.append(arr.copy()) # Start insertion sort for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, to one position ahead # of their current position while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key # Append a copy of the current state of the array to snapshots snapshots.append(arr.copy()) return arr, snapshots"},{"question":"You are a software engineer tasked with optimizing the performance of sorting in large datasets. Your challenge is to implement a function that performs Quick Sort on an array, but with an enhancement to the pivot selection process. The goal is to reduce the chances of hitting the worst-case time complexity by selecting a pivot using the median-of-three rule. # Function Signature ```python def optimized_quick_sort(arr: list) -> list: ``` # Input and Output - **Input**: A list of integers `arr` - **Output**: A list of integers, sorted in non-decreasing order. # Constraints - The input array can contain up to 10^5 elements. - Each element in the array can be an integer within the range [-10^6, 10^6]. # Requirements 1. Optimize pivot selection using the median-of-three rule. 2. The pivot should be chosen as the median of the first, middle, and last elements of the array (or sub-array in recursive calls). 3. The solution must handle high recursion depth efficiently. # Example ```python print(optimized_quick_sort([3, 6, 8, 10, 1, 2, 1])) # Output: [1, 1, 2, 3, 6, 8, 10] print(optimized_quick_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] ``` # Detailed Explanation - Implement the `partition` function to use the median-of-three rule for pivot selection. - Recursively sort the sub-arrays created by partitioning. - Ensure the solution efficiently manages the recursion depth.","solution":"def optimized_quick_sort(arr): Performs Quick Sort on an array with an optimized pivot selection using the median-of-three rule. if len(arr) <= 1: return arr def median_of_three(left, right): mid = (left + right) // 2 a, b, c = arr[left], arr[mid], arr[right] if a > b: if b > c: return mid elif a > c: return right else: return left else: if a > c: return left elif b > c: return right else: return mid def partition(left, right): pivot_idx = median_of_three(left, right) arr[pivot_idx], arr[right] = arr[right], arr[pivot_idx] pivot = arr[right] i = left for j in range(left, right): if arr[j] < pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[right] = arr[right], arr[i] return i def quick_sort_recursive(left, right): if left >= right: return pivot_idx = partition(left, right) quick_sort_recursive(left, pivot_idx - 1) quick_sort_recursive(pivot_idx + 1, right) quick_sort_recursive(0, len(arr) - 1) return arr"},{"question":"**Question**: Keyboard Row Words *Scenario*: You are developing an application that helps users learn to type more efficiently by analyzing their typing patterns. One feature needs to filter out words that can be typed using letters from only one row of an American keyboard (QWERTY layout). Given an array of words, implement a function to return the words that can be typed using letters of the alphabet located on only one row of an American keyboard. **Function Signature**: ```python def find_keyboard_row(words: List[str]) -> List[str]: ``` **Input**: * `words` - a list of strings (1 <= len(words) <= 100). Each word only contains alphabets and has length between 1 and 12. **Output**: * A list of strings containing the words that can be typed using letters from only one row of an American keyboard. **Constraints**: * All input words consist only of alphabetic characters. * Case sensitivity should be handled; i.e. \'a\' and \'A\' are considered the same character. **Performance Requirements**: * The function should run efficiently for the given constraints. *Example*: Input: `[\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]` Output: `[\\"Alaska\\", \\"Dad\\"]` You need to ensure that your solution is well-optimized and can handle the provided constraints effectively.","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: # Rows of the QWERTY keyboard row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: # Convert the word to lowercase for case insensitive comparison lower_word = set(word.lower()) # Check if the set of word\'s characters is a subset of any keyboard row if lower_word.issubset(row1) or lower_word.issubset(row2) or lower_word.issubset(row3): result.append(word) return result"},{"question":"# Scenario You are working on a plagiarism detection system which needs to identify if a given snippet (word) exists within a large body of text. Implement the Rabin-Karp algorithm to efficiently find the first occurrence of the snippet within the text. # Implementation Details Write a function `find_substring` that takes two strings as input - `pattern` and `text` - and returns the starting index of the first occurrence of the pattern in the text. If the pattern is not found, return `-1`. Ensure your implementation handles empty strings and the case when the pattern is longer than the text. # Function Signature ```python def find_substring(pattern: str, text: str) -> int: pass ``` # Input - `pattern`: a string representing the snippet to search for. - `text`: a string representing the larger body of text to search within. # Output - Return the starting index of the first occurrence of the pattern in the text, or `-1` if the pattern is not found. # Constraints - The pattern and text contain only lowercase letters. - The length of the pattern and text are between `1` and `10^5`. # Examples ```python assert find_substring(\\"abc\\", \\"abdefabcghi\\") == 5 assert find_substring(\\"aaa\\", \\"aaaaaa\\") == 0 assert find_substring(\\"xyz\\", \\"abcdef\\") == -1 assert find_substring(\\"\\", \\"sampletext\\") == -1 assert find_substring(\\"pattern\\", \\"\\") == -1 assert find_substring(\\"longpattern\\", \\"short\\") == -1 ``` # Notes - Ensure you use a rolling hash to efficiently match the pattern. - Carefully handle edge cases, such as when pattern or text are empty, and when pattern length exceeds text length.","solution":"def find_substring(pattern: str, text: str) -> int: Returns the starting index of the first occurrence of the pattern in the text, or -1 if the pattern is not found. if not pattern: # If pattern is empty return -1 if len(pattern) > len(text): # If the pattern is longer than the text return -1 # Base values for the Rabin-Karp algorithm base = 256 prime = 101 pattern_len = len(pattern) text_len = len(text) # Calculate the hash values pattern_hash = 0 text_window_hash = 0 highest_base_power = 1 # This will be base^(pattern_len-1) for i in range(pattern_len - 1): highest_base_power = (highest_base_power * base) % prime for i in range(pattern_len): pattern_hash = (base * pattern_hash + ord(pattern[i])) % prime text_window_hash = (base * text_window_hash + ord(text[i])) % prime # Slide the pattern over the text one character at a time for i in range(text_len - pattern_len + 1): if pattern_hash == text_window_hash: # If the hash values match then only check the substring if text[i:i + pattern_len] == pattern: return i if i < text_len - pattern_len: text_window_hash = (base * (text_window_hash - ord(text[i]) * highest_base_power) + ord(text[i + pattern_len])) % prime # We might get a negative value of text_window_hash, convert it to positive if text_window_hash < 0: text_window_hash += prime return -1"},{"question":"# Word Search with Constraints Objective: You are given a 2D grid `board` consisting of letters and a list of words. Write a function `find_words_with_constraints(board: List[List[str]], words: List[str], n: int) -> List[str]` that returns all words from the list that can be constructed on the board. The words must be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. Additionally, no word should be constructed using cells more than `n` times. Input/Output Format: - **Input**: - `board`: A 2D list of characters `List[List[str]]` where each element is a single lowercase English letter. - `words`: A list of strings `List[str]`, where each string is a word to search. - `n`: An integer representing the maximum times any cell can be used in total across all word constructions. - **Output**: - A list of words `List[str]` found in the board that meet the given constraints. Constraints: - The dimensions of the `board` will be between 1x1 and 12x12 inclusive. - The words list will contain between 1 and 20 words. - Each word in the list will have a length between 1 and 10. - The value of `n` will be between 1 and 20. Example: ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] n = 5 find_words_with_constraints(board, words, n) ``` Expected Output: `[\\"oath\\", \\"eat\\"]` Explanation: - The words \\"oath\\" and \\"eat\\" can be constructed on the board without reusing any cell more than `n` times. Notes: - You will need to use the Trie data structure for efficient word search and backtracking with the additional constraint of keeping track of cell usage across different word searches. - Consider edge cases such as words that do not exist in the board, words overlapping significantly, and boards with cells that have limited variety of letters.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.word = None class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for letter in word: if letter not in node.children: node.children[letter] = TrieNode() node = node.children[letter] node.word = word def find_words_with_constraints(board: List[List[str]], words: List[str], n: int) -> List[str]: def dfs(board, row, col, node, visited, result): if node.word: result.add(node.word) node.word = None if len(visited) > n: return for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_row, new_col = row + dx, col + dy if 0 <= new_row < len(board) and 0 <= new_col < len(board[0]) and (new_row, new_col) not in visited: char = board[new_row][new_col] if char in node.children: visited.add((new_row, new_col)) dfs(board, new_row, new_col, node.children[char], visited, result) visited.remove((new_row, new_col)) trie = Trie() for word in words: trie.insert(word) result = set() usage_count = {} for r in range(len(board)): for c in range(len(board[0])): if board[r][c] in trie.root.children: visited = set([(r, c)]) dfs(board, r, c, trie.root.children[board[r][c]], visited, result) result_with_constraints = [] for word in result: cell_usage = {} for r in range(len(board)): for c in range(len(board[0])): if board[r][c] == word[0]: visited = set([(r, c)]) count = get_usage_count(board, r, c, word, 1, cell_usage) if count <= n: result_with_constraints.append(word) break return result_with_constraints def get_usage_count(board, row, col, word, index, cell_usage): if index == len(word): return 0 total_count = 0 char = word[index] found = False for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_row, new_col = row + dx, col + dy if 0 <= new_row < len(board) and 0 <= new_col < len(board[0]) and (new_row, new_col) not in cell_usage: if board[new_row][new_col] == char: cell_usage[(new_row, new_col)] = cell_usage.get((new_row, new_col), 0) + 1 found = True count = get_usage_count(board, new_row, new_col, word, index + 1, cell_usage) total_count = max(total_count, cell_usage[(new_row, new_col)] + count) cell_usage[(new_row, new_col)] -= 1 if cell_usage[(new_row, new_col)] == 0: del cell_usage[(new_row, new_col)] if not found: return float(\\"inf\\") return total_count"},{"question":"# Summarizing Consecutive Ranges **Context**: Imagine you\'re developing a feature for a data analysis application. The feature needs to summarize ranges of consecutive integer values in a sorted list. **Task**: Write a function `summarize_ranges` that takes a sorted list of non-duplicate integers and returns a list of strings summarizing the ranges of consecutive numbers. Function Signature: ```python def summarize_ranges(array: List[int]) -> List[str]: pass ``` Input: * `array`: A list of sorted integers without duplicates. * Example: `[0, 1, 2, 4, 5, 7]` Output: * A list of strings, where each string represents a range of consecutive integers. * Example: `[\\"0-2\\", \\"4-5\\", \\"7\\"]` Constraints: * The input list may contain between 0 and 10^5 integers. * Each integer will be in the range from -10^9 to 10^9. Performance Requirements: * Your solution should run in linear time relative to the size of the input list. * Utilize constant additional space for computation, aside from the space used to store the output. Example: ```python assert summarize_ranges([0, 1, 2, 4, 5, 7]) == [\\"0-2\\", \\"4-5\\", \\"7\\"] assert summarize_ranges([2, 3, 4, 6, 8, 9, 10]) == [\\"2-4\\", \\"6\\", \\"8-10\\"] assert summarize_ranges([-5, -4, -3, 1]) == [\\"-5--3\\", \\"1\\"] ``` **Note**: Ensure you handle edge cases such as an empty list or a list with only one element. **Hint**: Use start and end pointers to track the beginning and end of each range, updating the pointers as you traverse the list.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] ranges = [] start = array[0] end = array[0] for num in array[1:]: if num == end + 1: end = num else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = num end = num if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"# Question Given a number, find the next higher number which has the exact same set of digits as the original number. If no such number exists, return -1. Your task is to implement a function `next_bigger(num)` that accomplishes this task. Function Signature ```python def next_bigger(num: int) -> int: ``` Input - `num`: an integer value where 1 <= num <= 10^9. Output - Return the next bigger number with the same set of digits. Return -1 if no such number exists. Constraints - The input will always be a valid integer. - The next bigger number, if exists, will not exceed 10^9. Performance Requirements - The function should work efficiently for all the numbers in the given range. Examples ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(99999) == -1 assert next_bigger(1) == -1 ``` Notes - Pay attention to edge cases such as when all digits are the same or in descending order. - Optimize for both time and space complexity where possible.","solution":"def next_bigger(num: int) -> int: Given a number, find the next higher number which has the exact same set of digits as the original number. If no such number exists, return -1. num_list = list(str(num)) # Convert number to a list of digits n = len(num_list) # Traverse the number from the right for i in range(n - 2, -1, -1): if num_list[i] < num_list[i + 1]: break else: return -1 # If no such pair is found, return -1 # Find the smallest digit on the right side of num_list[i] that is greater than num_list[i] for j in range(n - 1, i, -1): if num_list[j] > num_list[i]: break # Swap numbers at i and j num_list[i], num_list[j] = num_list[j], num_list[i] # Reverse the digits after the index i num_list = num_list[:i + 1] + sorted(num_list[i + 1:]) next_bigger_num = int(\\"\\".join(num_list)) # Check if the number is within the allowed range return next_bigger_num if next_bigger_num <= 1_000_000_000 else -1"},{"question":"You are given a string **s** and a dictionary of words **dictionaries**. Write a function `count_sentences(s, dictionaries)` that returns the number of ways you can split the string into a sequence of dictionary words. Example - For `s = \\"appletablet\\"` and `dictionaries = {\\"apple\\", \\"tablet\\", \\"applet\\", \\"able\\", \\"t\\"}`, there are 3 possible sentences: - `\\"apple tablet\\"` - `\\"app let able t\\"` - `\\"applet\\"` - For `s = \\"thing\\"` and `dictionaries = {\\"thing\\"}`, there is 1 possible sentence: - `\\"thing\\"` Function Signature ```python def count_sentences(s: str, dictionaries: set) -> int: ``` Input - `s`: A non-empty string (1 ≤ len(s) ≤ 500). - `dictionaries`: A set of words available for creating sentences with length constraints (1 ≤ len(word) ≤ len(s)). Output - Returns an integer indicating the number of ways the string can be segmented into words from the dictionary. Constraints 1. The same word in the dictionary can be reused multiple times. 2. The input string can be assumed to be lowercase alphabets. Requirements 1. Ensure the solution is efficient enough to handle the upper constraint limits. 2. Handle edge cases such as the empty string correctly.","solution":"def count_sentences(s: str, dictionaries: set) -> int: Returns the number of ways the string s can be split into a sequence of words from dictionaries. # Using dynamic programming to count number of ways to split s n = len(s) dp = [0] * (n + 1) dp[0] = 1 # base case: there\'s one way to split an empty string for i in range(1, n + 1): for word in dictionaries: if i >= len(word) and s[i-len(word):i] == word: dp[i] += dp[i-len(word)] return dp[n]"},{"question":"# QWERTY Keyboard Word Filter Your task is to write a function that filters words based on whether they can be typed using letters from only one row of a QWERTY keyboard. Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: ``` Input * `words`: A list of strings `List[str]`, where each string consists of alphabetic characters (both upper and lowercase). * **Constraints**: - The number of words (n) will be in the range ([1, 1000]). - The length of each word (m) will be in the range ([1, 20]). Output * `A` list of strings containing only those words from the input that can be typed using letters from just one row on a standard QWERTY keyboard. Example Input: ```python words = [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] ``` Output: ```python [\\"Alaska\\", \\"Dad\\"] ``` Explanation * \\"Alaska\\" can be typed using the second row: `a, s, d, f, g, h, j, k, l`. * \\"Dad\\" can be typed using letters from the first and second rows but all characters are contained in the second. * \\"Hello\\" and \\"Peace\\" cannot be typed using just one row of the keyboard. Requirements * The function should handle both uppercase and lowercase inputs effectively. * It should account for different word lengths and return an accurate result based on the described criteria.","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: lower_word = set(word.lower()) if lower_word.issubset(row1) or lower_word.issubset(row2) or lower_word.issubset(row3): result.append(word) return result"},{"question":"# Question: Search for a Key in a Sorted Matrix Given a matrix where every row and every column are sorted in non-decreasing order, write a function `search_in_matrix(matrix, rows, cols, key)` that searches for a specified key within the matrix. Your function should print the position of the key in the matrix if it is found or notify that the key is not found. The function should be efficient and have a time complexity of O(m + n), where \'m\' is the number of rows and \'n\' is the number of columns. Input: - `matrix` (List[List[int]]): A 2D list representing the matrix. - `rows` (int): Number of rows in the matrix. - `cols` (int): Number of columns in the matrix. - `key` (int): The key to search for within the matrix. Output: - If the key is found, print the position as: `Key {key} found at row- {row} column- {col}`. - If the key is not found, print: `Key {key} not found`. Example: ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 search_in_matrix(matrix, len(matrix), len(matrix[0]), key) # Output: \\"Key 13 found at row- 2 column- 3\\" key = 10 search_in_matrix(matrix, len(matrix), len(matrix[0]), key) # Output: \\"Key 10 not found\\" ``` Constraints: - The number of rows (m) and columns (n) is between 1 and 1000. - Each element in the matrix is an integer where -10^6 ≤ matrix[i][j] ≤ 10^6. - The key is an integer within the range -10^6 to 10^6.","solution":"def search_in_matrix(matrix, rows, cols, key): Searches for a key in a sorted matrix and prints the position if found or not found message. Args: matrix (List[List[int]]): A 2D list representing the matrix. rows (int): Number of rows in the matrix. cols (int): Number of columns in the matrix. key (int): The key to search for within the matrix. # Start from the top-right corner of the matrix row, col = 0, cols - 1 # Continue while we are inside the bounds of the matrix while row < rows and col >= 0: if matrix[row][col] == key: print(f\\"Key {key} found at row- {row + 1} column- {col + 1}\\") return elif matrix[row][col] > key: col -= 1 # Move left else: row += 1 # Move down print(f\\"Key {key} not found\\")"},{"question":"# Problem: Flexible Base Converter Alice is a software developer working on a project that requires conversion of integers to and from various numeral systems. She needs a robust utility to handle these conversions efficiently. You have been asked to help her by writing a couple of functions: one to convert a positive or negative integer to a given base between 2 and 36, and another to convert a string representing a number in any base between 2 and 36 back to a decimal integer. Function 1: `int_to_base(num, base):` * **Input**: * `num` - (int) the integer to convert (can be negative). * `base` - (int) the base to which the number needs to be converted (2 <= base <= 36). * **Output**: * (str) the string representation of the number in the specified base. Function 2: `base_to_int(str_to_convert, base):` * **Input**: * `str_to_convert` - (str) string representing the number in the given base. * `base` - (int) the base of the input number (2 <= base <= 36). * **Output**: * (int) the decimal integer representation of the input string. Example: ```python assert int_to_base(5, 2) == \'101\' assert int_to_base(-255, 16) == \'-FF\' assert base_to_int(\'101\', 2) == 5 assert base_to_int(\'FF\', 16) == 255 ``` Constraints: * You must not use Python\'s built-in `int()` method for `base_to_int`. * You should handle invalid inputs gracefully (bases outside of the valid range, invalid characters in the string for the given base, etc.). Tips: * Use a string containing digits and uppercase alphabet characters to map values for conversion. * Pay attention to sign handling, especially for negative numbers in `int_to_base`. Your implementation should be efficient and robust, capable of handling any valid input within the specified constraints.","solution":"def int_to_base(num, base): Convert a given integer to a specified base representation. Args: num (int): The integer to convert. base (int): The base for conversion. Must be between 2 and 36. Returns: str: The string representation of the number in the specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \'0\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" sign = \'-\' if num < 0 else \'\' num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base return sign + \'\'.join(reversed(result)) def base_to_int(str_to_convert, base): Convert a string representation of a number in a specified base to a decimal integer. Args: str_to_convert (str): The string representing the number. base (int): The base of the number. Must be between 2 and 36. Returns: int: The decimal integer representation of the input string. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") str_to_convert = str_to_convert.strip().upper() if not str_to_convert: raise ValueError(\\"Input string is invalid\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" value_map = {char: index for index, char in enumerate(digits)} sign = -1 if str_to_convert[0] == \'-\' else 1 if str_to_convert[0] in \'+-\': str_to_convert = str_to_convert[1:] value = 0 for char in str_to_convert: if char not in value_map or value_map[char] >= base: raise ValueError(f\\"Invalid character \'{char}\' for base {base}\\") value = value * base + value_map[char] return sign * value"},{"question":"You are tasked with implementing a `ResizableHashTable`, which dynamically adjusts its size as more elements are added, in such a way that the time complexity of the `put`, `get`, and `del` operations remains close to O(1) in the average case by resizing when the table becomes too full. # Function Signature ```python class ResizableHashTable: def __init__(self): pass def put(self, key: int, value: any) -> None: pass def get(self, key: int) -> any: pass def del_(self, key: int) -> None: pass def __getitem__(self, key: int) -> any: pass def __delitem__(self, key: int) -> None: pass def __setitem__(self, key: int, value: any) -> None: pass def __len__(self) -> int: pass ``` # Requirements - Implement a **hash table** with dynamic resizing. # Detailed Requirements 1. **Initialization**: - Initializes the hash table with a minimum size. 2. **Put Operation**: - Inserts a key-value pair into the hash table. - Triggers resizing when 2/3 of the slots are filled. 3. **Get Operation**: - Retrieves the value associated with a given key. 4. **Delete Operation**: - Removes a key-value pair from the hash table. 5. **Special Methods**: - Magic methods `__getitem__`, `__setitem__`, and `__delitem__` to allow using the HashTable like a Python dictionary. - `__len__` method to return the number of items in the hash table. # Input and Output Formats * **put(key, value)**: `key` is an integer, and `value` can be any type. * **get(key)**: Return the value associated with the `key` if it exists, or `None` otherwise. * **del_(key)**: Delete the key-value pair if it exists, otherwise no action. * **__setitem__(key, value)**: Same as the put operation. * **__getitem__(key)**: Same as the get operation. * **__delitem__(key)**: Same as del_ operation. * **__len__()**: Return the number of key-value pairs in the hash table. # Constraints 1. The hash table should handle linear probing for collision resolution. 2. When resizing, rehash all existing key-value pairs efficiently. 3. Include edge case handling such as managing deleted slots and proper resizing triggers. 4. You may assume keys are integers and are unique. # Example Usage ```python ht = ResizableHashTable() ht.put(1, \'one\') ht.put(2, \'two\') print(ht.get(1)) # Output: \'one\' print(ht.get(3)) # Output: None ht[3] = \'three\' print(ht[3]) # Output: \'three\' del ht[2] print(ht.get(2)) # Output: None print(len(ht)) # Output: 2 ```","solution":"class ResizableHashTable: def __init__(self): self.size = 8 # Initial size of hash table self.count = 0 # Number of key-value pairs in the hash table self.table = [None] * self.size def _hash(self, key): return key % self.size def _rehash(self, key, i): # Linear probing return (self._hash(key) + i) % self.size def _resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: key, value = item self.put(key, value) def put(self, key, value): if self.count >= 2 * self.size // 3: self._resize() index = self._hash(key) i = 0 while self.table[index] is not None and self.table[index][0] != key: i += 1 index = self._rehash(key, i) if self.table[index] is None: self.count += 1 self.table[index] = (key, value) def get(self, key): index = self._hash(key) i = 0 while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] i += 1 index = self._rehash(key, i) return None def del_(self, key): index = self._hash(key) i = 0 while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.count -= 1 return i += 1 index = self._rehash(key, i) def __getitem__(self, key): return self.get(key) def __setitem__(self, key, value): self.put(key, value) def __delitem__(self, key): self.del_(key) def __len__(self): return self.count"},{"question":"# Counting Sort Challenge Background: You\'re tasked with implementing a specialized version of the Counting Sort algorithm, which is tailored to handle arrays containing both positive and negative integers. Objective: Implement a function `counting_sort_variant(arr)` that carries out the counting sort on an array of integers, which may include negative numbers. Your implementation should normalize the array to handle negative values, sort the array using the counting sort principles, and then convert it back to its original values. Function Signature: ```python def counting_sort_variant(arr: List[int]) -> List[int]: ``` Input: * `arr`: A list of integers where the length of `arr` is (n) (0 ≤ (n) ≤ 100,000) and any integer element\'s value lies in the range of (-100,000 ≤ arr[i] ≤ 100,000). Output: * Returns the sorted list of integers. Constraints: 1. You must use the Counting Sort algorithm principles as discussed. 2. The function should efficiently handle the provided constraints on range and size. Example: ```python # Example 1: input_array = [4, 2, -3, 6, 8, -5, 0, 2] output_array = counting_sort_variant(input_array) print(output_array) # Output: [-5, -3, 0, 2, 2, 4, 6, 8] # Example 2: input_array = [-1, -1, 0, 0, 1, 1] output_array = counting_sort_variant(input_array) print(output_array) # Output: [-1, -1, 0, 0, 1, 1] ``` Notes: * Be sure to handle arrays containing only negative numbers, only positive numbers, or a mix of both effectively. * Always validate the implementation against the edge cases provided.","solution":"from typing import List def counting_sort_variant(arr: List[int]) -> List[int]: if not arr: return [] # Find the minimum and maximum values in arr min_value = min(arr) max_value = max(arr) # Create the count array with a size of (maximum - minimum + 1) count = [0] * (max_value - min_value + 1) # Populate the count array for number in arr: count[number - min_value] += 1 # Generate the sorted array sorted_arr = [] for i, cnt in enumerate(count): sorted_arr.extend([i + min_value] * cnt) return sorted_arr"},{"question":"Question: Efficient Exponentiation with Error Handling You are tasked with writing an optimized function for computing the result of raising an integer to a power, optionally taking the result modulo another integer. This is a common operation in various mathematical and cryptographic computations. Your function should be efficient and handle edge cases effectively. You must implement both iterative and recursive versions of the binary exponentiation algorithm. Additionally, you should incorporate error handling to address invalid inputs. # Function Signature ```python def power(a: int, n: int, mod: int = None) -> int: pass def power_recur(a: int, n: int, mod: int = None) -> int: pass ``` # Input - `a` (int): The base integer (can be negative). - `n` (int): The exponent (must be non-negative). - `mod` (int, optional): If specified, compute the result modulo this value (must be positive if provided). # Output - Return the result of ( a^n ), optionally modulo `mod`. # Constraints - The exponent `n` is non-negative. - If `mod` is specified, it is a positive integer. - The base `a` can be any integer (negative, zero, positive). # Requirements - The function should be efficient with a time complexity of ( O(log n) ). - The iterative version should have a space complexity of ( O(1) ). - The recursive version should have a space complexity of ( O(log n) ). # Examples 1. `power(2, 10)` should return `1024`. 2. `power(2, 10, 1000)` should return `24`. 3. `power_recur(2, 10)` should return `1024`. 4. `power_recur(2, 10, 1000)` should return `24`. 5. `power(5, 0)` should return `1`. # Notes - Ensure that the functions handle edge cases properly. - Test for performance with large values of `n` and ensure the functions run within acceptable time limits. # Error Handling - Raise an appropriate exception if the exponent `n` is negative. - Raise an appropriate exception if `mod` is specified but is not a positive integer. Good luck with your implementation!","solution":"def power(a: int, n: int, mod: int = None) -> int: Iterative version of the binary exponentiation algorithm. Computes a^n % mod if mod is specified. if n < 0: raise ValueError(\\"Exponent should be non-negative\\") if mod is not None and mod <= 0: raise ValueError(\\"Modulus should be a positive integer\\") result = 1 base = a while n > 0: if n % 2 == 1: # If n is odd result = (result * base) % mod if mod else result * base base = (base * base) % mod if mod else base * base n //= 2 return result def power_recur(a: int, n: int, mod: int = None) -> int: Recursive version of the binary exponentiation algorithm. Computes a^n % mod if mod is specified. if n < 0: raise ValueError(\\"Exponent should be non-negative\\") if mod is not None and mod <= 0: raise ValueError(\\"Modulus should be a positive integer\\") def recur(base, exponent): if exponent == 0: return 1 half = recur(base, exponent // 2) half = (half * half) % mod if mod else half * half if exponent % 2 == 0: return half else: return (half * base) % mod if mod else half * base return recur(a, n)"},{"question":"You are developing a library management system that categorizes books by their titles to group together similar titles which can be formed by rearranging characters, i.e., anagrams. Write a function named `group_anagrams` that groups anagrams from a list of book titles. # Input - A list of strings `book_titles` where each string represents a book title. The length of the list can go up to 10,000 titles and each title can have a maximum length of 100 characters. # Output - A list of lists, where each inner list contains strings that are anagrams of each other from the input list. # Constraints - All input strings will be lowercase alphabets. - The output does not need to be in any particular order. # Performance Requirements - Aim to achieve a total time complexity of about (O(N cdot K log K)), where (N) is the number of titles, and (K) is the maximum length of the titles. # Example ```python book_titles = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"google\\", \\"gogole\\", \\"abc\\", \\"cab\\", \\"bac\\"] output = group_anagrams(book_titles) # Output could be: # [ # [\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\"], # [\\"google\\", \\"gogole\\"], # [\\"abc\\", \\"cab\\", \\"bac\\"] # ] ``` # Note Your function should handle edge cases like: - An empty list of titles. - Titles that are already sorted but are anagrams of each other. - Titles with varying lengths. Write a well-documented and optimized function to handle the above requirements.","solution":"from collections import defaultdict def group_anagrams(book_titles): Groups anagrams from a list of book titles. Parameters: book_titles (list of str): List of book titles. Returns: list of list of str: Grouped anagrams. anagram_map = defaultdict(list) for title in book_titles: # Sort the title to use it as a key sorted_title = \'\'.join(sorted(title)) anagram_map[sorted_title].append(title) # Return the grouped anagrams return list(anagram_map.values())"},{"question":"You are given a pattern string and a sentence string. Write a function `word_pattern(pattern, sentence)` that checks if the sentence follows the same pattern as the pattern string. Here, following the pattern means there is a bijection between a letter in the pattern and a non-empty word in the sentence. # Input - `pattern`: A string containing only lowercase letters. - `sentence`: A string containing lowercase words separated by a single space. # Output - Return `True` if the sentence follows the same pattern as the pattern string, otherwise `False`. # Constraints - The length of the pattern string and the number of words in the sentence must be the same for a valid match. - `pattern` will contain only lowercase English letters (a-z), and `sentence` will contain lowercase words separated by a single space. # Examples Example 1: ```plaintext Input: pattern = \\"abba\\", sentence = \\"dog cat cat dog\\" Output: True ``` Example 2: ```plaintext Input: pattern = \\"abba\\", sentence = \\"dog cat cat fish\\" Output: False ``` Example 3: ```plaintext Input: pattern = \\"aaaa\\", sentence = \\"dog cat cat dog\\" Output: False ``` Example 4: ```plaintext Input: pattern = \\"abba\\", sentence = \\"dog dog dog dog\\" Output: False ``` # Guidelines - Ensure the code has a time complexity of O(n). - Aim to handle potential edge cases effectively. - Your solution should not just account for typical cases but also edge cases like empty strings where applicable, though the given examples assume non-empty strings. # Function Signature ```python def word_pattern(pattern: str, sentence: str) -> bool: pass ```","solution":"def word_pattern(pattern, sentence): Checks if the sentence follows the same pattern as the pattern string. words = sentence.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char not in char_to_word: char_to_word[char] = word if word not in word_to_char: word_to_char[word] = char if char_to_word[char] != word or word_to_char[word] != char: return False return True"},{"question":"# Coin Change Combination Problem **Scenario**: You run a financial planning company that helps clients understand different ways they can achieve their savings goals. In one service, you need to advise them on how many ways they can combine different denominations of coins to make up a particular value. **Problem**: Given a target value `value` and an infinite supply of each of the coin denominations listed in the array `coins`, determine how many distinct combinations of coin sums can make up that target value. The order of coins in the sum does not matter. **Function Specification**: ```python def count(coins, value): Find number of combination of `coins` that adds up to `value` Keyword arguments: coins -- list of int, denotes available coin denominations value -- int, the target value to be achieved with coins ``` **Input**: * `coins` - A list of `m` integers where each integer represents a different coin denomination. (`1 <= m <= 50`), (`1 <= coins[i] <= 100`) * `value` - An integer representing the target value to achieve. (`0 <= value <= 10000`) **Output**: * Return an integer representing the number of distinct ways the coins can be combined to sum up to the target value. **Constraints**: * Result must be calculated in less than 1 second for given input bounds. **Examples**: 1. `count([1, 2, 3], 4)` should return `4` because there are four combinations to make 4: `[1, 1, 1, 1]`, `[1, 1, 2]`, `[2, 2]`, `[1, 3]`. 2. `count([2, 5, 3, 6], 10)` should return `5` because there are five combinations to make 10: `[2, 2, 2, 2, 2]`, `[2, 2, 3, 3]`, `[2, 2, 6]`, `[2, 3, 5]` and `[5, 5]`. **Explanation of Example 1**: For the input `value = 4` and `coins = [1, 2, 3]`, the function should return `4` as there are the following 4 ways to make up 4: `[1+1+1+1, 1+1+2, 2+2, 1+3]`. **Your Task**: Write a function using the specification provided above that correctly computes the number of ways to combine the given coin denominations to sum up to the `value`.","solution":"def count(coins, value): Returns the number of distinct ways to make up the target value using the given coin denominations. :param coins: List[int] - List of available coin denominations :param value: int - The target value to be achieved with coins :return: int - Number of ways to combine the given coin denominations to sum up to the value # Initialize an array to store the count of combinations for each amount up to the target value dp = [0] * (value + 1) dp[0] = 1 # There\'s one way to get zero value - using no coins # For each coin, update the dp array for coin in coins: for amount in range(coin, value + 1): dp[amount] += dp[amount - coin] return dp[value]"},{"question":"# Scenario A segment tree is a versatile data structure ideal for answering range queries over an array efficiently. Imagine you are a software engineer tasked with developing a range query system for a large-scale application where the dataset undergoes frequent changes. You need to implement and utilize a segment tree to handle range sum queries and updates dynamically. # Problem Statement Write a class `SegmentTree` that supports the following functionalities: 1. **Initialization (`__init__`)**: - Takes an array of integers and constructs the segment tree. 2. **Query (`range_sum`)**: - Returns the sum of elements between two given indices in the array (inclusive). 3. **Update (`update`)**: - Updates the value at a specific index in the array and adjusts the segment tree accordingly. # Input - `__init__`: - An array of integers `arr` (0 ≤ arr[i] ≤ 10^9, 1 ≤ len(arr) ≤ 10^5). - `range_sum`: - Two integers `L` and `R` representing the query range (0 ≤ L ≤ R < len(arr)). - `update`: - Two integers `index` and `value` where `value` is the new element to be updated at `index` in the array (0 ≤ index < len(arr), 0 ≤ value ≤ 10^9). # Output - `range_sum`: - Return the integer sum of elements from index `L` to `R`. - `update`: - No return value. # Constraints - Optimized for both query and update operations with time complexity O(log N) for each. - Handle edge cases such as empty queries or index updates. # Example ```python # Initialization arr = [1, 3, 5, 7, 9, 11] seg_tree = SegmentTree(arr) # Queries print(seg_tree.range_sum(1, 3)) # Output: 15 print(seg_tree.range_sum(0, 5)) # Output: 36 # Update seg_tree.update(3, 10) # Queries after update print(seg_tree.range_sum(1, 3)) # Output: 18 ``` # Note Implement the segment tree using a bottom-up approach to ensure efficient query and update operations.","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr): # Initial array values in the second half of the tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def range_sum(self, L, R): # Adjust indices to point to the leaves L += self.n R += self.n sum = 0 while L <= R: if L % 2 == 1: sum += self.tree[L] L += 1 if R % 2 == 0: sum += self.tree[R] R -= 1 L //= 2 R //= 2 return sum def update(self, index, value): # Set value at position index pos = index + self.n self.tree[pos] = value # Move upwards and update parents while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]"},{"question":"# Scenario In a world where digital content is rampant, you are tasked with creating a tool to detect specific words or phrases within large documents efficiently. For this purpose, you want to use the Rabin-Karp algorithm to find the starting index of a given word within a given text. # Question Implement a function `find_word_index(word: str, text: str) -> Optional[int]` using the provided Rabin-Karp algorithm. Your function should return the starting index of the first occurrence of `word` in `text`. If the word is not found, return `None`. # Function Signature ```python def find_word_index(word: str, text: str) -> Optional[int]: pass ``` Input - `word`: A non-empty string representing the word to search for. - `text`: A string representing the text to search within. Output - An integer representing the starting index of the first occurrence of `word` in `text`, or `None` if `word` is not found. Constraints - Both `word` and `text` contain only lowercase letters a-z. - The length of `word` is at most equal to `text`. Performance Requirements - Efficient average-case performance is expected. Aim for a solution that handles most cases in linear time relative to the size of the text. Example ```python print(find_word_index(\\"abc\\", \\"abcdef\\")) # Output: 0 print(find_word_index(\\"abc\\", \\"ababcabc\\")) # Output: 2 print(find_word_index(\\"xyz\\", \\"abcdef\\")) # Output: None ```","solution":"from typing import Optional def find_word_index(word: str, text: str) -> Optional[int]: Returns the starting index of the first occurrence of \'word\' in \'text\' using the Rabin-Karp algorithm. If the word is not found, returns None. n = len(text) m = len(word) if m > n: return None # Prime number for hash calculation prime = 101 # Function to calculate hash value def calculate_hash(s: str, end: int) -> int: h = 0 for i in range(end): h = h * prime + ord(s[i]) return h # Initial hashes hash_word = calculate_hash(word, m) hash_text = calculate_hash(text, m) # Sliding window to check every substring for i in range(n - m + 1): if hash_word == hash_text: # Potential match found if text[i:i+m] == word: # Verify actual match return i if i < n - m: # Compute next window hash: Rabin-Karp rolling hash function hash_text = (hash_text - ord(text[i]) * (prime ** (m - 1))) * prime + ord(text[i + m]) return None"},{"question":"You are given a sorted array of integers in non-decreasing order. Your task is to implement a search method that efficiently finds the position of a given target value using interpolation search strategy tailored for specific conditions of the dataset. Requirements: * Write a function named `advanced_interpolation_search(array: List[int], search_key: int) -> int` which takes a sorted list `array` and an integer `search_key`. * If `search_key` is found in the array, return its index. * If `search_key` is not found, return -1. # Input: * `array` (List[int]): A list of integers sorted in non-decreasing order. * `search_key` (int): An integer value to search for within the array. # Output: * (int): The index of `search_key` in `array` if found; otherwise, -1. # Constraints: 1. `1 <= len(array) <= 10^7` 2. `-10^9 <= array[i], search_key <= 10^9` # Example Scenarios: ```python # Example 1 array = [-25, -12, -1, 10, 12, 15, 20, 41, 55] search_key = -1 Output: 2 # Example 2 array = [5, 10, 12, 14, 17, 20, 21] search_key = 55 Output: -1 # Example 3 array = [5, 10, 12, 14, 17, 20, 21] search_key = -5 Output: -1 ``` # Instructions: 1. Ensure the function addresses the edge cases described in the analysis. 2. Prioritize performance by avoiding unnecessary computations or potential slowdowns. 3. Consider constraints on hardware or platform, optimizing for both time and space usage within reasonable limits. Note: * This problem expects a balance between theoretical optimization and practical coding application, testing your understanding of interpolation search and designing an adapted search for specific scenarios.","solution":"from typing import List def advanced_interpolation_search(array: List[int], search_key: int) -> int: Perform an interpolation search to find the position of search_key in array. Parameters: array (List[int]): A list of sorted integers. search_key (int): The integer value to be searched in the array. Returns: int: The index of search_key in the array if found, otherwise -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Probing the position with assuming uniform distribution of values pos = low + int(((float(high - low) / (array[high] - array[low])) * (search_key - array[low]))) # If search_key is found if array[pos] == search_key: return pos # If search_key is larger, search in the upper part if array[pos] < search_key: low = pos + 1 # If search_key is smaller, search in the lower part else: high = pos - 1 return -1"},{"question":"Context You are given a stream of integer-sign pairs where each integer is a non-negative number and the sign indicates whether it is added or subtracted in the overall sum. Your task is to determine if the stream is 1-sparse, meaning if after summing the integers by their signs, there is exactly one unique uncanceled number left. Problem Statement Implement the function `one_sparse` that takes a list of tuples representing a stream of integer-sign pairs and returns the unique number if the stream is 1-sparse. Return `None` if the stream is not 1-sparse. Input * A list of tuples `(int, \'+\') or (int, \'-\')`, where the integers are non-negative. Output * An integer if the stream is 1-sparse. * `None` if the stream is not 1-sparse. Constraints * The stream contains at least one tuple. * All integers in the stream are non-negative. Example ```python # Example 1 Input: [(4,\'+\'), (2,\'+\'), (2,\'-\'), (4,\'+\'), (3,\'+\'), (3,\'-\')] Output: 4 # Example 2 Input: [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\')] Output: 2 # Example 3 Input: [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (1, \'+\')] Output: None ``` Function Signature ```python def one_sparse(array): 1-sparse algorithm Keyword arguments: array -- stream of tuples ``` Your task is to complete the implementation of the `one_sparse` function based on the given specification. Ensure to handle edge cases and properly test your function.","solution":"def one_sparse(array): Determine if the stream is 1-sparse and return the unique uncanceled number. Otherwise, return None. Parameters: array -- stream of tuples in the format (int, \'+\') or (int, \'-\') Returns: An integer if the stream is 1-sparse, otherwise None. number_counts = {} for num, sign in array: if sign == \'+\': number_counts[num] = number_counts.get(num, 0) + 1 elif sign == \'-\': number_counts[num] = number_counts.get(num, 0) - 1 # Filter out numbers that are completely canceled out (count == 0) result = [num for num, count in number_counts.items() if count != 0] # Check if there is exactly one such number if len(result) == 1: return result[0] return None"},{"question":"# Stooge Sort Implementation and Analysis Imagine you are a data scientist who has been provided with an archaic and theoretical sorting algorithm, Stooge Sort. You are tasked with writing the implementation and providing an analysis of its performance on various edge cases. Task: 1. Implement the Stooge Sort function based on its definition. 2. Write a secondary function that uses this implementation to sort the provided arrays and collect performance data. 3. Analyze and report the performance data on various edge cases. Function Specifications: 1. **stoogesort(arr, l, h)**: - Input: - arr: List of integers that needs to be sorted. - l: Starting index of the current segment of the array to be sorted. - h: Ending index of the current segment of the array to be sorted. - Output: The function doesn\'t return anything. It modifies the input list in place. 2. **analyze_stoogesort_performance(arrays)**: - Input: - arrays: A list of integer arrays on which to run Stooge Sort. - Output: - Returns a dictionary with array as the key and a dictionary containing the following metrics as values: - Time taken for sorting. - Number of comparisons. - Number of swaps. Performance Requirements: - Include performance data on the following edge cases: - Small sized arrays (1 to 3 elements) - Large sized arrays with random integers - Reverse sorted arrays - Already sorted arrays Constraints: - Elements within the arrays can be any integer within the range [-10^3, 10^3]. - Report should include a brief summary of the performance characteristics and suitability of Stooge Sort based on your analysis. Example Use: ```python # Example of usage if __name__ == \\"__main__\\": arrays = [ [34, 7, 23, 32, 5, 62], [1, 2, 3], [9, 8, 7, 6, 5], [1, 2, 3, 4, 5] ] performance_data = analyze_stoogesort_performance(arrays) for array, data in performance_data.items(): print(f\\"Array: {array}, Performance: {data}\\") ```","solution":"import time def stoogesort(arr, l, h, performance_data=None): Sorts arr[l..h] using Stooge Sort algorithm. if l >= h: return # Compare arr[l] and arr[h] if performance_data is not None: performance_data[\'comparisons\'] += 1 if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if performance_data is not None: performance_data[\'swaps\'] += 1 # If there are more than 2 elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort the first 2/3 of the array stoogesort(arr, l, h - t, performance_data) # Recursively sort the last 2/3 of the array stoogesort(arr, l + t, h, performance_data) # Recursively sort the first 2/3 of the array again to confirm sort stoogesort(arr, l, h - t, performance_data) def analyze_stoogesort_performance(arrays): import copy performance_results = {} for array in arrays: performance_data = { \'time_taken\': 0, \'comparisons\': 0, \'swaps\': 0 } array_copy = copy.deepcopy(array) start_time = time.time() stoogesort(array_copy, 0, len(array) - 1, performance_data) end_time = time.time() performance_data[\'time_taken\'] = end_time - start_time performance_results[tuple(array)] = performance_data return performance_results"},{"question":"# Segment Tree Implementation with Lazy Propagation Context: A segment tree with lazy propagation is a powerful data structure that can handle not only range queries but also range updates efficiently. Lazy propagation is a modification that enables the segment tree to handle range updates without degrading the performance. Task: Implement a segment tree that supports range sum queries and range increment updates. The segment tree should be able to handle an array of integers and perform the following operations efficiently: 1. Range Query: Sum of elements in a given range. 2. Range Update: Add a value to all elements in a given range. Function Signature: ```python class LazySegmentTree: def __init__(self, arr): # Constructor initializing the segment tree and the lazy array def _build_tree(self, i, l, r): # Helper function to build the tree def _update_range(self, i, l, r, ql, qr, val): # Helper function to update a range def _query_range(self, i, l, r, ql, qr): # Helper function to query a range def update_range(self, l, r, val): # Public method to update a range def query_range(self, l, r): # Public method to query a range ``` Input: 1. The constructor receives an array of integers. 2. `update_range`: Receives three parameters: left index (l), right index (r), and the value to add. 3. `query_range`: Receives two parameters: left index (l) and right index (r). Output: `query_range` should return the sum of elements in the specified range. Constraints: * 1 ≤ arr.length ≤ 10^5 * -10^9 ≤ arr[i] ≤ 10^9 * 1 ≤ number of queries/updates ≤ 10^5 Example: ```python arr = [1, 3, 5, 7, 9, 11] seg_tree = LazySegmentTree(arr) # Initial Segment Tree queries print(seg_tree.query_range(1, 3)) # Output: 15 (3 + 5 + 7) # Update range seg_tree.update_range(1, 3, 5) # Increment elements from index 1 to 3 by 5 # Query after update print(seg_tree.query_range(1, 3)) # Output: 30 (8 + 10 + 12) print(seg_tree.query_range(0, 5)) # Output: 51 (1 + 8 + 10 + 12 + 9 + 11) ``` Explanation: In the example, after creating the segment tree, a range query (1 to 3) sums up the elements 3, 5, and 7 to give 15. Then, updating the range 1 to 3 by adding 5 increments the elements to [8, 10, 12]. Next, querying the same range sums these updated values to give 30, and querying the entire range gives 51.","solution":"class LazySegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (4 * self.n) self.lazy = [0] * (4 * self.n) self._build_tree(arr, 0, 0, self.n - 1) def _build_tree(self, arr, i, l, r): if l == r: self.tree[i] = arr[l] else: mid = (l + r) // 2 self._build_tree(arr, 2 * i + 1, l, mid) self._build_tree(arr, 2 * i + 2, mid + 1, r) self.tree[i] = self.tree[2 * i + 1] + self.tree[2 * i + 2] def _update_range(self, i, l, r, ql, qr, val): if self.lazy[i] != 0: self.tree[i] += (r - l + 1) * self.lazy[i] if l != r: self.lazy[2 * i + 1] += self.lazy[i] self.lazy[2 * i + 2] += self.lazy[i] self.lazy[i] = 0 if l > qr or r < ql: return if l >= ql and r <= qr: self.tree[i] += (r - l + 1) * val if l != r: self.lazy[2 * i + 1] += val self.lazy[2 * i + 2] += val return mid = (l + r) // 2 self._update_range(2 * i + 1, l, mid, ql, qr, val) self._update_range(2 * i + 2, mid + 1, r, ql, qr, val) self.tree[i] = self.tree[2 * i + 1] + self.tree[2 * i + 2] def _query_range(self, i, l, r, ql, qr): if self.lazy[i] != 0: self.tree[i] += (r - l + 1) * self.lazy[i] if l != r: self.lazy[2 * i + 1] += self.lazy[i] self.lazy[2 * i + 2] += self.lazy[i] self.lazy[i] = 0 if l > qr or r < ql: return 0 if l >= ql and r <= qr: return self.tree[i] mid = (l + r) // 2 left_sum = self._query_range(2 * i + 1, l, mid, ql, qr) right_sum = self._query_range(2 * i + 2, mid + 1, r, ql, qr) return left_sum + right_sum def update_range(self, l, r, val): self._update_range(0, 0, self.n - 1, l, r, val) def query_range(self, l, r): return self._query_range(0, 0, self.n - 1, l, r)"},{"question":"# Red-Black Tree Validation and Key Operations **Context**: A Red-Black Tree is a balanced binary search tree with additional properties which ensure the tree remains balanced. This balance ensures that operations like insertions, deletions, and lookups can be performed in O(log n) time. **Task**: You need to implement a function to validate if a given binary tree is a valid Red-Black Tree or not. Additionally, implement a function to find the k-th smallest element in the Red-Black Tree. **Implement Two Functions**: 1. `is_valid_rb_tree()`: * **Input**: The root node of a binary tree. * **Output**: Boolean value indicating if the tree satisfies all Red-Black Tree properties. 2. `kth_smallest_element()`: * **Input**: The root node of a Red-Black Tree and an integer k. * **Output**: The k-th smallest element in the Red-Black Tree. **Constraints**: * You may assume the Red-Black Tree will not contain duplicate elements. * For `kth_smallest_element()`, you can assume 1 <= k <= number of nodes in the tree. * The Red-Black Tree will have at most 10000 nodes. **Specifications**: * Your validation logic in `is_valid_rb_tree()` should ensure that the tree satisfies the following: * Each node is either red or black. * The root is black. * Red nodes cannot have red children (no two consecutive red nodes). * Every path from a node to its descendant NIL nodes contains the same number of black nodes. * Utilize in-order traversal to implement the `kth_smallest_element()` function. **Function Signatures**: ```python def is_valid_rb_tree(root: RBNode) -> bool: # Your validation logic here def kth_smallest_element(root: RBNode, k: int) -> int: # Your logic for finding k-th smallest element here ```","solution":"class RBNode: def __init__(self, value, color, left=None, right=None): self.value = value self.color = color self.left = left self.right = right def is_valid_rb_tree(root: RBNode) -> bool: def dfs(node): if not node: return True, 1 # Valid and black-height of NULL node is 1 if node.color not in [\'R\', \'B\']: return False, 0 if node.left and node.value <= node.left.value: return False, 0 if node.right and node.value >= node.right.value: return False, 0 if node.color == \'R\': if (node.left and node.left.color == \'R\') or (node.right and node.right.color == \'R\'): return False, 0 left_valid, left_count = dfs(node.left) right_valid, right_count = dfs(node.right) if not left_valid or not right_valid: return False, 0 if left_count != right_count: return False, 0 return True, left_count + (1 if node.color == \'B\' else 0) valid, _ = dfs(root) return (root.color == \'B\') and valid def kth_smallest_element(root: RBNode, k: int) -> int: def in_order_traversal(node): if not node: return [] return in_order_traversal(node.left) + [node.value] + in_order_traversal(node.right) elements = in_order_traversal(root) return elements[k - 1]"},{"question":"Scenario: You are working on a system that needs to reliably transfer lists of strings over the network. To facilitate this, you have decided to use a custom encoding scheme where the list is converted into a single string, transferred, and then decoded back into a list of strings on the receiver\'s end. To achieve this, you\'re tasked with implementing two functions: `encode` and `decode`. Task: Implement the following two functions to handle the encoding and decoding of lists of strings: 1. **encode**: * **Input**: A list of strings `List[str]`. * **Output**: A single encoded string `str` that represents the list. * **Behavior**: The encoded string should start with the length of each string followed by a colon (`:`) and then the string itself. Example: ```python encode([\\"hello\\", \\"world\\"]) -> \\"5:hello5:world\\" ``` 2. **decode**: * **Input**: A single encoded string `str`. * **Output**: A list of strings `List[str]` that was originally encoded. * **Behavior**: The function should decode the input string back to the original list of strings by reading the length prefixes. Example: ```python decode(\\"5:hello5:world\\") -> [\\"hello\\", \\"world\\"] ``` Constraints: * The length of each string in the list will be a non-negative integer. * The encoded string will be properly formatted according to the encoding scheme. # Performance Requirements: * The `encode` function should have a time complexity of O(n), where n is the total number of characters in the input list. * The `decode` function should have a time complexity of O(m), where m is the total length of the input encoded string. * Space complexity for both functions should be O(n) for `encode` and O(m) for `decode`. Edge Cases to Consider: * An empty list of strings. * Strings containing digits and colons. * Very large strings or lists. Write your implementation for the `encode` and `decode` functions below: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): index = s.find(\\":\\", i) size = int(s[i:index]) strs.append(s[index+1: index+1+size]) i = index+1+size return strs ```","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): index = s.find(\\":\\", i) size = int(s[i:index]) strs.append(s[index+1: index+1+size]) i = index+1+size return strs"},{"question":"# Anagram Checker for Sentences You are given two sentences containing only lowercase letters and spaces. You need to determine if these sentences are anagrams of each other. Two sentences are anagrams if, after reordering the letters (ignoring spaces), both sentences use the exact same characters the same number of times. **Input**: * Two strings `sentence1` and `sentence2`. **Output**: * Return `True` if the sentences are anagrams, `False` otherwise. **Constraints**: 1. The input strings will only contain lowercase letters and spaces. 2. The length of each string will not exceed 10,000 characters. **Examples**: ```python assert are_anagrams(\\"listen\\", \\"silent\\") == True assert are_anagrams(\\"the eyes\\", \\"they see\\") == True assert are_anagrams(\\"modern\\", \\"norman\\") == False assert are_anagrams(\\"a gentleman\\", \\"elegant man\\") == True assert are_anagrams(\\"school master\\", \\"the classroom\\") == False assert are_anagrams(\\"\\", \\"\\") == True assert are_anagrams(\\"abc\\", \\"def\\") == False ``` **Function Signature**: ```python def are_anagrams(sentence1: str, sentence2: str) -> bool: pass ```","solution":"def are_anagrams(sentence1: str, sentence2: str) -> bool: Check if two sentences are anagrams of each other by comparing the sorted characters of each sentence, ignoring spaces. # Remove spaces from both sentences filtered_sentence1 = sentence1.replace(\\" \\", \\"\\") filtered_sentence2 = sentence2.replace(\\" \\", \\"\\") # Sort the filtered sentences and compare return sorted(filtered_sentence1) == sorted(filtered_sentence2)"},{"question":"**Scenario**: You have been tasked with developing a function that determines if a given string `s` matches a pattern `p`. The pattern can include the special characters \'.\' and \'*\', where: - \'.\' matches any single character. - \'*\' matches zero or more of the preceding element. **Objective**: Implement the function `is_match` which takes two arguments—a string `s` and a pattern `p`, and returns a boolean indicating whether the string matches the pattern. **Function Signature**: ```python def is_match(s: str, p: str) -> bool: ``` # Input * `s` (string): The input string to be matched. Length of `s` is in the range [0, 100]. * `p` (string): The pattern string containing regular characters and the special characters \'.\' and \'*\'. Length of `p` is in the range [0, 100]. # Output * Returns `True` if the string `s` matches the pattern `p`, `False` otherwise. # Constraints * The matching should cover the entire input string, not partial. * Ensure that your solution handles edge cases and performs efficiently. # Examples ```python is_match(\\"aa\\", \\"a\\") # False is_match(\\"aa\\", \\"aa\\") # True is_match(\\"aaa\\", \\"aa\\") # False is_match(\\"aa\\", \\"a*\\") # True is_match(\\"aa\\", \\".*\\") # True is_match(\\"ab\\", \\".*\\") # True is_match(\\"aab\\", \\"c*a*b\\") # True ``` # Requirements 1. You must use the dynamic programming approach as discussed. 2. Provide comments in your code to explain each major step. 3. Handle edge cases such as empty strings and patterns appropriately.","solution":"def is_match(s: str, p: str) -> bool: m, n = len(s), len(p) # dp[i][j] will be True if s[:i] matches p[:j], else False dp = [[False] * (n + 1) for _ in range(m + 1)] # Empty string matches with empty pattern dp[0][0] = True # Populate for patterns with \'*\' that can match 0 preceding character for j in range(1, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill dp array for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: # Match a single character dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': # Match zero or more of the preceding character dp[i][j] = dp[i][j - 2] or ((p[j - 2] == s[i - 1] or p[j - 2] == \'.\') and dp[i - 1][j]) return dp[m][n]"},{"question":"**Context and Objective**: In communication systems, error detection and correction techniques frequently rely on counting the number of bit differences (i.e., the Hamming weight) in binary data. To test and reinforce your understanding of bit manipulation algorithms, you are asked to implement a function that efficiently counts the number of 1s in the binary representation of an unsigned integer. # Task: Write a function `count_hamming_weight(n)` that accepts an unsigned integer `n` and returns the number of 1 bits in its binary representation. Input: * `n` - an unsigned integer (0 <= n <= 2^31 - 1) Output: * Return an integer representing the number of 1 bits in the binary representation of `n`. Constraints: * Your solution should have a linear time complexity in terms of the number of 1 bits present, O(k), where k is the number of 1 bits in n. * Use an iterative approach leveraging bitwise operations. # Examples: ```python assert count_hamming_weight(11) == 3 assert count_hamming_weight(0) == 0 assert count_hamming_weight(4) == 1 assert count_hamming_weight(15) == 4 ``` # Guidelines: * Implement the function from scratch without using any built-in functions that directly count the number of 1 bits. * Consider edge cases such as the smallest and largest possible values of `n`. * Aim for a clean and efficient implementation.","solution":"def count_hamming_weight(n): Returns the number of 1 bits in the binary representation of the unsigned integer n. count = 0 while n: count += n & 1 n >>= 1 return count"},{"question":"You are provided with an integer within the range from 1 to 4999. Your task is to convert this integer to its correct Roman numeral representation. **Roman Numerals Rules:** 1. Letters are combined in descending order. 2. There are specific combinations that represent values using subtraction: - `4` is written as `IV` (5 - 1). - `9` is written as `IX` (10 - 1). - `40` is written as `XL` (50 - 10). - `90` is written as `XC` (100 - 10). - `400` is written as `CD` (500 - 100). - `900` is written as `CM` (1000 - 100). **Roman Numeral Values:** - M = 1000 - D = 500 - C = 100 - L = 50 - X = 10 - V = 5 - I = 1 # Function Signature ```python def int_to_roman(num: int) -> str: pass ``` # Input * An integer, `num`, such that `1 <= num <= 4999`. # Output * A string representing the Roman numeral of the given input integer. # Constraints * You must ensure that the provided integer falls within the specified range. * The implementation should be efficient with minimal overhead. # Examples ```python assert int_to_roman(1) == \\"I\\" assert int_to_roman(58) == \\"LVIII\\" assert int_to_roman(1994) == \\"MCMXCIV\\" assert int_to_roman(3999) == \\"MMMCMXCIX\\" ``` Create the function `int_to_roman` that fulfills these requirements.","solution":"def int_to_roman(num: int) -> str: Convert an integer to its Roman numeral representation. # Define the Roman numeral mappings value_map = [ (1000, \\"M\\"), (900, \\"CM\\"), (500, \\"D\\"), (400, \\"CD\\"), (100, \\"C\\"), (90, \\"XC\\"), (50, \\"L\\"), (40, \\"XL\\"), (10, \\"X\\"), (9, \\"IX\\"), (5, \\"V\\"), (4, \\"IV\\"), (1, \\"I\\") ] roman_numeral = \\"\\" # Convert the integer to Roman numeral for value, numeral in value_map: while num >= value: roman_numeral += numeral num -= value return roman_numeral"},{"question":"# Scenario Imagine you are developing a simulator for a customer service center where customer inquiries are handled in the order they arrive. You need to implement an efficient queue system to manage and process customer requests. Your task is to create two different queue implementations following the FIFO principle - one using arrays and the other using linked lists. # Objective Implement two classes, **ArrayQueue** and **LinkedListQueue**, to simulate queue operations as described below: # Specifications 1. **ArrayQueue**: - `__init__(self, capacity=10)`: Initialize with a given capacity. - `enqueue(self, value)`: Add an item to the rear of the queue. - `dequeue(self)`: Remove and return the front item from the queue. - `peek(self)`: Return the front item without removing it. - `is_empty(self)`: Check if the queue is empty. - `__len__(self)`: Return the number of items in the queue. - Implement any required helper methods (e.g., `_expand`). 2. **LinkedListQueue**: - `__init__(self)`: Initialize an empty queue. - `enqueue(self, value)`: Add an item to the rear of the queue. - `dequeue(self)`: Remove and return the front item from the queue. - `peek(self)`: Return the front item without removing it. - `is_empty(self)`: Check if the queue is empty. - `__len__(self)`: Return the number of items in the queue. # Input Constraints - Values enqueued will be non-null integers. - Dequeue and peek operations will handle exceptions where necessary. # Performance Requirements - Ensure that `enqueue`, `dequeue`, and `peek` operations have time complexity of O(1) in both implementations. # Implementation Checklist - Implement `ArrayQueue` and `LinkedListQueue` as described. - Handle possible edge cases (e.g., dequeue from an empty queue). ```python # Define your ArrayQueue and LinkedListQueue classes here. ``` # Example Usage ```python # Example with ArrayQueue aq = ArrayQueue(5) aq.enqueue(1) aq.enqueue(2) print(aq.dequeue()) # Output: 1 print(aq.peek()) # Output: 2 # Example with LinkedListQueue llq = LinkedListQueue() llq.enqueue(1) llq.enqueue(2) print(llq.dequeue()) # Output: 1 print(llq.peek()) # Output: 2 ``` # Edge Cases to Consider - Attempting to `dequeue` or `peek` from an empty queue should raise an `IndexError`.","solution":"class ArrayQueue: def __init__(self, capacity=10): self._capacity = capacity self._queue = [None] * capacity self._front = 0 self._rear = 0 self._size = 0 def enqueue(self, value): if self._size == self._capacity: self._expand() self._queue[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Dequeue from empty queue\\") value = self._queue[self._front] self._queue[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty queue\\") return self._queue[self._front] def is_empty(self): return self._size == 0 def __len__(self): return self._size def _expand(self): new_capacity = self._capacity * 2 new_queue = [None] * new_capacity for i in range(self._size): new_queue[i] = self._queue[(self._front + i) % self._capacity] self._queue = new_queue self._front = 0 self._rear = self._size self._capacity = new_capacity class LinkedListQueue: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self._front = None self._rear = None self._size = 0 def enqueue(self, value): new_node = self.Node(value) if self._rear: self._rear.next = new_node self._rear = new_node if not self._front: self._front = new_node self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Dequeue from empty queue\\") value = self._front.value self._front = self._front.next if not self._front: self._rear = None self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty queue\\") return self._front.value def is_empty(self): return self._size == 0 def __len__(self): return self._size"},{"question":"# Question: Implement an Optimized Search Function You are given an array of integers `arr` and an integer `target`. Your task is to implement an optimized search function `optimized_search(arr, target)` that: 1. **Checks if the array is sorted**. If the array is sorted, perform a binary search to find the `target`. 2. If the array is **not sorted**, perform a linear search to find the `target`. # Requirements: - **Input**: An array `arr` of n integers (1 ≤ n ≤ 10^5), and an integer `target`. - **Output**: The index of the `target` in the array if found, otherwise -1. - Your implementation should efficiently handle arrays up to the size limit. # Constraints: - You must identify whether the array is sorted in O(n) time. - Your binary search implementation should have O(log n) time complexity for sorted arrays. - Linear search should be used if the array is not sorted. # Test Cases: 1. `optimized_search([1, 2, 3, 4, 5], 3)` should return `2`. 2. `optimized_search([5, 4, 3, 2, 1], 3)` should return `2`. 3. `optimized_search([3, 1, 4, 1, 5], 9)` should return `-1`. # Function Signature: ```python def optimized_search(arr: list[int], target: int) -> int: pass ``` **Task**: Implement the `optimized_search` function following the described requirements.","solution":"def optimized_search(arr, target): This function takes an array and a target value. It checks if the array is sorted and performs binary search if sorted, else performs linear search. Returns the index of the target if found, otherwise -1. def is_sorted(arr): return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def binary_search(arr, target): low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] == target: return mid elif arr[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def linear_search(arr, target): for index, value in enumerate(arr): if value == target: return index return -1 if is_sorted(arr): return binary_search(arr, target) else: return linear_search(arr, target)"},{"question":"# Scenario & Context You are building a task scheduler for an operating system, where each task has a specific priority. High-priority tasks should be processed first. As part of the scheduler\'s components, design and implement a `PriorityScheduler` class that extends the given `PriorityQueue` class. Your scheduler should manage adding tasks, removing the highest priority task, and retrieving the current highest priority task without removing it. # Question Implement a `PriorityScheduler` class, which will utilize the provided `PriorityQueue` class to manage tasks. The `PriorityScheduler` should support the following operations: 1. **add_task(task_name: str, task_priority: int)**: Adds a task with a specific priority. 2. **pop_task() -> str**: Removes and returns the name of the task with the highest priority. 3. **peek_task() -> str**: Returns the name of the task with the highest priority without removing it. 4. **is_empty() -> bool**: Returns whether there are no tasks in the scheduler. 5. **size() -> int**: Returns the number of tasks in the scheduler. # Constraints - Tasks are identified uniquely by their names. - Task priorities are integers. The higher the integer, the higher the priority. - The methods should handle edge cases appropriately, such as attempting to pop or peek from an empty scheduler. - Consider efficiency of operations where possible within the given implementation constraints. # Expected Input and Output Format ```python class PriorityScheduler(PriorityQueue): def add_task(self, task_name: str, task_priority: int) -> None: Adds a task with a specific priority ... def pop_task(self) -> str: Removes and returns the name of the task with the highest priority ... def peek_task(self) -> str: Returns the name of the task with the highest priority without removing it ... def is_empty(self) -> bool: Returns True if there are no tasks, False otherwise ... def size(self) -> int: Returns the number of tasks in the scheduler ... # Example Usage: scheduler = PriorityScheduler() scheduler.add_task(\\"Write report\\", 2) scheduler.add_task(\\"Fix bug\\", 1) scheduler.add_task(\\"Email client\\", 3) assert scheduler.size() == 3 assert scheduler.peek_task() == \\"Email client\\" assert scheduler.pop_task() == \\"Email client\\" assert scheduler.size() == 2 assert not scheduler.is_empty() assert scheduler.pop_task() == \\"Write report\\" assert scheduler.pop_task() == \\"Fix bug\\" assert scheduler.is_empty() assert scheduler.size() == 0 ``` # Notes - Ensure the `PriorityScheduler` inherits from `PriorityQueue` and uses its `push` and `pop` methods. - Efficiently handle the operations and manage any potential exceptions, especially when the scheduler is empty.","solution":"import heapq class PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def push(self, item, priority): heapq.heappush(self._queue, (-priority, self._index, item)) self._index += 1 def pop(self): return heapq.heappop(self._queue)[-1] def __len__(self): return len(self._queue) class PriorityScheduler(PriorityQueue): def add_task(self, task_name: str, task_priority: int) -> None: Adds a task with a specific priority self.push(task_name, task_priority) def pop_task(self) -> str: Removes and returns the name of the task with the highest priority if self.is_empty(): raise IndexError(\\"pop from empty scheduler\\") return self.pop() def peek_task(self) -> str: Returns the name of the task with the highest priority without removing it if self.is_empty(): raise IndexError(\\"peek from empty scheduler\\") return self._queue[0][-1] def is_empty(self) -> bool: Returns True if there are no tasks, False otherwise return len(self) == 0 def size(self) -> int: Returns the number of tasks in the scheduler return len(self)"},{"question":"# AVL Tree Maximum Height Challenge Your task is to complete the implementation of an AVL tree as laid out in the provided partial implementation. Specifically, you need to write a function `calculate_max_height` that computes the maximum height of the AVL tree after a series of insertions. # Function to Implement ```python def calculate_max_height(keys): Computes the maximum height of the AVL tree after inserting all keys. :param keys: A list of integers to insert into the AVL tree. :return: An integer representing the maximum height of the AVL tree. # Your implementation here ``` # Input - `keys`: A list of integers (1 ≤ len(keys) ≤ 10^5 and -10^9 ≤ keys[i] ≤ 10^9). # Output - An integer representing the maximum height of the AVL tree after inserting all keys. # Constraints - You must use the provided AVL Tree implementation structure to complete this task. - The AVL tree must remain balanced after each insertion. # Example ```python # Example usage keys = [10, 20, 30, 40, 50, 25] print(calculate_max_height(keys)) # Output should be an integer representing height ``` # Context Efficiently managing the height of a tree is crucial in ensuring optimal performance for search, insert, and delete operations. In this problem, you will gain hands-on experience with balancing mechanisms in AVL trees and deepen your understanding of self-balancing tree structures.","solution":"class TreeNode: def __init__(self, key): self.key = key self.height = 1 self.left = None self.right = None def get_height(node): if not node: return 0 return node.height def update_height(node): if node: node.height = 1 + max(get_height(node.left), get_height(node.right)) def get_balance(node): if not node: return 0 return get_height(node.left) - get_height(node.right) def right_rotate(y): x = y.left T2 = x.right x.right = y y.left = T2 update_height(y) update_height(x) return x def left_rotate(x): y = x.right T2 = y.left y.left = x x.right = T2 update_height(x) update_height(y) return y def insert(node, key): if not node: return TreeNode(key) if key < node.key: node.left = insert(node.left, key) else: node.right = insert(node.right, key) update_height(node) balance = get_balance(node) if balance > 1 and key < node.left.key: return right_rotate(node) if balance < -1 and key > node.right.key: return left_rotate(node) if balance > 1 and key > node.left.key: node.left = left_rotate(node.left) return right_rotate(node) if balance < -1 and key < node.right.key: node.right = right_rotate(node.right) return left_rotate(node) return node def compute_max_height(node): if not node: return 0 return node.height def calculate_max_height(keys): root = None for key in keys: root = insert(root, key) return compute_max_height(root)"},{"question":"# Question You are given a singly linked list where each node contains a lowercase alphabetic character. Your task is to implement two functions to remove duplicate characters from the list: 1. `remove_dups`: This function should use extra space to achieve an optimal time complexity. 2. `remove_dups_without_set`: This function should avoid using additional data structures to maintain O(1) space complexity. Please complete the following task: Task Implement both functions as described. Ensure that after removing duplicates: - The linked list retains only unique characters. - The order of characters remains unchanged. Function Signatures ```python class Node(): def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: pass def remove_dups_without_set(head: Node) -> None: pass ``` Input - A singly linked list of nodes with each node containing a lowercase alphabet character. Output - The linked list should be modified in place. Example Consider the given linked list A -> A -> B -> C -> D -> C -> F -> G: 1. After calling `remove_dups` on this list, it should display: ``` A -> B -> C -> D -> F -> G ``` 2. Given the same list before removing duplicates, after calling `remove_dups_without_set`, it should display: ``` A -> B -> C -> D -> F -> G ``` Constraints - You should not alter the given data structures or nodes\' values. - Ensure to handle edge cases such as empty lists or lists with all identical values.","solution":"class Node(): def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: Removes duplicate characters from the linked list using extra space. if not head: return current = head seen = set() prev = None while current: if current.val in seen: prev.next = current.next else: seen.add(current.val) prev = current current = current.next def remove_dups_without_set(head: Node) -> None: Removes duplicate characters from the linked list without using extra data structures. current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Question: Detect Cycle in a Linked List Given a singly linked list, implement a function that detects if the list contains a cycle. If a cycle exists, return the node where the cycle begins. If no cycle exists, return `None`. Your solution should utilize Floyd\'s Cycle-Finding Algorithm (Tortoise and Hare) and must be both time and space efficient. Function Signature ```python def detect_cycle(head: Node) -> Optional[Node]: :type head: Node :rtype: Optional[Node] ``` # Constraints * Each node has a unique value. * The linked list may have zero or more nodes. * The solution must run in O(n) time complexity with O(1) space complexity. # Input - A singly linked list, where each node has an attribute `val` for its value and an attribute `next` pointing to the next node in the list. # Output - The node where the cycle begins, or `None` if no cycle exists. # Examples 1. **Example 1** ```python # Input: 1 -> 2 -> 3 -> 4 -> 5 -> 1 (Cycle: 1 is the starting node of the cycle) head = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(4) node5 = Node(5) head.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 node5.next = head assert detect_cycle(head).val == 1 ``` 2. **Example 2** ```python # Input: A -> B -> C -> D -> C (Cycle: C is the starting node of the cycle) head = Node(\'A\') nodeB = Node(\'B\') nodeC = Node(\'C\') nodeD = Node(\'D\') head.next = nodeB nodeB.next = nodeC nodeC.next = nodeD nodeD.next = nodeC assert detect_cycle(head).val == \'C\' ``` 3. **Example 3** ```python # Input: 1 -> 2 -> 3 -> 4 -> 5 (No Cycle) head = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(4) node5 = Node(5) head.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 node5.next = None assert detect_cycle(head) is None ``` # Note - Be sure to handle edge cases, such as empty linked lists or lists with only one node.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def detect_cycle(head: Node) -> Node: Returns the node where the cycle begins. If no cycle exists, returns None. if not head or not head.next: return None slow = head fast = head # Detect if there is a cycle using two pointers. while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # If no cycle, return None. return None # Find the entry point of the cycle. slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"Question: Cycle Detection in Directed Graph # Context In computer science, detecting cycles in directed graphs is a crucial problem, especially in systems for deadlock detection in operating systems, task scheduling, and dependency management. The given Python code demonstrates an algorithm to detect cycles using Depth-First Search (DFS) with state markers. # Task Implement a function `detect_cycle(graph)` that checks whether a given directed graph contains any cycles. The graph will be represented as an adjacency list (a dictionary where keys are nodes and values are lists of neighbors). # Function Signature ```python def detect_cycle(graph: dict) -> bool: ``` # Input - `graph`: A dictionary representing the directed graph where keys are nodes (strings) and values are lists of neighbor nodes (strings). # Output - Return `True` if there is at least one cycle in the graph. Return `False` otherwise. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(detect_cycle(graph)) # Output: True graph_no_cycle = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\'], \'E\': [\'F\'], \'F\': [] } print(detect_cycle(graph_no_cycle)) # Output: False ``` # Constraints - The graph may be empty but will not contain null or invalid nodes. - Nodes are represented as unique strings. - The number of nodes (`V`) will be between 0 and 1000. - The number of edges (`E`) will be between 0 and 5000. # Notes - Consider edge cases like an empty graph, a graph with a single node with no edges, or a graph with multiple disconnected components. - Optimizing both time and space complexity is essential due to potentially large input sizes. # Testing Ensure to thoroughly test your function with various graph inputs, including edge cases.","solution":"def detect_cycle(graph): Detects if there is a cycle in a directed graph. :param graph: A dictionary representing the directed graph where keys are nodes and values are lists of neighbor nodes. :returns: True if there is at least one cycle in the graph, False otherwise. WHITE = 0 # Node has not been visited GRAY = 1 # Node is in the current path BLACK = 2 # Node and its descendants have been fully explored def dfs(node, color): # If the node is currently in the recursion stack (GRAY), we found a cycle if color[node] == GRAY: return True # If the node is already processed (BLACK), no cycle originates from it if color[node] == BLACK: return False # Mark the node as being visited (GRAY) color[node] = GRAY # Recursively visit all the adjacent nodes for neighbor in graph[node]: if dfs(neighbor, color): return True # Mark the node as completely processed (BLACK) color[node] = BLACK return False # Initialize all nodes as WHITE color = {node: WHITE for node in graph} # Check each node, initiating a DFS if the node hasn\'t been visited yet for node in graph: if color[node] == WHITE: if dfs(node, color): return True return False"},{"question":"Anagram Pair Validation Given two strings `str1` and `str2`, implement a function `is_anagram(str1, str2)` that determines if `str1` is an anagram of `str2`. Two strings are considered anagrams if one is a permutation of the other, i.e., they contain the same characters with the same frequency. Function Signature ```python def is_anagram(str1: str, str2: str) -> bool: pass ``` Input * `str1`: A string consisting of lowercase English letters with a length up to 10^5. * `str2`: A string consisting of lowercase English letters with a length up to 10^5. Output * A boolean value: * `True` if `str1` is an anagram of `str2` * `False` otherwise Constraints - The input strings will contain only lowercase English letters. - The length of the input strings will be up to 100,000 characters. Examples ```python assert is_anagram(\\"listen\\", \\"silent\\") == True assert is_anagram(\\"triangle\\", \\"integral\\") == True assert is_anagram(\\"apple\\", \\"pleap\\") == True assert is_anagram(\\"apple\\", \\"cherry\\") == False assert is_anagram(\\"abcd\\", \\"dcbae\\") == False ``` Notes - Pay attention to optimization, as the input size might be large. An efficient solution is required. - Consider edge cases such as empty strings or strings of different lengths.","solution":"def is_anagram(str1: str, str2: str) -> bool: Determines if str1 is an anagram of str2. Anagrams are strings that contain the same characters with the same frequency. if len(str1) != len(str2): return False # Count characters in both strings count1, count2 = {}, {} for char in str1: count1[char] = count1.get(char, 0) + 1 for char in str2: count2[char] = count2.get(char, 0) + 1 # Compare the character counts return count1 == count2"},{"question":"# Objective You are tasked with implementing a function that simulates the summation of two numbers represented by linked lists. This exercise aims to evaluate your understanding of linked list operations, digit-wise arithmetic, and proper carry-forward handling. # Question Implement a function `add_two_linked_lists(left: Node, right: Node) -> Node:` which takes two linked lists `left` and `right` representing two non-negative integers in reverse order. The function should return a linked list representing their sum, also in reverse order. You may assume there are no leading zeros in the numbers, except for the number 0 itself. # Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def add_two_linked_lists(left: Node, right: Node) -> Node: pass ``` # Constraints 1. Linked lists can be of different lengths. 2. Node values range from 0 to 9. 3. The input linked lists will represent non-negative integers. 4. The output linked list must also be in reverse order. # Input / Output Formats 1. **Input**: * `left`: Node - The first linked list. * `right`: Node - The second linked list. 2. **Output**: * A new linked list representing the sum of the input lists. # Examples ```python # Example 1 left = Node(2) left.next = Node(4) left.next.next = Node(3) right = Node(5) right.next = Node(6) right.next.next = Node(4) result = add_two_linked_lists(left, right) # Expected Output: 7 -> 0 -> 8 # Example 2 left = Node(0) right = Node(0) result = add_two_linked_lists(left, right) # Expected Output: 0 ``` # Testing Your Solution Your function should be able to pass a variety of test cases, including but not limited to: 1. Different lengths of linked lists. 2. Handling of carry-over properly in consecutive nodes. 3. Correct handling of trailing zeros. # Additional Context (Bonus) If you have extra time, consider creating a helper function that converts a plain string of a number into its corresponding linked list in reverse order to further test your implementation in various scenarios easily. # Note You are not required to implement the Node class since its definition is provided.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def add_two_linked_lists(left: Node, right: Node) -> Node: dummy_head = Node(0) current = dummy_head carry = 0 while left is not None or right is not None: left_val = left.val if left is not None else 0 right_val = right.val if right is not None else 0 total = left_val + right_val + carry carry = total // 10 current.next = Node(total % 10) current = current.next if left is not None: left = left.next if right is not None: right = right.next if carry > 0: current.next = Node(carry) return dummy_head.next"},{"question":"You are tasked to implement an enhanced version of Insertion Sort with a feature that allows the sorting to be done in descending order or with detailed steps printed for educational purposes. Here are the requirements: 1. **Function Signature**: ```python def enhanced_insertion_sort(arr, ascending=True, debug=False): ``` 2. **Parameters**: * `arr`: List of integers to be sorted. * `ascending`: Boolean flag to sort in ascending order (default: True) or descending order (False). * `debug`: Boolean flag to print detailed steps for each iteration (default: False). 3. **Return**: * Return the sorted list of integers based on the `ascending` flag. 4. **Requirements**: * If `ascending` is True, sort the list in ascending order. If False, sort in descending order. * If `debug` is True, print the state of the list after each iteration of the outer loop. 5. **Constraints**: * The input list `arr` will have at most `100` elements. * Each element in the list will be between `-1000` and `1000`. # Example ```python input: arr = [4, 3, 2, 10, 12, 1, 5, 6] ascending = True debug = True output: iteration 1: 3 4 2 10 12 1 5 6 iteration 2: 2 3 4 10 12 1 5 6 iteration 3: 2 3 4 10 12 1 5 6 iteration 4: 2 3 4 10 12 1 5 6 iteration 5: 1 2 3 4 10 12 5 6 iteration 6: 1 2 3 4 5 10 12 6 iteration 7: 1 2 3 4 5 6 10 12 [1, 2, 3, 4, 5, 6, 10, 12] input: arr = [4, 3, 2, 10, 12, 1, 5, 6] ascending = False debug = False output: [12, 10, 6, 5, 4, 3, 2, 1] ``` Implement the function `enhanced_insertion_sort` as specified. Your solution will be evaluated on correctness, clarity, and efficiency.","solution":"def enhanced_insertion_sort(arr, ascending=True, debug=False): Sorts the array using insertion sort. :param arr: List[int], list of integers to be sorted. :param ascending: bool, flag to indicate sorting order; True for ascending, False for descending. :param debug: bool, flag to indicate if detailed steps should be printed. :return: List[int], sorted list of integers. n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 if ascending: while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 else: while j >= 0 and arr[j] < key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if debug: print(f\\"iteration {i}: {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# AVL Tree Range Query You are given an implementation of an AVL tree with insertion and basic tree-balancing methods such as rotations. Your task is to extend the AVL tree to support a range query operation. The range query should return a list of all keys in the tree that lie within a specified range [low, high]. Function Signature: ```python def range_query(avl_tree: AvlTree, low: int, high: int) -> List[int]: pass ``` Input: * `avl_tree`: An instance of an `AvlTree` with existing nodes. * `low`: The lower bound of the range (inclusive). * `high`: The upper bound of the range (inclusive). Output: * A list of integers representing the keys in the given range [low, high]. Constraints: * You can assume `low <= high`. * All keys in the AVL tree are unique. Example: Assume the AVL tree contains the keys: 5, 2, 8, 1, 3, 7, 9. ```python result = range_query(avl_tree, 3, 8) print(result) # Output: [3, 5, 7, 8] ``` Requirements: * Your function should have a time complexity of O(k + log n), where k is the number of keys in the result list. * Use the properties of the AVL tree to enhance performance.","solution":"class AVLNode: def __init__(self, key, left=None, right=None, height=1): self.key = key self.left = left self.right = right self.height = height class AvlTree: # Other AVL tree methods would be implemented here but are omitted for simplicity def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = AVLNode(key) else: self.root = self._insert(self.root, key) def _insert(self, node, key): if node is None: return AVLNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._rotate_right(node) if balance < -1 and key > node.right.key: return self._rotate_left(node) if balance > 1 and key > node.left.key: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1 and key < node.right.key: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def range_query(avl_tree: AvlTree, low: int, high: int) -> list: result = [] def inorder_traversal(node): if not node: return if node.key >= low: inorder_traversal(node.left) if low <= node.key <= high: result.append(node.key) if node.key <= high: inorder_traversal(node.right) inorder_traversal(avl_tree.root) return result"},{"question":"# Context A public transportation system wants to determine the shortest paths between various stations to optimize the routes. As part of an assessment, you need to implement an algorithm that determines the shortest path from a source station to all other stations. # Task Implement a function `find_shortest_paths(station_count, routes, start_station)` that uses Dijkstra\'s algorithm to find the shortest path from the `start_station` to all other stations in the system. The function should return a list of shortest distances from the `start_station` to every other station. # Input - `station_count`: An integer representing the number of stations (vertices). - `routes`: A list of tuples where each tuple contains three integers: `(source, destination, time)`, representing a directed route from the source station to the destination station with a travel time. - `start_station`: An integer representing the starting station index. # Output - A list of integers where the ith element is the shortest travel time from `start_station` to station i. If a station is not reachable, its distance should be represented as `float(\'inf\')`. # Constraints - The graph is directed and may contain zero or positive weights. - The number of stations will be at most 200. - The number of routes will not exceed 10,000. # Function Signature ```python def find_shortest_paths(station_count: int, routes: List[Tuple[int, int, int]], start_station: int) -> List[int]: pass ``` # Example: ```python station_count = 5 routes = [(0, 1, 10), (0, 4, 5), (1, 2, 1), (4, 1, 3), (4, 2, 9), (4, 3, 2), (2, 3, 4), (3, 2, 6), (3, 0, 7)] start_station = 0 output = find_shortest_paths(station_count, routes, start_station) # output should be [0, 8, 9, 7, 5] ``` # Explanation - Starting from station 0, the shortest paths to stations 1, 2, 3, and 4 are calculated based on the travel times provided in the `routes`. The function should correctly implement Dijkstra\'s algorithm to yield the shortest travel times.","solution":"import heapq from typing import List, Tuple def find_shortest_paths(station_count: int, routes: List[Tuple[int, int, int]], start_station: int) -> List[int]: Implements Dijkstra\'s algorithm to find the shortest paths from start_station to all other stations. :param station_count: Number of stations :param routes: List of tuples representing the routes between stations and their travel time :param start_station: Index of the starting station :return: List of shortest travel times from the start_station to all other stations # Create adjacency list adjacency_list = {i: [] for i in range(station_count)} for src, dest, time in routes: adjacency_list[src].append((dest, time)) # Initialize distance array dist = [float(\'inf\')] * station_count dist[start_station] = 0 # Min-heap priority queue priority_queue = [(0, start_station)] while priority_queue: current_distance, current_station = heapq.heappop(priority_queue) if current_distance > dist[current_station]: continue for neighbor, weight in adjacency_list[current_station]: distance = current_distance + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return dist"},{"question":"**Scenario:** You are given an array of integers that represents the sales data of a certain product over several days. You want to identify the most frequent sales counts, which helps in understanding the most common sales quantity. **Task:** Write a function `find_modes(sales_data)` that takes a list of integers `sales_data` and returns a list of the most frequently occurring sales counts. If there are multiple modes, the function should return all of them. # Implementation Details: * Define a function `find_modes(sales_data)`: - **Input:** - `sales_data` (a list of integers, `0 <= len(sales_data) <= 10^6`) - **Output:** - A list of integers that are the most frequently occurring values in `sales_data`. If `sales_data` is empty, return an empty list. - Ensure your function runs efficiently with a time complexity of O(n). **Constraints:** - The elements in `sales_data` can be any integer (positive, negative, and zero). - Optimize for both time and space complexity appropriately. # Examples: ```python # Example 1 find_modes([4, 4, 2, 2, 3, 3, 4, 5]) # Should return [4] since 4 appears 3 times which is more frequent than any other number. # Example 2 find_modes([1, 1, 2, 2, 3, 4]) # Should return [1, 2] since 1 and 2 both appear 2 times which is the most frequent count. # Example 3 find_modes([]) # Should return [] since there\'s no element in the list. ``` **Note:** You need to consider edge cases like an empty array, all elements being unique, and multiple modes.","solution":"from collections import Counter def find_modes(sales_data): Returns the list of the most frequently occurring sales counts in the sales_data list. if not sales_data: return [] # Count occurrences of each sales count frequency_count = Counter(sales_data) # Find the highest frequency max_frequency = max(frequency_count.values()) # Collect all keys (sales counts) that have the highest frequency modes = [key for key, count in frequency_count.items() if count == max_frequency] return modes"},{"question":"# Question You are building a software system where data integrity is critical. One of the component requires validating the order of elements stored in a stack-like data structure. Specifically, you need to verify that all elements within the stack are sorted in ascending order, from bottom to top. Task Write a function `is_sorted` that determines if the elements in a given stack are in ascending order from bottom to top. The function should return `True` if the stack is sorted, and `False` otherwise. The stack is provided as a list where the last element of the list is considered the top of the stack. Requirements: * **Input**: A list `stack` of integers representing the stack, where `stack[-1]` is the top of the stack. * **Output**: Return a boolean indicating whether the stack is sorted in ascending order from bottom to top. * **Constraints**: * You must not modify the original stack, it should remain the same after function execution. * Elements of the stack are guaranteed to be integers. * Your solution should be efficient and handle edge cases (such as empty stack or stack with a single element). Examples: * **Example 1**: * Input: `stack = [1, 2, 3, 4, 5, 6]` * Output: `True` * Explanation: The stack is already sorted in ascending order. * **Example 2**: * Input: `stack = [6, 3, 5, 1, 2, 4]` * Output: `False` * Explanation: The elements do not follow the ascending order from bottom to top. Performance: Your implementation should handle stacks up to a size of 10^4 elements efficiently within acceptable time and space complexity. # Below is the function signature: ```python def is_sorted(stack): # Your code here pass ```","solution":"def is_sorted(stack): Determines if the elements in the given stack are sorted in ascending order from bottom to top. Arguments: stack -- list of integers where the last element is the top of the stack Returns: True if the stack is sorted in ascending order from bottom to top, False otherwise # Edge case: An empty stack or a stack with one element is always sorted if len(stack) <= 1: return True # Iterate through the stack to check if adjacent elements are in ascending order for i in range(len(stack) - 1): if stack[i] > stack[i + 1]: return False return True"},{"question":"# Question: Matrix Manipulation Functions Context You are working on a project that involves image processing. Images in your system are represented as 2D matrices of pixels. You need to implement various transformations on these matrices, including rotating them and inverting their contents. Task Implement the following matrix manipulation functions with optimized performance and clear handling of all edge cases. 1. `rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]`: * Rotate the given matrix 90 degrees clockwise. 2. `rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]`: * Rotate the given matrix 90 degrees counterclockwise. 3. `bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]`: * Invert the given matrix about its bottom-left to the top-right diagonal (180-degree rotation). 4. **(Bonus)** `rotate_anticlockwise(matrix: List[List[int]]) -> List[List[int]]`: * Rotate the given matrix 90 degrees anticlockwise. Constraints * The input matrix will always contain integers. * The matrix can be non-square. * Aim to reduce the computational complexity where possible. * Handle edge cases, including empty matrices and single element matrices. Input Format ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Expected Output Format ```python # For clockwise rotation of the matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] # For counterclockwise rotation of the matrix [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] # For bottom-left invert of the matrix [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] ``` Example Test Cases ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_clockwise(matrix)) # Expected [[7, 4, 1], [8, 5, 2], [9, 6, 3]] print(rotate_counterclockwise(matrix)) # Expected [[3, 6, 9], [2, 5, 8], [1, 4, 7]] print(bottom_left_invert(matrix)) # Expected [[9, 8, 7], [6, 5, 4], [3, 2, 1]] ```","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate the given matrix 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate the given matrix 90 degrees counterclockwise. return [list(row) for row in zip(*matrix)][::-1] def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: Invert the given matrix about its bottom-left to the top-right diagonal (180-degree rotation). return [row[::-1] for row in matrix[::-1]] def rotate_anticlockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate the given matrix 90 degrees anticlockwise. This is an alias for rotate_counterclockwise. return rotate_counterclockwise(matrix)"},{"question":"You are given a directed graph that represents a network of cities and roads between them. Each city is represented by a node and each road is a directed edge between nodes. Your task is to implement a function that determines whether there is a path from a specified source city to a target city using the Depth-First Search (DFS) approach. Implement a class `CityGraph` with the following methods: 1. `__init__(self, num_cities: int)`: * Initializes the graph with a given number of cities. 2. `add_road(self, from_city: int, to_city: int)`: * Adds a directed road/edge from `from_city` to `to_city`. 3. `has_path(self, source: int, target: int) -> bool`: * Determines whether there is a path from `source` to `target` city. Implementation Details: - Assume that city numbers are non-negative integers starting from 0 up to `num_cities - 1`. - Implement the graph using an adjacency list representation. - Use Depth-First Search (DFS) for path determination. Example: ```python # Create a graph with 5 cities graph = CityGraph(5) graph.add_road(0, 1) graph.add_road(0, 2) graph.add_road(1, 3) graph.add_road(3, 4) # Determine if there is a path from city 0 to city 4 print(graph.has_path(0, 4)) # Output: True # Determine if there is a path from city 4 to city 0 print(graph.has_path(4, 0)) # Output: False ``` Constraints: - 1 <= num_cities <= 10^5 - 0 <= from_city, to_city < num_cities - Multiple roads (edges) and self-loops are allowed. - Ensure your solution handles large graphs efficiently within the time and space limits.","solution":"class CityGraph: def __init__(self, num_cities: int): Initializes the graph with a given number of cities. self.num_cities = num_cities self.adj_list = [[] for _ in range(num_cities)] def add_road(self, from_city: int, to_city: int): Adds a directed road/edge from `from_city` to `to_city`. self.adj_list[from_city].append(to_city) def has_path(self, source: int, target: int) -> bool: Determines whether there is a path from `source` to `target` city. Uses Depth-First Search (DFS) for path determination. visited = [False] * self.num_cities return self._dfs(source, target, visited) def _dfs(self, current: int, target: int, visited: list) -> bool: Helper method for performing DFS. if current == target: return True visited[current] = True for neighbor in self.adj_list[current]: if not visited[neighbor]: if self._dfs(neighbor, target, visited): return True return False"},{"question":"# Regular Expression Matching You are required to implement a function to perform regular expression matching with support for two special characters `.` and `*`. * `.` Matches any single character. * `*` Matches zero or more of the preceding element. The matching should cover the entire input string (i.e., not partially matched). Function Signature ```python def is_match(input_str: str, pattern: str) -> bool: Determine if the input string matches the pattern. Parameters: - input_str (str): The string to be matched. - pattern (str): The pattern containing `.` and `*`. Returns: - bool: True if input_str matches pattern, False otherwise. ``` Example ```python assert is_match(\\"aa\\",\\"a\\") == False assert is_match(\\"aa\\",\\"aa\\") == True assert is_match(\\"aaa\\",\\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` Constraints * `input_str` and `pattern` are strings with a maximum length of 1000. * The pattern may contain only lowercase letters, `.` and `*`. Details Write the provided function using a dynamic programming approach: 1. Create a DP table to store match results for substrings of the input string and pattern. 2. Initialize the table and determine matches based on the characters and given rules. 3. Return the final result that indicates whether the entire input string matches the entire pattern. Hint * **Initialization**: Ensure the DP table is set up correctly considering empty strings and patterns. * **Transitions**: Carefully manage the transitions in the DP table when encountering `.` and `*`. * **Edge Cases**: Consider empty strings, strings matching only because of `*` at the end, etc.","solution":"def is_match(input_str: str, pattern: str) -> bool: Determine if the input string matches the pattern. Parameters: - input_str (str): The string to be matched. - pattern (str): The pattern containing `.` and `*`. Returns: - bool: True if input_str matches pattern, False otherwise. m, n = len(input_str), len(pattern) dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for j in range(1, n + 1): if pattern[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] for i in range(1, m + 1): for j in range(1, n + 1): if pattern[j - 1] == input_str[i - 1] or pattern[j - 1] == \'.\': dp[i][j] = dp[i - 1][j - 1] elif pattern[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (input_str[i - 1] == pattern[j - 2] or pattern[j - 2] == \'.\')) else: dp[i][j] = False return dp[m][n]"},{"question":"**Objective**: Write a function that ensures no element in a list appears more than a specified number of times while preserving the order of their first appearance. Use efficient data structures to achieve optimal performance. **Detailed Problem Statement**: Implement a function `delete_nth(array: List[int], n: int) -> List[int]` that takes in a list of integers `array` and an integer `n`. Your task is to return a new list such that each element in `array` appears at most `n` times in the resulting list. Ensure that the relative order of elements is preserved. **Input**: - `array`: List of integers (e.g., `[1,2,3,1,2,1,2,3]`) - `n`: A non-negative integer (e.g., `2`) **Output**: - A list of integers wherein each element appears no more than `n` times, maintaining original order (e.g., `[1,2,3,1,2,3]`) **Constraints**: - The function should handle up to (10^5) elements in `array` efficiently. - Handle special cases, such as: * An empty input list should return an empty list. * `n` can be any non-negative integer. **Performance Requirement**: * Aim for a time complexity of (O(n)) and space complexity of (O(u)), where (u) is the number of unique elements. **Example**: ```python assert delete_nth([1, 2, 3, 1, 2, 1, 2, 3], 2) == [1, 2, 3, 1, 2, 3] assert delete_nth([20, 37, 20, 21], 1) == [20, 37, 21] assert delete_nth([1, 1, 3, 3, 7, 2, 2, 2, 2], 3) == [1, 1, 3, 3, 7, 2, 2, 2] ``` Write your solution in Python 3. Note that you should not use any pre-existing function that directly solves the problem.","solution":"def delete_nth(array, n): Return a list such that each element in the array appears at most n times, maintaining the original order. from collections import defaultdict result = [] counts = defaultdict(int) for item in array: if counts[item] < n: result.append(item) counts[item] += 1 return result"},{"question":"# Context You are tasked with improving the efficiency of a task scheduling system used in an operating system. The current system uses a priority queue which relies on a sorted linear array. While extraction of the highest priority task is efficient, inserting new tasks tends to be slow and inefficient with rising numbers of tasks. # Objective Implement a modified data structure to maintain a priority queue that retains efficient insertion and extraction of tasks. # Task Design and implement a `PriorityQueue` class using a heap (binary heap) to improve the efficiency of both insertion and extraction operations. # Requirements 1. The `PriorityQueue` class should support the following operations: - `push(item, priority)`: Insert a new task with a given priority. The lower the number, the higher the priority (e.g., priority 1 is higher than priority 5). - `pop()`: Extract and return the task with the highest priority. - `peek()`: Return the task with the highest priority without removing it from the queue. - `size()`: Return the number of tasks in the queue. 2. Your solution should ensure: - Insertions take logarithmic time, O(log n). - Extractions take logarithmic time, O(log n). - You handle edge cases such as popping from an empty queue gracefully. # Input and Output Format * **Input**: - Method calls with arguments, e.g., `push(\\"task1\\", 3)`, `pop()`, `size()`. * **Output**: - Results from method calls, e.g., `pop()` returns the task with the highest priority. # Constraints * Tasks and priorities are provided as strings and integers, respectively. * Assume priorities are unique for simplicity. # Example ```python pq = PriorityQueue() pq.push(\\"task1\\", 3) pq.push(\\"task2\\", 1) print(pq.pop()) # Output: \\"task2\\" print(pq.peek()) # Output: \\"task1\\" print(pq.size()) # Output: 1 ``` Design and implement the `PriorityQueue` class based on the requirements given.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def push(self, item, priority): heapq.heappush(self.heap, (priority, item)) def pop(self): if not self.is_empty(): return heapq.heappop(self.heap)[1] else: raise IndexError(\\"pop from an empty priority queue\\") def peek(self): if not self.is_empty(): return self.heap[0][1] else: raise IndexError(\\"peek from an empty priority queue\\") def size(self): return len(self.heap) def is_empty(self): return len(self.heap) == 0"},{"question":"# Palindrome Checker: Advanced Variations You are provided multiple variations of a function to check if a given string is a palindrome. Your task is to implement a function to identify the most efficient algorithm in terms of both time and space complexity for checking palindromes. Additionally, write a function that handles edge cases effectively. Requirements: 1. Write a function `most_efficient_palindrome_checker(s: str) -> bool` that: - Determines if the input string `s` is a palindrome. - Efficiently handles edge cases, such as empty strings and strings with only non-alphanumeric characters. - Uses the most time and space-efficient algorithm among the provided variations. 2. The function should comply with the following: - **Input**: A string `s` where 1 ≤ len(s) ≤ 10^5. - **Output**: A boolean indicating whether the string is a valid palindrome. 3. String characteristics: - Only alphanumeric characters are considered. - The function should be case-insensitive. Constraints: - Try to optimize the function to handle up to 10^5 characters efficiently. - Consider both time and space complexities for the best approach. Example Input and Output: ```python # Example 1 input_str = \\"A man, a plan, a canal: Panama\\" Output: True # Example 2 input_str = \\"race a car\\" Output: False # Example 3 input_str = \\" \\" Output: True # Example 4 input_str = \\".,\\" Output: True ``` Provide the implementation of `most_efficient_palindrome_checker` below.","solution":"import re def most_efficient_palindrome_checker(s: str) -> bool: This function determines if the input string s is a palindrome, considering only alphanumeric characters. It uses a case-insensitive comparison to determine if the string is a palindrome. :param s: Input string to be checked :returns: True if the string is a palindrome, False otherwise # Removing all non-alphanumeric characters and converting to lower case s = re.sub(r\'[^a-zA-Z0-9]\', \'\', s).lower() # Comparing the string with its reverse return s == s[::-1]"},{"question":"Scenario You are working on a system dealing with linked lists. As part of an operation, you need to remove a specific range of elements from the list efficiently. The task involves manipulating pointers of a linked list to remove elements from a given starting index to an ending index inclusively. Task Write a function `remove_range` that takes in the head of a singly linked list and two integers `start` and `end`. The function should remove all nodes from the start index to the end index (inclusive) and return the head of the modified list. Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_range(head, start, end): # Your implementation here ``` Input * The **head** of a linked list where each node has an integer value. * Two integers, **start** and **end** which represent the indices (0-based) of the elements to be removed. Output * The **head** of the modified linked list. Constraints * all indices are 0-based. * 0 <= start <= end < size of the list (The function should assert this condition). Example ```python # List: [8, 13, 17, 4, 9, 12, 98, 41, 7, 23, 0, 92] linked_list = ListNode(8, ListNode(13, ListNode(17, ListNode(4, ListNode(9, ListNode(12, ListNode(98, ListNode(41, ListNode(7, ListNode(23, ListNode(0, ListNode(92)))))))))))) remove_range(linked_list, 3, 8) # List becomes: [8, 13, 17, 23, 0, 92] ``` Notes * Ensure the function correctly handles different start and end positions, including cases where nodes at the beginning, middle, or end of the list might be removed. * The function should maintain the integrity of the list\'s remaining elements, correctly re-linking nodes as necessary. * The provided `ListNode` class defines nodes in the linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_range(head, start, end): assert 0 <= start <= end, \\"Start index must be less than or equal to end index and within the list bounds.\\" dummy = ListNode(0) dummy.next = head current = dummy # Navigate to the node just before the start index for _ in range(start): current = current.next # Mark the node just before the start of the range to be removed prev = current # Move to the end of the range to be removed for _ in range(end - start + 1): current = current.next # Re-link to skip the removed nodes prev.next = current.next return dummy.next"},{"question":"First Occurrence Finder in Sorted Array You are given a sorted array of integers (in increasing order) and a query integer. Your task is to find the index of the first occurrence of the query integer in the array efficiently. If the query integer is not found in the array, return -1. # Function Signature ```python def first_occurrence(array: List[int], query: int) -> int: pass ``` # Input 1. `array` (List[int]): A list of integers sorted in increasing order. The list may contain duplicate values. 2. `query` (int): An integer value to search for in the array. # Output - Returns an integer representing the index of the first occurrence of the query integer in the sorted array. - Returns -1 if the query integer is not present in the array. # Constraints - The array can have at most 10^5 elements. - The array elements and the query integer can be in the range of -10^9 to 10^9. - You must achieve a time complexity of O(log n). # Example ```python # Example 1 array = [1, 2, 2, 2, 3, 4, 5] query = 2 # The first occurrence of 2 is at index 1 assert first_occurrence(array, query) == 1 # Example 2 array = [1, 2, 3, 4, 5, 6, 7] query = 8 # The element 8 is not in the array assert first_occurrence(array, query) == -1 # Example 3 array = [] query = 1 # The element 1 is not in the empty array assert first_occurrence(array, query) == -1 ``` # Description Implement the function `first_occurrence` which takes in a sorted array and a query integer, and returns the index of the first occurrence of the query. Use binary search to achieve the required time complexity of O(log n). Consider edge cases such as an empty array and elements that are not present.","solution":"from typing import List def first_occurrence(array: List[int], query: int) -> int: left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == query: if mid == 0 or array[mid - 1] < query: return mid right = mid - 1 elif array[mid] < query: left = mid + 1 else: right = mid - 1 return -1"},{"question":"<|Analysis Begin|> **Algorithm/Data Structure:** * **B-Tree** (Balanced Tree) * **Type:** Tree data structure * **Main Purpose:** B-Trees are used to store sorted data and allow searches, insertions, deletions, and sequential access to be performed in logarithmic time. This makes them highly efficient for use in database systems and file systems. **Complexity:** * **Space Complexity:** O(n) * **Search Complexity:** O(log n) * **Insertion Complexity:** O(log n) * **Deletion Complexity:** O(log n) **Principles:** * B-Trees maintain balanced multi-level indexes that require O(log n) time to search. * Nodes may contain multiple keys and children, unlike binary search trees. * Nodes split or merge when they become full or too sparse, respectively, in order to maintain balance. * Operations ensure that all leaf nodes remain at the same depth. **Characteristics & Applications:** * **Properties:** * Each node (except the root) must have at least `t-1` keys and at most `2t-1` keys (`t` is the minimum degree of the B-Tree). * The tree grows from the root and ensures all leaf nodes stay at the same level. * **Common Use Cases:** * Databases and filesystems use B-Trees due to their balanced nature and efficiency in data retrieval and updates. * **Strengths/Limitations:** * Strengths: Handles large blocks of data efficiently because of its balanced nature and logarithmic time complexity. * Limitations: Can be complex to implement and maintain, especially with dynamic operations. **Implementation Challenges:** * **Edge Cases:** * Full nodes requiring splits, sparse nodes requiring merges or rotations. * **Performance Bottlenecks:** * During splits and merges, where multiple tree traversals and structural adjustments may be necessary. * **Error Scenarios:** * When searching or deleting, incorrect handling of non-existent keys or underflow conditions. * **Optimization Points:** * Careful handling of node splits and merges to minimize overhead. <|Analysis End|> <|Question Begin|> # Coding Assessment Context: The B-Tree is an efficient self-balancing tree data structure, widely used for database indexing and file storage systems. It supports fundamental operations such as search, insert, and delete, ensuring that all leaf nodes remain at the same level, thereby maintaining balance. Task: Implement the `remove_key` method in a B-Tree, which supports balanced deletion of keys while maintaining the B-Tree properties. Function Signature: ```python def remove_key(self, key: int) -> bool: # Your implementation goes here pass ``` Constraints: * The tree will be balanced such that it does not violate B-Tree properties. * The B-Tree is of a minimum degree `t` (integer, `t >= 2`). * Initial state of the tree ensures no two keys in a node are the same (keys are unique). Input: * `key`: An integer that represents the key to be removed from the B-Tree. Output: * Return `True` if removal is successful, or `False` if the key does not exist in the tree. Example: ```python # Assuming the B-Tree class has been properly initialized and populated. btree = BTree(t_val=3) # Initialize B-tree with minimum degree t=3. btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) assert btree.remove_key(6) == True # Removal of existing key 6. assert btree.find(6) == False # Confirm key 6 is removed. assert btree.remove_key(100) == False # Attempt removing non-existent key 100. ``` Implementation Details: * Utilize the helper methods provided in the initial B-Tree code template to balance the tree and perform necessary rotations or merges. * Ensure the method removes the key appropriately while preserving the B-Tree properties. * Handle edge cases such as underflow in nodes or non-existent keys gracefully. Note: The integrity and balance of the B-Tree are crucial for optimal performance in database systems or filesystems, making the correct implementation of operations including deletion imperative.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] class BTree: def __init__(self, t_val): self.t = t_val self.root = BTreeNode(t_val, True) def insert_key(self, key): root = self.root if len(root.keys) == (2 * self.t - 1): new_root = BTreeNode(self.t, False) new_root.children.insert(0, self.root) self._split_child(new_root, 0) self._insert_non_full(new_root, key) self.root = new_root else: self._insert_non_full(root, key) def _insert_non_full(self, node, key): i = len(node.keys) - 1 if node.leaf: node.keys.append(None) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t - 1): self._split_child(node, i) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def _split_child(self, parent, idx): t = self.t full_child = parent.children[idx] new_child = BTreeNode(t, full_child.leaf) parent.keys.insert(idx, full_child.keys[t-1]) parent.children.insert(idx + 1, new_child) new_child.keys = full_child.keys[t:(2*t-1)] full_child.keys = full_child.keys[0:(t-1)] if not full_child.leaf: new_child.children = full_child.children[t:(2*t)] full_child.children = full_child.children[0:t] def find(self, key): return self._find_key(self.root, key) def _find_key(self, node, key): i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and key == node.keys[i]: return True if node.leaf: return False return self._find_key(node.children[i], key) def remove_key(self, key): if not self.find(key): return False self._remove_key(self.root, key) if len(self.root.keys) == 0: if not self.root.leaf: self.root = self.root.children[0] else: self.root = None return True def _remove_key(self, node, key): t = self.t i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and node.keys[i] == key: if node.leaf: node.keys.pop(i) else: if len(node.children[i].keys) >= t: pred_key = self._get_predecessor(node, i) node.keys[i] = pred_key self._remove_key(node.children[i], pred_key) elif len(node.children[i + 1].keys) >= t: succ_key = self._get_successor(node, i) node.keys[i] = succ_key self._remove_key(node.children[i + 1], succ_key) else: self._merge(node, i) self._remove_key(node.children[i], key) elif not node.leaf: if len(node.children[i].keys) < t: self._fill(node, i) self._remove_key(node.children[i], key) def _get_predecessor(self, node, idx): cur = node.children[idx] while not cur.leaf: cur = cur.children[-1] return cur.keys[-1] def _get_successor(self, node, idx): cur = node.children[idx + 1] while not cur.leaf: cur = cur.children[0] return cur.keys[0] def _merge(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] t = self.t child.keys.append(node.keys[idx]) for i in range(len(sibling.keys)): child.keys.append(sibling.keys[i]) if not child.leaf: for i in range(len(sibling.children)): child.children.append(sibling.children[i]) node.keys.pop(idx) node.children.pop(idx + 1) def _fill(self, node, idx): t = self.t if idx != 0 and len(node.children[idx - 1].keys) >= t: self._borrow_from_prev(node, idx) elif idx != len(node.children) - 1 and len(node.children[idx + 1].keys) >= t: self._borrow_from_next(node, idx) else: if idx != len(node.children) - 1: self._merge(node, idx) else: self._merge(node, idx - 1) def _borrow_from_prev(self, node, idx): child = node.children[idx] sibling = node.children[idx - 1] for i in range(len(child.keys) - 1, -1, -1): child.keys[i + 1] = child.keys[i] if not child.leaf: for i in range(len(child.children) - 1, -1, -1): child.children[i + 1] = child.children[i] child.keys[0] = node.keys[idx - 1] if not child.leaf: child.children[0] = sibling.children.pop() node.keys[idx - 1] = sibling.keys.pop(-1) def _borrow_from_next(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) node.keys[idx] = sibling.keys.pop(0) if not child.leaf: child.children.append(sibling.children.pop(0))"},{"question":"# Scenario You are working as a software engineer at a company where you need to handle communication of lists of strings over a network. To achieve this, the lists will be encoded into a single string before transmission and decoded back into a list upon reception. # Task Create two functions, `encode` and `decode`, to handle this process. The `encode` function should turn a list of strings into a single string formatted such that it can later be accurately decoded by the `decode` function. The `decode` function should reverse this process, taking the formatted string and returning the original list of strings. # Input and Output - `encode` function: - **Input**: `strs` - List of strings `[str, ...]` - **Output**: Encoded string `str` - `decode` function: - **Input**: `s` - Encoded string `str` - **Output**: Decoded list of strings `[str, ...]` # Constraints - All characters in strings are valid ASCII characters. - You can assume that your functions are always called with correctly formatted inputs as per the above definitions. # Example ```python # Example Usage: input_strs = [\\"hello\\", \\"world\\"] encoded_str = encode(input_strs) print(encoded_str) # Outputs a single encoded string, e.g., \\"5:hello5:world\\" decoded_strs = decode(encoded_str) print(decoded_strs) # Outputs the original list of strings, e.g., [\\"hello\\", \\"world\\"] ``` # Requirements Your solution should handle: - Lists containing empty strings. - Performance considerations for potentially large lists. # Implementation Implement the `encode` and `decode` functions below: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str # Your implementation here pass def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] # Your implementation here pass ```","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] i, n = 0, len(s) decoded_list = [] while i < n: j = i while s[j] != \':\': # Find the separator to get the length of the string j += 1 length = int(s[i:j]) i = j + 1 # Move the index to the start of the actual string decoded_list.append(s[i:i + length]) i += length # Move the index to the start of the next length descriptor return decoded_list"},{"question":"You are tasked with implementing a system that supports fast insertion and querying of words based on their prefixes. The system should use a trie (prefix tree) data structure to achieve this, offering three primary functionalities: `insert`, `search`, and `starts_with`. # Requirements 1. **Insert word**: Adds a word to the trie. 2. **Search word**: Returns `True` if the word is in the trie, otherwise `False`. 3. **Starts with prefix**: Returns `True` if there is any word in the trie that starts with the given prefix, otherwise `False`. # Input and Output Formats Input - Words and prefixes are composed of lowercase English letters (\'a\' to \'z\') only. - Multiple operations are requested in sequence. Operations - **insert(word)**: `word` is a non-empty string. - **search(word)**: `word` is a non-empty string. - **starts_with(prefix)**: `prefix` is a non-empty string. Output - Return `True` or `False` for `search` and `starts_with` operations. - No output for `insert` operations. # Constraints - Assume that all input words and prefixes consist of lowercase letters a-z. - The total number of words and prefixes queried will not exceed 10^5. # Performance Requirements - The code should be optimized for insertion and look-up operations to run in O(m) time, where m is the length of the word or prefix being handled. - Space complexity should be managed efficiently to handle large numbers of words. # Example Operations ```python # Initialize the trie trie = Trie() # Insert words trie.insert(\\"apple\\") trie.insert(\\"app\\") # Search for words print(trie.search(\\"apple\\")) # returns True print(trie.search(\\"app\\")) # returns True print(trie.search(\\"appl\\")) # returns False # Check prefixes print(trie.starts_with(\\"app\\")) # returns True print(trie.starts_with(\\"a\\")) # returns True print(trie.starts_with(\\"b\\")) # returns False ``` # Implementation Implement the `Trie` class in Python with the specified methods. Ensure your code handles edge cases and performs optimally under the given constraints.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: Inserts a word into the trie. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: Returns if the word is in the trie. node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: Returns if there is any word in the trie that starts with the given prefix. node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Question You are provided with an array of sorted integers, `array`, and an integer value, `val`. Your task is to write a function `optimized_search_insert(array, val)` that determines the index where `val` would be inserted into `array` to maintain the sorted order. If `val` exists in `array`, return the index at which it occurs. # Function Signature ```python def optimized_search_insert(array: List[int], val: int) -> int: Find the index of val in the sorted array, or the insert index where it should be placed to maintain sorted order. Parameters: array (List[int]): A list of integers sorted in ascending order. val (int): A target integer value to find within `array`. Returns: int: The index where `val` is located or should be inserted. ``` # Input * `array` (List[int]): A sorted list of integers, where 1 <= len(array) <= 10^5 and -10^9 <= array[i] <= 10^9. * `val` (int): An integer target value within the range -10^9 <= val <= 10^9. # Output * An integer representing the index at which `val` should be inserted to maintain the sorted order of `array`. If `val` already exists, return the index of its first occurrence. # Example ```python array = [1, 3, 5, 6] val = 7 print(optimized_search_insert(array, val)) # Output: 4 array = [1, 3, 5, 6] val = 0 print(optimized_search_insert(array, val)) # Output: 0 array = [1, 3, 5, 6] val = 5 print(optimized_search_insert(array, val)) # Output: 2 ``` # Constraints * The function must complete within a time complexity of O(log n). * Assume that the input array is already sorted. Ensure your implementation is tested against edge cases such as: * Minimum and maximum lengths of the array. * Values that fall outside the current range of the array.","solution":"from typing import List def optimized_search_insert(array: List[int], val: int) -> int: Find the index of val in the sorted array, or the insert index where it should be placed to maintain sorted order. Parameters: array (List[int]): A list of integers sorted in ascending order. val (int): A target integer value to find within `array`. Returns: int: The index where `val` is located or should be inserted. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == val: return mid elif array[mid] < val: left = mid + 1 else: right = mid - 1 return left"},{"question":"# Question You have been provided with a skeleton class for a `TreeNode` used to implement a binary search tree (BST). Your task is to complete the implementation of this binary search tree by writing the functions to insert, search, and delete nodes. Class and Function Details 1. **TreeNode class**: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None ``` 2. **BST class** (you need to complete): ```python class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: Insert a value into the BST. :param val: Value to insert. # Your code here def search(self, val: int) -> bool: Search for a value in the BST. :param val: Value to search. :return: True if the value exists in the tree, otherwise False. # Your code here def delete(self, val: int) -> None: Delete a value from the BST. :param val: Value to delete. # Your code here ``` Input and Output * `insert(val: int) -> None`: You need to insert the value `val` into the BST. * `search(val: int) -> bool`: You need to search for the value `val` in the BST. Return `True` if the value exists, otherwise return `False`. * `delete(val: int) -> None`: You need to delete the value `val` from the BST. Constraints * Values in the BST are integers. * No duplicate values should be inserted. Performance Requirements * All operations (insert, search, delete) should strive to maintain an average time complexity of O(log n). Your Tasks 1. Implement the `insert` function. 2. Implement the `search` function. 3. Implement the `delete` function.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: Insert a value into the BST. :param val: Value to insert. if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node: TreeNode, val: int) -> None: if val < node.val: if node.left: self._insert(node.left, val) else: node.left = TreeNode(val) elif val > node.val: if node.right: self._insert(node.right, val) else: node.right = TreeNode(val) def search(self, val: int) -> bool: Search for a value in the BST. :param val: Value to search. :return: True if the value exists in the tree, otherwise False. return self._search(self.root, val) def _search(self, node: TreeNode, val: int) -> bool: if not node: return False if val == node.val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val) def delete(self, val: int) -> None: Delete a value from the BST. :param val: Value to delete. self.root = self._delete(self.root, val) def _delete(self, node: TreeNode, val: int) -> TreeNode: if not node: return None if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if not node.left: return node.right elif not node.right: return node.left min_larger_node = self._get_min(node.right) node.val = min_larger_node.val node.right = self._delete(node.right, min_larger_node.val) return node def _get_min(self, node: TreeNode) -> TreeNode: while node.left: node = node.left return node"},{"question":"You are given an implementation of a Separate Chaining Hash Table, a data structure that allows for efficient average-case time complexity for basic operations such as insertion, deletion, and retrieval of key-value pairs. Your task is to extend this implementation by adding two methods: 1. **resize(new_size):** This method should resize the hash table to a new size and rehash all existing elements. 2. **load_factor():** This method should return the load factor of the hash table, defined as the number of elements divided by the size of the table. # Function Signatures ```python class SeparateChainingHashTable: def resize(self, new_size): pass def load_factor(self): pass ``` # Constraints and Requirements 1. The hash table should maintain its property of efficient average time complexity after resizing. 2. Ensure that all elements are rehashed correctly when resized. 3. The `load_factor` method should return a float value. 4. The provided solution should handle edge cases such as resizing to a smaller size than the number of elements. # Example ```python table = SeparateChainingHashTable(size=5) table.put(\'a\', 1) table.put(\'b\', 2) table.put(\'c\', 3) # The load factor before resizing print(table.load_factor()) # Should print 0.6 # Resize the table table.resize(10) # Verifying if elements are correctly hashed in the new table size print(table.get(\'a\')) # Should return 1 print(table.get(\'b\')) # Should return 2 print(table.get(\'c\')) # Should return 3 # The load factor after resizing print(table.load_factor()) # Should print 0.3 ``` # Notes 1. You may assume that the keys are always hashable. 2. The initial implementation assumes a basic hash function and linear probing strategy. You must ensure that the new size specified during resizing always maintains a valid hash table (prime numbers are not necessary). 3. Thoroughly test your implementation for different scenarios, such as resizing with high, low, or even zero elements.","solution":"class SeparateChainingHashTable: def __init__(self, size=10): self.table = [[] for _ in range(size)] self.size = size self.count = 0 def hash(self, key): return hash(key) % self.size def put(self, key, value): index = self.hash(key) for item in self.table[index]: if item[0] == key: item[1] = value return self.table[index].append([key, value]) self.count += 1 def get(self, key): index = self.hash(key) for item in self.table[index]: if item[0] == key: return item[1] return None def delete(self, key): index = self.hash(key) for i, item in enumerate(self.table[index]): if item[0] == key: del self.table[index][i] self.count -= 1 return True return False def resize(self, new_size): old_table = self.table self.table = [[] for _ in range(new_size)] self.size = new_size self.count = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) def load_factor(self): return self.count / self.size"},{"question":"# Question Given the provided implementations of max heap sort and min heap sort algorithms, you are required to write a function that switches between the sorting algorithms based on user input. The function signature should be defined as follows: ```python def heap_sort_switch(arr, sort_type, simulation=False): Sorts the array using either max heap or min heap sort based on \'sort_type\'. Parameters: arr (list of int): The array to be sorted sort_type (str): \'max\' for max heap sort, \'min\' for min heap sort simulation (bool): If True, enables printing iteration steps Returns: list of int: The sorted array ``` Input Constraints * `arr` is a list of integers (1 ≤ len(arr) ≤ 10^5, -10^6 ≤ arr[i] ≤ 10^6) * `sort_type` is a string and must be either `\'max\'` or `\'min\'` * `simulation` is a boolean, default is `False` Output * Return a list of integers sorted in ascending order. You are expected to use the provided `max_heap_sort` and `min_heap_sort` functions to perform the sorting based on the `sort_type` parameter. Example ```python # Example Input 1: arr = [4, 10, 3, 5, 1] sort_type = \\"max\\" # Example Output 1: [1, 3, 4, 5, 10] # Example Input 2: arr = [4, 10, 3, 5, 1] sort_type = \\"min\\" # Example Output 2: [1, 3, 4, 5, 10] ``` Additional Explanation The `heap_sort_switch` function should delegate the actual sorting to `max_heap_sort` or `min_heap_sort` based on the `sort_type` value. The `simulation` flag, when set to `True`, should be passed to the heap sort functions to enable iteration printing each step.","solution":"def max_heapify(arr, n, i, simulation): largest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and arr[l] > arr[largest]: largest = l if r < n and arr[r] > arr[largest]: largest = r if largest != i: arr[i], arr[largest] = arr[largest], arr[i] if simulation: print(arr) max_heapify(arr, n, largest, simulation) def max_heap_sort(arr, simulation=False): n = len(arr) for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i, simulation) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(arr) max_heapify(arr, i, 0, simulation) return arr def min_heapify(arr, n, i, simulation): smallest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and arr[l] < arr[smallest]: smallest = l if r < n and arr[r] < arr[smallest]: smallest = r if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] if simulation: print(arr) min_heapify(arr, n, smallest, simulation) def min_heap_sort(arr, simulation=False): n = len(arr) for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i, simulation) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(arr) min_heapify(arr, i, 0, simulation) arr.reverse() # For ascending order return arr def heap_sort_switch(arr, sort_type, simulation=False): if sort_type == \'max\': return max_heap_sort(arr, simulation) elif sort_type == \'min\': return min_heap_sort(arr, simulation) else: raise ValueError(\\"Invalid sort_type. Use \'max\' or \'min\'.\\")"},{"question":"# Zigzag Iterator for Multiple Lists You are tasked with implementing a more generalized version of the Zigzag Iterator that can handle `k` lists (`v1`, `v2`, ..., `vk`) rather than just 2 lists. This iterator must return elements from the provided lists in a zigzag manner - delivering one element from each list in sequence. Once elements in a list are exhausted, it should continue with the remaining lists until all elements from all lists have been returned. # Function Signature ```python class ZigZagIteratorK: def __init__(self, lists: List[List[int]]): Initialize your data structure here. :type lists: List[List[int]] pass def next(self) -> int: :rtype: int pass def has_next(self) -> bool: :rtype: bool pass ``` # Requirements 1. **Initialization**: The constructor should initialize the data structure with the given lists. 2. **Next**: The `next` method should return the next element in the zigzag order. 3. **Has Next**: The `has_next` method should return `True` if there are more elements to return, otherwise `False`. # Constraints - The number of input lists `k` is between 1 and 1000. - The number of elements in each list is between 0 and 1000. # Example ```python lists = [[1, 2], [3, 4, 5, 6], [7, 8, 9]] it = ZigZagIteratorK(lists) results = [] while it.has_next(): results.append(it.next()) print(results) # Output should be [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` # Explanation In the provided example: 1. Initialize the iterator with 3 lists. 2. During iteration, it will extract elements in the following zigzag order: - 1 (from list 1) - 3 (from list 2) - 7 (from list 3) - 2 (from list 1) - 4 (from list 2) - 8 (from list 3) - 5 (from list 2) - 9 (from list 3) - 6 (from list 2)","solution":"from typing import List class ZigZagIteratorK: def __init__(self, lists: List[List[int]]): Initialize the zigzag iterator with a list of lists. self.lists = lists self.queue = [] for i, lst in enumerate(lists): if lst: # Only add non-empty lists self.queue.append((i, 0)) def next(self) -> int: Return the next element in zigzag order. if not self.has_next(): raise Exception(\\"No more elements\\") list_idx, elem_idx = self.queue.pop(0) value = self.lists[list_idx][elem_idx] if elem_idx + 1 < len(self.lists[list_idx]): self.queue.append((list_idx, elem_idx + 1)) return value def has_next(self) -> bool: Return whether there are more elements to iterate over. return len(self.queue) > 0"},{"question":"Your task is to implement two functions, `encode` and `decode`, that encode a list of strings into a single string for transmission and decode it back to the original list of strings. These functions need to handle edge cases and be efficient in terms of both time and space. Functions to Implement * **encode(strs: List[str]) -> str**: This function takes a list of strings and returns a single encoded string. The encoding should be in the form `length_of_string1:string1length_of_string2:string2...`. * **decode(s: str) -> List[str]**: This function takes a single encoded string and returns the original list of strings. Input/Output Format * **Input**: - `encode`: * `strs`: List of strings (any valid string). - `decode`: * `s`: An encoded string using the specified format. * **Output**: - `encode`: A single encoded string. - `decode`: The original list of strings. Constraints * Strings can be any printable characters. * Empty lists and empty strings within lists are allowed. Example ```python # Example 1 input_strs = [\\"hello\\", \\"world\\"] encoded_str = encode(input_strs) print(encoded_str) # Output: \\"5:hello5:world\\" decoded_list = decode(encoded_str) print(decoded_list) # Output: [\\"hello\\", \\"world\\"] # Example 2 input_strs = [\\"\\", \\"foo\\", \\"bar\\"] encoded_str = encode(input_strs) print(encoded_str) # Output: \\"0:3:foo3:bar\\" decoded_list = decode(encoded_str) print(decoded_list) # Output: [\\"\\", \\"foo\\", \\"bar\\"] ``` Notes * Assume all input strings are properly formatted according to the described requirements. * Ensure your code handles edge cases such as empty lists and strings containing the delimiter properly.","solution":"def encode(strs): Encodes a list of strings to a single string. :param strs: List of strings :return: Encoded single string return \'\'.join(f\\"{len(s)}:{s}\\" for s in strs) def decode(s): Decodes a single string to a list of strings. :param s: Encoded single string :return: List of original strings res, i = [], 0 while i < len(s): j = i while s[j] != \':\': j += 1 length = int(s[i:j]) i = j + 1 + length res.append(s[j+1:i]) return res"},{"question":"# Rotated String Check You are given two strings `s1` and `s2`. Your task is to determine if `s2` is a rotation of `s1`. A string rotation involves shifting the characters of a string to the left or the right to form another string. For example, \\"abcde\\" shifted left by 2 characters becomes \\"cdeab\\". Input - `s1`: A string of lowercase English letters, length (n) (1 ≤ (n) ≤ 10^5). - `s2`: A string of lowercase English letters, length (n). Output - Return a boolean value `True` if `s2` is a rotation of `s1`, otherwise return `False`. Constraints 1. The lengths of `s1` and `s2` are equal. 2. The strings may contain up to (10^5) characters. Scenario Imagine you are designing a text editor that supports advanced text manipulation operations. One such feature is checking whether a particular word can be formed by rotating another word. Implementing this check efficiently is crucial for the performance of your application. Example ```python # Example 1 s1 = \\"hello\\" s2 = \\"llohe\\" Output: True # Example 2 s1 = \\"hello\\" s2 = \\"helol\\" Output: False ``` You are required to implement the function: ```python def is_rotated(s1: str, s2: str) -> bool: # Your implementation here ``` # Considerations - Ensure your solution efficiently handles the maximum input size. - Think about special cases such as empty strings or repetitive patterns.","solution":"def is_rotated(s1: str, s2: str) -> bool: Determines if s2 is a rotation of s1 by checking if s2 is a substring of s1 concatenated with s1. if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"# Diffie-Hellman Secure Key Exchange Simulation You are tasked with implementing a secure key exchange algorithm using the Diffie-Hellman method. The given code snippets include all the utility functions required to verify primes, compute Euler\'s Totient function, find primitive roots, and perform the key exchange itself. Your task is to create a function `secure_key_exchange` that: 1. Ensures the prime number ( p ) and its primitive root ( a ) are valid. 2. Generates private and public keys for two parties (Alice and Bob). 3. Computes the shared secret key. 4. Returns the shared secret key or indicate an error if the keys cannot be correctly generated. # Expected Input and Output Input * Prime number ( p ) (an integer greater than 1). * Primitive root ( a ) (a positive integer less than ( p )). Output * An integer which is the shared secret key if successful. * A string indicating the error in case of incorrect input or failure in key generation. # Constraints * ( 2 leq p leq 10^6 ) * ( 1 leq a < p ) * Both ( p ) and ( a ) are provided as positive integers. # Performance Requirements * The solution should be optimized for large integers within the given constraints. * Efficient primality checks and totient function evaluations are necessary. # Function Signature ```python def secure_key_exchange(p: int, a: int) -> Union[int, str]: pass ``` # Example Example 1: ```python p = 23 a = 5 shared_key = secure_key_exchange(p, a) print(shared_key) # Expected output: 2 (or another valid shared key depending on key generation) ``` Example 2: ```python p = 15 a = 5 shared_key = secure_key_exchange(p, a) print(shared_key) # Expected output: \\"15 is not a prime number\\" ```","solution":"import random def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def power_mod(base, exp, mod): result = 1 base = base % mod while exp > 0: if exp % 2 == 1: result = (result * base) % mod exp = exp >> 1 base = (base * base) % mod return result def find_primitive_root(p): if p == 2: return 1 phi = p - 1 prime_factors = set() n = phi factor = 2 while factor * factor <= n: if n % factor == 0: prime_factors.add(factor) while n % factor == 0: n //= factor factor += 1 if n > 1: prime_factors.add(n) for r in range(2, p): flag = False for factor in prime_factors: if power_mod(r, phi // factor, p) == 1: flag = True break if not flag: return r return -1 def secure_key_exchange(p: int, a: int) -> int: if not is_prime(p): return f\\"{p} is not a prime number\\" if find_primitive_root(p) != a: return f\\"{a} is not a primitive root of {p}\\" alice_private = random.randint(1, p-2) bob_private = random.randint(1, p-2) alice_public = power_mod(a, alice_private, p) bob_public = power_mod(a, bob_private, p) alice_shared_secret = power_mod(bob_public, alice_private, p) bob_shared_secret = power_mod(alice_public, bob_private, p) assert alice_shared_secret == bob_shared_secret return alice_shared_secret"},{"question":"# Question: Efficient Binomial Coefficient Calculation Context The binomial coefficient, C(n, k), represents the number of ways to choose k items from a set of n items without considering the order. It is a fundamental concept in combinatorics and has applications in probability, statistics, and various algorithmic problems. Task Write a function `iterative_binomial_coefficient` in Python that efficiently computes the binomial coefficient C(n, k) using an iterative approach. Your implementation should handle large values of n and k without running into recursion depth limits. Function Signature ```python def iterative_binomial_coefficient(n: int, k: int) -> int: pass ``` Input - `n` (0 <= n <= 10^6): A non-negative integer representing the total number of items. - `k` (0 <= k <= n): A non-negative integer representing the number of items to choose. Output - Returns an integer representing the binomial coefficient C(n, k). Constraints 1. Ensure your solution handles large values efficiently. 2. Avoid recursion to prevent stack overflow issues. 3. Optimize the function to work within the given constraints. Example ```python assert iterative_binomial_coefficient(5, 0) == 1 assert iterative_binomial_coefficient(8, 2) == 28 assert iterative_binomial_coefficient(500, 300) == 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 ``` Hint Use iterative computation and leverage the symmetry property C(n, k) = C(n, n-k) for optimization.","solution":"def iterative_binomial_coefficient(n: int, k: int) -> int: Compute the binomial coefficient C(n, k) using an iterative approach. if k > n: return 0 if k == 0 or k == n: return 1 if k > n - k: k = n - k # take advantage of symmetry property result = 1 for i in range(k): result = result * (n - i) // (i + 1) return result"},{"question":"# Sorting a List with Minimal Writes using Cycle Sort As part of a programming assessment, you are tasked with implementing a function based on a sorting algorithm that minimizes write operations. Specifically, you need to use the **Cycle Sort** algorithm to sort a list in ascending order. # `def cycle_sort(arr: List[int]) -> List[int]:` Input * A list of integers `arr` where `1 <= len(arr) <= 1000`. Output * A sorted list of integers with the elements from `arr` arranged in ascending order. # Constraints * The list may contain duplicate elements. * The input list will have a length between 1 and 1000. * Do not use any built-in sorting functions. * Your implementation should aim to minimize write operations to the list. # Example ```python # Example 1 Input: [4, 3, 2, 1] Output: [1, 2, 3, 4] # Example 2 Input: [1, 3, 0, 2, 5, 4] Output: [0, 1, 2, 3, 4, 5] # Example 3 Input: [5, 5, 4, 4, 3] Output: [3, 4, 4, 5, 5] ``` # Testing * Test your function with various edge cases, including arrays that are already sorted, arrays with duplicates, an empty array, and an array with a single element. * Ensure your code efficiently sorts the array and handles all the given constraints. # Tips * Carefully handle indexes and duplication within the array. * Ensure that each cycle is handled correctly without infinite looping. * Thoroughly test your solution to ensure correctness and minimal writes.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: writes = 0 # traverse array elements and put it to on # the right place for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find position where we put the element pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the element is already in correct position if pos == cycle_start: continue # Ignore all duplicate elements while item == arr[pos]: pos += 1 # Put the item to it\'s right position arr[pos], item = item, arr[pos] writes += 1 # Rotate rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"Context You work for a company developing a low-level hardware driver for a new communication device. This device relies on efficient bit manipulation to handle its numerous control flags effectively. Your task is to implement several functions that will set, clear, get, and update specific control flags represented as bits within an integer. Task Implement the following four bit manipulation functions: 1. **get_bit(num, i)**: Return the bit value (0 or 1) at the specified index from the integer `num`. 2. **set_bit(num, i)**: Return an integer with the bit at the specified index set to 1. 3. **clear_bit(num, i)**: Return an integer with the bit at the specified index cleared to 0. 4. **update_bit(num, i, bit)**: Return an integer with the bit at the specified index updated to the given `bit` value, which can be either 0 or 1. Input and Output Formats - **get_bit(num, i)**: - Inputs: `num` (an integer), `i` (a non-negative integer index). - Output: A bit value (0 or 1). - **set_bit(num, i)**: - Inputs: `num` (an integer), `i` (a non-negative integer index). - Output: An integer with the specified bit set to 1. - **clear_bit(num, i)**: - Inputs: `num` (an integer), `i` (a non-negative integer index). - Output: An integer with the specified bit cleared to 0. - **update_bit(num, i, bit)**: - Inputs: `num` (an integer), `i` (a non-negative integer index), `bit` (a bit value, 0 or 1). - Output: An integer with the specified bit updated to `bit`. Constraints and Limitations 1. Assume the integer `num` is a 32-bit signed integer. 2. Indices provided are within the range of 0 to 31. 3. Negative index values should be treated as invalid and should raise an error or handle appropriately. Performance Requirements The functions must operate in O(1) time complexity and O(1) space complexity. Here is the template for the functions: ```python def get_bit(num, i): # Implement the function to get the bit at the i-th index pass def set_bit(num, i): # Implement the function to set the bit at the i-th index pass def clear_bit(num, i): # Implement the function to clear the bit at the i-th index pass def update_bit(num, i, bit): # Implement the function to update the bit at the i-th index with the given bit value pass ```","solution":"def get_bit(num, i): Returns the bit value (0 or 1) at the specified index from the integer `num`. if i < 0 or i >= 32: raise ValueError(\\"Index out of range\\") return (num >> i) & 1 def set_bit(num, i): Returns an integer with the bit at the specified index set to 1. if i < 0 or i >= 32: raise ValueError(\\"Index out of range\\") return num | (1 << i) def clear_bit(num, i): Returns an integer with the bit at the specified index cleared to 0. if i < 0 or i >= 32: raise ValueError(\\"Index out of range\\") return num & ~(1 << i) def update_bit(num, i, bit): Returns an integer with the bit at the specified index updated to the given `bit` value (0 or 1). if i < 0 or i >= 32: raise ValueError(\\"Index out of range\\") if bit not in [0, 1]: raise ValueError(\\"Bit value must be 0 or 1\\") num = clear_bit(num, i) return num | (bit << i)"},{"question":"Problem Context An alien species has developed a new method of cataloging items in a grid-like pattern, and they need help to retrieve data in specific patterns. One such pattern is the \\"spiral order\\". Your task is to help them extract the elements of a matrix in spiral order. Objective Write a function `spiral_traversal` that takes a 2D list (matrix) as input and returns a list of its elements in spiral order. Function Signature ```python def spiral_traversal(matrix: List[List[int]]) -> List[int]: ``` Input Constraints - The matrix contains integers. - The matrix dimensions are m x n, where 0 ≤ m, n ≤ 100. Output Format - Return a list of integers representing the matrix elements in spiral order. Details - **Empty Matrix**: If the matrix is empty, the function should return an empty list. - **Single Row or Column**: The function should handle correctly matrices with only one row or one column. - **Boundary Conditions**: Update boundaries properly in each step to avoid index errors. Example ```python # Example 1: matrix = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] # The function should return [1, 2, 3, 6, 9, 8, 7, 4, 5] # Example 2: matrix = [ [1, 2, 3, 4] ] # The function should return [1, 2, 3, 4] # Example 3: matrix = [] # The function should return [] ``` Write a function to solve the problem efficiently while adhering to the specified constraints.","solution":"def spiral_traversal(matrix): if not matrix: return [] result = [] while matrix: result += matrix.pop(0) # move right if matrix and matrix[0]: for row in matrix: result.append(row.pop()) # move down if matrix: result += matrix.pop()[::-1] # move left if matrix and matrix[0]: for row in matrix[::-1]: result.append(row.pop(0)) # move up return result"},{"question":"# Matrix Multiplication Assessment Matrix Multiplication is a fundamental operation in various scientific computations, graphics, and data analysis. You are tasked with implementing a function to multiply two matrices and return the resultant matrix. Your function should handle edge cases and provide meaningful error messages when the matrices are not compatible for multiplication. **Function Specification** ```python def multiply_matrices(m1: list[list[int]], m2: list[list[int]]) -> list[list[int]]: Multiply two matrices m1 and m2. :param m1: First matrix (2D list of integers) :param m2: Second matrix (2D list of integers) :return: Resultant matrix product of m1 and m2 (2D list of integers) Raises ValueError if the matrices cannot be multiplied due to incompatible dimensions. ``` **Input** - `m1`: A list of lists of integers representing the first matrix. - 1 <= len(m1) <= 100 (number of rows) - 1 <= len(m1[0]) <= 100 (number of columns) - `m2`: A list of lists of integers representing the second matrix. - 1 <= len(m2) <= 100 (number of rows) - 1 <= len(m2[0]) <= 100 (number of columns) **Output** - A list of lists of integers representing the matrix product of `m1` and `m2`. **Constraints** - The number of columns in `m1` must equal the number of rows in `m2`. - Each element in the matrices will be an integer in the range -1000 to 1000. **Example** ```python m1 = [ [1, 2, 3], [4, 5, 6] ] m2 = [ [7, 8], [9, 10], [11, 12] ] Expected output: [ [58, 64], [139, 154] ] ``` **Notes** - Ensure your function is efficient and handles edge cases, such as incompatible matrices, by raising a `ValueError`. - You may assume that the input matrices contain only integers.","solution":"def multiply_matrices(m1: list[list[int]], m2: list[list[int]]) -> list[list[int]]: Multiply two matrices m1 and m2. :param m1: First matrix (2D list of integers) :param m2: Second matrix (2D list of integers) :return: Resultant matrix product of m1 and m2 (2D list of integers) Raises ValueError if the matrices cannot be multiplied due to incompatible dimensions. if len(m1[0]) != len(m2): raise ValueError(\\"Incompatible matrices cannot be multiplied.\\") result = [[0 for _ in range(len(m2[0]))] for _ in range(len(m1))] for i in range(len(m1)): for j in range(len(m2[0])): for k in range(len(m2)): result[i][j] += m1[i][k] * m2[k][j] return result"},{"question":"# Graph Cloning with Path Validation You are given an undirected graph representation using a class `UndirectedGraphNode` and a function `clone_graph` that can clone graphs. Your task is to enhance this cloning function with an additional feature: validate if a particular path exists in both the original and cloned graphs. Function Signature ```python def clone_and_validate_path(node: Optional[UndirectedGraphNode], path: List[int]) -> Tuple[Optional[UndirectedGraphNode], bool]: pass ``` Input - `node`: An instance of `UndirectedGraphNode` representing the starting node of the graph (can be None). - `path`: A list of integers representing a sequence of labels that should form a path in the graph. Output - Returns a tuple: - A new instance of the graph starting from the cloned node. - A boolean indicating whether the path exists in both the original and cloned graphs. Example Consider the example graph provided in the task description: ```plaintext 1 / / 0 --- 2 / _/ ``` If the path given is `[0, 2, 2]`, both the original and cloned graphs have this path. ```python node0 = UndirectedGraphNode(0) node1 = UndirectedGraphNode(1) node2 = UndirectedGraphNode(2) node0.add_neighbor(node1) node0.add_neighbor(node2) node1.add_neighbor(node2) node2.add_neighbor(node2) clone, is_valid = clone_and_validate_path(node0, [0, 2, 2]) ``` Constraints - Assume node labels are unique positive integers. - Path may contain labels that may not exist in the graph, in which case path existence should return `False`. Performance Requirements - Expected to work efficiently with graphs containing up to 10^4 nodes. Implementation Notes 1. Use the provided BFS/DFS structure for cloning. 2. Implement a helper function to validate path existence in a graph. 3. Ensure to handle edge cases properly. Helpful Methods - `def find_path(node: UndirectedGraphNode, path: List[int]) -> bool`: - Validates if a given path exists in the graph starting from the given node.","solution":"from typing import List, Optional, Tuple class UndirectedGraphNode: def __init__(self, label: int): self.label = label self.neighbors = [] def add_neighbor(self, node: \'UndirectedGraphNode\'): self.neighbors.append(node) def clone_graph(node: Optional[UndirectedGraphNode]) -> Optional[UndirectedGraphNode]: if not node: return None node_map = {} def clone(node: UndirectedGraphNode) -> UndirectedGraphNode: if node.label in node_map: return node_map[node.label] clone_node = UndirectedGraphNode(node.label) node_map[node.label] = clone_node for neighbor in node.neighbors: clone_node.neighbors.append(clone(neighbor)) return clone_node return clone(node) def find_path(node: Optional[UndirectedGraphNode], path: List[int]) -> bool: if not node: return False index = 0 stack = [(node, index)] while stack: current, index = stack.pop() if current.label == path[index]: if index + 1 == len(path): return True for neighbor in current.neighbors: stack.append((neighbor, index + 1)) return False def clone_and_validate_path(node: Optional[UndirectedGraphNode], path: List[int]) -> Tuple[Optional[UndirectedGraphNode], bool]: cloned_node = clone_graph(node) original_path_valid = find_path(node, path) cloned_path_valid = find_path(cloned_node, path) return cloned_node, original_path_valid and cloned_path_valid"},{"question":"# Longest Increasing Subsequence with Minimum Number of Segments Given an unsorted array of integers, your task is to determine the length of the longest increasing subsequence (LIS) and return the minimum number of segments required to form this subsequence using consecutive elements from the original array. You should implement an efficient algorithm that optimizes both time and space complexity. Input: - A list of integers `sequence` with `1 <= len(sequence) <= 10^5` and `1 <= element <= 10^5`. Output: - An integer representing the minimum number of segments needed to form the longest increasing subsequence. Performance Requirements: - The time complexity of your solution should be O(n log n). - The space complexity should be O(n). Example: ```python Input: [10, 9, 2, 5, 3, 7, 101, 18] Output: 4 Explanation: The longest increasing subsequence is [2, 3, 7, 101], which is formed using 4 segments of 1 element each from the input list. ``` Constraints: - The sequence can have up to `10^5` elements. - Elements in the sequence are positive integers up to `10^5`. Your implementation should ensure optimal performance even for large input sizes.","solution":"import bisect def lis_min_segments(sequence): Determine the minimum number of segments needed to form the LIS using consecutive elements from the original array. Args: sequence: List[int] - The input list of integers Returns: int - Minimum number of segments needed to form the LIS if not sequence: return 0 # To store positions of the end elements of the increasing subsequences tails = [] for num in sequence: pos = bisect.bisect_left(tails, num) if pos == len(tails): tails.append(num) else: tails[pos] = num return len(tails)"},{"question":"# Markov Chain Simulation You have been provided with a Markov Chain implementation, allowing for random state transitions based on predefined probabilities. Your task is to extend this functionality by implementing the following features: 1. **Final State Determination**: Implement a function `find_final_state(chain, start_state, k)` that simulates `k` transitions from the initial state and returns the final state reached after `k` steps. ```python def find_final_state(chain, start_state, k): Simulate k transitions in the Markov chain starting from start_state. Parameters: chain (dict): The Markov chain with state transitions. start_state (str): The initial state of the chain. k (int): The number of transitions to simulate. Returns: str: The state of the chain after k transitions. pass ``` 2. **Path Tracing**: Write a function `trace_path(chain, start_state, k)` that returns the sequence of states visited starting from the initial state over `k` transitions. ```python def trace_path(chain, start_state, k): Trace the sequence of states in the Markov chain from start_state over k transitions. Parameters: chain (dict): The Markov chain with state transitions. start_state (str): The initial state of the chain. k (int): The number of transitions to simulate. Returns: list: The sequence of states visited, including the initial state. pass ``` # Input & Output - **Input**: - `chain` is a dictionary where keys are states and values are dictionaries of possible transitions with their respective probabilities. - `start_state` is a string representing the initial state. - `k` is a non-negative integer specifying the number of transitions. - **Output**: - For `find_final_state`, return a string representing the state after `k` transitions. - For `trace_path`, return a list of strings representing the sequence of states visited. # Constraints - Transition probabilities for each state must sum up to 1. - There may be at least one state with outgoing transitions. # Performance Requirements - Efficiently handle Markov chains with up to 100 states and 1000 transitions. # Example ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3}, \'C\': {\'A\': 0.5, \'C\': 0.5} } start_state = \'A\' k = 3 # Example call to find_final_state print(find_final_state(chain, start_state, k)) # Possible output could be \'A\' or \'E\' # Example call to trace_path print(trace_path(chain, start_state, k)) # Possible output could be [\'A\', \'E\', \'A\', \'E\'] ``` **Note**: Ensure your functions handle the edge case where the start state has no outgoing transitions gracefully, perhaps by terminating the simulation early.","solution":"import random def find_final_state(chain, start_state, k): Simulate k transitions in the Markov chain starting from the start_state. Parameters: chain (dict): The Markov chain with state transitions. start_state (str): The initial state of the chain. k (int): The number of transitions to simulate. Returns: str: The state of the chain after k transitions. current_state = start_state for _ in range(k): if current_state not in chain or not chain[current_state]: break next_state = random.choices(list(chain[current_state].keys()), list(chain[current_state].values()))[0] current_state = next_state return current_state def trace_path(chain, start_state, k): Trace the sequence of states in the Markov chain from start_state over k transitions. Parameters: chain (dict): The Markov chain with state transitions. start_state (str): The initial state of the chain. k (int): The number of transitions to simulate. Returns: list: The sequence of states visited, including the initial state. path = [start_state] current_state = start_state for _ in range(k): if current_state not in chain or not chain[current_state]: break next_state = random.choices(list(chain[current_state].keys()), list(chain[current_state].values()))[0] current_state = next_state path.append(current_state) return path"},{"question":"**Context**: You are tasked with building a fast and efficient search tool to find specific patterns within large bodies of text. To accomplish this, you will implement the Rabin-Karp Algorithm, a powerful and well-suited algorithm for this kind of task due to its use of hash functions for fast pattern matching. **Problem**: Write a function `find_substring_indices(text: str, word: str) -> List[int]` that takes a `text` string and a `word` string as inputs and returns a list of starting indices of each occurrence of `word` in `text`. If the `word` does not occur in `text`, return an empty list. # Input Format - `text` - A string of length `n` (1 ≤ n ≤ 10^6). - `word` - A string of length `m` (1 ≤ m ≤ 10^6). # Output Format - A list of integers representing the starting indices of each occurrence of `word` in `text`. # Constraints - The function should handle large inputs efficiently. - Avoid unnecessary use of memory. # Example ```python def find_substring_indices(text: str, word: str) -> List[int]: # Implement the function here pass # Examples: assert find_substring_indices(\\"abracadabra\\", \\"abra\\") == [0, 7] assert find_substring_indices(\\"testtexttest\\", \\"test\\") == [0, 8] assert find_substring_indices(\\"abcdefgh\\", \\"xyz\\") == [] ``` # Explanation - In the first example, \\"abra\\" occurs at indices 0 and 7 in the text \\"abracadabra\\". - In the second example, \\"test\\" occurs at indices 0 and 8 in the text \\"testtexttest\\". - In the third example, since \\"xyz\\" does not occur in \\"abcdefgh\\", the result is an empty list. # Testing Your Solution Make sure to test your solution thoroughly, considering edge cases such as very large texts and patterns, non-overlapping patterns, overlapping patterns, and empty patterns.","solution":"from typing import List def find_substring_indices(text: str, word: str) -> List[int]: if not text or not word: return [] n, m = len(text), len(word) if m > n: return [] base = 256 # Larger base to avoid collisions mod = 101 # Prime number for modulus operation word_hash = 0 text_hash = 0 h = 1 # The value of base^(m-1) for i in range(m-1): h = (h * base) % mod for i in range(m): word_hash = (base * word_hash + ord(word[i])) % mod text_hash = (base * text_hash + ord(text[i])) % mod result = [] for i in range(n - m + 1): if word_hash == text_hash: if text[i:i+m] == word: result.append(i) if i < n - m: text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % mod if text_hash < 0: text_hash += mod return result"},{"question":"# Scenario You have been hired to optimize an ancient sorting algorithm used for sorting small datasets in a legacy system. Your task is to implement a modified version of Exchange Sort, which can detect if the list is already sorted and thus avoid unnecessary passes through the array. # Task Implement a function `optimized_exchange_sort` that sorts an array of integers in ascending order using the optimized exchange sort algorithm. # Function Signature ```python def optimized_exchange_sort(arr: list[int]) -> list[int]: ``` # Input * `arr`: A list of integers with length `n` (0 <= n <= 10^4). # Output * Returns a new list of integers sorted in ascending order. # Constraints * The algorithm should ensure the best-case time complexity is O(n) when the array is already sorted. * Modify the traditional exchange sort algorithm to improve performance on sorted arrays using an early termination mechanism. # Example ```python # Example 1 input: [3, 1, 2, 4] output: [1, 2, 3, 4] # Example 2 input: [5, 3, 8, 6, 2] output: [2, 3, 5, 6, 8] # Example 3 input: [1, 2, 3, 4, 5] output: [1, 2, 3, 4, 5] ``` # Implementation Notes * Consider adding a flag that helps check if a pass through the array makes any swaps. If no swaps are made, the array is already sorted, and the function can terminate early.","solution":"def optimized_exchange_sort(arr: list[int]) -> list[int]: n = len(arr) new_arr = arr.copy() for i in range(n - 1): swapped = False for j in range(i + 1, n): if new_arr[i] > new_arr[j]: new_arr[i], new_arr[j] = new_arr[j], new_arr[i] swapped = True if not swapped: break return new_arr"},{"question":"# Sudoku Solver Implementation Scenario You have been hired by a puzzle company to develop an efficient Sudoku puzzle solver. The company uses a 9x9 grid, where each cell\'s value can range from 1 to 9, and empty cells are denoted by a dot (\'.\'). Your task is to finalize and implement a module that reads a partially filled Sudoku board and determines its complete solution if it exists. Task Write a Python class `SudokuSolver` with the following methods: 1. **`__init__(self, board: List[List[str]])`**: Initialize the solver with the given board. 2. **`solve(self) -> bool`**: Solve the Sudoku puzzle and return `True` if a solution exists, otherwise `False`. 3. **`get_board(self) -> List[List[str]]`**: Return the board after attempting to solve it. Method Details - **`__init__(self, board: List[List[str]])`**: - `board` contains a 9x9 grid representing the Sudoku puzzle. - Store the board internally and initialize any necessary data structures to help with solving the puzzle. - **`solve(self) -> bool`**: - Attempt to solve the board using a backtracking technique. - Return `True` if a solution exists, otherwise `False`. - The board should be modified in-place to represent the solution if it exists. - **`get_board(self) -> List[List[str]]`**: - Return the current state of the board. Constraints - The input board array will have exactly 9 rows and each row will have exactly 9 columns. - Each element in the board will be a single character (either digits \'1\'-\'9\' or \'.\'). - It is guaranteed that the Sudoku board is valid up to the given configuration. Example Usage ```python initial_board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] solver = SudokuSolver(initial_board) solver.solve() solved_board = solver.get_board() for row in solved_board: print(\\" \\".join(row)) ``` Expected Output ```plaintext 5 3 4 6 7 8 9 1 2 6 7 2 1 9 5 3 4 8 1 9 8 3 4 2 5 6 7 8 5 9 7 6 1 4 2 3 4 2 6 8 5 3 7 9 1 7 1 3 9 2 4 8 5 6 9 6 1 5 3 7 2 8 4 2 8 7 4 1 9 6 3 5 3 4 5 2 8 6 1 7 9 ```","solution":"from typing import List class SudokuSolver: def __init__(self, board: List[List[str]]): self.board = board def solve(self) -> bool: return self._backtrack() def get_board(self) -> List[List[str]]: return self.board def _is_valid(self, row: int, col: int, num: str) -> bool: # Check the row for c in range(9): if self.board[row][c] == num: return False # Check the column for r in range(9): if self.board[r][col] == num: return False # Check the 3x3 sub-box start_row, start_col = 3 * (row // 3), 3 * (col // 3) for r in range(start_row, start_row + 3): for c in range(start_col, start_col + 3): if self.board[r][c] == num: return False return True def _backtrack(self) -> bool: for row in range(9): for col in range(9): if self.board[row][col] == \'.\': for num in \'123456789\': if self._is_valid(row, col, num): self.board[row][col] = num if self._backtrack(): return True self.board[row][col] = \'.\' return False return True"},{"question":"# Quick Sort Implementation with Edge Case Handling Scenario: You are developing a high-performance software system that frequently requires sorting datasets of various lengths and distributions. While Quick Sort is a strong candidate due to its average-case efficiency, you need to enhance it to reliably handle diverse edge cases and improve its practical robustness. Task: Implement a robust version of the Quick Sort algorithm that: 1. Enhances performance by choosing an optimal pivot and handles diverse edge cases. 2. Incorporates a check to switch to a simpler sorting algorithm, like insertion sort, for small sub-arrays to improve performance. Function Signature: ```python def enhanced_quick_sort(arr): Sorts an array using an optimized Quick Sort algorithm. Args: arr (list): List of integers to sort. Returns: list: Sorted list of integers. ``` Input: * `arr`: A list of integers (0 <= len(arr) <= 10^5) Output: * A sorted list of integers. Constraints: * Utilize a randomized pivot to avoid worst-case scenarios. * Switch to insertion sort for sub-arrays with sizes less than a specified threshold (e.g., 10). * Ensure your implementation handles: - Edge cases such as empty arrays and arrays with duplicate values. - Efficiently sorts large datasets. Example: ```python print(enhanced_quick_sort([3, 6, 8, 10, 1, 2, 1])) # Output: [1, 1, 2, 3, 6, 8, 10] print(enhanced_quick_sort([])) # Output: [] print(enhanced_quick_sort([3])) # Output: [3] ``` Additional Notes: - Explain your choice of the pivot and any cut-off points for switching to insertion sort within your implementation. - Ensure the solution adheres to in-place sorting requirements and maintains a low space complexity.","solution":"from random import randint def insertion_sort(arr, left, right): Use insertion sort for smaller sub-arrays for efficiency. for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def partition(arr, low, high): Hoare partition scheme with a randomized pivot. pivot_index = randint(low, high) pivot = arr[pivot_index] arr[pivot_index], arr[low] = arr[low], arr[pivot_index] i, j = low, high while True: while i <= j and arr[i] < pivot: i += 1 while i <= j and arr[j] > pivot: j -= 1 if i >= j: return j arr[i], arr[j] = arr[j], arr[i] i += 1 j -= 1 def _quick_sort(arr, low, high, threshold): Recursive quick sort function with a switch to insertion sort. if high - low + 1 <= threshold: insertion_sort(arr, low, high) return if low < high: pivot_index = partition(arr, low, high) _quick_sort(arr, low, pivot_index, threshold) _quick_sort(arr, pivot_index + 1, high, threshold) def enhanced_quick_sort(arr): Sorts an array using an optimized Quick Sort algorithm. if not arr: return [] _quick_sort(arr, 0, len(arr) - 1, 10) return arr"},{"question":"You are given a singly linked list. Your task is to determine if the linked list contains a cycle. A linked list is said to have a cycle if there is some node in the list that can be reached again by continuously following the \'next\' pointer. **Function Signature**: ```python def detect_cycle(head: Node) -> bool: Determine if the linked list represented by \'head\' has a cycle. :param head: The head node of the singly linked list. :type head: Node :return: True if there is a cycle in the linked list; otherwise, False. :rtype: bool ``` **Input**: - A linked list node `head` which is the starting point of the linked list. **Output**: - Return `True` if the linked list contains a cycle. - Return `False` if the linked list does not contain a cycle. **Constraints**: - You cannot use any extra space (no additional data structures). - Each node in the linked list has an integer value and a \'next\' pointer to the next node. **Examples**: 1. **Example 1**: - Input: A -> B -> C -> D -> B (cycle) - Output: True 2. **Example 2**: - Input: X -> Y -> Z (no cycle) - Output: False 3. **Example 3**: - Input: 1 -> 2 -> 3 -> 4 -> 5 -> 3 (cycle) - Output: True 4. **Example 4**: - Input: None (empty list) - Output: False **Hints**: - Consider implementing Floyd’s Tortoise and Hare algorithm for efficient cycle detection. - Remember to handle edge cases like an empty list or a single-node list.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle(head: Node) -> bool: if not head or not head.next: return False slow = head fast = head.next while fast and fast.next: if slow == fast: return True slow = slow.next fast = fast.next.next return False"},{"question":"Integer and Byte Array Conversion with Endianness **Context**: You are working on a low-level data communication module where handling byte order is crucial. The module must deal with both big-endian and little-endian byte orders, converting between integers and byte arrays as needed. **Problem Statement**: Implement a class `EndianConverter` that offers methods to handle these conversions. Your class should support the following methods: 1. `int_to_big_endian(num: int) -> bytes` 2. `int_to_little_endian(num: int) -> bytes` 3. `big_endian_to_int(bytestr: bytes) -> int` 4. `little_endian_to_int(bytestr: bytes) -> int` **Input and Output Formats**: 1. `int_to_big_endian(num: int) -> bytes`: Converts an integer to a big-endian byte array. 2. `int_to_little_endian(num: int) -> bytes`: Converts an integer to a little-endian byte array. 3. `big_endian_to_int(bytestr: bytes) -> int`: Converts a big-endian byte array back to an integer. 4. `little_endian_to_int(bytestr: bytes) -> int`: Converts a little-endian byte array back to an integer. **Constraints**: - The integer `num` will be non-negative and within the range of a typical 64-bit signed integer. - The byte array `bytestr` will be non-empty and represent a valid big-endian or little-endian integer. **Performance Requirements**: - Your methods should handle conversion efficiently, ensuring that operations complete within O(log n) time complexity where n is the integer value. - Use appropriate data structures to optimize memory usage. **Example**: ```python converter = EndianConverter() # Convert integer 1024 to big-endian bytes big_endian_bytes = converter.int_to_big_endian(1024) # big_endian_bytes should be b\'x04x00\' # Convert the same integer 1024 to little-endian bytes little_endian_bytes = converter.int_to_little_endian(1024) # little_endian_bytes should be b\'x00x04\' # Convert back from big-endian bytes to integer integer_from_big_endian = converter.big_endian_to_int(b\'x04x00\') # integer_from_big_endian should be 1024 # Convert back from little-endian bytes to integer integer_from_little_endian = converter.little_endian_to_int(b\'x00x04\') # integer_from_little_endian should be 1024 ```","solution":"class EndianConverter: @staticmethod def int_to_big_endian(num: int) -> bytes: Converts an integer to a big-endian byte array. length = (num.bit_length() + 7) // 8 # calculate necessary number of bytes return num.to_bytes(length, byteorder=\'big\') @staticmethod def int_to_little_endian(num: int) -> bytes: Converts an integer to a little-endian byte array. length = (num.bit_length() + 7) // 8 # calculate necessary number of bytes return num.to_bytes(length, byteorder=\'little\') @staticmethod def big_endian_to_int(bytestr: bytes) -> int: Converts a big-endian byte array back to an integer. return int.from_bytes(bytestr, byteorder=\'big\') @staticmethod def little_endian_to_int(bytestr: bytes) -> int: Converts a little-endian byte array back to an integer. return int.from_bytes(bytestr, byteorder=\'little\')"},{"question":"# Segment Tree Range Update and Query You have been given an array of integers and you need to implement a segment tree that can handle the following operations efficiently: 1. **Range Sum Query**: Return the sum of elements within a specified range. 2. **Range Update**: Add a specified value to all elements within a specified range. Implement the `SegmentTree` class that provides the following methods: 1. **`__init__(self, arr)`:** Initializes the segment tree with the provided array, and prepares it for handling queries. 2. **`update(self, L, R, value)`:** Adds `value` to every element between indices `L` and `R` (inclusive). 3. **`query(self, L, R)`:** Returns the sum of the elements between indices `L` and `R` (inclusive). # Input/Output - `__init__(self, arr)`: * **Input**: `arr` - List[int]. Array of integers to build the segment tree. - `update(self, L, R, value)`: * **Input**: * `L` - int. Left boundary of the range. * `R` - int. Right boundary of the range. * `value` - int. Value to add to each element in the range `[L, R]`. * **Output**: None - `query(self, L, R)`: * **Input**: * `L` - int. Left boundary of the range. * `R` - int. Right boundary of the range. * **Output**: int. Sum of the elements in the range `[L, R]`. # Example ```python # Construct segment tree arr = [2, 4, 5, 3, 4] tree = SegmentTree(arr) # Range sum query print(tree.query(1, 3)) # Output: 12 (4+5+3) # Range update tree.update(2, 4, 2) # Adds 2 to elements at indices 2, 3, and 4 # Query again after update print(tree.query(1, 3)) # Output: 14 (4+7+3) ``` # Constraints - The array size will be at least 1 and at most 10^5. - Update and query operations will not exceed 10^5. # Notes - You need to handle both building the segment tree and operations efficiently. - Consider edge cases such as empty sub-ranges, and single-element ranges.","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.arr = arr self.tree = [0] * (4 * self.n) self.lazy = [0] * (4 * self.n) self._build(0, 0, self.n - 1) def _build(self, node, start, end): if start == end: self.tree[node] = self.arr[start] else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self._build(left_child, start, mid) self._build(right_child, mid + 1, end) self.tree[node] = self.tree[left_child] + self.tree[right_child] def _update_range(self, node, start, end, L, R, value): if self.lazy[node] != 0: self.tree[node] += (end - start + 1) * self.lazy[node] if start != end: left_child = 2 * node + 1 right_child = 2 * node + 2 self.lazy[left_child] += self.lazy[node] self.lazy[right_child] += self.lazy[node] self.lazy[node] = 0 if start > end or start > R or end < L: return if start >= L and end <= R: self.tree[node] += (end - start + 1) * value if start != end: left_child = 2 * node + 1 right_child = 2 * node + 2 self.lazy[left_child] += value self.lazy[right_child] += value return mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self._update_range(left_child, start, mid, L, R, value) self._update_range(right_child, mid + 1, end, L, R, value) self.tree[node] = self.tree[left_child] + self.tree[right_child] def _query_range(self, node, start, end, L, R): if self.lazy[node] != 0: self.tree[node] += (end - start + 1) * self.lazy[node] if start != end: left_child = 2 * node + 1 right_child = 2 * node + 2 self.lazy[left_child] += self.lazy[node] self.lazy[right_child] += self.lazy[node] self.lazy[node] = 0 if start > end or start > R or end < L: return 0 if start >= L and end <= R: return self.tree[node] mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 left_sum = self._query_range(left_child, start, mid, L, R) right_sum = self._query_range(right_child, mid + 1, end, L, R) return left_sum + right_sum def update(self, L, R, value): self._update_range(0, 0, self.n - 1, L, R, value) def query(self, L, R): return self._query_range(0, 0, self.n - 1, L, R)"},{"question":"**Context**: You are tasked with creating a novel data structure called `RandomizedMap`, which extends the capability of a traditional dictionary. The `RandomizedMap` should support the following operations efficiently: - `insert(key, value)`: Inserts a key-value pair into the map if the key is not already present. - `remove(key)`: Removes a key and its associated value if present. - `get_random_key()`: Returns a random key from the current set of keys in the map. The operations `insert`, `remove`, and `get_random_key` should all run in average O(1) time. **Instructions**: 1. Implement the class `RandomizedMap` with the following methods: ```python class RandomizedMap: def __init__(self): # Initialize your data structures here def insert(self, key: int, value: int) -> bool: # Inserts a key-value pair. Returns True if inserted, False if key already exists. def remove(self, key: int) -> bool: # Removes a key-value pair. Returns True if removed, False if key does not exist. def get_random_key(self) -> int: # Returns a random key from the map. Keys should have the same probability of being returned. ``` 2. Ensure the average time complexity for `insert`, `remove`, and `get_random_key` is O(1). 3. Consider edge cases: - Insert a key that already exists. - Remove a key that does not exist. - Get a random key when no elements exist in the map (handle gracefully by returning `None` or raise an appropriate exception). # Constraints - The `insert` method should only accept integer keys and values. - The `remove` and `get_random_key` methods should operate based on the key. # Example Usage ```python # Example usage: rm = RandomizedMap() assert rm.insert(1, 10) == True assert rm.insert(2, 20) == True assert rm.insert(1, 30) == False assert rm.remove(1) == True assert rm.remove(1) == False assert rm.get_random_key() in [2] ``` Implement the `RandomizedMap` class with an emphasis on achieving the specified average time complexities for the operations.","solution":"import random class RandomizedMap: def __init__(self): self.map = {} self.keys = [] def insert(self, key: int, value: int) -> bool: if key in self.map: return False self.map[key] = value self.keys.append(key) return True def remove(self, key: int) -> bool: if key not in self.map: return False self.keys.remove(key) del self.map[key] return True def get_random_key(self) -> int: if not self.keys: return None return random.choice(self.keys)"},{"question":"You are given an array of `n` integers sorted in non-descending order and a target integer `key`. Your task is to implement the ternary search algorithm as an iterative function. The function should return the index of the `key` if it is present in the array; otherwise, it should return -1. Function Signature ```python def iterative_ternary_search(arr: List[int], key: int) -> int: pass ``` # Input * `arr`: A list of integers sorted in non-descending order. The number of elements `n` satisfies `1 <= n <= 10^5`. * `key`: An integer which you need to search in the array. Value of `key` satisfies `-10^9 <= key <= 10^9`. # Output * The function should return the index of the `key` if it is present in `arr`; otherwise, return -1. # Example ```python assert iterative_ternary_search([1, 2, 3, 4, 5], 3) == 2 assert iterative_ternary_search([10, 20, 30, 40, 50], 40) == 3 assert iterative_ternary_search([1, 3, 5, 7, 9], 2) == -1 ``` # Constraints * The input array will be sorted in non-descending order. * Try to achieve the best possible time complexity within O(nlog3(n)). # Performance Requirements * Ensure that the solution runs efficiently for the upper limits of the constraints.","solution":"from typing import List def iterative_ternary_search(arr: List[int], key: int) -> int: left, right = 0, len(arr) - 1 while left <= right: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"Suppose you are given a string `word`, your task is to implement a function `generate_abbreviations(word)` that returns a list containing all possible unique abbreviations of the given word. Each abbreviation must represent removing consecutive characters and replacing them with their count. Function Signature ```python def generate_abbreviations(word: str) -> List[str]: pass ``` Input * `word`: A string consisting of lowercase English letters (1 ≤ len(word) ≤ 15). Output * A list of strings, containing all possible abbreviations of the input `word`. Constraints * The function must generate all unique abbreviations of the input string. * Ensure the algorithm handles edge cases efficiently. * Performance of the solution should be adequately managed, given the input constraints. Example ```python # Example 1 input: \\"word\\" output: [\\"word\\", \\"wor1\\", \\"wo1d\\", \\"wo2\\", \\"w1rd\\", \\"w1r1\\", \\"w2d\\", \\"w3\\", \\"1ord\\", \\"1or1\\", \\"1o1d\\", \\"1o2\\", \\"2rd\\", \\"2r1\\", \\"3d\\", \\"4\\"] # Example 2 input: \\"a\\" output: [\\"a\\", \\"1\\"] ``` Explanation For the word \\"word\\": * The abbreviations include keeping each letter as is and replacing different combinations of consecutive letters with their counts. * For instance, \\"wor1\\" represents replacing the last letter \'d\' with \'1\'. * The solution must explore all possible combinations and capture them in the result list.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: def backtrack(pos, curr): if pos == len(word): abbreviations.append(curr) else: # Option 1: Keep the current character backtrack(pos + 1, curr + word[pos]) # Option 2: Abbreviate current or following characters if not curr or curr[-1].isalpha(): for i in range(1, len(word) - pos + 1): backtrack(pos + i, curr + str(i)) abbreviations = [] backtrack(0, \\"\\") return abbreviations"},{"question":"# Matrix Inversion Function You are required to write a function that inverts a given (n times n) matrix. The function should handle edge cases appropriately and return special values or error messages when encountering invalid matrices. Input - A 2D list of integers or floats representing an (n times n) matrix. Output - A 2D list of same dimensions representing the inverted matrix, or a 2D list `[[err_code]]` where `err_code` is: - (-1) if the input is not a matrix. - (-2) if the matrix is not square. - (-3) if the matrix is smaller than (2 times 2). - (-4) if the matrix is singular. Constraints - (2 leq n leq 10) Function Signature ```python def invert_matrix(matrix: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]: ``` # Example ```python matrix = [ [4, 7], [2, 6] ] print(invert_matrix(matrix)) # Output: [[0.6, -0.7], [-0.2, 0.4]] matrix = [ [1, 2, 3], [0, 1, 4], [5, 6, 0] ] print(invert_matrix(matrix)) # Output: [[-24, 18, 5], [20, -15, -4], [-5, 4, 1]] matrix = [ [1, 2], [3, 6] ] print(invert_matrix(matrix)) # Output: [[-4]] ``` Hints - You may use helper functions such as `get_determinant`, `get_matrix_of_minors`, and `transpose_and_multiply`. - Ensure you handle the checkerboard pattern for cofactors correctly.","solution":"from typing import List, Union import numpy as np def invert_matrix(matrix: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]: # Check if input is a list of lists if not all(isinstance(row, list) for row in matrix): return [[-1]] n = len(matrix) # Check if the matrix is square if not all(len(row) == n for row in matrix): return [[-2]] # Check if the matrix is at least 2x2 if n < 2: return [[-3]] try: # Try to compute the inverse using numpy for handling numerical issues and convenience inverse_matrix = np.linalg.inv(matrix) return inverse_matrix.tolist() except np.linalg.LinAlgError: # This handles the singular matrix case return [[-4]]"},{"question":"# String Manipulation Challenge Context You are given a string and need to perform specific modifications on it. This string consists of letters, digits, and special characters. You are required to reverse the vowels in the string while keeping other characters in their original positions. Problem Statement Write a function `reverse_vowel(s: str) -> str` that accepts a string `s` and returns the string with its vowels reversed. Input - A single string `s` where the length of `s` can be in the range of 1 to 10^5. - The string contains only printable ASCII characters. Output - A single string with the vowels reversed. Constraints - Only the vowels \'a\', \'e\', \'i\', \'o\', \'u\' (both lowercase and uppercase) should be reversed. - Non-vowel characters should remain in their original positions. - The input string may be empty or contain no vowels. - Perform the operation in O(n) time where n is the length of the string. Examples 1. `reverse_vowel(\\"hello\\")` should return `\\"holle\\"`. 2. `reverse_vowel(\\"leetcode\\")` should return `\\"leotcede\\"`. 3. `reverse_vowel(\\"aA\\")` should return `\\"Aa\\"`. Constraints & Assumptions - You can assume the input string is always valid and contains only printable ASCII characters. - There\'s no need to handle international or non-ASCII characters. Edge Cases - An empty string should return an empty string. - A string with no vowels should be returned as-is. - For a single character string, return the same character.","solution":"def reverse_vowel(s: str) -> str: This function takes a string s and returns a new string with the vowels reversed, while keeping other characters in their original positions. vowels = set(\'aeiouAEIOU\') s = list(s) left, right = 0, len(s) - 1 while left < right: if s[left] in vowels and s[right] in vowels: # swap the vowels s[left], s[right] = s[right], s[left] left += 1 right -= 1 if s[left] not in vowels: left += 1 if s[right] not in vowels: right -= 1 return \'\'.join(s)"},{"question":"You have been assigned a task to build a secure messaging application using public-key cryptography. A critical part of this implementation requires computing the modular inverse of large numbers efficiently. Write a function `modular_inverse(a: int, m: int) -> int` which computes the modular inverse of `a` under modulo `m` using the Extended Euclidean Algorithm. Given two integers `a` and `m`, return the integer ( x ) such that: [ a * x equiv 1 mod m ] If no such integer exists, raise a `ValueError`. # Input - An integer `a` where (1 leq a leq 10^9). - An integer `m` where (1 leq m leq 10^9). # Output - An integer representing the modular inverse of (a) under modulo (m). # Constraints - (a) and (m) are coprime. # Example ```python modular_inverse(3, 11) ``` Output: ``` 4 ``` Explanation: (3 * 4 equiv 1 mod 11) # Notes - Ensure your solution handles the maximum value scenarios effectively. - Do not use Python\'s built-in functions directly providing the modular inverse. # Edge Cases - Handle cases where (a) is 1 or (m) is 1 appropriately. # Performance Requirements Your implementation should execute in (O(log m)) time complexity.","solution":"def modular_inverse(a: int, m: int) -> int: Computes the modular inverse of a under modulo m using the Extended Euclidean Algorithm. def extended_gcd(a, b): old_r, r = a, b old_s, s = 1, 0 old_t, t = 0, 1 while r != 0: quotient = old_r // r old_r, r = r, old_r - quotient * r old_s, s = s, old_s - quotient * s old_t, t = t, old_t - quotient * t return old_r, old_s, old_t g, x, y = extended_gcd(a, m) if g != 1: raise ValueError(f\\"No modular inverse exists for a = {a} and m = {m}\\") return x % m"},{"question":"# Integer Partitioning Problem Context In this task, you are required to create a function that calculates the number of ways to partition an integer `n` into sums of non-negative integers. This is valuable in various combinatorial mathematics problems. Function Definition Implement a function `integer_partition(n: int) -> int` that returns the number of ways to partition the given integer `n`. Input - `n`: An integer `n` (1 ≤ n ≤ 100). Output - An integer representing the number of unique integer partitions of `n`. Constraints - Focus on efficient computation with a time complexity around `O(n^2)`. - Consider space utilization and try to optimize if possible. Example ```plaintext Input: 4 Output: 5 Explanation: 4 can be partitioned in the following ways: 4 3 + 1 2 + 2 2 + 1 + 1 1 + 1 + 1 + 1 ``` # Guidelines: - Use dynamic programming to structure your solution. - Ensure edge cases are handled, such as the smallest values of `n`. - Optimize for performance and memory usage where feasible.","solution":"def integer_partition(n: int) -> int: Returns the number of ways to partition integer n. dp = [1] + [0] * n for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"# Scenario You are working on a project where you need a data structure that maintains order among elements. Specifically, you need a stack where every element you **push** is placed in such a way that the stack remains ordered. This means the highest value should always be at the top and the lowest at the bottom. # Task Implement a class `OrderedStack` with the following methods: ```python class OrderedStack: def __init__(self): # Initializes an empty stack. def is_empty(self): # Returns True if the stack is empty, else False. def push(self, item): # Pushes an item onto the stack, maintaining the order. def pop(self): # Removes the top item from the stack and returns it. def peek(self): # Returns (without removing) the top item of the stack. def size(self): # Returns the size of the stack. ``` # Constraints - **Input types**: Integer values for items pushed onto the stack. - **Error Handling**: The `pop` method should raise an `IndexError` if attempted on an empty stack. - **Performance**: The `push` operation should be made as efficient as possible with respect to maintaining the order. # Input/Output Examples ```python stack = OrderedStack() stack.push(3) stack.push(1) stack.push(2) assert stack.pop() == 3 # Highest item is at the top assert stack.peek() == 2 # Next highest item remains assert stack.pop() == 2 assert stack.pop() == 1 assert stack.is_empty() == True assert stack.size() == 0 ``` # Notes - Your implementation must maintain the stacking order such that even intermediate values are correctly ordered. - Pay careful attention to the mechanics of how the `push` function operates to ensure optimal performance.","solution":"class OrderedStack: def __init__(self): self.stack = [] def is_empty(self): return len(self.stack) == 0 def push(self, item): temp_stack = [] while not self.is_empty() and self.stack[-1] > item: temp_stack.append(self.pop()) self.stack.append(item) while temp_stack: self.stack.append(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def size(self): return len(self.stack)"},{"question":"You are tasked with implementing a more advanced interval manipulation utility that builds on the simple representation and merging of intervals. # Problem Statement Given a list of interval objects, provide the following functionalities: 1. **Merge Overlapping Intervals**: * Implement a method to merge overlapping intervals using the given list of interval objects. * Input: List of Interval objects. * Output: List of merged Interval objects. 2. **Find Intervals Containing a Given Point**: * Implement a method that given a point, finds all intervals that contain this point. * Input: List of Interval objects and an integer point. * Output: List of Interval objects containing the point. 3. **Optimization Requirement**: * Minimize the time complexity, especially in merging and containment checking. Aim for an overall efficient performance utilizing advance structures or algorithms where possible. # Constraints * Assume that the intervals are well-defined where `start <= end`. * The input list of intervals must contain at least one interval. * Intervals can contain any integers within the typical machine limits. # Function Definitions Specifically, you need to implement the following: ```python class Interval: def __init__(self, start=0, end=0): self.start = start self.end = end def __repr__(self): return \\"Interval({}, {})\\".format(self.start, self.end) # Implement the merging functionality here def merge_intervals(intervals): Merge overlapping intervals from a list of Interval objects pass def find_intervals_containing_point(intervals, point): Find all intervals containing the given point pass ``` # Example Usage 1. **Merging Intervals**: ```python intervals = [Interval(1, 5), Interval(2, 6), Interval(8, 10), Interval(9, 12)] merged_intervals = merge_intervals(intervals) print(merged_intervals) # Output: [Interval(1, 6), Interval(8, 12)] ``` 2. **Finding Intervals Containing a Point**: ```python intervals = [Interval(1, 5), Interval(2, 6), Interval(8, 10), Interval(9, 12)] point = 4 containing_intervals = find_intervals_containing_point(intervals, point) print(containing_intervals) # Output: [Interval(1, 5), Interval(2, 6)] ``` Make sure your implementation is efficient and robust to handle various edge cases.","solution":"class Interval: def __init__(self, start=0, end=0): self.start = start self.end = end def __repr__(self): return \\"Interval({}, {})\\".format(self.start, self.end) def __eq__(self, other): return self.start == other.start and self.end == other.end def merge_intervals(intervals): Merge overlapping intervals from a list of Interval objects. if not intervals: return [] # First, sort the intervals by their starting point intervals.sort(key=lambda x: x.start) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] if current.start <= last_merged.end: # There is overlap, so merge the current interval with the last merged interval last_merged.end = max(last_merged.end, current.end) else: # No overlap, so add the current interval to the list merged_intervals.append(current) return merged_intervals def find_intervals_containing_point(intervals, point): Find all intervals containing the given point. containing_intervals = [] for interval in intervals: if interval.start <= point <= interval.end: containing_intervals.append(interval) return containing_intervals"},{"question":"**Problem Statement**: You are given a positive integer. Find the next higher number that uses the exact same set of digits as the original number. If no such number exists, return -1. # Input Format * An integer `num` where 0 ≤ num ≤ 10^18. # Output Format * An integer which is the next higher number made from the same digits. Return -1 if no such number exists. # Constraints 1. The input number will always be a valid positive integer. 2. The function should handle edge cases where no higher permutation exists. 3. The function should decide in a reasonable time (within seconds) for any valid input. # Examples ```python * Example 1: Input: 38276 Output: 38627 * Example 2: Input: 99999 Output: -1 * Example 3: Input: 54321 Output: -1 * Example 4: Input: 1528452 Output: 1528524 ``` # Function Signature ```python def next_bigger(num: int) -> int: pass ``` # Scenario Imagine you are exploring different permutations of a combination lock code to determine the next valid code in ascending order. Using the above method, you can determine the next code to try without cycling through all permutations.","solution":"def next_bigger(num: int) -> int: Find the next higher number that uses the exact same set of digits as the original number. If no such number exists, return -1. # Convert the number to a list of its digits digits = list(str(num)) length = len(digits) # Traverse the digits from right to left to find the first digit # that is smaller than the digit next to it for i in range(length - 2, -1, -1): if digits[i] < digits[i + 1]: break else: # If no such digit is found, then all digits are in descending order return -1 # Find the smallest digit on right side of (i) digit, which is greater than digits[i] for j in range(length - 1, i, -1): if digits[j] > digits[i]: break # Swap digits[i] with digits[j] digits[i], digits[j] = digits[j], digits[i] # Reverse the digits after index (i) inclusive digits = digits[:i+1] + digits[i+1:][::-1] # Convert list of digits back to a number next_bigger_number = int(\'\'.join(digits)) return next_bigger_number"},{"question":"Context In this exercise, you will implement a queue that ensures elements are dequeued in increasing order. The purpose is to test your understanding of fundamental data structures and algorithms and your ability to maintain order within a dynamic data structure. Problem Statement You are required to implement a class `OrderedQueue` that maintains an internal queue of integers. When an element is enqueued, it will be inserted into the correct position to keep the queue ordered. When an element is dequeued, it will remove the front-most (smallest) element. Your task is to implement the following methods: * `__init__(self)`: Initializes an empty queue. * `is_empty(self)`: Checks if the queue is empty. * `enqueue(self, item)`: Adds an item to the queue in the correct sorted position. * `dequeue(self)`: Removes and returns the smallest item from the queue. * `peek(self)`: Returns the smallest item without removing it from the queue. * `size(self)`: Returns the number of items in the queue. Constraints * Do not use built-in Python sorting methods (e.g., `sorted`, `list.sort()`, etc.). * The queue should maintain order upon each `enqueue` operation. * Ensure that all methods execute within reasonable time limits for moderate-sized inputs (up to 10,000 elements). Example ```python queue = OrderedQueue() queue.enqueue(3) queue.enqueue(1) queue.enqueue(2) assert queue.dequeue() == 1 assert queue.peek() == 2 assert queue.size() == 2 assert not queue.is_empty() queue.dequeue() queue.dequeue() assert queue.is_empty() ``` You are provided with partial implementation to get started: ```python class OrderedQueue: def __init__(self): self.items = [] def is_empty(self): return len(self.items) == 0 def enqueue(self, item): # Implement the logic to maintain order while enqueuing an item pass def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.items.pop(0) def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.items[0] def size(self): return len(self.items) ``` Complete the `enqueue` method to ensure that the queue maintains order after each insertion.","solution":"class OrderedQueue: def __init__(self): self.items = [] def is_empty(self): return len(self.items) == 0 def enqueue(self, item): if self.is_empty(): self.items.append(item) else: # Find the right position to insert the item to maintain order for i in range(len(self.items)): if self.items[i] > item: self.items.insert(i, item) break else: self.items.append(item) def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.items.pop(0) def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.items[0] def size(self): return len(self.items)"},{"question":"You are provided with the structure of a binary tree. Your task is to write a function `binary_tree_paths(root)` which accepts the root of the binary tree and returns a list of all root-to-leaf paths in the tree. Each path should be represented as a string, formatted as sequences of node values separated by `\\"->\\"`. # Input Format - A class `TreeNode` representing a node in the binary tree: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - The `binary_tree_paths` function takes one parameter: - `root`: The root node of the binary tree (an instance of `TreeNode`). # Output Format - The function should return a list of strings, where each string represents a root-to-leaf path in the tree. # Constraints - All integer node values are unique. - The number of nodes in the tree is in the range [0, 1000]. # Performance Requirement - Your solution should have a time complexity of O(N) and a space complexity of O(H), where N is the number of nodes and H is the height of the tree. # Example ```python # Example Input: # 1 # / # 2 3 # # 5 root = TreeNode(1) root.left = TreeNode(2) root.left.right = TreeNode(5) root.right = TreeNode(3) # Example Output: # [\\"1->2->5\\", \\"1->3\\"] print(binary_tree_paths(root)) ``` # Edge Case Example ```python # Example Input: # <empty tree> root = None # Example Output: # [] print(binary_tree_paths(root)) ``` ```python # Example Input: # 1 root = TreeNode(1) # Example Output: # [\\"1\\"] print(binary_tree_paths(root)) ``` You need to ensure that your function handles all specified edge cases and adheres to the performance requirements.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): if not root: return [] def dfs(node, path, paths): if not node.left and not node.right: paths.append(path) return if node.left: dfs(node.left, path + \\"->\\" + str(node.left.val), paths) if node.right: dfs(node.right, path + \\"->\\" + str(node.right.val), paths) paths = [] dfs(root, str(root.val), paths) return paths"},{"question":"# AVL Tree Insertion Implementation You are given a partial implementation of an AVL Tree class that includes methods for node insertion, rebalancing, and in-order traversal. Your task is to complete the implementation by writing additional functions to handle the following: 1. **Search Operation**: Implement a method that searches for a given key in the AVL Tree and returns `True` if found, `False` otherwise. ```python def search(self, key): Search for a key in AVL tree pass ``` 2. **Delete Operation**: Extend the AVL tree to support node deletion, ensuring the tree remains balanced after deletion. ```python def delete(self, key): Delete node with the given key and rebalance the tree pass ``` **Input and Output Formats**: 1. The `search` function: * **Input**: * A key to search (integer). * **Output**: * `True` if the key is found, otherwise `False`. 2. The `delete` function: * **Input**: * A key to delete (integer). * **Output**: * None. The function only modifies the tree structure. **Constraints**: 1. The tree initially can contain up to 10^5 nodes. 2. Keys in the tree are unique integers. 3. Perform the operations efficiently to maintain the logarithmic time complexity. **Performance Requirements**: 1. Ensure all operations (insert, delete, search) perform within O(log n) time complexity. **Scenario**: Consider a scenario where you need to manage a dynamically updating collection of integers efficiently. For instance, an event management system where events (represented by integer timestamps) are frequently added, accessed, and removed. **Edge Cases to Consider**: 1. Deleting a non-existent key. 2. Ensuring the tree remains balanced after consecutive insertions and deletions. 3. Handling a large number of operations efficiently. **Implementation**: Extend the provided `AvlTree` class with the `search` and `delete` methods. ```python class AvlTree(object): # ... existing code ... def search(self, key): Search for a key in AVL tree # Your implementation here def delete(self, key): Delete node with the given key and rebalance the tree # Your implementation here ``` Test your implementation with the provided AVL Tree structure to ensure it handles all edge cases and maintains efficiency.","solution":"class TreeNode: def __init__(self, key, left=None, right=None, height=1): self.key = key self.left = left self.right = right self.height = height class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._rebalance(node) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp_val = self._get_min_value_node(node.right) node.key = temp_val.key node.right = self._delete(node.right, temp_val.key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._rebalance(node) def _get_min_value_node(self, node): current = node while current.left: current = current.left return current def search(self, key): return self._search(self.root, key) def _search(self, node, key): if not node: return False if node.key == key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key) def in_order_traversal(self): return self._in_order_traversal(self.root) def _in_order_traversal(self, node): result = [] if node: result = self._in_order_traversal(node.left) result.append(node.key) result = result + self._in_order_traversal(node.right) return result def _get_height(self, node): if not node: return 0 return node.height def _rebalance(self, node): balance = self._get_balance(node) if balance > 1: if self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1: if self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y"},{"question":"# Question You are tasked with creating an optimized encoder and decoder based on the Run-Length Encoding (RLE) algorithm. Your goal is to implement the following two functions with the given requirements: 1. `encode_rle(input)`: This function receives a string and returns its run-length encoded version. 2. `decode_rle(input)`: This function receives a run-length encoded string and returns the original string. Detailed Requirements: 1. **Run-Length Encoding**: - For each sequence of repeated characters, replace it with the count of repetitions followed by the character. - For example, the string `\\"aaabbc\\"` should be encoded as `\\"3a2b1c\\"`. 2. **Run-Length Decoding**: - Convert the encoded string back to its original form. - For example, the encoded string `\\"3a2b1c\\"` should be decoded back to `\\"aaabbc\\"`. Input and Output Formats: 1. **encode_rle(input)** - **Input**: - `input`: A string consisting of uppercase and lowercase letters. The string length is between 0 and 1000. - **Output**: - A run-length encoded string. 2. **decode_rle(input)** - **Input**: - `input`: A run-length encoded string. The encoded string length is between 0 and 2000. - **Output**: - The original string before encoding. Constraints: - `input` strings will be valid and will not contain digits other than those used within the encoded format for `decode_rle`. - Both functions must handle edge cases such as empty strings and strings with no repeated characters. Example: ```python input_str = \\"aaabbc\\" encoded_str = encode_rle(input_str) print(encoded_str) # Output: \\"3a2b1c\\" decoded_str = decode_rle(encoded_str) print(decoded_str) # Output: \\"aaabbc\\" ``` Good luck and ensure your functions are efficient and handle all specified constraints.","solution":"def encode_rle(input): if not input: return \\"\\" encoded_string = \\"\\" count = 1 for i in range(1, len(input)): if input[i] == input[i-1]: count += 1 else: encoded_string += f\\"{count}{input[i-1]}\\" count = 1 encoded_string += f\\"{count}{input[-1]}\\" return encoded_string def decode_rle(input): if not input: return \\"\\" decoded_string = \\"\\" count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded_string += char * int(count) count = \\"\\" return decoded_string"},{"question":"**Problem**: You are given a singly linked list and two integer indices, `start` and `end`. Write a function `remove_range(head, start, end)` that removes elements from the linked list starting at index `start` and ending at index `end` (inclusive). **Function Signature**: ```python def remove_range(head, start, end): ``` **Input**: - `head`: The head node of the singly linked list. - `start`: An integer, the start index of the range to remove. - `end`: An integer, the end index of the range to remove. **Output**: - Return the head node of the modified linked list. **Constraints**: - `0 <= start <= end < size of list`. **Example**: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_range(head, start, end): # Implementation goes here ``` **Scenario**: You are tasked with implementing a data cleaning routine for a linked list which holds timestamps of events from a logging system. Some segments of the list have irrelevant or redundant data collected between specific intervals. Your function is used to streamline the list by removing entries within a specified range of indices. **Details**: - Ensure the function works correctly for edge cases, such as when the range includes the head of the list. - Focus on avoiding memory leaks or pointer errors. - Do not create a new list or use auxiliary data structures (e.g., arrays) beyond a minimal number of temporary variables. **Example Test Case**: ```python lst = ListNode(8, ListNode(13, ListNode(17, ListNode(4, ListNode(9, ListNode(12, ListNode(98, ListNode(41, ListNode(7, ListNode(23, ListNode(0, ListNode(92)))))))))))) start, end = 3, 8 new_head = remove_range(lst, start, end) # Expected output: 8 -> 13 -> 17 -> 23 -> 0 -> 92 ``` **Evaluation Criteria**: - **Correctness**: Your function should correctly modify the list. - **Efficiency**: Your function should operate within the time complexity of O(n) and space complexity of O(1). - **Edge Case Handling**: The function must handle cases like removing from the head, single-element removal, and invalid inputs correctly.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_range(head, start, end): # Create a dummy node to handle edge cases where head itself needs to be removed dummy = ListNode(0) dummy.next = head # Initialize pointers curr = dummy # Move \'curr\' to the node just before the start index for _ in range(start): curr = curr.next # Maintain another pointer to traverse and find the end to_remove = curr.next for _ in range(end - start + 1): to_remove = to_remove.next # Bypass the nodes from start to end curr.next = to_remove return dummy.next"},{"question":"# Question: Dijkstra\'s Algorithm Enhancement and Application You are given a directed graph represented as an adjacency matrix and you need to enhance the traditional Dijkstra\'s algorithm to support real-world applications. Specifically, considering the following requirements: 1. **Input**: You will receive an adjacency matrix where each element represents the weight of the edge between nodes. If there is no edge between two nodes, the respective cell will contain -1. 2. **Output**: Return the shortest path distances from a given source node to all other nodes in the form of a list. If a node is unreachable from the source node, its distance should be reported as -1. 3. **Enhancement**: - Modify the algorithm to handle graphs with edges that have both zero and positive weights. - Ensure the algorithm correctly identifies and marks unreachable nodes. 4. **Constraints**: - The adjacency matrix will be an N x N matrix, where N is the number of nodes (1 ≤ N ≤ 100). - The weights of the edges will be in the range [-1, 1000], where -1 represents no edge. # Function Signature Implement the function as follows: ```python def dijkstra_with_unreachable(graph: List[List[int]], src: int) -> List[int]: pass ``` # Example ```python graph = [ [0, 2, -1, 1], [2, 0, 4, -1], [-1, 4, 0, 3], [1, -1, 3, 0] ] src = 0 print(dijkstra_with_unreachable(graph, src)) # Output: [0, 2, 5, 1] ``` # Explanation - From node 0, the shortest distance to node 1 is 2, to node 2 is 5 (via node 3), and to node 3 is 1. # Performance Requirements - Your solution should handle edge cases efficiently and ensure that it performs within acceptable limits for the given constraints.","solution":"from typing import List import heapq def dijkstra_with_unreachable(graph: List[List[int]], src: int) -> List[int]: N = len(graph) distances = [float(\'inf\')] * N distances[src] = 0 priority_queue = [(0, src)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the popped node\'s distance is greater than the known shortest, skip it if current_distance > distances[current_node]: continue for neighbor in range(N): weight = graph[current_node][neighbor] if weight >= 0: # Valid edge distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # Replace all \'inf\' with -1 to indicate unreachable nodes return [-1 if d == float(\'inf\') else d for d in distances]"},{"question":"# Scenario You have come across a simple yet fascinating encryption method named Caesar Cipher, which shifts every letter in a string by a fixed number of positions in the alphabet. Understanding this cipher will help build familiarity with basic encryption concepts and string manipulation techniques. # Problem Statement Write a function named `caesar_cipher_optimized` that applies Caesar\'s cipher to an input string. The function should handle both uppercase and lowercase letters but leave non-alphabetic characters unchanged. Additionally, ensure the resulting cipher maintains the case of the original characters. # Function Signature ```python def caesar_cipher_optimized(s: str, k: int) -> str: pass ``` # Input - `s`: A string `s` (1 ≤ |s| ≤ 10^4), where `|s|` denotes the length. The string can include any printable ASCII characters. - `k`: An integer `k` (0 ≤ k ≤ 100), representing the number of positions each letter in the string should be shifted. # Output - Return a new string, which is the result of applying the Caesar cipher to the input string `s` with a shift of `k`. # Constraints - Characters other than letters (a-z, A-Z) should not be altered. - The function should preserve the original case of each letter. # Performance Requirements - The function should run efficiently for strings up to the maximum length (10^4). # Example ```python assert caesar_cipher_optimized(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" assert caesar_cipher_optimized(\\"abcXYZ\\", 2) == \\"cdeZAB\\" ``` # Notes - The ASCII values for lowercase letters are between 97 (`\'a\'`) and 122 (`\'z\'`). - The ASCII values for uppercase letters are between 65 (`\'A\'`) and 90 (`\'Z\'`).","solution":"def caesar_cipher_optimized(s: str, k: int) -> str: def shift_char(c, k): if c.isalpha(): if c.islower(): return chr((ord(c) - ord(\'a\') + k) % 26 + ord(\'a\')) else: return chr((ord(c) - ord(\'A\') + k) % 26 + ord(\'A\')) return c return \'\'.join(shift_char(c, k) for c in s)"},{"question":"# Rotate String by K Positions **Context**: You are working on a cryptographic application that requires you to rotate strings by a certain number of positions. To achieve this, you need to implement a function that efficiently performs this rotation. **Task**: Write a function `rotate_string(s: str, k: int) -> str` that rotates the input string `s` to the left by `k` positions. If `k` is larger than the length of the string, it should wrap around using modular arithmetic to determine the effective number of rotations. **Input**: * A string `s` (1 <= len(s) <= 10^5) consisting of lowercase English letters. * An integer `k` (0 <= k <= 10^9). **Output**: * A string that is the result of rotating `s` to the left by `k` positions. **Constraints**: * You should handle very large values of `k` efficiently without using excessive memory. * Rotation should preserve the relative order of characters. **Examples**: ```python assert rotate_string(\\"hello\\", 2) == \\"llohe\\" assert rotate_string(\\"hello\\", 5) == \\"hello\\" assert rotate_string(\\"hello\\", 6) == \\"elloh\\" assert rotate_string(\\"hello\\", 7) == \\"llohe\\" assert rotate_string(\\"hello\\", 102) == \\"lohel\\" ``` **Performance Note**: Ensure your solution handles edge cases such as `k` being a multiple of the string length, and that it operates within acceptable time and space boundaries.","solution":"def rotate_string(s: str, k: int) -> str: Rotates the input string `s` to the left by `k` positions. If `k` is larger than the length of the string, it wraps around using modular arithmetic. n = len(s) k = k % n # Normalize k to be within the range of 0 to n-1 return s[k:] + s[:k]"},{"question":"You are given two integers, `a` and `n`, and an optional integer `mod`. Your task is to implement a function that computes the power `a^n` using binary exponentiation. The function should be efficient and handle large values of `n` in logarithmic time. Additionally, if the optional `mod` parameter is provided, the function should return the result modulo `mod`. # Function Signature ```python def power(a: int, n: int, mod: int = None) -> int: pass ``` **Input**: - `a` (int): The base integer. - `n` (int): The exponent integer. - `mod` (Optional[int]): The modulus value to be applied to the result. **Output**: - (int): The result of `a^n` modulo `mod` if `mod` is provided, else the result of `a^n`. # Constraints - `1 <= a <= 2^31 - 1` - `0 <= n <= 10^9` - If `mod` is provided, `1 <= mod <= 10^9` # Examples 1. power(2, 10) - **Input**: a=2, n=10 - **Output**: 1024 2. power(2, 10, 1000) - **Input**: a=2, n=10, mod=1000 - **Output**: 24 3. power(3, 0) - **Input**: a=3, n=0 - **Output**: 1 4. power(5, 3) - **Input**: a=5, n=3 - **Output**: 125 5. power(7, 3, 10) - **Input**: a=7, n=3, mod=10 - **Output**: 3 # Notes - Your implementation should handle edge cases such as `n` being zero. - The algorithm should be efficient, with a time complexity of O(log(n)). - You may use either the iterative or the recursive version but ensure not to exceed the stack limit for the recursive calls.","solution":"def power(a: int, n: int, mod: int = None) -> int: Computes the power a^n using binary exponentiation. If mod is provided, computes (a^n) % mod. result = 1 base = a while n > 0: if n % 2 == 1: result = (result * base) % mod if mod else (result * base) base = (base * base) % mod if mod else (base * base) n //= 2 return result"},{"question":"# Question You are given a task to design a pair of encoding and decoding functions: 1. **Function `encode`**: Takes a list of strings and encodes it to a single string. 2. **Function `decode`**: Takes the encoded string and decodes it back to the original list of strings. Requirements: * The `encode` function should handle a list of strings and return a single encoded string. * The `decode` function should handle the encoded string and return the original list of strings. # Function Signatures: ```python def encode(strs: List[str]) -> str: pass def decode(s: str) -> List[str]: pass ``` Input & Output **Input**: * For `encode(strs: List[str]) -> str`: - `strs`: A list of strings. Example: `[\\"hello\\", \\"world\\"]` * For `decode(s: str) -> List[str]`: - `s`: An encoded string. Example: `5:hello5:world` **Output**: * For `encode`: - A single encoded string. Example: `\\"5:hello5:world\\"` * For `decode`: - The original list of strings. Example: `[\\"hello\\", \\"world\\"]` Constraints: * The list of strings will have at most 1000 strings. * Each string will have at most 1000 characters. Performance Requirements: * The solution should be optimized for both time and space complexity. Additional Points: * Consider edge cases such as an empty list or strings that contain the delimiter used for encoding. * Ensure that the implementation can handle special characters and long strings effectively. # Example Example 1: **Input**: ```python strs = [\\"hello\\", \\"world\\"] encoded_string = encode(strs) decoded_list = decode(encoded_string) ``` **Output**: ```python encoded_string = \\"5:hello5:world\\" decoded_list = [\\"hello\\", \\"world\\"] ``` Example 2: **Input**: ```python strs = [\\"we\\", \\"love\\", \\"python\\"] encoded_string = encode(strs) decoded_list = decode(encoded_string) ``` **Output**: ```python encoded_string = \\"2:we4:love6:python\\" decoded_list = [\\"we\\", \\"love\\", \\"python\\"] ``` Implement the `encode` and `decode` methods as described.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. Args: strs (List[str]): List of strings to be encoded. Returns: str: Encoded string. return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s: str) -> List[str]: Decodes a single string back to a list of strings. Args: s (str): Encoded string. Returns: List[str]: List of original strings. i, n = 0, len(s) result = [] while i < n: j = i while s[j] != \':\': j += 1 length = int(s[i:j]) result.append(s[j+1:j+1+length]) i = j + 1 + length return result"},{"question":"# Scenario You are given the task of implementing a self-balancing AVL tree. The AVL tree should support the insertion of key-value pairs and should maintain balance at all times to ensure efficient operations. Your implementation should also provide a method to verify the balance and structure of the tree using an in-order traversal. # Task Implement the following functions for the AVL tree: 1. `insert(key)`: Inserts the given key into the AVL tree. 2. `in_order_traverse()`: Returns the in-order traversal list of the tree\'s keys. # Input and Output * The `insert(key)` function will be called multiple times to build the AVL tree. Key will be an integer. * The `in_order_traverse()` function should return a list of integer keys in ascending order. # Constraints 1. The keys inserted will be in the range of 1 to 10^6. 2. The total number of keys inserted will not exceed 10^5 in any test scenario. 3. Ensure that your `insert` method maintains the tree\'s balance according to AVL tree properties. # Example ```python # Create an empty AVL Tree avl_tree = AvlTree() # Perform Insertions avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(5) avl_tree.insert(4) avl_tree.insert(15) # Perform In-Order Traversal print(avl_tree.in_order_traverse()) # Output: [4, 5, 10, 15, 20] ``` # Performance Requirements 1. Your implementation should efficiently handle up to 10^5 insert operations. 2. The solution should ensure all operations adhere to AVL balance rules for optimal performance. # Notes 1. After insertion operations, use `in_order_traverse` to check if tree keys are in sorted order. 2. Ensure that the tree remains balanced after each insertion.","solution":"class Node: def __init__(self, key): self.key = key self.height = 1 # Height of node self.left = None self.right = None class AvlTree: def __init__(self): self.root = None def insert(self, key): Insert a key into the AVL tree. self.root = self._insert(self.root, key) def _insert(self, node, key): # Perform normal BST insertion if not node: return Node(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) # Update height of this ancestor node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) # Get the balance factor of this ancestor node balance = self._get_balance(node) # If node becomes unbalanced, then balance it # Case 1 - Left Left if balance > 1 and key < node.left.key: return self._right_rotate(node) # Case 2 - Right Right if balance < -1 and key > node.right.key: return self._left_rotate(node) # Case 3 - Left Right if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Case 4 - Right Left if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def in_order_traverse(self): Returns the in-order traversal of the AVL tree as a list of keys. result = [] self._in_order_helper(self.root, result) return result def _in_order_helper(self, node, result): if not node: return self._in_order_helper(node.left, result) result.append(node.key) self._in_order_helper(node.right, result)"},{"question":"# Task Description The goal of this task is to implement a method for reversing a given Doubly Linked List. # Problem Statement: Write a class `DoublyLinkedList` that supports the following operations: 1. `append(value)`: Adds a new node with the given value to the end of the list. 2. `reverse()`: Reverses the linked list in-place. 3. `to_list()`: Returns a list of the values in the linked list from head to tail. # Constraints: 1. Do not use any additional data structures except pointer manipulations. 2. The reversal operation must be in-place. # Input Format: - The `append` method will be called multiple times to provide the values. - The `reverse` method will be called to reverse the list. - The `to_list` method will be called to retrieve the list of values in the current state. # Expected Output: - After calling the `reverse` method, `to_list` should return the list in reversed order. # Example: ```python dll = DoublyLinkedList() dll.append(1) dll.append(2) dll.append(3) dll.append(4) print(dll.to_list()) # Output: [1, 2, 3, 4] dll.reverse() print(dll.to_list()) # Output: [4, 3, 2, 1] ``` # Make sure your solution handles: - Edge cases such as reversing an empty list or a list with a single node. - Efficiency concerns by ensuring the reverse operation is done in O(n) time using in-place manipulation.","solution":"class Node: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): new_node = Node(value) if self.tail is None: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def reverse(self): current = self.head temp = None while current is not None: temp = current.prev current.prev = current.next current.next = temp current = current.prev if temp is not None: self.head = temp.prev def to_list(self): result = [] current = self.head while current is not None: result.append(current.value) current = current.next return result"},{"question":"In this task, you are required to write a Python function that performs the Diffie-Hellman Key Exchange algorithm outlined above. You will implement both the key exchange and verification of the shared key. Make sure to handle all edge cases and possible errors. Function Signature ```python def diffie_hellman_key_exchange(a: int, p: int, display_steps: bool = False) -> bool: Perform Diffie-Hellman key exchange. Parameters: - a (int): The primitive root of p. - p (int): A large prime number. - display_steps (bool): If True, print the steps of the key exchange process. Returns: - bool: True if the shared keys match, False otherwise. ``` Input * `a`: The primitive root of `p` (integer). * `p`: A large prime number (integer). * `display_steps`: Boolean flag to indicate if the steps need to be printed (default False). Output * `bool`: Returns `True` if the shared keys derived by Alice and Bob match, `False` otherwise. Requirements 1. Validate that `p` is a prime number. 2. Validate that `a` is a primitive root of `p`. 3. Implement modular exponentiation for key computations. 4. Generate private and public keys for Alice and Bob using random integers. 5. Compute the shared secret keys and verify if they are identical. 6. If `display_steps` is `True`, print the keys and the computations during the process. Constraints * ( 2 leq p leq 10^9 ). * ( 2 leq a < p ). Example ```python result = diffie_hellman_key_exchange(5, 23, True) # Output should include intermediate steps for key exchange and final result True or False ```","solution":"import random from sympy import isprime, primerange def is_primitive_root(a, p): required_set = set(num for num in range(1, p) if gcd(num, p) == 1) actual_set = set(pow(a, powers, p) for powers in range(1, p)) return required_set == actual_set def gcd(a, b): while b: a, b = b, a % b return a def diffie_hellman_key_exchange(a: int, p: int, display_steps: bool = False) -> bool: Perform Diffie-Hellman key exchange. Parameters: - a (int): The primitive root of p. - p (int): A large prime number. - display_steps (bool): If True, print the steps of the key exchange process. Returns: - bool: True if the shared keys match, False otherwise. if not isprime(p): raise ValueError(\\"p must be a prime number.\\") if not is_primitive_root(a, p): raise ValueError(f\\"{a} is not a primitive root of {p}.\\") # Private keys (secret) Alice_private_key = random.randint(2, p-2) Bob_private_key = random.randint(2, p-2) # Public keys Alice_public_key = pow(a, Alice_private_key, p) Bob_public_key = pow(a, Bob_private_key, p) if display_steps: print(f\\"Alice\'s private key: {Alice_private_key}\\") print(f\\"Alice\'s public key: {Alice_public_key}\\") print(f\\"Bob\'s private key: {Bob_private_key}\\") print(f\\"Bob\'s public key: {Bob_public_key}\\") # Shared secret keys Alice_shared_key = pow(Bob_public_key, Alice_private_key, p) Bob_shared_key = pow(Alice_public_key, Bob_private_key, p) if display_steps: print(f\\"Alice\'s shared secret key: {Alice_shared_key}\\") print(f\\"Bob\'s shared secret key: {Bob_shared_key}\\") return Alice_shared_key == Bob_shared_key"},{"question":"Context A company is building a contact management system which requires efficient storage and retrieval of contacts based on the contact name. To achieve this, you have been tasked with implementing a hash table using separate chaining. Task Your task is to extend the provided `SeparateChainingHashTable` class. Implement a method `resize` that dynamically resizes the hash table when the load factor exceeds a certain threshold. Requirements - Implement a method called `resize` which doubles the size of the hash table and rehashes all existing entries. - Add a method `load_factor` to compute the current load factor of the hash table, defined as the number of key-value pairs divided by the size of the table. - Modify the `put` method to call `resize` when the load factor exceeds 0.7. ```python class SeparateChainingHashTable(object): ... def resize(self): # Your code here def load_factor(self): # Return the current load factor of the hash table # Extend the existing `put` method to handle resizing def put(self, key, value): if self.load_factor() > 0.7: self.resize() # Existing implementation of `put` method ... ``` Input/Output: - `resize` will not take any input and will not return any value. - `load_factor` will return a float representing the current load factor. Constraints: - Assume the hash table only stores alphanumeric keys and values. By completing this task, you will demonstrate your understanding of basic hash table operations and how to handle dynamic resizing to maintain performance.","solution":"class SeparateChainingHashTable: def __init__(self, size=10): self.size = size self.table = [[] for _ in range(size)] self.count = 0 def _hash(self, key): return hash(key) % self.size def put(self, key, value): if self.load_factor() > 0.7: self.resize() hashed_key = self._hash(key) for idx, element in enumerate(self.table[hashed_key]): k, v = element if k == key: self.table[hashed_key][idx] = (key, value) return self.table[hashed_key].append((key, value)) self.count += 1 def get(self, key): hashed_key = self._hash(key) for k, v in self.table[hashed_key]: if k == key: return v return None def load_factor(self): return self.count / self.size def resize(self): new_size = self.size * 2 new_table = [[] for _ in range(new_size)] for bucket in self.table: for key, value in bucket: new_hashed_key = hash(key) % new_size new_table[new_hashed_key].append((key, value)) self.size = new_size self.table = new_table def delete(self, key): hashed_key = self._hash(key) for idx, (k, v) in enumerate(self.table[hashed_key]): if k == key: del self.table[hashed_key][idx] self.count -= 1 return True return False"},{"question":"You are tasked with implementing a function to find all prime numbers less than a given positive integer `n`, with an optimization to reduce the number of checks by excluding even numbers. Use the modified Sieve of Eratosthenes algorithm, which only handles odd numbers beyond the base case check for the number 2. Function Specification **Function Name**: `get_primes_optimized` **Inputs**: - `n` (int): A positive integer. **Outputs**: - `List[int]`: A list of all prime numbers less than `n`. **Constraints**: - `n` will be a positive integer within the range (0 leq n leq 10^6). **Performance Requirements**: - Ensure the function runs efficiently for large values of `n` (up to (10^6)). - Optimize the space usage by excluding even numbers from the sieve where possible. # Instructions 1. Handle edge cases where `n` is less than or equal to 2 appropriately. 2. Use the modified sieve described to focus on odd numbers and optimize the sieve\'s size. 3. Your implementation should handle large inputs efficiently within the given constraints. # Example Usage: ```python > print(get_primes_optimized(10)) # Output: [2, 3, 5, 7] > print(get_primes_optimized(1)) # Output: [] > print(get_primes_optimized(11)) # Output: [2, 3, 5, 7] > print(get_primes_optimized(0)) # Output: [] ```","solution":"def get_primes_optimized(n): Returns a list of all prime numbers less than the given positive integer n. if n <= 2: return [] sieve = [True] * (n // 2) sieve[0] = False # 1 is not a prime number for i in range(1, int(n**0.5) // 2 + 1): if sieve[i]: prime = 2 * i + 1 sieve[prime * prime // 2::prime] = [False] * len(sieve[prime * prime // 2::prime]) primes = [2] + [2 * i + 1 for i in range(1, n // 2) if sieve[i]] return primes"},{"question":"You are given an array of integers, where every element appears twice except for one element that appears only once. Your task is to implement an efficient algorithm to find that single unique element. The algorithm should run in linear time and use constant space. # Input - `nums`: A list of integers, such that all elements appear exactly twice except for one element that appears exactly once. # Output - Returns the single element that appears once in the list. # Constraints - The length of the array will be at least one. - The array will have at most one unique element that only appears once in the entire array. # Example ```python Given the array: [4, 1, 2, 1, 2] Your function should return: 4 Given the array: [2, 2, 3, 4, 4] Your function should return: 3 ``` # Notes 1. Implement the function using bitwise XOR to achieve the desired time and space complexity. 2. Consider edge cases such as an array with a single element or very large arrays. # Function Signature ```python def single_number(nums: List[int]) -> int: pass ``` # Hints 1. The XOR operation returns 0 when both bits are the same and 1 when they are different. 2. XOR of a number with itself results in 0 (e.g., ( n oplus n = 0 )), and XOR of a number with 0 results in the number itself (e.g., ( n oplus 0 = n )). 3. Using these properties, iterate through the array and XOR all elements together to find the single unique element.","solution":"from typing import List def single_number(nums: List[int]) -> int: Finds the single unique number in a list where all other numbers appear exactly twice. Args: nums (List[int]): List of integers where all elements except one appear exactly twice. Returns: int: The element that appears once. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Cycle Detection in a Directed Graph **Background**: You\'ve been hired by a company to build a resource allocation system. The system must ensure there are no cyclic dependencies in resource requests, avoiding deadlocks. Your task is to implement functionality to detect cycles in a directed graph representing resource allocation dependencies. **Task**: Implement the `contains_cycle(graph)` function which determines if a given directed graph contains a cycle. **Function Signature**: ```python def contains_cycle(graph: Dict[str, List[str]]) -> bool: ``` **Input**: - `graph`: A dictionary representing a directed graph where: - The keys are node identifiers (strings). - The values are lists of strings representing nodes each node points to (outgoing edges). **Output**: - Returns `True` if the graph contains at least one cycle, otherwise `False`. **Constraints**: - The graph nodes are represented as strings. - Consider typical edge cases like nodes with self-loops and completely disconnected graphs. **Performance Requirements**: - The implementation should run in O(V + E) time complexity. **Example**: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } assert contains_cycle(graph) == True graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [], \'F\': [] } assert contains_cycle(graph) == False ``` **Hints**: - Use Depth-First Search (DFS) to explore nodes. - Utilize node states (WHITE, GRAY, BLACK) to track discovery and processing status. - Use the provided structure or modify as required to suit the problem.","solution":"from typing import Dict, List def contains_cycle(graph: Dict[str, List[str]]) -> bool: WHITE, GRAY, BLACK = 0, 1, 2 node_color = {node: WHITE for node in graph} def dfs(node): if node_color[node] == GRAY: return True if node_color[node] == BLACK: return False node_color[node] = GRAY for neighbor in graph[node]: if dfs(neighbor): return True node_color[node] = BLACK return False for node in graph: if node_color[node] == WHITE: if dfs(node): return True return False"},{"question":"# Problem Description: You are given a singly linked list and an integer k. Your task is to rotate the list to the right by k places. Write a function `rotate_right` that performs this transformation efficiently and in place. Function Signature: ```python def rotate_right(head: ListNode, k: int) -> ListNode: ``` Input: - `head`: The head node of a singly linked list. - `k`: A non-negative integer representing the number of positions to rotate the list. Output: - Returns the new head of the rotated list. Example: ```python # Given the linked list 1->2->3->4->5 and k = 2, # The function should return 4->5->1->2->3. # Given the linked list 0->1->2 and k = 4, # The function should return 2->0->1. ``` Constraints: - The number of nodes in the list is between 0 and 10^4. - `k` is a non-negative integer within the range [0, 2^31 - 1]. Requirements: - The solution should handle all edge cases correctly. - Aim for a time complexity of O(n) and a space complexity of O(1). - Ensure the list is correctly transformed without introducing cycles or leaving unlinked nodes. Context: Imagine an online book reader where each book is stored as a linked list of pages, and rotating pages reflects a scenario where a reader can switch to a specific page index cyclically. The algorithm should ensure seamless navigation through the list by efficiently rotating and linking list nodes.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_right(head: ListNode, k: int) -> ListNode: if not head or k == 0: return head # Find the length of the linked list length = 1 last_node = head while last_node.next: last_node = last_node.next length += 1 # Connect the last node to the head to make it circular last_node.next = head # Compute the number of rotations needed k = k % length if k == 0: last_node.next = None return head # Find the new tail which is (length - k) nodes from the beginning new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"# Task: Write a function that accepts a string and removes any reoccurring character, returning a new string with unique characters which appear in the same order as they first appeared in the input. Implement your solution in Python. # Function Signature: ```python def delete_reoccurring_characters(string: str) -> str: # your code here ``` # Input: - `string` (str): A string containing ASCII characters. The length of the string is between 0 and 10^5. # Output: - (str): A new string with duplicate characters removed. # Constraints: - The resultant string should contain characters in the same order as they first appeared in the input. - Ensure that your solution is efficient in terms of both time and space complexity. # Example: ```python assert delete_reoccurring_characters(\\"banana\\") == \\"ban\\" assert delete_reoccurring_characters(\\"google\\") == \\"gole\\" assert delete_reoccurring_characters(\\"programming\\") == \\"progamin\\" assert delete_reoccurring_characters(\\"aabbcc\\") == \\"abc\\" assert delete_reoccurring_characters(\\"\\") == \\"\\" ``` *Use these examples to outline what your function should return in different cases.* # Requirements: - Your solution should handle edge cases such as an empty string or strings with no repeating characters efficiently. Good luck!","solution":"def delete_reoccurring_characters(string: str) -> str: Returns a new string with duplicate characters removed. Characters appear in the same order as they first appeared in the input. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Problem Description You are tasked with implementing a data structure that stands as a word dictionary which supports adding new words and then searching for existing words with the support of a wildcard search. The wildcard character can be `\'.\'`, which can match any single letter. Your implementation should allow: 1. Adding a new word to the dictionary. 2. Searching for a word in the dictionary with support for wildcard `\'.\'`. Your implementation should support the following methods: * `add_word(word)`: Adds the given word to the dictionary. * `search(word)`: Searches for the given word in the dictionary. # Function Signature ```python class WordDictionary: def __init__(self): # initialize the data structure def add_word(self, word: str) -> None: # Adds the word to the dictionary def search(self, word: str) -> bool: # Searches for the word with support for wildcard \'.\' and returns True if found, False otherwise ``` # Input and Output Formats **Input**: * `add_word(word: str)`: `word` is a non-empty string consisting of lowercase letters [\'a\'-\'z\']. * `search(word: str)`: `word` is a non-empty string consisting of lowercase letters [\'a\'-\'z\'] and/or wildcard character `\'.\'`. **Output**: * `search(word: str) -> bool`: Returns `True` if the word is found in the dictionary with support for wildcard searches, `False` otherwise. # Example ```python word_dict = WordDictionary() word_dict.add_word(\\"bad\\") word_dict.add_word(\\"dad\\") word_dict.add_word(\\"mad\\") print(word_dict.search(\\"pad\\")) # Output: False print(word_dict.search(\\"bad\\")) # Output: True print(word_dict.search(\\".ad\\")) # Output: True print(word_dict.search(\\"b..\\")) # Output: True ``` # Constraints * Words in the dictionary will have a length of at most 100. * Your implementation should be efficient and should not exceed a reasonable time complexity. # Notes * Consider different edge cases, such as adding and searching for words containing only the wildcard character. * Ensure your implementation can handle multiple wildcard characters in a single search word.","solution":"class WordDictionary: def __init__(self): self.trie = {} def add_word(self, word: str) -> None: node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node[\\"#\\"] = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char not in node: if char == \'.\': for x in node: if x != \'#\' and search_in_node(word[i + 1:], node[x]): return True return False else: node = node[char] return \\"#\\" in node return search_in_node(word, self.trie)"},{"question":"# Merge Sort Implementation and Analysis Background: Merge Sort is a classic and efficient sorting algorithm that uses a divide-and-conquer approach. This challenge aims to assess your understanding of its core principles by implementing it and addressing common scenarios it handles. Task: Write a function `merge_sort` to sort an array of integers in ascending order using the merge sort algorithm. Specifications: 1. **Function Signature**: ```python def merge_sort(arr: List[int]) -> List[int]: ``` 2. **Input**: - `arr`: A list of integers with length `n` (0 <= n <= 10^5). 3. **Output**: - A new list of integers sorted in ascending order. 4. **Constraints**: - The function should use O(n log(n)) time complexity. - The function should not return the input array itself but a new sorted list. - Aim to minimize additional space usage while ensuring the function stays clear and efficient. Edge Cases to Handle: 1. Sorting an empty array should return an empty array. 2. Sorting an already sorted array should not alter the order. 3. Sorting an array with only one element should return the same array. 4. Include error handling for incorrect input types. Example: ```python assert merge_sort([]) == [] assert merge_sort([1]) == [1] assert merge_sort([3, 2, 1]) == [1, 2, 3] assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert merge_sort([4, 1, 3, 9, 7]) == [1, 3, 4, 7, 9] ``` You must ensure your implementation is efficient and correctly handles all specified scenarios.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts an array of integers in ascending order using merge sort algorithm. if len(arr) <= 1: return arr # Helper function to merge two sorted lists def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] left_index, right_index = 0, 0 # Merge the two sorted lists into a single sorted list while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 # If there are remaining elements in left or right, extend the sorted list sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list # Divide the array into two halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the sorted halves return merge(left_half, right_half)"},{"question":"Objective Implement a function that determines if two binary trees are structurally identical. Two binary trees are structurally identical if they have the same structure and nodes have the same values. Input/Output - **Input**: Two serialized strings representing two binary trees. - **Output**: A boolean value, `True` if the trees are structurally identical, `False` otherwise. Constraints - The serialized strings are produced using the same serialization mechanism as defined in the provided `serialize` function. - The function should handle trees with up to 10^4 nodes. Scenario Imagine you\'re working on a network application where binary trees are serialized and sent over the network. You receive two serialized binary trees and you need to verify if the received trees are structurally identical to perform further operations. Function Signature ```python def are_trees_identical(serialized_tree1: str, serialized_tree2: str) -> bool: # Implement your solution here ``` Example ```python # Example Trees: # Tree 1: 1 Tree 2: 1 # / / # 2 3 2 3 serialized_tree1 = \\"1 2 # # 3 # #\\" serialized_tree2 = \\"1 2 # # 3 # #\\" assert are_trees_identical(serialized_tree1, serialized_tree2) == True # Different structure serialized_tree3 = \\"1 2 # # #\\" serialized_tree4 = \\"1 # 2 # #\\" assert are_trees_identical(serialized_tree3, serialized_tree4) == False ``` Steps to Solve the Problem 1. Deserialize both serialized tree strings into their respective binary tree structures using the provided `deserialize` function. 2. Implement a function to compare the two deserialized trees and check if they are structurally identical: - Both trees being `None` returns `True`. - One tree being `None` and the other not being `None` returns `False`. - Both trees having the same value and identical left and right subtrees returns `True`.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def deserialize(data: str) -> TreeNode: Decodes your encoded data to tree. if not data: return None nodes = iter(data.split()) root = TreeNode(next(nodes)) queue = [root] while queue: node = queue.pop(0) left_val = next(nodes, None) if left_val and left_val != \\"#\\": node.left = TreeNode(left_val) queue.append(node.left) right_val = next(nodes, None) if right_val and right_val != \\"#\\": node.right = TreeNode(right_val) queue.append(node.right) return root def are_trees_identical(serialized_tree1: str, serialized_tree2: str) -> bool: Returns True if two serialized binary trees are structurally identical, else False. def is_identical(tree1: TreeNode, tree2: TreeNode) -> bool: if not tree1 and not tree2: return True if tree1 and tree2: return (tree1.val == tree2.val and is_identical(tree1.left, tree2.left) and is_identical(tree1.right, tree2.right)) return False tree1 = deserialize(serialized_tree1) tree2 = deserialize(serialized_tree2) return is_identical(tree1, tree2)"},{"question":"# Question Given an array of integers, write a function `threshold_filter` that filters the array to include only integers greater than a specified minimum value and less than a specified maximum value. If either the minimum or maximum values are not provided, assume no limit. Your task is to implement this function with the following requirements: - **Function Signature**: `def threshold_filter(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]:` - **Input**: * `arr` (List[int]): An array of integers. * `min_lim` (Optional[int]): Minimum threshold value, defaults to `None`. * `max_lim` (Optional[int]): Maximum threshold value, defaults to `None`. - **Output**: * A new list containing integers from `arr` that are greater than `min_lim` and less than `max_lim`. - **Constraints**: * All integers in the array and thresholds are within the range -10^6 to 10^6. * Solve the problem with a time complexity of O(n). * The input list may be empty. # Example ```python assert threshold_filter([1,2,3,4,5], None, 3) == [1,2,3] assert threshold_filter([1,5,10,15,20,25,30], 5, 20) == [5,10,15,20] assert threshold_filter([3,3,2,2,1,1], 2, 3) == [2,2,3,3] assert threshold_filter([], None, None) == [] assert threshold_filter([100,200,300], 150, None) == [200,300] ``` **Scenario**: Imagine you are developing a basic data filtering utility where data readings need to be cleaned based on a threshold range before further processing. This utility function helps ensure your data falls within acceptable boundaries, critical in initial data preprocessing stages.","solution":"from typing import List, Optional def threshold_filter(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: result = [] for num in arr: if (min_lim is None or num > min_lim) and (max_lim is None or num < max_lim): result.append(num) return result"},{"question":"# Problem Scenario A small social network is represented as a graph where each node represents a user, and each edge represents a connection between users. You are tasked with implementing a feature to analyze user\'s connectivity. Specifically, you need to identify all users that can be reached starting from a given user using both DFS and BFS methods. # Objective Write functions to implement both DFS (iteratively and recursively) and BFS to traverse the graph starting from a given user. # Specifications 1. **Inputs**: * `graph` (dictionary): A dictionary representing adjacency list of the graph where keys are user IDs and values are lists of connected user IDs. * `start` (int): The starting user ID for the traversal. 2. **Outputs**: * A set of user IDs representing users reachable from the starting user. 3. **Function Signatures**: ```python def dfs_traverse(graph: dict, start: int) -> set: # Your code here def dfs_traverse_recursive(graph: dict, start: int, visited: set = None) -> set: # Your code here def bfs_traverse(graph: dict, start: int) -> set: # Your code here ``` 4. **Constraints**: * Assume `graph` is not necessarily connected. * Each user is uniquely identified. * The input graph can be large with up to 10,000 nodes. 5. **Performance Requirements**: * The solution should be efficient in terms of time complexity, ideally O(V + E), and use reasonable auxiliary space. # Example ```python graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2, 5, 6], 5: [4], 6: [4], 7: [] # Isolated node } start_user = 1 print(dfs_traverse(graph, start_user)) # Output: {1, 2, 3, 4, 5, 6} print(dfs_traverse_recursive(graph, start_user)) # Output: {1, 2, 3, 4, 5, 6} print(bfs_traverse(graph, start_user)) # Output: {1, 2, 3, 4, 5, 6} ``` Note: Ensure your implementations account for isolated nodes, disconnected parts of the graph, and handle large inputs efficiently both in terms of time and memory.","solution":"def dfs_traverse(graph, start): Perform an iterative DFS traversal starting from \'start\' node. Parameters: graph (dict): The graph represented as an adjacency list. start (int): The starting user ID for the traversal. Returns: set: A set of user IDs representing users reachable from the starting user. visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend(neighbour for neighbour in graph.get(node, []) if neighbour not in visited) return visited def dfs_traverse_recursive(graph, start, visited=None): Perform a recursive DFS traversal starting from \'start\' node. Parameters: graph (dict): The graph represented as an adjacency list. start (int): The starting user ID for the traversal. visited (set): A set of visited nodes (used in recursive calls). Returns: set: A set of user IDs representing users reachable from the starting user. if visited is None: visited = set() visited.add(start) for neighbour in graph.get(start, []): if neighbour not in visited: dfs_traverse_recursive(graph, neighbour, visited) return visited def bfs_traverse(graph, start): Perform a BFS traversal starting from \'start\' node. Parameters: graph (dict): The graph represented as an adjacency list. start (int): The starting user ID for the traversal. Returns: set: A set of user IDs representing users reachable from the starting user. visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) queue.extend(neighbour for neighbour in graph.get(node, []) if neighbour not in visited) return visited"},{"question":"Extended Selection Sort with Custom Order You are to implement an extended version of the selection sort algorithm to sort an array of integers based on a custom order defined by the user. The user will provide a list of unique integers which defines the order for sorting elements of the input array. If there are elements in the input array that are not present in the order list, those elements should be placed at the end of the sorted section in ascending order. Write a function `extended_selection_sort(arr, order)` that accomplishes this task. # Function Signature: ```python def extended_selection_sort(arr: List[int], order: List[int]) -> List[int]: ``` # Input: - `arr`: List of integers `[a1, a2, ..., an]` (0 ≤ n ≤ 10^5) - `order`: List of unique integers `[b1, b2, ..., bm]` (0 ≤ m ≤ 10^5) # Output: - A list of integers representing the sorted array. # Constraints: - Elements in `order` are unique and within the range of integers present in `arr`. - The array `arr` can have integers not present in `order`. # Example: ```python assert extended_selection_sort([9, 1, 5, 3, 3, 6, 1], [1, 5, 3]) == [1, 1, 5, 3, 3, 6, 9] assert extended_selection_sort([4, 5, 6, 7, 8], [5, 4, 6]) == [5, 4, 6, 7, 8] assert extended_selection_sort([1, 10, 3, 2, 9], [10, 9, 8, 7]) == [10, 9, 1, 2, 3] assert extended_selection_sort([], [1, 2, 3]) == [] assert extended_selection_sort([8, 7, 8, 8], []) == [7, 8, 8, 8] ``` # Guidelines: 1. **Custom Sort Mechanism**: Sort elements by preserving the order specified in the list `order`. Other elements should be sorted in ascending order and placed at the end. 2. **Performance**: Aim for an efficient implementation to handle input sizes up to 100,000 elements. 3. **Edge Cases**: Consider cases when `arr` or `order` might be empty. # Example Explanation: * For the array `[9, 1, 5, 3, 3, 6, 1]` and order `[1, 5, 3]`, the integers `1`, `5`, and `3` are arranged according to the order list, and the remaining elements `6` and `9` are sorted at the end in ascending order. * For an empty `arr`, the result is an empty list regardless of the `order`. * For empty `order`, the array is simply sorted in ascending order.","solution":"def extended_selection_sort(arr, order): Sorts the array `arr` based on the `order` list of integers. Elements in `arr` not present in `order` are placed at the end in ascending order. Args: arr (List[int]): The list of integers to sort. order (List[int]): The custom order list. Returns: List[int]: The sorted list according to the custom order. # Create a dictionary to map the order values to their positions order_map = {value: i for i, value in enumerate(order)} # Separate `arr` into two lists: `ordered_part` and `unordered_part` ordered_part = [] unordered_part = [] for num in arr: if num in order_map: ordered_part.append(num) else: unordered_part.append(num) # Sort the ordered part based on the custom order ordered_part.sort(key=lambda x: order_map[x]) # Sort the unordered part in ascending order unordered_part.sort() # Concatenate both parts return ordered_part + unordered_part"},{"question":"You are tasked to write a function to find the next higher permutation of digits from a given number. This permutation should use the exact set of digits from the original number. # Requirements * **Function Signature**: `def next_higher_permutation(num: int) -> int:` * **Input**: A positive integer `num` (1 ≤ num ≤ 10^18). * **Output**: The next higher number formed by the same set of digits in `num`. If no such number exists, return `-1`. # Examples 1. `next_higher_permutation(38276)` should return `38627`. 2. `next_higher_permutation(12345)` should return `12354`. 3. `next_higher_permutation(54321)` should return `-1`. # Constraints 1. The number `num` will not have leading zeros. 2. You cannot convert the number to string or any other non-digit representations except for intermediate processing. 3. The function should be efficient with a time complexity close to O(n). # Implementation Guidelines 1. Parse the number\'s digits. 2. Identify the \\"pivot\\" where the sequence stops increasing. 3. Find the smallest digit higher than the pivot in the suffix. 4. Swap these two digits. 5. Reverse the suffix to get the smallest lexicographical order. # Edge Cases 1. The number `num` is already the highest permutation. 2. Minimal input values like single-digit numbers. # Unit Testing Include a test suite to validate the following cases: 1. Typical numbers with next higher permutations. 2. Numbers which are in descending order. 3. Single digit numbers. 4. Numbers with repeated digits. ```python import unittest def next_higher_permutation(num: int) -> int: digits = [int(i) for i in str(num)] idx = len(digits) - 1 while idx >= 1 and digits[idx - 1] >= digits[idx]: idx -= 1 if idx == 0: return -1 # no such number exists pivot = digits[idx - 1] swap_idx = len(digits) - 1 while pivot >= digits[swap_idx]: swap_idx -= 1 digits[swap_idx], digits[idx - 1] = digits[idx - 1], digits[swap_idx] digits[idx:] = digits[:idx - 1:-1] return int(\'\'.join(str(x) for x in digits)) class TestSuite(unittest.TestCase): def test_next_higher_permutation(self): self.assertEqual(next_higher_permutation(38276), 38627) self.assertEqual(next_higher_permutation(12345), 12354) self.assertEqual(next_higher_permutation(54321), -1) self.assertEqual(next_higher_permutation(999), -1) self.assertEqual(next_higher_permutation(5), -1) # Single digit if __name__ == \'__main__\': unittest.main() ```","solution":"def next_higher_permutation(num: int) -> int: Finds the next higher permutation of digits from a given number. Uses the exact set of digits from the original number. If no such number exists, returns -1. digits = [int(d) for d in str(num)] n = len(digits) # Step 1: Find the largest index i such that digits[i-1] < digits[i] i = n - 1 while i > 0 and digits[i - 1] >= digits[i]: i -= 1 if i == 0: return -1 # If no such index exists, the number is the highest permutation # Step 2: Find the largest index j such that j >= i and digits[j] > digits[i-1] j = n - 1 while digits[j] <= digits[i - 1]: j -= 1 # Step 3: Swap the value of digits[i-1] with digits[j] digits[i - 1], digits[j] = digits[j], digits[i - 1] # Step 4: Reverse the sequence from digits[i] to the end digits[i:] = reversed(digits[i:]) # Combine the digits to form the next permutation number return int(\'\'.join(map(str, digits)))"},{"question":"Scenario: You are in charge of cleaning up log files from a server. Each log entry is represented as a string where identical events might appear multiple times. You need to process a batch of these log entries to remove duplicate events while preserving their order of first occurrence. Task: Write a function `unique_logs` that takes a list of log entries (strings) and returns a new list where each log entry appears only once, in the order they first appeared in the input list. # Function Signature: ```python def unique_logs(logs: List[str]) -> List[str]: pass ``` # Input: * A list of strings `logs` (1 <= len(logs) <= 10^5, 1 <= len(logs[i]) <= 100). # Output: * A list of strings, the de-duplicated log entries in the order they first appeared. # Example: ```python # Input logs = [\\"error\\", \\"warning\\", \\"info\\", \\"error\\", \\"info\\", \\"debug\\"] # Output unique_logs(logs) -> [\\"error\\", \\"warning\\", \\"info\\", \\"debug\\"] ``` # Constraints: 1. The input list may contain between 1 and 100,000 log entries. 2. Each log entry is a string containing ASCII characters. 3. Maintain the original order of the first occurrence of each log entry. # Notes: - Think about efficiency both in terms of time and space complexity. - Be attentive to edge cases, such as an empty list or all entries being the same.","solution":"from typing import List def unique_logs(logs: List[str]) -> List[str]: This function takes a list of log entries and returns a list with duplicate log entries removed, preserving the order of their first appearance. seen = set() result = [] for log in logs: if log not in seen: seen.add(log) result.append(log) return result"},{"question":"# Context You are working with an IoT data stream that continuously sends temperature readings every minute. However, a specific analysis only requires data points that lie within a designated range. You need to filter out temperature readings to retain only those within given minimum and maximum values before performing further analysis. # Problem Statement Write a function `limit_temperatures` that filters an array of temperature readings, retaining only those that fall within the specified minimum and maximum range. If no minimum or maximum is specified, you should assume no constraint on that range. # Function Signature ```python def limit_temperatures(readings: List[float], min_temp: float = None, max_temp: float = None) -> List[float]: ``` # Input * `readings` (List[float]): A list of temperature readings. * `min_temp` (float, optional): Minimum temperature threshold. Defaults to `None`, indicating no minimum limit. * `max_temp` (float, optional): Maximum temperature threshold. Defaults to `None`, indicating no maximum limit. # Output Returns a list containing only the readings that are: * Greater than or equal to `min_temp` (if specified). * Less than or equal to `max_temp` (if specified). # Constraints * The function should handle an empty list. * Temperature readings can be positive, negative, or zero. * If `min_temp` or `max_temp` is `None`, do not apply the corresponding limit. # Examples ```python print(limit_temperatures([12.1, 22.3, 18.3, 45.2, 33.1], min_temp=20.0, max_temp=40.0)) # Output: [22.3, 33.1] print(limit_temperatures([12.1, 22.3, 18.3, 45.2, 33.1], min_temp=None, max_temp=30.0)) # Output: [12.1, 22.3, 18.3] print(limit_temperatures([12.1, 22.3, 18.3, 45.2, 33.1], min_temp=15.0, max_temp=None)) # Output: [22.3, 18.3, 45.2, 33.1] print(limit_temperatures([], min_temp=10.0, max_temp=20.0)) # Output: [] print(limit_temperatures([10.5, -5.0, 0.0, 25.3], min_temp=None, max_temp=None)) # Output: [10.5, -5.0, 0.0, 25.3] ``` # Notes * Aim for linear time complexity O(n). * Avoid re-calculating the default limits for every element in the array.","solution":"from typing import List def limit_temperatures(readings: List[float], min_temp: float = None, max_temp: float = None) -> List[float]: return [ reading for reading in readings if (min_temp is None or reading >= min_temp) and (max_temp is None or reading <= max_temp) ]"},{"question":"# Segment Tree Range Query and Update Scenario You are working on an application that needs to efficiently handle multiple simultaneous data updates and range queries. To achieve this, you are going to implement a Segment Tree, which is a powerful data structure suitable for such scenarios. Problem Statement Implement a Segment Tree that performs the following operations in O(log N) time: 1. **Build the tree** from an input array. 2. **Range Query**: Given a range [l, r], compute the result for that range using a commutative function. 3. **Update**: Update an element at a specified position in the array and adjust the tree accordingly. The segment tree must support a commutative function that takes two values and returns the same type value. Requirements 1. Implement the class `SegmentTree` with the following methods: - `__init__(self, arr: List[Any], function: Callable[[Any, Any], Any])`: Constructor to initialize the segment tree with the provided array and commutative function. - `update(self, p: int, v: Any) -> None`: Update the element at position `p` (0-based index) to value `v`. - `query(self, l: int, r: int) -> Any`: Perform a query for the range [l, r] (inclusive) and return the result. 2. **Input/Output Format**: - `__init__` takes an array and a function. - `update` takes an index and a new value. - `query` takes two indices and returns a value. Constraints: - The array will have a length of up to 10^5. - Elements in the array and function results will fit within standard Python integer/float ranges. Example: ```python # Example for range sum queries mytree = SegmentTree([2, 4, 5, 3, 4], lambda a, b: a + b) print(mytree.query(2, 4)) # Output: 12 (5 + 3 + 4) mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 17 (2 + 4 + 5 + 6) # Example for range max queries mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(0, 3)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 ``` Note: Do not reference any example code directly while solving the problem.","solution":"from typing import List, Callable, Any class SegmentTree: def __init__(self, arr: List[Any], function: Callable[[Any, Any], Any]): self.n = len(arr) self.function = function self.tree = [None] * (2 * self.n) # to hold the segment tree # Build the tree self.build(arr) def build(self, arr: List[Any]): # Initialize leaves nodes for i in range(self.n): self.tree[self.n + i] = arr[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, p: int, v: Any) -> None: # Update the value at leaf node p += self.n self.tree[p] = v # Update internal nodes i = p while i > 1: i //= 2 self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def query(self, l: int, r: int) -> Any: # Inclusive range query l += self.n r += self.n + 1 res = None while l < r: if l % 2: res = self.tree[l] if res is None else self.function(res, self.tree[l]) l += 1 if r % 2: r -= 1 res = self.tree[r] if res is None else self.function(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"# Scenario You have been tasked to implement a hash table for a school\'s enrollment system. This hash table will store student IDs as keys and their enrollment details as values. # Problem Implement a `ResizableHashTable` class with the following constraints and requirements: Requirements 1. **Dynamic Resizing**: The hash table should double in size when at least 2/3 of the slots are filled. 2. **Collision Resolution**: Use linear probing for collision resolution. 3. **Operations**: * `put(key, value)`: Insert or update the key-value pair. * `get(key)`: Retrieve the value for the provided key. * `del_(key)`: Delete the key-value pair. * Implement standard Python magic methods (`__getitem__`, `__setitem__`, `__delitem__`, `__len__`). Input Format * `put(key, value)`: `key` is a non-negative integer, and `value` is a string representing the student\'s enrollment details. * `get(key)`: `key` is a non-negative integer. * `del_(key)`: `key` is a non-negative integer. Output Format * `put(key, value)`: None * `get(key)`: Return enrollment details string if found, None otherwise. * `del_(key)`: None * Magic methods should follow the expected behavior with corresponding operations. Constraints * The system should handle up to 10,000 students initially but must be capable of dynamically resizing to handle more records. * The hash table should provide average-case O(1) time complexity for the provided operations. Example ```python # Initialize table = ResizableHashTable() # Insert students table.put(1021, \\"John Doe - Math101, Physics102\\") table.put(2022, \\"Jane Smith - Chem101, Bio202\\") # Retrieve student details print(table.get(1021)) # John Doe - Math101, Physics102 # Delete a student table.del_(1021) print(table.get(1021)) # None ``` Write the complete implementation of the `ResizableHashTable` class with detailed comments explaining its logic.","solution":"class ResizableHashTable: def __init__(self, initial_capacity=16): self.capacity = initial_capacity self.size = 0 self.table = [None] * self.capacity def _hash(self, key): return key % self.capacity def _resize(self): old_table = self.table self.capacity *= 2 self.size = 0 self.table = [None] * self.capacity for item in old_table: if item is not None: self.put(item[0], item[1]) def _probe(self, key): index = self._hash(key) while self.table[index] is not None and self.table[index][0] != key: index = (index + 1) % self.capacity return index def put(self, key, value): if self.size + 1 > 2 * self.capacity // 3: self._resize() index = self._probe(key) if self.table[index] is None: self.size += 1 self.table[index] = (key, value) def get(self, key): index = self._probe(key) if self.table[index] is None: return None return self.table[index][1] def del_(self, key): index = self._probe(key) if self.table[index] is not None: self.table[index] = None self.size -= 1 self._rehash(index) def _rehash(self, start_index): index = (start_index + 1) % self.capacity while self.table[index] is not None: key, value = self.table[index] self.table[index] = None self.size -= 1 self.put(key, value) index = (index + 1) % self.capacity def __getitem__(self, key): return self.get(key) def __setitem__(self, key, value): self.put(key, value) def __delitem__(self, key): self.del_(key) def __len__(self): return self.size"},{"question":"Design and implement a function `quick_sort(arr)` that sorts an array of integers using the Quick Sort algorithm. The function should utilize an optimized pivot selection strategy and should handle both best and worst-case scenarios efficiently. # Function Signature ```python def quick_sort(arr: List[int]) -> List[int]: ``` # Input - `arr` (List[int]): A list of integers to sort. The list will have at most 10,000 elements. # Output - Returns a new list containing the elements of `arr` sorted in non-decreasing order. # Constraints - You should implement the quick sort algorithm using an optimised pivot selection strategy. - You must avoid excessive stack depth for recursive calls. # Requirements - The implemented sorting algorithm should demonstrate an average-case time complexity of O(n log n). - The solution should handle edge cases such as arrays with duplicate elements and already sorted arrays. # Example - Input: `[3, 6, 8, 10, 1, 2, 1]` - Output: `[1, 1, 2, 3, 6, 8, 10]` - Input: `[3, -1, 0, 1, 2, 1]` - Output: `[-1, 0, 1, 1, 2, 3]` # Notes - Your implementation will be assessed on both correctness (it sorts the array correctly) and performance (it handles large inputs efficiently). - Pay special attention to handling edge cases and optimizing the pivot selection to ensure the performance of your quick sort implementation.","solution":"from typing import List def quick_sort(arr: List[int]) -> List[int]: Sorts the list of integers using the Quick Sort algorithm with an optimized pivot selection. if len(arr) <= 1: return arr def partition(low, high): pivot_index = (low + high) // 2 pivot = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] i = low for j in range(low, high): if arr[j] < pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[high] = arr[high], arr[i] return i def quick_sort_helper(low, high): if low < high: pi = partition(low, high) quick_sort_helper(low, pi - 1) quick_sort_helper(pi + 1, high) quick_sort_helper(0, len(arr) - 1) return arr"},{"question":"# Remove Duplicates from a Linked List # Objective: Design a function to remove duplicates from a given singly linked list. You will be implementing both the hash set approach and the nested traversal approach as described. # Instructions: 1. Implement the function `remove_dups_set(head)` which removes duplicates using a HashSet. 2. Implement the function `remove_dups_no_set(head)` which removes duplicates without using any extra space. 3. Verify both functions using the provided linked list node definitions and the print function. # Function Definitions: - Function 1: `remove_dups_set(head: Node) -> None` - **Input**: The head node of the linked list. - **Output**: None (modifies the list in place). - Function 2: `remove_dups_no_set(head: Node) -> None` - **Input**: The head node of the linked list. - **Output**: None (modifies the list in place). # Constraints: - The linked list contains nodes with string values. - The list can be of any length within reasonable bounds (1 ≤ length ≤ 10^4). # Example: ```python # Linked List: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_dups_set(a1) print_linked_list(a1) # Expected Output: A -> B -> C -> D -> F -> G remove_dups_no_set(a1) print_linked_list(a1) # Expected Output: A -> B -> C -> D -> F -> G ``` # Expected Solutions: You will need to implement class `Node` and the linked list functions as described. The list provided in the example should be free of duplicates after both functions are executed.","solution":"class Node: def __init__(self, value): self.value = value self.next = None def remove_dups_set(head): Removes duplicates from a linked list using a hash set. if not head: return current = head seen = set([current.value]) while current.next: if current.next.value in seen: current.next = current.next.next else: seen.add(current.next.value) current = current.next def remove_dups_no_set(head): Removes duplicates from a linked list without using extra space. current = head while current: runner = current while runner.next: if runner.next.value == current.value: runner.next = runner.next.next else: runner = runner.next current = current.next def print_linked_list(head): Utility function to print out the linked list. values = [] current = head while current: values.append(current.value) current = current.next print(\\" -> \\".join(values))"},{"question":"Imagine you are developing a component for a database engine that provides efficient iteration over records stored in a binary search tree (BST). Implement a `BSTIterator` class supporting the following operations: 1. `__init__(self, root)`: Initialize the iterator object with the root node of the BST. 2. `has_next(self) -> bool`: Return True if there is a next element available in the in-order traversal of the BST, otherwise False. 3. `next(self) -> int`: Return the next smallest element in the in-order traversal of the BST. # Constraints: - Nodes of the BST will have unique integer values. - Number of nodes in the BST will be in the range `[0, 10^4]`. # Input: - The `root` of a binary search tree. # Output: - For `has_next()`, return a boolean. - For `next()`, return an integer. # Example: ```python # Assuming the following BST: # 7 # / # 3 15 # / # 9 20 root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) iterator = BSTIterator(root) print(iterator.next()) # returns 3 print(iterator.next()) # returns 7 print(iterator.has_next()) # returns True print(iterator.next()) # returns 9 print(iterator.has_next()) # returns True print(iterator.next()) # returns 15 print(iterator.has_next()) # returns True print(iterator.next()) # returns 20 print(iterator.has_next()) # returns False ``` # Note: - You are not allowed to use a list to store the in-order traversal for your iterator. - Your implementation should be able to handle large BSTs efficiently. The `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): Helper function that adds the nodes along the leftmost branch of the root to the stack. while root: self.stack.append(root) root = root.left def has_next(self) -> bool: Returns True if there is a next smallest number in the BST return len(self.stack) > 0 def next(self) -> int: Returns the next smallest number in the BST # The top of the stack is the next smallest element topmost_node = self.stack.pop() # If the node has a right child, we add the leftmost branch of the right child to the stack if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"You work for a company that transmits lists of strings over a network. Your task is to design an encoding scheme for these lists that ensures they can be transmitted as a single string and then decoded back to the original list. Function Requirements 1. **Encoding Function**: * **Function Name**: `encode` * **Input**: List of strings (`List[str]`). * **Output**: A single encoded string (`str`). * **Description**: Creates an encoded string where each original string is prefixed with its length and a colon. 2. **Decoding Function**: * **Function Name**: `decode` * **Input**: Encoded string (`str`). * **Output**: List of strings (`List[str]`). * **Description**: Converts the encoded string back into the original list of strings. Constraints * The input list can contain between 0 and 10^4 strings. * Each string can have a length ranging from 0 to 10^4 characters. Your implementation should handle all edge cases gracefully, including but not limited to empty lists and strings containing special characters. Example ```python # Example usage: original_list = [\\"hello\\", \\"world\\", \\"\\", \\"Python:3.8\\"] encoded_string = encode(original_list) print(encoded_string) # Expected: \\"5:hello5:world0:7:Python:3.8\\" decoded_list = decode(encoded_string) print(decoded_list) # Expected: [\\"hello\\", \\"world\\", \\"\\", \\"Python:3.8\\"] ``` Additional Notes * The delimiter character \':\' is used to separate the length and the string, and it should be handled properly to avoid conflicts with its occurrence in the strings. * Minimizing the processing time is essential, so ensure the solution efficiently reads and writes characters.","solution":"def encode(strs): Encodes a list of strings to a single string. Parameters: strs (List[str]): List of strings to encode Returns: str: Encoded string encoded_str = \\"\\" for s in strs: encoded_str += f\\"{len(s)}:{s}\\" return encoded_str def decode(s): Decodes a single string to a list of strings. Parameters: s (str): Encoded string Returns: List[str]: Decoded list of strings i = 0 strs = [] while i < len(s): # find the length delimiter j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 strs.append(s[i:i + length]) i += length return strs"},{"question":"Context You are tasked with generating all possible permutations of a given list of distinct integers. Understanding permutations is crucial for solving complex problems that require exploring all potential arrangements. Problem Statement Write a function `generate_permutations(numbers: List[int]) -> List[List[int]]` that takes a list of distinct integers and returns a list of permutations, where each permutation is also a list of integers. Expected Input and Output * **Input**: A list of distinct integers, e.g., `[1, 2, 3]`. * **Output**: A list of lists, where each inner list is a permutation of the input list `[1, 2, 3]`. Should return: ```python [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] ``` Constraints * The maximum length of the input list will be 8. * The elements of the input list will be unique and in the range from -10 to 10. Performance Requirements * The function should handle the worst-case scenario of a list of length 8 efficiently within a reasonable time frame. Function Signature ```python from typing import List def generate_permutations(numbers: List[int]) -> List[List[int]]: pass ``` Example ```python assert generate_permutations([1, 2, 3]) == [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] assert generate_permutations([0, 1]) == [ [0, 1], [1, 0] ] assert generate_permutations([1]) == [ [1] ] ```","solution":"from typing import List from itertools import permutations def generate_permutations(numbers: List[int]) -> List[List[int]]: Generates all possible permutations of a list of distinct integers. :param numbers: List of distinct integers. :return: List of lists, where each inner list is a permutation. return [list(p) for p in permutations(numbers)]"},{"question":"# Context You are tasked with designing a system that converts sorted integer arrays into height-balanced Binary Search Trees (BST). Given the nature of the sorted array, the system must ensure that the resultant BST maintains the property of minimal height to optimize search operations. # Problem Write a function `sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]` where: - `nums` is a list of integers sorted in ascending order. - The function returns the root node of a height-balanced BST. # Input - A list of integers `nums` where: - 0 <= `len(nums)` <= 10^4 - -10^4 <= `nums[i]` <= 10^4 for all 0 <= `i` < `len(nums)` # Output - The root node of a height-balanced BST. # Constraints - Your solution should be optimally efficient in both time and space. - You may assume duplicates do not exist in the input array. # Example 1. `sorted_array_to_bst([-10, -3, 0, 5, 9])` should create the following BST: ``` 0 / -10 5 -3 9 ``` 2. `sorted_array_to_bst([])` should return `None`. 3. `sorted_array_to_bst([1])` should return a single node tree with `1`. # Implementation Notes - Ensure to handle edge cases such as empty arrays and single-element arrays. - Consider the balance requirement of the tree while choosing the middle element.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]: Converts a sorted array to a height-balanced BST. if not nums: return None def convert(left: int, right: int) -> Optional[TreeNode]: if left > right: return None mid = (left + right) // 2 node = TreeNode(nums[mid]) node.left = convert(left, mid - 1) node.right = convert(mid + 1, right) return node return convert(0, len(nums) - 1)"},{"question":"# Objective Design and implement a class for polynomials that supports basic arithmetic operations and some advanced features. Your class should be able to handle monomials and perform polynomial operations such as addition, subtraction, multiplication, and division. # Problem Statement Imagine you are working on a symbolic algebra software. You need to implement a polynomial class which can handle algebraic operations and manipulations efficiently. # Task Implement a `Polynomial` class with the following methods: 1. **Addition**: `(Polynomial.__add__(self, other))`, which takes another polynomial and returns the sum. 2. **Subtraction**: `(Polynomial.__sub__(self, other))`, which takes another polynomial and returns the difference. 3. **Multiplication**: `(Polynomial.__mul__(self, other))`, which takes another polynomial or a constant and returns the product. 4. **Division**: `(Polynomial.__truediv__(self, other))`, which takes a non-zero monomial and returns the quotient. 5. **Substitution**: `(Polynomial.subs(self, substitutions))`, which takes a dictionary of variable substitutions and returns the numeric result after substituting the values into the polynomial. # Input Format - For addition, subtraction operations: another polynomial. - For multiplication: another polynomial or a constant (int, float, or Fraction). - For division: a non-zero monomial represented as a `Monomial` object. - For substitution: a dictionary where keys are variable indices and values are their corresponding numeric values. # Output Format - For arithmetic operations: Return the resulting `Polynomial` object. - For substitution: Return the numeric result as `Fraction`. # Constraints 1. Variables in monomials are represented as non-negative integers to denote different variables. 2. Coefficients can be integers, floats, or `fractions.Fraction`. 3. Operations should raise appropriate errors for incompatible or invalid inputs. 4. Polynomial and monomial classes should properly handle edge cases like zero coefficients and empty monomials. # Example ```python # Example usage: # Construct monomials mon1 = Monomial({1:3, 2:2}, 12) mon2 = Monomial({2:3, 3:-1}, 1.5) # Construct polynomials poly1 = Polynomial([mon1, mon2]) poly2 = Polynomial([Monomial({1:1}, 2), Monomial({2:1}, 3)]) # Add polynomials result = poly1 + poly2 print(result) # Output a string representation of the resulting polynomial # Multiply polynomial by a constant result = poly1 * 2 print(result) # Output a string representation of the resulting polynomial # Substitute variables result = poly1.subs({1: 2, 2: 3}) print(result) # Output the numeric result after substitution ``` # Additional Information - Ensure code is well-documented with proper docstrings and comments. - Include error handling for invalid operations (e.g., division by zero monomial).","solution":"from fractions import Fraction from collections import defaultdict class Monomial: def __init__(self, vars, coeff=1): self.vars = {v: exp for v, exp in vars.items() if exp != 0} # Filter out zero exponents self.coeff = Fraction(coeff) def __mul__(self, other): assert isinstance(other, (Monomial, int, float, Fraction)), \\"Can only multiply by monomial or scalar\\" if isinstance(other, Monomial): new_vars = self.vars.copy() for var, exp in other.vars.items(): new_vars[var] = new_vars.get(var, 0) + exp # Add the exponents return Monomial(new_vars, self.coeff * other.coeff) else: return Monomial(self.vars, self.coeff * Fraction(other)) def __truediv__(self, other): assert isinstance(other, Monomial) and other.coeff != 0, \\"Can only divide by non-zero monomial\\" new_vars = self.vars.copy() for var, exp in other.vars.items(): new_vars[var] = new_vars.get(var, 0) - exp # Subtract the exponents return Monomial(new_vars, self.coeff / other.coeff) def __str__(self): vars_str = \'\'.join([f\\"X{v}^{exp}\\" if exp != 1 else f\\"X{v}\\" for v, exp in sorted(self.vars.items())]) coeff_str = f\\"{self.coeff}\\" if self.coeff != 1 or not vars_str else \\"\\" return f\\"{coeff_str}{vars_str}\\" def __eq__(self, other): return self.vars == other.vars and self.coeff == other.coeff class Polynomial: def __init__(self, monomials=None): self.monomials = monomials if monomials else [] def __add__(self, other): assert isinstance(other, Polynomial), \\"Can only add another polynomial\\" return Polynomial(self.monomials + other.monomials) def __sub__(self, other): assert isinstance(other, Polynomial), \\"Can only subtract another polynomial\\" negated_monomials = [Monomial(m.vars, -m.coeff) for m in other.monomials] return Polynomial(self.monomials + negated_monomials) def __mul__(self, other): if isinstance(other, (int, float, Fraction)): return Polynomial([Monomial(m.vars, m.coeff * other) for m in self.monomials]) elif isinstance(other, Polynomial): result = [] for m1 in self.monomials: for m2 in other.monomials: result.append(m1 * m2) return Polynomial(result) else: raise TypeError(\\"Can only multiply by a constant or another polynomial\\") def __str__(self): return \' + \'.join([str(m) for m in self.monomials]) def subs(self, substitutions): result = Fraction(0) for monomial in self.monomials: term_value = monomial.coeff for var, exp in monomial.vars.items(): if var in substitutions: term_value *= substitutions[var] ** exp else: term_value = 0 break result += term_value return result def gcd(x, y): while y: x, y = y, x % y return x def lcm(x, y): return x * y // gcd(x, y)"},{"question":"Scenario You are on a research team tasked with designing a control system for autonomous drones. Each drone can receive movement commands to navigate a grid. Your task is to ensure that a series of move commands will predict whether the drone will return to its start position. A drone starts at the origin point (0, 0) on a 2D grid. Given a sequence of its moves, determine if the drone returns to its original starting position after executing all moves. The movements are represented by a string consisting of characters: \'R\' (Right), \'L\' (Left), \'U\' (Up), and \'D\' (Down). The function should return `true` if the sequence returns the drone to the origin point, and `false` otherwise. Function Signature ```python def does_drone_return(moves: str) -> bool: pass ``` Input * `moves`: A string representing the series of moves the drone makes. (1 ≤ len(moves) ≤ 10^4) Output * Returns a boolean: `true` if the drone returns to its starting place, otherwise `false`. Examples 1. Input: \\"UD\\" Output: `True` 2. Input: \\"LL\\" Output: `False` 3. Input: \\"\\" Output: `True` 4. Input: \\"UDLR\\" Output: `True` Constraints * The input string will only contain characters \'U\', \'D\', \'L\' and \'R\'. Notes * Consider all edge cases, including an empty move string, which should return `True` since the drone never moves away from its start position. * Pay attention to the implementation to ensure efficiency with respect to time and space complexity.","solution":"def does_drone_return(moves: str) -> bool: Determines if the drone returns to the starting position after a series of movements. Arguments: moves -- A string containing movements \'R\', \'L\', \'U\', and \'D\'. Returns: True if the drone returns to the starting position, False otherwise. # Initialize the coordinates of the drone x, y = 0, 0 # Process each move for move in moves: if move == \'R\': x += 1 elif move == \'L\': x -= 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 # Check if the drone is back at the starting position return x == 0 and y == 0"},{"question":"Directed Graph Cycle Detection # Objective Given the data structure provided, you are tasked with detecting if there is any cycle in the graph. # Problem Statement Write a function `has_cycle(self)` for the `DirectedGraph` class that checks if there is any cycle in the directed graph. # Input & Output * **Input**: No input parameters. * **Output**: Return `True` if there is a cycle in the graph, otherwise return `False`. # Constraints * The graph can have up to (10^5) nodes and edges. * Assume nodes and edges are valid as per the given classes. # Example ```python graph_data = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"], } graph = DirectedGraph(graph_data) print(graph.has_cycle()) # Output: True graph_data = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [], } graph = DirectedGraph(graph_data) print(graph.has_cycle()) # Output: False ``` # Hints * Consider using Depth-First Search (DFS) for cycle detection. * Maintain a set of visited nodes and a recursion stack to detect back edges indicating cycles. # Note * Make sure to handle graphs with multiple disconnected subgraphs. * Avoid modifying the provided classes (`Node`, `DirectedEdge`, `DirectedGraph`).","solution":"class DirectedGraph: def __init__(self, graph): self.graph = graph def has_cycle(self): Returns True if there is a cycle in the graph, otherwise False. visited = set() rec_stack = set() def dfs(node): if node in rec_stack: return True if node in visited: return False visited.add(node) rec_stack.add(node) for neighbor in self.graph.get(node, []): if dfs(neighbor): return True rec_stack.remove(node) return False for node in self.graph: if dfs(node): return True return False"},{"question":"**Question: Implement a Segment Tree for Range Minimum Queries** You are given an array of integers. Your task is to implement a Segment Tree that supports the following operations: 1. **Build**: Construct the segment tree from the given array. 2. **Query**: Answer the range minimum query, i.e., find the minimum element in a specified range of the array. # Input: - The first line of input contains the integer `N` (1 ≤ N ≤ 10^5) representing the number of elements in the array. - The next line contains `N` space-separated integers representing the elements of the array. - The following line contains an integer `Q` (1 ≤ Q ≤ 10^5) representing the number of queries. - Each of the next `Q` lines contains two space-separated integers `L` and `R` (0 ≤ L ≤ R < N) representing a range for the minimum query. # Output: - For each query, output the minimum element in the range `[L, R]`. # Constraints: - The array contains integers ranging from `-10^9` to `10^9`. - You need to ensure your solutions are efficient and work within the constraints. # Example: Input: ``` 5 2 4 5 3 4 3 1 3 0 4 2 4 ``` Output: ``` 3 2 3 ``` # Implementation Hints: - Use the Segment Tree data structure to handle the efficient range minimum queries. - Follow the principles given in the analysis, ensuring your solution efficiently constructs the tree and answers the queries.","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr): # Initialize leaves in the tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the segment tree by filling up the nodes for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, pos, value): # Update the value at the leaf node pos += self.n self.tree[pos] = value # Update the rest of the tree while pos > 1: pos //= 2 self.tree[pos] = min(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, left, right): # Query for the minimum value in the range [left, right] left += self.n right += self.n result = float(\'inf\') while left <= right: if left % 2 == 1: result = min(result, self.tree[left]) left += 1 if right % 2 == 0: result = min(result, self.tree[right]) right -= 1 left //= 2 right //= 2 return result"},{"question":"**Context**: You are working on a legacy system that extensively uses stacks for different processing tasks. Recently, you have been instructed to write a custom function to manipulate stacks in a specific way to support new business requirements. One common manipulation is switching successive pairs of elements in a stack. If the stack has an odd number of elements, the element at the top should remain in the same position after the switch. Task Write a function called `switch_pairs_in_stack` that performs this operation using an auxiliary stack or queue. Function Signature ```python def switch_pairs_in_stack(stack: list) -> list: ``` Expected Input and Output * **Input**: A list named `stack` representing the stack where the first element is the bottom of the stack and the last element is the top of the stack. * **Output**: Return the modified stack with successive pairs of elements switched. If the stack has an odd number of elements, the last element remains unchanged. Constraints * The function should handle stacks of different sizes including empty stacks. * You are not allowed to use any library functions that directly solve the problem. * Your implementation should aim to be efficient concerning time and space complexity. Example ```python assert switch_pairs_in_stack([3, 8, 17, 9, 1, 10]) == [8, 3, 9, 17, 10, 1] assert switch_pairs_in_stack([3, 8, 17, 9, 1]) == [8, 3, 9, 17, 1] assert switch_pairs_in_stack([]) == [] assert switch_pairs_in_stack([10]) == [10] ``` Performance Requirements * The function should run in O(n) time complexity where n is the number of elements in the stack. * The space complexity should also be O(n). Notes Make sure your implementation adheres to the stack operations and mimics their behavior closely.","solution":"def switch_pairs_in_stack(stack: list) -> list: if len(stack) < 2: return stack aux_stack = [] # Reverse the stack into the auxiliary stack while stack: aux_stack.append(stack.pop()) # Perform the pair switching while len(aux_stack) > 1: first = aux_stack.pop() second = aux_stack.pop() stack.append(second) stack.append(first) # If there\'s an odd number of elements, put the last element back if aux_stack: stack.append(aux_stack.pop()) return stack"},{"question":"# Implementing and Extending Queue Functionalities Context As a software engineer, you are working on the backend system of a task management application. The application tasks need to be managed using the queue data structure that you study in your classes. You need to extend the current implementations of a queue in two ways: 1. Add functionality to reverse the order of elements in both ArrayQueue and LinkedListQueue. 2. Implement a priority queue using a heap. Requirements 1. **Reverse Method**: * **Input**: No explicit input, but the method will operate on the queue\'s internal state. * **Output**: The queue should be reversed in place. * **Constraints**: Use only the methods and attributes of the class for each queue implementation. 2. **Priority Queue Implementation**: * **Input**: Elements with integer priority (lower number indicates higher priority). * **Output**: Standard FIFO operations, but dequeue should return the element with the highest priority available. * **Constraints**: Use a heap for managing the internal state to ensure efficient priority-based operations. # Example: For both queue implementations: * Reversing `1 -> 2 -> 3` results in `3 -> 2 -> 1`. * For priority queue, inserting (3, \'A\'), (1, \'B\'), (2, \'C\') should dequeue \'B\' then \'C\' then \'A\'. # Task **Part A:** 1. Extend `ArrayQueue` with a `reverse` method. 2. Extend `LinkedListQueue` with a `reverse` method. **Part B:** Implement a `PriorityQueue` class with the following methods: * `enqueue(value, priority)` - Adds an element with a given priority. * `dequeue()` - Removes and returns the element with the highest priority. * `peek()` - Returns the element with the highest priority without removing it.","solution":"class ArrayQueue: def __init__(self): self.queue = [] def enqueue(self, value): self.queue.append(value) def dequeue(self): if not self.is_empty(): return self.queue.pop(0) def is_empty(self): return len(self.queue) == 0 def reverse(self): self.queue.reverse() class LinkedListQueue: class Node: def __init__(self, value=None): self.value = value self.next = None def __init__(self): self.head = self.tail = None def enqueue(self, value): new_node = self.Node(value) if self.tail is not None: self.tail.next = new_node self.tail = new_node if self.head is None: self.head = new_node def dequeue(self): if self.is_empty(): return None value = self.head.value self.head = self.head.next if self.head is None: self.tail = None return value def is_empty(self): return self.head is None def reverse(self): prev = None current = self.head self.tail = self.head while current is not None: next_node = current.next current.next = prev prev = current current = next_node self.head = prev import heapq class PriorityQueue: def __init__(self): self.heap = [] def enqueue(self, value, priority): heapq.heappush(self.heap, (priority, value)) def dequeue(self): if not self.is_empty(): return heapq.heappop(self.heap)[1] def peek(self): if not self.is_empty(): return self.heap[0][1] def is_empty(self): return len(self.heap) == 0"},{"question":"Factor Combinations Finder Context & Objective In mathematical computations and certain cryptographic applications, breaking down an integer into its constituent factors can be crucial. Given a number `n`, your task is to write a function that returns all possible combinations of its factors, ensuring that each combination (product sequence) appears exactly once. Problem Statement Write a function named `find_factor_combinations` which takes an integer `n` and returns a list of lists, where each sublist contains the factors of `n` in ascending order. Function Signature ```python def find_factor_combinations(n: int) -> List[List[int]]: pass ``` Input - An integer `n` (1 ≤ n ≤ 10^6). Output - A list of lists of integers representing the factor combinations of `n`. Constraints - Factors should be greater than 1 and less than `n`. - Each combination must be unique and sorted in non-descending order. Example Scenarios: # Example 1: ```python input: 1 output: [] # Since 1 has no factors greater than 1 and less than 1. ``` # Example 2: ```python input: 37 output: [] # Since 37 is a prime number, it has no factors within the given range. ``` # Example 3: ```python input: 12 output: [ [2, 6], [2, 2, 3], [3, 4] ] # Possible combinations of factors of 12 are listed above. ``` # Example 4: ```python input: 32 output: [ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8] ] # All possible unique combinations of factors of 32. ``` Performance Requirements - Your implementation should handle the upper constraint efficiently to provide optimal results within a reasonable time frame. Note Consider edge cases such as when `n` = 1, prime numbers, and large numbers to ensure your implementation handles them correctly.","solution":"from typing import List def find_factor_combinations(n: int) -> List[List[int]]: Returns all unique combinations of factors for a given integer n. def backtrack(start, target, path): if target == 1: if len(path) > 1: result.append(path[:]) return for i in range(start, target + 1): if target % i == 0: path.append(i) backtrack(i, target // i, path) path.pop() result = [] backtrack(2, n, []) return result"},{"question":"# Question: Implement Cycle Sort Context: You work in a hardware design company where EEPROM memory units are limited to a finite number of write operations before they become unusable. In such a context, you need to design an in-place sorting algorithm with the minimal number of writes to the memory. Objective: Implement the Cycle Sort algorithm to sort an array of integers efficiently in-place. Task: Write a function `cycle_sort(arr)` that takes: - `arr`: A list of integers. The function should return the sorted version of `arr` without using any auxiliary space (i.e., sorting should be in-place). Constraints: - 1 <= len(arr) <= 10^3 - -10^5 <= arr[i] <= 10^5 Input: - A single list of integers. Output: - A single list of integers, sorted in ascending order. Example: ```python >>> cycle_sort([3, 1, 4, 1, 5]) [1, 1, 3, 4, 5] >>> cycle_sort([10, 7, 8, 9, 1, 5]) [1, 5, 7, 8, 9, 10] ``` Requirements: - Your solution should have an average and worst-case time complexity of (O(N^2)). - The solution should be in-place, using (O(1)) additional space. - Carefully handle any duplicate elements in the input array.","solution":"def cycle_sort(arr): In-place Cycle Sort function to sort a list of integers writes = 0 for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find where to put the item. pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Skip duplicate elements while item == arr[pos]: pos += 1 # Put the item to the right position if pos != cycle_start: arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 if item != arr[pos]: arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Nearest Neighbor Classifier You are provided with a dataset of points in a multidimensional space, each point having a label. Your task is to implement a function using the Nearest Neighbor algorithm to classify a given point. Function Signature ```python def classify_point(point: tuple, dataset: dict) -> any: ``` Input - **point**: A tuple representing the coordinates of the point to classify. - **dataset**: A dictionary where keys are tuples representing coordinates of points in the training set, and values are labels (can be of any type, strings, numbers, etc.) Output - Return the label of the dataset point that is nearest to the given point based on Euclidean distance. Constraints - The input point and all points in the dataset must have the same number of dimensions. - The dataset must not be empty. - All coordinate values are numerical (int or float). Example ```python point = (2, 4) dataset = {(1, 2): \'A\', (3, 4): \'B\', (5, 6): \'C\'} classify_point(point, dataset) ``` Output: \'B\' Explanation In this example, the Euclidean distances are: - Distance between (2, 4) and (1, 2) is sqrt((2-1)^2 + (4-2)^2) = sqrt(1 + 4) = sqrt(5) - Distance between (2, 4) and (3, 4) is sqrt((2-3)^2 + (4-4)^2) = sqrt(1 + 0) = sqrt(1) - Distance between (2, 4) and (5, 6) is sqrt((2-5)^2 + (4-6)^2) = sqrt(9 + 4) = sqrt(13) The minimum distance is sqrt(1), hence the point (2, 4) is closest to (3, 4) with label \'B\'. # Performance Requirement Your implementation should aim to minimize computation, particularly if the dataset is large.","solution":"import math def classify_point(point: tuple, dataset: dict) -> any: Classify the given point based on the nearest neighbor approach using Euclidean distance. :param point: A tuple representing the coordinates of the point to classify. :param dataset: A dictionary where keys are tuples representing coordinates of points in the training set, and values are labels. :return: The label of the nearest neighbor point. def euclidean_distance(p1, p2): return math.sqrt(sum((a - b) ** 2 for a, b in zip(p1, p2))) nearest_point = min(dataset.keys(), key=lambda pt: euclidean_distance(point, pt)) return dataset[nearest_point]"},{"question":"# Question: Implement RSA Key Pair Generation with Optimized Prime Testing. The RSA algorithm provided includes simple prime testing and modular inverse calculations which may not be efficient for large bit sizes. Your task is to enhance the RSA key generation function for improved performance. Part 1: Optimized Prime Testing Replace the given `is_prime` function with a more efficient probabilistic algorithm such as the Miller-Rabin primality test. Part 2: Modular Inverse Calculation Modify the `modinv` function to use the Extended Euclidean Algorithm for efficiency. Function Specification Implement the following functions: ```python def optimized_generate_key(k, seed=None): Optimized RSA key generating algorithm. k: Number of bits in n seed: Optional seed for reproducibility of the random number generator Returns: (n, e, d): Tuple of RSA modulus and exponent pairs # Implement optimizations here def miller_rabin_test(n, k: int) -> bool: Miller-Rabin primality test. n: the number to be tested for primality k: number of testing rounds for accuracy Returns: True if n is likely prime, False if composite # Implement test here def extended_gcd(a, b): Helper function for Extended Euclidean Algorithm. Returns: coefficients and gcd of a and b def modinv_optimized(a, m): Calculate the modular inverse of a mod m using the Extended Euclidean Algorithm ``` Constraints 1. `k` will be at least 8 and at most 1024 (representing bit length of RSA modulus `n`). 2. Use a minimum of 5 rounds for the Miller-Rabin primality test. 3. Assume prime number generation should return numbers such that `2^k-1` < prime number < `2^k` for the bit size requested. 4. Efficient prime number generation and key computation must be achieved within reasonable time constraints. Input and Output Formats * Input: Single integer `k` representing the number of bits for key generation. * Output: A tuple `(n, e, d)` representing modulus and exponent pairs. Example ```python n, e, d = optimized_generate_key(16) # Produces a 16-bit RSA key pair # Verify the key functionality data = 20 encrypted = pow(data, e, n) decrypted = pow(encrypted, d, n) assert decrypted == data ``` Note: - Review edge cases for very small keys to ensure robustness. - Pay special attention to performance with larger keys (256 bits and above).","solution":"import random def miller_rabin_test(n, k: int) -> bool: Miller-Rabin primality test. n: the number to be tested for primality k: number of testing rounds for accuracy Returns: True if n is likely prime, False if composite if n in (2, 3): return True if n <= 1 or n % 2 == 0: return False # Write n-1 as 2^r * d r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 # Witness loop def check_composite(a): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True for _ in range(k): a = random.randrange(2, n - 1) if check_composite(a): return False return True def generate_large_prime(bits, k=40): Generates a large prime number approximately \'bits\' bits in size. bits: Size of the prime number in bits. k: number of rounds for the Miller-Rabin test for accuracy. while True: candidate = random.getrandbits(bits) candidate |= (1 << bits - 1) | 1 # Ensure the candidate is odd and has the maximum bit set if miller_rabin_test(candidate, k): return candidate def extended_gcd(a, b): Helper function for Extended Euclidean Algorithm. Returns: coefficients and gcd of a and b x0, x1, y0, y1 = 1, 0, 0, 1 while b != 0: q, a, b = a // b, b, a % b x0, x1 = x1, x0 - q * x1 y0, y1 = y1, y0 - q * y1 return x0, y0, a def modinv_optimized(a, m): Calculate the modular inverse of a mod m using the Extended Euclidean Algorithm x, y, g = extended_gcd(a, m) if g != 1: raise ValueError(\'Modular inverse does not exist\') return x % m def optimized_generate_key(k, seed=None): Optimized RSA key generating algorithm. k: Number of bits in n seed: Optional seed for reproducibility of the random number generator Returns: (n, e, d): Tuple of RSA modulus and exponent pairs if seed is not None: random.seed(seed) # Generate two large primes p and q bit_size = k // 2 p = generate_large_prime(bit_size) q = generate_large_prime(bit_size) n = p * q phi = (p - 1) * (q - 1) e = 65537 d = modinv_optimized(e, phi) return n, e, d"},{"question":"# Quick Sort Implementation & Optimization Context You are working on an analytics tool that handles large datasets. Efficiency is crucial given that you sometimes work with millions of records. While Quick Sort is generally efficient, it can degrade to O(n^2) based on pivot choices. Our goal is to optimize the Quick Sort implementation to ensure robust performance across various datasets. Task Implement a function `optimized_quick_sort` that sorts an array of integers using Quick Sort. To improve against worst-case scenarios, use median-of-three as a pivot selection strategy. Function Signature ```python def optimized_quick_sort(arr: list, simulation: bool=False) -> list: pass ``` Input - `arr`: A list of integers to be sorted. The list can be of any length, including empty. - `simulation`: (Optional) A boolean flag. If `True`, the function should print the current state of the list at each top-level recursion for demonstration purposes. Output - Returns a new list with the integers sorted in non-decreasing order. Constraints - Do not use built-in sort functions. - Function should be optimized against worst-case scenarios using median-of-three for pivot selection. - Aim for average time complexity of O(n log n). Prototype for Helper Functions You might need helper functions such as: - Median-of-three pivot selection - Recursive Quick Sort function - Partition function Make sure to consider edge cases and provide appropriate handling to ensure your implementation is robust. Test your function with various datasets including but not limited to: - An already sorted list - A reverse-sorted list - A list of identical elements - A list with a large number of elements","solution":"def median_of_three(arr, low, high): mid = (low + high) // 2 a, b, c = arr[low], arr[mid], arr[high] if a > b: if a < c: median = low elif b > c: median = mid else: median = high else: if b < c: median = mid elif a > c: median = low else: median = high return median def partition(arr, low, high): pivot_index = median_of_three(arr, low, high) arr[pivot_index], arr[low] = arr[low], arr[pivot_index] pivot = arr[low] left = low + 1 right = high while True: while left <= right and arr[left] <= pivot: left += 1 while left <= right and arr[right] >= pivot: right -= 1 if left <= right: arr[left], arr[right] = arr[right], arr[left] else: break arr[low], arr[right] = arr[right], arr[low] return right def _quick_sort(arr, low, high, simulation): if low < high: pi = partition(arr, low, high) if simulation: print(f\\"Current state (pivot at index {pi}): {arr}\\") _quick_sort(arr, low, pi - 1, simulation) _quick_sort(arr, pi + 1, high, simulation) def optimized_quick_sort(arr: list, simulation: bool=False) -> list: if len(arr) <= 1: return arr arr_copy = arr[:] _quick_sort(arr_copy, 0, len(arr_copy) - 1, simulation) return arr_copy"},{"question":"**Objective**: Demonstrate understanding of recursive algorithms and binary search trees. **Scenario**: You\'re tasked with implementing a function that converts a sorted array into a height-balanced binary search tree (BST). A height-balanced BST is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one. # Expected Input and Output **Function Signature**: ```python def array_to_bst(nums: List[int]) -> Optional[TreeNode]: pass ``` **Input**: - `nums` (List[int]): A list of integers sorted in ascending order. The list can be empty. **Output**: - Returns the root node of the height-balanced BST. **Constraints**: - The elements in the input array are unique. - The length of the input array will not exceed 10^4. # Example 1. **Input**: `nums = [-10, -3, 0, 5, 9]` - **Output**: A height-balanced BST. - Example Structure: ``` 0 / -3 9 / / -10 5 ``` 2. **Input**: `nums = [1, 3]` - **Output**: A height-balanced BST. - Example Structure: ``` 3 / 1 ``` 3. **Input**: `nums = []` - **Output**: None (since the input array is empty) **Performance Requirements**: - The function should run in O(n) time complexity where n is the number of elements in the input array. - The function should use O(n) space complexity. **Guidance**: - The middle element of the array should be chosen as the root to ensure the tree remains height-balanced. - Use recursion to build the left and right subtrees from the left and right subarrays respectively. - Ensure to handle edge cases such as an empty array or arrays with a single element correctly. **Usage**: This conversion is widely used in database indexing, range searching in sorted arrays, and in-memory tree data structures.","solution":"from typing import List, Optional # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def array_to_bst(nums: List[int]) -> Optional[TreeNode]: Convert a sorted array to a height-balanced binary search tree (BST). Args: nums (List[int]): A list of integers sorted in ascending order. Returns: Optional[TreeNode]: The root node of the height-balanced BST. if not nums: return None def helper(left: int, right: int) -> Optional[TreeNode]: if left > right: return None mid = (left + right) // 2 root = TreeNode(nums[mid]) root.left = helper(left, mid - 1) root.right = helper(mid + 1, right) return root return helper(0, len(nums) - 1)"},{"question":"# Question: Histogram Generation Problem Statement You are provided with a list of integers representing some data entries. Implement a function `generate_histogram(input_list)` that takes this list and returns a dictionary representing the histogram of the input list. Each key in this dictionary should be an element from the list, and the corresponding value should be the count of its occurrences in the list. Function Signature ```python def generate_histogram(input_list: list) -> dict: Generate a histogram from the input list ``` Input * A list of integers, `input_list` (1 <= len(input_list) <= 10^6, -10^6 <= input_list[i] <= 10^6). Output * A dictionary where keys are integers from the `input_list` and values are their counts (frequency appearance). Constraints * Your implementation should be efficient in terms of time and space complexity. * Consider edge cases such as an empty input list, a list with only one type of integers, etc. Example ```python assert generate_histogram([3, 3, 2, 1]) == {1: 1, 2: 1, 3: 2} assert generate_histogram([2, 3, 5, 5, 5, 6, 4, 3, 7]) == {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} assert generate_histogram([]) == {} assert generate_histogram([10]) == {10: 1} assert generate_histogram([-1, -2, -1, -2, -3]) == {-1: 2, -2: 2, -3: 1} ```","solution":"def generate_histogram(input_list): Generate a histogram from the input list histogram = {} for item in input_list: if item in histogram: histogram[item] += 1 else: histogram[item] = 1 return histogram"},{"question":"# Bitonic Sequence Sort **Context**: Bitonic Sort is a sophisticated sorting algorithm that can effectively be utilized in parallel computing environments. Despite its unique characteristics, your goal is to understand its mechanism and apply it to solve sorting problems for datasets defined with particular constraints. **Problem**: Implement a function `bitonic_sort` that sorts an array of integers. The function should be capable of sorting in both ascending and descending order based on a boolean flag. Note that the array\'s length must be a power of 2, or the function should raise a `ValueError`. Function Signature: ```python def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: pass ``` Input: * `arr` - A list of integers with a length that is a power of 2. * `reverse` - A boolean flag. If `True`, sort the array in ascending order. If `False`, sort the array in descending order. Output: * Returns the sorted list of integers based on the `reverse` flag. Constraints: * The length of `arr` is guaranteed to be a power of 2. * The list contains up to `2^16` (65536) elements. * Your implementation should aim to minimize time and space complexity. Example: ```python print(bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5], True)) # Output: [1, 2, 3, 4, 5, 6, 7, 8] print(bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5], False)) # Output: [8, 7, 6, 5, 4, 3, 2, 1] print(bitonic_sort([10, 30], True)) # Output: [10, 30] print(bitonic_sort([10, 30], False)) # Output: [30, 10] ``` Note: Handle small and large arrays efficiently while adhering to the time and space complexity.","solution":"from typing import List def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: def compare_and_swap(arr, i, j, direction): if (arr[i] > arr[j]) == direction: arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_rec(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort_rec(arr, low, k, True) bitonic_sort_rec(arr, low + k, k, False) bitonic_merge(arr, low, cnt, direction) n = len(arr) if (n & (n - 1)) != 0: raise ValueError(\\"Length of array must be a power of 2\\") bitonic_sort_rec(arr, 0, n, reverse) return arr"},{"question":"You are given a binary tree and need to write a function to determine the height of the tree. The height here is defined as the longest path from the root node down to a leaf node. The binary tree is defined by a class `Node` and methods within a class `bst` to build the tree, both provided for you. Implement the `height` function to calculate the tree\'s height. # Function Signature ```python def height(root: Node) -> int: ``` # Input - `root`: A `Node`, representing the root of a binary tree. # Output - An `int`, the height of the tree. # Constraints - The number of nodes in the binary tree is between 0 and 10000. - Each node in the binary tree contains a unique integer value. # Example Given the binary tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` Calling `height(root)` should return `4`. # Task 1. Implement the `height` function. 2. Ensure your solution works for both an empty tree (`None` root) and a tree with multiple nodes. # Additional Testing A test suite is provided for your convenience: ```python import unittest from bst import Node from bst import bst def height(root: Node) -> int: # Your implementation here pass class TestSuite(unittest.TestCase): def setUp(self): self.tree = bst() self.tree.insert(9) self.tree.insert(6) self.tree.insert(12) self.tree.insert(3) self.tree.insert(8) self.tree.insert(10) self.tree.insert(15) self.tree.insert(7) self.tree.insert(18) def test_height(self): self.assertEqual(4, height(self.tree.root)) if __name__ == \'__main__\': unittest.main() ``` Implement the `height` function and ensure it passes the test cases provided.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def height(root: Node) -> int: Function to calculate the height of a binary tree if root is None: return 0 else: # Recursively calculate the height of left and right subtrees left_height = height(root.left) right_height = height(root.right) # The height of the tree is the maximum height of the left and right subtrees, plus one return max(left_height, right_height) + 1"},{"question":"# Objective: Write a function implementing the nearest neighbor classification algorithm using Manhattan distance instead of Euclidean distance. # Function Signature: ```python def nearest_neighbor_manhattan(x: tuple, tSet: dict) -> any: pass ``` # Input: 1. `x` (tuple): A vector of numerical values representing the point to classify. 2. `tSet` (dict): A dictionary where keys are tuples representing vectors and values are their corresponding classifications. # Output: - Return the classification of the vector in `tSet` that has the smallest Manhattan distance to `x`. # Constraints: - All vectors (keys in `tSet` and `x`) will have the same dimensionality. - `tSet` will have at least one entry. # Example: ```python tSet = { (1, 2): \'A\', (3, 4): \'B\', (5, 6): \'A\', (7, 8): \'B\' } x = (2, 3) print(nearest_neighbor_manhattan(x, tSet)) # Output: \'A\' x = (6, 7) print(nearest_neighbor_manhattan(x, tSet)) # Output: \'B\' ``` # Explanation: The Manhattan distance between vectors (x) and (y) is calculated as: [ text{Manhattan Distance}(x, y) = sum_{i=1}^n |x_i - y_i| ] Where (n) is the number of dimensions in the vectors.","solution":"def manhattan_distance(x, y): Calculate the Manhattan distance between two vectors x and y. return sum(abs(a - b) for a, b in zip(x, y)) def nearest_neighbor_manhattan(x: tuple, tSet: dict) -> any: Find the nearest neighbor of vector x based on Manhattan distance in training set tSet. Return the classification of the closest vector. nearest = None min_distance = float(\'inf\') for vector, classification in tSet.items(): distance = manhattan_distance(x, vector) if distance < min_distance: min_distance = distance nearest = classification return nearest"},{"question":"# Priority Queue Optimization and Handling Edge Cases **Context**: You are given a basic implementation of a priority queue using a linear array. The priority queue ensures that the element with the highest priority can be efficiently accessed and removed, but insertion operation is relatively inefficient (O(n)). Additionally, the provided implementation does not handle scenarios where the priority queue might be empty during a `pop` operation. # Task: 1. **Optimize the Priority Queue**: Improve the efficiency of the priority queue for insertion operation by using a more efficient data structure (e.g., binary heap). 2. **Handle Edge Cases for Pop Operation**: Ensure the `pop` operation handles the scenario where the priority queue is empty by raising an appropriate exception. # Instructions: - **Function to Implement**: ```python class OptimizedPriorityQueue: def __init__(self, items=None, priorities=None): pass def size(self): pass def push(self, item, priority=None): pass def pop(self): pass ``` - **Expected Input and Output**: - `__init__(items=None, priorities=None)`: Should initialize the priority queue. If `items` and `priorities` are provided, initialize the queue with these items and associated priorities. - `size()`: Should return the number of elements in the priority queue. - `push(item, priority=None)`: Should insert the item with the given priority into the priority queue, maintaining the priority order efficiently. - `pop()`: Should remove and return the item with the highest priority. If the queue is empty, it should raise an `IndexError` with the message \\"pop from empty priority queue\\". # Constraints: - You can assume that all priorities are integers. - You need to handle insertion and extraction efficiently. # Example: ```python pq = OptimizedPriorityQueue() pq.push(\'task1\', priority=2) pq.push(\'task2\', priority=1) assert pq.pop() == \'task2\' assert pq.pop() == \'task1\' try: pq.pop() except IndexError as e: assert str(e) == \'pop from empty priority queue\' ```","solution":"import heapq class OptimizedPriorityQueue: def __init__(self, items=None, priorities=None): self.heap = [] if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) def size(self): return len(self.heap) def push(self, item, priority=None): if priority is None: raise ValueError(\\"Priority must be provided\\") heapq.heappush(self.heap, (priority, item)) def pop(self): if not self.heap: raise IndexError(\\"pop from empty priority queue\\") return heapq.heappop(self.heap)[1]"},{"question":"# Longest Symbol Substring Replacement You are given an array of words and an array of symbols. Your task is to write a function that replaces the substring in each word that matches one of the symbols with the symbol surrounded by square brackets. If a word contains multiple substrings that match different symbols, choose the match with the longest length. Input - An array of words (0 < number of words ≤ 1000, 1 ≤ length of each word ≤ 100). - An array of symbols (0 < number of symbols ≤ 100, 1 ≤ length of each symbol ≤ 100). Output - Return an array of words where each word\'s longest matching symbol substring is surrounded by square brackets. Example Input: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] ``` Output: ```python [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Constraints - Each word may contain at most one symbol substring from the symbols array. - If a word matches multiple symbols of the same length, use any one of them. - Case sensitivity does not need to be considered (all words and symbols are given in lowercase). Function Signature ```python def longest_symbol_substring_replacement(words, symbols): # Implementation here ``` Notes - Implement a Trie (prefix tree) to store the symbols and then search for longest matching substring efficiently. - Ensure to consider edge cases where no symbols match any part of the words. - Avoid using brute-force methods that may lead to inefficiency.","solution":"def longest_symbol_substring_replacement(words, symbols): Replaces the longest substring in each word that matches one of the symbols with the symbol surrounded by square brackets. symbols.sort(key=len, reverse=True) # Sort symbols by length in descending order def find_and_replace(word): for symbol in symbols: if symbol in word: return word.replace(symbol, f\'[{symbol}]\', 1) return word return [find_and_replace(word) for word in words]"},{"question":"Scenario You have been hired by a software firm specializing in network applications. They are working on a protocol that requires efficient conversion between integers and byte arrays in both big-endian and little-endian formats. Your task is to write two functions: one for converting an integer to its byte array representation in both endian formats and another to reconstruct the integer from its byte array representation. The code should handle both positive and negative integers correctly. Task Implement the following functions: 1. `int_to_bytes(num: int, endian: str) -> bytes` 2. `bytes_to_int(bytestr: bytes, endian: str) -> int` * **Function Specifications**: 1. `int_to_bytes`: Converts an integer to a byte array based on the specified endian format. - **Input**: - `num` (int): The integer to be converted. - `endian` (str): The endian format, either \'big\' or \'little\'. - **Output**: - `bytes`: Byte array representation of the integer. 2. `bytes_to_int`: Converts a byte array back to an integer. - **Input**: - `bytestr` (bytes): The byte array to be converted. - `endian` (str): The endian format used in the byte array, either \'big\' or \'little\'. - **Output**: - `int`: The reconstructed integer. * **Constraints**: - You must handle both positive and negative integers. - Python\'s built-in `int.to_bytes()` and `int.from_bytes()` are not allowed. - Consider byte arrays that can be very large, but within reasonable limits for memory handling in normal applications. * **Example**: ```python # Example scenario number = 305419896 endian_format = \'big\' # Converting number to byte array byte_array = int_to_bytes(number, endian_format) # Expected output: b\'x12x34x56x78\' # Converting byte array back to integer resulting_number = bytes_to_int(byte_array, endian_format) # Expected output: 305419896 ```","solution":"def int_to_bytes(num: int, endian: str) -> bytes: Converts an integer to a byte array based on the specified endian format. # Determine the length in bytes needed to represent the integer num_bytes = (num.bit_length() + 7) // 8 or 1 # Ensure at least 1 byte for 0 # Prepare byte array holder result = bytearray(num_bytes) # Handle negative numbers by adjusting for two\'s complement representation if num < 0: num += 1 << (num_bytes * 8) for i in range(num_bytes): # Extract each byte result[i] = (num >> (8 * i)) & 0xff if endian == \'big\': result.reverse() return bytes(result) def bytes_to_int(bytestr: bytes, endian: str) -> int: Converts a byte array back to an integer. if endian == \'big\': bytestr = bytestr[::-1] length = len(bytestr) result = 0 for i in range(length): result |= bytestr[i] << (8 * i) # Check if the integer was negative in two\'s complement representation if bytestr[-1] >= 0x80: result -= 1 << (length * 8) return result"},{"question":"# Removing Duplicates from an Array (Optimized) Scenario Consider a system that processes large lists of user inputs where duplicates can occur. Due to performance constraints, it is crucial to optimize the duplicate removal process. Task Write a function `remove_duplicates_optimized(array)` that removes duplicate entries from an array efficiently while preserving the order of first occurrences. Requirements * The function should take a single argument: * `array` (list): A list of items which can include integers, strings, booleans, etc. * The function should return a list with duplicates removed, preserving the initial order of the first occurrences. Constraints * Elements in the list may be of mixed data types. * The solution should aim for a time complexity of O(n). * An empty input array should return an empty list. * Ensure the function handles large lists efficiently. Input/Output Examples *Example 1*: * Input: `[1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True]` * Output: `[1, 2, 3, 4, \'hey\', \'hello\', True]` *Example 2*: * Input: `[]` * Output: `[]` *Example 3*: * Input: `[4, 5, \\"apple\\", \\"apple\\", 4, True, False, True, False, \\"banana\\"]` * Output: `[4, 5, \'apple\', True, False, \'banana\']`","solution":"def remove_duplicates_optimized(array): Removes duplicate entries from the array while preserving the order of first occurrences. Parameters: array (list): A list containing elements which may include integers, strings, etc. Returns: list: A list with duplicates removed, preserving the initial order of first occurrences. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Question You are assigned the task to implement an optimized version of Euclid’s algorithm for computing the greatest common divisor (GCD) of two non-negative integers using bitwise operations. This algorithm should handle edge cases such as zero inputs and negative values effectively. Function Signature ```python def gcd_bit(a: int, b: int) -> int: Computes the greatest common divisor of a and b using bitwise operations. Args: a (int) : The first non-negative integer. b (int) : The second non-negative integer. Returns: int : The greatest common divisor of a and b. Raises: ValueError : If both a and b are zero. ``` # Requirements 1. The function must handle any combination of non-negative integers. 2. You should avoid using direct arithmetic operations wherever possible and should leverage bitwise operations instead. 3. The function should raise a `ValueError` if both arguments are zero. 4. Ensure the function runs efficiently for large inputs. # Example ```python assert gcd_bit(0, 0) == ValueError(\\"Both inputs are zero\\") assert gcd_bit(9, 6) == 3 assert gcd_bit(14, 7) == 7 assert gcd_bit(20, 25) == 5 assert gcd_bit(0, 10) == 10 ``` # Constraints * Inputs will range from 0 to 10^9. * Function should be optimally designed to handle upper input limits efficiently.","solution":"def gcd_bit(a: int, b: int) -> int: Computes the greatest common divisor of a and b using bitwise operations. Args: a (int) : The first non-negative integer. b (int) : The second non-negative integer. Returns: int : The greatest common divisor of a and b. Raises: ValueError : If both a and b are zero. # Handle edge case where both a and b are zero if a == 0 and b == 0: raise ValueError(\\"Both inputs are zero\\") # Handle cases where any input is zero if a == 0: return b if b == 0: return a # Bitwise GCD algorithm # Remove all common factors of 2 shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 # Now `a` is odd, we can process it as a single odd number while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b -= a # Restore common factors of 2 return a << shift"},{"question":"# In-Order Traversal Implementation Problem Statement You are provided with a binary tree consisting of nodes. Your task is to implement the in-order traversal of this binary tree using both iterative and recursive approaches. Function Signature ```python def inorder_iterative(root: \'Node\') -> List[int]: pass def inorder_recursive(root: \'Node\') -> List[int]: pass ``` Input - `root` (Node): The root node of the binary tree. Each node is defined as follows: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` Output - Both functions should return a list of integers representing the in-order traversal of the binary tree. Constraints 1. The number of nodes in the tree is in the range [0, 1000]. 2. The value of each node is a unique integer. Example Given the binary tree: ``` 1 / 2 3 / 4 5 ``` ```python n1 = Node(1) n2 = Node(2) n3 = Node(3) n4 = Node(4) n5 = Node(5) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 ``` Calling `inorder_iterative(n1)` or `inorder_recursive(n1)` should both return: `[4, 2, 5, 1, 3]`. Notes 1. Ensure proper handling of edge cases such as an empty tree (should return an empty list). 2. The iterative version should avoid recursion errors by managing a stack explicitly. 3. The recursive version should be implemented to leverage the call stack for managing the traversal. Task Implement the two functions `inorder_iterative` and `inorder_recursive` to accomplish the described in-order traversal.","solution":"from typing import List class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iterative(root: \'Node\') -> List[int]: Perform in-order traversal of the binary tree iteratively. stack = [] current = root result = [] while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root: \'Node\') -> List[int]: Perform in-order traversal of the binary tree recursively. result = [] def helper(node: \'Node\'): if node is not None: helper(node.left) result.append(node.val) helper(node.right) helper(root) return result"},{"question":"# Coding Problem: Next Higher Number with Same Digits Given a number, you need to find the next higher number that has the exact same set of digits as the original number. This problem challenges your understanding of permutations and efficient in-place manipulations. Function Signature: ```python def next_bigger(num: int) -> int: ``` Input: * `num`: An integer (1 leq text{num} leq 10^9) Output: * Returns the next higher number with the same set of digits as `num`. If no such number exists, return `-1`. Constraints: * Your solution should efficiently handle the given constraints. * You should not use library functions that directly compute permutations. Example: * Example 1: Given `38276`, return `38627`. * Example 2: Given `54321`, return `-1`. Explanation: 1. **Example 1**: * Initial number: 38276 * Next higher permutation: 38627. 2. **Example 2**: * Initial number: 54321 * Digits are in descending order; hence no higher permutation is possible. Return `-1`. Implement the function respecting edge cases and ensuring optimal performance. Test Cases: ```python class TestNextBigger(unittest.TestCase): def test_cases(self): self.assertEqual(next_bigger(38276), 38627) self.assertEqual(next_bigger(12345), 12354) self.assertEqual(next_bigger(54321), -1) self.assertEqual(next_bigger(99999), -1) self.assertEqual(next_bigger(1528452), 1528524) self.assertEqual(next_bigger(138654), 143568) # Add more test cases as necessary if __name__ == \'__main__\': unittest.main() ``` This problem encourages you to demonstrate your ability to manipulate sequences efficiently and handle edge cases appropriately.","solution":"def next_bigger(num: int) -> int: Returns the next higher number that has the exact same set of digits as the given number. If no such number exists, returns -1. num_list = list(str(num)) n = len(num_list) # Step 1: Find the first digit that is smaller than the digit next to it. for i in range(n-2, -1, -1): if num_list[i] < num_list[i + 1]: break else: return -1 # If no such digit is found, then all digits are in descending order. # Step 2: Find the smallest digit on the right of the found digit, which is larger than the found digit. for j in range(n-1, i, -1): if num_list[j] > num_list[i]: break # Step 3: Swap the found digit with the smallest larger digit. num_list[i], num_list[j] = num_list[j], num_list[i] # Step 4: Reverse the sequence after the original position of the found digit. num_list = num_list[:i+1] + num_list[i+1:][::-1] return int(\'\'.join(num_list))"},{"question":"Regular Expression Matcher **Objective**: Implement a function to match a given string against a pattern containing `\'.\'` and `\'*\'`. Problem Statement Write a function `is_match(str_a: str, str_b: str) -> bool` that takes two strings `str_a` and `str_b` and returns `True` if `str_a` matches the pattern `str_b`, otherwise `False`. Pattern `str_b` can include: - `\'.\'` which matches any single character. - `\'*\'` which matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Input Format - `str_a`: A non-empty string consisting of lowercase letters. - `str_b`: A string consisting of lowercase letters, `\'.\'`, and `\'*\'`. Constraints - The length of `str_a` and `str_b` will not exceed 100. Output Format - Return `True` if `str_a` matches `str_b` in entirety, otherwise `False`. Example ```python assert is_match(\\"aa\\",\\"a\\") == False assert is_match(\\"aa\\",\\"aa\\") == True assert is_match(\\"aaa\\",\\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` Edge Cases - Ensure the function handles empty patterns and strings. - Incorporate patterns where `\'*\'` appears at the start or end. - Account for patterns where `.` and `*` appear in varied sequences. Performance Requirements - Optimize for both time and space considering the constraint limits. - Aim for a solution within the `O(M * N)` complexity bounds.","solution":"def is_match(str_a: str, str_b: str) -> bool: def dp(i, j): if j == len(str_b): return i == len(str_a) first_match = i < len(str_a) and str_b[j] in {str_a[i], \'.\'} if j + 1 < len(str_b) and str_b[j + 1] == \'*\': return dp(i, j + 2) or (first_match and dp(i + 1, j)) else: return first_match and dp(i + 1, j + 1) return dp(0, 0)"},{"question":"# Polynomial Manipulation and Evaluation In this task, you will implement two additional methods for the provided `Polynomial` class. Your task is to: 1. **`derivative(self, variable: int) -> Polynomial`:** - Compute the derivative of the polynomial with respect to a given variable. - **Input**: An integer representing the variable with respect to which the polynomial derivative is to be taken. - **Output**: A new instance of `Polynomial` representing the derivative of the original polynomial. 2. **`integrate(self, variable: int) -> Polynomial`:** - Compute the indefinite integral of the polynomial with respect to a given variable. - **Input**: An integer representing the variable with respect to which the polynomial is to be integrated. - **Output**: A new instance of `Polynomial` representing the indefinite integral of the original polynomial. # Implementation Details - Assume the variables are indexed as `a_1`, `a_2`, etc. - Extend the given `Polynomial` class with these methods. - For the derivative method, apply the basic rules of derivatives on each monomial. - For the integration method, apply the basic rules of indefinite integration on each monomial. - Remember to handle edge cases such as zero coefficients and negative exponents appropriately. # Example Given a polynomial represented as: [3a_1^2 + 2a_1a_2 - 5a_2^3 + 4] - Derivative with respect to ( a_1 ): [frac{d}{da_1}(3a_1^2 + 2a_1a_2 - 5a_2^3 + 4) = 6a_1 + 2a_2] - Integral with respect to ( a_2 ): [int (3a_1^2 + 2a_1a_2 - 5a_2^3 + 4) , da_2 = 3a_1^2a_2 + a_1a_2^2 - frac{5}{4}a_2^4 + 4a_2 + C] (Here, `C` represents the constant of integration, which can be considered as zero in this case.) **Input Format**: - The `derivative` function receives an integer. - The `integrate` function receives an integer. **Output Format**: - Both functions return an instance of `Polynomial`. # Constraints - You can assume that the input polynomial provided to these functions will be valid and contain only integer, float, or Fraction coefficients and exponents. Implement the methods in the `Polynomial` class: ```python class Polynomial: # Existing methods... def derivative(self, variable: int) -> Polynomial: # Your implementation here... pass def integrate(self, variable: int) -> Polynomial: # Your implementation here... pass ```","solution":"from collections import defaultdict from fractions import Fraction class Polynomial: def __init__(self, terms): Initializes the Polynomial with terms. :param terms: A dictionary where keys are tuples representing exponents and values are coefficients. self.terms = defaultdict(Fraction, terms) def __repr__(self): return \\" + \\".join([f\\"{coef}*{\'*\'.join([f\'a_{i+1}^{exp}\' for i, exp in enumerate(exps) if exp != 0])}\\" for exps, coef in self.terms.items()]) def derivative(self, variable: int): Compute the derivative of the polynomial with respect to a given variable. :param variable: Integer representing the variable with respect to which the derivative is to be taken (1-based index). :return: A new Polynomial instance representing the derivative. derivative_terms = defaultdict(Fraction) for exps, coef in self.terms.items(): if exps[variable-1] > 0: new_exps = list(exps) new_exps[variable-1] -= 1 new_coef = coef * exps[variable-1] derivative_terms[tuple(new_exps)] += new_coef return Polynomial(derivative_terms) def integrate(self, variable: int): Compute the indefinite integral of the polynomial with respect to a given variable. :param variable: Integer representing the variable with respect to which the integral is to be taken (1-based index). :return: A new Polynomial instance representing the indefinite integral. integral_terms = defaultdict(Fraction) for exps, coef in self.terms.items(): new_exps = list(exps) new_exps[variable-1] += 1 new_coef = coef / new_exps[variable-1] integral_terms[tuple(new_exps)] += new_coef return Polynomial(integral_terms)"},{"question":"Enhanced Word Dictionary Context: You are developing a more efficient word dictionary that allows both adding words and performing search queries. This dictionary needs to support wildcard searches where the character \'.\' can represent any letter. Two versions of the word search functionality have been provided using a Trie and Hash Map-based approach for efficiency. Task: Implement a new `WordDictionary` class that supports the following operations: 1. `addWord(word: str) -> None`: Adds a word to the dictionary. 2. `search(word: str) -> bool`: Searches for the word in the dictionary. A word could be a complete match or contain wildcards (\'.\'). Implementation: Your task is to use a mix of Trie-based and Hash Map-based techniques to optimize both insertion and search operations. Here are detailed requirements: 1. **addWord(word: str) -> None**: - Should handle inserting words efficiently. - Consider leveraging the Trie structure to ensure quick prefix checking. 2. **search(word: str) -> bool**: - Should efficiently handle both exact and wildcard searches. - Use the Hash Map strategy for quick lookups by word length, combined with Trie traversal for wildcard support. Constraints: - Word length (`len(word)`) will range from 1 to 300. - Total number of words in the dictionary will not exceed 10^4. - Words consist only of lowercase English letters. Input/Output Formats: - `addWord(word: str) -> None`: Adds a word to the dictionary. No return value. - `search(word: str) -> bool`: Returns `True` if the word (with potential wildcards) is in the dictionary; otherwise, returns `False`. Example: ```python wd = WordDictionary() wd.addWord(\\"bad\\") wd.addWord(\\"dad\\") wd.addWord(\\"mad\\") assert not wd.search(\\"pad\\") assert wd.search(\\"bad\\") assert wd.search(\\".ad\\") assert wd.search(\\"b..\\") ``` Work through various test cases including edge cases to ensure robustness and efficiency of your implementation.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() self.word_length_map = {} def addWord(self, word: str) -> None: current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_word = True word_length = len(word) if word_length not in self.word_length_map: self.word_length_map[word_length] = [word] else: self.word_length_map[word_length].append(word) def search(self, word: str) -> bool: word_length = len(word) if word_length not in self.word_length_map: return False return self._search_in_trie(word, self.root, 0) def _search_in_trie(self, word, node, index): if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_in_trie(word, child, index + 1): return True else: if char in node.children: return self._search_in_trie(word, node.children[char], index + 1) else: return False return False"},{"question":"# Word Segmentation with Dictionary **Scenario**: You are working on an NLP project where you need to determine if a given sentence can be split into valid words according to a predefined dictionary. For this task, you are provided a string `sentence` and a dictionary `word_dict` containing a list of words. Your goal is to write a function `can_segment` that returns `True` if the sentence can be segmented into one or more words from the dictionary, and `False` otherwise. # Function Signature ```python def can_segment(sentence: str, word_dict: Set[str]) -> bool: pass ``` # Expected Input and Output - **Input**: * `sentence` - A non-empty string `s`, composed of lowercase English letters. * `word_dict` - A set of non-empty words. - **Output**: * `True` if the sentence can be segmented into dictionary words, otherwise `False`. # Constraints - The length of the sentence is at most 300. - There will be no duplicates in `word_dict`. # Performance Requirements - The solution should run in O(N^2) time complexity, where N is the length of the sentence. # Example ```python assert can_segment(\\"leetcode\\", {\\"leet\\", \\"code\\"}) == True assert can_segment(\\"applepenapple\\", {\\"apple\\", \\"pen\\"}) == True assert can_segment(\\"catsandog\\", {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"}) == False ``` # Additional Information - Consider edge cases such as single character words, and words not present in the dictionary.","solution":"def can_segment(sentence: str, word_dict: set) -> bool: Determines if the given sentence can be segmented into one or more words from the dictionary. :param sentence: A string composed of lowercase English letters. :param word_dict: A set of valid dictionary words. :return: True if the sentence can be segmented, otherwise False. n = len(sentence) dp = [False] * (n + 1) dp[0] = True # Base case: an empty string is considered segmented for i in range(1, n + 1): for j in range(i): if dp[j] and sentence[j:i] in word_dict: dp[i] = True break return dp[n]"},{"question":"Problem Statement You are given an array of integers and a non-negative integer `k`. Write a function `rotate_array` that rotates the array to the right by `k` steps. You may implement the function using any of the following methods: 1. Iterative shifting of elements. 2. Segment reversal. 3. Array slicing and concatenation. However, your solution must handle all edge cases efficiently and provide the best performance possible for large input sizes. # Function Signature ```python def rotate_array(array: List[int], k: int) -> List[int]: pass ``` # Input * `array`: A list of integers, `1 <= len(array) <= 10^5`. * `k`: A non-negative integer, `0 <= k <= 10^5`. # Output * The rotated array. # Example ```python assert rotate_array([1,2,3,4,5,6,7], 3) == [5,6,7,1,2,3,4] assert rotate_array([1,2,3,4,5], 7) == [4,5,1,2,3] assert rotate_array([], 1) == [] assert rotate_array([1,2,3], 0) == [1,2,3] assert rotate_array([1], 10) == [1] ``` # Constraints * You must handle large inputs and performance is a key consideration. * Implement the function considering space optimization. # Notes 1. **Edge Cases**: Consider edge cases such as empty arrays, `k` greater than the length of the array, and cases with minimal array size. 2. **Performance**: Optimize for the best time complexity and avoid unnecessary space usage.","solution":"from typing import List def rotate_array(array: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. n = len(array) if n == 0: return array k = k % n # In case k is larger than array size return array[-k:] + array[:-k]"},{"question":"# Selection Sort with Custom Comparator Scenario You\'re redesigning a software module that handles sorting operations on various data types, including custom objects. The current implementation uses selection sort, and you need to modify it to allow custom sorting criteria. By allowing a custom comparator function, the sorting can be more flexible and applied to complex data types. Task Write a modified version of the `selection_sort` function that takes an additional `comparator` function argument. The `comparator` function should be used to determine the ordering of elements. It should return True if the first argument is considered less than the second argument, and False otherwise. Function Signature ```python def selection_sort_with_comparator(arr, comparator, simulation=False): Sorts the input array using selection sort based on the provided comparator function. Args: - arr: List of elements to be sorted. - comparator: A function that takes two arguments and returns True if the first argument is less than the second, otherwise False. - simulation: A boolean flag for printing intermediate steps (default is False). Returns: - A list of sorted elements. # Your code here ``` Input Specifications * `arr`: A list of elements (e.g., integers, strings, or custom objects). * `comparator`: A function that takes two arguments and returns a boolean. * `simulation`: Optional boolean argument that, if set to True, prints the intermediate steps during sorting. Output Specifications * Returns the list of elements sorted based on the comparator function. Constraints * The length of the input list is between 0 and 1000. * The comparator function will always return a boolean value. Example ```python # Comparator function for sorting integers in ascending order def ascending_comparator(a, b): return a < b # Comparator function for sorting strings by length (shorter strings first) def length_comparator(a, b): return len(a) < len(b) arr1 = [5, 3, 1, 4, 2] arr2 = [\\"apple\\", \\"pear\\", \\"banana\\", \\"cherry\\"] print(selection_sort_with_comparator(arr1, ascending_comparator)) # Output: [1, 2, 3, 4, 5] print(selection_sort_with_comparator(arr2, length_comparator)) # Output: [\'pear\', \'apple\', \'banana\', \'cherry\'] ``` Notes - Ensure that the solution handles edge cases like an empty array or an array with a single element. - Make sure to test the function with different types of comparators to validate correctness.","solution":"def selection_sort_with_comparator(arr, comparator, simulation=False): Sorts the input array using selection sort based on the provided comparator function. Args: - arr: List of elements to be sorted. - comparator: A function that takes two arguments and returns True if the first argument is less than the second, otherwise False. - simulation: A boolean flag for printing intermediate steps (default is False). Returns: - A list of sorted elements. n = len(arr) for i in range(n): min_index = i for j in range(i + 1, n): if comparator(arr[j], arr[min_index]): min_index = j if min_index != i: arr[i], arr[min_index] = arr[min_index], arr[i] if simulation: print(f\\"Step {i + 1}: {arr}\\") return arr"},{"question":"**Coding Assessment Question** # **Array Right Rotation** **Context** In computer science, array manipulation is a fundamental concept. Array rotation is a specific operation where elements of the array are shifted to the right by k steps. This operation is crucial in various applications including data processing, memory management, and addressing cyclic buffers efficiently. **Problem** You are given an array of integers **arr** and an integer **k**. Your task is to write a function that rotates the array to the right by **k** steps. **Function Signature** ```python def rotate_array(arr: List[int], k: int) -> List[int]: pass ``` **Input** - **arr**: A list of integers (0 <= len(arr) <= 1000, -10^6 <= arr[i] <= 10^6) - **k**: An integer (0 <= k <= 10^6) **Output** - A list of integers representing the rotated array. **Constraints** - The rotation should be done in-place with O(1) space complexity. However, if possible, an initial out-of-place solution can be written for simplicity. **Examples** 1. **Example 1:** ```python Input: arr = [1, 2, 3, 4, 5, 6, 7], k = 3 Output: [5, 6, 7, 1, 2, 3, 4] ``` 2. **Example 2:** ```python Input: arr = [-1, -100, 3, 99], k = 2 Output: [3, 99, -1, -100] ``` 3. **Example 3:** ```python Input: arr = [], k = 3 Output: [] ``` **Guidelines** - Implement a **space-optimal solution** similar to the `rotate_v2` approach as the final version. - Consider edge cases where the array is empty, has only one element, or where k exceeds the length of the array. - Ensure your function adheres to O(1) additional space complexity for the **final submission**. - Initially, you may use an out-of-place solution with slicing for clarity, but provide the in-place version as the final solution. **Submission** Submit your solution as a function definition. Be sure to test it against multiple edge cases and expected scenarios.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. n = len(arr) if n == 0 or k % n == 0: return arr k = k % n arr[:] = arr[-k:] + arr[:-k] return arr"},{"question":"# Question: Assessing Strongly Connected Components You are working on a software project that requires analyzing the connectivity of a directed graph. Your task is to determine whether a given graph is strongly connected. A directed graph is considered strongly connected if there is a path between any pair of its vertices. Implement the function `is_strongly_connected` that takes a number of vertices and a list of directed edges as input and returns `True` if the graph is strongly connected and `False` otherwise. # Function Signature ```python def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: ``` # Input - `vertex_count` (int): The number of vertices in the graph. - `edges` (List[Tuple[int, int]]): A list of directed edges where each edge is represented as a tuple `(source, target)` indicating an edge from `source` to `target`. # Output - Returns `True` if the graph is strongly connected, `False` otherwise. # Constraints - `1 <= vertex_count <= 10^5` - `0 <= len(edges) <= 2 * 10^5` - The vertices are numbered from `0` to `vertex_count - 1`. # Example ```python print(is_strongly_connected(4, [(0, 1), (1, 2), (2, 3), (3, 0)])) # Output: True print(is_strongly_connected(4, [(0, 1), (1, 2), (2, 3)])) # Output: False ``` # Explanation - In the first example, there\'s a path between any pair of vertices, making the graph strongly connected. - In the second example, you cannot reach vertex `(3)` from vertex `(0)`, hence the graph is not strongly connected. # Notes - Make sure to handle edge cases such as disconnected graphs or graphs with no vertices efficiently. - Ensure your solution is optimized to handle large inputs within the provided constraints.","solution":"def is_strongly_connected(vertex_count, edges): from collections import defaultdict, deque # Helper function to perform BFS def bfs(start_node, graph): visited = [False] * vertex_count queue = deque([start_node]) visited[start_node] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return visited if vertex_count == 0: return True # Create graph and reverse graph graph = defaultdict(list) reverse_graph = defaultdict(list) for src, dst in edges: graph[src].append(dst) reverse_graph[dst].append(src) # Perform BFS from the first node in the graph first_node = 0 visited_from_first = bfs(first_node, graph) # If not all nodes are reachable from first_node, graph is not strongly connected if not all(visited_from_first): return False # Perform BFS from the first node in the reverse graph visited_from_reverse_first = bfs(first_node, reverse_graph) # If not all nodes are reachable from first_node in the reverse graph, graph is not strongly connected if not all(visited_from_reverse_first): return False return True"},{"question":"You have been given a singly linked list where each node contains a string value. Your task is to implement a function that removes duplicates from the linked list. You need to implement two versions of the function: 1. Using an additional data structure (a hash set). 2. Without using any additional data structure. Here is the structure of the `Node` class: ```python class Node(): def __init__(self, val = None): self.val = val self.next = None ``` # Function Signatures: ```python def remove_duplicates_with_set(head: Node) -> None: Removes duplicates from the linked list using an additional data structure. Parameters: head (Node): The head of the linked list. Returns: None (modifies the list in place) pass def remove_duplicates_without_set(head: Node) -> None: Removes duplicates from the linked list without using any additional data structure. Parameters: head (Node): The head of the linked list. Returns: None (modifies the list in place) pass ``` # Input - The head node of a singly linked list of strings. # Output - These functions modify the linked list in place and do not return any value. # Constraints - The list can have a maximum of (10^6) nodes. - Each string in the list can have a maximum length of 100 characters. # Example If the linked list is: `A -> A -> B -> C -> D -> C -> F -> G` After calling `remove_duplicates_with_set(head)`, the list should be: `A -> B -> C -> D -> F -> G` If the linked list is: `A -> A -> B -> C -> D -> C -> F -> G` After calling `remove_duplicates_without_set(head)`, the list should be: `A -> B -> C -> D -> F -> G` # Notes - You must ensure that your implementation correctly handles edge cases such as an empty list or a list where all nodes are duplicates. - Aim for optimal performance regarding both time and space. Good luck!","solution":"class Node(): def __init__(self, val=None): self.val = val self.next = None def remove_duplicates_with_set(head: Node) -> None: Removes duplicates from the linked list using an additional data structure. Parameters: head (Node): The head of the linked list. Returns: None (modifies the list in place) if not head: return current = head seen = set([current.val]) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_duplicates_without_set(head: Node) -> None: Removes duplicates from the linked list without using any additional data structure. Parameters: head (Node): The head of the linked list. Returns: None (modifies the list in place) current = head while current is not None: runner = current while runner.next is not None: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# AVL Tree Insert and Search Operation You are required to implement an AVL Tree by extending the provided code snippet. More specifically, add the functionality to search for a specific key in the AVL Tree and complete the \\"insert\\" method to handle edge cases. After inserting a new key, the tree should remain balanced. Function to Implement 1. `search(self, key: int) -> bool` * **Input**: An integer `key`. * **Output**: Returns `True` if the key is found in the AVL Tree, `False` otherwise. 2. Complete the `insert` method to accurately manage tree heights and balance during insertion. 3. Ensure no duplicate keys are present in the AVL Tree. Constraints * `-10^5 <= key <= 10^5` * The keys inserted are unique. # Example ```python avl_tree = AvlTree() avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(30) avl_tree.insert(40) print(avl_tree.search(20)) # Should return True print(avl_tree.search(25)) # Should return False ``` # Notes * The `insert` method should maintain AVL Tree balance. * The `search` method should traverse the AVL Tree to find the specified key. * Ensure that your implementation handles all edge cases and optimizes performance for both insert and search operations.","solution":"class Node: Node class for AVL Tree def __init__(self, key): self.key = key self.height = 1 self.left = None self.right = None class AvlTree: AVL Tree implementation def __init__(self): self.root = None def insert(self, key): Function to insert a key into the AVL tree self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return Node(key) elif key < node.key: node.left = self._insert(node.left, key) elif key > node.key: node.right = self._insert(node.right, key) else: return node # Duplicate keys are not allowed node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance_factor = self._get_balance(node) if balance_factor > 1 and key < node.left.key: return self._right_rotate(node) if balance_factor < -1 and key > node.right.key: return self._left_rotate(node) if balance_factor > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance_factor < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def search(self, key): Function to search for a key in the AVL tree return self._search(self.root, key) def _search(self, node, key): if node is None: return False elif node.key == key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T2 = y.right y.right = z z.left = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right)"},{"question":"# Context: You are working with a medical database that stores patient IDs in an array sorted in ascending order. You need to quickly find patients based on their unique ID. # Problem Statement: Write a function `find_patient_id` that takes in a sorted array of patient IDs and a target ID, and returns the index of the target ID in the array using binary search. If the target ID is not found, return -1. # Signature: ```python def find_patient_id(patient_ids: List[int], target_id: int) -> int: pass ``` # Input: - `patient_ids`: A list of integers, sorted in ascending order. - `target_id`: An integer representing the patient ID to search for. # Output: - An integer representing the index of the target ID if found, otherwise -1. # Constraints: - The length of `patient_ids` will be at most 10^5. - The elements of `patient_ids` are unique integers ranging from 0 to 10^6. # Assumptions: - The function should be efficient with a logarithmic complexity, O(log n). - Sorting is not required as the input is guaranteed to be sorted. # Example: Example 1: ```python patient_ids = [10, 22, 35, 42, 57, 63, 75, 80, 95] target_id = 57 find_patient_id(patient_ids, target_id) # Expected output: 4 (because 57 is at index 4) ``` Example 2: ```python patient_ids = [10, 22, 35, 42, 57, 63, 75, 80, 95] target_id = 50 find_patient_id(patient_ids, target_id) # Expected output: -1 (because 50 is not in the array) ``` **Note**: Your function will be tested against various cases, including edge cases like an empty array or the target being the smallest or largest element in the array. # Extra Challenge: Try implementing both iterative and recursive solutions for this problem.","solution":"from typing import List def find_patient_id(patient_ids: List[int], target_id: int) -> int: Returns the index of the target_id in the sorted list patient_ids using binary search. If the target_id is not found, returns -1. left, right = 0, len(patient_ids) - 1 while left <= right: mid = left + (right - left) // 2 if patient_ids[mid] == target_id: return mid elif patient_ids[mid] < target_id: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Pigeonhole Sort Implementation and Extension Scenario You are working on a project that requires sorting a dataset of integers. Given the nature of the data, pigeonhole sort is identified as a potentially efficient algorithm. You are asked to extend the pigeonhole sort to handle not only positive integers but also a wider range of integers, including negative values. Task Write a function `extended_pigeonhole_sort` that performs pigeonhole sorting on an input list of integers which can include both positive and negative numbers. Input * A list of integers `arr` where: - The elements can include negative, zero, and positive integers. - The list size is at most `10^5`. Output * A sorted list of integers. Requirements 1. The function should have optimal time complexity, leveraging the strengths of pigeonhole sort. 2. Space complexity should be managed efficiently. 3. Consider edge cases, such as empty list and list with all identical elements. # Constraints - Range of integers in the array is within `[-10^6, 10^6]`. Example ```python Example 1: Input: arr = [8, 3, -2, 7, 4] Output: [-2, 3, 4, 7, 8] Example 2: Input: arr = [5, 3, 5, 3] Output: [3, 3, 5, 5] ```","solution":"def extended_pigeonhole_sort(arr): Perform an extended pigeonhole sort on the given list of integers, which can include both positive and negative numbers. if not arr: return arr # Find the minimum and maximum values in the list min_val = min(arr) max_val = max(arr) # Calculate the range of the holes range_of_values = max_val - min_val + 1 # Create and initialize holes array holes = [0] * range_of_values # Populate the holes for number in arr: holes[number - min_val] += 1 # Build the sorted list sorted_arr = [] for index in range(range_of_values): while holes[index] > 0: sorted_arr.append(index + min_val) holes[index] -= 1 return sorted_arr"},{"question":"# Exchange Sort Implementation You have been given the task of implementing the Exchange Sort algorithm to sort an array of integers. This sorting algorithm compares each pair of elements in the list and swaps them if they are out of order. The algorithm continues this process until the entire list is sorted. Task Write a function `custom_exchange_sort(arr)` that takes a list of integers `arr` and returns a new list containing these integers sorted in ascending order. Input - A single list `arr` of integers. Output - A new list containing the sorted integers in ascending order. Example ```python Input: [3, 1, 2, 4] Output: [1, 2, 3, 4] Input: [10, -1, 3, 7, 5] Output: [-1, 3, 5, 7, 10] ``` Constraints - All elements within the list are integers. - The list can contain both positive and negative integers. - The list length `n` can be up to `10^3` to maintain practical time complexity for this algorithm. Notes - You are required to return a **new** list and not sort the input list in place. - Handle edge cases such as empty lists and lists with only one element. Performance Requirements - Time Complexity: O(n^2) - Space Complexity: O(n) due to the creation of a new sorted list.","solution":"def custom_exchange_sort(arr): Sorts the given list of integers in ascending order using Exchange Sort algorithm. Parameters: arr (list): List of integers to be sorted. Returns: list: New list containing sorted integers. n = len(arr) sorted_arr = arr.copy() for i in range(n - 1): for j in range(i + 1, n): if sorted_arr[i] > sorted_arr[j]: sorted_arr[i], sorted_arr[j] = sorted_arr[j], sorted_arr[i] return sorted_arr"},{"question":"# Hailstone Scenario You have been assigned a problem by the research team studying integer sequences. The team wants to analyze the behavior of various initial conditions for the hailstone sequence, specifically the maximum number reached during the sequence before hitting 1, as well as how long each sequence is. Your task is to write a function `hailstone_analysis` that takes an integer ( n ) and returns the following: 1. The full hailstone sequence starting from ( n ). 2. The maximum number reached in this sequence. 3. The number of steps taken to reach 1 from ( n ). Input - A single integer ( n ), where ( n > 0 ). Output - A tuple containing: 1. A list of integers representing the hailstone sequence from ( n ) to 1. 2. An integer representing the maximum number reached in the sequence. 3. An integer representing the total number of steps taken to reach 1. # Constraints - ( n ) will be a positive integer. - Your solution should work efficiently for values of ( n ) up to ( 10^6 ). # Example ```python hailstone_analysis(7) # Output: ([7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], 52, 16) ```","solution":"def hailstone_analysis(n): Computes the hailstone sequence starting from n, the maximum number reached, and the total steps taken to reach 1. Parameters: n (int): The starting integer of the hailstone sequence. Returns: tuple: A tuple containing the list of the hailstone sequence, the maximum number reached, and the total steps taken to reach 1. sequence = [] max_num = n steps = 0 while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 if n > max_num: max_num = n steps += 1 sequence.append(1) # Add the final 1 to the sequence return sequence, max_num, steps"},{"question":"# Rabin-Karp Algorithm for Substring Search Given a text `text` and a pattern `word`, implement the Rabin-Karp algorithm to find the starting index of the first occurrence of `word` in `text`. If the pattern does not exist in the text, return -1. Input - `text`: A string representing the text in which the pattern is to be searched. (1 <= len(text) <= 10000) - `word`: A string representing the pattern to be searched in the text. (1 <= len(word) <= 1000) Output - Return the starting index of the first occurrence of `word` in `text`. If the `word` is not found, return -1. Constraints - The alphabet consists of lowercase English letters. Example ```python # Input: text = \\"abracadabra\\" word = \\"cad\\" # Output: 4 # Input: text = \\"hello\\" word = \\"world\\" # Output: -1 ``` Notes - Consider using a high base for the hash function to reduce hash collisions. - Be sure to handle edge cases such as when either `text` or `word` is an empty string, or when `word` is longer than `text`. Implementation ```python class RollingHash: def __init__(self, text, size_word): self.text = text self.hash = 0 self.size_word = size_word for i in range(0, size_word): self.hash += (ord(self.text[i]) - ord(\\"a\\")+1)*(26**(size_word - i -1)) self.window_start = 0 self.window_end = size_word def move_window(self): if self.window_end <= len(self.text) - 1: self.hash -= (ord(self.text[self.window_start]) - ord(\\"a\\")+1)*26**(self.size_word-1) self.hash *= 26 self.hash += ord(self.text[self.window_end])- ord(\\"a\\")+1 self.window_start += 1 self.window_end += 1 def window_text(self): return self.text[self.window_start:self.window_end] def rabin_karp(word, text): if word == \\"\\" or text == \\"\\" or len(word) > len(text): return -1 rolling_hash = RollingHash(text, len(word)) word_hash = RollingHash(word, len(word)) for i in range(len(text) - len(word) + 1): if rolling_hash.hash == word_hash.hash: if rolling_hash.window_text() == word: return i rolling_hash.move_window() return -1 ```","solution":"class RollingHash: def __init__(self, text, size_word): self.text = text self.size_word = size_word self.hash = 0 for i in range(size_word): self.hash += (ord(text[i]) - ord(\'a\') + 1) * (26 ** (size_word - i - 1)) self.window_start = 0 self.window_end = size_word def move_window(self): if self.window_end <= len(self.text) - 1: self.hash -= (ord(self.text[self.window_start]) - ord(\'a\') + 1) * (26 ** (self.size_word - 1)) self.hash *= 26 self.hash += (ord(self.text[self.window_end]) - ord(\'a\') + 1) self.window_start += 1 self.window_end += 1 def window_text(self): return self.text[self.window_start:self.window_end] def rabin_karp(text, word): if not text or not word or len(word) > len(text): return -1 word_hash = RollingHash(word, len(word)).hash rolling_hash = RollingHash(text, len(word)) for i in range(len(text) - len(word) + 1): if rolling_hash.hash == word_hash and rolling_hash.window_text() == word: return i rolling_hash.move_window() return -1"},{"question":"**Context**: You are tasked with implementing a robust version of the Rabin-Karp string matching algorithm. Your implementation should handle edge cases effectively and optimize for minimizing hash collisions. **Task**: Write a function `rabin_karp_search(pattern, text)` that finds the first occurrence of the `pattern` string within the `text` string using the Rabin-Karp algorithm. **Input**: * `pattern`: A non-empty string which represents the pattern to search in the text. * `text`: A non-empty string in which the pattern should be searched. **Output**: * Return the starting index of the first occurrence of the pattern in the text. * Return `None` if the pattern is not found or in case of invalid inputs (pattern longer than text, empty strings). **Constraints**: * Do not use Python\'s built-in substring search methods. * Consider additional edge cases beyond the provided implementation. * Optimize for large inputs where possible. ```python def rabin_karp_search(pattern, text): # Implement the function here pass ``` # Examples ```python # Example 1: print(rabin_karp_search(\\"test\\", \\"this is a test text\\")) # Output: 10 # Example 2: print(rabin_karp_search(\\"a\\", \\"a\\")) # Output: 0 # Example 3: print(rabin_karp_search(\\"abc\\", \\"abdabc\\")) # Output: 3 # Example 4: print(rabin_karp_search(\\"\\", \\"text\\")) # Output: None # Example 5: print(rabin_karp_search(\\"pattern\\", \\"\\")) # Output: None ``` **Requirements**: * Perform input validation where necessary. * Handle edge cases such as empty strings or pattern longer than text. * Consider optimization for hash collision handling.","solution":"def rabin_karp_search(pattern, text): Finds the first occurrence of the pattern string within the text string using the Rabin-Karp algorithm. if not pattern or not text or len(pattern) > len(text): return None base = 256 # Number of characters in the input alphabet prime = 101 # A prime number def hash_value(s, end, base, prime): h = 0 for i in range(end): h = (h * base + ord(s[i])) % prime return h m = len(pattern) n = len(text) pattern_hash = hash_value(pattern, m, base, prime) text_hash = hash_value(text, m, base, prime) # Pre-compute base^(m-1) % prime base_m_1 = pow(base, m - 1, prime) for i in range(n - m + 1): if pattern_hash == text_hash: if text[i:i + m] == pattern: return i if i < n - m: text_hash = (text_hash - ord(text[i]) * base_m_1) * base + ord(text[i + m]) text_hash %= prime if text_hash < 0: text_hash += prime return None"},{"question":"# Question Scenario You are given a string as an input. The task is to transform this string by deleting any reoccurring characters while keeping only the first occurrence of each character. The transformed string should be returned as output. Input and Output Formats * **Input**: A single string `s` with length `n`. * **Output**: A new string with reoccurring characters removed, containing only the first occurrence of each character in their initial order of appearance. Constraints * The string will contain only printable ASCII characters. * 1 <= n <= 100,000 Performance Requirements * The solution must have a time complexity of O(n). * Space complexity should not exceed O(n) for auxiliary data structures used. Examples * `remove_reoccurring_characters(\\"hello\\")` should return `\\"helo\\"`. * `remove_reoccurring_characters(\\"programming\\")` should return `\\"progamin\\"`. * `remove_reoccurring_characters(\\"aabbcc\\")` should return `\\"abc\\"`. # Function Signature ```python def remove_reoccurring_characters(s: str) -> str: pass ``` Additional Notes Consider the usage of efficient data structures to ensure time and space efficiency. Pay attention to edge cases like empty strings, and strings with all unique or all identical characters.","solution":"def remove_reoccurring_characters(s: str) -> str: This function returns a string after removing all reoccurring characters, keeping only the first occurrence of each character. Parameters: s (str): Input string Returns: str: A new string with reoccurring characters removed seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"Interpolation Search You are given a sorted array `array` of integers in non-decreasing order and an integer `search_key`. Implement the interpolation search algorithm to find the `search_key` in the array. If the `search_key` exists in the array, return its index. Otherwise, return -1. Function Signature ```python def interpolation_search(array: List[int], search_key: int) -> int: ``` Input * `array`: A sorted list of integers (0 ≤ len(array) ≤ 10^6) * `search_key`: An integer to search for in the array Output * An integer representing the index of `search_key` in `array` if it is found, otherwise -1. Example ```python # Example 1: assert interpolation_search([3, 6, 8, 12, 14, 18, 21, 24, 27, 33, 37, 43, 47, 50, 53, 55, 57, 61, 69, 75], 18) == 5 # Example 2: assert interpolation_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7) == 6 # Example 3: assert interpolation_search([5, 10, 15, 20, 25], 30) == -1 # Example 4: assert interpolation_search([], 5) == -1 # Example 5: assert interpolation_search([1], 1) == 0 ``` Constraints * The elements in the array are distinct. * The array may contain up to 10^6 elements. * The algorithm should handle all possible edge cases such as empty arrays, single-element arrays, the search key being outside the range of numbers in the array, etc. * The implementation must operate within a reasonable time frame for the given constraints. Performance Requirement * The average time complexity of the solution should be logarithmic, ideally O(log(log n)). Hints * Take care to handle integer division correctly to avoid misplacing the search index. * Ensure that the algorithm terminates correctly even if the search key is not present.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: if not array: return -1 low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Probing the position with keeping uniform distribution in mind pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"Maximum Flow - Advanced Graph Algorithms Scenario A company is building a network of pipelines to transport water from a source to various facilities. The pipelines have different capacities, and the company needs to determine the maximum amount of water that can be transported from the source to the main facility at the end. The structure of the network is represented as a graph where nodes are junctions and edges represent pipelines with given capacities. Task Implement a function `max_flow` to determine the maximum flow from a given source node to a sink node in a directed graph using Dinic\'s algorithm. Specifications * **Function signature**: ```python def max_flow(capacity: List[List[int]], source: int, sink: int) -> int: ``` * **Inputs**: * `capacity` - A 2D list of integers where `capacity[i][j]` is the capacity of the edge from node `i` to node `j`. If there is no direct edge, it is zero. * `source` - An integer representing the source node. * `sink` - An integer representing the sink node. * **Output**: * Returns an integer representing the maximum flow from the source to the sink. Constraints * Assume that the input graph is directed and may have multiple edges but no self-loops. * The number of vertices (V) in the graph: (2 leq V leq 500). * The capacities are non-negative integers and can be zero or positive. Example For the given input: ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 ``` The function should return `23`, which is the maximum flow from node `0` to node `5`. **Note**: An efficient implementation and clear code comments are expected. Hint * Utilize BFS for constructing level graphs and DFS for pushing flows, iteratively; use Dinic’s algorithm structure as a guide.","solution":"from typing import List from collections import deque def bfs_level_graph(capacity: List[List[int]], source: int, sink: int, level: List[int]) -> bool: V = len(capacity) for i in range(V): level[i] = -1 level[source] = 0 queue = deque([source]) while queue: u = queue.popleft() for v in range(V): if level[v] < 0 and capacity[u][v] > 0: level[v] = level[u] + 1 queue.append(v) return level[sink] >= 0 def dfs_send_flow(u: int, flow: int, sink: int, capacity: List[List[int]], level: List[int], start: List[int]) -> int: if u == sink: return flow V = len(capacity) while start[u] < V: v = start[u] if capacity[u][v] > 0 and level[v] == level[u] + 1: curr_flow = min(flow, capacity[u][v]) temp_flow = dfs_send_flow(v, curr_flow, sink, capacity, level, start) if temp_flow > 0: capacity[u][v] -= temp_flow capacity[v][u] += temp_flow return temp_flow start[u] += 1 return 0 def max_flow(capacity: List[List[int]], source: int, sink: int) -> int: V = len(capacity) if source == sink: return 0 total_flow = 0 level = [-1] * V while bfs_level_graph(capacity, source, sink, level): start = [0] * V while True: flow = dfs_send_flow(source, float(\'Inf\'), sink, capacity, level, start) if flow <= 0: break total_flow += flow return total_flow"},{"question":"You have been given an integer array `arr` which might contain negative numbers. Your task is to implement `effective_counting_sort` function to sort the array using the counting sort algorithm provided. The function should handle negative numbers correctly and efficiently. Function Signature ```python def effective_counting_sort(arr: List[int]) -> List[int]: # Your code here ``` Input - An array `arr` of integers, where `1 <= len(arr) <= 10^5` and `-10^5 <= arr[i] <= 10^5`. Output - Return a new sorted array consisting of the elements from `arr` sorted in non-decreasing order. Constraints - The input array can contain both positive and negative integers. - Your implementation must run in O(n + k) time complexity. - Your implementation should handle edge cases gracefully, such as arrays with all identical elements, single element arrays, and very large ranges of values. Example ```python print(effective_counting_sort([3, -2, 3, -7, 1, 0, -2, 1])) # Output: [-7, -2, -2, 0, 1, 1, 3, 3] print(effective_counting_sort([5, 2, 9, 5, -2, -2, 1])) # Output: [-2, -2, 1, 2, 5, 5, 9] print(effective_counting_sort([0, 0, 0, 0, 0])) # Output: [0, 0, 0, 0, 0] ``` Notes 1. Ensure that your function handles negative values by appropriately adjusting the range of values. 2. Strive to keep the space complexity within reasonable bounds without sacrificing the time complexity.","solution":"from typing import List def effective_counting_sort(arr: List[int]) -> List[int]: Sorts the given list of integers using Counting Sort supporting both negative and positive numbers. if not arr: return [] # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Range of the values in the array range_of_elements = max_val - min_val + 1 # Create count array to store the count of each unique object count = [0] * range_of_elements # Populate the count array for number in arr: count[number - min_val] += 1 # Reconstruct the sorted array sorted_arr = [] for i in range(range_of_elements): sorted_arr.extend([i + min_val] * count[i]) return sorted_arr"},{"question":"# Question: Generate All Subsets of a Set **Scenario**: You are tasked with designing an algorithm for a system that needs to test all possible combinations of a set of distinct positive integers. This functionality is crucial for scenarios such as evaluating all possible feature sets in software testing or calculating every possible combination of options for a product. **Task**: Write a function `generate_subsets(nums)` that receives a list of distinct integers and returns a list of lists, where each list represents a possible subset of the given list of integers. The output should contain all possible subsets, including the empty set and the set itself. **Input and Output Format**: - Input: A list of distinct integers, e.g., `nums = [1, 2, 3]` - Output: A list of lists, representing all subsets of the input list. # Example - If `nums = [1, 2, 3]`, the output should be `[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]` - If `nums = [1, 2]`, the output should be `[[], [1], [2], [1, 2]]` - If `nums = []`, the output should be `[[]]` # Constraints - All integers in the input list are distinct. - The length of the input list will not exceed 20 (to manage performance due to the exponential growth of subsets). **Function Signature**: ```python def generate_subsets(nums): # Your code here ``` # Performance Requirements - The solution should efficiently handle lists up to the size limit. - Aim for clarity and simplicity in your implementation, with good handling of edge cases. **Note**: Be sure to handle edge cases appropriately, such as empty input lists.","solution":"def generate_subsets(nums): Returns all possible subsets of the list nums. result = [[]] for num in nums: new_subsets = [subset + [num] for subset in result] result.extend(new_subsets) return result"},{"question":"You are provided with a binary tree and asked to implement two functions to perform in-order traversal on it. The traversal should visit the left subtree, the root node, and then the right subtree. You need to implement both an iterative and a recursive version of the in-order traversal. # Function Specifications 1. **Iterative Approach (inorder)** - **Function Name**: `inorder` - **Input**: - `root` (Node): The root node of the binary tree. - **Output**: - `List[int]`: List of integers representing the values of the tree nodes in in-order. 2. **Recursive Approach (inorder_rec)** - **Function Name**: `inorder_rec` - **Input**: - `root` (Node): The root node of the binary tree. - `res` (Optional[List[int]]): A list to accumulate the node values. - **Output**: - `List[int]`: List of integers representing the values of the tree nodes in in-order. # Constraints - The number of nodes in the tree is `1 <= n <= 10^4`. - The node values range from `-10^4` to `10^4`. # Examples Example 1: Input: ```python n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 ``` Output: ```python inorder(n1) # [25, 50, 75, 100, 125, 150, 175] inorder_rec(n1) # [25, 50, 75, 100, 125, 150, 175] ``` Example 2: Input: ```python n1 = Node(1) n2 = Node(2) n1.right = n2 ``` Output: ```python inorder(n1) # [1, 2] inorder_rec(n1) # [1, 2] ``` Write the full implementation for the given functions. Ensure the code passes all the test cases provided.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def inorder(root): Perform in-order traversal iteratively. Parameters: root (Node): The root node of the binary tree. Returns: List[int]: List of integers representing the values of the tree nodes in in-order. result = [] stack = [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.value) current = current.right return result def inorder_rec(root, res=None): Perform in-order traversal recursively. Parameters: root (Node): The root node of the binary tree. res (List[int], optional): A list to accumulate the node values. Defaults to None. Returns: List[int]: List of integers representing the values of the tree nodes in in-order. if res is None: res = [] if root: inorder_rec(root.left, res) res.append(root.value) inorder_rec(root.right, res) return res"},{"question":"# Question Context You are part of the team developing an automated sorting mechanism for a factory that produces colored balls. The balls come in three colors: red, white, and blue. Each color is represented by a distinct integer: red (0), white (1), and blue (2). Problem Write a function `sort_colors` that takes a list of integers representing the colors of the balls and sorts them so that balls of the same color are adjacent, following the order red (0), white (1), and blue (2). You should achieve this in-place without using any built-in sort function. Function Signature ```python def sort_colors(nums: List[int]) -> None: pass ``` Input * `nums`: A list of integers where each integer is 0, 1, or 2. Output * The function should modify the input list in place to sort the balls by their colors. Constraints * The input list will not necessarily be sorted initially. * You cannot use any library sort functions. Performance Requirements * The algorithm should run in O(n) time complexity. * The algorithm should use O(1) additional space. Examples Example 1: ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] ``` Example 2: ```python nums = [2, 0, 1] sort_colors(nums) print(nums) # Output: [0, 1, 2] ``` Example 3: ```python nums = [1, 2, 0] sort_colors(nums) print(nums) # Output: [0, 1, 2] ``` Edge Cases * An empty list should remain empty. * A list with all the same elements [0, 0, 0] should remain the same. * Lists that are already sorted should not change.","solution":"def sort_colors(nums): Sorts a list of integers representing colors in-place such that balls of the same color are adjacent and follow the order red (0), white (1), and blue (2). low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"You are given an array of integers `arr` and an integer `k` representing the size of a sub-array window. Your task is to write a function `find_max_elements` that returns a list of maximum elements for each sub-array of length `k`. # Function Signature ```python def find_max_elements(arr: list[int], k: int) -> list[int]: ``` # Input - `arr` (List of integers): The array of integers where 1 <= len(arr) <= 10^5. - `k` (Integer): The size of the sub-array window, 1 <= k <= len(arr). # Output - List of integers: The maximum elements of each sub-array of length `k`. # Constraints - Elements in `arr` can be negative. - The function should run in O(n) time complexity. - Space complexity should not exceed O(k). # Example ```python print(find_max_elements([1, 3, -1, -3, 5, 3, 6, 7], 3)) # Output: [3, 3, 5, 5, 6, 7] print(find_max_elements([1, 3, 1, 2, 0, 5], 2)) # Output: [3, 3, 2, 2, 5] ``` # Detailed Description 1. You are to utilize a deque to keep track of the indices of the elements in the current window. 2. Make sure to maintain the properties described in the algorithm: * Pop indexes from the deque where elements are smaller than the current element. * Remove the index from the front if it\'s out of the window. 3. As soon as the window of size `k` is reached, append the element at the index held at the front of the deque to the result list. # Hint - Consider using a deque to optimize the maximum find operation within the sub-array.","solution":"from collections import deque def find_max_elements(arr: list[int], k: int) -> list[int]: Returns a list of maximum elements for each sub-array of length k. if not arr or k == 0: return [] result = [] deq = deque() for i in range(len(arr)): # Remove indexes from deque that are out of the window if deq and deq[0] < i - k + 1: deq.popleft() # Remove elements from deque that are smaller than the current element while deq and arr[deq[-1]] < arr[i]: deq.pop() # Add current element\'s index to the deque deq.append(i) # Append the current max to the result (first element of deque) if i >= k - 1: result.append(arr[deq[0]]) return result"},{"question":"Context You are tasked with developing a scheduler that manages multiple continuous time slots represented as intervals. The primary operation required is to merge all overlapping time intervals into continuous blocks. Task Implement a function `merge_time_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]` that takes a list of intervals represented as tuples `(start, end)` and returns a new list where all overlapping intervals are merged. Function Signature ```python def merge_time_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` Input - A list of tuples, `intervals`, where each tuple represents a closed interval `[start, end]`, with `0 <= start < end <= 10^9`. - Example: `[(1, 5), (2, 6), (8, 10), (15, 18)]`. Output - A list of merged intervals, where overlapping or adjacent intervals are combined into a single interval. - Example: `[(1, 6), (8, 10), (15, 18)]`. Constraints - You may assume no interval will be improperly formatted such that `start >= end`. Example Input: `[(1, 3), (2, 6), (8, 10), (15, 18)]` Output: `[(1, 6), (8, 10), (15, 18)]` Input: `[(1, 4), (2, 5), (7, 9), (10, 11)]` Output: `[(1, 5), (7, 9), (10, 11)]` Performance Requirements - The solution should efficiently handle up to `10^5` intervals.","solution":"from typing import List, Tuple def merge_time_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges all overlapping intervals and returns a list of merged intervals. Args: intervals (List[Tuple[int, int]]): A list of tuples where each tuple represents an interval [start, end]. Returns: List[Tuple[int, int]]: A list of merged intervals. if not intervals: return [] # Sort intervals by their start value intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current_start, current_end in intervals[1:]: last_start, last_end = merged_intervals[-1] if current_start <= last_end: # There is an overlap, merge the intervals merged_intervals[-1] = (last_start, max(last_end, current_end)) else: # No overlap, add the current interval to the merged list merged_intervals.append((current_start, current_end)) return merged_intervals"},{"question":"# Problem Description You are tasked with implementing the classic FizzBuzz algorithm, a simple problem that tests your understanding of iteration and conditional logic. # Function Specification **Function Name**: `custom_fizzbuzz` **Inputs**: * `n` (int): The length of the number sequence. `n` will always be a positive integer (1 <= n <= 10^6). **Outputs**: * Return a **list of strings and integers** where: - Numbers divisible by 3 are replaced with \\"Fizz\\". - Numbers divisible by 5 are replaced with \\"Buzz\\". - Numbers divisible by both 3 and 5 are replaced with \\"FizzBuzz\\". - All other numbers remain unchanged. # Constraints * You must handle inputs where n can be as large as 10^6 efficiently. * Ensure your solution runs within a reasonable time frame. # Example ```python >>> custom_fizzbuzz(15) [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ``` # Edge Cases 1. If `n` is 1, the expected output is `[1]`. 2. Ensure the function handles the maximum constraints efficiently. # Additional Notes * Consider input validation. If `n` is less than 1 or None, raise an appropriate error. * Ensure the function is efficient and can handle large inputs up to 10^6 in a reasonable timeframe.","solution":"def custom_fizzbuzz(n): Returns a list of numbers from 1 to n with the following replacements: - Multiples of 3 are replaced with \'Fizz\'. - Multiples of 5 are replaced with \'Buzz\'. - Multiples of both 3 and 5 are replaced with \'FizzBuzz\'. if not isinstance(n, int) or n < 1: raise ValueError(\\"Input must be a positive integer.\\") result = [] for i in range(1, n+1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"# Scenario You are developing a data processing application that needs to sort lists of integers that have small ranges of values. Given the constraints of the application, you decide to implement Pigeonhole Sort because it is efficient for sorting lists where the number of elements and the range of values are relatively small. # Task Write a function `sort_with_pigeonhole(input_list)` that sorts a given list of integers using the Pigeonhole Sort algorithm. # Input * A list of integers `input_list` where: - `1 <= len(input_list) <= 10^6` - All integers are within the inclusive range `[1, 10^6]` # Output * A list of integers sorted in non-decreasing order. # Example ```python input_list = [8, 3, 2, 7, 4, 6, 8] print(sort_with_pigeonhole(input_list)) ``` *Output*: `[2, 3, 4, 6, 7, 8, 8]` # Constraints 1. Time complexity of the sorting should be O(n + Range). 2. Space complexity should be carefully managed to handle large lists and keep memory usage efficient. # Notes 1. You may assume that the list will not contain negative numbers. 2. Focus on optimizing both time and space to handle the upper limits effectively.","solution":"def sort_with_pigeonhole(input_list): if not input_list: return [] min_value = min(input_list) max_value = max(input_list) size = max_value - min_value + 1 # Initialize pigeonholes holes = [0] * size # Populate the pigeonholes for number in input_list: holes[number - min_value] += 1 # Reconstruct the sorted list from pigeonholes sorted_list = [] for i in range(size): count = holes[i] while count > 0: sorted_list.append(i + min_value) count -= 1 return sorted_list"},{"question":"Introduction You are tasked with implementing a self-balancing AVL Tree to ensure efficient performance for dynamic sets of data where insertions and deletions happen frequently. The AVL Tree should maintain a balance such that for any node, the height difference between the left and right subtrees is at most 1. Requirements Implement an AVL tree class with the following functionalities: 1. **Insert**: Insert a given key into the AVL Tree. 2. **Delete**: Remove a given key from the AVL Tree. 3. **In-order Traversal**: Return a list of elements representing in-order traversal of the tree. Specifications - You are given a class definition `AvlTree` setup and its necessary methods. - You should extend this class to include the `delete` operation. - You should ensure the tree remains balanced after each insertion and deletion. Constraints - Only distinct integer keys will be used (no duplicates). - Consider edge cases like insertion or deletion when the tree is empty or when it involves leaf nodes. Function Signatures ```python class AvlTree(object): # Existing pre-included methods def insert(self, key): # Existing method remains unchanged. def delete(self, key): Removes the key from the AVL Tree if it exists. If the tree becomes unbalanced, it should restore balance. pass # Implement this function def in_order_traverse(self): Returns a list of elements in in-order traversal. pass # Implement this function if not already. ``` # Example ```python avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(30) print(avl.in_order_traverse()) # Output: [10, 20, 30] (or similar, depending on balancing) avl.delete(20) print(avl.in_order_traverse()) # Output: [10, 30] (tree remains balanced) ``` Additional Notes - Implement rotation methods if necessary to maintain tree balance. - Ensure accurate height and balance factor updates. - Ensure that the `in_order_traverse` method correctly accesses the keys in a sorted order.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def delete(self, key): self.root = self._delete(self.root, key) def in_order_traverse(self): result = [] self._in_order_traverse(self.root, result) return result def _insert(self, node, key): if not node: return Node(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_minimum(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def _in_order_traverse(self, node, result): if not node: return self._in_order_traverse(node.left, result) result.append(node.key) self._in_order_traverse(node.right, result) def _balance(self, node): balance_factor = self._get_balance(node) if balance_factor > 1: if self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance_factor < -1: if self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _get_minimum(self, node): while node.left: node = node.left return node"},{"question":"# Question Create a function named `custom_heap_sort` that sorts an array of integers in ascending order using either a max-heap or min-heap, based on a flag. This function should efficiently perform heap sort and display the array at each main step for educational and debugging purposes. Function Signature ```python def custom_heap_sort(arr: [int], use_max_heap: bool, simulation: bool=False) -> [int]: pass ``` Input - `arr` : A list of integers to be sorted. - `use_max_heap` : A boolean flag. If `True`, use max-heap sort. If `False`, use min-heap sort. - `simulation` : A boolean flag for simulation purposes. If `True`, print the array at each main step of the algorithm. Output - Return a new list of integers sorted in ascending order. # Constraints 1. The elements in the array are within the range of -10^6 to 10^6. 2. The function should handle arrays of size up to 10^5. 3. The algorithm must run in O(n log n) time complexity. 4. The sorting should be done in place (O(1) additional space). # Example ```python # Sample Input arr = [3, 2, 5, 1, 7, 8] use_max_heap = True simulation = True # Sample Output print(custom_heap_sort(arr, use_max_heap, simulation)): # Output should display the array at each main step. # Using max-heap logic: # iteration 0 : 3 2 5 1 7 8 # iteration 1 : 8 2 5 1 7 3 # ... # Final sorted output: [1, 2, 3, 5, 7, 8] # Sample Input arr = [3, 2, 5, 1, 7, 8] use_max_heap = False simulation = True # Sample Output print(custom_heap_sort(arr, use_max_heap, simulation)): # Output should display the array at each main step. # Using min-heap logic: # iteration 0 : 3 2 5 1 7 8 # iteration 1 : 1 2 5 3 7 8 # ... # Final sorted output: [1, 2, 3, 5, 7, 8] ``` # Notes - Ensure that your function handles edge cases effectively. - Optimize the heapify process to avoid performance bottlenecks. - Focus on an iterative approach to avoid recursion limitations.","solution":"def heapify(arr, n, i, use_max_heap): largest = i left = 2 * i + 1 right = 2 * i + 2 if use_max_heap: # Max-Heapify if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right else: # Min-Heapify if left < n and arr[left] < arr[largest]: largest = left if right < n and arr[right] < arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest, use_max_heap) def build_heap(arr, n, use_max_heap, simulation): for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, use_max_heap) if simulation: print(f\\"build_heap step {i}: {arr}\\") def custom_heap_sort(arr, use_max_heap, simulation=False): n = len(arr) build_heap(arr, n, use_max_heap, simulation) if simulation: print(f\\"after build_heap: {arr}\\") for i in range(n - 1, 0, -1): arr[0], arr[i] = arr[i], arr[0] heapify(arr, i, 0, use_max_heap) if simulation: print(f\\"heap_sort step {n - i}: {arr}\\") if not use_max_heap: arr.reverse() return arr"},{"question":"Scenario You are given a list composed of various elements, including integers, booleans, strings, and potentially other types. The task is to refactor the given list such that all integers resembling zero (specifically `0`, not `False` or any other falsey values) are moved to the end of the list while preserving the order of the other elements. Function Specification Implement the function `move_zeros_to_end(array)` which performs this operation. **Input and Output Requirements**: - **Input**: A list of mixed-type elements, e.g., `[False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]` - **Output**: A list where all `0` integers are moved to the end, maintaining the order of other elements, e.g., `[False, 1, 1, 2, 1, 3, \\"a\\", 0, 0]` **Constraints**: - The list can contain elements of different types. - Only numeric zeros (`0`) should be moved. Example ```python >> move_zeros_to_end([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] >> move_zeros_to_end([0, \\"b\\", 0.0, [], 0, False, True, 0, \\"\\"]) [\\"b\\", 0.0, [], False, True, \\"\\", 0, 0, 0] ``` Notes Your function should handle all the edge cases described above, including arrays without any zeros or with all elements as zeros. Pay attention to performance and aim to achieve the goal with optimal time and space complexity.","solution":"def move_zeros_to_end(array): Moves all integer zeros (0) to the end of the list while preserving the order of other elements. non_zeros = [] zeros = [] for element in array: if element is 0 and not isinstance(element, bool): zeros.append(element) else: non_zeros.append(element) return non_zeros + zeros"},{"question":"**Problem Description**: You are given a `m x n` 2D grid initialized with three possible values: - `-1`: Represents a wall or an obstacle. - `0`: Represents a gate. - `INF`: Represents an empty room. (Use `2147483647` to represent `INF`). Your task is to fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, leave it as `INF`. **Additional Details:** - You must use a more efficient BFS algorithm to address performance and stack overflow issues associated with large grids and deep recursion required by DFS. **Function Signature:** ```python def walls_and_gates(rooms: List[List[int]]) -> None: ``` **Input:** - `rooms` is a list of lists representing the grid `m x n` with integer values `-1`, `0`, and `2147483647`. **Output:** - The function must modify the input grid `rooms` in-place. **Constraints:** 1. `1 <= m, n <= 250` 2. The distance between any empty room and a gate is at most 2147483646. # Example: ```python rooms = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] walls_and_gates(rooms) print(rooms) ``` Expected Output: ```python [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] ``` **Instructions:** - Implement the function `walls_and_gates` using BFS. - Do not return anything from the function, as the input grid must be modified directly.","solution":"from typing import List from collections import deque def walls_and_gates(rooms: List[List[int]]) -> None: Modify the input grid in-place to fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, leave it as INF. if not rooms or not rooms[0]: return m, n = len(rooms), len(rooms[0]) gates = deque() # Constants representing the four possible directions directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Enqueue all gates initially for i in range(m): for j in range(n): if rooms[i][j] == 0: gates.append((i, j)) # Perform BFS from each gate while gates: x, y = gates.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == 2147483647: rooms[nx][ny] = rooms[x][y] + 1 gates.append((nx, ny))"},{"question":"You are given an array `arr` that may contain duplicates. Write a Python function `remove_duplicates(arr)` that returns a new list with all duplicates removed. The function should preserve the order of their first occurrence in the original list. To demonstrate your understanding, solve the problem optimally with respect to time complexity, aiming for O(n) time complexity if possible. Input * `arr` (List): A list of elements which may include duplicate values. Output * List: A new list with duplicates removed, preserving the order of the first occurrence. Constraints 1. The length of `arr` will not exceed 10^5. 2. Elements of `arr` can be of any data type (e.g., integer, string, boolean). # Performance Requirements * Aim for O(n) time complexity to handle larger datasets efficiently. # Example ```python Input: [1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True] Output: [1, 2, 3, 4, \'hey\', \'hello\', True] ``` # Function Signature ```python def remove_duplicates(arr): pass ```","solution":"def remove_duplicates(arr): Returns a new list with duplicates removed, preserving the order of their first occurrence. seen = set() result = [] for element in arr: if element not in seen: seen.add(element) result.append(element) return result"},{"question":"# Problem: Navigating Delivery Routes You work for a delivery company that uses city maps represented by graphs where intersections are nodes, and roads are edges between nodes. Your task is to implement three functions for navigating these maps: 1. **find_path(graph, start, end)**: Returns a list representing a path from the starting intersection to the ending intersection using Depth-First Search. If no path exists, return `None`. 2. **find_all_paths(graph, start, end)**: Returns a list of lists, where each list represents a unique path from the starting intersection to the ending intersection using Depth-First Search. 3. **find_shortest_path(graph, start, end)**: Returns a list representing the shortest path in terms of the number of intersections from the starting intersection to the ending intersection. If no path exists, return `None`. # Input Format * `graph`: A dictionary where keys are node identifiers (strings) and values are lists of adjacent nodes. * `start`: The starting node identifier (string). * `end`: The ending node identifier (string). # Output Format * `find_path`: A list of node identifiers (strings) representing the path or `None`. * `find_all_paths`: A list of lists, where each list represents a path. * `find_shortest_path`: A list of node identifiers (strings) representing the shortest path or `None`. # Constraints * Nodes are unique strings. * The graph can be cyclic or acyclic, directed or undirected. * Assume the graph is connected for simplicity in `find_path` and `find_shortest_path`. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [], \'E\': [\'F\'], \'F\': [] } # Example usage print(find_path(graph, \'A\', \'F\')) # Might output [\'A\', \'B\', \'E\', \'F\'] print(find_all_paths(graph, \'A\', \'F\')) # Outputs [[\'A\', \'C\', \'F\'], [\'A\', \'B\', \'E\', \'F\']] print(find_shortest_path(graph, \'A\', \'F\')) # Outputs [\'A\', \'C\', \'F\'] ``` # Edge Cases to Consider * The start and end nodes are the same. * Paths involving cycles in the graph. * No path exists between the start and end nodes. Implement the functions accordingly.","solution":"def find_path(graph, start, end, path=None): Returns a path from the starting intersection to the ending intersection using Depth-First Search. if path is None: path = [] path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: new_path = find_path(graph, node, end, path) if new_path: return new_path return None def find_all_paths(graph, start, end, path=None): Returns all unique paths from the starting intersection to the ending intersection using Depth-First Search. if path is None: path = [] path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: new_paths = find_all_paths(graph, node, end, path) for new_path in new_paths: paths.append(new_path) return paths def find_shortest_path(graph, start, end): Returns the shortest path in terms of number of intersections from the starting intersection to the ending intersection using Breadth-First Search. from collections import deque queue = deque([(start, [start])]) visited = set() while queue: (current, path) = queue.popleft() if current in visited: continue if current == end: return path visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return None"},{"question":"# Merge Sort Algorithm Implementation Description Write a function `merge_sort(arr)` that implements the Merge Sort algorithm to sort an array of integers in ascending order. Input - A list of integers `arr` with length `n` where ( 1 leq n leq 10^5 ). Output - A sorted list of integers in ascending order. Constraints - The function should handle edge cases such as empty lists and lists with a single element. - The function should perform efficiently with a time complexity of O(n log(n)) and space complexity of O(n). Example ```python assert merge_sort([38, 27, 43, 3, 9, 82, 10]) == [3, 9, 10, 27, 38, 43, 82] assert merge_sort([5, 2, 7, 3, 1]) == [1, 2, 3, 5, 7] assert merge_sort([]) == [] assert merge_sort([1]) == [1] assert merge_sort([2, 1]) == [1, 2] ``` Guidelines 1. **Divide**: Split the list into two roughly equal halves. 2. **Conquer**: Recursively sort both halves. 3. **Combine**: Merge the sorted halves into a single sorted list. **Note**: Ensure that the provided `merge_sort` function leverages the helper function `merge(left, right, merged)` to combine sorted arrays efficiently.","solution":"def merge_sort(arr): Function to sort an array using the merge sort algorithm. if len(arr) <= 1: return arr def merge(left, right): merged = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 # If either left or right still has elements, extend the merged array with them merged.extend(left[left_index:]) merged.extend(right[right_index:]) return merged mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"Scenario A popular app enables users to categorize their tasks by priority represented by three levels: High (0), Medium (1), and Low (2). The app needs to internally sort the tasks so that all High priority tasks come before Medium, and all Medium come before Low priority tasks. You are required to implement this sorting mechanism efficiently to ensure that user experiences are seamless even with a large number of tasks. Problem Statement Given an array, `tasks`, with n elements where each element is an integer representing the priority level (0, 1, and 2 for High, Medium, and Low respectively), write a function `sort_priorities(tasks)` that sorts the array in-place such that all 0s appear before 1s and all 1s appear before 2s. You are not allowed to use the built-in sort function for this problem. Function Signature ```python def sort_priorities(tasks: List[int]) -> None: pass ``` Input * A list `tasks` of integers of size n (1 ≤ n ≤ 10^6) where each integer is either 0, 1, or 2. Output * The function should modify the input list `tasks` in-place such that all 0s come before all 1s, and all 1s come before all 2s. The function should not return anything. Constraints * You must operate on the given list in-place. * You cannot use the library sort function. * The algorithm should run in O(n) time complexity. Example Input: ```python tasks = [0, 1, 2, 1, 0, 2, 0, 1, 2] ``` Output (after calling the function): ```python print(tasks) # Output should be [0, 0, 0, 1, 1, 1, 2, 2, 2] ``` Additional Information * Consider edge cases such as empty lists, lists with all elements being the same, etc. * Ensure your solution is well-tested to handle large inputs efficiently.","solution":"def sort_priorities(tasks): Sorts the list `tasks` in-place such that all 0s appear before 1s and all 1s appear before 2s. low, mid, high = 0, 0, len(tasks) - 1 while mid <= high: if tasks[mid] == 0: tasks[low], tasks[mid] = tasks[mid], tasks[low] low += 1 mid += 1 elif tasks[mid] == 1: mid += 1 else: tasks[mid], tasks[high] = tasks[high], tasks[mid] high -= 1"},{"question":"# Cycle Sort Implementation **Scenario:** You are working on optimizing performance for a low-memory embedded system that needs to sort small datasets frequently. Due to hardware constraints, minimizing the number of write operations is crucial. Cycle Sort can be a suitable option given its minimal write operations. **Task:** Implement the Cycle Sort algorithm in Python to sort a list of integers in non-descending order. The function should be efficient in terms of write operations and work for different edge cases including duplicate values and pre-sorted arrays. **Function Signature:** ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` **Input:** - A list of integers, `arr`, where `1 <= len(arr) <= 1000`. **Output:** - A sorted list of integers in non-descending order. **Constraints:** - You must implement Cycle Sort from scratch. - Do not use built-in sorting functions. **Performance Requirements:** - Time complexity: O(N^2) (inherent to Cycle Sort) - Space complexity: O(1) **Example:** 1. Input: `[3, 1, 5, 2, 4]` Output: `[1, 2, 3, 4, 5]` 2. Input: `[5, 4, 3, 2, 1]` Output: `[1, 2, 3, 4, 5]` 3. Input: `[1, 2, 3, 4, 5]` Output: `[1, 2, 3, 4, 5]` 4. Input: `[4, 3, 2, 1, 2]` Output: `[1, 2, 2, 3, 4]` Consider the provided code template and detailed examples to ensure you handle all edge cases.","solution":"def cycle_sort(arr): Sorts a list of integers using Cycle Sort algorithm. :param arr: List of integers :return: Sorted list of integers # Traverse the array elements and put them to their correct positions writes = 0 n = len(arr) for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find the position where we put the element pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Otherwise, put the item to the correct position while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Maximum Path Sum in a Binary Tree Problem Statement Write a function called `max_path_sum` that takes the root node of a binary tree and returns the maximum path sum. The path can start and end at any two nodes in the tree. Input Format * The input is the root of a binary tree where each node contains an integer value. Output Format * The output should be a single integer representing the maximum path sum. Example Given the binary tree: ``` 10 / 2 10 / 20 1 -25 / 3 4 ``` The output should be `42`, as the maximum path sum is `20 + 2 + 10 + 10` (path does not have to be from root to leaf). # Constraints * The number of nodes in the tree won\'t exceed 1000. * The node values are in the range `[-1000, 1000]`. Implementation Details * Define a recursive helper function to assist with the traversal of the tree. * Keep track of the maximum path sum encountered during the traversal. * Consider paths that may include both or neither subtrees from any node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Returns the maximum path sum in the binary tree. The path can start and end at any two nodes in the tree. def helper(node): nonlocal max_sum if not node: return 0 # Recursively get the maximum sum of the left and right subtrees # Ignore paths with negative sums, since we are looking for the maximum sum left_sum = max(helper(node.left), 0) right_sum = max(helper(node.right), 0) # Calculate the path sum passing through the current node current_sum = node.val + left_sum + right_sum # Update the global maximum path sum max_sum = max(max_sum, current_sum) # Return the maximum sum path of either left or right subtree plus the node\'s value return node.val + max(left_sum, right_sum) max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"# Heap Sort Challenge Heap Sort is a comparison-based sorting algorithm that leverages the properties of a binary heap (a complete binary tree where each node is greater than its children in a max heap, or smaller than its children in a min heap). Your task is to implement the `heap_sort` function that accepts an unsorted list of integers and a boolean flag `use_max_heap`. If `use_max_heap` is `True`, the function should use the max heap approach to sort the array; if `use_max_heap` is `False`, it should use the min heap approach. # Input * A list of integers `arr`. * A boolean `use_max_heap` indicating whether to use max-heap sort (True) or min-heap sort (False). # Output * A list of sorted integers. # Constraints * `0 <= len(arr) <= 10^5` * `-10^9 <= arr[i] <= 10^9` # Implementation Requirements 1. Your solution should handle the edge cases, including empty arrays and single-element arrays. 2. The time complexity should be O(n log n), and the space complexity should be O(1) as it should be an in-place sort. 3. Your solution must avoid unnecessary swaps and comparisons to optimize the performance. 4. Do not use Python\'s built-in sort functions. # Example ```python def heap_sort(arr, use_max_heap=True): # Implement your solution here # Example usage: print(heap_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3], True)) # Max-heap sort: [1, 1, 2, 3, 3, 4, 5, 5, 6, 9] print(heap_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3], False)) # Min-heap sort: [1, 1, 2, 3, 3, 4, 5, 5, 6, 9] ``` Provide your implementation of the `heap_sort` function based on the described behavior and constraints.","solution":"def heapify(arr, n, i, use_max_heap): To heapify a subtree rooted with node i which is an index in arr[]. n is size of heap if use_max_heap: largest = i # Initialize largest as root l = 2 * i + 1 # left = 2*i + 1 r = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if l < n and arr[l] > arr[largest]: largest = l # See if right child of root exists and is greater than root if r < n and arr[r] > arr[largest]: largest = r # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root. heapify(arr, n, largest, use_max_heap) else: smallest = i # Initialize smallest as root l = 2 * i + 1 # left = 2*i + 1 r = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is smaller than root if l < n and arr[l] < arr[smallest]: smallest = l # See if right child of root exists and is smaller than root if r < n and arr[r] < arr[smallest]: smallest = r # Change root, if needed if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] # swap # Heapify the root. heapify(arr, n, smallest, use_max_heap) def heap_sort(arr, use_max_heap=True): Heap sort function that sorts an array using max-heap or min-heap n = len(arr) # Build a maxheap/minheap. for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, use_max_heap) # One by one extract elements for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0, use_max_heap) if not use_max_heap: arr.reverse() return arr"},{"question":"# Quick Sort Implementation and Analysis As a part of the assessment for your understanding of sorting algorithms, particularly Quick Sort, you are required to complete and extend the provided Quick Sort algorithm. The goal is to implement an optimized version of Quick Sort and analyze its performance under different conditions. Problem Statement: 1. Implement a function `quick_sort_optimized` which performs quick sort and uses a randomized pivot selection to avoid worst-case scenarios. 2. Allow logging the iterations of sorting by enabling a simulation mode. 3. Analyze the performance of your algorithm with edge cases and common datasets. Function Signature: ```python def quick_sort_optimized(arr: List[int], simulation: bool = False) -> List[int]: pass ``` Input: * `arr`: A list of integers. * `simulation`: A boolean flag to control the logging of sorting iterations. Output: * Return the sorted list of integers. Constraints: * The function must sort the array in place (do not use extra space beyond O(log(n)) stack space). * The array contains integers within the range [-10^5, 10^5]. * The length of the array will not exceed 10^4. Performance Requirements: * Your implementation should handle the worst-case scenario efficiently by reducing its impact through random pivot selection. * When simulation is True, log each iteration step as shown in the example simulation below. Example: ```python arr = [3, 6, 8, 10, 1, 2, 1] print(quick_sort_optimized(arr, simulation=True)) # Output Logs (example): # iteration 0 : 3 6 8 10 1 2 1 # iteration 1 : 1 1 2 3 6 8 10 ``` Tasks: 1. Implement the `quick_sort_optimized` function using randomized pivot selection. 2. Test your function with different datasets like sorted arrays, arrays with repeated elements, and large random arrays. 3. Analyze and discuss the behavior and performance of your implementation in your submission. Note: * Do not use built-in sorting functions. * Pay close attention to edge cases and ensure your implementation is robust.","solution":"import random from typing import List, Tuple def quick_sort_optimized(arr: List[int], simulation: bool = False) -> List[int]: def quick_sort_helper(arr: List[int], low: int, high: int, depth: int): if low < high: pivot_index = randomized_partition(arr, low, high) if simulation: print(f\\"iteration {depth}: {\' \'.join(map(str, arr))}\\") quick_sort_helper(arr, low, pivot_index - 1, depth + 1) quick_sort_helper(arr, pivot_index + 1, high, depth + 1) def randomized_partition(arr: List[int], low: int, high: int) -> int: pivot_index = random.randint(low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] return partition(arr, low, high) def partition(arr: List[int], low: int, high: int) -> int: pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 quick_sort_helper(arr, 0, len(arr) - 1, 0) return arr"},{"question":"# Question: Determine Strong Connectivity in Directed Graph You are given a directed graph with `N` vertices and `M` edges, described by two lists of `from_edges` and `to_edges`, representing the directed edges from `from_edges[i]` to `to_edges[i]`. Your task is to determine whether this graph is \\"strongly connected\\". A directed graph is strongly connected if there is a path between all pairs of vertices. Implement the function `is_strongly_connected(N, from_edges, to_edges)` that will: * Take an integer `N` representing the number of vertices (numbered from 0 to N-1). * Take a list of integers `from_edges` and a list of integers `to_edges` of length `M` representing the directed edges. * Return `True` if the graph is strongly connected, otherwise return `False`. Input * `N`: an integer (1 ≤ N ≤ 10^5) * `from_edges`: a list of integers with length M (0 ≤ from_edges[i] < N) * `to_edges`: a list of integers with length M (0 ≤ to_edges[i] < N) Output * Boolean: `True` or `False` Constraints * The sums of M over all test cases will not exceed 10^6. # Example Example 1 ``` Input: N = 5 from_edges = [0, 1, 2, 3, 4] to_edges = [2, 0, 3, 4, 1] Output: True ``` Example 2 ``` Input: N = 4 from_edges = [0, 1, 2] to_edges = [1, 2, 3] Output: False ``` # Requirements * Your implementation should run in O(N + M) time complexity. * You are free to use existing data structures or methods from libraries if they help simplify your implementation.","solution":"from collections import defaultdict, deque def is_strongly_connected(N, from_edges, to_edges): def dfs(graph, vertex, visited, stack=None): visited.add(vertex) for neighbour in graph[vertex]: if neighbour not in visited: dfs(graph, neighbour, visited, stack) if stack is not None: stack.append(vertex) # Create the original graph graph = defaultdict(list) for u, v in zip(from_edges, to_edges): graph[u].append(v) # Perform DFS to get the finish order of vertices visited = set() stack = [] for vertex in range(N): if vertex not in visited: dfs(graph, vertex, visited, stack) # Create the reversed graph reversed_graph = defaultdict(list) for u, v in zip(from_edges, to_edges): reversed_graph[v].append(u) # Perform DFS in the order of decreasing finish time on reversed graph visited.clear() while stack: vertex = stack.pop() if vertex not in visited: component_stack = [] dfs(reversed_graph, vertex, visited, component_stack) if len(visited) != N: return False return True"},{"question":"**Scenario**: You have been assigned the task of developing a function that removes all duplicate characters from a given string while maintaining the order of the first occurrence of each character. This is useful in applications that require input normalization, such as preprocessing for text analysis or cleaning user-submitted data. Function Definition Implement the function `remove_duplicates` that takes a single input parameter: - `string`: A non-empty string consisting of lowercase English letters only. Output Return a new string with all duplicate characters removed, preserving the original order of the first occurrences. Constraints - The length of the input string will not exceed 10^5 characters. - The input string will consist only of lowercase English letters. Example ```python remove_duplicates(\\"google\\") # Output: \\"gole\\" remove_duplicates(\\"programming\\") # Output: \\"progamin\\" remove_duplicates(\\"aabbcc\\") # Output: \\"abc\\" ``` Implementation Requirements - Ensure the solution is efficient with a time complexity of O(n). - Pay attention to space usage, aiming for O(n) space complexity. - Consider edge cases such as an empty string and strings with all unique characters.","solution":"def remove_duplicates(string): Removes all duplicate characters from a given string while maintaining the order of the first occurrence of each character. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Coding Challenge: Doubling Elements in a Stack **Context**: You are tasked with developing a data processing program that involves duplicating elements within a stack. More specifically, every element in the stack should be replaced by two occurrences of that value, and the order of the elements should remain the same. # Problem Statement: Write a function `double_elements_in_stack(stack: list) -> list` that takes a stack (represented as a list) as an input and returns the stack with every element duplicated. You should implement the function using an auxiliary queue to achieve this. # Input: - A list of integers `stack` representing a stack, where the last element of the list is the top of the stack. # Output: - A list of integers representing the modified stack after doubling each element. # Constraints: - Use only a single auxiliary data structure other than the stack. - The input stack may contain a large number of elements (up to 10^5). - You must preserve the order of elements as described. # Example: ```python stack = [3, 7, 1, 14, 9] # expected output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] result = double_elements_in_stack(stack) print(result) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Constraints: - Elements of the stack: -10^6 <= value <= 10^6 - Length of stack, ( n ): ( 1 leq n leq 10^5 ) # Hints: - You can use the `collections.deque` module for the auxiliary queue. - Pay attention to handling edge cases such as an empty stack or a stack with only one element.","solution":"from collections import deque def double_elements_in_stack(stack: list) -> list: This function duplicates each element in the stack using an auxiliary queue to preserve the order of elements. if not stack: return [] queue = deque() # Using the auxiliary queue to reorder elements for element in stack: queue.append(element) queue.append(element) doubled_stack = [] while queue: doubled_stack.append(queue.popleft()) return doubled_stack"},{"question":"# RSA Encryption: Secure Your Message Scenario As the security lead for a tech company, you\'ve been tasked with implementing the RSA encryption algorithm to secure communication between servers. The RSA encryption method should ensure that messages can be sent securely, even over an insecure channel. Task Implement functions `rsa_generate_keys`, `rsa_encrypt`, and `rsa_decrypt` that follow the principles of the RSA algorithm. The key generation should handle edge cases and ensure high security by ensuring the primes are well-chosen. Function Signature 1. **rsa_generate_keys(k: int, seed: int = None) -> Tuple[int, int, int]** - **Input**: - `k` (int): The number of bits for the product of primes (n). - `seed` (int, optional): Seed for randomness to reproduce tests. - **Output**: - A tuple (n, e, d): - `n` (int): Product of two primes. - `e` (int): Public encryption exponent. - `d` (int): Private decryption exponent. 2. **rsa_encrypt(data: int, e: int, n: int) -> int** - **Input**: - `data` (int): Data to be encrypted (must be a positive integer). - `e` (int): Encryption exponent from the public key. - `n` (int): Modulus from the public key. - **Output**: - Encrypted integer data. 3. **rsa_decrypt(data: int, d: int, n: int) -> int** - **Input**: - `data` (int): Encrypted data. - `d` (int): Decryption exponent from the private key. - `n` (int): Modulus from the private key. - **Output**: - Decrypted integer corresponding to the original data. Example ```python k = 16 n, e, d = rsa_generate_keys(k) data = 20 encrypted_data = rsa_encrypt(data, e, n) decrypted_data = rsa_decrypt(encrypted_data, d, n) assert data == decrypted_data ``` Constraints - `k` should be a multiple of 2 and >= 16. - Any input integer `data` to encrypt should be a positive integer < `n`. Performance Requirements - Prime generation should optimize for speed and security. - Functions should aim for accuracy while considering potential edge cases.","solution":"import random from sympy import isprime, nextprime from math import gcd from typing import Tuple def rsa_generate_keys(k: int, seed: int = None) -> Tuple[int, int, int]: Generates RSA keys: public key (n, e) and private key (d). k: The number of bits for the product of two primes n. seed: An optional seed for randomness to help with reproducibility. Returns a tuple (n, e, d). if seed is not None: random.seed(seed) # Generate two large prime numbers p and q p = nextprime(random.getrandbits(k // 2)) q = nextprime(random.getrandbits(k // 2)) n = p * q phi_n = (p - 1) * (q - 1) # Choose e such that 1 < e < phi_n and gcd(e, phi_n) = 1 e = random.randint(2, phi_n - 1) while gcd(e, phi_n) != 1: e = random.randint(2, phi_n - 1) # Calculate d such that (d * e) % phi_n = 1 d = pow(e, -1, phi_n) return (n, e, d) def rsa_encrypt(data: int, e: int, n: int) -> int: Encrypts the provided data using the RSA encryption algorithm. data: The plain text data to encrypt. e: The public exponent from the public key. n: The modulus from the public key. Returns the encrypted integer data. return pow(data, e, n) def rsa_decrypt(data: int, d: int, n: int) -> int: Decrypts the provided data using the RSA decryption algorithm. data: The encrypted data to decrypt. d: The private exponent from the private key. n: The modulus from the private key. Returns the decrypted integer corresponding to the original data. return pow(data, d, n)"},{"question":"# Regular Expression Matching **Objective**: Implement a function that performs regular expression matching with support for the wildcard characters `\'.\'` and `\'*\'`. The function should cover the entire input string (not just a substring) and determine if the input string matches the pattern entirely. Function Signature ```python def is_match(s: str, p: str) -> bool: ``` Parameters - `s`: A string representing the text to match. - `p`: A string representing the pattern containing `\'.\'` and `\'*\'`. Wildcard Characters - `\'.\'` matches any single character. - `\'*\'` matches zero or more of the preceding element. Return - Boolean value `True` if the entire string `s` matches the pattern `p`, `False` otherwise. # Examples ```python # Example 1 s = \\"aa\\" p = \\"a\\" assert is_match(s, p) == False # Example 2 s = \\"aa\\" p = \\"aa\\" assert is_match(s, p) == True # Example 3 s = \\"aaa\\" p = \\"aa\\" assert is_match(s, p) == False # Example 4 s = \\"aa\\" p = \\"a*\\" assert is_match(s, p) == True # Example 5 s = \\"aa\\" p = \\".*\\" assert is_match(s, p) == True # Example 6 s = \\"ab\\" p = \\".*\\" assert is_match(s, p) == True # Example 7 s = \\"aab\\" p = \\"c*a*b\\" assert is_match(s, p) == True ``` # Constraints - The length of input string `s` and pattern string `p` will not exceed 30 characters. - The function must have a quadratic time complexity in terms of the combined length of `s` and `p`.","solution":"def is_match(s: str, p: str) -> bool: Returns whether the input string s matches the pattern p. The pattern supports \'.\' which matches any single character and \'*\' which matches zero or more of the preceding element. # Initialize a DP table with False values dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Empty string and empty pattern are a match dp[0][0] = True # Handle patterns like a*, a*b*, a*b*c* etc -> empty string for j in range(2, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill the dp table for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (p[j - 2] == s[i - 1] or p[j - 2] == \'.\') and dp[i - 1][j] return dp[len(s)][len(p)]"},{"question":"# Question: Enhanced Linear Search with Constraints You are tasked with implementing a variant of the linear search function. Given an array of integers and a query integer, your function should return an array of all indices where the query integer appears. However, this enhanced linear search has some additional constraints to consider: 1. Report all indices where the query integer appears. 2. Handle large arrays efficiently by breaking early when all elements are identical to the query integer. 3. If the query integer is not found, return an empty list `[]`. Function Signature ```python def enhanced_linear_search(array, query): pass ``` Input - `array`: a list of integers of size `n` where `1 <= n <= 10^6`. - `query`: an integer to search for. Output - Return a list of integers representing the indices where the query integer appears in the array. - If the query integer does not appear in the array, return an empty list. Constraints - The function should run within reasonable time limits for large inputs. - The array elements can be positive, negative, or zero. Example ```python assert enhanced_linear_search([5, 3, 7, 3, 9, 3], 3) == [1, 3, 5] assert enhanced_linear_search([10, 20, 30], 15) == [] assert enhanced_linear_search([1, 1, 1, 1], 1) == [0, 1, 2, 3] ``` **Scenario**: You are writing a basic search utility for a data collection application. Given the vast dataset, the utility needs to quickly locate all positions of a specific value while handling cases with repetitive values and large arrays efficiently.","solution":"def enhanced_linear_search(array, query): Given an array of integers and a query integer, return an array of all indices where the query integer appears. If the query integer does not appear, return an empty list. if not array: return [] # Optimization: If all elements are the same and equal to query, return the entire index range if all(x == query for x in array): return list(range(len(array))) # Linear search for all occurrences result = [] for index, value in enumerate(array): if value == query: result.append(index) return result"},{"question":"# Question: Implement a Doubly Linked List Problem Statement You are required to implement a `DoublyLinkedList` that supports the following operations efficiently: 1. **InsertAtHead(value)**: Insert a node with the specified `value` at the beginning of the list. 2. **InsertAtTail(value)**: Insert a node with the specified `value` at the end of the list. 3. **Delete(value)**: Delete the first occurrence of a node with the specified `value` from the list. 4. **Find(value)**: Return `True` if a node with the specified value exists in the list; otherwise, return `False`. 5. **Reverse()**: Reverse the list. Specifications - The list should maintain bidirectional links among nodes. - Your implementation should handle edge cases like operations on an empty list gracefully. Input Format All input parameters for functions will be integers. Output Format - **InsertAtHead** and **InsertAtTail** operations return no value. - **Delete** returns `True` if the node was found and deleted, otherwise `False`. - **Find** returns `True` if the node with the value exists, otherwise `False`. - **Reverse** returns no value but reverses the list in-place. Constraints - The operations should be as efficient as possible given the underlying data structure constraints. Here\'s a template for your implementation: ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): # Your code here def insert_at_tail(self, value): # Your code here def delete(self, value): # Your code here def find(self, value): # Your code here def reverse(self): # Your code here # You can add more helper functions if needed ```","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = DoublyLinkedListNode(value) if not self.head: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_tail(self, value): new_node = DoublyLinkedListNode(value) if not self.tail: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return True current = current.next return False def find(self, value): current = self.head while current: if current.value == value: return True current = current.next return False def reverse(self): current = self.head prev_temp = None while current: prev_temp = current.prev current.prev = current.next current.next = prev_temp current = current.prev if prev_temp: self.head, self.tail = self.tail, self.head"},{"question":"# Subtree Verification Challenge You are given two binary trees, `s` (large tree) and `t` (potential subtree). Write a function to determine if `t` is a subtree of `s`. A subtree of `s` is defined as a node in `s` and all its descendants that form a tree identical to `t`. Input - The function will receive two nodes, `s` and `t`, representing the roots of the binary trees. - Each node contains the following attributes: * `val` (an integer value of the node) * `left` (pointer to the left child node, or `None` if there is no left child) * `right` (pointer to the right child node, or `None` if there is no right child) Output - Return `True` if `t` is a subtree of `s`, and `False` otherwise. Constraints - Both `s` and `t` must be valid binary trees with node values. - Consider efficiency: aim to achieve the best possible time and space complexity. Example ```text Example 1: Input: s = [3, 4, 5, 1, 2], t = [4, 1, 2] Output: True Explanation: Given large tree s: 3 / 4 5 / 1 2 Given subtree t: 4 / 1 2 t is a subtree of s, return true. Example 2: Input: s = [3, 4, 5, 1, 2, null, null, null, 0], t = [4, 1, 2] Output: False Explanation: Given large tree s: 3 / 4 5 / 1 2 / 0 Even though tree t is part of s, it does not contain all its descendants. ``` Follow-up Discuss how you would approach this problem if `s` is significantly larger than `t`. Function Signature ```python def is_subtree(s: TreeNode, t: TreeNode) -> bool: # Your implementation here ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(s: TreeNode, t: TreeNode) -> bool: if not s and not t: return True if not s or not t: return False if s.val != t.val: return False return is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right) def is_subtree(s: TreeNode, t: TreeNode) -> bool: if not t: return True if not s: return False if is_same_tree(s, t): return True return is_subtree(s.left, t) or is_subtree(s.right, t)"},{"question":"Scenario: You are analyzing stock prices to determine the best time to buy and sell for maximum profit. However, the stock prices have a peculiar behavior where encountering any negative price would be unrealistic. The function should consider only valid (non-negative) stock prices to determine the maximum profit that can be obtained from a contiguous subarray of non-negative stock prices. Task: Implement a function `max_profit(stock_prices)` that uses Kadane\'s Algorithm to find the maximum sum of a contiguous subarray of non-negative stock prices. If all are non-negative, or contiguous segment of all non-negatives exists, it should return their sum. If all are negative, it should return 0 as no realistic profit calculation can include negative prices. Function Signature: ```python def max_profit(stock_prices: List[int]) -> int: ``` Input: * `stock_prices`: A list of integers `stock_prices` where -1,000 <= stock_prices[i] <= 1,000 and 0 <= len(stock_prices) <= 10^5. Output: * Returns an integer representing the maximum profit which is the sum of the largest contiguous subarray of non-negative numbers in `stock_prices`. Constraints: * Subarrays are contiguous parts of an array that contains at least one element. * Your solution should have a time complexity of O(n) and space complexity of O(1). Example Input and Output: ```python # Example 1 stock_prices = [1, 2, -3, 4, 5, -7, 6, 8, 9] print(max_profit(stock_prices)) # Output: 23 (4 + 5 + 6 + 8) # Example 2 stock_prices = [-5, -3, -1] print(max_profit(stock_prices)) # Output: 0 (no valid subarray) # Example 3 stock_prices = [0, 2, 3, 5, -1, 3] print(max_profit(stock_prices)) # Output: 10 (0 + 2 + 3 + 5) ``` Notes: * Ensure your implementation handles edge cases such as arrays with only negative numbers, single element arrays, and cases where non-negative subarrays are interrupted by single negative numbers. * Focus on optimal and clean code design.","solution":"def max_profit(stock_prices): Uses a variant of Kadane\'s Algorithm to find the maximum sum of a contiguous subarray of non-negative stock prices. max_sum = 0 current_sum = 0 for price in stock_prices: if price >= 0: current_sum += price max_sum = max(max_sum, current_sum) else: current_sum = 0 return max_sum"},{"question":"# Task Description You are to implement the function `convert_and_verify_bytes`, which combines integer-to-byte and byte-to-integer conversions in both big-endian and little-endian formats. Your task is to: 1. Convert an integer to its big-endian and little-endian byte representation. 2. Reconvert the byte representations back into an integer. 3. Verify that the reconverted integers match the original integer. # Function Signature ```python def convert_and_verify_bytes(num: int) -> dict: ``` # Input * `num` (int): A non-negative integer to be converted. # Output * `result` (dict): A dictionary with the following keys and values: - `\'big_endian_bytes\'`: Big-endian byte representation of the integer. - `\'big_endian_reconverted\'`: Reconverted integer from the aforementioned big-endian byte representation. - `\'little_endian_bytes\'`: Little-endian byte representation of the integer. - `\'little_endian_reconverted\'`: Reconverted integer from the aforementioned little-endian byte representation. - `\'verification\'`: Boolean value indicating whether both reconversions match the original integer. # Constraints * 0 <= `num` <= 10**18 # Example ```python convert_and_verify_bytes(305419896) Expected Output: { \'big_endian_bytes\': b\'x12x34x56x78\', \'big_endian_reconverted\': 305419896, \'little_endian_bytes\': b\'x78x56x34x12\', \'little_endian_reconverted\': 305419896, \'verification\': True } ``` Notes * Make sure to handle the edge case where `num` is 0 and very large integers. * Utilize efficient data structures where necessary to optimize performance.","solution":"def convert_and_verify_bytes(num: int) -> dict: # Determine the number of bytes needed to represent the integer num_bytes = (num.bit_length() + 7) // 8 or 1 # At least one byte for zero # Convert integer to big-endian byte representation big_endian_bytes = num.to_bytes(num_bytes, byteorder=\'big\') # Convert big-endian byte representation back to integer big_endian_reconverted = int.from_bytes(big_endian_bytes, byteorder=\'big\') # Convert integer to little-endian byte representation little_endian_bytes = num.to_bytes(num_bytes, byteorder=\'little\') # Convert little-endian byte representation back to integer little_endian_reconverted = int.from_bytes(little_endian_bytes, byteorder=\'little\') # Verify that both reconversions match the original integer verification = (big_endian_reconverted == num) and (little_endian_reconverted == num) return { \'big_endian_bytes\': big_endian_bytes, \'big_endian_reconverted\': big_endian_reconverted, \'little_endian_bytes\': little_endian_bytes, \'little_endian_reconverted\': little_endian_reconverted, \'verification\': verification, }"},{"question":"You are working for a company that needs to quickly sort lists of integers where the ranges of the values are known beforehand and limited. Given that the ranges are small relative to the number of elements, the Pigeonhole Sort algorithm is a suitable choice. Implement a function named `pigeonhole_sort` that sorts a given list of integers using the Pigeonhole Sort algorithm. Function Signature: ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` # Input: - `arr` (List[int]): A list of integers that needs to be sorted. The list can contain both positive and negative numbers. # Output: - Returns a new list containing the sorted integers. # Constraints: - The list can contain at most 10^6 elements. - The range of integer values in the list will not exceed 10^6 in either direction (including negative integers). # Example: ```python assert pigeonhole_sort([8, 3, -2, 7, 1, -7, 4, 3, 0]) == [-7, -2, 0, 1, 3, 3, 4, 7, 8] assert pigeonhole_sort([5, 1, 4, 2, 3]) == [1, 2, 3, 4, 5] assert pigeonhole_sort([1, 1, 1, 1, 1]) == [1, 1, 1, 1, 1] ``` # Performance Requirements: - Ensure that the sorting works within the constraints and the time complexity of O(n + Range). # Notes: - Carefully handle edge cases such as arrays with negative values and arrays with duplicated elements. - Consider memory usage when dealing with large ranges and large numbers of elements.","solution":"def pigeonhole_sort(arr): if not arr: return [] min_value = min(arr) max_value = max(arr) size = max_value - min_value + 1 holes = [0] * size for x in arr: holes[x - min_value] += 1 sorted_arr = [] for index, count in enumerate(holes): sorted_arr.extend([index + min_value] * count) return sorted_arr"},{"question":"Context Given the inefficiency of Selection Sort on large datasets, you are tasked with improving its overall performance while keeping its fundamental principles intact. You will modify the original algorithm to reduce redundant operations and expand its application to partially sorted data. Task Implement an optimized version of Selection Sort that identifies runs of already sorted elements to minimize unnecessary swaps. Function Signature Implement the function `optimized_selection_sort(arr: List[int], simulation: bool=False) -> List[int]`. * **Input**: * `arr`: List of integers to be sorted (1 <= len(arr) <= 10^4, with elements in the range [-10^5, 10^5]). * `simulation`: Boolean flag for printing the internal state after each iteration. Default is `False`. * **Output**: * Returns the sorted list of integers in ascending order. * **Performance Requirements**: * Aim for less than O(n^2) swaps, particularly taking advantage of partially sorted runs to minimize unnecessary operations. * Maintain the overall time complexity while improving practical performance. * **Constraints**: * The input array may contain duplicates and negative numbers. * Do not use Python\'s built-in `sorted()` function. Example ```python from typing import List def optimized_selection_sort(arr: List[int], simulation: bool=False) -> List[int]: # Your implementation here # Example usage result = optimized_selection_sort([64, 25, 12, 22, 11], simulation=True) # should print the internal state after every swap and return [11, 12, 22, 25, 64] ``` Edge Cases to Consider * Empty array should return an empty array. * Array with a single element should return the element as is. * Array with duplicate values should be handled correctly. Good luck!","solution":"from typing import List def optimized_selection_sort(arr: List[int], simulation: bool=False) -> List[int]: Sorts the array using an optimized version of the selection sort algorithm. n = len(arr) for i in range(n): min_idx = i sorted_run_flag = True for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j sorted_run_flag = False if sorted_run_flag: if simulation: print(f\\"Array is already sorted from index {i} onwards.\\") break if min_idx != i: arr[i], arr[min_idx] = arr[min_idx], arr[i] if simulation: print(f\\"Array after iterating index {i}: {arr}\\") return arr"},{"question":"# Insertion Sort Enhancement Problem Statement: You are given the task of enhancing the `insertion_sort` function to handle an additional feature: **early termination** if the list becomes sorted before completing all iterations. This will improve performance in cases where the array is almost sorted. Function Signature: ```python def enhanced_insertion_sort(arr, simulation=False): Sorts an array using an enhanced version of insertion sort with early termination. Parameters: arr (list of int): The list of integers to sort simulation (bool): If True, prints the array after each iteration (default is False) Returns: list of int: The sorted list pass ``` Input: * `arr`: A list of integers that needs to be sorted. The length of the list (n) will be such that 1 ≤ n ≤ 10^4. * `simulation` (Optional): A boolean flag that when set to `True`, prints the array state after each iteration (default to `False`). Output: * A new list of integers that is sorted in non-decreasing order. Constraints: * The function should handle early termination to improve performance for nearly sorted datasets. * Time complexity: The solution should aim to be optimized for the best average-case performance. * Space complexity: O(1). Example: **Input**: ```python arr = [3, 2, 1] ``` **Output**: ```python [1, 2, 3] ``` **Input**: ```python arr = [1, 2, 3, 4, 5] ``` **Output**: ```python [1, 2, 3, 4, 5] ``` Instructions: 1. Implement the function `enhanced_insertion_sort`. 2. Make sure to include the early termination feature. 3. Add any necessary edge case checks. 4. If `simulation` is `True`, print the array after each iteration in the format: ``` iteration <iteration_number>: <space-separated list of elements> ```","solution":"def enhanced_insertion_sort(arr, simulation=False): Sorts an array using an enhanced version of insertion sort with early termination. Parameters: arr (list of int): The list of integers to sort simulation (bool): If True, prints the array after each iteration (default is False) Returns: list of int: The sorted list n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, to one position ahead # of their current position while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\\"iteration {i}: {\' \'.join(map(str, arr))}\\") # Early termination check is_sorted = True for k in range(1, n): if arr[k - 1] > arr[k]: is_sorted = False break if is_sorted: break return arr"},{"question":"# Bitonic Sort Implementation You are a software engineer working on optimizing algorithms for distributed systems. One of your tasks is to implement a bitonic sort, a highly parallelizable sorting algorithm. Your implementation will: - Sort an array whose size is always a power of 2. - Allow sorting in both ascending and descending order based on a flag. Function Signature: ```python def bitonic_sort(arr: List[int], reverse: bool) -> List[int]: pass ``` Input: - `arr`: A list of integers (e.g., [3, 7, 4, 8, 6, 2, 1, 5]). - `reverse`: A boolean flag where `True` implies sorting in ascending order and `False` implies sorting in descending order. Output: - Returns a sorted list of integers based on the order defined by the `reverse` flag. Constraints: - The length of `arr` will always be a power of 2. - All integers in `arr` are within the range [-1000, 1000]. Example: ```python assert bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5], True) == [1, 2, 3, 4, 5, 6, 7, 8] assert bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5], False) == [8, 7, 6, 5, 4, 3, 2, 1] ``` Explanation: 1. Your function will first check if the array length is a power of 2. 2. It will then recursively divide the array into smaller subparts, sort each subpart bitonically, and then merge them into a completely sorted array. 3. If `reverse` is `True`, the output should be in ascending order; otherwise, it should be in descending order. Requirements: - Implement the sorting algorithm following the bitonic sort approach. - Demonstrate understanding and handling of edge cases. - Ensure that the final solution is efficient with respect to its given constraints. **Note**: You do not need to handle input/output operations. You only need to complete the bitonic_sort function.","solution":"from typing import List def bitonic_sort(arr: List[int], reverse: bool) -> List[int]: def compare_and_swap(arr, i, j, direction): if (direction == (arr[i] > arr[j])): arr[i], arr[j] = arr[j], arr[i] def merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(arr, i, i + k, direction) merge(arr, low, k, direction) merge(arr, low + k, k, direction) def bitonic_sort_rec(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort_rec(arr, low, k, True) # sorting first half in ascending order bitonic_sort_rec(arr, low + k, k, False) # sorting second half in descending order merge(arr, low, cnt, direction) bitonic_sort_rec(arr, 0, len(arr), reverse) return arr"},{"question":"# Question: Enhanced Base Conversion Functions You are required to implement enhanced base conversion functions that convert between integers and their representations in various bases, including some additional features to handle improper inputs and support a wider range of bases (2-62, including both lowercase and uppercase letters). Function 1: `int_to_base` **Function Signature**: ```python def int_to_base(num: int, base: int) -> str: pass ``` **Inputs**: * `num` (int): The integer number to convert. * `base` (int): The base (between 2 and 62 inclusive) to which the number should be converted. **Output**: * Returns a string representing the number in the specified base. **Constraints**: * The base must be in the range 2 to 62. * Handle negative numbers by prefixing the result with a minus sign. **Examples**: ```python int_to_base(5, 2) # Returns \'101\' int_to_base(255, 16) # Returns \'FF\' int_to_base(-42, 16) # Returns \'-2A\' int_to_base(12345, 36) # Returns \'9IX\' ``` Function 2: `base_to_int` **Function Signature**: ```python def base_to_int(str_to_convert: str, base: int) -> int: pass ``` **Inputs**: * `str_to_convert` (str): The string representing the number in the specified base. * `base` (int): The base (between 2 and 62 inclusive) of the provided string. **Output**: * Returns the integer value that the base string represents. **Constraints**: * The base must be in the range 2 to 62. * The string can be in lowercase or uppercase. **Examples**: ```python base_to_int(\'101\', 2) # Returns 5 base_to_int(\'FF\', 16) # Returns 255 base_to_int(\'-2A\', 16) # Returns -42 base_to_int(\'9IX\', 36) # Returns 12345 ``` Notes: 1. For invalid bases (less than 2 or greater than 62), the function should raise a `ValueError`. 2. For invalid characters in the string that are not valid digits in the given base, raise a `ValueError`. 3. Both functions should be able to handle edge cases such as `0`, negative inputs, and large numbers. # Your Task Implement the `int_to_base` and `base_to_int` functions as described above. Ensure your functions handle edge cases and invalid inputs appropriately.","solution":"def int_to_base(num: int, base: int) -> str: if not (2 <= base <= 62): raise ValueError(\\"Base must be between 2 and 62\\") chars = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\" if num == 0: return \\"0\\" if num < 0: return \\"-\\" + int_to_base(-num, base) result = [] while num: result.append(chars[num % base]) num //= base return \'\'.join(reversed(result)) def base_to_int(str_to_convert: str, base: int) -> int: if not (2 <= base <= 62): raise ValueError(\\"Base must be between 2 and 62\\") chars = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\" char_to_value = {char: idx for idx, char in enumerate(chars)} if str_to_convert[0] == \'-\': return -base_to_int(str_to_convert[1:], base) num = 0 for char in str_to_convert: if char not in char_to_value or char_to_value[char] >= base: raise ValueError(f\\"Invalid character \'{char}\' for base {base}\\") num = num * base + char_to_value[char] return num"},{"question":"# Question You are tasked with extending an existing library to handle serialization and deserialization of integers to byte arrays in both big endian and little endian formats. Design an optimized and comprehensive solution considering given edge cases and performance expectations. # Objective: Implement two primary functions: Function 1: `optimized_int_to_bytes_big_endian(num: int) -> bytes` Converts an integer into a big-endian byte array. - **Input**: An integer `num` (0 <= num <= 2^64 - 1). - **Output**: A bytes object representing the integer in big endian format, including handling the integer `0`. Function 2: `optimized_bytes_to_int_big_endian(bytestr: bytes) -> int` Converts a big-endian byte array back to an integer. - **Input**: A bytes object `bytestr`. - **Output**: Integer representation of the bytes in big endian format. # Constraints: - Input `num` is a non-negative integer. - Input `bytestr` will be a bytes object. - Ensure the implementation is both time and space efficient, and handle the edge case of zero input explicitly. # Example: 1. For `optimized_int_to_bytes_big_endian(1024)`, the output should be `b\'x04x00\'`. 2. For `optimized_bytes_to_int_big_endian(b\'x04x00\')`, the output should be `1024`. # Requirements: - Performance should be optimal. - Properly handle edge cases including zero input value. - Do not use external libraries other than `collections` and standard Python libraries.","solution":"def optimized_int_to_bytes_big_endian(num: int) -> bytes: Converts an integer into a big-endian byte array. if num == 0: return b\'x00\' byte_length = (num.bit_length() + 7) // 8 return num.to_bytes(byte_length, \'big\') def optimized_bytes_to_int_big_endian(bytestr: bytes) -> int: Converts a big-endian byte array back to an integer. return int.from_bytes(bytestr, \'big\')"},{"question":"# Password Strength Validator You are to implement a function `strong_password(n, password)` that checks whether a given password meets the criteria of being strong and returns the minimum number of characters that need to be added to make the password strong as per the following rules: 1. The password length must be at least 6 characters. 2. The password must contain at least one digit (`0-9`). 3. The password must contain at least one lowercase English character (`a-z`). 4. The password must contain at least one uppercase English character (`A-Z`). 5. The password must contain at least one special character from the set `!@#%^&*()-+`. You need to return how many characters should be added to the password to make it strong. # Input Format * An integer `n` representing the length of the string. * A string `password`, which is the current password input by a user. # Output Format * An integer representing the minimum number of characters to be added to make the password strong. Ensure that your solution considers both these rules simultaneously to produce the correct result. Example: **Input:** ``` strong_password(3, \\"Ab1\\") ``` **Output:** ``` 3 ``` **Explanation:** The existing password \\"Ab1\\" has: - One uppercase character: `A` - One lowercase character: `b` - One digit: `1` - No special character. - Length of 3 characters which does not satisfy the minimum length of 6. Thus, to make it strong, it needs 3 more characters (including one special character and two of any type to meet the minimum length of 6). **Input:** ``` strong_password(11, \\"#Algorithms\\") ``` **Output:** ``` 1 ``` **Explanation:** The password \\"#Algorithms\\" has all required characters except a digit. Hence, it needs only 1 digit to be added to become a strong password.","solution":"def strong_password(n, password): Returns the minimum number of characters that need to be added to make the password strong. required_chars = 0 # Check for the presence of at least one digit has_digit = any(c.isdigit() for c in password) # Check for the presence of at least one lowercase character has_lower = any(c.islower() for c in password) # Check for the presence of at least one uppercase character has_upper = any(c.isupper() for c in password) # Check for the presence of at least one special character special_characters = \\"!@#%^&*()-+\\" has_special = any(c in special_characters for c in password) # Counting missing types of characters if not has_digit: required_chars += 1 if not has_lower: required_chars += 1 if not has_upper: required_chars += 1 if not has_special: required_chars += 1 # Calculate the minimum length required to be 6 characters additional_length_needed = max(0, 6 - n) # The final number of characters to add must cover both the character types and minimum length requirements return max(required_chars, additional_length_needed)"},{"question":"# Scenario: You are developing a simplified task scheduler system where each task has a priority. To ensure that the highest-priority task is always executed first, you are to implement a priority queue. The tasks are uniquely identified by their name and have a corresponding integer priority. # Task: Implement the two critical methods of a priority queue using a class structure as given below: * `push(task, priority)`: Adds a task with the given priority to the queue. * `pop()`: Removes and returns the task with the highest priority. # Constraints: * Task names are strings of up to 100 characters. * Priorities are integers, where higher integers represent higher priorities. * Assume a maximum of 1000 tasks. # Input/Output: **Function 1**: `push(task, priority)` * **Inputs**: * `task`: string * `priority`: integer * **Output**: None **Function 2**: `pop()` * **Output**: string (name of the task with the highest priority) # Example: ```python pq = PriorityQueue() pq.push(\\"Task 1\\", 5) pq.push(\\"Task 2\\", 10) pq.push(\\"Task 3\\", 1) print(pq.pop()) # Output: \\"Task 2\\" print(pq.pop()) # Output: \\"Task 1\\" print(pq.pop()) # Output: \\"Task 3\\" ``` # Notes: - Ensure that the `pop` method raises an appropriate exception or returns `None` if the queue is empty. - Handle edge cases such as attempts to pop from an empty queue and tasks with identical priorities efficiently. - Avoid using built-in priority queue libraries or data structures. - Describe any assumptions or decisions you make during implementation.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.entry_map = {} self.counter = 0 def push(self, task, priority): if task in self.entry_map: self.remove(task) count = self.counter entry = [-priority, count, task] self.entry_map[task] = entry heapq.heappush(self.heap, entry) self.counter += 1 def remove(self, task): entry = self.entry_map.pop(task) entry[-1] = None def pop(self): while self.heap: priority, count, task = heapq.heappop(self.heap) if task is not None: del self.entry_map[task] return task return None"},{"question":"# Scenario Imagine you are working on implementing a robust encryption algorithm. As part of the encryption process, you need to compute the modular order of integers to strengthen the encryption scheme. Given integers `a` and `n`, the order of `a` modulo `n` is defined as the smallest positive integer `k` such that (a^k equiv 1 mod n). Your task is to implement a function that computes this order efficiently while considering edge cases and ensuring the inputs are valid. # Task Implement the `find_order(a, n)` function to achieve the following: 1. Return the smallest positive integer `k` such that (a^k equiv 1 mod n). 2. If such `k` does not exist, return -1. 3. If `gcd(a, n) ≠ 1`, output `\\"a and n should be relative prime!\\"` and return -1. 4. If `a = 1` and `n = 1`, return 1. # Function Signature `def find_order(a: int, n: int) -> int:` # Input - `a` (1 ≤ a ≤ 10^6): The base integer. - `n` (1 ≤ n ≤ 10^6): The modulus integer. # Output - Returns an integer representing the order of `a` modulo `n`. - Print an error message and return -1 if the input conditions are not met. # Constraints - Both `a` and `n` are guaranteed to be positive integers. - Ensure efficient handling for large values of `a` and `n`. # Example ```python print(find_order(3, 7)) # Output: 6 print(find_order(2, 8)) # Output: a and n should be relative prime!, -1 print(find_order(1, 1)) # Output: 1 print(find_order(10, 17)) # Output: 16 print(find_order(4, 13)) # Output: 6 ``` # Note - Ensure your implementation works efficiently for larger ranges of `a` and `n`. - Handle edge cases where `a` and `n` are not relatively prime properly.","solution":"def gcd(a, b): Helper function to compute GCD of two integers using Euclidean algorithm. while b: a, b = b, a % b return a def find_order(a, n): Returns the smallest positive integer k such that a^k ≡ 1 (mod n). If gcd(a, n) != 1, print an error message and return -1. If a and n are both 1, return 1. if a == 1 and n == 1: return 1 if gcd(a, n) != 1: print(\\"a and n should be relative prime!\\") return -1 k = 1 exp = a % n while exp != 1: exp = (exp * a) % n k += 1 if k > n: # if k exceeds n, then no order exists return -1 return k"},{"question":"# Assessing Maximum Flow Computation **Objective**: Design an algorithm to determine the maximum flow in a network using the BFS-based Edmonds-Karp method. **Scenario/Context**: You\'ve been tasked with optimizing the network traffic flow between a source node and sink node in a city\'s internet infrastructure. The network is represented as an adjacency matrix where each cell indicates the bandwidth capacity between two nodes. **Function Specification**: * Function Name: `maximum_flow_bfs` * Input: A 2D list `adjacency_matrix` representing the capacity graph of size `n*n` where `n` is the number of vertices. * The first vertex (position 0) is the source. * The last vertex (position n-1) is the sink. * Output: An integer representing the maximum flow from the source to the sink. **Constraints**: * `1 <= n <= 100` (n being the number of nodes) * `0 <= adjacency_matrix[i][j] <= 10^5` representing the capacity between two nodes. **Performance Requirements**: * The solution should efficiently handle up to the maximum constraint of 100 nodes. **Example**: ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] print(maximum_flow_bfs(graph)) # Output: 23 ``` **Instructions**: * Write a Python function `maximum_flow_bfs()` to compute the maximum flow. * Ensure the function handles large graphs within reasonable time and memory usage. * Carefully manage visited nodes and paths to avoid infinite loops and incorrect path updates. * Remember to test edge cases, including graphs with nodes having no connectivity and graphs with very high capacities.","solution":"from collections import deque def bfs_capacity(residual_graph, source, sink, parent): visited = [False] * len(residual_graph) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, capacity in enumerate(residual_graph[u]): if not visited[v] and capacity > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def maximum_flow_bfs(adjacency_matrix): source = 0 sink = len(adjacency_matrix) - 1 residual_graph = [list(row) for row in adjacency_matrix] parent = [-1] * len(adjacency_matrix) max_flow = 0 while bfs_capacity(residual_graph, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] residual_graph[u][v] -= path_flow residual_graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Separate Chaining Hash Table Extended Functionality Objective Extend the provided Separate Chaining Hash Table implementation with the following additional functionalities: 1. **Resize Method**: * Implement a method `resize(new_size)` which resizes the hash table to a new size and rehashes all existing keys. * This ensures that the load factor remains under a specified threshold. 2. **Keys Method**: * Implement a method `keys()` which returns a list of all keys currently in the hash table. 3. **Values Method**: * Implement a method `values()` which returns a list of all values currently in the hash table. Function Descriptions ```python def resize(self, new_size: int): Resizes the hash table to the new size and rehashes all existing keys. Args: new_size (int): The new size of the hash table. pass def keys(self) -> list: Returns a list of all keys currently in the hash table. Returns: list: A list of keys. pass def values(self) -> list: Returns a list of all values currently in the hash table. Returns: list: A list of values. pass ``` Constraints * The new size in the `resize` method should always be greater than the current size. * Performance: Aim to make sure the insertions, deletions, and accesses are efficient post-resizing. Example Usage ```python table = SeparateChainingHashTable() table.put(\'apple\', \'fruit\') table.put(\'carrot\', \'vegetable\') table.put(\'berry\', \'fruit\') print(table.keys()) # [\'apple\', \'carrot\', \'berry\'] print(table.values()) # [\'fruit\', \'vegetable\', \'fruit\'] table.resize(20) print(table.keys()) # Ensure the keys persist post-resize: [\'apple\', \'carrot\', \'berry\'] print(table.get(\'carrot\')) # \'vegetable\' ``` Use this example to test your implementation, ensuring you correctly resize and maintain all keys and values.","solution":"class SeparateChainingHashTable: def __init__(self, size=10): self.size = size self.table = [[] for _ in range(size)] self.count = 0 def put(self, key, value): index = self.hash_function(key) for kvp in self.table[index]: if kvp[0] == key: kvp[1] = value return self.table[index].append([key, value]) self.count += 1 def get(self, key): index = self.hash_function(key) for kvp in self.table[index]: if kvp[0] == key: return kvp[1] return None def delete(self, key): index = self.hash_function(key) for i, kvp in enumerate(self.table[index]): if kvp[0] == key: del self.table[index][i] self.count -= 1 return kvp[1] return None def hash_function(self, key): return hash(key) % self.size def resize(self, new_size): old_table = self.table self.size = new_size self.table = [[] for _ in range(new_size)] self.count = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) def keys(self): keys_list = [] for bucket in self.table: for key, _ in bucket: keys_list.append(key) return keys_list def values(self): values_list = [] for bucket in self.table: for _, value in bucket: values_list.append(value) return values_list"},{"question":"# Problem Description You are given a string `s` and a dictionary of valid words `wordDict`. Your task is to implement a function `count_sentences(s: str, wordDict: List[str]) -> int` that determines the number of possible ways to segment the string such that every segment is a word in the dictionary. # Input 1. `s`: A string consisting of lowercase letters (1 ≤ `len(s)` ≤ 50). 2. `wordDict`: A list of strings where each string is a valid word. The list will contain between 1 to 1000 words, inclusive. Each word in the dictionary consists of lowercase letters and no word length will exceed 50. # Output - Return an integer that represents the number of valid ways to segment `s`. # Constraints - All inputs are lowercase English letters. - You can assume that the dictionary does not contain duplicate words. # Example Scenario Example 1 ```python s = \\"appletablet\\" wordDict = [\\"apple\\", \\"tablet\\", \\"applet\\", \\"able\\", \\"t\\"] Output: 3 ``` Explanation: You can segment `appletablet` into: - \\"apple\\" + \\"tablet\\" - \\"applet\\" + \\"able\\" + \\"t\\" - \\"apple\\" + \\"table\\" + \\"t\\" Example 2 ```python s = \\"thing\\" wordDict = [\\"thing\\"] Output: 1 ``` Explanation: You can segment `thing` into: - \\"thing\\" # Function Signature ```python def count_sentences(s: str, wordDict: List[str]) -> int: pass ``` # Additional Notes - Consider implementing memoization to optimize the recursive solution. - Be sure to handle the edge cases appropriately with explanations.","solution":"from typing import List def count_sentences(s: str, wordDict: List[str]) -> int: word_set = set(wordDict) memo = {} def dfs(index): if index == len(s): return 1 if index in memo: return memo[index] count = 0 for end in range(index + 1, len(s) + 1): if s[index:end] in word_set: count += dfs(end) memo[index] = count return count return dfs(0)"},{"question":"# Coding Challenge: Valid Anagram You need to implement a function `is_anagram` that determines if one string is an anagram of another. Scenario Imagine you are writing an application for a word game, similar to Scrabble, where you need to check if one word (formed by rearranging the letters of another word) is valid. Specifications 1. **Function Name**: `is_anagram` 2. **Inputs**: - `s`: A string containing only lowercase alphabets. - `t`: A string containing only lowercase alphabets. 3. **Output**: - Return a boolean value `True` if `t` is an anagram of `s`, and `False` otherwise. Constraints - The input strings will have a length of at least 1 and at most 10⁴. - You may assume the strings contain only lowercase alphabets. Example 1. **Example 1**: - Input: s = \\"anagram\\", t = \\"nagaram\\" - Output: True 2. **Example 2**: - Input: s = \\"rat\\", t = \\"car\\" - Output: False Notes - An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all of the original letters exactly once. Solution Constraints - Aim for a time complexity of O(n) where n is the length of strings `s` and `t`. - The solution should be space efficient, taking into consideration the possible fixed set of characters (26 lowercase alphabets). Function Signature ```python def is_anagram(s: str, t: str) -> bool: Determine if string t is an anagram of string s. :param s: The first string. :param t: The second string. :return: True if t is an anagram of s, False otherwise. pass ``` Implement this function and ensure it handles the provided example cases correctly.","solution":"def is_anagram(s: str, t: str) -> bool: Determine if string t is an anagram of string s. :param s: The first string. :param t: The second string. :return: True if t is an anagram of s, False otherwise. # Anagrams must have the same length if len(s) != len(t): return False # Python\'s `collections.Counter` can be used to count the frequency of # characters. We can use it to compare the two strings. from collections import Counter return Counter(s) == Counter(t)"},{"question":"# Question: Maximum Subarray Sum with Detailed Analysis **Context**: In the world of competitive programming and financial analysis, efficiently determining the segment (or subarray) with the highest sum within a given array of numbers is a widely needed operation. Kadane\'s Algorithm provides a linear-time solution to this problem. # Task: Implement a function `max_subarray` that takes a single input list of integers and returns the maximum sum of any contiguous subarray. # Function Signature: ```python def max_subarray(array: List[int]) -> int: ``` # Input: - `array`: A list of integers `array` with at least one element, where: * `-10^5 <= array[i] <= 10^5` * `1 <= len(array) <= 10^5` # Output: - Return a single integer representing the largest sum of any contiguous subarray. # Constraints: - The array will contain at least one integer. - Optimal solution with a time complexity of O(n) and constant space complexity is expected. # Example: ```python # Example 1 input_array = [1, 2, -3, 4, 5, -7, 23] # The max subarray sum is 25 (from the subarray [4, 5, -7, 23]) # Example 2 input_array = [-2, 1] # The max subarray sum is 1 # Example 3 input_array = [1] # The max subarray sum is 1 ``` # Edge Cases to Consider: - Single element arrays. - Arrays with all negative numbers. - Arrays with mixed positive and negative numbers, especially with densely spaced negatives. # Notes: - Ensure to handle possible edge cases where input size and values are at their minimum or maximum limits. - Aim for a clean, modular, and efficient implementation of the solution.","solution":"from typing import List def max_subarray(array: List[int]) -> int: Finds the maximum sum of any contiguous subarray using Kadane\'s Algorithm. :param array: A list of integers. :return: Maximum sum of any contiguous subarray. max_current = max_global = array[0] for num in array[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Decoding Encoded Strings Context In many programming tasks, you might encounter strings that are encoded using specific rules, especially in compression and data transfer mechanisms. You need to decode these strings back to their original form. Task Your task is to write a function, `decode_string(s)`, that takes an encoded string `s` and returns the decoded string. The encoding rule is defined as `k[encoded_string]`, where `k` is a positive integer indicating the number of times the `encoded_string` should be repeated. Constraints - The input string will always be valid; you do not need to handle extra white spaces or malformed brackets. - Digits in the string are only used for indicating the number of repetitions and will not be found inside the `encoded_string`. Requirements 1. **Input**: A single string `s` (encoded format). 2. **Output**: A single string, the decoded version of `s`. Examples - `decode_string(\\"3[a]2[bc]\\")` should return `\\"aaabcbc\\"`. - `decode_string(\\"3[a2[c]]\\")` should return `\\"accaccacc\\"`. - `decode_string(\\"2[abc]3[cd]ef\\")` should return `\\"abcabccdcdcdef\\"`. You are expected to implement this function with an efficient algorithm that can handle nested encoding structures. Function Signature ```python def decode_string(s): :type s: str :rtype: str ``` Note: - Pay attention to handling nested encoded strings correctly. - Make sure to handle edge cases such as empty strings or no repetition required (e.g., `1[a]` should return `\\"a\\"`). Good luck and happy coding!","solution":"def decode_string(s): Decodes the encoded string based on the described pattern. :type s: str :rtype: str stack = [] cur_num = 0 cur_str = \'\' for char in s: if char.isdigit(): cur_num = cur_num * 10 + int(char) elif char == \'[\': stack.append((cur_str, cur_num)) cur_str = \'\' cur_num = 0 elif char == \']\': last_str, repeat_num = stack.pop() cur_str = last_str + cur_str * repeat_num else: cur_str += char return cur_str"},{"question":"# Tree Height Calculation In this exercise, you are required to write a function that calculates the height of a binary search tree. The height of a tree is defined as the number of levels in the tree from the root node to the deepest leaf node. Function Signature: ```python def height(root: Node) -> int: ``` Input: * `root` (Node): The root node of the binary search tree. Output: * `int`: The height of the tree. Example: Consider the following Binary Search Tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` The height of this tree is `4`. Constraints: * 0 <= number of nodes <= 10^4 * The tree nodes contain unique integer values. Requirements: 1. Handle the edge case where the tree is empty (return 0). 2. Ensure efficient traversal through recursive implementation. # Implementation: Use the provided class structure to test the solution in Python: ```python class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(key, self.root) def _insert(self, key, node): if key < node.val: if node.left is None: node.left = Node(key) else: self._insert(key, node.left) else: if node.right is None: node.right = Node(key) else: self._insert(key, node.right) import unittest def height(root): if root is None: return 0 else: return 1 + max(height(root.left), height(root.right)) class TestSuite(unittest.TestCase): def setUp(self): self.tree = BinarySearchTree() self.tree.insert(9) self.tree.insert(6) self.tree.insert(12) self.tree.insert(3) self.tree.insert(8) self.tree.insert(10) self.tree.insert(15) self.tree.insert(7) self.tree.insert(18) def test_height(self): self.assertEqual(4, height(self.tree.root)) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(key, self.root) def _insert(self, key, node): if key < node.val: if node.left is None: node.left = Node(key) else: self._insert(key, node.left) else: if node.right is None: node.right = Node(key) else: self._insert(key, node.right) def height(root): if root is None: return 0 else: return 1 + max(height(root.left), height(root.right))"},{"question":"# Question: Implement a function called `count_digits_in_string`, which takes a single string as input. The function\'s purpose is to calculate and return a dictionary where each key is a digit (0-9), and the corresponding value is the count of that digit in the string. All characters in the input string should be processed, and any non-numeric characters should be ignored. Input: - A single string `s`. Output: - A dictionary with digits (as keys) from \'0\' to \'9\' and corresponding counts (as values). Constraints: - The input string will be non-empty and can contain any printable character. # Example: ```python >>> count_digits_in_string(\\"ab1234cd56789\\") {\'0\': 0, \'1\': 1, \'2\': 1, \'3\': 1, \'4\': 1, \'5\': 1, \'6\': 1, \'7\': 1, \'8\': 1, \'9\': 1} >>> count_digits_in_string(\\"hello2022\\") {\'0\': 1, \'1\': 0, \'2\': 3, \'3\': 0, \'4\': 0, \'5\': 0, \'6\': 0, \'7\': 0, \'8\': 0, \'9\': 0} ``` # Implementation Notes: - Iterate over each character in the string. - Maintain a dictionary to count digit occurrences. - Ignore any characters that are not digits.","solution":"def count_digits_in_string(s): Returns a dictionary where keys are digits (0-9) and values are their counts in the string `s`. digit_count = {str(i): 0 for i in range(10)} for char in s: if char.isdigit(): digit_count[char] += 1 return digit_count"},{"question":"# Pancake Sort Challenge Context: Pancake Sort is a theoretical sorting algorithm where the only allowed operation is to reverse the elements in a subarray, similar to rearranging pancakes using a spatula by flipping sections of the stack. Although not practical compared to other sorting algorithms like QuickSort or MergeSort, it provides insight into algorithm design through manipulative data transformations. Problem Statement: Implement a function `pancake_sort(arr)` that sorts an array of integers in non-decreasing order using the Pancake Sort algorithm. The function should be efficient and handle edge cases gracefully. Function Signature: ```python def pancake_sort(arr: List[int]) -> List[int]: ``` Input: - `arr` is a list of integers with length (N) (0 ≤ (N) ≤ (10^3)). - All elements in `arr` can be negative, zero, or positive integers. Output: - Return a list of integers sorted in non-decreasing order. Constraints: - The algorithm should be implemented in place, meaning you should not use additional arrays for sorting. - Aim for a time complexity of (O(N^2)) and space complexity of (O(1)). Examples: ```python assert pancake_sort([3, 2, 4, 1]) == [1, 2, 3, 4] assert pancake_sort([1, 2, 3]) == [1, 2, 3] assert pancake_sort([8, 5, 2, 9, 5, 6, 3]) == [2, 3, 5, 5, 6, 8, 9] assert pancake_sort([]) == [] ``` Guidance: - First, locate the maximum value in the unsorted portion of the list. - Flip the subarray to bring this maximum value to the front. - Then, flip it again to place it into its final position. - Repeat the above steps for the unsorted portion of the array reducing its size by 1 in each iteration.","solution":"from typing import List def pancake_sort(arr: List[int]) -> List[int]: def flip(end: int): start = 0 while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 def find_max_index(end: int) -> int: max_index = 0 for i in range(1, end + 1): if arr[i] > arr[max_index]: max_index = i return max_index n = len(arr) for size in range(n, 1, -1): max_index = find_max_index(size - 1) if max_index != size - 1: flip(max_index) flip(size - 1) return arr"},{"question":"You are given a list of words, where each word is comprised of lowercase English letters. Your task is to transform each word into its corresponding Morse code representation, then determine how many unique Morse code representations exist in the list. Each English letter maps to a series of dots and dashes, as given in the diagram below: ``` \'a\': \\".-\\", \'b\': \\"-...\\", \'c\': \\"-.-.\\", \'d\': \\"-..\\", \'e\': \\".\\", \'f\': \\"..-.\\", \'g\': \\"--.\\", \'h\': \\"....\\", \'i\': \\"..\\", \'j\': \\".---\\", \'k\': \\"-.-\\", \'l\': \\".-..\\", \'m\': \\"--\\", \'n\': \\"-.\\", \'o\': \\"---\\", \'p\': \\".--.\\", \'q\': \\"--.-\\", \'r\': \\".-.\\", \'s\': \\"...\\", \'t\': \\"-\\", \'u\': \\"..-\\", \'v\': \\"...-\\", \'w\': \\".--\\", \'x\': \\"-..-\\", \'y\': \\"-.--\\", \'z\': \\"--..\\" ``` Write a function `unique_morse_transformations(words: List[str]) -> int` that returns the number of unique Morse code transformations among all given words. Here are the detailed steps: 1. Create a Morse code dictionary. 2. Convert each word to its Morse code equivalent. 3. Count how many unique Morse code representations there are. # Input - `words` - List of words (1 <= len(words) <= 100, 1 <= len(word) <= 12). # Output - An integer representing the number of unique Morse code transformations in the list. # Constraints - Words consist of lowercase English letters only. # Example ```python Example 1: Input: words = [\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"] Output: 2 Explanation: The transformation of each word is: \\"gin\\" -> \\"--...-.\\" \\"zen\\" -> \\"--...-.\\" \\"gig\\" -> \\"--...--.\\" \\"msg\\" -> \\"--...--.\\" There are 2 unique transformations: \\"--...-.\\" and \\"--...--.\\". ``` # Note 1. Implement a helper function `convert_morse_word(word: str) -> str` to convert a single word into its Morse code representation. 2. Use a set to store unique Morse code transformations to optimize look-ups and avoid duplicates.","solution":"from typing import List def unique_morse_transformations(words: List[str]) -> int: morse_code_dict = { \'a\': \\".-\\", \'b\': \\"-...\\", \'c\': \\"-.-.\\", \'d\': \\"-..\\", \'e\': \\".\\", \'f\': \\"..-.\\", \'g\': \\"--.\\", \'h\': \\"....\\", \'i\': \\"..\\", \'j\': \\".---\\", \'k\': \\"-.-\\", \'l\': \\".-..\\", \'m\': \\"--\\", \'n\': \\"-.\\", \'o\': \\"---\\", \'p\': \\".--.\\", \'q\': \\"--.-\\", \'r\': \\".-.\\", \'s\': \\"...\\", \'t\': \\"-\\", \'u\': \\"..-\\", \'v\': \\"...-\\", \'w\': \\".--\\", \'x\': \\"-..-\\", \'y\': \\"-.--\\", \'z\': \\"--..\\" } def convert_morse_word(word: str) -> str: return \'\'.join(morse_code_dict[char] for char in word) unique_transformations = {convert_morse_word(word) for word in words} return len(unique_transformations)"},{"question":"Context You are assigned to work on a project where you need to analyze data in a series of linked lists. A common requirement is to find specific elements relative to the end of these lists efficiently. Task Write a function `find_kth_to_last` that when given the head of a singly linked list and an integer k, returns the k-th to last element of the list. Implementation Details: - **Function Signature**: ```python def find_kth_to_last(head: Node, k: int) -> Node: ``` - **Input**: - `head`: The head node of a singly linked list where each node is an instance of the provided `Node` class. - `k`: An integer representing the k-th position from the last element (0 based). - **Output**: - Return the node which is k-th to the last element of the list. If such element does not exist, raise an `IndexError`. - **Constraints**: - The linked list can have between 0 and 10^6 nodes. - k will be a non-negative integer. - **Performance**: - Your solution should be optimal in terms of time complexity, targeting (O(N)) time where (N) is the number of nodes in the list. - Aim to use (O(1)) additional space for the optimal solution. Example: ```python # Define test linked list a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Example usage kth_node = find_kth_to_last(a1, 4) print(kth_node.val) # Output should be \\"D\\" ``` Note: - Ensure your solution handles edge cases such as empty lists and invalid k values appropriately by raising an `IndexError`.","solution":"class Node: def __init__(self, val=None, next=None): self.val = val self.next = next def find_kth_to_last(head: Node, k: int) -> Node: Find the k-th to last element of a singly linked list. Parameters: head (Node): The head node of the singly linked list. k (int): The zero-based position from the end of the list. Returns: Node: The k-th to last node. Raises: IndexError: If k is larger than the list length or the list is empty. if not head: raise IndexError(\\"List is empty\\") fast = slow = head # Move the fast pointer k steps ahead for _ in range(k): if not fast.next: raise IndexError(\\"Index out of range\\") fast = fast.next # Move both pointers until fast reaches the end while fast.next: slow = slow.next fast = fast.next # Now slow is the k-th to last element return slow"},{"question":"# Prime Number Generation Challenge Objective Given an integer `n`, write a Python function to generate all prime numbers less than or equal to `n`. Function Signature ```python def generate_primes(n: int) -> list: pass ``` Input * An integer `n` (1 <= n <= 10^6) Output * Return a list of all prime numbers less than or equal to `n` in ascending order. Constraints * Ensure that your solution runs efficiently with the given constraint. Example ```python print(generate_primes(10)) # Output: [2, 3, 5, 7] print(generate_primes(20)) # Output: [2, 3, 5, 7, 11, 13, 17, 19] ``` Notes * Consider performance implications for large values of `n`. * Pay attention to edge cases such as: - When `n` is 1 (output should be an empty list as there are no primes ≤ 1). - When `n` is a prime number itself (it should be included in the output).","solution":"def generate_primes(n: int) -> list: Generates all prime numbers less than or equal to `n`. if n < 2: return [] sieve = [True] * (n + 1) p = 2 while (p * p <= n): if sieve[p] == True: for i in range(p * p, n + 1, p): sieve[i] = False p += 1 primes = [p for p in range(2, n + 1) if sieve[p]] return primes"},{"question":"**Scenario:** A renowned tech company is in the process of improving their database systems. They need an efficient way to convert sorted unique user IDs into a height-balanced Binary Search Tree (BST) for quick search and retrieval operations. You have been asked to implement this conversion. **Task:** Given the `TreeNode` class and a function signature `array_to_bst(nums)`, write a function that converts a sorted array `nums` into a height-balanced BST. # Function Signature ```python def array_to_bst(nums: List[int]) -> TreeNode: ``` # Input - `nums`: A list of integers where elements are sorted in ascending order. # Output - Returns the root node of a height-balanced BST. # Constraints 1. The input array `nums` will contain between 0 and 10,000 elements. 2. Each element in `nums` is unique. # Requirements - Your function should aim for optimal time and space complexity. - Ensure the resulting BST is height-balanced (for every node in the BST, the depth difference between left and right subtrees is at most 1). # Example ```python Input: nums = [-10, -3, 0, 5, 9] Output: A BST with the structure: 0 / -3 9 / / -10 5 Explanation: - The middle element 0 becomes root. - Subarray [-10, -3] forms the left subtree. - Subarray [5, 9] forms the right subtree. ``` # Note - Your function may not produce the exact same BST structure as shown in the example, but it should be height-balanced. **Assessment Criteria**: - Correctness: The function should return the root of a height-balanced BST. - Efficiency: The function should operate within the time and space constraints. - Edge Cases Handling: Consider cases such as empty arrays and small arrays.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def array_to_bst(nums: List[int]) -> Optional[TreeNode]: Converts a sorted array into a height-balanced BST. :param nums: List[int] - A list of integers sorted in ascending order. :return: TreeNode - The root node of the height-balanced BST. def helper(left: int, right: int) -> Optional[TreeNode]: if left > right: return None mid = (left + right) // 2 node = TreeNode(nums[mid]) node.left = helper(left, mid - 1) node.right = helper(mid + 1, right) return node return helper(0, len(nums) - 1)"},{"question":"# Segment Tree: Range Minimum Query with Updates You are tasked with implementing a segment tree data structure to efficiently process range minimum queries (RMQ) and point updates. Given an array of integers, you need to build a segment tree to answer these queries: 1. `range_min(L, R)`: Returns the minimum value in the sub-range [L, R] of the array. 2. `update(index, value)`: Updates the element at the specified index to the given value and updates the segment tree accordingly. **Implement the SegmentTree class with the following method signatures:** ```python class SegmentTree: def __init__(self, arr: List[int]): Initialize the segment tree with the given array and construct the tree. :param arr: List of integers to build the segment tree from. def range_min(self, L: int, R: int) -> int: Return the minimum value in the sub-range [L, R]. :param L: Starting index of the range (inclusive). :param R: Ending index of the range (inclusive). :return: Minimum value in the sub-range [L, R]. def update(self, index: int, value: int): Update the element at the given index to the new value and update the segment tree. :param index: Index of the element to update. :param value: New value of the element. ``` **Constraints:** - The array size can be up to `10^5`. - The array elements are integers within the range `[-10^9, 10^9]`. - 1 <= L <= R < size of the array. - Multiple queries and updates will be performed in any order. **Example:** ```python arr = [2, 4, 5, 3, 4] tree = SegmentTree(arr) assert tree.range_min(1, 3) == 3 assert tree.range_min(0, 2) == 2 tree.update(1, 1) assert tree.range_min(0, 2) == 1 ``` --- This question will assess your ability to understand and implement an advanced data structure such as the Segment Tree, ensuring efficient range queries and updates are handled correctly.","solution":"class SegmentTree: def __init__(self, arr): Initialize the segment tree with the given array and construct the tree. :param arr: List of integers to build the segment tree from. self.n = len(arr) self.tree = [0] * (2 * self.n) # Build the segment tree # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def range_min(self, L, R): Return the minimum value in the sub-range [L, R]. :param L: Starting index of the range (inclusive). :param R: Ending index of the range (inclusive). :return: Minimum value in the sub-range [L, R]. # Convert range to segment tree representation L += self.n R += self.n + 1 min_val = float(\'inf\') while L < R: if L % 2 == 1: min_val = min(min_val, self.tree[L]) L += 1 if R % 2 == 1: R -= 1 min_val = min(min_val, self.tree[R]) L //= 2 R //= 2 return min_val def update(self, index, value): Update the element at the given index to the new value and update the segment tree. :param index: Index of the element to update. :param value: New value of the element. # Set value at the leaf node pos = self.n + index self.tree[pos] = value # Update internal nodes while pos > 1: pos //= 2 self.tree[pos] = min(self.tree[2 * pos], self.tree[2 * pos + 1])"},{"question":"**Problem**: You are building a web categorization tool that needs to identify the primary domain from a list of URLs. Write a function `extract_domain_name` that accepts a URL as a string and returns the primary domain name as a string. **Function Signature:** ```python def extract_domain_name(url: str) -> str: ``` **Input**: * `url` (str): A string representing a URL. **Output**: * A string representing the domain name extracted from the URL. **Constraints**: * The input URL will always be a valid URL. * Do not use any built-in libraries such as `re` (regular expression) or `urlparse`, except the built-in `split()` function. **Requirements**: 1. Your function should handle URLs with `http`, `https`, and other protocols. 2. Your function should manage URLs with and without `www`. 3. Your function should be efficient with a time complexity of O(n) and space complexity of O(n). **Examples**: ```python assert extract_domain_name(\\"http://github.com/SaadBenn\\") == \\"github\\" assert extract_domain_name(\\"http://www.zombie-bites.com\\") == \\"zombie-bites\\" assert extract_domain_name(\\"https://www.cnet.com\\") == \\"cnet\\" assert extract_domain_name(\\"https://abc.def.something.com\\") == \\"abc\\" assert extract_domain_name(\\"http://example.co.uk\\") == \\"example\\" ``` **Note**: * Consider edge cases where URLs include uncommon subdomains or top-level domains. * Ensure to handle cases where the URLs do not contain `www`, by fetching the correct part of the domain.","solution":"def extract_domain_name(url: str) -> str: Extracts the primary domain name from a given URL. # Remove the protocol section if \'://\' in url: url = url.split(\'://\', 1)[1] # Remove the path section if it exists if \'/\' in url: url = url.split(\'/\', 1)[0] # Split the remaining section by dots domain_parts = url.split(\'.\') if \'www\' in domain_parts: domain_parts.remove(\'www\') # Return the first part of the domain return domain_parts[0]"},{"question":"You are tasked with implementing a function `find_nearest_neighbors` to classify a set of queries based on the nearest neighbor algorithm. The function should take a list of query vectors and a dictionary representing the training set. Each query in the list should be classified by its nearest neighbor in the training set. Function Signature ```python def find_nearest_neighbors(queries, training_set): Classifies each query vector based on the nearest neighbor in the training set. Arguments: queries: List of tuples where each tuple represents a vector. training_set: Dictionary where keys are tuples representing vectors and values are their respective labels. Returns: List of labels representing the nearest neighbor classification for each query. pass ``` Input 1. `queries`: A list of tuples, where each tuple has the same length. - Example: [(1, 2), (3, 4)] 2. `training_set`: A dictionary where keys are tuples (vectors) and values are their corresponding labels (strings). - Example: {(1, 2): \\"A\\", (5, 6): \\"B\\"} Output A list of labels corresponding to the nearest neighbor of each query vector. - Example: [\\"A\\", \\"B\\"] Constraints 1. The length of each vector in `queries` and `training_set` will be the same. 2. The number of dimensions of each vector will not exceed 100. 3. The number of vectors in `queries` and `training_set` will not exceed 10^4. Example ```python queries = [(1, 2), (3, 3)] training_set = {(1, 2): \\"A\\", (3, 4): \\"B\\"} # Expected Output: [\\"A\\", \\"B\\"] print(find_nearest_neighbors(queries, training_set)) ``` Performance Requirements The implementation should efficiently handle the upper constraint limits. # Instructions for Students 1. Implement the `find_nearest_neighbors` function. 2. Ensure your implementation considers edge cases such as empty query sets or training sets. 3. Optimize distance calculations for large input sizes if possible.","solution":"import math def find_nearest_neighbors(queries, training_set): def euclidean_distance(vec1, vec2): return math.sqrt(sum((x - y) ** 2 for x, y in zip(vec1, vec2))) results = [] for query in queries: nearest_label = None min_distance = float(\'inf\') for train_vec, label in training_set.items(): distance = euclidean_distance(query, train_vec) if distance < min_distance: min_distance = distance nearest_label = label results.append(nearest_label) return results"},{"question":"**Base Conversion Challenge** You are required to implement two functions: `convert_base` and `parse_base`. These functions will convert integers to strings in a specified base and vice versa, similar to the provided examples. Your task tests understanding of numeric systems and ensures students handle common edge cases effectively. # Function 1: `convert_base(num, base)` # Input: - `num` (int): The number to convert; can be negative. - `base` (int): The target base, ranging from 2 to 36. # Output: - (str): The string representation of `num` in the target base. # Example: ```python convert_base(5, 2) returns \'101\' convert_base(-15, 16) returns \'-F\' ``` # Function 2: `parse_base(str_num, base)` # Input: - `str_num` (str): The base-string to convert to an integer; can be negative. - `base` (int): The base of the string, ranging from 2 to 36. # Output: - (int): The integer representation of `str_num`. # Example: ```python parse_base(\'101\', 2) returns 5 parse_base(\'-F\', 16) returns -15 ``` # Constraints: - The base should be between 2 and 36 (inclusive). - The `str_num` should only contain valid characters for the base. - Negative numbers and their representations should be handled correctly. # Requirements: 1. Pay special attention to edge cases, such as zero, negative numbers, and the upper limit of the base. 2. Optimize for readability and performance where possible. # Objective: Your solution will be evaluated based on correctness, efficiency, and handling of edge cases. Use appropriate error handling to ensure robustness.","solution":"def convert_base(num, base): Converts an integer to a string representation in the given base. :param num: int :param base: int :return: str if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36.\\") if num == 0: return \\"0\\" digits = \'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\' negative = num < 0 num = abs(num) result = \'\' while num > 0: remainder = num % base result = digits[remainder] + result num = num // base if negative: result = \'-\' + result return result def parse_base(str_num, base): Converts a string representation of a number in the given base to an integer. :param str_num: str :param base: int :return: int if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36.\\") digits = \'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\' str_num = str_num.upper() negative = str_num[0] == \'-\' if negative: str_num = str_num[1:] num = 0 for char in str_num: num = num * base + digits.index(char) if negative: num = -num return num"},{"question":"You are asked to implement a modified version of Dijkstra\'s algorithm for a given directed graph. The graph is represented with a list of edges, where each edge is a triplet (source, destination, weight). Your task is to find the shortest path from a given source vertex to all other vertices in the graph. # Input * An integer `n` representing the number of vertices in the graph (0 indexed). * A list of triplets `edges` of form (source, destination, weight), representing the edges of the graph. * An integer `src` representing the source vertex. # Output * Return a list of distances where `dist[i]` represents the shortest distance from the source vertex to vertex `i`. If a vertex is unreachable, its distance should be `float(\'inf\')`. # Constraints * `1 <= n <= 1000` * `0 <= len(edges) <= 10000` * `0 <= source, destination < n` * `0 <= weight <= 1000` # Performance Requirements Make your algorithm as efficient as possible. Aim for a time complexity of O(E log V) if possible. # Example Input ```python n = 5 edges = [(0, 1, 10), (0, 4, 5), (1, 2, 1), (2, 3, 4), (4, 1, 3), (4, 2, 9), (4, 3, 2)] src = 0 ``` Output ```python [0, 8, 9, 7, 5] ``` # Function Signature ```python def dijkstra_shortest_path(n, edges, src): # your code here pass ``` # Instructions 1. Implement `dijkstra_shortest_path` function as described above. 2. Ensure that your function handles all edge cases efficiently. 3. Avoid using any libraries other than those included in Python\'s standard library.","solution":"import heapq import sys def dijkstra_shortest_path(n, edges, src): Implement Dijkstra\'s algorithm to find the shortest path from the source to all vertices. Parameters: n: int - number of vertices in the graph edges: list of tuple(source, destination, weight) - edges of the graph src: int - source vertex Returns: list of int - distances from source to each vertex. If a vertex is unreachable, its distance will be float(\'inf\'). # Initialize the adjacency list graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) # Initialize the distance to all nodes as infinite and distance to source as 0 dist = [float(\'inf\')] * n dist[src] = 0 # Priority queue to store (distance, node) pq = [(0, src)] while pq: current_distance, current_node = heapq.heappop(pq) # If the distance popped is greater than the currently known distance, we skip processing if current_distance > dist[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return dist"},{"question":"# Problem: Generate All Subsets Given a set of distinct integers `nums`, you are required to implement a function `generate_subsets` that returns all possible subsets of the provided set. The solution must not contain duplicate subsets and should consider the following requirements: * `nums` will contain only distinct integers. * For example, if `nums = [1,2,3]`, all possible subsets would be: ```plaintext [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] ``` Function Signature ```python def generate_subsets(nums: List[int]) -> List[List[int]]: pass ``` # Input * A list of integers `nums` where (1 leq text{len(nums)} leq 16) and (-10 leq text{nums[i]} leq 10). # Output * A list of lists containing all possible subsets of the input list `nums`. # Constraints * The solution must handle edge cases including empty input array and arrays with a single element. * The output should not include duplicate subsets. # Example Input: ```python nums = [1, 2, 3] ``` Output: ```python [ [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3] ] ``` # Notes * You can assume the input list `nums` does not contain duplicate elements. * The order of the subsets in the output does not matter. # Additional Information * Consider the performance implications and choose an appropriate implementation method (either backtracking or iterative approach). * Your implementation should be efficient and concise.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: Generate all possible subsets of the provided set of distinct integers. Args: nums (List[int]): List of distinct integers Returns: List[List[int]]: A list of all possible subsets of nums result = [[]] for num in nums: result += [curr + [num] for curr in result] return result"},{"question":"# Scenario: You work for a tech company that requires efficient keyword highlighting in text processing. The provided words may contain multiple substrings that match a list of given symbols. Your task is to develop a function that finds the longest matching symbol in each word and surrounds it with square brackets. # Task: Write a function that, given a list of words and a list of symbols, processes each word to highlight the longest matching symbol with square brackets. If none of the symbols match a specific word, the word should remain unchanged. # Function Signature: ```python def highlight_symbols(words: List[str], symbols: List[str]) -> List[str]: ``` # Input: * `words`: A list of words (strings) you need to process. * `symbols`: A list of symbols (strings) you need to find and highlight in the words. # Output: * Returns a list of words with the longest matching symbols highlighted. If no symbol matches a word, the word should not be altered. # Constraints: * The length of the words and symbols lists will not exceed 10^4 elements. * Each word and symbol is composed of lowercase and uppercase English letters. * The words and symbols may differ in their lengths with a maximum length of 100 characters. # Example: **Input**: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] ``` **Output**: ```python [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Notes: * In the word \\"Amazon\\", the symbol \\"Am\\" is recognized as the longest match. * In the word \\"Microsoft\\", the symbol \\"cro\\" is recognized as the longest match. * In the word \\"Google\\", the symbol \\"le\\" is recognized as the longest match.","solution":"from typing import List def highlight_symbols(words: List[str], symbols: List[str]) -> List[str]: Processes each word in the words list to highlight the longest matching symbol with square brackets. If no symbols match, the word remains unchanged. highlighted_words = [] for word in words: longest_match = \\"\\" for symbol in symbols: if symbol in word and len(symbol) > len(longest_match): longest_match = symbol if longest_match: word = word.replace(longest_match, f\\"[{longest_match}]\\") highlighted_words.append(word) return highlighted_words"},{"question":"# Question: Remove Reoccurring Characters Context You work at a company where user input needs to be sanitized to ensure all characters in a string are unique but in the order of their first appearance. Your task is to write a function to address this requirement. Requirements Implement a function `remove_reoccurring_characters(string: str) -> str` that removes all reoccurring characters from the input string, retaining only the first occurrence of each character. Input * A single string `string` with a length of up to 10^6 characters. The string may contain any character. Output * A new string with all reoccurring characters removed, preserving only the first occurrence of each character and maintaining the order. Constraints * The string can include any characters (alphabetic, numeric, symbols, whitespace). * The solution should be optimized for time and space given the potentially large input size. Performance Requirements * Time Complexity: O(n) * Space Complexity: O(n) Example ```plaintext Input: \\"abbcad\\" Output: \\"abcd\\" Input: \\"google\\" Output: \\"gole\\" Input: \\"\\" Output: \\"\\" ``` Function Signature ```python def remove_reoccurring_characters(string: str) -> str: # your implementation goes here ```","solution":"def remove_reoccurring_characters(string: str) -> str: Returns a string with all reoccurring characters removed, preserving only the first occurrence of each character and maintaining the order of first appearance. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"Context: You are tasked with improving a dynamic list data structure where elements are frequently inserted in a sorted manner. To enhance the efficiency of insertions, you need to implement an algorithm that efficiently finds the correct position for new elements. Objective: Write a function `find_insert_position(sorted_list, value)` that takes a sorted list of integers and a target value, and returns the index where the target value should be inserted to maintain sorted order. Function Signature: ```python def find_insert_position(sorted_list: List[int], value: int) -> int: pass ``` Input: * `sorted_list`: A list of integers in non-decreasing order (`1 <= len(sorted_list) <= 10^5`). * `value`: An integer (`-10^6 <= value <= 10^6`). Output: * An integer representing the index where the value should be inserted in the sorted list to keep it in sorted order. Constraints: * The list may contain duplicates. * The solution should aim for O(log n) time complexity. * Do not use built-in functions that directly perform binary search. Example: ```python print(find_insert_position([1, 3, 5, 6], 5)) # Output: 2 print(find_insert_position([1, 3, 5, 6], 2)) # Output: 1 print(find_insert_position([1, 3, 5, 6], 7)) # Output: 4 print(find_insert_position([1, 3, 5, 6], 0)) # Output: 0 ``` Explanation: For each example, the function finds the index where the target value should be inserted to maintain the sorted order of the list.","solution":"def find_insert_position(sorted_list, value): Finds the index where the value should be inserted in the sorted list to keep it in sorted order. Args: sorted_list (List[int]): A list of integers in non-decreasing order. value (int): The target value to be inserted. Returns: int: The index where the target value should be inserted. left, right = 0, len(sorted_list) while left < right: mid = (left + right) // 2 if sorted_list[mid] < value: left = mid + 1 else: right = mid return left"},{"question":"# Efficient Insertion and Lookup in a Binary Search Tree You are required to implement a Binary Search Tree (BST) class in Python. This class should support insertion of values and lookup operations to check if a value exists in the tree. # Requirements 1. **Insert Value**: - The tree should allow insertion of unique integer values only. - Values should be inserted following BST properties. 2. **Lookup Value**: - The tree should be able to search a given integer and return True if it exists, otherwise return False. # Constraints - The values to be inserted and looked up will strictly be integers. - Negative values and zero should be handled correctly. - Assume the tree will handle up to 10,000 insertions/lookup operations efficiently. Methods to Implement - `insert(val: int) -> None`: Inserts a value into the BST. - `exists(val: int) -> bool`: Checks if a value exists in the BST. # Example Usage ```python bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) print(bst.exists(10)) # Output: True print(bst.exists(7)) # Output: False ``` # Performance Requirements - Implementing a naive BST is acceptable, but strive for O(log n) complexity for average cases. - Consider edge cases such as empty tree and skewed tree (all nodes to the left or right).","solution":"class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: if self.root is None: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) elif val > node.val: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) # If val == node.val, do nothing (no duplicates allowed) def exists(self, val: int) -> bool: return self._exists(self.root, val) def _exists(self, node, val): if node is None: return False if val == node.val: return True elif val < node.val: return self._exists(node.left, val) else: return self._exists(node.right, val)"},{"question":"# Quick Sort Implementation with Optimization Problem Description Implement an optimized `quick_sort` function that sorts an array of integers. To improve performance, your function should use the median-of-three strategy for selecting the pivot. The median-of-three takes the first, middle, and last elements of the given array and sorts them. The median value is chosen as the pivot. Input * A list of integers `arr` with size (n) where (1 leq n leq 10^5). Output * The sorted list of integers. Constraints * You should aim for average time complexity of (O(n log n)). * You must implement the sort in-place (i.e., using only a small amount of extra memory). # Performance Requirements * Handle arrays up to (10^5) elements efficiently. * Avoid the worst-case time complexity of (O(n^2)). Additional Instructions * Do not use Python’s built-in sorting functions. * Incorporate detailed comments explaining the various parts of your code. * Ensure your code handles edge cases such as already sorted arrays, arrays with all identical elements, and empty arrays. ```python def quick_sort(arr): Quick sort with median-of-three pivot optimization. if len(arr) <= 1: return arr def median_of_three(arr, low, high): mid = (low + high) // 2 if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[low] > arr[high]: arr[low], arr[high] = arr[high], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] return mid def quick_sort_recur(arr, low, high): if low < high: pivot_index = median_of_three(arr, low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = partition(arr, low, high) quick_sort_recur(arr, low, pivot - 1) quick_sort_recur(arr, pivot + 1, high) def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 quick_sort_recur(arr, 0, len(arr) - 1) return arr # Example usage: arr = [3, 6, 8, 10, 1, 2, 1] print(quick_sort(arr)) # Output should be a sorted array ```","solution":"def quick_sort(arr): Quick sort with median-of-three pivot optimization. if len(arr) <= 1: return arr def median_of_three(arr, low, high): mid = (low + high) // 2 if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[low] > arr[high]: arr[low], arr[high] = arr[high], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] return mid def quick_sort_recur(arr, low, high): if low < high: pivot_index = median_of_three(arr, low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = partition(arr, low, high) quick_sort_recur(arr, low, pivot - 1) quick_sort_recur(arr, pivot + 1, high) def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 quick_sort_recur(arr, 0, len(arr) - 1) return arr # Example usage: arr = [3, 6, 8, 10, 1, 2, 1] print(quick_sort(arr)) # Output should be a sorted array"},{"question":"In combinatorial mathematics, the function to compute the number of ways to choose `r` items from `n` items without regard to order (denoted as nCr) is fundamental. You\'re tasked with implementing this combination function efficiently. # Task Implement the function `combination(n, r)` to compute and return the number of ways to choose `r` items from `n` items using both recursive and optimized recursive with memoization methods. # Requirements 1. **Recursive Approach**: Write a function `combination(n, r)` using a straightforward recursive technique. 2. **Memoized Recursion**: Write a function `combination_memo(n, r)` that optimizes the recursive technique using memoization. 3. Both functions should handle edge cases where `r` is greater than `n` or when either `n` or `r` is negative. # Constraints - Inputs will be integers such that `0 <= r <= n <= 30`. - Your solution should handle input parameters efficiently within these constraints. # Functions Signature ```python def combination(n: int, r: int) -> int: pass def combination_memo(n: int, r: int) -> int: pass ``` # Example ```python # Example 1 print(combination(5, 2)) # Output: 10 # Example 2 print(combination_memo(5, 2)) # Output: 10 # Example 3 print(combination(6, 3)) # Output: 20 # Example 4 print(combination_memo(6, 3)) # Output: 20 ``` # Notes - If `r` is greater than `n`, the function should return 0 because it is impossible to choose more items than are available. - Use internal helper functions if needed. # Evaluation Your code will be evaluated on correctness, efficiency (particularly for the memoized approach), handling of edge cases, and adherence to the constraints.","solution":"def combination(n: int, r: int) -> int: Calculate the number of combinations (nCr) using a recursive approach. if r > n or n < 0 or r < 0: return 0 if r == 0 or r == n: return 1 return combination(n - 1, r - 1) + combination(n - 1, r) def combination_memo(n: int, r: int, memo=None) -> int: Calculate the number of combinations (nCr) using a memoized recursive approach. if r > n or n < 0 or r < 0: return 0 if r == 0 or r == n: return 1 if memo is None: memo = {} if (n, r) in memo: return memo[(n, r)] memo[(n, r)] = combination_memo(n - 1, r - 1, memo) + combination_memo(n - 1, r, memo) return memo[(n, r)]"},{"question":"# Next Higher Number with Same Digits You are given an integer `num`. Your task is to find the next higher integer that can be formed with the same digits as `num`. If no such number exists (i.e., `num` is the highest possible permutation of its digits), return -1. Function Signature ```python def next_bigger(num: int) -> int: ``` # Input * `num` (1 <= num <= 10^9): An integer whose next higher permutation is to be found. # Output * An integer representing the next higher permutation of `num` using the same set of digits, or -1 if no such number exists. # Constraints * The input number will fit within a 32-bit unsigned integer. * No leading zeros in `num`. # Examples ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(999) == -1 assert next_bigger(1) == -1 assert next_bigger(54321) == -1 ``` # Context Imagine you are sorting through a series of numbers and you need to find the next possible configuration with the digits at hand. This kind of operation is particularly useful in combinatorial testing where permutations of items need to be generated, or it can be used in scenarios like identifying the next possible combination in a sequence of entries. # Constraints and Edge Cases * When the digit pattern is the highest possible permutation (like 999 or 54321), there is no next higher number. * Ensure the function handles edge cases such as single-digit and descending order inputs correctly.","solution":"def next_bigger(num: int) -> int: Given an integer num, returns the next higher integer that can be formed with the same digits. If no such number exists, returns -1. num_list = list(str(num)) n = len(num_list) # Step 1: Find the rightmost digit that is smaller than the digit next to it for i in range(n - 2, -1, -1): if num_list[i] < num_list[i + 1]: break else: return -1 # Return -1 if no such digit is found (highest permutation) # Step 2: Find the smallest digit on the right of \'i\' and greater than num_list[i] for j in range(n - 1, i, -1): if num_list[j] > num_list[i]: break # Step 3: Swap the found digits num_list[i], num_list[j] = num_list[j], num_list[i] # Step 4: Reverse the digits after the position \'i\' num_list[i + 1:] = reversed(num_list[i + 1:]) return int(\'\'.join(num_list))"},{"question":"# Scenario You are tasked to create a utility that will interact with a file system to determine the absolute path for a series of file and directory references given in different forms. Your utility will need to handle user home directory expansions, relative paths, and should account for various edge cases. # Objective Implement a function `resolve_paths` that takes a list of file and directory references, transforms each into its absolute path, and returns a list of these absolute paths. # Input Format - A list of strings, where each string is a file or directory reference. The list length, `n`, will be between 1 and 1000 inclusive. - Each reference can be a user directory expansion (start with `~`), relative path, or absolute path. # Output Format - A list of strings, each being the absolute path corresponding to the input reference. # Constraints - Paths will be valid strings but might not necessarily exist on the filesystem. - Ensure the solution handles empty paths gracefully. - The maximum length of any path is 4096 characters. # Function Signature ```python def resolve_paths(references: list) -> list: ``` # Examples Example 1 **Input:** ```python [\\"~/file.txt\\", \\"../other_folder\\", \\"/absolute/path\\"] ``` **Output:** ```python [\\"/home/user/file.txt\\", \\"/home/user/other_folder\\", \\"/absolute/path\\"] ``` *Note*: Assume the user directory `/home/user`. Example 2 **Input:** ```python [\\"~/../file.txt\\", \\"folder/../file.txt\\", \\"./filename\\"] ``` **Output:** ```python [\\"/home/file.txt\\", \\"/home/user/file.txt\\", \\"/home/user/filename\\"] ``` *Note*: Assume the working directory is `/home/user`. # Task Completion Ensure that your utility correctly resolves the provided references into absolute paths while managing edge cases efficiently.","solution":"import os def resolve_paths(references): Resolve given file and directory references to their absolute paths. Args: references (list): List of file and directory references as strings. Returns: list: List of absolute paths corresponding to the input references. resolved_paths = [] for ref in references: resolved_path = os.path.abspath(os.path.expanduser(ref)) resolved_paths.append(resolved_path) return resolved_paths"},{"question":"You have been tasked with detecting cycles in a directed graph for a simulations system that models process dependencies. Processes may wait for resources held by other processes, and it\'s critical to detect deadlocks (cycles) that may arise. Problem Description Write a function `detect_cycles` that determines if a directed graph contains any cycles. The graph is represented as a dictionary where keys are node identifiers (strings) and values are lists of adjacent nodes (also strings). Function Signature ```python def detect_cycles(graph: dict[str, list[str]]) -> bool: pass ``` Input * `graph`: A dictionary representing a directed graph. Keys are node identifiers, values are lists of adjacent nodes (i.e., each node points to other nodes it is directly connected to). Output * Returns `True` if the graph contains at least one cycle, otherwise returns `False`. Constraints * The graph may have up to 10,000 vertices and 50,000 edges. * Vertices are represented by unique strings. * The graph may be disconnected (i.e., it may consist of more than one component). Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(detect_cycles(graph)) # Output: True ``` Notes Consider using Depth-First Search (DFS) and a color-coding mechanism (e.g., WHITE, GRAY, BLACK) to effectively manage node traversal states and detect cycles. Ensure that your implementation handles edge cases such as self-loops and disconnected components.","solution":"def detect_cycles(graph): Returns True if the graph contains a cycle, False otherwise. # Colors for marking the state of each node during DFS # WHITE - unvisited # GRAY - visiting (ancestors of the current node) # BLACK - visited WHITE, GRAY, BLACK = 0, 1, 2 color = {node: WHITE for node in graph} def dfs(node): if color[node] == GRAY: # We are visiting an ancestor node again, hence cycle detected return True if color[node] == BLACK: # Node already fully processed, no cycle found through this node return False # Mark the node as GRAY color[node] = GRAY # Visit all adjacent nodes for neighbor in graph[node]: if dfs(neighbor): return True # Mark the node as BLACK color[node] = BLACK return False # Check for cycles in every component of the graph for node in graph: if color[node] == WHITE: # Unvisited node if dfs(node): return True return False"},{"question":"# Problem Description Given an input string and a set of valid dictionary words, determine how many distinct sentences can be formed where each sentence is a whitespace-separated sequence of words contained in the dictionary. Each word in the dictionary can be used multiple times. Function Signature ```python def count_distinct_sentences(s: str, dictionary: Set[str]) -> int: ``` Input * `s` (string): A non-empty string consisting of lowercase English letters. * `dictionary` (Set[str]): A non-empty set of distinct lowercase words. Output * Return an integer representing the number of distinct sentences that can be formed. Constraints * `1 <= len(s) <= 20` * `1 <= len(dictionary) <= 10^3` * Each word in the dictionary has a length between 1 and 20. Example ```python # Example 1 s = \\"appletablet\\" dictionary = {\\"apple\\", \\"tablet\\"} # Output: 1 (\\"apple tablet\\") # Example 2 s = \\"applet\\" dictionary = {\\"app\\", \\"let\\", \\"apple\\", \\"t\\", \\"applet\\"} # Output: 3 (\\"app let\\", \\"apple t\\", \\"applet\\") # Example 3 s = \\"thing\\" dictionary = {\\"thing\\"} # Output: 1 (\\"thing\\") ``` Implementation Notes * Ensure your implementation is both time and space efficient. * Consider utilizing memoization to avoid recalculating the results of previously computed segments.","solution":"def count_distinct_sentences(s: str, dictionary: set) -> int: def helper(s, dictionary, memo): if s in memo: return memo[s] if not s: return 1 total_sentences = 0 for word in dictionary: if s.startswith(word): total_sentences += helper(s[len(word):], dictionary, memo) memo[s] = total_sentences return total_sentences return helper(s, dictionary, {}) # Example usage: # s = \\"appletablet\\" # dictionary = {\\"apple\\", \\"tablet\\"} # print(count_distinct_sentences(s, dictionary)) # Output: 1"},{"question":"# Scenario You are working for a text editor software company, and you need to implement a function that searches for the first occurrence of a word (needle) in a given text (haystack). Your function should be efficient and handle various edge cases gracefully. # Task Implement the function `find_first_occurrence(haystack, needle)`, which returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Function Signature ```python def find_first_occurrence(haystack: str, needle: str) -> int: pass ``` # Input * `haystack`: A string containing the text to search within. (1 ≤ len(haystack) ≤ 2 * 10^4) * `needle`: A string containing the word to find. (0 ≤ len(needle) ≤ 10^2) # Output * Return an integer representing the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not found. # Constraints * The input strings `haystack` and `needle` may contain letters, digits, and special characters. * Performance requirements are relaxed when `needle` is an empty string or longer than `haystack`. # Example 1 ```python haystack = \\"hello\\" needle = \\"ll\\" find_first_occurrence(haystack, needle) ``` Output: `2` # Example 2 ```python haystack = \\"aaaaa\\" needle = \\"bba\\" find_first_occurrence(haystack, needle) ``` Output: `-1` # Example 3 ```python haystack = \\"testhaystack\\" needle = \\"\\" find_first_occurrence(haystack, needle) ``` Output: `0`","solution":"def find_first_occurrence(haystack: str, needle: str) -> int: Returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not found. # Handling the case where the needle is an empty string if needle == \\"\\": return 0 # Using Python\'s built-in string find method which is efficient return haystack.find(needle)"},{"question":"Implement a function `reverse_string(s: str) -> str` that reverses the given string `s` using one of the provided methods: Recursive, Iterative, or Pythonic. Discuss why you chose the particular method and analyze its complexities. Function Signature ```python def reverse_string(s: str) -> str: pass ``` Input - `s` (string): A non-empty string. Output - A string which is the reverse of the input string. Constraints - The length of the string `s` can be up to 10^5 characters. Requirements - The implemented method must handle both typical and edge cases efficiently. - Discuss the complexity analysis in the code comments. Performance - Aim for a solution with O(n) time complexity where n is the length of the string. # Example ```python print(reverse_string(\\"hello\\")) # Output: \\"olleh\\" print(reverse_string(\\"A\\")) # Output: \\"A\\" print(reverse_string(\\"\\")) # Output: \\"\\" ```","solution":"def reverse_string(s: str) -> str: Returns the reverse of the input string `s`. We use the Pythonic way which is both concise and efficient. This method leverages Python\'s slicing capabilities. Complexity Analysis: - Time complexity: O(n), where n is the length of the string. This is because slicing a string creates a new string with the same length. - Space complexity: O(n), where n is the length of the string. This is due to the allocation of a new string of the same length. return s[::-1]"},{"question":"# Scenario You have been tasked to implement an efficient priority queue for a scheduling system. The priority queue must support fast insertion of tasks, quick access to the task with the highest priority (lowest value), and quick removal of the highest-priority task. # Task You are required to implement a `BinaryHeap` class encapsulating a Min Heap. Specifically, you need to implement two key methods: `insert` and `remove_min`. Method 1: insert Insert a new element into the heap while maintaining the heap property. Method 2: remove_min Remove the minimum element from the heap (root element) and restore the heap property. # Function Signatures ```python class BinaryHeap: def insert(self, val: int) -> None: Insert an integer value into the BinaryHeap while maintaining the min-heap property. Parameters: val (int): The value to be inserted. Returns: None pass def remove_min(self) -> int: Remove and return the minimum element from the BinaryHeap, ensuring to maintain the min-heap property. Returns: int: The minimum element in the heap. pass ``` # Constraints * The BinaryHeap should only store integers. * There should be no duplicate values in the heap. * You can use an internal array to store heap elements. * Follow a zero-based index for array representation. * Assume all input values are within the range of 32-bit integers. # Example Test Case 1. **Sample Usage**: ```python heap = BinaryHeap() heap.insert(5) heap.insert(3) heap.insert(17) heap.insert(10) heap.insert(84) heap.insert(19) heap.insert(6) heap.insert(22) heap.insert(9) assert heap.remove_min() == 3 assert heap.remove_min() == 5 ``` # Explanation: 1. Insert values: The min-heap will look like [3, 5, 6, 9, 84, 19, 17, 22, 10]. 2. Removal of minimum (3): The heap will be reordered to [5, 9, 6, 10, 84, 19, 17, 22]. 3. Removal of minimum (5): The heap will be reordered to [6, 9, 17, 10, 84, 19, 22]. # Notes: * Do not worry about the performance of building the heap from scratch. * Ensure the heap maintains the properties after each operation.","solution":"class BinaryHeap: def __init__(self): self.heap = [] def insert(self, val: int) -> None: Insert an integer value into the BinaryHeap while maintaining the min-heap property. Parameters: val (int): The value to be inserted. Returns: None self.heap.append(val) self._sift_up(len(self.heap) - 1) def remove_min(self) -> int: Remove and return the minimum element from the BinaryHeap, ensuring to maintain the min-heap property. Returns: int: The minimum element in the heap. if len(self.heap) == 0: raise IndexError(\\"remove_min(): empty heap\\") min_val = self.heap[0] # Move the last value to the root and sift it down self.heap[0] = self.heap[-1] self.heap.pop() if len(self.heap) > 0: self._sift_down(0) return min_val def _sift_up(self, index): parent = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] self._sift_up(parent) def _sift_down(self, index): smallest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left] < self.heap[smallest]: smallest = left if right < len(self.heap) and self.heap[right] < self.heap[smallest]: smallest = right if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._sift_down(smallest)"},{"question":"You are tasked with implementing an enhanced nearest neighbor classifier. In addition to the plain nearest neighbor search, you must also incorporate a weighted voting scheme based on the inverse of the distance to each neighbor. The final classification is determined by the vector class that receives the highest weight sum. # Implementation 1. Write a function `distance(x: tuple, y: tuple) -> float`, which computes the Euclidean distance between vectors x and y. 2. Write a function `nearest_neighbor(x: tuple, tSet: dict) -> any`, which: - Finds the k nearest neighbors (k provided as a parameter). - Classifies the input vector based on a majority vote with weights inversely proportional to the distance. # Input - `x` (tuple): The input vector. - `tSet` (dict): The training set where keys are vectors and values are their respective classes. - `k` (int): Number of nearest neighbors to consider. # Output - The class that the input vector is classified under. # Constraints - All vectors must have the same length. - Training set will contain at least one vector. # Example ```python def distance(x: tuple, y: tuple) -> float: # Your implementation here def nearest_neighbor(x: tuple, tSet: dict, k: int) -> any: # Your implementation here # Example Usage tSet = { (1.0, 2.0): \'A\', (2.0, 3.0): \'B\', (3.0, 4.0): \'A\', (6.0, 7.0): \'B\', } print(nearest_neighbor((2.5, 3.5), tSet, 3)) # Expected output might be \'A\' based on the provided definition. ``` # Notes - Ensure that the `distance` function throws an assertion error if the vectors have different lengths. - Use appropriate data structures and algorithms to maintain efficiency.","solution":"import math from collections import defaultdict def distance(x: tuple, y: tuple) -> float: Computes the Euclidean distance between two vectors x and y. assert len(x) == len(y), \\"Vectors must be of the same length.\\" return math.sqrt(sum((xi - yi) ** 2 for xi, yi in zip(x, y))) def nearest_neighbor(x: tuple, tSet: dict, k: int) -> any: Finds the k nearest neighbors and classifies the input vector x based on a weighted majority vote where weights are inversely proportional to the distances. distances = [] for tVec, tClass in tSet.items(): dist = distance(x, tVec) distances.append((dist, tClass)) # Sort by distance and pick k closest neighbors nearest = sorted(distances, key=lambda d: d[0])[:k] # Weighted voting based on inverse distance weight_sums = defaultdict(float) for dist, tClass in nearest: weight_sums[tClass] += 1 / (dist + 1e-9) # Add a small value to avoid division by zero # Determine the class with the highest weight sum return max(weight_sums.items(), key=lambda item: item[1])[0]"},{"question":"# RSA Encryption Application # Problem Statement You are tasked with enhancing the performance of an RSA encryption algorithm by implementing an optimized solution for calculating the modular inverse and prime number generation. Using this optimized RSA key generation, encryption, and decryption should be made more efficient. # Requirements 1. **Optimized Modular Inverse Calculation**: Implement an efficient method for calculating the inverse of a number modulo (m). 2. **Efficient Prime Generation**: Replace the current prime generation method with a faster algorithm, such as probabilistic tests (Miller-Rabin). 3. **Enhanced Key Generation**: Implement the RSA key generation utilizing the optimizations developed. # Input and Output Format - **Function 1**: `generate_key(k: int) -> Tuple[int, int, int]` - **Input**: Integer `k` which specifies the bit length of the modulus `n`. - **Output**: Tuple `(n, e, d)` representing the modulus and the public/private exponents. - **Function 2**: `encrypt(data: int, e: int, n: int) -> int` - **Input**: Integer `data` to be encrypted, public exponent `e` and modulus `n`. - **Output**: Encrypted integer `E`. - **Function 3**: `decrypt(data: int, d: int, n: int) -> int` - **Input**: Encrypted integer `data`, private exponent `d` and modulus `n`. - **Output**: Decrypted original integer `x`. # Constraints - (1 leq data < n) - (2^{(k-1)} < n < 2^{k}) # Example ```python k = 16 n, e, d = generate_key(k) data = 20 encrypted = encrypt(data, e, n) print(\\"Encrypted:\\", encrypted) decrypted = decrypt(encrypted, d, n) print(\\"Decrypted:\\", decrypted) assert decrypted == data ``` # Notes - You should benchmark your new implementations to ensure they are indeed optimized. - Make sure to handle any potential edge cases to avoid infinite loops or incorrect calculations.","solution":"import random from typing import Tuple def modinv(a: int, m: int) -> int: Compute the modular inverse of a under modulo m using the Extended Euclidean Algorithm. m0, x0, x1 = m, 0, 1 if m == 1: return 0 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 if x1 < 0: x1 += m0 return x1 def is_prime(n: int, k: int = 5) -> bool: Determine if a number is prime using the Miller-Rabin primality test. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write (n-1) as 2^s * d s, d = 0, n - 1 while d % 2 == 0: s += 1 d //= 2 def miller_rabin_trial(a): x = pow(a, d, n) if x == 1 or x == n - 1: return True for _ in range(s - 1): x = pow(x, 2, n) if x == n - 1: return True return False for _ in range(k): a = random.randint(2, n - 2) if not miller_rabin_trial(a): return False return True def generate_prime_candidate(length): # Generate random numbers of bit size length return random.getrandbits(length) | (1 << length - 1) | 1 def generate_prime_number(length=16): p = 4 while not is_prime(p, 128): p = generate_prime_candidate(length) return p def generate_key(k: int) -> Tuple[int, int, int]: Generate RSA key pair with a bit length of k for n. e = 65537 # commonly used prime exponent p = generate_prime_number(k // 2) q = generate_prime_number(k // 2) n = p * q phi = (p - 1) * (q - 1) d = modinv(e, phi) return n, e, d def encrypt(data: int, e: int, n: int) -> int: Encrypt the data with the public key (e, n) return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: Decrypt the data with the private key (d, n) return pow(data, d, n)"},{"question":"Validate Stack Order Scenario You are working on a software package that requires frequent validation of stack data structures to ensure their elements are in order before performing other operations. As such, you are tasked to write a function to check if the elements in the stack are sorted in ascending order, from bottom to top. Task Implement the function `is_sorted` that accepts a stack (implemented as a Python list) and returns `True` if the stack is sorted in ascending order from bottom to top, and `False` otherwise. Function Signature ```python def is_sorted(stack: list) -> bool: pass ``` Input - `stack`: A list of integers representing the stack, where the last element in the list represents the top of the stack. Output - Returns a boolean `True` if the elements in the stack are in ascending order from the bottom to the top, `False` otherwise. Constraints - The function should not modify the original stack. Performance Requirements - Time Complexity should be O(n), where n is the number of elements in the stack. - Space Complexity should be at most O(n). Examples ```python assert is_sorted([1, 2, 3, 4, 5, 6]) == True # Sorted order assert is_sorted([6, 5, 4, 3, 2, 1]) == False # Descending order assert is_sorted([1, 3, 2]) == False # Unsorted assert is_sorted([]) == True # Empty stack assert is_sorted([42]) == True # Single element stack ```","solution":"def is_sorted(stack: list) -> bool: Check if the elements in the stack are sorted in ascending order from bottom to top. n = len(stack) if n <= 1: return True for i in range(n-1): if stack[i] > stack[i+1]: return False return True"},{"question":"# Trie Implementation for Contacts Management Background: You have been asked to develop a simple contact management system for a mobile application. The application needs to efficiently store contacts and support quick lookups to suggest names based on prefixes entered by the user (for example, for autocomplete when typing a name). Your Task: Implement a class `Contacts` using the Trie data structure to manage the contacts. Your implementation should support the following operations: 1. **add_contact(name: str)**: Add a contact name to the contacts list. 2. **search_contact(name: str) -> bool**: Check if a full contact name exists in the contacts list. 3. **suggest_contacts(prefix: str) -> List[str]**: Retrieve a list of all contact names that start with the given prefix. You may assume that all inputs are lowercase alphabet characters (\'a\' to \'z\') and that contact names are unique. The list of contacts should be maintained in lexicographical order. Constraints: - The methods should be efficient enough to handle a large number of contacts and frequent lookups. - You should handle edge cases like empty strings and prefixes that match no contacts. Example: ```python # Example usage of the Contacts class contacts = Contacts() contacts.add_contact(\\"alice\\") contacts.add_contact(\\"bob\\") contacts.add_contact(\\"alex\\") contacts.add_contact(\\"alina\\") print(contacts.search_contact(\\"alice\\")) # Output: True print(contacts.search_contact(\\"alicia\\")) # Output: False print(contacts.suggest_contacts(\\"al\\")) # Output: [\\"alice\\", \\"alina\\", \\"alex\\"] print(contacts.suggest_contacts(\\"z\\")) # Output: [] ``` Implementation: Define the `Contacts` class with the specified methods. Ensure that you test your implementation thoroughly with multiple test cases to cover edge cases and typical usage scenarios. Requirements: - The `suggest_contacts` method should return a list of names sorted in lexicographical order. - Performance of the `add_contact`, `search_contact`, and `suggest_contacts` methods should be optimal considering the nature of the problem.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Contacts: def __init__(self): self.root = TrieNode() def add_contact(self, name: str): node = self.root for char in name: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_contact(self, name: str) -> bool: node = self.root for char in name: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def suggest_contacts(self, prefix: str): node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] result = [] self._find_words_with_prefix(node, prefix, result) return result def _find_words_with_prefix(self, node, prefix, result): if node.is_end_of_word: result.append(prefix) for char in sorted(node.children): self._find_words_with_prefix(node.children[char], prefix + char, result)"},{"question":"# Power Calculation with Constraints Problem Statement You are required to implement a function that calculates the power of a given base raised to a given exponent using iterative binary exponentiation. Additionally, you should implement an optimized version that handles large numbers by taking the result modulo `10^9 + 7`. Function Signature ```python def power_with_mod(base: int, exponent: int) -> int: ``` Input * `base` (int): an integer, which could be positive or negative. * `exponent` (int): a non-negative integer. **Additional Constraints**: * Inputs `base` and `exponent` will be within the range of 0 to (10^9). Output * Returns the result of (base^{exponent}) modulo (10^9 + 7). Constraints * (base) and (exponent) are integers. * 0 ≤ base ≤ (10^9) * 0 ≤ exponent ≤ (10^9) * The result should be modulo (10^9 + 7) which is a prime number. Example ```python assert power_with_mod(2, 10) == 1024 assert power_with_mod(3, 5) == 243 assert power_with_mod(2, 1000000000) == 140625001 assert power_with_mod(0, 0) == 1 # Assuming 0^0 is 1 assert power_with_mod(1000000000, 0) == 1 # Any number to the power of 0 is 1 ``` Notes * The function must handle very large inputs efficiently. * Consider edge cases such as 0^0 and values at the boundary of the constraints. Write an optimized function in Python adhering to the specifications. Test your implementation with various test cases to ensure its accuracy and efficiency.","solution":"def power_with_mod(base: int, exponent: int) -> int: MOD = 10**9 + 7 if base == 0 and exponent == 0: return 1 # conventionally 0^0 is considered as 1 in many programming problems result = 1 base = base % MOD while exponent > 0: if (exponent % 2) == 1: result = (result * base) % MOD exponent = exponent >> 1 base = (base * base) % MOD return result"},{"question":"# Question: Generate a Word Frequency Histogram Consider a scenario where you are developing a tool to analyze word frequencies in text data. This can be used in various applications such as text analysis, search engines, or content recommendation systems. To help build this tool, your task is to implement a function that takes a list of words and returns a dictionary representing the histogram of word frequencies. **Function Signature** ```python def word_histogram(word_list: list) -> dict: ``` **Input** - `word_list`: A list of strings where each string is a word. The list can contain duplicates and is not necessarily sorted. For example, `[\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]`. **Output** - Returns a dictionary where keys are distinct words from the input list and values are the frequency counts of those words. The dictionary need not be sorted by keys or values. For example, from the input example above, the return value would be `{\\"apple\\": 3, \\"banana\\": 2, \\"orange\\": 1}`. **Constraints** - The input list can be empty, in which case the function should return an empty dictionary. - The words in the list consist only of lowercase alphabets (a-z). - Aim for an efficient solution with O(n) time complexity, where n is the length of the input list. **Example Case** ```python assert word_histogram([\\"a\\", \\"b\\", \\"a\\", \\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"d\\", \\"d\\"]) == {\\"a\\": 3, \\"b\\": 2, \\"c\\": 1, \\"d\\": 3} assert word_histogram([]) == {} assert word_histogram([\\"word\\"]) == {\\"word\\": 1} assert word_histogram([\\"repeat\\", \\"repeat\\", \\"repeat\\"]) == {\\"repeat\\": 3} ``` **Considerations** - The function should handle edge cases like an empty list, and lists of varying lengths efficiently. - The function should handle cases where the word list is highly redundant or contains many unique words equally well.","solution":"def word_histogram(word_list: list) -> dict: Returns a dictionary representing the histogram of word frequencies in the input word_list. histogram = {} for word in word_list: if word in histogram: histogram[word] += 1 else: histogram[word] = 1 return histogram"},{"question":"You are given an array `nums` which is sorted in ascending order but has been rotated at some unknown pivot such that the array now appears as a mix of two sorted subarrays. Given a target value, write a function that returns the index of the target if it is present in `nums`, otherwise, return -1. Your implementation must have a runtime complexity of `O(log n)`. # Function Signature ```python def search_in_rotated_array(nums: List[int], target: int) -> int: pass ``` # Input - `nums`: A list of integers representing the rotated sorted array. (1 ≤ len(nums) ≤ 10^4) - `target`: An integer value to search for in the array. # Output - Return the index of the target if it exists, otherwise return -1. # Constraints - The algorithm should run in O(log n) time complexity. - The array may not contain duplicate values. # Example ```python assert search_in_rotated_array([4, 5, 6, 7, 0, 1, 2], 0) == 4 assert search_in_rotated_array([4, 5, 6, 7, 0, 1, 2], 3) == -1 assert search_in_rotated_array([1], 0) == -1 ``` # Notes - Consider edge cases such as empty arrays, arrays with one element, and arrays that were not rotated (fully sorted). - Should handle different values of `target` effectively and promptly return the correct index or -1.","solution":"from typing import List def search_in_rotated_array(nums: List[int], target: int) -> int: Returns the index of the target if it is present in nums, otherwise return -1. if not nums: return -1 left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # Check if the left part is sorted if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 # Right part is sorted else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"You are given a Hermitian positive-definite matrix (A) of size (n times n). Write a function `cholesky_decomposition(A)` that returns the matrix (V) such that (V times V^*) = (A), where (V^*) denotes the conjugate transpose of (V). If the matrix (A) is not Hermitian or not positive-definite, the function should return `None`. Function Signature ```python def cholesky_decomposition(A: List[List[float]]) -> Optional[List[List[float]]]: ``` Input * `A`: A square Hermitian positive-definite matrix of size (n times n), where (1 leq n leq 100). Output * A matrix (V) of size (n times n) if the decomposition is possible, otherwise `None`. Constraints * All elements of matrix (A) are real numbers. * (A) must be Hermitian (symmetric in real matrices). * (A) must be positive-definite. Example ```python # Example 1: A = [ [4, 12, -16], [12, 37, -43], [-16, -43, 98] ] print(cholesky_decomposition(A)) # Output: # [ # [2.0, 0.0, 0.0], # [6.0, 1.0, 0.0], # [-8.0, 5.0, 3.0] # ] # Example 2: A = [ [1, 2], [2, 1] ] print(cholesky_decomposition(A)) # Output: None (Not positive-definite) ``` Implement the function to ensure it handles edge cases such as non-square, non-Hermitian, or non-positive-definite matrices appropriately. Additional Notes * Hermitian means for real matrices, they are symmetric: (A[i][j] = A[j][i]). * Positive-definite matrices have all positive eigenvalues or diagonal elements positive upon decomposition if they are truly decomposable.","solution":"from typing import List, Optional import numpy as np def cholesky_decomposition(A: List[List[float]]) -> Optional[List[List[float]]]: Perform Cholesky decomposition on a given Hermitian positive-definite matrix A. :param A: A square matrix of size n x n :return: Matrix V such that V * V^* = A, or None if A is not Hermitian or positive-definite A = np.array(A) # Check if A is square n, m = A.shape if n != m: return None # Check if A is Hermitian (Symmetric in the real case) if not np.allclose(A, A.T): return None try: # Perform Cholesky decomposition using numpy V = np.linalg.cholesky(A) return V.tolist() except np.linalg.LinAlgError: # Matrix is not positive-definite or some other numerical issue return None"},{"question":"# Sparse Matrix Multiplication Problem Statement Given two sparse matrices A and B, implement an efficient algorithm to compute the product of these matrices and return the result. The matrices will be provided as 2D lists where the majority of the elements will be zeroes. You may assume that the number of columns in matrix A is equal to the number of rows in matrix B. Input - A: List of Lists of integers representing a matrix where `A[i][j]` is the element at row `i` and column `j` of matrix A. - B: List of Lists of integers representing a matrix where `B[i][j]` is the element at row `i` and column `j` of matrix B. Output - A List of Lists of integers representing the product of matrices A and B. Constraints - 1 ≤ number of rows in A, number of columns in B ≤ 1000 - -100 ≤ A[i][j], B[i][j] ≤ 100 Example ``` Input: A = [ [1, 0, 0], [-1, 0, 3] ] B = [ [7, 0, 0], [0, 0, 0], [0, 0, 1] ] Output: [ [7, 0, 0], [-7, 0, 3] ] ``` Notes - The output matrix should be constructed by efficiently computing only the necessary multiplications. Avoid performing unnecessary calculations involving zeroes.","solution":"def sparse_matrix_multiplication(A, B): Computes the product of two sparse matrices A and B. Parameters: A (list of list of int): The first 2D matrix. B (list of list of int): The second 2D matrix. Returns: list of list of int: The resulting matrix product. # Get dimensions of input matrices num_rows_A, num_cols_A = len(A), len(A[0]) num_rows_B, num_cols_B = len(B), len(B[0]) # Initialize the result matrix with zeros result = [[0] * num_cols_B for _ in range(num_rows_A)] # Compute the product for i in range(num_rows_A): for j in range(num_cols_A): if A[i][j] != 0: for k in range(num_cols_B): result[i][k] += A[i][j] * B[j][k] return result"},{"question":"# Context You are developing a command-line tool for managing project files. One of the critical features is to consistently handle file paths entered by users. To ensure the paths are standardized, they need to be converted into their absolute forms. # Task Write a function `resolve_paths` that takes a list of file paths and returns their corresponding absolute paths. # Function Signature ```python def resolve_paths(paths: List[str]) -> List[str]: ``` # Input * `paths`: A list of strings, where each string is a file path (may be relative or absolute). # Output * A list of strings where each string is the absolute path corresponding to the input paths. # Constraints * Each path in `paths` has a length of at most 1000 characters. * The length of `paths` will not exceed 1000. # Example ```python paths = [\\"./docs/README.md\\", \\"~/notes/todo.txt\\", \\"../sibling/file.txt\\"] resolve_paths(paths) # Expected output may look something like (depending on your current working directory and user home): # [\'/home/current_user/project/docs/README.md\', \'/home/current_user/notes/todo.txt\', \'/home/current_user/sibling/file.txt\'] ``` # Requirements * Ensure the function handles paths involving user directories (`~`), relative directories (`..`), and current directories (`.`) correctly. * Do not check for file existence on the file system.","solution":"import os from typing import List def resolve_paths(paths: List[str]) -> List[str]: Resolves a list of file paths to their absolute paths. Arguments: paths -- a list of file paths (strings), can be relative or absolute. Returns: A list of absolute paths corresponding to the input paths. resolved_paths = [] for path in paths: absolute_path = os.path.abspath(os.path.expanduser(path)) resolved_paths.append(absolute_path) return resolved_paths"},{"question":"# Palindrome Permutation Checker Context Given a string, you are to determine if any permutation of the string can form a palindrome. A palindrome permutation check would ignore spaces, punctuation, and consider case insensitivity. # Task Write a function `can_form_palindrome(s)` that: 1. Normalizes the string to remove spaces, punctuation, and make it case insensitive. 2. Checks if any permutation of the given string can form a palindrome. 3. Returns `True` if any permutation can form a palindrome and `False` otherwise. # Input and Output * **Input**: A single string `s` (1 <= len(s) <= 10^5) * **Output**: A boolean `True` or `False`. # Constraints * The function should efficiently handle very large strings with up to 100,000 characters. # Performance Requirements - Time Complexity: O(n) - Space Complexity: O(1) beyond the input space # Examples 1. Input: \\"A man, a plan, a canal: Panama\\" - Output: `True` - Reason: \\"amanaP lanac a nalp a nam A\\" is a palindrome. 2. Input: \\"race a car\\" - Output: `False` - Reason: No permutation forms a palindrome. 3. Input: \\"civic\\" - Output: `True` - Reason: The string itself is a palindrome. # Implementation Notes - Think about how to leverage character frequency counts to identify if a permutation can be a palindrome. - Remember that a palindrome can have at most one character that appears an odd number of times.","solution":"import re from collections import Counter def can_form_palindrome(s): Returns True if any permutation of the string s can form a palindrome. Ignores spaces, punctuation, and is case insensitive. # Remove non-alphanumeric characters and convert to lower case s = re.sub(r\'[^A-Za-z0-9]\', \'\', s).lower() # Count frequency of each character char_counts = Counter(s) # Check the number of characters with odd frequency odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # At most one character with odd frequency is allowed for palindrome return odd_count <= 1"},{"question":"# Comb Sort Implementation for String Lists **Problem Statement**: You are provided with a list of strings. Your task is to implement the Comb Sort algorithm to sort this list of strings in ascending alphabetical order. Comb Sort is an efficient enhancement over Bubble Sort and utilizes a \\"gap\\" to compare and swap elements far apart before finalizing with a more traditional bubble sort pass. **Requirements**: 1. Implement the function `comb_sort_strings(arr: List[str]) -> List[str]` that sorts the provided list. 2. Sort the list in ascending order (lexicographical order for strings). 3. The function should handle edge cases efficiently, including empty list scenarios. **Function Signature**: ```python def comb_sort_strings(arr: List[str]) -> List[str]: pass ``` **Constraints**: - The input list will have at most 10^5 strings. - Each string will have a maximum length of 100 characters. - You cannot use any built-in sorting functions. - The implementation should be in-place and must not utilize extra space for a second list. **Example**: ```python input_list = [\\"apple\\", \\"banana\\", \\"grapes\\", \\"kiwi\\", \\"cherry\\"] print(comb_sort_strings(input_list)) # Output: [\\"apple\\", \\"banana\\", \\"cherry\\", \\"grapes\\", \\"kiwi\\"] input_list = [\\"z\\", \\"y\\", \\"x\\", \\"w\\"] print(comb_sort_strings(input_list)) # Output: [\\"w\\", \\"x\\", \\"y\\", \\"z\\"] input_list = [\\"aaa\\", \\"aa\\", \\"a\\"] print(comb_sort_strings(input_list)) # Output: [\\"a\\", \\"aa\\", \\"aaa\\"] ``` **Performance Considerations**: - Ensure that the solution works efficiently for the upper constraint of 10^5 strings. - Minimize the number of swaps and comparisons where possible. **Note**: Your implementation should adhere to the Comb Sort principles, adjusting the gap between elements and using a shrink factor, eventually switching to a gap of 1 for the final pass.","solution":"from typing import List def comb_sort_strings(arr: List[str]) -> List[str]: Implement comb sort algorithm for sorting a list of strings in ascending order. def getNextGap(gap): # Shrink gap by shrink factor of 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return int(gap) n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = getNextGap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Question: Single Non-Duplicate Number Finder You have been given an array of integers where every integer except one appears twice. Your task is to find the integer that appears only once. **Objective**: Implement a function `find_single_number(nums)` that returns the integer that appears only once in the `nums` array. **Function Signature**: ```python def find_single_number(nums: List[int]) -> int: ``` **Input**: * `nums` - A list of integers where every element appears twice except for one single element. (1 <= len(nums) <= 10^5) * You can assume that the list is non-empty and contains integers that range from -10^9 to 10^9. **Output**: * Return the integer from `nums` that appears only once. **Constraints**: * Your solution should run in linear runtime complexity O(n). * You should not use any extra memory for this (i.e., constant space complexity O(1)). **Examples**: 1. Input: `nums = [4, 1, 2, 1, 2]` Output: `4` 2. Input: `nums = [2, 2, 1]` Output: `1` 3. Input: `nums = [1]` Output: `1` **Context**: The array provided ensures that only one such number exists, and every other number appears exactly twice. The problem showcases the application of bitwise XOR operation to efficiently solve problems involving unique elements in paired data.","solution":"def find_single_number(nums): This function finds the single number in the array where every other number appears twice. The solution uses the property of XOR operation: a ^ a = 0 and a ^ 0 = a. single_number = 0 for num in nums: single_number ^= num return single_number"},{"question":"# Moving Average Implementation Question You are given a class `MovingAverage` that calculates the moving average from a stream of integers with a fixed window size. The class maintains a sliding window which ensures that the average is always computed using the most recent `size` elements. If fewer than `size` elements have been added, the average is over all the elements added so far. Function Signatures: * `__init__(self, size: int) -> None` - Initializes the `MovingAverage` object with a fixed window size. * `next(self, val: int) -> float` - Adds a new integer to the stream and returns the current moving average of the window. Input/Output Format: - **__init__(size: int)** - **Input**: An integer `size` indicating the size of the moving window (1 <= size <= 10^5). - **next(val: int) -> float** - **Input**: An integer `val` to be added to the stream (-10^5 <= val <= 10^5). - **Output**: A float representing the current moving average of the fixed window. Example: ```python m = MovingAverage(3) assert m.next(1) == 1.0 # Window is [1], average is 1/1 = 1.0 assert m.next(10) == 5.5 # Window is [1, 10], average is (1 + 10) / 2 = 5.5 assert m.next(3) == 4.66667 # Window is [1, 10, 3], average is (1 + 10 + 3) / 3 = 4.66667 assert m.next(5) == 6.0 # Window is [10, 3, 5], average is (10 + 3 + 5) / 3 = 6.0 ``` Constraints: - You can assume that the `next` method will be called at most 10^4 times. # Task: Implement the `MovingAverage` class as described. The class should handle the moving average calculation efficiently, considering the constraints provided.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int) -> None: Initialize the MovingAverage with a fixed window size. self.size = size self.window = deque() self.window_sum = 0 def next(self, val: int) -> float: Adds a new integer to the stream and returns the current moving average of the window. if len(self.window) == self.size: self.window_sum -= self.window.popleft() self.window.append(val) self.window_sum += val return self.window_sum / len(self.window)"},{"question":"# Quick Sort Implementation with Optimized Pivot Selection **Objective**: Implement a modified version of the Quick Sort algorithm which incorporates an optimized pivot selection strategy to improve performance on various types of inputs. **Context**: In practical scenarios, the performance of the basic Quick Sort algorithm can degrade significantly if the input array is already sorted or contains many duplicate elements. An optimized pivot selection strategy, such as the median-of-three approach, can help to mitigate this issue. **Function Signature**: ```python def optimized_quick_sort(arr, simulation=False): Function to sort an array using Quick Sort with an optimized pivot selection strategy. Parameters: arr (list): A list of numerical elements that need to be sorted. simulation (bool): If True, prints the array on each iteration for visualization. Returns: list: Sorted list of elements. pass ``` **Input Format**: - `arr`: A list of numbers (both integers and floats). - `simulation`: A boolean flag that, if set to True, prints the array\'s state during each iteration of the sorting process. **Output Format**: - A sorted list of numerical elements. **Constraints**: - The input list can contain up to (10^5) elements. - The elements in the input list can range from (-10^6) to (10^6). **Performance Requirements**: - Ensure that the algorithm consistently runs in O(n log n) time on average, even for edge cases. **Task**: Implement the `optimized_quick_sort` function making sure to: 1. Use a median-of-three approach to select the pivot. 2. Sort the array in-place. 3. Optionally print the array\'s state during each iteration if the `simulation` flag is set. **Example**: ```python arr = [3, 6, 8, 10, 1, 2, 1] print(optimized_quick_sort(arr)) # Output: [1, 1, 2, 3, 6, 8, 10] arr = [0, -1, -1, 8, 10, 0, -10] print(optimized_quick_sort(arr)) # Output: [-10, -1, -1, 0, 0, 8, 10] ``` **Explanation**: - The function should handle arrays with duplicate values and varied distributions of elements efficiently. - Employing the median-of-three strategy should ensure better performance over edge cases like pre-sorted arrays. - The `simulation` parameter is optional but should be implemented to aid understanding through visual output.","solution":"def optimized_quick_sort(arr, simulation=False): Function to sort an array using Quick Sort with an optimized pivot selection strategy. Parameters: arr (list): A list of numerical elements that need to be sorted. simulation (bool): If True, prints the array at certain stages for visualization. Returns: list: Sorted list of elements. def median_of_three(lo, hi): mid = (lo + hi) // 2 a, b, c = arr[lo], arr[mid], arr[hi] if a <= b <= c or c <= b <= a: return mid elif b <= a <= c or c <= a <= b: return lo else: return hi def quick_sort_recursive(lo, hi): if lo < hi: pivot_index = median_of_three(lo, hi) arr[lo], arr[pivot_index] = arr[pivot_index], arr[lo] p = partition(lo, hi) if simulation: print(arr) quick_sort_recursive(lo, p - 1) quick_sort_recursive(p + 1, hi) def partition(lo, hi): pivot = arr[lo] left_marker = lo + 1 right_marker = hi done = False while not done: while left_marker <= right_marker and arr[left_marker] <= pivot: left_marker += 1 while arr[right_marker] >= pivot and right_marker >= left_marker: right_marker -= 1 if right_marker < left_marker: done = True else: arr[left_marker], arr[right_marker] = arr[right_marker], arr[left_marker] arr[lo], arr[right_marker] = arr[right_marker], arr[lo] return right_marker quick_sort_recursive(0, len(arr) - 1) return arr"},{"question":"Problem Statement You are tasked with implementing a function that solves the \\"Two Sum\\" problem: given an array of integers, your function should return the indices of the two numbers that add up to a specific target. The function should adhere to the following requirements: 1. Each input array will have exactly one pair of numbers that add up to the target. 2. You may not use the same element more than once. # Function Signature ```python def two_sum(array: List[int], target: int) -> Tuple[int, int]: pass ``` # Input - A list of integers `array` where the length of `array` is between 2 and 10^4. - An integer `target` which is the sum we aim to find with two distinct elements in `array`. # Output - A tuple of two integers representing the indices of the two numbers adding up to `target`. # Constraints - Exactly one solution exists for each input. - The returned indices should be in any order. # Example ```python # Example 1 array = [2, 7, 11, 15] target = 9 assert two_sum(array, target) == (0, 1) # Explanation: Because array[0] + array[1] == 2 + 7 == 9, we return indices (0, 1). # Example 2 array = [3, 3] target = 6 assert two_sum(array, target) == (0, 1) # Explanation: Because array[0] + array[1] == 3 + 3 == 6, we return indices (0, 1). ``` # Notes Ensure your function does not return the same element twice and performs efficiently even for large input sizes.","solution":"from typing import List, Tuple def two_sum(array: List[int], target: int) -> Tuple[int, int]: Returns the indices of the two numbers that add up to a specific target. Args: array (List[int]): The list of integers. target (int): The target sum of two numbers from the array. Returns: Tuple[int, int]: A tuple containing the indices of the two numbers that add up to the target. num_to_index = {} for i, num in enumerate(array): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i raise ValueError(\\"No two sum solution found\\")"},{"question":"# Question: Ordered Stack with Enhanced Functionality You are asked to implement an enhanced version of an `OrderedStack` that maintains its elements in ascending order at all times. Additionally, you need to provide an optimized method to merge two ordered stacks into a single ordered stack. Objective * Create a class `EnhancedOrderedStack` which extends the functionality of the given `OrderedStack`. * Implement a method `merge(other_stack)` within this class that merges the current stack with another ordered stack (`other_stack`) and maintains the order. Method Specifications * `merge(other_stack: EnhancedOrderedStack) -> EnhancedOrderedStack`: This function takes another ordered stack and returns a new ordered stack which is the result of merging the two stacks while maintaining the elements in ascending order. Expected Input and Output * An instance of the `EnhancedOrderedStack` class. * The merge function will take another `EnhancedOrderedStack` instance and return a new `EnhancedOrderedStack` instance with merged elements in ascending order. Implementation Requirements * Ensure the `merge` operation is efficient, aiming for O(n + m) time complexity, where n and m are the sizes of the two stacks being merged. Constraints * Assume that the maximum number of elements in the stack will not exceed 10^5. Example ```python class EnhancedOrderedStack: # Implement the required methods here including the merge method. # Example Usage stack1 = EnhancedOrderedStack() stack1.push(3) stack1.push(1) stack1.push(5) stack2 = EnhancedOrderedStack() stack2.push(4) stack2.push(2) merged_stack = stack1.merge(stack2) # Expected merged_stack will have elements: 1, 2, 3, 4, 5 (from bottom to top) ``` **Note**: Ensure the `EnhancedOrderedStack` class inherits from `OrderedStack` and implements the additional functionality efficiently and correctly.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) self.stack.sort() def pop(self): if self.stack: return self.stack.pop(0) else: return None def peek(self): if self.stack: return self.stack[0] else: return None def is_empty(self): return len(self.stack) == 0 def size(self): return len(self.stack) class EnhancedOrderedStack(OrderedStack): def merge(self, other_stack): merged_stack = EnhancedOrderedStack() i, j = 0, 0 while i < len(self.stack) and j < len(other_stack.stack): if self.stack[i] < other_stack.stack[j]: merged_stack.stack.append(self.stack[i]) i += 1 else: merged_stack.stack.append(other_stack.stack[j]) j += 1 while i < len(self.stack): merged_stack.stack.append(self.stack[i]) i += 1 while j < len(other_stack.stack): merged_stack.stack.append(other_stack.stack[j]) j += 1 return merged_stack"},{"question":"Implementing an Improved Shell Sort As a software developer, you are tasked to optimize the sorting of numerical datasets. Given an array of integers, your goal is to implement an enhanced version of the Shell Sort algorithm that uses a better gap sequence to improve its performance. Instead of using the simple gap sequence (n//2, n//4, ..., 1), you can use the sequence proposed by Sedgewick which is more efficient. **Task**: Write a function `improved_shell_sort(arr)` that sorts the given array using the Shell Sort algorithm with the Sedgewick gap sequence. # Function Signature: ```python def improved_shell_sort(arr: List[int]) -> List[int]: pass ``` # Input: - `arr` (List[int]): A list of integers that needs to be sorted. # Output: - Returns the sorted list of integers in ascending order. # Constraints: - The list can contain up to 10,000 integers. - Each integer in the list will be between -10^6 and 10^6. # Performance Requirement: - The function should aim for average case time complexity better than O(n^2) by utilizing the Sedgewick gap sequence. # Example: ```python >>> improved_shell_sort([23, 12, 1, 8, 34, 54, 2, 3]) [1, 2, 3, 8, 12, 23, 34, 54] >>> improved_shell_sort([4, 3, 2, 10, 12, 1, 5, 6]) [1, 2, 3, 4, 5, 6, 10, 12] ``` # Implementation Notes: - Ensure to handle edge cases such as empty arrays or arrays with one element. - Employ the Sedgewick gap sequence: 1, 5, 19, 41, 109, ... which helps in achieving better average case performance.","solution":"from typing import List def improved_shell_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the Shell Sort algorithm with the Sedgewick gap sequence. # Generate Sedgewick gap sequence n = len(arr) gaps = [] k = 0 # Sedgewick gap sequence: 1, 5, 19, 41, 109, ... while True: gap1 = 9 * (4**k - 2**k) + 1 gap2 = 4**(k+2) - 3 * 2**(k+2) + 1 if gap1 < n: gaps.append(gap1) if gap2 < n: gaps.append(gap2) if gap1 >= n and gap2 >= n: break k += 1 gaps = sorted(gaps, reverse=True) # Perform the sorting using the generated gaps for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Objective Implement an algorithm to calculate the diameter of a Binary Search Tree (BST). The diameter of a BST is defined as the number of nodes on the longest path between two leaves in the tree. # Function Signature ```python def diameter(root: Node) -> int: pass ``` # Input The function should take a single parameter: - `root`: The root node of a BST. You can assume that the Node class has the attributes `left` and `right` for the left and right children, respectively. # Output The function should return an integer representing the diameter of the tree. # Examples ```python # Example 1: # Input: A tree with structure: # 9 # / # 6 12 # / / # 3 8 10 15 # / # 7 18 # Output: 6 (The longest path is 3 -> 6 -> 9 -> 12 -> 15 -> 18) # Example 2: # Input: A tree with structure: # 1 # / # 2 # / # 3 # Output: 3 (The longest path is 1 -> 2 -> 3) ``` # Constraints - (0 leq text{Number of Nodes} leq 10^4) - The function should run efficiently for large trees. # Additional Context The longest path may or may not pass through the root node. The recursion needs to understand the maximum diameter at each node, which is determined by the sum of the longest paths in the left and right subtrees plus the current node. # Code Snippet for Initialization To help you get started, here\'s a partial code snippet for the Node class: ```python class Node: def __init__(self, key): self.left = None self.right = None self.value = key ```","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.value = key def diameter(root: Node) -> int: Returns the diameter of a binary tree. def height_and_diameter(node): if not node: return 0, 0 # height, diameter left_height, left_diameter = height_and_diameter(node.left) right_height, right_diameter = height_and_diameter(node.right) current_height = 1 + max(left_height, right_height) current_diameter = max(left_diameter, right_diameter, left_height + right_height + 1) return current_height, current_diameter if not root: return 0 height, tree_diameter = height_and_diameter(root) return tree_diameter - 1 # subtract 1 to convert from number of nodes to number of edges"},{"question":"# Hailstone Sequence Enhancements Problem Statement In this task, you will write a function that generates the hailstone sequence for a given starting number `n`. Additionally, your function should also return the maximum number in this sequence and the total number of steps taken to reach 1. Function Signature ```python def extended_hailstone(n: int) -> (list, int, int): ``` Input - An integer `n` (positive, n >= 1). Output - A tuple containing: 1. A list representing the hailstone sequence from `n` to 1. 2. An integer representing the maximum value in the sequence. 3. An integer representing the total number of steps taken to reach 1. Example ```python # Input >>> n = 5 # Output >>> extended_hailstone(5) ([5, 16, 8, 4, 2, 1], 16, 5) # Input >>> n = 1 # Output >>> extended_hailstone(1) ([1], 1, 0) ``` Constraints - You may assume `n` is a positive integer greater than or equal to 1. - Implement the function efficiently to handle large values of `n`. Notes - Carefully handle edge cases like `n = 1`. - Optimize for both space and time where necessary.","solution":"def extended_hailstone(n: int) -> (list, int, int): Generates the hailstone sequence for a given starting number n. Additionally returns the maximum number in this sequence and the total number of steps taken to reach 1. :param n: A positive integer (n >= 1) :return: A tuple containing the hailstone sequence, the maximum value in the sequence, and the total number of steps taken to reach 1. if n < 1: raise ValueError(\\"n should be a positive integer greater than or equal to 1\\") sequence = [n] current = n max_value = n steps = 0 while current != 1: if current % 2 == 0: current = current // 2 else: current = 3 * current + 1 sequence.append(current) max_value = max(max_value, current) steps += 1 return sequence, max_value, steps"},{"question":"# Context You are working on a numerical analysis software that requires the inversion of matrices for solving systems of linear equations. You are given a helper function that can compute the inverse of an n x n matrix. # Problem Statement Implement a function `validate_and_invert_matrix(matrix: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]` which: 1. Validates if the input is a square matrix. 2. Returns the inverse of the matrix if invertible. 3. Handles the edge cases (i.e., singular matrices, non-square matrices, matrices smaller than 2x2) as described. # Input and Output Formats - **Input**: A 2D list representing an n x n matrix (n ≥ 2). - **Output**: A 2D list representing the inverse matrix if the matrix is valid and invertible, otherwise the function should return specific error codes: - Return `[[−1]]` if the input is not a valid matrix. - Return `[[−2]]` if the matrix is not square. - Return `[[−3]]` if the matrix size is less than 2x2. - Return `[[−4]]` if the matrix is singular (determinant = 0). # Constraints 1. The matrix will only contain integers or floating-point numbers. 2. Maximum matrix size is 20x20. # Function Signature ```python from typing import List, Union def validate_and_invert_matrix(matrix: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]: pass ``` # Example ```python matrix = [ [4, 7], [2, 6] ] print(validate_and_invert_matrix(matrix)) # Expected Output: [ # [0.6, -0.7], # [-0.2, 0.4] # ] matrix = [ [4, 7], [2, 6, 1] ] print(validate_and_invert_matrix(matrix)) # Expected Output: [[-2]] matrix = [ [1, 2], [3, 4] ] print(validate_and_invert_matrix(matrix)) # Expected Output: [[-4]] (since determinant is 0 and the matrix is singular) ``` # Performance Requirements The solution should handle input matrices within the specified constraints efficiently. Optimal solutions are appreciated but not mandatory, correctness and handling of edge cases are prioritized.","solution":"from typing import List, Union def validate_and_invert_matrix(matrix: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]: import numpy as np # Check if input is a list of lists if not all(isinstance(row, list) for row in matrix): return [[-1]] # Check if matrix is empty or less than 2x2 if len(matrix) < 2 or any(len(row) < 2 for row in matrix): return [[-3]] # Check if matrix is square n = len(matrix) if any(len(row) != n for row in matrix): return [[-2]] try: matrix_np = np.array(matrix) # Check if matrix is singular if np.linalg.det(matrix_np) == 0: return [[-4]] # Compute inverse inverse = np.linalg.inv(matrix_np) return inverse.tolist() except: return [[-1]] # In case of any unforeseen error"},{"question":"Problem Statement You are given a sorted array of integers where the elements are uniformly distributed. Your task is to implement the interpolation search algorithm in Python to find the position of a given target value within the array. # Function Signature ```python def find_position(array: List[int], target: int) -> int: ``` # Input - `array` (List[int]): A sorted list of integers where the elements are uniformly distributed. - `target` (int): The integer value you need to search for in the array. # Output - Returns the index (int) of the `target` within the `array` if found; otherwise, returns -1. # Constraints - The input array can have up to (10^6) elements. - All elements in the array are distinct integers. - The integers in the array are uniformly distributed. # Example ```python assert find_position([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert find_position([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert find_position([3, 5, 8, 12, 15, 20, 22], 15) == 4 ``` # Guidelines 1. Implement the interpolation search algorithm based on the provided template. 2. Ensure to handle edge cases, such as when the array is empty or the target is outside the range of the array. 3. Aim for optimal performance to handle large datasets within acceptable time limits. 4. Provide a clear and concise function, adhering to good naming conventions and code readability standards.","solution":"def find_position(array, target): Find the position of the target value within a uniformly distributed sorted array using interpolation search. Returns the index of the target value if found, otherwise returns -1. low = 0 high = len(array) - 1 while low <= high and target >= array[low] and target <= array[high]: if low == high: if array[low] == target: return low return -1 # Probing the position with uniform distribution formula pos = low + ((high - low) // (array[high] - array[low])) * (target - array[low]) # If target is found if array[pos] == target: return pos # If target is larger, target is in the upper part if array[pos] < target: low = pos + 1 # If target is smaller, target is in the lower part else: high = pos - 1 return -1"},{"question":"# Question: AVL Tree Re-implementation and Analysis You are required to re-implement the AVL Tree data structure, focusing on core functionalities and enhancements as mentioned. In particular, implement an AVL Tree that supports the following operations: 1. **Insertion**: Add a key to the tree and ensure it remains balanced. 2. **Search**: Find a key in the tree and return a boolean indicating its presence. 3. **In-order Traversal**: Return the keys of the tree in in-order sequence. Develop your solution in Python adhering to the given constraints. You should explain your approach briefly and ensure your code is optimized for performance. Input and Output Formats - **insert(key)**: - **Input**: `key` (a unique integer). - **Functionality**: Insert `key` into the AVL Tree. - **Output**: None. - **search(key)**: - **Input**: `key` (an integer). - **Functionality**: Check if `key` is present in the AVL Tree. - **Output**: A boolean (`True` if found, `False` otherwise). - **in_order_traversal()**: - **Input**: None. - **Functionality**: Produce a list of all keys in the AVL Tree in in-order sequence. - **Output**: A list of integers. Constraints - You should maintain the AVL Tree properties during all operations. - Assume no duplicate keys. Performance Requirements Your implementation should handle up to (10^5) insertions efficiently, maintaining O(log n) complexity for insertion, search, and balance operations. Example Usage You should provide an example usage of your AVL Tree implementation showing insertion of several keys, searching for specific keys, and performing in-order traversal. ```python # Example usage: avl_tree = AvlTree() avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(5) print(avl_tree.search(20)) # Output: True print(avl_tree.search(15)) # Output: False print(avl_tree.in_order_traversal()) # Output: [5, 10, 20] ```","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def search(self, key): return self._search(self.root, key) def in_order_traversal(self): results = [] self._in_order_traversal(self.root, results) return results def _insert(self, node, key): if not node: return Node(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _search(self, node, key): if node is None: return False if key == node.key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key) def _in_order_traversal(self, node, results): if node is not None: self._in_order_traversal(node.left, results) results.append(node.key) self._in_order_traversal(node.right, results) def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y"},{"question":"# Matrix Transformation and Validation Context You are working on an image processing application where matrix operations such as rotation and inversion are regularly performed. To ensure the consistency of these operations, you need to verify that transformations result in correctly structured matrices. Task Implement functions to rotate a matrix clockwise and counterclockwise, and then verify the correctness of these transformations. You will also determine if an inverse of a transformation returns the matrix to its original state. Steps 1. Implement a function `rotate_clockwise(matrix)` to rotate the given matrix 90 degrees clockwise. 2. Implement a function `rotate_counterclockwise(matrix)` to rotate the given matrix 90 degrees counterclockwise. 3. Implement a function `is_identity(matrix, transformation_fn_1, transformation_fn_2)` that: * Applies `transformation_fn_1` and then `transformation_fn_2` to the matrix. * Returns `True` if the resulting matrix matches the original matrix, and `False` otherwise. Function Signatures ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: # Function implementation here def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: # Function implementation here def is_identity(matrix: List[List[int]], transformation_fn_1: Callable, transformation_fn_2: Callable) -> bool: # Function implementation here ``` Input and Output Formats * `matrix`: A 2D list of integers representing the matrix. * `transformation_fn_1` and `transformation_fn_2`: Functions to apply in sequence to the matrix. * Return `True` or `False` from `is_identity`. Constraints * The matrix will have at least 1 row and 1 column but no more than 1000 rows and 1000 columns. * Each element will be an integer. Examples ```python # Example matrix matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] # Rotating clockwise assert rotate_clockwise(matrix) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3], ] # Rotating counterclockwise assert rotate_counterclockwise(matrix) == [ [3, 6, 9], [2, 5, 8], [1, 4, 7], ] # Verify identity transformations assert is_identity(matrix, rotate_clockwise, rotate_counterclockwise) == True assert is_identity(matrix, rotate_counterclockwise, rotate_clockwise) == True assert is_identity(matrix, rotate_clockwise, rotate_clockwise) == False ```","solution":"from typing import List, Callable def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given matrix 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given matrix 90 degrees counterclockwise. return [list(row) for row in zip(*matrix)][::-1] def is_identity(matrix: List[List[int]], transformation_fn_1: Callable, transformation_fn_2: Callable) -> bool: Applies transformation_fn_1 and then transformation_fn_2 to the matrix, and returns True if the resulting matrix matches the original matrix. transformed_matrix = transformation_fn_1(matrix) transformed_back_matrix = transformation_fn_2(transformed_matrix) return transformed_back_matrix == matrix"},{"question":"# Pigeonhole Sort Implementation and Analysis You are asked to implement and analyze the Pigeonhole Sort algorithm. Given the context and constraints of this sorting algorithm, your task is to sort an array of integers. The range of values in the array should be carefully considered to avoid inefficiencies. Input Format * An array `arr` of integers where the size of the array and the range of values are relatively close. Output Format * A sorted array of integers in non-decreasing order. Constraints 1. The array contains at least 1 and at most 10^6 elements. 2. The range between the minimum and maximum values in the array should not exceed 10^3. Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Example ```python # Example 1 input_arr = [8, 3, 2, 7, 4] output_arr = pigeonhole_sort(input_arr) # Output: [2, 3, 4, 7, 8] # Example 2 input_arr = [10, 20, 40, 20, 10] output_arr = pigeonhole_sort(input_arr) # Output: [10, 10, 20, 20, 40] ``` Additional Context Consider edge cases such as arrays with all identical elements, arrays with elements already in sorted order, and arrays containing negative integers as well. Evaluate your solution\'s performance with varying sizes and ranges, making sure to respect the constraints provided.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: Sorts the array using Pigeonhole Sort algorithm. if not arr: return arr min_val = min(arr) max_val = max(arr) range_val = max_val - min_val + 1 holes = [0] * range_val for number in arr: holes[number - min_val] += 1 sorted_arr = [] for index in range(range_val): while holes[index] > 0: sorted_arr.append(index + min_val) holes[index] -= 1 return sorted_arr"},{"question":"# Scenario You are implementing a simple text-processing software where one of the requirements is to reverse strings efficiently. You need to provide a function that can reverse a given string using efficient methods. # Task Write a function `reverse_string` that takes a string `s` and returns its reversed version. Consider different approaches to achieve this, ensuring it runs efficiently even for large strings. # Requirements * Implement the `reverse_string` function using any of the following methods: 1. Iterative approach. 2. Pythonic approach using built-in functions or methods. 3. A slicing approach. # Function Signature ```python def reverse_string(s: str) -> str: # Write your code here ``` # Input * `s` (1 <= len(s) <= 10^6): A string consisting of alphanumeric characters and symbols. # Output * A string which is the reversed version of input string `s`. # Constraints * The function should handle large input sizes efficiently. * Avoid using excessive memory. # Example ```python assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"OpenAI\\") == \\"IAnepO\\" assert reverse_string(\\"1234!@#\\") == \\"#@!4321\\" assert reverse_string(\\"a\\") == \\"a\\" assert reverse_string(\\"\\") == \\"\\" ``` # Notes * Consider the iterative or slicing approach for the optimal balance between simplicity and performance.","solution":"def reverse_string(s: str) -> str: Reverses the input string `s`. Args: s (str): Input string to be reversed. Returns: str: Reversed string. # Using Python slicing to reverse the string return s[::-1]"},{"question":"# Problem: Ticket Sales and Refund Tracker **Scenario**: A ticket selling platform needs to efficiently manage the sale and refund of tickets across multiple events. To implement this, they require a system to quickly record sales/refunds and compute the total sales up to a certain date. **Task**: You are to implement a Fenwick Tree for keeping track of ticket sales. Your implementation should be able to: 1. Record sales for a specific event on a specific day. 2. Record refunds for a specific event on a specific day. 3. Calculate the total number of tickets sold up to a specific day for all events. You need to provide the implementation for: 1. `get_sum` method to calculate the total number of tickets sold up to a given day. 2. `update_sales` method to update the number of tickets sold or refunded for a specific day. **Function Specifications**: 1. `def __init__(self, days: int):` - Initializes the Fenwick Tree to handle data for `days` (an integer, number of days). 2. `def get_sum(self, i: int) -> int:` - Returns the cumulative total of tickets sold from day 0 to day `i` (inclusive). 3. `def update_sales(self, i: int, delta: int):` - Updates the number of tickets sold for day `i` by adding `delta`. - If `delta` is positive, it represents a sale. If `delta` is negative, it represents a refund. 4. `def construct(self, sales: List[int]) -> List[int]:` - Initializes the Fenwick Tree with the initial ticket sales data provided in the `sales` list. **Example**: ```python # Initialize for 5 days tracker = Fenwick_Tree(5) # Initial sales initial_sales = [10, 20, 30, 40, 50] tracker.construct(initial_sales) # Get total sales up to day 3 (index 2) print(tracker.get_sum(2)) # Output: 60 # Record sales for day 4 (index 3) tracker.update_sales(3, 10) # Record refunds for day 2 (index 1) tracker.update_sales(1, -5) # Get total sales up to day 3 (index 2) again after updates print(tracker.get_sum(2)) # Output: 55 ``` **Constraints**: 1. 0 <= i < days. 2. -1000 <= delta <= 1000. 3. The total number of days can be up to 10^6. **Hints**: * You must ensure the construction and updates are efficiently managed in logarithmic time. * Consider edge cases such as large delta values and the precise handling of day indexes.","solution":"class Fenwick_Tree: def __init__(self, days: int): self.size = days self.tree = [0] * (days + 1) def get_sum(self, i: int) -> int: sum = 0 i += 1 # Adjusting index to be 1-based for Fenwick Tree. while i > 0: sum += self.tree[i] i -= i & -i return sum def update_sales(self, i: int, delta: int): i += 1 # Adjusting index to be 1-based for Fenwick Tree. while i <= self.size: self.tree[i] += delta i += i & -i def construct(self, sales: list) -> None: for i, value in enumerate(sales): self.update_sales(i, value)"},{"question":"**Context:** You are developing a feature for a software system that processes and sorts large datasets. One of the fundamental requirements is to implement an efficient and reliable sorting mechanism that can handle diverse input sizes and maintain stability in sorting. **Task:** Implement the Merge Sort algorithm in Python. Your function should sort a given list of integers in ascending order. The implementation should be efficient with a time complexity of O(n log(n)) and manage memory usage effectively. # Requirements: 1. Implement the `merge_sort` function that takes a list of integers and returns a sorted list. 2. Make sure the implemented algorithm is stable and not in-place. # Input: - A list of integers `arr` (0 ≤ len(arr) ≤ 10^5, -10^6 ≤ arr[i] ≤ 10^6). # Output: - A new list of integers sorted in ascending order. # Example: ```python input: [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` # Constraints: - The function should not modify the input list. - Handle edge cases, such as an empty list or a list with one element. # Code Template: ```python def merge_sort(arr): Merge Sort Algorithm if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): result = [] left_cursor, right_cursor = 0, 0 while left_cursor < len(left) and right_cursor < len(right): if left[left_cursor] <= right[right_cursor]: result.append(left[left_cursor]) left_cursor += 1 else: result.append(right[right_cursor]) right_cursor += 1 result.extend(left[left_cursor:]) result.extend(right[right_cursor:]) return result # Example usage # arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] # print(merge_sort(arr)) ``` Your task is to complete the implementation of the `merge_sort` and `merge` functions according to the outlined requirements and constraints.","solution":"def merge_sort(arr): Merge Sort Algorithm if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): Merge helper function result = [] left_cursor, right_cursor = 0, 0 while left_cursor < len(left) and right_cursor < len(right): if left[left_cursor] <= right[right_cursor]: result.append(left[left_cursor]) left_cursor += 1 else: result.append(right[right_cursor]) right_cursor += 1 result.extend(left[left_cursor:]) result.extend(right[right_cursor:]) return result"},{"question":"# Scenario Imagine you are a software developer at a startup that deals with large amounts of text data. One of your tasks is to create an efficient function that helps detect patterns within repeated text blocks. For instance, you might need to detect a particular pattern within a large concatenated log file. # Problem Statement Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If there is no such solution, return -1. Write a function: ```python def repeated_string_match(A: str, B: str) -> int: ``` Input: * A: A string of length between 1 and 10000. * B: A string of length between 1 and 10000. Output: * An integer representing the minimum number of times A needs to be repeated for B to be a substring of the repeated string. If no repetition of A can make B a substring, return -1. Constraints: * A and B consist of lowercase alphabetic characters. * Your solution should aim to optimize both time and space complexities as much as possible. Example: ```python A = \\"abcd\\" B = \\"cdabcdab\\" # Output: 3 A = \\"a\\" B = \\"aa\\" # Output: 2 A = \\"abc\\" B = \\"wxyz\\" # Output: -1 ``` * The first example returns 3, because by repeating A three times (\\"abcdabcdabcd\\"), B is a substring of it, and B is not a substring of A repeated two times (\\"abcdabcd\\"). * The second example returns 2 because two repetitions of \\"a\\" become \\"aa\\", which contains B. * The third example returns -1 because no number of repetitions of A will contain B. # Requirements: * Implement the function in a way that efficiently determines the number of repetitions, considering performance for very large strings. * Consider edge cases and constraints mentioned above while implementing the function.","solution":"def repeated_string_match(A: str, B: str) -> int: Returns the minimum number of times A has to be repeated such that B is a substring of it. If there is no such solution, return -1. # Minimum initial repetitions min_repeats = -(-len(B) // len(A)) for i in range(2): repeated_A = A * (min_repeats + i) if B in repeated_A: return min_repeats + i return -1"},{"question":"**Objective**: Implement a function `optimized_switch_pairs` to switch successive pairs of elements in a given stack, but only use a single traversal and space that is directly proportional to the number of elements in the stack. Function Signature ```python def optimized_switch_pairs(stack: list) -> list: pass ``` Description You are given a stack (implemented as a list) which may contain an odd or even number of integers. Your task is to reverse successive pairs of elements starting from the bottom of the stack while employing efficient space usage. If the stack contains an odd number of elements, the top element remains unchanged. # Example ```python # Given stack stack = [3, 8, 17, 9, 1, 10] # After calling optimized_switch_pairs(stack) # Resulting stack should be: # [8, 3, 9, 17, 10, 1] # Given stack stack = [3, 8, 17, 9, 1] # After calling optimized_switch_pairs(stack) # Resulting stack should be: # [8, 3, 9, 17, 1] ``` Constraints * The function should minimize the number of stack operations. * The stack should be manipulated in place. * You can use O(n) additional space, where n is the number of elements in the stack. Requirements 1. The main logic must efficiently switch pairs with minimal temporary storage. 2. Handle edge cases where the number of elements is either zero or one without failure. 3. Ensure the top element remains as is for odd count scenarios. Hint Consider leveraging multiple auxiliary storage transformations to achieve the desired outcome.","solution":"def optimized_switch_pairs(stack: list) -> list: Switches successive pairs of elements in the stack in place. n = len(stack) for i in range(0, n - 1, 2): stack[i], stack[i + 1] = stack[i + 1], stack[i] return stack"},{"question":"# Doubly Linked List Implementation and Usage **Problem Statement:** You are tasked with implementing a Doubly Linked List as a dynamic data structure. You need to provide essential methods for insertion, deletion, and traversal, as well as handling edge cases. Additionally, your implementation should account for typical use case scenarios and should demonstrate practical usage. **Requirements:** 1. **Implementation of Doubly Linked List**: * **Class**: `DoublyLinkedList` * **Methods**: - `insert_at_head(value)`: Insert a new node with the given value at the head of the list. - `insert_at_tail(value)`: Insert a new node with the given value at the tail of the list. - `delete_node(value)`: Remove the first node containing the specified value. - `display_forward()`: Display the values in the list from head to tail. - `display_backward()`: Display the values in the list from tail to head. 2. **Edge Cases**: * Handle operations for an empty list. * Handle insertion and deletion when the list contains only one node. * Ensure the list remains consistent when adding/removing nodes. 3. **Test Cases**: * Insertions and deletions at the head and tail. * Traversal in both forward and backward directions. **Input and Output Formats:** - Assume all input values are integers. - `insert_at_head`, `insert_at_tail`, and `delete_node` methods do not return a value. - `display_forward` and `display_backward` methods should return a list of values in the respective order. **Constraints:** - The number of operations (insertions, deletions, and traversals) will not exceed 10^4. **Example:** ```python # Create a Doubly Linked List dll = DoublyLinkedList() # Insert elements dll.insert_at_head(3) dll.insert_at_tail(5) dll.insert_at_head(1) # Display the list forward and backward print(dll.display_forward()) # Output: [1, 3, 5] print(dll.display_backward()) # Output: [5, 3, 1] # Delete elements and display the list dll.delete_node(3) print(dll.display_forward()) # Output: [1, 5] print(dll.display_backward()) # Output: [5, 1] ``` **Implementation:** ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = DoublyLinkedListNode(value) if self.head is None: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_tail(self, value): new_node = DoublyLinkedListNode(value) if self.tail is None: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_node(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return current = current.next def display_forward(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result def display_backward(self): result = [] current = self.tail while current: result.append(current.value) current = current.prev return result ```","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = DoublyLinkedListNode(value) if self.head is None: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_tail(self, value): new_node = DoublyLinkedListNode(value) if self.tail is None: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_node(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return current = current.next def display_forward(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result def display_backward(self): result = [] current = self.tail while current: result.append(current.value) current = current.prev return result"},{"question":"Context: You are given Bogo Sort, a whimsical and highly inefficient sorting algorithm, as provided in the code snippet. However, given its impracticality, your task is to implement a more efficient sorting algorithm called **Quick Sort**. Quick Sort Analysis: Quick Sort is a highly efficient sorting algorithm suitable for large datasets. It works on the principle of Divide and Conquer, partitioning the array around a pivot element and recursively sorting the sub-arrays. * **Time Complexity**: * Best Case: (O(n log n)) * Average Case: (O(n log n)) * Worst Case: (O(n^2)), typically reduced with good pivot selection (e.g., using median-of-three). * **Space Complexity**: (O(log n)) due to the recursive stack. * **Properties**: * **In-place**: Does not require additional memory for sorting. * **Unstable**: Relative order of equal elements may not be preserved. Task: Implement the function `quick_sort` to sort an array of integers using the Quick Sort algorithm. Function Signature: ```python def quick_sort(arr: list[int]) -> list[int]: ``` Input: * A list of integers `arr` (1 <= len(arr) <= 10^5), containing elements (-10^9 <= arr[i] <= 10^9). Output: * A sorted list of integers. Constraints: * The sorting must be performed in-place. * Your solution should handle very large lists efficiently. Example: ```python assert quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10] assert quick_sort([10, 7, 8, 9, 1, 5]) == [1, 5, 7, 8, 9, 10] ``` ```python def quick_sort(arr: list[int]) -> list[int]: def partition(low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i = i + 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_recursive(low, high): if low < high: pi = partition(low, high) quick_sort_recursive(low, pi - 1) quick_sort_recursive(pi + 1, high) quick_sort_recursive(0, len(arr) - 1) return arr ```","solution":"def quick_sort(arr: list[int]) -> list[int]: Sorts an array of integers using the quick sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: The sorted list of integers. def partition(low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i = i + 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_recursive(low, high): if low < high: pi = partition(low, high) quick_sort_recursive(low, pi - 1) quick_sort_recursive(pi + 1, high) quick_sort_recursive(0, len(arr) - 1) return arr"},{"question":"# Question: Implement a Secure Diffie-Hellman Key Exchange with Primality and Primitive Root Check Scenario: Alice and Bob want to securely share a secret key over an insecure channel using the Diffie-Hellman key exchange algorithm. As part of this process, they need to verify that the chosen prime number and its primitive root are correct for the security of their communication. Task: Write a Python function `secure_diffie_hellman(a, p)` that: 1. Verifies that `p` is a large prime number. 2. Checks that `a` is a primitive root of `p`. 3. Completes the Diffie-Hellman key exchange for Alice and Bob. 4. Returns the shared secret key if successful, otherwise returns an error message indicating why it failed. Function Signature: ```python def secure_diffie_hellman(a: int, p: int) -> Union[int, str]: ``` Inputs: - `a`: An integer supposed to be the primitive root. - `p`: A large prime number. Outputs: - Returns the shared secret key as an integer if `a` and `p` are valid. - Returns a string message indicating an error if the conditions are not met. # Example: ```python print(secure_diffie_hellman(5, 23)) # Expected Output: Shared Key calculated by Alice = x, Shared Key calculated by Bob = x # Will return the shared key if the checks pass print(secure_diffie_hellman(5, 20)) # Expected Output: \\"20 is not a prime number\\" ``` # Constraints: - `2 <= a < p <= 10^9` - The function should handle large prime numbers efficiently. # Requirements: 1. Implement prime check within the function. 2. Find the order of `a` modulo `p` to verify it\'s a primitive root. 3. Compute shared keys using the Diffie-Hellman method with private and public keys. Notes: - Include necessary mathematical functions within the main function or import them appropriately. - Handle all error scenarios and edge cases gracefully.","solution":"from typing import Union from sympy import isprime, mod_inverse def is_primitive_root(a, p): Check if a is a primitive root of prime p. if not isprime(p): return False required_set = set(num for num in range(1, p) if gcd(num, p) == 1) actual_set = set(pow(a, powers, p) for powers in range(1, p)) return required_set == actual_set def secure_diffie_hellman(a: int, p: int) -> Union[int, str]: # Check if p is a prime number if not isprime(p): return f\\"{p} is not a prime number\\" # Check if a is a primitive root of p if not is_primitive_root(a, p): return f\\"{a} is not a primitive root of {p}\\" # Generate private keys for Alice and Bob private_key_alice = 6 # In practice, this should be random and secure private_key_bob = 15 # In practice, this should be random and secure # Calculate public keys public_key_alice = pow(a, private_key_alice, p) public_key_bob = pow(a, private_key_bob, p) # Calculate shared secret keys shared_key_alice = pow(public_key_bob, private_key_alice, p) shared_key_bob = pow(public_key_alice, private_key_bob, p) # Both shared keys should be equal for successful key exchange if shared_key_alice == shared_key_bob: return shared_key_alice else: return \\"Key exchange failed\\" def gcd(a, b): while b: a, b = b, a % b return a"},{"question":"# Word Search with Constraints Given a 2D board of characters and a list of words, write a function `find_advanced_words` that returns a list of all words from the list that are present on the board. Special Constraints: 1. Words must be constructed from letters of sequentially adjacent cells. 2. A cell can only be used once in the word construction. 3. Enhance the Trie-based search to exclude words formed diagonally or involving cells revisited due to complex patterns (i.e., longer and diverse word formations). Core Requirements: 1. Implement the function `find_advanced_words(board, words)` that meets the constraints. 2. Use Trie for efficient prefix searching. 3. Implement depth-first search (DFS) with necessary optimizations. **Function Signature** ```python def find_advanced_words(board: List[List[str]], words: List[str]) -> List[str]: pass ``` **Input** - `board`: A 2D grid of characters. - `words`: A list of words to search for. **Output** - A list of words found in the board. **Example** ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"] print(find_advanced_words(board, words)) # Output: [\\"oath\\", \\"eat\\"] ``` **Constraints** - Board dimensions: 1 ≤ m, n ≤ 12. - Number of words: 1 ≤ words.length ≤ 3 * 10^4. - Word length: 1 ≤ words[i].length ≤ 10. - Characters are lowercase English letters. Testing & Validation Ensure that your function correctly handles: 1. Small and large boards. 2. Word lists of varying lengths. 3. Edge cases like empty inputs or full utilization of the board space. 4. Constraints and performance within specified limits.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False self.word = None def add_word_to_trie(root, word): node = root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True node.word = word def find_advanced_words(board: List[List[str]], words: List[str]) -> List[str]: if not board or not board[0]: return [] root = TrieNode() for word in words: add_word_to_trie(root, word) rows, cols = len(board), len(board[0]) found_words = set() def dfs(r, c, node): char = board[r][c] if char not in node.children: return next_node = node.children[char] if next_node.is_end_of_word: found_words.add(next_node.word) board[r][c] = \'#\' # Mark as visited for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)): # Only search in 4 directions nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and board[nr][nc] != \'#\': dfs(nr, nc, next_node) board[r][c] = char # Restore character for i in range(rows): for j in range(cols): dfs(i, j, root) return list(found_words)"},{"question":"# Problem: Bipartite Graph Verification A company is trying to set up two different teams for a project, with the condition that no two team members should have conflicts with each other. You are given information about conflicts between team members in the form of a graph. You need to check whether it is possible to split the team members into two groups such that no two members in the same group have conflicts between them. This problem reduces to checking if the graph is bipartite. Task Write a function `is_bipartite` that determines if the given conflict graph is bipartite. ```python def is_bipartite(adj_list): \'\'\' Args: adj_list : List[List[int]] : adjacency list representing conflict graph Returns: bool : `True` if the graph is bipartite, otherwise `False` \'\'\' pass # your implementation here ``` Input Format * `adj_list` : A list of lists, where `adj_list[i]` contains all vertices adjacent to vertex `i`. - For example, `adj_list = [[1, 3], [0, 2], [1, 3], [0, 2]]` represents a graph with 4 vertices where vertex 0 is connected to vertices 1 and 3, and so on. Output Format * Return `True` if the graph is bipartite, otherwise `False`. Constraints * The number of vertices `n` (length of the `adj_list`) will be in the range [1, 1000]. * 0 ≤ number of edges in the graph ≤ n × (n-1) / 2. Example * `is_bipartite([[1, 3], [0, 2], [1, 3], [0, 2]])` returns `True`. * `is_bipartite([[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]])` returns `False`. # Explanation 1. For the first example, the graph can be split into two sets: {0, 2} and {1, 3}, showing no internal conflicts. 2. For the second example, there is no way to split the graph such that no two adjacent vertices are in the same set. Note Be mindful of edge cases such as self-loops (`adj_list[i]` contains `i`), disconnected graphs, and graphs with no edges at all.","solution":"def is_bipartite(adj_list): Determines if the given graph is bipartite. Args: adj_list : List[List[int]] : adjacency list representing conflict graph Returns: bool : `True` if the graph is bipartite, otherwise `False` n = len(adj_list) colors = [-1] * n # -1 means uncolored, 0 means one color, 1 means another color def bfs(start): queue = [start] colors[start] = 0 # Start coloring with color 0 while queue: node = queue.pop(0) for neighbor in adj_list[node]: if colors[neighbor] == -1: # If not colored colors[neighbor] = 1 - colors[node] # Color with opposite color queue.append(neighbor) elif colors[neighbor] == colors[node]: # If it has same color return False return True for i in range(n): if colors[i] == -1: # Not yet colored if not bfs(i): return False return True"},{"question":"You are given a list of integers and a number N. Your task is to write a function `filter_list_by_occurrences` that generates a new list from the given list such that each number appears at most N times, maintaining the order of their first appearances. The function should utilize efficient data structures to ensure optimal performance. Function Signature: ```python def filter_list_by_occurrences(lst: list[int], N: int) -> list[int]: pass ``` Input: - `lst`: A list of integers (1 <= len(lst) <= 10^5). - `N`: An integer indicating the maximum allowed occurrences of any element (1 <= N <= 1000). Output: - A list of integers where each number appears at most N times, preserving the order of their first appearances. Constraints: - The function should aim for a time complexity of (O(n)). # Examples: **Example 1:** ```python lst = [1, 2, 3, 1, 2, 1, 2, 3] N = 2 Output: [1, 2, 3, 1, 2, 3] ``` **Example 2:** ```python lst = [20, 37, 20, 21] N = 1 Output: [20, 37, 21] ``` # Notes: - Implement the function and ensure it works efficiently for large input sizes. - Think about edge cases such as empty lists, lists with all identical elements, and edge values for N.","solution":"def filter_list_by_occurrences(lst: list[int], N: int) -> list[int]: from collections import defaultdict count = defaultdict(int) result = [] for num in lst: if count[num] < N: result.append(num) count[num] += 1 return result"},{"question":"Counting Connected Components in a Dynamic Grid You are given a 2D grid with water initially. You will receive operations that convert cells in the grid from water to land. An island is defined as a group of connected lands (1s) surrounded by water (0s). Connected lands are horizontally or vertically adjacent. You need to implement a function `num_islands` that returns the number of islands after each `addLand` operation. Write a function: ```python def num_islands(positions: List[List[int]]) -> List[int]: pass ``` # Input: - `positions`: A list of lists of integers representing positions of `addLand` operations. Each operation is represented by a list `[r, c]` where r is the row index and c is the column index. # Output: - A list of integers where each integer is the number of islands after corresponding `addLand` operation. # Constraints: 1. The size of the grid is not fixed. Each addLand operation will only target valid positions in a non-negative rectilinear grid. 2. The positions list will not contain duplicate operations. # Example: ```python positions = [[0, 0], [0, 1], [1, 2], [2, 1]] print(num_islands(positions)) # Output: [1, 1, 2, 3] ``` # Explanation: 1. Add land at (0,0): ``` 1 0 0 0 0 0 0 0 0 ``` Number of islands = 1. 2. Add land at (0,1): ``` 1 1 0 0 0 0 0 0 0 ``` Number of islands = 1. 3. Add land at (1,2): ``` 1 1 0 0 0 1 0 0 0 ``` Number of islands = 2. 4. Add land at (2,1): ``` 1 1 0 0 0 1 0 1 0 ``` Number of islands = 3.","solution":"from typing import List def num_islands(positions: List[List[int]]) -> List[int]: if not positions: return [] parent, rank = {}, {} def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def add(x, y): if (x, y) in parent: return 0 parent[(x, y)] = (x, y) rank[(x, y)] = 0 count = 1 for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]: nx, ny = x + dx, y + dy if (nx, ny) in parent: if find((nx, ny)) != find((x, y)): union((nx, ny), (x, y)) count -= 1 return count current_islands = 0 result = [] for x, y in positions: current_islands += add(x, y) result.append(current_islands) return result"},{"question":"Given an integer `n`, write a function `optimized_fib(n)` that computes the n-th Fibonacci number using the most efficient algorithm in terms of both time and space complexity. Avoid using recursion to prevent the exponential time complexity issue. Input - An integer `n` (0 ≤ n ≤ 10**6). Output - A single integer representing the n-th Fibonacci number. Constraints - You must implement the algorithm with a time complexity of O(n) and space complexity of O(1). Example ```python >>> optimized_fib(10) 55 >>> optimized_fib(50) 12586269025 ``` Edge Cases - Consider testing for `n = 0` (should return 0). - Consider testing for `n = 1` (should return 1). - Consider an upper bound case like `n = 10**6`. # Scenario In this exercise, your objective is to write an optimized function leveraging the iterative method demonstrated earlier. It involves computing large Fibonacci numbers efficiently without consuming significant memory. Note Ensure your code handles large values efficiently and adheres to the constraints provided.","solution":"def optimized_fib(n): Computes the n-th Fibonacci number using an iterative approach with O(n) time complexity and O(1) space complexity. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Question: Implement the Longest Prefix Suffix (LPS) Array for KMP Algorithm **Context**: Understanding the construction of the prefix function (or pi table) is crucial for implementing the Knuth-Morris-Pratt (KMP) algorithm. The pi table is used to determine the longest proper prefix which is also a suffix for substrings of the pattern. **Task**: Write a function to compute the LPS array (used in the KMP algorithm) for a given pattern string. **Function Signature**: ```python def compute_lps(pattern: str) -> List[int]: pass ``` **Input**: - `pattern` (str): The pattern string for which to compute the LPS array. - Constraints: - Length of `pattern` is between 1 and 10^5. - `pattern` consists of only lowercase English letters. **Output**: - Returns a list of integers representing the LPS array of the pattern. **Examples**: ```python >>> compute_lps(\\"ababc\\") [0, 0, 1, 2, 0] >>> compute_lps(\\"aaaa\\") [0, 1, 2, 3] >>> compute_lps(\\"aabaabaaa\\") [0, 1, 0, 1, 2, 3, 4, 5, 2] ``` **Explanation**: 1. The LPS array for `pattern=\\"ababc\\"` is `[0, 0, 1, 2, 0]`. The value `lps[i]` indicates the length of the proper prefix which is also a suffix for the substring `pattern[0:i+1]`. 2. For `pattern=\\"aaaa\\"`, the LPS array `[0, 1, 2, 3]` shows that the prefixes increase progressively. 3. The pattern `aabaabaaa` results in the LPS array `[0, 1, 0, 1, 2, 3, 4, 5, 2]`, indicating repeating patterns within the string. **Constraints**: - Your solution should run in O(M) time, where M is the length of the pattern.","solution":"from typing import List def compute_lps(pattern: str) -> List[int]: Computes the Longest Prefix Suffix (LPS) array for the given pattern string. The LPS array is used in the KMP pattern matching algorithm to determine the longest proper prefix which is also a suffix. Parameters: pattern (str): The pattern string for which the LPS array is to be computed. Returns: List[int]: The LPS array. # Initialize the LPS array with zeros length = 0 # Length of the previous longest prefix suffix lps = [0] * len(pattern) # The loop calculates lps[i] for i from 1 to len(pattern)-1 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: # This is tricky. Consider the example AAACAAAA and i = 7. if length != 0: length = lps[length - 1] # Note that we do not increment i here else: lps[i] = 0 i += 1 return lps"},{"question":"You are tasked with implementing a function to sort a given list of integers using the Insertion Sort algorithm. Your implementation should follow the principles of the Insertion Sort as described. Additionally, provide functionality to display intermediate sorting steps for educational purposes. # Function Signature ```python def custom_insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Input * `arr`: A list of integers (1 <= len(arr) <= 10^3) that need to be sorted. * `simulation`: A boolean flag indicating whether to display intermediate steps of the sorting process. # Output * Returns the sorted list of integers. # Constraints * Your implementation must work in-place, meaning you should not use additional space for another list. * You must handle the following edge cases: * Empty array. * Single-element array. * Already sorted array. * Array containing duplicate elements. # Example ```python custom_insertion_sort([5, 2, 9, 1, 5, 6], simulation=True) # Expected intermediate output if simulation is True: # iteration 0: 5 2 9 1 5 6 # iteration 1: 2 5 9 1 5 6 # iteration 2: 2 5 9 1 5 6 # iteration 3: 1 2 5 9 5 6 # iteration 4: 1 2 5 5 9 6 # iteration 5: 1 2 5 5 6 9 custom_insertion_sort([3, 1, 4], simulation=False) # Expected output: [1, 3, 4] ``` Please ensure your code is efficient and handles all specified edge cases correctly.","solution":"def custom_insertion_sort(arr, simulation=False): Performs insertion sort on the input list `arr`. Parameters: arr (list): List of integers to be sorted. simulation (bool): Flag to display intermediate steps if True. Returns: list: Sorted list of integers. n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, to one position ahead while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key # If simulation is on, print intermediate steps if simulation: print(f\'iteration {i}: {\\" \\".join(map(str, arr))}\') return arr"},{"question":"# Shell Sort Implementation Challenge You have been hired as a software engineer to optimize data processing in a financial company. The task is to implement the Shell Sort algorithm to sort transaction amounts so they can be processed efficiently. Problem Description You need to write a function `optimized_shell_sort` that sorts a list of transaction amounts in ascending order using the Shell Sort algorithm. The function should follow the optimal Shell\'s original sequence for gaps, which is reducing gap from `n//2` gradually. Function Signature ```python def optimized_shell_sort(arr: List[int]) -> List[int]: pass ``` Input - A list of integers `arr` representing the transaction amounts. It can be empty or contain up to 100,000 elements, where each element is between (-1,000,000) and (1,000,000). Output - A new list of integers `arr` sorted in ascending order. Constraints - Try to optimize the performance as much as possible. The more efficient your implementation, the better it handles large datasets. - Aim for a (O(n log n)) time complexity on average with good gap sequences. Example ```python assert optimized_shell_sort([23, 1, 45, -2, 78, 0, 34]) == [-2, 0, 1, 23, 34, 45, 78] assert optimized_shell_sort([]) == [] assert optimized_shell_sort([5]) == [5] assert optimized_shell_sort([10, 8, -5, 3, 3, 0]) == [-5, 0, 3, 3, 8, 10] ``` Edge Cases to Consider - An empty list. - A list with one element. - A list where all elements are the same. - Lists with maximum and minimum values in the given range. Implement this function showcasing your understanding of the Shell Sort algorithm and handle all necessary edge cases gracefully.","solution":"def optimized_shell_sort(arr): Sorts a list of integers using the Shell Sort algorithm. Parameters: arr (list of int): A list of integers to be sorted. Returns: list of int: A new list containing the sorted integers. n = len(arr) gap = n // 2 # Starting with a large gap, then reduce the gap while gap > 0: for i in range(gap, n): # Perform a gapped insertion sort temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"# Context You have been hired as a software engineer at a company that designs and manages large networking systems. One of the key tasks is to determine the most efficient routes for network data transmission between multiple data centers. As part of this task, you must determine the shortest data paths between all pairs of data centers in a weighted network graph, where weights represent the transmission times between data centers. # Task Implement the `all_pairs_shortest_path` function using the Floyd-Warshall algorithm to determine the shortest paths for all pairs of nodes in a given weighted graph represented by an adjacency matrix. Function Signature ```python def all_pairs_shortest_path(adjacency_matrix: List[List[float]]) -> List[List[float]]: ``` Input - `adjacency_matrix`: A list of lists of floats where `adjacency_matrix[i][j]` represents the transmission time between data center `i` and data center `j`. If `i == j`, `adjacency_matrix[i][j]` will be 0. Output - A list of lists of floats containing the shortest transmission times between each pair of data centers. Constraints - `adjacency_matrix` will be an `n x n` matrix where `1 <= n <= 100` - Weights in the adjacency matrix will be non-negative floats (if there is no direct edge between nodes, the weight can be assumed to be a very large number `inf`). # Example **Input**: ```python [ [0, 0.1, 0.101, 0.142, 0.277], [0.465, 0, 0.191, 0.192, 0.587], [0.245, 0.554, 0, 0.333, 0.931], [1.032, 0.668, 0.656, 0, 0.151], [0.867, 0.119, 0.352, 0.398, 0], ] ``` **Output**: ```python [ [0 , 0.1 , 0.101, 0.142, 0.277], [0.436, 0 , 0.191, 0.192, 0.343], [0.245, 0.345, 0 , 0.333, 0.484], [0.706, 0.27 , 0.461, 0 , 0.151], [0.555, 0.119, 0.31 , 0.311, 0] ] ``` # Notes 1. Make sure your implementation handles any floating-point arithmetic issues. 2. Aim to make your solution as efficient as possible within the given constraints. 3. Avoid using any external libraries that provide direct implementations of all-pairs shortest paths.","solution":"from typing import List def all_pairs_shortest_path(adjacency_matrix: List[List[float]]) -> List[List[float]]: Apply the Floyd-Warshall algorithm to find the shortest paths between all pairs of nodes in a weighted graph. n = len(adjacency_matrix) # Initialize the distances with the given adjacency matrix dist = [row[:] for row in adjacency_matrix] # Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): # Update the distance only if a shorter path is found if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist"},{"question":"# Question You are tasked with writing a function that calculates the parity of a number\'s binary representation. The parity of a number is 1 if the number of \'1\' bits in its binary representation is odd, and 0 if that count is even. Parity is important in various error detection schemes. **Function Signature**: ```python def calculate_parity(n: int) -> int: pass ``` # Input * An unsigned integer `n` (0 ≤ n < 2^32). # Output * Return `1` if the number of \'1\' bits is odd. * Return `0` if the number of \'1\' bits is even. # Constraints * Your implementation should handle the largest 32-bit unsigned integers efficiently. * Aim to minimize the number of operations and maximize performance efficiency. # Examples 1. `calculate_parity(11)` should return `1` because the binary representation of 11 is `1011`, which contains three \'1\' bits (odd). 2. `calculate_parity(4)` should return `0` because the binary representation of 4 is `100`, which contains one \'1\' bit (odd). # Performance Requirements The solution should ideally run in O(k) time, where k is the number of \'1\' bits in the binary representation of the input number. # Scenario You are working on a system that leverages parity to detect errors on-the-fly. Implementing an efficient parity calculation function will greatly improve the reliability of the system without incurring a significant computational overhead.","solution":"def calculate_parity(n: int) -> int: Calculate the parity of the number of 1\'s in the binary representation of n. :param n: An unsigned integer (0 ≤ n < 2^32). :return: 1 if the number of 1\'s is odd, 0 if it\'s even. parity = 0 while n: parity ^= 1 n &= n - 1 # Drops the lowest set bit of n return parity"},{"question":"# Prompt Given an array `nums` of size `n`, rotate the array to the right by `k` steps, where `k` is non-negative. Implement the rotation using an efficient method that modifies the array in-place with O(n) time complexity and O(1) space complexity. Requirements Implement the function `def rotate_array(nums: List[int], k: int) -> None:` where: * **Input**: * `nums` (List[int]): A list of integers of size `n`. * `k` (int): A non-negative integer denoting the number of steps to rotate the array to the right. * **Output**: * Modify `nums` in-place to achieve the rotation. Constraints * `1 <= n <= 10^5` * `0 <= nums[i] <= 10^3` * `0 <= k <= 10^5` # Example ```python # Example 1: nums = [1, 2, 3, 4, 5, 6, 7] rotate_array(nums, 3) # Expected output: [5, 6, 7, 1, 2, 3, 4] # Example 2: nums = [-1, -100, 3, 99] rotate_array(nums, 2) # Expected output: [3, 99, -1, -100] ``` # Notes * You can use helper functions if necessary. * The algorithm should handle large values of `k` effectively by using `k % n` to minimize redundant rotations.","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> None: Rotates the given list \'nums\' to the right by \'k\' steps. Modifies the list in-place to achieve the rotation. n = len(nums) k %= n # To handle the case where k is greater than n # Function to reverse a subarray from start to end indices def reverse(start: int, end: int) -> None: while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 # Reverse the entire array reverse(0, n - 1) # Reverse the first k elements reverse(0, k - 1) # Reverse the remaining n-k elements reverse(k, n - 1)"},{"question":"You are given a matrix (2D list) and you need to perform different transformations on this matrix. Implement the following functions to demonstrate your understanding of matrix manipulation. 1. **rotate_clockwise(matrix)**: Rotates the given matrix 90 degrees clockwise. 2. **rotate_counterclockwise(matrix)**: Rotates the given matrix 90 degrees counterclockwise. 3. **bottom_left_invert(matrix)**: Inverts the given matrix by rotating it 180 degrees. # Function Definitions ```python def rotate_clockwise(matrix): # Implement this function def rotate_counterclockwise(matrix): # Implement this function def bottom_left_invert(matrix): # Implement this function ``` # Input - **matrix**: A list of lists, where each inner list represents a row of the matrix. * Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] ``` # Output - Each function should return a new matrix representing the rotated or inverted matrix. # Constraints 1. The input matrix can be rectangular (i.e., it might not necessarily be a square matrix). 2. Your functions should handle cases where the matrix is empty or has only one row/column. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] # Rotated 90 degrees clockwise: rotate_clockwise(matrix) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3], # ] # Rotated 90 degrees counterclockwise: rotate_counterclockwise(matrix) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7], # ] # Inverted by rotating 180 degrees: bottom_left_invert(matrix) # Output: # [ # [9, 8, 7], # [6, 5, 4], # [3, 2, 1], # ] ``` Your task is to implement these functions correctly in such a way that they handle edge cases and perform the required transformations accurately.","solution":"def rotate_clockwise(matrix): Rotates the given matrix 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix): Rotates the given matrix 90 degrees counterclockwise. return [list(row) for row in zip(*matrix)][::-1] def bottom_left_invert(matrix): Inverts the given matrix by rotating it 180 degrees. return [row[::-1] for row in matrix[::-1]]"},{"question":"# Task Description Based on the analysis of the provided algorithms, implement a function that performs a sequence of number theory operations to assist in a cryptographic key exchange process. Your task involves writing a function that utilizes prime checking, Euler\'s totient function, and primitive roots to generate cryptographically secure keys. # Problem Statement Implement a function `generate_cryptographic_keys(p)` that takes a large prime number `p` and performs the following operations: 1. Confirms that `p` is a prime number. 2. Finds the primitive roots of `p`. 3. Randomly selects one of the primitive roots. 4. Generates private-public key pairs for Alice and Bob. 5. Computes the shared secret key using Diffie-Hellman key exchange. # Input - `p`: A large prime integer (2 ≤ p ≤ 10^6). # Output - A tuple containing four values: 1. Alice\'s private key. 2. Alice\'s public key. 3. Bob\'s private key. 4. Bob\'s public key. 5. The shared secret key. # Constraints - Ensure that `p` is a prime number. - If no primitive root exists, return `(-1, -1, -1, -1, -1)`. # Function Signature ```python def generate_cryptographic_keys(p: int) -> tuple: pass ``` # Example ```python p = 23 print(generate_cryptographic_keys(p)) # Output might be: # (4, 9, 5, 8, 20) ``` # Notes - Your function should handle edge cases efficiently. - Randomness should be utilized carefully to ensure secure key generation. - The accuracy of Euler\'s totient function and finding primitive roots is crucial. - Ensure the shared secret key matches for both Alice and Bob.","solution":"import random from sympy import isprime, primitive_root def generate_cryptographic_keys(p: int) -> tuple: # Check if p is a prime number if not isprime(p): return (-1, -1, -1, -1, -1) # Find a primitive root for p try: g = primitive_root(p) except ValueError: return (-1, -1, -1, -1, -1) # Generate private keys for Alice and Bob private_key_alice = random.randint(2, p-2) private_key_bob = random.randint(2, p-2) # Compute public keys public_key_alice = pow(g, private_key_alice, p) public_key_bob = pow(g, private_key_bob, p) # Compute the shared secret key shared_secret_key_alice = pow(public_key_bob, private_key_alice, p) shared_secret_key_bob = pow(public_key_alice, private_key_bob, p) if shared_secret_key_alice != shared_secret_key_bob: return (-1, -1, -1, -1, -1) return (private_key_alice, public_key_alice, private_key_bob, public_key_bob, shared_secret_key_alice)"},{"question":"You are given an array of integers and a minimum and maximum limit. Your task is to implement a function that filters the array, keeping only the integers that fall between the given minimum and maximum limits, inclusive. If either limit is not specified, it should treat that bound as \\"unlimited\\". # Function Signature ```python def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: ``` # Input * `arr` (List[int]): A list of integers. You can assume all elements in `arr` are distinct. * `min_lim` (Optional[int]): The minimum limit (inclusive). This can be None to imply no lower bound. * `max_lim` (Optional[int]): The maximum limit (inclusive). This can be None to imply no upper bound. # Output * A list of integers containing elements from the input array that are within the specified limits. # Constraints * `1 <= len(arr) <= 10^6` * `-10^9 <= arr[i], min_lim, max_lim <= 10^9` # Examples ```python assert limit([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert limit([10, 20, 30, 40, 50], 15, None) == [20, 30, 40, 50] assert limit([5, 15, 25, 35, 45], 10, 40) == [15, 25, 35] assert limit([], 10, 40) == [] assert limit([1], None, None) == [1] assert limit([1, 2, 3], 10, 20) == [] ``` # Performance Requirements Your solution should have a time complexity of O(n) and space complexity of O(n). # Notes 1. Ensure your implementation efficiently handles large inputs within the constraint limits. 2. Pay careful attention to handling of None values for `min_lim` and `max_lim`.","solution":"from typing import List, Optional def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: Filters the array keeping only those integers which fall between the given minimum and maximum limits, inclusive. Parameters: arr (List[int]): A list of integers min_lim (Optional[int]): The minimum limit (inclusive). This can be None. max_lim (Optional[int]): The maximum limit (inclusive). This can be None. Returns: List[int]: A list of integers within the specified limits. result = [] for num in arr: if (min_lim is None or num >= min_lim) and (max_lim is None or num <= max_lim): result.append(num) return result"},{"question":"# Question: Interval Operations You are tasked with extending the capabilities of the Interval class to support additional operations. Specifically, you need to implement a function that receives a list of Interval objects and returns a list of non-overlapping intervals that union all the input intervals. # Objective Write a function `union_intervals` that takes in a list of intervals and returns a new list where all overlapping intervals are merged into single intervals. The intervals should be non-overlapping and sorted in ascending order based on their starting values. # Input and Output - **Input**: List of `Interval` objects. - **Output**: List of non-overlapping `Interval` objects. # Constraints - Each interval is represented with a start and end point where `start <= end`. - The input list may contain overlapping intervals. - The input list can be empty (return an empty list). - Assume the interval values are integers. # Example ```python intervals = [Interval(1, 3), Interval(2, 4), Interval(5, 7), Interval(6, 8)] result = union_intervals(intervals) # The result should be [Interval(1, 4), Interval(5, 8)] ``` # Additional Notes 1. Ensure that the `union_intervals` function does not modify the original list of intervals. 2. You should leverage the `Interval.merge` static method for merging intervals where possible. ```python class Interval: def __init__(self, start=0, end=0): self.start = start self.end = end def __repr__(self): return \\"Interval({}, {})\\".format(self.start, self.end) def __eq__(self, other): return self.start == other.start and self.end == other.end @staticmethod def merge(intervals): out = [] for i in sorted(intervals, key=lambda i: i.start): if out and i.start <= out[-1].end: out[-1].end = max(out[-1].end, i.end) else: out.append(i) return out def union_intervals(intervals): # Insert your code here pass ```","solution":"class Interval: def __init__(self, start=0, end=0): self.start = start self.end = end def __repr__(self): return \\"Interval({}, {})\\".format(self.start, self.end) def __eq__(self, other): return self.start == other.start and self.end == other.end @staticmethod def merge(intervals): out = [] for i in sorted(intervals, key=lambda i: i.start): if out and i.start <= out[-1].end: out[-1].end = max(out[-1].end, i.end) else: out.append(i) return out def union_intervals(intervals): if not intervals: return [] return Interval.merge(intervals)"},{"question":"**Context**: You are part of a team developing a system that processes linked lists. One of the operations frequently required is partitioning the list based on a given threshold value. The partition operation needs to ensure that all nodes with values less than the threshold come before nodes with values greater than or equal to it. It\'s vital to maintain this order to enable quick filtering and querying processes. **Task**: Write a function `partition` that takes as input the head of a singly linked list and a partition value `x`. This function should reorder the list such that all elements less than `x` appear before elements greater than or equal to `x`. The original relative order of elements in each partition should be maintained. **Input Format**: * The input consists of the head of a singly linked list and an integer `x` which serves as the partition value. **Output Format**: * The function should return the new head of the reordered linked list. **Constraints**: * The values of the linked list nodes are integers. * The partition value `x` is an integer. * You should not use additional data structures (like arrays) to store intermediate nodes. ```python class Node: def __init__(self, val=None): self.val = int(val) self.next = None def partition(head: Node, x: int) -> Node: Reorders the linked list such that all nodes with values less than x come before nodes with values greater than or equal to x. :param head: Node - The head of the singly linked list. :param x: int - The partition value. :return: Node - The new head of the reordered linked list. pass ``` **Examples**: 1. Given the linked list `3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1` and the partition value `5`, it should be reordered to `3 -> 2 -> 1 -> 5 -> 8 -> 5 -> 10`. 2. Given the linked list `1 -> 4 -> 3 -> 2 -> 5 -> 2` and the partition value `3`, it should be reordered to `1 -> 2 -> 2 -> 4 -> 3 -> 5`. **Additional Instructions**: * Ensure that the function handles edge cases gracefully. * Provide a `main` function for testing your implementation.","solution":"class Node: def __init__(self, val=None): self.val = int(val) self.next = None def partition(head: Node, x: int) -> Node: Reorders the linked list such that all nodes with values less than x come before nodes with values greater than or equal to x. :param head: Node - The head of the singly linked list. :param x: int - The partition value. :return: Node - The new head of the reordered linked list. # Create two dummy nodes to start the less and greater lists less_head = less_tail = Node(0) greater_head = greater_tail = Node(0) # Iterate over the original list and partition it into less and greater lists current = head while current: if current.val < x: less_tail.next = current less_tail = less_tail.next else: greater_tail.next = current greater_tail = greater_tail.next current = current.next # Connect the less list with the greater list less_tail.next = greater_head.next greater_tail.next = None # Return the head of the new list which is the next of the less_head dummy node return less_head.next"},{"question":"Background: Given a stack, your task is to implement a function that switches successive pairs of numbers starting at the bottom of the stack. If there are an odd number of values in the stack, the value at the top of the stack should remain in place. Prompt: Write a function `switch_pairs` that takes a stack (implemented as list in Python) and two boolean flags. The flags determine whether to use a stack or a queue for auxiliary storage. ```python def switch_pairs(stack, use_stack: bool, use_queue: bool) -> list: Switch successive pairs starting from the bottom of the stack. Parameters: - stack: List[int] -> A list of integers representing the stack. - use_stack: bool -> Whether to use a stack (list) as auxiliary storage. - use_queue: bool -> Whether to use a queue (collections.deque) as auxiliary storage. Returns: - List[int] -> A list representing the modified stack after pair switching. # Your code here ``` Constraints: * Only one of the boolean flags will be `True` for any given function call. * The stack will contain at most 10^3 elements. * Do not modify the stack in-place; return a new stack that results from switching pairs. Example: ```python stack = [3, 8, 17, 9, 1, 10] use_stack = True use_queue = False print(switch_pairs(stack, use_stack, use_queue)) # Expected output: [8, 3, 9, 17, 10, 1] stack = [3, 8, 17, 9, 1] use_stack = False use_queue = True print(switch_pairs(stack, use_stack, use_queue)) # Expected output: [8, 3, 9, 17, 1] ``` Performance Requirements: * The solution should run efficiently within the provided constraints. * The function should handle edge cases including empty stack and single-element stack gracefully.","solution":"from collections import deque def switch_pairs(stack, use_stack: bool, use_queue: bool) -> list: Switch successive pairs starting from the bottom of the stack. Parameters: - stack: List[int] -> A list of integers representing the stack. - use_stack: bool -> Whether to use a stack (list) as auxiliary storage. - use_queue: bool -> Whether to use a queue (collections.deque) as auxiliary storage. Returns: - List[int] -> A list representing the modified stack after pair switching. if not stack: return [] size = len(stack) aux = [] if use_stack: while stack: aux.append(stack.pop(0)) elif use_queue: aux = deque() while stack: aux.append(stack.pop(0)) result = [] for i in range(0, size, 2): if i + 1 < size: result.append(aux[i + 1]) # push the next element first result.append(aux[i]) # then push the current element else: result.append(aux[i]) # push the last element if odd size return result"},{"question":"# Longest Consecutive Sequence Path in a Binary Tree Objective: Write a function that finds the length of the longest consecutive sequence path in a given binary tree. The path must be from parent to child (cannot be in reverse). Function Signature: ```python def longest_consecutive(root: TreeNode) -> int: ``` Input: - `root`: The root node of the binary tree where each node has an integer value. - `TreeNode` class is defined as: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Output: - Return an integer representing the length of the longest consecutive sequence path from parent to child. Constraints: - The binary tree node values are all integers. - The length of the longest consecutive sequence path will not exceed the number of nodes in the tree. Performance Requirements: - The algorithm should efficiently handle binary trees with up to `10^5` nodes. Example: 1. Given binary tree: ``` 1 3 / 2 4 5 ``` The function should return `3` (the longest consecutive sequence path is 3-4-5). 2. Given binary tree: ``` 2 3 / 2 / 1 ``` The function should return `2` (the longest consecutive sequence path is 2-3). Scenario: You are working as a software engineer for a company developing analytical tools for genetic research. One of the features needed in the tool is to find the longest consecutive genetic mutation sequence in a binary tree representation of mutations. This task involves finding the longest consecutive sequence from a given root node through its children in a mutation tree. Your job is to implement the function that will help in analyzing these genetic mutation sequences. Implementation Note: - You must consider edge cases like an empty tree. - Ensure the function is optimized for large binary trees to prevent performance issues.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def longest_consecutive(root: TreeNode) -> int: Returns the length of the longest consecutive sequence path in the binary tree. def helper(node, parent, length): if not node: return length current_length = length + 1 if parent and node.val == parent.val + 1 else 1 left_length = helper(node.left, node, current_length) right_length = helper(node.right, node, current_length) return max(current_length, left_length, right_length) return helper(root, None, 0)"},{"question":"Problem Statement You are given an array of integers where exactly two elements appear only once and all other elements appear exactly twice. Write a function to identify these two unique elements. The function should have a time complexity of O(N) and use constant, O(1), additional space. Function Signature ```python def find_unique_numbers(nums: List[int]) -> List[int]: pass ``` Input - `nums`: A list of integers where the length of `nums` is at least 4 and there are exactly two unique elements; all other elements appear twice. Output - A list of exactly two integers, which are the unique elements in the array. The order of the output does not matter. Example 1. For `nums = [1, 2, 1, 3, 2, 5]`, the output could be `[3, 5]` or `[5, 3]`. 2. For `nums = [4, 1, 2, 1, 2, 3]`, the output could be `[3, 4]` or `[4, 3]`. Constraints - The input array has at least 4 elements and always contains exactly two unique numbers. - The function _must_ run in O(N) time and use O(1) additional space. Requirements Implement the `find_unique_numbers` function adhering to the above specifications.","solution":"from typing import List def find_unique_numbers(nums: List[int]) -> List[int]: # Step 1: XOR all the numbers in the array xor_result = 0 for num in nums: xor_result ^= num # Step 2: Find a set bit in the xor_result (trick to find lowest set bit) set_bit = xor_result & -xor_result # Step 3: Divide the numbers into two groups and XOR them independently num1, num2 = 0, 0 for num in nums: if num & set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"**Problem Statement: Library Book Finder** You\'re given a sorted list of book IDs in a library, and you need to find a specific book given its ID. However, this library periodically encounters an issue where the books are sometimes not perfectly uniformly distributed by ID due to donations, discards, and new acquisitions. Write a function `find_book(book_ids: List[int], book_id: int) -> int` to implement an improved interpolation search that can handle slight non-uniformities better. # Function Signature ```python def find_book(book_ids: List[int], book_id: int) -> int: ``` # Input - `book_ids`: A list of integers representing sorted book IDs. - `book_id`: An integer representing the book ID you are searching for. # Output - Return the index of the `book_id` in the `book_ids` list if it is found; otherwise, return -1. # Constraints - The length of `book_ids` list will be between 0 and 10^6. - All book IDs in the list are unique. - The book IDs are sorted in increasing order. - The function should handle non-uniformly distributed data efficiently. # Example ```python assert find_book([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert find_book([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert find_book([5, 10, 12, 14, 17, 20, 21], -5) == -1 assert find_book([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 70) == 6 ``` # Additional Info - Consider slight variations in the distribution and provide heuristic improvements to the interpolation formula. - Ensure your solution is efficient and handles edge cases appropriately.","solution":"def find_book(book_ids, book_id): This function implements an enhanced version of the interpolation search algorithm, designed to work efficiently even on non-uniformly distributed sorted lists of book IDs. low = 0 high = len(book_ids) - 1 while low <= high and book_id >= book_ids[low] and book_id <= book_ids[high]: # Avoid division by zero if book_ids[high] == book_ids[low]: pos = low else: # Calculate the position using a modified interpolation formula pos = low + ((high - low) * (book_id - book_ids[low]) // (book_ids[high] - book_ids[low])) # Check if the element is at position pos if book_ids[pos] == book_id: return pos # If the book ID is larger, it is in the upper part of the array if book_ids[pos] < book_id: low = pos + 1 # If the book ID is smaller, it is in the lower part of the array else: high = pos - 1 # If the book ID is not found return -1"},{"question":"# Question: Implement a Modified Pigeonhole Sort Scenario: Imagine you are tasked with sorting a list of integers where the difference between the maximum and minimum elements is nearly similar to the number of elements in the list. Knowing that traditional sorting algorithms may not be optimal, you decide to use Pigeonhole Sort but modify it to handle potential edge cases such as negative numbers and empty lists. Task: Write a Python function `modified_pigeonhole_sort(arr)` that sorts a provided list of integers using a modified version of the Pigeonhole Sort algorithm. Ensure that your implementation correctly handles edge cases like empty arrays and arrays with negative numbers. Function Signature: ```python def modified_pigeonhole_sort(arr: list) -> list: ``` Input: * A list `arr` of integers `arr` (can contain both positive and negative integers, may also be empty), with constraints: len(arr) ≤ 10^6 and -10^6 ≤ arr[i] ≤ 10^6 for each element `arr[i]`. Output: * Returns a new list with the elements from `arr` sorted in non-decreasing order. Example: ```python assert modified_pigeonhole_sort([8, 3, -7, 3, 8, -1, 0]) == [-7, -1, 0, 3, 3, 8, 8] assert modified_pigeonhole_sort([]) == [] assert modified_pigeonhole_sort([5, 5, 5]) == [5, 5, 5] assert modified_pigeonhole_sort([0, -1, -10, 0, 5, 100]) == [-10, -1, 0, 0, 5, 100] ``` Constraints: * Do not import any external libraries. * Ensure your solution is efficient in both time and space given the possible input sizes. Performance Requirements: * The implementation should handle the edge cases efficiently without compromising on the time complexity of O(n + Range). Hints: - Consider the absolute difference between the maximum and minimum values for initializing the array size. - Think about how negative numbers affect the mapping into the holes array.","solution":"def modified_pigeonhole_sort(arr: list) -> list: if not arr: return [] # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Find the range of the input list range_of_elements = max_val - min_val + 1 # Create holes for each value in the range holes = [0] * range_of_elements # Populate the holes for num in arr: holes[num - min_val] += 1 # Create the sorted output sorted_arr = [] for index in range(range_of_elements): while holes[index] > 0: sorted_arr.append(index + min_val) holes[index] -= 1 return sorted_arr"},{"question":"# Bitonic Sort Enhancement Problem You have been tasked with enhancing a bitonic sort algorithm, which is an efficient parallel sorting mechanism. The core algorithm has been provided, but you need to make sure it is optimized and handles additional constraints effectively. Task: Enhance the provided bitonic sort function to: 1. **Handle arrays that aren\'t powers of 2 by padding them with the maximum integer value** until the length is a power of 2. 2. **Optimize memory usage and performance** by implementing in-place sorting where appropriate. 3. **Ensure the function can sort in both increasing and decreasing orders** based on a provided boolean flag. Implementation Details: * You are to modify the function `bitonic_sort(arr, reverse=False)` to meet the above requirements. * The function argument `arr` will be a list of integers. * The function `reverse` will be a boolean flag indicating if the array should be sorted in descending order (`True` for descending, `False` for ascending). Input: * List of integers `arr` which may or may not have length as a power of 2. * Boolean `reverse` indicating the order in which the array should be sorted. Output: * A list of integers sorted in the specified order. Constraints: * The input list `arr` can have up to ( 10^6 ) elements. * The maximum integer value in the list will be ( 10^9 ) and the minimum value can be (-10^9). Example: ```python bitonic_sort([3, 7, 2, 5, 1, 4, 6, 8], reverse=True) ``` Output: `[8, 7, 6, 5, 4, 3, 2, 1]` Note: - The function should handle non-power of 2 lengths by appropriately padding the array. Good Luck!","solution":"def bitonic_sort(arr, reverse=False): Sorts the array in ascending or descending order using bitonic sort. Parameters: arr (list): List of integers to be sorted. reverse (bool): If True, sort in descending order. Else, sort in ascending order. Returns: list: Sorted list in the specified order. import math # Helper function to compare and swap elements def compare_and_swap(arr, i, j, direction): if (direction == 1 and arr[i] > arr[j]) or (direction == 0 and arr[i] < arr[j]): arr[i], arr[j] = arr[j], arr[i] # Helper function to bitonic merge def bitonic_merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) # Helper function to recursively sort bitonic sequence def bitonic_sort_rec(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort_rec(arr, low, k, 1) # Ascending bitonic_sort_rec(arr, low + k, k, 0) # Descending bitonic_merge(arr, low, cnt, direction) # Check if length of the array is power of 2 n = len(arr) if n & (n - 1) != 0: # Not a power of 2, pad the array next_power_of_2 = 1 << (n - 1).bit_length() arr.extend([float(\'inf\')] * (next_power_of_2 - n)) # Perform bitonic sort bitonic_sort_rec(arr, 0, len(arr), 1 if not reverse else 0) if reverse: # Remove padding if reverse sorting return [x for x in arr if x != float(\'inf\')] else: # Remove padding for ascending sorting return [x for x in arr if x != float(\'inf\')]"},{"question":"# Implementing a Weighted Moving Average You are required to implement a class `WeightedMovingAverage` that computes the weighted moving average of a stream of integers within a specified sliding window size. The weight of each value within the window increases linearly with time, giving more importance to recent values. Function Signature ```python class WeightedMovingAverage: def __init__(self, size: int): Initialize the data structure. def next(self, val: int) -> float: Calculate and return the weighted moving average of the sliding window. ``` Input & Output - **Input**: - `val`: integer values sequentially passed to the `next` method. - **Output**: - Returns a float representing the weighted moving average. Constraints - Window size (`size`) is a positive integer. - The weight of each value is its position in the window (1 for the oldest, increasing by 1 for more recent values). Example ```python wma = WeightedMovingAverage(3) assert wma.next(1) == 1.0 assert wma.next(10) == (1*1 + 10*2) / (1+2) assert wma.next(3) == (1*1 + 10*2 + 3*3) / (1+2+3) assert wma.next(5) == (10*1 + 3*2 + 5*3) / (1+2+3) ``` Notes - You are expected to handle the initialization and updating of the moving average internally using an appropriate data structure. - You must ensure efficient computation, targeting O(1) time complexity per update. - Consider edge cases where fewer than \'N\' elements are available in the window.","solution":"from collections import deque class WeightedMovingAverage: def __init__(self, size: int): Initialize the data structure. self.size = size self.window = deque() # to store the sliding window values self.weights_sum = 0 # to store the cumulative weight is 1+2+...+window_size def next(self, val: int) -> float: Calculate and return the weighted moving average of the sliding window. self.window.append(val) if len(self.window) > self.size: self.window.popleft() window_length = len(self.window) weights = list(range(1, window_length + 1)) weighted_sum = sum(v * w for v, w in zip(self.window, weights)) self.weights_sum = sum(weights) return weighted_sum / self.weights_sum"},{"question":"Advanced Insertion Sort with Descending Order Option You are asked to extend the functionality of the provided insertion sort algorithm to handle sorting in both ascending and descending orders. Your implementation should take an additional boolean parameter `descending` which, when set to `True`, sorts the array in descending order, otherwise, it sorts in ascending order. The function should also handle various edge cases and ensure stability when sorting duplicate elements in both orders. Function Signature ```python def advanced_insertion_sort(arr: list, descending: bool = False) -> list: pass ``` Input * `arr`: A list of integers. * `descending`: A boolean which indicates whether the list should be sorted in descending order. Output * A list of integers sorted based on the provided order (ascending by default, descending if specified). Constraints * The length of the list (`n`) is in the range [0, 10^6]. * The elements of the list are integers in the range [-10^9, 10^9]. Example ```python >>> advanced_insertion_sort([5, 2, 9, 1, 5, 6]) [1, 2, 5, 5, 6, 9] >>> advanced_insertion_sort([5, 2, 9, 1, 5, 6], descending=True) [9, 6, 5, 5, 2, 1] >>> advanced_insertion_sort([]) [] >>> advanced_insertion_sort([3]) [3] ``` Note * Your solution must work efficiently for large lists, keeping in mind the O(n^2) limitations. * Ensure your implementation maintains the stability property of the insertion sort.","solution":"def advanced_insertion_sort(arr: list, descending: bool = False) -> list: Sorts a list using insertion sort algorithm in ascending order by default or in descending order if the flag `descending` is set to True. Parameters: arr (list): List of integers to be sorted. descending (bool): Sort order flag, True for descending, False for ascending. Returns: list: Sorted list of integers. n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 # Change condition based on the order if descending: while j >= 0 and arr[j] < key: arr[j + 1] = arr[j] j -= 1 else: while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"**Context:** Euler\'s Totient function (ϕ(n)) is a foundational concept in number theory that finds applications in various domains including cryptography. Implement an advanced version of this function that can handle multiple queries efficiently, due to its frequent use in real-world applications like RSA encryption. **Problem Statement:** Given an integer `n`, compute the values of Euler\'s Totient function for all integers from 1 to `n`. **Function Signature:** ```python def compute_totients(n: int) -> List[int]: Computes the Totient function for all integers from 1 to n. Args: n (int): A positive integer. 1 ≤ n ≤ 10^6. Returns: List[int]: A list where the ith element is the value of ϕ(i). ``` # Input: * An integer `n` where `1 ≤ n ≤ 10^6`. # Output: * A list of integers where the ith element is the value of ϕ(i) for `1 ≤ i ≤ n`. # Constraints: * The function must run efficiently for the given range up to 10^6. * Consider the properties of the Totient function for optimization. # Example: ```python assert compute_totients(6) == [0, 1, 1, 2, 2, 4, 2] ``` # Explanation: - ϕ(1) = 1 (1 coprime with 1) - ϕ(2) = 1 (1 coprime with 2) - ϕ(3) = 2 (1, 2 coprime with 3) - ϕ(4) = 2 (1, 3 coprime with 4) - ϕ(5) = 4 (1, 2, 3, 4 coprime with 5) - ϕ(6) = 2 (1, 5 coprime with 6) Implement the function considering efficient computation for large inputs.","solution":"from typing import List def compute_totients(n: int) -> List[int]: Computes the Totient function for all integers from 1 to n. Args: n (int): A positive integer. 1 ≤ n ≤ 10^6. Returns: List[int]: A list where the ith element is the value of ϕ(i). phi = list(range(n + 1)) for i in range(2, n + 1): if phi[i] == i: for j in range(i, n + 1, i): phi[j] *= (i - 1) phi[j] //= i phi[1] = 1 # ϕ(1) is 1 by definition. return phi"},{"question":"# Question: Enhanced Interpolation Search Given the implementation of the Interpolation Search algorithm above, you are to enhance its robustness and efficiency to handle additional edge cases and optimize performance. Your task is to write a function `optimal_interpolation_search` that includes these improvements: * **Handle arrays with non-uniform distribution of elements more efficiently.** * **Handle potential division by zero errors.** * **Return a message if the array is empty.** Implement the function `optimal_interpolation_search` with the following signature: ```python from typing import List, Union def optimal_interpolation_search(array: List[int], search_key: int) -> Union[int, str]: :param array: A sorted array to search within. :param search_key: The value to search for in the array. :return: Index of the search_key if found, otherwise -1. If the array is empty, return \\"Array is empty\\". pass ``` # Constraints * The `array` is guaranteed to be sorted in increasing order. * The elements of `array` and `search_key` will be integers. * Optimize your function to ensure desirable performance characteristics under typical and edge cases. # Example Implementation Below are some example executions of the function: ```python assert optimal_interpolation_search([], 10) == \\"Array is empty\\" assert optimal_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert optimal_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert optimal_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) == -1 assert optimal_interpolation_search([10, 10, 10, 10, 10, 10, 10], 10) == 0 ``` # Performance Requirement Your solution should aim to perform interpolation search in (O(log log n)) for average cases and avoid linear performance degradation wherever possible.","solution":"from typing import List, Union def optimal_interpolation_search(array: List[int], search_key: int) -> Union[int, str]: Performs an interpolation search for the search_key in the given array. :param array: A sorted list of integers. :param search_key: The integer value to search for. :return: The index of search_key if found, -1 if not found, or a message \\"Array is empty\\" if the array is empty. n = len(array) if n == 0: return \\"Array is empty\\" low = 0 high = n - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if array[low] == array[high]: if array[low] == search_key: return low else: return -1 pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) # Check boundaries in case pos goes out of range if pos < 0 or pos >= n: break if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Scenario A company has a system that needs to store and manage a large number of user data entries where each entry includes a username (as the key) and user profile details (as the value). The system needs a fast way to retrieve, insert, and delete profiles based on usernames. Given the company\'s requirement for high efficiency, you have decided to use a hash table with separate chaining to handle possible collisions. # Task Implement the `SeparateChainingHashTable` class with methods to handle the following operations efficiently: 1. **Insert a new key-value pair** into the hash table. 2. **Retrieve the value** associated with a given key. 3. **Delete a key-value pair** based on a given key. 4. **Return the number of key-value pairs** currently stored in the hash table. # Function Signature ```python class SeparateChainingHashTable: def __init__(self, size=11): pass def put(self, key, value): pass def get(self, key): pass def del_(self, key): pass def __len__(self): pass ``` # Input and Output 1. **put(key, value)**: * **Input**: `key` (str), `value` (str) - Adds or updates the key with the given value. * **Output**: None 2. **get(key)**: * **Input**: `key` (str) - Retrieves the value associated with the key. * **Output**: `value` (str) if the key exists, otherwise `None`. 3. **del_(key)**: * **Input**: `key` (str) - Deletes the key-value pair if the key exists. * **Output**: None 4. **__len__()**: * **Output**: Returns the number of key-value pairs stored in the hash table. # Constraints * You must use separate chaining to handle collisions. * The hash table should support typical operations within O(1) average time complexity. * The implementation can assume that keys and values are both strings. # Example ```python # Initializing the hash table ht = SeparateChainingHashTable() # Adding key-value pairs ht.put(\'user1\', \'profile1\') ht.put(\'user2\', \'profile2\') # Retrieving values print(ht.get(\'user1\')) # Output: \'profile1\' print(ht.get(\'user3\')) # Output: None # Deleting a key-value pair ht.del_(\'user1\') print(ht.get(\'user1\')) # Output: None # Getting the length of the hash table print(len(ht)) # Output: 1 ```","solution":"class SeparateChainingHashTable: def __init__(self, size=11): self.size = size self.table = [[] for _ in range(size)] self.count = 0 def _hash(self, key): return hash(key) % self.size def put(self, key, value): hash_index = self._hash(key) for pair in self.table[hash_index]: if pair[0] == key: pair[1] = value return self.table[hash_index].append([key, value]) self.count += 1 def get(self, key): hash_index = self._hash(key) for pair in self.table[hash_index]: if pair[0] == key: return pair[1] return None def del_(self, key): hash_index = self._hash(key) for pair in self.table[hash_index]: if pair[0] == key: self.table[hash_index].remove(pair) self.count -= 1 return def __len__(self): return self.count"},{"question":"Generate All Possible Subsets Given a list of distinct integers `nums`, write a function `generate_subsets(nums)`. The function should return all possible subsets of the given list. The solution set must not contain duplicate subsets. The order of subsets does not matter. # Input - `nums` (list of integers): a list of distinct integers, where (0 leq len(nums) leq 10). # Output - Return a list of lists, where each list is a subset of the original list `nums`. All subsets, including the empty set, should be represented. # Constraints - The integers in `nums` are unique. - The maximum length of `nums` is 10, ensuring the solution can handle (2^{10} = 1024) subsets. # Examples Example 1: Input: ```python nums = [1, 2, 3] ``` Output: ```python [ [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3] ] ``` Example 2: Input: ```python nums = [] ``` Output: ```python [ [] ] ``` # Instructions: 1. Implement the `generate_subsets` function using either the backtracking or iterative approach. 2. Ensure your solution runs efficiently for the given constraints. 3. Provide comments explaining your code logic and how it handles edge cases.","solution":"def generate_subsets(nums): Generate all possible subsets of a list of distinct integers. Args: nums (list): List of distinct integers. Returns: list: A list of lists, where each inner list is a subset of the input list. result = [[]] # Start with the empty subset for num in nums: new_subsets = [] for subset in result: new_subsets.append(subset + [num]) result.extend(new_subsets) return result"},{"question":"# Coding Challenge: Encrypted Message Decoder **Context**: You have been given the task to implement a decryption function for a modified version of Caesar Cipher used in a secure message transmission between secret agents. This decryption function needs to handle both encoding and decoding eventually but for now, your focus is decoding encrypted messages using a known shift value. **Objective**: Write a function that decrypts a message encrypted using the Caesar Cipher technique. **Function Signature**: ```python def decrypt_caesar_cipher(s: str, k: int) -> str: pass ``` **Input and Output**: * **Input**: A string `s` containing the encrypted message composed of alphabetic characters and an integer `k` representing the shift value. * **Output**: A string representing the plain text (original message before encryption). **Constraints**: * 0 ≤ k ≤ 25 * 0 ≤ len(s) ≤ 10^6 **Example**: ```python assert decrypt_caesar_cipher(\\"d\\", 3) == \\"a\\" assert decrypt_caesar_cipher(\\"def\\", 3) == \\"abc\\" assert decrypt_caesar_cipher(\\"Zab\\", 1) == \\"Yza\\" ``` **Guidance**: 1. Focus on correctly handling both uppercase and lowercase alphabetic characters. 2. Ensure that non-alphabetic characters (if any) are preserved in their original positions. 3. Consider edge cases like an empty input string and very large strings close to the maximum constraint. Implement the function considering the above requirements and constraints.","solution":"def decrypt_caesar_cipher(s: str, k: int) -> str: Decrypts a message encrypted with the Caesar Cipher technique. Parameters: s (str): Encrypted message. k (int): Shift value. Returns: str: Decrypted plain text. def decrypt_char(c, k): if \'a\' <= c <= \'z\': return chr((ord(c) - k - ord(\'a\')) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - k - ord(\'A\')) % 26 + ord(\'A\')) else: return c return \'\'.join(decrypt_char(c, k) for c in s)"},{"question":"In this coding assessment, you are required to implement an efficient solution to compute the n-th Fibonacci number. Given the different approaches discussed (recursive, dynamic programming, and iterative), you are expected to leverage the most efficient approach in terms of time and space complexity. # Specifics You need to implement a function `fibonacci(n: int) -> int` that returns the n-th Fibonacci number. # Requirements and Constraints * **Input**: * An integer `n` where (0 leq n leq 10^6). * **Output**: * The n-th Fibonacci number. * **Constraints**: * Solve the problem efficiently both in terms of time and space. * Ensure that the input validation is performed (i.e., `n` should be a non-negative integer). * **Performance**: * Your solution should run in (O(n)) time complexity and (O(1)) space complexity. # Example ```python def fibonacci(n: int) -> int: # Your implementation here pass # Example Usage # Input: 10 # Output: 55 print(fibonacci(10)) # Input: 50 # Output: 12586269025 print(fibonacci(50)) ``` # Edge Cases * Handle the case when `n` is 0 (should return 0). * Handle the case when `n` is 1 (should return 1).","solution":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number. :param n: Non-negative integer representing the position in the Fibonacci sequence. :return: The n-th Fibonacci number. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") elif n == 0: return 0 elif n == 1: return 1 prev, curr = 0, 1 for _ in range(2, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"# Question You are given an array of integers where every integer appears exactly three times except for one integer that appears exactly once. Your task is to find the integer that appears only once. Your solution should have a linear runtime complexity and must not use extra memory beyond constant space. Function Signature ```python def single_number(nums: List[int]) -> int: ``` Input - `nums`: A list of integers, with length `n` (`1 <= n <= 3 * 10^4`). - It is guaranteed that every element in `nums` appears exactly three times except for one element which appears exactly once. Output - Return the single integer in the array that appears only once. Constraints - The function must run in `O(n)` time complexity. - The function must use `O(1)` additional space complexity. Example ```python assert single_number([2, 2, 3, 2]) == 3 assert single_number([0, 1, 0, 1, 0, 1, 99]) == 99 ``` Implementation Requirements - The solution should use bit manipulation. - Any additional data structure like another array, list, hashmap is not allowed. **Hint:** Consider how you can use bit operations to differentiate between numbers appearing once versus numbers appearing multiple times.","solution":"def single_number(nums): Finds the element in the list that appears only once where every other element appears exactly three times. Uses bit manipulation to achieve constant space complexity. ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"# Array Filtering with Limits Objective: You need to implement a function, similar to the provided code, that filters elements of an array based on given minimum and maximum limits. Function Signature: ```python def filter_with_limits(arr: List[int], min_lim: Union[int, None], max_lim: Union[int, None]) -> List[int]: ``` Parameters: * `arr`: A list of integers that needs to be filtered. * `min_lim`: An integer or `None`. If it is `None`, consider the smallest element of the array as the lower bound. * `max_lim`: An integer or `None`. If it is `None`, consider the largest element of the array as the upper bound. Returns: * A new list containing elements within the specified limits. Constraints: * The elements in `arr` are integers. * The length of `arr` will be between `0` and `10^5`. * `min_lim` and `max_lim` can be `None` or integers such that `-10^9 ≤ min_lim ≤ max_lim ≤ 10^9`. Examples: ```python assert filter_with_limits([1,2,3,4,5], 2, 4) == [2, 3, 4] assert filter_with_limits([1,2,3,4,5], None, 3) == [1, 2, 3] assert filter_with_limits([1,2,3,4,5], 3, None) == [3, 4, 5] assert filter_with_limits([], None, None) == [] assert filter_with_limits([1,2,3,4,5], 10, None) == [] assert filter_with_limits([1,2,3,4,5], None, 0) == [] ``` Notes: * If both `min_lim` and `max_lim` are `None`, the function should return the array sorted in ascending order.","solution":"from typing import List, Union def filter_with_limits(arr: List[int], min_lim: Union[int, None], max_lim: Union[int, None]) -> List[int]: Filters elements of the array based on given minimum and maximum limits. If min_lim is None, the smallest element of the array should be considered as the lower bound. If max_lim is None, the largest element of the array should be considered as the upper bound. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# ZigZag Iterator Coding Challenge **Context**: You are building a new presentation feature for a data visualization tool that displays sequences from multiple data sources alternatively, ensuring fair representation. **Problem**: Implement a class `MultiZigZagIterator` that allows iteration over `k` lists in a zigzag manner. The class should evenly distribute the elements from each list by alternating between them in round-robin order. # Function Signature ```python class MultiZigZagIterator: def __init__(self, lists: List[List[int]]): Initialize your data structure here. :type lists: List[List[int]] pass def next(self) -> int: :rtype: int pass def has_next(self) -> bool: :rtype: bool pass ``` # Input & Output * `__init__(lists: List[List[int]])` - initializes the iterator with a list of lists. * `next() -> int` - returns the next integer in the zigzag sequence. * `has_next() -> bool` - returns `True` if there are more elements to iterate over, otherwise `False`. # Constraints * Each list may have different lengths. * The lists may contain thousands of elements. * Elements are integers in the range `[-10^6, 10^6]`. # Example ```python lists = [ [1, 2, 3], [4, 5, 6, 7], [8, 9] ] iterator = MultiZigZagIterator(lists) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) # Output: [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` # Points to Consider * **Edge Cases**: Lists of varying lengths, one or more empty lists. * **Efficiency**: Consider using a more efficient data structure than simple lists for managing the iteration state. * **Correctness**: Ensure elements are returned in the correct zigzag order even if the lists have different lengths.","solution":"from typing import List from collections import deque class MultiZigZagIterator: def __init__(self, lists: List[List[int]]): Initialize the iterator with a list of lists. :type lists: List[List[int]] self.queue = deque((lst, 0) for lst in lists if lst) def next(self) -> int: Returns the next integer in the zigzag sequence. :rtype: int if self.has_next(): lst, idx = self.queue.popleft() result = lst[idx] if idx + 1 < len(lst): self.queue.append((lst, idx + 1)) return result def has_next(self) -> bool: Returns True if there are more elements to iterate over, otherwise False. :rtype: bool return bool(self.queue)"},{"question":"# Scenario: A city has multiple pipelines that distribute water between different sectors. Each pipeline has a maximum capacity of water flow. We need to determine the maximum possible flow of water from the water plant (source) to the emergency reservoir (sink). You are required to implement this using Dinic\'s Algorithm due to its efficiency with large networks. # Problem Statement: Implement a function `calculate_max_flow` that computes the maximum flow from the source to the sink using Dinic\'s Algorithm. # Function Signature: ```python def calculate_max_flow(capacity: List[List[int]], source: int, sink: int) -> int: pass ``` # Input: * `capacity`: A 2D list (matrix) of integers where `capacity[i][j]` represents the maximum capacity of water flow from sector `i` to sector `j`. * `source`: An integer representing the water plant sector. * `sink`: An integer representing the emergency reservoir sector. # Output: * An integer representing the maximum possible flow from the source to the sink. # Constraints: * `1 <= len(capacity) <= 1000` (Number of sectors) * `0 <= capacity[i][j] <= 10^6` (Capacity of each pipeline) * Sectors are represented by unique integers `0` to `len(capacity) - 1`. * Assume valid input for source and sink sectors. # Example: ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 ``` Expected Output: ```python 23 ``` # Notes: 1. Implement the code considering edge cases like disconnected graphs where some sections cannot be reached. 2. Utilize the provided auxiliary functions for BFS and DFS as needed.","solution":"from collections import deque from typing import List, Optional def bfs(level: List[Optional[int]], capacity: List[List[int]], flow: List[List[int]], source: int, sink: int) -> bool: Performs a BFS to construct level graph. queue = deque([source]) level[source] = 0 while queue: u = queue.popleft() for v in range(len(capacity)): if level[v] is None and flow[u][v] < capacity[u][v]: level[v] = level[u] + 1 queue.append(v) if v == sink: return True return False def dfs(u: int, sink: int, flow: List[List[int]], capacity: List[List[int]], level: List[Optional[int]], start: List[int], current_flow: int) -> int: Sends flow along an augmenting path using DFS. if u == sink: return current_flow while start[u] < len(capacity): v = start[u] if level[v] == level[u] + 1 and flow[u][v] < capacity[u][v]: min_flow = min(current_flow, capacity[u][v] - flow[u][v]) result_flow = dfs(v, sink, flow, capacity, level, start, min_flow) if result_flow > 0: flow[u][v] += result_flow flow[v][u] -= result_flow return result_flow start[u] += 1 return 0 def calculate_max_flow(capacity: List[List[int]], source: int, sink: int) -> int: Calculates the maximum flow from source to sink using Dinic\'s Algorithm. n = len(capacity) flow = [[0] * n for _ in range(n)] max_flow = 0 while True: level = [None] * n if not bfs(level, capacity, flow, source, sink): break start = [0] * n while True: increment = dfs(source, sink, flow, capacity, level, start, float(\'Inf\')) if increment == 0: break max_flow += increment return max_flow"},{"question":"You are given the task of identifying numbers that possess a unique property within a specified range. A number is considered to have this property if it is equal to the sum of its digits, each raised to the power of its positional index (starting from 1). **Function Signature**: `def find_eureka_numbers(low: int, high: int) -> list:` # Input: - The function accepts two integers, `low` and `high`, inclusive, indicating the range within which to identify such numbers. * `1 <= low <= high <= 10^4` # Output: - Return a list of integers that satisfy the property, sorted in ascending order. # Constraints: - The range is inclusive of `low` and `high`. - Ensure the function operates efficiently within provided constraints. # Example: ```python assert find_eureka_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_eureka_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert find_eureka_numbers(50, 150) == [89, 135] ``` # Explanation: - For the first example, within range 1 to 10, all single-digit numbers are returned. - For range 1 to 100, numbers include single-digit numbers and the special number 89. - For range 50 to 150, the special numbers 89 and 135 meet the criteria.","solution":"def find_eureka_numbers(low: int, high: int) -> list: Identifies numbers within the range [low, high] that are equal to the sum of their digits each raised to the power of its positional index (starting from 1). :param low: The lower bound of the range (inclusive). :param high: The upper bound of the range (inclusive). :return: A list of integers within the range that satisfy the property. def is_eureka_number(num: int) -> bool: digits = [int(d) for d in str(num)] eureka_sum = sum(d ** (i + 1) for i, d in enumerate(digits)) return num == eureka_sum return [num for num in range(low, high + 1) if is_eureka_number(num)]"},{"question":"**Context**: You are developing a feature for a new word game where players can abbreviate a given word in any possible format. An abbreviation is defined as replacing any substring (including single letters) of the word with the count of letters in that substring. For example, \\"word\\" can be abbreviated as \\"w1rd\\" (one character between \'w\' and \'r\'), \\"wo1d\\" (one character between \'wo\' and \'d\'), and so on. **Task**: Write a function `generate_abbreviations(word)` that takes a `word` as input and returns a list of all possible abbreviations of the word. **Function Signature**: ```python def generate_abbreviations(word: str) -> List[str]: pass ``` **Input**: - `word` (1 ≤ length(word) ≤ 15): A non-empty string of lowercase alphabets. **Output**: - A list of strings containing all possible abbreviations of the word. **Constraints**: - The order of the abbreviations in the list does not matter. - Performance considerations due to the exponential nature of the problem should be kept in mind but do not affect the expected output for the given constraints. **Example**: ```python assert set(generate_abbreviations(\\"word\\")) == set([ \'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\' ]) ``` **Explanation**: For the word \\"word\\", there are multiple ways it can be abbreviated, either by replacing parts of it with their counts or keeping certain letters as they are. **Notes**: - Consider edge cases such as an empty string or a very short word. - Assume the input is always valid, containing only lowercase alphabets. **Implementation Plan**: 1. Implement a recursive helper function that takes the remaining part of the word, the current position, the count of abbreviated characters, and the current abbreviation being built. 2. Use backtracking to either abbreviate the current character or keep it. 3. Append the completed abbreviation to the result list.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: def backtrack(pos, current, count): if pos == len(word): if count > 0: current += str(count) result.append(current) else: # Abbreviate current character backtrack(pos + 1, current, count + 1) # Do not abbreviate current character new_current = current + (str(count) if count > 0 else \'\') + word[pos] backtrack(pos + 1, new_current, 0) result = [] backtrack(0, \\"\\", 0) return result"},{"question":"You are tasked with designing a Deterministic Finite Automaton (DFA) to validate certain input strings according to specified rules. Given a transition table, the initial state, and a set of final states, you need to determine if an input string is accepted by the DFA. # Function Signature ```python def DFA(transitions: dict, start: int, final: list, string: str) -> bool: pass ``` # Inputs - `transitions` (dict): A dictionary representing the transition table of the DFA. Keys are current states, and values are dictionaries where keys are input symbols and values are next states. - `start` (int): The start state. - `final` (list): A list of final (accepting) states. - `string` (str): The input string to be tested against the DFA. # Output - Returns `True` if the input string is accepted by the DFA, i.e., leads from the start state to one of the final states via valid transitions. - Returns `False` otherwise. # Constraints - The transition table will cover all necessary transitions, i.e., transitions for each symbol from every state will be defined. - The input string will only contain symbols existing in the transition table. - The DFA has a finite number of states and transitions. - The string length (n) will be feasible for processing within typical constraints (1 ≤ n ≤ 1000). # Sample Input ```python transitions = { 0: {\'a\': 1, \'b\': 0}, 1: {\'a\': 0, \'b\': 2}, 2: {\'a\': 2, \'b\': 2} } start = 0 final = [2] string = \\"ab\\" ``` # Sample Output ```python True ``` # Explanation Starting from state 0: - On reading \'a\', transition to state 1. - On reading \'b\', transition to state 2. State 2 is a final state, so the DFA accepts the string \\"ab\\". # Notes: - Consider edge cases such as empty strings, strings consisting of the same character, and invalid paths. - Ensure your solution handles edge cases where an input symbol leads to a state with no further transitions by returning `False`.","solution":"def DFA(transitions: dict, start: int, final: list, string: str) -> bool: Determine if the DFA accepts the input string. Args: transitions (dict): The transition table of the DFA. start (int): The start state. final (list): List of final (accepting) states. string (str): The input string to validate. Returns: bool: True if the input string is accepted by the DFA, False otherwise. current_state = start for symbol in string: if symbol in transitions[current_state]: current_state = transitions[current_state][symbol] else: return False return current_state in final"},{"question":"**Problem Statement**: You are given a list of non-negative integers representing the amount of money hidden in each house along a street. You are a professional robber who wants to maximize the amount of money robbed without triggering the home\'s security system. The security system will be triggered if two adjacent houses are robbed on the same night. Given the list of non-negative integers, implement a function `max_rob_amount` that returns the maximum amount of money you can rob tonight without triggering the alarm. **Function Signature**: ```python def max_rob_amount(houses: List[int]) -> int: ``` **Input**: - `houses`: A list of non-negative integers (0 ≤ house amount ≤ 10^4) representing the money in each house. The length of the list will be between 0 and 10^5. **Output**: - Returns the maximum amount of money that can be robbed without triggering the security system. **Constraints**: - You cannot rob two adjacent houses. - You may assume all inputs are valid and within the given constraints. **Example**: 1. Input: `[2, 3, 2]` Output: `4` Explanation: Rob houses 1 and 3 for a total of 2 + 2 = 4. 2. Input: `[1, 2, 3, 1]` Output: `4` Explanation: Rob houses 1 and 3 for a total of 1 + 3 = 4. 3. Input: `[0]` Output: `0` Explanation: No money to rob. **Guidelines**: - This is a dynamic programming problem. The optimal solution involves deciding for each house whether to rob it or not based on the previous decisions. - Make sure your solution is efficient and adheres to the given constraints as the list could be very large.","solution":"from typing import List def max_rob_amount(houses: List[int]) -> int: Function to determine the maximum amount of money that can be robbed without triggering the security system. :param houses: List[int] - A list of non-negative integers representing money in each house. :return: int - The maximum amount of money that can be robbed. if not houses: return 0 n = len(houses) if n == 1: return houses[0] # Initialize an array to store the maximum robbed amount at each house dp = [0] * n # Base cases dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) # Fill the dp array for each house from 2 to n-1 for i in range(2, n): dp[i] = max(dp[i - 1], dp[i - 2] + houses[i]) # The last element in dp array will have the maximum amount that can be robbed return dp[-1]"},{"question":"# Segment Tree Implementation and Utilization Context Segment trees are powerful data structures used for efficient range queries and updates. Given an array, you can perform operations like getting the sum, minimum, or maximum over a sub-array effectively by leveraging a segment tree. In this task, you will demonstrate your understanding of segment trees by implementing the core operations of a segment tree: building the tree, updating an element, and querying a range. Task You are required to implement the following operations of a segment tree: 1. **Build the tree**: Based on a given array and an associative function. 2. **Update an element**: Update the value of an element in the original array and reflect this change in the segment tree. 3. **Query a range**: Compute the result of the associative function over a given range in the array. Function Signatures * `__init__(self, arr: List[int], function: Callable[[int, int], int]) -> None` * `def update(self, index: int, value: int) -> None` * `def query(self, start: int, end: int) -> int` Input and Output * `__init__`: Initialize the segment tree with the given array (`arr`) and function (`function`). The function must be associative and take two integers, returning an integer. * `update`: Update the element at the given `index` in the array to the new `value`. * `query`: Return the accumulated result of the associative function over the sub-array segment from `start` to `end` (inclusive). Constraints * The input array `arr` will have a length of `0` to `10^5`. * Values in the array are integers in the range of `-10^9` to `10^9`. * The associative function will be a valid lambda or function that adheres to the properties of commutativity and associativity for integers. Example ```python segment_tree = SegmentTree([2, 4, 5, 3, 4], max) assert segment_tree.query(2, 4) == 5 segment_tree.update(3, 6) assert segment_tree.query(0, 3) == 6 segment_tree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) assert segment_tree.query(0, 6) == 64 segment_tree.update(2, -10) assert segment_tree.query(0, 6) == 52 segment_tree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) assert segment_tree.query(0, 2) == (9, 13) segment_tree.update(2, (-1, 2)) assert segment_tree.query(0, 2) == (4, 10) ``` Performance Constraints * Ensure your implementation runs efficiently within the provided constraints.","solution":"from typing import List, Callable class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]) -> None: Initialize the segment tree with the given array and function. self.n = len(arr) self.function = function self.tree = [0] * (2 * self.n) # Build the tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index: int, value: int) -> None: Update the element at the given index to the new value. index += self.n self.tree[index] = value while index > 1: index //= 2 self.tree[index] = self.function(self.tree[2 * index], self.tree[2 * index + 1]) def query(self, start: int, end: int) -> int: Query the result of the associative function over the range [start, end]. start += self.n end += self.n + 1 res = None while start < end: if start % 2: res = self.tree[start] if res is None else self.function(res, self.tree[start]) start += 1 if end % 2: end -= 1 res = self.tree[end] if res is None else self.function(res, self.tree[end]) start //= 2 end //= 2 return res"},{"question":"<|Analysis Begin|> # Algorithm/Data Structure * **Algorithm**: Chinese Remainder Theorem (CRT) solution * **Type**: System of equations solving algorithm * **Main Purpose**: Computes the smallest non-negative integer `x` that satisfies a given system of modular equations. # Complexity * **Time Complexity**: * Worst-case time complexity is `O(p1 * p2 * ... * pk)`, where ( p1, p2, ..., pk ) are the elements in `nums`. * For each potential solution `x`, we increment and check if it satisfies all modular equations. This is a brute-force strategy and can be inefficient for large values. * **Space Complexity**: * `O(1)` for the main algorithm, since it only needs constants and a few additional variables irrespective of the input size. # Principles * **Core Operational Steps**: 1. Validate inputs: Check the lists `nums` and `rems` for validity. 2. Ensure each `num` is greater than 1 and that all pairs in `nums` are coprime. 3. Use a brute-force approach to find the smallest `x` that satisfies all equations in the system. # Characteristics & Applications * **Properties**: * Works when `nums` are pairwise coprime. * Finds the smallest non-negative solution to a set of linear congruences. * **Common Use Cases**: * Robotics (for synchronization purposes). * Cryptography (for RSA algorithm, secret sharing schemes). * Calendar calculations. * **Strengths/Limitations**: * **Strengths**: Conceptually straightforward. * **Limitations**: Inefficient for large inputs due to the brute-force search method; assumes `nums` are coprime. # Implementation Challenges * **Edge Cases**: * Non-coprime elements in `nums`. * Elements of `nums` being less than or equal to 1. * Mismatched lengths of `nums` and `rems`. * **Performance Bottlenecks**: * Brute-force strategy can be very slow for large numbers. * **Error Scenarios**: * Throws exceptions when input conditions aren\'t met. * **Optimization Points**: * Replace brute-force solution with a more optimized number-theoretic approach involving multiplicative inverses. <|Analysis End|> <|Question Begin|> # Question Given a list of positive integers `nums` and another list `rems` of equal length, implement the function `solve_chinese_remainder(nums: List[int], rems: List[int]) -> int` to compute the smallest positive integer `x` that satisfies the Chinese Remainder Theorem for the given lists. If the system of modular equations is inconsistent, return -1. **Input**: - `nums`: A list of `k` positive integers greater than 1. - `rems`: A list of `k` integers representing remainders. **Output**: - Returns the smallest non-negative integer `x` that satisfies the system; otherwise, return -1 if no solution exists. **Constraints**: - The system of congruences in list `nums` are pairwise coprime. - The length of `nums` and `rems` will be the same. - All entries in the list `nums` are greater than 1. - The length `k` of `nums` and `rems` will be `1 ≤ k ≤ 10`. **Performance Requirements**: - Aim for a more efficient solution than the provided brute-force approach. __Example__: ```python nums = [3, 5, 7] rems = [2, 3, 2] solve_chinese_remainder(nums, rems) -> 23 # Explanation: # The system of equations is: # x % 3 = 2 # x % 5 = 3 # x % 7 = 2 # The smallest x that satisfies all these equations is 23. ``` **Notes**: - Think about how you can iteratively find a solution without iterating over every possible value and avoid the performance issue in the provided brute-force solution. - Utilize properties of the Chinese Remainder Theorem and number theory principles to optimize your approach.","solution":"from typing import List def solve_chinese_remainder(nums: List[int], rems: List[int]) -> int: def extended_gcd(a, b): Returns a tuple (g, x, y) such that a * x + b * y = g = gcd(a, b) if a == 0: return b, 0, 1 gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y def mod_inverse(a, m): Returns the modular inverse of a under modulo m gcd, x, y = extended_gcd(a, m) if gcd != 1: return None # Modular inverse doesn\'t exist if a and m are not coprime else: return x % m k = len(nums) x = 0 M = 1 for num in nums: M *= num for i in range(k): Mi = M // nums[i] inv = mod_inverse(Mi, nums[i]) if inv is None: return -1 x = (x + rems[i] * Mi * inv) % M return x"},{"question":"# Question: Implement Wiggle Sort **Context:** You are given an unsorted array of integers and need to reorder it in-place in a specific \\"wiggle\\" pattern. The \\"wiggle\\" pattern requires that every adjacent pair of elements satisfies the condition where nums[0] < nums[1] > nums[2] < nums[3] ... and so on. **Task:** Implement the function `wiggle_sort(nums)` that rearranges the elements of the array into the specified pattern. # Input: - `nums`: A list of integers of length `n` (1 <= n <= 10^4) # Output: - The function should modify the list `nums` in place to follow the wiggle pattern without returning anything. # Example: ```python Input: [3, 5, 2, 1, 6, 4] Output: [3, 5, 1, 6, 2, 4] ``` Explanation: The output array should fulfill the condition where every even-indexed element is less than its adjacent elements, and every odd-indexed element is greater than its adjacent elements. # Constraints: - Modify the array in place. - The solution should operate within O(n) time and O(1) additional space. # Notes: - Assume the input array will always have at least one element. - If there are multiple valid wiggle sort permutations, any correct output is acceptable. **Hints:** - Consider the behavior of elements at even and odd indexes separately. - Use in-place swapping to minimize space complexity.","solution":"def wiggle_sort(nums): Rearranges the elements of nums in-place to follow the wiggle pattern. for i in range(len(nums) - 1): if i % 2 == 0 and nums[i] > nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i] elif i % 2 == 1 and nums[i] < nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"# Binary Search Tree with Deletion Operation Implement a Binary Search Tree (BST) in Python to include an additional method for deleting nodes. Your BST class should include the following methods: 1. **Insert** - Insert a value into the BST. 2. **Search** - Search for a value in the BST. 3. **Size** - Return the number of nodes in the BST. 4. **Traversal** - Methods for preorder, inorder, and postorder traversal. 5. **Delete** - Delete a value from the BST. # Deletion Details: * If the node to be deleted has no children, simply remove it. * If the node has one child, replace the node with its child. * If the node has two children, find the next highest value (inorder successor), replace the node\'s value with the successor\'s value, and delete the successor. # Expected Input and Output Format: 1. **insert(data)**: - **Input**: `data` (integer) - **Output**: Boolean `True` if insertion is successful, otherwise `False` (if the value already exists). 2. **search(data)**: - **Input**: `data` (integer) - **Output**: Boolean `True` if the value exists, otherwise `False`. 3. **size()**: - **Input**: None - **Output**: An integer representing the total number of nodes. 4. **traversal(type)**: - **Input**: `type` (string, either \\"preorder\\", \\"inorder\\", \\"postorder\\") - **Output**: A list of node values in specified traversal order. 5. **delete(data)**: - **Input**: `data` (integer) - **Output**: Boolean `True` if deletion is successful, otherwise `False` (if the value is not found). # Constraints: * Data values will be integers within the range [1, 10^6]. * Assume the tree will hold unique values. * Combine both recursive and iterative solutions as needed. # Example: ```python bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) print(bst.size()) # Output: 7 print(bst.search(4)) # Output: True print(bst.search(10)) # Output: False print(bst.traversal(\\"inorder\\")) # Output: [2, 3, 4, 5, 6, 7, 8] bst.delete(7) print(bst.traversal(\\"inorder\\")) # Output: [2, 3, 4, 5, 6, 8] bst.delete(5) print(bst.traversal(\\"inorder\\")) # Output: [2, 3, 4, 6, 8] ```","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None self.node_count = 0 def insert(self, data): if self.search(data): return False self.root = self._insert(self.root, data) self.node_count += 1 return True def _insert(self, node, data): if node is None: return Node(data) if data < node.data: node.left = self._insert(node.left, data) else: node.right = self._insert(node.right, data) return node def search(self, data): return self._search(self.root, data) def _search(self, node, data): if node is None: return False if data == node.data: return True elif data < node.data: return self._search(node.left, data) else: return self._search(node.right, data) def size(self): return self.node_count def traversal(self, type): result = [] if type == \\"preorder\\": self._preorder(self.root, result) elif type == \\"inorder\\": self._inorder(self.root, result) elif type == \\"postorder\\": self._postorder(self.root, result) return result def _preorder(self, node, result): if node: result.append(node.data) self._preorder(node.left, result) self._preorder(node.right, result) def _inorder(self, node, result): if node: self._inorder(node.left, result) result.append(node.data) self._inorder(node.right, result) def _postorder(self, node, result): if node: self._postorder(node.left, result) self._postorder(node.right, result) result.append(node.data) def delete(self, data): if not self.search(data): return False self.root, deleted = self._delete(self.root, data) if deleted: self.node_count -= 1 return deleted def _delete(self, node, data): if node is None: return node, False if data < node.data: node.left, deleted = self._delete(node.left, data) elif data > node.data: node.right, deleted = self._delete(node.right, data) else: if node.left is None: return node.right, True elif node.right is None: return node.left, True else: successor = self._min_value_node(node.right) node.data = successor.data node.right, _ = self._delete(node.right, successor.data) return node, True return node, deleted def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current"},{"question":"# Finding Extra Character in Shuffled String Background: Given two strings `s` and `t`, where `t` is generated by random shuffling string `s` and then adding one more letter at a random position, your task is to find the letter that was added. # Instructions: Write a function `find_difference(s: str, t: str) -> str` that takes two parameters: - `s`: A string of lowercase letters. - `t`: A string resulting from shuffling `s` and adding an additional character. The function should return the character from `t` that is not present in `s`. Input/Output: - **Input**: - `s`: A string consisting of only lowercase letters; length n. - `t`: A string with one additional character compared to `s`; length n+1. - **Output**: - A single character representing the extra character in `t`. Constraints: - The strings will only contain lowercase English letters (`\'a\'` to `\'z\'`). - The strings will be valid with the described properties. Examples: - Example 1: - Input: `s = \\"abcd\\"`, `t = \\"abcde\\"` - Output: `\'e\'` - Example 2: - Input: `s = \\"xyz\\"`, `t = \\"yzxq\\"` - Output: `\'q\'` Requirements: - Ensure the function has a time complexity of O(n). - The space complexity should be O(1). Hints: - Utilize XOR properties to efficiently solve this problem. You can use the following template to start: ```python def find_difference(s, t): ret = 0 for ch in s + t: ret = ret ^ ord(ch) return chr(ret) # Example test cases print(find_difference(\\"abcd\\", \\"abcde\\")) # Output: \'e\' print(find_difference(\\"xyz\\", \\"yzxq\\")) # Output: \'q\' ``` # Good luck!","solution":"def find_difference(s, t): Find the difference between two strings where t is a shuffled version of s with one additional character. ret = 0 for ch in s + t: ret ^= ord(ch) return chr(ret)"},{"question":"Scenario: You are working on a software project that involves processing large datasets represented as linked lists. To ensure data integrity, you need to implement a function to verify that the data in these lists is sorted before further processing. Task: Write a Python function `is_sorted(head)` that checks if a singly linked list is sorted in non-decreasing order. Requirements: - The function should take the head node of a singly linked list as input. - It should return `True` if the list is sorted in non-decreasing order, and `False` otherwise. - An empty list should be considered sorted. - Try to keep the solution efficient in both time and space complexity. Input and Output Format: - **Input**: A singly linked list\'s head node. The nodes are defined as: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` - **Output**: Boolean value (`True` or `False`). Constraints: - Assume the elements of the linked list are integers. Example: ```python # Define nodes node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) # Link nodes node1.next = node2 node2.next = node3 node3.next = node4 # Check if the list is sorted print(is_sorted(node1)) # Output: True node2.val = 5 print(is_sorted(node1)) # Output: False ``` Important Considerations: - Ensure your solution accounts for edge cases like an empty list or a list with a single node. - Maintain a clean and readable code structure with appropriate comments if needed.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head): Checks if a singly linked list is sorted in non-decreasing order. Parameters: head (ListNode): The head node of the singly linked list. Returns: bool: True if the linked list is sorted in non-decreasing order, False otherwise. if not head: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"You are given a social network graph where each node represents a person, and each edge represents a friendship between two people. Your task is to write functions to analyze the network using depth-first search (DFS) and breadth-first search (BFS). Implement the following functions: 1. **find_network_dfs(graph: Dict[int, List[int]], start: int) -> Set[int]**: * Using an iterative DFS approach, find all people in the social network connected to the starting person. * The graph is represented as an adjacency list. 2. **find_network_bfs(graph: Dict[int, List[int]], start: int) -> Set[int]**: * Using a BFS approach, find all people in the social network connected to the starting person. * The graph is represented as an adjacency list. 3. **find_network_dfs_recursive(graph: Dict[int, List[int]], start: int) -> Set[int]**: * Using a recursive DFS approach, find all people in the social network connected to the starting person. * The graph is represented as an adjacency list. # Input and Output Formats - **Input**: - `graph`: A dictionary where the keys are person IDs (integers) and values are lists of friends\' person IDs (integers). - `start`: An integer representing the person ID from which to start the traversal. - **Output**: - A set of integers representing the person IDs in the connected component of the starting person. # Constraints - The graph may contain 1 to 1000 nodes. - Each person ID is unique and represented by a non-negative integer. - The graph may or may not be connected. - There might be cycles present in the graph. # Example ```python graph = { 0: [1, 2], 1: [0, 3], 2: [0], 3: [1] } start = 0 # Output for the functions should be {0, 1, 2, 3} as all these nodes are connected directly or indirectly. ```","solution":"from typing import Dict, List, Set def find_network_dfs(graph: Dict[int, List[int]], start: int) -> Set[int]: Find all people in the social network connected to the starting person using iterative DFS. visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend(n for n in graph[node] if n not in visited) return visited def find_network_bfs(graph: Dict[int, List[int]], start: int) -> Set[int]: Find all people in the social network connected to the starting person using BFS. visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) queue.extend(n for n in graph[node] if n not in visited) return visited def find_network_dfs_recursive(graph: Dict[int, List[int]], start: int, visited=None) -> Set[int]: Find all people in the social network connected to the starting person using recursive DFS. if visited is None: visited = set() visited.add(start) for neighbor in graph[start]: if neighbor not in visited: find_network_dfs_recursive(graph, neighbor, visited) return visited"},{"question":"As part of our studies on bitwise manipulation algorithms, you are required to implement a function that counts the number of \'1\' bits (also known as the Hamming weight) in the binary representation of an unsigned integer using Brian Kernighan\'s Algorithm. # Function Specification * **Function Name**: `count_hamming_weight` * **Input**: An unsigned integer `n`. * **Output**: An integer representing the number of \'1\' bits in the binary representation of `n`. # Constraints * Guaranteed constraints: * ( 0 leq n leq 2^{32} - 1 ) * Performance expectations: * The function should have a time complexity of O(k), where k is the number of \'1\' bits in the binary representation of `n`. * The function should handle the maximum input size efficiently. # Notes * You are expected to handle the input using an iterative approach to avoid issues with deep recursion. * Your implementation should directly manipulate bits using bitwise operations to achieve the desired complexity. # Example ```python Example 1: Input: n = 11 Output: 3 Explanation: The binary representation of 11 is 00000000000000000000000000001011 which contains three \'1\' bits. Example 2: Input: n = 128 Output: 1 Explanation: The binary representation of 128 is 00000000000000000000000010000000 which contains one \'1\' bit. Example 3: Input: n = 0 Output: 0 Explanation: The binary representation of 0 is 00000000000000000000000000000000 which contains zero \'1\' bits. ``` # Implementation Please write your implementation of the function `count_hamming_weight` in the space provided. # Solution Template ```python def count_hamming_weight(n): # Your code here ```","solution":"def count_hamming_weight(n): Returns the number of \'1\' bits in the binary representation of n using Brian Kernighan\'s Algorithm. count = 0 while n: n = n & (n - 1) count += 1 return count"},{"question":"**Background**: You are a network administrator managing a network of interconnected nodes. It is essential to understand the paths between different nodes for efficient data routing and redundancy planning. You need to write functions to find different types of paths in an unweighted graph. # Task: Implement three functions to find different types of paths between two nodes in an unweighted graph, represented as an adjacency list. # Specifications: 1. **Function**: `find_a_path(graph, start, end)`: - **Input**: `graph` (a dictionary where keys are nodes, and values are lists of connected nodes), `start` (starting node), `end` (end node). - **Output**: A list representing a path from `start` to `end`. If no path exists, return `None`. 2. **Function**: `find_all_paths(graph, start, end)`: - **Input**: `graph` (a dictionary), `start` (starting node), `end` (end node). - **Output**: A list of lists, where each list represents a unique path from `start` to `end`. If no paths exist, return an empty list. 3. **Function**: `find_shortest_path(graph, start, end)`: - **Input**: `graph` (a dictionary), `start` (starting node), `end` (end node). - **Output**: A list representing the shortest path from `start` to `end`. If no path exists, return `None`. # Constraints: - All node values are strings. - Graph can be disconnected. - Graph will not contain duplicate edges. # Example Usage: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } # Example Function Calls: print(find_a_path(graph, \'A\', \'F\')) # Example Output: [\'A\', \'C\', \'F\'] print(find_all_paths(graph, \'A\', \'F\')) # Example Output: [[\'A\', \'C\', \'F\'], [\'A\', \'B\', \'E\', \'F\']] print(find_shortest_path(graph, \'A\', \'F\')) # Example Output: [\'A\', \'C\', \'F\'] ``` Make sure to test your functions with various edge cases, including graphs with no connection between nodes, self-loops, and densely connected nodes.","solution":"def find_a_path(graph, start, end, path=None): Returns a path from start node to end node in an unweighted graph. If no path exists, returns None. if path is None: path = [] path.append(start) if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: new_path = find_a_path(graph, node, end, path.copy()) if new_path: return new_path return None def find_all_paths(graph, start, end, path=None): Returns all paths from start node to end node in an unweighted graph. If no paths exist, returns an empty list. if path is None: path = [] path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: new_paths = find_all_paths(graph, node, end, path.copy()) for new_path in new_paths: paths.append(new_path) return paths from collections import deque def find_shortest_path(graph, start, end): Returns the shortest path from start node to end node in an unweighted graph. If no path exists, returns None. if start not in graph or end not in graph: return None queue = deque([(start, [start])]) visited = set() while queue: current, path = queue.popleft() if current in visited: continue visited.add(current) for neighbor in graph[current]: if neighbor == end: return path + [neighbor] if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return None"},{"question":"**Objective**: Implement an in-place algorithm that moves all the zeroes in a list to the end while preserving the order of non-zero elements. **Question**: Write a function named `move_zeroes` that takes a list of integers and moves all zeroes to the end of the list, maintaining the order of non-zero elements. This function must be performed in-place, and no additional list should be used to temporarily hold non-zero elements. Function Signature: ```python def move_zeroes(nums: List[int]) -> None: pass ``` Input: * A list of integers, `nums` (1 ≤ len(nums) ≤ 10^4). Output: * The function should modify the input list in-place and must return `None`. Constraints: * The length of the list `nums` is at least 1 and at most 10,000. * Elements in the list can include any integer values. Performance Requirements: * The algorithm must run in O(n) time complexity. * The algorithm must use O(1) additional space. Example: ```python nums = [0, 1, 0, 3, 12] move_zeroes(nums) print(nums) # Output: [1, 3, 12, 0, 0] nums = [0, 0, 0, 1, 2, 3] move_zeroes(nums) print(nums) # Output: [1, 2, 3, 0, 0, 0] nums = [1, 2, 3, 4] move_zeroes(nums) print(nums) # Output: [1, 2, 3, 4] ``` **Context**: You\'re working on a data processing pipeline where zero values are placeholders and need to be moved to the end of the processing queue, but you cannot afford to use additional memory due to high data volume.","solution":"from typing import List def move_zeroes(nums: List[int]) -> None: Move all zeroes in the list `nums` to the end while preserving the order of non-zero elements. This function modifies `nums` in-place and returns `None`. last_non_zero_found_at = 0 # Move all non-zero elements to the front of the array for i in range(len(nums)): if nums[i] != 0: nums[last_non_zero_found_at] = nums[i] last_non_zero_found_at += 1 # Fill remaining positions in the array with zeroes for i in range(last_non_zero_found_at, len(nums)): nums[i] = 0"},{"question":"Island Counter with Union-Find You are given a 2D grid of size `m x n` initially filled with water (represented by 0s). A sequence of operations is performed to add land (represented by 1s) at specific positions in the grid. Your task is to implement a function that counts the number of islands after each addLand operation. An island is defined as a group of horizontally or vertically adjacent lands. **Function Signature:** ```python def num_islands2(m: int, n: int, positions: List[List[int]]) -> List[int]: pass ``` **Input:** * `m` : int - The number of rows in the grid. * `n` : int - The number of columns in the grid. * `positions` : List[List[int]] - A list of positions where land is added. Each position is a list `[i, j]` where `0 <= i < m` and `0 <= j < n`. **Output:** * List[int] - A list of integers where each integer represents the number of islands after the corresponding addLand operation. **Constraints:** * 1 <= m, n <= 1000 * 1 <= positions.length <= 10000 * positions[i].length == 2 * 0 <= positions[i][0] < m * 0 <= positions[i][1] < n **Example:** ```python m = 3 n = 3 positions = [[0,0], [0,1], [1,2], [2,1]] Output: [1, 1, 2, 3] ``` **Explanation:** 1. After adding land at `[0,0]`, grid becomes: ``` 1 0 0 0 0 0 0 0 0 Number of islands = 1 ``` 2. After adding land at `[0,1]`, grid becomes: ``` 1 1 0 0 0 0 0 0 0 Number of islands = 1 ``` 3. After adding land at `[1,2]`, grid becomes: ``` 1 1 0 0 0 1 0 0 0 Number of islands = 2 ``` 4. After adding land at `[2,1]`, grid becomes: ``` 1 1 0 0 0 1 0 1 0 Number of islands = 3 ``` **Notes:** - Use the Union-Find data structure to efficiently manage the dynamic connectivity check after each addLand operation. - Consider edge cases where operations may try to add land to cells already converted to land. - Implement path compression and union by size for optimal performance during union and find operations.","solution":"from typing import List class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size self.count = 0 # Number of current isolated islands def find(self, i): if self.parent[i] != i: self.parent[i] = self.find(self.parent[i]) # Path compression return self.parent[i] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def setParent(self, i): self.parent[i] = i self.count += 1 def num_islands2(m: int, n: int, positions: List[List[int]]) -> List[int]: if not positions: return [] uf = UnionFind(m * n) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] grid = [[0] * n for _ in range(m)] results = [] for r, c in positions: if grid[r][c] == 1: results.append(uf.count) continue grid[r][c] = 1 index = r * n + c uf.setParent(index) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1: uf.union(index, nr * n + nc) results.append(uf.count) return results"},{"question":"Custom String Manipulations Scenario Imagine you are working on a system that requires several string manipulations. You\'ve already implemented a basic string reversal method, but you\'ve noticed inefficiencies and limitations in your approach. Your task is to write a function that not only reverses the string but also meets certain constraints and optimizations fit for large-scale data. Problem Statement Write a function `custom_reverse` that takes a string `s` as input and returns a new string which is the reversed form of `s`, but optimized for large-scale input. **Input Format**: - A single string `s` (1 ≤ length of s ≤ 10^6) **Output Format**: - A single reversed string. **Constraints**: - The function should handle very large strings efficiently. - The implementation should avoid hitting recursion limits or excessive memory usage. **Performance Requirement**: - Time complexity must be O(n). - Space complexity must be O(n). # Example **Input**: ``` abcdefgh ``` **Output**: ``` hgfedcba ``` # Implementation Details - You must implement an efficient algorithm that avoids using simple recursion due to its limitations with large inputs. - You can use built-in methods and Python-specific syntax, but ensure clarity in your explanation. ```python def custom_reverse(s): # Write your code here pass # Example Usage print(custom_reverse(\\"abcdefgh\\")) # Output: \\"hgfedcba\\" ``` **Note**: Focus on providing the most efficient and clear solution possible. Make sure to test your function with large strings to demonstrate its efficiency.","solution":"def custom_reverse(s): Returns the reversed form of the input string `s`. This implementation is efficient for large-scale input. Parameters: s (str): The string to be reversed. Returns: str: The reversed string. # Python string slicing method, which is optimized for performance return s[::-1] # Example Usage # print(custom_reverse(\\"abcdefgh\\")) # Output: \\"hgfedcba\\""},{"question":"Scenario You have been hired to optimize data storage in a database by ensuring sparse arrays are padded with zeros at the end. This optimization task will improve efficiencies in data processing tasks such as sorting, searching, and analytics. Your task with this specific problem is to write a function that takes an array and moves all zeros to the end, while preserving the order of other elements. Problem Statement Write a function `move_zeros_in_place(array: List[Any]) -> None` that processes the input array in place and moves all the zeros (integer 0) to the end, maintaining the order of non-zero elements. The function must operate in O(n) time complexity and O(1) additional space complexity. # Input * A list of any types, with a length up to 10^6. # Output * None (The function modifies the array in place). # Constraints * Booleans should not be considered zeros. Only integer zeros should be moved. * The function should not use any auxiliary data structures that increase the space complexity beyond O(1). Example ```python arr = [False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"] move_zeros_in_place(arr) print(arr) # Output: [False, 1, 1, 2, 1, 3, \'a\', 0, 0] arr = [0, 0, 0, 0, 1] move_zeros_in_place(arr) print(arr) # Output: [1, 0, 0, 0, 0] arr = [4, 2, 4, 0, 0, 3, 0, 5, 1, 0] move_zeros_in_place(arr) print(arr) # Output: [4, 2, 4, 3, 5, 1, 0, 0, 0, 0] ``` Additional Notes - Ensure that the algorithm counts and differentiates strictly integer zeros. - False and other falsy values should remain in their original places. - Aim for an efficient solution that does not rely on additional list allocations for processing.","solution":"from typing import List, Any def move_zeros_in_place(array: List[Any]) -> None: Moves all the zeros in the array to the end, preserving the order of other elements. The function modifies the array in place without returning any value. Parameters: array (List[Any]): The input list containing elements of any type. Returns: None: The input array is modified in place. last_non_zero_found_at = 0 # Position to place the next non-zero element for i in range(len(array)): if array[i] != 0 or type(array[i]) == bool: # True is not considered an integer zero. array[last_non_zero_found_at] = array[i] last_non_zero_found_at += 1 # Filling the rest of the array with zeros for i in range(last_non_zero_found_at, len(array)): array[i] = 0"},{"question":"Given a list of distinct integers `nums`, write a function `generate_subsets(nums)` to return all possible subsets of the list. The solution set must not contain duplicate subsets. # Function Signature: ```python def generate_subsets(nums: List[int]) -> List[List[int]]: pass ``` # Input: * A list of distinct integers `nums`. # Output: * A list of lists, where each list is a unique subset of the input list. # Constraints: * All elements in `nums` are distinct. * The length of `nums` will be in the range [0, 20]. # Example: Example 1: Input: `nums = [1,2,3]` Output: ```python [ [], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3] ] ``` Example 2: Input: `nums = [0]` Output: ```python [ [], [0] ] ``` # Performance Requirements: * Ensure the solution has a time complexity of O(2^n) and space complexity of O(2^n). # Additional Notes: * The order of subsets in the output does not matter. * Be sure to handle edge cases, such as when `nums` is an empty list. Implement the `generate_subsets(nums)` function by leveraging the principles of backtracking discussed in the analysis.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: Generate all possible subsets of a list of distinct integers. :param nums: List of distinct integers. :return: List of all possible subsets. result = [] def backtrack(start, path): result.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) backtrack(0, []) return result"},{"question":"You are provided with a partial implementation of a matrix multiplication algorithm. The current implementation multiplies two matrices and returns their product. However, the existing code may raise an exception if the matrices are not conformable (i.e., the number of columns in the first matrix does not match the number of rows in the second matrix). The algorithm has a cubic time complexity which might be inefficient for large matrices. # Task Refactor the given matrix multiplication function to include additional features and optimizations: 1. Implement the matrix multiplication using Strassen\'s algorithm to improve the time complexity. 2. Ensure that the function handles non-conformable matrices gracefully by returning `None` instead of raising an exception. 3. Add proper documentation and comments for better readability and maintainability. # Input and Output Formats * **Input**: - Two two-dimensional lists `multiplicand` and `multiplier` representing matrices. - All matrix entries are integers. * **Output**: - A two-dimensional list representing the resulting matrix if the matrices are conformable. - `None` if the matrices are not conformable. # Constraints * Matrices can have up to 128 rows and columns. # Performance Requirements - While solving the problem, aim for an optimized approach in terms of time complexity. # Sample Input ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [2, 0], [1, 2] ] ``` # Sample Output ```python [[4, 4], [10, 8]] ``` # Edge Case Example ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [2] ] Output: None ``` # Notes - Use Strassen\'s algorithm for matrix multiplication. - Ensure your implementation falls back to a traditional method for small matrix sizes where Strassen\'s algorithm may not be efficient.","solution":"def add_matrix(A, B): Adds two matrices element-wise. n = len(A) result = [[A[i][j] + B[i][j] for j in range(n)] for i in range(n)] return result def subtract_matrix(A, B): Subtracts matrix B from matrix A element-wise. n = len(A) result = [[A[i][j] - B[i][j] for j in range(n)] for i in range(n)] return result def strassen_mult(A, B): Performs matrix multiplication using Strassen\'s algorithm. n = len(A) if n == 1: return [[A[0][0] * B[0][0]]] half = n // 2 A11 = [[A[i][j] for j in range(half)] for i in range(half)] A12 = [[A[i][j] for j in range(half, n)] for i in range(half)] A21 = [[A[i+half][j] for j in range(half)] for i in range(half)] A22 = [[A[i+half][j] for j in range(half, n)] for i in range(half)] B11 = [[B[i][j] for j in range(half)] for i in range(half)] B12 = [[B[i][j] for j in range(half, n)] for i in range(half)] B21 = [[B[i+half][j] for j in range(half)] for i in range(half)] B22 = [[B[i+half][j] for j in range(half, n)] for i in range(half)] M1 = strassen_mult(add_matrix(A11, A22), add_matrix(B11, B22)) M2 = strassen_mult(add_matrix(A21, A22), B11) M3 = strassen_mult(A11, subtract_matrix(B12, B22)) M4 = strassen_mult(A22, subtract_matrix(B21, B11)) M5 = strassen_mult(add_matrix(A11, A12), B22) M6 = strassen_mult(subtract_matrix(A21, A11), add_matrix(B11, B12)) M7 = strassen_mult(subtract_matrix(A12, A22), add_matrix(B21, B22)) C11 = add_matrix(subtract_matrix(add_matrix(M1, M4), M5), M7) C12 = add_matrix(M3, M5) C21 = add_matrix(M2, M4) C22 = add_matrix(subtract_matrix(add_matrix(M1, M3), M2), M6) result = [[0] * n for _ in range(n)] for i in range(half): for j in range(half): result[i][j] = C11[i][j] result[i][j+half] = C12[i][j] result[i+half][j] = C21[i][j] result[i+half][j+half] = C22[i][j] return result def multiply_matrices(multiplicand, multiplier): Multiplies two given matrices using Strassen\'s algorithm if they are square matrices and conformable. Falls back to standard multiplication for small matrices. if len(multiplicand[0]) != len(multiplier): return None # Pad the matrices to be powers of two original_size = len(multiplicand) n = 1 while n < original_size: n *= 2 padded_multiplicand = [[0] * n for _ in range(n)] padded_multiplier = [[0] * n for _ in range(n)] for i in range(len(multiplicand)): for j in range(len(multiplicand[0])): padded_multiplicand[i][j] = multiplicand[i][j] for i in range(len(multiplier)): for j in range(len(multiplier[0])): padded_multiplier[i][j] = multiplier[i][j] result = strassen_mult(padded_multiplicand, padded_multiplier) return [[result[i][j] for j in range(original_size)] for i in range(original_size)]"},{"question":"# Hash Table with Separate Chaining Write a class `OptimizedHashTable` that extends the `SeparateChainingHashTable` class, adding functionality to dynamically resize the hash table when the load factor exceeds a threshold. Also, optimize any bottlenecks identified in the initial implementation. Your solution should ensure that the performance of hash table operations remains efficient. Function Signature ```python class OptimizedHashTable(SeparateChainingHashTable): def __init__(self, initial_size=11, load_factor_threshold=0.75): super().__init__(initial_size) self.load_factor_threshold = load_factor_threshold def resize(self): Resize the table to double its current size and redistribute all key-value pairs. This method is called automatically whenever the load factor exceeds the threshold. pass def put(self, key, value): Inserts the key-value pair into the hash table, and resizes it if necessary. pass def del_(self, key): Deletes the key-value pair from the hash table. pass ``` Requirements * **Resize Functionality**: - The hash table should grow in size (preferably double) when the load factor exceeds the specified `load_factor_threshold`. - The load factor is defined as ( text{number of elements} / text{number of buckets} ). - All elements should be redistributed according to the new table size when resizing. * **Chaining Implementation**: - Handle collisions using separate chaining as in the provided class. * **Expected Input and Output**: - Input and output should be consistent with the superclass (key-value operations). Constraints * The load factor threshold should be a floating point number greater than 0 and less than or equal to 1. * The key should be hashable. Handle cases where the key is unhashable with an appropriate exception. * Ensure that the overall time complexity remains efficient after resizing. Sample Usage ```python hash_table = OptimizedHashTable(5, 0.75) hash_table.put(\'a\', 1) hash_table.put(\'b\', 2) hash_table.put(\'c\', 3) # Should trigger resize print(hash_table.get(\'a\')) # Output: 1 print(hash_table.get(\'b\')) # Output: 2 print(hash_table.get(\'c\')) # Output: 3 hash_table.del_(\'b\') print(hash_table.get(\'b\')) # Output: None print(len(hash_table)) # Output: 2 ```","solution":"class SeparateChainingHashTable: def __init__(self, initial_size=11): self.table_size = initial_size self.table = [[] for _ in range(initial_size)] self.item_count = 0 def _hash(self, key): return hash(key) % self.table_size def put(self, key, value): hashed_key = self._hash(key) bucket = self.table[hashed_key] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.item_count += 1 def get(self, key): hashed_key = self._hash(key) bucket = self.table[hashed_key] for k, v in bucket: if k == key: return v return None def del_(self, key): hashed_key = self._hash(key) bucket = self.table[hashed_key] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.item_count -= 1 return True return False def __len__(self): return self.item_count class OptimizedHashTable(SeparateChainingHashTable): def __init__(self, initial_size=11, load_factor_threshold=0.75): super().__init__(initial_size) self.load_factor_threshold = load_factor_threshold def resize(self): old_table = self.table new_size = self.table_size * 2 self.table_size = new_size self.table = [[] for _ in range(new_size)] self.item_count = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) def put(self, key, value): if not hasattr(key, \'__hash__\'): raise TypeError(\\"Unhashable type: \'{}\'\\".format(type(key).__name__)) super().put(key, value) if len(self) / self.table_size > self.load_factor_threshold: self.resize() def del_(self, key): return super().del_(key)"},{"question":"You are given a pattern and a string. Implement a function `pattern_match(pattern, string)` that checks if the string follows the given pattern. Following the pattern means there is a one-to-one relationship between a character in the pattern and a non-empty substring in the string. Your function should follow the signature: ```python def pattern_match(pattern: str, string: str) -> bool: ``` # Input: - `pattern` (string): A string of lowercase letters. - `string` (string): A string of lowercase letters. # Output: - `True` if the string follows the pattern. - `False` otherwise. # Constraints: - Both `pattern` and `string` will contain only lowercase letters. - Pattern length `m` and string length `n` will be such that 1 ≤ m, n ≤ 20. # Requirements: - Efficient handling of the pattern matching. - Consider edge cases like patterns longer than the string or repeating patterns leading to different substrings. - Ensure your solution does not crash for maximum input sizes. # Example Scenarios: 1. **Example 1**: - Input: `pattern = \\"abab\\"`, `str = \\"redblueredblue\\"` - Output: `True` - Explanation: \'a\' can map to \\"red\\" and \'b\' can map to \\"blue\\". 2. **Example 2**: - Input: `pattern = \\"aaaa\\"`, `str = \\"asdasdasdasd\\"` - Output: `True` - Explanation: \'a\' maps to \\"asd\\". 3. **Example 3**: - Input: `pattern = \\"aabb\\"`, `str = \\"xyzabcxzyabc\\"` - Output: `False` - Explanation: No valid mapping exists for this pattern and string. **Note**: Your solution must not use any predefined functions or methods for pattern matching.","solution":"def pattern_match(pattern: str, string: str) -> bool: def is_match(s, p, bijection): if not p: return not s if p[0] in bijection: match = bijection[p[0]] if s.startswith(match): return is_match(s[len(match):], p[1:], bijection) else: return False else: for i in range(1, len(s) - len(p) + 2): match = s[:i] if match not in bijection.values(): bijection[p[0]] = match if is_match(s[i:], p[1:], bijection): return True del bijection[p[0]] return False return is_match(string, pattern, {})"},{"question":"Problem Statement Write a function named `find_special_numbers` that identifies and returns a list of numbers within a given range that exhibit the \\"special number\\" property. A \\"special number\\" is defined as a number whose sum of its digits raised to consecutive powers equals the number itself. For instance: * 89 is a special number because (8^1 + 9^2 = 89). * 135 is a special number because (1^1 + 3^2 + 5^3 = 135). Function Signature ```python def find_special_numbers(start: int, end: int) -> List[int]: pass ``` Input * `start` (int): The starting point of the range (inclusive). * `end` (int): The ending point of the range (inclusive). Output * List[int]: A list of integers within the given range that qualify as special numbers. Constraints * (0 leq start leq end leq 10^5) * Both `start` and `end` are non-negative integers. Example ```python assert find_special_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_special_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert find_special_numbers(100, 150) == [135] ``` Additional Notes * Ensure the function checks all numbers within the given range and returns them in a list if they satisfy the \\"special number\\" condition. * Aim for optimal performance by considering algorithmic improvements.","solution":"from typing import List def is_special_number(num: int) -> bool: digit_str = str(num) total = sum(int(digit_str[i]) ** (i + 1) for i in range(len(digit_str))) return total == num def find_special_numbers(start: int, end: int) -> List[int]: return [num for num in range(start, end + 1) if is_special_number(num)]"},{"question":"Radix Sort Implementation **Scenario**: You work as a software engineer at an e-commerce company that often deals with large datasets, such as a list of transaction amounts that need to be sorted for reporting purposes. To enhance your system\'s performance, you decide to implement an efficient sorting algorithm: Radix Sort. Your task is to write a function that sorts a list of non-negative integers using the Radix Sort algorithm. **Task**: Implement a function `radix_sort(arr, simulation=False)` that sorts a given list of non-negative integers. **Function Signature**: ```python def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Input: * `arr`: A list of non-negative integers (0 <= arr[i] <= 10^9, 0 <= len(arr) <= 10^6). * `simulation`: (Optional) A boolean flag. If `True`, print the state of the list after each digit processing iteration. Default is `False`. # Output: * Returns a list of integers sorted in ascending order. # Constraints: * The input list can be empty. * The size of the input list will not exceed 1 million. * All numbers in the list are non-negative integers within the specified range. # Performance Requirements: * Time complexity should be O(nk) where n is the number of elements and k is the number of digits in the largest number. * Space complexity should be optimized for large datasets. # Test Cases: 1. `radix_sort([])` should return `[]`. 2. `radix_sort([3, 1, 2])` should return `[1, 2, 3]`. 3. `radix_sort([10, 1, 100, 1000])` should return `[1, 10, 100, 1000]`. 4. `radix_sort([123, 456, 789, 1, 0, 999, 888])` should return `[0, 1, 123, 456, 789, 888, 999]`. Additionally, ensure your implementation considers efficiency for large input sizes and handles edge cases appropriately.","solution":"def counting_sort_for_radix(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 for i in range(n): arr[i] = output[i] def radix_sort(arr, simulation=False): if len(arr) == 0: return [] max_val = max(arr) exp = 1 while max_val // exp > 0: if simulation: print(f\\"Sorting by place {exp}: {arr}\\") counting_sort_for_radix(arr, exp) exp *= 10 if simulation: print(f\\"Final sorted array: {arr}\\") return arr"},{"question":"Context You have been hired by a software company to develop a computational library that includes various mathematical functions. The first function they want you to implement is an optimized function to calculate the square root of a number using the Newton-Raphson method, considering various constraints and potential issues. Task Implement the function `optimized_square_root`, which accepts a positive integer `N` and a precision factor `epsilon` for determining the acceptable error margin of the square root approximation. Ensure your function handles different possible edge cases and optimizes performance as much as possible. Specifications - **Function Signature**: `def optimized_square_root(N: int, epsilon: float = 0.001) -> float:` - **Input**: - `N`: A positive integer (1 ≤ N ≤ 10^9). - `epsilon`: A floating-point number indicating the acceptable error margin (default is 0.001). - **Output**: - A floating-point number representing the approximate square root of `N` within the error margin `epsilon`. Constraints - Your implementation should avoid infinite loops and handle edge cases effectively. - The function should work efficiently for large values of `N`. - You cannot use the built-in `math.sqrt` function or similar library functions. Examples 1. Given `N = 5` and `epsilon = 0.001`, the output should be a floating-point number such that `2.235 < x < 2.237` (Actual square root is approximately 2.236). 2. Given `N = 0` and `epsilon = 0.001`, the function should return `0` as the square root of `0` is `0`. Hint Consider starting with an initial guess and iteratively refining it using the average of the guess and the result of dividing the number by the guess. Make sure your implementation avoids excessive iterations.","solution":"def optimized_square_root(N: int, epsilon: float = 0.001) -> float: Computes the square root of a positive integer N using the Newton-Raphson method with a specified precision epsilon. if N < 0: raise ValueError(\\"N must be a positive integer.\\") if N == 0: return 0.0 guess = N / 2.0 while abs(guess * guess - N) >= epsilon: guess = (guess + N / guess) / 2.0 return guess"},{"question":"You are given a list of strings. For each string, you need to find the index of its first non-repeating character. If no such character exists, return `-1`. # Function Signature ```python def first_unique_chars(lst): :type lst: List[str] :rtype: List[int] ``` # Input * `lst`: A list of strings where each string `s` has a length `1 <= len(s) <= 10^5`. # Output * A list of integers where each integer represents the index of the first non-repeating character in the corresponding string from the input list. # Constraints 1. Strings contain only lower-case English letters (\'a\' - \'z\'). 2. List of strings, `lst`, have a length `1 <= len(lst) <= 10^4`. # Example ```python # Example 1: lst = [\\"leetcode\\", \\"loveleetcode\\", \\"aabbcc\\"] # Solution: # \\"leetcode\\" -> 0 (\'l\' is the first unique) # \\"loveleetcode\\" -> 2 (\'v\' is the first unique) # \\"aabbcc\\" -> -1 (no unique character) first_unique_chars(lst) -> [0, 2, -1] ``` # Explanation 1. For \\"leetcode\\", the first unique character is \'l\' which is at index 0. 2. For \\"loveleetcode\\", the first unique character is \'v\' which is at index 2. 3. For \\"aabbcc\\", there is no unique character, so the index is `-1`. # Notes 1. Provide a solution that is optimized for large inputs. 2. Ensure edge cases such as empty strings and strings with all identical characters are handled. 3. Aim for a time complexity of O(n) for each string where `n` is the length of the string.","solution":"def first_unique_chars(lst): For each string in the list, return the index of the first non-repeating character. If no such character exists, return -1. :type lst: List[str] :rtype: List[int] result = [] for s in lst: char_count = {} for char in s: char_count[char] = char_count.get(char, 0) + 1 unique_index = -1 for idx, char in enumerate(s): if char_count[char] == 1: unique_index = idx break result.append(unique_index) return result"},{"question":"# Mode Calculation Challenge Objective: Implement a function that identifies the most frequent elements (mode) in a given array. The function should return all elements that share the highest frequency of occurrence. Scenario: You are a data scientist analyzing survey data where participants selected their favorite technology gadgets. Given the recorded responses as an array of strings, your task is to determine the most frequently chosen gadgets. There might be multiple gadgets sharing the same highest frequency. Requirements: Implement the function `calculate_mode(arr: List[int]) -> List[int]` that takes an array of integers and returns a list of the most frequent integers. Input: - `arr`: A list of integers representing the survey responses (`1 <= len(arr) <= 10^6, -10^6 <= arr[i] <= 10^6`). Output: - A list of integers representing the modes of the input array. If there are multiple modes, include all of them in any order. Constraints: - The input list will contain at least one element. - The elements of the list can be negative, zero, or positive. Performance: - The solution should have a time complexity of O(n). - Space complexity should be minimized while efficiently handling the input size. Example: ```python def calculate_mode(arr): This function should: 1. Calculate the frequency of each element in the array. 2. Identify the frequency count that is the highest. 3. Collect all elements that have this highest frequency. Returns a list of integers representing the modes. pass # Example 1: # Input: [1, 1, 2, 2, 3, 4] # Output: [1, 2] # Example 2: # Input: [4, 5, 6, 7, 7, 6, 6, 5, 5] # Output: [5, 6] # Example 3: # Input: [10] # Output: [10] ``` Notes: The example provided is for clarification purposes. You are expected to implement the `calculate_mode` function to meet the performance and functional requirements specified.","solution":"from typing import List from collections import Counter def calculate_mode(arr: List[int]) -> List[int]: Returns the list of most frequent elements in the input array `arr`. Params: - arr: List[int]: List of integers representing the survey responses Returns: - List[int]: List of integers representing the mode(s) if not arr: return [] # Count the frequency of each element in the array frequency_counter = Counter(arr) # Find the highest frequency highest_frequency = max(frequency_counter.values()) # Collect all elements that have the highest frequency modes = [key for key, count in frequency_counter.items() if count == highest_frequency] return modes"},{"question":"# Question: Given a binary tree, write a function `max_depth(root)` that calculates the maximum depth of the tree using either a recursive or an iterative approach. You should consider the following when implementing your function: Function Signature: ```python def max_depth(root: Optional[TreeNode]) -> int: ``` Input: - `root`: The root node of the binary tree. It could be `None` representing an empty tree. Output: - Returns the maximum depth of the binary tree as an integer. Constraints: - The number of nodes in the tree is in the range `[0, 10^4]`. - The depth of the tree will theoretically not exceed `10^4`. Examples: ```python # Example 1: # Input: root = [3,9,20,None,None,15,7] # Output: 3 # Example 2: # Input: root = [1, None, 2] # Output: 2 # Example 3: # Input: root = [] # Output: 0 ``` Scenario: Consider you are implementing a system to manage a hierarchical structure, such as a company\'s organizational chart. Each position in the company is represented as a node in a binary tree. Your task is to determine the maximum hierarchy depth, which will help in understanding the levels of management and possibly redistributing responsibilities for efficiency. Performance Requirement: - The solution should efficiently handle large binary trees up to the maximum constraint limits.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: Optional[TreeNode]) -> int: if root is None: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"**Objective**: Implement a function that validates and then converts a given file path to its absolute path. **Scenario**: You are tasked with ensuring that all file paths provided to a software application are absolute. This is particularly important for ensuring data is read from or written to the correct location without ambiguity. **Task**: Write a function `validated_full_path(file)` that performs the following steps: 1. Validates the provided path to ensure it exists in the file system. 2. Converts the valid file path to its absolute form. **Specifications**: 1. **Input**: A string representing the file path. 2. **Output**: A string representing the absolute path if the file exists, or a message \\"File does not exist\\" if the validation fails. 3. **Constraints**: * The input string will always be a valid file path format. * Your solution should handle both relative paths and paths containing `~`. **Function Signature**: ```python def validated_full_path(file: str) -> str: pass ``` **Example**: ```python # Example 1 input: \\"~/Documents/example.txt\\" output: \\"/home/user/Documents/example.txt\\" # Assuming the file exists and the user\'s home directory is /home/user # Example 2 input: \\"non_existent_file.txt\\" output: \\"File does not exist\\" # Assuming the file does not exist ``` Implement the function and ensure it correctly validates and resolves the absolute path for the file.","solution":"import os def validated_full_path(file: str) -> str: Validates the provided file path and converts it to its absolute form. Parameters: file (str): The file path to validate and convert. Returns: str: The absolute file path if the file exists, or \\"File does not exist\\" if the validation fails. # Expand ~ to the full path if present expanded_path = os.path.expanduser(file) # Convert relative path to absolute path absolute_path = os.path.abspath(expanded_path) # Check if the path exists if os.path.exists(absolute_path): return absolute_path else: return \\"File does not exist\\""},{"question":"You are required to implement two functions to calculate the factorial of a given non-negative integer `n`. Additionally, if a positive integer `mod` is provided, return the result as `(n! % mod)`. **Function Signatures**: ```python def factorial(n: int, mod: int = None) -> int: pass def factorial_recur(n: int, mod: int = None) -> int: pass ``` **Input**: - `n`: A non-negative integer (0 <= n <= 1000). - `mod` (optional): A positive integer to compute the result as `(n! % mod)`. **Output**: - Returns the factorial of `n`. If `mod` is provided, returns `(n! % mod)`. **Constraints**: - If `mod` is provided, it is guaranteed to be a positive integer. **Performance Requirements**: - Your iterative function should have a time complexity of O(n) and space complexity of O(1) (excluding input and output). - Your recursive function should have a time complexity of O(n) and a space complexity which includes the recursion stack. # Examples: 1. `factorial(5)` should return `120` 2. `factorial(5, 3)` should return `0` because `120 % 3 = 0` 3. `factorial(0)` should return `1` 4. `factorial(10, 1000)` should return `800` # Important Notes: - Ensure both functions handle invalid inputs gracefully by raising a `ValueError` with an appropriate error message. - Account for edge cases like `n = 0` and `mod` being `None`. # Testing: Write comprehensive tests to cover a wide range of inputs, including edge cases.","solution":"def factorial(n: int, mod: int = None) -> int: Returns the factorial of n. If mod is provided, returns (n! % mod). if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if mod is not None and mod <= 0: raise ValueError(\\"mod must be a positive integer\\") result = 1 for i in range(2, n+1): result *= i if mod is not None: result %= mod return result def factorial_recur(n: int, mod: int = None) -> int: Returns the factorial of n using recursion. If mod is provided, returns (n! % mod). if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if mod is not None and mod <= 0: raise ValueError(\\"mod must be a positive integer\\") if n == 0: return 1 res = n * factorial_recur(n - 1, mod) if mod is not None: res %= mod return res"},{"question":"# Queue Intersection Problem Context You are working on a call center software system where multiple call queues are being maintained. Each queue represents a sequence of calls to be handled by an operator. Sometimes, you need to find common calls (intersection) between different queues to prioritize them. Task Implement a function `queue_intersection(queue1, queue2)` that takes two queues (of any size) and returns a list with the intersection of their elements in the order they appear in the first queue. Requirements * Use the `ArrayQueue` or `LinkedListQueue` implementation to create the input queues. * Avoid modifying the original input queues. * The time complexity should not exceed O(n + m), where n and m are the sizes of the two queues. Input * Two queues, `queue1` and `queue2`, with integer elements. Output * A list containing the intersection of elements. Constraints * You can assume the queues do not contain duplicate elements. * The elements in the returned list should preserve the order from `queue1`. Example ``` # Suppose Queue1 contains: 1 -> 2 -> 3 -> 4 # Suppose Queue2 contains: 3 -> 4 -> 5 -> 6 queue_intersection(queue1, queue2) should return [3, 4] ``` Edge Cases * If either queue is empty, the intersection should be an empty list. * If there is no common element, return an empty list. Function Signature ```python def queue_intersection(queue1, queue2): pass ```","solution":"from collections import deque class LinkedListQueue: def __init__(self): self.queue = deque() def enqueue(self, item): self.queue.append(item) def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue.popleft() def is_empty(self): return len(self.queue) == 0 def __iter__(self): return iter(self.queue) def __len__(self): return len(self.queue) def queue_intersection(queue1, queue2): Returns a list with the intersection of elements in the order they appear in queue1 # Use a set to track elements of queue2 for O(1) look-up time. elements_queue2 = set(queue2) # Intersection list to store elements common to both queues, preserving the order from queue1 intersection = [] for item in queue1: if item in elements_queue2: intersection.append(item) return intersection"},{"question":"**Queue-Based Task Scheduler** Imagine a task scheduler that manages tasks using a queue. Tasks arrive at different times and need to be processed in the order they arrive. For this assessment, you will implement a task scheduler using the `Queue ADT` provided above. Specifically, you are required to use an `ArrayQueue` and implement a scheduler that processes the tasks in arrival order. Your scheduler should provide the following functionalities: 1. **add_task(description: str, priority: int)**: Adds a new task to the queue with the given description and priority. 2. **process_task()**: Removes and returns the next task from the queue as a tuple of (description, priority). 3. **next_task()**: Returns the description and priority of the next task to be processed without removing it. Here\'s how you should implement the Scheduler class: ```python class Scheduler: def __init__(self): # Initialize the internal queue with a reasonable capacity self._queue = ArrayQueue(capacity=10) def add_task(self, description: str, priority: int): Adds a new task to the queue. Parameters: description (str): Description of the task. priority (int): Priority level of the task. Returns: None # Add implementation of enqueue task def process_task(self): Processes and removes the next task in the queue. Returns: tuple: (description, priority) of the processed task. Raises: IndexError: If there are no tasks to process. # Add implementation of dequeue task def next_task(self): Retrieves the next task without removing it. Returns: tuple: (description, priority) of the next task. Raises: IndexError: If there are no tasks to retrieve. # Add implementation of peek task # Example usage: scheduler = Scheduler() scheduler.add_task(\\"Write report\\", 2) scheduler.add_task(\\"Email team\\", 1) print(scheduler.next_task()) # Output should be (\\"Write report\\", 2) print(scheduler.process_task()) # Output should be (\\"Write report\\", 2) print(scheduler.process_task()) # Output should be (\\"Email team\\", 1) ``` # Input/Output Formats * **add_task(description: str, priority: int)**: * **input**: A string description of up to 250 characters and an integer priority (e.g., `scheduler.add_task(\\"Write report\\", 2)`). * **output**: This function returns nothing but modifies the queue. * **process_task()**: * **input**: No input parameters. * **output**: Returns a tuple of (description, priority). * **next_task()**: * **input**: No input parameters. * **output**: Returns a tuple of (description, priority). # Constraints/Limitations * The size of each task description should not exceed 250 characters. * Priority values are integers, with lower values indicating higher priority (for contextual purposes, though they have no effect here). Ensure your solution efficiently manages the tasks in the queue and handles edge cases such as trying to process or peek from an empty queue.","solution":"from collections import deque class ArrayQueue: def __init__(self, capacity=10): self._queue = deque(maxlen=capacity) def enqueue(self, item): if self.is_full(): raise OverflowError(\\"Queue is full\\") self._queue.append(item) def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._queue.popleft() def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._queue[0] def is_empty(self): return len(self._queue) == 0 def is_full(self): return len(self._queue) == self._queue.maxlen def __len__(self): return len(self._queue) class Scheduler: def __init__(self): # Initialize the internal queue with a reasonable capacity self._queue = ArrayQueue(capacity=10) def add_task(self, description: str, priority: int): Adds a new task to the queue. Parameters: description (str): Description of the task. priority (int): Priority level of the task. Returns: None if len(description) > 250: raise ValueError(\\"Description exceeds 250 characters\\") self._queue.enqueue((description, priority)) def process_task(self): Processes and removes the next task in the queue. Returns: tuple: (description, priority) of the processed task. Raises: IndexError: If there are no tasks to process. return self._queue.dequeue() def next_task(self): Retrieves the next task without removing it. Returns: tuple: (description, priority) of the next task. Raises: IndexError: If there are no tasks to retrieve. return self._queue.peek() # Example usage: scheduler = Scheduler() scheduler.add_task(\\"Write report\\", 2) scheduler.add_task(\\"Email team\\", 1) print(scheduler.next_task()) # Output should be (\\"Write report\\", 2) print(scheduler.process_task()) # Output should be (\\"Write report\\", 2) print(scheduler.process_task()) # Output should be (\\"Email team\\", 1)"},{"question":"# The Task Implement a count frequency table using a ResizableHashTable, based on provided class definitions. This frequency table will count and update occurrences of words in a list. # Requirements - Write a function `count_word_frequency(words: List[str]) -> dict` that: - Takes a list of strings `words` as input. - Uses the `ResizableHashTable` to store and update the count of each word. - Returns a dictionary representing the frequency table. Constraints: - Words are case-sensitive (\'Word\' != \'word\'). - You can use the `hash` function directly while implementing hash for the keys. # Function Signature - You need to complete the function `count_word_frequency(words: List[str]) -> dict`. # Example ```python # Given input: words = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"] # Expected output: # {\'apple\': 3, \'banana\': 2, \'orange\': 1} ``` # Important Notes - Ensure optimized performance for large inputs. - Handle edge cases like empty input lists. # Implementation Guide 1. Instantiate a `ResizableHashTable`. 2. Traverse the words list to update frequencies. 3. Populate and return the result as a Python dictionary.","solution":"class ResizableHashTable: def __init__(self): self.size = 8 self.table = [None] * self.size self.count = 0 def _hash(self, key): return hash(key) % self.size def _resize(self, new_size): old_table = self.table self.size = new_size self.table = [None] * new_size self.count = 0 for item in old_table: if item: for key, value in item: self.set(key, value) def set(self, key, value): if self.count / self.size > 0.7: self._resize(self.size * 2) index = self._hash(key) if self.table[index] is None: self.table[index] = [] for i, (k, v) in enumerate(self.table[index]): if k == key: self.table[index][i] = (key, value) return self.table[index].append((key, value)) self.count += 1 def get(self, key): index = self._hash(key) if self.table[index] is not None: for k, v in self.table[index]: if k == key: return v return None def count_word_frequency(words): table = ResizableHashTable() for word in words: count = table.get(word) if count is None: table.set(word, 1) else: table.set(word, count + 1) frequency_dict = {} for item in table.table: if item: for key, value in item: frequency_dict[key] = value return frequency_dict"},{"question":"# Remove Duplicates from Linked List You are provided with a singly linked list where each node contains a single character. Your task is to implement a function that removes all duplicate characters from the list. You must implement two functions as follows: 1. **remove_dups** - This function should remove duplicates using additional space but should operate in linear time O(N). 2. **remove_dups_without_set** - This function should remove duplicates without using extra space but will operate in quadratic time O(N^2). # Function Signatures ```python class Node(): def __init__(self, val: str = None): self.val = val self.next = None def remove_dups(head: Node) -> None: pass def remove_dups_without_set(head: Node) -> None: pass ``` # Input * `head`: The head node of a singly linked list where each node contains a single character. # Output Both functions should mutate the linked list in place to remove duplicates. They do not need to return anything. # Constraints * The linked list contains a maximum of `10^5` nodes. * Node values are single uppercase letters `\'A\' - \'Z\'`. # Example ```python # Example Linked List A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Using remove_dups to remove duplicates remove_dups(a1) print_linked_list(a1) # Output should be: A -> B -> C -> D -> F -> G # Rebuilding same linked list for second approach a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Using remove_dups_without_set to remove duplicates remove_dups_without_set(a1) print_linked_list(a1) # Output should be: A -> B -> C -> D -> F -> G ```","solution":"class Node(): def __init__(self, val: str = None): self.val = val self.next = None def remove_dups(head: Node) -> None: Remove duplicates from the linked list using a set for additional space. if head is None: return curr = head seen = set([curr.val]) while curr.next: if curr.next.val in seen: curr.next = curr.next.next else: seen.add(curr.next.val) curr = curr.next def remove_dups_without_set(head: Node) -> None: Remove duplicates from the linked list without using additional space. if head is None: return curr = head while curr: runner = curr while runner.next: if runner.next.val == curr.val: runner.next = runner.next.next else: runner = runner.next curr = curr.next # Helper function to print the linked list for verification def print_linked_list(head: Node) -> str: values = [] while head: values.append(head.val) head = head.next return \\" -> \\".join(values)"},{"question":"# Pigeonhole Sort Implementation and Analysis Background Pigeonhole Sort is an effective sorting algorithm for lists where the number of elements and key values are not very different. By distributing elements into \\"holes\\" and then collecting them in an orderly fashion, it achieves a time complexity of O(n + Range), where Range is the difference between the maximum and minimum values in the array. Task Given an unsorted list of non-negative integers, you are required to implement the Pigeonhole Sort algorithm. Your implementation should follow the principles of pigeonhole sorting, accounting for the range between the minimum and maximum values of the list. Requirements 1. **Function Signature**: ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` 2. **Input**: * A list of non-negative integers, `arr` (0 ≤ arr[i] ≤ 1000). The length of the list will be n (1 ≤ n ≤ 1000). 3. **Output**: * A list of integers sorted in non-decreasing order. 4. **Constraints**: * The input and output lists must contain the same elements. * The implementation must handle edge cases such as single-element lists and lists with the same repeated element. 5. **Performance**: * Aim for O(n + Range) time complexity and O(Range) space complexity. Example ```python assert pigeonhole_sort([8, 3, 2, 7, 4]) == [2, 3, 4, 7, 8] assert pigeonhole_sort([1]) == [1] assert pigeonhole_sort([5, 5, 5, 5]) == [5, 5, 5, 5] ``` Analysis Questions 1. After implementing the pigeonhole sort, analyze its benefits and limitations in practical applications. 2. Discuss potential performance issues when the range of key values is significantly larger than the number of elements.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr min_val = min(arr) max_val = max(arr) range_val = max_val - min_val + 1 # Initialize holes holes = [0] * range_val # Populate the pigeonholes for num in arr: holes[num - min_val] += 1 # Collect sorted elements sorted_arr = [] for i in range(range_val): while holes[i] > 0: sorted_arr.append(i + min_val) holes[i] -= 1 return sorted_arr"},{"question":"You are given a binary tree, and your task is to write a function named `print_leaf_nodes` that prints all the leaf nodes of this tree. A leaf node is a node with no children (both left and right children are null). # Function Signature ```python def print_leaf_nodes(root: Node) -> None: ``` # Input: * `root` - The root node of the binary tree. The tree is described by Node class as follows: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output: * Print the values of all leaf nodes in any order. # Constraints: * The number of nodes in the tree can be at most 10^5. * Node values are distinct integers within the range [-10^6, 10^6]. # Example: Input: ``` Given binary tree: 1 / 2 3 /| | 4 5 6 7 Output: 4 5 6 7 ``` # Implementation Requirement: - Use a function named `print_leaf_nodes`. - Focus on efficient traversal to ensure the solution works within the constraints.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def print_leaf_nodes(root): Prints all leaf nodes of the given binary tree. A leaf node is a node that has no children (both left and right are None). def traverse(node): if node is None: return if node.left is None and node.right is None: print(node.val, end=\' \') traverse(node.left) traverse(node.right) traverse(root) print() # for a newline at the end of output"},{"question":"# Atbash Cipher Encoder **Context**: You are tasked with creating a simple encryption tool based on the historical Atbash cipher technique. This tool will be used to encode short messages. **Task**: Write a function called `atbash_cipher` that takes a single string `message` as input and returns its Atbash cipher encoded equivalent. # Function Signature: ```python def atbash_cipher(message: str) -> str: pass ``` # Input: - `message`: A string containing the message to be encoded. It may include alphabetic characters (both uppercase and lowercase), digits, spaces, and symbols. # Output: - Returns a string which is the Atbash cipher encoded result of the input `message`. # Constraints: - The length of `message` will be between 1 and 1000 characters. - The output must preserve the non-alphabetic characters (e.g., spaces and punctuation) unchanged in their original positions. # Examples: ```python assert atbash_cipher(\\"Hello World!\\") == \\"Svool Dliow!\\" assert atbash_cipher(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash_cipher(\\"123abcXYZ\\") == \\"123zyxCBA\\" assert atbash_cipher(\\"\\") == \\"\\" ``` **Performance Requirements**: - The solution must run in O(n) time complexity, where n is the length of the input string. Here is the main function provided for the task: ```python def atbash_cipher(message: str) -> str: translated = \\"\\" for char in message: if char.isalpha(): if char.isupper(): translated += chr(ord(\'Z\') - (ord(char) - ord(\'A\'))) elif char.islower(): translated += chr(ord(\'z\') - (ord(char) - ord(\'a\'))) else: translated += char return translated ``` Ensure your implementation correctly handles all edge cases and adheres to the specified constraints and requirements.","solution":"def atbash_cipher(message: str) -> str: translated = \\"\\" for char in message: if char.isalpha(): if char.isupper(): translated += chr(ord(\'Z\') - (ord(char) - ord(\'A\'))) elif char.islower(): translated += chr(ord(\'z\') - (ord(char) - ord(\'a\'))) else: translated += char return translated"},{"question":"Implement a function `binary_power` that computes the power of a number using binary exponentiation. The function should be flexible to compute both normal powers and modular powers. # Function Signature ```python def binary_power(base: int, exponent: int, modulus: int = None) -> int: pass ``` # Input - `base (int)`: The base number `a`. (Constraints: (1 leq |a| leq 10^9)) - `exponent (int)`: The exponent `n`. (Constraints: (0 leq n leq 10^9)) - `modulus (int)`: An optional parameter. If provided, compute `(base ** exponent) % modulus`. (Constraints: (1 leq modulus leq 10^9)) # Output - Return the result of ( text{base}^ text{exponent} ) if modulus not provided, otherwise return ( (text{base}^ text{exponent}) % text{modulus} ). # Constraints - Do not use Python\'s built-in `pow` function or the exponentiation operator `**`. # Examples ```python assert binary_power(2, 10) == 1024 assert binary_power(2, 10, 1000) == 24 assert binary_power(3, 0) == 1 assert binary_power(2, 31) == 2147483648 assert binary_power(2, 31, 1000) == 648 ``` # Notes - Consider edge cases such as `exponent = 0` which should always return 1 regardless of the base. - Optimize the implementation to avoid large intermediate results when using the modulus. # Solution Requirements - The solution should be efficient with a maximum time complexity of O(log(n)).","solution":"def binary_power(base: int, exponent: int, modulus: int = None) -> int: Function to compute the power of a number using binary exponentiation. If modulus is provided, it computes (base ** exponent) % modulus. Parameters: base (int): Base number a exponent (int): Exponent n modulus (int, optional): Optional modulus m Returns: int: Result of the power function if base == 0 and exponent == 0: raise ValueError(\\"0^0 is an indeterminate form\\") result = 1 current_base = base current_exponent = exponent while current_exponent > 0: if current_exponent % 2 == 1: # If the exponent is odd if modulus: result = (result * current_base) % modulus else: result *= current_base current_base = (current_base * current_base) % modulus if modulus else current_base * current_base current_exponent //= 2 return result"},{"question":"# Question: Bitwise Operation Challenge Objective Write implementations for functions that manipulate bits within an integer. Specifically, write functions to: 1. Get the value of a bit at a particular index. 2. Set a bit to 1 at a particular index. 3. Clear a bit (set to 0) at a particular index. 4. Update a bit at a particular index to a specified value (0 or 1). Requirements - **get_bit(num, i)**: - **Input**: An integer `num` and an index `i`. - **Output**: Return the bit (either 0 or 1) at index `i` of `num`. - **set_bit(num, i)**: - **Input**: An integer `num` and an index `i`. - **Output**: Return the integer after setting the bit at index `i` to 1. - **clear_bit(num, i)**: - **Input**: An integer `num` and an index `i`. - **Output**: Return the integer after clearing the bit at index `i` (setting it to 0). - **update_bit(num, i, bit)**: - **Input**: An integer `num`, an index `i`, and a target value `bit` which can be 0 or 1. - **Output**: Return the integer after setting the bit at index `i` to the value of `bit`. Constraints - `num` will be a 32-bit signed integer. - `0 <= i < 32`. - `bit` will be either 0 or 1. Example ```python num = 29 # Binary: 11101 i = 1 print(get_bit(num, i)) # Output: 0 print(set_bit(num, i)) # Output: 31 (Binary: 11111) print(clear_bit(num, i)) # Output: 29 (Binary: 11101) print(update_bit(num, i, 1)) # Output: 31 (Binary: 11111) print(update_bit(num, i, 0)) # Output: 29 (Binary: 11101) ``` Task Implement and test these functions in Python. ```python def get_bit(num, i): # Implementation here def set_bit(num, i): # Implementation here def clear_bit(num, i): # Implementation here def update_bit(num, i, bit): # Implementation here ``` Your implementation should handle the given constraints and edge cases effectively.","solution":"def get_bit(num, i): Returns the value of the bit at index i. return (num >> i) & 1 def set_bit(num, i): Sets the bit at index i to 1. return num | (1 << i) def clear_bit(num, i): Clears the bit at index i (sets it to 0). return num & ~(1 << i) def update_bit(num, i, bit): Updates the bit at index i to the specified value (bit). return (num & ~(1 << i)) | (bit << i)"},{"question":"You are tasked with implementing a function `remove_duplicate_characters` that receives a string as input and returns a new string formed by removing any duplicate characters, ensuring that only the first occurrence of each character is retained and the order of characters is preserved. Function Signature ```python def remove_duplicate_characters(s: str) -> str: ``` Input * A single string `s` of length `n` (0 ≤ n ≤ 100,000). Output * A string containing only the first occurrence of each character in `s`, preserving their original order. # Requirements * The time complexity of your solution should be O(n). * You should use only O(n) additional space. # Constraints * The input string will only contain ASCII characters (English letters, digits, punctuation, and whitespace). # Example Usage ```python assert remove_duplicate_characters(\\"programming\\") == \\"progamin\\" assert remove_duplicate_characters(\\"google\\") == \\"gole\\" assert remove_duplicate_characters(\\"aabbcc\\") == \\"abc\\" assert remove_duplicate_characters(\\"a\\") == \\"a\\" assert remove_duplicate_characters(\\"\\") == \\"\\" ``` # Additional Notes 1. Consider creating auxiliary data structures like sets and lists to track characters and construct the result without compromising performance. 2. Ensure to handle cases where the input string is empty or has all identical characters effectively.","solution":"def remove_duplicate_characters(s: str) -> str: Removes duplicate characters from the input string, keeping only the first occurrence of each character and preserving their order. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Question: Sorting Three Unique Elements Problem Description You are given an array containing `n` objects, each colored either red, white, or blue. You need to sort the array so that objects of the same color are adjacent, with colors in the order red, white, and blue. Here, we will use the integers 0, 1, and 2 to represent red, white, and blue respectively. Requirements - **Function Signature**: ```python def sort_colors(nums): ``` - The function should sort the array in place without using any library\'s sort function. - The function should handle arrays of any length with elements being one of the three colors. Input Format - `nums`: A list of integers representing colors (0 for red, 1 for white, and 2 for blue). Output Format - The function does not need to return anything. The sorting should be done in place. Constraints - The array should contain only 0s, 1s, and 2s. - The function should operate with O(n) time complexity and O(1) space complexity. Example ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] ``` Explanation: - The array `[2, 0, 2, 1, 1, 0]` after calling `sort_colors` should be sorted into `[0, 0, 1, 1, 2, 2]` as per the required order of red (0), white (1), and blue (2).","solution":"def sort_colors(nums): Sort an array with 0s, 1s, and 2s in place so that all 0s come first, followed by 1s, then all 2s. Parameters: nums (list of int): List of integers where 0 represents red, 1 represents white, and 2 represents blue. Returns: None # Initialize pointers for next position of 0 and 2 low, mid, high = 0, 0, len(nums) - 1 # Use a three-way partitioning to sort in place while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[mid], nums[high] = nums[high], nums[mid] high -= 1"},{"question":"You are tasked with implementing a data structure that uses bitwise operations to store and manipulate the states of individual bits in a compact manner. Your task is to complete the implementation of a `BitSet` class that allows operations on individual bits. # Class Definition Implement a class `BitSet` with the following methods: 1. **`__init__(self)`**: - Initializes the BitSet with an integer value of 0. 2. **`get_bit(self, i: int) -> bool`**: - Returns the boolean value of the bit at index (i). 3. **`set_bit(self, i: int) -> None`**: - Sets the bit at index (i) to 1. 4. **`clear_bit(self, i: int) -> None`**: - Clears the bit at index (i). 5. **`update_bit(self, i: int, bit: int) -> None`**: - Sets the bit at index (i) to `bit` (where `bit` is either 0 or 1). # Constraints - (i) is a non-negative integer. - (i) should be within the bit-width range of the integer in the implementation language (consider Python\'s capability with arbitrary-precision integers). # Example Usage ```python bit_set = BitSet() bit_set.set_bit(2) print(bit_set.get_bit(2)) # Output: True bit_set.clear_bit(2) print(bit_set.get_bit(2)) # Output: False bit_set.update_bit(2, 1) print(bit_set.get_bit(2)) # Output: True bit_set.update_bit(2, 0) print(bit_set.get_bit(2)) # Output: False ``` # Notes - Ensure that all bitwise operations operate within valid bit indices. - Handle any invalid operations gracefully, either by ignoring them or raising appropriate errors.","solution":"class BitSet: def __init__(self): self.bits = 0 def get_bit(self, i: int) -> bool: Returns the boolean value of the bit at index i. if i < 0: raise ValueError(\\"Bit index must be non-negative\\") return (self.bits & (1 << i)) != 0 def set_bit(self, i: int) -> None: Sets the bit at index i to 1. if i < 0: raise ValueError(\\"Bit index must be non-negative\\") self.bits |= (1 << i) def clear_bit(self, i: int) -> None: Clears the bit at index i. if i < 0: raise ValueError(\\"Bit index must be non-negative\\") self.bits &= ~(1 << i) def update_bit(self, i: int, bit: int) -> None: Sets the bit at index i to \'bit\', where bit is either 0 or 1. if i < 0: raise ValueError(\\"Bit index must be non-negative\\") if bit not in [0, 1]: raise ValueError(\\"Bit value must be 0 or 1\\") self.bits = (self.bits & ~(1 << i)) | (bit << i)"},{"question":"# Context You are tasked with developing a scheduling system for a sequence of workshops. Each workshop has certain prerequisites that must be completed before it can be started. Your goal is to determine a valid order in which the workshops can be completed. # Task Write a Python function `find_workshop_order` that takes a dictionary representing the prerequisites of each workshop and returns a list representing a valid order to complete the workshops. If no valid order exists due to a cycle in the dependencies, raise a `ValueError` with the message \\"cycle\\". # Input * `workshop_prerequisites`: A dictionary where keys are workshop IDs (strings) and values are lists of workshop IDs that must be completed before the key workshop. # Output * A list of workshop IDs in a valid order of completion. # Constraints * The graph is always a Directed Graph. * There can be up to 10<sup>4</sup> workshops. * Each workshop can have up to 10<sup>4</sup> prerequisites. # Example ```python workshop_prerequisites = { \\"w1\\": [\\"w2\\", \\"w3\\"], \\"w2\\": [\\"w4\\"], \\"w3\\": [\\"w4\\"], \\"w4\\": [] } find_workshop_order(workshop_prerequisites) # Returns: [\'w4\', \'w2\', \'w3\', \'w1\'] or other valid order ``` # Notes 1. If there are multiple valid orders, any of them are acceptable. 2. Consider edge cases such as a graph with no nodes or a graph with a single node.","solution":"def find_workshop_order(workshop_prerequisites): Returns the order in which workshops can be completed based on prerequisites. If no valid order exists due to a cycle, raises a ValueError. from collections import defaultdict, deque # Create an adjacency list and a dictionary to keep track of in-degrees adj_list = defaultdict(list) in_degree = {workshop: 0 for workshop in workshop_prerequisites} # Build the graph and calculate in-degrees of each node for workshop, prerequisites in workshop_prerequisites.items(): for prereq in prerequisites: adj_list[prereq].append(workshop) in_degree[workshop] += 1 # Find all nodes with no incoming edges zero_in_degree_queue = deque([wk for wk, deg in in_degree.items() if deg == 0]) sorted_order = [] while zero_in_degree_queue: workshop = zero_in_degree_queue.popleft() sorted_order.append(workshop) for neighbor in adj_list[workshop]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If sorted_order does not contain all workshops, there is a cycle if len(sorted_order) == len(workshop_prerequisites): return sorted_order else: raise ValueError(\\"cycle\\")"},{"question":"**Problem: Counting Set Bits Using Brian Kernighan\'s Algorithm** Write a function to count the number of 1 bits (also known as Hamming weight) in the binary representation of a given unsigned integer using Brian Kernighan\'s Algorithm. Implement both recursive and iterative approaches as separate functions within one program. Ensure the solution handles edge cases and large integers appropriately. # Function Signature: ```python def count_ones_recur(n: int) -> int: def count_ones_iter(n: int) -> int: ``` # Input Format: * A single unsigned integer `n`. # Output Format: * An integer representing the number of 1 bits in the binary representation of `n`. # Constraints: * 0 <= n <= 2^32 - 1 (consider 32-bit unsigned integer) # Examples: ```python print(count_ones_recur(11)) # Output: 3 (binary 00000000000000000000000000001011) print(count_ones_iter(11)) # Output: 3 print(count_ones_recur(128)) # Output: 1 (binary 00000000000000000000000010000000) print(count_ones_iter(128)) # Output: 1 print(count_ones_recur(0)) # Output: 0 (binary 00000000000000000000000000000000) print(count_ones_iter(0)) # Output: 0 ``` # Special Notes: * For the recursive approach, ensure to consider the depth of recursion and the potential for stack overflow in case of a high number of 1 bits. * The iterative approach must maintain a constant space complexity. # Performance Requirement: * Solution should run efficiently even for the upper limit of the input integer.","solution":"def count_ones_recur(n: int) -> int: Recursively counts the number of 1 bits in the binary representation of n using Brian Kernighan\'s Algorithm. if n == 0: return 0 return 1 + count_ones_recur(n & (n - 1)) def count_ones_iter(n: int) -> int: Iteratively counts the number of 1 bits in the binary representation of n using Brian Kernighan\'s Algorithm. count = 0 while n: n &= n - 1 count += 1 return count"},{"question":"Find the Missing Number in a Sequence You are given an array of unique integers where each integer is within the range [0, n]. The array is guaranteed to be a permutation of the range [0, n-1] except for one number that is missing. Your task is to identify the missing number and return it. If all numbers are present, return the next number in the sequence. Input: * An array of unique integers `nums` of length `n`, where the integers are within the range [0, n]. * `1 ≤ n ≤ 10^5` Output: * An integer denoting the missing number from the sequence. Function Signature: ```python def find_missing_number(nums: List[int]) -> int: pass ``` Examples: 1. `Input: nums = [4, 1, 3, 0, 6, 5, 2]` `Output: 7` 2. `Input: nums = [3, 0, 1]` `Output: 2` 3. `Input: nums = [0, 1, 2, 3, 4, 5]` `Output: 6` Constraints: * Your solution should work efficiently with an array of length up to `10^5`. Notes: * Consider various edge cases such as: * The smallest possible array. * An array where the numbers are sequential without any missing element. Implement the function using both the XOR-based method and the Sum-based method described in the provided analysis.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Find the missing number in the sequence. n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"# Two Sum Variant Given a sorted array of integers, your task is to find the indices of two elements such that their sum equals a given target. The indices returned should be one-based. You must write a function `find_pair_with_sum(numbers, target)` that implements this functionality using the two-pointer technique for optimal performance. Input: * `numbers`: A list of integers sorted in ascending order. * `target`: An integer representing the target sum. Output: * A list of two integers representing the one-based indices of the two numbers that add up to `target`. Constraints: * Each input list will have exactly one solution. * `numbers` will have at least two integers and up to 10,000 integers. * The integers are not necessarily unique. # Example: Example 1 * Input: `numbers = [2, 7, 11, 15]`, `target = 9`. * Output: `[1, 2]`. Constraints: * Lists will always be in ascending order and the problem guarantees a valid result. Write the function `find_pair_with_sum(numbers, target)`: ```python def find_pair_with_sum(numbers, target): left = 0 right = len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 return None # If no pair is found (though based on constraints, this won\'t happen) ``` In your implementation, ensure efficient traversal and correct handling of all edge cases.","solution":"def find_pair_with_sum(numbers, target): Finds the indices of two elements in the sorted list \'numbers\' such that their sum equals \'target\'. Indices are returned as one-based. left = 0 right = len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] # converting to one-based index elif current_sum < target: left += 1 else: right -= 1 return None # If no pair is found (though based on constraints, this won\'t happen)"},{"question":"You are given a matrix in which every row and every column is sorted in ascending order. Write a function to search for a given integer key in this matrix. If the key is found, return a tuple with the row and column indices (both zero-based). If the key is not found, return (-1, -1). # Function Signature ```python def search_in_sorted_matrix(matrix: List[List[int]], key: int) -> Tuple[int, int]: pass ``` # Input - `matrix` is a list of lists of integers, where each list represents a row of the matrix. It is guaranteed that each row and each column is sorted in ascending order. - `key` is an integer to search for in the matrix. # Output - A tuple `(row_index, col_index)` if the key is found, with `row_index` and `col_index` being the zero-based indices of the matrix. - `(-1, -1)` if the key is not found in the matrix. # Constraints - The number of rows (m) and columns (n) are such that (1 leq m, n leq 10^3). - The matrix and key will be such that an integer search can be performed within the range of typical Python integers. # Performance Requirements - Your algorithm should have a time complexity of O(m + n). # Example ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 assert search_in_sorted_matrix(matrix, key) == (1, 2) key = 10 assert search_in_sorted_matrix(matrix, key) == (-1, -1) ``` Write an efficient implementation of this function.","solution":"from typing import List, Tuple def search_in_sorted_matrix(matrix: List[List[int]], key: int) -> Tuple[int, int]: if not matrix or not matrix[0]: return (-1, -1) rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return (row, col) elif matrix[row][col] < key: row += 1 else: col -= 1 return (-1, -1)"},{"question":"# Question You are tasked with implementing a merge sort algorithm, but with certain optimizations and special requirements. This will test your understanding of the algorithm’s nuances and your ability to make improvements. Requirements: 1. Implement the merge sort algorithm in a Python function `optimized_merge_sort`. 2. Optimize the algorithm to handle arrays with a large number of elements by reducing recursive depth. 3. Introduce a threshold `k` below which the algorithm uses insertion sort for sorting small arrays to improve overall performance. 4. The merge sort implementation should maintain stability and operate on the input list in-place. Function Signature: ```python def optimized_merge_sort(arr: List[int], k: int) -> List[int]: pass ``` Input: - `arr`: A list of integers to be sorted. (1 <= len(arr) <= 10^5) - `k`: An integer threshold for switching to insertion sort. (1 <= k <= 100) Output: - Returns the sorted list. Example: ```python arr = [38, 27, 43, 3, 9, 82, 10] k = 10 print(optimized_merge_sort(arr, k)) # Output: [3, 9, 10, 27, 38, 43, 82] ``` Constraints: - Your implementation should run efficiently for large arrays (up to 10^5 elements). - Ensure that the algorithm remains stable. # Additional Information: 1. **Insertion Sort** has a time complexity of O(n^2) but performs well for small arrays due to low overhead. 2. **Space Usage**: Minimize extra space by simultaneously using and reusing the input array. 3. **Handling Edges**: Your code should gracefully handle edge cases such as empty arrays or arrays with a single element. Implement your function in Python and ensure it passes all constraints and edge cases.","solution":"from typing import List def insertion_sort(arr: List[int], left: int, right: int) -> None: for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def merge(arr: List[int], left: int, mid: int, right: int) -> None: n1 = mid - left + 1 n2 = right - mid left_arr = arr[left:mid + 1] right_arr = arr[mid + 1:right + 1] i = j = 0 k = left while i < n1 and j < n2: if left_arr[i] <= right_arr[j]: arr[k] = left_arr[i] i += 1 else: arr[k] = right_arr[j] j += 1 k += 1 while i < n1: arr[k] = left_arr[i] i += 1 k += 1 while j < n2: arr[k] = right_arr[j] j += 1 k += 1 def optimized_merge_sort_helper(arr: List[int], left: int, right: int, k: int) -> None: if left < right: if right - left + 1 <= k: insertion_sort(arr, left, right) else: mid = (left + right) // 2 optimized_merge_sort_helper(arr, left, mid, k) optimized_merge_sort_helper(arr, mid + 1, right, k) merge(arr, left, mid, right) def optimized_merge_sort(arr: List[int], k: int) -> List[int]: if not arr: return [] optimized_merge_sort_helper(arr, 0, len(arr) - 1, k) return arr"},{"question":"# Question: Phone Number Letter Combinations You are given a string containing digits from \'2\' to \'9\', inclusive. Each digit maps to a set of letters as in traditional telephone keypads. Your task is to write a function `letter_combinations(digits: str) -> List[str]` that returns all possible letter combinations that the number could represent. Mapping: ``` 2: \\"abc\\" 3: \\"def\\" 4: \\"ghi\\" 5: \\"jkl\\" 6: \\"mno\\" 7: \\"pqrs\\" 8: \\"tuv\\" 9: \\"wxyz\\" ``` Input: - A single string `digits` of length N (0 <= N <= 10) representing the digits from which translations have to be generated. Output: - A list of strings representing all possible letter combinations that can be formed from the input digits. - If the input string is empty, the output should be an empty list. Constraints: 1. The input string can be of any length between 0 and 10. 2. The input string will only contain digits between 2 and 9. Example: ```python assert letter_combinations(\\"23\\") == [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] assert letter_combinations(\\"\\") == [] assert letter_combinations(\\"7\\") == [\\"p\\", \\"q\\", \\"r\\", \\"s\\"] ``` Requirements: - The function should efficiently compute the combinations following a backtracking approach. - Analyze and optimize memory and computational limits wherever possible.","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: if not digits: return [] phone_mapping = { \'2\': \\"abc\\", \'3\': \\"def\\", \'4\': \\"ghi\\", \'5\': \\"jkl\\", \'6\': \\"mno\\", \'7\': \\"pqrs\\", \'8\': \\"tuv\\", \'9\': \\"wxyz\\" } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = phone_mapping[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"Context You have access to an infinite sequence of positive integers written in a row (`123456789101112131415...`) formed by concatenating sequential numbers. Given a position `n`, your task is to determine the nth digit in this sequence. Problem Statement Implement a Python function `find_nth_digit(n: int) -> int` that returns the nth digit of the sequence described above. Function Signature ```python def find_nth_digit(n: int) -> int: pass ``` Input - An integer `n` (1 ≤ n ≤ 2 * 10^9), representing the position in the sequence. Output - A single integer, the digit at the nth position in the sequence. Constraints - The function should be optimized for both time and space efficiency. - Handle all edge cases, including very small (n=1) and very large values of n (up to 2 * 10^9). Example ```python print(find_nth_digit(3)) # Output: 3 print(find_nth_digit(11)) # Output: 0 print(find_nth_digit(15)) # Output: 2 print(find_nth_digit(2889)) # Output: 9 print(find_nth_digit(190)) # Output: 1 ``` # Notes - Ensure your solution does not attempt to generate or store large sequences. - Think about the properties of number lengths and how digits transition from one segment to another.","solution":"def find_nth_digit(n: int) -> int: length = 1 count = 9 start = 1 # Find the length of the number which includes the nth digit while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Identify the exact number containing the nth digit start += (n - 1) // length # Identify the exact digit in the number s = str(start) return int(s[(n - 1) % length])"},{"question":"# Decoding Encoded Messages In a cipher, each letter from \'A\' to \'Z\' is encoded to the numbers \'1\' to \'26\'. For example, \'A\' is encoded as \'1\', \'B\' as \'2\', and so on. Given an encoded message containing only digits, you need to determine the total number of ways to decode it. Write a function `count_decodings(enc_mes)` that takes a string `enc_mes` representing the encoded message and returns the number of ways to decode it. Function Signature ```python def count_decodings(enc_mes: str) -> int: pass ``` Input * A string `enc_mes` containing only digits (\'0\'-\'9\'). * `1 <= len(enc_mes) <= 100` Output * An integer representing the number of ways to decode the given message. Constraints * The input string may contain invalid sequences that need to be handled. * The sequences \'0\', \'30\', \'40\', ... are invalid, but \'10\' and \'20\' are valid. Examples 1. For `enc_mes = \\"12\\"`, the output should be `2`. (\\"AB\\" or \\"L\\") 2. For `enc_mes = \\"226\\"`, the output should be `3`. (\\"BZ\\", \\"VF\\", or \\"BBF\\") 3. For `enc_mes = \\"0\\"`, the output should be `0`. (Invalid sequence) Explanation You are to decode the message using a DP approach. Use initial base case checks: starting with \'0\' should immediately signal no valid decodings. Traverse the input, maintaining count states for single character and two-character decodings, ensuring usage of valid pairs. Optimize in terms of space complexity to fit within a constant amount for large strings.","solution":"def count_decodings(enc_mes: str) -> int: if not enc_mes or enc_mes.startswith(\'0\'): return 0 n = len(enc_mes) dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 # Initial base cases for i in range(2, n + 1): single_digit = int(enc_mes[i-1]) double_digit = int(enc_mes[i-2:i]) # Check if single digit decode is valid if 1 <= single_digit <= 9: dp[i] += dp[i - 1] # Check if two digit decode is valid if 10 <= double_digit <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"You are tasked with implementing a basic Binary Search Tree (BST). Your implementation should include the following operations: 1. **Insert**: To add a new value to the BST. 2. **Delete**: To remove a value from the BST. 3. **Search**: To find if a value is present in the BST. 4. **In-Order Traversal**: To retrieve the values in sorted order. You are provided with a `TreeNode` class, where each node contains an integer value, and pointers to the left and right child nodes. Implement a `BinarySearchTree` class which should support the above operations and conform to the properties of a BST. # Input and Output Formats Insert * **Input**: `insert(val: int)` * **Output**: None. The tree should be updated with the added value. Delete * **Input**: `delete(val: int)` * **Output**: None. The tree should be updated without the removed value. If the value does not exist, do nothing. Search * **Input**: `search(val: int) -> bool` * **Output**: Return `True` if the value is found in the BST, `False` otherwise. In-Order Traversal * **Input**: `in_order_traversal() -> List[int]` * **Output**: Return a list of integers representing the values of the BST in sorted order. # Constraints * All values are integers within the range of -10^4 to 10^4. * There can be up to 10^4 operations in total. * Your solution should be efficient with respect to both time and space complexity. # Example ```python # Creating new BST instance bst = BinarySearchTree() # Insert operations bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) # Search operation print(bst.search(4)) # Output: True print(bst.search(10)) # Output: False # In-order traversal print(bst.in_order_traversal()) # Output: [2, 3, 4, 5, 6, 7, 8] # Delete operation bst.delete(3) print(bst.in_order_traversal()) # Output: [2, 4, 5, 6, 7, 8] ``` Write your implementation of the `BinarySearchTree` class below: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int): # Your code here def delete(self, val: int): # Your code here def search(self, val: int) -> bool: # Your code here def in_order_traversal(self) -> List[int]: # Your code here ```","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int): if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left: self._insert(node.left, val) else: node.left = TreeNode(val) else: if node.right: self._insert(node.right, val) else: node.right = TreeNode(val) def delete(self, val: int): self.root = self._delete(self.root, val) def _delete(self, node, val): if not node: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if not node.left: return node.right elif not node.right: return node.left temp = self._min_value_node(node.right) node.val = temp.val node.right = self._delete(node.right, temp.val) return node def _min_value_node(self, node): current = node while current.left: current = current.left return current def search(self, val: int) -> bool: return self._search(self.root, val) def _search(self, node, val): if not node: return False if val == node.val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val) def in_order_traversal(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if node: self._in_order_traversal(node.left, result) result.append(node.val) self._in_order_traversal(node.right, result)"},{"question":"# Coding Challenge: Implement In-Place Merge Sort Scenario Merge Sort is a fundamental sorting algorithm frequently used due to its predictable performance and stability. However, its memory overhead can be a drawback in some memory-constrained applications. Your task is to implement an in-place version of Merge Sort, which sorts an array without using additional arrays for merging. Problem Statement Given an array of integers, implement a function `in_place_merge_sort(arr)` that sorts the array in ascending order using an in-place merge sort algorithm. The function should modify the input array directly without utilizing extra space for arrays during the merging process. Function Signature ```python def in_place_merge_sort(arr: List[int]) -> None: pass ``` Input - `arr`: List of integers (0 <= len(arr) <= 10^5, elements are in the range -10^9 to 10^9) Output - The function should modify the input list `arr` and sort it in place. Do not return anything. Constraints - Sorting must be done in place with O(1) extra space for merging. - The implementation should be efficient and handle large datasets within reasonable time limits. Example ```python arr = [38, 27, 43, 3, 9, 82, 10] in_place_merge_sort(arr) print(arr) # Output: [3, 9, 10, 27, 38, 43, 82] arr = [5, 2, 9, 1, 5, 6] in_place_merge_sort(arr) print(arr) # Output: [1, 2, 5, 5, 6, 9] ``` Notes - Focus on minimizing additional memory usage. - Ensure that the function handles edge cases, such as an already sorted array, duplicate elements, single-element arrays, and empty arrays.","solution":"def in_place_merge_sort(arr): In-place merge sort algorithm to sort the array in ascending order. def merge(arr, start, mid, end): start2 = mid + 1 if arr[mid] <= arr[start2]: return while start <= mid and start2 <= end: if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 while index != start: arr[index] = arr[index - 1] index -= 1 arr[start] = value start += 1 mid += 1 start2 += 1 def merge_sort(arr, l, r): if l < r: m = l + (r - l) // 2 merge_sort(arr, l, m) merge_sort(arr, m + 1, r) merge(arr, l, m, r) merge_sort(arr, 0, len(arr) - 1)"},{"question":"# Prompt You are given a singly linked list represented by its head node and an integer k. Your task is to implement a function that returns the k-th to last element of the list. Write the code for this function optimally. # Function Signature ```python def kth_to_last_optimal(head: Node, k: int) -> Node: ``` # Input - `head`: The head node of a singly linked list. - `k`: An integer representing which element to retrieve from the end of the list. # Output - The function should return the k-th to last node of the linked list. If no such element exists, return `None`. # Constraints - You may assume the linked list has at least one element (head is not None). # Examples Example 1 **Input**: - List: A -> B -> C -> D -> E - k: 2 **Output**: - D Example 2 **Input**: - List: X -> Y -> Z - k: 5 **Output**: - None # Explanation In Example 1, starting from the end of the list, the 2nd element is \'D\'. In Example 2, `k` is greater than the length of the list, so the function returns None. # Notes - You should handle edge cases like the list length being shorter than k. - Focus on optimizing the solution for both time and space complexity. # Testing A preliminary function for testing your code is provided below. Use a similar structure to validate your solution. ```python class Node: def __init__(self, val: int = None): self.val = val self.next = None def print_linked_list(head): node = head while node: print(node.val, end=\\" -> \\" if node.next else \\"\\") node = node.next print() def test(): # Creating the linked list A -> B -> C -> D -> E a = Node(\\"A\\") b = Node(\\"B\\") c = Node(\\"C\\") d = Node(\\"D\\") e = Node(\\"E\\") a.next = b b.next = c c.next = d d.next = e print_linked_list(a) assert kth_to_last_optimal(a, 2).val == \\"D\\" assert kth_to_last_optimal(a, 5).val == \\"A\\" assert kth_to_last_optimal(a, 6) is None if __name__ == \\"__main__\\": test() ```","solution":"class Node: def __init__(self, val: int = None): self.val = val self.next = None def kth_to_last_optimal(head: Node, k: int) -> Node: Returns the k-th to last element of the singly linked list. Args: head (Node): The head node of the linked list. k (int): The position from the end of the list to retrieve. Returns: Node: The k-th to last node or None if not existent. # Two-pointer approach fast = slow = head for _ in range(k): if fast is None: return None fast = fast.next while fast: slow = slow.next fast = fast.next return slow"},{"question":"# Coding Exercise: Segment Tree with Custom Function You are tasked with implementing a Segment Tree data structure to efficiently handle range queries and point updates on an array. The structure will support any commutative function to combine segments. Specifications 1. **Class Signature**: ```python class SegmentTree: def __init__(self, arr: list, function: callable): # Initialization code (build the segment tree) def update(self, index: int, value): # Updates the value at the specified index def query(self, left: int, right: int): # Returns the result of applying the function to the range [left, right] ``` 2. **Input**: - **Initialization**: An array `arr` of any data type and a function `function` that takes two arguments of the same type as elements of `arr` and returns a value of the same type. - **Update Method**: Takes an integer `index` and a new value `value` to update at that index. - **Query Method**: Takes two integers `left` and `right` representing the inclusive range and returns the result of applying the function to the range. 3. **Output**: - **Update Method**: No return value, updates the tree. - **Query Method**: Value computed using the provided function over the specified range. 4. **Constraints**: - 1 <= length of `arr` <= 10^5. - `index`, `left`, `right` are valid indices within `arr`. Example Usage ```python # Example 1 - Query using max function mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 # Example 2 - Query using sum function mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 ``` Implement the `SegmentTree` class following the described requirements. Ensure your code handles edge cases such as single-element arrays and non-overlapping queries correctly.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.function = function self.tree = [None] * (2 * self.n) # Build the tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index, value): # Update the value at the leaf node pos = index + self.n self.tree[pos] = value # Update the internal nodes pos //= 2 while pos >= 1: self.tree[pos] = self.function(self.tree[2 * pos], self.tree[2 * pos + 1]) pos //= 2 def query(self, left, right): # Adjust range to be [left, right) left += self.n right += self.n + 1 result = None while left < right: if left % 2 == 1: result = self.tree[left] if result is None else self.function(result, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 result = self.tree[right] if result is None else self.function(result, self.tree[right]) left //= 2 right //= 2 return result"},{"question":"Given an unsorted array `arr` of integers, write a function `findLIS(arr: List[int]) -> int` that calculates the length of the longest increasing subsequence (LIS) in the array. **Definition**: A subsequence is a sequence derived by deleting some or no elements of the array without disturbing the order of the remaining elements. **Input**: - `arr`: List of integers (1 ≤ len(arr) ≤ 10^4, -10^5 ≤ arr[i] ≤ 10^5) **Output**: - The length of the longest increasing subsequence. # Requirements - Your function should exhibit O(nlog(n)) time complexity. - Avoid using built-in sorting and library functions unless optimizing custom data structures such as segment trees. # Constraints - The function should handle large inputs efficiently. - You must consider various edge cases, including but not limited to empty arrays, arrays with one element, and arrays with all elements the same. # Example 1. Example 1: ``` Input: [10, 9, 2, 5, 3, 7, 101, 18] Output: 4 Explanation: The longest increasing subsequence is [2, 3, 7, 101] which has length 4. ``` 2. Example 2: ``` Input: [0, 1, 0, 3, 2, 3] Output: 4 Explanation: The longest increasing subsequence is [0, 1, 2, 3] which has length 4. ``` 3. Example 3: ``` Input: [7, 7, 7, 7, 7, 7, 7] Output: 1 Explanation: The longest increasing subsequence is [7] which has length 1 since all elements are the same. ``` # Notes - **Edge Cases**: Properly handle edge cases where the input list is empty or contains only one element. - **Optimization**: Ensure to consider improvement points such as efficient usage of segment trees or binary index trees for better performance. - **Error Handling**: Your implementation should be robust enough to avoid errors related to index bounds and input constraints. # Submission Submit your function `findLIS` implementation along with a brief explanation highlighting the key mechanisms, edge cases handled, and possible improvements.","solution":"from typing import List import bisect def findLIS(arr: List[int]) -> int: Function to find the length of the longest increasing subsequence (LIS). Uses binary search for optimal O(n log n) time complexity. if not arr: return 0 # `lis` will maintain the current longest increasing subsequence lis = [] for num in arr: # Find the insertion point for `num` in `lis` using binary search pos = bisect.bisect_left(lis, num) # If `num` is larger than any element in `lis` if pos == len(lis): lis.append(num) # If there is a larger or equal element in lis, replace it with `num` else: lis[pos] = num return len(lis)"},{"question":"# Problem Description You are tasked with implementing the Cocktail Shaker Sort algorithm. This algorithm is a variation of Bubble Sort that sorts an array bidirectionally. A single pass involves traversing the array from left to right, swapping adjacent elements if they are in the wrong order, and then traversing back from right to left, ensuring the smallest elements \\"bubble\\" to the start of the list and the largest to the end. Your job is to create a function: ```python def cocktail_shaker_sort(arr: list) -> list: pass ``` # Input * A list of integers `arr` where (1 leq text{len(arr)} leq 10^5) and (-10^9 leq arr[i] leq 10^9). # Output * The function should return a list of integers sorted in non-decreasing order. # Constraints * Attempt to minimize the number of swaps and comparisons. * Ensure the solution handles edge cases effectively including empty arrays, arrays with one element, and arrays that are already sorted. # Examples 1. **Input**: [3, 2, 9, 7, 4] **Output**: [2, 3, 4, 7, 9] 2. **Input**: [1, 1, 1, 1] **Output**: [1, 1, 1, 1] 3. **Input**: [] **Output**: [] 4. **Input**: [10, 9, 8, 7, 6] **Output**: [6, 7, 8, 9, 10] # Explanation 1. The array [3, 2, 9, 7, 4] undergoes multiple passes: * Pass 1: [2, 3, 7, 4, 9] * Pass 2: [2, 3, 4, 7, 9] (from right to left) * The array is sorted after the second pass. 2. The array [1, 1, 1, 1] remains unchanged as all elements are equal. 3. An empty array has nothing to sort. 4. The array [10, 9, 8, 7, 6] is sorted into [6, 7, 8, 9, 10] after multiple passes.","solution":"def cocktail_shaker_sort(arr: list) -> list: Perform an in-place Cocktail Shaker Sort on the given list. if not arr: return arr n = len(arr) swapped = True start = 0 end = n - 1 while swapped: # Reset the swapped flag swapped = False # Traverse the array from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If no elements were swapped, the array is sorted if not swapped: break # Reset the swapped flag so that it can be used in the next stage swapped = False # Move the end point back by one end -= 1 # Traverse the array from right to left for i in range(end - 1, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # Increase the starting point start += 1 return arr"},{"question":"# **Primal Instruction** Alice is implementing a reliable system for testing large prime numbers required in cryptographic applications. She plans to use the Rabin-Miller Primality Test. Your task is to modify and expand the provided Rabin-Miller test function to ensure it handles a wider range of inputs effectively and integrates a deterministic step for enhanced testing speed. You must: 1. Implement a deterministic test for small primes ( (n < 10^6) ) before invoking the Rabin-Miller procedure. 2. Optimize the Rabin-Miller test for very large ( n ) by allowing users to configure the number of witnesses ( k ). # **Function Signature** ```python def is_prime_extended(n: int, k: int = 5) -> bool: Determines if n is a probable prime using an optimized Rabin-Miller Primality Test Parameters: - n: int : The number to be tested for primality (0 <= n <= 10^18) - k: int : The number of witnesses to use in the Rabin-Miller test. Default is 5. Returns: - bool: True if n is probably prime, False if n is composite. pass ``` # **Constraints** 1. ( 0 <= n <= 10^{18} ) 2. ( 1 <= k <= 20 ) 3. For ( n < 10^6 ), use a deterministic approach based on a pre-sieved array of small primes. 4. Beyond the deterministic step, apply the Rabin-Miller Primality Test. # **Example** ```python assert is_prime_extended(2) == True assert is_prime_extended(3) == True assert is_prime_extended(15) == False assert is_prime_extended(982451653, 7) == True ``` # **Performance Requirements** Your solution should perform the primality test efficiently even for very large ( n ) while adhering to the probabilistic nature of the Rabin-Miller test.","solution":"import random def is_prime_extended(n: int, k: int = 5) -> bool: Determines if n is a probable prime using an optimized Rabin-Miller Primality Test Parameters: - n: int : The number to be tested for primality (0 <= n <= 10^18) - k: int : The number of witnesses to use in the Rabin-Miller test. Default is 5. Returns: - bool: True if n is probably prime, False if n is composite. # Deterministic check for small primes SMALL_PRIMES = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997 ] if n <= 1: return False if n in SMALL_PRIMES: return True if any(n % p == 0 for p in SMALL_PRIMES): return False # Rabin-Miller Primality Test def miller_rabin(d, n): a = random.randint(2, n - 2) # Pick a random number in [2, n-2] x = pow(a, d, n) if x == 1 or x == n - 1: return True while d != n - 1: x = (x * x) % n d *= 2 if x == n - 1: return True return False # Write n as d*2^r + 1 with d odd (by factoring out powers of 2 from n-1) d = n - 1 while d % 2 == 0: d //= 2 # Witness loop for _ in range(k): if not miller_rabin(d, n): return False return True"},{"question":"You are working on a text processing tool and need to implement the core functionality for searching specific patterns in large texts efficiently. Your task is to implement a function that takes two strings `pattern` and `text` and returns the index of the first occurrence of `pattern` in `text` using the Rabin-Karp algorithm. If the pattern does not exist in the text, the function should return `-1`. Implement the function `rabin_karp_search(pattern: str, text: str) -> int`. # Input and Output Specifications Input: - `pattern`: A non-empty string representing the substring to search for. - `text`: A potentially large string in which to search for the pattern. Output: - An integer representing the starting index of the first occurrence of the `pattern` in the `text`. - Return `-1` if the pattern is not found in the text. # Constraints: 1. Both `pattern` and `text` consist of lowercase English letters only. 2. The length of `pattern` will be less than or equal to the length of `text`. 3. Length of `text` will be <= 10^6. # Performance Requirements: - The algorithm should efficiently handle the given constraints and ensure optimal use of time and space. # Example: ```python assert rabin_karp_search(\\"abc\\", \\"abxabcabcaby\\") == 3 assert rabin_karp_search(\\"aab\\", \\"abxabcabcaby\\") == -1 ``` # Implementation Notes - Implement a `RollingHash` class to maintain and update the rolling hash values effectively. - Handle edge cases as discussed in the analysis such as empty patterns or texts. - Ensure to optimize the hash function to reduce hash collisions. **Function Signature:** ```python def rabin_karp_search(pattern: str, text: str) -> int: # Implementation here ```","solution":"def rabin_karp_search(pattern: str, text: str) -> int: Implements Rabin-Karp algorithm to find the first occurrence of `pattern` in `text`. Returns -1 if the pattern is not found. if not pattern or not text or len(pattern) > len(text): return -1 base = 256 prime = 101 # A prime number for modulo operation m = len(pattern) n = len(text) pattern_hash = 0 text_hash = 0 h = 1 for i in range(m - 1): h = (h * base) % prime for i in range(m): pattern_hash = (base * pattern_hash + ord(pattern[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime for i in range(n - m + 1): if pattern_hash == text_hash: if text[i:i + m] == pattern: return i if i < n - m: text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % prime if text_hash < 0: text_hash += prime return -1"},{"question":"# Linear Search in Various Contexts You are tasked with creating a function that executes a linear search to determine the position of a query element within various types of data collections. This function should correctly handle both lists of numbers and lists of strings. It\'s crucial to account for the following constraints and performance requirements: # Function Signature ```python def generalized_linear_search(data, target): pass ``` # Input - `data`: a list, which can either contain integers or strings. The list is not pre-sorted. - `target`: an element, which will either be an integer or a string, depending on the content of `data`. # Output - Returns an integer, representing the index of the `target` element within the `data` list. - If the `target` is not present in the list, return -1. # Constraints - The list may contain up to 10^6 elements. - The function should operate within O(n) time complexity. # Example | data | target | Expected Output | |-------------------------|---------|-----------------| | [1, 3, 5, 7, 9] | 5 | 2 | | [1, 3, 5, 7, 9] | 2 | -1 | | [\\"cat\\", \\"dog\\", \\"bird\\"] | \\"dog\\" | 1 | | [\\"cat\\", \\"dog\\", \\"bird\\"] | \\"lion\\" | -1 | # Scenario You are creating a search function for a basic library system. The function allows users to search for either book IDs or titles to find their respective positions in the system. Given the size and nature of the data (which varies from a few entries to several hundreds of thousands), your function should be efficient and perform well within the linear constraints. **Task**: Implement the function `generalized_linear_search` to meet the above requirements. # Additional Notes - You should handle cases where the `data` list is empty. - Ensure the function execution is efficient enough for the upper limit of input constraints.","solution":"def generalized_linear_search(data, target): Perform a linear search to find the target in the data list. Parameters: data (list): A list of integers or strings. target (int/str): The target element to find in the list. Returns: int: The index of the target if found, otherwise -1. for index, element in enumerate(data): if element == target: return index return -1"},{"question":"Stack Permutation Validation **Context**: The stack is a versatile data structure. One of its interesting applications is validating sequences of stack operations. Suppose you have two sequences of integers - the first sequence represents the order in which elements are pushed onto the stack, and the second sequence represents the order in which elements are popped from the stack. Your task is to determine if the given pop sequence is valid for the given push sequence using stack operations. **Problem Statement**: Implement a function `is_valid_stack_permutation(push_sequence, pop_sequence)` that determines if `pop_sequence` is a valid stack permutation of `push_sequence`. **Input**: - `push_sequence`: A list of integers representing the push order. - `pop_sequence`: A list of integers representing the pop order. **Output**: - Return `True` if `pop_sequence` is a valid stack permutation of `push_sequence`. - Return `False` otherwise. **Constraints**: - Both `push_sequence` and `pop_sequence` contain the same distinct integers and have the same length. - The lengths of the sequences are between 0 and 1000. **Function Signature**: ```python def is_valid_stack_permutation(push_sequence: List[int], pop_sequence: List[int]) -> bool: pass ``` # Examples Example 1: Input: ```python push_sequence = [1, 2, 3, 4, 5] pop_sequence = [4, 5, 3, 2, 1] ``` Output: ```python True ``` Explanation: This pop sequence is valid. You can push elements in the order 1, 2, 3, then pop 3, push 4, pop 4, push 5, pop 5, then pop 2 and 1. Example 2: Input: ```python push_sequence = [1, 2, 3, 4, 5] pop_sequence = [4, 3, 5, 1, 2] ``` Output: ```python False ``` Explanation: This pop sequence is not valid. You cannot pop 4 and 3 without popping 2 and 1 first. # Additional Info: - **Performance Requirements**: The solution should run in linear time relative to the input size. - **Edge Cases**: Consider cases where the input sequences are already in sorted order or reversed order, or are empty. Good luck!","solution":"def is_valid_stack_permutation(push_sequence, pop_sequence): stack = [] pop_index = 0 for num in push_sequence: stack.append(num) while stack and stack[-1] == pop_sequence[pop_index]: stack.pop() pop_index += 1 return not stack"},{"question":"You are given a set of distinct integers, `nums`, and you need to return all possible k-sized subsets. In mathematics, this is also known as the k-combinations or k-element subsets of a set. # Objective: Implement a function `k_subsets(nums: List[int], k: int) -> Set[Tuple[int]]` that returns all possible subsets of size `k` from the list `nums`. The subsets should be returned as a set of tuples. # Function Signature: ```python def k_subsets(nums: List[int], k: int) -> Set[Tuple[int]]: ``` # Input: - `nums`: A list of distinct integers. Constraints: 1 <= len(nums) <= 16, -100 <= nums[i] <= 100 - `k`: An integer representing the size of the subsets to generate. Constraints: 0 <= k <= len(nums) # Output: - A set of tuples, where each tuple represents a unique k-sized subset of `nums`. # Constraints: - The function must handle k = 0 by returning a set containing an empty tuple. - The function must handle the case where k equals the length of `nums` by returning a set containing a single tuple that is identical to `nums`. - The function must handle the case where `nums` is empty appropriately. # Example: ```python assert k_subsets([1, 2, 3], 2) == {(1, 2), (1, 3), (2, 3)} assert k_subsets([1, 2, 3, 4], 3) == {(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)} assert k_subsets([1, 2, 3], 0) == {()} assert k_subsets([], 0) == {()} assert k_subsets([1, 2, 3], 3) == {(1, 2, 3)} ``` # Performance Requirements: - The solution must run efficiently for n up to 16 due to the exponential number of possible subsets. # Note: Consider using combinations from itertools or replicate the functionality using bit manipulation or backtracking to solve this problem. Avoid generating all subsets if possible for optimization.","solution":"from itertools import combinations from typing import List, Set, Tuple def k_subsets(nums: List[int], k: int) -> Set[Tuple[int]]: Returns all possible k-sized subsets from the list nums. return set(combinations(nums, k))"},{"question":"# Question: Implement a Binary Tree Serializer and Deserializer You are tasked with implementing a binary tree serializer and deserializer. This involves converting a binary tree to a serialized string representation and constructing a binary tree from a serialized string. Function Signature - Implement the following two functions: - `def serialize(root: TreeNode) -> str` - `def deserialize(data: str) -> TreeNode` Input and Output Formats 1. **serialize** - **Input**: A TreeNode representing the root of a binary tree. - **Output**: A string representing the serialized binary tree. 2. **deserialize** - **Input**: A string representing a serialized binary tree. - **Output**: A TreeNode representing the root of the deserialized binary tree. Constraints and Limitations - The nodes\' values are integers. - The tree will contain at most 10^4 nodes. - The serialized string should correctly represent null nodes to be able to reconstruct the entire tree. Example Consider the binary tree below: ``` 1 / 2 3 / 4 5 ``` - **Serialization**: The function `serialize` should return \\"1 2 # # 3 4 # # 5 # #\\". - **Deserialization**: The function `deserialize` should convert the string \\"1 2 # # 3 4 # # 5 # #\\" back into the original binary tree structure. Scenario Context Imagine you are developing a feature for a data visualization tool that needs to save and load binary tree structures. Efficient and lossless serialization and deserialization help users save their progress and share tree structures accurately. Implement the `serialize` and `deserialize` functions to meet these requirements.","solution":"from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def serialize(root: TreeNode) -> str: Encodes a tree to a single string. def helper(node): if node: return f\\"{node.val} \\" + helper(node.left) + helper(node.right) else: return \\"# \\" return helper(root).strip() def deserialize(data: str) -> TreeNode: Decodes your encoded data to tree. def helper(vals): val = next(vals) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = helper(vals) node.right = helper(vals) return node vals = iter(data.split()) return helper(vals)"},{"question":"# Binary Search Variants You need to implement two variations of the Binary Search algorithm to solve a specific problem. The problem involves finding the first and last occurrence of a target value in a sorted array of integers. Implement the functions as described below: Function 1: Find First Occurrence Implement the function `find_first(array, target)` that returns the index of the first occurrence of the target in the array. If the target is not found, return -1. Function 2: Find Last Occurrence Implement the function `find_last(array, target)` that returns the index of the last occurrence of the target in the array. If the target is not found, return -1. # Input and Output Formats 1. **Input**: * `array`: A sorted list of integers (ascending order). * `target`: An integer value to be searched within the array. 2. **Output**: * `find_first` and `find_last`: Both functions return an integer value representing the index of the first or last occurrence respectively. If the target is not found, return -1. # Constraints 1. The elements of the array and the target value are integers within the range [-10^9, 10^9]. 2. The array size is within the range [0, 10^5]. 3. The input array is sorted in ascending order. # Example 1. If the input is `array = [1, 2, 2, 2, 3, 4, 5]` and `target = 2`, * `find_first(array, 2)` should return `1` (first occurrence at index 1). * `find_last(array, 2)` should return `3` (last occurrence at index 3). 2. If the input is `array = [1, 2, 3, 4, 5]` and `target = 6`, * Both `find_first(array, 6)` and `find_last(array, 6)` should return `-1`. Ensure that your implementations are efficient and handle edge cases correctly. # Constraints and Performance 1. Aim for O(log(n)) time complexity. 2. Ensure that your implementation handles large arrays efficiently without unnecessary computations.","solution":"def find_first(array, target): Returns the index of the first occurrence of the target in the array. If the target is not found, returns -1. low, high = 0, len(array) - 1 result = -1 while low <= high: mid = (low + high) // 2 if array[mid] == target: result = mid high = mid - 1 # Move to the left part to find the first occurrence elif array[mid] < target: low = mid + 1 else: high = mid - 1 return result def find_last(array, target): Returns the index of the last occurrence of the target in the array. If the target is not found, returns -1. low, high = 0, len(array) - 1 result = -1 while low <= high: mid = (low + high) // 2 if array[mid] == target: result = mid low = mid + 1 # Move to the right part to find the last occurrence elif array[mid] < target: low = mid + 1 else: high = mid - 1 return result"},{"question":"# Context: In your task as a software developer, you\'ve been assigned to work on a module where you need to handle numerical values and often determine the number of digits they contain. To streamline this, you must write a function that calculates the digit count efficiently. # Task: Write a function `count_digits(n: int) -> int` that takes an integer `n` and returns the number of digits in its decimal representation. Your function should operate in constant time. # Function Signature: ```python def count_digits(n: int) -> int: # Your code here pass ``` # Input: * An integer `n` (can be positive, negative, or zero). The integer will be in the range of typical 32-bit signed integers (from -2,147,483,648 to 2,147,483,647). # Output: * An integer representing the number of digits in the given number `n`. # Constraints: * Perform the task in constant time O(1). * Handle both positive and negative integers correctly. * Ensure accurate results for the number 0, which should return a digit count of 1. # Examples: * `count_digits(12345)` should return `5`. * `count_digits(-9876)` should return `4`. * `count_digits(0)` should return `1`. # Edge Cases to Consider: * Zero as input. * Negative numbers. * Single-digit positive and negative numbers. # Performance Requirements: The function must execute in constant time, which means the execution time does not vary with the size of the input `n`.","solution":"def count_digits(n: int) -> int: Returns the number of digits in the decimal representation of the integer n. # Using string conversion: Convert number to string, take absolute value to ignore negative sign, count characters return len(str(abs(n)))"},{"question":"Pancake Sort Coding Challenge # Objective Implement the Pancake Sort algorithm to sort an array of integers in ascending order using the principles described. # Function Signature ```python def pancake_sort(arr: List[int]) -> List[int]: ``` # Input * `arr` (List[int]): A list of integers to be sorted. The list can be empty or contain up to (10^3) elements. # Output * Returns a sorted list `arr` in ascending order. # Constraints 1. The input list `arr` may contain negative numbers and duplicates. 2. The elements of `arr` are in the range of (-10^6) to (10^6). # Performance Requirements * Aim for an in-place sort with time complexity of O(N^2). # Examples ```python # Example 1 input_list = [3, 2, 4, 1] output_list = pancake_sort(input_list) print(output_list) # Expected: [1, 2, 3, 4] # Example 2 input_list = [23, 10, 20, 11, 12, 6, 7] output_list = pancake_sort(input_list) print(output_list) # Expected: [6, 7, 10, 11, 12, 20, 23] # Example 3 input_list = [] output_list = pancake_sort(input_list) print(output_list) # Expected: [] # Example 4 input_list = [1, 2, 3, 3, 2, 1] output_list = pancake_sort(input_list) print(output_list) # Expected: [1, 1, 2, 2, 3, 3] ``` # Explanation - Implement your solution based on the Pancake Sort algorithm discussed. - Consider edge cases like empty arrays and arrays with duplicate values. - Your implementation should handle all provided constraints and conduct sorting in-place.","solution":"from typing import List def pancake_sort(arr: List[int]) -> List[int]: def flip(sublist, k): sublist[:k] = reversed(sublist[:k]) for size in range(len(arr), 1, -1): # Find the max element in arr[0:size] max_index = arr.index(max(arr[:size])) if max_index != size - 1: # Flip the max element to the front if it\'s not already at the front flip(arr, max_index + 1) # Flip it to its correct position flip(arr, size) return arr"},{"question":"You are required to implement a modified version of the Radix Sort algorithm that can handle both positive and negative integers. The implementation should still leverage the stable sorting property of Radix Sort. Additionally, ensure that the implementation maintains the time complexity of O(nk + n). # Detailed Requirements 1. **Function Signature**: ```python def modified_radix_sort(arr: List[int]) -> List[int]: ``` 2. **Input**: * A list of integers `arr` which may contain both positive and negative integers. * The list may be empty. 3. **Output**: * A new list of integers from `arr`, sorted in non-decreasing order. 4. **Constraints**: * The integers can be any value from -10^6 to 10^6. * The input list length can be up to 10^5. 5. **Examples**: ```python assert modified_radix_sort([170, 45, 75, -90, 802, 24, 2, 66]) == [-90, 2, 24, 45, 66, 75, 170, 802] assert modified_radix_sort([1, -1, 3, 0, -2, 2]) == [-2, -1, 0, 1, 2, 3] assert modified_radix_sort([]) == [] assert modified_radix_sort([-5, -10, -3, -1]) == [-10, -5, -3, -1] ``` # Performance Requirement Your solution should be efficient and run in O(nk + n) time complexity, where `n` is the number of elements and `k` is the number of digits in the largest (absolute) number. # Guidelines * Use the standard Radix Sort algorithm as a base and modify it to handle negative integers. * You may need to preprocess the list to separate and handle negative and positive numbers independently, and then merge the results. * Ensure your code is clean, well-documented, and handles all edge cases.","solution":"def modified_radix_sort(arr): from itertools import chain def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = abs(arr[i]) // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n-1, -1, -1): index = abs(arr[i]) // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 for i in range(n): arr[i] = output[i] def radix_sort(arr): max1 = max(arr, key=abs) exp = 1 while abs(max1) // exp > 0: counting_sort(arr, exp) exp *= 10 if not arr: return [] positive_numbers = [num for num in arr if num >= 0] negative_numbers = [-num for num in arr if num < 0] if positive_numbers: radix_sort(positive_numbers) if negative_numbers: radix_sort(negative_numbers) negative_numbers = [-num for num in reversed(negative_numbers)] return list(chain(negative_numbers, positive_numbers))"},{"question":"You are working on a networking module that needs to handle integer and byte conversions in both big-endian and little-endian formats. To extend the current functionality, you need to implement a new function that accommodates endian conversion directly within the range of integers. This involves considering various edge cases and ensuring efficient performance. Your task is to implement a function `endian_conversion(src_bytes, src_endian, dst_endian)` that converts a given byte sequence from one endianness to another. Function Signature ```python def endian_conversion(src_bytes: bytes, src_endian: str, dst_endian: str) -> bytes: pass ``` # Input * `src_bytes` (bytes): A sequence of bytes representing the integer to be converted. * `src_endian` (str): A string representing the source endianness. It can be either `\\"big\\"` or `\\"little\\"`. * `dst_endian` (str): A string representing the destination endianness. It can be either `\\"big\\"` or `\\"little\\"`. # Output * Return a sequence of bytes that represents the integer converted into the specified destination endianness. # Constraints * `src_bytes` can be of any length from 0 to 8 bytes. * The input endianness strings (`src_endian` and `dst_endian`) are guaranteed to be valid. * Conversion between identical endianness formats should return the original byte sequence unchanged. # Example ```python # Example 1 print(endian_conversion(b\'x01x02x03x04\', \'big\', \'little\')) # Output => b\'x04x03x02x01\' # Example 2 print(endian_conversion(b\'x01x02x03x04\', \'little\', \'big\')) # Output => b\'x04x03x02x01\' # Example 3 print(endian_conversion(b\'x01\', \'big\', \'big\')) # Output => b\'x01\' ``` # Detailed Goals 1. Convert a sequence of bytes from one endianness to another efficiently. 2. Handle edge cases such as empty byte sequences and single-byte sequences. 3. Ensure the function works within the constraints and provides the correct results. Note: You may reuse any fundamental algorithms and principles highlighted in the analysis to design your solution. Your implementation should be efficient and adhere to the performance characteristics outlined.","solution":"def endian_conversion(src_bytes: bytes, src_endian: str, dst_endian: str) -> bytes: Converts a byte sequence from one endianness to another. Parameters: src_bytes (bytes): A sequence of bytes representing the integer to be converted. src_endian (str): Source endianness (\\"big\\" or \\"little\\"). dst_endian (str): Destination endianness (\\"big\\" or \\"little\\"). Returns: bytes: A sequence of bytes converted to the destination endianness. # If source and destination endianness are the same, return the original bytes if src_endian == dst_endian: return src_bytes # Otherwise, reverse the byte sequence return src_bytes[::-1]"},{"question":"# Longest Common Subsequence with Distinct Characters Context: You are given two strings `s1` and `s2`, where `s2` contains all distinct characters. Your task is to find the longest common subsequence between `s1` and `s2`. Function Signature: ```python def max_common_sub_string(s1: str, s2: str) -> str: Returns the longest common subsequence between s1 and s2 Args: s1 : str : First input string s2 : str : Second input string containing distinct characters Returns: str : Longest common subsequence ``` # Input: * `s1`: A string of length `n` (0 ≤ n ≤ 1000). * `s2`: A string of length `m` (0 ≤ m ≤ 1000) containing all distinct characters. # Output: * Return the longest common subsequence as a string. If multiple such subsequences exist, return any. # Constraints: * The string `s2` is guaranteed to have all unique characters. * Attempt to achieve a time complexity of O(n log n). # Example: 1. Input: ```python s1 = \\"abcdaf\\" s2 = \\"acbcf\\" ``` Output: ```python \\"abcf\\" ``` 2. Input: ```python s1 = \\"axyz\\" s2 = \\"bazx\\" ``` Output: ```python \\"ax\\" # Note: Consider edge cases where strings might be empty or have no common characters. Ensure to optimize performance for larger strings. # Performance Requirements: Your implementation should ensure an expected time complexity of O(n log n). Please document any assumptions or special handling of input cases in your code comments.","solution":"def max_common_sub_string(s1: str, s2: str) -> str: Returns the longest common subsequence between s1 and s2 Args: s1 : str : First input string s2 : str : Second input string containing distinct characters Returns: str : Longest common subsequence # Convert s2 into a set for fast lookup s2_set = set(s2) # Filter s1 to only include characters that are in s2 common_chars = [char for char in s1 if char in s2_set] # Initialize LCS table len1, len2 = len(common_chars), len(s2) lcs_table = [[\\"\\" for _ in range(len2 + 1)] for _ in range(len1 + 1)] # Fill LCS table for i in range(1, len1 + 1): for j in range(1, len2 + 1): if common_chars[i - 1] == s2[j - 1]: lcs_table[i][j] = lcs_table[i - 1][j - 1] + common_chars[i - 1] else: lcs_table[i][j] = max(lcs_table[i - 1][j], lcs_table[i][j - 1], key=len) # The bottom-right cell contains the longest common subsequence return lcs_table[-1][-1]"},{"question":"# Question: Increment Big-Endian Array Representation of Integer You are given a non-negative integer represented as a list of digits, where each element in the list is a digit of the integer. The most significant digit is at the start of the list, as in big-endian. Write a function `increment_array(digits: List[int]) -> List[int]` that takes this list and returns a new list which represents the integer incremented by one. Input and Output Formats: - **Input**: - *digits*: List[int] - A list of digits representing a non-negative integer (0 <= digit <= 9). - **Output**: - List[int] - A new list representing the incremented integer. Example: - Input: `[1, 2, 3]` - Output: `[1, 2, 4]` - Explanation: The integer 123 incremented by 1 is 124. - Input: `[9, 9, 9]` - Output: `[1, 0, 0, 0]` - Explanation: The integer 999 incremented by 1 is 1000. Constraints: - The length of the list does not exceed 1000 digits. - The list will always consist of digits between 0 and 9, inclusive. Performance Requirements: - The algorithm should run in linear time, O(n), where n is the length of the input list. - The space complexity should be optimized to O(1) for the output list (excluding the input list\'s storage). Additional Details: - Make sure to handle special cases like: - Empty list (should ideally return `[1]` as incrementing zero). - All elements being 9 leading to increasing the number of digits.","solution":"from typing import List def increment_array(digits: List[int]) -> List[int]: Increments the integer represented by the list of digits by one. n = len(digits) # We iterate from the last digit to the first for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If all the digits were 9, we need to add a leading 1 return [1] + [0] * n"},{"question":"# Task Description You are given a `Family Tree Manager` application where you can store and compare family trees of different families. Given two binary trees representing two family trees, you need to write a function to check whether both trees are equal. Two binary trees are considered equal if they are structurally identical, and the corresponding nodes have the same value. # Input Specification 1. Function signature: `def is_same_tree(tree_p, tree_q) -> bool` 2. `tree_p`: Root node of the first binary tree. 3. `tree_q`: Root node of the second binary tree. The binary tree nodes are defined with a `TreeNode` class: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Output Specification - Return a boolean value: * `True` if both trees are identical. * `False` otherwise. # Constraints - The number of nodes in the trees is in the range `[0, 1000]`. - Node values are integers in the range `[-1000, 1000]`. # Example ```python # Example Test Case # Tree 1 # 1 # / # 2 3 # Tree 2 # 1 # / # 2 3 tree_p = TreeNode(1) tree_p.left = TreeNode(2) tree_p.right = TreeNode(3) tree_q = TreeNode(1) tree_q.left = TreeNode(2) tree_q.right = TreeNode(3) print(is_same_tree(tree_p, tree_q)) # Output: True ``` # Edge Cases 1. Trees with single nodes having different and same values. 2. Completely unbalanced trees with single child nodes. 3. Trees with varying depths.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_same_tree(tree_p, tree_q): Checks if two binary trees are the same. Args: tree_p: TreeNode - Root of the first tree. tree_q: TreeNode - Root of the second tree. Returns: bool: True if both trees are identical, False otherwise. # Both nodes are None, so trees are identical if not tree_p and not tree_q: return True # One of the nodes is None, so trees are not identical if not tree_p or not tree_q: return False # The values of the two nodes are different, so trees are not identical if tree_p.val != tree_q.val: return False # Check recursively for the left and right subtrees return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)"},{"question":"# Matrix Rotation Challenge In this task, you will implement a function that rotates a given N x N matrix by 180 degrees. Unlike simple 90-degree rotations, a 180-degree rotation means every element is moved to its diagonally opposite position in the matrix. Function Signature ```python def rotate_180(matrix): pass ``` Input - `matrix`: A list of lists where each inner list represents a row of the N x N matrix. Each element of the matrix is an integer. Output - Returns a new list of lists representing the input matrix rotated by 180 degrees. Example: ```python input_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] output_matrix = rotate_180(input_matrix) # Expected output: # [ # [9, 8, 7], # [6, 5, 4], # [3, 2, 1] # ] ``` # Constraints: - The input matrix is always a square matrix (N x N), where 1 <= N <= 1000. - Each element of the matrix is an integer. # Performance Requirements - Your solution must run in O(N^2) time complexity. - You should not use any extra space for another matrix of the same size (i.e., aim for an in-place transformation if possible). Notes: - Consider edge cases such as small matrices (1x1, 2x2). - Ensure proper handling of indices to avoid out-of-bound errors. - Think about how to efficiently swap elements between opposite positions. Implement the `rotate_180` function in Python with these guidelines in mind.","solution":"def rotate_180(matrix): Rotates the given N x N matrix by 180 degrees. n = len(matrix) for i in range(n): for j in range(n): if i * n + j < (n * n) // 2: opp_i, opp_j = n - 1 - i, n - 1 - j matrix[i][j], matrix[opp_i][opp_j] = matrix[opp_i][opp_j], matrix[i][j] return matrix"},{"question":"In the realm of competitive programming and cryptography, handling large numbers efficiently is crucial. One common requirement is to compute powers with a modulus which ensures the numbers stay manageable even when dealing with very large exponents. Given the critical importance of this, implement the efficient Modular Exponential Algorithm as described. # Function Specification Implement the function `modular_exponential(base: int, exponent: int, mod: int) -> int`. Input 1. `base (int)`: The base integer ( b ). ( 1 leq base leq 10^9 ). 2. `exponent (int)`: The exponent integer ( e ). ( 0 leq exponent leq 10^9 ). 3. `mod (int)`: The modulus integer ( m ). ( 1 leq mod leq 10^9 ). Output - Returns the result of ( (base^{exponent}) mod mod ). # Constraints - The exponent will always be non-negative. # Example ```python assert modular_exponential(2, 10, 1000) == 24 assert modular_exponential(3, 7, 13) == 3 assert modular_exponential(2, 5, 100) == 32 assert modular_exponential(10, 0, 7) == 1 ``` # Detailed Explanation 1. For the example `modular_exponential(2, 10, 1000)`, we essentially want to compute ( (2^{10}) mod 1000 ). The correct result is 24. 2. For the example `modular_exponential(3, 7, 13)`, the computed power is 3^7 which when modulo 13 results in 3. 3. For the edge case with a zero exponent, such as `modular_exponential(10, 0, 7)`, any number raised to the power 0 is 1, hence the result is 1. The task requires handling large numbers and ensuring accuracy even with powerful computations. Your solution should demonstrate an understanding of the underlying principles of modular exponentiation and efficiently compute the required values.","solution":"def modular_exponential(base: int, exponent: int, mod: int) -> int: Returns the result of (base^exponent) % mod using iterative Fast Exponentiation. result = 1 base = base % mod while exponent > 0: if (exponent % 2) == 1: result = (result * base) % mod exponent = exponent >> 1 # Equivalent to exponent //= 2 base = (base * base) % mod return result"},{"question":"# Problem: Enhanced Interpolation Search with Error Handling You have implemented the basic Interpolation Search algorithm from the given snippet. Now, you need to enhance it by ensuring it handles edge cases and performance bottlenecks effectively. Task Implement the `optimized_interpolation_search` function according to the following specifications: 1. **Input**: * `array`: A sorted list of integers given in non-decreasing order. * `search_key`: An integer to search for within `array`. 2. **Output**: * Return the index of `search_key` if found within the array. * Return `-1` if `search_key` is not present in the array. 3. **Additional Requirements**: * Your solution must handle the edge case where all elements in the range are the same. * Ensure no division by zero errors. * Optimize for the scenario where array elements are not uniformly distributed. * Provide clear comments documenting your logic and any additional checks you include. 4. **Example**: ```python >>> optimized_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> optimized_interpolation_search([10, 10, 10, 10, 10, 10, 10], 10) 0 >>> optimized_interpolation_search([1, 3, 5, 7, 9, 11, 13], 7) 3 ``` Constraints * You can assume the array contains no more than 10^6 elements. * The integer values will lie in the range of -10^9 to 10^9. Good luck, and make sure to test your function with various edge cases including uniform elements, absent keys, and very large arrays.","solution":"def optimized_interpolation_search(array, search_key): Search for a specified key in a sorted list using an optimized interpolation search algorithm. Parameters: array (list): A sorted list of integers in non-decreasing order. search_key (int): The integer to be searched for within the array. Returns: int: The index of search_key if found within the array, otherwise -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: # If the array has identical values in this range if array[high] == array[low]: if array[low] == search_key: return low # Any index between low and high is valid else: return -1 # Interpolation formula pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) # Ensure the position is within the range if pos < low or pos > high: return -1 if array[pos] == search_key: return pos elif array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"**Problem Statement**: Given a stack containing integer values, write a function `double_elements` that duplicates each element of the stack in its original order such that each value appears consecutively twice. You are required to implement this using a single auxiliary stack and a single auxiliary queue approach. Function Signature ```python def double_elements(stack: list) -> list: pass ``` Input - `stack`: A list of integers representing a stack (you can use list operations to simulate stack operations where the end of the list is considered the top of the stack). Output - Return the modified stack after each value has been duplicated. Constraints - You may assume that the stack contains at most 1000 elements. - You will need to use both a stack and a queue for separate implementations to solve this. # Requirements 1. Implement `first_double_elements` which uses a single stack as auxiliary storage. 2. Implement `second_double_elements` which uses a single queue as auxiliary storage. Example ```python stack = [3, 7, 1, 14, 9] # Expected output: # stack after first_double_elements function: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] # stack after second_double_elements function: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Notes - Your implementation should ensure the integrity of the stack\'s order. - Pay attention to the space complexity and ensure your implementations meet the requirements. - Consider edge cases such as an empty stack or a stack with a single element. # Implementation ```python def first_double_elements(stack): storage_stack = [] while stack: storage_stack.append(stack.pop()) while storage_stack: val = storage_stack.pop() stack.append(val) stack.append(val) return stack def second_double_elements(stack): from collections import deque q = deque() while stack: q.append(stack.pop()) while q: stack.append(q.pop()) while stack: q.append(stack.pop()) while q: val = q.pop() stack.append(val) stack.append(val) return stack ```","solution":"def first_double_elements(stack): storage_stack = [] while stack: storage_stack.append(stack.pop()) while storage_stack: val = storage_stack.pop() stack.append(val) stack.append(val) return stack def second_double_elements(stack): from collections import deque q = deque() while stack: q.append(stack.pop()) while q: stack.append(q.pop()) while stack: q.append(stack.pop()) while q: val = q.pop() stack.append(val) stack.append(val) return stack"},{"question":"# Objective Implement an optimized version of the Selection Sort called \\"Stable Selection Sort\\". The goal of the Stable Selection Sort is to maintain the relative order of equal elements (stability) while sorting the list. # Input * A list of tuples. Each tuple has two elements: an integer and a string. * The list should be sorted based on the integer values in non-decreasing order. # Output * A list of tuples sorted based on the integer values in non-decreasing order while maintaining the stability for equal integer values. # Constraints * The list can have up to 10,000 tuples. * Each integer value in the tuple will be between 0 and 1,000,000. # Function Signature ```python def stable_selection_sort(arr: list) -> list: pass ``` # Example Input: ```python arr = [(4, \'apple\'), (3, \'banana\'), (4, \'pear\'), (3, \'orange\')] ``` Output: ```python [(3, \'banana\'), (3, \'orange\'), (4, \'apple\'), (4, \'pear\')] ``` # Explanation: In the given input, tuples `(3, \'banana\')` and `(3, \'orange\')` should remain in the same relative order (i.e., \'banana\' before \'orange\') in the sorted output list. # Requirements * Ensure that the sorting algorithm maintains the relative order of tuples with equal integer values. * The algorithm should handle all edge cases mentioned in the analysis. * Performance should be efficient enough to handle the upper constraint.","solution":"def stable_selection_sort(arr: list) -> list: Sorts a list of tuples based on integer values in a stable manner using the Selection Sort algorithm. n = len(arr) for i in range(n): # Find the minimum element in remaining unsorted array min_index = i for j in range(i + 1, n): if arr[j][0] < arr[min_index][0]: min_index = j # Move minimum element to current position by shifting elements key = arr[min_index] while min_index > i: arr[min_index] = arr[min_index - 1] min_index -= 1 arr[i] = key return arr"},{"question":"You are provided with an array of integers, `nums`, where exactly two elements appear only once, and all the other elements appear exactly twice. Your task is to implement a function `find_single_numbers` that finds and returns the two elements that appear only once. The function signature is as follows: ```python def find_single_numbers(nums: List[int]) -> List[int]: ``` # Input - `nums` (List[int]): A list of integers where exactly two elements appear only once and all the other elements appear exactly twice. - Constraints: - The list will contain at least 2 integers and have an even length (since every element appearing twice ensures even count for pairs). # Output - Returns a list of the two unique integers. # Requirements - Your solution should have a time complexity of O(N) and a space complexity of O(1). # Example ```python # Example 1: nums = [1, 2, 1, 3, 2, 5] assert set(find_single_numbers(nums)) == {3, 5} # Example 2: nums = [4, 1, 2, 1, 2, 5] assert set(find_single_numbers(nums)) == {4, 5} ``` # Solution Outline 1. Use XOR to cancel out the pairs and isolate the XOR result `A^B` of the two unique numbers A and B. 2. Identify a pivot bit that differentiates A and B. 3. Partition the array into two groups based on the pivot bit. 4. XOR elements within each group to isolate A and B. # Notes - You may assume that the input list always conforms to the constraints. - The order of the two numbers in the output list is not important.","solution":"from typing import List def find_single_numbers(nums: List[int]) -> List[int]: # Step 1: Find the XOR of all elements xor = 0 for num in nums: xor ^= num # Step 2: Find a bit that is set (i.e., 1) in the xor_result to differentiate the two groups bitmask = xor & (-xor) # This isolates the rightmost set bit # Step 3: Partition the numbers into two groups and XOR separately a, b = 0, 0 for num in nums: if num & bitmask: a ^= num else: b ^= num return [a, b]"},{"question":"# Question: Fibonacci Paths in a Grid You are given an `n x m` grid. You can start from any cell in the first row and only move to cells in the row just below the current cell. From each cell, you can move to the three possible cells directly beneath it, or diagonally left or right below it. Your task is to implement a function `path_count(n, m)` that returns the number of distinct paths from any cell in the first row to any cell in the last row. The path count should follow the pattern similar to the Fibonacci sequence, adjusted for the given grid constraints. Function Signature ```python def path_count(n, m): ``` # Input: - `n`: An integer representing the number of rows in the grid. - `m`: An integer representing the number of columns in the grid. # Output: - An integer representing the total number of distinct paths from any cell in the first row to any cell in the last row. # Constraints: - 1 ≤ `n` ≤ 100 - 1 ≤ `m` ≤ 100 Example: ```python assert path_count(1, 3) == 3 # There are three columns, each can individually be the path assert path_count(2, 3) == 9 # From each of the 3 cells in the first row, there are 3 potential cells in the next row assert path_count(3, 3) == 27 # 9 choices from second row, for each of the above ``` Developers should consider the possibilities of handling the grid boundaries properly and ensure the function efficiently calculates the number of paths without storing unnecessary data.","solution":"def path_count(n, m): Returns the number of distinct paths from any cell in the first row to any cell in the last row for an n x m grid where you can move to cells directly below, or diagonally left or right below. if n == 1: return m # Each cell in row k+1 has three choices directed from cell in row k return m ** n"},{"question":"# Inverting a Binary Tree Scenario: You are part of a team working on an image processing application that uses binary trees to represent image data structures for certain editing features. One essential function in your image editor is the \\"mirror\\" function, which should invert the image data by flipping all pixel positions left-to-right in a symmetrical manner. To achieve this, you must correctly invert the binary tree that represents the image data. Task: Write a function `invert_tree` that takes the root of a binary tree and inverts it. After inverting, each node, originally on the left side of the tree, should be moved to the right side and vice versa. Function Signature: ```python def invert_tree(root): ``` Input: - `root`: The root node of a binary tree (can be `None`). Output: - The root node of the inverted binary tree. Constraints: - The number of nodes in the tree does not exceed 10^4. - Node values are unique and range between -10^5 to 10^5. Example: ```python # Example Tree Structure # 4 # / # 2 7 # / / # 1 3 6 9 # After Inversion # 4 # / # 7 2 # / / # 9 6 3 1 # Define a simple TreeNode class for use in your solution class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Input Tree root = TreeNode(4) root.left = TreeNode(2, TreeNode(1), TreeNode(3)) root.right = TreeNode(7, TreeNode(6), TreeNode(9)) # Function call inverted_root = invert_tree(root) ``` Note: Assume there is a pre-defined TreeNode class provided as shown in the example. Additional Notes: - Consider edge cases such as when the input tree is empty (root is `None`). - Pay attention to the tree structure principles, ensuring your algorithm handles the inversion correctly for all nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root): Invert a binary tree by swapping left and right children recursively. :param root: TreeNode - root of the binary tree :return: TreeNode - root of the inverted binary tree if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invert_tree(root.left) invert_tree(root.right) return root"},{"question":"# Shell Sort Implementation and Adaptation **Context**: You have to implement the Shell Sort algorithm, but with a twist: you need to sort an array where multiple element types are present (integers, strings). **Task**: Write a function `shell_sort_with_mixed_types(arr: List[Union[int, str]]) -> List[Union[int, str]]` that sorts an array containing both integers and strings. For sorting purposes, strings should be considered larger than any integer. # Expected Complexity: * **Time Complexity**: Should aim to be better than O(n^2) with an optimized gap sequence. * **Space Complexity**: Should be O(1) as it sorts in place. # Input: - `arr` (List[Union[int, str]]): A list of integers and strings to be sorted. # Output: - A single sorted list where integers come first in ascending order, followed by strings in lexicographical order. # Constraints: - The array length will be between 1 and 10^4. - The integers will be in the range -10^6 to 10^6. - Strings will be non-empty and consist of lowercase English letters. # Performance Requirements: - Given the potentially high number of elements and mixed types, the function should efficiently handle larger input sizes. # Example: ```python input: [3, \\"banana\\", 1, \\"apple\\", 5, \\"cherry\\"] output: [1, 3, 5, \\"apple\\", \\"banana\\", \\"cherry\\"] input: [7, 2, 3, \\"a\\", \\"z\\", \\"m\\"] output: [2, 3, 7, \\"a\\", \\"m\\", \\"z\\"] ``` **Hint**: You can modify the Shell Sort algorithm to take special comparison cases into account for mixed types. Implement the function `shell_sort_with_mixed_types` below: ```python from typing import List, Union def shell_sort_with_mixed_types(arr: List[Union[int, str]]) -> List[Union[int, str]]: # Your implementation here ```","solution":"from typing import List, Union def shell_sort_with_mixed_types(arr: List[Union[int, str]]) -> List[Union[int, str]]: Sorts an array containing mixed types (integers and strings) such that integers come first in ascending order, followed by strings in lexicographical order. n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and compare(arr[j - gap], temp) > 0: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr def compare(a: Union[int, str], b: Union[int, str]) -> int: Custom comparator function for mixed types. Integers are considered smaller than strings. if isinstance(a, int) and isinstance(b, int): return a - b elif isinstance(a, str) and isinstance(b, str): return (a > b) - (a < b) elif isinstance(a, int): return -1 else: return 1"},{"question":"Context You are working on a graphical application where you need to process and manipulate images represented as 2D arrays (matrices). A common operation in this application is to rotate images by 90 degrees (clockwise). Task Write a function `rotate_image` that takes an n x n 2D list `matrix` representing an image and rotates the image by 90 degrees clockwise in-place. Function Signature ```python def rotate_image(matrix: List[List[int]]) -> None: ``` Input * `matrix` - n x n 2D list representing the image Output * The function should mutate the input matrix in-place and does not need to return anything. Constraints * Do not use any additional space for performing the operation (i.e., perform the rotation in-place). Examples ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_image(matrix) print(matrix) # Output should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_image(matrix) print(matrix) # Output should be: # [ # [15, 13, 2, 5], # [14, 3, 4, 1], # [12, 6, 8, 9], # [16, 7, 10, 11] # ] ``` Notes * You can assume that the input matrix is always a square matrix (n x n). * Take care of edge cases, such as a matrix with only one row/column or an empty matrix. * Your solution should demonstrate a clear understanding of in-place matrix rotation operations and must adhere to the constraints provided.","solution":"from typing import List def rotate_image(matrix: List[List[int]]) -> None: Rotates the input n x n image matrix by 90 degrees clockwise in place. n = len(matrix) # Step 1: Transpose the matrix (convert rows to columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"You are given a directed graph where each node represents a point in the network and each edge has a capacity, representing how much can flow through that edge. Implement an optimized version of the maximum flow problem using the BFS search strategy to ensure better path selection. # Input: - An `n x n` adjacency matrix `adjacency_matrix` where `adjacency_matrix[i][j]` represents the capacity of the edge from node `i` to node `j` (0 if there is no edge). # Output: - A single integer representing the maximum possible flow from the source (node 0) to the sink (node n-1). # Constraints: - (1 leq n leq 1000) - (0 leq adjacency_matrix[i][j] leq 10^5) # Example: ```python graph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]] maximum_flow_bfs(graph) -> 23 ``` # Instructions: 1. Implement the `maximum_flow_bfs` function to solve the maximum flow using BFS: * Ensure it identifies augmenting paths using BFS for optimal performance. * It should update the residual capacities correctly and record the maximum flow transferred. # Functional Signature: ```python def maximum_flow_bfs(adjacency_matrix: List[List[int]]) -> int: pass ``` # Points to cover: 1. Properly handle the edge cases and offer optimal complexity improvements. 2. Ensure correct residual capacity updates and final flow calculations.","solution":"from collections import deque def bfs(residual_graph, source, sink, parent): Returns True if there is a path from source to sink in residual graph. visited = [False] * len(residual_graph) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, capacity in enumerate(residual_graph[u]): if visited[v] == False and capacity > 0: # If node not yet visited and there is an edge queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def maximum_flow_bfs(adjacency_matrix): Returns the maximum flow from source (node 0) to sink (node len(adjacency_matrix)-1). source = 0 sink = len(adjacency_matrix) - 1 residual_graph = [row[:] for row in adjacency_matrix] # Create residual graph parent = [-1] * len(adjacency_matrix) # Array to store the path max_flow = 0 # Initialize max flow # Augment the flow while there is a path from source to sink. while bfs(residual_graph, source, sink, parent): # Find the maximum flow through the path found by BFS. path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] # update residual capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] residual_graph[u][v] -= path_flow residual_graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Segment Tree Implementation with Functionality Extension Objective: Implement a segment tree class with extended functionality to handle a new operation: **Range Update**, where you update all elements in a given range by adding a specific value. Scenario: You have an initial array of integers, and you need to efficiently perform the following operations: - **Range Query**: Get the sum of elements within a specified range. - **Point Update**: Update the value of a specific element. - **Range Update**: Add a specific value to all elements within a specified range. For example: - If the array is `[1, 3, 5, 7, 9, 11]`, and you perform a range update adding `2` to the range `[1, 4]`, the array becomes `[1, 5, 7, 9, 11, 11]`. - Querying the sum of the range `[0, 3]` would now return `1 + 5 + 7 + 9 = 22`. Requirements: 1. Implement the SegmentTree class with the following methods: - **__init__(self, arr)**: Initializes the segment tree with the given array for sum queries. - **update(self, index, value)**: Updates the value of the element at the specified index. - **query(self, left, right)**: Returns the sum of elements in the range `[left, right]`. - **range_update(self, left, right, value)**: Adds `value` to all elements in the range `[left, right]`. 2. Your implementation should meet these constraints: - The array has a length of up to `100000`. - Each element in the array and each value for updates/queries are within the integer range. 3. Performance Requirements: - `update` and `query` operations should run in (O(log N)) time. - `range_update` should run in (O(log N)) time with lazy propagation. You should demonstrate the process with a few test cases to help understand your implementation. Sample Input/Output ```python # Sample Input arr = [1, 3, 5, 7, 9, 11] segment_tree = SegmentTree(arr) segment_tree.update(3, 6) # Updates index 3 to 6, array becomes [1, 3, 5, 6, 9, 11] print(segment_tree.query(0, 3)) # Output: 1 + 3 + 5 + 6 = 15 segment_tree.range_update(1, 4, 2) # Adds 2 to all elements from index 1 to 4, array becomes [1, 5, 7, 8, 11, 11] print(segment_tree.query(1, 5)) # Output: 5 + 7 + 8 + 11 + 11 = 42 # Another Sample Input arr = [4, 5, 2, 3, 4, 43, 3] segment_tree = SegmentTree(arr) print(segment_tree.query(0, 6)) # Output: 4 + 5 + 2 + 3 + 4 + 43 + 3 = 64 segment_tree.range_update(2, 5, -1) # Subtracts 1 from all elements from index 2 to 5, array becomes [4, 5, 1, 2, 3, 42, 3] print(segment_tree.query(0, 6)) # Output: 4 + 5 + 1 + 2 + 3 + 42 + 3 = 60 ``` Provide your implementation for the SegmentTree class below.","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (4 * self.n) self.lazy = [0] * (4 * self.n) self.build(arr, 0, 0, self.n - 1) def build(self, arr, node, start, end): if start == end: self.tree[node] = arr[start] else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self.build(arr, left_child, start, mid) self.build(arr, right_child, mid + 1, end) self.tree[node] = self.tree[left_child] + self.tree[right_child] def update(self, idx, value): self._update(0, 0, self.n - 1, idx, value) def _update(self, node, start, end, idx, value): if start == end: self.tree[node] = value else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 if start <= idx <= mid: self._update(left_child, start, mid, idx, value) else: self._update(right_child, mid + 1, end, idx, value) self.tree[node] = self.tree[left_child] + self.tree[right_child] def query(self, left, right): return self._query(0, 0, self.n - 1, left, right) def _query(self, node, start, end, left, right): if right < start or end < left: return 0 if left <= start and end <= right: return self.tree[node] self._propagate(node, start, end) mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 left_sum = self._query(left_child, start, mid, left, right) right_sum = self._query(right_child, mid + 1, end, left, right) return left_sum + right_sum def range_update(self, left, right, value): self._range_update(0, 0, self.n - 1, left, right, value) def _range_update(self, node, start, end, left, right, value): self._propagate(node, start, end) if right < start or end < left: return if left <= start and end <= right: self.lazy[node] += value self._propagate(node, start, end) return mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self._range_update(left_child, start, mid, left, right, value) self._range_update(right_child, mid + 1, end, left, right, value) self.tree[node] = self.tree[left_child] + self.tree[right_child] def _propagate(self, node, start, end): if self.lazy[node] != 0: self.tree[node] += (end - start + 1) * self.lazy[node] if start != end: left_child = 2 * node + 1 right_child = 2 * node + 2 self.lazy[left_child] += self.lazy[node] self.lazy[right_child] += self.lazy[node] self.lazy[node] = 0"},{"question":"You are provided with a data structure called `OrderedStack` that maintains an ordered stack such that the highest value is always at the top and the lowest at the bottom. Your task is to implement the `push` method that ensures this order is maintained as new elements are added. # Function Signature You need to implement the following method: ```python def push(self, item): # Your implementation here ``` # Existing Constraints 1. You must not use any other data structures except the provided `OrderedStack` class and basic Python lists. 2. The `push` method must ensure stack order after every insertion. 3. The `pop` method will raise `IndexError` if the stack is empty. # Input/Output Formats * **Input**: * An element that needs to be inserted into the stack. * **Output**: * The stack should maintain order after insertion. # Functional Requirements The method should handle insertion efficiently while maintaining the stack order. Here are some example scenarios: **Example 1**: ```python stack = OrderedStack() stack.push(3) stack.push(1) stack.push(2) print(stack.items) # Expected output: [1, 2, 3] (Lowest to highest) ``` **Example 2**: ```python stack = OrderedStack() stack.push(5) print(stack.items) # Expected output: [5] stack.push(1) print(stack.items) # Expected output: [1, 5] stack.push(7) print(stack.items) # Expected output: [1, 5, 7] stack.push(3) print(stack.items) # Expected output: [1, 3, 5, 7] ``` Consider edge cases like inserting into an empty stack, inserting elements in descending or ascending order, and inserting duplicates. Implement the `push` method ensuring efficient handling and maintaining order within the stack.","solution":"class OrderedStack: def __init__(self): self.items = [] def push(self, item): # Find the right place to insert the item to maintain order index = 0 while index < len(self.items) and self.items[index] < item: index += 1 self.items.insert(index, item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.items.pop() def is_empty(self): return len(self.items) == 0"},{"question":"Implementation of Bitonic Sort Algorithm Problem Statement You are tasked with implementing the Bitonic Sort algorithm, an efficient parallel sorting algorithm designed for arrays whose sizes are powers of two. Your implementation should handle both ascending and descending order sorting. Function Signature ```python def bitonic_sort(arr: List[int], reverse: bool=False) -> List[int]: ``` Input/Output Format * **Input**: * `arr` (List[int]): A list of integers where the size is a power of 2. * `reverse` (bool): A boolean flag that determines the sorting order. If `False` (default), the list should be sorted in ascending order. If `True`, the list should be sorted in descending order. * **Output**: * Returns a list of integers sorted according to the given order. Constraints * The length of `arr` will be a power of 2 (e.g., 2, 4, 8, ...). Example ```python bitonic_sort([3, 7, 2, 1, 9, 5, 6, 4], reverse=False) # Output: [1, 2, 3, 4, 5, 6, 7, 9] bitonic_sort([3, 7, 2, 1, 9, 5, 6, 4], reverse=True) # Output: [9, 7, 6, 5, 4, 3, 2, 1] ``` Guidelines 1. Implement the `compare` function to facilitate element comparison and swapping within the array based on the desired order. 2. Implement the `bitonic_merge` function to recursively merge the bitonic sequences. 3. Ensure that the input array is checked for the power-of-2 length constraint and handle cases accordingly. 4. Your final implementation should call these helper functions and handle the recursive partitioning and merging of the bitonic sequences. Performance Requirements The algorithm should have a time complexity of O(n log(n)^2) in non-parallel execution, while space complexity should be O(n). Good luck!","solution":"from typing import List def compare_and_swap(arr: List[int], i: int, j: int, ascending: bool): Compare and swap the elements if they are in the wrong order based on ascending flag. if (ascending and arr[i] > arr[j]) or (not ascending and arr[i] < arr[j]): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr: List[int], low: int, cnt: int, ascending: bool): Merge function to merge the bitonic sequences in a sorted manner. if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(arr, i, i + k, ascending) bitonic_merge(arr, low, k, ascending) bitonic_merge(arr, low + k, k, ascending) def bitonic_sort_recursive(arr: List[int], low: int, cnt: int, ascending: bool): Recursively sorts a portion of the array into a bitonic sequence, then sorts that bitonic sequence. if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) # first half in ascending order bitonic_sort_recursive(arr, low + k, k, False) # second half in descending order bitonic_merge(arr, low, cnt, ascending) def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: Function to sort the array using bitonic sort. n = len(arr) if (n & (n - 1)) != 0 or n == 0: raise ValueError(\\"The length of the array must be a power of 2\\") bitonic_sort_recursive(arr, 0, n, not reverse) return arr"},{"question":"Scenario You are working on a software that manages hierarchical data with frequent insertion and search operations. To optimize certain operations, your system utilizes a Binary Search Tree (BST). A frequent task is to identify the predecessor of a given node in the BST. Problem Statement Write a function `find_predecessor(root, node_value)` that returns the value of the predecessor node in a binary search tree (BST). If no predecessor exists (i.e., the given node is the smallest in the BST, or the node is not found), the function should return None. Your function should efficiently navigate the tree without using extra space for storing nodes. The BST node is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Function Signature ```python def find_predecessor(root: TreeNode, node_value: int) -> int: ``` Input * `root` (TreeNode): The root node of the BST. * `node_value` (int): The value of the node whose predecessor is to be found. Output * `int`: The value of the predecessor node, or `None` if no predecessor exists. Constraints * The given `root` node will be the root of a valid BST. * Node values are unique integers. * The tree can have up to 1000 nodes. Performance Requirements * Your solution must run in O(h) time, where h is the height of the tree. * Use O(1) additional space. Example ```python # Example usage: # Constructing a sample BST root = TreeNode(20) root.left = TreeNode(10) root.right = TreeNode(30) root.left.left = TreeNode(5) root.left.right = TreeNode(15) root.left.right.left = TreeNode(13) # Finding predecessor predecessor = find_predecessor(root, 15) print(predecessor) # Output: 13 # Edge case: smallest node predecessor = find_predecessor(root, 5) print(predecessor) # Output: None ``` Notes * Focus on edge cases where the node may be the smallest element. * Ensure function correctly handles cases where the node does not exist in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_predecessor(root: TreeNode, node_value: int) -> int: # Helper function to find the maximum value node in a subtree def get_maximum_node(node): current = node while current.right: current = current.right return current.val predecessor = None current = root while current: if node_value > current.val: predecessor = current.val # potential predecessor found current = current.right elif node_value < current.val: current = current.left else: if current.left: return get_maximum_node(current.left) return predecessor return None"},{"question":"Scenario You are working on developing a function for analyzing customer purchase data. The data is provided as a list where each element represents a product ID bought by a customer. You need to create a function to count how many times each product was purchased. Task Implement the function `get_histogram` that takes a list of product IDs and returns a dictionary representing the histogram of product purchases. Function Signature ```python def get_histogram(input_list: list) -> dict: Get histogram representation of product purchases. :param input_list: list of product IDs :return: dictionary where keys are product IDs and values are their frequencies ``` Input * A list of integers, where each integer represents a product ID. * Constraints: - 1 <= len(input_list) <= 10^6 - Each product ID is a non-negative integer. Output * A dictionary where each key is a unique product ID from the input list and the corresponding value is the count of how many times that product ID appears in the list. Example ```python assert get_histogram([]) == {} assert get_histogram([3, 3, 2, 1]) == {1: 1, 2: 1, 3: 2} assert get_histogram([2, 3, 5, 5, 5, 6, 4, 3, 7]) == {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} assert get_histogram([7, 7, 7, 7]) == {7: 4} ``` Important Notes * Consider edge cases such as empty lists and lists with a single product ID. * Your implementation should be efficient enough to handle the upper limits of input size.","solution":"from collections import defaultdict def get_histogram(input_list: list) -> dict: Get histogram representation of product purchases. :param input_list: list of product IDs :return: dictionary where keys are product IDs and values are their frequencies histogram = defaultdict(int) for product_id in input_list: histogram[product_id] += 1 return dict(histogram)"},{"question":"# Question Description As a software engineer at a company that specializes in cryptographic services, you are tasked with developing a module that efficiently verifies the primality of a given number. Your algorithm should cater to large integers up to 10^12. Function Signature ```python def is_prime(n: int) -> bool: Return True if n is a prime number, else return False. ``` Input - An integer `n` (1 ≤ n ≤ 10^12) Output - A boolean value, `True` if `n` is a prime number, `False` otherwise. Requirements * The implementation should be efficient with a time complexity of O(√n). * The code should handle edge cases correctly and be robust enough for large values of `n`. Example ```python assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(5) == True assert is_prime(25) == False assert is_prime(999983) == True ``` # Additional Notes Prime numbers have a fundamental role in the field of cryptography, particularly in encryption algorithms. It\'s crucial to evaluate the prime status efficiently to ensure the security of cryptographic processes. Implement the function `is_prime` with the above specifications and ensure optimal performance for large inputs.","solution":"def is_prime(n: int) -> bool: Return True if n is a prime number, else return False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Reformatting Serial Codes Problem Statement Given a string representing a serial code and an integer `k`, your task is to reformat this serial code by dividing its alphanumeric characters into groups of size `k` starting from the end of the string, with each group separated by a dash (\'-\'). - Ignore all dashes in the original string. - The characters in the groups should appear in the same order as in the original string. Implement the function: ```python def reformat_serial_code(code: str, k: int) -> str: pass ``` Input * `code` (string): The original serial code string (may contain alphanumeric characters and dashes). * `k` (int): The group size. Output * The reformatted serial code as a string. Constraints * 1 <= len(code) <= 1000 * 1 <= k <= 1000 Example * Input: `code = \\"2-4A0r7-4k\\"`, `k = 4` * Output: `\\"24A0-R74K\\"` * Input: `code = \\"2-4A0-4k\\"`, `k = 3` * Output: `\\"24-A04-K\\"` Notes - The reformatted string should not start or end with a dash. - All lowercase letters should be converted to uppercase. Implement the function and ensure it handles various edge cases as indicated by the constraints and examples provided.","solution":"def reformat_serial_code(code: str, k: int) -> str: Reformats a serial code by dividing its alphanumeric characters into groups of size `k`. Each group is separated by a dash. code = code.replace(\\"-\\", \\"\\").upper() n = len(code) # Calculate the size of the first group first_group_size = n % k if n % k != 0 else k parts = [] # Add the first group parts.append(code[:first_group_size]) # Add the remaining groups of size `k` for i in range(first_group_size, n, k): parts.append(code[i:i + k]) return \\"-\\".join(parts)"},{"question":"You are required to implement an algorithm that determines whether a directed graph is strongly connected. A graph is strongly connected if there is a path in both directions between each pair of vertices of the graph. # Inputs - An integer `n` (number of vertices): (1 leq n leq 1000) - A list of edges, where each edge is represented as a pair `[source, target]` indicating a directed edge from `source` to `target`. # Output - Return `True` if the graph is strongly connected, otherwise return `False`. # Function Signature ```python def is_strongly_connected(n: int, edges: List[List[int]]) -> bool: pass ``` # Example Input ```python n = 5 edges = [ [0, 1], [1, 2], [2, 0], [1, 3], [3, 4], [4, 1] ] ``` Output ```python True ``` Explanation In this example, the graph is strongly connected because there is a path between every pair of vertices in both directions. # Constraints - Ensure to handle edge cases such as graphs with zero edges or graphs with vertices not inter-connected. - Minimize memory usage and optimize for large `n` wherever possible. # Notes 1. You may use the provided `Graph` class code as a reference but you need to solve the problem by implementing the `is_strongly_connected` function separately. 2. Make sure to handle reversed graph correctly by reassigning edges appropriately.","solution":"from typing import List, Dict from collections import defaultdict, deque def is_strongly_connected(n: int, edges: List[List[int]]) -> bool: def bfs(graph: Dict[int, List[int]], start: int) -> bool: visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) queue.extend(graph[node]) return len(visited) == n def build_graph(edges: List[List[int]]) -> Dict[int, List[int]]: graph = defaultdict(list) for src, dest in edges: graph[src].append(dest) return graph # Build the original graph original_graph = build_graph(edges) # Check if all nodes are reachable from the first node if not bfs(original_graph, 0): return False # Build the reversed graph reversed_edges = [[dest, src] for src, dest in edges] reversed_graph = build_graph(reversed_edges) # Check if all nodes are reachable from the first node in the reversed graph if not bfs(reversed_graph, 0): return False return True"},{"question":"**Question: Implement an Improved Bitonic Sort Algorithm** Using your knowledge of the bitonic sort algorithm, implement a function that takes an array of integers and sorts it in ascending order. Ensure your function handles arrays of arbitrary sizes by padding them to the next power of two, if necessary. Return the sorted array. # Requirements: 1. The input can be of any length, but to apply bitonic sort, make sure to handle cases where the length is not a power of two by padding the array with the maximum integer value, `sys.maxsize`. 2. Implement the bitonic sort in both recursive and non-parallel fashion. 3. Do not use any pre-existing sort library functions. 4. Output should be the sorted array in ascending order. # Input: - An array of integers `arr` of length `n` (0 ≤ n ≤ 10^5). # Output: - A sorted array in ascending order. # Constraints: - Your solution should handle edge cases efficiently. - Ensure the solution is optimized for the given complexity bounds. # Example: 1. **Input**: `[4, 3, 2, 5, 1]` - **Output**: `[1, 2, 3, 4, 5]` 2. **Input**: `[10, 30, 10, 20, 20]` - **Output**: `[10, 10, 20, 20, 30]` # Scenario: Imagine a scenario where you are tasked with processing a large batch of sensor data collected at different intervals. Since your input sensor data may not always come in power-of-two batches, ensuring the sorting algorithm can handle such cases efficiently is crucial. This implementation will automatically pad the array when necessary and ensure sorted output in a timely manner.","solution":"import sys from math import log2, ceil def bitonic_sort(arr): Sorts an array in ascending order using the bitonic sort algorithm. def bitonic_compare_and_swap(arr, i, j, direction): if (direction == 1 and arr[i] > arr[j]) or (direction == 0 and arr[i] < arr[j]): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): bitonic_compare_and_swap(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_recursive(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, 1) bitonic_sort_recursive(arr, low + k, k, 0) bitonic_merge(arr, low, cnt, direction) def pad_to_power_of_two(arr): next_power_of_two = 2 ** ceil(log2(len(arr))) return arr + [sys.maxsize] * (next_power_of_two - len(arr)) if len(arr) == 0: return arr padded_arr = pad_to_power_of_two(arr) bitonic_sort_recursive(padded_arr, 0, len(padded_arr), 1) return padded_arr[:len(arr)] # return only the original length part of the array"},{"question":"You are tasked with calculating the number of combinations, denoted as `nCr`, that represent the number of ways to choose `r` items from `n` items. This number is fundamental in combinatorics and has applications across probability, statistics, and various computational fields. # Problem Statement Write a function `optimized_combination(n: int, r: int) -> int` that calculates the value of `nCr` using the principles of dynamic programming to ensure the solution is efficient even for large inputs. # Input - Two integers `n` and `r`, where `n >= 0` and `r >= 0`. # Output - An integer representing the value of `nCr`. # Constraints - Ensure that your solution is efficient, aiming for O(n*r) time complexity. - Consider edge cases, such as when `r > n` (should return 0), `r == 0`, `n == 0`, and when `n == r`. # Example ```python assert optimized_combination(5, 3) == 10 assert optimized_combination(6, 2) == 15 assert optimized_combination(1, 1) == 1 assert optimized_combination(0, 0) == 1 assert optimized_combination(10, 0) == 1 assert optimized_combination(10, 10) == 1 assert optimized_combination(10, 11) == 0 ``` # Requirements - Implement efficient handling of the recursive steps using memoization or an iterative approach to dynamic programming. - Handle edge cases correctly. - Ensure the function executes within a reasonable time for large values of `n` and `r` (up to 1000).","solution":"def optimized_combination(n: int, r: int) -> int: Computes the binomial coefficient nCr using an efficient dynamic programming approach. :param n: Number of items. :param r: Number of items to choose. :return: nCr value. if r > n: return 0 if r == 0 or r == n: return 1 # Create a list to store the intermediate results C = [0] * (r + 1) C[0] = 1 # There is always 1 way to choose 0 items for i in range(1, n + 1): # Compute next row of pascal triangle using the previous row # elements starting from the end. This minimizes space complexity to O(r) for j in range(min(i, r), 0, -1): C[j] = C[j] + C[j-1] return C[r]"},{"question":"# Objective You are required to implement a function that takes a string and reverses it, resembling any language of your preference but avoiding simple built-in functions or library methods that directly reverse strings. # Requirements 1. **Function signature**: `def reverse_string(s: str) -> str:` 2. **Input**: A string `s` of length `n` where ( 0 leq n leq 10^5 ). 3. **Output**: The reversed string. 4. The solution must handle strings efficiently in terms of both time and space complexity. # Constraints * The input string `s` will contain only printable ASCII characters. # Examples 1. Input: `\\"hello\\"` Output: `\\"olleh\\"` 2. Input: `\\"Python\\"` Output: `\\"nohtyP\\"` 3. Input: `\\"\\"` Output: `\\"\\"` 4. Input: `\\"racecar\\"` Output: `\\"racecar\\"` # Context Imagine you are developing a utility for a text-processing software that needs to reverse words in several documents. Your function will be used in multiple such use cases, and it\'s critical that it performs efficiently, especially when dealing with large texts. Develop your solution considering edge cases like empty strings and strings with special characters. Avoid simple built-in functions that directly reverse strings to demonstrate your understanding of fundamental coding concepts.","solution":"def reverse_string(s: str) -> str: Reverses the input string without using built-in functions that directly reverse strings. :param s: The input string to be reversed. :return: The reversed string. reversed_s = [] for i in range(len(s) - 1, -1, -1): reversed_s.append(s[i]) return \'\'.join(reversed_s)"},{"question":"# Binary Exponentiation Assessment You are required to implement the iterative and recursive versions of binary exponentiation as described. Given base `a`, exponent `n`, and an optional modulus `mod`, your function should compute ( a^n ) efficiently. If `mod` is provided, the result should be modulo `mod`. Function Signatures: - `def bin_exp_iter(a: int, n: int, mod: int = None) -> int:` - `def bin_exp_recur(a: int, n: int, mod: int = None) -> int:` # Input Format: - `a`: An integer base. - `n`: A non-negative integer exponent. - `mod`: An optional integer modulus. If not provided, assume it is `None`. # Output Format: - Returns an integer which is the result of the exponentiation. # Constraints: - ( 0 leq a leq 10^9 ) - ( 0 leq n leq 10^9 ) - ( 1 leq mod leq 10^9 ) (if provided) # Performance Requirements: - Your iterative implementation should have a space complexity of O(1). - Your recursive implementation should have a space complexity of O(log(n)) due to the function call stack. # Edge Cases: - Handle cases where `n` is 0 or 1. - Ensure modulo operation handles negative results correctly to produce a non-negative output. # Examples: 1. **Input:** `bin_exp_iter(2, 10, 1000)` **Output:** 24 2. **Input:** `bin_exp_recur(2, 10, 1000)` **Output:** 24 3. **Input:** `bin_exp_iter(2, 0)` **Output:** 1 4. **Input:** `bin_exp_recur(2, 1)` **Output:** 2 5. **Input:** `bin_exp_iter(3, 5)` **Output:** 243 You are expected to write the complete code for both functions `bin_exp_iter` and `bin_exp_recur` and ensure all edge cases and constraints are appropriately handled.","solution":"def bin_exp_iter(a: int, n: int, mod: int = None) -> int: Iterative function to perform binary exponentiation. Calculates a^n (mod mod) if mod is provided. result = 1 base = a if mod is not None: base %= mod while n > 0: if n % 2 == 1: result = result * base if mod is not None: result %= mod base = base * base if mod is not None: base %= mod n //= 2 return result def bin_exp_recur(a: int, n: int, mod: int = None) -> int: Recursive function to perform binary exponentiation. Calculates a^n (mod mod) if mod is provided. if n == 0: return 1 half = bin_exp_recur(a, n // 2, mod) half = (half * half) % mod if mod is not None else half * half if n % 2 != 0: half = (half * a) % mod if mod is not None else half * a return half"},{"question":"# Pattern and Word Matching Given a pattern consisting of lowercase letters and a string consisting of words separated by a single space, implement a function `word_pattern(pattern: str, sentence: str) -> bool` to determine if the string `sentence` follows the same pattern as the given `pattern`. In this context, following the pattern means there is a one-to-one and onto mapping between characters in the pattern and the words in the sentence. Input: * `pattern` (string): a non-empty string containing only lowercase letters. * `sentence` (string): a string containing words separated by single spaces, where each word consists only of lowercase letters. Output: * Returns `True` if the sentence matches the given pattern, otherwise returns `False`. Constraints: 1. Pattern and sentence both are non-empty. 2. Both strings contain only lowercase English letters and spaces. 3. Words in `sentence` are separated by exactly one space, with no leading or trailing spaces. Example: 1. Input: `pattern = \\"abba\\"`, `sentence = \\"dog cat cat dog\\"` Output: `True` 2. Input: `pattern = \\"abba\\"`, `sentence = \\"dog cat cat fish\\"` Output: `False` 3. Input: `pattern = \\"aaaa\\"`, `sentence = \\"dog cat cat dog\\"` Output: `False` 4. Input: `pattern = \\"abba\\"`, `sentence = \\"dog dog dog dog\\"` Output: `False` # Additional Requirements: * Your solution must be implemented using Python. * Aim for an efficient solution with minimal time and space complexity. * Carefully handle all edge cases as highlighted in the problem description.","solution":"def word_pattern(pattern: str, sentence: str) -> bool: words = sentence.split() if len(pattern) != len(words): return False pattern_to_word = {} word_to_pattern = {} for p, w in zip(pattern, words): if p in pattern_to_word: if pattern_to_word[p] != w: return False if w in word_to_pattern: if word_to_pattern[w] != p: return False pattern_to_word[p] = w word_to_pattern[w] = p return True"},{"question":"Given the problem of validating a string containing parentheses, your task is to implement a function `is_valid_brackets` that determines if the input string contains valid and correctly nested pairs of brackets. Function Signature ```python def is_valid_brackets(s: str) -> bool: pass ``` Input * `s` (string): A string consisting of characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. The length of the string (0 leq |s| leq 10^4). Output * (boolean): Return `True` if the string `s` is valid, otherwise return `False`. Constraints 1. The input string can be empty which should be considered valid. 2. The solution must process the string in a single pass ensuring O(n) time complexity. 3. You may assume that none of the other characters will appear in the input string. Examples *Example 1:* ```python is_valid_brackets(\\"()\\") # Output: True ``` *Example 2:* ```python is_valid_brackets(\\"()[]{}\\") # Output: True ``` *Example 3:* ```python is_valid_brackets(\\"(]\\") # Output: False ``` *Example 4:* ```python is_valid_brackets(\\"([)]\\") # Output: False ``` *Example 5:* ```python is_valid_brackets(\\"{[]}\\") # Output: True ``` Scenario Consider a text editor that highlights matching brackets for the user as they type. Implement a function that can be used within the text editor to validate the current state of the text regarding balanced brackets. Additional Requirement Optimize for legibility and efficiency. Ensure that any constraints, performance limitations, or edge cases are thoroughly handled.","solution":"def is_valid_brackets(s: str) -> bool: stack = [] mapping = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in mapping.values(): stack.append(char) elif char in mapping: if not stack or stack[-1] != mapping[char]: return False stack.pop() else: return False return not stack"},{"question":"You are given an array of integers and a target sum. Your task is to write a function `find_two_sum(nums: List[int], target: int) -> Tuple[int, int]` that finds two distinct indices `i` and `j` (where `i < j`) such that the sum of the elements at these indices is equal to the target. Each input array will have exactly one solution, and you may not use the same element twice. # Input * `nums`: A list of integers. * `target`: An integer representing the target sum. # Output * A tuple of two integers representing the indices of the two numbers whose sum equals the target. The order of the indices in the tuple should be `(i, j)` where `i < j`. # Constraints * The array will have a size ranging from 2 to 10^5 elements. * Each number in the array can range from -10^9 to 10^9. * There is exactly one valid solution. # Examples 1. **Example 1:** * Input: `nums = [2, 7, 11, 15]`, `target = 9` * Output: `(0, 1)` * Explanation: Because nums[0] + nums[1] = 2 + 7 = 9 2. **Example 2:** * Input: `nums = [3, 2, 4]`, `target = 6` * Output: `(1, 2)` * Explanation: Because nums[1] + nums[2] = 2 + 4 = 6 3. **Example 3:** * Input: `nums = [3, 3]`, `target = 6` * Output: `(0, 1)` * Explanation: Because nums[0] + nums[1] = 3 + 3 = 6 # Performance Requirements * Your solution should run in O(n) time complexity. * Use O(n) extra space for storing intermediate values. # Function Signature ```python from typing import List, Tuple def find_two_sum(nums: List[int], target: int) -> Tuple[int, int]: # Your code here ``` # Notes Remember to handle edge cases where the input array may contain only two elements or where elements are negative.","solution":"from typing import List, Tuple def find_two_sum(nums: List[int], target: int) -> Tuple[int, int]: This function finds two distinct indices i and j such that nums[i] + nums[j] equals the target. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return (-1, -1) # This line should never be reached given the problem constraints."},{"question":"Run-Length Encoding and Decoding Implementation You have learned about the Run-Length Encoding (RLE) algorithm for data compression. Now, it\'s time to demonstrate your understanding by writing a Python function to encode and decode a string using RLE. # Objective Implement two functions: `encode_rle` and `decode_rle`. - The `encode_rle` function should compress the input string using RLE. - The `decode_rle` function should decompress a string encoded using RLE back to its original form. # Input and Output Formats * `encode_rle(input: str) -> str` - **Input**: A string `input` consisting of alphanumeric characters and spaces. - **Output**: A compressed string using RLE. * `decode_rle(input: str) -> str` - **Input**: A string `input` encoded using RLE. - **Output**: The original uncompressed string. # Examples ```python # Encoding Examples encode_rle(\\"AAAABBBCCDAA\\") # should return \\"4A3B2C1D2A\\" encode_rle(\\"XYZ\\") # should return \\"1X1Y1Z\\" # Decoding Examples decode_rle(\\"4A3B2C1D2A\\") # should return \\"AAAABBBCCDAA\\" decode_rle(\\"1X1Y1Z\\") # should return \\"XYZ\\" ``` # Constraints 1. The input string for `encode_rle` can be empty, which should return an empty string. 2. Assume that the decoded string for `decode_rle` has valid encoding and does not contain errors. 3. Consider edge cases such as empty strings, single character strings, and strings with non-repetitive characters. 4. Your solution should be efficient in terms of time and space complexity. Write your implementations of `encode_rle` and `decode_rle` ensuring that they handle the described inputs and constraints effectively.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded_string = \\"\\" current_char = input[0] count = 0 for char in input: if char == current_char: count += 1 else: encoded_string += f\\"{count}{current_char}\\" current_char = char count = 1 encoded_string += f\\"{count}{current_char}\\" return encoded_string def decode_rle(input: str) -> str: decoded_string = \\"\\" count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded_string += char * int(count) count = \\"\\" return decoded_string"},{"question":"# Question: Implement a Multiple Operation Randomized Data Structure You are tasked with implementing a data structure named `RandomizedMultiSet` that supports multiple operations including insert, remove, get random, and retrieve duplicates. The requirements are as follows: 1. `insert(val)`: Inserts an item `val` into the set even if it already exists. 2. `remove(val)`: Removes one occurrence of an item `val` from the set if present. 3. `getRandom()`: Returns a random element from the current set of elements, each element must have the same probability of being returned. 4. `getDuplicates()`: Returns a list of items in the set that have duplicates. Your implementation should aim for the following constraints: * **Average time complexity** for `insert`, `remove`, and `getRandom` operations should be O(1). * **Space complexity** should be O(n), where n is the total number of elements in the set (including duplicates). # Function Signatures Implement the following methods of the `RandomizedMultiSet` class: ```python class RandomizedMultiSet: def __init__(self): # Initializes the data structure. pass def insert(self, val: int) -> bool: # Inserts an item val to the set even if it already present. pass def remove(self, val: int) -> bool: # Removes one occurrence of an item val from the set if present. pass def getRandom(self) -> int: # Returns a random element from current set of elements. pass def getDuplicates(self) -> List[int]: # Returns a list of items that have duplicates in the set. pass ``` # Example ```python # Example usage rs = RandomizedMultiSet() print(rs.insert(10)) # True print(rs.insert(20)) # True print(rs.insert(10)) # True print(rs.remove(10)) # True print(rs.getDuplicates()) # [10] print(rs.getRandom()) # Random element from [10, 20] print(rs.remove(10)) # True print(rs.getDuplicates()) # [] ``` # Constraints * The values inserted will be integers. * The number of operations will be in the range [1, 10^4].","solution":"import random from collections import defaultdict class RandomizedMultiSet: def __init__(self): Initializes the data structure. self.data = [] self.indices = defaultdict(set) def insert(self, val: int) -> bool: Inserts an item val into the set even if it already present. self.indices[val].add(len(self.data)) self.data.append(val) return True def remove(self, val: int) -> bool: Removes one occurrence of an item val from the set if present. if not self.indices[val]: return False # Get an index of the element to remove. remove_idx = self.indices[val].pop() # Move the last element to the spot of the element to remove. last_element = self.data[-1] self.data[remove_idx] = last_element # Update the set of indices for the last element. if self.indices[last_element]: self.indices[last_element].add(remove_idx) self.indices[last_element].discard(len(self.data) - 1) # Remove the last element from the data list. self.data.pop() return True def getRandom(self) -> int: Returns a random element from current set of elements. return random.choice(self.data) def getDuplicates(self) -> list: Returns a list of items that have duplicates in the set. return [key for key, indices in self.indices.items() if len(indices) > 1]"},{"question":"# Question: You are required to implement a function that calculates the square root of a given positive integer (N) using Newton\'s Method. The method should ensure that the result approximates the actual square root within a given precision (P). Write a function `square_root(n: int, epsilon: float = 0.001) -> float` that: 1. Computes the square root of a number (N) such that the absolute difference between the computed value and the real square root is no greater than a given precision (P). 2. Handles edge cases, including (N = 0) which should return 0 immediately. # Input: - `n` (positive integer): The number for which the square root is to be calculated. - `epsilon` (float, optional): The precision for the square root calculation, default is 0.001. # Output: - Returns a float which is the approximated square root of `n` with maximum error `epsilon`. # Constraints: - (1 leq n leq 10^9) - (0 < epsilon < 1) # Examples: 1. `square_root(5, 0.001)` should return a value between 2.235 and 2.237. 2. `square_root(10, 0.0001)` should return a value between 3.1622 and 3.1624. Implement the function considering performance and handle potential edge cases.","solution":"def square_root(n: int, epsilon: float = 0.001) -> float: Computes the square root of a given positive integer n using Newton\'s Method ensuring the result approximates the actual square root within a given precision epsilon. Args: n (int): The number for which the square root is to be calculated. epsilon (float): The precision for the square root calculation. Returns: float: The approximated square root of n. if n == 0: return 0.0 guess = n while abs(guess * guess - n) > epsilon: guess = (guess + n / guess) / 2.0 return guess"},{"question":"Scenario You are given an organizational structure represented as a nested dictionary. Each key corresponds to a department and has a list of employees or sub-departments with associated details. Your task is to write a function to print this structure clearly and hierarchically. Specifications * Write a function `print_organization_structure(org_structure: dict) -> None` that performs the following steps: - For each department (key), print the department name. - For each sub-element in the department: - Print `\\" -> \\"` followed by the sub-element. - If the sub-element is not a string, print an indent followed by the sub-element on a new line. * Use the following constraints: - Keys are unique department names (strings). - Associated elements are either strings or nested dictionaries. Input and Output Formats - **Input**: A nested dictionary `org_structure` representing the organizational structure. - **Output**: Print the formatted structure. Example ```python org_structure = { \\"a\\": [\\"Adam\\", {\\"Book\\": 4}], \\"b\\": [\\"Bill\\", {\\"Computer\\": 5}, {\\"TV\\": 6}, \\"Jill\\", {\\"Sports\\": 1}], \\"c\\": [\\"Bill\\", {\\"Sports\\": 3}], \\"d\\": [\\"Adam\\", {\\"Computer\\": 3}, \\"Quin\\", {\\"Computer\\": 3}], \\"e\\": [\\"Quin\\", {\\"Book\\": 5}, {\\"TV\\": 2}], \\"f\\": [\\"Adam\\", {\\"Computer\\": 7}] } ``` Expected Output: ```plaintext a -> Adam -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` **Note**: Newlines and spacing must match the given format clearly demonstrating the hierarchy.","solution":"def print_organization_structure(org_structure, indent=\\"\\"): for department, elements in org_structure.items(): print(f\\"{indent}{department}\\") for element in elements: if isinstance(element, str): print(f\\"{indent} -> {element}\\") elif isinstance(element, dict): for key, value in element.items(): print(f\\"{indent} -> {key} -> {value}\\") # Test Example Organization Structure if __name__ == \\"__main__\\": org_structure = { \\"a\\": [\\"Adam\\", {\\"Book\\": 4}], \\"b\\": [\\"Bill\\", {\\"Computer\\": 5}, {\\"TV\\": 6}, \\"Jill\\", {\\"Sports\\": 1}], \\"c\\": [\\"Bill\\", {\\"Sports\\": 3}], \\"d\\": [\\"Adam\\", {\\"Computer\\": 3}, \\"Quin\\", {\\"Computer\\": 3}], \\"e\\": [\\"Quin\\", {\\"Book\\": 5}, {\\"TV\\": 2}], \\"f\\": [\\"Adam\\", {\\"Computer\\": 7}] } print_organization_structure(org_structure)"},{"question":"# Scenario You have been hired to build an efficient data storage system for a large application that requires frequent access to user data based on unique user IDs. The proposed solution is to use a hash table to manage user records with separate chaining for collision resolution. # Task Implement a Python function that extends the provided `SeparateChainingHashTable` class to include a method `rehash` which adjusts the table size dynamically when the load factor exceeds a certain threshold. The load factor can be defined as the ratio of the number of entries to the number of buckets. # Specifications - Use separate chaining with linked lists to handle collisions. - Implement a method `rehash` that resizes the hash table, redistributing the keys across a new, larger set of buckets when the load factor exceeds 0.75. - Recalculate hash index positions for all existing keys during resizing. - Maintain average-case O(1) time complexity for `put` and `get` operations. # Method to Implement ```python class SeparateChainingHashTable: # Previous implementation def rehash(self): Resizes the hash table to accommodate more elements and redistributes existing elements. # Your implementation here ``` # Input and Output - **Input**: None for the `rehash` method, although `put`, `get`, and `del_` methods will interact with it indirectly. - **Output**: The hash table should be resized and all elements should be correctly redistributed. # Constraints - Upon resizing, the size of the hash table should be doubled to the next prime number to maintain efficiency. - The `rehash` function should maintain all existing key-value pairs and ensure that lookups and deletions remain correct. Write comprehensive test cases to verify the correctness of your solution, ensuring it handles edge cases such as adding, deleting, and rehashing on both empty and filled states of the hash table.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None class SeparateChainingHashTable: def __init__(self, initial_capacity=11): self.table = [None] * initial_capacity self.size = 0 def _hash(self, key): return hash(key) % len(self.table) def put(self, key, value): if self.size / len(self.table) > 0.75: self.rehash() index = self._hash(key) node = self.table[index] if node is None: self.table[index] = Node(key, value) else: while node: if node.key == key: node.value = value return if node.next is None: break node = node.next node.next = Node(key, value) self.size += 1 def get(self, key): index = self._hash(key) node = self.table[index] while node: if node.key == key: return node.value node = node.next return None def del_(self, key): index = self._hash(key) node = self.table[index] prev = None while node: if node.key == key: if prev is None: self.table[index] = node.next else: prev.next = node.next self.size -= 1 return prev = node node = node.next def rehash(self): def next_prime(n): def is_prime(num): if num < 2: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True while not is_prime(n): n += 1 return n old_table = self.table new_capacity = next_prime(2 * len(old_table)) self.table = [None] * new_capacity self.size = 0 for item in old_table: while item: self.put(item.key, item.value) item = item.next"},{"question":"# Matrix Path Product You have a directed weighted graph represented as an adjacency matrix. Given the adjacency matrix, write a function to find the maximum product of edge weights on any path starting from a given node `u` and ending at another node `v` within a given number of `k` steps. You can represent the adjacency matrix as `A` where `A[i][j]` represents the weight of the directed edge from node `i` to node `j`. If there is no edge from `i` to `j`, `A[i][j]` will be 0. # Function Signature ```python def max_product_path(A: list, u: int, v: int, k: int) -> int: Calculates the maximum product of path weights from node u to node v within k steps. Parameters: - A: The adjacency matrix representing the directed graph. - u: The starting node. - v: The ending node. - k: Maximum number of steps allowed. Returns: - The maximum product of edge weights if a path exists, otherwise returns -1. ``` # Input * `A`: list[list[int]] - An n x n adjacency matrix `A` (0 ≤ n ≤ 100). * `u`: int - Start node (0 ≤ u < n). * `v`: int - End node (0 ≤ v < n). * `k`: int - Maximum number of steps (1 ≤ k ≤ 100). # Output * int - The maximum product of edge weights on any valid path from node `u` to node `v` within `k` steps. # Constraints * The adjacency matrix is sparse; many entries are 0 indicating no direct edge. * If no valid path exists, return -1. * You may assume that for the purpose of this problem, no paths will result in integer overflow. # Example ```python A = [ [0, 2, 3], [0, 0, 4], [0, 0, 0] ] u = 0 v = 2 k = 2 max_product_path(A, u, v, k) ``` **Output**: 8 # Explanation There are two paths from node `0` to node `2`: - `0 -> 1 -> 2`: product = 2 * 4 = 8 - `0 -> 2`: product = 3 (less than 8) Hence, the output is 8. Note: Ensure that your code efficiently handles the production constraints provided in the prompt.","solution":"def max_product_path(A: list, u: int, v: int, k: int) -> int: Calculates the maximum product of path weights from node u to node v within k steps. Parameters: - A: The adjacency matrix representing the directed graph. - u: The starting node. - v: The ending node. - k: Maximum number of steps allowed. Returns: - The maximum product of edge weights if a path exists, otherwise returns -1. n = len(A) # DP Table: dp[node][step] represents the maximum product to reach node with step steps dp = [[-1] * (k + 1) for _ in range(n)] dp[u][0] = 1 # Starting point product is 1 with 0 steps for step in range(1, k + 1): for i in range(n): if dp[i][step - 1] != -1: for j in range(n): if A[i][j] != 0: dp[j][step] = max(dp[j][step], dp[i][step - 1] * A[i][j]) max_product = -1 for step in range(1, k + 1): max_product = max(max_product, dp[v][step]) return max_product if max_product != -1 else -1"},{"question":"Context In a typical singly linked list, deleting a node usually requires access to the list\'s head and a traversal process to find the node and its predecessor. In this problem, however, you\'re provided direct access to the node to be deleted, simplifying the deletion process significantly. Problem Statement Write a function `delete_node(node)` to delete a given node (except the tail node) in a singly linked list. You are only given direct access to that node and not the head of the list. The function should update the current node\'s value to be the same as its next node\'s value and then bypass the next node. Requirements 1. **Input Format**: - A `Node` instance which is part of a singly linked list. 2. **Output Format**: - The linked list should be modified in-place to exclude the given node, effectively deleting it. 3. **Constraints**: - The given node will not be the tail. - The node should be a valid non-null node within an existing singly linked list. Performance Expectations - Time Complexity: O(1) - Space Complexity: O(1) Example Consider the linked list 1 -> 2 -> 3 -> 4. If you are given the node with value 3, the linked list should become 1 -> 2 -> 4 after calling `delete_node(node)`. Testing Here\'s a basic test script to validate your implementation: ```python import unittest class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node): if node is None or node.next is None: raise ValueError node.val = node.next.val node.next = node.next.next class TestSuite(unittest.TestCase): def test_delete_node(self): # make linkedlist 1 -> 2 -> 3 -> 4 head = Node(1) curr = head for i in range(2, 5): curr.next = Node(i) curr = curr.next # node3 = 3 node3 = head.next.next # after delete_node => 1 -> 2 -> 4 delete_node(node3) curr = head self.assertEqual(1, curr.val) # First node should be 1 curr = curr.next self.assertEqual(2, curr.val) # Second node should be 2 curr = curr.next self.assertEqual(4, curr.val) # Third node should be 4 self.assertIsNone(curr.next) # No more nodes after 4 tail = curr self.assertRaises(ValueError, delete_node, tail) self.assertRaises(ValueError, delete_node, tail.next) if __name__ == \'__main__\': unittest.main() ``` Implement the function `delete_node(node)` as described and ensure all tests pass successfully.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node): if node is None or node.next is None: raise ValueError(\\"Cannot delete the given node.\\") node.val = node.next.val node.next = node.next.next"},{"question":"# Objective: Write a function to calculate the minimum depth of a given binary tree and print all node values in pre-order traversal. # Function Signature: ```python def min_depth(root: TreeNode) -> int: pass def print_tree(root: TreeNode) -> None: pass ``` # Input: - A single parameter `root` representing the root node of the binary tree. # Output: - The function `min_depth` should return an integer representing the minimum depth. - The function `print_tree` should print all the values in the binary tree using pre-order traversal. # Example: Suppose the binary tree is ``` 1 / 2 3 4 5 ``` Calling `min_depth` on this tree should return `2`, as the shortest path from the root node to a leaf node is `1 -> 3`. Calling `print_tree` should output: ``` 1 2 4 5 3 ``` # Constraints: - The number of nodes in the tree will not exceed 10^4. - Node values are integers. # Notes: - Ensure all edge cases (e.g., an empty tree, a tree with only one node) are handled. - Aim for an optimal solution in terms of time and space complexity.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_depth(root: TreeNode) -> int: if root is None: return 0 from collections import deque queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if node.left is None and node.right is None: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) def print_tree(root: TreeNode) -> None: def preorder(node): if not node: return print(node.val) preorder(node.left) preorder(node.right) preorder(root)"},{"question":"# Manipulating Bits for Control Flags You are developing a system that uses control flags, represented as a single integer, to efficiently manage various states and permissions in your application. Write a function that performs several operations on these flags using bit manipulation. Tasks: 1. **Activation**: Given an integer `num` representing the current flags, activate (set to 1) the bit at index `i`. 2. **Deactivation**: Given an integer `num` representing the current flags, deactivate (set to 0) the bit at index `i`. 3. **Toggle**: Given an integer `num` representing the current flags, toggle (flip) the bit at index `i`. Each task should be implemented as a separate function. Input Format: - For **activation**: `activate_bit(num: int, i: int) -> int` - `num`: The integer representing the current flags. - `i`: The index of the bit to activate. - For **deactivation**: `deactivate_bit(num: int, i: int) -> int` - `num`: The integer representing the current flags. - `i`: The index of the bit to deactivate. - For **toggle**: `toggle_bit(num: int, i: int) -> int` - `num`: The integer representing the current flags. - `i`: The index of the bit to toggle. Output Format: - Return the modified integer after performing the required bit manipulation. Constraints: - Assume `0 <= i < 32` for simplicity and to fit within typical 32-bit integer representation. Examples: 1. **Activation**: ```python >>> activate_bit(5, 1) 7 ``` (In binary: 0101 becomes 0111 as the bit at index 1 is set to 1) 2. **Deactivation**: ```python >>> deactivate_bit(5, 2) 1 ``` (In binary: 0101 becomes 0001 as the bit at index 2 is set to 0) 3. **Toggle**: ```python >>> toggle_bit(5, 0) 4 ``` (In binary: 0101 becomes 0100 as the bit at index 0 is toggled from 1 to 0)","solution":"def activate_bit(num, i): Set the bit at index i to 1. return num | (1 << i) def deactivate_bit(num, i): Set the bit at index i to 0. return num & ~(1 << i) def toggle_bit(num, i): Toggle the bit at index i. return num ^ (1 << i)"},{"question":"**Problem Statement**: Given a stream of characters representing compressed data (using Run-Length Encoding), write a function to decompress it to its original form. Also, write a function to compress a given input stream of characters using Run-Length Encoding. # Function Specifications: * `encode_rle(input: str) -> str` - **Input**: A string representing the data to be compressed. - **Output**: A string representing the run-length encoded data. * `decode_rle(input: str) -> str` - **Input**: A string representing the run-length encoded data. - **Output**: The original, uncompressed string. # Constraints: * The input strings contain only printable ASCII characters (no control characters). * Maximum length of input `input` is 10^5. * Output strings should be returned in a case-insensitive manner if applicable. # Example: ```python assert encode_rle(\\"aaabbbcccaaa\\") == \\"3a3b3c3a\\" assert decode_rle(\\"3a3b3c3a\\") == \\"aaabbbcccaaa\\" assert encode_rle(\\"\\") == \\"\\" assert decode_rle(\\"\\") == \\"\\" assert encode_rle(\\"a\\") == \\"1a\\" assert decode_rle(\\"1a\\") == \\"a\\" ``` Note: Ensure that your solution handles edge cases, such as empty strings or strings without any consecutive repeated characters. Additionally, take care of performance, keeping time and space complexity in mind.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded.append(f\\"{count}{input[i-1]}\\") count = 1 encoded.append(f\\"{count}{input[-1]}\\") # append last set return \'\'.join(encoded) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) # handle multi-digit numbers else: decoded.append(char * count) count = 0 return \'\'.join(decoded)"},{"question":"# Queue Implementation and Performance Testing You are tasked with implementing the Queue Abstract Data Type (ADT) using a circular array. Given your understanding of how we previously implemented a queue using a dynamic array and linked list, we want to explore a slightly different method which should optimally use space and handle frequent enqueue and dequeue operations more efficiently. # Objectives 1. Implement `CircularArrayQueue` based on the `AbstractQueue` abstract class. 2. Write a performance test to compare the performance of `CircucularArrayQueue` against the provided `ArrayQueue` and `LinkedListQueue`. # Requirements Class Definition Implement a class `CircularArrayQueue` such that: * **Constructor Parameters**: Initialize with a fixed capacity (default 10). * **Methods**: - `enqueue(value)`: Adds a new item to the rear of the queue. - `dequeue()`: Removes and returns the front item from the queue. - `is_empty()`: Returns whether the queue is empty. - `size()`: Returns the number of items in the queue. - `peek()`: Returns the front element without modifying the queue. - `__iter__()`: Iterates through all elements of the queue from front to rear. Performance Test Write a function `performance_test()` to compare the execution time for enqueuing and dequeuing a large number of elements (e.g., 1,000,000) for `CircularArrayQueue`, `ArrayQueue`, and `LinkedListQueue`. Constraints and Assumptions * Handle edge cases, such as enqueueing to a full queue and dequeuing from an empty queue. * Make use of the circular property to efficiently manage the array space. # Input and Output * **Input**: - `enqueue(value)`: Accepts any integer value. - `dequeue()`: Returns dequeued integer value. - `is_empty()`, `size()`, and `peek()`: boolean or integer values as described above. * **Output**: - `enqueue()`, `dequeue()`, `is_empty()`, `size()`, and `peek()`: respective operations as described. - `performance_test()`: Prints performance measurements for each queue implementation. # Example ```python # Initialize circular queue with capacity 5 circular_queue = CircularArrayQueue(5) circular_queue.enqueue(10) circular_queue.enqueue(20) circular_queue.enqueue(30) print(circular_queue.dequeue()) # Output: 10 print(circular_queue.peek()) # Output: 20 print(circular_queue.is_empty()) # Output: False print(circular_queue.size()) # Output: 2 # Performance test performance_test() ```","solution":"class CircularArrayQueue: def __init__(self, capacity=10): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.count = 0 def enqueue(self, value): if self.size() == self.capacity: raise OverflowError(\\"Queue is full\\") self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.count += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.count -= 1 return value def is_empty(self): return self.size() == 0 def size(self): return self.count def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def __iter__(self): idx = self.front num_elements = self.size() for _ in range(num_elements): yield self.queue[idx] idx = (idx + 1) % self.capacity"},{"question":"# Question **Context**: Implement a function that sorts a list of integers using an optimized version of Shell Sort with a specific gap sequence proposed by **Donald Knuth**. **Problem Statement**: Write a function `optimized_shell_sort(arr)` that sorts an array of integers in ascending order using the optimized Shell Sort algorithm with Knuth\'s gap sequence. The Knuth sequence is defined as: `h = 3*h + 1` starting with `h = 1` until `h` is less than one-third of the array size. **Function Signature**: ```python def optimized_shell_sort(arr: List[int]) -> List[int]: pass ``` **Input**: * A list of integers `arr` where `1 <= len(arr) <= 1000`. **Output**: * The sorted list of integers. **Constraints**: * The algorithm should maintain its in-place characteristic, not consuming additional memory beyond O(1) for temporary variables. * Solution should efficiently handle lists with up to 1000 elements. # Examples ```python # Example 1 input_arr = [34, 8, 64, 51, 32, 21] print(optimized_shell_sort(input_arr)) # Output: [8, 21, 32, 34, 51, 64] # Example 2 input_arr = [9, 1, 7, 4, 3] print(optimized_shell_sort(input_arr)) # Output: [1, 3, 4, 7, 9] ``` # Notes * Remember to implement the gap sequence according to Knuth\'s method. * Edge cases such as empty array or array with single element should return the array as is.","solution":"def optimized_shell_sort(arr): Sorts an array of integers in ascending order using the optimized Shell Sort algorithm with Knuth\'s gap sequence. n = len(arr) h = 1 # Initialize Knuth\'s sequence while h < n // 3: h = 3 * h + 1 # Perform the shell sort while h >= 1: for i in range(h, n): j = i while j >= h and arr[j] < arr[j - h]: arr[j], arr[j - h] = arr[j - h], arr[j] j -= h h //= 3 return arr"},{"question":"# Stooge Sort Implementation and Analysis **Scenario**: You have been presented with a list of patient IDs that need to be sorted chronologically based on their timestamps of record creation. The list of IDs might contain duplicates, and the sorting needs to maintain the sequence of identical records (i.e., it should be stable). Unfortunately, due to constraints on the environment, you only have Stooge Sort available, which is known for its inefficiency but is the only sort allowed by the environment. Your task is to implement the Stooge Sort algorithm based on the provided template and analyze its behavior based on different input array characteristics. **Requirements**: 1. Implement the Stooge Sort algorithm. 2. Analyze the running time for input arrays of size `n` ranging from 1 to 15. 3. Identify any edge cases and how the algorithm handles them. 4. Determine the efficiency of Stooge Sort in terms of stability when sorting IDs with duplicates. **Input/Output Format**: - Input: A list, `array`, of integers representing patient IDs. - Output: A new list, `sorted_array`, sorted in ascending order using Stooge Sort. **Constraints**: - The length of the array `1 ≤ len(array) ≤ 15`. - Each element in `array` is an integer, with possible duplicates. **Performance Requirements**: - Although Stooge Sort is very inefficient, your implementation should correctly sort arrays up to the specified length. **Implementation Template**: ```python def stoogesort(arr, l, h): if l >= h: return # If first element is smaller than last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array if h - l + 1 > 2: t = (int)((h - l + 1) / 3) # Recursively sort first 2/3 elements stoogesort(arr, l, h - t) # Recursively sort last 2/3 elements stoogesort(arr, l + t, h) # Recursively sort first 2/3 elements again to confirm stoogesort(arr, l, h - t) def sort_patient_ids(patient_ids): n = len(patient_ids) stoogesort(patient_ids, 0, n - 1) return patient_ids # Example for testing: patient_ids = [10, 30, 20, 40, 30, 50, 30, 60] sorted_patient_ids = sort_patient_ids(patient_ids) print(sorted_patient_ids) ``` # Task: 1. Implement the `stoogesort` function above. 2. Include a function `sort_patient_ids` that utilizes `stoogesort` to sort the patient IDs. 3. Analyze and report the performance of the implemented algorithm on inputs of varying lengths. **Deliverables**: - The implemented Stooge Sort code. - The performance analysis report. - Observations on the stability and efficiency of the algorithm.","solution":"def stoogesort(arr, l, h): if l >= h: return # If first element is greater than last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort first 2/3 elements stoogesort(arr, l, h - t) # Recursively sort last 2/3 elements stoogesort(arr, l + t, h) # Recursively sort first 2/3 elements again to confirm stoogesort(arr, l, h - t) def sort_patient_ids(patient_ids): n = len(patient_ids) stoogesort(patient_ids, 0, n - 1) return patient_ids # Example for testing: patient_ids = [10, 30, 20, 40, 30, 50, 30, 60] sorted_patient_ids = sort_patient_ids(patient_ids) print(sorted_patient_ids)"},{"question":"# Unique Binary Search Trees In this problem, you are required to implement a function to determine the number of structurally unique Binary Search Trees (BSTs) that can be constructed with exactly `n` distinct values, where the values range from `1` to `n`. # Input An integer `n`, where `1 <= n <= 19`. # Output An integer representing the number of structurally unique BSTs that can be constructed with `n` distinct values. # Constraints * `1 <= n <= 19` # Example Example 1 * Input: `n = 3` * Output: `5` Explanation: There are 5 unique BSTs possible with `n = 3`: ``` 1 3 3 2 1 / / / 3 2 1 1 3 2 / / 2 1 2 3 ``` Example 2 * Input: `n = 1` * Output: `1` Explanation: There is only 1 unique BST possible with `n = 1`: ``` 1 ``` # Instructions Implement the function `num_trees(n)` which takes an integer `n` and returns the number of structurally unique BSTs that can be formed with `n` distinct values.","solution":"def num_trees(n): Returns the number of structurally unique BSTs that can be constructed with exactly n distinct values. if n == 0 or n == 1: return 1 # Dynamic Programming to store the results of distinct BSTs count for each number of nodes. dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for nodes in range(2, n + 1): for root in range(1, nodes + 1): left = dp[root - 1] right = dp[nodes - root] dp[nodes] += left * right return dp[n]"},{"question":"# Scenario: You are working on a software project that involves data stored in a linked list. An important feature of this project is to dynamically filter out subsets of the list based on user-specified indices. Your task is to implement a function that removes a range of elements from the linked list, inclusive of the start and end indices. # Problem Statement: Write a function `remove_range` that accepts a linked list head node, a starting index, and an ending index as parameters. Your function should remove the nodes in the linked list from the starting index up to and including the ending index. # Function Signature: ```python def remove_range(head: ListNode, start: int, end: int) -> ListNode: ``` # Input: - `head` (ListNode): The head node of the singly linked list. - `start` (int): The starting index of the range to remove. - `end` (int): The ending index of the range to remove. # Output: - Returns: `ListNode` (the head node of the modified list). # Constraints: - 0 <= start <= end < size of list (You can assume the input constraints are always valid). # Example: ```python # Define the ListNode class class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next # Example usage # List: [8, 13, 17, 4, 9, 12, 98, 41, 7, 23, 0, 92] list_head = ListNode(8, ListNode(13, ListNode(17, ListNode(4, ListNode(9, ListNode(12, ListNode(98, ListNode(41, ListNode(7, ListNode(23, ListNode(0, ListNode(92)))))))))))) start, end = 3, 8 new_head = remove_range(list_head, start, end) # The new list should be: [8, 13, 17, 23, 0, 92] ``` # Notes: - Consider how to handle rearranging pointers effectively for varying sizes of the list. - Ensure your solution efficiently traverses and modifies the list in place.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_range(head: ListNode, start: int, end: int) -> ListNode: dummy = ListNode(0) dummy.next = head prev = dummy # Step through the list to find the starting point (start-1) for removal for _ in range(start): prev = prev.next # Define the node at the end for removal curr = prev.next for _ in range(end - start + 1): curr = curr.next # Link previous part to the next part, skipping the range prev.next = curr return dummy.next"},{"question":"Context Comb Sort is an improvement over Bubble Sort by eliminating small values at the end of the list that greatly slows down Bubble Sort. The idea is to eliminate turtles, or small values near the end of the list, by making gap comparisons larger and reducing them gradually. Task Design and implement a function `custom_comb_sort()` that sorts an array of integers. Alongside sorting, the function should also collect and return diagnostics information that includes the number of swaps performed and the number of iterations for each gap. Function Signature ```python def custom_comb_sort(arr: List[int]) -> Tuple[List[int], int, Dict[int, int]]: # Your code here ``` Input & Output - **Input**: A list of integers `arr` (1 <= len(arr) <= 1000; -10^6 <= arr[i] <= 10^6). - **Output**: A tuple consisting of: 1. The sorted list. 2. The total number of swaps performed. 3. A dictionary mapping each gap value to the number of iterations it took to completely sort with that gap. Example ```python array = [13, 24, 0, -4, 7, 8, 9] sorted_array, total_swaps, gap_iterations = custom_comb_sort(array) # Expected Output: ([-4, 0, 7, 8, 9, 13, 24], <swaps_count>, {<gap1>: <count1>, <gap2>: <count2>, ...}) ``` Constraints - Your implementation should use the Comb Sort algorithm with a shrink factor of 1.3. - Optimize for readability, correct edge case handling, and in-place operations. - Avoid using built-in sorting functions or libraries.","solution":"from typing import List, Tuple, Dict def custom_comb_sort(arr: List[int]) -> Tuple[List[int], int, Dict[int, int]]: def get_next_gap(gap): gap = int(gap / 1.3) if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True total_swaps = 0 gap_iterations = {} while gap != 1 or swapped: gap = get_next_gap(gap) if gap not in gap_iterations: gap_iterations[gap] = 0 gap_iterations[gap] += 1 swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True total_swaps += 1 return arr, total_swaps, gap_iterations"},{"question":"# Question Problem Statement Given a matrix of `m` x `n` elements (m rows, n columns), write a function `spiral_traversal(matrix)` that returns all elements of the matrix in spiral order. Context You are working on a project involving image processing, and you need a way to traverse a matrix representing pixel values in a specific spiral pattern starting from the top-left corner. Implementation Details * Implement the function `spiral_traversal(matrix)` that: - Accepts a 2D list `matrix`. - Returns a list of elements in spiral order starting from the top-left corner. Example Given the following matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Your function should return: ``` [1, 2, 3, 6, 9, 8, 7, 4, 5] ``` Constraints 1. The dimensions of the matrix will not exceed 100x100. 2. The matrix may contain negative and positive integers. 3. Ensure the function handles the edge cases where the matrix may be empty or have varying row lengths. Edge Cases to Consider * `[]`: Empty matrix * `[[1]]`: Matrix with a single element * `[[1, 2], [3, 4]]`: Matrix with even number of rows and columns * `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]`: Non-empty square matrix * `[[1], [2], [3]]`: Single column matrix * `[[1, 2, 3]]`: Single row matrix Function Signature ```python def spiral_traversal(matrix): # Your code here ```","solution":"def spiral_traversal(matrix): Given an m x n matrix, return all elements of the matrix in spiral order. :param matrix: List[List[int]] :return: List[int] # Check for an empty matrix if not matrix or not matrix[0]: return [] result = [] m, n = len(matrix), len(matrix[0]) # dimensions of the matrix top, bottom, left, right = 0, m - 1, 0, n - 1 # boundaries while top <= bottom and left <= right: # Traverse from left to right for col in range(left, right + 1): result.append(matrix[top][col]) top += 1 # Traverse downwards for row in range(top, bottom + 1): result.append(matrix[row][right]) right -= 1 # Make sure we are now on a different row if top <= bottom: # Traverse from right to left for col in range(right, left - 1, -1): result.append(matrix[bottom][col]) bottom -= 1 # Make sure we are now on a different column if left <= right: # Traverse upwards for row in range(bottom, top - 1, -1): result.append(matrix[row][left]) left += 1 return result"},{"question":"# Question You are provided with a list of words, and you need to return those words that can be typed using letters from only one row of an American keyboard. The American keyboard is divided into three rows: 1. Top row: \\"qwertyuiop\\" 2. Middle row: \\"asdfghjkl\\" 3. Bottom row: \\"zxcvbnm\\" # Requirements Implement the function `find_words_from_single_row(words)` which takes a list of words as input and returns a list of words that can be typed using one row of the keyboard. # Input - `words`: A list of strings containing lowercase or mixed case words (1 <= len(words) <= 100, each word is 1-12 characters long). # Output - A list of strings containing the words that can be typed using only one row of the keyboard. # Constraints 1. Any character not in the English alphabet should be considered invalid input and should not appear in the words. 2. Consider case insensitivity— \\"Hello\\" and \\"hello\\" should be treated the same. # Performance - Ensure the solution runs efficiently for the given constraints. # Scenario Imagine a scenario where you are developing an application for a specialized keyboard designed for typists who use only one row of keys at a time. Your job is to add a feature to filter words that can be typed using a single row. For instance, given the words [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"], only \\"Alaska\\" and \\"Dad\\" can be typed using one row. # Example ```python Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] Output: [\\"Alaska\\", \\"Dad\\"] Input: [\\"Type\\", \\"Sheet\\", \\"Quiz\\", \\"Root\\"] Output: [\\"Type\\", \\"Root\\"] ``` # Function Signature ```python def find_words_from_single_row(words: List[str]) -> List[str]: # your code here ```","solution":"def find_words_from_single_row(words): This function takes a list of words and returns a list of words that can be typed using only one row of an American keyboard. top_row = set(\\"qwertyuiop\\") middle_row = set(\\"asdfghjkl\\") bottom_row = set(\\"zxcvbnm\\") result = [] for word in words: lower_word = word.lower() if all(char in top_row for char in lower_word): result.append(word) elif all(char in middle_row for char in lower_word): result.append(word) elif all(char in bottom_row for char in lower_word): result.append(word) return result"},{"question":"Problem Statement You are a security consultant and need to implement a function that calculates the modular exponentiation, which is an essential part of many cryptographic algorithms. # Task Write a Python function `mod_exp(base: int, exponent: int, mod: int) -> int` that computes `(base ^ exponent) % mod`. # Input * `base` (1 <= base <= 10^9): The base number. * `exponent` (0 <= exponent <= 10^9): The exponent number. * `mod` (1 <= mod <= 10^9): The modulus number. # Output * Return an integer representing the result of the computation. # Constraints * The computation must be efficient with respect to time and space complexities. * Handle edge cases correctly, such as when the exponent is zero. # Example ```python print(mod_exp(2, 3, 5)) # Expected output: 3 ``` *Explanation*: (2^3 = 8). (8 % 5 = 3). ```python print(mod_exp(10, 0, 7)) # Expected output: 1 ``` *Explanation*: (10^0 = 1). (1 % 7 = 1). # Notes * If you handle negative exponents (optional enhancement), raise a meaningful exception (e.g., `ValueError(\\"Exponent must be non-negative.\\")`). * Edge cases include large values of `base` and `exponent`, and the smallest possible non-zero value for `mod`.","solution":"def mod_exp(base: int, exponent: int, mod: int) -> int: Computes (base ^ exponent) % mod using an efficient modular exponentiation algorithm. :param base: The base integer (1 <= base <= 10^9) :param exponent: The exponent integer (0 <= exponent <= 10^9) :param mod: The modulus integer (1 <= mod <= 10^9) :return: The result of (base ^ exponent) % mod if exponent < 0: raise ValueError(\\"Exponent must be non-negative.\\") result = 1 base = base % mod while exponent > 0: if (exponent % 2) == 1: result = (result * base) % mod exponent = exponent >> 1 base = (base * base) % mod return result"},{"question":"# Integer-Byte Conversion: Enhanced Implementation and Validation Objective Implement enhanced versions of integer-to-bytes and bytes-to-integer conversion functions for both big-endian and little-endian formats. Ensure your implementations are robust against edge cases and validate your solutions accordingly. Instructions 1. **Function Definitions**: * Implement `enhanced_int_to_bytes_big_endian(num: int) -> bytes` * Implement `enhanced_int_to_bytes_little_endian(num: int) -> bytes` * Implement `enhanced_bytes_big_endian_to_int(bytestr: bytes) -> int` * Implement `enhanced_bytes_little_endian_to_int(bytestr: bytes) -> int` 2. **Input Formats**: * `num`: A non-negative integer that may be as large as the platform\'s integer size allows. * `bytestr`: A byte array representing the integer in either big-endian or little-endian format. 3. **Output Formats**: * For `int_to_bytes` functions: Return a byte array corresponding to the integer. * For `bytes_to_int` functions: Return the integer that the byte array represents. 4. **Constraints**: * Ensure your functions handle zero correctly. * Interpret an empty byte array as an integer zero. * Handle large integers consistently within the platform\'s constraints. 5. **Performance Considerations**: * The algorithms should be linear in the number of bytes for both time and space. Avoid unnecessary data structure operations that lead to inefficiencies. 6. **Examples**: ```python assert enhanced_int_to_bytes_big_endian(0) == b\'x00\' assert enhanced_int_to_bytes_little_endian(0) == b\'x00\' assert enhanced_bytes_big_endian_to_int(b\'\') == 0 assert enhanced_bytes_little_endian_to_int(b\'\') == 0 assert enhanced_int_to_bytes_big_endian(305419896) == b\'x12x34x56x78\' assert enhanced_int_to_bytes_little_endian(305419896) == b\'x78x56x34x12\' assert enhanced_bytes_big_endian_to_int(b\'x12x34x56x78\') == 305419896 assert enhanced_bytes_little_endian_to_int(b\'x78x56x34x12\') == 305419896 ``` Performance Requirements Ensure the algorithms remain efficient for large integers and validate properly against edge cases and potential input errors.","solution":"def enhanced_int_to_bytes_big_endian(num): Converts an integer to its byte representation in big-endian format. if num == 0: return b\'x00\' return num.to_bytes((num.bit_length() + 7) // 8, \'big\') def enhanced_int_to_bytes_little_endian(num): Converts an integer to its byte representation in little-endian format. if num == 0: return b\'x00\' return num.to_bytes((num.bit_length() + 7) // 8, \'little\') def enhanced_bytes_big_endian_to_int(bytestr): Converts a byte array in big-endian format to its integer representation. if bytestr == b\'\': return 0 return int.from_bytes(bytestr, \'big\') def enhanced_bytes_little_endian_to_int(bytestr): Converts a byte array in little-endian format to its integer representation. if bytestr == b\'\': return 0 return int.from_bytes(bytestr, \'little\')"},{"question":"# Scenario You are given the task of determining whether one binary tree is a subtree of another. A subtree is defined as a node in the main tree along with all of its descendants. # Problem Statement Write a function `is_subtree(s: TreeNode, t: TreeNode) -> bool` that determines whether tree `t` is a subtree of tree `s`. # Expected Input and Output * **Input**: * `s` (`TreeNode`): The root node of the primary tree. * `t` (`TreeNode`): The root node of the candidate subtree. * **Output**: * `(bool)`: `True` if `t` is a subtree of `s`, `False` otherwise. # Constraints * The number of nodes in both trees will not exceed `10^4`. * Node values are integers and can be negative. # Performance Requirements * The solution should aim for an average-case scenario with a time complexity of O(m * n) or better where `m` is the number of nodes in `s` and `n` is the number of nodes in `t`. * Space complexity should ideally be O(max(m, n)). # Example Example 1: ``` Given s: 3 / 4 5 / 1 2 Given t: 4 / 1 2 ``` Output: `True` (t is a subtree of s). Example 2: ``` Given s: 3 / 4 5 / 1 2 / 0 Given t: 4 / 1 2 ``` Output: `False` (t is not a subtree of s due to an extra node). # Function Signature ```python # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None def is_subtree(s: TreeNode, t: TreeNode) -> bool: pass ``` Implement the above function `is_subtree` to complete the task.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_subtree(s: TreeNode, t: TreeNode) -> bool: if not t: return True if not s: return False if are_identical(s, t): return True return is_subtree(s.left, t) or is_subtree(s.right, t) def are_identical(s: TreeNode, t: TreeNode) -> bool: if not s and not t: return True if not s or not t: return False return s.val == t.val and are_identical(s.left, t.left) and are_identical(s.right, t.right)"}]'),S={name:"App",components:{PoemCard:E},data(){return{searchQuery:"",visibleCount:4,poemsData:O,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},z={class:"card-container"},L={key:0,class:"empty-state"},F=["disabled"],R={key:0},Y={key:1};function P(r,e,l,p,s,a){const f=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",z,[(n(!0),i(b,null,v(a.displayedPoems,(o,m)=>(n(),w(f,{key:m,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",L,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,F)):u("",!0)])}const j=c(S,[["render",P],["__scopeId","data-v-b5358fd6"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/56.md","filePath":"drive/56.md"}'),B={name:"drive/56.md"},H=Object.assign(B,{setup(r){return(e,l)=>(n(),i("div",null,[x(j)]))}});export{M as __pageData,H as default};
